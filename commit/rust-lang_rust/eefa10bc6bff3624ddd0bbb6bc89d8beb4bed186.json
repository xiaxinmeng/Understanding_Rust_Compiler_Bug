{"sha": "eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlZmExMGJjNmJmZjM2MjRkZGQwYmJiNmJjODlkOGJlYjRiZWQxODY=", "commit": {"author": {"name": "Mikhail Rakhmanov", "email": "rakhmanov.m@gmail.com", "date": "2020-06-03T18:10:54Z"}, "committer": {"name": "Mikhail Rakhmanov", "email": "rakhmanov.m@gmail.com", "date": "2020-06-03T18:10:54Z"}, "message": "Merge branch 'master' into assists_extract_enum", "tree": {"sha": "15c38c2993c52f4065d338090ca9185cc1fcd3da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15c38c2993c52f4065d338090ca9185cc1fcd3da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "html_url": "https://github.com/rust-lang/rust/commit/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/comments", "author": {"login": "mcrakhman", "id": 16068868, "node_id": "MDQ6VXNlcjE2MDY4ODY4", "avatar_url": "https://avatars.githubusercontent.com/u/16068868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcrakhman", "html_url": "https://github.com/mcrakhman", "followers_url": "https://api.github.com/users/mcrakhman/followers", "following_url": "https://api.github.com/users/mcrakhman/following{/other_user}", "gists_url": "https://api.github.com/users/mcrakhman/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcrakhman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcrakhman/subscriptions", "organizations_url": "https://api.github.com/users/mcrakhman/orgs", "repos_url": "https://api.github.com/users/mcrakhman/repos", "events_url": "https://api.github.com/users/mcrakhman/events{/privacy}", "received_events_url": "https://api.github.com/users/mcrakhman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcrakhman", "id": 16068868, "node_id": "MDQ6VXNlcjE2MDY4ODY4", "avatar_url": "https://avatars.githubusercontent.com/u/16068868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcrakhman", "html_url": "https://github.com/mcrakhman", "followers_url": "https://api.github.com/users/mcrakhman/followers", "following_url": "https://api.github.com/users/mcrakhman/following{/other_user}", "gists_url": "https://api.github.com/users/mcrakhman/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcrakhman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcrakhman/subscriptions", "organizations_url": "https://api.github.com/users/mcrakhman/orgs", "repos_url": "https://api.github.com/users/mcrakhman/repos", "events_url": "https://api.github.com/users/mcrakhman/events{/privacy}", "received_events_url": "https://api.github.com/users/mcrakhman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e", "html_url": "https://github.com/rust-lang/rust/commit/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e"}, {"sha": "794f6da821c5d6e2490b996baffe162e4753262d", "url": "https://api.github.com/repos/rust-lang/rust/commits/794f6da821c5d6e2490b996baffe162e4753262d", "html_url": "https://github.com/rust-lang/rust/commit/794f6da821c5d6e2490b996baffe162e4753262d"}], "stats": {"total": 10583, "additions": 6904, "deletions": 3679}, "files": [{"sha": "b499cd0fd837444b20d4651c0bad60364ea910a0", "filename": ".github/actions/github-release/main.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/.github%2Factions%2Fgithub-release%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/.github%2Factions%2Fgithub-release%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Factions%2Fgithub-release%2Fmain.js?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -16,7 +16,7 @@ async function runOnce() {\n   const slug = process.env.GITHUB_REPOSITORY;\n   const owner = slug.split('/')[0];\n   const repo = slug.split('/')[1];\n-  const sha = process.env.GITHUB_SHA;\n+  const sha = process.env.HEAD_SHA;\n \n   core.info(`files: ${files}`);\n   core.info(`name: ${name}`);"}, {"sha": "ed9191c49c374e885feea4887fa33420444b902b", "filename": ".github/workflows/ci.yaml", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/.github%2Fworkflows%2Fci.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/.github%2Fworkflows%2Fci.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yaml?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -97,7 +97,13 @@ jobs:\n \n   typescript:\n     name: TypeScript\n-    runs-on: ubuntu-latest\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        os: [ubuntu-latest, windows-latest, macos-latest]\n+\n+    runs-on: ${{ matrix.os }}\n+    \n     steps:\n     - name: Checkout repository\n       uses: actions/checkout@v2\n@@ -111,10 +117,19 @@ jobs:\n       working-directory: ./editors/code\n \n     - run: npm audit || { sleep 10 && npm audit; } || { sleep 30 && npm audit; }\n+      if: runner.os == 'Linux'\n       working-directory: ./editors/code\n \n     - run: npm run lint\n       working-directory: ./editors/code\n \n+    - name: Run vscode tests\n+      uses: GabrielBB/xvfb-action@v1.2\n+      env:\n+        VSCODE_CLI: 1\n+      with:\n+        run: npm --prefix ./editors/code test\n+        # working-directory: ./editors/code  # does not work: https://github.com/GabrielBB/xvfb-action/issues/8\n+\n     - run: npm run package --scripts-prepend-node-path\n       working-directory: ./editors/code"}, {"sha": "1ae8ed1b63ef7ab8cc819c9fdbf5e2be759f561e", "filename": ".github/workflows/release.yaml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/.github%2Fworkflows%2Frelease.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/.github%2Fworkflows%2Frelease.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Frelease.yaml?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -6,7 +6,7 @@ on:\n   push:\n     branches:\n     - release\n-    - nightly\n+    - trigger-nightly\n \n env:\n   CARGO_INCREMENTAL: 0\n@@ -88,6 +88,9 @@ jobs:\n     - name: Checkout repository\n       uses: actions/checkout@v2\n \n+    - run: echo \"::set-env name=HEAD_SHA::$(git rev-parse HEAD)\"\n+    - run: 'echo \"HEAD_SHA: $HEAD_SHA\"'\n+\n     - uses: actions/download-artifact@v1\n       with:\n         name: dist-macos-latest"}, {"sha": "aef0fac3397fdf8b3549df237953e0b69522d0ab", "filename": ".gitignore", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -7,4 +7,6 @@ crates/*/target\n *.log\n *.iml\n .vscode/settings.json\n-cargo-timing*.html\n+*.html\n+generated_assists.adoc\n+generated_features.adoc"}, {"sha": "8ca27d878363af3de245aeb5b45648abf213a6d7", "filename": ".vscode/launch.json", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/.vscode%2Flaunch.json", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/.vscode%2Flaunch.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.vscode%2Flaunch.json?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -70,6 +70,28 @@\n         \"__RA_LSP_SERVER_DEBUG\": \"${workspaceFolder}/target/release/rust-analyzer\"\n       }\n     },\n+    {\n+      // Used for testing the extension with a local build of the LSP server (in `target/release`)\n+      // with all other extendions loaded.\n+      \"name\": \"Run With Extensions\",\n+      \"type\": \"extensionHost\",\n+      \"request\": \"launch\",\n+      \"runtimeExecutable\": \"${execPath}\",\n+      \"args\": [\n+        \"--disable-extension\", \"matklad.rust-analyzer\",\n+        \"--extensionDevelopmentPath=${workspaceFolder}/editors/code\"\n+      ],\n+      \"outFiles\": [\n+        \"${workspaceFolder}/editors/code/out/**/*.js\"\n+      ],\n+      \"preLaunchTask\": \"Build Server (Release) and Extension\",\n+      \"skipFiles\": [\n+        \"<node_internals>/**/*.js\"\n+      ],\n+      \"env\": {\n+        \"__RA_LSP_SERVER_DEBUG\": \"${workspaceFolder}/target/release/rust-analyzer\"\n+      }\n+    },\n     {\n       // Used to attach LLDB to a running LSP server.\n       // NOTE: Might require root permissions. For this run:\n@@ -87,5 +109,17 @@\n         \"rust\"\n       ]\n     },\n+    {\n+      \"name\": \"Run Unit Tests\",\n+      \"type\": \"extensionHost\",\n+      \"request\": \"launch\",\n+      \"runtimeExecutable\": \"${execPath}\",\n+      \"args\": [\n+          \"--extensionDevelopmentPath=${workspaceFolder}/editors/code\",\n+          \"--extensionTestsPath=${workspaceFolder}/editors/code/out/tests/unit\" ],\n+      \"sourceMaps\": true,\n+      \"outFiles\": [ \"${workspaceFolder}/editors/code/out/tests/unit/**/*.js\" ],\n+      \"preLaunchTask\": \"Pretest\"\n+    }\n   ]\n }"}, {"sha": "a25dff19e4155d6081665ae3636d609b6bc80863", "filename": ".vscode/tasks.json", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/.vscode%2Ftasks.json", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/.vscode%2Ftasks.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.vscode%2Ftasks.json?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -40,6 +40,18 @@\n       \"command\": \"cargo build --release --package rust-analyzer\",\n       \"problemMatcher\": \"$rustc\"\n     },\n+    {\n+      \"label\": \"Pretest\",\n+      \"group\": \"build\",\n+      \"isBackground\": false,\n+      \"type\": \"npm\",\n+      \"script\": \"pretest\",\n+      \"path\": \"editors/code/\",\n+      \"problemMatcher\": {\n+        \"base\": \"$tsc\",\n+        \"fileLocation\": [\"relative\", \"${workspaceFolder}/editors/code/\"]\n+      }\n+    },\n \n     {\n       \"label\": \"Build Server and Extension\","}, {"sha": "5f88ad0c4db59cf12ce6f253ecf05a5583c10c37", "filename": "Cargo.lock", "status": "modified", "additions": 52, "deletions": 66, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -101,9 +101,9 @@ dependencies = [\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.53\"\n+version = \"1.0.54\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"404b1fe4f65288577753b17e3b36a04596ee784493ec249bf81c7f2d2acd751c\"\n+checksum = \"7bbb73db36c1246e9034e307d0fba23f9a2e251faa47ade70c1bd252220c8311\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -114,7 +114,7 @@ checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n [[package]]\n name = \"chalk-derive\"\n version = \"0.10.1-dev\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=eaab84b394007d1bed15f5470409a6ea02900a96#eaab84b394007d1bed15f5470409a6ea02900a96\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=329b7f3fdd2431ed6f6778cde53f22374c7d094c#329b7f3fdd2431ed6f6778cde53f22374c7d094c\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -125,51 +125,30 @@ dependencies = [\n [[package]]\n name = \"chalk-engine\"\n version = \"0.10.1-dev\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=eaab84b394007d1bed15f5470409a6ea02900a96#eaab84b394007d1bed15f5470409a6ea02900a96\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=329b7f3fdd2431ed6f6778cde53f22374c7d094c#329b7f3fdd2431ed6f6778cde53f22374c7d094c\"\n dependencies = [\n- \"chalk-macros\",\n+ \"chalk-derive\",\n+ \"chalk-ir\",\n  \"rustc-hash\",\n ]\n \n [[package]]\n name = \"chalk-ir\"\n version = \"0.10.1-dev\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=eaab84b394007d1bed15f5470409a6ea02900a96#eaab84b394007d1bed15f5470409a6ea02900a96\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=329b7f3fdd2431ed6f6778cde53f22374c7d094c#329b7f3fdd2431ed6f6778cde53f22374c7d094c\"\n dependencies = [\n  \"chalk-derive\",\n- \"chalk-engine\",\n- \"chalk-macros\",\n-]\n-\n-[[package]]\n-name = \"chalk-macros\"\n-version = \"0.10.1-dev\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=eaab84b394007d1bed15f5470409a6ea02900a96#eaab84b394007d1bed15f5470409a6ea02900a96\"\n-dependencies = [\n  \"lazy_static\",\n ]\n \n-[[package]]\n-name = \"chalk-rust-ir\"\n-version = \"0.10.1-dev\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=eaab84b394007d1bed15f5470409a6ea02900a96#eaab84b394007d1bed15f5470409a6ea02900a96\"\n-dependencies = [\n- \"chalk-derive\",\n- \"chalk-engine\",\n- \"chalk-ir\",\n- \"chalk-macros\",\n-]\n-\n [[package]]\n name = \"chalk-solve\"\n version = \"0.10.1-dev\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=eaab84b394007d1bed15f5470409a6ea02900a96#eaab84b394007d1bed15f5470409a6ea02900a96\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=329b7f3fdd2431ed6f6778cde53f22374c7d094c#329b7f3fdd2431ed6f6778cde53f22374c7d094c\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-engine\",\n  \"chalk-ir\",\n- \"chalk-macros\",\n- \"chalk-rust-ir\",\n  \"ena\",\n  \"itertools\",\n  \"petgraph\",\n@@ -264,9 +243,9 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-queue\"\n-version = \"0.2.1\"\n+version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c695eeca1e7173472a32221542ae469b3e9aac3a4fc81f7696bcad82029493db\"\n+checksum = \"ab6bffe714b6bb07e42f201352c34f51fefd355ace793f9e638ebd52d23f98d2\"\n dependencies = [\n  \"cfg-if\",\n  \"crossbeam-utils\",\n@@ -382,9 +361,9 @@ dependencies = [\n \n [[package]]\n name = \"fst\"\n-version = \"0.4.3\"\n+version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"81f9cac32c1741cdf6b66be7dcf0d9c7f25ccf12f8aa84c16cfa31f9f14513b3\"\n+checksum = \"a7293de202dbfe786c0b3fe6110a027836c5438ed06db7b715c9955ff4bfea51\"\n \n [[package]]\n name = \"fuchsia-zircon\"\n@@ -483,9 +462,9 @@ dependencies = [\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.3.2\"\n+version = \"1.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"076f042c5b7b98f31d205f1249267e12a6518c1481e9dae9764af19b707d2292\"\n+checksum = \"c398b2b113b55809ceb9ee3e753fcbac793f1956663f3c36549c1346015c2afe\"\n dependencies = [\n  \"autocfg\",\n ]\n@@ -610,9 +589,9 @@ checksum = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.70\"\n+version = \"0.2.71\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3baa92041a6fec78c687fa0cc2b3fae8884f743d672cf551bed1d6dac6988d0f\"\n+checksum = \"9457b06509d27052635f90d6466700c65095fdf75409b3fbdd903e988b886f49\"\n \n [[package]]\n name = \"libloading\"\n@@ -661,9 +640,9 @@ dependencies = [\n \n [[package]]\n name = \"lsp-types\"\n-version = \"0.74.1\"\n+version = \"0.74.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"57c0e6a2b8837d27b29deb3f3e6dc1c6d2f57947677f9be1024e482ec5b59525\"\n+checksum = \"b360754e89e0e13c114245131382ba921d4ff1efabb918e549422938aaa8d392\"\n dependencies = [\n  \"base64\",\n  \"bitflags\",\n@@ -830,19 +809,19 @@ dependencies = [\n \n [[package]]\n name = \"paste\"\n-version = \"0.1.12\"\n+version = \"0.1.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0a229b1c58c692edcaa5b9b0948084f130f55d2dcc15b02fcc5340b2b4521476\"\n+checksum = \"d508492eeb1e5c38ee696371bf7b9fc33c83d46a7d451606b96458fbbbdc2dec\"\n dependencies = [\n  \"paste-impl\",\n  \"proc-macro-hack\",\n ]\n \n [[package]]\n name = \"paste-impl\"\n-version = \"0.1.12\"\n+version = \"0.1.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2e0bf239e447e67ff6d16a8bb5e4d4bd2343acf5066061c0e8e06ac5ba8ca68c\"\n+checksum = \"84f328a6a63192b333fce5fbb4be79db6758a4d518dfac6d54412f1492f72d32\"\n dependencies = [\n  \"proc-macro-hack\",\n  \"proc-macro2\",\n@@ -858,9 +837,9 @@ checksum = \"d4fd5641d01c8f18a23da7b6fe29298ff4b55afcccdf78973b24cf3175fee32e\"\n \n [[package]]\n name = \"petgraph\"\n-version = \"0.5.0\"\n+version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"29c127eea4a29ec6c85d153c59dc1213f33ec74cead30fe4730aecc88cc1fd92\"\n+checksum = \"467d164a6de56270bd7c4d070df81d07beace25012d5103ced4e9ff08d6afdb7\"\n dependencies = [\n  \"fixedbitset\",\n  \"indexmap\",\n@@ -886,15 +865,15 @@ checksum = \"237a5ed80e274dbc66f86bd59c1e25edc039660be53194b5fe0a482e0f2612ea\"\n \n [[package]]\n name = \"proc-macro-hack\"\n-version = \"0.5.15\"\n+version = \"0.5.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0d659fe7c6d27f25e9d80a1a094c223f5246f6a6596453e09d7229bf42750b63\"\n+checksum = \"7e0456befd48169b9f13ef0f0ad46d492cf9d2dbb918bcf38e01eed4ce3ec5e4\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.13\"\n+version = \"1.0.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"53f5ffe53a6b28e37c9c1ce74893477864d64f74778a93a4beb43c8fa167f639\"\n+checksum = \"beae6331a816b1f65d04c45b078fd8e6c93e8071771f41b8163255bbd8d7c8fa\"\n dependencies = [\n  \"unicode-xid\",\n ]\n@@ -1036,7 +1015,6 @@ version = \"0.1.0\"\n dependencies = [\n  \"arrayvec\",\n  \"chalk-ir\",\n- \"chalk-rust-ir\",\n  \"chalk-solve\",\n  \"ena\",\n  \"insta\",\n@@ -1141,6 +1119,7 @@ dependencies = [\n  \"memmap\",\n  \"ra_mbe\",\n  \"ra_proc_macro\",\n+ \"ra_toolchain\",\n  \"ra_tt\",\n  \"serde_derive\",\n  \"test_utils\",\n@@ -1313,9 +1292,9 @@ checksum = \"2439c63f3f6139d1b57529d16bc3b8bb855230c8efcc5d3a896c8bea7c3b1e84\"\n \n [[package]]\n name = \"regex\"\n-version = \"1.3.7\"\n+version = \"1.3.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a6020f034922e3194c711b82a627453881bc4682166cabb07134a10c26ba7692\"\n+checksum = \"9c3780fcf44b193bc4d09f36d2a3c87b251da4a046c87795a0d35f4f927ad8e6\"\n dependencies = [\n  \"aho-corasick\",\n  \"memchr\",\n@@ -1325,9 +1304,9 @@ dependencies = [\n \n [[package]]\n name = \"regex-syntax\"\n-version = \"0.6.17\"\n+version = \"0.6.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7fe5bd57d1d7414c6b5ed48563a2c855d995ff777729dcd91c369ec7fea395ae\"\n+checksum = \"26412eb97c6b088a6997e05f69403a802a92d520de2f8e63c2b65f9e0f47c4e8\"\n \n [[package]]\n name = \"relative-path\"\n@@ -1372,17 +1351,20 @@ dependencies = [\n  \"lsp-types\",\n  \"parking_lot\",\n  \"pico-args\",\n+ \"ra_cfg\",\n  \"ra_db\",\n  \"ra_flycheck\",\n  \"ra_hir\",\n  \"ra_hir_def\",\n  \"ra_hir_ty\",\n  \"ra_ide\",\n+ \"ra_mbe\",\n  \"ra_proc_macro_srv\",\n  \"ra_prof\",\n  \"ra_project_model\",\n  \"ra_syntax\",\n  \"ra_text_edit\",\n+ \"ra_tt\",\n  \"ra_vfs\",\n  \"rand\",\n  \"relative-path\",\n@@ -1398,9 +1380,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"656.0.0\"\n+version = \"661.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9cbba98ec46e96a4663197dfa8c0378752de2006e314e5400c0ca74929d6692f\"\n+checksum = \"a6d88abd7c634b52557e46fc7ba47644f0cbe45c358c33f51c532d60d1da239e\"\n dependencies = [\n  \"unicode-xid\",\n ]\n@@ -1419,9 +1401,9 @@ checksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n \n [[package]]\n name = \"ryu\"\n-version = \"1.0.4\"\n+version = \"1.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ed3d612bc64430efeb3f7ee6ef26d590dce0c43249217bddc62112540c7941e1\"\n+checksum = \"71d301d4193d031abdd79ff7e3dd721168a9572ef3fe51a1517aba235bd8f86e\"\n \n [[package]]\n name = \"salsa\"\n@@ -1510,18 +1492,18 @@ checksum = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.110\"\n+version = \"1.0.111\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"99e7b308464d16b56eba9964e4972a3eee817760ab60d88c3f86e1fecb08204c\"\n+checksum = \"c9124df5b40cbd380080b2cc6ab894c040a3070d995f5c9dc77e18c34a8ae37d\"\n dependencies = [\n  \"serde_derive\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.110\"\n+version = \"1.0.111\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"818fbf6bfa9a42d3bfcaca148547aa00c7b915bec71d1757aa2d44ca68771984\"\n+checksum = \"3f2c3ac8e6ca1e9c80b8be1023940162bf81ae3cffbb1809474152f2ce1eb250\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1595,9 +1577,9 @@ checksum = \"ab16ced94dbd8a46c82fd81e3ed9a8727dac2977ea869d217bcc4ea1f122e81f\"\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.22\"\n+version = \"1.0.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1425de3c33b0941002740a420b1a906a350b88d08b82b2c8a01035a3f9447bac\"\n+checksum = \"93a56fabc59dce20fe48b6c832cc249c713e7ed88fa28b0ee0a3bfcaae5fe4e2\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1654,7 +1636,11 @@ name = \"test_utils\"\n version = \"0.1.0\"\n dependencies = [\n  \"difference\",\n+ \"ra_cfg\",\n+ \"relative-path\",\n+ \"rustc-hash\",\n  \"serde_json\",\n+ \"stdx\",\n  \"text-size\",\n ]\n \n@@ -1813,9 +1799,9 @@ dependencies = [\n \n [[package]]\n name = \"yaml-rust\"\n-version = \"0.4.3\"\n+version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"65923dd1784f44da1d2c3dbbc5e822045628c590ba72123e1c73d3c230c4434d\"\n+checksum = \"39f0c922f1a334134dc2f7a8b67dc5d25f0735263feec974345ff706bcf20b0d\"\n dependencies = [\n  \"linked-hash-map\",\n ]"}, {"sha": "5278b5a1676c912d2c3064abd58bdbc239f8c833", "filename": "Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -22,8 +22,6 @@ opt-level = 0\n opt-level = 0\n [profile.release.package.chalk-derive]\n opt-level = 0\n-[profile.release.package.chalk-macros]\n-opt-level = 0\n [profile.release.package.salsa-macros]\n opt-level = 0\n [profile.release.package.xtask]"}, {"sha": "1e7c3e9b4344b7bce027dc481e04784aef244d1d", "filename": "README.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -27,9 +27,13 @@ If you want to **use** rust-analyzer's language server with your editor of\n choice, check [the manual](https://rust-analyzer.github.io/manual.html) folder. It also contains some tips & tricks to help\n you be more productive when using rust-analyzer.\n \n-## Getting in touch\n+## Communication\n \n-We are on the rust-lang Zulip!\n+For usage and troubleshooting requests, please use \"IDEs and Editors\" category of the Rust forum:\n+\n+https://users.rust-lang.org/c/ide/14\n+\n+For questions about development and implementation, join rls-2.0 working group on Zulip:\n \n https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Frls-2.2E0\n "}, {"sha": "13ce236df5b4574586ff052471b2675177ea8193", "filename": "bors.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/bors.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/bors.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/bors.toml?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -2,6 +2,8 @@ status = [\n     \"Rust (ubuntu-latest)\",\n     \"Rust (windows-latest)\",\n     \"Rust (macos-latest)\",\n-    \"TypeScript\"\n+    \"TypeScript (ubuntu-latest)\",\n+    \"TypeScript (windows-latest)\",\n+    \"TypeScript (macos-latest)\",\n ]\n delete_merged_branches = true"}, {"sha": "776bddf918a9188209eb4989046b8ecbd07c8261", "filename": "crates/ra_assists/src/handlers/add_from_impl_for_enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -4,9 +4,9 @@ use test_utils::mark;\n \n use crate::{utils::FamousDefs, AssistContext, AssistId, Assists};\n \n-// Assist add_from_impl_for_enum\n+// Assist: add_from_impl_for_enum\n //\n-// Adds a From impl for an enum variant with one tuple field\n+// Adds a From impl for an enum variant with one tuple field.\n //\n // ```\n // enum A { <|>One(u32) }"}, {"sha": "beb5b7366d9091eb479a13ad53953325d35c277a", "filename": "crates/ra_assists/src/handlers/introduce_named_lifetime.rs", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -0,0 +1,303 @@\n+use ra_syntax::{\n+    ast::{self, NameOwner, TypeAscriptionOwner, TypeParamsOwner},\n+    AstNode, SyntaxKind, TextRange, TextSize,\n+};\n+use rustc_hash::FxHashSet;\n+\n+use crate::{assist_context::AssistBuilder, AssistContext, AssistId, Assists};\n+\n+static ASSIST_NAME: &str = \"introduce_named_lifetime\";\n+static ASSIST_LABEL: &str = \"Introduce named lifetime\";\n+\n+// Assist: introduce_named_lifetime\n+//\n+// Change an anonymous lifetime to a named lifetime.\n+//\n+// ```\n+// impl Cursor<'_<|>> {\n+//     fn node(self) -> &SyntaxNode {\n+//         match self {\n+//             Cursor::Replace(node) | Cursor::Before(node) => node,\n+//         }\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// impl<'a> Cursor<'a> {\n+//     fn node(self) -> &SyntaxNode {\n+//         match self {\n+//             Cursor::Replace(node) | Cursor::Before(node) => node,\n+//         }\n+//     }\n+// }\n+// ```\n+// FIXME: How can we handle renaming any one of multiple anonymous lifetimes?\n+// FIXME: should also add support for the case fun(f: &Foo) -> &<|>Foo\n+pub(crate) fn introduce_named_lifetime(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let lifetime_token = ctx\n+        .find_token_at_offset(SyntaxKind::LIFETIME)\n+        .filter(|lifetime| lifetime.text() == \"'_\")?;\n+    if let Some(fn_def) = lifetime_token.ancestors().find_map(ast::FnDef::cast) {\n+        generate_fn_def_assist(acc, &fn_def, lifetime_token.text_range())\n+    } else if let Some(impl_def) = lifetime_token.ancestors().find_map(ast::ImplDef::cast) {\n+        // only allow naming the last anonymous lifetime\n+        lifetime_token.next_token().filter(|tok| tok.kind() == SyntaxKind::R_ANGLE)?;\n+        generate_impl_def_assist(acc, &impl_def, lifetime_token.text_range())\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Generate the assist for the fn def case\n+fn generate_fn_def_assist(\n+    acc: &mut Assists,\n+    fn_def: &ast::FnDef,\n+    lifetime_loc: TextRange,\n+) -> Option<()> {\n+    let param_list: ast::ParamList = fn_def.param_list()?;\n+    let new_lifetime_param = generate_unique_lifetime_param_name(&fn_def.type_param_list())?;\n+    let end_of_fn_ident = fn_def.name()?.ident_token()?.text_range().end();\n+    let self_param =\n+        // use the self if it's a reference and has no explicit lifetime\n+        param_list.self_param().filter(|p| p.lifetime_token().is_none() && p.amp_token().is_some());\n+    // compute the location which implicitly has the same lifetime as the anonymous lifetime\n+    let loc_needing_lifetime = if let Some(self_param) = self_param {\n+        // if we have a self reference, use that\n+        Some(self_param.self_token()?.text_range().start())\n+    } else {\n+        // otherwise, if there's a single reference parameter without a named liftime, use that\n+        let fn_params_without_lifetime: Vec<_> = param_list\n+            .params()\n+            .filter_map(|param| match param.ascribed_type() {\n+                Some(ast::TypeRef::ReferenceType(ascribed_type))\n+                    if ascribed_type.lifetime_token() == None =>\n+                {\n+                    Some(ascribed_type.amp_token()?.text_range().end())\n+                }\n+                _ => None,\n+            })\n+            .collect();\n+        match fn_params_without_lifetime.len() {\n+            1 => Some(fn_params_without_lifetime.into_iter().nth(0)?),\n+            0 => None,\n+            // multiple unnnamed is invalid. assist is not applicable\n+            _ => return None,\n+        }\n+    };\n+    acc.add(AssistId(ASSIST_NAME), ASSIST_LABEL, lifetime_loc, |builder| {\n+        add_lifetime_param(fn_def, builder, end_of_fn_ident, new_lifetime_param);\n+        builder.replace(lifetime_loc, format!(\"'{}\", new_lifetime_param));\n+        loc_needing_lifetime.map(|loc| builder.insert(loc, format!(\"'{} \", new_lifetime_param)));\n+    })\n+}\n+\n+/// Generate the assist for the impl def case\n+fn generate_impl_def_assist(\n+    acc: &mut Assists,\n+    impl_def: &ast::ImplDef,\n+    lifetime_loc: TextRange,\n+) -> Option<()> {\n+    let new_lifetime_param = generate_unique_lifetime_param_name(&impl_def.type_param_list())?;\n+    let end_of_impl_kw = impl_def.impl_token()?.text_range().end();\n+    acc.add(AssistId(ASSIST_NAME), ASSIST_LABEL, lifetime_loc, |builder| {\n+        add_lifetime_param(impl_def, builder, end_of_impl_kw, new_lifetime_param);\n+        builder.replace(lifetime_loc, format!(\"'{}\", new_lifetime_param));\n+    })\n+}\n+\n+/// Given a type parameter list, generate a unique lifetime parameter name\n+/// which is not in the list\n+fn generate_unique_lifetime_param_name(\n+    existing_type_param_list: &Option<ast::TypeParamList>,\n+) -> Option<char> {\n+    match existing_type_param_list {\n+        Some(type_params) => {\n+            let used_lifetime_params: FxHashSet<_> = type_params\n+                .lifetime_params()\n+                .map(|p| p.syntax().text().to_string()[1..].to_owned())\n+                .collect();\n+            (b'a'..=b'z').map(char::from).find(|c| !used_lifetime_params.contains(&c.to_string()))\n+        }\n+        None => Some('a'),\n+    }\n+}\n+\n+/// Add the lifetime param to `builder`. If there are type parameters in `type_params_owner`, add it to the end. Otherwise\n+/// add new type params brackets with the lifetime parameter at `new_type_params_loc`.\n+fn add_lifetime_param<TypeParamsOwner: ast::TypeParamsOwner>(\n+    type_params_owner: &TypeParamsOwner,\n+    builder: &mut AssistBuilder,\n+    new_type_params_loc: TextSize,\n+    new_lifetime_param: char,\n+) {\n+    match type_params_owner.type_param_list() {\n+        // add the new lifetime parameter to an existing type param list\n+        Some(type_params) => {\n+            builder.insert(\n+                (u32::from(type_params.syntax().text_range().end()) - 1).into(),\n+                format!(\", '{}\", new_lifetime_param),\n+            );\n+        }\n+        // create a new type param list containing only the new lifetime parameter\n+        None => {\n+            builder.insert(new_type_params_loc, format!(\"<'{}>\", new_lifetime_param));\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    #[test]\n+    fn test_example_case() {\n+        check_assist(\n+            introduce_named_lifetime,\n+            r#\"impl Cursor<'_<|>> {\n+                fn node(self) -> &SyntaxNode {\n+                    match self {\n+                        Cursor::Replace(node) | Cursor::Before(node) => node,\n+                    }\n+                }\n+            }\"#,\n+            r#\"impl<'a> Cursor<'a> {\n+                fn node(self) -> &SyntaxNode {\n+                    match self {\n+                        Cursor::Replace(node) | Cursor::Before(node) => node,\n+                    }\n+                }\n+            }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_example_case_simplified() {\n+        check_assist(\n+            introduce_named_lifetime,\n+            r#\"impl Cursor<'_<|>> {\"#,\n+            r#\"impl<'a> Cursor<'a> {\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_example_case_cursor_after_tick() {\n+        check_assist(\n+            introduce_named_lifetime,\n+            r#\"impl Cursor<'<|>_> {\"#,\n+            r#\"impl<'a> Cursor<'a> {\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_example_case_cursor_before_tick() {\n+        check_assist(\n+            introduce_named_lifetime,\n+            r#\"impl Cursor<<|>'_> {\"#,\n+            r#\"impl<'a> Cursor<'a> {\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_not_applicable_cursor_position() {\n+        check_assist_not_applicable(introduce_named_lifetime, r#\"impl Cursor<'_><|> {\"#);\n+        check_assist_not_applicable(introduce_named_lifetime, r#\"impl Cursor<|><'_> {\"#);\n+    }\n+\n+    #[test]\n+    fn test_not_applicable_lifetime_already_name() {\n+        check_assist_not_applicable(introduce_named_lifetime, r#\"impl Cursor<'a<|>> {\"#);\n+        check_assist_not_applicable(introduce_named_lifetime, r#\"fn my_fun<'a>() -> X<'a<|>>\"#);\n+    }\n+\n+    #[test]\n+    fn test_with_type_parameter() {\n+        check_assist(\n+            introduce_named_lifetime,\n+            r#\"impl<T> Cursor<T, '_<|>>\"#,\n+            r#\"impl<T, 'a> Cursor<T, 'a>\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_with_existing_lifetime_name_conflict() {\n+        check_assist(\n+            introduce_named_lifetime,\n+            r#\"impl<'a, 'b> Cursor<'a, 'b, '_<|>>\"#,\n+            r#\"impl<'a, 'b, 'c> Cursor<'a, 'b, 'c>\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_function_return_value_anon_lifetime_param() {\n+        check_assist(\n+            introduce_named_lifetime,\n+            r#\"fn my_fun() -> X<'_<|>>\"#,\n+            r#\"fn my_fun<'a>() -> X<'a>\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_function_return_value_anon_reference_lifetime() {\n+        check_assist(\n+            introduce_named_lifetime,\n+            r#\"fn my_fun() -> &'_<|> X\"#,\n+            r#\"fn my_fun<'a>() -> &'a X\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_function_param_anon_lifetime() {\n+        check_assist(\n+            introduce_named_lifetime,\n+            r#\"fn my_fun(x: X<'_<|>>)\"#,\n+            r#\"fn my_fun<'a>(x: X<'a>)\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_function_add_lifetime_to_params() {\n+        check_assist(\n+            introduce_named_lifetime,\n+            r#\"fn my_fun(f: &Foo) -> X<'_<|>>\"#,\n+            r#\"fn my_fun<'a>(f: &'a Foo) -> X<'a>\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_function_add_lifetime_to_params_in_presence_of_other_lifetime() {\n+        check_assist(\n+            introduce_named_lifetime,\n+            r#\"fn my_fun<'other>(f: &Foo, b: &'other Bar) -> X<'_<|>>\"#,\n+            r#\"fn my_fun<'other, 'a>(f: &'a Foo, b: &'other Bar) -> X<'a>\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_function_not_applicable_without_self_and_multiple_unnamed_param_lifetimes() {\n+        // this is not permitted under lifetime elision rules\n+        check_assist_not_applicable(\n+            introduce_named_lifetime,\n+            r#\"fn my_fun(f: &Foo, b: &Bar) -> X<'_<|>>\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_function_add_lifetime_to_self_ref_param() {\n+        check_assist(\n+            introduce_named_lifetime,\n+            r#\"fn my_fun<'other>(&self, f: &Foo, b: &'other Bar) -> X<'_<|>>\"#,\n+            r#\"fn my_fun<'other, 'a>(&'a self, f: &Foo, b: &'other Bar) -> X<'a>\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_function_add_lifetime_to_param_with_non_ref_self() {\n+        check_assist(\n+            introduce_named_lifetime,\n+            r#\"fn my_fun<'other>(self, f: &Foo, b: &'other Bar) -> X<'_<|>>\"#,\n+            r#\"fn my_fun<'other, 'a>(self, f: &'a Foo, b: &'other Bar) -> X<'a>\"#,\n+        );\n+    }\n+}"}, {"sha": "897da283238f7b67c0aa26e8dc6e994a3f26ab84", "filename": "crates/ra_assists/src/handlers/reorder_fields.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -23,7 +23,7 @@ use crate::{AssistContext, AssistId, Assists};\n // ```\n //\n pub(crate) fn reorder_fields(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    reorder::<ast::RecordLit>(acc, ctx.clone()).or_else(|| reorder::<ast::RecordPat>(acc, ctx))\n+    reorder::<ast::RecordLit>(acc, ctx).or_else(|| reorder::<ast::RecordPat>(acc, ctx))\n }\n \n fn reorder<R: AstNode>(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {"}, {"sha": "88ce9b62ebf0a34f8f8be3caad6162d5b3612d1a", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -122,6 +122,7 @@ mod handlers {\n     mod flip_comma;\n     mod flip_trait_bound;\n     mod inline_local_variable;\n+    mod introduce_named_lifetime;\n     mod introduce_variable;\n     mod invert_if;\n     mod merge_imports;\n@@ -162,6 +163,7 @@ mod handlers {\n             flip_comma::flip_comma,\n             flip_trait_bound::flip_trait_bound,\n             inline_local_variable::inline_local_variable,\n+            introduce_named_lifetime::introduce_named_lifetime,\n             introduce_variable::introduce_variable,\n             invert_if::invert_if,\n             merge_imports::merge_imports,"}, {"sha": "d17504529fd44e2ec93f9ba32578ab39fe4e2b43", "filename": "crates/ra_assists/src/tests/generated.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -58,6 +58,25 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_add_from_impl_for_enum() {\n+    check_doc_test(\n+        \"add_from_impl_for_enum\",\n+        r#####\"\n+enum A { <|>One(u32) }\n+\"#####,\n+        r#####\"\n+enum A { One(u32) }\n+\n+impl From<u32> for A {\n+    fn from(v: u32) -> Self {\n+        A::One(v)\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_add_function() {\n     check_doc_test(\n@@ -432,6 +451,31 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_introduce_named_lifetime() {\n+    check_doc_test(\n+        \"introduce_named_lifetime\",\n+        r#####\"\n+impl Cursor<'_<|>> {\n+    fn node(self) -> &SyntaxNode {\n+        match self {\n+            Cursor::Replace(node) | Cursor::Before(node) => node,\n+        }\n+    }\n+}\n+\"#####,\n+        r#####\"\n+impl<'a> Cursor<'a> {\n+    fn node(self) -> &SyntaxNode {\n+        match self {\n+            Cursor::Replace(node) | Cursor::Before(node) => node,\n+        }\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_introduce_variable() {\n     check_doc_test("}, {"sha": "85b100c6adfe6523c1e3cf5488815682ad90c05f", "filename": "crates/ra_cfg/src/cfg_expr.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_cfg%2Fsrc%2Fcfg_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_cfg%2Fsrc%2Fcfg_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cfg%2Fsrc%2Fcfg_expr.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -88,13 +88,17 @@ fn next_cfg_expr(it: &mut SliceIter<tt::TokenTree>) -> Option<CfgExpr> {\n mod tests {\n     use super::*;\n \n-    use mbe::ast_to_token_tree;\n+    use mbe::{ast_to_token_tree, TokenMap};\n     use ra_syntax::ast::{self, AstNode};\n \n-    fn assert_parse_result(input: &str, expected: CfgExpr) {\n+    fn get_token_tree_generated(input: &str) -> (tt::Subtree, TokenMap) {\n         let source_file = ast::SourceFile::parse(input).ok().unwrap();\n         let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n-        let (tt, _) = ast_to_token_tree(&tt).unwrap();\n+        ast_to_token_tree(&tt).unwrap()\n+    }\n+\n+    fn assert_parse_result(input: &str, expected: CfgExpr) {\n+        let (tt, _) = get_token_tree_generated(input);\n         assert_eq!(parse_cfg(&tt), expected);\n     }\n "}, {"sha": "482a2f3e651e199f689f319079167c9f5ada9cd6", "filename": "crates/ra_db/src/fixture.rs", "status": "modified", "additions": 21, "deletions": 49, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Ffixture.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -63,7 +63,7 @@ use std::sync::Arc;\n \n use ra_cfg::CfgOptions;\n use rustc_hash::FxHashMap;\n-use test_utils::{extract_offset, parse_fixture, parse_single_fixture, CURSOR_MARKER};\n+use test_utils::{extract_offset, parse_fixture, parse_single_fixture, FixtureMeta, CURSOR_MARKER};\n \n use crate::{\n     input::CrateName, CrateGraph, CrateId, Edition, Env, FileId, FilePosition, RelativePathBuf,\n@@ -113,7 +113,7 @@ fn with_single_file(db: &mut dyn SourceDatabaseExt, ra_fixture: &str) -> FileId\n     let fixture = parse_single_fixture(ra_fixture);\n \n     let crate_graph = if let Some(entry) = fixture {\n-        let meta = match parse_meta(&entry.meta) {\n+        let meta = match ParsedMeta::from(&entry.meta) {\n             ParsedMeta::File(it) => it,\n             _ => panic!(\"with_single_file only support file meta\"),\n         };\n@@ -170,7 +170,7 @@ fn with_files(db: &mut dyn SourceDatabaseExt, fixture: &str) -> Option<FilePosit\n     let mut file_position = None;\n \n     for entry in fixture.iter() {\n-        let meta = match parse_meta(&entry.meta) {\n+        let meta = match ParsedMeta::from(&entry.meta) {\n             ParsedMeta::Root { path } => {\n                 let source_root = std::mem::replace(&mut source_root, SourceRoot::new_local());\n                 db.set_source_root(source_root_id, Arc::new(source_root));\n@@ -258,53 +258,25 @@ struct FileMeta {\n     env: Env,\n }\n \n-//- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b env:OUTDIR=path/to,OTHER=foo)\n-fn parse_meta(meta: &str) -> ParsedMeta {\n-    let components = meta.split_ascii_whitespace().collect::<Vec<_>>();\n-\n-    if components[0] == \"root\" {\n-        let path: RelativePathBuf = components[1].into();\n-        assert!(path.starts_with(\"/\") && path.ends_with(\"/\"));\n-        return ParsedMeta::Root { path };\n-    }\n-\n-    let path: RelativePathBuf = components[0].into();\n-    assert!(path.starts_with(\"/\"));\n-\n-    let mut krate = None;\n-    let mut deps = Vec::new();\n-    let mut edition = Edition::Edition2018;\n-    let mut cfg = CfgOptions::default();\n-    let mut env = Env::default();\n-    for component in components[1..].iter() {\n-        let (key, value) = split1(component, ':').unwrap();\n-        match key {\n-            \"crate\" => krate = Some(value.to_string()),\n-            \"deps\" => deps = value.split(',').map(|it| it.to_string()).collect(),\n-            \"edition\" => edition = Edition::from_str(&value).unwrap(),\n-            \"cfg\" => {\n-                for key in value.split(',') {\n-                    match split1(key, '=') {\n-                        None => cfg.insert_atom(key.into()),\n-                        Some((k, v)) => cfg.insert_key_value(k.into(), v.into()),\n-                    }\n-                }\n-            }\n-            \"env\" => {\n-                for key in value.split(',') {\n-                    if let Some((k, v)) = split1(key, '=') {\n-                        env.set(k, v.into());\n-                    }\n-                }\n+impl From<&FixtureMeta> for ParsedMeta {\n+    fn from(meta: &FixtureMeta) -> Self {\n+        match meta {\n+            FixtureMeta::Root { path } => {\n+                // `Self::Root` causes a false warning: 'variant is never constructed: `Root` '\n+                // see https://github.com/rust-lang/rust/issues/69018\n+                ParsedMeta::Root { path: path.to_owned() }\n             }\n-            _ => panic!(\"bad component: {:?}\", component),\n+            FixtureMeta::File(f) => Self::File(FileMeta {\n+                path: f.path.to_owned(),\n+                krate: f.crate_name.to_owned(),\n+                deps: f.deps.to_owned(),\n+                cfg: f.cfg.to_owned(),\n+                edition: f\n+                    .edition\n+                    .as_ref()\n+                    .map_or(Edition::Edition2018, |v| Edition::from_str(&v).unwrap()),\n+                env: Env::from(f.env.iter()),\n+            }),\n         }\n     }\n-\n-    ParsedMeta::File(FileMeta { path, krate, deps, edition, cfg, env })\n-}\n-\n-fn split1(haystack: &str, delim: char) -> Option<(&str, &str)> {\n-    let idx = haystack.find(delim)?;\n-    Some((&haystack[..idx], &haystack[idx + delim.len_utf8()..]))\n }"}, {"sha": "4d2d3b48a0c073f71ef52ec62f4367883c405924", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -311,6 +311,21 @@ impl fmt::Display for Edition {\n     }\n }\n \n+impl<'a, T> From<T> for Env\n+where\n+    T: Iterator<Item = (&'a String, &'a String)>,\n+{\n+    fn from(iter: T) -> Self {\n+        let mut result = Self::default();\n+\n+        for (k, v) in iter {\n+            result.entries.insert(k.to_owned(), v.to_owned());\n+        }\n+\n+        result\n+    }\n+}\n+\n impl Env {\n     pub fn set(&mut self, env: &str, value: String) {\n         self.entries.insert(env.to_owned(), value);"}, {"sha": "4a06f3bcddb69fa092ab1557443e837984436c0c", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -532,7 +532,7 @@ impl Adt {\n         Some(self.module(db).krate())\n     }\n \n-    pub fn name(&self, db: &dyn HirDatabase) -> Name {\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n         match self {\n             Adt::Struct(s) => s.name(db),\n             Adt::Union(u) => u.name(db),\n@@ -637,6 +637,10 @@ impl Function {\n         db.function_data(self.id).params.clone()\n     }\n \n+    pub fn is_unsafe(self, db: &dyn HirDatabase) -> bool {\n+        db.function_data(self.id).is_unsafe\n+    }\n+\n     pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n         let _p = profile(\"Function::diagnostics\");\n         let infer = db.infer(self.id.into());\n@@ -1018,15 +1022,15 @@ impl ImplDef {\n         impls.lookup_impl_defs_for_trait(trait_.id).map(Self::from).collect()\n     }\n \n-    pub fn target_trait(&self, db: &dyn HirDatabase) -> Option<TypeRef> {\n+    pub fn target_trait(self, db: &dyn HirDatabase) -> Option<TypeRef> {\n         db.impl_data(self.id).target_trait.clone()\n     }\n \n-    pub fn target_type(&self, db: &dyn HirDatabase) -> TypeRef {\n+    pub fn target_type(self, db: &dyn HirDatabase) -> TypeRef {\n         db.impl_data(self.id).target_type.clone()\n     }\n \n-    pub fn target_ty(&self, db: &dyn HirDatabase) -> Type {\n+    pub fn target_ty(self, db: &dyn HirDatabase) -> Type {\n         let impl_data = db.impl_data(self.id);\n         let resolver = self.id.resolver(db.upcast());\n         let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n@@ -1038,23 +1042,23 @@ impl ImplDef {\n         }\n     }\n \n-    pub fn items(&self, db: &dyn HirDatabase) -> Vec<AssocItem> {\n+    pub fn items(self, db: &dyn HirDatabase) -> Vec<AssocItem> {\n         db.impl_data(self.id).items.iter().map(|it| (*it).into()).collect()\n     }\n \n-    pub fn is_negative(&self, db: &dyn HirDatabase) -> bool {\n+    pub fn is_negative(self, db: &dyn HirDatabase) -> bool {\n         db.impl_data(self.id).is_negative\n     }\n \n-    pub fn module(&self, db: &dyn HirDatabase) -> Module {\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n         self.id.lookup(db.upcast()).container.module(db.upcast()).into()\n     }\n \n-    pub fn krate(&self, db: &dyn HirDatabase) -> Crate {\n+    pub fn krate(self, db: &dyn HirDatabase) -> Crate {\n         Crate { id: self.module(db).id.krate }\n     }\n \n-    pub fn is_builtin_derive(&self, db: &dyn HirDatabase) -> Option<InFile<ast::Attr>> {\n+    pub fn is_builtin_derive(self, db: &dyn HirDatabase) -> Option<InFile<ast::Attr>> {\n         let src = self.source(db);\n         let item = src.file_id.is_builtin_derive(db.upcast())?;\n         let hygenic = hir_expand::hygiene::Hygiene::new(db.upcast(), item.file_id);\n@@ -1190,6 +1194,10 @@ impl Type {\n         )\n     }\n \n+    pub fn is_raw_ptr(&self) -> bool {\n+        matches!(&self.ty.value, Ty::Apply(ApplicationTy { ctor: TypeCtor::RawPtr(..), .. }))\n+    }\n+\n     pub fn contains_unknown(&self) -> bool {\n         return go(&self.ty.value);\n \n@@ -1363,6 +1371,7 @@ impl HirDisplay for Type {\n }\n \n /// For IDE only\n+#[derive(Debug)]\n pub enum ScopeDef {\n     ModuleDef(ModuleDef),\n     MacroDef(MacroDef),"}, {"sha": "f4a6b05038754e2a7b21e4070aa81b1d68aed84d", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -62,6 +62,7 @@ pub use crate::{\n \n pub use hir_def::{\n     adt::StructKind,\n+    attr::Attrs,\n     body::scope::ExprScopes,\n     builtin_type::BuiltinType,\n     docs::Documentation,"}, {"sha": "2eeba057299185a1b1ad308052308740de4645e9", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -81,18 +81,24 @@ impl Attrs {\n         }\n     }\n \n-    fn from_attrs_owner(db: &dyn DefDatabase, owner: InFile<&dyn AttrsOwner>) -> Attrs {\n+    pub fn from_attrs_owner(db: &dyn DefDatabase, owner: InFile<&dyn AttrsOwner>) -> Attrs {\n         let hygiene = Hygiene::new(db.upcast(), owner.file_id);\n         Attrs::new(owner.value, &hygiene)\n     }\n \n     pub(crate) fn new(owner: &dyn AttrsOwner, hygiene: &Hygiene) -> Attrs {\n+        let docs = ast::CommentIter::from_syntax_node(owner.syntax()).doc_comment_text().map(\n+            |docs_text| Attr {\n+                input: Some(AttrInput::Literal(SmolStr::new(docs_text))),\n+                path: ModPath::from(hir_expand::name!(doc)),\n+            },\n+        );\n         let mut attrs = owner.attrs().peekable();\n         let entries = if attrs.peek().is_none() {\n             // Avoid heap allocation\n             None\n         } else {\n-            Some(attrs.flat_map(|ast| Attr::from_src(ast, hygiene)).collect())\n+            Some(attrs.flat_map(|ast| Attr::from_src(ast, hygiene)).chain(docs).collect())\n         };\n         Attrs { entries }\n     }"}, {"sha": "273036cee1cfec60fee9b4398055fdfc45731519", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -29,7 +29,7 @@ use crate::{\n     AsMacroCall, DefWithBodyId, HasModule, Lookup, ModuleId,\n };\n \n-/// A subset of Exander that only deals with cfg attributes. We only need it to\n+/// A subset of Expander that only deals with cfg attributes. We only need it to\n /// avoid cyclic queries in crate def map during enum processing.\n pub(crate) struct CfgExpander {\n     cfg_options: CfgOptions,"}, {"sha": "f159f80af05c71caf2d9c3a1fd81b8454c795986", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 72, "deletions": 15, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -28,7 +28,7 @@ use crate::{\n     },\n     item_scope::BuiltinShadowMode,\n     path::{GenericArgs, Path},\n-    type_ref::{Mutability, TypeRef},\n+    type_ref::{Mutability, Rawness, TypeRef},\n     AdtId, ConstLoc, ContainerId, DefWithBodyId, EnumLoc, FunctionLoc, Intern, ModuleDefId,\n     StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n };\n@@ -134,7 +134,7 @@ impl ExprCollector<'_> {\n         self.make_expr(expr, Err(SyntheticSyntax))\n     }\n     fn empty_block(&mut self) -> ExprId {\n-        self.alloc_expr_desugared(Expr::Block { statements: Vec::new(), tail: None })\n+        self.alloc_expr_desugared(Expr::Block { statements: Vec::new(), tail: None, label: None })\n     }\n     fn missing_expr(&mut self) -> ExprId {\n         self.alloc_expr_desugared(Expr::Missing)\n@@ -215,7 +215,16 @@ impl ExprCollector<'_> {\n             ast::Expr::BlockExpr(e) => self.collect_block(e),\n             ast::Expr::LoopExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());\n-                self.alloc_expr(Expr::Loop { body }, syntax_ptr)\n+                self.alloc_expr(\n+                    Expr::Loop {\n+                        body,\n+                        label: e\n+                            .label()\n+                            .and_then(|l| l.lifetime_token())\n+                            .map(|l| Name::new_lifetime(&l)),\n+                    },\n+                    syntax_ptr,\n+                )\n             }\n             ast::Expr::WhileExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());\n@@ -230,25 +239,56 @@ impl ExprCollector<'_> {\n                             let pat = self.collect_pat(pat);\n                             let match_expr = self.collect_expr_opt(condition.expr());\n                             let placeholder_pat = self.missing_pat();\n-                            let break_ = self.alloc_expr_desugared(Expr::Break { expr: None });\n+                            let break_ =\n+                                self.alloc_expr_desugared(Expr::Break { expr: None, label: None });\n                             let arms = vec![\n                                 MatchArm { pat, expr: body, guard: None },\n                                 MatchArm { pat: placeholder_pat, expr: break_, guard: None },\n                             ];\n                             let match_expr =\n                                 self.alloc_expr_desugared(Expr::Match { expr: match_expr, arms });\n-                            return self.alloc_expr(Expr::Loop { body: match_expr }, syntax_ptr);\n+                            return self.alloc_expr(\n+                                Expr::Loop {\n+                                    body: match_expr,\n+                                    label: e\n+                                        .label()\n+                                        .and_then(|l| l.lifetime_token())\n+                                        .map(|l| Name::new_lifetime(&l)),\n+                                },\n+                                syntax_ptr,\n+                            );\n                         }\n                     },\n                 };\n \n-                self.alloc_expr(Expr::While { condition, body }, syntax_ptr)\n+                self.alloc_expr(\n+                    Expr::While {\n+                        condition,\n+                        body,\n+                        label: e\n+                            .label()\n+                            .and_then(|l| l.lifetime_token())\n+                            .map(|l| Name::new_lifetime(&l)),\n+                    },\n+                    syntax_ptr,\n+                )\n             }\n             ast::Expr::ForExpr(e) => {\n                 let iterable = self.collect_expr_opt(e.iterable());\n                 let pat = self.collect_pat_opt(e.pat());\n                 let body = self.collect_block_opt(e.loop_body());\n-                self.alloc_expr(Expr::For { iterable, pat, body }, syntax_ptr)\n+                self.alloc_expr(\n+                    Expr::For {\n+                        iterable,\n+                        pat,\n+                        body,\n+                        label: e\n+                            .label()\n+                            .and_then(|l| l.lifetime_token())\n+                            .map(|l| Name::new_lifetime(&l)),\n+                    },\n+                    syntax_ptr,\n+                )\n             }\n             ast::Expr::CallExpr(e) => {\n                 let callee = self.collect_expr_opt(e.expr());\n@@ -301,13 +341,16 @@ impl ExprCollector<'_> {\n                     .unwrap_or(Expr::Missing);\n                 self.alloc_expr(path, syntax_ptr)\n             }\n-            ast::Expr::ContinueExpr(_e) => {\n-                // FIXME: labels\n-                self.alloc_expr(Expr::Continue, syntax_ptr)\n-            }\n+            ast::Expr::ContinueExpr(e) => self.alloc_expr(\n+                Expr::Continue { label: e.lifetime_token().map(|l| Name::new_lifetime(&l)) },\n+                syntax_ptr,\n+            ),\n             ast::Expr::BreakExpr(e) => {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n-                self.alloc_expr(Expr::Break { expr }, syntax_ptr)\n+                self.alloc_expr(\n+                    Expr::Break { expr, label: e.lifetime_token().map(|l| Name::new_lifetime(&l)) },\n+                    syntax_ptr,\n+                )\n             }\n             ast::Expr::ParenExpr(e) => {\n                 let inner = self.collect_expr_opt(e.expr());\n@@ -378,8 +421,21 @@ impl ExprCollector<'_> {\n             }\n             ast::Expr::RefExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n-                let mutability = Mutability::from_mutable(e.mut_token().is_some());\n-                self.alloc_expr(Expr::Ref { expr, mutability }, syntax_ptr)\n+                let raw_tok = e.raw_token().is_some();\n+                let mutability = if raw_tok {\n+                    if e.mut_token().is_some() {\n+                        Mutability::Mut\n+                    } else if e.const_token().is_some() {\n+                        Mutability::Shared\n+                    } else {\n+                        unreachable!(\"parser only remaps to raw_token() if matching mutability token follows\")\n+                    }\n+                } else {\n+                    Mutability::from_mutable(e.mut_token().is_some())\n+                };\n+                let rawness = Rawness::from_raw(raw_tok);\n+\n+                self.alloc_expr(Expr::Ref { expr, rawness, mutability }, syntax_ptr)\n             }\n             ast::Expr::PrefixExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n@@ -516,7 +572,8 @@ impl ExprCollector<'_> {\n             })\n             .collect();\n         let tail = block.expr().map(|e| self.collect_expr(e));\n-        self.alloc_expr(Expr::Block { statements, tail }, syntax_node_ptr)\n+        let label = block.label().and_then(|l| l.lifetime_token()).map(|t| Name::new_lifetime(&t));\n+        self.alloc_expr(Expr::Block { statements, tail, label }, syntax_node_ptr)\n     }\n \n     fn collect_block_items(&mut self, block: &ast::BlockExpr) {"}, {"sha": "e48ff38f96048c18ebe88ae6401c566f55a929b8", "filename": "crates/ra_hir_def/src/body/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -138,10 +138,10 @@ fn compute_block_scopes(\n fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope: ScopeId) {\n     scopes.set_scope(expr, scope);\n     match &body[expr] {\n-        Expr::Block { statements, tail } => {\n+        Expr::Block { statements, tail, .. } => {\n             compute_block_scopes(&statements, *tail, body, scopes, scope);\n         }\n-        Expr::For { iterable, pat, body: body_expr } => {\n+        Expr::For { iterable, pat, body: body_expr, .. } => {\n             compute_expr_scopes(*iterable, body, scopes, scope);\n             let scope = scopes.new_scope(scope);\n             scopes.add_bindings(body, scope, *pat);"}, {"sha": "807195d25ad98068bd607455d0c2543fd5973dc2", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -34,6 +34,7 @@ pub struct FunctionData {\n     /// True if the first param is `self`. This is relevant to decide whether this\n     /// can be called as a method.\n     pub has_self_param: bool,\n+    pub is_unsafe: bool,\n     pub visibility: RawVisibility,\n }\n \n@@ -85,11 +86,14 @@ impl FunctionData {\n             ret_type\n         };\n \n+        let is_unsafe = src.value.unsafe_token().is_some();\n+\n         let vis_default = RawVisibility::default_for_container(loc.container);\n         let visibility =\n             RawVisibility::from_ast_with_default(db, vis_default, src.map(|s| s.visibility()));\n \n-        let sig = FunctionData { name, params, ret_type, has_self_param, visibility, attrs };\n+        let sig =\n+            FunctionData { name, params, ret_type, has_self_param, is_unsafe, visibility, attrs };\n         Arc::new(sig)\n     }\n }"}, {"sha": "2630b3d895e60db1c6a07ffaee6cb233b37d490e", "filename": "crates/ra_hir_def/src/docs.rs", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -29,6 +29,13 @@ impl Documentation {\n         Documentation(s.into())\n     }\n \n+    pub fn from_ast<N>(node: &N) -> Option<Documentation>\n+    where\n+        N: ast::DocCommentsOwner + ast::AttrsOwner,\n+    {\n+        docs_from_ast(node)\n+    }\n+\n     pub fn as_str(&self) -> &str {\n         &*self.0\n     }\n@@ -70,6 +77,45 @@ impl Documentation {\n     }\n }\n \n-pub(crate) fn docs_from_ast(node: &impl ast::DocCommentsOwner) -> Option<Documentation> {\n-    node.doc_comment_text().map(|it| Documentation::new(&it))\n+pub(crate) fn docs_from_ast<N>(node: &N) -> Option<Documentation>\n+where\n+    N: ast::DocCommentsOwner + ast::AttrsOwner,\n+{\n+    let doc_comment_text = node.doc_comment_text();\n+    let doc_attr_text = expand_doc_attrs(node);\n+    let docs = merge_doc_comments_and_attrs(doc_comment_text, doc_attr_text);\n+    docs.map(|it| Documentation::new(&it))\n+}\n+\n+fn merge_doc_comments_and_attrs(\n+    doc_comment_text: Option<String>,\n+    doc_attr_text: Option<String>,\n+) -> Option<String> {\n+    match (doc_comment_text, doc_attr_text) {\n+        (Some(mut comment_text), Some(attr_text)) => {\n+            comment_text.push_str(\"\\n\\n\");\n+            comment_text.push_str(&attr_text);\n+            Some(comment_text)\n+        }\n+        (Some(comment_text), None) => Some(comment_text),\n+        (None, Some(attr_text)) => Some(attr_text),\n+        (None, None) => None,\n+    }\n+}\n+\n+fn expand_doc_attrs(owner: &dyn ast::AttrsOwner) -> Option<String> {\n+    let mut docs = String::new();\n+    for attr in owner.attrs() {\n+        if let Some((\"doc\", value)) =\n+            attr.as_simple_key_value().as_ref().map(|(k, v)| (k.as_str(), v.as_str()))\n+        {\n+            docs.push_str(value);\n+            docs.push_str(\"\\n\\n\");\n+        }\n+    }\n+    if docs.is_empty() {\n+        None\n+    } else {\n+        Some(docs.trim_end_matches(\"\\n\\n\").to_owned())\n+    }\n }"}, {"sha": "ca49b26d15f857752f633018bdd902dd5b3a1244", "filename": "crates/ra_hir_def/src/expr.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -19,7 +19,7 @@ use ra_syntax::ast::RangeOp;\n use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt},\n     path::{GenericArgs, Path},\n-    type_ref::{Mutability, TypeRef},\n+    type_ref::{Mutability, Rawness, TypeRef},\n };\n \n pub type ExprId = Idx<Expr>;\n@@ -52,18 +52,22 @@ pub enum Expr {\n     Block {\n         statements: Vec<Statement>,\n         tail: Option<ExprId>,\n+        label: Option<Name>,\n     },\n     Loop {\n         body: ExprId,\n+        label: Option<Name>,\n     },\n     While {\n         condition: ExprId,\n         body: ExprId,\n+        label: Option<Name>,\n     },\n     For {\n         iterable: ExprId,\n         pat: PatId,\n         body: ExprId,\n+        label: Option<Name>,\n     },\n     Call {\n         callee: ExprId,\n@@ -79,9 +83,12 @@ pub enum Expr {\n         expr: ExprId,\n         arms: Vec<MatchArm>,\n     },\n-    Continue,\n+    Continue {\n+        label: Option<Name>,\n+    },\n     Break {\n         expr: Option<ExprId>,\n+        label: Option<Name>,\n     },\n     Return {\n         expr: Option<ExprId>,\n@@ -110,6 +117,7 @@ pub enum Expr {\n     },\n     Ref {\n         expr: ExprId,\n+        rawness: Rawness,\n         mutability: Mutability,\n     },\n     Box {\n@@ -224,7 +232,7 @@ impl Expr {\n                     f(*else_branch);\n                 }\n             }\n-            Expr::Block { statements, tail } => {\n+            Expr::Block { statements, tail, .. } => {\n                 for stmt in statements {\n                     match stmt {\n                         Statement::Let { initializer, .. } => {\n@@ -240,8 +248,8 @@ impl Expr {\n                 }\n             }\n             Expr::TryBlock { body } => f(*body),\n-            Expr::Loop { body } => f(*body),\n-            Expr::While { condition, body } => {\n+            Expr::Loop { body, .. } => f(*body),\n+            Expr::While { condition, body, .. } => {\n                 f(*condition);\n                 f(*body);\n             }\n@@ -267,8 +275,8 @@ impl Expr {\n                     f(arm.expr);\n                 }\n             }\n-            Expr::Continue => {}\n-            Expr::Break { expr } | Expr::Return { expr } => {\n+            Expr::Continue { .. } => {}\n+            Expr::Break { expr, .. } | Expr::Return { expr } => {\n                 if let Some(expr) = expr {\n                     f(*expr);\n                 }"}, {"sha": "3516784b8d8d2e5a5cdd33785f40783dddc3eb26", "filename": "crates/ra_hir_def/src/lang_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -164,7 +164,7 @@ impl LangItems {\n         T: Into<AttrDefId> + Copy,\n     {\n         if let Some(lang_item_name) = lang_attr(db, item) {\n-            self.items.entry(lang_item_name.clone()).or_insert_with(|| constructor(item));\n+            self.items.entry(lang_item_name).or_insert_with(|| constructor(item));\n         }\n     }\n }"}, {"sha": "f44baa57942fb0dc887312ba0fdacef183973abb", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -175,7 +175,7 @@ pub(super) enum DefKind {\n }\n \n impl DefKind {\n-    pub fn ast_id(&self) -> FileAstId<ast::ModuleItem> {\n+    pub fn ast_id(self) -> FileAstId<ast::ModuleItem> {\n         match self {\n             DefKind::Function(it) => it.upcast(),\n             DefKind::Struct(it, _) => it.upcast(),"}, {"sha": "86a77b7046d44cc082d901d80a12bfd680e2b876", "filename": "crates/ra_hir_def/src/type_ref.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -35,6 +35,22 @@ impl Mutability {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum Rawness {\n+    RawPtr,\n+    Ref,\n+}\n+\n+impl Rawness {\n+    pub fn from_raw(is_raw: bool) -> Rawness {\n+        if is_raw {\n+            Rawness::RawPtr\n+        } else {\n+            Rawness::Ref\n+        }\n+    }\n+}\n+\n /// Compare ty::Ty\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum TypeRef {"}, {"sha": "660bdfe3365b2f20182ede8f1c4abd356e049669", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -37,6 +37,11 @@ impl Name {\n         Name(Repr::TupleField(idx))\n     }\n \n+    pub fn new_lifetime(lt: &ra_syntax::SyntaxToken) -> Name {\n+        assert!(lt.kind() == ra_syntax::SyntaxKind::LIFETIME);\n+        Name(Repr::Text(lt.text().clone()))\n+    }\n+\n     /// Shortcut to create inline plain text name\n     const fn new_inline_ascii(text: &[u8]) -> Name {\n         Name::new_text(SmolStr::new_inline_from_ascii(text.len(), text))\n@@ -148,6 +153,7 @@ pub mod known {\n         str,\n         // Special names\n         macro_rules,\n+        doc,\n         // Components of known path (value or mod name)\n         std,\n         core,"}, {"sha": "04c0260046bc21851704d61865f592d52cef5164", "filename": "crates/ra_hir_expand/src/proc_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fproc_macro.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -25,7 +25,7 @@ impl ProcMacroExpander {\n     }\n \n     pub fn expand(\n-        &self,\n+        self,\n         db: &dyn AstDatabase,\n         _id: LazyMacroId,\n         tt: &tt::Subtree,"}, {"sha": "4b8dcdc07ff55a8f5b88127702ca0a3b1d5a7fb0", "filename": "crates/ra_hir_ty/Cargo.toml", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2FCargo.toml?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -27,9 +27,8 @@ test_utils = { path = \"../test_utils\" }\n \n scoped-tls = \"1\"\n \n-chalk-solve =   { git = \"https://github.com/rust-lang/chalk.git\", rev = \"eaab84b394007d1bed15f5470409a6ea02900a96\" }\n-chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"eaab84b394007d1bed15f5470409a6ea02900a96\" }\n-chalk-ir =      { git = \"https://github.com/rust-lang/chalk.git\", rev = \"eaab84b394007d1bed15f5470409a6ea02900a96\" }\n+chalk-solve =   { git = \"https://github.com/rust-lang/chalk.git\", rev = \"329b7f3fdd2431ed6f6778cde53f22374c7d094c\" }\n+chalk-ir =      { git = \"https://github.com/rust-lang/chalk.git\", rev = \"329b7f3fdd2431ed6f6778cde53f22374c7d094c\" }\n \n [dev-dependencies]\n insta = \"0.16.0\""}, {"sha": "0a8bb24ac2394e7d64248294ff847cd40acad6c5", "filename": "crates/ra_hir_ty/src/db.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -76,6 +76,8 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::interned]\n     fn intern_type_ctor(&self, type_ctor: TypeCtor) -> crate::TypeCtorId;\n     #[salsa::interned]\n+    fn intern_callable_def(&self, callable_def: CallableDef) -> crate::CallableDefId;\n+    #[salsa::interned]\n     fn intern_type_param_id(&self, param_id: TypeParamId) -> GlobalTypeParamId;\n     #[salsa::interned]\n     fn intern_chalk_impl(&self, impl_: Impl) -> crate::traits::GlobalImplId;\n@@ -94,6 +96,9 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::traits::chalk::impl_datum_query)]\n     fn impl_datum(&self, krate: CrateId, impl_id: chalk::ImplId) -> Arc<chalk::ImplDatum>;\n \n+    #[salsa::invoke(crate::traits::chalk::fn_def_datum_query)]\n+    fn fn_def_datum(&self, krate: CrateId, fn_def_id: chalk::FnDefId) -> Arc<chalk::FnDefDatum>;\n+\n     #[salsa::invoke(crate::traits::chalk::associated_ty_value_query)]\n     fn associated_ty_value(\n         &self,"}, {"sha": "2c7298714d8d291d6238d101a0f2d173477cf1ab", "filename": "crates/ra_hir_ty/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -40,7 +40,7 @@ impl Diagnostic for MissingFields {\n     fn message(&self) -> String {\n         let mut buf = String::from(\"Missing structure fields:\\n\");\n         for field in &self.missed_fields {\n-            format_to!(buf, \"- {}\", field);\n+            format_to!(buf, \"- {}\\n\", field);\n         }\n         buf\n     }\n@@ -73,7 +73,7 @@ impl Diagnostic for MissingPatFields {\n     fn message(&self) -> String {\n         let mut buf = String::from(\"Missing structure fields:\\n\");\n         for field in &self.missed_fields {\n-            format_to!(buf, \"- {}\", field);\n+            format_to!(buf, \"- {}\\n\", field);\n         }\n         buf\n     }"}, {"sha": "dc77e88e50b2a25af823373efc19bc55e23f59f2", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -219,6 +219,17 @@ struct InferenceContext<'a> {\n struct BreakableContext {\n     pub may_break: bool,\n     pub break_ty: Ty,\n+    pub label: Option<name::Name>,\n+}\n+\n+fn find_breakable<'c>(\n+    ctxs: &'c mut [BreakableContext],\n+    label: Option<&name::Name>,\n+) -> Option<&'c mut BreakableContext> {\n+    match label {\n+        Some(_) => ctxs.iter_mut().rev().find(|ctx| ctx.label.as_ref() == label),\n+        None => ctxs.last_mut(),\n+    }\n }\n \n impl<'a> InferenceContext<'a> {"}, {"sha": "32c7c57cd61a3be0561d59436b391eb6fda0ec77", "filename": "crates/ra_hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -45,9 +45,7 @@ impl<'a> InferenceContext<'a> {\n                 self.coerce_merge_branch(&ptr_ty1, &ptr_ty2)\n             } else {\n                 mark::hit!(coerce_merge_fail_fallback);\n-                // For incompatible types, we use the latter one as result\n-                // to be better recovery for `if` without `else`.\n-                ty2.clone()\n+                ty1.clone()\n             }\n         }\n     }"}, {"sha": "4a98e2debff5f2d3b9345ac62338979f020d1e1c", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 63, "deletions": 35, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -17,13 +17,13 @@ use crate::{\n     autoderef, method_resolution, op,\n     traits::InEnvironment,\n     utils::{generics, variant_data, Generics},\n-    ApplicationTy, Binders, CallableDef, InferTy, IntTy, Mutability, Obligation, Substs, TraitRef,\n-    Ty, TypeCtor, Uncertain,\n+    ApplicationTy, Binders, CallableDef, InferTy, IntTy, Mutability, Obligation, Rawness, Substs,\n+    TraitRef, Ty, TypeCtor, Uncertain,\n };\n \n use super::{\n-    BindingMode, BreakableContext, Diverges, Expectation, InferenceContext, InferenceDiagnostic,\n-    TypeMismatch,\n+    find_breakable, BindingMode, BreakableContext, Diverges, Expectation, InferenceContext,\n+    InferenceDiagnostic, TypeMismatch,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -86,16 +86,20 @@ impl<'a> InferenceContext<'a> {\n \n                 self.coerce_merge_branch(&then_ty, &else_ty)\n             }\n-            Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected),\n+            Expr::Block { statements, tail, .. } => {\n+                // FIXME: Breakable block inference\n+                self.infer_block(statements, *tail, expected)\n+            }\n             Expr::TryBlock { body } => {\n                 let _inner = self.infer_expr(*body, expected);\n                 // FIXME should be std::result::Result<{inner}, _>\n                 Ty::Unknown\n             }\n-            Expr::Loop { body } => {\n+            Expr::Loop { body, label } => {\n                 self.breakables.push(BreakableContext {\n                     may_break: false,\n                     break_ty: self.table.new_type_var(),\n+                    label: label.clone(),\n                 });\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n \n@@ -110,8 +114,12 @@ impl<'a> InferenceContext<'a> {\n                     Ty::simple(TypeCtor::Never)\n                 }\n             }\n-            Expr::While { condition, body } => {\n-                self.breakables.push(BreakableContext { may_break: false, break_ty: Ty::Unknown });\n+            Expr::While { condition, body, label } => {\n+                self.breakables.push(BreakableContext {\n+                    may_break: false,\n+                    break_ty: Ty::Unknown,\n+                    label: label.clone(),\n+                });\n                 // while let is desugared to a match loop, so this is always simple while\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n@@ -120,10 +128,14 @@ impl<'a> InferenceContext<'a> {\n                 self.diverges = Diverges::Maybe;\n                 Ty::unit()\n             }\n-            Expr::For { iterable, body, pat } => {\n+            Expr::For { iterable, body, pat, label } => {\n                 let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n \n-                self.breakables.push(BreakableContext { may_break: false, break_ty: Ty::Unknown });\n+                self.breakables.push(BreakableContext {\n+                    may_break: false,\n+                    break_ty: Ty::Unknown,\n+                    label: label.clone(),\n+                });\n                 let pat_ty =\n                     self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n \n@@ -140,13 +152,13 @@ impl<'a> InferenceContext<'a> {\n \n                 let mut sig_tys = Vec::new();\n \n-                for (arg_pat, arg_type) in args.iter().zip(arg_types.iter()) {\n-                    let expected = if let Some(type_ref) = arg_type {\n+                // collect explicitly written argument types\n+                for arg_type in arg_types.iter() {\n+                    let arg_ty = if let Some(type_ref) = arg_type {\n                         self.make_ty(type_ref)\n                     } else {\n-                        Ty::Unknown\n+                        self.table.new_type_var()\n                     };\n-                    let arg_ty = self.infer_pat(*arg_pat, &expected, BindingMode::default());\n                     sig_tys.push(arg_ty);\n                 }\n \n@@ -158,7 +170,7 @@ impl<'a> InferenceContext<'a> {\n                 sig_tys.push(ret_ty.clone());\n                 let sig_ty = Ty::apply(\n                     TypeCtor::FnPtr { num_args: sig_tys.len() as u16 - 1 },\n-                    Substs(sig_tys.into()),\n+                    Substs(sig_tys.clone().into()),\n                 );\n                 let closure_ty =\n                     Ty::apply_one(TypeCtor::Closure { def: self.owner, expr: tgt_expr }, sig_ty);\n@@ -168,6 +180,12 @@ impl<'a> InferenceContext<'a> {\n                 // infer the body.\n                 self.coerce(&closure_ty, &expected.ty);\n \n+                // Now go through the argument patterns\n+                for (arg_pat, arg_ty) in args.iter().zip(sig_tys) {\n+                    let resolved = self.resolve_ty_as_possible(arg_ty);\n+                    self.infer_pat(*arg_pat, &resolved, BindingMode::default());\n+                }\n+\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n \n@@ -230,23 +248,24 @@ impl<'a> InferenceContext<'a> {\n                 let resolver = resolver_for_expr(self.db.upcast(), self.owner, tgt_expr);\n                 self.infer_path(&resolver, p, tgt_expr.into()).unwrap_or(Ty::Unknown)\n             }\n-            Expr::Continue => Ty::simple(TypeCtor::Never),\n-            Expr::Break { expr } => {\n+            Expr::Continue { .. } => Ty::simple(TypeCtor::Never),\n+            Expr::Break { expr, label } => {\n                 let val_ty = if let Some(expr) = expr {\n                     self.infer_expr(*expr, &Expectation::none())\n                 } else {\n                     Ty::unit()\n                 };\n \n-                let last_ty = if let Some(ctxt) = self.breakables.last() {\n-                    ctxt.break_ty.clone()\n-                } else {\n-                    Ty::Unknown\n-                };\n+                let last_ty =\n+                    if let Some(ctxt) = find_breakable(&mut self.breakables, label.as_ref()) {\n+                        ctxt.break_ty.clone()\n+                    } else {\n+                        Ty::Unknown\n+                    };\n \n                 let merged_type = self.coerce_merge_branch(&last_ty, &val_ty);\n \n-                if let Some(ctxt) = self.breakables.last_mut() {\n+                if let Some(ctxt) = find_breakable(&mut self.breakables, label.as_ref()) {\n                     ctxt.break_ty = merged_type;\n                     ctxt.may_break = true;\n                 } else {\n@@ -350,19 +369,28 @@ impl<'a> InferenceContext<'a> {\n                 // FIXME check the cast...\n                 cast_ty\n             }\n-            Expr::Ref { expr, mutability } => {\n-                let expectation =\n-                    if let Some((exp_inner, exp_mutability)) = &expected.ty.as_reference() {\n-                        if *exp_mutability == Mutability::Mut && *mutability == Mutability::Shared {\n-                            // FIXME: throw type error - expected mut reference but found shared ref,\n-                            // which cannot be coerced\n-                        }\n-                        Expectation::rvalue_hint(Ty::clone(exp_inner))\n-                    } else {\n-                        Expectation::none()\n-                    };\n+            Expr::Ref { expr, rawness, mutability } => {\n+                let expectation = if let Some((exp_inner, exp_rawness, exp_mutability)) =\n+                    &expected.ty.as_reference_or_ptr()\n+                {\n+                    if *exp_mutability == Mutability::Mut && *mutability == Mutability::Shared {\n+                        // FIXME: throw type error - expected mut reference but found shared ref,\n+                        // which cannot be coerced\n+                    }\n+                    if *exp_rawness == Rawness::Ref && *rawness == Rawness::RawPtr {\n+                        // FIXME: throw type error - expected reference but found ptr,\n+                        // which cannot be coerced\n+                    }\n+                    Expectation::rvalue_hint(Ty::clone(exp_inner))\n+                } else {\n+                    Expectation::none()\n+                };\n                 let inner_ty = self.infer_expr_inner(*expr, &expectation);\n-                Ty::apply_one(TypeCtor::Ref(*mutability), inner_ty)\n+                let ty = match rawness {\n+                    Rawness::RawPtr => TypeCtor::RawPtr(*mutability),\n+                    Rawness::Ref => TypeCtor::Ref(*mutability),\n+                };\n+                Ty::apply_one(ty, inner_ty)\n             }\n             Expr::Box { expr } => {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());"}, {"sha": "9fa8d3bdc3f4c6edf46fff61ac7e0868bdebbe32", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -49,8 +49,10 @@ use std::sync::Arc;\n use std::{iter, mem};\n \n use hir_def::{\n-    expr::ExprId, type_ref::Mutability, AdtId, AssocContainerId, DefWithBodyId, GenericDefId,\n-    HasModule, Lookup, TraitId, TypeAliasId, TypeParamId,\n+    expr::ExprId,\n+    type_ref::{Mutability, Rawness},\n+    AdtId, AssocContainerId, DefWithBodyId, GenericDefId, HasModule, Lookup, TraitId, TypeAliasId,\n+    TypeParamId,\n };\n use ra_db::{impl_intern_key, salsa, CrateId};\n \n@@ -159,6 +161,12 @@ pub enum TypeCtor {\n pub struct TypeCtorId(salsa::InternId);\n impl_intern_key!(TypeCtorId);\n \n+/// This exists just for Chalk, because Chalk just has a single `FnDefId` where\n+/// we have different IDs for struct and enum variant constructors.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd)]\n+pub struct CallableDefId(salsa::InternId);\n+impl_intern_key!(CallableDefId);\n+\n impl TypeCtor {\n     pub fn num_ty_params(self, db: &dyn HirDatabase) -> usize {\n         match self {\n@@ -703,6 +711,18 @@ impl Ty {\n         }\n     }\n \n+    pub fn as_reference_or_ptr(&self) -> Option<(&Ty, Rawness, Mutability)> {\n+        match self {\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Ref(mutability), parameters }) => {\n+                Some((parameters.as_single(), Rawness::Ref, *mutability))\n+            }\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::RawPtr(mutability), parameters }) => {\n+                Some((parameters.as_single(), Rawness::RawPtr, *mutability))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     pub fn strip_references(&self) -> &Ty {\n         let mut t: &Ty = self;\n "}, {"sha": "6f777ed8c937e5c2b10ffa9bab1a56643fcdbecf", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -116,15 +116,20 @@ fn infer_let_stmt_coerce() {\n     assert_snapshot!(\n         infer(r#\"\n fn test() {\n-    let x: &[i32] = &[1];\n+    let x: &[isize] = &[1];\n+    let x: *const [isize] = &[1];\n }\n \"#),\n         @r###\"\n-    11..40 '{     ...[1]; }': ()\n-    21..22 'x': &[i32]\n-    33..37 '&[1]': &[i32; _]\n-    34..37 '[1]': [i32; _]\n-    35..36 '1': i32\n+    11..76 '{     ...[1]; }': ()\n+    21..22 'x': &[isize]\n+    35..39 '&[1]': &[isize; _]\n+    36..39 '[1]': [isize; _]\n+    37..38 '1': isize\n+    49..50 'x': *const [isize]\n+    69..73 '&[1]': &[isize; _]\n+    70..73 '[1]': [isize; _]\n+    71..72 '1': isize\n     \"###);\n }\n "}, {"sha": "fe62587c0d7014595bb83b5f4dc9df81faecd7f3", "filename": "crates/ra_hir_ty/src/tests/patterns.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -520,3 +520,53 @@ fn main() {\n         105..107 '()': ()\n     \")\n }\n+\n+#[test]\n+fn match_ergonomics_in_closure_params() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang = \"fn_once\"]\n+trait FnOnce<Args> {\n+    type Output;\n+}\n+\n+fn foo<T, U, F: FnOnce(T) -> U>(t: T, f: F) -> U { loop {} }\n+\n+fn test() {\n+    foo(&(1, \"a\"), |&(x, y)| x); // normal, no match ergonomics\n+    foo(&(1, \"a\"), |(x, y)| x);\n+}\n+\"#),\n+        @r###\"\n+    94..95 't': T\n+    100..101 'f': F\n+    111..122 '{ loop {} }': U\n+    113..120 'loop {}': !\n+    118..120 '{}': ()\n+    134..233 '{     ... x); }': ()\n+    140..143 'foo': fn foo<&(i32, &str), i32, |&(i32, &str)| -> i32>(&(i32, &str), |&(i32, &str)| -> i32) -> i32\n+    140..167 'foo(&(...y)| x)': i32\n+    144..153 '&(1, \"a\")': &(i32, &str)\n+    145..153 '(1, \"a\")': (i32, &str)\n+    146..147 '1': i32\n+    149..152 '\"a\"': &str\n+    155..166 '|&(x, y)| x': |&(i32, &str)| -> i32\n+    156..163 '&(x, y)': &(i32, &str)\n+    157..163 '(x, y)': (i32, &str)\n+    158..159 'x': i32\n+    161..162 'y': &str\n+    165..166 'x': i32\n+    204..207 'foo': fn foo<&(i32, &str), &i32, |&(i32, &str)| -> &i32>(&(i32, &str), |&(i32, &str)| -> &i32) -> &i32\n+    204..230 'foo(&(...y)| x)': &i32\n+    208..217 '&(1, \"a\")': &(i32, &str)\n+    209..217 '(1, \"a\")': (i32, &str)\n+    210..211 '1': i32\n+    213..216 '\"a\"': &str\n+    219..229 '|(x, y)| x': |&(i32, &str)| -> &i32\n+    220..226 '(x, y)': (i32, &str)\n+    221..222 'x': &i32\n+    224..225 'y': &&str\n+    228..229 'x': &i32\n+    \"###\n+    );\n+}"}, {"sha": "88309157b78c08711f39197498c4a4aceda60d65", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -384,6 +384,26 @@ fn test(a: &u32, b: &mut u32, c: *const u32, d: *mut u32) {\n     );\n }\n \n+#[test]\n+fn infer_raw_ref() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test(a: i32) {\n+    &raw mut a;\n+    &raw const a;\n+}\n+\"#),\n+        @r###\"\n+    9..10 'a': i32\n+    17..54 '{     ...t a; }': ()\n+    23..33 '&raw mut a': *mut i32\n+    32..33 'a': i32\n+    39..51 '&raw const a': *const i32\n+    50..51 'a': i32\n+    \"###\n+    );\n+}\n+\n #[test]\n fn infer_literals() {\n     assert_snapshot!(\n@@ -937,7 +957,7 @@ fn main(foo: Foo) {\n     51..107 'if tru...     }': ()\n     54..58 'true': bool\n     59..67 '{      }': ()\n-    73..107 'if fal...     }': ()\n+    73..107 'if fal...     }': i32\n     76..81 'false': bool\n     82..107 '{     ...     }': i32\n     92..95 'foo': Foo\n@@ -1923,3 +1943,57 @@ fn test() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn infer_labelled_break_with_val() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn foo() {\n+    let _x = || 'outer: loop {\n+        let inner = 'inner: loop {\n+            let i = Default::default();\n+            if (break 'outer i) {\n+                loop { break 'inner 5i8; };\n+            } else if true {\n+                break 'inner 6;\n+            }\n+            break 7;\n+        };\n+        break inner < 8;\n+    };\n+}\n+\"#),\n+        @r###\"\n+    10..336 '{     ...  }; }': ()\n+    20..22 '_x': || -> bool\n+    25..333 '|| 'ou...     }': || -> bool\n+    28..333 ''outer...     }': bool\n+    41..333 '{     ...     }': ()\n+    55..60 'inner': i8\n+    63..301 ''inner...     }': i8\n+    76..301 '{     ...     }': ()\n+    94..95 'i': bool\n+    98..114 'Defaul...efault': {unknown}\n+    98..116 'Defaul...ault()': bool\n+    130..270 'if (br...     }': ()\n+    134..148 'break 'outer i': !\n+    147..148 'i': bool\n+    150..209 '{     ...     }': ()\n+    168..194 'loop {...5i8; }': !\n+    173..194 '{ brea...5i8; }': ()\n+    175..191 'break ...er 5i8': !\n+    188..191 '5i8': i8\n+    215..270 'if tru...     }': ()\n+    218..222 'true': bool\n+    223..270 '{     ...     }': ()\n+    241..255 'break 'inner 6': !\n+    254..255 '6': i8\n+    283..290 'break 7': !\n+    289..290 '7': i8\n+    311..326 'break inner < 8': !\n+    317..322 'inner': i8\n+    317..326 'inner < 8': bool\n+    325..326 '8': i8\n+    \"###\n+    );\n+}"}, {"sha": "e8778d419be7decf44b3143cde09bc02ee9d49a4", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -2643,6 +2643,79 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn builtin_fn_def_copy() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+fn foo() {}\n+fn bar<T: Copy>(T) -> T {}\n+struct Struct(usize);\n+enum Enum { Variant(usize) }\n+\n+trait Test { fn test(&self) -> bool; }\n+impl<T: Copy> Test for T {}\n+\n+fn test() {\n+    foo.test();\n+    bar.test();\n+    Struct.test();\n+    Enum::Variant.test();\n+}\n+\"#, true),\n+        @r###\"\n+    42..44 '{}': ()\n+    61..62 'T': {unknown}\n+    69..71 '{}': ()\n+    69..71: expected T, got ()\n+    146..150 'self': &Self\n+    202..282 '{     ...t(); }': ()\n+    208..211 'foo': fn foo()\n+    208..218 'foo.test()': bool\n+    224..227 'bar': fn bar<{unknown}>({unknown}) -> {unknown}\n+    224..234 'bar.test()': bool\n+    240..246 'Struct': Struct(usize) -> Struct\n+    240..253 'Struct.test()': bool\n+    259..272 'Enum::Variant': Variant(usize) -> Enum\n+    259..279 'Enum::...test()': bool\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn builtin_fn_ptr_copy() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+trait Test { fn test(&self) -> bool; }\n+impl<T: Copy> Test for T {}\n+\n+fn test(f1: fn(), f2: fn(usize) -> u8, f3: fn(u8, u8) -> &u8) {\n+    f1.test();\n+    f2.test();\n+    f3.test();\n+}\n+\"#, true),\n+        @r###\"\n+    55..59 'self': &Self\n+    109..111 'f1': fn()\n+    119..121 'f2': fn(usize) -> u8\n+    140..142 'f3': fn(u8, u8) -> &u8\n+    163..211 '{     ...t(); }': ()\n+    169..171 'f1': fn()\n+    169..178 'f1.test()': bool\n+    184..186 'f2': fn(usize) -> u8\n+    184..193 'f2.test()': bool\n+    199..201 'f3': fn(u8, u8) -> &u8\n+    199..208 'f3.test()': bool\n+    \"###\n+    );\n+}\n+\n #[test]\n fn builtin_sized() {\n     assert_snapshot!(\n@@ -2680,3 +2753,48 @@ fn test() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn integer_range_iterate() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+fn test() {\n+    for x in 0..100 { x<|>; }\n+}\n+\n+//- /std.rs crate:std\n+pub mod ops {\n+    pub struct Range<Idx> {\n+        pub start: Idx,\n+        pub end: Idx,\n+    }\n+}\n+\n+pub mod iter {\n+    pub trait Iterator {\n+        type Item;\n+    }\n+\n+    pub trait IntoIterator {\n+        type Item;\n+        type IntoIter: Iterator<Item = Self::Item>;\n+    }\n+\n+    impl<T> IntoIterator for T where T: Iterator {\n+        type Item = <T as Iterator>::Item;\n+        type IntoIter = Self;\n+    }\n+}\n+\n+trait Step {}\n+impl Step for i32 {}\n+impl Step for i64 {}\n+\n+impl<A: Step> iter::Iterator for ops::Range<A> {\n+    type Item = A;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"i32\");\n+}"}, {"sha": "88a422d2cb48cda6a86107aae7963cb0be054e52", "filename": "crates/ra_hir_ty/src/traits/builtin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -290,8 +290,7 @@ fn trait_object_unsize_impl_datum(\n     let self_trait_ref = TraitRef { trait_, substs: self_substs };\n     let where_clauses = vec![GenericPredicate::Implemented(self_trait_ref)];\n \n-    let impl_substs =\n-        Substs::builder(2).push(self_ty).push(Ty::Dyn(target_bounds.clone().into())).build();\n+    let impl_substs = Substs::builder(2).push(self_ty).push(Ty::Dyn(target_bounds.into())).build();\n \n     let trait_ref = TraitRef { trait_: unsize_trait, substs: impl_substs };\n "}, {"sha": "61de3cc30c66fcb4870b035e4d0df62586cb0397", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 59, "deletions": 28, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -4,6 +4,7 @@ use std::sync::Arc;\n use log::debug;\n \n use chalk_ir::{fold::shift::Shift, GenericArg, TypeName};\n+use chalk_solve::rust_ir::{self, WellKnownTrait};\n \n use hir_def::{\n     lang_item::{lang_attr, LangItemTarget},\n@@ -14,9 +15,8 @@ use ra_db::{salsa::InternKey, CrateId};\n use super::{builtin, AssocTyValue, ChalkContext, Impl};\n use crate::{\n     db::HirDatabase, display::HirDisplay, method_resolution::TyFingerprint, utils::generics,\n-    DebruijnIndex, GenericPredicate, Substs, Ty, TypeCtor,\n+    CallableDef, DebruijnIndex, GenericPredicate, Substs, Ty, TypeCtor,\n };\n-use chalk_rust_ir::WellKnownTrait;\n use mapping::{convert_where_clauses, generic_predicate_to_inline_bound, make_binders};\n \n pub use self::interner::*;\n@@ -54,10 +54,9 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n \n     fn fn_def_datum(\n         &self,\n-        _fn_def_id: chalk_ir::FnDefId<Interner>,\n-    ) -> Arc<chalk_rust_ir::FnDefDatum<Interner>> {\n-        // We don't yet provide any FnDefs to Chalk\n-        unimplemented!()\n+        fn_def_id: chalk_ir::FnDefId<Interner>,\n+    ) -> Arc<rust_ir::FnDefDatum<Interner>> {\n+        self.db.fn_def_datum(self.krate, fn_def_id)\n     }\n \n     fn impls_for_trait(\n@@ -113,7 +112,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     }\n     fn well_known_trait_id(\n         &self,\n-        well_known_trait: chalk_rust_ir::WellKnownTrait,\n+        well_known_trait: rust_ir::WellKnownTrait,\n     ) -> Option<chalk_ir::TraitId<Interner>> {\n         let lang_attr = lang_attr_from_well_known_trait(well_known_trait);\n         let lang_items = self.db.crate_lang_items(self.krate);\n@@ -134,13 +133,13 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     fn opaque_ty_data(\n         &self,\n         _id: chalk_ir::OpaqueTyId<Interner>,\n-    ) -> Arc<chalk_rust_ir::OpaqueTyDatum<Interner>> {\n+    ) -> Arc<rust_ir::OpaqueTyDatum<Interner>> {\n         unimplemented!()\n     }\n \n     fn force_impl_for(\n         &self,\n-        _well_known: chalk_rust_ir::WellKnownTrait,\n+        _well_known: rust_ir::WellKnownTrait,\n         _ty: &chalk_ir::TyData<Interner>,\n     ) -> Option<bool> {\n         // this method is mostly for rustc\n@@ -151,6 +150,10 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         // FIXME: implement actual object safety\n         true\n     }\n+\n+    fn hidden_opaque_type(&self, _id: chalk_ir::OpaqueTyId<Interner>) -> chalk_ir::Ty<Interner> {\n+        Ty::Unknown.to_chalk(self.db)\n+    }\n }\n \n pub(crate) fn program_clauses_for_chalk_env_query(\n@@ -189,7 +192,7 @@ pub(crate) fn associated_ty_data_query(\n         .collect();\n \n     let where_clauses = convert_where_clauses(db, type_alias.into(), &bound_vars);\n-    let bound_data = chalk_rust_ir::AssociatedTyDatumBound { bounds, where_clauses };\n+    let bound_data = rust_ir::AssociatedTyDatumBound { bounds, where_clauses };\n     let datum = AssociatedTyDatum {\n         trait_id: trait_.to_chalk(db),\n         id,\n@@ -210,7 +213,7 @@ pub(crate) fn trait_datum_query(\n     debug!(\"trait {:?} = {:?}\", trait_id, trait_data.name);\n     let generic_params = generics(db.upcast(), trait_.into());\n     let bound_vars = Substs::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n-    let flags = chalk_rust_ir::TraitFlags {\n+    let flags = rust_ir::TraitFlags {\n         auto: trait_data.auto,\n         upstream: trait_.lookup(db.upcast()).container.module(db.upcast()).krate != krate,\n         non_enumerable: true,\n@@ -222,7 +225,7 @@ pub(crate) fn trait_datum_query(\n     let where_clauses = convert_where_clauses(db, trait_.into(), &bound_vars);\n     let associated_ty_ids =\n         trait_data.associated_types().map(|type_alias| type_alias.to_chalk(db)).collect();\n-    let trait_datum_bound = chalk_rust_ir::TraitDatumBound { where_clauses };\n+    let trait_datum_bound = rust_ir::TraitDatumBound { where_clauses };\n     let well_known =\n         lang_attr(db.upcast(), trait_).and_then(|name| well_known_trait_from_lang_attr(&name));\n     let trait_datum = TraitDatum {\n@@ -272,12 +275,12 @@ pub(crate) fn struct_datum_query(\n             convert_where_clauses(db, generic_def, &bound_vars)\n         })\n         .unwrap_or_else(Vec::new);\n-    let flags = chalk_rust_ir::AdtFlags {\n+    let flags = rust_ir::AdtFlags {\n         upstream,\n         // FIXME set fundamental flag correctly\n         fundamental: false,\n     };\n-    let struct_datum_bound = chalk_rust_ir::AdtDatumBound {\n+    let struct_datum_bound = rust_ir::AdtDatumBound {\n         fields: Vec::new(), // FIXME add fields (only relevant for auto traits)\n         where_clauses,\n     };\n@@ -317,9 +320,9 @@ fn impl_def_datum(\n     let bound_vars = Substs::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n     let trait_ = trait_ref.trait_;\n     let impl_type = if impl_id.lookup(db.upcast()).container.module(db.upcast()).krate == krate {\n-        chalk_rust_ir::ImplType::Local\n+        rust_ir::ImplType::Local\n     } else {\n-        chalk_rust_ir::ImplType::External\n+        rust_ir::ImplType::External\n     };\n     let where_clauses = convert_where_clauses(db, impl_id.into(), &bound_vars);\n     let negative = impl_data.is_negative;\n@@ -332,13 +335,9 @@ fn impl_def_datum(\n     );\n     let trait_ref = trait_ref.to_chalk(db);\n \n-    let polarity = if negative {\n-        chalk_rust_ir::Polarity::Negative\n-    } else {\n-        chalk_rust_ir::Polarity::Positive\n-    };\n+    let polarity = if negative { rust_ir::Polarity::Negative } else { rust_ir::Polarity::Positive };\n \n-    let impl_datum_bound = chalk_rust_ir::ImplDatumBound { trait_ref, where_clauses };\n+    let impl_datum_bound = rust_ir::ImplDatumBound { trait_ref, where_clauses };\n     let trait_data = db.trait_data(trait_);\n     let associated_ty_value_ids = impl_data\n         .items\n@@ -396,15 +395,35 @@ fn type_alias_associated_ty_value(\n         .associated_type_by_name(&type_alias_data.name)\n         .expect(\"assoc ty value should not exist\"); // validated when building the impl data as well\n     let ty = db.ty(type_alias.into());\n-    let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: ty.value.to_chalk(db) };\n-    let value = chalk_rust_ir::AssociatedTyValue {\n+    let value_bound = rust_ir::AssociatedTyValueBound { ty: ty.value.to_chalk(db) };\n+    let value = rust_ir::AssociatedTyValue {\n         impl_id: Impl::ImplDef(impl_id).to_chalk(db),\n         associated_ty_id: assoc_ty.to_chalk(db),\n         value: make_binders(value_bound, ty.num_binders),\n     };\n     Arc::new(value)\n }\n \n+pub(crate) fn fn_def_datum_query(\n+    db: &dyn HirDatabase,\n+    _krate: CrateId,\n+    fn_def_id: FnDefId,\n+) -> Arc<FnDefDatum> {\n+    let callable_def: CallableDef = from_chalk(db, fn_def_id);\n+    let generic_params = generics(db.upcast(), callable_def.into());\n+    let sig = db.callable_item_signature(callable_def);\n+    let bound_vars = Substs::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n+    let where_clauses = convert_where_clauses(db, callable_def.into(), &bound_vars);\n+    let bound = rust_ir::FnDefDatumBound {\n+        // Note: Chalk doesn't actually use this information yet as far as I am aware, but we provide it anyway\n+        argument_types: sig.value.params().iter().map(|ty| ty.clone().to_chalk(db)).collect(),\n+        return_type: sig.value.ret().clone().to_chalk(db),\n+        where_clauses,\n+    };\n+    let datum = FnDefDatum { id: fn_def_id, binders: make_binders(bound, sig.num_binders) };\n+    Arc::new(datum)\n+}\n+\n impl From<AdtId> for crate::TypeCtorId {\n     fn from(struct_id: AdtId) -> Self {\n         struct_id.0\n@@ -417,6 +436,18 @@ impl From<crate::TypeCtorId> for AdtId {\n     }\n }\n \n+impl From<FnDefId> for crate::CallableDefId {\n+    fn from(fn_def_id: FnDefId) -> Self {\n+        InternKey::from_intern_id(fn_def_id.0)\n+    }\n+}\n+\n+impl From<crate::CallableDefId> for FnDefId {\n+    fn from(callable_def_id: crate::CallableDefId) -> Self {\n+        chalk_ir::FnDefId(callable_def_id.as_intern_id())\n+    }\n+}\n+\n impl From<ImplId> for crate::traits::GlobalImplId {\n     fn from(impl_id: ImplId) -> Self {\n         InternKey::from_intern_id(impl_id.0)\n@@ -429,14 +460,14 @@ impl From<crate::traits::GlobalImplId> for ImplId {\n     }\n }\n \n-impl From<chalk_rust_ir::AssociatedTyValueId<Interner>> for crate::traits::AssocTyValueId {\n-    fn from(id: chalk_rust_ir::AssociatedTyValueId<Interner>) -> Self {\n+impl From<rust_ir::AssociatedTyValueId<Interner>> for crate::traits::AssocTyValueId {\n+    fn from(id: rust_ir::AssociatedTyValueId<Interner>) -> Self {\n         Self::from_intern_id(id.0)\n     }\n }\n \n-impl From<crate::traits::AssocTyValueId> for chalk_rust_ir::AssociatedTyValueId<Interner> {\n+impl From<crate::traits::AssocTyValueId> for rust_ir::AssociatedTyValueId<Interner> {\n     fn from(assoc_ty_value_id: crate::traits::AssocTyValueId) -> Self {\n-        chalk_rust_ir::AssociatedTyValueId(assoc_ty_value_id.as_intern_id())\n+        rust_ir::AssociatedTyValueId(assoc_ty_value_id.as_intern_id())\n     }\n }"}, {"sha": "e27074ba6fad0cb1c592fda8cd233c331b80af48", "filename": "crates/ra_hir_ty/src/traits/chalk/interner.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -11,15 +11,17 @@ use std::{fmt, sync::Arc};\n pub struct Interner;\n \n pub type AssocTypeId = chalk_ir::AssocTypeId<Interner>;\n-pub type AssociatedTyDatum = chalk_rust_ir::AssociatedTyDatum<Interner>;\n+pub type AssociatedTyDatum = chalk_solve::rust_ir::AssociatedTyDatum<Interner>;\n pub type TraitId = chalk_ir::TraitId<Interner>;\n-pub type TraitDatum = chalk_rust_ir::TraitDatum<Interner>;\n+pub type TraitDatum = chalk_solve::rust_ir::TraitDatum<Interner>;\n pub type AdtId = chalk_ir::AdtId<Interner>;\n-pub type StructDatum = chalk_rust_ir::AdtDatum<Interner>;\n+pub type StructDatum = chalk_solve::rust_ir::AdtDatum<Interner>;\n pub type ImplId = chalk_ir::ImplId<Interner>;\n-pub type ImplDatum = chalk_rust_ir::ImplDatum<Interner>;\n-pub type AssociatedTyValueId = chalk_rust_ir::AssociatedTyValueId<Interner>;\n-pub type AssociatedTyValue = chalk_rust_ir::AssociatedTyValue<Interner>;\n+pub type ImplDatum = chalk_solve::rust_ir::ImplDatum<Interner>;\n+pub type AssociatedTyValueId = chalk_solve::rust_ir::AssociatedTyValueId<Interner>;\n+pub type AssociatedTyValue = chalk_solve::rust_ir::AssociatedTyValue<Interner>;\n+pub type FnDefId = chalk_ir::FnDefId<Interner>;\n+pub type FnDefDatum = chalk_solve::rust_ir::FnDefDatum<Interner>;\n \n impl chalk_ir::interner::Interner for Interner {\n     type InternedType = Box<chalk_ir::TyData<Self>>; // FIXME use Arc?"}, {"sha": "5f6daf842be696c25a34001827380f3ec4536654", "filename": "crates/ra_hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 61, "deletions": 32, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -7,6 +7,7 @@ use chalk_ir::{\n     cast::Cast, fold::shift::Shift, interner::HasInterner, PlaceholderIndex, Scalar, TypeName,\n     UniverseIndex,\n };\n+use chalk_solve::rust_ir;\n \n use hir_def::{type_ref::Mutability, AssocContainerId, GenericDefId, Lookup, TypeAliasId};\n use ra_db::salsa::InternKey;\n@@ -15,8 +16,8 @@ use crate::{\n     db::HirDatabase,\n     primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness, Uncertain},\n     traits::{builtin, AssocTyValue, Canonical, Impl, Obligation},\n-    ApplicationTy, GenericPredicate, InEnvironment, ProjectionPredicate, ProjectionTy, Substs,\n-    TraitEnvironment, TraitRef, Ty, TypeCtor,\n+    ApplicationTy, CallableDef, GenericPredicate, InEnvironment, ProjectionPredicate, ProjectionTy,\n+    Substs, TraitEnvironment, TraitRef, Ty, TypeCtor,\n };\n \n use super::interner::*;\n@@ -26,14 +27,19 @@ impl ToChalk for Ty {\n     type Chalk = chalk_ir::Ty<Interner>;\n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Ty<Interner> {\n         match self {\n-            Ty::Apply(apply_ty) => {\n-                if let TypeCtor::Ref(m) = apply_ty.ctor {\n-                    return ref_to_chalk(db, m, apply_ty.parameters);\n+            Ty::Apply(apply_ty) => match apply_ty.ctor {\n+                TypeCtor::Ref(m) => ref_to_chalk(db, m, apply_ty.parameters),\n+                TypeCtor::FnPtr { num_args: _ } => {\n+                    let substitution = apply_ty.parameters.to_chalk(db).shifted_in(&Interner);\n+                    chalk_ir::TyData::Function(chalk_ir::Fn { num_binders: 0, substitution })\n+                        .intern(&Interner)\n                 }\n-                let name = apply_ty.ctor.to_chalk(db);\n-                let substitution = apply_ty.parameters.to_chalk(db);\n-                chalk_ir::ApplicationTy { name, substitution }.cast(&Interner).intern(&Interner)\n-            }\n+                _ => {\n+                    let name = apply_ty.ctor.to_chalk(db);\n+                    let substitution = apply_ty.parameters.to_chalk(db);\n+                    chalk_ir::ApplicationTy { name, substitution }.cast(&Interner).intern(&Interner)\n+                }\n+            },\n             Ty::Projection(proj_ty) => {\n                 let associated_ty_id = proj_ty.associated_ty.to_chalk(db);\n                 let substitution = proj_ty.parameters.to_chalk(db);\n@@ -93,9 +99,15 @@ impl ToChalk for Ty {\n                 Ty::Projection(ProjectionTy { associated_ty, parameters })\n             }\n             chalk_ir::TyData::Alias(chalk_ir::AliasTy::Opaque(_)) => unimplemented!(),\n-            chalk_ir::TyData::Function(_) => unimplemented!(),\n+            chalk_ir::TyData::Function(chalk_ir::Fn { num_binders: _, substitution }) => {\n+                let parameters: Substs = from_chalk(db, substitution);\n+                Ty::Apply(ApplicationTy {\n+                    ctor: TypeCtor::FnPtr { num_args: (parameters.len() - 1) as u16 },\n+                    parameters,\n+                })\n+            }\n             chalk_ir::TyData::BoundVar(idx) => Ty::Bound(idx),\n-            chalk_ir::TyData::InferenceVar(_iv) => Ty::Unknown,\n+            chalk_ir::TyData::InferenceVar(_iv, _kind) => Ty::Unknown,\n             chalk_ir::TyData::Dyn(where_clauses) => {\n                 assert_eq!(where_clauses.bounds.binders.len(&Interner), 1);\n                 let predicates = where_clauses\n@@ -217,13 +229,17 @@ impl ToChalk for TypeCtor {\n             TypeCtor::Slice => TypeName::Slice,\n             TypeCtor::Ref(mutability) => TypeName::Ref(mutability.to_chalk(db)),\n             TypeCtor::Str => TypeName::Str,\n+            TypeCtor::FnDef(callable_def) => {\n+                let id = callable_def.to_chalk(db);\n+                TypeName::FnDef(id)\n+            }\n+            TypeCtor::Never => TypeName::Never,\n+\n             TypeCtor::Int(Uncertain::Unknown)\n             | TypeCtor::Float(Uncertain::Unknown)\n             | TypeCtor::Adt(_)\n             | TypeCtor::Array\n-            | TypeCtor::FnDef(_)\n             | TypeCtor::FnPtr { .. }\n-            | TypeCtor::Never\n             | TypeCtor::Closure { .. } => {\n                 // other TypeCtors get interned and turned into a chalk StructId\n                 let struct_id = db.intern_type_ctor(self).into();\n@@ -259,10 +275,14 @@ impl ToChalk for TypeCtor {\n             TypeName::Slice => TypeCtor::Slice,\n             TypeName::Ref(mutability) => TypeCtor::Ref(from_chalk(db, mutability)),\n             TypeName::Str => TypeCtor::Str,\n+            TypeName::Never => TypeCtor::Never,\n \n-            TypeName::FnDef(_) => unreachable!(),\n+            TypeName::FnDef(fn_def_id) => {\n+                let callable_def = from_chalk(db, fn_def_id);\n+                TypeCtor::FnDef(callable_def)\n+            }\n \n-            TypeName::Error => {\n+            TypeName::Array | TypeName::Error => {\n                 // this should not be reached, since we don't represent TypeName::Error with TypeCtor\n                 unreachable!()\n             }\n@@ -347,6 +367,18 @@ impl ToChalk for Impl {\n     }\n }\n \n+impl ToChalk for CallableDef {\n+    type Chalk = FnDefId;\n+\n+    fn to_chalk(self, db: &dyn HirDatabase) -> FnDefId {\n+        db.intern_callable_def(self).into()\n+    }\n+\n+    fn from_chalk(db: &dyn HirDatabase, fn_def_id: FnDefId) -> CallableDef {\n+        db.lookup_intern_callable_def(fn_def_id.into())\n+    }\n+}\n+\n impl ToChalk for TypeAliasId {\n     type Chalk = AssocTypeId;\n \n@@ -479,7 +511,7 @@ where\n \n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Canonical<T::Chalk> {\n         let parameter = chalk_ir::CanonicalVarKind::new(\n-            chalk_ir::VariableKind::Ty,\n+            chalk_ir::VariableKind::Ty(chalk_ir::TyKind::General),\n             chalk_ir::UniverseIndex::ROOT,\n         );\n         let value = self.value.to_chalk(db);\n@@ -550,17 +582,17 @@ impl ToChalk for builtin::BuiltinImplData {\n     type Chalk = ImplDatum;\n \n     fn to_chalk(self, db: &dyn HirDatabase) -> ImplDatum {\n-        let impl_type = chalk_rust_ir::ImplType::External;\n+        let impl_type = rust_ir::ImplType::External;\n         let where_clauses = self.where_clauses.into_iter().map(|w| w.to_chalk(db)).collect();\n \n         let impl_datum_bound =\n-            chalk_rust_ir::ImplDatumBound { trait_ref: self.trait_ref.to_chalk(db), where_clauses };\n+            rust_ir::ImplDatumBound { trait_ref: self.trait_ref.to_chalk(db), where_clauses };\n         let associated_ty_value_ids =\n             self.assoc_ty_values.into_iter().map(|v| v.to_chalk(db)).collect();\n-        chalk_rust_ir::ImplDatum {\n+        rust_ir::ImplDatum {\n             binders: make_binders(impl_datum_bound, self.num_vars),\n             impl_type,\n-            polarity: chalk_rust_ir::Polarity::Positive,\n+            polarity: rust_ir::Polarity::Positive,\n             associated_ty_value_ids,\n         }\n     }\n@@ -575,9 +607,9 @@ impl ToChalk for builtin::BuiltinImplAssocTyValueData {\n \n     fn to_chalk(self, db: &dyn HirDatabase) -> AssociatedTyValue {\n         let ty = self.value.to_chalk(db);\n-        let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty };\n+        let value_bound = rust_ir::AssociatedTyValueBound { ty };\n \n-        chalk_rust_ir::AssociatedTyValue {\n+        rust_ir::AssociatedTyValue {\n             associated_ty_id: self.assoc_ty_id.to_chalk(db),\n             impl_id: self.impl_.to_chalk(db),\n             value: make_binders(value_bound, self.num_vars),\n@@ -599,7 +631,7 @@ where\n     chalk_ir::Binders::new(\n         chalk_ir::VariableKinds::from(\n             &Interner,\n-            std::iter::repeat(chalk_ir::VariableKind::Ty).take(num_vars),\n+            std::iter::repeat(chalk_ir::VariableKind::Ty(chalk_ir::TyKind::General)).take(num_vars),\n         ),\n         value,\n     )\n@@ -626,7 +658,7 @@ pub(super) fn generic_predicate_to_inline_bound(\n     db: &dyn HirDatabase,\n     pred: &GenericPredicate,\n     self_ty: &Ty,\n-) -> Option<chalk_rust_ir::InlineBound<Interner>> {\n+) -> Option<rust_ir::InlineBound<Interner>> {\n     // An InlineBound is like a GenericPredicate, except the self type is left out.\n     // We don't have a special type for this, but Chalk does.\n     match pred {\n@@ -641,8 +673,8 @@ pub(super) fn generic_predicate_to_inline_bound(\n                 .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n                 .collect();\n             let trait_bound =\n-                chalk_rust_ir::TraitBound { trait_id: trait_ref.trait_.to_chalk(db), args_no_self };\n-            Some(chalk_rust_ir::InlineBound::TraitBound(trait_bound))\n+                rust_ir::TraitBound { trait_id: trait_ref.trait_.to_chalk(db), args_no_self };\n+            Some(rust_ir::InlineBound::TraitBound(trait_bound))\n         }\n         GenericPredicate::Projection(proj) => {\n             if &proj.projection_ty.parameters[0] != self_ty {\n@@ -656,16 +688,13 @@ pub(super) fn generic_predicate_to_inline_bound(\n                 .iter()\n                 .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n                 .collect();\n-            let alias_eq_bound = chalk_rust_ir::AliasEqBound {\n+            let alias_eq_bound = rust_ir::AliasEqBound {\n                 value: proj.ty.clone().to_chalk(db),\n-                trait_bound: chalk_rust_ir::TraitBound {\n-                    trait_id: trait_.to_chalk(db),\n-                    args_no_self,\n-                },\n+                trait_bound: rust_ir::TraitBound { trait_id: trait_.to_chalk(db), args_no_self },\n                 associated_ty_id: proj.projection_ty.associated_ty.to_chalk(db),\n                 parameters: Vec::new(), // FIXME we don't support generic associated types yet\n             };\n-            Some(chalk_rust_ir::InlineBound::AliasEqBound(alias_eq_bound))\n+            Some(rust_ir::InlineBound::AliasEqBound(alias_eq_bound))\n         }\n         GenericPredicate::Error => None,\n     }"}, {"sha": "d88828c7c0a0ecc9b72c145f45d2d9e21256beba", "filename": "crates/ra_hir_ty/src/traits/chalk/tls.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -247,10 +247,24 @@ impl DebugContext<'_> {\n \n     pub fn debug_fn_def_id(\n         &self,\n-        _fn_def_id: chalk_ir::FnDefId<Interner>,\n+        fn_def_id: chalk_ir::FnDefId<Interner>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Result<(), fmt::Error> {\n-        write!(fmt, \"fn\")\n+        let def: CallableDef = from_chalk(self.0, fn_def_id);\n+        let name = match def {\n+            CallableDef::FunctionId(ff) => self.0.function_data(ff).name.clone(),\n+            CallableDef::StructId(s) => self.0.struct_data(s).name.clone(),\n+            CallableDef::EnumVariantId(e) => {\n+                let enum_data = self.0.enum_data(e.parent);\n+                enum_data.variants[e.local_id].name.clone()\n+            }\n+        };\n+        match def {\n+            CallableDef::FunctionId(_) => write!(fmt, \"{{fn {}}}\", name),\n+            CallableDef::StructId(_) | CallableDef::EnumVariantId(_) => {\n+                write!(fmt, \"{{ctor {}}}\", name)\n+            }\n+        }\n     }\n \n     pub fn debug_const("}, {"sha": "defd8176ff87ddb7dc75ae66e1c7f19340f5322b", "filename": "crates/ra_ide/src/call_hierarchy.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_hierarchy.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -245,6 +245,35 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_call_hierarchy_in_tests_mod() {\n+        check_hierarchy(\n+            r#\"\n+            //- /lib.rs cfg:test\n+            fn callee() {}\n+            fn caller1() {\n+                call<|>ee();\n+            }\n+\n+            #[cfg(test)]\n+            mod tests {\n+                use super::*;\n+\n+                #[test]\n+                fn test_caller() {\n+                    callee();\n+                }\n+            }\n+            \"#,\n+            \"callee FN_DEF FileId(1) 0..14 3..9\",\n+            &[\n+                \"caller1 FN_DEF FileId(1) 15..45 18..25 : [34..40]\",\n+                \"test_caller FN_DEF FileId(1) 93..147 108..119 : [132..138]\",\n+            ],\n+            &[],\n+        );\n+    }\n+\n     #[test]\n     fn test_call_hierarchy_in_different_files() {\n         check_hierarchy("}, {"sha": "a721e23c6934544bacf9c8593bf97f7fe1823779", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 123, "deletions": 2, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n mod completion_config;\n mod completion_item;\n mod completion_context;\n@@ -35,6 +33,51 @@ pub use crate::completion::{\n     completion_item::{CompletionItem, CompletionItemKind, CompletionScore, InsertTextFormat},\n };\n \n+//FIXME: split the following feature into fine-grained features.\n+\n+// Feature: Magic Completions\n+//\n+// In addition to usual reference completion, rust-analyzer provides some \u2728magic\u2728\n+// completions as well:\n+//\n+// Keywords like `if`, `else` `while`, `loop` are completed with braces, and cursor\n+// is placed at the appropriate position. Even though `if` is easy to type, you\n+// still want to complete it, to get ` { }` for free! `return` is inserted with a\n+// space or `;` depending on the return type of the function.\n+//\n+// When completing a function call, `()` are automatically inserted. If a function\n+// takes arguments, the cursor is positioned inside the parenthesis.\n+//\n+// There are postfix completions, which can be triggered by typing something like\n+// `foo().if`. The word after `.` determines postfix completion. Possible variants are:\n+//\n+// - `expr.if` -> `if expr {}` or `if let ... {}` for `Option` or `Result`\n+// - `expr.match` -> `match expr {}`\n+// - `expr.while` -> `while expr {}` or `while let ... {}` for `Option` or `Result`\n+// - `expr.ref` -> `&expr`\n+// - `expr.refm` -> `&mut expr`\n+// - `expr.not` -> `!expr`\n+// - `expr.dbg` -> `dbg!(expr)`\n+//\n+// There also snippet completions:\n+//\n+// .Expressions\n+// - `pd` -> `println!(\"{:?}\")`\n+// - `ppd` -> `println!(\"{:#?}\")`\n+//\n+// .Items\n+// - `tfn` -> `#[test] fn f(){}`\n+// - `tmod` ->\n+// ```rust\n+// #[cfg(test)]\n+// mod tests {\n+//     use super::*;\n+//\n+//     #[test]\n+//     fn test_fn() {}\n+// }\n+// ```\n+\n /// Main entry point for completion. We run completion as a two-phase process.\n ///\n /// First, we look at the position and collect a so-called `CompletionContext.\n@@ -82,3 +125,81 @@ pub(crate) fn completions(\n \n     Some(acc)\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::completion::completion_config::CompletionConfig;\n+    use crate::mock_analysis::analysis_and_position;\n+\n+    struct DetailAndDocumentation<'a> {\n+        detail: &'a str,\n+        documentation: &'a str,\n+    }\n+\n+    fn check_detail_and_documentation(fixture: &str, expected: DetailAndDocumentation) {\n+        let (analysis, position) = analysis_and_position(fixture);\n+        let config = CompletionConfig::default();\n+        let completions = analysis.completions(&config, position).unwrap().unwrap();\n+        for item in completions {\n+            if item.detail() == Some(expected.detail) {\n+                let opt = item.documentation();\n+                let doc = opt.as_ref().map(|it| it.as_str());\n+                assert_eq!(doc, Some(expected.documentation));\n+                return;\n+            }\n+        }\n+        panic!(\"completion detail not found: {}\", expected.detail)\n+    }\n+\n+    #[test]\n+    fn test_completion_detail_from_macro_generated_struct_fn_doc_attr() {\n+        check_detail_and_documentation(\n+            r#\"\n+            //- /lib.rs\n+            macro_rules! bar {\n+                () => {\n+                    struct Bar;\n+                    impl Bar {\n+                        #[doc = \"Do the foo\"]\n+                        fn foo(&self) {}\n+                    }\n+                }\n+            }\n+\n+            bar!();\n+\n+            fn foo() {\n+                let bar = Bar;\n+                bar.fo<|>;\n+            }\n+            \"#,\n+            DetailAndDocumentation { detail: \"fn foo(&self)\", documentation: \"Do the foo\" },\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_detail_from_macro_generated_struct_fn_doc_comment() {\n+        check_detail_and_documentation(\n+            r#\"\n+            //- /lib.rs\n+            macro_rules! bar {\n+                () => {\n+                    struct Bar;\n+                    impl Bar {\n+                        /// Do the foo\n+                        fn foo(&self) {}\n+                    }\n+                }\n+            }\n+\n+            bar!();\n+\n+            fn foo() {\n+                let bar = Bar;\n+                bar.fo<|>;\n+            }\n+            \"#,\n+            DetailAndDocumentation { detail: \"fn foo(&self)\", documentation: \" Do the foo\" },\n+        );\n+    }\n+}"}, {"sha": "fb3f0b743ef222388da38b30e0a1e652bbe3c4c3", "filename": "crates/ra_ide/src/completion/complete_attribute.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -112,7 +112,7 @@ const ATTRIBUTES: &[AttrCompletion] = &[\n     AttrCompletion { label: \"repr\", snippet: Some(\"repr(${0:C})\"), should_be_inner: false },\n     AttrCompletion {\n         label: \"should_panic\",\n-        snippet: Some(r#\"expected = \"${0:reason}\"\"#),\n+        snippet: Some(r#\"should_panic(expected = \"${0:reason}\")\"#),\n         should_be_inner: false,\n     },\n     AttrCompletion {\n@@ -571,7 +571,7 @@ mod tests {\n                 label: \"should_panic\",\n                 source_range: 19..19,\n                 delete: 19..19,\n-                insert: \"expected = \\\"${0:reason}\\\"\",\n+                insert: \"should_panic(expected = \\\"${0:reason}\\\")\",\n                 kind: Attribute,\n             },\n             CompletionItem {\n@@ -810,7 +810,7 @@ mod tests {\n                 label: \"should_panic\",\n                 source_range: 20..20,\n                 delete: 20..20,\n-                insert: \"expected = \\\"${0:reason}\\\"\",\n+                insert: \"should_panic(expected = \\\"${0:reason}\\\")\",\n                 kind: Attribute,\n             },\n             CompletionItem {"}, {"sha": "59b58bf98b6b5282466190326f2c9431569429df", "filename": "crates/ra_ide/src/completion/complete_postfix.rs", "status": "modified", "additions": 62, "deletions": 3, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,20 +1,20 @@\n //! FIXME: write short doc here\n-\n+use ra_assists::utils::TryEnum;\n use ra_syntax::{\n     ast::{self, AstNode},\n     TextRange, TextSize,\n };\n use ra_text_edit::TextEdit;\n \n-use super::completion_config::SnippetCap;\n use crate::{\n     completion::{\n         completion_context::CompletionContext,\n         completion_item::{Builder, CompletionKind, Completions},\n     },\n     CompletionItem,\n };\n-use ra_assists::utils::TryEnum;\n+\n+use super::completion_config::SnippetCap;\n \n pub(super) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n     if !ctx.config.enable_postfix_completions {\n@@ -184,6 +184,16 @@ pub(super) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n         &format!(\"dbg!({})\", receiver_text),\n     )\n     .add_to(acc);\n+\n+    postfix_snippet(\n+        ctx,\n+        cap,\n+        &dot_receiver,\n+        \"call\",\n+        \"function(expr)\",\n+        &format!(\"${{1}}({})\", receiver_text),\n+    )\n+    .add_to(acc);\n }\n \n fn get_receiver_text(receiver: &ast::Expr, receiver_is_ambiguous_float_literal: bool) -> String {\n@@ -255,6 +265,13 @@ mod tests {\n                 insert: \"Box::new(bar)\",\n                 detail: \"Box::new(expr)\",\n             },\n+            CompletionItem {\n+                label: \"call\",\n+                source_range: 89..89,\n+                delete: 85..89,\n+                insert: \"${1}(bar)\",\n+                detail: \"function(expr)\",\n+            },\n             CompletionItem {\n                 label: \"dbg\",\n                 source_range: 89..89,\n@@ -334,6 +351,13 @@ mod tests {\n                 insert: \"Box::new(bar)\",\n                 detail: \"Box::new(expr)\",\n             },\n+            CompletionItem {\n+                label: \"call\",\n+                source_range: 210..210,\n+                delete: 206..210,\n+                insert: \"${1}(bar)\",\n+                detail: \"function(expr)\",\n+            },\n             CompletionItem {\n                 label: \"dbg\",\n                 source_range: 210..210,\n@@ -413,6 +437,13 @@ mod tests {\n                 insert: \"Box::new(bar)\",\n                 detail: \"Box::new(expr)\",\n             },\n+            CompletionItem {\n+                label: \"call\",\n+                source_range: 211..211,\n+                delete: 207..211,\n+                insert: \"${1}(bar)\",\n+                detail: \"function(expr)\",\n+            },\n             CompletionItem {\n                 label: \"dbg\",\n                 source_range: 211..211,\n@@ -487,6 +518,13 @@ mod tests {\n                 insert: \"Box::new(bar)\",\n                 detail: \"Box::new(expr)\",\n             },\n+            CompletionItem {\n+                label: \"call\",\n+                source_range: 91..91,\n+                delete: 87..91,\n+                insert: \"${1}(bar)\",\n+                detail: \"function(expr)\",\n+            },\n             CompletionItem {\n                 label: \"dbg\",\n                 source_range: 91..91,\n@@ -546,6 +584,13 @@ mod tests {\n                 insert: \"Box::new(42)\",\n                 detail: \"Box::new(expr)\",\n             },\n+            CompletionItem {\n+                label: \"call\",\n+                source_range: 52..52,\n+                delete: 49..52,\n+                insert: \"${1}(42)\",\n+                detail: \"function(expr)\",\n+            },\n             CompletionItem {\n                 label: \"dbg\",\n                 source_range: 52..52,\n@@ -607,6 +652,13 @@ mod tests {\n                 insert: \"Box::new(bar)\",\n                 detail: \"Box::new(expr)\",\n             },\n+            CompletionItem {\n+                label: \"call\",\n+                source_range: 149..150,\n+                delete: 145..150,\n+                insert: \"${1}(bar)\",\n+                detail: \"function(expr)\",\n+            },\n             CompletionItem {\n                 label: \"dbg\",\n                 source_range: 149..150,\n@@ -666,6 +718,13 @@ mod tests {\n                 insert: \"Box::new(&&&&42)\",\n                 detail: \"Box::new(expr)\",\n             },\n+            CompletionItem {\n+                label: \"call\",\n+                source_range: 56..56,\n+                delete: 49..56,\n+                insert: \"${1}(&&&&42)\",\n+                detail: \"function(expr)\",\n+            },\n             CompletionItem {\n                 label: \"dbg\",\n                 source_range: 56..56,"}, {"sha": "21c9316e6662f2cc34aad09391123c597b1fc9fd", "filename": "crates/ra_ide/src/completion/complete_trait_impl.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -49,56 +49,53 @@ use crate::{\n pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext) {\n     if let Some((trigger, impl_def)) = completion_match(ctx) {\n         match trigger.kind() {\n-            SyntaxKind::NAME_REF => {\n-                get_missing_assoc_items(&ctx.sema, &impl_def).iter().for_each(|item| match item {\n+            SyntaxKind::NAME_REF => get_missing_assoc_items(&ctx.sema, &impl_def)\n+                .into_iter()\n+                .for_each(|item| match item {\n                     hir::AssocItem::Function(fn_item) => {\n-                        add_function_impl(&trigger, acc, ctx, &fn_item)\n+                        add_function_impl(&trigger, acc, ctx, fn_item)\n                     }\n                     hir::AssocItem::TypeAlias(type_item) => {\n-                        add_type_alias_impl(&trigger, acc, ctx, &type_item)\n+                        add_type_alias_impl(&trigger, acc, ctx, type_item)\n                     }\n                     hir::AssocItem::Const(const_item) => {\n-                        add_const_impl(&trigger, acc, ctx, &const_item)\n+                        add_const_impl(&trigger, acc, ctx, const_item)\n                     }\n-                })\n-            }\n+                }),\n \n             SyntaxKind::FN_DEF => {\n-                for missing_fn in\n-                    get_missing_assoc_items(&ctx.sema, &impl_def).iter().filter_map(|item| {\n-                        match item {\n-                            hir::AssocItem::Function(fn_item) => Some(fn_item),\n-                            _ => None,\n-                        }\n+                for missing_fn in get_missing_assoc_items(&ctx.sema, &impl_def)\n+                    .into_iter()\n+                    .filter_map(|item| match item {\n+                        hir::AssocItem::Function(fn_item) => Some(fn_item),\n+                        _ => None,\n                     })\n                 {\n-                    add_function_impl(&trigger, acc, ctx, &missing_fn);\n+                    add_function_impl(&trigger, acc, ctx, missing_fn);\n                 }\n             }\n \n             SyntaxKind::TYPE_ALIAS_DEF => {\n-                for missing_fn in\n-                    get_missing_assoc_items(&ctx.sema, &impl_def).iter().filter_map(|item| {\n-                        match item {\n-                            hir::AssocItem::TypeAlias(type_item) => Some(type_item),\n-                            _ => None,\n-                        }\n+                for missing_fn in get_missing_assoc_items(&ctx.sema, &impl_def)\n+                    .into_iter()\n+                    .filter_map(|item| match item {\n+                        hir::AssocItem::TypeAlias(type_item) => Some(type_item),\n+                        _ => None,\n                     })\n                 {\n-                    add_type_alias_impl(&trigger, acc, ctx, &missing_fn);\n+                    add_type_alias_impl(&trigger, acc, ctx, missing_fn);\n                 }\n             }\n \n             SyntaxKind::CONST_DEF => {\n-                for missing_fn in\n-                    get_missing_assoc_items(&ctx.sema, &impl_def).iter().filter_map(|item| {\n-                        match item {\n-                            hir::AssocItem::Const(const_item) => Some(const_item),\n-                            _ => None,\n-                        }\n+                for missing_fn in get_missing_assoc_items(&ctx.sema, &impl_def)\n+                    .into_iter()\n+                    .filter_map(|item| match item {\n+                        hir::AssocItem::Const(const_item) => Some(const_item),\n+                        _ => None,\n                     })\n                 {\n-                    add_const_impl(&trigger, acc, ctx, &missing_fn);\n+                    add_const_impl(&trigger, acc, ctx, missing_fn);\n                 }\n             }\n \n@@ -126,9 +123,9 @@ fn add_function_impl(\n     fn_def_node: &SyntaxNode,\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    func: &hir::Function,\n+    func: hir::Function,\n ) {\n-    let signature = FunctionSignature::from_hir(ctx.db, *func);\n+    let signature = FunctionSignature::from_hir(ctx.db, func);\n \n     let fn_name = func.name(ctx.db).to_string();\n \n@@ -167,7 +164,7 @@ fn add_type_alias_impl(\n     type_def_node: &SyntaxNode,\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    type_alias: &hir::TypeAlias,\n+    type_alias: hir::TypeAlias,\n ) {\n     let alias_name = type_alias.name(ctx.db).to_string();\n \n@@ -187,7 +184,7 @@ fn add_const_impl(\n     const_def_node: &SyntaxNode,\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    const_: &hir::Const,\n+    const_: hir::Const,\n ) {\n     let const_name = const_.name(ctx.db).map(|n| n.to_string());\n "}, {"sha": "68032c37eda7a0887fdb3fe48850ea435ddab012", "filename": "crates/ra_ide/src/completion/complete_unqualified_path.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -297,6 +297,42 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn completes_bindings_from_for_with_in_prefix() {\n+        mark::check!(completes_bindings_from_for_with_in_prefix);\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                fn test() {\n+                    for index in &[1, 2, 3] {\n+                        let t = in<|>\n+                    }\n+                }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"index\",\n+                source_range: 107..107,\n+                delete: 107..107,\n+                insert: \"index\",\n+                kind: Binding,\n+            },\n+            CompletionItem {\n+                label: \"test()\",\n+                source_range: 107..107,\n+                delete: 107..107,\n+                insert: \"test()$0\",\n+                kind: Function,\n+                lookup: \"test\",\n+                detail: \"fn test()\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn completes_generic_params() {\n         assert_debug_snapshot!("}, {"sha": "c4646b727c639ecd10abaf6f5459f26391697877", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -12,6 +12,7 @@ use ra_syntax::{\n use ra_text_edit::Indel;\n \n use crate::{call_info::ActiveParameter, completion::CompletionConfig, FilePosition};\n+use test_utils::mark;\n \n /// `CompletionContext` is created early during completion to figure out, where\n /// exactly is the cursor, syntax-wise.\n@@ -169,7 +170,17 @@ impl<'a> CompletionContext<'a> {\n         match self.token.kind() {\n             // workaroud when completion is triggered by trigger characters.\n             IDENT => self.original_token.text_range(),\n-            _ => TextRange::empty(self.offset),\n+            _ => {\n+                // If we haven't characters between keyword and our cursor we take the keyword start range to edit\n+                if self.token.kind().is_keyword()\n+                    && self.offset == self.original_token.text_range().end()\n+                {\n+                    mark::hit!(completes_bindings_from_for_with_in_prefix);\n+                    TextRange::empty(self.original_token.text_range().start())\n+                } else {\n+                    TextRange::empty(self.offset)\n+                }\n+            }\n         }\n     }\n "}, {"sha": "61565c84fe2bb1af35b802d2f621f747f0cd727e", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -211,7 +211,7 @@ impl Completions {\n             .parameter_names\n             .iter()\n             .skip(if function_signature.has_self_param { 1 } else { 0 })\n-            .cloned()\n+            .map(|name| name.trim_start_matches('_').into())\n             .collect();\n \n         builder = builder.add_call_parens(ctx, name, Params::Named(params));\n@@ -669,6 +669,37 @@ mod tests {\n         ]\n         \"###\n         );\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                fn with_ignored_args(_foo: i32, ___bar: bool, ho_ge_: String) {}\n+                fn main() { with_<|> }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"main()\",\n+                source_range: 110..115,\n+                delete: 110..115,\n+                insert: \"main()$0\",\n+                kind: Function,\n+                lookup: \"main\",\n+                detail: \"fn main()\",\n+            },\n+            CompletionItem {\n+                label: \"with_ignored_args(\u2026)\",\n+                source_range: 110..115,\n+                delete: 110..115,\n+                insert: \"with_ignored_args(${1:foo}, ${2:bar}, ${3:ho_ge_})$0\",\n+                kind: Function,\n+                lookup: \"with_ignored_args\",\n+                detail: \"fn with_ignored_args(_foo: i32, ___bar: bool, ho_ge_: String)\",\n+                trigger_call_info: true,\n+            },\n+        ]\n+        \"###\n+        );\n         assert_debug_snapshot!(\n             do_reference_completion(\n                 r\"\n@@ -695,6 +726,33 @@ mod tests {\n         ]\n         \"###\n         );\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                struct S {}\n+                impl S {\n+                    fn foo_ignored_args(&self, _a: bool, b: i32) {}\n+                }\n+                fn bar(s: &S) {\n+                    s.f<|>\n+                }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"foo_ignored_args(\u2026)\",\n+                source_range: 194..195,\n+                delete: 194..195,\n+                insert: \"foo_ignored_args(${1:a}, ${2:b})$0\",\n+                kind: Method,\n+                lookup: \"foo_ignored_args\",\n+                detail: \"fn foo_ignored_args(&self, _a: bool, b: i32)\",\n+                trigger_call_info: true,\n+            },\n+        ]\n+        \"###\n+        );\n     }\n \n     #[test]"}, {"sha": "15dc50cf143d5ff606f86f0499c18a9cf8eb8b13", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -664,7 +664,7 @@ mod tests {\n         assert_debug_snapshot!(diagnostics, @r###\"\n         [\n             Diagnostic {\n-                message: \"Missing structure fields:\\n- b\",\n+                message: \"Missing structure fields:\\n- b\\n\",\n                 range: 224..233,\n                 severity: Error,\n                 fix: Some("}, {"sha": "827c094e7163878b4b84ce46787a06438206bb79", "filename": "crates/ra_ide/src/display.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -79,16 +79,17 @@ pub(crate) fn rust_code_markup_with_doc(\n     doc: Option<&str>,\n     mod_path: Option<&str>,\n ) -> String {\n-    let mut buf = \"```rust\\n\".to_owned();\n+    let mut buf = String::new();\n \n     if let Some(mod_path) = mod_path {\n         if !mod_path.is_empty() {\n-            format_to!(buf, \"{}\\n\", mod_path);\n+            format_to!(buf, \"```rust\\n{}\\n```\\n\\n\", mod_path);\n         }\n     }\n-    format_to!(buf, \"{}\\n```\", code);\n+    format_to!(buf, \"```rust\\n{}\\n```\", code);\n \n     if let Some(doc) = doc {\n+        format_to!(buf, \"\\n___\");\n         format_to!(buf, \"\\n\\n{}\", doc);\n     }\n "}, {"sha": "ca8a6a650994c38f24da8ec16d9f98fe0d5aad21", "filename": "crates/ra_ide/src/display/function_signature.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -10,7 +10,7 @@ use std::{\n use hir::{Docs, Documentation, HasSource, HirDisplay};\n use ra_ide_db::RootDatabase;\n use ra_syntax::ast::{self, AstNode, NameOwner, VisibilityOwner};\n-use stdx::SepBy;\n+use stdx::{split1, SepBy};\n \n use crate::display::{generic_parameters, where_predicates};\n \n@@ -207,7 +207,16 @@ impl From<&'_ ast::FnDef> for FunctionSignature {\n                     res.push(raw_param);\n                 }\n \n-                res.extend(param_list.params().map(|param| param.syntax().text().to_string()));\n+                // macro-generated functions are missing whitespace\n+                fn fmt_param(param: ast::Param) -> String {\n+                    let text = param.syntax().text().to_string();\n+                    match split1(&text, ':') {\n+                        Some((left, right)) => format!(\"{}: {}\", left.trim(), right.trim()),\n+                        _ => text,\n+                    }\n+                }\n+\n+                res.extend(param_list.params().map(fmt_param));\n                 res_types.extend(param_list.params().map(|param| {\n                     let param_text = param.syntax().text().to_string();\n                     match param_text.split(':').nth(1).and_then(|it| it.get(1..)) {"}, {"sha": "c7bb1e69f8a575765da2aeb9b82d7dbb25904577", "filename": "crates/ra_ide/src/display/navigation_target.rs", "status": "modified", "additions": 23, "deletions": 43, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -92,15 +92,16 @@ impl NavigationTarget {\n         let name = module.name(db).map(|it| it.to_string().into()).unwrap_or_default();\n         if let Some(src) = module.declaration_source(db) {\n             let frange = original_range(db, src.as_ref().map(|it| it.syntax()));\n-            return NavigationTarget::from_syntax(\n+            let mut res = NavigationTarget::from_syntax(\n                 frange.file_id,\n                 name,\n                 None,\n                 frange.range,\n                 src.value.syntax().kind(),\n-                src.value.doc_comment_text(),\n-                src.value.short_label(),\n             );\n+            res.docs = src.value.doc_comment_text();\n+            res.description = src.value.short_label();\n+            return res;\n         }\n         module.to_nav(db)\n     }\n@@ -130,11 +131,9 @@ impl NavigationTarget {\n     }\n \n     /// Allows `NavigationTarget` to be created from a `NameOwner`\n-    fn from_named(\n+    pub(crate) fn from_named(\n         db: &RootDatabase,\n         node: InFile<&dyn ast::NameOwner>,\n-        docs: Option<String>,\n-        description: Option<String>,\n     ) -> NavigationTarget {\n         //FIXME: use `_` instead of empty string\n         let name = node.value.name().map(|it| it.text().clone()).unwrap_or_default();\n@@ -148,8 +147,6 @@ impl NavigationTarget {\n             focus_range,\n             frange.range,\n             node.value.syntax().kind(),\n-            docs,\n-            description,\n         )\n     }\n \n@@ -159,8 +156,6 @@ impl NavigationTarget {\n         focus_range: Option<TextRange>,\n         full_range: TextRange,\n         kind: SyntaxKind,\n-        docs: Option<String>,\n-        description: Option<String>,\n     ) -> NavigationTarget {\n         NavigationTarget {\n             file_id,\n@@ -169,8 +164,8 @@ impl NavigationTarget {\n             full_range,\n             focus_range,\n             container_name: None,\n-            description,\n-            docs,\n+            description: None,\n+            docs: None,\n         }\n     }\n }\n@@ -238,12 +233,11 @@ where\n {\n     fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n         let src = self.source(db);\n-        NavigationTarget::from_named(\n-            db,\n-            src.as_ref().map(|it| it as &dyn ast::NameOwner),\n-            src.value.doc_comment_text(),\n-            src.value.short_label(),\n-        )\n+        let mut res =\n+            NavigationTarget::from_named(db, src.as_ref().map(|it| it as &dyn ast::NameOwner));\n+        res.docs = src.value.doc_comment_text();\n+        res.description = src.value.short_label();\n+        res\n     }\n }\n \n@@ -258,15 +252,7 @@ impl ToNav for hir::Module {\n             }\n         };\n         let frange = original_range(db, src.with_value(syntax));\n-        NavigationTarget::from_syntax(\n-            frange.file_id,\n-            name,\n-            focus,\n-            frange.range,\n-            syntax.kind(),\n-            None,\n-            None,\n-        )\n+        NavigationTarget::from_syntax(frange.file_id, name, focus, frange.range, syntax.kind())\n     }\n }\n \n@@ -285,8 +271,6 @@ impl ToNav for hir::ImplDef {\n             None,\n             frange.range,\n             src.value.syntax().kind(),\n-            None,\n-            None,\n         )\n     }\n }\n@@ -296,12 +280,12 @@ impl ToNav for hir::Field {\n         let src = self.source(db);\n \n         match &src.value {\n-            FieldSource::Named(it) => NavigationTarget::from_named(\n-                db,\n-                src.with_value(it),\n-                it.doc_comment_text(),\n-                it.short_label(),\n-            ),\n+            FieldSource::Named(it) => {\n+                let mut res = NavigationTarget::from_named(db, src.with_value(it));\n+                res.docs = it.doc_comment_text();\n+                res.description = it.short_label();\n+                res\n+            }\n             FieldSource::Pos(it) => {\n                 let frange = original_range(db, src.with_value(it.syntax()));\n                 NavigationTarget::from_syntax(\n@@ -310,8 +294,6 @@ impl ToNav for hir::Field {\n                     None,\n                     frange.range,\n                     it.syntax().kind(),\n-                    None,\n-                    None,\n                 )\n             }\n         }\n@@ -322,12 +304,10 @@ impl ToNav for hir::MacroDef {\n     fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n         let src = self.source(db);\n         log::debug!(\"nav target {:#?}\", src.value.syntax());\n-        NavigationTarget::from_named(\n-            db,\n-            src.as_ref().map(|it| it as &dyn ast::NameOwner),\n-            src.value.doc_comment_text(),\n-            None,\n-        )\n+        let mut res =\n+            NavigationTarget::from_named(db, src.as_ref().map(|it| it as &dyn ast::NameOwner));\n+        res.docs = src.value.doc_comment_text();\n+        res\n     }\n }\n "}, {"sha": "aad5a8e4db69b5d4b57a7b4c0ca8567abaa6b9cb", "filename": "crates/ra_ide/src/display/structure.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fstructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fstructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fstructure.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,10 +1,6 @@\n-//! FIXME: write short doc here\n-\n-use crate::TextRange;\n-\n use ra_syntax::{\n     ast::{self, AttrsOwner, NameOwner, TypeAscriptionOwner, TypeParamsOwner},\n-    match_ast, AstNode, SourceFile, SyntaxKind, SyntaxNode, WalkEvent,\n+    match_ast, AstNode, SourceFile, SyntaxKind, SyntaxNode, TextRange, WalkEvent,\n };\n \n #[derive(Debug, Clone)]\n@@ -18,6 +14,19 @@ pub struct StructureNode {\n     pub deprecated: bool,\n }\n \n+// Feature: File Structure\n+//\n+// Provides a tree of the symbols defined in the file. Can be used to\n+//\n+// * fuzzy search symbol in a file (super useful)\n+// * draw breadcrumbs to describe the context around the cursor\n+// * draw outline of the file\n+//\n+// |===\n+// | Editor  | Shortcut\n+//\n+// | VS Code | kbd:[Ctrl+Shift+O]\n+// |===\n pub fn file_structure(file: &SourceFile) -> Vec<StructureNode> {\n     let mut res = Vec::new();\n     let mut stack = Vec::new();"}, {"sha": "54a47aac0684e0df4a89bd90464722df98cdbc4d", "filename": "crates/ra_ide/src/expand_macro.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,5 +1,3 @@\n-//! This modules implements \"expand macro\" functionality in the IDE\n-\n use hir::Semantics;\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n@@ -14,6 +12,15 @@ pub struct ExpandedMacro {\n     pub expansion: String,\n }\n \n+// Feature: Expand Macro Recursively\n+//\n+// Shows the full macro expansion of the macro at current cursor.\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Rust Analyzer: Expand macro recursively**\n+// |===\n pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<ExpandedMacro> {\n     let sema = Semantics::new(db);\n     let file = sema.parse(position.file_id);"}, {"sha": "a4bc93cdbaa74722a70469fe1290fb557a20d1e2", "filename": "crates/ra_ide/src/extend_selection.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n use std::iter::successors;\n \n use hir::Semantics;\n@@ -14,6 +12,16 @@ use ra_syntax::{\n \n use crate::FileRange;\n \n+// Feature: Extend Selection\n+//\n+// Extends the current selection to the encompassing syntactic construct\n+// (expression, statement, item, module, etc). It works with multiple cursors.\n+//\n+// |===\n+// | Editor  | Shortcut\n+//\n+// | VS Code | kbd:[Ctrl+Shift+\u2192]\n+// |===\n pub(crate) fn extend_selection(db: &RootDatabase, frange: FileRange) -> TextRange {\n     let sema = Semantics::new(db);\n     let src = sema.parse(frange.file_id);"}, {"sha": "a6c86e99c95eb9fc60355c23cd11eeb5ed6acf8d", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n use hir::Semantics;\n use ra_ide_db::{\n     defs::{classify_name, classify_name_ref},\n@@ -17,6 +15,15 @@ use crate::{\n     FilePosition, NavigationTarget, RangeInfo,\n };\n \n+// Feature: Go to Definition\n+//\n+// Navigates to the definition of an identifier.\n+//\n+// |===\n+// | Editor  | Shortcut\n+//\n+// | VS Code | kbd:[F12]\n+// |===\n pub(crate) fn goto_definition(\n     db: &RootDatabase,\n     position: FilePosition,"}, {"sha": "0cec0657e416073fccde1255caf6720d7de5f098", "filename": "crates/ra_ide/src/goto_implementation.rs", "status": "renamed", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fgoto_implementation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fgoto_implementation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_implementation.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,11 +1,18 @@\n-//! FIXME: write short doc here\n-\n use hir::{Crate, ImplDef, Semantics};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n \n use crate::{display::ToNav, FilePosition, NavigationTarget, RangeInfo};\n \n+// Feature: Go to Implementation\n+//\n+// Navigates to the impl block of structs, enums or traits. Also implemented as a code lens.\n+//\n+// |===\n+// | Editor  | Shortcut\n+//\n+// | VS Code | kbd:[Ctrl+F12]\n+// |===\n pub(crate) fn goto_implementation(\n     db: &RootDatabase,\n     position: FilePosition,", "previous_filename": "crates/ra_ide/src/impls.rs"}, {"sha": "91a3097fbb3697141eec5fa6d8b023560f618ffa", "filename": "crates/ra_ide/src/goto_type_definition.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,10 +1,17 @@\n-//! FIXME: write short doc here\n-\n use ra_ide_db::RootDatabase;\n use ra_syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset};\n \n use crate::{display::ToNav, FilePosition, NavigationTarget, RangeInfo};\n \n+// Feature: Go to Type Definition\n+//\n+// Navigates to the type of an identifier.\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Go to Type Definition*\n+// |===\n pub(crate) fn goto_type_definition(\n     db: &RootDatabase,\n     position: FilePosition,"}, {"sha": "9636cd0d6af7ad32bec9d4dff2084933c82d639b", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 189, "deletions": 75, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,28 +1,21 @@\n-//! Logic for computing info that is displayed when the user hovers over any\n-//! source code items (e.g. function call, struct field, variable symbol...)\n+use std::iter::once;\n \n use hir::{\n-    Adt, AsAssocItem, AssocItemContainer, FieldSource, HasSource, HirDisplay, ModuleDef,\n-    ModuleSource, Semantics,\n+    Adt, AsAssocItem, AssocItemContainer, Documentation, FieldSource, HasSource, HirDisplay,\n+    ModuleDef, ModuleSource, Semantics,\n };\n+use itertools::Itertools;\n use ra_db::SourceDatabase;\n use ra_ide_db::{\n     defs::{classify_name, classify_name_ref, Definition},\n     RootDatabase,\n };\n-use ra_syntax::{\n-    ast::{self, DocCommentsOwner},\n-    match_ast, AstNode,\n-    SyntaxKind::*,\n-    SyntaxToken, TokenAtOffset,\n-};\n+use ra_syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset};\n \n use crate::{\n     display::{macro_label, rust_code_markup, rust_code_markup_with_doc, ShortLabel},\n     FilePosition, RangeInfo,\n };\n-use itertools::Itertools;\n-use std::iter::once;\n \n /// Contains the results when hovering over an item\n #[derive(Debug, Default)]\n@@ -62,6 +55,63 @@ impl HoverResult {\n     }\n }\n \n+// Feature: Hover\n+//\n+// Shows additional information, like type of an expression or documentation for definition when \"focusing\" code.\n+// Focusing is usually hovering with a mouse, but can also be triggered with a shortcut.\n+pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeInfo<HoverResult>> {\n+    let sema = Semantics::new(db);\n+    let file = sema.parse(position.file_id).syntax().clone();\n+    let token = pick_best(file.token_at_offset(position.offset))?;\n+    let token = sema.descend_into_macros(token);\n+\n+    let mut res = HoverResult::new();\n+\n+    if let Some((node, name_kind)) = match_ast! {\n+        match (token.parent()) {\n+            ast::NameRef(name_ref) => {\n+                classify_name_ref(&sema, &name_ref).map(|d| (name_ref.syntax().clone(), d.definition()))\n+            },\n+            ast::Name(name) => {\n+                classify_name(&sema, &name).map(|d| (name.syntax().clone(), d.definition()))\n+            },\n+            _ => None,\n+        }\n+    } {\n+        let range = sema.original_range(&node).range;\n+        res.extend(hover_text_from_name_kind(db, name_kind));\n+\n+        if !res.is_empty() {\n+            return Some(RangeInfo::new(range, res));\n+        }\n+    }\n+\n+    let node = token\n+        .ancestors()\n+        .find(|n| ast::Expr::cast(n.clone()).is_some() || ast::Pat::cast(n.clone()).is_some())?;\n+\n+    let ty = match_ast! {\n+        match node {\n+            ast::MacroCall(_it) => {\n+                // If this node is a MACRO_CALL, it means that `descend_into_macros` failed to resolve.\n+                // (e.g expanding a builtin macro). So we give up here.\n+                return None;\n+            },\n+            ast::Expr(it) => {\n+                sema.type_of_expr(&it)\n+            },\n+            ast::Pat(it) => {\n+                sema.type_of_pat(&it)\n+            },\n+            _ => None,\n+        }\n+    }?;\n+\n+    res.extend(Some(rust_code_markup(&ty.display(db))));\n+    let range = sema.original_range(&node).range;\n+    Some(RangeInfo::new(range, res))\n+}\n+\n fn hover_text(\n     docs: Option<String>,\n     desc: Option<String>,\n@@ -114,21 +164,24 @@ fn hover_text_from_name_kind(db: &RootDatabase, def: Definition) -> Option<Strin\n     return match def {\n         Definition::Macro(it) => {\n             let src = it.source(db);\n-            hover_text(src.value.doc_comment_text(), Some(macro_label(&src.value)), mod_path)\n+            let docs = Documentation::from_ast(&src.value).map(Into::into);\n+            hover_text(docs, Some(macro_label(&src.value)), mod_path)\n         }\n         Definition::Field(it) => {\n             let src = it.source(db);\n             match src.value {\n                 FieldSource::Named(it) => {\n-                    hover_text(it.doc_comment_text(), it.short_label(), mod_path)\n+                    let docs = Documentation::from_ast(&it).map(Into::into);\n+                    hover_text(docs, it.short_label(), mod_path)\n                 }\n                 _ => None,\n             }\n         }\n         Definition::ModuleDef(it) => match it {\n             ModuleDef::Module(it) => match it.definition_source(db).value {\n                 ModuleSource::Module(it) => {\n-                    hover_text(it.doc_comment_text(), it.short_label(), mod_path)\n+                    let docs = Documentation::from_ast(&it).map(Into::into);\n+                    hover_text(docs, it.short_label(), mod_path)\n                 }\n                 _ => None,\n             },\n@@ -153,66 +206,14 @@ fn hover_text_from_name_kind(db: &RootDatabase, def: Definition) -> Option<Strin\n     fn from_def_source<A, D>(db: &RootDatabase, def: D, mod_path: Option<String>) -> Option<String>\n     where\n         D: HasSource<Ast = A>,\n-        A: ast::DocCommentsOwner + ast::NameOwner + ShortLabel,\n+        A: ast::DocCommentsOwner + ast::NameOwner + ShortLabel + ast::AttrsOwner,\n     {\n         let src = def.source(db);\n-        hover_text(src.value.doc_comment_text(), src.value.short_label(), mod_path)\n+        let docs = Documentation::from_ast(&src.value).map(Into::into);\n+        hover_text(docs, src.value.short_label(), mod_path)\n     }\n }\n \n-pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeInfo<HoverResult>> {\n-    let sema = Semantics::new(db);\n-    let file = sema.parse(position.file_id).syntax().clone();\n-    let token = pick_best(file.token_at_offset(position.offset))?;\n-    let token = sema.descend_into_macros(token);\n-\n-    let mut res = HoverResult::new();\n-\n-    if let Some((node, name_kind)) = match_ast! {\n-        match (token.parent()) {\n-            ast::NameRef(name_ref) => {\n-                classify_name_ref(&sema, &name_ref).map(|d| (name_ref.syntax().clone(), d.definition()))\n-            },\n-            ast::Name(name) => {\n-                classify_name(&sema, &name).map(|d| (name.syntax().clone(), d.definition()))\n-            },\n-            _ => None,\n-        }\n-    } {\n-        let range = sema.original_range(&node).range;\n-        res.extend(hover_text_from_name_kind(db, name_kind));\n-\n-        if !res.is_empty() {\n-            return Some(RangeInfo::new(range, res));\n-        }\n-    }\n-\n-    let node = token\n-        .ancestors()\n-        .find(|n| ast::Expr::cast(n.clone()).is_some() || ast::Pat::cast(n.clone()).is_some())?;\n-\n-    let ty = match_ast! {\n-        match node {\n-            ast::MacroCall(_it) => {\n-                // If this node is a MACRO_CALL, it means that `descend_into_macros` failed to resolve.\n-                // (e.g expanding a builtin macro). So we give up here.\n-                return None;\n-            },\n-            ast::Expr(it) => {\n-                sema.type_of_expr(&it)\n-            },\n-            ast::Pat(it) => {\n-                sema.type_of_pat(&it)\n-            },\n-            _ => None,\n-        }\n-    }?;\n-\n-    res.extend(Some(rust_code_markup(&ty.display(db))));\n-    let range = sema.original_range(&node).range;\n-    Some(RangeInfo::new(range, res))\n-}\n-\n fn pick_best(tokens: TokenAtOffset<SyntaxToken>) -> Option<SyntaxToken> {\n     return tokens.max_by_key(priority);\n     fn priority(n: &SyntaxToken) -> usize {\n@@ -405,7 +406,7 @@ mod tests {\n                 };\n             }\n         \"#,\n-            &[\"Foo\\nfield_a: u32\"],\n+            &[\"Foo\\n```\\n\\n```rust\\nfield_a: u32\"],\n         );\n \n         // Hovering over the field in the definition\n@@ -422,7 +423,7 @@ mod tests {\n                 };\n             }\n         \"#,\n-            &[\"Foo\\nfield_a: u32\"],\n+            &[\"Foo\\n```\\n\\n```rust\\nfield_a: u32\"],\n         );\n     }\n \n@@ -475,7 +476,7 @@ fn main() {\n             \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"Option\\nSome\"));\n+        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"Option\\n```\\n\\n```rust\\nSome\"));\n \n         let (analysis, position) = single_file_with_position(\n             \"\n@@ -503,8 +504,12 @@ fn main() {\n         \"#,\n             &[\"\n Option\n+```\n+\n+```rust\n None\n ```\n+___\n \n The None variant\n             \"\n@@ -524,8 +529,12 @@ The None variant\n         \"#,\n             &[\"\n Option\n+```\n+\n+```rust\n Some\n ```\n+___\n \n The Some variant\n             \"\n@@ -606,7 +615,10 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"wrapper::Thing\\nfn new() -> Thing\"));\n+        assert_eq!(\n+            trim_markup_opt(hover.info.first()),\n+            Some(\"wrapper::Thing\\n```\\n\\n```rust\\nfn new() -> Thing\")\n+        );\n     }\n \n     #[test]\n@@ -882,7 +894,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n                 fo<|>o();\n             }\n             \",\n-            &[\"fn foo()\\n```\\n\\n<- `\\u{3000}` here\"],\n+            &[\"fn foo()\\n```\\n___\\n\\n<- `\\u{3000}` here\"],\n         );\n     }\n \n@@ -938,4 +950,106 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             &[\"mod my\"],\n         );\n     }\n+\n+    #[test]\n+    fn test_hover_struct_doc_comment() {\n+        check_hover_result(\n+            r#\"\n+            //- /lib.rs\n+            /// bar docs\n+            struct Bar;\n+\n+            fn foo() {\n+                let bar = Ba<|>r;\n+            }\n+            \"#,\n+            &[\"struct Bar\\n```\\n___\\n\\nbar docs\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_struct_doc_attr() {\n+        check_hover_result(\n+            r#\"\n+            //- /lib.rs\n+            #[doc = \"bar docs\"]\n+            struct Bar;\n+\n+            fn foo() {\n+                let bar = Ba<|>r;\n+            }\n+            \"#,\n+            &[\"struct Bar\\n```\\n___\\n\\nbar docs\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_struct_doc_attr_multiple_and_mixed() {\n+        check_hover_result(\n+            r#\"\n+            //- /lib.rs\n+            /// bar docs 0\n+            #[doc = \"bar docs 1\"]\n+            #[doc = \"bar docs 2\"]\n+            struct Bar;\n+\n+            fn foo() {\n+                let bar = Ba<|>r;\n+            }\n+            \"#,\n+            &[\"struct Bar\\n```\\n___\\n\\nbar docs 0\\n\\nbar docs 1\\n\\nbar docs 2\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_macro_generated_struct_fn_doc_comment() {\n+        check_hover_result(\n+            r#\"\n+            //- /lib.rs\n+            macro_rules! bar {\n+                () => {\n+                    struct Bar;\n+                    impl Bar {\n+                        /// Do the foo\n+                        fn foo(&self) {}\n+                    }\n+                }\n+            }\n+\n+            bar!();\n+\n+            fn foo() {\n+                let bar = Bar;\n+                bar.fo<|>o();\n+            }\n+            \"#,\n+            &[\"Bar\\n```\\n\\n```rust\\nfn foo(&self)\\n```\\n___\\n\\n Do the foo\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_macro_generated_struct_fn_doc_attr() {\n+        check_hover_result(\n+            r#\"\n+            //- /lib.rs\n+            macro_rules! bar {\n+                () => {\n+                    struct Bar;\n+                    impl Bar {\n+                        #[doc = \"Do the foo\"]\n+                        fn foo(&self) {}\n+                    }\n+                }\n+            }\n+\n+            bar!();\n+\n+            fn foo() {\n+                let bar = Bar;\n+                bar.fo<|>o();\n+            }\n+            \"#,\n+            &[\"Bar\\n```\\n\\n```rust\\nfn foo(&self)\\n```\\n___\\n\\nDo the foo\"],\n+        );\n+    }\n }"}, {"sha": "75bd3c96bb1fc841d6fc4473c7248913e871e492", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,5 +1,3 @@\n-//! This module defines multiple types of inlay hints and their visibility\n-\n use hir::{Adt, HirDisplay, Semantics, Type};\n use ra_ide_db::RootDatabase;\n use ra_prof::profile;\n@@ -39,6 +37,26 @@ pub struct InlayHint {\n     pub label: SmolStr,\n }\n \n+// Feature: Inlay Hints\n+//\n+// rust-analyzer shows additional information inline with the source code.\n+// Editors usually render this using read-only virtual text snippets interspersed with code.\n+//\n+// rust-analyzer shows hits for\n+//\n+// * types of local variables\n+// * names of function arguments\n+// * types of chained expressions\n+//\n+// **Note:** VS Code does not have native support for inlay hints https://github.com/microsoft/vscode/issues/16221[yet] and the hints are implemented using decorations.\n+// This approach has limitations, the caret movement and bracket highlighting near the edges of the hint may be weird:\n+// https://github.com/rust-analyzer/rust-analyzer/issues/1623[1], https://github.com/rust-analyzer/rust-analyzer/issues/3453[2].\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Rust Analyzer: Toggle inlay hints*\n+// |===\n pub(crate) fn inlay_hints(\n     db: &RootDatabase,\n     file_id: FileId,"}, {"sha": "5036c1fb0c62ee4dea5847d416884d91e3d0a804", "filename": "crates/ra_ide/src/join_lines.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fjoin_lines.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n use itertools::Itertools;\n use ra_fmt::{compute_ws, extract_trivial_expression};\n use ra_syntax::{\n@@ -11,6 +9,15 @@ use ra_syntax::{\n };\n use ra_text_edit::{TextEdit, TextEditBuilder};\n \n+// Feature: Join Lines\n+//\n+// Join selected lines into one, smartly fixing up whitespace, trailing commas, and braces.\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Rust Analyzer: Join lines**\n+// |===\n pub fn join_lines(file: &SourceFile, range: TextRange) -> TextEdit {\n     let range = if range.is_empty() {\n         let syntax = file.syntax();"}, {"sha": "12d5716e83598ac3c02ef74c70040de4ff1b0cbc", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -23,14 +23,14 @@ mod completion;\n mod runnables;\n mod goto_definition;\n mod goto_type_definition;\n+mod goto_implementation;\n mod extend_selection;\n mod hover;\n mod call_hierarchy;\n mod call_info;\n mod syntax_highlighting;\n mod parent_module;\n mod references;\n-mod impls;\n mod diagnostics;\n mod syntax_tree;\n mod folding_ranges;\n@@ -309,7 +309,8 @@ impl Analysis {\n \n     /// Returns an edit which should be applied when opening a new line, fixing\n     /// up minor stuff like continuing the comment.\n-    pub fn on_enter(&self, position: FilePosition) -> Cancelable<Option<SourceChange>> {\n+    /// The edit will be a snippet (with `$0`).\n+    pub fn on_enter(&self, position: FilePosition) -> Cancelable<Option<TextEdit>> {\n         self.with_db(|db| typing::on_enter(&db, position))\n     }\n \n@@ -372,7 +373,7 @@ impl Analysis {\n         &self,\n         position: FilePosition,\n     ) -> Cancelable<Option<RangeInfo<Vec<NavigationTarget>>>> {\n-        self.with_db(|db| impls::goto_implementation(db, position))\n+        self.with_db(|db| goto_implementation::goto_implementation(db, position))\n     }\n \n     /// Returns the type definitions for the symbol at `position`."}, {"sha": "407a9636d1d1f7de837ac0dfe053a9556a435f32", "filename": "crates/ra_ide/src/matching_brace.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fmatching_brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fmatching_brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmatching_brace.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,7 +1,16 @@\n-//! FIXME: write short doc here\n-\n use ra_syntax::{ast::AstNode, SourceFile, SyntaxKind, TextSize, T};\n \n+// Feature: Matching Brace\n+//\n+// If the cursor is on any brace (`<>(){}[]`) which is a part of a brace-pair,\n+// moves cursor to the matching brace. It uses the actual parser to determine\n+// braces, so it won't confuse generics with comparisons.\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Rust Analyzer: Find matching brace**\n+// |===\n pub fn matching_brace(file: &SourceFile, offset: TextSize) -> Option<TextSize> {\n     const BRACES: &[SyntaxKind] =\n         &[T!['{'], T!['}'], T!['['], T![']'], T!['('], T![')'], T![<], T![>]];"}, {"sha": "ad78d2d93fd4d105b91d1673db85ab32b04581d5", "filename": "crates/ra_ide/src/mock_analysis.rs", "status": "modified", "additions": 102, "deletions": 21, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,21 +1,81 @@\n //! FIXME: write short doc here\n \n+use std::str::FromStr;\n use std::sync::Arc;\n \n use ra_cfg::CfgOptions;\n use ra_db::{CrateName, Env, RelativePathBuf};\n-use test_utils::{extract_offset, extract_range, parse_fixture, CURSOR_MARKER};\n+use test_utils::{extract_offset, extract_range, parse_fixture, FixtureEntry, CURSOR_MARKER};\n \n use crate::{\n-    Analysis, AnalysisChange, AnalysisHost, CrateGraph, Edition::Edition2018, FileId, FilePosition,\n-    FileRange, SourceRootId,\n+    Analysis, AnalysisChange, AnalysisHost, CrateGraph, Edition, FileId, FilePosition, FileRange,\n+    SourceRootId,\n };\n \n+#[derive(Debug)]\n+enum MockFileData {\n+    Plain { path: String, content: String },\n+    Fixture(FixtureEntry),\n+}\n+\n+impl MockFileData {\n+    fn new(path: String, content: String) -> Self {\n+        // `Self::Plain` causes a false warning: 'variant is never constructed: `Plain` '\n+        // see https://github.com/rust-lang/rust/issues/69018\n+        MockFileData::Plain { path, content }\n+    }\n+\n+    fn path(&self) -> &str {\n+        match self {\n+            MockFileData::Plain { path, .. } => path.as_str(),\n+            MockFileData::Fixture(f) => f.meta.path().as_str(),\n+        }\n+    }\n+\n+    fn content(&self) -> &str {\n+        match self {\n+            MockFileData::Plain { content, .. } => content,\n+            MockFileData::Fixture(f) => f.text.as_str(),\n+        }\n+    }\n+\n+    fn cfg_options(&self) -> CfgOptions {\n+        match self {\n+            MockFileData::Fixture(f) => {\n+                f.meta.cfg_options().map_or_else(Default::default, |o| o.clone())\n+            }\n+            _ => CfgOptions::default(),\n+        }\n+    }\n+\n+    fn edition(&self) -> Edition {\n+        match self {\n+            MockFileData::Fixture(f) => {\n+                f.meta.edition().map_or(Edition::Edition2018, |v| Edition::from_str(v).unwrap())\n+            }\n+            _ => Edition::Edition2018,\n+        }\n+    }\n+\n+    fn env(&self) -> Env {\n+        match self {\n+            MockFileData::Fixture(f) => Env::from(f.meta.env()),\n+            _ => Env::default(),\n+        }\n+    }\n+}\n+\n+impl From<FixtureEntry> for MockFileData {\n+    fn from(fixture: FixtureEntry) -> Self {\n+        Self::Fixture(fixture)\n+    }\n+}\n+\n /// Mock analysis is used in test to bootstrap an AnalysisHost/Analysis\n /// from a set of in-memory files.\n #[derive(Debug, Default)]\n pub struct MockAnalysis {\n-    files: Vec<(String, String)>,\n+    files: Vec<MockFileData>,\n }\n \n impl MockAnalysis {\n@@ -35,7 +95,7 @@ impl MockAnalysis {\n     pub fn with_files(fixture: &str) -> MockAnalysis {\n         let mut res = MockAnalysis::new();\n         for entry in parse_fixture(fixture) {\n-            res.add_file(&entry.meta, &entry.text);\n+            res.add_file_fixture(entry);\n         }\n         res\n     }\n@@ -48,38 +108,52 @@ impl MockAnalysis {\n         for entry in parse_fixture(fixture) {\n             if entry.text.contains(CURSOR_MARKER) {\n                 assert!(position.is_none(), \"only one marker (<|>) per fixture is allowed\");\n-                position = Some(res.add_file_with_position(&entry.meta, &entry.text));\n+                position = Some(res.add_file_fixture_with_position(entry));\n             } else {\n-                res.add_file(&entry.meta, &entry.text);\n+                res.add_file_fixture(entry);\n             }\n         }\n         let position = position.expect(\"expected a marker (<|>)\");\n         (res, position)\n     }\n \n+    pub fn add_file_fixture(&mut self, fixture: FixtureEntry) -> FileId {\n+        let file_id = self.next_id();\n+        self.files.push(MockFileData::from(fixture));\n+        file_id\n+    }\n+\n+    pub fn add_file_fixture_with_position(&mut self, mut fixture: FixtureEntry) -> FilePosition {\n+        let (offset, text) = extract_offset(&fixture.text);\n+        fixture.text = text;\n+        let file_id = self.next_id();\n+        self.files.push(MockFileData::from(fixture));\n+        FilePosition { file_id, offset }\n+    }\n+\n     pub fn add_file(&mut self, path: &str, text: &str) -> FileId {\n-        let file_id = FileId((self.files.len() + 1) as u32);\n-        self.files.push((path.to_string(), text.to_string()));\n+        let file_id = self.next_id();\n+        self.files.push(MockFileData::new(path.to_string(), text.to_string()));\n         file_id\n     }\n     pub fn add_file_with_position(&mut self, path: &str, text: &str) -> FilePosition {\n         let (offset, text) = extract_offset(text);\n-        let file_id = FileId((self.files.len() + 1) as u32);\n-        self.files.push((path.to_string(), text));\n+        let file_id = self.next_id();\n+        self.files.push(MockFileData::new(path.to_string(), text));\n         FilePosition { file_id, offset }\n     }\n     pub fn add_file_with_range(&mut self, path: &str, text: &str) -> FileRange {\n         let (range, text) = extract_range(text);\n-        let file_id = FileId((self.files.len() + 1) as u32);\n-        self.files.push((path.to_string(), text));\n+        let file_id = self.next_id();\n+        self.files.push(MockFileData::new(path.to_string(), text));\n         FileRange { file_id, range }\n     }\n     pub fn id_of(&self, path: &str) -> FileId {\n         let (idx, _) = self\n             .files\n             .iter()\n             .enumerate()\n-            .find(|(_, (p, _text))| path == p)\n+            .find(|(_, data)| path == data.path())\n             .expect(\"no file in this mock\");\n         FileId(idx as u32 + 1)\n     }\n@@ -90,29 +164,32 @@ impl MockAnalysis {\n         change.add_root(source_root, true);\n         let mut crate_graph = CrateGraph::default();\n         let mut root_crate = None;\n-        for (i, (path, contents)) in self.files.into_iter().enumerate() {\n+        for (i, data) in self.files.into_iter().enumerate() {\n+            let path = data.path();\n             assert!(path.starts_with('/'));\n             let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n+            let cfg_options = data.cfg_options();\n             let file_id = FileId(i as u32 + 1);\n-            let cfg_options = CfgOptions::default();\n+            let edition = data.edition();\n+            let env = data.env();\n             if path == \"/lib.rs\" || path == \"/main.rs\" {\n                 root_crate = Some(crate_graph.add_crate_root(\n                     file_id,\n-                    Edition2018,\n+                    edition,\n                     None,\n                     cfg_options,\n-                    Env::default(),\n+                    env,\n                     Default::default(),\n                     Default::default(),\n                 ));\n             } else if path.ends_with(\"/lib.rs\") {\n                 let crate_name = path.parent().unwrap().file_name().unwrap();\n                 let other_crate = crate_graph.add_crate_root(\n                     file_id,\n-                    Edition2018,\n+                    edition,\n                     Some(CrateName::new(crate_name).unwrap()),\n                     cfg_options,\n-                    Env::default(),\n+                    env,\n                     Default::default(),\n                     Default::default(),\n                 );\n@@ -122,7 +199,7 @@ impl MockAnalysis {\n                         .unwrap();\n                 }\n             }\n-            change.add_file(source_root, file_id, path, Arc::new(contents));\n+            change.add_file(source_root, file_id, path, Arc::new(data.content().to_owned()));\n         }\n         change.set_crate_graph(crate_graph);\n         host.apply_change(change);\n@@ -131,6 +208,10 @@ impl MockAnalysis {\n     pub fn analysis(self) -> Analysis {\n         self.analysis_host().analysis()\n     }\n+\n+    fn next_id(&self) -> FileId {\n+        FileId((self.files.len() + 1) as u32)\n+    }\n }\n \n /// Creates analysis from a multi-file fixture, returns positions marked with <|>."}, {"sha": "fa1535da5b0a95147316277071b1c13b40cf8c5d", "filename": "crates/ra_ide/src/parent_module.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fparent_module.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n use hir::Semantics;\n use ra_db::{CrateId, FileId, FilePosition};\n use ra_ide_db::RootDatabase;\n@@ -11,6 +9,16 @@ use test_utils::mark;\n \n use crate::NavigationTarget;\n \n+// Feature: Parent Module\n+//\n+// Navigates to the parent module of the current module.\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Rust Analyzer: Locate parent module**\n+// |===\n+\n /// This returns `Vec` because a module may be included from several places. We\n /// don't handle this case yet though, so the Vec has length at most one.\n pub(crate) fn parent_module(db: &RootDatabase, position: FilePosition) -> Vec<NavigationTarget> {"}, {"sha": "bb40d2043786ce4434fae04d324b901c660a7d9e", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -615,6 +615,33 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_find_all_refs_nested_module() {\n+        let code = r#\"\n+            //- /lib.rs\n+            mod foo {\n+                mod bar;\n+            }\n+\n+            fn f<|>() {}\n+\n+            //- /foo/bar.rs\n+            use crate::f;\n+\n+            fn g() {\n+                f();\n+            }\n+        \"#;\n+\n+        let (analysis, pos) = analysis_and_position(code);\n+        let refs = analysis.find_all_refs(pos, None).unwrap().unwrap();\n+        check_result(\n+            refs,\n+            \"f FN_DEF FileId(1) 25..34 28..29 Other\",\n+            &[\"FileId(2) 11..12 Other\", \"FileId(2) 27..28 StructLiteral\"],\n+        );\n+    }\n+\n     fn get_all_refs(text: &str) -> ReferenceSearchResult {\n         let (analysis, position) = single_file_with_position(text);\n         analysis.find_all_refs(position, None).unwrap().unwrap()"}, {"sha": "f32ce0d229b84247246fa46f103604f771f4fc2e", "filename": "crates/ra_ide/src/runnables.rs", "status": "modified", "additions": 382, "deletions": 58, "changes": 440, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Frunnables.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,21 +1,21 @@\n-//! FIXME: write short doc here\n+use std::fmt;\n \n-use hir::{AsAssocItem, Semantics};\n+use hir::{AsAssocItem, Attrs, HirFileId, InFile, Semantics};\n use itertools::Itertools;\n+use ra_cfg::CfgExpr;\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n-    ast::{self, AstNode, AttrsOwner, ModuleItemOwner, NameOwner},\n-    match_ast, SyntaxNode, TextRange,\n+    ast::{self, AstNode, AttrsOwner, DocCommentsOwner, ModuleItemOwner, NameOwner},\n+    match_ast, SyntaxNode,\n };\n \n-use crate::FileId;\n-use ast::DocCommentsOwner;\n-use std::fmt::Display;\n+use crate::{display::ToNav, FileId, NavigationTarget};\n \n #[derive(Debug)]\n pub struct Runnable {\n-    pub range: TextRange,\n+    pub nav: NavigationTarget,\n     pub kind: RunnableKind,\n+    pub cfg_exprs: Vec<CfgExpr>,\n }\n \n #[derive(Debug)]\n@@ -24,8 +24,8 @@ pub enum TestId {\n     Path(String),\n }\n \n-impl Display for TestId {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+impl fmt::Display for TestId {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self {\n             TestId::Name(name) => write!(f, \"{}\", name),\n             TestId::Path(path) => write!(f, \"{}\", path),\n@@ -42,32 +42,47 @@ pub enum RunnableKind {\n     Bin,\n }\n \n+// Feature: Run\n+//\n+// Shows a popup suggesting to run a test/benchmark/binary **at the current cursor\n+// location**. Super useful for repeatedly running just a single test. Do bind this\n+// to a shortcut!\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Rust Analyzer: Run**\n+// |===\n pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n     let sema = Semantics::new(db);\n     let source_file = sema.parse(file_id);\n-    source_file.syntax().descendants().filter_map(|i| runnable(&sema, i)).collect()\n+    source_file.syntax().descendants().filter_map(|i| runnable(&sema, i, file_id)).collect()\n }\n \n-fn runnable(sema: &Semantics<RootDatabase>, item: SyntaxNode) -> Option<Runnable> {\n+fn runnable(sema: &Semantics<RootDatabase>, item: SyntaxNode, file_id: FileId) -> Option<Runnable> {\n     match_ast! {\n         match item {\n-            ast::FnDef(it) => runnable_fn(sema, it),\n-            ast::Module(it) => runnable_mod(sema, it),\n+            ast::FnDef(it) => runnable_fn(sema, it, file_id),\n+            ast::Module(it) => runnable_mod(sema, it, file_id),\n             _ => None,\n         }\n     }\n }\n \n-fn runnable_fn(sema: &Semantics<RootDatabase>, fn_def: ast::FnDef) -> Option<Runnable> {\n+fn runnable_fn(\n+    sema: &Semantics<RootDatabase>,\n+    fn_def: ast::FnDef,\n+    file_id: FileId,\n+) -> Option<Runnable> {\n     let name_string = fn_def.name()?.text().to_string();\n \n     let kind = if name_string == \"main\" {\n         RunnableKind::Bin\n     } else {\n-        let test_id = if let Some(module) = sema.to_def(&fn_def).map(|def| def.module(sema.db)) {\n-            let def = sema.to_def(&fn_def)?;\n-            let impl_trait_name =\n-                def.as_assoc_item(sema.db).and_then(|assoc_item| {\n+        let test_id = match sema.to_def(&fn_def).map(|def| def.module(sema.db)) {\n+            Some(module) => {\n+                let def = sema.to_def(&fn_def)?;\n+                let impl_trait_name = def.as_assoc_item(sema.db).and_then(|assoc_item| {\n                     match assoc_item.container(sema.db) {\n                         hir::AssocItemContainer::Trait(trait_item) => {\n                             Some(trait_item.name(sema.db).to_string())\n@@ -79,25 +94,25 @@ fn runnable_fn(sema: &Semantics<RootDatabase>, fn_def: ast::FnDef) -> Option<Run\n                     }\n                 });\n \n-            let path_iter = module\n-                .path_to_root(sema.db)\n-                .into_iter()\n-                .rev()\n-                .filter_map(|it| it.name(sema.db))\n-                .map(|name| name.to_string());\n-\n-            let path = if let Some(impl_trait_name) = impl_trait_name {\n-                path_iter\n-                    .chain(std::iter::once(impl_trait_name))\n-                    .chain(std::iter::once(name_string))\n-                    .join(\"::\")\n-            } else {\n-                path_iter.chain(std::iter::once(name_string)).join(\"::\")\n-            };\n-\n-            TestId::Path(path)\n-        } else {\n-            TestId::Name(name_string)\n+                let path_iter = module\n+                    .path_to_root(sema.db)\n+                    .into_iter()\n+                    .rev()\n+                    .filter_map(|it| it.name(sema.db))\n+                    .map(|name| name.to_string());\n+\n+                let path = if let Some(impl_trait_name) = impl_trait_name {\n+                    path_iter\n+                        .chain(std::iter::once(impl_trait_name))\n+                        .chain(std::iter::once(name_string))\n+                        .join(\"::\")\n+                } else {\n+                    path_iter.chain(std::iter::once(name_string)).join(\"::\")\n+                };\n+\n+                TestId::Path(path)\n+            }\n+            None => TestId::Name(name_string),\n         };\n \n         if has_test_related_attribute(&fn_def) {\n@@ -111,7 +126,13 @@ fn runnable_fn(sema: &Semantics<RootDatabase>, fn_def: ast::FnDef) -> Option<Run\n             return None;\n         }\n     };\n-    Some(Runnable { range: fn_def.syntax().text_range(), kind })\n+\n+    let attrs = Attrs::from_attrs_owner(sema.db, InFile::new(HirFileId::from(file_id), &fn_def));\n+    let cfg_exprs =\n+        attrs.by_key(\"cfg\").tt_values().map(|subtree| ra_cfg::parse_cfg(subtree)).collect();\n+\n+    let nav = NavigationTarget::from_named(sema.db, InFile::new(file_id.into(), &fn_def));\n+    Some(Runnable { nav, kind, cfg_exprs })\n }\n \n #[derive(Debug)]\n@@ -147,7 +168,11 @@ fn has_doc_test(fn_def: &ast::FnDef) -> bool {\n     fn_def.doc_comment_text().map_or(false, |comment| comment.contains(\"```\"))\n }\n \n-fn runnable_mod(sema: &Semantics<RootDatabase>, module: ast::Module) -> Option<Runnable> {\n+fn runnable_mod(\n+    sema: &Semantics<RootDatabase>,\n+    module: ast::Module,\n+    file_id: FileId,\n+) -> Option<Runnable> {\n     let has_test_function = module\n         .item_list()?\n         .items()\n@@ -159,12 +184,21 @@ fn runnable_mod(sema: &Semantics<RootDatabase>, module: ast::Module) -> Option<R\n     if !has_test_function {\n         return None;\n     }\n-    let range = module.syntax().text_range();\n-    let module = sema.to_def(&module)?;\n+    let module_def = sema.to_def(&module)?;\n \n-    let path =\n-        module.path_to_root(sema.db).into_iter().rev().filter_map(|it| it.name(sema.db)).join(\"::\");\n-    Some(Runnable { range, kind: RunnableKind::TestMod { path } })\n+    let path = module_def\n+        .path_to_root(sema.db)\n+        .into_iter()\n+        .rev()\n+        .filter_map(|it| it.name(sema.db))\n+        .join(\"::\");\n+\n+    let attrs = Attrs::from_attrs_owner(sema.db, InFile::new(HirFileId::from(file_id), &module));\n+    let cfg_exprs =\n+        attrs.by_key(\"cfg\").tt_values().map(|subtree| ra_cfg::parse_cfg(subtree)).collect();\n+\n+    let nav = module_def.to_nav(sema.db);\n+    Some(Runnable { nav, kind: RunnableKind::TestMod { path }, cfg_exprs })\n }\n \n #[cfg(test)]\n@@ -194,11 +228,38 @@ mod tests {\n         @r###\"\n         [\n             Runnable {\n-                range: 1..21,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 1..21,\n+                    name: \"main\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        12..16,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: Bin,\n+                cfg_exprs: [],\n             },\n             Runnable {\n-                range: 22..46,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 22..46,\n+                    name: \"test_foo\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        33..41,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: Test {\n                     test_id: Path(\n                         \"test_foo\",\n@@ -207,9 +268,23 @@ mod tests {\n                         ignore: false,\n                     },\n                 },\n+                cfg_exprs: [],\n             },\n             Runnable {\n-                range: 47..81,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 47..81,\n+                    name: \"test_foo\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        68..76,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: Test {\n                     test_id: Path(\n                         \"test_foo\",\n@@ -218,6 +293,7 @@ mod tests {\n                         ignore: true,\n                     },\n                 },\n+                cfg_exprs: [],\n             },\n         ]\n         \"###\n@@ -243,16 +319,44 @@ mod tests {\n         @r###\"\n         [\n             Runnable {\n-                range: 1..21,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 1..21,\n+                    name: \"main\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        12..16,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: Bin,\n+                cfg_exprs: [],\n             },\n             Runnable {\n-                range: 22..64,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 22..64,\n+                    name: \"foo\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        56..59,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: DocTest {\n                     test_id: Path(\n                         \"foo\",\n                     ),\n                 },\n+                cfg_exprs: [],\n             },\n         ]\n         \"###\n@@ -281,16 +385,44 @@ mod tests {\n         @r###\"\n         [\n             Runnable {\n-                range: 1..21,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 1..21,\n+                    name: \"main\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        12..16,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: Bin,\n+                cfg_exprs: [],\n             },\n             Runnable {\n-                range: 51..105,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 51..105,\n+                    name: \"foo\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        97..100,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: DocTest {\n                     test_id: Path(\n                         \"Data::foo\",\n                     ),\n                 },\n+                cfg_exprs: [],\n             },\n         ]\n         \"###\n@@ -314,13 +446,40 @@ mod tests {\n         @r###\"\n         [\n             Runnable {\n-                range: 1..59,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 1..59,\n+                    name: \"test_mod\",\n+                    kind: MODULE,\n+                    focus_range: Some(\n+                        13..21,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: TestMod {\n                     path: \"test_mod\",\n                 },\n+                cfg_exprs: [],\n             },\n             Runnable {\n-                range: 28..57,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 28..57,\n+                    name: \"test_foo1\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        43..52,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: Test {\n                     test_id: Path(\n                         \"test_mod::test_foo1\",\n@@ -329,6 +488,7 @@ mod tests {\n                         ignore: false,\n                     },\n                 },\n+                cfg_exprs: [],\n             },\n         ]\n         \"###\n@@ -354,13 +514,40 @@ mod tests {\n         @r###\"\n         [\n             Runnable {\n-                range: 23..85,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 23..85,\n+                    name: \"test_mod\",\n+                    kind: MODULE,\n+                    focus_range: Some(\n+                        27..35,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: TestMod {\n                     path: \"foo::test_mod\",\n                 },\n+                cfg_exprs: [],\n             },\n             Runnable {\n-                range: 46..79,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 46..79,\n+                    name: \"test_foo1\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        65..74,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: Test {\n                     test_id: Path(\n                         \"foo::test_mod::test_foo1\",\n@@ -369,6 +556,7 @@ mod tests {\n                         ignore: false,\n                     },\n                 },\n+                cfg_exprs: [],\n             },\n         ]\n         \"###\n@@ -396,13 +584,40 @@ mod tests {\n         @r###\"\n         [\n             Runnable {\n-                range: 41..115,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 41..115,\n+                    name: \"test_mod\",\n+                    kind: MODULE,\n+                    focus_range: Some(\n+                        45..53,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: TestMod {\n                     path: \"foo::bar::test_mod\",\n                 },\n+                cfg_exprs: [],\n             },\n             Runnable {\n-                range: 68..105,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 68..105,\n+                    name: \"test_foo1\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        91..100,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: Test {\n                     test_id: Path(\n                         \"foo::bar::test_mod::test_foo1\",\n@@ -411,6 +626,115 @@ mod tests {\n                         ignore: false,\n                     },\n                 },\n+                cfg_exprs: [],\n+            },\n+        ]\n+        \"###\n+                );\n+    }\n+\n+    #[test]\n+    fn test_runnables_with_feature() {\n+        let (analysis, pos) = analysis_and_position(\n+            r#\"\n+        //- /lib.rs crate:foo cfg:feature=foo\n+        <|> //empty\n+        #[test]\n+        #[cfg(feature = \"foo\")]\n+        fn test_foo1() {}\n+        \"#,\n+        );\n+        let runnables = analysis.runnables(pos.file_id).unwrap();\n+        assert_debug_snapshot!(&runnables,\n+        @r###\"\n+        [\n+            Runnable {\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 1..58,\n+                    name: \"test_foo1\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        44..53,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n+                kind: Test {\n+                    test_id: Path(\n+                        \"test_foo1\",\n+                    ),\n+                    attr: TestAttr {\n+                        ignore: false,\n+                    },\n+                },\n+                cfg_exprs: [\n+                    KeyValue {\n+                        key: \"feature\",\n+                        value: \"foo\",\n+                    },\n+                ],\n+            },\n+        ]\n+        \"###\n+                );\n+    }\n+\n+    #[test]\n+    fn test_runnables_with_features() {\n+        let (analysis, pos) = analysis_and_position(\n+            r#\"\n+        //- /lib.rs crate:foo cfg:feature=foo,feature=bar\n+        <|> //empty\n+        #[test]\n+        #[cfg(all(feature = \"foo\", feature = \"bar\"))]\n+        fn test_foo1() {}\n+        \"#,\n+        );\n+        let runnables = analysis.runnables(pos.file_id).unwrap();\n+        assert_debug_snapshot!(&runnables,\n+        @r###\"\n+        [\n+            Runnable {\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 1..80,\n+                    name: \"test_foo1\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        66..75,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n+                kind: Test {\n+                    test_id: Path(\n+                        \"test_foo1\",\n+                    ),\n+                    attr: TestAttr {\n+                        ignore: false,\n+                    },\n+                },\n+                cfg_exprs: [\n+                    All(\n+                        [\n+                            KeyValue {\n+                                key: \"feature\",\n+                                value: \"foo\",\n+                            },\n+                            KeyValue {\n+                                key: \"feature\",\n+                                value: \"bar\",\n+                            },\n+                        ],\n+                    ),\n+                ],\n             },\n         ]\n         \"###"}, {"sha": "fcdc98201f2e465d78224d75e879a00185ac3d4b", "filename": "crates/ra_ide/src/snapshots/highlight_injection.html", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_injection.html", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_injection.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_injection.html?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -10,13 +10,15 @@\n .string_literal     { color: #CC9393; }\n .field              { color: #94BFF3; }\n .function           { color: #93E0E3; }\n+.operator.unsafe    { color: #E28C14; }\n .parameter          { color: #94BFF3; }\n .text               { color: #DCDCCC; }\n .type               { color: #7CB8BB; }\n .builtin_type       { color: #8CD0D3; }\n .type_param         { color: #DFAF8F; }\n .attribute          { color: #94BFF3; }\n .numeric_literal    { color: #BFEBBF; }\n+.bool_literal       { color: #BFE6EB; }\n .macro              { color: #94BFF3; }\n .module             { color: #AFD8AF; }\n .variable           { color: #DCDCCC; }"}, {"sha": "e97192b614a01e59724ce6e85162f0801b797059", "filename": "crates/ra_ide/src/snapshots/highlight_strings.html", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -10,13 +10,15 @@\n .string_literal     { color: #CC9393; }\n .field              { color: #94BFF3; }\n .function           { color: #93E0E3; }\n+.operator.unsafe    { color: #E28C14; }\n .parameter          { color: #94BFF3; }\n .text               { color: #DCDCCC; }\n .type               { color: #7CB8BB; }\n .builtin_type       { color: #8CD0D3; }\n .type_param         { color: #DFAF8F; }\n .attribute          { color: #94BFF3; }\n .numeric_literal    { color: #BFEBBF; }\n+.bool_literal       { color: #BFE6EB; }\n .macro              { color: #94BFF3; }\n .module             { color: #AFD8AF; }\n .variable           { color: #DCDCCC; }\n@@ -51,6 +53,7 @@\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"format_specifier\">{</span><span class=\"variable\">argument</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">\"</span>, argument = <span class=\"string_literal\">\"test\"</span>);   <span class=\"comment\">// =&gt; \"test\"</span>\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"format_specifier\">{</span><span class=\"variable\">name</span><span class=\"format_specifier\">}</span><span class=\"string_literal\"> </span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">\"</span>, <span class=\"numeric_literal\">1</span>, name = <span class=\"numeric_literal\">2</span>);          <span class=\"comment\">// =&gt; \"2 1\"</span>\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"format_specifier\">{</span><span class=\"variable\">a</span><span class=\"format_specifier\">}</span><span class=\"string_literal\"> </span><span class=\"format_specifier\">{</span><span class=\"variable\">c</span><span class=\"format_specifier\">}</span><span class=\"string_literal\"> </span><span class=\"format_specifier\">{</span><span class=\"variable\">b</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">\"</span>, a=<span class=\"string_literal\">\"a\"</span>, b=<span class=\"char_literal\">'b'</span>, c=<span class=\"numeric_literal\">3</span>);  <span class=\"comment\">// =&gt; \"a 3 b\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"{{</span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">}}\"</span>, <span class=\"numeric_literal\">2</span>);                       <span class=\"comment\">// =&gt; \"{2}\"</span>\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">:</span><span class=\"numeric_literal\">5</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"x\"</span>);\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">:</span><span class=\"numeric_literal\">1</span><span class=\"format_specifier\">$</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"x\"</span>, <span class=\"numeric_literal\">5</span>);\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"format_specifier\">{</span><span class=\"numeric_literal\">1</span><span class=\"format_specifier\">:</span><span class=\"numeric_literal\">0</span><span class=\"format_specifier\">$</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"numeric_literal\">5</span>, <span class=\"string_literal\">\"x\"</span>);"}, {"sha": "17ffc727cd064db0435e0083be8e56c4aeb89a46", "filename": "crates/ra_ide/src/snapshots/highlight_unsafe.html", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_unsafe.html", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_unsafe.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_unsafe.html?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -0,0 +1,48 @@\n+\n+<style>\n+body                { margin: 0; }\n+pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padding: 0.4em; }\n+\n+.lifetime           { color: #DFAF8F; font-style: italic; }\n+.comment            { color: #7F9F7F; }\n+.struct, .enum      { color: #7CB8BB; }\n+.enum_variant       { color: #BDE0F3; }\n+.string_literal     { color: #CC9393; }\n+.field              { color: #94BFF3; }\n+.function           { color: #93E0E3; }\n+.operator.unsafe    { color: #E28C14; }\n+.parameter          { color: #94BFF3; }\n+.text               { color: #DCDCCC; }\n+.type               { color: #7CB8BB; }\n+.builtin_type       { color: #8CD0D3; }\n+.type_param         { color: #DFAF8F; }\n+.attribute          { color: #94BFF3; }\n+.numeric_literal    { color: #BFEBBF; }\n+.bool_literal       { color: #BFE6EB; }\n+.macro              { color: #94BFF3; }\n+.module             { color: #AFD8AF; }\n+.variable           { color: #DCDCCC; }\n+.format_specifier   { color: #CC696B; }\n+.mutable            { text-decoration: underline; }\n+\n+.keyword            { color: #F0DFAF; font-weight: bold; }\n+.keyword.unsafe     { color: #BC8383; font-weight: bold; }\n+.control            { font-style: italic; }\n+</style>\n+<pre><code><span class=\"keyword unsafe\">unsafe</span> <span class=\"keyword\">fn</span> <span class=\"function declaration unsafe\">unsafe_fn</span>() {}\n+\n+<span class=\"keyword\">struct</span> <span class=\"struct declaration\">HasUnsafeFn</span>;\n+\n+<span class=\"keyword\">impl</span> <span class=\"struct\">HasUnsafeFn</span> {\n+    <span class=\"keyword unsafe\">unsafe</span> <span class=\"keyword\">fn</span> <span class=\"function declaration unsafe\">unsafe_method</span>(&<span class=\"self_keyword\">self</span>) {}\n+}\n+\n+<span class=\"keyword\">fn</span> <span class=\"function declaration\">main</span>() {\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration\">x</span> = &<span class=\"numeric_literal\">5</span> <span class=\"keyword\">as</span> *<span class=\"keyword\">const</span> <span class=\"builtin_type\">usize</span>;\n+    <span class=\"keyword unsafe\">unsafe</span> {\n+        <span class=\"function unsafe\">unsafe_fn</span>();\n+        <span class=\"struct\">HasUnsafeFn</span>.<span class=\"function unsafe\">unsafe_method</span>();\n+        <span class=\"keyword\">let</span> <span class=\"variable declaration\">y</span> = <span class=\"operator unsafe\">*</span><span class=\"variable\">x</span>;\n+        <span class=\"keyword\">let</span> <span class=\"variable declaration\">z</span> = -<span class=\"variable\">x</span>;\n+    }\n+}</code></pre>\n\\ No newline at end of file"}, {"sha": "42c5f3e5515e7e24fd739fe70cd0550067d9c983", "filename": "crates/ra_ide/src/snapshots/highlighting.html", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -10,13 +10,15 @@\n .string_literal     { color: #CC9393; }\n .field              { color: #94BFF3; }\n .function           { color: #93E0E3; }\n+.operator.unsafe    { color: #E28C14; }\n .parameter          { color: #94BFF3; }\n .text               { color: #DCDCCC; }\n .type               { color: #7CB8BB; }\n .builtin_type       { color: #8CD0D3; }\n .type_param         { color: #DFAF8F; }\n .attribute          { color: #94BFF3; }\n .numeric_literal    { color: #BFEBBF; }\n+.bool_literal       { color: #BFE6EB; }\n .macro              { color: #94BFF3; }\n .module             { color: #AFD8AF; }\n .variable           { color: #DCDCCC; }\n@@ -27,19 +29,19 @@\n .keyword.unsafe     { color: #BC8383; font-weight: bold; }\n .control            { font-style: italic; }\n </style>\n-<pre><code><span class=\"attribute\">#[derive(Clone, Debug)]</span>\n+<pre><code><span class=\"attribute\">#[</span><span class=\"function attribute\">derive</span><span class=\"attribute\">(Clone, Debug)]</span>\n <span class=\"keyword\">struct</span> <span class=\"struct declaration\">Foo</span> {\n     <span class=\"keyword\">pub</span> <span class=\"field declaration\">x</span>: <span class=\"builtin_type\">i32</span>,\n     <span class=\"keyword\">pub</span> <span class=\"field declaration\">y</span>: <span class=\"builtin_type\">i32</span>,\n }\n \n <span class=\"keyword\">trait</span> <span class=\"trait declaration\">Bar</span> {\n-    <span class=\"keyword\">fn</span> <span class=\"function declaration\">bar</span>(&<span class=\"keyword\">self</span>) -&gt; <span class=\"builtin_type\">i32</span>;\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration\">bar</span>(&<span class=\"self_keyword\">self</span>) -&gt; <span class=\"builtin_type\">i32</span>;\n }\n \n <span class=\"keyword\">impl</span> <span class=\"trait\">Bar</span> <span class=\"keyword\">for</span> <span class=\"struct\">Foo</span> {\n-    <span class=\"keyword\">fn</span> <span class=\"function declaration\">bar</span>(&<span class=\"keyword\">self</span>) -&gt; <span class=\"builtin_type\">i32</span> {\n-        <span class=\"keyword\">self</span>.<span class=\"field\">x</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration\">bar</span>(&<span class=\"self_keyword\">self</span>) -&gt; <span class=\"builtin_type\">i32</span> {\n+        <span class=\"self_keyword\">self</span>.<span class=\"field\">x</span>\n     }\n }\n \n@@ -64,7 +66,7 @@\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello, {}!\"</span>, <span class=\"numeric_literal\">92</span>);\n \n     <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable declaration mutable\">vec</span> = <span class=\"unresolved_reference\">Vec</span>::<span class=\"unresolved_reference\">new</span>();\n-    <span class=\"keyword control\">if</span> <span class=\"keyword\">true</span> {\n+    <span class=\"keyword control\">if</span> <span class=\"bool_literal\">true</span> {\n         <span class=\"keyword\">let</span> <span class=\"variable declaration\">x</span> = <span class=\"numeric_literal\">92</span>;\n         <span class=\"variable mutable\">vec</span>.<span class=\"unresolved_reference\">push</span>(<span class=\"struct\">Foo</span> { <span class=\"field\">x</span>, <span class=\"field\">y</span>: <span class=\"numeric_literal\">1</span> });\n     }\n@@ -91,7 +93,7 @@\n <span class=\"keyword\">use</span> <span class=\"enum\">Option</span>::*;\n \n <span class=\"keyword\">impl</span>&lt;<span class=\"type_param declaration\">T</span>&gt; <span class=\"enum\">Option</span>&lt;<span class=\"type_param\">T</span>&gt; {\n-    <span class=\"keyword\">fn</span> <span class=\"function declaration\">and</span>&lt;<span class=\"type_param declaration\">U</span>&gt;(<span class=\"keyword\">self</span>, <span class=\"variable declaration\">other</span>: <span class=\"enum\">Option</span>&lt;<span class=\"type_param\">U</span>&gt;) -&gt; <span class=\"enum\">Option</span>&lt;(<span class=\"type_param\">T</span>, <span class=\"type_param\">U</span>)&gt; {\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration\">and</span>&lt;<span class=\"type_param declaration\">U</span>&gt;(<span class=\"self_keyword\">self</span>, <span class=\"variable declaration\">other</span>: <span class=\"enum\">Option</span>&lt;<span class=\"type_param\">U</span>&gt;) -&gt; <span class=\"enum\">Option</span>&lt;(<span class=\"type_param\">T</span>, <span class=\"type_param\">U</span>)&gt; {\n         <span class=\"keyword control\">match</span> <span class=\"variable\">other</span> {\n             <span class=\"enum_variant\">None</span> =&gt; <span class=\"macro\">unimplemented!</span>(),\n             <span class=\"variable declaration\">Nope</span> =&gt; <span class=\"variable\">Nope</span>,"}, {"sha": "2dd61d20d6912cce61c2f14e9ddca9fc5b5f1bb2", "filename": "crates/ra_ide/src/snapshots/rainbow_highlighting.html", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -10,13 +10,15 @@\n .string_literal     { color: #CC9393; }\n .field              { color: #94BFF3; }\n .function           { color: #93E0E3; }\n+.operator.unsafe    { color: #E28C14; }\n .parameter          { color: #94BFF3; }\n .text               { color: #DCDCCC; }\n .type               { color: #7CB8BB; }\n .builtin_type       { color: #8CD0D3; }\n .type_param         { color: #DFAF8F; }\n .attribute          { color: #94BFF3; }\n .numeric_literal    { color: #BFEBBF; }\n+.bool_literal       { color: #BFE6EB; }\n .macro              { color: #94BFF3; }\n .module             { color: #AFD8AF; }\n .variable           { color: #DCDCCC; }"}, {"sha": "93e9aee1d01e47ca8db25bef13bef269f91ce4f1", "filename": "crates/ra_ide/src/ssr.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fssr.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,5 +1,3 @@\n-//!  structural search replace\n-\n use std::{collections::HashMap, iter::once, str::FromStr};\n \n use ra_db::{SourceDatabase, SourceDatabaseExt};\n@@ -25,6 +23,28 @@ impl std::fmt::Display for SsrError {\n \n impl std::error::Error for SsrError {}\n \n+// Feature: Structural Seach and Replace\n+//\n+// Search and replace with named wildcards that will match any expression.\n+// The syntax for a structural search replace command is `<search_pattern> ==>> <replace_pattern>`.\n+// A `$<name>:expr` placeholder in the search pattern will match any expression and `$<name>` will reference it in the replacement.\n+// Available via the command `rust-analyzer.ssr`.\n+//\n+// ```rust\n+// // Using structural search replace command [foo($a:expr, $b:expr) ==>> ($a).foo($b)]\n+//\n+// // BEFORE\n+// String::from(foo(y + 5, z))\n+//\n+// // AFTER\n+// String::from((y + 5).foo(z))\n+// ```\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Rust Analyzer: Structural Search Replace**\n+// |===\n pub fn parse_search_replace(\n     query: &str,\n     parse_only: bool,\n@@ -196,10 +216,10 @@ fn find(pattern: &SsrPattern, code: &SyntaxNode) -> SsrMatches {\n     ) -> Option<Match> {\n         let match_ = check_opt_nodes(pattern.path(), code.path(), placeholders, match_)?;\n \n-        let mut pattern_fields =\n-            pattern.record_field_list().map(|x| x.fields().collect()).unwrap_or(vec![]);\n-        let mut code_fields =\n-            code.record_field_list().map(|x| x.fields().collect()).unwrap_or(vec![]);\n+        let mut pattern_fields: Vec<RecordField> =\n+            pattern.record_field_list().map(|x| x.fields().collect()).unwrap_or_default();\n+        let mut code_fields: Vec<RecordField> =\n+            code.record_field_list().map(|x| x.fields().collect()).unwrap_or_default();\n \n         if pattern_fields.len() != code_fields.len() {\n             return None;"}, {"sha": "5b7992920071d5f3e335555e98d37cdfdbc3cc5b", "filename": "crates/ra_ide/src/status.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fstatus.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n use std::{fmt, iter::FromIterator, sync::Arc};\n \n use hir::MacroFile;\n@@ -26,6 +24,15 @@ fn macro_syntax_tree_stats(db: &RootDatabase) -> SyntaxTreeStats {\n     db.query(hir::db::ParseMacroQuery).entries::<SyntaxTreeStats>()\n }\n \n+// Feature: Status\n+//\n+// Shows internal statistic about memory usage of rust-analyzer.\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Rust Analyzer: Status**\n+// |===\n pub(crate) fn status(db: &RootDatabase) -> String {\n     let files_stats = db.query(FileTextQuery).entries::<FilesStats>();\n     let syntax_tree_stats = syntax_tree_stats(db);"}, {"sha": "19ecd54d6cf2cdaee5fd20c0e3743fed96e3821e", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 133, "deletions": 90, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,5 +1,3 @@\n-//! Implements syntax highlighting.\n-\n mod tags;\n mod html;\n #[cfg(test)]\n@@ -32,81 +30,15 @@ pub struct HighlightedRange {\n     pub binding_hash: Option<u64>,\n }\n \n-#[derive(Debug)]\n-struct HighlightedRangeStack {\n-    stack: Vec<Vec<HighlightedRange>>,\n-}\n-\n-/// We use a stack to implement the flattening logic for the highlighted\n-/// syntax ranges.\n-impl HighlightedRangeStack {\n-    fn new() -> Self {\n-        Self { stack: vec![Vec::new()] }\n-    }\n-\n-    fn push(&mut self) {\n-        self.stack.push(Vec::new());\n-    }\n-\n-    /// Flattens the highlighted ranges.\n-    ///\n-    /// For example `#[cfg(feature = \"foo\")]` contains the nested ranges:\n-    /// 1) parent-range: Attribute [0, 23)\n-    /// 2) child-range: String [16, 21)\n-    ///\n-    /// The following code implements the flattening, for our example this results to:\n-    /// `[Attribute [0, 16), String [16, 21), Attribute [21, 23)]`\n-    fn pop(&mut self) {\n-        let children = self.stack.pop().unwrap();\n-        let prev = self.stack.last_mut().unwrap();\n-        let needs_flattening = !children.is_empty()\n-            && !prev.is_empty()\n-            && prev.last().unwrap().range.contains_range(children.first().unwrap().range);\n-        if !needs_flattening {\n-            prev.extend(children);\n-        } else {\n-            let mut parent = prev.pop().unwrap();\n-            for ele in children {\n-                assert!(parent.range.contains_range(ele.range));\n-                let mut cloned = parent.clone();\n-                parent.range = TextRange::new(parent.range.start(), ele.range.start());\n-                cloned.range = TextRange::new(ele.range.end(), cloned.range.end());\n-                if !parent.range.is_empty() {\n-                    prev.push(parent);\n-                }\n-                prev.push(ele);\n-                parent = cloned;\n-            }\n-            if !parent.range.is_empty() {\n-                prev.push(parent);\n-            }\n-        }\n-    }\n-\n-    fn add(&mut self, range: HighlightedRange) {\n-        self.stack\n-            .last_mut()\n-            .expect(\"during DFS traversal, the stack must not be empty\")\n-            .push(range)\n-    }\n-\n-    fn flattened(mut self) -> Vec<HighlightedRange> {\n-        assert_eq!(\n-            self.stack.len(),\n-            1,\n-            \"after DFS traversal, the stack should only contain a single element\"\n-        );\n-        let mut res = self.stack.pop().unwrap();\n-        res.sort_by_key(|range| range.range.start());\n-        // Check that ranges are sorted and disjoint\n-        assert!(res\n-            .iter()\n-            .zip(res.iter().skip(1))\n-            .all(|(left, right)| left.range.end() <= right.range.start()));\n-        res\n-    }\n-}\n-\n+// Feature: Semantic Syntax Highlighting\n+//\n+// rust-analyzer highlights the code semantically.\n+// For example, `bar` in `foo::Bar` might be colored differently depending on whether `Bar` is an enum or a trait.\n+// rust-analyzer does not specify colors directly, instead it assigns tag (like `struct`) and a set of modifiers (like `declaration`) to each token.\n+// It's up to the client to map those to specific colors.\n+//\n+// The general rule is that a reference to an entity gets colored the same way as the entity itself.\n+// We also give special modifier for `mut` and `&mut` local variables.\n pub(crate) fn highlight(\n     db: &RootDatabase,\n     file_id: FileId,\n@@ -291,6 +223,81 @@ pub(crate) fn highlight(\n     stack.flattened()\n }\n \n+#[derive(Debug)]\n+struct HighlightedRangeStack {\n+    stack: Vec<Vec<HighlightedRange>>,\n+}\n+\n+/// We use a stack to implement the flattening logic for the highlighted\n+/// syntax ranges.\n+impl HighlightedRangeStack {\n+    fn new() -> Self {\n+        Self { stack: vec![Vec::new()] }\n+    }\n+\n+    fn push(&mut self) {\n+        self.stack.push(Vec::new());\n+    }\n+\n+    /// Flattens the highlighted ranges.\n+    ///\n+    /// For example `#[cfg(feature = \"foo\")]` contains the nested ranges:\n+    /// 1) parent-range: Attribute [0, 23)\n+    /// 2) child-range: String [16, 21)\n+    ///\n+    /// The following code implements the flattening, for our example this results to:\n+    /// `[Attribute [0, 16), String [16, 21), Attribute [21, 23)]`\n+    fn pop(&mut self) {\n+        let children = self.stack.pop().unwrap();\n+        let prev = self.stack.last_mut().unwrap();\n+        let needs_flattening = !children.is_empty()\n+            && !prev.is_empty()\n+            && prev.last().unwrap().range.contains_range(children.first().unwrap().range);\n+        if !needs_flattening {\n+            prev.extend(children);\n+        } else {\n+            let mut parent = prev.pop().unwrap();\n+            for ele in children {\n+                assert!(parent.range.contains_range(ele.range));\n+                let mut cloned = parent.clone();\n+                parent.range = TextRange::new(parent.range.start(), ele.range.start());\n+                cloned.range = TextRange::new(ele.range.end(), cloned.range.end());\n+                if !parent.range.is_empty() {\n+                    prev.push(parent);\n+                }\n+                prev.push(ele);\n+                parent = cloned;\n+            }\n+            if !parent.range.is_empty() {\n+                prev.push(parent);\n+            }\n+        }\n+    }\n+\n+    fn add(&mut self, range: HighlightedRange) {\n+        self.stack\n+            .last_mut()\n+            .expect(\"during DFS traversal, the stack must not be empty\")\n+            .push(range)\n+    }\n+\n+    fn flattened(mut self) -> Vec<HighlightedRange> {\n+        assert_eq!(\n+            self.stack.len(),\n+            1,\n+            \"after DFS traversal, the stack should only contain a single element\"\n+        );\n+        let mut res = self.stack.pop().unwrap();\n+        res.sort_by_key(|range| range.range.start());\n+        // Check that ranges are sorted and disjoint\n+        assert!(res\n+            .iter()\n+            .zip(res.iter().skip(1))\n+            .all(|(left, right)| left.range.end() <= right.range.start()));\n+        res\n+    }\n+}\n+\n fn highlight_format_specifier(kind: FormatSpecifier) -> Option<HighlightTag> {\n     Some(match kind {\n         FormatSpecifier::Open\n@@ -361,7 +368,9 @@ fn highlight_element(\n         }\n \n         // Highlight references like the definitions they resolve to\n-        NAME_REF if element.ancestors().any(|it| it.kind() == ATTR) => return None,\n+        NAME_REF if element.ancestors().any(|it| it.kind() == ATTR) => {\n+            Highlight::from(HighlightTag::Function) | HighlightModifier::Attribute\n+        }\n         NAME_REF => {\n             let name_ref = element.into_node().and_then(ast::NameRef::cast).unwrap();\n             match classify_name_ref(sema, &name_ref) {\n@@ -389,13 +398,31 @@ fn highlight_element(\n         INT_NUMBER | FLOAT_NUMBER => HighlightTag::NumericLiteral.into(),\n         BYTE => HighlightTag::ByteLiteral.into(),\n         CHAR => HighlightTag::CharLiteral.into(),\n+        QUESTION => Highlight::new(HighlightTag::Operator) | HighlightModifier::ControlFlow,\n         LIFETIME => {\n             let h = Highlight::new(HighlightTag::Lifetime);\n             match element.parent().map(|it| it.kind()) {\n                 Some(LIFETIME_PARAM) | Some(LABEL) => h | HighlightModifier::Definition,\n                 _ => h,\n             }\n         }\n+        PREFIX_EXPR => {\n+            let prefix_expr = element.into_node().and_then(ast::PrefixExpr::cast)?;\n+            match prefix_expr.op_kind() {\n+                Some(ast::PrefixOp::Deref) => {}\n+                _ => return None,\n+            }\n+\n+            let expr = prefix_expr.expr()?;\n+            let ty = sema.type_of_expr(&expr)?;\n+            if !ty.is_raw_ptr() {\n+                return None;\n+            }\n+\n+            let mut h = Highlight::new(HighlightTag::Operator);\n+            h |= HighlightModifier::Unsafe;\n+            h\n+        }\n \n         k if k.is_keyword() => {\n             let h = Highlight::new(HighlightTag::Keyword);\n@@ -411,6 +438,8 @@ fn highlight_element(\n                 | T![in] => h | HighlightModifier::ControlFlow,\n                 T![for] if !is_child_of_impl(element) => h | HighlightModifier::ControlFlow,\n                 T![unsafe] => h | HighlightModifier::Unsafe,\n+                T![true] | T![false] => HighlightTag::BoolLiteral.into(),\n+                T![self] => HighlightTag::SelfKeyword.into(),\n                 _ => h,\n             }\n         }\n@@ -446,7 +475,13 @@ fn highlight_name(db: &RootDatabase, def: Definition) -> Highlight {\n         Definition::Field(_) => HighlightTag::Field,\n         Definition::ModuleDef(def) => match def {\n             hir::ModuleDef::Module(_) => HighlightTag::Module,\n-            hir::ModuleDef::Function(_) => HighlightTag::Function,\n+            hir::ModuleDef::Function(func) => {\n+                let mut h = HighlightTag::Function.into();\n+                if func.is_unsafe(db) {\n+                    h |= HighlightModifier::Unsafe;\n+                }\n+                return h;\n+            }\n             hir::ModuleDef::Adt(hir::Adt::Struct(_)) => HighlightTag::Struct,\n             hir::ModuleDef::Adt(hir::Adt::Enum(_)) => HighlightTag::Enum,\n             hir::ModuleDef::Adt(hir::Adt::Union(_)) => HighlightTag::Union,\n@@ -478,23 +513,31 @@ fn highlight_name(db: &RootDatabase, def: Definition) -> Highlight {\n }\n \n fn highlight_name_by_syntax(name: ast::Name) -> Highlight {\n-    let default = HighlightTag::Function.into();\n+    let default = HighlightTag::UnresolvedReference;\n \n     let parent = match name.syntax().parent() {\n         Some(it) => it,\n-        _ => return default,\n+        _ => return default.into(),\n     };\n \n-    match parent.kind() {\n-        STRUCT_DEF => HighlightTag::Struct.into(),\n-        ENUM_DEF => HighlightTag::Enum.into(),\n-        UNION_DEF => HighlightTag::Union.into(),\n-        TRAIT_DEF => HighlightTag::Trait.into(),\n-        TYPE_ALIAS_DEF => HighlightTag::TypeAlias.into(),\n-        TYPE_PARAM => HighlightTag::TypeParam.into(),\n-        RECORD_FIELD_DEF => HighlightTag::Field.into(),\n+    let tag = match parent.kind() {\n+        STRUCT_DEF => HighlightTag::Struct,\n+        ENUM_DEF => HighlightTag::Enum,\n+        UNION_DEF => HighlightTag::Union,\n+        TRAIT_DEF => HighlightTag::Trait,\n+        TYPE_ALIAS_DEF => HighlightTag::TypeAlias,\n+        TYPE_PARAM => HighlightTag::TypeParam,\n+        RECORD_FIELD_DEF => HighlightTag::Field,\n+        MODULE => HighlightTag::Module,\n+        FN_DEF => HighlightTag::Function,\n+        CONST_DEF => HighlightTag::Constant,\n+        STATIC_DEF => HighlightTag::Static,\n+        ENUM_VARIANT => HighlightTag::EnumVariant,\n+        BIND_PAT => HighlightTag::Local,\n         _ => default,\n-    }\n+    };\n+\n+    tag.into()\n }\n \n fn highlight_injection("}, {"sha": "7d946c98dae771ca20d4baf3f8734a2d24de46bf", "filename": "crates/ra_ide/src/syntax_highlighting/html.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -69,13 +69,15 @@ pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padd\n .string_literal     { color: #CC9393; }\n .field              { color: #94BFF3; }\n .function           { color: #93E0E3; }\n+.operator.unsafe    { color: #E28C14; }\n .parameter          { color: #94BFF3; }\n .text               { color: #DCDCCC; }\n .type               { color: #7CB8BB; }\n .builtin_type       { color: #8CD0D3; }\n .type_param         { color: #DFAF8F; }\n .attribute          { color: #94BFF3; }\n .numeric_literal    { color: #BFEBBF; }\n+.bool_literal       { color: #BFE6EB; }\n .macro              { color: #94BFF3; }\n .module             { color: #AFD8AF; }\n .variable           { color: #DCDCCC; }"}, {"sha": "94f466966a3a642899fbac6109125482dc6ff76c", "filename": "crates/ra_ide/src/syntax_highlighting/tags.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -15,6 +15,7 @@ pub struct HighlightModifiers(u32);\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n pub enum HighlightTag {\n     Attribute,\n+    BoolLiteral,\n     BuiltinType,\n     ByteLiteral,\n     CharLiteral,\n@@ -23,12 +24,15 @@ pub enum HighlightTag {\n     Enum,\n     EnumVariant,\n     Field,\n+    FormatSpecifier,\n     Function,\n     Keyword,\n     Lifetime,\n     Macro,\n     Module,\n     NumericLiteral,\n+    Operator,\n+    SelfKeyword,\n     SelfType,\n     Static,\n     StringLiteral,\n@@ -39,14 +43,15 @@ pub enum HighlightTag {\n     Union,\n     Local,\n     UnresolvedReference,\n-    FormatSpecifier,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n #[repr(u8)]\n pub enum HighlightModifier {\n+    /// Used to differentiate individual elements within attributes.\n+    Attribute = 0,\n     /// Used with keywords like `if` and `break`.\n-    ControlFlow = 0,\n+    ControlFlow,\n     /// `foo` in `fn foo(x: i32)` is a definition, `foo` in `foo(90 + 2)` is\n     /// not.\n     Definition,\n@@ -58,6 +63,7 @@ impl HighlightTag {\n     fn as_str(self) -> &'static str {\n         match self {\n             HighlightTag::Attribute => \"attribute\",\n+            HighlightTag::BoolLiteral => \"bool_literal\",\n             HighlightTag::BuiltinType => \"builtin_type\",\n             HighlightTag::ByteLiteral => \"byte_literal\",\n             HighlightTag::CharLiteral => \"char_literal\",\n@@ -66,12 +72,15 @@ impl HighlightTag {\n             HighlightTag::Enum => \"enum\",\n             HighlightTag::EnumVariant => \"enum_variant\",\n             HighlightTag::Field => \"field\",\n+            HighlightTag::FormatSpecifier => \"format_specifier\",\n             HighlightTag::Function => \"function\",\n             HighlightTag::Keyword => \"keyword\",\n             HighlightTag::Lifetime => \"lifetime\",\n             HighlightTag::Macro => \"macro\",\n             HighlightTag::Module => \"module\",\n             HighlightTag::NumericLiteral => \"numeric_literal\",\n+            HighlightTag::Operator => \"operator\",\n+            HighlightTag::SelfKeyword => \"self_keyword\",\n             HighlightTag::SelfType => \"self_type\",\n             HighlightTag::Static => \"static\",\n             HighlightTag::StringLiteral => \"string_literal\",\n@@ -82,7 +91,6 @@ impl HighlightTag {\n             HighlightTag::Union => \"union\",\n             HighlightTag::Local => \"variable\",\n             HighlightTag::UnresolvedReference => \"unresolved_reference\",\n-            HighlightTag::FormatSpecifier => \"format_specifier\",\n         }\n     }\n }\n@@ -95,6 +103,7 @@ impl fmt::Display for HighlightTag {\n \n impl HighlightModifier {\n     const ALL: &'static [HighlightModifier] = &[\n+        HighlightModifier::Attribute,\n         HighlightModifier::ControlFlow,\n         HighlightModifier::Definition,\n         HighlightModifier::Mutable,\n@@ -103,6 +112,7 @@ impl HighlightModifier {\n \n     fn as_str(self) -> &'static str {\n         match self {\n+            HighlightModifier::Attribute => \"attribute\",\n             HighlightModifier::ControlFlow => \"control\",\n             HighlightModifier::Definition => \"declaration\",\n             HighlightModifier::Mutable => \"mutable\","}, {"sha": "36a1aa419bc3e1d6ed12896478b5e496beee9d5e", "filename": "crates/ra_ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -218,6 +218,7 @@ fn main() {\n     println!(\"{argument}\", argument = \"test\");   // => \"test\"\n     println!(\"{name} {}\", 1, name = 2);          // => \"2 1\"\n     println!(\"{a} {c} {b}\", a=\"a\", b='b', c=3);  // => \"a 3 b\"\n+    println!(\"{{{}}}\", 2);                       // => \"{2}\"\n     println!(\"Hello {:5}!\", \"x\");\n     println!(\"Hello {:1$}!\", \"x\", 5);\n     println!(\"Hello {1:0$}!\", 5, \"x\");\n@@ -257,3 +258,34 @@ fn main() {\n     fs::write(dst_file, &actual_html).unwrap();\n     assert_eq_text!(expected_html, actual_html);\n }\n+\n+#[test]\n+fn test_unsafe_highlighting() {\n+    let (analysis, file_id) = single_file(\n+        r#\"\n+unsafe fn unsafe_fn() {}\n+\n+struct HasUnsafeFn;\n+\n+impl HasUnsafeFn {\n+    unsafe fn unsafe_method(&self) {}\n+}\n+\n+fn main() {\n+    let x = &5 as *const usize;\n+    unsafe {\n+        unsafe_fn();\n+        HasUnsafeFn.unsafe_method();\n+        let y = *x;\n+        let z = -x;\n+    }\n+}\n+\"#\n+        .trim(),\n+    );\n+    let dst_file = project_dir().join(\"crates/ra_ide/src/snapshots/highlight_unsafe.html\");\n+    let actual_html = &analysis.highlight_as_html(file_id, false).unwrap();\n+    let expected_html = &read_text(&dst_file);\n+    fs::write(dst_file, &actual_html).unwrap();\n+    assert_eq_text!(expected_html, actual_html);\n+}"}, {"sha": "a341684fda203cf697c758a438d36ba144c75684", "filename": "crates/ra_ide/src/syntax_tree.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,15 +1,21 @@\n-//! FIXME: write short doc here\n-\n-use ra_db::SourceDatabase;\n+use ra_db::{FileId, SourceDatabase};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo, AstNode, NodeOrToken, SourceFile,\n     SyntaxKind::{RAW_STRING, STRING},\n     SyntaxToken, TextRange, TextSize,\n };\n \n-pub use ra_db::FileId;\n-\n+// Feature: Show Syntax Tree\n+//\n+// Shows the parse tree of the current file. It exists mostly for debugging\n+// rust-analyzer itself.\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Rust Analyzer: Show Syntax Tree**\n+// |===\n pub(crate) fn syntax_tree(\n     db: &RootDatabase,\n     file_id: FileId,"}, {"sha": "67e2c33a000ed95ba9f28855923e37ee7cadfe11", "filename": "crates/ra_ide/src/typing.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ftyping.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -32,6 +32,13 @@ pub(crate) use on_enter::on_enter;\n \n pub(crate) const TRIGGER_CHARS: &str = \".=>\";\n \n+// Feature: On Typing Assists\n+//\n+// Some features trigger on typing certain characters:\n+//\n+// - typing `let =` tries to smartly add `;` if `=` is followed by an existing expression\n+// - Enter inside comments automatically inserts `///`\n+// - typing `.` in a chain method call auto-indents\n pub(crate) fn on_char_typed(\n     db: &RootDatabase,\n     position: FilePosition,"}, {"sha": "a40d8af9c43de32e0d98fcc3154f6090dbe360a2", "filename": "crates/ra_ide/src/typing/on_enter.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Ftyping%2Fon_enter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide%2Fsrc%2Ftyping%2Fon_enter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ftyping%2Fon_enter.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -11,9 +11,7 @@ use ra_syntax::{\n };\n use ra_text_edit::TextEdit;\n \n-use crate::{SourceChange, SourceFileEdit};\n-\n-pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<SourceChange> {\n+pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<TextEdit> {\n     let parse = db.parse(position.file_id);\n     let file = parse.tree();\n     let comment = file\n@@ -41,9 +39,7 @@ pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<Sour\n     let inserted = format!(\"\\n{}{} $0\", indent, prefix);\n     let edit = TextEdit::insert(position.offset, inserted);\n \n-    let mut res = SourceChange::from(SourceFileEdit { edit, file_id: position.file_id });\n-    res.is_snippet = true;\n-    Some(res)\n+    Some(edit)\n }\n \n fn followed_by_comment(comment: &ast::Comment) -> bool {\n@@ -90,9 +86,8 @@ mod tests {\n         let (analysis, file_id) = single_file(&before);\n         let result = analysis.on_enter(FilePosition { offset, file_id }).unwrap()?;\n \n-        assert_eq!(result.source_file_edits.len(), 1);\n         let mut actual = before.to_string();\n-        result.source_file_edits[0].edit.apply(&mut actual);\n+        result.apply(&mut actual);\n         Some(actual)\n     }\n "}, {"sha": "335a1ad03c7bba3dfa1fd4c4edbcb6ce86cb0442", "filename": "crates/ra_ide_db/src/search.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -124,29 +124,33 @@ impl Definition {\n \n         let vis = self.visibility(db);\n \n-        // FIXME:\n-        // The following logic are wrong that it does not search\n-        // for submodules within other files recursively.\n-\n         if let Some(Visibility::Module(module)) = vis.and_then(|it| it.into()) {\n             let module: Module = module.into();\n             let mut res = FxHashMap::default();\n-            let src = module.definition_source(db);\n-            let file_id = src.file_id.original_file(db);\n \n-            match src.value {\n-                ModuleSource::Module(m) => {\n-                    let range = Some(m.syntax().text_range());\n-                    res.insert(file_id, range);\n-                }\n-                ModuleSource::SourceFile(_) => {\n-                    res.insert(file_id, None);\n-                    res.extend(module.children(db).map(|m| {\n-                        let src = m.definition_source(db);\n-                        (src.file_id.original_file(db), None)\n-                    }));\n-                }\n+            let mut to_visit = vec![module];\n+            let mut is_first = true;\n+            while let Some(module) = to_visit.pop() {\n+                let src = module.definition_source(db);\n+                let file_id = src.file_id.original_file(db);\n+                match src.value {\n+                    ModuleSource::Module(m) => {\n+                        if is_first {\n+                            let range = Some(m.syntax().text_range());\n+                            res.insert(file_id, range);\n+                        } else {\n+                            // We have already added the enclosing file to the search scope,\n+                            // so do nothing.\n+                        }\n+                    }\n+                    ModuleSource::SourceFile(_) => {\n+                        res.insert(file_id, None);\n+                    }\n+                };\n+                is_first = false;\n+                to_visit.extend(module.children(db));\n             }\n+\n             return SearchScope::new(res);\n         }\n "}, {"sha": "acc31fe3b51bd2b1b538e308cbf1124148a1b8ff", "filename": "crates/ra_ide_db/src/symbol_index.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -110,6 +110,27 @@ fn file_symbols(db: &impl SymbolsDatabase, file_id: FileId) -> Arc<SymbolIndex>\n     Arc::new(SymbolIndex::new(symbols))\n }\n \n+// Feature: Workspace Symbol\n+//\n+// Uses fuzzy-search to find types, modules and functions by name across your\n+// project and dependencies. This is **the** most useful feature, which improves code\n+// navigation tremendously. It mostly works on top of the built-in LSP\n+// functionality, however `#` and `*` symbols can be used to narrow down the\n+// search. Specifically,\n+//\n+// - `Foo` searches for `Foo` type in the current workspace\n+// - `foo#` searches for `foo` function in the current workspace\n+// - `Foo*` searches for `Foo` type among dependencies, including `stdlib`\n+// - `foo#*` searches for `foo` function among dependencies\n+//\n+// That is, `#` switches from \"types\" to all symbols, `*` switches from the current\n+// workspace to dependencies.\n+//\n+// |===\n+// | Editor  | Shortcut\n+//\n+// | VS Code | kbd:[Ctrl+T]\n+// |===\n pub fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol> {\n     /// Need to wrap Snapshot to provide `Clone` impl for `map_with`\n     struct Snap(salsa::Snapshot<RootDatabase>);"}, {"sha": "293baecf6a2c1b87f62d6d12b6cf6293110f6493", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -18,9 +18,10 @@\n //! // fn foo() {}\n //! ```\n //!\n-//! After adding a new inline-test, run `cargo collect-tests` to extract\n-//! it as a standalone text-fixture into `tests/data/parser/inline`, and\n-//! run `cargo test` once to create the \"gold\" value.\n+//! After adding a new inline-test, run `cargo xtask codegen` to\n+//! extract it as a standalone text-fixture into\n+//! `crates/ra_syntax/test_data/parser/`, and run `cargo test` once to\n+//! create the \"gold\" value.\n //!\n //! Coding convention: rules like `where_clause` always produce either a\n //! node or an error, rules like `opt_where_clause` may produce nothing."}, {"sha": "d6e8df32a14e2e0d4c410295fdddfa8dfb429f38", "filename": "crates/ra_parser/src/grammar/expressions.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -325,13 +325,27 @@ fn lhs(p: &mut Parser, r: Restrictions) -> Option<(CompletedMarker, BlockLike)>\n     let kind = match p.current() {\n         // test ref_expr\n         // fn foo() {\n+        //     // reference operator\n         //     let _ = &1;\n         //     let _ = &mut &f();\n+        //     let _ = &raw;\n+        //     let _ = &raw.0;\n+        //     // raw reference operator\n+        //     let _ = &raw mut foo;\n+        //     let _ = &raw const foo;\n         // }\n         T![&] => {\n             m = p.start();\n             p.bump(T![&]);\n-            p.eat(T![mut]);\n+            if p.at(IDENT)\n+                && p.at_contextual_kw(\"raw\")\n+                && (p.nth_at(1, T![mut]) || p.nth_at(1, T![const]))\n+            {\n+                p.bump_remap(T![raw]);\n+                p.bump_any();\n+            } else {\n+                p.eat(T![mut]);\n+            }\n             REF_EXPR\n         }\n         // test unary_expr"}, {"sha": "5821029450f5b0062bdbab907c684695c7f8609d", "filename": "crates/ra_proc_macro_srv/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_proc_macro_srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_proc_macro_srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2FCargo.toml?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -22,3 +22,4 @@ cargo_metadata = \"0.10.0\"\n difference = \"2.0.0\"\n # used as proc macro test target\n serde_derive = \"1.0.106\"\n+ra_toolchain = { path = \"../ra_toolchain\" }"}, {"sha": "8d85f2d8a77521d40c396c3fb55a9f0a22853694", "filename": "crates/ra_proc_macro_srv/src/tests/utils.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -2,7 +2,6 @@\n \n use crate::dylib;\n use crate::ProcMacroSrv;\n-pub use difference::Changeset as __Changeset;\n use ra_proc_macro::ListMacrosTask;\n use std::str::FromStr;\n use test_utils::assert_eq_text;\n@@ -13,7 +12,7 @@ mod fixtures {\n \n     // Use current project metadata to get the proc-macro dylib path\n     pub fn dylib_path(crate_name: &str, version: &str) -> std::path::PathBuf {\n-        let command = Command::new(\"cargo\")\n+        let command = Command::new(ra_toolchain::cargo())\n             .args(&[\"check\", \"--message-format\", \"json\"])\n             .output()\n             .unwrap()"}, {"sha": "4b7444039e7b9b448126b7e5f09f21f7659d18ac", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -64,7 +64,7 @@ impl Default for CargoConfig {\n     fn default() -> Self {\n         CargoConfig {\n             no_default_features: false,\n-            all_features: true,\n+            all_features: false,\n             features: Vec::new(),\n             load_out_dirs_from_check: false,\n             target: None,"}, {"sha": "09c06fef9359ff9ea1a7e238f920954767c7e0fb", "filename": "crates/ra_project_model/src/json_project.rs", "status": "modified", "additions": 84, "deletions": 5, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_project_model%2Fsrc%2Fjson_project.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_project_model%2Fsrc%2Fjson_project.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fjson_project.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -5,6 +5,13 @@ use std::path::PathBuf;\n use rustc_hash::{FxHashMap, FxHashSet};\n use serde::Deserialize;\n \n+/// Roots and crates that compose this Rust project.\n+#[derive(Clone, Debug, Deserialize)]\n+pub struct JsonProject {\n+    pub(crate) roots: Vec<Root>,\n+    pub(crate) crates: Vec<Crate>,\n+}\n+\n /// A root points to the directory which contains Rust crates. rust-analyzer watches all files in\n /// all roots. Roots might be nested.\n #[derive(Clone, Debug, Deserialize)]\n@@ -20,8 +27,17 @@ pub struct Crate {\n     pub(crate) root_module: PathBuf,\n     pub(crate) edition: Edition,\n     pub(crate) deps: Vec<Dep>,\n+\n+    // This is the preferred method of providing cfg options.\n+    #[serde(default)]\n+    pub(crate) cfg: FxHashSet<String>,\n+\n+    // These two are here for transition only.\n+    #[serde(default)]\n     pub(crate) atom_cfgs: FxHashSet<String>,\n+    #[serde(default)]\n     pub(crate) key_value_cfgs: FxHashMap<String, String>,\n+\n     pub(crate) out_dir: Option<PathBuf>,\n     pub(crate) proc_macro_dylib_path: Option<PathBuf>,\n }\n@@ -48,9 +64,72 @@ pub struct Dep {\n     pub(crate) name: String,\n }\n \n-/// Roots and crates that compose this Rust project.\n-#[derive(Clone, Debug, Deserialize)]\n-pub struct JsonProject {\n-    pub(crate) roots: Vec<Root>,\n-    pub(crate) crates: Vec<Crate>,\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use serde_json::json;\n+\n+    #[test]\n+    fn test_crate_deserialization() {\n+        let raw_json = json!(    {\n+            \"crate_id\": 2,\n+            \"root_module\": \"this/is/a/file/path.rs\",\n+            \"deps\": [\n+              {\n+                \"crate\": 1,\n+                \"name\": \"some_dep_crate\"\n+              },\n+            ],\n+            \"edition\": \"2015\",\n+            \"cfg\": [\n+              \"atom_1\",\n+              \"atom_2\",\n+              \"feature=feature_1\",\n+              \"feature=feature_2\",\n+              \"other=value\",\n+            ],\n+\n+        });\n+\n+        let krate: Crate = serde_json::from_value(raw_json).unwrap();\n+\n+        assert!(krate.cfg.contains(&\"atom_1\".to_string()));\n+        assert!(krate.cfg.contains(&\"atom_2\".to_string()));\n+        assert!(krate.cfg.contains(&\"feature=feature_1\".to_string()));\n+        assert!(krate.cfg.contains(&\"feature=feature_2\".to_string()));\n+        assert!(krate.cfg.contains(&\"other=value\".to_string()));\n+    }\n+\n+    #[test]\n+    fn test_crate_deserialization_old_json() {\n+        let raw_json = json!(    {\n+           \"crate_id\": 2,\n+           \"root_module\": \"this/is/a/file/path.rs\",\n+           \"deps\": [\n+             {\n+               \"crate\": 1,\n+               \"name\": \"some_dep_crate\"\n+             },\n+           ],\n+           \"edition\": \"2015\",\n+           \"atom_cfgs\": [\n+             \"atom_1\",\n+             \"atom_2\",\n+           ],\n+           \"key_value_cfgs\": {\n+             \"feature\": \"feature_1\",\n+             \"feature\": \"feature_2\",\n+             \"other\": \"value\",\n+           },\n+        });\n+\n+        let krate: Crate = serde_json::from_value(raw_json).unwrap();\n+\n+        assert!(krate.atom_cfgs.contains(&\"atom_1\".to_string()));\n+        assert!(krate.atom_cfgs.contains(&\"atom_2\".to_string()));\n+        assert!(krate.key_value_cfgs.contains_key(&\"feature\".to_string()));\n+        assert_eq!(krate.key_value_cfgs.get(\"feature\"), Some(&\"feature_2\".to_string()));\n+        assert!(krate.key_value_cfgs.contains_key(&\"other\".to_string()));\n+        assert_eq!(krate.key_value_cfgs.get(\"other\"), Some(&\"value\".to_string()));\n+    }\n }"}, {"sha": "7ad941279506fc8d30ddc5196121019afb4b41ae", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -14,7 +14,7 @@ use std::{\n use anyhow::{bail, Context, Result};\n use ra_cfg::CfgOptions;\n use ra_db::{CrateGraph, CrateName, Edition, Env, ExternSource, ExternSourceId, FileId};\n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use serde_json::from_reader;\n \n pub use crate::{\n@@ -32,6 +32,12 @@ pub enum ProjectWorkspace {\n     Json { project: JsonProject },\n }\n \n+impl From<JsonProject> for ProjectWorkspace {\n+    fn from(project: JsonProject) -> ProjectWorkspace {\n+        ProjectWorkspace::Json { project }\n+    }\n+}\n+\n /// `PackageRoot` describes a package root folder.\n /// Which may be an external dependency, or a member of\n /// the current workspace.\n@@ -57,25 +63,25 @@ impl PackageRoot {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum ProjectRoot {\n+#[derive(Debug, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]\n+pub enum ProjectManifest {\n     ProjectJson(PathBuf),\n     CargoToml(PathBuf),\n }\n \n-impl ProjectRoot {\n-    pub fn from_manifest_file(path: PathBuf) -> Result<ProjectRoot> {\n+impl ProjectManifest {\n+    pub fn from_manifest_file(path: PathBuf) -> Result<ProjectManifest> {\n         if path.ends_with(\"rust-project.json\") {\n-            return Ok(ProjectRoot::ProjectJson(path));\n+            return Ok(ProjectManifest::ProjectJson(path));\n         }\n         if path.ends_with(\"Cargo.toml\") {\n-            return Ok(ProjectRoot::CargoToml(path));\n+            return Ok(ProjectManifest::CargoToml(path));\n         }\n         bail!(\"project root must point to Cargo.toml or rust-project.json: {}\", path.display())\n     }\n \n-    pub fn discover_single(path: &Path) -> Result<ProjectRoot> {\n-        let mut candidates = ProjectRoot::discover(path)?;\n+    pub fn discover_single(path: &Path) -> Result<ProjectManifest> {\n+        let mut candidates = ProjectManifest::discover(path)?;\n         let res = match candidates.pop() {\n             None => bail!(\"no projects\"),\n             Some(it) => it,\n@@ -87,12 +93,12 @@ impl ProjectRoot {\n         Ok(res)\n     }\n \n-    pub fn discover(path: &Path) -> io::Result<Vec<ProjectRoot>> {\n+    pub fn discover(path: &Path) -> io::Result<Vec<ProjectManifest>> {\n         if let Some(project_json) = find_in_parent_dirs(path, \"rust-project.json\") {\n-            return Ok(vec![ProjectRoot::ProjectJson(project_json)]);\n+            return Ok(vec![ProjectManifest::ProjectJson(project_json)]);\n         }\n         return find_cargo_toml(path)\n-            .map(|paths| paths.into_iter().map(ProjectRoot::CargoToml).collect());\n+            .map(|paths| paths.into_iter().map(ProjectManifest::CargoToml).collect());\n \n         fn find_cargo_toml(path: &Path) -> io::Result<Vec<PathBuf>> {\n             match find_in_parent_dirs(path, \"Cargo.toml\") {\n@@ -128,16 +134,28 @@ impl ProjectRoot {\n                 .collect()\n         }\n     }\n+\n+    pub fn discover_all(paths: &[impl AsRef<Path>]) -> Vec<ProjectManifest> {\n+        let mut res = paths\n+            .iter()\n+            .filter_map(|it| ProjectManifest::discover(it.as_ref()).ok())\n+            .flatten()\n+            .collect::<FxHashSet<_>>()\n+            .into_iter()\n+            .collect::<Vec<_>>();\n+        res.sort();\n+        res\n+    }\n }\n \n impl ProjectWorkspace {\n     pub fn load(\n-        root: ProjectRoot,\n+        manifest: ProjectManifest,\n         cargo_features: &CargoConfig,\n         with_sysroot: bool,\n     ) -> Result<ProjectWorkspace> {\n-        let res = match root {\n-            ProjectRoot::ProjectJson(project_json) => {\n+        let res = match manifest {\n+            ProjectManifest::ProjectJson(project_json) => {\n                 let file = File::open(&project_json).with_context(|| {\n                     format!(\"Failed to open json file {}\", project_json.display())\n                 })?;\n@@ -148,7 +166,7 @@ impl ProjectWorkspace {\n                     })?,\n                 }\n             }\n-            ProjectRoot::CargoToml(cargo_toml) => {\n+            ProjectManifest::CargoToml(cargo_toml) => {\n                 let cargo = CargoWorkspace::from_cargo_metadata(&cargo_toml, cargo_features)\n                     .with_context(|| {\n                         format!(\n@@ -252,6 +270,16 @@ impl ProjectWorkspace {\n                         };\n                         let cfg_options = {\n                             let mut opts = default_cfg_options.clone();\n+                            for cfg in &krate.cfg {\n+                                match cfg.find('=') {\n+                                    None => opts.insert_atom(cfg.into()),\n+                                    Some(pos) => {\n+                                        let key = &cfg[..pos];\n+                                        let value = cfg[pos + 1..].trim_matches('\"');\n+                                        opts.insert_key_value(key.into(), value.into());\n+                                    }\n+                                }\n+                            }\n                             for name in &krate.atom_cfgs {\n                                 opts.insert_atom(name.into());\n                             }"}, {"sha": "a8ff2e74f5c6d4f3349e0135d6eaa75c729737f8", "filename": "crates/ra_syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_syntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_syntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2FCargo.toml?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -13,7 +13,7 @@ doctest = false\n [dependencies]\n itertools = \"0.9.0\"\n rowan = \"0.10.0\"\n-rustc_lexer = { version = \"656.0.0\", package = \"rustc-ap-rustc_lexer\" }\n+rustc_lexer = { version = \"661.0.0\", package = \"rustc-ap-rustc_lexer\" }\n rustc-hash = \"1.1.0\"\n arrayvec = \"0.5.1\"\n once_cell = \"1.3.1\""}, {"sha": "eddc807d5a503d9726eab404b864c85a50d96a61", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -75,7 +75,7 @@ impl<N> AstChildren<N> {\n impl<N: AstNode> Iterator for AstChildren<N> {\n     type Item = N;\n     fn next(&mut self) -> Option<N> {\n-        self.inner.by_ref().find_map(N::cast)\n+        self.inner.find_map(N::cast)\n     }\n }\n "}, {"sha": "cb430ca013528d1833e1349d321d76605b7efb38", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1081,6 +1081,7 @@ pub struct BlockExpr {\n impl ast::AttrsOwner for BlockExpr {}\n impl ast::ModuleItemOwner for BlockExpr {}\n impl BlockExpr {\n+    pub fn label(&self) -> Option<Label> { support::child(&self.syntax) }\n     pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n     pub fn statements(&self) -> AstChildren<Stmt> { support::children(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n@@ -1235,6 +1236,8 @@ impl CastExpr {\n /// ```\n /// \u2770 &foo \u2771;\n /// \u2770 &mut bar \u2771;\n+/// \u2770 &raw const bar \u2771;\n+/// \u2770 &raw mut bar \u2771;\n /// ```\n ///\n /// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#borrow-operators)\n@@ -1247,6 +1250,7 @@ impl RefExpr {\n     pub fn amp_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![&]) }\n     pub fn raw_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![raw]) }\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n+    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n /// Prefix operator call. This is either `!` or `*` or `-`."}, {"sha": "04b0a4480375a2af3e3a1b59015fa50ef9a3a343", "filename": "crates/ra_syntax/src/ast/tokens.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -6,6 +6,7 @@ use crate::{\n     ast::{AstToken, Comment, RawString, String, Whitespace},\n     TextRange, TextSize,\n };\n+use rustc_lexer::unescape::{unescape_literal, Mode};\n \n impl Comment {\n     pub fn kind(&self) -> CommentKind {\n@@ -147,7 +148,7 @@ impl HasStringValue for String {\n \n         let mut buf = std::string::String::with_capacity(text.len());\n         let mut has_error = false;\n-        rustc_lexer::unescape::unescape_str(text, &mut |_, unescaped_char| match unescaped_char {\n+        unescape_literal(text, Mode::Str, &mut |_, unescaped_char| match unescaped_char {\n             Ok(c) => buf.push(c),\n             Err(_) => has_error = true,\n         });\n@@ -417,14 +418,9 @@ pub trait HasFormatSpecifier: AstToken {\n \n                     let mut cloned = chars.clone().take(2);\n                     let first = cloned.next().and_then(|next| next.1.as_ref().ok()).copied();\n-                    let second = cloned.next().and_then(|next| next.1.as_ref().ok()).copied();\n                     if first != Some('}') {\n                         continue;\n                     }\n-                    if second == Some('}') {\n-                        // Escaped format end specifier, `}}`\n-                        continue;\n-                    }\n                     skip_char_and_emit(&mut chars, FormatSpecifier::Close, &mut callback);\n                 }\n                 _ => {\n@@ -498,7 +494,7 @@ impl HasFormatSpecifier for String {\n         let offset = self.text_range_between_quotes()?.start() - self.syntax().text_range().start();\n \n         let mut res = Vec::with_capacity(text.len());\n-        rustc_lexer::unescape::unescape_str(text, &mut |range, unescaped_char| {\n+        unescape_literal(text, Mode::Str, &mut |range, unescaped_char| {\n             res.push((\n                 TextRange::new(range.start.try_into().unwrap(), range.end.try_into().unwrap())\n                     + offset,"}, {"sha": "a8f2454fd96e861209a9345911cef983ce41ace4", "filename": "crates/ra_syntax/src/ast/traits.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -83,13 +83,22 @@ pub trait DocCommentsOwner: AstNode {\n         CommentIter { iter: self.syntax().children_with_tokens() }\n     }\n \n+    fn doc_comment_text(&self) -> Option<String> {\n+        self.doc_comments().doc_comment_text()\n+    }\n+}\n+\n+impl CommentIter {\n+    pub fn from_syntax_node(syntax_node: &ast::SyntaxNode) -> CommentIter {\n+        CommentIter { iter: syntax_node.children_with_tokens() }\n+    }\n+\n     /// Returns the textual content of a doc comment block as a single string.\n     /// That is, strips leading `///` (+ optional 1 character of whitespace),\n     /// trailing `*/`, trailing whitespace and then joins the lines.\n-    fn doc_comment_text(&self) -> Option<String> {\n+    pub fn doc_comment_text(self) -> Option<String> {\n         let mut has_comments = false;\n         let docs = self\n-            .doc_comments()\n             .filter(|comment| comment.kind().doc.is_some())\n             .map(|comment| {\n                 has_comments = true;"}, {"sha": "9650b8781748a2ca8c66a07715959cd68e849965", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -48,11 +48,11 @@ impl SyntaxTreeBuilder {\n \n     pub fn finish(self) -> Parse<SyntaxNode> {\n         let (green, errors) = self.finish_raw();\n-        let node = SyntaxNode::new_root(green);\n         if cfg!(debug_assertions) {\n+            let node = SyntaxNode::new_root(green.clone());\n             crate::validation::validate_block_structure(&node);\n         }\n-        Parse::new(node.green().clone(), errors)\n+        Parse::new(green, errors)\n     }\n \n     pub fn token(&mut self, kind: SyntaxKind, text: SmolStr) {"}, {"sha": "fdec48fb0b88c33469114fd9e855a89e5ba49a06", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -2,15 +2,15 @@\n \n mod block;\n \n-use std::convert::TryFrom;\n-\n-use rustc_lexer::unescape;\n-\n use crate::{\n     ast, match_ast, AstNode, SyntaxError,\n     SyntaxKind::{BYTE, BYTE_STRING, CHAR, CONST_DEF, FN_DEF, INT_NUMBER, STRING, TYPE_ALIAS_DEF},\n     SyntaxNode, SyntaxToken, TextSize, T,\n };\n+use rustc_lexer::unescape::{\n+    self, unescape_byte, unescape_byte_literal, unescape_char, unescape_literal, Mode,\n+};\n+use std::convert::TryFrom;\n \n fn rustc_unescape_error_to_string(err: unescape::EscapeError) -> &'static str {\n     use unescape::EscapeError as EE;\n@@ -81,10 +81,8 @@ fn rustc_unescape_error_to_string(err: unescape::EscapeError) -> &'static str {\n \n pub(crate) fn validate(root: &SyntaxNode) -> Vec<SyntaxError> {\n     // FIXME:\n-    // * Add validation of character literal containing only a single char\n-    // * Add validation of `crate` keyword not appearing in the middle of the symbol path\n+    // * Add unescape validation of raw string literals and raw byte string literals\n     // * Add validation of doc comments are being attached to nodes\n-    // * Remove validation of unterminated literals (it is already implemented in `tokenize()`)\n \n     let mut errors = Vec::new();\n     for node in root.descendants() {\n@@ -121,18 +119,18 @@ fn validate_literal(literal: ast::Literal, acc: &mut Vec<SyntaxError>) {\n \n     match token.kind() {\n         BYTE => {\n-            if let Some(Err(e)) = unquote(text, 2, '\\'').map(unescape::unescape_byte) {\n+            if let Some(Err(e)) = unquote(text, 2, '\\'').map(unescape_byte) {\n                 push_err(2, e);\n             }\n         }\n         CHAR => {\n-            if let Some(Err(e)) = unquote(text, 1, '\\'').map(unescape::unescape_char) {\n+            if let Some(Err(e)) = unquote(text, 1, '\\'').map(unescape_char) {\n                 push_err(1, e);\n             }\n         }\n         BYTE_STRING => {\n             if let Some(without_quotes) = unquote(text, 2, '\"') {\n-                unescape::unescape_byte_str(without_quotes, &mut |range, char| {\n+                unescape_byte_literal(without_quotes, Mode::ByteStr, &mut |range, char| {\n                     if let Err(err) = char {\n                         push_err(2, (range.start, err));\n                     }\n@@ -141,7 +139,7 @@ fn validate_literal(literal: ast::Literal, acc: &mut Vec<SyntaxError>) {\n         }\n         STRING => {\n             if let Some(without_quotes) = unquote(text, 1, '\"') {\n-                unescape::unescape_str(without_quotes, &mut |range, char| {\n+                unescape_literal(without_quotes, Mode::Str, &mut |range, char| {\n                     if let Err(err) = char {\n                         push_err(1, (range.start, err));\n                     }"}, {"sha": "58bdf7e34c64becb76e0a1850e163fb7328e71d5", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0082_ref_expr.rast", "status": "modified", "additions": 128, "deletions": 44, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0082_ref_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0082_ref_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0082_ref_expr.rast?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,5 +1,5 @@\n-SOURCE_FILE@0..52\n-  FN_DEF@0..51\n+SOURCE_FILE@0..200\n+  FN_DEF@0..199\n     FN_KW@0..2 \"fn\"\n     WHITESPACE@2..3 \" \"\n     NAME@3..6\n@@ -8,47 +8,131 @@ SOURCE_FILE@0..52\n       L_PAREN@6..7 \"(\"\n       R_PAREN@7..8 \")\"\n     WHITESPACE@8..9 \" \"\n-    BLOCK_EXPR@9..51\n+    BLOCK_EXPR@9..199\n       L_CURLY@9..10 \"{\"\n       WHITESPACE@10..15 \"\\n    \"\n-      LET_STMT@15..26\n-        LET_KW@15..18 \"let\"\n-        WHITESPACE@18..19 \" \"\n-        PLACEHOLDER_PAT@19..20\n-          UNDERSCORE@19..20 \"_\"\n-        WHITESPACE@20..21 \" \"\n-        EQ@21..22 \"=\"\n-        WHITESPACE@22..23 \" \"\n-        REF_EXPR@23..25\n-          AMP@23..24 \"&\"\n-          LITERAL@24..25\n-            INT_NUMBER@24..25 \"1\"\n-        SEMICOLON@25..26 \";\"\n-      WHITESPACE@26..31 \"\\n    \"\n-      LET_STMT@31..49\n-        LET_KW@31..34 \"let\"\n-        WHITESPACE@34..35 \" \"\n-        PLACEHOLDER_PAT@35..36\n-          UNDERSCORE@35..36 \"_\"\n-        WHITESPACE@36..37 \" \"\n-        EQ@37..38 \"=\"\n-        WHITESPACE@38..39 \" \"\n-        REF_EXPR@39..48\n-          AMP@39..40 \"&\"\n-          MUT_KW@40..43 \"mut\"\n-          WHITESPACE@43..44 \" \"\n-          REF_EXPR@44..48\n-            AMP@44..45 \"&\"\n-            CALL_EXPR@45..48\n-              PATH_EXPR@45..46\n-                PATH@45..46\n-                  PATH_SEGMENT@45..46\n-                    NAME_REF@45..46\n-                      IDENT@45..46 \"f\"\n-              ARG_LIST@46..48\n-                L_PAREN@46..47 \"(\"\n-                R_PAREN@47..48 \")\"\n-        SEMICOLON@48..49 \";\"\n-      WHITESPACE@49..50 \"\\n\"\n-      R_CURLY@50..51 \"}\"\n-  WHITESPACE@51..52 \"\\n\"\n+      COMMENT@15..36 \"// reference operator\"\n+      WHITESPACE@36..41 \"\\n    \"\n+      LET_STMT@41..52\n+        LET_KW@41..44 \"let\"\n+        WHITESPACE@44..45 \" \"\n+        PLACEHOLDER_PAT@45..46\n+          UNDERSCORE@45..46 \"_\"\n+        WHITESPACE@46..47 \" \"\n+        EQ@47..48 \"=\"\n+        WHITESPACE@48..49 \" \"\n+        REF_EXPR@49..51\n+          AMP@49..50 \"&\"\n+          LITERAL@50..51\n+            INT_NUMBER@50..51 \"1\"\n+        SEMICOLON@51..52 \";\"\n+      WHITESPACE@52..57 \"\\n    \"\n+      LET_STMT@57..75\n+        LET_KW@57..60 \"let\"\n+        WHITESPACE@60..61 \" \"\n+        PLACEHOLDER_PAT@61..62\n+          UNDERSCORE@61..62 \"_\"\n+        WHITESPACE@62..63 \" \"\n+        EQ@63..64 \"=\"\n+        WHITESPACE@64..65 \" \"\n+        REF_EXPR@65..74\n+          AMP@65..66 \"&\"\n+          MUT_KW@66..69 \"mut\"\n+          WHITESPACE@69..70 \" \"\n+          REF_EXPR@70..74\n+            AMP@70..71 \"&\"\n+            CALL_EXPR@71..74\n+              PATH_EXPR@71..72\n+                PATH@71..72\n+                  PATH_SEGMENT@71..72\n+                    NAME_REF@71..72\n+                      IDENT@71..72 \"f\"\n+              ARG_LIST@72..74\n+                L_PAREN@72..73 \"(\"\n+                R_PAREN@73..74 \")\"\n+        SEMICOLON@74..75 \";\"\n+      WHITESPACE@75..80 \"\\n    \"\n+      LET_STMT@80..93\n+        LET_KW@80..83 \"let\"\n+        WHITESPACE@83..84 \" \"\n+        PLACEHOLDER_PAT@84..85\n+          UNDERSCORE@84..85 \"_\"\n+        WHITESPACE@85..86 \" \"\n+        EQ@86..87 \"=\"\n+        WHITESPACE@87..88 \" \"\n+        REF_EXPR@88..92\n+          AMP@88..89 \"&\"\n+          PATH_EXPR@89..92\n+            PATH@89..92\n+              PATH_SEGMENT@89..92\n+                NAME_REF@89..92\n+                  IDENT@89..92 \"raw\"\n+        SEMICOLON@92..93 \";\"\n+      WHITESPACE@93..98 \"\\n    \"\n+      LET_STMT@98..113\n+        LET_KW@98..101 \"let\"\n+        WHITESPACE@101..102 \" \"\n+        PLACEHOLDER_PAT@102..103\n+          UNDERSCORE@102..103 \"_\"\n+        WHITESPACE@103..104 \" \"\n+        EQ@104..105 \"=\"\n+        WHITESPACE@105..106 \" \"\n+        REF_EXPR@106..112\n+          AMP@106..107 \"&\"\n+          FIELD_EXPR@107..112\n+            PATH_EXPR@107..110\n+              PATH@107..110\n+                PATH_SEGMENT@107..110\n+                  NAME_REF@107..110\n+                    IDENT@107..110 \"raw\"\n+            DOT@110..111 \".\"\n+            NAME_REF@111..112\n+              INT_NUMBER@111..112 \"0\"\n+        SEMICOLON@112..113 \";\"\n+      WHITESPACE@113..118 \"\\n    \"\n+      COMMENT@118..143 \"// raw reference oper ...\"\n+      WHITESPACE@143..148 \"\\n    \"\n+      LET_STMT@148..169\n+        LET_KW@148..151 \"let\"\n+        WHITESPACE@151..152 \" \"\n+        PLACEHOLDER_PAT@152..153\n+          UNDERSCORE@152..153 \"_\"\n+        WHITESPACE@153..154 \" \"\n+        EQ@154..155 \"=\"\n+        WHITESPACE@155..156 \" \"\n+        REF_EXPR@156..168\n+          AMP@156..157 \"&\"\n+          RAW_KW@157..160 \"raw\"\n+          WHITESPACE@160..161 \" \"\n+          MUT_KW@161..164 \"mut\"\n+          WHITESPACE@164..165 \" \"\n+          PATH_EXPR@165..168\n+            PATH@165..168\n+              PATH_SEGMENT@165..168\n+                NAME_REF@165..168\n+                  IDENT@165..168 \"foo\"\n+        SEMICOLON@168..169 \";\"\n+      WHITESPACE@169..174 \"\\n    \"\n+      LET_STMT@174..197\n+        LET_KW@174..177 \"let\"\n+        WHITESPACE@177..178 \" \"\n+        PLACEHOLDER_PAT@178..179\n+          UNDERSCORE@178..179 \"_\"\n+        WHITESPACE@179..180 \" \"\n+        EQ@180..181 \"=\"\n+        WHITESPACE@181..182 \" \"\n+        REF_EXPR@182..196\n+          AMP@182..183 \"&\"\n+          RAW_KW@183..186 \"raw\"\n+          WHITESPACE@186..187 \" \"\n+          CONST_KW@187..192 \"const\"\n+          WHITESPACE@192..193 \" \"\n+          PATH_EXPR@193..196\n+            PATH@193..196\n+              PATH_SEGMENT@193..196\n+                NAME_REF@193..196\n+                  IDENT@193..196 \"foo\"\n+        SEMICOLON@196..197 \";\"\n+      WHITESPACE@197..198 \"\\n\"\n+      R_CURLY@198..199 \"}\"\n+  WHITESPACE@199..200 \"\\n\""}, {"sha": "c5262f4469b0683a9766b1003c8eea83767cd227", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0082_ref_expr.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0082_ref_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0082_ref_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0082_ref_expr.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,4 +1,10 @@\n fn foo() {\n+    // reference operator\n     let _ = &1;\n     let _ = &mut &f();\n+    let _ = &raw;\n+    let _ = &raw.0;\n+    // raw reference operator\n+    let _ = &raw mut foo;\n+    let _ = &raw const foo;\n }"}, {"sha": "65b487db3b98267547d659452b6553568dc41d67", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -40,6 +40,7 @@ ra_project_model = { path = \"../ra_project_model\" }\n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }\n ra_vfs = \"0.6.0\"\n+ra_cfg = { path = \"../ra_cfg\"}\n \n # This should only be used in CLI\n ra_db = { path = \"../ra_db\" }\n@@ -55,6 +56,8 @@ winapi = \"0.3.8\"\n tempfile = \"3.1.0\"\n insta = \"0.16.0\"\n test_utils = { path = \"../test_utils\" }\n+mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }\n+tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n \n [features]\n jemalloc = [ \"ra_prof/jemalloc\" ]"}, {"sha": "8d071ab1ca2b8fac88f216bd2b39f3470cbe987c", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -4,9 +4,14 @@\n mod args;\n \n use lsp_server::Connection;\n-use rust_analyzer::{cli, config::Config, from_json, Result};\n+use rust_analyzer::{\n+    cli,\n+    config::{Config, LinkedProject},\n+    from_json, Result,\n+};\n \n use crate::args::HelpPrinted;\n+use ra_project_model::ProjectManifest;\n \n fn main() -> Result<()> {\n     setup_logging()?;\n@@ -97,28 +102,38 @@ fn run_server() -> Result<()> {\n         log::info!(\"Client '{}' {}\", client_info.name, client_info.version.unwrap_or_default());\n     }\n \n-    let cwd = std::env::current_dir()?;\n-    let root = initialize_params.root_uri.and_then(|it| it.to_file_path().ok()).unwrap_or(cwd);\n-\n-    let workspace_roots = initialize_params\n-        .workspace_folders\n-        .map(|workspaces| {\n-            workspaces.into_iter().filter_map(|it| it.uri.to_file_path().ok()).collect::<Vec<_>>()\n-        })\n-        .filter(|workspaces| !workspaces.is_empty())\n-        .unwrap_or_else(|| vec![root]);\n-\n     let config = {\n         let mut config = Config::default();\n         if let Some(value) = &initialize_params.initialization_options {\n             config.update(value);\n         }\n         config.update_caps(&initialize_params.capabilities);\n \n+        if config.linked_projects.is_empty() {\n+            let cwd = std::env::current_dir()?;\n+            let root =\n+                initialize_params.root_uri.and_then(|it| it.to_file_path().ok()).unwrap_or(cwd);\n+            let workspace_roots = initialize_params\n+                .workspace_folders\n+                .map(|workspaces| {\n+                    workspaces\n+                        .into_iter()\n+                        .filter_map(|it| it.uri.to_file_path().ok())\n+                        .collect::<Vec<_>>()\n+                })\n+                .filter(|workspaces| !workspaces.is_empty())\n+                .unwrap_or_else(|| vec![root]);\n+\n+            config.linked_projects = ProjectManifest::discover_all(&workspace_roots)\n+                .into_iter()\n+                .map(LinkedProject::from)\n+                .collect();\n+        }\n+\n         config\n     };\n \n-    rust_analyzer::main_loop(workspace_roots, config, connection)?;\n+    rust_analyzer::main_loop(config, connection)?;\n \n     log::info!(\"shutting down IO...\");\n     io_threads.join()?;"}, {"sha": "673795e781e679dc675284b1f552ce4663fdd0e3", "filename": "crates/rust-analyzer/src/caps.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -85,6 +85,11 @@ pub fn server_capabilities(client_caps: &ClientCapabilities) -> ServerCapabiliti\n         experimental: Some(json!({\n             \"joinLines\": true,\n             \"ssr\": true,\n+            \"onEnter\": true,\n+            \"parentModule\": true,\n+            \"runnables\": {\n+                \"kinds\": [ \"cargo\" ],\n+            },\n         })),\n     }\n }"}, {"sha": "44f856f6b457d2de9af1a1f85fd376eb32383538", "filename": "crates/rust-analyzer/src/cargo_target_spec.rs", "status": "modified", "additions": 85, "deletions": 2, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,9 +1,10 @@\n //! See `CargoTargetSpec`\n \n+use ra_cfg::CfgExpr;\n use ra_ide::{FileId, RunnableKind, TestId};\n use ra_project_model::{self, ProjectWorkspace, TargetKind};\n \n-use crate::{world::WorldSnapshot, Result};\n+use crate::{global_state::GlobalStateSnapshot, Result};\n \n /// Abstract representation of Cargo target.\n ///\n@@ -20,6 +21,7 @@ impl CargoTargetSpec {\n     pub(crate) fn runnable_args(\n         spec: Option<CargoTargetSpec>,\n         kind: &RunnableKind,\n+        cfgs: &[CfgExpr],\n     ) -> Result<(Vec<String>, Vec<String>)> {\n         let mut args = Vec::new();\n         let mut extra_args = Vec::new();\n@@ -73,11 +75,21 @@ impl CargoTargetSpec {\n                 }\n             }\n         }\n+\n+        let mut features = Vec::new();\n+        for cfg in cfgs {\n+            required_features(cfg, &mut features);\n+        }\n+        for feature in features {\n+            args.push(\"--features\".to_string());\n+            args.push(feature);\n+        }\n+\n         Ok((args, extra_args))\n     }\n \n     pub(crate) fn for_file(\n-        world: &WorldSnapshot,\n+        world: &GlobalStateSnapshot,\n         file_id: FileId,\n     ) -> Result<Option<CargoTargetSpec>> {\n         let &crate_id = match world.analysis().crate_for(file_id)?.first() {\n@@ -132,3 +144,74 @@ impl CargoTargetSpec {\n         }\n     }\n }\n+\n+/// Fill minimal features needed\n+fn required_features(cfg_expr: &CfgExpr, features: &mut Vec<String>) {\n+    match cfg_expr {\n+        CfgExpr::KeyValue { key, value } if key == \"feature\" => features.push(value.to_string()),\n+        CfgExpr::All(preds) => {\n+            preds.iter().for_each(|cfg| required_features(cfg, features));\n+        }\n+        CfgExpr::Any(preds) => {\n+            for cfg in preds {\n+                let len_features = features.len();\n+                required_features(cfg, features);\n+                if len_features != features.len() {\n+                    break;\n+                }\n+            }\n+        }\n+        _ => {}\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use mbe::{ast_to_token_tree, TokenMap};\n+    use ra_cfg::parse_cfg;\n+    use ra_syntax::{\n+        ast::{self, AstNode},\n+        SmolStr,\n+    };\n+\n+    fn get_token_tree_generated(input: &str) -> (tt::Subtree, TokenMap) {\n+        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        ast_to_token_tree(&tt).unwrap()\n+    }\n+\n+    #[test]\n+    fn test_cfg_expr_minimal_features_needed() {\n+        let (subtree, _) = get_token_tree_generated(r#\"#![cfg(feature = \"baz\")]\"#);\n+        let cfg_expr = parse_cfg(&subtree);\n+        let mut min_features = vec![];\n+        required_features(&cfg_expr, &mut min_features);\n+\n+        assert_eq!(min_features, vec![SmolStr::new(\"baz\")]);\n+\n+        let (subtree, _) =\n+            get_token_tree_generated(r#\"#![cfg(all(feature = \"baz\", feature = \"foo\"))]\"#);\n+        let cfg_expr = parse_cfg(&subtree);\n+\n+        let mut min_features = vec![];\n+        required_features(&cfg_expr, &mut min_features);\n+        assert_eq!(min_features, vec![SmolStr::new(\"baz\"), SmolStr::new(\"foo\")]);\n+\n+        let (subtree, _) =\n+            get_token_tree_generated(r#\"#![cfg(any(feature = \"baz\", feature = \"foo\", unix))]\"#);\n+        let cfg_expr = parse_cfg(&subtree);\n+\n+        let mut min_features = vec![];\n+        required_features(&cfg_expr, &mut min_features);\n+        assert_eq!(min_features, vec![SmolStr::new(\"baz\")]);\n+\n+        let (subtree, _) = get_token_tree_generated(r#\"#![cfg(foo)]\"#);\n+        let cfg_expr = parse_cfg(&subtree);\n+\n+        let mut min_features = vec![];\n+        required_features(&cfg_expr, &mut min_features);\n+        assert!(min_features.is_empty());\n+    }\n+}"}, {"sha": "c7e86fe0c48b5b855c9db448add36b812e83b5e7", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -8,7 +8,8 @@ use crossbeam_channel::{unbounded, Receiver};\n use ra_db::{ExternSourceId, FileId, SourceRootId};\n use ra_ide::{AnalysisChange, AnalysisHost};\n use ra_project_model::{\n-    get_rustc_cfg_options, CargoConfig, PackageRoot, ProcMacroClient, ProjectRoot, ProjectWorkspace,\n+    get_rustc_cfg_options, CargoConfig, PackageRoot, ProcMacroClient, ProjectManifest,\n+    ProjectWorkspace,\n };\n use ra_vfs::{RootEntry, Vfs, VfsChange, VfsTask, Watch};\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -28,7 +29,7 @@ pub fn load_cargo(\n     with_proc_macro: bool,\n ) -> Result<(AnalysisHost, FxHashMap<SourceRootId, PackageRoot>)> {\n     let root = std::env::current_dir()?.join(root);\n-    let root = ProjectRoot::discover_single(&root)?;\n+    let root = ProjectManifest::discover_single(&root)?;\n     let ws = ProjectWorkspace::load(\n         root,\n         &CargoConfig { load_out_dirs_from_check, ..Default::default() },"}, {"sha": "0e5dc56fd744b57b2fa5af29ea953f0fa60034ec", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 49, "deletions": 7, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -12,14 +12,13 @@ use std::{ffi::OsString, path::PathBuf};\n use lsp_types::ClientCapabilities;\n use ra_flycheck::FlycheckConfig;\n use ra_ide::{AssistConfig, CompletionConfig, InlayHintsConfig};\n-use ra_project_model::CargoConfig;\n+use ra_project_model::{CargoConfig, JsonProject, ProjectManifest};\n use serde::Deserialize;\n \n #[derive(Debug, Clone)]\n pub struct Config {\n     pub client_caps: ClientCapsConfig,\n \n-    pub with_sysroot: bool,\n     pub publish_diagnostics: bool,\n     pub lru_capacity: Option<usize>,\n     pub proc_macro_srv: Option<(PathBuf, Vec<OsString>)>,\n@@ -35,6 +34,27 @@ pub struct Config {\n     pub assist: AssistConfig,\n     pub call_info_full: bool,\n     pub lens: LensConfig,\n+\n+    pub with_sysroot: bool,\n+    pub linked_projects: Vec<LinkedProject>,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub enum LinkedProject {\n+    ProjectManifest(ProjectManifest),\n+    JsonProject(JsonProject),\n+}\n+\n+impl From<ProjectManifest> for LinkedProject {\n+    fn from(v: ProjectManifest) -> Self {\n+        LinkedProject::ProjectManifest(v)\n+    }\n+}\n+\n+impl From<JsonProject> for LinkedProject {\n+    fn from(v: JsonProject) -> Self {\n+        LinkedProject::JsonProject(v)\n+    }\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -122,7 +142,7 @@ impl Default for Config {\n             check: Some(FlycheckConfig::CargoCommand {\n                 command: \"check\".to_string(),\n                 all_targets: true,\n-                all_features: true,\n+                all_features: false,\n                 extra_args: Vec::new(),\n             }),\n \n@@ -141,6 +161,7 @@ impl Default for Config {\n             assist: AssistConfig::default(),\n             call_info_full: true,\n             lens: LensConfig::default(),\n+            linked_projects: Vec::new(),\n         }\n     }\n }\n@@ -240,6 +261,22 @@ impl Config {\n             self.lens = LensConfig::NO_LENS;\n         }\n \n+        if let Some(linked_projects) = get::<Vec<ManifestOrJsonProject>>(value, \"/linkedProjects\") {\n+            if !linked_projects.is_empty() {\n+                self.linked_projects.clear();\n+                for linked_project in linked_projects {\n+                    let linked_project = match linked_project {\n+                        ManifestOrJsonProject::Manifest(it) => match ProjectManifest::from_manifest_file(it) {\n+                            Ok(it) => it.into(),\n+                            Err(_) => continue,\n+                        }\n+                        ManifestOrJsonProject::JsonProject(it) => it.into(),\n+                    };\n+                    self.linked_projects.push(linked_project);\n+                }\n+            }\n+        }\n+\n         log::info!(\"Config::update() = {:#?}\", self);\n \n         fn get<'a, T: Deserialize<'a>>(value: &'a serde_json::Value, pointer: &str) -> Option<T> {\n@@ -269,10 +306,8 @@ impl Config {\n             {\n                 self.client_caps.hierarchical_symbols = value\n             }\n-            if let Some(value) = doc_caps\n-                .code_action\n-                .as_ref()\n-                .and_then(|it| Some(it.code_action_literal_support.is_some()))\n+            if let Some(value) =\n+                doc_caps.code_action.as_ref().map(|it| it.code_action_literal_support.is_some())\n             {\n                 self.client_caps.code_action_literals = value;\n             }\n@@ -305,3 +340,10 @@ impl Config {\n         }\n     }\n }\n+\n+#[derive(Deserialize)]\n+#[serde(untagged)]\n+enum ManifestOrJsonProject {\n+    Manifest(PathBuf),\n+    JsonProject(JsonProject),\n+}"}, {"sha": "33b516e269b860289269d47d138d8937e13bec90", "filename": "crates/rust-analyzer/src/diagnostics/snapshots/rust_analyzer__diagnostics__to_proto__tests__snap_rustc_unused_variable.snap", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_unused_variable.snap", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_unused_variable.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_unused_variable.snap?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -29,7 +29,7 @@ expression: diag\n                 },\n             },\n             severity: Some(\n-                Warning,\n+                Hint,\n             ),\n             code: Some(\n                 String("}, {"sha": "6a6e7b45735a363af5c29d0dce7b0b3245a7d07f", "filename": "crates/rust-analyzer/src/diagnostics/to_proto.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -183,7 +183,7 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n         return Vec::new();\n     }\n \n-    let severity = map_level_to_severity(rd.level);\n+    let mut severity = map_level_to_severity(rd.level);\n \n     let mut source = String::from(\"rustc\");\n     let mut code = rd.code.as_ref().map(|c| c.code.clone());\n@@ -225,6 +225,7 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n     }\n \n     if is_unused_or_unnecessary(rd) {\n+        severity = Some(DiagnosticSeverity::Hint);\n         tags.push(DiagnosticTag::Unnecessary);\n     }\n "}, {"sha": "206673829c489b5fc9ac2da597c934d7e81cb0db", "filename": "crates/rust-analyzer/src/from_proto.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -3,7 +3,7 @@ use ra_db::{FileId, FilePosition, FileRange};\n use ra_ide::{LineCol, LineIndex};\n use ra_syntax::{TextRange, TextSize};\n \n-use crate::{world::WorldSnapshot, Result};\n+use crate::{global_state::GlobalStateSnapshot, Result};\n \n pub(crate) fn offset(line_index: &LineIndex, position: lsp_types::Position) -> TextSize {\n     let line_col = LineCol { line: position.line as u32, col_utf16: position.character as u32 };\n@@ -16,12 +16,12 @@ pub(crate) fn text_range(line_index: &LineIndex, range: lsp_types::Range) -> Tex\n     TextRange::new(start, end)\n }\n \n-pub(crate) fn file_id(world: &WorldSnapshot, url: &lsp_types::Url) -> Result<FileId> {\n+pub(crate) fn file_id(world: &GlobalStateSnapshot, url: &lsp_types::Url) -> Result<FileId> {\n     world.uri_to_file_id(url)\n }\n \n pub(crate) fn file_position(\n-    world: &WorldSnapshot,\n+    world: &GlobalStateSnapshot,\n     tdpp: lsp_types::TextDocumentPositionParams,\n ) -> Result<FilePosition> {\n     let file_id = file_id(world, &tdpp.text_document.uri)?;\n@@ -31,7 +31,7 @@ pub(crate) fn file_position(\n }\n \n pub(crate) fn file_range(\n-    world: &WorldSnapshot,\n+    world: &GlobalStateSnapshot,\n     text_document_identifier: lsp_types::TextDocumentIdentifier,\n     range: lsp_types::Range,\n ) -> Result<FileRange> {"}, {"sha": "0bebb5bf615a74912bed884b49bb8446ec4ac3a6", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "renamed", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -50,15 +50,15 @@ fn create_flycheck(workspaces: &[ProjectWorkspace], config: &FlycheckConfig) ->\n         })\n }\n \n-/// `WorldState` is the primary mutable state of the language server\n+/// `GlobalState` is the primary mutable state of the language server\n ///\n /// The most interesting components are `vfs`, which stores a consistent\n /// snapshot of the file systems, and `analysis_host`, which stores our\n /// incremental salsa database.\n #[derive(Debug)]\n-pub struct WorldState {\n+pub struct GlobalState {\n     pub config: Config,\n-    pub roots: Vec<PathBuf>,\n+    pub local_roots: Vec<PathBuf>,\n     pub workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub analysis_host: AnalysisHost,\n     pub vfs: Arc<RwLock<Vfs>>,\n@@ -70,7 +70,7 @@ pub struct WorldState {\n }\n \n /// An immutable snapshot of the world's state at a point in time.\n-pub struct WorldSnapshot {\n+pub struct GlobalStateSnapshot {\n     pub config: Config,\n     pub workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub analysis: Analysis,\n@@ -79,33 +79,37 @@ pub struct WorldSnapshot {\n     vfs: Arc<RwLock<Vfs>>,\n }\n \n-impl WorldState {\n+impl GlobalState {\n     pub fn new(\n-        folder_roots: Vec<PathBuf>,\n         workspaces: Vec<ProjectWorkspace>,\n         lru_capacity: Option<usize>,\n         exclude_globs: &[Glob],\n         watch: Watch,\n         config: Config,\n-    ) -> WorldState {\n+    ) -> GlobalState {\n         let mut change = AnalysisChange::new();\n \n         let extern_dirs: FxHashSet<_> =\n             workspaces.iter().flat_map(ProjectWorkspace::out_dirs).collect();\n \n+        let mut local_roots = Vec::new();\n         let roots: Vec<_> = {\n             let create_filter = |is_member| {\n                 RustPackageFilterBuilder::default()\n                     .set_member(is_member)\n                     .exclude(exclude_globs.iter().cloned())\n                     .into_vfs_filter()\n             };\n-            folder_roots\n+            workspaces\n                 .iter()\n-                .map(|path| RootEntry::new(path.clone(), create_filter(true)))\n-                .chain(workspaces.iter().flat_map(ProjectWorkspace::to_roots).map(|pkg_root| {\n-                    RootEntry::new(pkg_root.path().to_owned(), create_filter(pkg_root.is_member()))\n-                }))\n+                .flat_map(ProjectWorkspace::to_roots)\n+                .map(|pkg_root| {\n+                    let path = pkg_root.path().to_owned();\n+                    if pkg_root.is_member() {\n+                        local_roots.push(path.clone());\n+                    }\n+                    RootEntry::new(path, create_filter(pkg_root.is_member()))\n+                })\n                 .chain(\n                     extern_dirs\n                         .iter()\n@@ -121,7 +125,7 @@ impl WorldState {\n         let mut extern_source_roots = FxHashMap::default();\n         for r in vfs_roots {\n             let vfs_root_path = vfs.root2path(r);\n-            let is_local = folder_roots.iter().any(|it| vfs_root_path.starts_with(it));\n+            let is_local = local_roots.iter().any(|it| vfs_root_path.starts_with(it));\n             change.add_root(SourceRootId(r.0), is_local);\n             change.set_debug_root_path(SourceRootId(r.0), vfs_root_path.display().to_string());\n \n@@ -176,9 +180,9 @@ impl WorldState {\n \n         let mut analysis_host = AnalysisHost::new(lru_capacity);\n         analysis_host.apply_change(change);\n-        WorldState {\n+        GlobalState {\n             config,\n-            roots: folder_roots,\n+            local_roots,\n             workspaces: Arc::new(workspaces),\n             analysis_host,\n             vfs: Arc::new(RwLock::new(vfs)),\n@@ -216,7 +220,7 @@ impl WorldState {\n             match c {\n                 VfsChange::AddRoot { root, files } => {\n                     let root_path = self.vfs.read().root2path(root);\n-                    let is_local = self.roots.iter().any(|r| root_path.starts_with(r));\n+                    let is_local = self.local_roots.iter().any(|r| root_path.starts_with(r));\n                     if is_local {\n                         *roots_scanned += 1;\n                         for (file, path, text) in files {\n@@ -251,8 +255,8 @@ impl WorldState {\n         self.analysis_host.apply_change(change);\n     }\n \n-    pub fn snapshot(&self) -> WorldSnapshot {\n-        WorldSnapshot {\n+    pub fn snapshot(&self) -> GlobalStateSnapshot {\n+        GlobalStateSnapshot {\n             config: self.config.clone(),\n             workspaces: Arc::clone(&self.workspaces),\n             analysis: self.analysis_host.analysis(),\n@@ -275,7 +279,7 @@ impl WorldState {\n     }\n }\n \n-impl WorldSnapshot {\n+impl GlobalStateSnapshot {\n     pub fn analysis(&self) -> &Analysis {\n         &self.analysis\n     }", "previous_filename": "crates/rust-analyzer/src/world.rs"}, {"sha": "609cb69d3bff6174a15502db7dfd1f19900bb034", "filename": "crates/rust-analyzer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flib.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -26,7 +26,7 @@ mod main_loop;\n mod markdown;\n pub mod lsp_ext;\n pub mod config;\n-mod world;\n+mod global_state;\n mod diagnostics;\n mod semantic_tokens;\n "}, {"sha": "ec24ce5e0f5f0009ad128fb6f57c32d823556130", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 41, "deletions": 27, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -3,8 +3,7 @@\n use std::{collections::HashMap, path::PathBuf};\n \n use lsp_types::request::Request;\n-use lsp_types::{Location, Position, Range, TextDocumentIdentifier};\n-use rustc_hash::FxHashMap;\n+use lsp_types::{Position, Range, TextDocumentIdentifier};\n use serde::{Deserialize, Serialize};\n \n pub enum AnalyzerStatus {}\n@@ -38,13 +37,6 @@ pub struct SyntaxTreeParams {\n     pub range: Option<Range>,\n }\n \n-#[derive(Deserialize, Serialize, Debug)]\n-#[serde(rename_all = \"camelCase\")]\n-pub struct ExpandedMacro {\n-    pub name: String,\n-    pub expansion: String,\n-}\n-\n pub enum ExpandMacro {}\n \n impl Request for ExpandMacro {\n@@ -57,30 +49,37 @@ impl Request for ExpandMacro {\n #[serde(rename_all = \"camelCase\")]\n pub struct ExpandMacroParams {\n     pub text_document: TextDocumentIdentifier,\n-    pub position: Option<Position>,\n+    pub position: Position,\n }\n \n-pub enum FindMatchingBrace {}\n+#[derive(Deserialize, Serialize, Debug)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct ExpandedMacro {\n+    pub name: String,\n+    pub expansion: String,\n+}\n+\n+pub enum MatchingBrace {}\n \n-impl Request for FindMatchingBrace {\n-    type Params = FindMatchingBraceParams;\n+impl Request for MatchingBrace {\n+    type Params = MatchingBraceParams;\n     type Result = Vec<Position>;\n-    const METHOD: &'static str = \"rust-analyzer/findMatchingBrace\";\n+    const METHOD: &'static str = \"experimental/matchingBrace\";\n }\n \n #[derive(Deserialize, Serialize, Debug)]\n #[serde(rename_all = \"camelCase\")]\n-pub struct FindMatchingBraceParams {\n+pub struct MatchingBraceParams {\n     pub text_document: TextDocumentIdentifier,\n-    pub offsets: Vec<Position>,\n+    pub positions: Vec<Position>,\n }\n \n pub enum ParentModule {}\n \n impl Request for ParentModule {\n     type Params = lsp_types::TextDocumentPositionParams;\n-    type Result = Vec<Location>;\n-    const METHOD: &'static str = \"rust-analyzer/parentModule\";\n+    type Result = Option<lsp_types::GotoDefinitionResponse>;\n+    const METHOD: &'static str = \"experimental/parentModule\";\n }\n \n pub enum JoinLines {}\n@@ -102,16 +101,16 @@ pub enum OnEnter {}\n \n impl Request for OnEnter {\n     type Params = lsp_types::TextDocumentPositionParams;\n-    type Result = Option<SnippetWorkspaceEdit>;\n-    const METHOD: &'static str = \"rust-analyzer/onEnter\";\n+    type Result = Option<Vec<SnippetTextEdit>>;\n+    const METHOD: &'static str = \"experimental/onEnter\";\n }\n \n pub enum Runnables {}\n \n impl Request for Runnables {\n     type Params = RunnablesParams;\n     type Result = Vec<Runnable>;\n-    const METHOD: &'static str = \"rust-analyzer/runnables\";\n+    const METHOD: &'static str = \"experimental/runnables\";\n }\n \n #[derive(Serialize, Deserialize, Debug)]\n@@ -124,13 +123,28 @@ pub struct RunnablesParams {\n #[derive(Deserialize, Serialize, Debug)]\n #[serde(rename_all = \"camelCase\")]\n pub struct Runnable {\n-    pub range: Range,\n     pub label: String,\n-    pub bin: String,\n-    pub args: Vec<String>,\n-    pub extra_args: Vec<String>,\n-    pub env: FxHashMap<String, String>,\n-    pub cwd: Option<PathBuf>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub location: Option<lsp_types::LocationLink>,\n+    pub kind: RunnableKind,\n+    pub args: CargoRunnable,\n+}\n+\n+#[derive(Serialize, Deserialize, Debug)]\n+#[serde(rename_all = \"lowercase\")]\n+pub enum RunnableKind {\n+    Cargo,\n+}\n+\n+#[derive(Deserialize, Serialize, Debug)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct CargoRunnable {\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub workspace_root: Option<PathBuf>,\n+    // command, --package and --lib stuff\n+    pub cargo_args: Vec<String>,\n+    // stuff after --\n+    pub executable_args: Vec<String>,\n }\n \n pub enum InlayHints {}"}, {"sha": "1f8f6b978616babdf06dbfcc88f582143e9b69e0", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 72, "deletions": 79, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -12,13 +12,11 @@ use std::{\n     fmt,\n     ops::Range,\n     panic,\n-    path::PathBuf,\n     sync::Arc,\n     time::{Duration, Instant},\n };\n \n use crossbeam_channel::{never, select, unbounded, RecvError, Sender};\n-use itertools::Itertools;\n use lsp_server::{Connection, ErrorCode, Message, Notification, Request, RequestId, Response};\n use lsp_types::{\n     DidChangeTextDocumentParams, NumberOrString, TextDocumentContentChangeEvent, WorkDoneProgress,\n@@ -36,14 +34,15 @@ use serde::{de::DeserializeOwned, Serialize};\n use threadpool::ThreadPool;\n \n use crate::{\n-    config::{Config, FilesWatcher},\n+    config::{Config, FilesWatcher, LinkedProject},\n     diagnostics::{to_proto::url_from_path_with_drive_lowercasing, DiagnosticTask},\n-    from_proto, lsp_ext,\n+    from_proto,\n+    global_state::{GlobalState, GlobalStateSnapshot},\n+    lsp_ext,\n     main_loop::{\n         pending_requests::{PendingRequest, PendingRequests},\n         subscriptions::Subscriptions,\n     },\n-    world::{WorldSnapshot, WorldState},\n     Result,\n };\n \n@@ -69,7 +68,7 @@ impl fmt::Display for LspError {\n \n impl Error for LspError {}\n \n-pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection) -> Result<()> {\n+pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n     log::info!(\"initial config: {:#?}\", config);\n \n     // Windows scheduler implements priority boosts: if thread waits for an\n@@ -92,43 +91,37 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n     }\n \n     let mut loop_state = LoopState::default();\n-    let mut world_state = {\n+    let mut global_state = {\n         let workspaces = {\n-            // FIXME: support dynamic workspace loading.\n-            let project_roots: FxHashSet<_> = ws_roots\n-                .iter()\n-                .filter_map(|it| ra_project_model::ProjectRoot::discover(it).ok())\n-                .flatten()\n-                .collect();\n-\n-            if project_roots.is_empty() && config.notifications.cargo_toml_not_found {\n+            if config.linked_projects.is_empty() && config.notifications.cargo_toml_not_found {\n                 show_message(\n                     lsp_types::MessageType::Error,\n-                    format!(\n-                        \"rust-analyzer failed to discover workspace, no Cargo.toml found, dirs searched: {}\",\n-                        ws_roots.iter().format_with(\", \", |it, f| f(&it.display()))\n-                    ),\n+                    \"rust-analyzer failed to discover workspace\".to_string(),\n                     &connection.sender,\n                 );\n             };\n \n-            project_roots\n-                .into_iter()\n-                .filter_map(|root| {\n-                    ra_project_model::ProjectWorkspace::load(\n-                        root,\n-                        &config.cargo,\n-                        config.with_sysroot,\n-                    )\n-                    .map_err(|err| {\n-                        log::error!(\"failed to load workspace: {:#}\", err);\n-                        show_message(\n-                            lsp_types::MessageType::Error,\n-                            format!(\"rust-analyzer failed to load workspace: {:#}\", err),\n-                            &connection.sender,\n-                        );\n-                    })\n-                    .ok()\n+            config\n+                .linked_projects\n+                .iter()\n+                .filter_map(|project| match project {\n+                    LinkedProject::ProjectManifest(manifest) => {\n+                        ra_project_model::ProjectWorkspace::load(\n+                            manifest.clone(),\n+                            &config.cargo,\n+                            config.with_sysroot,\n+                        )\n+                        .map_err(|err| {\n+                            log::error!(\"failed to load workspace: {:#}\", err);\n+                            show_message(\n+                                lsp_types::MessageType::Error,\n+                                format!(\"rust-analyzer failed to load workspace: {:#}\", err),\n+                                &connection.sender,\n+                            );\n+                        })\n+                        .ok()\n+                    }\n+                    LinkedProject::JsonProject(it) => Some(it.clone().into()),\n                 })\n                 .collect::<Vec<_>>()\n         };\n@@ -163,8 +156,7 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n             connection.sender.send(request.into()).unwrap();\n         }\n \n-        WorldState::new(\n-            ws_roots,\n+        GlobalState::new(\n             workspaces,\n             config.lru_capacity,\n             &globs,\n@@ -173,7 +165,7 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n         )\n     };\n \n-    loop_state.roots_total = world_state.vfs.read().n_roots();\n+    loop_state.roots_total = global_state.vfs.read().n_roots();\n \n     let pool = ThreadPool::default();\n     let (task_sender, task_receiver) = unbounded::<Task>();\n@@ -191,12 +183,12 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n                     Err(RecvError) => return Err(\"client exited without shutdown\".into()),\n                 },\n                 recv(task_receiver) -> task => Event::Task(task.unwrap()),\n-                recv(world_state.task_receiver) -> task => match task {\n+                recv(global_state.task_receiver) -> task => match task {\n                     Ok(task) => Event::Vfs(task),\n                     Err(RecvError) => return Err(\"vfs died\".into()),\n                 },\n                 recv(libdata_receiver) -> data => Event::Lib(data.unwrap()),\n-                recv(world_state.flycheck.as_ref().map_or(&never(), |it| &it.task_recv)) -> task => match task {\n+                recv(global_state.flycheck.as_ref().map_or(&never(), |it| &it.task_recv)) -> task => match task {\n                     Ok(task) => Event::CheckWatcher(task),\n                     Err(RecvError) => return Err(\"check watcher died\".into()),\n                 }\n@@ -211,16 +203,16 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n                 &task_sender,\n                 &libdata_sender,\n                 &connection,\n-                &mut world_state,\n+                &mut global_state,\n                 &mut loop_state,\n                 event,\n             )?;\n         }\n     }\n-    world_state.analysis_host.request_cancellation();\n+    global_state.analysis_host.request_cancellation();\n     log::info!(\"waiting for tasks to finish...\");\n     task_receiver.into_iter().for_each(|task| {\n-        on_task(task, &connection.sender, &mut loop_state.pending_requests, &mut world_state)\n+        on_task(task, &connection.sender, &mut loop_state.pending_requests, &mut global_state)\n     });\n     libdata_receiver.into_iter().for_each(drop);\n     log::info!(\"...tasks have finished\");\n@@ -229,7 +221,7 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n     drop(pool);\n     log::info!(\"...threadpool has finished\");\n \n-    let vfs = Arc::try_unwrap(world_state.vfs).expect(\"all snapshots should be dead\");\n+    let vfs = Arc::try_unwrap(global_state.vfs).expect(\"all snapshots should be dead\");\n     drop(vfs);\n \n     Ok(())\n@@ -320,7 +312,7 @@ fn loop_turn(\n     task_sender: &Sender<Task>,\n     libdata_sender: &Sender<LibraryData>,\n     connection: &Connection,\n-    world_state: &mut WorldState,\n+    global_state: &mut GlobalState,\n     loop_state: &mut LoopState,\n     event: Event,\n ) -> Result<()> {\n@@ -336,22 +328,22 @@ fn loop_turn(\n \n     match event {\n         Event::Task(task) => {\n-            on_task(task, &connection.sender, &mut loop_state.pending_requests, world_state);\n-            world_state.maybe_collect_garbage();\n+            on_task(task, &connection.sender, &mut loop_state.pending_requests, global_state);\n+            global_state.maybe_collect_garbage();\n         }\n         Event::Vfs(task) => {\n-            world_state.vfs.write().handle_task(task);\n+            global_state.vfs.write().handle_task(task);\n         }\n         Event::Lib(lib) => {\n-            world_state.add_lib(lib);\n-            world_state.maybe_collect_garbage();\n+            global_state.add_lib(lib);\n+            global_state.maybe_collect_garbage();\n             loop_state.in_flight_libraries -= 1;\n             loop_state.roots_scanned += 1;\n         }\n-        Event::CheckWatcher(task) => on_check_task(task, world_state, task_sender)?,\n+        Event::CheckWatcher(task) => on_check_task(task, global_state, task_sender)?,\n         Event::Msg(msg) => match msg {\n             Message::Request(req) => on_request(\n-                world_state,\n+                global_state,\n                 &mut loop_state.pending_requests,\n                 pool,\n                 task_sender,\n@@ -360,7 +352,7 @@ fn loop_turn(\n                 req,\n             )?,\n             Message::Notification(not) => {\n-                on_notification(&connection.sender, world_state, loop_state, not)?;\n+                on_notification(&connection.sender, global_state, loop_state, not)?;\n             }\n             Message::Response(resp) => {\n                 let removed = loop_state.pending_responses.remove(&resp.id);\n@@ -379,9 +371,9 @@ fn loop_turn(\n                         }\n                         (None, Some(configs)) => {\n                             if let Some(new_config) = configs.get(0) {\n-                                let mut config = world_state.config.clone();\n+                                let mut config = global_state.config.clone();\n                                 config.update(&new_config);\n-                                world_state.update_configuration(config);\n+                                global_state.update_configuration(config);\n                             }\n                         }\n                         (None, None) => {\n@@ -394,7 +386,7 @@ fn loop_turn(\n     };\n \n     let mut state_changed = false;\n-    if let Some(changes) = world_state.process_changes(&mut loop_state.roots_scanned) {\n+    if let Some(changes) = global_state.process_changes(&mut loop_state.roots_scanned) {\n         state_changed = true;\n         loop_state.pending_libraries.extend(changes);\n     }\n@@ -416,7 +408,7 @@ fn loop_turn(\n     }\n \n     let show_progress =\n-        !loop_state.workspace_loaded && world_state.config.client_caps.work_done_progress;\n+        !loop_state.workspace_loaded && global_state.config.client_caps.work_done_progress;\n \n     if !loop_state.workspace_loaded\n         && loop_state.roots_scanned == loop_state.roots_total\n@@ -425,7 +417,7 @@ fn loop_turn(\n     {\n         state_changed = true;\n         loop_state.workspace_loaded = true;\n-        if let Some(flycheck) = &world_state.flycheck {\n+        if let Some(flycheck) = &global_state.flycheck {\n             flycheck.update();\n         }\n     }\n@@ -437,13 +429,13 @@ fn loop_turn(\n     if state_changed && loop_state.workspace_loaded {\n         update_file_notifications_on_threadpool(\n             pool,\n-            world_state.snapshot(),\n+            global_state.snapshot(),\n             task_sender.clone(),\n             loop_state.subscriptions.subscriptions(),\n         );\n         pool.execute({\n             let subs = loop_state.subscriptions.subscriptions();\n-            let snap = world_state.snapshot();\n+            let snap = global_state.snapshot();\n             move || snap.analysis().prime_caches(subs).unwrap_or_else(|_: Canceled| ())\n         });\n     }\n@@ -467,7 +459,7 @@ fn on_task(\n     task: Task,\n     msg_sender: &Sender<Message>,\n     pending_requests: &mut PendingRequests,\n-    state: &mut WorldState,\n+    state: &mut GlobalState,\n ) {\n     match task {\n         Task::Respond(response) => {\n@@ -485,7 +477,7 @@ fn on_task(\n }\n \n fn on_request(\n-    world: &mut WorldState,\n+    global_state: &mut GlobalState,\n     pending_requests: &mut PendingRequests,\n     pool: &ThreadPool,\n     task_sender: &Sender<Task>,\n@@ -496,7 +488,7 @@ fn on_request(\n     let mut pool_dispatcher = PoolDispatcher {\n         req: Some(req),\n         pool,\n-        world,\n+        global_state,\n         task_sender,\n         msg_sender,\n         pending_requests,\n@@ -509,9 +501,7 @@ fn on_request(\n         .on_sync::<lsp_types::request::SelectionRangeRequest>(|s, p| {\n             handlers::handle_selection_range(s.snapshot(), p)\n         })?\n-        .on_sync::<lsp_ext::FindMatchingBrace>(|s, p| {\n-            handlers::handle_find_matching_brace(s.snapshot(), p)\n-        })?\n+        .on_sync::<lsp_ext::MatchingBrace>(|s, p| handlers::handle_matching_brace(s.snapshot(), p))?\n         .on::<lsp_ext::AnalyzerStatus>(handlers::handle_analyzer_status)?\n         .on::<lsp_ext::SyntaxTree>(handlers::handle_syntax_tree)?\n         .on::<lsp_ext::ExpandMacro>(handlers::handle_expand_macro)?\n@@ -554,7 +544,7 @@ fn on_request(\n \n fn on_notification(\n     msg_sender: &Sender<Message>,\n-    state: &mut WorldState,\n+    state: &mut GlobalState,\n     loop_state: &mut LoopState,\n     not: Notification,\n ) -> Result<()> {\n@@ -728,7 +718,7 @@ fn apply_document_changes(\n \n fn on_check_task(\n     task: CheckTask,\n-    world_state: &mut WorldState,\n+    global_state: &mut GlobalState,\n     task_sender: &Sender<Task>,\n ) -> Result<()> {\n     match task {\n@@ -747,7 +737,7 @@ fn on_check_task(\n                     .uri\n                     .to_file_path()\n                     .map_err(|()| format!(\"invalid uri: {}\", diag.location.uri))?;\n-                let file_id = match world_state.vfs.read().path2file(&path) {\n+                let file_id = match global_state.vfs.read().path2file(&path) {\n                     Some(file) => FileId(file.0),\n                     None => {\n                         log::error!(\n@@ -767,7 +757,7 @@ fn on_check_task(\n         }\n \n         CheckTask::Status(status) => {\n-            if world_state.config.client_caps.work_done_progress {\n+            if global_state.config.client_caps.work_done_progress {\n                 let progress = match status {\n                     Status::Being => {\n                         lsp_types::WorkDoneProgress::Begin(lsp_types::WorkDoneProgressBegin {\n@@ -806,7 +796,7 @@ fn on_check_task(\n     Ok(())\n }\n \n-fn on_diagnostic_task(task: DiagnosticTask, msg_sender: &Sender<Message>, state: &mut WorldState) {\n+fn on_diagnostic_task(task: DiagnosticTask, msg_sender: &Sender<Message>, state: &mut GlobalState) {\n     let subscriptions = state.diagnostics.handle_task(task);\n \n     for file_id in subscriptions {\n@@ -881,7 +871,7 @@ fn send_startup_progress(sender: &Sender<Message>, loop_state: &mut LoopState) {\n struct PoolDispatcher<'a> {\n     req: Option<Request>,\n     pool: &'a ThreadPool,\n-    world: &'a mut WorldState,\n+    global_state: &'a mut GlobalState,\n     pending_requests: &'a mut PendingRequests,\n     msg_sender: &'a Sender<Message>,\n     task_sender: &'a Sender<Task>,\n@@ -892,7 +882,7 @@ impl<'a> PoolDispatcher<'a> {\n     /// Dispatches the request onto the current thread\n     fn on_sync<R>(\n         &mut self,\n-        f: fn(&mut WorldState, R::Params) -> Result<R::Result>,\n+        f: fn(&mut GlobalState, R::Params) -> Result<R::Result>,\n     ) -> Result<&mut Self>\n     where\n         R: lsp_types::request::Request + 'static,\n@@ -905,18 +895,21 @@ impl<'a> PoolDispatcher<'a> {\n                 return Ok(self);\n             }\n         };\n-        let world = panic::AssertUnwindSafe(&mut *self.world);\n+        let world = panic::AssertUnwindSafe(&mut *self.global_state);\n         let task = panic::catch_unwind(move || {\n             let result = f(world.0, params);\n             result_to_task::<R>(id, result)\n         })\n         .map_err(|_| format!(\"sync task {:?} panicked\", R::METHOD))?;\n-        on_task(task, self.msg_sender, self.pending_requests, self.world);\n+        on_task(task, self.msg_sender, self.pending_requests, self.global_state);\n         Ok(self)\n     }\n \n     /// Dispatches the request onto thread pool\n-    fn on<R>(&mut self, f: fn(WorldSnapshot, R::Params) -> Result<R::Result>) -> Result<&mut Self>\n+    fn on<R>(\n+        &mut self,\n+        f: fn(GlobalStateSnapshot, R::Params) -> Result<R::Result>,\n+    ) -> Result<&mut Self>\n     where\n         R: lsp_types::request::Request + 'static,\n         R::Params: DeserializeOwned + Send + 'static,\n@@ -930,7 +923,7 @@ impl<'a> PoolDispatcher<'a> {\n         };\n \n         self.pool.execute({\n-            let world = self.world.snapshot();\n+            let world = self.global_state.snapshot();\n             let sender = self.task_sender.clone();\n             move || {\n                 let result = f(world, params);\n@@ -1014,7 +1007,7 @@ where\n \n fn update_file_notifications_on_threadpool(\n     pool: &ThreadPool,\n-    world: WorldSnapshot,\n+    world: GlobalStateSnapshot,\n     task_sender: Sender<Task>,\n     subscriptions: Vec<FileId>,\n ) {"}, {"sha": "c2a5bf4d6b8f7a9cc38fad22afe194eee664f46c", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 231, "deletions": 265, "changes": 496, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -18,13 +18,11 @@ use lsp_types::{\n     SemanticTokensResult, SymbolInformation, TextDocumentIdentifier, Url, WorkspaceEdit,\n };\n use ra_ide::{\n-    FileId, FilePosition, FileRange, Query, RangeInfo, Runnable, RunnableKind, SearchScope,\n-    TextEdit,\n+    FileId, FilePosition, FileRange, Query, RangeInfo, RunnableKind, SearchScope, TextEdit,\n };\n use ra_prof::profile;\n use ra_project_model::TargetKind;\n use ra_syntax::{AstNode, SyntaxKind, TextRange, TextSize};\n-use rustc_hash::FxHashMap;\n use serde::{Deserialize, Serialize};\n use serde_json::to_value;\n use stdx::format_to;\n@@ -34,17 +32,16 @@ use crate::{\n     config::RustfmtConfig,\n     diagnostics::DiagnosticTask,\n     from_json, from_proto,\n+    global_state::GlobalStateSnapshot,\n     lsp_ext::{self, InlayHint, InlayHintsParams},\n-    to_proto,\n-    world::WorldSnapshot,\n-    LspError, Result,\n+    to_proto, LspError, Result,\n };\n \n-pub fn handle_analyzer_status(world: WorldSnapshot, _: ()) -> Result<String> {\n+pub fn handle_analyzer_status(snap: GlobalStateSnapshot, _: ()) -> Result<String> {\n     let _p = profile(\"handle_analyzer_status\");\n-    let mut buf = world.status();\n+    let mut buf = snap.status();\n     format_to!(buf, \"\\n\\nrequests:\\n\");\n-    let requests = world.latest_requests.read();\n+    let requests = snap.latest_requests.read();\n     for (is_last, r) in requests.iter() {\n         let mark = if is_last { \"*\" } else { \" \" };\n         format_to!(buf, \"{}{:4} {:<36}{}ms\\n\", mark, r.id, r.method, r.duration.as_millis());\n@@ -53,42 +50,37 @@ pub fn handle_analyzer_status(world: WorldSnapshot, _: ()) -> Result<String> {\n }\n \n pub fn handle_syntax_tree(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::SyntaxTreeParams,\n ) -> Result<String> {\n     let _p = profile(\"handle_syntax_tree\");\n-    let id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(id)?;\n+    let id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(id)?;\n     let text_range = params.range.map(|r| from_proto::text_range(&line_index, r));\n-    let res = world.analysis().syntax_tree(id, text_range)?;\n+    let res = snap.analysis().syntax_tree(id, text_range)?;\n     Ok(res)\n }\n \n pub fn handle_expand_macro(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::ExpandMacroParams,\n ) -> Result<Option<lsp_ext::ExpandedMacro>> {\n     let _p = profile(\"handle_expand_macro\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let offset = params.position.map(|p| from_proto::offset(&line_index, p));\n-\n-    match offset {\n-        None => Ok(None),\n-        Some(offset) => {\n-            let res = world.analysis().expand_macro(FilePosition { file_id, offset })?;\n-            Ok(res.map(|it| lsp_ext::ExpandedMacro { name: it.name, expansion: it.expansion }))\n-        }\n-    }\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let offset = from_proto::offset(&line_index, params.position);\n+\n+    let res = snap.analysis().expand_macro(FilePosition { file_id, offset })?;\n+    Ok(res.map(|it| lsp_ext::ExpandedMacro { name: it.name, expansion: it.expansion }))\n }\n \n pub fn handle_selection_range(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::SelectionRangeParams,\n ) -> Result<Option<Vec<lsp_types::SelectionRange>>> {\n     let _p = profile(\"handle_selection_range\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let res: Result<Vec<lsp_types::SelectionRange>> = params\n         .positions\n         .into_iter()\n@@ -100,7 +92,7 @@ pub fn handle_selection_range(\n                 loop {\n                     ranges.push(range);\n                     let frange = FileRange { file_id, range };\n-                    let next = world.analysis().extend_selection(frange)?;\n+                    let next = snap.analysis().extend_selection(frange)?;\n                     if next == range {\n                         break;\n                     } else {\n@@ -125,19 +117,19 @@ pub fn handle_selection_range(\n     Ok(Some(res?))\n }\n \n-pub fn handle_find_matching_brace(\n-    world: WorldSnapshot,\n-    params: lsp_ext::FindMatchingBraceParams,\n+pub fn handle_matching_brace(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_ext::MatchingBraceParams,\n ) -> Result<Vec<Position>> {\n-    let _p = profile(\"handle_find_matching_brace\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let _p = profile(\"handle_matching_brace\");\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let res = params\n-        .offsets\n+        .positions\n         .into_iter()\n         .map(|position| {\n             let offset = from_proto::offset(&line_index, position);\n-            let offset = match world.analysis().matching_brace(FilePosition { file_id, offset }) {\n+            let offset = match snap.analysis().matching_brace(FilePosition { file_id, offset }) {\n                 Ok(Some(matching_brace_offset)) => matching_brace_offset,\n                 Err(_) | Ok(None) => offset,\n             };\n@@ -148,17 +140,17 @@ pub fn handle_find_matching_brace(\n }\n \n pub fn handle_join_lines(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::JoinLinesParams,\n ) -> Result<Vec<lsp_types::TextEdit>> {\n     let _p = profile(\"handle_join_lines\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let line_endings = world.file_line_endings(file_id);\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let line_endings = snap.file_line_endings(file_id);\n     let mut res = TextEdit::default();\n     for range in params.ranges {\n         let range = from_proto::text_range(&line_index, range);\n-        let edit = world.analysis().join_lines(FileRange { file_id, range })?;\n+        let edit = snap.analysis().join_lines(FileRange { file_id, range })?;\n         match res.union(edit) {\n             Ok(()) => (),\n             Err(_edit) => {\n@@ -171,33 +163,37 @@ pub fn handle_join_lines(\n }\n \n pub fn handle_on_enter(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::TextDocumentPositionParams,\n-) -> Result<Option<lsp_ext::SnippetWorkspaceEdit>> {\n+) -> Result<Option<Vec<lsp_ext::SnippetTextEdit>>> {\n     let _p = profile(\"handle_on_enter\");\n-    let position = from_proto::file_position(&world, params)?;\n-    match world.analysis().on_enter(position)? {\n-        None => Ok(None),\n-        Some(source_change) => to_proto::snippet_workspace_edit(&world, source_change).map(Some),\n-    }\n+    let position = from_proto::file_position(&snap, params)?;\n+    let edit = match snap.analysis().on_enter(position)? {\n+        None => return Ok(None),\n+        Some(it) => it,\n+    };\n+    let line_index = snap.analysis().file_line_index(position.file_id)?;\n+    let line_endings = snap.file_line_endings(position.file_id);\n+    let edit = to_proto::snippet_text_edit_vec(&line_index, line_endings, true, edit);\n+    Ok(Some(edit))\n }\n \n // Don't forget to add new trigger characters to `ServerCapabilities` in `caps.rs`.\n pub fn handle_on_type_formatting(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::DocumentOnTypeFormattingParams,\n ) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n     let _p = profile(\"handle_on_type_formatting\");\n-    let mut position = from_proto::file_position(&world, params.text_document_position)?;\n-    let line_index = world.analysis().file_line_index(position.file_id)?;\n-    let line_endings = world.file_line_endings(position.file_id);\n+    let mut position = from_proto::file_position(&snap, params.text_document_position)?;\n+    let line_index = snap.analysis().file_line_index(position.file_id)?;\n+    let line_endings = snap.file_line_endings(position.file_id);\n \n     // in `ra_ide`, the `on_type` invariant is that\n     // `text.char_at(position) == typed_char`.\n     position.offset -= TextSize::of('.');\n     let char_typed = params.ch.chars().next().unwrap_or('\\0');\n     assert!({\n-        let text = world.analysis().file_text(position.file_id)?;\n+        let text = snap.analysis().file_text(position.file_id)?;\n         text[usize::from(position.offset)..].starts_with(char_typed)\n     });\n \n@@ -209,7 +205,7 @@ pub fn handle_on_type_formatting(\n         return Ok(None);\n     }\n \n-    let edit = world.analysis().on_char_typed(position, char_typed)?;\n+    let edit = snap.analysis().on_char_typed(position, char_typed)?;\n     let mut edit = match edit {\n         Some(it) => it,\n         None => return Ok(None),\n@@ -223,16 +219,16 @@ pub fn handle_on_type_formatting(\n }\n \n pub fn handle_document_symbol(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::DocumentSymbolParams,\n ) -> Result<Option<lsp_types::DocumentSymbolResponse>> {\n     let _p = profile(\"handle_document_symbol\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n \n     let mut parents: Vec<(DocumentSymbol, Option<usize>)> = Vec::new();\n \n-    for symbol in world.analysis().file_structure(file_id)? {\n+    for symbol in snap.analysis().file_structure(file_id)? {\n         let doc_symbol = DocumentSymbol {\n             name: symbol.label,\n             detail: symbol.detail,\n@@ -258,10 +254,10 @@ pub fn handle_document_symbol(\n         }\n     }\n \n-    let res = if world.config.client_caps.hierarchical_symbols {\n+    let res = if snap.config.client_caps.hierarchical_symbols {\n         document_symbols.into()\n     } else {\n-        let url = to_proto::url(&world, file_id)?;\n+        let url = to_proto::url(&snap, file_id)?;\n         let mut symbol_information = Vec::<SymbolInformation>::new();\n         for symbol in document_symbols {\n             flatten_document_symbol(&symbol, None, &url, &mut symbol_information);\n@@ -281,7 +277,7 @@ pub fn handle_document_symbol(\n             kind: symbol.kind,\n             deprecated: symbol.deprecated,\n             location: Location::new(url.clone(), symbol.range),\n-            container_name: container_name,\n+            container_name,\n         });\n \n         for child in symbol.children.iter().flatten() {\n@@ -291,7 +287,7 @@ pub fn handle_document_symbol(\n }\n \n pub fn handle_workspace_symbol(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::WorkspaceSymbolParams,\n ) -> Result<Option<Vec<SymbolInformation>>> {\n     let _p = profile(\"handle_workspace_symbol\");\n@@ -309,22 +305,22 @@ pub fn handle_workspace_symbol(\n         q.limit(128);\n         q\n     };\n-    let mut res = exec_query(&world, query)?;\n+    let mut res = exec_query(&snap, query)?;\n     if res.is_empty() && !all_symbols {\n         let mut query = Query::new(params.query);\n         query.limit(128);\n-        res = exec_query(&world, query)?;\n+        res = exec_query(&snap, query)?;\n     }\n \n     return Ok(Some(res));\n \n-    fn exec_query(world: &WorldSnapshot, query: Query) -> Result<Vec<SymbolInformation>> {\n+    fn exec_query(snap: &GlobalStateSnapshot, query: Query) -> Result<Vec<SymbolInformation>> {\n         let mut res = Vec::new();\n-        for nav in world.analysis().symbol_search(query)? {\n+        for nav in snap.analysis().symbol_search(query)? {\n             let info = SymbolInformation {\n                 name: nav.name().to_string(),\n                 kind: to_proto::symbol_kind(nav.kind()),\n-                location: to_proto::location(world, nav.file_range())?,\n+                location: to_proto::location(snap, nav.file_range())?,\n                 container_name: nav.container_name().map(|v| v.to_string()),\n                 deprecated: None,\n             };\n@@ -335,87 +331,75 @@ pub fn handle_workspace_symbol(\n }\n \n pub fn handle_goto_definition(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::GotoDefinitionParams,\n ) -> Result<Option<lsp_types::GotoDefinitionResponse>> {\n     let _p = profile(\"handle_goto_definition\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let nav_info = match world.analysis().goto_definition(position)? {\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let nav_info = match snap.analysis().goto_definition(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let res = to_proto::goto_definition_response(\n-        &world,\n-        FileRange { file_id: position.file_id, range: nav_info.range },\n-        nav_info.info,\n-    )?;\n+    let src = FileRange { file_id: position.file_id, range: nav_info.range };\n+    let res = to_proto::goto_definition_response(&snap, Some(src), nav_info.info)?;\n     Ok(Some(res))\n }\n \n pub fn handle_goto_implementation(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::request::GotoImplementationParams,\n ) -> Result<Option<lsp_types::request::GotoImplementationResponse>> {\n     let _p = profile(\"handle_goto_implementation\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let nav_info = match world.analysis().goto_implementation(position)? {\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let nav_info = match snap.analysis().goto_implementation(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let res = to_proto::goto_definition_response(\n-        &world,\n-        FileRange { file_id: position.file_id, range: nav_info.range },\n-        nav_info.info,\n-    )?;\n+    let src = FileRange { file_id: position.file_id, range: nav_info.range };\n+    let res = to_proto::goto_definition_response(&snap, Some(src), nav_info.info)?;\n     Ok(Some(res))\n }\n \n pub fn handle_goto_type_definition(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::request::GotoTypeDefinitionParams,\n ) -> Result<Option<lsp_types::request::GotoTypeDefinitionResponse>> {\n     let _p = profile(\"handle_goto_type_definition\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let nav_info = match world.analysis().goto_type_definition(position)? {\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let nav_info = match snap.analysis().goto_type_definition(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let res = to_proto::goto_definition_response(\n-        &world,\n-        FileRange { file_id: position.file_id, range: nav_info.range },\n-        nav_info.info,\n-    )?;\n+    let src = FileRange { file_id: position.file_id, range: nav_info.range };\n+    let res = to_proto::goto_definition_response(&snap, Some(src), nav_info.info)?;\n     Ok(Some(res))\n }\n \n pub fn handle_parent_module(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::TextDocumentPositionParams,\n-) -> Result<Vec<Location>> {\n+) -> Result<Option<lsp_types::GotoDefinitionResponse>> {\n     let _p = profile(\"handle_parent_module\");\n-    let position = from_proto::file_position(&world, params)?;\n-    world\n-        .analysis()\n-        .parent_module(position)?\n-        .into_iter()\n-        .map(|it| to_proto::location(&world, it.file_range()))\n-        .collect::<Result<Vec<_>>>()\n+    let position = from_proto::file_position(&snap, params)?;\n+    let navs = snap.analysis().parent_module(position)?;\n+    let res = to_proto::goto_definition_response(&snap, None, navs)?;\n+    Ok(Some(res))\n }\n \n pub fn handle_runnables(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::RunnablesParams,\n ) -> Result<Vec<lsp_ext::Runnable>> {\n     let _p = profile(\"handle_runnables\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let offset = params.position.map(|it| from_proto::offset(&line_index, it));\n     let mut res = Vec::new();\n-    let workspace_root = world.workspace_root_for(file_id);\n-    let cargo_spec = CargoTargetSpec::for_file(&world, file_id)?;\n-    for runnable in world.analysis().runnables(file_id)? {\n+    let workspace_root = snap.workspace_root_for(file_id);\n+    let cargo_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n+    for runnable in snap.analysis().runnables(file_id)? {\n         if let Some(offset) = offset {\n-            if !runnable.range.contains_inclusive(offset) {\n+            if !runnable.nav.full_range().contains_inclusive(offset) {\n                 continue;\n             }\n         }\n@@ -428,50 +412,56 @@ pub fn handle_runnables(\n                 }\n             }\n         }\n-        res.push(to_lsp_runnable(&world, file_id, runnable)?);\n+        res.push(to_proto::runnable(&snap, file_id, runnable)?);\n     }\n \n     // Add `cargo check` and `cargo test` for the whole package\n     match cargo_spec {\n         Some(spec) => {\n             for &cmd in [\"check\", \"test\"].iter() {\n                 res.push(lsp_ext::Runnable {\n-                    range: Default::default(),\n                     label: format!(\"cargo {} -p {}\", cmd, spec.package),\n-                    bin: \"cargo\".to_string(),\n-                    args: vec![cmd.to_string(), \"--package\".to_string(), spec.package.clone()],\n-                    extra_args: Vec::new(),\n-                    env: FxHashMap::default(),\n-                    cwd: workspace_root.map(|root| root.to_owned()),\n+                    location: None,\n+                    kind: lsp_ext::RunnableKind::Cargo,\n+                    args: lsp_ext::CargoRunnable {\n+                        workspace_root: workspace_root.map(|root| root.to_owned()),\n+                        cargo_args: vec![\n+                            cmd.to_string(),\n+                            \"--package\".to_string(),\n+                            spec.package.clone(),\n+                        ],\n+                        executable_args: Vec::new(),\n+                    },\n                 })\n             }\n         }\n         None => {\n             res.push(lsp_ext::Runnable {\n-                range: Default::default(),\n                 label: \"cargo check --workspace\".to_string(),\n-                bin: \"cargo\".to_string(),\n-                args: vec![\"check\".to_string(), \"--workspace\".to_string()],\n-                extra_args: Vec::new(),\n-                env: FxHashMap::default(),\n-                cwd: workspace_root.map(|root| root.to_owned()),\n+                location: None,\n+                kind: lsp_ext::RunnableKind::Cargo,\n+                args: lsp_ext::CargoRunnable {\n+                    workspace_root: workspace_root.map(|root| root.to_owned()),\n+                    cargo_args: vec![\"check\".to_string(), \"--workspace\".to_string()],\n+                    executable_args: Vec::new(),\n+                },\n             });\n         }\n     }\n     Ok(res)\n }\n \n pub fn handle_completion(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::CompletionParams,\n ) -> Result<Option<lsp_types::CompletionResponse>> {\n     let _p = profile(\"handle_completion\");\n-    let position = from_proto::file_position(&world, params.text_document_position)?;\n+    let position = from_proto::file_position(&snap, params.text_document_position)?;\n     let completion_triggered_after_single_colon = {\n         let mut res = false;\n         if let Some(ctx) = params.context {\n             if ctx.trigger_character.unwrap_or_default() == \":\" {\n-                let source_file = world.analysis().parse(position.file_id)?;\n+                let source_file = snap.analysis().parse(position.file_id)?;\n                 let syntax = source_file.syntax();\n                 let text = syntax.text();\n                 if let Some(next_char) = text.char_at(position.offset) {\n@@ -489,12 +479,12 @@ pub fn handle_completion(\n         return Ok(None);\n     }\n \n-    let items = match world.analysis().completions(&world.config.completion, position)? {\n+    let items = match snap.analysis().completions(&snap.config.completion, position)? {\n         None => return Ok(None),\n         Some(items) => items,\n     };\n-    let line_index = world.analysis().file_line_index(position.file_id)?;\n-    let line_endings = world.file_line_endings(position.file_id);\n+    let line_index = snap.analysis().file_line_index(position.file_id)?;\n+    let line_endings = snap.file_line_endings(position.file_id);\n     let items: Vec<CompletionItem> = items\n         .into_iter()\n         .map(|item| to_proto::completion_item(&line_index, line_endings, item))\n@@ -504,15 +494,15 @@ pub fn handle_completion(\n }\n \n pub fn handle_folding_range(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: FoldingRangeParams,\n ) -> Result<Option<Vec<FoldingRange>>> {\n     let _p = profile(\"handle_folding_range\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let folds = world.analysis().folding_ranges(file_id)?;\n-    let text = world.analysis().file_text(file_id)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let line_folding_only = world.config.client_caps.line_folding_only;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let folds = snap.analysis().folding_ranges(file_id)?;\n+    let text = snap.analysis().file_text(file_id)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let line_folding_only = snap.config.client_caps.line_folding_only;\n     let res = folds\n         .into_iter()\n         .map(|it| to_proto::folding_range(&*text, &line_index, line_folding_only, it))\n@@ -521,16 +511,16 @@ pub fn handle_folding_range(\n }\n \n pub fn handle_signature_help(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::SignatureHelpParams,\n ) -> Result<Option<lsp_types::SignatureHelp>> {\n     let _p = profile(\"handle_signature_help\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let call_info = match world.analysis().call_info(position)? {\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let call_info = match snap.analysis().call_info(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let concise = !world.config.call_info_full;\n+    let concise = !snap.config.call_info_full;\n     let mut active_parameter = call_info.active_parameter.map(|it| it as i64);\n     if concise && call_info.signature.has_self_param {\n         active_parameter = active_parameter.map(|it| it.saturating_sub(1));\n@@ -544,14 +534,17 @@ pub fn handle_signature_help(\n     }))\n }\n \n-pub fn handle_hover(world: WorldSnapshot, params: lsp_types::HoverParams) -> Result<Option<Hover>> {\n+pub fn handle_hover(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::HoverParams,\n+) -> Result<Option<Hover>> {\n     let _p = profile(\"handle_hover\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let info = match world.analysis().hover(position)? {\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let info = match snap.analysis().hover(position)? {\n         None => return Ok(None),\n         Some(info) => info,\n     };\n-    let line_index = world.analysis.file_line_index(position.file_id)?;\n+    let line_index = snap.analysis.file_line_index(position.file_id)?;\n     let range = to_proto::range(&line_index, info.range);\n     let res = Hover {\n         contents: HoverContents::Markup(MarkupContent {\n@@ -564,26 +557,29 @@ pub fn handle_hover(world: WorldSnapshot, params: lsp_types::HoverParams) -> Res\n }\n \n pub fn handle_prepare_rename(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::TextDocumentPositionParams,\n ) -> Result<Option<PrepareRenameResponse>> {\n     let _p = profile(\"handle_prepare_rename\");\n-    let position = from_proto::file_position(&world, params)?;\n+    let position = from_proto::file_position(&snap, params)?;\n \n-    let optional_change = world.analysis().rename(position, \"dummy\")?;\n+    let optional_change = snap.analysis().rename(position, \"dummy\")?;\n     let range = match optional_change {\n         None => return Ok(None),\n         Some(it) => it.range,\n     };\n \n-    let line_index = world.analysis().file_line_index(position.file_id)?;\n+    let line_index = snap.analysis().file_line_index(position.file_id)?;\n     let range = to_proto::range(&line_index, range);\n     Ok(Some(PrepareRenameResponse::Range(range)))\n }\n \n-pub fn handle_rename(world: WorldSnapshot, params: RenameParams) -> Result<Option<WorkspaceEdit>> {\n+pub fn handle_rename(\n+    snap: GlobalStateSnapshot,\n+    params: RenameParams,\n+) -> Result<Option<WorkspaceEdit>> {\n     let _p = profile(\"handle_rename\");\n-    let position = from_proto::file_position(&world, params.text_document_position)?;\n+    let position = from_proto::file_position(&snap, params.text_document_position)?;\n \n     if params.new_name.is_empty() {\n         return Err(LspError::new(\n@@ -593,61 +589,61 @@ pub fn handle_rename(world: WorldSnapshot, params: RenameParams) -> Result<Optio\n         .into());\n     }\n \n-    let optional_change = world.analysis().rename(position, &*params.new_name)?;\n+    let optional_change = snap.analysis().rename(position, &*params.new_name)?;\n     let source_change = match optional_change {\n         None => return Ok(None),\n         Some(it) => it.info,\n     };\n-    let workspace_edit = to_proto::workspace_edit(&world, source_change)?;\n+    let workspace_edit = to_proto::workspace_edit(&snap, source_change)?;\n     Ok(Some(workspace_edit))\n }\n \n pub fn handle_references(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::ReferenceParams,\n ) -> Result<Option<Vec<Location>>> {\n     let _p = profile(\"handle_references\");\n-    let position = from_proto::file_position(&world, params.text_document_position)?;\n+    let position = from_proto::file_position(&snap, params.text_document_position)?;\n \n-    let refs = match world.analysis().find_all_refs(position, None)? {\n+    let refs = match snap.analysis().find_all_refs(position, None)? {\n         None => return Ok(None),\n         Some(refs) => refs,\n     };\n \n     let locations = if params.context.include_declaration {\n         refs.into_iter()\n-            .filter_map(|reference| to_proto::location(&world, reference.file_range).ok())\n+            .filter_map(|reference| to_proto::location(&snap, reference.file_range).ok())\n             .collect()\n     } else {\n         // Only iterate over the references if include_declaration was false\n         refs.references()\n             .iter()\n-            .filter_map(|reference| to_proto::location(&world, reference.file_range).ok())\n+            .filter_map(|reference| to_proto::location(&snap, reference.file_range).ok())\n             .collect()\n     };\n \n     Ok(Some(locations))\n }\n \n pub fn handle_formatting(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: DocumentFormattingParams,\n ) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n     let _p = profile(\"handle_formatting\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let file = world.analysis().file_text(file_id)?;\n-    let crate_ids = world.analysis().crate_for(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let file = snap.analysis().file_text(file_id)?;\n+    let crate_ids = snap.analysis().crate_for(file_id)?;\n \n-    let file_line_index = world.analysis().file_line_index(file_id)?;\n+    let file_line_index = snap.analysis().file_line_index(file_id)?;\n     let end_position = to_proto::position(&file_line_index, TextSize::of(file.as_str()));\n \n-    let mut rustfmt = match &world.config.rustfmt {\n+    let mut rustfmt = match &snap.config.rustfmt {\n         RustfmtConfig::Rustfmt { extra_args } => {\n             let mut cmd = process::Command::new(\"rustfmt\");\n             cmd.args(extra_args);\n             if let Some(&crate_id) = crate_ids.first() {\n                 // Assume all crates are in the same edition\n-                let edition = world.analysis().crate_edition(crate_id)?;\n+                let edition = snap.analysis().crate_edition(crate_id)?;\n                 cmd.arg(\"--edition\");\n                 cmd.arg(edition.to_string());\n             }\n@@ -706,23 +702,23 @@ pub fn handle_formatting(\n }\n \n pub fn handle_code_action(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::CodeActionParams,\n ) -> Result<Option<Vec<lsp_ext::CodeAction>>> {\n     let _p = profile(\"handle_code_action\");\n     // We intentionally don't support command-based actions, as those either\n     // requires custom client-code anyway, or requires server-initiated edits.\n     // Server initiated edits break causality, so we avoid those as well.\n-    if !world.config.client_caps.code_action_literals {\n+    if !snap.config.client_caps.code_action_literals {\n         return Ok(None);\n     }\n \n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let range = from_proto::text_range(&line_index, params.range);\n     let frange = FileRange { file_id, range };\n \n-    let diagnostics = world.analysis().diagnostics(file_id)?;\n+    let diagnostics = snap.analysis().diagnostics(file_id)?;\n     let mut res: Vec<lsp_ext::CodeAction> = Vec::new();\n \n     let fixes_from_diagnostics = diagnostics\n@@ -733,45 +729,50 @@ pub fn handle_code_action(\n \n     for fix in fixes_from_diagnostics {\n         let title = fix.label;\n-        let edit = to_proto::snippet_workspace_edit(&world, fix.source_change)?;\n-        let action =\n-            lsp_ext::CodeAction { title, group: None, kind: None, edit: Some(edit), command: None };\n+        let edit = to_proto::snippet_workspace_edit(&snap, fix.source_change)?;\n+        let action = lsp_ext::CodeAction {\n+            title,\n+            group: None,\n+            kind: Some(lsp_types::code_action_kind::QUICKFIX.into()),\n+            edit: Some(edit),\n+            command: None,\n+        };\n         res.push(action);\n     }\n \n-    for fix in world.check_fixes.get(&file_id).into_iter().flatten() {\n+    for fix in snap.check_fixes.get(&file_id).into_iter().flatten() {\n         let fix_range = from_proto::text_range(&line_index, fix.range);\n         if fix_range.intersect(range).is_none() {\n             continue;\n         }\n         res.push(fix.action.clone());\n     }\n \n-    for assist in world.analysis().assists(&world.config.assist, frange)?.into_iter() {\n-        res.push(to_proto::code_action(&world, assist)?.into());\n+    for assist in snap.analysis().assists(&snap.config.assist, frange)?.into_iter() {\n+        res.push(to_proto::code_action(&snap, assist)?.into());\n     }\n     Ok(Some(res))\n }\n \n pub fn handle_code_lens(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::CodeLensParams,\n ) -> Result<Option<Vec<CodeLens>>> {\n     let _p = profile(\"handle_code_lens\");\n     let mut lenses: Vec<CodeLens> = Default::default();\n \n-    if world.config.lens.none() {\n+    if snap.config.lens.none() {\n         // early return before any db query!\n         return Ok(Some(lenses));\n     }\n \n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let cargo_spec = CargoTargetSpec::for_file(&world, file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let cargo_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n \n-    if world.config.lens.runnable() {\n+    if snap.config.lens.runnable() {\n         // Gather runnables\n-        for runnable in world.analysis().runnables(file_id)? {\n+        for runnable in snap.analysis().runnables(file_id)? {\n             let (run_title, debugee) = match &runnable.kind {\n                 RunnableKind::Test { .. } | RunnableKind::TestMod { .. } => {\n                     (\"\u25b6\\u{fe0e} Run Test\", true)\n@@ -796,10 +797,11 @@ pub fn handle_code_lens(\n                 }\n             };\n \n-            let mut r = to_lsp_runnable(&world, file_id, runnable)?;\n-            if world.config.lens.run {\n+            let range = to_proto::range(&line_index, runnable.nav.range());\n+            let r = to_proto::runnable(&snap, file_id, runnable)?;\n+            if snap.config.lens.run {\n                 let lens = CodeLens {\n-                    range: r.range,\n+                    range,\n                     command: Some(Command {\n                         title: run_title.to_string(),\n                         command: \"rust-analyzer.runSingle\".into(),\n@@ -810,14 +812,9 @@ pub fn handle_code_lens(\n                 lenses.push(lens);\n             }\n \n-            if debugee && world.config.lens.debug {\n-                if r.args[0] == \"run\" {\n-                    r.args[0] = \"build\".into();\n-                } else {\n-                    r.args.push(\"--no-run\".into());\n-                }\n+            if debugee && snap.config.lens.debug {\n                 let debug_lens = CodeLens {\n-                    range: r.range,\n+                    range,\n                     command: Some(Command {\n                         title: \"Debug\".into(),\n                         command: \"rust-analyzer.debugSingle\".into(),\n@@ -830,11 +827,10 @@ pub fn handle_code_lens(\n         }\n     }\n \n-    if world.config.lens.impementations {\n+    if snap.config.lens.impementations {\n         // Handle impls\n         lenses.extend(\n-            world\n-                .analysis()\n+            snap.analysis()\n                 .file_structure(file_id)?\n                 .into_iter()\n                 .filter(|it| match it.kind {\n@@ -869,14 +865,17 @@ enum CodeLensResolveData {\n     Impls(lsp_types::request::GotoImplementationParams),\n }\n \n-pub fn handle_code_lens_resolve(world: WorldSnapshot, code_lens: CodeLens) -> Result<CodeLens> {\n+pub fn handle_code_lens_resolve(\n+    snap: GlobalStateSnapshot,\n+    code_lens: CodeLens,\n+) -> Result<CodeLens> {\n     let _p = profile(\"handle_code_lens_resolve\");\n     let data = code_lens.data.unwrap();\n     let resolve = from_json::<Option<CodeLensResolveData>>(\"CodeLensResolveData\", data)?;\n     match resolve {\n         Some(CodeLensResolveData::Impls(lens_params)) => {\n             let locations: Vec<Location> =\n-                match handle_goto_implementation(world, lens_params.clone())? {\n+                match handle_goto_implementation(snap, lens_params.clone())? {\n                     Some(lsp_types::GotoDefinitionResponse::Scalar(loc)) => vec![loc],\n                     Some(lsp_types::GotoDefinitionResponse::Array(locs)) => locs,\n                     Some(lsp_types::GotoDefinitionResponse::Link(links)) => links\n@@ -915,14 +914,14 @@ pub fn handle_code_lens_resolve(world: WorldSnapshot, code_lens: CodeLens) -> Re\n }\n \n pub fn handle_document_highlight(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::DocumentHighlightParams,\n ) -> Result<Option<Vec<DocumentHighlight>>> {\n     let _p = profile(\"handle_document_highlight\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let line_index = world.analysis().file_line_index(position.file_id)?;\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let line_index = snap.analysis().file_line_index(position.file_id)?;\n \n-    let refs = match world\n+    let refs = match snap\n         .analysis()\n         .find_all_refs(position, Some(SearchScope::single_file(position.file_id)))?\n     {\n@@ -942,19 +941,19 @@ pub fn handle_document_highlight(\n }\n \n pub fn handle_ssr(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::SsrParams,\n ) -> Result<lsp_types::WorkspaceEdit> {\n     let _p = profile(\"handle_ssr\");\n     let source_change =\n-        world.analysis().structural_search_replace(&params.query, params.parse_only)??;\n-    to_proto::workspace_edit(&world, source_change)\n+        snap.analysis().structural_search_replace(&params.query, params.parse_only)??;\n+    to_proto::workspace_edit(&snap, source_change)\n }\n \n-pub fn publish_diagnostics(world: &WorldSnapshot, file_id: FileId) -> Result<DiagnosticTask> {\n+pub fn publish_diagnostics(snap: &GlobalStateSnapshot, file_id: FileId) -> Result<DiagnosticTask> {\n     let _p = profile(\"publish_diagnostics\");\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let diagnostics: Vec<Diagnostic> = world\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let diagnostics: Vec<Diagnostic> = snap\n         .analysis()\n         .diagnostics(file_id)?\n         .into_iter()\n@@ -971,62 +970,29 @@ pub fn publish_diagnostics(world: &WorldSnapshot, file_id: FileId) -> Result<Dia\n     Ok(DiagnosticTask::SetNative(file_id, diagnostics))\n }\n \n-fn to_lsp_runnable(\n-    world: &WorldSnapshot,\n-    file_id: FileId,\n-    runnable: Runnable,\n-) -> Result<lsp_ext::Runnable> {\n-    let spec = CargoTargetSpec::for_file(world, file_id)?;\n-    let target = spec.as_ref().map(|s| s.target.clone());\n-    let (args, extra_args) = CargoTargetSpec::runnable_args(spec, &runnable.kind)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let label = match &runnable.kind {\n-        RunnableKind::Test { test_id, .. } => format!(\"test {}\", test_id),\n-        RunnableKind::TestMod { path } => format!(\"test-mod {}\", path),\n-        RunnableKind::Bench { test_id } => format!(\"bench {}\", test_id),\n-        RunnableKind::DocTest { test_id, .. } => format!(\"doctest {}\", test_id),\n-        RunnableKind::Bin => {\n-            target.map_or_else(|| \"run binary\".to_string(), |t| format!(\"run {}\", t))\n-        }\n-    };\n-    Ok(lsp_ext::Runnable {\n-        range: to_proto::range(&line_index, runnable.range),\n-        label,\n-        bin: \"cargo\".to_string(),\n-        args,\n-        extra_args,\n-        env: {\n-            let mut m = FxHashMap::default();\n-            m.insert(\"RUST_BACKTRACE\".to_string(), \"short\".to_string());\n-            m\n-        },\n-        cwd: world.workspace_root_for(file_id).map(|root| root.to_owned()),\n-    })\n-}\n-\n pub fn handle_inlay_hints(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: InlayHintsParams,\n ) -> Result<Vec<InlayHint>> {\n     let _p = profile(\"handle_inlay_hints\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let analysis = world.analysis();\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let analysis = snap.analysis();\n     let line_index = analysis.file_line_index(file_id)?;\n     Ok(analysis\n-        .inlay_hints(file_id, &world.config.inlay_hints)?\n+        .inlay_hints(file_id, &snap.config.inlay_hints)?\n         .into_iter()\n         .map(|it| to_proto::inlay_int(&line_index, it))\n         .collect())\n }\n \n pub fn handle_call_hierarchy_prepare(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: CallHierarchyPrepareParams,\n ) -> Result<Option<Vec<CallHierarchyItem>>> {\n     let _p = profile(\"handle_call_hierarchy_prepare\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n \n-    let nav_info = match world.analysis().call_hierarchy(position)? {\n+    let nav_info = match snap.analysis().call_hierarchy(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -1035,24 +1001,24 @@ pub fn handle_call_hierarchy_prepare(\n     let res = navs\n         .into_iter()\n         .filter(|it| it.kind() == SyntaxKind::FN_DEF)\n-        .map(|it| to_proto::call_hierarchy_item(&world, it))\n+        .map(|it| to_proto::call_hierarchy_item(&snap, it))\n         .collect::<Result<Vec<_>>>()?;\n \n     Ok(Some(res))\n }\n \n pub fn handle_call_hierarchy_incoming(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: CallHierarchyIncomingCallsParams,\n ) -> Result<Option<Vec<CallHierarchyIncomingCall>>> {\n     let _p = profile(\"handle_call_hierarchy_incoming\");\n     let item = params.item;\n \n     let doc = TextDocumentIdentifier::new(item.uri);\n-    let frange = from_proto::file_range(&world, doc, item.range)?;\n+    let frange = from_proto::file_range(&snap, doc, item.range)?;\n     let fpos = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n \n-    let call_items = match world.analysis().incoming_calls(fpos)? {\n+    let call_items = match snap.analysis().incoming_calls(fpos)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -1061,8 +1027,8 @@ pub fn handle_call_hierarchy_incoming(\n \n     for call_item in call_items.into_iter() {\n         let file_id = call_item.target.file_id();\n-        let line_index = world.analysis().file_line_index(file_id)?;\n-        let item = to_proto::call_hierarchy_item(&world, call_item.target)?;\n+        let line_index = snap.analysis().file_line_index(file_id)?;\n+        let item = to_proto::call_hierarchy_item(&snap, call_item.target)?;\n         res.push(CallHierarchyIncomingCall {\n             from: item,\n             from_ranges: call_item\n@@ -1077,17 +1043,17 @@ pub fn handle_call_hierarchy_incoming(\n }\n \n pub fn handle_call_hierarchy_outgoing(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: CallHierarchyOutgoingCallsParams,\n ) -> Result<Option<Vec<CallHierarchyOutgoingCall>>> {\n     let _p = profile(\"handle_call_hierarchy_outgoing\");\n     let item = params.item;\n \n     let doc = TextDocumentIdentifier::new(item.uri);\n-    let frange = from_proto::file_range(&world, doc, item.range)?;\n+    let frange = from_proto::file_range(&snap, doc, item.range)?;\n     let fpos = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n \n-    let call_items = match world.analysis().outgoing_calls(fpos)? {\n+    let call_items = match snap.analysis().outgoing_calls(fpos)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -1096,8 +1062,8 @@ pub fn handle_call_hierarchy_outgoing(\n \n     for call_item in call_items.into_iter() {\n         let file_id = call_item.target.file_id();\n-        let line_index = world.analysis().file_line_index(file_id)?;\n-        let item = to_proto::call_hierarchy_item(&world, call_item.target)?;\n+        let line_index = snap.analysis().file_line_index(file_id)?;\n+        let item = to_proto::call_hierarchy_item(&snap, call_item.target)?;\n         res.push(CallHierarchyOutgoingCall {\n             to: item,\n             from_ranges: call_item\n@@ -1112,31 +1078,31 @@ pub fn handle_call_hierarchy_outgoing(\n }\n \n pub fn handle_semantic_tokens(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: SemanticTokensParams,\n ) -> Result<Option<SemanticTokensResult>> {\n     let _p = profile(\"handle_semantic_tokens\");\n \n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let text = world.analysis().file_text(file_id)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let text = snap.analysis().file_text(file_id)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n \n-    let highlights = world.analysis().highlight(file_id)?;\n+    let highlights = snap.analysis().highlight(file_id)?;\n     let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n     Ok(Some(semantic_tokens.into()))\n }\n \n pub fn handle_semantic_tokens_range(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: SemanticTokensRangeParams,\n ) -> Result<Option<SemanticTokensRangeResult>> {\n     let _p = profile(\"handle_semantic_tokens_range\");\n \n-    let frange = from_proto::file_range(&world, params.text_document, params.range)?;\n-    let text = world.analysis().file_text(frange.file_id)?;\n-    let line_index = world.analysis().file_line_index(frange.file_id)?;\n+    let frange = from_proto::file_range(&snap, params.text_document, params.range)?;\n+    let text = snap.analysis().file_text(frange.file_id)?;\n+    let line_index = snap.analysis().file_line_index(frange.file_id)?;\n \n-    let highlights = world.analysis().highlight_range(frange)?;\n+    let highlights = snap.analysis().highlight_range(frange)?;\n     let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n     Ok(Some(semantic_tokens.into()))\n }"}, {"sha": "6f125c37cb99672081a5ffe3c100d45f7adf2694", "filename": "crates/rust-analyzer/src/semantic_tokens.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -36,9 +36,11 @@ macro_rules! define_semantic_token_types {\n \n define_semantic_token_types![\n     (ATTRIBUTE, \"attribute\"),\n+    (BOOLEAN, \"boolean\"),\n     (BUILTIN_TYPE, \"builtinType\"),\n     (ENUM_MEMBER, \"enumMember\"),\n     (LIFETIME, \"lifetime\"),\n+    (SELF_KEYWORD, \"selfKeyword\"),\n     (TYPE_ALIAS, \"typeAlias\"),\n     (UNION, \"union\"),\n     (UNRESOLVED_REFERENCE, \"unresolvedReference\"),\n@@ -67,6 +69,7 @@ define_semantic_token_modifiers![\n     (CONTROL_FLOW, \"controlFlow\"),\n     (MUTABLE, \"mutable\"),\n     (UNSAFE, \"unsafe\"),\n+    (ATTRIBUTE_MODIFIER, \"attribute\"),\n ];\n \n #[derive(Default)]"}, {"sha": "0915a7fcb786c5bcc26d760f85032bd4c6f09c80", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 106, "deletions": 42, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -3,13 +3,16 @@ use ra_db::{FileId, FileRange};\n use ra_ide::{\n     Assist, CompletionItem, CompletionItemKind, Documentation, FileSystemEdit, Fold, FoldKind,\n     FunctionSignature, Highlight, HighlightModifier, HighlightTag, HighlightedRange, Indel,\n-    InlayHint, InlayKind, InsertTextFormat, LineIndex, NavigationTarget, ReferenceAccess, Severity,\n-    SourceChange, SourceFileEdit, TextEdit,\n+    InlayHint, InlayKind, InsertTextFormat, LineIndex, NavigationTarget, ReferenceAccess, Runnable,\n+    RunnableKind, Severity, SourceChange, SourceFileEdit, TextEdit,\n };\n use ra_syntax::{SyntaxKind, TextRange, TextSize};\n use ra_vfs::LineEndings;\n \n-use crate::{lsp_ext, semantic_tokens, world::WorldSnapshot, Result};\n+use crate::{\n+    cargo_target_spec::CargoTargetSpec, global_state::GlobalStateSnapshot, lsp_ext,\n+    semantic_tokens, Result,\n+};\n \n pub(crate) fn position(line_index: &LineIndex, offset: TextSize) -> lsp_types::Position {\n     let line_col = line_index.line_col(offset);\n@@ -135,6 +138,18 @@ pub(crate) fn text_edit_vec(\n     text_edit.into_iter().map(|indel| self::text_edit(line_index, line_endings, indel)).collect()\n }\n \n+pub(crate) fn snippet_text_edit_vec(\n+    line_index: &LineIndex,\n+    line_endings: LineEndings,\n+    is_snippet: bool,\n+    text_edit: TextEdit,\n+) -> Vec<lsp_ext::SnippetTextEdit> {\n+    text_edit\n+        .into_iter()\n+        .map(|indel| self::snippet_text_edit(line_index, line_endings, is_snippet, indel))\n+        .collect()\n+}\n+\n pub(crate) fn completion_item(\n     line_index: &LineIndex,\n     line_endings: LineEndings,\n@@ -274,6 +289,7 @@ fn semantic_token_type_and_modifiers(\n         HighlightTag::TypeAlias => semantic_tokens::TYPE_ALIAS,\n         HighlightTag::Trait => lsp_types::SemanticTokenType::INTERFACE,\n         HighlightTag::BuiltinType => semantic_tokens::BUILTIN_TYPE,\n+        HighlightTag::SelfKeyword => semantic_tokens::SELF_KEYWORD,\n         HighlightTag::SelfType => lsp_types::SemanticTokenType::TYPE,\n         HighlightTag::Field => lsp_types::SemanticTokenType::PROPERTY,\n         HighlightTag::Function => lsp_types::SemanticTokenType::FUNCTION,\n@@ -295,6 +311,7 @@ fn semantic_token_type_and_modifiers(\n         HighlightTag::ByteLiteral | HighlightTag::NumericLiteral => {\n             lsp_types::SemanticTokenType::NUMBER\n         }\n+        HighlightTag::BoolLiteral => semantic_tokens::BOOLEAN,\n         HighlightTag::CharLiteral | HighlightTag::StringLiteral => {\n             lsp_types::SemanticTokenType::STRING\n         }\n@@ -303,10 +320,12 @@ fn semantic_token_type_and_modifiers(\n         HighlightTag::Keyword => lsp_types::SemanticTokenType::KEYWORD,\n         HighlightTag::UnresolvedReference => semantic_tokens::UNRESOLVED_REFERENCE,\n         HighlightTag::FormatSpecifier => semantic_tokens::FORMAT_SPECIFIER,\n+        HighlightTag::Operator => lsp_types::SemanticTokenType::OPERATOR,\n     };\n \n     for modifier in highlight.modifiers.iter() {\n         let modifier = match modifier {\n+            HighlightModifier::Attribute => semantic_tokens::ATTRIBUTE_MODIFIER,\n             HighlightModifier::Definition => lsp_types::SemanticTokenModifier::DECLARATION,\n             HighlightModifier::ControlFlow => semantic_tokens::CONTROL_FLOW,\n             HighlightModifier::Mutable => semantic_tokens::MUTABLE,\n@@ -366,36 +385,46 @@ pub(crate) fn folding_range(\n     }\n }\n \n-pub(crate) fn url(world: &WorldSnapshot, file_id: FileId) -> Result<lsp_types::Url> {\n-    world.file_id_to_uri(file_id)\n+pub(crate) fn url(snap: &GlobalStateSnapshot, file_id: FileId) -> Result<lsp_types::Url> {\n+    snap.file_id_to_uri(file_id)\n }\n \n pub(crate) fn versioned_text_document_identifier(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     file_id: FileId,\n     version: Option<i64>,\n ) -> Result<lsp_types::VersionedTextDocumentIdentifier> {\n-    let res = lsp_types::VersionedTextDocumentIdentifier { uri: url(world, file_id)?, version };\n+    let res = lsp_types::VersionedTextDocumentIdentifier { uri: url(snap, file_id)?, version };\n     Ok(res)\n }\n \n-pub(crate) fn location(world: &WorldSnapshot, frange: FileRange) -> Result<lsp_types::Location> {\n-    let url = url(world, frange.file_id)?;\n-    let line_index = world.analysis().file_line_index(frange.file_id)?;\n+pub(crate) fn location(\n+    snap: &GlobalStateSnapshot,\n+    frange: FileRange,\n+) -> Result<lsp_types::Location> {\n+    let url = url(snap, frange.file_id)?;\n+    let line_index = snap.analysis().file_line_index(frange.file_id)?;\n     let range = range(&line_index, frange.range);\n     let loc = lsp_types::Location::new(url, range);\n     Ok(loc)\n }\n \n pub(crate) fn location_link(\n-    world: &WorldSnapshot,\n-    src: FileRange,\n+    snap: &GlobalStateSnapshot,\n+    src: Option<FileRange>,\n     target: NavigationTarget,\n ) -> Result<lsp_types::LocationLink> {\n-    let src_location = location(world, src)?;\n-    let (target_uri, target_range, target_selection_range) = location_info(world, target)?;\n+    let origin_selection_range = match src {\n+        Some(src) => {\n+            let line_index = snap.analysis().file_line_index(src.file_id)?;\n+            let range = range(&line_index, src.range);\n+            Some(range)\n+        }\n+        None => None,\n+    };\n+    let (target_uri, target_range, target_selection_range) = location_info(snap, target)?;\n     let res = lsp_types::LocationLink {\n-        origin_selection_range: Some(src_location.range),\n+        origin_selection_range,\n         target_uri,\n         target_range,\n         target_selection_range,\n@@ -404,35 +433,35 @@ pub(crate) fn location_link(\n }\n \n fn location_info(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     target: NavigationTarget,\n ) -> Result<(lsp_types::Url, lsp_types::Range, lsp_types::Range)> {\n-    let line_index = world.analysis().file_line_index(target.file_id())?;\n+    let line_index = snap.analysis().file_line_index(target.file_id())?;\n \n-    let target_uri = url(world, target.file_id())?;\n+    let target_uri = url(snap, target.file_id())?;\n     let target_range = range(&line_index, target.full_range());\n     let target_selection_range =\n         target.focus_range().map(|it| range(&line_index, it)).unwrap_or(target_range);\n     Ok((target_uri, target_range, target_selection_range))\n }\n \n pub(crate) fn goto_definition_response(\n-    world: &WorldSnapshot,\n-    src: FileRange,\n+    snap: &GlobalStateSnapshot,\n+    src: Option<FileRange>,\n     targets: Vec<NavigationTarget>,\n ) -> Result<lsp_types::GotoDefinitionResponse> {\n-    if world.config.client_caps.location_link {\n+    if snap.config.client_caps.location_link {\n         let links = targets\n             .into_iter()\n-            .map(|nav| location_link(world, src, nav))\n+            .map(|nav| location_link(snap, src, nav))\n             .collect::<Result<Vec<_>>>()?;\n         Ok(links.into())\n     } else {\n         let locations = targets\n             .into_iter()\n             .map(|nav| {\n                 location(\n-                    world,\n+                    snap,\n                     FileRange {\n                         file_id: nav.file_id(),\n                         range: nav.focus_range().unwrap_or(nav.range()),\n@@ -445,50 +474,50 @@ pub(crate) fn goto_definition_response(\n }\n \n pub(crate) fn snippet_text_document_edit(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     is_snippet: bool,\n     source_file_edit: SourceFileEdit,\n ) -> Result<lsp_ext::SnippetTextDocumentEdit> {\n-    let text_document = versioned_text_document_identifier(world, source_file_edit.file_id, None)?;\n-    let line_index = world.analysis().file_line_index(source_file_edit.file_id)?;\n-    let line_endings = world.file_line_endings(source_file_edit.file_id);\n+    let text_document = versioned_text_document_identifier(snap, source_file_edit.file_id, None)?;\n+    let line_index = snap.analysis().file_line_index(source_file_edit.file_id)?;\n+    let line_endings = snap.file_line_endings(source_file_edit.file_id);\n     let edits = source_file_edit\n         .edit\n         .into_iter()\n-        .map(|it| snippet_text_edit(&line_index, line_endings, is_snippet, it.clone()))\n+        .map(|it| snippet_text_edit(&line_index, line_endings, is_snippet, it))\n         .collect();\n     Ok(lsp_ext::SnippetTextDocumentEdit { text_document, edits })\n }\n \n pub(crate) fn resource_op(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     file_system_edit: FileSystemEdit,\n ) -> Result<lsp_types::ResourceOp> {\n     let res = match file_system_edit {\n         FileSystemEdit::CreateFile { source_root, path } => {\n-            let uri = world.path_to_uri(source_root, &path)?;\n+            let uri = snap.path_to_uri(source_root, &path)?;\n             lsp_types::ResourceOp::Create(lsp_types::CreateFile { uri, options: None })\n         }\n         FileSystemEdit::MoveFile { src, dst_source_root, dst_path } => {\n-            let old_uri = world.file_id_to_uri(src)?;\n-            let new_uri = world.path_to_uri(dst_source_root, &dst_path)?;\n+            let old_uri = snap.file_id_to_uri(src)?;\n+            let new_uri = snap.path_to_uri(dst_source_root, &dst_path)?;\n             lsp_types::ResourceOp::Rename(lsp_types::RenameFile { old_uri, new_uri, options: None })\n         }\n     };\n     Ok(res)\n }\n \n pub(crate) fn snippet_workspace_edit(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     source_change: SourceChange,\n ) -> Result<lsp_ext::SnippetWorkspaceEdit> {\n     let mut document_changes: Vec<lsp_ext::SnippetDocumentChangeOperation> = Vec::new();\n     for op in source_change.file_system_edits {\n-        let op = resource_op(&world, op)?;\n+        let op = resource_op(&snap, op)?;\n         document_changes.push(lsp_ext::SnippetDocumentChangeOperation::Op(op));\n     }\n     for edit in source_change.source_file_edits {\n-        let edit = snippet_text_document_edit(&world, source_change.is_snippet, edit)?;\n+        let edit = snippet_text_document_edit(&snap, source_change.is_snippet, edit)?;\n         document_changes.push(lsp_ext::SnippetDocumentChangeOperation::Edit(edit));\n     }\n     let workspace_edit =\n@@ -497,11 +526,11 @@ pub(crate) fn snippet_workspace_edit(\n }\n \n pub(crate) fn workspace_edit(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     source_change: SourceChange,\n ) -> Result<lsp_types::WorkspaceEdit> {\n     assert!(!source_change.is_snippet);\n-    snippet_workspace_edit(world, source_change).map(|it| it.into())\n+    snippet_workspace_edit(snap, source_change).map(|it| it.into())\n }\n \n impl From<lsp_ext::SnippetWorkspaceEdit> for lsp_types::WorkspaceEdit {\n@@ -540,13 +569,13 @@ impl From<lsp_ext::SnippetWorkspaceEdit> for lsp_types::WorkspaceEdit {\n }\n \n pub fn call_hierarchy_item(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     target: NavigationTarget,\n ) -> Result<lsp_types::CallHierarchyItem> {\n     let name = target.name().to_string();\n     let detail = target.description().map(|it| it.to_string());\n     let kind = symbol_kind(target.kind());\n-    let (uri, range, selection_range) = location_info(world, target)?;\n+    let (uri, range, selection_range) = location_info(snap, target)?;\n     Ok(lsp_types::CallHierarchyItem { name, kind, tags: None, detail, uri, range, selection_range })\n }\n \n@@ -594,13 +623,48 @@ fn main() <fold>{\n     }\n }\n \n-pub(crate) fn code_action(world: &WorldSnapshot, assist: Assist) -> Result<lsp_ext::CodeAction> {\n+pub(crate) fn code_action(\n+    snap: &GlobalStateSnapshot,\n+    assist: Assist,\n+) -> Result<lsp_ext::CodeAction> {\n     let res = lsp_ext::CodeAction {\n         title: assist.label,\n-        group: if world.config.client_caps.code_action_group { assist.group_label } else { None },\n+        group: if snap.config.client_caps.code_action_group { assist.group_label } else { None },\n         kind: Some(String::new()),\n-        edit: Some(snippet_workspace_edit(world, assist.source_change)?),\n+        edit: Some(snippet_workspace_edit(snap, assist.source_change)?),\n         command: None,\n     };\n     Ok(res)\n }\n+\n+pub(crate) fn runnable(\n+    snap: &GlobalStateSnapshot,\n+    file_id: FileId,\n+    runnable: Runnable,\n+) -> Result<lsp_ext::Runnable> {\n+    let spec = CargoTargetSpec::for_file(snap, file_id)?;\n+    let target = spec.as_ref().map(|s| s.target.clone());\n+    let (cargo_args, executable_args) =\n+        CargoTargetSpec::runnable_args(spec, &runnable.kind, &runnable.cfg_exprs)?;\n+    let label = match &runnable.kind {\n+        RunnableKind::Test { test_id, .. } => format!(\"test {}\", test_id),\n+        RunnableKind::TestMod { path } => format!(\"test-mod {}\", path),\n+        RunnableKind::Bench { test_id } => format!(\"bench {}\", test_id),\n+        RunnableKind::DocTest { test_id, .. } => format!(\"doctest {}\", test_id),\n+        RunnableKind::Bin => {\n+            target.map_or_else(|| \"run binary\".to_string(), |t| format!(\"run {}\", t))\n+        }\n+    };\n+    let location = location_link(snap, None, runnable.nav)?;\n+\n+    Ok(lsp_ext::Runnable {\n+        label,\n+        location: Some(location),\n+        kind: lsp_ext::RunnableKind::Cargo,\n+        args: lsp_ext::CargoRunnable {\n+            workspace_root: snap.workspace_root_for(file_id).map(|root| root.to_owned()),\n+            cargo_args,\n+            executable_args,\n+        },\n+    })\n+}"}, {"sha": "ad347631054b7f8ae6c1f4dd3ec0d7570c0970ab", "filename": "crates/rust-analyzer/tests/heavy_tests/main.rs", "status": "modified", "additions": 51, "deletions": 112, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -58,52 +58,6 @@ use std::collections::Spam;\n     eprintln!(\"completion took {:?}\", completion_start.elapsed());\n }\n \n-#[test]\n-fn test_runnables_no_project() {\n-    if skip_slow_tests() {\n-        return;\n-    }\n-\n-    let server = project(\n-        r\"\n-//- lib.rs\n-#[test]\n-fn foo() {\n-}\n-\",\n-    );\n-    server.wait_until_workspace_is_loaded();\n-    server.request::<Runnables>(\n-        RunnablesParams { text_document: server.doc_id(\"lib.rs\"), position: None },\n-        json!([\n-          {\n-            \"args\": [ \"test\" ],\n-            \"extraArgs\": [ \"foo\", \"--nocapture\" ],\n-            \"bin\": \"cargo\",\n-            \"env\": { \"RUST_BACKTRACE\": \"short\" },\n-            \"cwd\": null,\n-            \"label\": \"test foo\",\n-            \"range\": {\n-              \"end\": { \"character\": 1, \"line\": 2 },\n-              \"start\": { \"character\": 0, \"line\": 0 }\n-            }\n-          },\n-          {\n-            \"args\": [\"check\", \"--workspace\"],\n-            \"extraArgs\": [],\n-            \"bin\": \"cargo\",\n-            \"env\": {},\n-            \"cwd\": null,\n-            \"label\": \"cargo check --workspace\",\n-            \"range\": {\n-              \"end\": { \"character\": 0, \"line\": 0 },\n-              \"start\": { \"character\": 0, \"line\": 0 }\n-            }\n-          }\n-        ]),\n-    );\n-}\n-\n #[test]\n fn test_runnables_project() {\n     if skip_slow_tests() {\n@@ -138,42 +92,44 @@ fn main() {}\n     server.request::<Runnables>(\n         RunnablesParams { text_document: server.doc_id(\"foo/tests/spam.rs\"), position: None },\n         json!([\n-            {\n-              \"args\": [ \"test\", \"--package\", \"foo\", \"--test\", \"spam\" ],\n-              \"extraArgs\": [ \"test_eggs\", \"--exact\", \"--nocapture\" ],\n-              \"bin\": \"cargo\",\n-              \"env\": { \"RUST_BACKTRACE\": \"short\" },\n-              \"label\": \"test test_eggs\",\n-              \"range\": {\n-                \"end\": { \"character\": 17, \"line\": 1 },\n-                \"start\": { \"character\": 0, \"line\": 0 }\n-              },\n-              \"cwd\": server.path().join(\"foo\")\n+          {\n+            \"args\": {\n+              \"cargoArgs\": [\"test\", \"--package\", \"foo\", \"--test\", \"spam\"],\n+              \"executableArgs\": [\"test_eggs\", \"--exact\", \"--nocapture\"],\n+              \"workspaceRoot\": server.path().join(\"foo\")\n             },\n-            {\n-              \"args\": [ \"check\", \"--package\", \"foo\" ],\n-              \"extraArgs\": [],\n-              \"bin\": \"cargo\",\n-              \"env\": {},\n-              \"label\": \"cargo check -p foo\",\n-              \"range\": {\n-                \"end\": { \"character\": 0, \"line\": 0 },\n+            \"kind\": \"cargo\",\n+            \"label\": \"test test_eggs\",\n+            \"location\": {\n+              \"targetRange\": {\n+                \"end\": { \"character\": 17, \"line\": 1 },\n                 \"start\": { \"character\": 0, \"line\": 0 }\n               },\n-              \"cwd\": server.path().join(\"foo\")\n-            },\n-            {\n-              \"args\": [ \"test\", \"--package\", \"foo\" ],\n-              \"extraArgs\": [],\n-              \"bin\": \"cargo\",\n-              \"env\": {},\n-              \"label\": \"cargo test -p foo\",\n-              \"range\": {\n-                \"end\": { \"character\": 0, \"line\": 0 },\n-                \"start\": { \"character\": 0, \"line\": 0 }\n+              \"targetSelectionRange\": {\n+                \"end\": { \"character\": 12, \"line\": 1 },\n+                \"start\": { \"character\": 3, \"line\": 1 }\n               },\n-              \"cwd\": server.path().join(\"foo\")\n+              \"targetUri\": \"file:///[..]/tests/spam.rs\"\n             }\n+          },\n+          {\n+            \"args\": {\n+              \"cargoArgs\": [\"check\", \"--package\", \"foo\"],\n+              \"executableArgs\": [],\n+              \"workspaceRoot\": server.path().join(\"foo\")\n+            },\n+            \"kind\": \"cargo\",\n+            \"label\": \"cargo check -p foo\"\n+          },\n+          {\n+            \"args\": {\n+              \"cargoArgs\": [\"test\", \"--package\", \"foo\"],\n+              \"executableArgs\": [],\n+              \"workspaceRoot\": server.path().join(\"foo\")\n+            },\n+            \"kind\": \"cargo\",\n+            \"label\": \"cargo test -p foo\"\n+          }\n         ]),\n     );\n }\n@@ -342,6 +298,7 @@ fn main() {}\n                 }\n               ]\n             },\n+            \"kind\": \"quickfix\",\n             \"title\": \"Create module\"\n         }]),\n     );\n@@ -374,8 +331,7 @@ fn test_missing_module_code_action_in_json_project() {\n             \"root_module\": path.join(\"src/lib.rs\"),\n             \"deps\": [],\n             \"edition\": \"2015\",\n-            \"atom_cfgs\": [],\n-            \"key_value_cfgs\": {}\n+            \"cfg\": [ \"cfg_atom_1\", \"feature=cfg_1\"],\n         } ]\n     });\n \n@@ -413,6 +369,7 @@ fn main() {{}}\n                 }\n               ]\n             },\n+            \"kind\": \"quickfix\",\n             \"title\": \"Create module\"\n         }]),\n     );\n@@ -473,23 +430,14 @@ fn main() {{}}\n             text_document: server.doc_id(\"src/m0.rs\"),\n             position: Position { line: 0, character: 5 },\n         },\n-        json!({\n-          \"documentChanges\": [\n-            {\n-              \"edits\": [\n-                {\n-                  \"insertTextFormat\": 2,\n-                  \"newText\": \"\\n/// $0\",\n-                  \"range\": {\n-                    \"end\": { \"character\": 5, \"line\": 0 },\n-                    \"start\": { \"character\": 5, \"line\": 0 }\n-                  }\n-                }\n-              ],\n-              \"textDocument\": { \"uri\": \"file:///[..]src/m0.rs\", \"version\": null }\n+        json!([{\n+            \"insertTextFormat\": 2,\n+            \"newText\": \"\\n/// $0\",\n+            \"range\": {\n+            \"end\": { \"character\": 5, \"line\": 0 },\n+            \"start\": { \"character\": 5, \"line\": 0 }\n             }\n-          ]\n-        }),\n+        }]),\n     );\n     let elapsed = start.elapsed();\n     assert!(elapsed.as_millis() < 2000, \"typing enter took {:?}\", elapsed);\n@@ -519,23 +467,14 @@ version = \\\"0.0.0\\\"\n             text_document: server.doc_id(\"src/main.rs\"),\n             position: Position { line: 0, character: 8 },\n         },\n-        json!({\n-          \"documentChanges\": [\n-            {\n-              \"edits\": [\n-                {\n-                  \"insertTextFormat\": 2,\n-                  \"newText\": \"\\r\\n/// $0\",\n-                  \"range\": {\n-                    \"end\": { \"line\": 0, \"character\": 8 },\n-                    \"start\": { \"line\": 0, \"character\": 8 }\n-                  }\n-                }\n-              ],\n-              \"textDocument\": { \"uri\": \"file:///[..]src/main.rs\", \"version\": null }\n+        json!([{\n+            \"insertTextFormat\": 2,\n+            \"newText\": \"\\r\\n/// $0\",\n+            \"range\": {\n+            \"end\": { \"line\": 0, \"character\": 8 },\n+            \"start\": { \"line\": 0, \"character\": 8 }\n             }\n-          ]\n-        }),\n+        }]),\n     );\n }\n \n@@ -774,5 +713,5 @@ pub fn foo(_input: TokenStream) -> TokenStream {\n     });\n \n     let value = res.get(\"contents\").unwrap().get(\"value\").unwrap().to_string();\n-    assert_eq!(value, r#\"\"```rust\\nfoo::Bar\\nfn bar()\\n```\"\"#)\n+    assert_eq!(value, r#\"\"```rust\\nfoo::Bar\\n```\\n\\n```rust\\nfn bar()\\n```\"\"#)\n }"}, {"sha": "30d03b622b91f13c28091efb4faa5d487cfeb345", "filename": "crates/rust-analyzer/tests/heavy_tests/support.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -19,8 +19,9 @@ use serde_json::{to_string_pretty, Value};\n use tempfile::TempDir;\n use test_utils::{find_mismatch, parse_fixture};\n \n+use ra_project_model::ProjectManifest;\n use rust_analyzer::{\n-    config::{ClientCapsConfig, Config},\n+    config::{ClientCapsConfig, Config, LinkedProject},\n     main_loop,\n };\n \n@@ -42,7 +43,7 @@ impl<'a> Project<'a> {\n         self\n     }\n \n-    pub fn root(mut self, path: &str) -> Project<'a> {\n+    pub(crate) fn root(mut self, path: &str) -> Project<'a> {\n         self.roots.push(path.into());\n         self\n     }\n@@ -68,13 +69,22 @@ impl<'a> Project<'a> {\n         let mut paths = vec![];\n \n         for entry in parse_fixture(self.fixture) {\n-            let path = tmp_dir.path().join(entry.meta);\n+            let path = tmp_dir.path().join(entry.meta.path().as_str());\n             fs::create_dir_all(path.parent().unwrap()).unwrap();\n             fs::write(path.as_path(), entry.text.as_bytes()).unwrap();\n             paths.push((path, entry.text));\n         }\n \n-        let roots = self.roots.into_iter().map(|root| tmp_dir.path().join(root)).collect();\n+        let mut roots =\n+            self.roots.into_iter().map(|root| tmp_dir.path().join(root)).collect::<Vec<_>>();\n+        if roots.is_empty() {\n+            roots.push(tmp_dir.path().to_path_buf());\n+        }\n+        let linked_projects = roots\n+            .into_iter()\n+            .map(|it| ProjectManifest::discover_single(&it).unwrap())\n+            .map(LinkedProject::from)\n+            .collect::<Vec<_>>();\n \n         let mut config = Config {\n             client_caps: ClientCapsConfig {\n@@ -84,14 +94,15 @@ impl<'a> Project<'a> {\n                 ..Default::default()\n             },\n             with_sysroot: self.with_sysroot,\n+            linked_projects,\n             ..Config::default()\n         };\n \n         if let Some(f) = &self.config {\n             f(&mut config)\n         }\n \n-        Server::new(tmp_dir, config, roots, paths)\n+        Server::new(tmp_dir, config, paths)\n     }\n }\n \n@@ -109,20 +120,12 @@ pub struct Server {\n }\n \n impl Server {\n-    fn new(\n-        dir: TempDir,\n-        config: Config,\n-        roots: Vec<PathBuf>,\n-        files: Vec<(PathBuf, String)>,\n-    ) -> Server {\n-        let path = dir.path().to_path_buf();\n-\n-        let roots = if roots.is_empty() { vec![path] } else { roots };\n+    fn new(dir: TempDir, config: Config, files: Vec<(PathBuf, String)>) -> Server {\n         let (connection, client) = Connection::memory();\n \n         let _thread = jod_thread::Builder::new()\n             .name(\"test server\".to_string())\n-            .spawn(move || main_loop(roots, config, connection).unwrap())\n+            .spawn(move || main_loop(config, connection).unwrap())\n             .expect(\"failed to spawn a thread\");\n \n         let res ="}, {"sha": "c0356344ca24e94f75a75d1fb08f225241f7a261", "filename": "crates/stdx/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Flib.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -124,3 +124,8 @@ pub fn replace(buf: &mut String, from: char, to: &str) {\n     // FIXME: do this in place.\n     *buf = buf.replace(from, to)\n }\n+\n+pub fn split1(haystack: &str, delim: char) -> Option<(&str, &str)> {\n+    let idx = haystack.find(delim)?;\n+    Some((&haystack[..idx], &haystack[idx + delim.len_utf8()..]))\n+}"}, {"sha": "8840bf36ae325c79b39eaccaaa2ebdd56fa709d2", "filename": "crates/test_utils/Cargo.toml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Ftest_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Ftest_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2FCargo.toml?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -11,3 +11,8 @@ doctest = false\n difference = \"2.0.0\"\n text-size = \"1.0.0\"\n serde_json = \"1.0.48\"\n+relative-path = \"1.0.0\"\n+rustc-hash = \"1.1.0\"\n+\n+ra_cfg = { path = \"../ra_cfg\" }\n+stdx = { path = \"../stdx\" }\n\\ No newline at end of file"}, {"sha": "2141bfc202779a705eb7da0f378b2a94b61896d8", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 150, "deletions": 6, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -14,6 +14,11 @@ use std::{\n     path::{Path, PathBuf},\n };\n \n+pub use ra_cfg::CfgOptions;\n+use stdx::split1;\n+\n+pub use relative_path::{RelativePath, RelativePathBuf};\n+pub use rustc_hash::FxHashMap;\n use serde_json::Value;\n use text_size::{TextRange, TextSize};\n \n@@ -157,10 +162,82 @@ pub fn add_cursor(text: &str, offset: TextSize) -> String {\n \n #[derive(Debug, Eq, PartialEq)]\n pub struct FixtureEntry {\n-    pub meta: String,\n+    pub meta: FixtureMeta,\n     pub text: String,\n }\n \n+#[derive(Debug, Eq, PartialEq)]\n+pub enum FixtureMeta {\n+    Root { path: RelativePathBuf },\n+    File(FileMeta),\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct FileMeta {\n+    pub path: RelativePathBuf,\n+    pub crate_name: Option<String>,\n+    pub deps: Vec<String>,\n+    pub cfg: CfgOptions,\n+    pub edition: Option<String>,\n+    pub env: FxHashMap<String, String>,\n+}\n+\n+impl FixtureMeta {\n+    pub fn path(&self) -> &RelativePath {\n+        match self {\n+            FixtureMeta::Root { path } => &path,\n+            FixtureMeta::File(f) => &f.path,\n+        }\n+    }\n+\n+    pub fn crate_name(&self) -> Option<&String> {\n+        match self {\n+            FixtureMeta::File(f) => f.crate_name.as_ref(),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn cfg_options(&self) -> Option<&CfgOptions> {\n+        match self {\n+            FixtureMeta::File(f) => Some(&f.cfg),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn edition(&self) -> Option<&String> {\n+        match self {\n+            FixtureMeta::File(f) => f.edition.as_ref(),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn env(&self) -> impl Iterator<Item = (&String, &String)> {\n+        struct EnvIter<'a> {\n+            iter: Option<std::collections::hash_map::Iter<'a, String, String>>,\n+        }\n+\n+        impl<'a> EnvIter<'a> {\n+            fn new(meta: &'a FixtureMeta) -> Self {\n+                Self {\n+                    iter: match meta {\n+                        FixtureMeta::File(f) => Some(f.env.iter()),\n+                        _ => None,\n+                    },\n+                }\n+            }\n+        }\n+\n+        impl<'a> Iterator for EnvIter<'a> {\n+            type Item = (&'a String, &'a String);\n+            fn next(&mut self) -> Option<Self::Item> {\n+                self.iter.as_mut().and_then(|i| i.next())\n+            }\n+        }\n+\n+        EnvIter::new(self)\n+    }\n+}\n+\n /// Parses text which looks like this:\n ///\n ///  ```not_rust\n@@ -169,8 +246,8 @@ pub struct FixtureEntry {\n ///  line 2\n ///  // - other meta\n ///  ```\n-pub fn parse_fixture(fixture: &str) -> Vec<FixtureEntry> {\n-    let fixture = indent_first_line(fixture);\n+pub fn parse_fixture(ra_fixture: &str) -> Vec<FixtureEntry> {\n+    let fixture = indent_first_line(ra_fixture);\n     let margin = fixture_margin(&fixture);\n \n     let mut lines = fixture\n@@ -200,6 +277,7 @@ The offending line: {:?}\"#,\n     for line in lines.by_ref() {\n         if line.starts_with(\"//-\") {\n             let meta = line[\"//-\".len()..].trim().to_string();\n+            let meta = parse_meta(&meta);\n             res.push(FixtureEntry { meta, text: String::new() })\n         } else if let Some(entry) = res.last_mut() {\n             entry.text.push_str(line);\n@@ -209,6 +287,52 @@ The offending line: {:?}\"#,\n     res\n }\n \n+//- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b env:OUTDIR=path/to,OTHER=foo\n+fn parse_meta(meta: &str) -> FixtureMeta {\n+    let components = meta.split_ascii_whitespace().collect::<Vec<_>>();\n+\n+    if components[0] == \"root\" {\n+        let path: RelativePathBuf = components[1].into();\n+        assert!(path.starts_with(\"/\") && path.ends_with(\"/\"));\n+        return FixtureMeta::Root { path };\n+    }\n+\n+    let path: RelativePathBuf = components[0].into();\n+    assert!(path.starts_with(\"/\"));\n+\n+    let mut krate = None;\n+    let mut deps = Vec::new();\n+    let mut edition = None;\n+    let mut cfg = CfgOptions::default();\n+    let mut env = FxHashMap::default();\n+    for component in components[1..].iter() {\n+        let (key, value) = split1(component, ':').unwrap();\n+        match key {\n+            \"crate\" => krate = Some(value.to_string()),\n+            \"deps\" => deps = value.split(',').map(|it| it.to_string()).collect(),\n+            \"edition\" => edition = Some(value.to_string()),\n+            \"cfg\" => {\n+                for key in value.split(',') {\n+                    match split1(key, '=') {\n+                        None => cfg.insert_atom(key.into()),\n+                        Some((k, v)) => cfg.insert_key_value(k.into(), v.into()),\n+                    }\n+                }\n+            }\n+            \"env\" => {\n+                for key in value.split(',') {\n+                    if let Some((k, v)) = split1(key, '=') {\n+                        env.insert(k.into(), v.into());\n+                    }\n+                }\n+            }\n+            _ => panic!(\"bad component: {:?}\", component),\n+        }\n+    }\n+\n+    FixtureMeta::File(FileMeta { path, crate_name: krate, deps, edition, cfg, env })\n+}\n+\n /// Adjusts the indentation of the first line to the minimum indentation of the rest of the lines.\n /// This allows fixtures to start off in a different indentation, e.g. to align the first line with\n /// the other lines visually:\n@@ -288,13 +412,33 @@ struct Bar;\n     )\n }\n \n+#[test]\n+fn parse_fixture_gets_full_meta() {\n+    let parsed = parse_fixture(\n+        r\"\n+    //- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b,atom env:OUTDIR=path/to,OTHER=foo\n+    mod m;\n+    \",\n+    );\n+    assert_eq!(1, parsed.len());\n+\n+    let parsed = &parsed[0];\n+    assert_eq!(\"mod m;\\n\\n\", parsed.text);\n+\n+    let meta = &parsed.meta;\n+    assert_eq!(\"foo\", meta.crate_name().unwrap());\n+    assert_eq!(\"/lib.rs\", meta.path());\n+    assert!(meta.cfg_options().is_some());\n+    assert_eq!(2, meta.env().count());\n+}\n+\n /// Same as `parse_fixture`, except it allow empty fixture\n-pub fn parse_single_fixture(fixture: &str) -> Option<FixtureEntry> {\n-    if !fixture.lines().any(|it| it.trim_start().starts_with(\"//-\")) {\n+pub fn parse_single_fixture(ra_fixture: &str) -> Option<FixtureEntry> {\n+    if !ra_fixture.lines().any(|it| it.trim_start().starts_with(\"//-\")) {\n         return None;\n     }\n \n-    let fixtures = parse_fixture(fixture);\n+    let fixtures = parse_fixture(ra_fixture);\n     if fixtures.len() > 1 {\n         panic!(\"too many fixtures\");\n     }"}, {"sha": "1de5a2aab1d75d6c4c3d5158d842ed11271d9281", "filename": "docs/dev/README.md", "status": "modified", "additions": 104, "deletions": 1, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/docs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/docs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2FREADME.md?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -30,7 +30,7 @@ https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0\n \n * [good-first-issue](https://github.com/rust-analyzer/rust-analyzer/labels/good%20first%20issue)\n   are good issues to get into the project.\n-* [E-mentor](https://github.com/rust-analyzer/rust-analyzer/issues?q=is%3Aopen+is%3Aissue+label%3AE-mentor)\n+* [E-has-instructions](https://github.com/rust-analyzer/rust-analyzer/issues?q=is%3Aopen+is%3Aissue+label%3AE-has-instructions)\n   issues have links to the code in question and tests.\n * [E-easy](https://github.com/rust-analyzer/rust-analyzer/issues?q=is%3Aopen+is%3Aissue+label%3AE-easy),\n   [E-medium](https://github.com/rust-analyzer/rust-analyzer/issues?q=is%3Aopen+is%3Aissue+label%3AE-medium),\n@@ -117,6 +117,109 @@ Additionally, I use `cargo run --release -p rust-analyzer -- analysis-stats\n path/to/some/rust/crate` to run a batch analysis. This is primarily useful for\n performance optimizations, or for bug minimization.\n \n+# Code Style & Review Process\n+\n+Our approach to \"clean code\" is two fold:\n+\n+* We generally don't block PRs on style changes.\n+* At the same time, all code in rust-analyzer is constantly refactored.\n+\n+It is explicitly OK for reviewer to flag only some nits in the PR, and than send a follow up cleanup PR for things which are easier to explain by example, cc-ing the original author.\n+Sending small cleanup PRs (like rename a single local variable) is encouraged.\n+\n+## Scale of Changes\n+\n+Everyone knows that it's better to send small & focused pull requests.\n+The problem is, sometimes you *have* to, eg, rewrite the whole compiler, and that just doesn't fit into a set of isolated PRs.\n+\n+The main thing too keep an eye on is the boundaries between various components.\n+There are three kinds of changes:\n+\n+1. Internals of a single component are changed.\n+   Specifically, you don't change any `pub` items.\n+   A good example here would be an addition of a new assist.\n+\n+2. API of a component is expanded.\n+   Specifically, you add a new `pub` function which wasn't there before.\n+   A good example here would be expansion of assist API, for example, to implement lazy assists or assists groups.\n+\n+3. A new dependency between components is introduced.\n+   Specifically, you add a `pub use` reexport from another crate or you add a new line to `[dependencies]` section of `Cargo.toml`.\n+   A good example here would be adding reference search capability to the assists crates.\n+\n+For the first group, the change is generally merged as long as:\n+\n+* it works for the happy case,\n+* it has tests,\n+* it doesn't panic for unhappy case.\n+\n+For the second group, the change would be subjected to quite a bit of scrutiny and iteration.\n+The new API needs to be right (or at least easy to change later).\n+The actual implementation doesn't matter that much.\n+It's very important to minimize the amount of changed lines of code for changes of the second kind.\n+Often, you start doing change of the first kind, only to realise that you need to elevate to a change of the second kind.\n+In this case, we'll probably ask you to split API changes into a separate PR.\n+\n+Changes of the third group should be pretty rare, so we don't specify any specific process for them.\n+That said, adding an innocent-looking `pub use` is a very simple way to break encapsulation, keep an eye on it!\n+\n+Note: if you enjoyed this abstract hand-waving about boundaries, you might appreciate\n+https://www.tedinski.com/2018/02/06/system-boundaries.html\n+\n+## Order of Imports\n+\n+We separate import groups with blank lines\n+\n+```\n+mod x;\n+mod y;\n+\n+use std::{ ... }\n+\n+use crate_foo::{ ... }\n+use crate_bar::{ ... }\n+\n+use crate::{}\n+\n+use super::{} // but prefer `use crate::`\n+```\n+\n+## Order of Items\n+\n+Optimize for the reader who sees the file for the first time, and wants to get the general idea about what's going on.\n+People read things from top to bottom, so place most important things first.\n+\n+Specifically, if all items except one are private, always put the non-private item on top.\n+\n+Put `struct`s and `enum`s first, functions and impls last.\n+\n+Do\n+\n+```\n+// Good\n+struct Foo {\n+  bars: Vec<Bar>\n+}\n+\n+struct Bar;\n+```\n+\n+rather than\n+\n+```\n+// Not as good\n+struct Bar;\n+\n+struct Foo {\n+  bars: Vec<Bar>\n+}\n+```\n+\n+## Documentation\n+\n+For `.md` and `.adoc` files, prefer a sentence-per-line format, don't wrap lines.\n+If the line is too long, you want to split the sentence in two :-)\n+\n # Logging\n \n Logging is done by both rust-analyzer and VS Code, so it might be tricky to"}, {"sha": "647cf6107565c3e6d19829a28908a88e8d85a3b1", "filename": "docs/dev/lsp-extensions.md", "status": "modified", "additions": 307, "deletions": 34, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/docs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/docs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Flsp-extensions.md?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -3,7 +3,19 @@\n This document describes LSP extensions used by rust-analyzer.\n It's a best effort document, when in doubt, consult the source (and send a PR with clarification ;-) ).\n We aim to upstream all non Rust-specific extensions to the protocol, but this is not a top priority.\n-All capabilities are enabled via `experimental` field of `ClientCapabilities`.\n+All capabilities are enabled via `experimental` field of `ClientCapabilities` or `ServerCapabilities`.\n+Requests which we hope to upstream live under `experimental/` namespace.\n+Requests, which are likely to always remain specific to `rust-analyzer` are under `rust-analyzer/` namespace.\n+\n+If you want to be notified about the changes to this document, subscribe to [#4604](https://github.com/rust-analyzer/rust-analyzer/issues/4604).\n+\n+## `initializationOptions`\n+\n+As `initializationOptions`, `rust-analyzer` expects `\"rust-analyzer\"` section of the configuration.\n+That is, `rust-analyzer` usually sends `\"workspace/configuration\"` request with `{ \"items\": [\"rust-analyzer\"] }` payload.\n+`initializationOptions` should contain the same data that would be in the first item of the result.\n+It's OK to not send anything, then all the settings would take their default values.\n+However, some settings can not be changed after startup at the moment.\n \n ## Snippet `TextEdit`\n \n@@ -38,6 +50,87 @@ At the moment, rust-analyzer guarantees that only a single edit will have `Inser\n * Where exactly are `SnippetTextEdit`s allowed (only in code actions at the moment)?\n * Can snippets span multiple files (so far, no)?\n \n+## `CodeAction` Groups\n+\n+**Issue:** https://github.com/microsoft/language-server-protocol/issues/994\n+\n+**Client Capability:** `{ \"codeActionGroup\": boolean }`\n+\n+If this capability is set, `CodeAction` returned from the server contain an additional field, `group`:\n+\n+```typescript\n+interface CodeAction {\n+    title: string;\n+    group?: string;\n+    ...\n+}\n+```\n+\n+All code-actions with the same `group` should be grouped under single (extendable) entry in lightbulb menu.\n+The set of actions `[ { title: \"foo\" }, { group: \"frobnicate\", title: \"bar\" }, { group: \"frobnicate\", title: \"baz\" }]` should be rendered as\n+\n+```\n+\ud83d\udca1\n+  +-------------+\n+  | foo         |\n+  +-------------+-----+\n+  | frobnicate >| bar |\n+  +-------------+-----+\n+                | baz |\n+                +-----+\n+```\n+\n+Alternatively, selecting `frobnicate` could present a user with an additional menu to choose between `bar` and `baz`.\n+\n+### Example\n+\n+```rust\n+fn main() {\n+    let x: Entry/*cursor here*/ = todo!();\n+}\n+```\n+\n+Invoking code action at this position will yield two code actions for importing `Entry` from either `collections::HashMap` or `collection::BTreeMap`, grouped under a single \"import\" group.\n+\n+### Unresolved Questions\n+\n+* Is a fixed two-level structure enough?\n+* Should we devise a general way to encode custom interaction protocols for GUI refactorings?\n+\n+## Parent Module\n+\n+**Issue:** https://github.com/microsoft/language-server-protocol/issues/1002\n+\n+**Server Capability:** `{ \"parentModule\": boolean }`\n+\n+This request is send from client to server to handle \"Goto Parent Module\" editor action.\n+\n+**Method:** `experimental/parentModule`\n+\n+**Request:** `TextDocumentPositionParams`\n+\n+**Response:** `Location | Location[] | LocationLink[] | null`\n+\n+\n+### Example\n+\n+```rust\n+// src/main.rs\n+mod foo;\n+// src/foo.rs\n+\n+/* cursor here*/\n+```\n+\n+`experimental/parentModule` returns a single `Link` to the `mod foo;` declaration.\n+\n+### Unresolved Question\n+\n+* An alternative would be to use a more general \"gotoSuper\" request, which would work for super methods, super classes and super modules.\n+  This is the approach IntelliJ Rust is takeing.\n+  However, experience shows that super module (which generally has a feeling of navigation between files) should be separate.\n+  If you want super module, but the cursor happens to be inside an overriden function, the behavior with single \"gotoSuper\" request is surprising.\n+\n ## Join Lines\n \n **Issue:** https://github.com/microsoft/language-server-protocol/issues/992\n@@ -46,7 +139,7 @@ At the moment, rust-analyzer guarantees that only a single edit will have `Inser\n \n This request is send from client to server to handle \"Join Lines\" editor action.\n \n-**Method:** `experimental/JoinLines`\n+**Method:** `experimental/joinLines`\n \n **Request:**\n \n@@ -59,11 +152,7 @@ interface JoinLinesParams {\n }\n ```\n \n-**Response:**\n-\n-```typescript\n-TextEdit[]\n-```\n+**Response:** `TextEdit[]`\n \n ### Example\n \n@@ -75,7 +164,7 @@ fn main() {\n }\n ```\n \n-`experimental/joinLines` yields (curly braces are automagiacally removed)\n+`experimental/joinLines` yields (curly braces are automagically removed)\n \n ```rust\n fn main() {\n@@ -89,6 +178,59 @@ fn main() {\n   Currently this is left to editor's discretion, but it might be useful to specify on the server via snippets.\n   However, it then becomes unclear how it works with multi cursor.\n \n+## On Enter\n+\n+**Issue:** https://github.com/microsoft/language-server-protocol/issues/1001\n+\n+**Server Capability:** `{ \"onEnter\": boolean }`\n+\n+This request is send from client to server to handle <kbd>Enter</kbd> keypress.\n+\n+**Method:** `experimental/onEnter`\n+\n+**Request:**: `TextDocumentPositionParams`\n+\n+**Response:**\n+\n+```typescript\n+SnippetTextEdit[]\n+```\n+\n+### Example\n+\n+```rust\n+fn main() {\n+    // Some /*cursor here*/ docs\n+    let x = 92;\n+}\n+```\n+\n+`experimental/onEnter` returns the following snippet\n+\n+```rust\n+fn main() {\n+    // Some\n+    // $0 docs\n+    let x = 92;\n+}\n+```\n+\n+The primary goal of `onEnter` is to handle automatic indentation when opening a new line.\n+This is not yet implemented.\n+The secondary goal is to handle fixing up syntax, like continuing doc strings and comments, and escaping `\\n` in string literals.\n+\n+As proper cursor positioning is raison-d'etat for `onEnter`, it uses `SnippetTextEdit`.\n+\n+### Unresolved Question\n+\n+* How to deal with synchronicity of the request?\n+  One option is to require the client to block until the server returns the response.\n+  Another option is to do a OT-style merging of edits from client and server.\n+  A third option is to do a record-replay: client applies heuristic on enter immediatelly, then applies all user's keypresses.\n+  When the server is ready with the response, the client rollbacks all the changes and applies the recorded actions on top of the correct response.\n+* How to deal with multiple carets?\n+* Should we extend this to arbitrary typed events and not just `onEnter`?\n+\n ## Structural Search Replace (SSR)\n \n **Server Capability:** `{ \"ssr\": boolean }`\n@@ -124,49 +266,180 @@ SSR with query `foo($a:expr, $b:expr) ==>> ($a).foo($b)` will transform, eg `foo\n * Probably needs search without replace mode\n * Needs a way to limit the scope to certain files.\n \n-## `CodeAction` Groups\n+## Matching Brace\n \n-**Issue:** https://github.com/microsoft/language-server-protocol/issues/994\n+**Issue:** https://github.com/microsoft/language-server-protocol/issues/999\n \n-**Client Capability:** `{ \"codeActionGroup\": boolean }`\n+**Server Capability:** `{ \"matchingBrace\": boolean }`\n \n-If this capability is set, `CodeAction` returned from the server contain an additional field, `group`:\n+This request is send from client to server to handle \"Matching Brace\" editor action.\n+\n+**Method:** `experimental/matchingBrace`\n+\n+**Request:**\n \n ```typescript\n-interface CodeAction {\n-    title: string;\n-    group?: string;\n-    ...\n+interface MatchingBraceParams {\n+    textDocument: TextDocumentIdentifier,\n+    /// Position for each cursor\n+    positions: Position[],\n }\n ```\n \n-All code-actions with the same `group` should be grouped under single (extendable) entry in lightbulb menu.\n-The set of actions `[ { title: \"foo\" }, { group: \"frobnicate\", title: \"bar\" }, { group: \"frobnicate\", title: \"baz\" }]` should be rendered as\n+**Response:**\n \n-```\n-\ud83d\udca1\n-  +-------------+\n-  | foo         |\n-  +-------------+-----+\n-  | frobnicate >| bar |\n-  +-------------+-----+\n-                | baz |\n-                +-----+\n+```typescript\n+Position[]\n ```\n \n-Alternatively, selecting `frobnicate` could present a user with an additional menu to choose between `bar` and `baz`.\n-\n ### Example\n \n ```rust\n fn main() {\n-    let x: Entry/*cursor here*/ = todo!();\n+    let x: Vec<()>/*cursor here*/ = vec![]\n }\n ```\n \n-Invoking code action at this position will yield two code actions for importing `Entry` from either `collections::HashMap` or `collection::BTreeMap`, grouped under a single \"import\" group.\n+`experimental/matchingBrace` yields the position of `<`.\n+In many cases, matching braces can be handled by the editor.\n+However, some cases (like disambiguating between generics and comparison operations) need a real parser.\n+Moreover, it would be cool if editors didn't need to implement even basic language parsing\n \n-### Unresolved Questions\n+### Unresolved Question\n \n-* Is a fixed two-level structure enough?\n-* Should we devise a general way to encode custom interaction protocols for GUI refactorings?\n+* Should we return a a nested brace structure, to allow paredit-like actions of jump *out* of the current brace pair?\n+  This is how `SelectionRange` request works.\n+* Alternatively, should we perhaps flag certain `SelectionRange`s as being brace pairs?\n+\n+## Runnables\n+\n+**Issue:** https://github.com/microsoft/language-server-protocol/issues/944\n+\n+**Server Capability:** `{ \"runnables\": { \"kinds\": string[] } }`\n+\n+This request is send from client to server to get the list of things that can be run (tests, binaries, `cargo check -p`).\n+\n+**Method:** `experimental/runnables`\n+\n+**Request:**\n+\n+```typescript\n+interface RunnablesParams {\n+    textDocument: TextDocumentIdentifier;\n+    /// If null, compute runnables for the whole file.\n+    position?: Position;\n+}\n+```\n+\n+**Response:** `Runnable[]`\n+\n+```typescript\n+interface Runnable {\n+    label: string;\n+    /// If this Runnable is associated with a specific function/module, etc, the location of this item\n+    location?: LocationLink;\n+    /// Running things is necessary technology specific, `kind` needs to be advertised via server capabilities,\n+    // the type of `args` is specific to `kind`. The actual running is handled by the client.\n+    kind: string;\n+    args: any;\n+}\n+```\n+\n+rust-analyzer supports only one `kind`, `\"cargo\"`. The `args` for `\"cargo\"` look like this:\n+\n+```typescript\n+{\n+    workspaceRoot?: string;\n+    cargoArgs: string[];\n+    executableArgs: string[];\n+}\n+```\n+\n+## Analyzer Status\n+\n+**Method:** `rust-analyzer/analyzerStatus`\n+\n+**Request:** `null`\n+\n+**Response:** `string`\n+\n+Returns internal status message, mostly for debugging purposes.\n+\n+## Collect Garbage\n+\n+**Method:** `rust-analyzer/collectGarbage`\n+\n+**Request:** `null`\n+\n+**Response:** `null`\n+\n+Frees some caches. For internal use, and is mostly broken at the moment.\n+\n+## Syntax Tree\n+\n+**Method:** `rust-analyzer/syntaxTree`\n+\n+**Request:**\n+\n+```typescript\n+interface SyntaxTeeParams {\n+    textDocument: TextDocumentIdentifier,\n+    range?: Range,\n+}\n+```\n+\n+**Response:** `string`\n+\n+Returns textual representation of a parse tree for the file/selected region.\n+Primarily for debugging, but very useful for all people working on rust-analyzer itself.\n+\n+## Expand Macro\n+\n+**Method:** `rust-analyzer/expandMacro`\n+\n+**Request:**\n+\n+```typescript\n+interface ExpandMacroParams {\n+    textDocument: TextDocumentIdentifier,\n+    position: Position,\n+}\n+```\n+\n+**Response:**\n+\n+```typescript\n+interface ExpandedMacro {\n+    name: string,\n+    expansion: string,\n+}\n+```\n+\n+Expands macro call at a given position.\n+\n+## Inlay Hints\n+\n+**Method:** `rust-analyzer/inlayHints`\n+\n+This request is send from client to server to render \"inlay hints\" -- virtual text inserted into editor to show things like inferred types.\n+Generally, the client should re-query inlay hints after every modification.\n+Note that we plan to move this request to `experimental/inlayHints`, as it is not really Rust-specific, but the current API is not necessary the right one.\n+Upstream issue: https://github.com/microsoft/language-server-protocol/issues/956\n+\n+**Request:**\n+\n+```typescript\n+interface InlayHintsParams {\n+    textDocument: TextDocumentIdentifier,\n+}\n+```\n+\n+**Response:** `InlayHint[]`\n+\n+```typescript\n+interface InlayHint {\n+    kind: \"TypeHint\" | \"ParameterHint\" | \"ChainingHint\",\n+    range: Range,\n+    label: string,\n+}\n+```"}, {"sha": "00b0867d78eca328d756da0e4f385eb6b155762b", "filename": "docs/dev/lsp-features.md", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/docs%2Fdev%2Flsp-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/docs%2Fdev%2Flsp-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Flsp-features.md?ref=a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e", "patch": "@@ -1,72 +0,0 @@\n-# Supported LSP features\n-\n-This list documents LSP features, supported by rust-analyzer.\n-\n-## General\n-- [x] [initialize](https://microsoft.github.io/language-server-protocol/specification#initialize)\n-- [x] [initialized](https://microsoft.github.io/language-server-protocol/specification#initialized)\n-- [x] [shutdown](https://microsoft.github.io/language-server-protocol/specification#shutdown)\n-- [ ] [exit](https://microsoft.github.io/language-server-protocol/specification#exit)\n-- [x] [$/cancelRequest](https://microsoft.github.io/language-server-protocol/specification#cancelRequest)\n-\n-## Workspace\n-- [ ] [workspace/workspaceFolders](https://microsoft.github.io/language-server-protocol/specification#workspace_workspaceFolders)\n-- [ ] [workspace/didChangeWorkspaceFolders](https://microsoft.github.io/language-server-protocol/specification#workspace_didChangeWorkspaceFolders)\n-- [x] [workspace/didChangeConfiguration](https://microsoft.github.io/language-server-protocol/specification#workspace_didChangeConfiguration)\n-- [ ] [workspace/configuration](https://microsoft.github.io/language-server-protocol/specification#workspace_configuration)\n-- [x] [workspace/didChangeWatchedFiles](https://microsoft.github.io/language-server-protocol/specification#workspace_didChangeWatchedFiles)\n-- [x] [workspace/symbol](https://microsoft.github.io/language-server-protocol/specification#workspace_symbol)\n-- [ ] [workspace/applyEdit](https://microsoft.github.io/language-server-protocol/specification#workspace_applyEdit)\n-\n-## Text Synchronization\n-- [x] [textDocument/didOpen](https://microsoft.github.io/language-server-protocol/specification#textDocument_didOpen)\n-- [x] [textDocument/didChange](https://microsoft.github.io/language-server-protocol/specification#textDocument_didChange)\n-- [ ] [textDocument/willSave](https://microsoft.github.io/language-server-protocol/specification#textDocument_willSave)\n-- [ ] [textDocument/willSaveWaitUntil](https://microsoft.github.io/language-server-protocol/specification#textDocument_willSaveWaitUntil)\n-- [x] [textDocument/didSave](https://microsoft.github.io/language-server-protocol/specification#textDocument_didSave)\n-- [x] [textDocument/didClose](https://microsoft.github.io/language-server-protocol/specification#textDocument_didClose)\n-\n-## Diagnostics\n-- [x] [textDocument/publishDiagnostics](https://microsoft.github.io/language-server-protocol/specification#textDocument_publishDiagnostics)\n-\n-## Lanuguage Features\n-- [x] [textDocument/completion](https://microsoft.github.io/language-server-protocol/specification#textDocument_completion)\n- - open close: false\n- - change: Full\n- - will save: false\n- - will save wait until: false\n- - save: false\n-- [x] [completionItem/resolve](https://microsoft.github.io/language-server-protocol/specification#completionItem_resolve)\n- - resolve provider: none\n- - trigger characters: `:`, `.`\n-- [x] [textDocument/hover](https://microsoft.github.io/language-server-protocol/specification#textDocument_hover)\n-- [x] [textDocument/signatureHelp](https://microsoft.github.io/language-server-protocol/specification#textDocument_signatureHelp)\n- - trigger characters: `(`,  `,`\n-- [ ] [textDocument/declaration](https://microsoft.github.io/language-server-protocol/specification#textDocument_declaration)\n-- [x] [textDocument/definition](https://microsoft.github.io/language-server-protocol/specification#textDocument_definition)\n-- [x] [textDocument/typeDefinition](https://microsoft.github.io/language-server-protocol/specification#textDocument_typeDefinition)\n-- [x] [textDocument/implementation](https://microsoft.github.io/language-server-protocol/specification#textDocument_implementation)\n-- [x] [textDocument/references](https://microsoft.github.io/language-server-protocol/specification#textDocument_references)\n-- [x] [textDocument/documentHighlight](https://microsoft.github.io/language-server-protocol/specification#textDocument_documentHighlight)\n-- [x] [textDocument/documentSymbol](https://microsoft.github.io/language-server-protocol/specification#textDocument_documentSymbol)\n-- [x] [textDocument/codeAction](https://microsoft.github.io/language-server-protocol/specification#textDocument_codeAction)\n-- [x] [textDocument/selectionRange](https://github.com/Microsoft/language-server-protocol/issues/613)\n- - rust-analyzer.syntaxTree\n- - rust-analyzer.matchingBrace\n- - rust-analyzer.parentModule\n- - rust-analyzer.joinLines\n- - rust-analyzer.run\n- - rust-analyzer.analyzerStatus\n-- [x] [textDocument/codeLens](https://microsoft.github.io/language-server-protocol/specification#textDocument_codeLens)\n-- [x] [codeLens/resolve](https://microsoft.github.io/language-server-protocol/specification#codeLens_resolve)\n-- [ ] [documentLink/resolve](https://microsoft.github.io/language-server-protocol/specification#documentLink_resolve)\n-- [ ] [textDocument/documentColor](https://microsoft.github.io/language-server-protocol/specification#textDocument_documentColor)\n-- [ ] [textDocument/colorPresentation](https://microsoft.github.io/language-server-protocol/specification#textDocument_colorPresentation)\n-- [x] [textDocument/formatting](https://microsoft.github.io/language-server-protocol/specification#textDocument_formatting)\n-- [ ] [textDocument/rangeFormatting](https://microsoft.github.io/language-server-protocol/specification#textDocument_rangeFormatting)\n-- [x] [textDocument/onTypeFormatting](https://microsoft.github.io/language-server-protocol/specification#textDocument_onTypeFormatting)\n- - first trigger character: `=`\n- - more trigger character `.`\n-- [x] [textDocument/rename](https://microsoft.github.io/language-server-protocol/specification#textDocument_rename)\n-- [x] [textDocument/prepareRename](https://microsoft.github.io/language-server-protocol/specification#textDocument_prepareRename)\n-- [x] [textDocument/foldingRange](https://microsoft.github.io/language-server-protocol/specification#textDocument_foldingRange)"}, {"sha": "4ad7ea59d2e9b10e112428c2eb2f51a662349651", "filename": "docs/user/assists.md", "status": "removed", "additions": 0, "deletions": 769, "changes": 769, "blob_url": "https://github.com/rust-lang/rust/blob/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e", "patch": "@@ -1,769 +0,0 @@\n-# Assists\n-\n-Cursor position or selection is signified by `\u2503` character.\n-\n-\n-## `add_custom_impl`\n-\n-Adds impl block for derived trait.\n-\n-```rust\n-// BEFORE\n-#[derive(Deb\u2503ug, Display)]\n-struct S;\n-\n-// AFTER\n-#[derive(Display)]\n-struct S;\n-\n-impl Debug for S {\n-    $0\n-}\n-```\n-\n-## `add_derive`\n-\n-Adds a new `#[derive()]` clause to a struct or enum.\n-\n-```rust\n-// BEFORE\n-struct Point {\n-    x: u32,\n-    y: u32,\u2503\n-}\n-\n-// AFTER\n-#[derive($0)]\n-struct Point {\n-    x: u32,\n-    y: u32,\n-}\n-```\n-\n-## `add_explicit_type`\n-\n-Specify type for a let binding.\n-\n-```rust\n-// BEFORE\n-fn main() {\n-    let x\u2503 = 92;\n-}\n-\n-// AFTER\n-fn main() {\n-    let x: i32 = 92;\n-}\n-```\n-\n-## `add_function`\n-\n-Adds a stub function with a signature matching the function under the cursor.\n-\n-```rust\n-// BEFORE\n-struct Baz;\n-fn baz() -> Baz { Baz }\n-fn foo() {\n-    bar\u2503(\"\", baz());\n-}\n-\n-\n-// AFTER\n-struct Baz;\n-fn baz() -> Baz { Baz }\n-fn foo() {\n-    bar(\"\", baz());\n-}\n-\n-fn bar(arg: &str, baz: Baz) {\n-    ${0:todo!()}\n-}\n-\n-```\n-\n-## `add_hash`\n-\n-Adds a hash to a raw string literal.\n-\n-```rust\n-// BEFORE\n-fn main() {\n-    r#\"Hello,\u2503 World!\"#;\n-}\n-\n-// AFTER\n-fn main() {\n-    r##\"Hello, World!\"##;\n-}\n-```\n-\n-## `add_impl`\n-\n-Adds a new inherent impl for a type.\n-\n-```rust\n-// BEFORE\n-struct Ctx<T: Clone> {\n-    data: T,\u2503\n-}\n-\n-// AFTER\n-struct Ctx<T: Clone> {\n-    data: T,\n-}\n-\n-impl<T: Clone> Ctx<T> {\n-    $0\n-}\n-```\n-\n-## `add_impl_default_members`\n-\n-Adds scaffold for overriding default impl members.\n-\n-```rust\n-// BEFORE\n-trait Trait {\n-    Type X;\n-    fn foo(&self);\n-    fn bar(&self) {}\n-}\n-\n-impl Trait for () {\n-    Type X = ();\n-    fn foo(&self) {}\u2503\n-\n-}\n-\n-// AFTER\n-trait Trait {\n-    Type X;\n-    fn foo(&self);\n-    fn bar(&self) {}\n-}\n-\n-impl Trait for () {\n-    Type X = ();\n-    fn foo(&self) {}\n-    $0fn bar(&self) {}\n-\n-}\n-```\n-\n-## `add_impl_missing_members`\n-\n-Adds scaffold for required impl members.\n-\n-```rust\n-// BEFORE\n-trait Trait<T> {\n-    Type X;\n-    fn foo(&self) -> T;\n-    fn bar(&self) {}\n-}\n-\n-impl Trait<u32> for () {\u2503\n-\n-}\n-\n-// AFTER\n-trait Trait<T> {\n-    Type X;\n-    fn foo(&self) -> T;\n-    fn bar(&self) {}\n-}\n-\n-impl Trait<u32> for () {\n-    fn foo(&self) -> u32 {\n-        ${0:todo!()}\n-    }\n-\n-}\n-```\n-\n-## `add_new`\n-\n-Adds a new inherent impl for a type.\n-\n-```rust\n-// BEFORE\n-struct Ctx<T: Clone> {\n-     data: T,\u2503\n-}\n-\n-// AFTER\n-struct Ctx<T: Clone> {\n-     data: T,\n-}\n-\n-impl<T: Clone> Ctx<T> {\n-    fn $0new(data: T) -> Self { Self { data } }\n-}\n-\n-```\n-\n-## `add_turbo_fish`\n-\n-Adds `::<_>` to a call of a generic method or function.\n-\n-```rust\n-// BEFORE\n-fn make<T>() -> T { todo!() }\n-fn main() {\n-    let x = make\u2503();\n-}\n-\n-// AFTER\n-fn make<T>() -> T { todo!() }\n-fn main() {\n-    let x = make::<${0:_}>();\n-}\n-```\n-\n-## `apply_demorgan`\n-\n-Apply [De Morgan's law](https://en.wikipedia.org/wiki/De_Morgan%27s_laws).\n-This transforms expressions of the form `!l || !r` into `!(l && r)`.\n-This also works with `&&`. This assist can only be applied with the cursor\n-on either `||` or `&&`, with both operands being a negation of some kind.\n-This means something of the form `!x` or `x != y`.\n-\n-```rust\n-// BEFORE\n-fn main() {\n-    if x != 4 ||\u2503 !y {}\n-}\n-\n-// AFTER\n-fn main() {\n-    if !(x == 4 && y) {}\n-}\n-```\n-\n-## `auto_import`\n-\n-If the name is unresolved, provides all possible imports for it.\n-\n-```rust\n-// BEFORE\n-fn main() {\n-    let map = HashMap\u2503::new();\n-}\n-\n-// AFTER\n-use std::collections::HashMap;\n-\n-fn main() {\n-    let map = HashMap::new();\n-}\n-```\n-\n-## `change_return_type_to_result`\n-\n-Change the function's return type to Result.\n-\n-```rust\n-// BEFORE\n-fn foo() -> i32\u2503 { 42i32 }\n-\n-// AFTER\n-fn foo() -> Result<i32, ${0:_}> { Ok(42i32) }\n-```\n-\n-## `change_visibility`\n-\n-Adds or changes existing visibility specifier.\n-\n-```rust\n-// BEFORE\n-\u2503fn frobnicate() {}\n-\n-// AFTER\n-pub(crate) fn frobnicate() {}\n-```\n-\n-## `convert_to_guarded_return`\n-\n-Replace a large conditional with a guarded return.\n-\n-```rust\n-// BEFORE\n-fn main() {\n-    \u2503if cond {\n-        foo();\n-        bar();\n-    }\n-}\n-\n-// AFTER\n-fn main() {\n-    if !cond {\n-        return;\n-    }\n-    foo();\n-    bar();\n-}\n-```\n-\n-## `fill_match_arms`\n-\n-Adds missing clauses to a `match` expression.\n-\n-```rust\n-// BEFORE\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        \u2503\n-    }\n-}\n-\n-// AFTER\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        $0Action::Move { distance } => {}\n-        Action::Stop => {}\n-    }\n-}\n-```\n-\n-## `fix_visibility`\n-\n-Makes inaccessible item public.\n-\n-```rust\n-// BEFORE\n-mod m {\n-    fn frobnicate() {}\n-}\n-fn main() {\n-    m::frobnicate\u2503() {}\n-}\n-\n-// AFTER\n-mod m {\n-    $0pub(crate) fn frobnicate() {}\n-}\n-fn main() {\n-    m::frobnicate() {}\n-}\n-```\n-\n-## `flip_binexpr`\n-\n-Flips operands of a binary expression.\n-\n-```rust\n-// BEFORE\n-fn main() {\n-    let _ = 90 +\u2503 2;\n-}\n-\n-// AFTER\n-fn main() {\n-    let _ = 2 + 90;\n-}\n-```\n-\n-## `flip_comma`\n-\n-Flips two comma-separated items.\n-\n-```rust\n-// BEFORE\n-fn main() {\n-    ((1, 2),\u2503 (3, 4));\n-}\n-\n-// AFTER\n-fn main() {\n-    ((3, 4), (1, 2));\n-}\n-```\n-\n-## `flip_trait_bound`\n-\n-Flips two trait bounds.\n-\n-```rust\n-// BEFORE\n-fn foo<T: Clone +\u2503 Copy>() { }\n-\n-// AFTER\n-fn foo<T: Copy + Clone>() { }\n-```\n-\n-## `inline_local_variable`\n-\n-Inlines local variable.\n-\n-```rust\n-// BEFORE\n-fn main() {\n-    let x\u2503 = 1 + 2;\n-    x * 4;\n-}\n-\n-// AFTER\n-fn main() {\n-    (1 + 2) * 4;\n-}\n-```\n-\n-## `introduce_variable`\n-\n-Extracts subexpression into a variable.\n-\n-```rust\n-// BEFORE\n-fn main() {\n-    \u2503(1 + 2)\u2503 * 4;\n-}\n-\n-// AFTER\n-fn main() {\n-    let $0var_name = (1 + 2);\n-    var_name * 4;\n-}\n-```\n-\n-## `invert_if`\n-\n-Apply invert_if\n-This transforms if expressions of the form `if !x {A} else {B}` into `if x {B} else {A}`\n-This also works with `!=`. This assist can only be applied with the cursor\n-on `if`.\n-\n-```rust\n-// BEFORE\n-fn main() {\n-    if\u2503 !y { A } else { B }\n-}\n-\n-// AFTER\n-fn main() {\n-    if y { B } else { A }\n-}\n-```\n-\n-## `make_raw_string`\n-\n-Adds `r#` to a plain string literal.\n-\n-```rust\n-// BEFORE\n-fn main() {\n-    \"Hello,\u2503 World!\";\n-}\n-\n-// AFTER\n-fn main() {\n-    r#\"Hello, World!\"#;\n-}\n-```\n-\n-## `make_usual_string`\n-\n-Turns a raw string into a plain string.\n-\n-```rust\n-// BEFORE\n-fn main() {\n-    r#\"Hello,\u2503 \"World!\"\"#;\n-}\n-\n-// AFTER\n-fn main() {\n-    \"Hello, \\\"World!\\\"\";\n-}\n-```\n-\n-## `merge_imports`\n-\n-Merges two imports with a common prefix.\n-\n-```rust\n-// BEFORE\n-use std::\u2503fmt::Formatter;\n-use std::io;\n-\n-// AFTER\n-use std::{fmt::Formatter, io};\n-```\n-\n-## `merge_match_arms`\n-\n-Merges identical match arms.\n-\n-```rust\n-// BEFORE\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        \u2503Action::Move(..) => foo(),\n-        Action::Stop => foo(),\n-    }\n-}\n-\n-// AFTER\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move(..) | Action::Stop => foo(),\n-    }\n-}\n-```\n-\n-## `move_arm_cond_to_match_guard`\n-\n-Moves if expression from match arm body into a guard.\n-\n-```rust\n-// BEFORE\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move { distance } => \u2503if distance > 10 { foo() },\n-        _ => (),\n-    }\n-}\n-\n-// AFTER\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move { distance } if distance > 10 => foo(),\n-        _ => (),\n-    }\n-}\n-```\n-\n-## `move_bounds_to_where_clause`\n-\n-Moves inline type bounds to a where clause.\n-\n-```rust\n-// BEFORE\n-fn apply<T, U, \u2503F: FnOnce(T) -> U>(f: F, x: T) -> U {\n-    f(x)\n-}\n-\n-// AFTER\n-fn apply<T, U, F>(f: F, x: T) -> U where F: FnOnce(T) -> U {\n-    f(x)\n-}\n-```\n-\n-## `move_guard_to_arm_body`\n-\n-Moves match guard into match arm body.\n-\n-```rust\n-// BEFORE\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move { distance } \u2503if distance > 10 => foo(),\n-        _ => (),\n-    }\n-}\n-\n-// AFTER\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move { distance } => if distance > 10 { foo() },\n-        _ => (),\n-    }\n-}\n-```\n-\n-## `remove_dbg`\n-\n-Removes `dbg!()` macro call.\n-\n-```rust\n-// BEFORE\n-fn main() {\n-    \u2503dbg!(92);\n-}\n-\n-// AFTER\n-fn main() {\n-    92;\n-}\n-```\n-\n-## `remove_hash`\n-\n-Removes a hash from a raw string literal.\n-\n-```rust\n-// BEFORE\n-fn main() {\n-    r#\"Hello,\u2503 World!\"#;\n-}\n-\n-// AFTER\n-fn main() {\n-    r\"Hello, World!\";\n-}\n-```\n-\n-## `remove_mut`\n-\n-Removes the `mut` keyword.\n-\n-```rust\n-// BEFORE\n-impl Walrus {\n-    fn feed(&mut\u2503 self, amount: u32) {}\n-}\n-\n-// AFTER\n-impl Walrus {\n-    fn feed(&self, amount: u32) {}\n-}\n-```\n-\n-## `reorder_fields`\n-\n-Reorder the fields of record literals and record patterns in the same order as in\n-the definition.\n-\n-```rust\n-// BEFORE\n-struct Foo {foo: i32, bar: i32};\n-const test: Foo = \u2503Foo {bar: 0, foo: 1}\n-\n-// AFTER\n-struct Foo {foo: i32, bar: i32};\n-const test: Foo = Foo {foo: 1, bar: 0}\n-```\n-\n-## `replace_if_let_with_match`\n-\n-Replaces `if let` with an else branch with a `match` expression.\n-\n-```rust\n-// BEFORE\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    \u2503if let Action::Move { distance } = action {\n-        foo(distance)\n-    } else {\n-        bar()\n-    }\n-}\n-\n-// AFTER\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move { distance } => foo(distance),\n-        _ => bar(),\n-    }\n-}\n-```\n-\n-## `replace_let_with_if_let`\n-\n-Replaces `let` with an `if-let`.\n-\n-```rust\n-// BEFORE\n-\n-fn main(action: Action) {\n-    \u2503let x = compute();\n-}\n-\n-fn compute() -> Option<i32> { None }\n-\n-// AFTER\n-\n-fn main(action: Action) {\n-    if let Some(x) = compute() {\n-    }\n-}\n-\n-fn compute() -> Option<i32> { None }\n-```\n-\n-## `replace_qualified_name_with_use`\n-\n-Adds a use statement for a given fully-qualified name.\n-\n-```rust\n-// BEFORE\n-fn process(map: std::collections::\u2503HashMap<String, String>) {}\n-\n-// AFTER\n-use std::collections::HashMap;\n-\n-fn process(map: HashMap<String, String>) {}\n-```\n-\n-## `replace_unwrap_with_match`\n-\n-Replaces `unwrap` a `match` expression. Works for Result and Option.\n-\n-```rust\n-// BEFORE\n-enum Result<T, E> { Ok(T), Err(E) }\n-fn main() {\n-    let x: Result<i32, i32> = Result::Ok(92);\n-    let y = x.\u2503unwrap();\n-}\n-\n-// AFTER\n-enum Result<T, E> { Ok(T), Err(E) }\n-fn main() {\n-    let x: Result<i32, i32> = Result::Ok(92);\n-    let y = match x {\n-        Ok(a) => a,\n-        $0_ => unreachable!(),\n-    };\n-}\n-```\n-\n-## `split_import`\n-\n-Wraps the tail of import into braces.\n-\n-```rust\n-// BEFORE\n-use std::\u2503collections::HashMap;\n-\n-// AFTER\n-use std::{collections::HashMap};\n-```\n-\n-## `unwrap_block`\n-\n-This assist removes if...else, for, while and loop control statements to just keep the body.\n-\n-```rust\n-// BEFORE\n-fn foo() {\n-    if true {\u2503\n-        println!(\"foo\");\n-    }\n-}\n-\n-// AFTER\n-fn foo() {\n-    println!(\"foo\");\n-}\n-```"}, {"sha": "340bce835565fa793c598711ee2496543c70218d", "filename": "docs/user/features.md", "status": "removed", "additions": 0, "deletions": 212, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/docs%2Fuser%2Ffeatures.md", "raw_url": "https://github.com/rust-lang/rust/raw/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/docs%2Fuser%2Ffeatures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Ffeatures.md?ref=a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e", "patch": "@@ -1,212 +0,0 @@\n-This document is an index of features that the rust-analyzer language server\n-provides. Shortcuts are for the default VS Code layout. If there's no shortcut,\n-you can use <kbd>Ctrl+Shift+P</kbd> to search for the corresponding action.\n-\n-### Workspace Symbol <kbd>ctrl+t</kbd>\n-\n-Uses fuzzy-search to find types, modules and functions by name across your\n-project and dependencies. This is **the** most useful feature, which improves code\n-navigation tremendously. It mostly works on top of the built-in LSP\n-functionality, however `#` and `*` symbols can be used to narrow down the\n-search. Specifically,\n-\n-- `Foo` searches for `Foo` type in the current workspace\n-- `foo#` searches for `foo` function in the current workspace\n-- `Foo*` searches for `Foo` type among dependencies, including `stdlib`\n-- `foo#*` searches for `foo` function among dependencies\n-\n-That is, `#` switches from \"types\" to all symbols, `*` switches from the current\n-workspace to dependencies.\n-\n-### Document Symbol <kbd>ctrl+shift+o</kbd>\n-\n-Provides a tree of the symbols defined in the file. Can be used to\n-\n-* fuzzy search symbol in a file (super useful)\n-* draw breadcrumbs to describe the context around the cursor\n-* draw outline of the file\n-\n-### On Typing Assists\n-\n-Some features trigger on typing certain characters:\n-\n-- typing `let =` tries to smartly add `;` if `=` is followed by an existing expression\n-- Enter inside comments automatically inserts `///`\n-- typing `.` in a chain method call auto-indents\n-\n-### Extend Selection\n-\n-Extends the current selection to the encompassing syntactic construct\n-(expression, statement, item, module, etc). It works with multiple cursors. This\n-is a relatively new feature of LSP:\n-https://github.com/Microsoft/language-server-protocol/issues/613, check your\n-editor's LSP library to see if this feature is supported.\n-\n-### Go to Definition\n-\n-Navigates to the definition of an identifier.\n-\n-### Go to Implementation\n-\n-Navigates to the impl block of structs, enums or traits. Also implemented as a code lens.\n-\n-### Go to Type Defintion\n-\n-Navigates to the type of an identifier.\n-\n-### Commands <kbd>ctrl+shift+p</kbd>\n-\n-#### Run\n-\n-Shows a popup suggesting to run a test/benchmark/binary **at the current cursor\n-location**. Super useful for repeatedly running just a single test. Do bind this\n-to a shortcut!\n-\n-#### Parent Module\n-\n-Navigates to the parent module of the current module.\n-\n-#### Matching Brace\n-\n-If the cursor is on any brace (`<>(){}[]`) which is a part of a brace-pair,\n-moves cursor to the matching brace. It uses the actual parser to determine\n-braces, so it won't confuse generics with comparisons.\n-\n-#### Join Lines\n-\n-Join selected lines into one, smartly fixing up whitespace and trailing commas.\n-\n-#### Show Syntax Tree\n-\n-Shows the parse tree of the current file. It exists mostly for debugging\n-rust-analyzer itself.\n-\n-#### Expand Macro Recursively\n-\n-Shows the full macro expansion of the macro at current cursor.\n-\n-#### Status\n-\n-Shows internal statistic about memory usage of rust-analyzer.\n-\n-#### Show RA Version\n-\n-Show current rust-analyzer version.\n-\n-#### Run Garbage Collection\n-\n-Manually triggers GC.\n-\n-#### Start Cargo Watch\n-\n-Start `cargo watch` for live error highlighting. Will prompt to install if it's not already installed.\n-\n-#### Stop Cargo Watch\n-\n-Stop `cargo watch`.\n-\n-#### Structural Seach and Replace\n-\n-Search and replace with named wildcards that will match any expression.\n-The syntax for a structural search replace command is `<search_pattern> ==>> <replace_pattern>`. A `$<name>:expr` placeholder in the search pattern will match any expression and `$<name>` will reference it in the replacement. Available via the command `rust-analyzer.ssr`.\n-\n-```rust\n-// Using structural search replace command [foo($a:expr, $b:expr) ==>> ($a).foo($b)]\n-\n-// BEFORE\n-String::from(foo(y + 5, z))\n-\n-// AFTER\n-String::from((y + 5).foo(z))\n-```\n-\n-### Assists (Code Actions)\n-\n-Assists, or code actions, are small local refactorings, available in a particular context.\n-They are usually triggered by a shortcut or by clicking a light bulb icon in the editor.\n-\n-See [assists.md](./assists.md) for the list of available assists.\n-\n-### Magic Completions\n-\n-In addition to usual reference completion, rust-analyzer provides some \u2728magic\u2728\n-completions as well:\n-\n-Keywords like `if`, `else` `while`, `loop` are completed with braces, and cursor\n-is placed at the appropriate position. Even though `if` is easy to type, you\n-still want to complete it, to get ` { }` for free! `return` is inserted with a\n-space or `;` depending on the return type of the function.\n-\n-When completing a function call, `()` are automatically inserted. If a function\n-takes arguments, the cursor is positioned inside the parenthesis.\n-\n-There are postfix completions, which can be triggered by typing something like\n-`foo().if`. The word after `.` determines postfix completion. Possible variants are:\n-\n-- `expr.if` -> `if expr {}` or `if let ... {}` for `Option` or `Result`\n-- `expr.match` -> `match expr {}`\n-- `expr.while` -> `while expr {}` or `while let ... {}` for `Option` or `Result`\n-- `expr.ref` -> `&expr`\n-- `expr.refm` -> `&mut expr`\n-- `expr.not` -> `!expr`\n-- `expr.dbg` -> `dbg!(expr)`\n-\n-There also snippet completions:\n-\n-#### Inside Expressions\n-\n-- `pd` -> `println!(\"{:?}\")`\n-- `ppd` -> `println!(\"{:#?}\")`\n-\n-#### Inside Modules\n-\n-- `tfn` -> `#[test] fn f(){}`\n-- `tmod` ->\n-```rust\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn test_fn() {}\n-}\n-```\n-\n-### Code Highlighting\n-\n-Experimental feature to let rust-analyzer highlight Rust code instead of using the\n-default highlighter.\n-\n-#### Rainbow Highlighting\n-\n-Experimental feature that, given code highlighting using rust-analyzer is\n-active, will pick unique colors for identifiers.\n-\n-### Code hints\n-\n-Rust-analyzer has two types of hints to show the information about the code:\n-\n-* hover hints, appearing on hover on any element.\n-\n-These contain extended information on the hovered language item.\n-\n-* inlay hints, shown near the element hinted directly in the editor.\n-\n-Two types of inlay hints are displayed currently:\n-\n-* type hints, displaying the minimal information on the type of the expression (if the information is available)\n-* method chaining hints, type information for multi-line method chains\n-* parameter name hints, displaying the names of the parameters in the corresponding methods\n-\n-#### VS Code\n-\n-In VS Code, the following settings can be used to configure the inlay hints:\n-\n-* `rust-analyzer.inlayHints.typeHints` - enable hints for inferred types.\n-* `rust-analyzer.inlayHints.chainingHints` - enable hints for inferred types on method chains.\n-* `rust-analyzer.inlayHints.parameterHints` - enable hints for function parameters.\n-* `rust-analyzer.inlayHints.maxLength` \u2014\u00a0shortens the hints if their length exceeds the value specified. If no value is specified (`null`), no shortening is applied.\n-\n-**Note:** VS Code does not have native support for inlay hints [yet](https://github.com/microsoft/vscode/issues/16221) and the hints are implemented using decorations.\n-This approach has limitations, the caret movement and bracket highlighting near the edges of the hint may be weird:\n-[1](https://github.com/rust-analyzer/rust-analyzer/issues/1623), [2](https://github.com/rust-analyzer/rust-analyzer/issues/3453)."}, {"sha": "ea714f49addf05145defc3a20bfe303c66f1fd5c", "filename": "docs/user/manual.adoc", "status": "renamed", "additions": 83, "deletions": 13, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/docs%2Fuser%2Fmanual.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/docs%2Fuser%2Fmanual.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fmanual.adoc?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -2,14 +2,9 @@\n :toc: preamble\n :sectanchors:\n :page-layout: post\n-// https://gist.github.com/dcode/0cfbf2699a1fe9b46ff04c41721dda74#admonitions\n-:tip-caption: :bulb:\n-:note-caption: :information_source:\n-:important-caption: :heavy_exclamation_mark:\n-:caution-caption: :fire:\n-:warning-caption: :warning:\n-\n-\n+:icons: font\n+:source-highlighter: rouge\n+:experimental:\n \n // Master copy of this document lives in the https://github.com/rust-analyzer/rust-analyzer repository\n \n@@ -19,7 +14,9 @@ https://microsoft.github.io/language-server-protocol/[Language Server Protocol]\n The LSP allows various code editors, like VS Code, Emacs or Vim, to implement semantic features like completion or goto definition by talking to an external language server process.\n \n To improve this document, send a pull request against\n-https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/user/readme.adoc[this file].\n+https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/user/manual.adoc[this file].\n+\n+If you have questions about using rust-analyzer, please ask them in the https://users.rust-lang.org/c/ide/14[\"`IDEs and Editors`\"] topic of Rust users forum.\n \n == Installation\n \n@@ -112,10 +109,23 @@ Here are some useful self-diagnostic commands:\n * To log all LSP requests, add `\"rust-analyzer.trace.server\": \"verbose\"` to the settings and look for `Server Trace` in the panel.\n * To enable client-side logging, add `\"rust-analyzer.trace.extension\": true` to the settings and open the `Console` tab of VS Code developer tools.\n \n+==== Special `when` clause context for keybindings.\n+You may use `inRustProject` context to configure keybindings for rust projects only. For example:\n+[source,json]\n+----\n+{\n+  \"key\": \"ctrl+i\",\n+  \"command\": \"rust-analyzer.toggleInlayHints\",\n+  \"when\": \"inRustProject\"\n+}\n+----\n+More about `when` clause contexts https://code.visualstudio.com/docs/getstarted/keybindings#_when-clause-contexts[here].\n+\n === rust-analyzer Language Server Binary\n \n Other editors generally require the `rust-analyzer` binary to be in `$PATH`.\n-You can download the pre-built binary from the https://github.com/rust-analyzer/rust-analyzer/releases[releases] page. Typically, you then need to rename the binary for your platform, e.g. `rust-analyzer-mac` if you're on Mac OS, to `rust-analyzer` and make it executable in addition to moving it into a directory in your `$PATH`.\n+You can download the pre-built binary from the https://github.com/rust-analyzer/rust-analyzer/releases[releases] page.\n+Typically, you then need to rename the binary for your platform, e.g. `rust-analyzer-mac` if you're on Mac OS, to `rust-analyzer` and make it executable in addition to moving it into a directory in your `$PATH`.\n \n On Linux to install the `rust-analyzer` binary into `~/.local/bin`, this commands could be used\n \n@@ -135,7 +145,8 @@ $ git clone https://github.com/rust-analyzer/rust-analyzer.git && cd rust-analyz\n $ cargo xtask install --server\n ----\n \n-If your editor can't find the binary even though the binary is on your `$PATH`, the likely explanation is that it doesn't see the same `$PATH` as the shell, see https://github.com/rust-analyzer/rust-analyzer/issues/1811[this issue]. On Unix, running the editor from a shell or changing the `.desktop` file to set the environment should help.\n+If your editor can't find the binary even though the binary is on your `$PATH`, the likely explanation is that it doesn't see the same `$PATH` as the shell, see https://github.com/rust-analyzer/rust-analyzer/issues/1811[this issue].\n+On Unix, running the editor from a shell or changing the `.desktop` file to set the environment should help.\n \n ==== Arch Linux\n \n@@ -258,6 +269,65 @@ Gnome Builder currently has support for RLS, and there's no way to configure the\n 1. Rename, symlink or copy the `rust-analyzer` binary to `rls` and place it somewhere Builder can find (in `PATH`, or under `~/.cargo/bin`).\n 2. Enable the Rust Builder plugin.\n \n-== Usage\n+== Non-Cargo Based Projects\n+\n+rust-analyzer does not require Cargo.\n+However, if you use some other build system, you'll have to describe the structure of your project for rust-analyzer in the `rust-project.json` format:\n+\n+[source,TypeScript]\n+----\n+interface JsonProject {\n+   /// The set of paths containing the crates for this project.\n+   /// Any `Crate` must be nested inside some `root`.\n+   roots: string[];\n+   /// The set of crates comprising the current project.\n+   /// Must include all transitive dependencies as well as sysroot crate (libstd, libcore and such).\n+   crates: Crate[];\n+}\n+\n+interface Crate {\n+    /// Path to the root module of the crate.\n+    root_module: string;\n+    /// Edition of the crate.\n+    edition: \"2015\" | \"2018\";\n+    /// Dependencies\n+    deps: Dep[];\n+    /// The set of cfgs activated for a given crate, like `[\"unix\", \"feature=foo\", \"feature=bar\"]`.\n+    cfg: string[];\n+\n+    /// value of the OUT_DIR env variable.\n+    out_dir?: string;\n+    /// For proc-macro crates, path to compiles proc-macro (.so file).\n+    proc_macro_dylib_path?: string;\n+}\n+\n+interface Dep {\n+    /// Index of a crate in the `crates` array.\n+    crate: number,\n+    /// Name as should appear in the (implicit) `extern crate name` declaration.\n+    name: string,\n+}\n+----\n+\n+This format is provisional and subject to change.\n+Specifically, the `roots` setup will be different eventually.\n+\n+There are tree ways to feed `rust-project.json` to rust-analyzer:\n+\n+* Place `rust-project.json` file at the root of the project, and rust-anlayzer will discover it.\n+* Specify `\"rust-analyzer.linkedProjects\": [ \"path/to/rust-project.json\" ]` in the settings (and make sure that your LSP client sends settings as a part of initialize request).\n+* Specify `\"rust-analyzer.linkedProjects\": [ { \"roots\": [...], \"crates\": [...] }]` inline.\n+\n+See https://github.com/rust-analyzer/rust-project.json-example for a small example.\n+\n+== Features\n+\n+include::./generated_features.adoc[]\n+\n+== Assists (Code Actions)\n+\n+Assists, or code actions, are small local refactorings, available in a particular context.\n+They are usually triggered by a shortcut or by clicking a light bulb icon in the editor.\n+Cursor position or selection is signified by `\u2503` character.\n \n-See https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/user/features.md[features.md].\n+include::./generated_assists.adoc[]", "previous_filename": "docs/user/readme.adoc"}, {"sha": "7149ab7992309c53edbc63f7f0e0a8c531cb07c2", "filename": "editors/code/.vscodeignore", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2F.vscodeignore", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2F.vscodeignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2F.vscodeignore?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,5 +1,5 @@\n **\n-!out/main.js\n+!out/src/main.js\n !package.json\n !package-lock.json\n !ra_syntax_tree.tmGrammar.json"}, {"sha": "3b4a316820fe1e8f8fa4497d84eb37fff7ecda24", "filename": "editors/code/package-lock.json", "status": "modified", "additions": 1096, "deletions": 230, "changes": 1326, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fpackage-lock.json", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fpackage-lock.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage-lock.json?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -13,21 +13,27 @@\n                 \"@babel/highlight\": \"^7.8.3\"\n             }\n         },\n+        \"@babel/helper-validator-identifier\": {\n+            \"version\": \"7.9.5\",\n+            \"resolved\": \"https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.9.5.tgz\",\n+            \"integrity\": \"sha512-/8arLKUFq882w4tWGj9JYzRpAlZgiWUJ+dtteNTDqrRBz9Iguck9Rn3ykuBDoUwh2TO4tSAJlrxDUOXWklJe4g==\",\n+            \"dev\": true\n+        },\n         \"@babel/highlight\": {\n-            \"version\": \"7.8.3\",\n-            \"resolved\": \"https://registry.npmjs.org/@babel/highlight/-/highlight-7.8.3.tgz\",\n-            \"integrity\": \"sha512-PX4y5xQUvy0fnEVHrYOarRPXVWafSjTW9T0Hab8gVIawpl2Sj0ORyrygANq+KjcNlSSTw0YCLSNA8OyZ1I4yEg==\",\n+            \"version\": \"7.9.0\",\n+            \"resolved\": \"https://registry.npmjs.org/@babel/highlight/-/highlight-7.9.0.tgz\",\n+            \"integrity\": \"sha512-lJZPilxX7Op3Nv/2cvFdnlepPXDxi29wxteT57Q965oc5R9v86ztx0jfxVrTcBk8C2kcPkkDa2Z4T3ZsPPVWsQ==\",\n             \"dev\": true,\n             \"requires\": {\n+                \"@babel/helper-validator-identifier\": \"^7.9.0\",\n                 \"chalk\": \"^2.0.0\",\n-                \"esutils\": \"^2.0.2\",\n                 \"js-tokens\": \"^4.0.0\"\n             }\n         },\n         \"@rollup/plugin-commonjs\": {\n-            \"version\": \"11.1.0\",\n-            \"resolved\": \"https://registry.npmjs.org/@rollup/plugin-commonjs/-/plugin-commonjs-11.1.0.tgz\",\n-            \"integrity\": \"sha512-Ycr12N3ZPN96Fw2STurD21jMqzKwL9QuFhms3SD7KKRK7oaXUsBU9Zt0jL/rOPHiPYisI21/rXGO3jr9BnLHUA==\",\n+            \"version\": \"12.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/@rollup/plugin-commonjs/-/plugin-commonjs-12.0.0.tgz\",\n+            \"integrity\": \"sha512-8+mDQt1QUmN+4Y9D3yCG8AJNewuTSLYPJVzKKUZ+lGeQrI+bV12Tc5HCyt2WdlnG6ihIL/DPbKRJlB40DX40mw==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"@rollup/pluginutils\": \"^3.0.8\",\n@@ -40,27 +46,29 @@\n             }\n         },\n         \"@rollup/plugin-node-resolve\": {\n-            \"version\": \"7.1.3\",\n-            \"resolved\": \"https://registry.npmjs.org/@rollup/plugin-node-resolve/-/plugin-node-resolve-7.1.3.tgz\",\n-            \"integrity\": \"sha512-RxtSL3XmdTAE2byxekYLnx+98kEUOrPHF/KRVjLH+DEIHy6kjIw7YINQzn+NXiH/NTrQLAwYs0GWB+csWygA9Q==\",\n+            \"version\": \"8.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/@rollup/plugin-node-resolve/-/plugin-node-resolve-8.0.0.tgz\",\n+            \"integrity\": \"sha512-5poJCChrkVggXXND/sQ7yNqwjUNT4fP31gpRWCnSNnlXuUXTCMHT33xZrTGxgjm5Rl18MHj7iEzlCT8rYWwQSA==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"@rollup/pluginutils\": \"^3.0.8\",\n                 \"@types/resolve\": \"0.0.8\",\n                 \"builtin-modules\": \"^3.1.0\",\n+                \"deep-freeze\": \"^0.0.1\",\n+                \"deepmerge\": \"^4.2.2\",\n                 \"is-module\": \"^1.0.0\",\n                 \"resolve\": \"^1.14.2\"\n             }\n         },\n         \"@rollup/pluginutils\": {\n-            \"version\": \"3.0.9\",\n-            \"resolved\": \"https://registry.npmjs.org/@rollup/pluginutils/-/pluginutils-3.0.9.tgz\",\n-            \"integrity\": \"sha512-TLZavlfPAZYI7v33wQh4mTP6zojne14yok3DNSLcjoG/Hirxfkonn6icP5rrNWRn8nZsirJBFFpijVOJzkUHDg==\",\n+            \"version\": \"3.0.10\",\n+            \"resolved\": \"https://registry.npmjs.org/@rollup/pluginutils/-/pluginutils-3.0.10.tgz\",\n+            \"integrity\": \"sha512-d44M7t+PjmMrASHbhgpSbVgtL6EFyX7J4mYxwQ/c5eoaE6N2VgCgEcWVzNnwycIloti+/MpwFr8qfw+nRw00sw==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"@types/estree\": \"0.0.39\",\n                 \"estree-walker\": \"^1.0.1\",\n-                \"micromatch\": \"^4.0.2\"\n+                \"picomatch\": \"^2.2.2\"\n             }\n         },\n         \"@types/color-name\": {\n@@ -81,16 +89,45 @@\n             \"integrity\": \"sha512-EYNwp3bU+98cpU4lAWYYL7Zz+2gryWH1qbdDTidVd6hkiR6weksdbMadyXKXNPEkQFhXM+hVO9ZygomHXp+AIw==\",\n             \"dev\": true\n         },\n+        \"@types/events\": {\n+            \"version\": \"3.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/@types/events/-/events-3.0.0.tgz\",\n+            \"integrity\": \"sha512-EaObqwIvayI5a8dCzhFrjKzVwKLxjoG9T6Ppd5CEo07LRKfQ8Yokw54r5+Wq7FaBQ+yXRvQAYPrHwya1/UFt9g==\",\n+            \"dev\": true\n+        },\n+        \"@types/glob\": {\n+            \"version\": \"7.1.1\",\n+            \"resolved\": \"https://registry.npmjs.org/@types/glob/-/glob-7.1.1.tgz\",\n+            \"integrity\": \"sha512-1Bh06cbWJUHMC97acuD6UMG29nMt0Aqz1vF3guLfG+kHHJhy3AyohZFFxYk2f7Q1SQIrNwvncxAE0N/9s70F2w==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"@types/events\": \"*\",\n+                \"@types/minimatch\": \"*\",\n+                \"@types/node\": \"*\"\n+            }\n+        },\n         \"@types/json-schema\": {\n             \"version\": \"7.0.4\",\n             \"resolved\": \"https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.4.tgz\",\n             \"integrity\": \"sha512-8+KAKzEvSUdeo+kmqnKrqgeE+LcA0tjYWFY7RPProVYwnqDjukzO+3b6dLD56rYX5TdWejnEOLJYOIeh4CXKuA==\",\n             \"dev\": true\n         },\n+        \"@types/minimatch\": {\n+            \"version\": \"3.0.3\",\n+            \"resolved\": \"https://registry.npmjs.org/@types/minimatch/-/minimatch-3.0.3.tgz\",\n+            \"integrity\": \"sha512-tHq6qdbT9U1IRSGf14CL0pUlULksvY9OZ+5eEgl1N7t+OA3tGvNpxJCzuKQlsNgCVwbAs670L1vcVQi8j9HjnA==\",\n+            \"dev\": true\n+        },\n+        \"@types/mocha\": {\n+            \"version\": \"7.0.2\",\n+            \"resolved\": \"https://registry.npmjs.org/@types/mocha/-/mocha-7.0.2.tgz\",\n+            \"integrity\": \"sha512-ZvO2tAcjmMi8V/5Z3JsyofMe3hasRcaw88cto5etSVMwVQfeivGAlEYmaQgceUSVYFofVjT+ioHsATjdWcFt1w==\",\n+            \"dev\": true\n+        },\n         \"@types/node\": {\n-            \"version\": \"12.12.39\",\n-            \"resolved\": \"https://registry.npmjs.org/@types/node/-/node-12.12.39.tgz\",\n-            \"integrity\": \"sha512-pADGfwnDkr6zagDwEiCVE4yQrv7XDkoeVa4OfA9Ju/zRTk6YNDLGtQbkdL4/56mCQQCs4AhNrBIag6jrp7ZuOg==\",\n+            \"version\": \"14.0.5\",\n+            \"resolved\": \"https://registry.npmjs.org/@types/node/-/node-14.0.5.tgz\",\n+            \"integrity\": \"sha512-90hiq6/VqtQgX8Sp0EzeIsv3r+ellbGj4URKj5j30tLlZvRUpnAe9YbYnjl3pJM93GyXU0tghHhvXHq+5rnCKA==\",\n             \"dev\": true\n         },\n         \"@types/node-fetch\": {\n@@ -119,56 +156,54 @@\n             \"dev\": true\n         },\n         \"@typescript-eslint/eslint-plugin\": {\n-            \"version\": \"2.33.0\",\n-            \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-2.33.0.tgz\",\n-            \"integrity\": \"sha512-QV6P32Btu1sCI/kTqjTNI/8OpCYyvlGjW5vD8MpTIg+HGE5S88HtT1G+880M4bXlvXj/NjsJJG0aGcVh0DdbeQ==\",\n+            \"version\": \"3.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-3.0.0.tgz\",\n+            \"integrity\": \"sha512-lcZ0M6jD4cqGccYOERKdMtg+VWpoq3NSnWVxpc/AwAy0zhkUYVioOUZmfNqiNH8/eBNGhCn6HXd6mKIGRgNc1Q==\",\n             \"dev\": true,\n             \"requires\": {\n-                \"@typescript-eslint/experimental-utils\": \"2.33.0\",\n+                \"@typescript-eslint/experimental-utils\": \"3.0.0\",\n                 \"functional-red-black-tree\": \"^1.0.1\",\n                 \"regexpp\": \"^3.0.0\",\n+                \"semver\": \"^7.3.2\",\n                 \"tsutils\": \"^3.17.1\"\n+            },\n+            \"dependencies\": {\n+                \"semver\": {\n+                    \"version\": \"7.3.2\",\n+                    \"resolved\": \"https://registry.npmjs.org/semver/-/semver-7.3.2.tgz\",\n+                    \"integrity\": \"sha512-OrOb32TeeambH6UrhtShmF7CRDqhL6/5XpPNp2DuRH6+9QLw/orhp72j87v8Qa1ScDkvrrBNpZcDejAirJmfXQ==\",\n+                    \"dev\": true\n+                }\n             }\n         },\n         \"@typescript-eslint/experimental-utils\": {\n-            \"version\": \"2.33.0\",\n-            \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/experimental-utils/-/experimental-utils-2.33.0.tgz\",\n-            \"integrity\": \"sha512-qzPM2AuxtMrRq78LwyZa8Qn6gcY8obkIrBs1ehqmQADwkYzTE1Pb4y2W+U3rE/iFkSWcWHG2LS6MJfj6SmHApg==\",\n+            \"version\": \"3.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/experimental-utils/-/experimental-utils-3.0.0.tgz\",\n+            \"integrity\": \"sha512-BN0vmr9N79M9s2ctITtChRuP1+Dls0x/wlg0RXW1yQ7WJKPurg6X3Xirv61J2sjPif4F8SLsFMs5Nzte0WYoTQ==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"@types/json-schema\": \"^7.0.3\",\n-                \"@typescript-eslint/typescript-estree\": \"2.33.0\",\n+                \"@typescript-eslint/typescript-estree\": \"3.0.0\",\n                 \"eslint-scope\": \"^5.0.0\",\n                 \"eslint-utils\": \"^2.0.0\"\n-            },\n-            \"dependencies\": {\n-                \"eslint-utils\": {\n-                    \"version\": \"2.0.0\",\n-                    \"resolved\": \"https://registry.npmjs.org/eslint-utils/-/eslint-utils-2.0.0.tgz\",\n-                    \"integrity\": \"sha512-0HCPuJv+7Wv1bACm8y5/ECVfYdfsAm9xmVb7saeFlxjPYALefjhbYoCkBjPdPzGH8wWyTpAez82Fh3VKYEZ8OA==\",\n-                    \"dev\": true,\n-                    \"requires\": {\n-                        \"eslint-visitor-keys\": \"^1.1.0\"\n-                    }\n-                }\n             }\n         },\n         \"@typescript-eslint/parser\": {\n-            \"version\": \"2.33.0\",\n-            \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/parser/-/parser-2.33.0.tgz\",\n-            \"integrity\": \"sha512-AUtmwUUhJoH6yrtxZMHbRUEMsC2G6z5NSxg9KsROOGqNXasM71I8P2NihtumlWTUCRld70vqIZ6Pm4E5PAziEA==\",\n+            \"version\": \"3.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/parser/-/parser-3.0.0.tgz\",\n+            \"integrity\": \"sha512-8RRCA9KLxoFNO0mQlrLZA0reGPd/MsobxZS/yPFj+0/XgMdS8+mO8mF3BDj2ZYQj03rkayhSJtF1HAohQ3iylw==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"@types/eslint-visitor-keys\": \"^1.0.0\",\n-                \"@typescript-eslint/experimental-utils\": \"2.33.0\",\n-                \"@typescript-eslint/typescript-estree\": \"2.33.0\",\n+                \"@typescript-eslint/experimental-utils\": \"3.0.0\",\n+                \"@typescript-eslint/typescript-estree\": \"3.0.0\",\n                 \"eslint-visitor-keys\": \"^1.1.0\"\n             }\n         },\n         \"@typescript-eslint/typescript-estree\": {\n-            \"version\": \"2.33.0\",\n-            \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-2.33.0.tgz\",\n-            \"integrity\": \"sha512-d8rY6/yUxb0+mEwTShCQF2zYQdLlqihukNfG9IUlLYz5y1CH6G/9XYbrxQLq3Z14RNvkCC6oe+OcFlyUpwUbkg==\",\n+            \"version\": \"3.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-3.0.0.tgz\",\n+            \"integrity\": \"sha512-nevQvHyNghsfLrrByzVIH4ZG3NROgJ8LZlfh3ddwPPH4CH7W4GAiSx5qu+xHuX5pWsq6q/eqMc1io840ZhAnUg==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"debug\": \"^4.1.1\",\n@@ -189,9 +224,9 @@\n             }\n         },\n         \"acorn\": {\n-            \"version\": \"7.1.1\",\n-            \"resolved\": \"https://registry.npmjs.org/acorn/-/acorn-7.1.1.tgz\",\n-            \"integrity\": \"sha512-add7dgA5ppRPxCFJoAGfMDi7PIBXq1RtGo7BhbLaxwrXPOmw8gq48Y9ozT01hUKy9byMjlR20EJhu5zlkErEkg==\",\n+            \"version\": \"7.2.0\",\n+            \"resolved\": \"https://registry.npmjs.org/acorn/-/acorn-7.2.0.tgz\",\n+            \"integrity\": \"sha512-apwXVmYVpQ34m/i71vrApRrRKCWQnZZF1+npOD0WV5xZFfwWOmKGQ2RWlfdy9vWITsenisM8M0Qeq8agcFHNiQ==\",\n             \"dev\": true\n         },\n         \"acorn-jsx\": {\n@@ -200,10 +235,19 @@\n             \"integrity\": \"sha512-HiUX/+K2YpkpJ+SzBffkM/AQ2YE03S0U1kjTLVpoJdhZMOWy8qvXVN9JdLqv2QsaQ6MPYQIuNmwD8zOiYUofLQ==\",\n             \"dev\": true\n         },\n+        \"agent-base\": {\n+            \"version\": \"4.3.0\",\n+            \"resolved\": \"https://registry.npmjs.org/agent-base/-/agent-base-4.3.0.tgz\",\n+            \"integrity\": \"sha512-salcGninV0nPrwpGNn4VTXBb1SOuXQBiqbrNXoeizJsHrsL6ERFM2Ne3JUSBWRE6aeNJI2ROP/WEEIDUiDe3cg==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"es6-promisify\": \"^5.0.0\"\n+            }\n+        },\n         \"ajv\": {\n-            \"version\": \"6.12.0\",\n-            \"resolved\": \"https://registry.npmjs.org/ajv/-/ajv-6.12.0.tgz\",\n-            \"integrity\": \"sha512-D6gFiFA0RRLyUbvijN74DWAjXSFxWKaWP7mldxkVhyhAV3+SWA9HEJPHQ2c9soIeTFJqcSdFDGFgdqs1iUU2Hw==\",\n+            \"version\": \"6.12.2\",\n+            \"resolved\": \"https://registry.npmjs.org/ajv/-/ajv-6.12.2.tgz\",\n+            \"integrity\": \"sha512-k+V+hzjm5q/Mr8ef/1Y9goCmlsK4I6Sm74teeyGvFk1XrOsbsKLjEdrvny42CZ+a8sXbk8KWpY/bDwS+FLL2UQ==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"fast-deep-equal\": \"^3.1.1\",\n@@ -212,6 +256,12 @@\n                 \"uri-js\": \"^4.2.2\"\n             }\n         },\n+        \"ansi-colors\": {\n+            \"version\": \"3.2.3\",\n+            \"resolved\": \"https://registry.npmjs.org/ansi-colors/-/ansi-colors-3.2.3.tgz\",\n+            \"integrity\": \"sha512-LEHHyuhlPY3TmuUYMh2oz89lTShfvgbmzaBcxve9t/9Wuy7Dwf4yoAKcND7KFT1HAQfqZ12qtc+DUrBMeKF9nw==\",\n+            \"dev\": true\n+        },\n         \"ansi-escapes\": {\n             \"version\": \"4.3.1\",\n             \"resolved\": \"https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-4.3.1.tgz\",\n@@ -244,6 +294,16 @@\n                 \"color-convert\": \"^1.9.0\"\n             }\n         },\n+        \"anymatch\": {\n+            \"version\": \"3.1.1\",\n+            \"resolved\": \"https://registry.npmjs.org/anymatch/-/anymatch-3.1.1.tgz\",\n+            \"integrity\": \"sha512-mM8522psRCqzV+6LhomX5wgp25YVibjh8Wj23I5RPkPppSVSjyKD2A2mBJmWGa+KN7f2D6LNh9jkBCeyLktzjg==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"normalize-path\": \"^3.0.0\",\n+                \"picomatch\": \"^2.0.4\"\n+            }\n+        },\n         \"argparse\": {\n             \"version\": \"1.0.10\",\n             \"resolved\": \"https://registry.npmjs.org/argparse/-/argparse-1.0.10.tgz\",\n@@ -283,6 +343,12 @@\n             \"integrity\": \"sha1-ibTRmasr7kneFk6gK4nORi1xt2c=\",\n             \"dev\": true\n         },\n+        \"binary-extensions\": {\n+            \"version\": \"2.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.0.0.tgz\",\n+            \"integrity\": \"sha512-Phlt0plgpIIBOGTT/ehfFnbNlfsDEiqmzE2KRXoX1bLIlir4X/MR+zSyBEkL05ffWgnRSf/DXv+WrUAVr93/ow==\",\n+            \"dev\": true\n+        },\n         \"boolbase\": {\n             \"version\": \"1.0.0\",\n             \"resolved\": \"https://registry.npmjs.org/boolbase/-/boolbase-1.0.0.tgz\",\n@@ -308,6 +374,12 @@\n                 \"fill-range\": \"^7.0.1\"\n             }\n         },\n+        \"browser-stdout\": {\n+            \"version\": \"1.3.1\",\n+            \"resolved\": \"https://registry.npmjs.org/browser-stdout/-/browser-stdout-1.3.1.tgz\",\n+            \"integrity\": \"sha512-qhAVI1+Av2X7qelOfAIYwXONood6XlZE/fXaBSmW/T5SzLAmCgzi+eiWE7fUvbHaeNBQH13UftjpXxsfLkMpgw==\",\n+            \"dev\": true\n+        },\n         \"buffer-crc32\": {\n             \"version\": \"0.2.13\",\n             \"resolved\": \"https://registry.npmjs.org/buffer-crc32/-/buffer-crc32-0.2.13.tgz\",\n@@ -326,6 +398,12 @@\n             \"integrity\": \"sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==\",\n             \"dev\": true\n         },\n+        \"camelcase\": {\n+            \"version\": \"5.3.1\",\n+            \"resolved\": \"https://registry.npmjs.org/camelcase/-/camelcase-5.3.1.tgz\",\n+            \"integrity\": \"sha512-L28STB170nwWS63UjtlEOE3dldQApaJXZkOI1uMFfzf3rRuPegHaHesyee+YxQ+W6SvRDQV6UrdOdRiR153wJg==\",\n+            \"dev\": true\n+        },\n         \"chalk\": {\n             \"version\": \"2.4.2\",\n             \"resolved\": \"https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz\",\n@@ -357,6 +435,22 @@\n                 \"parse5\": \"^3.0.1\"\n             }\n         },\n+        \"chokidar\": {\n+            \"version\": \"3.3.0\",\n+            \"resolved\": \"https://registry.npmjs.org/chokidar/-/chokidar-3.3.0.tgz\",\n+            \"integrity\": \"sha512-dGmKLDdT3Gdl7fBUe8XK+gAtGmzy5Fn0XkkWQuYxGIgWVPPse2CxFA5mtrlD0TOHaHjEUqkWNyP1XdHoJES/4A==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"anymatch\": \"~3.1.1\",\n+                \"braces\": \"~3.0.2\",\n+                \"fsevents\": \"~2.1.1\",\n+                \"glob-parent\": \"~5.1.0\",\n+                \"is-binary-path\": \"~2.1.0\",\n+                \"is-glob\": \"~4.0.1\",\n+                \"normalize-path\": \"~3.0.0\",\n+                \"readdirp\": \"~3.2.0\"\n+            }\n+        },\n         \"cli-cursor\": {\n             \"version\": \"3.1.0\",\n             \"resolved\": \"https://registry.npmjs.org/cli-cursor/-/cli-cursor-3.1.0.tgz\",\n@@ -367,11 +461,62 @@\n             }\n         },\n         \"cli-width\": {\n-            \"version\": \"2.2.0\",\n-            \"resolved\": \"https://registry.npmjs.org/cli-width/-/cli-width-2.2.0.tgz\",\n-            \"integrity\": \"sha1-/xnt6Kml5XkyQUewwR8PvLq+1jk=\",\n+            \"version\": \"2.2.1\",\n+            \"resolved\": \"https://registry.npmjs.org/cli-width/-/cli-width-2.2.1.tgz\",\n+            \"integrity\": \"sha512-GRMWDxpOB6Dgk2E5Uo+3eEBvtOOlimMmpbFiKuLFnQzYDavtLFY3K5ona41jgN/WdRZtG7utuVSVTL4HbZHGkw==\",\n             \"dev\": true\n         },\n+        \"cliui\": {\n+            \"version\": \"5.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/cliui/-/cliui-5.0.0.tgz\",\n+            \"integrity\": \"sha512-PYeGSEmmHM6zvoef2w8TPzlrnNpXIjTipYK780YswmIP9vjxmd6Y2a3CB2Ks6/AU8NHjZugXvo8w3oWM2qnwXA==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"string-width\": \"^3.1.0\",\n+                \"strip-ansi\": \"^5.2.0\",\n+                \"wrap-ansi\": \"^5.1.0\"\n+            },\n+            \"dependencies\": {\n+                \"ansi-regex\": {\n+                    \"version\": \"4.1.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-4.1.0.tgz\",\n+                    \"integrity\": \"sha512-1apePfXM1UOSqw0o9IiFAovVz9M5S1Dg+4TrDwfMewQ6p/rmMueb7tWZjQ1rx4Loy1ArBggoqGpfqqdI4rondg==\",\n+                    \"dev\": true\n+                },\n+                \"emoji-regex\": {\n+                    \"version\": \"7.0.3\",\n+                    \"resolved\": \"https://registry.npmjs.org/emoji-regex/-/emoji-regex-7.0.3.tgz\",\n+                    \"integrity\": \"sha512-CwBLREIQ7LvYFB0WyRvwhq5N5qPhc6PMjD6bYggFlI5YyDgl+0vxq5VHbMOFqLg7hfWzmu8T5Z1QofhmTIhItA==\",\n+                    \"dev\": true\n+                },\n+                \"is-fullwidth-code-point\": {\n+                    \"version\": \"2.0.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-2.0.0.tgz\",\n+                    \"integrity\": \"sha1-o7MKXE8ZkYMWeqq5O+764937ZU8=\",\n+                    \"dev\": true\n+                },\n+                \"string-width\": {\n+                    \"version\": \"3.1.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/string-width/-/string-width-3.1.0.tgz\",\n+                    \"integrity\": \"sha512-vafcv6KjVZKSgz06oM/H6GDBrAtz8vdhQakGjFIvNrHA6y3HCF1CInLy+QLq8dTJPQ1b+KDUqDFctkdRW44e1w==\",\n+                    \"dev\": true,\n+                    \"requires\": {\n+                        \"emoji-regex\": \"^7.0.1\",\n+                        \"is-fullwidth-code-point\": \"^2.0.0\",\n+                        \"strip-ansi\": \"^5.1.0\"\n+                    }\n+                },\n+                \"strip-ansi\": {\n+                    \"version\": \"5.2.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-5.2.0.tgz\",\n+                    \"integrity\": \"sha512-DuRs1gKbBqsMKIZlrffwlug8MHkcnpjs5VPmL1PAh+mA30U0DTotfDZ0d2UUsXpPmPmMMJ6W773MaA3J+lbiWA==\",\n+                    \"dev\": true,\n+                    \"requires\": {\n+                        \"ansi-regex\": \"^4.1.0\"\n+                    }\n+                }\n+            }\n+        },\n         \"color-convert\": {\n             \"version\": \"1.9.3\",\n             \"resolved\": \"https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz\",\n@@ -421,24 +566,14 @@\n             \"dev\": true\n         },\n         \"cross-spawn\": {\n-            \"version\": \"6.0.5\",\n-            \"resolved\": \"https://registry.npmjs.org/cross-spawn/-/cross-spawn-6.0.5.tgz\",\n-            \"integrity\": \"sha512-eTVLrBSt7fjbDygz805pMnstIs2VTBNkRm0qxZd+M7A5XDdxVRWO5MxGBXZhjY4cqLYLdtrGqRf8mBPmzwSpWQ==\",\n+            \"version\": \"7.0.2\",\n+            \"resolved\": \"https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.2.tgz\",\n+            \"integrity\": \"sha512-PD6G8QG3S4FK/XCGFbEQrDqO2AnMMsy0meR7lerlIOHAAbkuavGU/pOqprrlvfTNjvowivTeBsjebAL0NSoMxw==\",\n             \"dev\": true,\n             \"requires\": {\n-                \"nice-try\": \"^1.0.4\",\n-                \"path-key\": \"^2.0.1\",\n-                \"semver\": \"^5.5.0\",\n-                \"shebang-command\": \"^1.2.0\",\n-                \"which\": \"^1.2.9\"\n-            },\n-            \"dependencies\": {\n-                \"semver\": {\n-                    \"version\": \"5.7.1\",\n-                    \"resolved\": \"https://registry.npmjs.org/semver/-/semver-5.7.1.tgz\",\n-                    \"integrity\": \"sha512-sauaDf/PZdVgrLTNYHRtpXa1iRiKcaebiKQ1BJdpQlWH2lCvexQdX55snPFyK7QzpudqbCI0qXFfOasHdyNDGQ==\",\n-                    \"dev\": true\n-                }\n+                \"path-key\": \"^3.1.0\",\n+                \"shebang-command\": \"^2.0.0\",\n+                \"which\": \"^2.0.1\"\n             }\n         },\n         \"css-select\": {\n@@ -468,12 +603,39 @@\n                 \"ms\": \"^2.1.1\"\n             }\n         },\n+        \"decamelize\": {\n+            \"version\": \"1.2.0\",\n+            \"resolved\": \"https://registry.npmjs.org/decamelize/-/decamelize-1.2.0.tgz\",\n+            \"integrity\": \"sha1-9lNNFRSCabIDUue+4m9QH5oZEpA=\",\n+            \"dev\": true\n+        },\n+        \"deep-freeze\": {\n+            \"version\": \"0.0.1\",\n+            \"resolved\": \"https://registry.npmjs.org/deep-freeze/-/deep-freeze-0.0.1.tgz\",\n+            \"integrity\": \"sha1-OgsABd4YZygZ39OM0x+RF5yJPoQ=\",\n+            \"dev\": true\n+        },\n         \"deep-is\": {\n             \"version\": \"0.1.3\",\n             \"resolved\": \"https://registry.npmjs.org/deep-is/-/deep-is-0.1.3.tgz\",\n             \"integrity\": \"sha1-s2nW+128E+7PUk+RsHD+7cNXzzQ=\",\n             \"dev\": true\n         },\n+        \"deepmerge\": {\n+            \"version\": \"4.2.2\",\n+            \"resolved\": \"https://registry.npmjs.org/deepmerge/-/deepmerge-4.2.2.tgz\",\n+            \"integrity\": \"sha512-FJ3UgI4gIl+PHZm53knsuSFpE+nESMr7M4v9QcgB7S63Kj/6WqMiFQJpBBYz1Pt+66bZpP3Q7Lye0Oo9MPKEdg==\",\n+            \"dev\": true\n+        },\n+        \"define-properties\": {\n+            \"version\": \"1.1.3\",\n+            \"resolved\": \"https://registry.npmjs.org/define-properties/-/define-properties-1.1.3.tgz\",\n+            \"integrity\": \"sha512-3MqfYKj2lLzdMSf8ZIZE/V+Zuy+BgD6f164e8K2w7dgnpKArBDerGYpM46IYYcjnkdPNMjPk9A6VFB8+3SKlXQ==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"object-keys\": \"^1.0.12\"\n+            }\n+        },\n         \"delayed-stream\": {\n             \"version\": \"1.0.0\",\n             \"resolved\": \"https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz\",\n@@ -486,6 +648,12 @@\n             \"integrity\": \"sha1-OjYof1A05pnnV3kBBSwubJQlFjE=\",\n             \"dev\": true\n         },\n+        \"diff\": {\n+            \"version\": \"3.5.0\",\n+            \"resolved\": \"https://registry.npmjs.org/diff/-/diff-3.5.0.tgz\",\n+            \"integrity\": \"sha512-A46qtFgd+g7pDZinpnwiRJtxbC1hpgf0uzP3iG89scHk0AUC7A1TGxf5OiiOUv/JMZR8GOt8hL900hV0bOy5xA==\",\n+            \"dev\": true\n+        },\n         \"doctrine\": {\n             \"version\": \"3.0.0\",\n             \"resolved\": \"https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz\",\n@@ -562,29 +730,74 @@\n             \"integrity\": \"sha512-f2LZMYl1Fzu7YSBKg+RoROelpOaNrcGmE9AZubeDfrCEia483oW4MI4VyFd5VNHIgQ/7qm1I0wUHK1eJnn2y2w==\",\n             \"dev\": true\n         },\n+        \"es-abstract\": {\n+            \"version\": \"1.17.5\",\n+            \"resolved\": \"https://registry.npmjs.org/es-abstract/-/es-abstract-1.17.5.tgz\",\n+            \"integrity\": \"sha512-BR9auzDbySxOcfog0tLECW8l28eRGpDpU3Dm3Hp4q/N+VtLTmyj4EUN088XZWQDW/hzj6sYRDXeOFsaAODKvpg==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"es-to-primitive\": \"^1.2.1\",\n+                \"function-bind\": \"^1.1.1\",\n+                \"has\": \"^1.0.3\",\n+                \"has-symbols\": \"^1.0.1\",\n+                \"is-callable\": \"^1.1.5\",\n+                \"is-regex\": \"^1.0.5\",\n+                \"object-inspect\": \"^1.7.0\",\n+                \"object-keys\": \"^1.1.1\",\n+                \"object.assign\": \"^4.1.0\",\n+                \"string.prototype.trimleft\": \"^2.1.1\",\n+                \"string.prototype.trimright\": \"^2.1.1\"\n+            }\n+        },\n+        \"es-to-primitive\": {\n+            \"version\": \"1.2.1\",\n+            \"resolved\": \"https://registry.npmjs.org/es-to-primitive/-/es-to-primitive-1.2.1.tgz\",\n+            \"integrity\": \"sha512-QCOllgZJtaUo9miYBcLChTUaHNjJF3PYs1VidD7AwiEj1kYxKeQTctLAezAOH5ZKRH0g2IgPn6KwB4IT8iRpvA==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"is-callable\": \"^1.1.4\",\n+                \"is-date-object\": \"^1.0.1\",\n+                \"is-symbol\": \"^1.0.2\"\n+            }\n+        },\n+        \"es6-promise\": {\n+            \"version\": \"4.2.8\",\n+            \"resolved\": \"https://registry.npmjs.org/es6-promise/-/es6-promise-4.2.8.tgz\",\n+            \"integrity\": \"sha512-HJDGx5daxeIvxdBxvG2cb9g4tEvwIk3i8+nhX0yGrYmZUzbkdg8QbDevheDB8gd0//uPj4c1EQua8Q+MViT0/w==\",\n+            \"dev\": true\n+        },\n+        \"es6-promisify\": {\n+            \"version\": \"5.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/es6-promisify/-/es6-promisify-5.0.0.tgz\",\n+            \"integrity\": \"sha1-UQnWLz5W6pZ8S2NQWu8IKRyKUgM=\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"es6-promise\": \"^4.0.3\"\n+            }\n+        },\n         \"escape-string-regexp\": {\n             \"version\": \"1.0.5\",\n             \"resolved\": \"https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz\",\n             \"integrity\": \"sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ=\",\n             \"dev\": true\n         },\n         \"eslint\": {\n-            \"version\": \"6.8.0\",\n-            \"resolved\": \"https://registry.npmjs.org/eslint/-/eslint-6.8.0.tgz\",\n-            \"integrity\": \"sha512-K+Iayyo2LtyYhDSYwz5D5QdWw0hCacNzyq1Y821Xna2xSJj7cijoLLYmLxTQgcgZ9mC61nryMy9S7GRbYpI5Ig==\",\n+            \"version\": \"7.1.0\",\n+            \"resolved\": \"https://registry.npmjs.org/eslint/-/eslint-7.1.0.tgz\",\n+            \"integrity\": \"sha512-DfS3b8iHMK5z/YLSme8K5cge168I8j8o1uiVmFCgnnjxZQbCGyraF8bMl7Ju4yfBmCuxD7shOF7eqGkcuIHfsA==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"@babel/code-frame\": \"^7.0.0\",\n                 \"ajv\": \"^6.10.0\",\n-                \"chalk\": \"^2.1.0\",\n-                \"cross-spawn\": \"^6.0.5\",\n+                \"chalk\": \"^4.0.0\",\n+                \"cross-spawn\": \"^7.0.2\",\n                 \"debug\": \"^4.0.1\",\n                 \"doctrine\": \"^3.0.0\",\n                 \"eslint-scope\": \"^5.0.0\",\n-                \"eslint-utils\": \"^1.4.3\",\n+                \"eslint-utils\": \"^2.0.0\",\n                 \"eslint-visitor-keys\": \"^1.1.0\",\n-                \"espree\": \"^6.1.2\",\n-                \"esquery\": \"^1.0.1\",\n+                \"espree\": \"^7.0.0\",\n+                \"esquery\": \"^1.2.0\",\n                 \"esutils\": \"^2.0.2\",\n                 \"file-entry-cache\": \"^5.0.1\",\n                 \"functional-red-black-tree\": \"^1.0.1\",\n@@ -597,27 +810,76 @@\n                 \"is-glob\": \"^4.0.0\",\n                 \"js-yaml\": \"^3.13.1\",\n                 \"json-stable-stringify-without-jsonify\": \"^1.0.1\",\n-                \"levn\": \"^0.3.0\",\n+                \"levn\": \"^0.4.1\",\n                 \"lodash\": \"^4.17.14\",\n                 \"minimatch\": \"^3.0.4\",\n-                \"mkdirp\": \"^0.5.1\",\n                 \"natural-compare\": \"^1.4.0\",\n-                \"optionator\": \"^0.8.3\",\n+                \"optionator\": \"^0.9.1\",\n                 \"progress\": \"^2.0.0\",\n-                \"regexpp\": \"^2.0.1\",\n-                \"semver\": \"^6.1.2\",\n-                \"strip-ansi\": \"^5.2.0\",\n-                \"strip-json-comments\": \"^3.0.1\",\n+                \"regexpp\": \"^3.1.0\",\n+                \"semver\": \"^7.2.1\",\n+                \"strip-ansi\": \"^6.0.0\",\n+                \"strip-json-comments\": \"^3.1.0\",\n                 \"table\": \"^5.2.3\",\n                 \"text-table\": \"^0.2.0\",\n                 \"v8-compile-cache\": \"^2.0.3\"\n             },\n             \"dependencies\": {\n-                \"regexpp\": {\n+                \"ansi-styles\": {\n+                    \"version\": \"4.2.1\",\n+                    \"resolved\": \"https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.2.1.tgz\",\n+                    \"integrity\": \"sha512-9VGjrMsG1vePxcSweQsN20KY/c4zN0h9fLjqAbwbPfahM3t+NL+M9HC8xeXG2I8pX5NoamTGNuomEUFI7fcUjA==\",\n+                    \"dev\": true,\n+                    \"requires\": {\n+                        \"@types/color-name\": \"^1.1.1\",\n+                        \"color-convert\": \"^2.0.1\"\n+                    }\n+                },\n+                \"chalk\": {\n+                    \"version\": \"4.0.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/chalk/-/chalk-4.0.0.tgz\",\n+                    \"integrity\": \"sha512-N9oWFcegS0sFr9oh1oz2d7Npos6vNoWW9HvtCg5N1KRFpUhaAhvTv5Y58g880fZaEYSNm3qDz8SU1UrGvp+n7A==\",\n+                    \"dev\": true,\n+                    \"requires\": {\n+                        \"ansi-styles\": \"^4.1.0\",\n+                        \"supports-color\": \"^7.1.0\"\n+                    }\n+                },\n+                \"color-convert\": {\n                     \"version\": \"2.0.1\",\n-                    \"resolved\": \"https://registry.npmjs.org/regexpp/-/regexpp-2.0.1.tgz\",\n-                    \"integrity\": \"sha512-lv0M6+TkDVniA3aD1Eg0DVpfU/booSu7Eev3TDO/mZKHBfVjgCGTV4t4buppESEYDtkArYFOxTJWv6S5C+iaNw==\",\n+                    \"resolved\": \"https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz\",\n+                    \"integrity\": \"sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==\",\n+                    \"dev\": true,\n+                    \"requires\": {\n+                        \"color-name\": \"~1.1.4\"\n+                    }\n+                },\n+                \"color-name\": {\n+                    \"version\": \"1.1.4\",\n+                    \"resolved\": \"https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz\",\n+                    \"integrity\": \"sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==\",\n+                    \"dev\": true\n+                },\n+                \"has-flag\": {\n+                    \"version\": \"4.0.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz\",\n+                    \"integrity\": \"sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==\",\n+                    \"dev\": true\n+                },\n+                \"semver\": {\n+                    \"version\": \"7.3.2\",\n+                    \"resolved\": \"https://registry.npmjs.org/semver/-/semver-7.3.2.tgz\",\n+                    \"integrity\": \"sha512-OrOb32TeeambH6UrhtShmF7CRDqhL6/5XpPNp2DuRH6+9QLw/orhp72j87v8Qa1ScDkvrrBNpZcDejAirJmfXQ==\",\n                     \"dev\": true\n+                },\n+                \"supports-color\": {\n+                    \"version\": \"7.1.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/supports-color/-/supports-color-7.1.0.tgz\",\n+                    \"integrity\": \"sha512-oRSIpR8pxT1Wr2FquTNnGet79b3BWljqOuoW/h4oBhxJ/HUbX5nX6JSruTkvXDCFMwDPvsaTTbvMLKZWSy0R5g==\",\n+                    \"dev\": true,\n+                    \"requires\": {\n+                        \"has-flag\": \"^4.0.0\"\n+                    }\n                 }\n             }\n         },\n@@ -632,9 +894,9 @@\n             }\n         },\n         \"eslint-utils\": {\n-            \"version\": \"1.4.3\",\n-            \"resolved\": \"https://registry.npmjs.org/eslint-utils/-/eslint-utils-1.4.3.tgz\",\n-            \"integrity\": \"sha512-fbBN5W2xdY45KulGXmLHZ3c3FHfVYmKg0IrAKGOkT/464PQsx2UeIzfz1RmEci+KLm1bBaAzZAh8+/E+XAeZ8Q==\",\n+            \"version\": \"2.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/eslint-utils/-/eslint-utils-2.0.0.tgz\",\n+            \"integrity\": \"sha512-0HCPuJv+7Wv1bACm8y5/ECVfYdfsAm9xmVb7saeFlxjPYALefjhbYoCkBjPdPzGH8wWyTpAez82Fh3VKYEZ8OA==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"eslint-visitor-keys\": \"^1.1.0\"\n@@ -647,9 +909,9 @@\n             \"dev\": true\n         },\n         \"espree\": {\n-            \"version\": \"6.2.1\",\n-            \"resolved\": \"https://registry.npmjs.org/espree/-/espree-6.2.1.tgz\",\n-            \"integrity\": \"sha512-ysCxRQY3WaXJz9tdbWOwuWr5Y/XrPTGX9Kiz3yoUXwW0VZ4w30HTkQLaGx/+ttFjF8i+ACbArnB4ce68a9m5hw==\",\n+            \"version\": \"7.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/espree/-/espree-7.0.0.tgz\",\n+            \"integrity\": \"sha512-/r2XEx5Mw4pgKdyb7GNLQNsu++asx/dltf/CI8RFi9oGHxmQFgvLbc5Op4U6i8Oaj+kdslhJtVlEZeAqH5qOTw==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"acorn\": \"^7.1.1\",\n@@ -664,12 +926,20 @@\n             \"dev\": true\n         },\n         \"esquery\": {\n-            \"version\": \"1.1.0\",\n-            \"resolved\": \"https://registry.npmjs.org/esquery/-/esquery-1.1.0.tgz\",\n-            \"integrity\": \"sha512-MxYW9xKmROWF672KqjO75sszsA8Mxhw06YFeS5VHlB98KDHbOSurm3ArsjO60Eaf3QmGMCP1yn+0JQkNLo/97Q==\",\n+            \"version\": \"1.3.1\",\n+            \"resolved\": \"https://registry.npmjs.org/esquery/-/esquery-1.3.1.tgz\",\n+            \"integrity\": \"sha512-olpvt9QG0vniUBZspVRN6lwB7hOZoTRtT+jzR+tS4ffYx2mzbw+z0XCOk44aaLYKApNX5nMm+E+P6o25ip/DHQ==\",\n             \"dev\": true,\n             \"requires\": {\n-                \"estraverse\": \"^4.0.0\"\n+                \"estraverse\": \"^5.1.0\"\n+            },\n+            \"dependencies\": {\n+                \"estraverse\": {\n+                    \"version\": \"5.1.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/estraverse/-/estraverse-5.1.0.tgz\",\n+                    \"integrity\": \"sha512-FyohXK+R0vE+y1nHLoBM7ZTyqRpqAlhdZHCWIWEviFLiGB8b04H6bQs8G+XTthacvT8VuwvteiP7RJSxMs8UEw==\",\n+                    \"dev\": true\n+                }\n             }\n         },\n         \"esrecurse\": {\n@@ -764,6 +1034,24 @@\n                 \"to-regex-range\": \"^5.0.1\"\n             }\n         },\n+        \"find-up\": {\n+            \"version\": \"3.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/find-up/-/find-up-3.0.0.tgz\",\n+            \"integrity\": \"sha512-1yD6RmLI1XBfxugvORwlck6f75tYL+iR0jqwsOrOxMZyGYqUuDhJ0l4AXdO1iX/FTs9cBAMEk1gWSEx1kSbylg==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"locate-path\": \"^3.0.0\"\n+            }\n+        },\n+        \"flat\": {\n+            \"version\": \"4.1.0\",\n+            \"resolved\": \"https://registry.npmjs.org/flat/-/flat-4.1.0.tgz\",\n+            \"integrity\": \"sha512-Px/TiLIznH7gEDlPXcUD4KnBusa6kR6ayRUVcnEAbreRIuhkqow/mun59BuRXwoYk7ZQOLW1ZM05ilIvK38hFw==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"is-buffer\": \"~2.0.3\"\n+            }\n+        },\n         \"flat-cache\": {\n             \"version\": \"2.0.1\",\n             \"resolved\": \"https://registry.npmjs.org/flat-cache/-/flat-cache-2.0.1.tgz\",\n@@ -776,9 +1064,9 @@\n             }\n         },\n         \"flatted\": {\n-            \"version\": \"2.0.1\",\n-            \"resolved\": \"https://registry.npmjs.org/flatted/-/flatted-2.0.1.tgz\",\n-            \"integrity\": \"sha512-a1hQMktqW9Nmqr5aktAux3JMNqaucxGcjtjWnZLHX7yyPCmlSV3M54nGYbqT8K+0GhF3NBgmJCc3ma+WOgX8Jg==\",\n+            \"version\": \"2.0.2\",\n+            \"resolved\": \"https://registry.npmjs.org/flatted/-/flatted-2.0.2.tgz\",\n+            \"integrity\": \"sha512-r5wGx7YeOwNWNlCA0wQ86zKyDLMQr+/RB8xy74M4hTphfmjlijTSSXGuH8rnvKZnfT9i+75zmd8jcKdMR4O6jA==\",\n             \"dev\": true\n         },\n         \"form-data\": {\n@@ -805,12 +1093,24 @@\n             \"dev\": true,\n             \"optional\": true\n         },\n+        \"function-bind\": {\n+            \"version\": \"1.1.1\",\n+            \"resolved\": \"https://registry.npmjs.org/function-bind/-/function-bind-1.1.1.tgz\",\n+            \"integrity\": \"sha512-yIovAzMX49sF8Yl58fSCWJ5svSLuaibPxXQJFLmBObTuCr0Mf1KiPopGM9NiFjiYBCbfaa2Fh6breQ6ANVTI0A==\",\n+            \"dev\": true\n+        },\n         \"functional-red-black-tree\": {\n             \"version\": \"1.0.1\",\n             \"resolved\": \"https://registry.npmjs.org/functional-red-black-tree/-/functional-red-black-tree-1.0.1.tgz\",\n             \"integrity\": \"sha1-GwqzvVU7Kg1jmdKcDj6gslIHgyc=\",\n             \"dev\": true\n         },\n+        \"get-caller-file\": {\n+            \"version\": \"2.0.5\",\n+            \"resolved\": \"https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz\",\n+            \"integrity\": \"sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==\",\n+            \"dev\": true\n+        },\n         \"glob\": {\n             \"version\": \"7.1.6\",\n             \"resolved\": \"https://registry.npmjs.org/glob/-/glob-7.1.6.tgz\",\n@@ -826,9 +1126,9 @@\n             }\n         },\n         \"glob-parent\": {\n-            \"version\": \"5.1.0\",\n-            \"resolved\": \"https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.0.tgz\",\n-            \"integrity\": \"sha512-qjtRgnIVmOfnKUE3NJAQEdk+lKrxfw8t5ke7SXtfMTHcjsBfOfWXCQfdb30zfDoZQ2IRSIiidmjtbHZPZ++Ihw==\",\n+            \"version\": \"5.1.1\",\n+            \"resolved\": \"https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.1.tgz\",\n+            \"integrity\": \"sha512-FnI+VGOpnlGHWZxthPGR+QhR78fuiK0sNLkHQv+bL9fQi57lNNdquIbna/WrfROrolq8GK5Ek6BiMwqL/voRYQ==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"is-glob\": \"^4.0.1\"\n@@ -843,12 +1143,39 @@\n                 \"type-fest\": \"^0.8.1\"\n             }\n         },\n+        \"growl\": {\n+            \"version\": \"1.10.5\",\n+            \"resolved\": \"https://registry.npmjs.org/growl/-/growl-1.10.5.tgz\",\n+            \"integrity\": \"sha512-qBr4OuELkhPenW6goKVXiv47US3clb3/IbuWF9KNKEijAy9oeHxU9IgzjvJhHkUzhaj7rOUD7+YGWqUjLp5oSA==\",\n+            \"dev\": true\n+        },\n+        \"has\": {\n+            \"version\": \"1.0.3\",\n+            \"resolved\": \"https://registry.npmjs.org/has/-/has-1.0.3.tgz\",\n+            \"integrity\": \"sha512-f2dvO0VU6Oej7RkWJGrehjbzMAjFp5/VKPp5tTpWIV4JHHZK1/BxbFRtf/siA2SWTe09caDmVtYYzWEIbBS4zw==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"function-bind\": \"^1.1.1\"\n+            }\n+        },\n         \"has-flag\": {\n             \"version\": \"3.0.0\",\n             \"resolved\": \"https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz\",\n             \"integrity\": \"sha1-tdRU3CGZriJWmfNGfloH87lVuv0=\",\n             \"dev\": true\n         },\n+        \"has-symbols\": {\n+            \"version\": \"1.0.1\",\n+            \"resolved\": \"https://registry.npmjs.org/has-symbols/-/has-symbols-1.0.1.tgz\",\n+            \"integrity\": \"sha512-PLcsoqu++dmEIZB+6totNFKq/7Do+Z0u4oT0zKOJNl3lYK6vGwwu2hjHs+68OEZbTjiUE9bgOABXbP/GvrS0Kg==\",\n+            \"dev\": true\n+        },\n+        \"he\": {\n+            \"version\": \"1.2.0\",\n+            \"resolved\": \"https://registry.npmjs.org/he/-/he-1.2.0.tgz\",\n+            \"integrity\": \"sha512-F/1DnUGPopORZi0ni+CvrCgHQ5FyEAHRLSApuYWMmrbSwoN2Mn/7k+Gl38gJnR7yyDZk6WLXwiGod1JOWNDKGw==\",\n+            \"dev\": true\n+        },\n         \"htmlparser2\": {\n             \"version\": \"3.10.1\",\n             \"resolved\": \"https://registry.npmjs.org/htmlparser2/-/htmlparser2-3.10.1.tgz\",\n@@ -863,16 +1190,64 @@\n                 \"readable-stream\": \"^3.1.1\"\n             }\n         },\n-        \"iconv-lite\": {\n-            \"version\": \"0.4.24\",\n-            \"resolved\": \"https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz\",\n-            \"integrity\": \"sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==\",\n+        \"http-proxy-agent\": {\n+            \"version\": \"2.1.0\",\n+            \"resolved\": \"https://registry.npmjs.org/http-proxy-agent/-/http-proxy-agent-2.1.0.tgz\",\n+            \"integrity\": \"sha512-qwHbBLV7WviBl0rQsOzH6o5lwyOIvwp/BdFnvVxXORldu5TmjFfjzBcWUWS5kWAZhmv+JtiDhSuQCp4sBfbIgg==\",\n             \"dev\": true,\n             \"requires\": {\n-                \"safer-buffer\": \">= 2.1.2 < 3\"\n+                \"agent-base\": \"4\",\n+                \"debug\": \"3.1.0\"\n+            },\n+            \"dependencies\": {\n+                \"debug\": {\n+                    \"version\": \"3.1.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/debug/-/debug-3.1.0.tgz\",\n+                    \"integrity\": \"sha512-OX8XqP7/1a9cqkxYw2yXss15f26NKWBpDXQd0/uK/KPqdQhxbPa994hnzjcE2VqQpDslf55723cKPUOGSmMY3g==\",\n+                    \"dev\": true,\n+                    \"requires\": {\n+                        \"ms\": \"2.0.0\"\n+                    }\n+                },\n+                \"ms\": {\n+                    \"version\": \"2.0.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/ms/-/ms-2.0.0.tgz\",\n+                    \"integrity\": \"sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=\",\n+                    \"dev\": true\n+                }\n             }\n         },\n-        \"ignore\": {\n+        \"https-proxy-agent\": {\n+            \"version\": \"2.2.4\",\n+            \"resolved\": \"https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-2.2.4.tgz\",\n+            \"integrity\": \"sha512-OmvfoQ53WLjtA9HeYP9RNrWMJzzAz1JGaSFr1nijg0PVR1JaD/xbJq1mdEIIlxGpXp9eSe/O2LgU9DJmTPd0Eg==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"agent-base\": \"^4.3.0\",\n+                \"debug\": \"^3.1.0\"\n+            },\n+            \"dependencies\": {\n+                \"debug\": {\n+                    \"version\": \"3.2.6\",\n+                    \"resolved\": \"https://registry.npmjs.org/debug/-/debug-3.2.6.tgz\",\n+                    \"integrity\": \"sha512-mel+jf7nrtEl5Pn1Qx46zARXKDpBbvzezse7p7LqINmdoIk8PYP5SySaxEmYv6TZ0JyEKA1hsCId6DIhgITtWQ==\",\n+                    \"dev\": true,\n+                    \"requires\": {\n+                        \"ms\": \"^2.1.1\"\n+                    }\n+                }\n+            }\n+        },\n+        \"iconv-lite\": {\n+            \"version\": \"0.4.24\",\n+            \"resolved\": \"https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz\",\n+            \"integrity\": \"sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"safer-buffer\": \">= 2.1.2 < 3\"\n+            }\n+        },\n+        \"ignore\": {\n             \"version\": \"4.0.6\",\n             \"resolved\": \"https://registry.npmjs.org/ignore/-/ignore-4.0.6.tgz\",\n             \"integrity\": \"sha512-cyFDKrqc/YdcWFniJhzI42+AzS+gNwmUzOSFcRCQYwySuBBBy/KjuxWLZ/FHEH6Moq1NizMOBWyTcv8O4OZIMg==\",\n@@ -972,15 +1347,6 @@\n                     \"integrity\": \"sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==\",\n                     \"dev\": true\n                 },\n-                \"strip-ansi\": {\n-                    \"version\": \"6.0.0\",\n-                    \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.0.tgz\",\n-                    \"integrity\": \"sha512-AuvKTrTfQNYNIctbR1K/YGTR1756GycPsg7b9bdV9Duqur4gv6aKqHXah67Z8ImS7WEz5QVcOtlfW2rZEugt6w==\",\n-                    \"dev\": true,\n-                    \"requires\": {\n-                        \"ansi-regex\": \"^5.0.0\"\n-                    }\n-                },\n                 \"supports-color\": {\n                     \"version\": \"7.1.0\",\n                     \"resolved\": \"https://registry.npmjs.org/supports-color/-/supports-color-7.1.0.tgz\",\n@@ -992,6 +1358,33 @@\n                 }\n             }\n         },\n+        \"is-binary-path\": {\n+            \"version\": \"2.1.0\",\n+            \"resolved\": \"https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz\",\n+            \"integrity\": \"sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"binary-extensions\": \"^2.0.0\"\n+            }\n+        },\n+        \"is-buffer\": {\n+            \"version\": \"2.0.4\",\n+            \"resolved\": \"https://registry.npmjs.org/is-buffer/-/is-buffer-2.0.4.tgz\",\n+            \"integrity\": \"sha512-Kq1rokWXOPXWuaMAqZiJW4XxsmD9zGx9q4aePabbn3qCRGedtH7Cm+zV8WETitMfu1wdh+Rvd6w5egwSngUX2A==\",\n+            \"dev\": true\n+        },\n+        \"is-callable\": {\n+            \"version\": \"1.1.5\",\n+            \"resolved\": \"https://registry.npmjs.org/is-callable/-/is-callable-1.1.5.tgz\",\n+            \"integrity\": \"sha512-ESKv5sMCJB2jnHTWZ3O5itG+O128Hsus4K4Qh1h2/cgn2vbgnLSVqfV46AeJA9D5EeeLa9w81KUXMtn34zhX+Q==\",\n+            \"dev\": true\n+        },\n+        \"is-date-object\": {\n+            \"version\": \"1.0.2\",\n+            \"resolved\": \"https://registry.npmjs.org/is-date-object/-/is-date-object-1.0.2.tgz\",\n+            \"integrity\": \"sha512-USlDT524woQ08aoZFzh3/Z6ch9Y/EWXEHQ/AaRN0SkKq4t2Jw2R2339tSXmwuVoY7LLlBCbOIlx2myP/L5zk0g==\",\n+            \"dev\": true\n+        },\n         \"is-extglob\": {\n             \"version\": \"2.1.1\",\n             \"resolved\": \"https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz\",\n@@ -1025,12 +1418,6 @@\n             \"integrity\": \"sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==\",\n             \"dev\": true\n         },\n-        \"is-promise\": {\n-            \"version\": \"2.1.0\",\n-            \"resolved\": \"https://registry.npmjs.org/is-promise/-/is-promise-2.1.0.tgz\",\n-            \"integrity\": \"sha1-eaKp7OfwlugPNtKy87wWwf9L8/o=\",\n-            \"dev\": true\n-        },\n         \"is-reference\": {\n             \"version\": \"1.1.4\",\n             \"resolved\": \"https://registry.npmjs.org/is-reference/-/is-reference-1.1.4.tgz\",\n@@ -1040,6 +1427,24 @@\n                 \"@types/estree\": \"0.0.39\"\n             }\n         },\n+        \"is-regex\": {\n+            \"version\": \"1.0.5\",\n+            \"resolved\": \"https://registry.npmjs.org/is-regex/-/is-regex-1.0.5.tgz\",\n+            \"integrity\": \"sha512-vlKW17SNq44owv5AQR3Cq0bQPEb8+kF3UKZ2fiZNOWtztYE5i0CzCZxFDwO58qAOWtxdBRVO/V5Qin1wjCqFYQ==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"has\": \"^1.0.3\"\n+            }\n+        },\n+        \"is-symbol\": {\n+            \"version\": \"1.0.3\",\n+            \"resolved\": \"https://registry.npmjs.org/is-symbol/-/is-symbol-1.0.3.tgz\",\n+            \"integrity\": \"sha512-OwijhaRSgqvhm/0ZdAcXNZt9lYdKFpcRDT5ULUuYXPoT794UNOdU+gpT6Rzo7b4V2HUl/op6GqY894AZwv9faQ==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"has-symbols\": \"^1.0.1\"\n+            }\n+        },\n         \"isexe\": {\n             \"version\": \"2.0.0\",\n             \"resolved\": \"https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz\",\n@@ -1053,9 +1458,9 @@\n             \"dev\": true\n         },\n         \"js-yaml\": {\n-            \"version\": \"3.13.1\",\n-            \"resolved\": \"https://registry.npmjs.org/js-yaml/-/js-yaml-3.13.1.tgz\",\n-            \"integrity\": \"sha512-YfbcO7jXDdyj0DGxYVSlSeQNHbD7XPWvrVWeVUujrQEoZzWJIRrCPoyk6kL6IAjAG2IolMK4T0hNUe0HOUs5Jw==\",\n+            \"version\": \"3.14.0\",\n+            \"resolved\": \"https://registry.npmjs.org/js-yaml/-/js-yaml-3.14.0.tgz\",\n+            \"integrity\": \"sha512-/4IbIeHcD9VMHFqDR/gQ7EdZdLimOvW2DdcxFjdyyZ9NsbS+ccrXqVWDtab/lRl5AlUqmpBx8EhPaWR+OtY17A==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"argparse\": \"^1.0.7\",\n@@ -1081,13 +1486,13 @@\n             \"dev\": true\n         },\n         \"levn\": {\n-            \"version\": \"0.3.0\",\n-            \"resolved\": \"https://registry.npmjs.org/levn/-/levn-0.3.0.tgz\",\n-            \"integrity\": \"sha1-OwmSTt+fCDwEkP3UwLxEIeBHZO4=\",\n+            \"version\": \"0.4.1\",\n+            \"resolved\": \"https://registry.npmjs.org/levn/-/levn-0.4.1.tgz\",\n+            \"integrity\": \"sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==\",\n             \"dev\": true,\n             \"requires\": {\n-                \"prelude-ls\": \"~1.1.2\",\n-                \"type-check\": \"~0.3.2\"\n+                \"prelude-ls\": \"^1.2.1\",\n+                \"type-check\": \"~0.4.0\"\n             }\n         },\n         \"linkify-it\": {\n@@ -1099,12 +1504,31 @@\n                 \"uc.micro\": \"^1.0.1\"\n             }\n         },\n+        \"locate-path\": {\n+            \"version\": \"3.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/locate-path/-/locate-path-3.0.0.tgz\",\n+            \"integrity\": \"sha512-7AO748wWnIhNqAuaty2ZWHkQHRSNfPVIsPIfwEOWO22AmaoVrWavlOcMR5nzTLNYvp36X220/maaRsrec1G65A==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"p-locate\": \"^3.0.0\",\n+                \"path-exists\": \"^3.0.0\"\n+            }\n+        },\n         \"lodash\": {\n             \"version\": \"4.17.15\",\n             \"resolved\": \"https://registry.npmjs.org/lodash/-/lodash-4.17.15.tgz\",\n             \"integrity\": \"sha512-8xOcRHvCjnocdS5cpwXQXVzmmh5e5+saE2QGoeQmbKmRS6J3VQppPOIt0MnmE+4xlZoumy0GPG0D0MVIQbNA1A==\",\n             \"dev\": true\n         },\n+        \"log-symbols\": {\n+            \"version\": \"3.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/log-symbols/-/log-symbols-3.0.0.tgz\",\n+            \"integrity\": \"sha512-dSkNGuI7iG3mfvDzUuYZyvk5dD9ocYCYzNU6CYDE6+Xqd+gwme6Z00NS3dUh8mq/73HaEtT7m6W+yUPtU6BZnQ==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"chalk\": \"^2.4.2\"\n+            }\n+        },\n         \"lru-cache\": {\n             \"version\": \"4.1.5\",\n             \"resolved\": \"https://registry.npmjs.org/lru-cache/-/lru-cache-4.1.5.tgz\",\n@@ -1151,16 +1575,6 @@\n             \"integrity\": \"sha1-/oWy7HWlkDfyrf7BAP1sYBdhFS4=\",\n             \"dev\": true\n         },\n-        \"micromatch\": {\n-            \"version\": \"4.0.2\",\n-            \"resolved\": \"https://registry.npmjs.org/micromatch/-/micromatch-4.0.2.tgz\",\n-            \"integrity\": \"sha512-y7FpHSbMUMoyPbYUSzO6PaZ6FyRnQOpHuKwbo1G+Knck95XVU4QAiKdGEnj5wwoS7PlOgthX/09u5iFJ+aYf5Q==\",\n-            \"dev\": true,\n-            \"requires\": {\n-                \"braces\": \"^3.0.1\",\n-                \"picomatch\": \"^2.0.5\"\n-            }\n-        },\n         \"mime\": {\n             \"version\": \"1.6.0\",\n             \"resolved\": \"https://registry.npmjs.org/mime/-/mime-1.6.0.tgz\",\n@@ -1204,14 +1618,111 @@\n             \"dev\": true\n         },\n         \"mkdirp\": {\n-            \"version\": \"0.5.3\",\n-            \"resolved\": \"https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.3.tgz\",\n-            \"integrity\": \"sha512-P+2gwrFqx8lhew375MQHHeTlY8AuOJSrGf0R5ddkEndUkmwpgUob/vQuBD1V22/Cw1/lJr4x+EjllSezBThzBg==\",\n+            \"version\": \"0.5.5\",\n+            \"resolved\": \"https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.5.tgz\",\n+            \"integrity\": \"sha512-NKmAlESf6jMGym1++R0Ra7wvhV+wFW63FaSOFPwRahvea0gMUcGUhVeAg/0BC0wiv9ih5NYPB1Wn1UEI1/L+xQ==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"minimist\": \"^1.2.5\"\n             }\n         },\n+        \"mocha\": {\n+            \"version\": \"7.2.0\",\n+            \"resolved\": \"https://registry.npmjs.org/mocha/-/mocha-7.2.0.tgz\",\n+            \"integrity\": \"sha512-O9CIypScywTVpNaRrCAgoUnJgozpIofjKUYmJhiCIJMiuYnLI6otcb1/kpW9/n/tJODHGZ7i8aLQoDVsMtOKQQ==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"ansi-colors\": \"3.2.3\",\n+                \"browser-stdout\": \"1.3.1\",\n+                \"chokidar\": \"3.3.0\",\n+                \"debug\": \"3.2.6\",\n+                \"diff\": \"3.5.0\",\n+                \"escape-string-regexp\": \"1.0.5\",\n+                \"find-up\": \"3.0.0\",\n+                \"glob\": \"7.1.3\",\n+                \"growl\": \"1.10.5\",\n+                \"he\": \"1.2.0\",\n+                \"js-yaml\": \"3.13.1\",\n+                \"log-symbols\": \"3.0.0\",\n+                \"minimatch\": \"3.0.4\",\n+                \"mkdirp\": \"0.5.5\",\n+                \"ms\": \"2.1.1\",\n+                \"node-environment-flags\": \"1.0.6\",\n+                \"object.assign\": \"4.1.0\",\n+                \"strip-json-comments\": \"2.0.1\",\n+                \"supports-color\": \"6.0.0\",\n+                \"which\": \"1.3.1\",\n+                \"wide-align\": \"1.1.3\",\n+                \"yargs\": \"13.3.2\",\n+                \"yargs-parser\": \"13.1.2\",\n+                \"yargs-unparser\": \"1.6.0\"\n+            },\n+            \"dependencies\": {\n+                \"debug\": {\n+                    \"version\": \"3.2.6\",\n+                    \"resolved\": \"https://registry.npmjs.org/debug/-/debug-3.2.6.tgz\",\n+                    \"integrity\": \"sha512-mel+jf7nrtEl5Pn1Qx46zARXKDpBbvzezse7p7LqINmdoIk8PYP5SySaxEmYv6TZ0JyEKA1hsCId6DIhgITtWQ==\",\n+                    \"dev\": true,\n+                    \"requires\": {\n+                        \"ms\": \"^2.1.1\"\n+                    }\n+                },\n+                \"glob\": {\n+                    \"version\": \"7.1.3\",\n+                    \"resolved\": \"https://registry.npmjs.org/glob/-/glob-7.1.3.tgz\",\n+                    \"integrity\": \"sha512-vcfuiIxogLV4DlGBHIUOwI0IbrJ8HWPc4MU7HzviGeNho/UJDfi6B5p3sHeWIQ0KGIU0Jpxi5ZHxemQfLkkAwQ==\",\n+                    \"dev\": true,\n+                    \"requires\": {\n+                        \"fs.realpath\": \"^1.0.0\",\n+                        \"inflight\": \"^1.0.4\",\n+                        \"inherits\": \"2\",\n+                        \"minimatch\": \"^3.0.4\",\n+                        \"once\": \"^1.3.0\",\n+                        \"path-is-absolute\": \"^1.0.0\"\n+                    }\n+                },\n+                \"js-yaml\": {\n+                    \"version\": \"3.13.1\",\n+                    \"resolved\": \"https://registry.npmjs.org/js-yaml/-/js-yaml-3.13.1.tgz\",\n+                    \"integrity\": \"sha512-YfbcO7jXDdyj0DGxYVSlSeQNHbD7XPWvrVWeVUujrQEoZzWJIRrCPoyk6kL6IAjAG2IolMK4T0hNUe0HOUs5Jw==\",\n+                    \"dev\": true,\n+                    \"requires\": {\n+                        \"argparse\": \"^1.0.7\",\n+                        \"esprima\": \"^4.0.0\"\n+                    }\n+                },\n+                \"ms\": {\n+                    \"version\": \"2.1.1\",\n+                    \"resolved\": \"https://registry.npmjs.org/ms/-/ms-2.1.1.tgz\",\n+                    \"integrity\": \"sha512-tgp+dl5cGk28utYktBsrFqA7HKgrhgPsg6Z/EfhWI4gl1Hwq8B/GmY/0oXZ6nF8hDVesS/FpnYaD/kOWhYQvyg==\",\n+                    \"dev\": true\n+                },\n+                \"strip-json-comments\": {\n+                    \"version\": \"2.0.1\",\n+                    \"resolved\": \"https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-2.0.1.tgz\",\n+                    \"integrity\": \"sha1-PFMZQukIwml8DsNEhYwobHygpgo=\",\n+                    \"dev\": true\n+                },\n+                \"supports-color\": {\n+                    \"version\": \"6.0.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/supports-color/-/supports-color-6.0.0.tgz\",\n+                    \"integrity\": \"sha512-on9Kwidc1IUQo+bQdhi8+Tijpo0e1SS6RoGo2guUwn5vdaxw8RXOF9Vb2ws+ihWOmh4JnCJOvaziZWP1VABaLg==\",\n+                    \"dev\": true,\n+                    \"requires\": {\n+                        \"has-flag\": \"^3.0.0\"\n+                    }\n+                },\n+                \"which\": {\n+                    \"version\": \"1.3.1\",\n+                    \"resolved\": \"https://registry.npmjs.org/which/-/which-1.3.1.tgz\",\n+                    \"integrity\": \"sha512-HxJdYWq1MTIQbJ3nw0cqssHoTNU267KlrDuGZ1WYlxDStUtKUhOaJmh112/TZmHxxUfuJqPXSOm7tDyas0OSIQ==\",\n+                    \"dev\": true,\n+                    \"requires\": {\n+                        \"isexe\": \"^2.0.0\"\n+                    }\n+                }\n+            }\n+        },\n         \"ms\": {\n             \"version\": \"2.1.2\",\n             \"resolved\": \"https://registry.npmjs.org/ms/-/ms-2.1.2.tgz\",\n@@ -1230,17 +1741,35 @@\n             \"integrity\": \"sha1-Sr6/7tdUHywnrPspvbvRXI1bpPc=\",\n             \"dev\": true\n         },\n-        \"nice-try\": {\n-            \"version\": \"1.0.5\",\n-            \"resolved\": \"https://registry.npmjs.org/nice-try/-/nice-try-1.0.5.tgz\",\n-            \"integrity\": \"sha512-1nh45deeb5olNY7eX82BkPO7SSxR5SSYJiPTrTdFUVYwAl8CKMA5N9PjTYkHiRjisVcxcQ1HXdLhx2qxxJzLNQ==\",\n-            \"dev\": true\n+        \"node-environment-flags\": {\n+            \"version\": \"1.0.6\",\n+            \"resolved\": \"https://registry.npmjs.org/node-environment-flags/-/node-environment-flags-1.0.6.tgz\",\n+            \"integrity\": \"sha512-5Evy2epuL+6TM0lCQGpFIj6KwiEsGh1SrHUhTbNX+sLbBtjidPZFAnVK9y5yU1+h//RitLbRHTIMyxQPtxMdHw==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"object.getownpropertydescriptors\": \"^2.0.3\",\n+                \"semver\": \"^5.7.0\"\n+            },\n+            \"dependencies\": {\n+                \"semver\": {\n+                    \"version\": \"5.7.1\",\n+                    \"resolved\": \"https://registry.npmjs.org/semver/-/semver-5.7.1.tgz\",\n+                    \"integrity\": \"sha512-sauaDf/PZdVgrLTNYHRtpXa1iRiKcaebiKQ1BJdpQlWH2lCvexQdX55snPFyK7QzpudqbCI0qXFfOasHdyNDGQ==\",\n+                    \"dev\": true\n+                }\n+            }\n         },\n         \"node-fetch\": {\n             \"version\": \"2.6.0\",\n             \"resolved\": \"https://registry.npmjs.org/node-fetch/-/node-fetch-2.6.0.tgz\",\n             \"integrity\": \"sha512-8dG4H5ujfvFiqDmVu9fQ5bOHUC15JMjMY/Zumv26oOvvVJjM67KF8koCWIabKQ1GJIa9r2mMZscBq/TbdOcmNA==\"\n         },\n+        \"normalize-path\": {\n+            \"version\": \"3.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz\",\n+            \"integrity\": \"sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==\",\n+            \"dev\": true\n+        },\n         \"nth-check\": {\n             \"version\": \"1.0.2\",\n             \"resolved\": \"https://registry.npmjs.org/nth-check/-/nth-check-1.0.2.tgz\",\n@@ -1250,6 +1779,40 @@\n                 \"boolbase\": \"~1.0.0\"\n             }\n         },\n+        \"object-inspect\": {\n+            \"version\": \"1.7.0\",\n+            \"resolved\": \"https://registry.npmjs.org/object-inspect/-/object-inspect-1.7.0.tgz\",\n+            \"integrity\": \"sha512-a7pEHdh1xKIAgTySUGgLMx/xwDZskN1Ud6egYYN3EdRW4ZMPNEDUTF+hwy2LUC+Bl+SyLXANnwz/jyh/qutKUw==\",\n+            \"dev\": true\n+        },\n+        \"object-keys\": {\n+            \"version\": \"1.1.1\",\n+            \"resolved\": \"https://registry.npmjs.org/object-keys/-/object-keys-1.1.1.tgz\",\n+            \"integrity\": \"sha512-NuAESUOUMrlIXOfHKzD6bpPu3tYt3xvjNdRIQ+FeT0lNb4K8WR70CaDxhuNguS2XG+GjkyMwOzsN5ZktImfhLA==\",\n+            \"dev\": true\n+        },\n+        \"object.assign\": {\n+            \"version\": \"4.1.0\",\n+            \"resolved\": \"https://registry.npmjs.org/object.assign/-/object.assign-4.1.0.tgz\",\n+            \"integrity\": \"sha512-exHJeq6kBKj58mqGyTQ9DFvrZC/eR6OwxzoM9YRoGBqrXYonaFyGiFMuc9VZrXf7DarreEwMpurG3dd+CNyW5w==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"define-properties\": \"^1.1.2\",\n+                \"function-bind\": \"^1.1.1\",\n+                \"has-symbols\": \"^1.0.0\",\n+                \"object-keys\": \"^1.0.11\"\n+            }\n+        },\n+        \"object.getownpropertydescriptors\": {\n+            \"version\": \"2.1.0\",\n+            \"resolved\": \"https://registry.npmjs.org/object.getownpropertydescriptors/-/object.getownpropertydescriptors-2.1.0.tgz\",\n+            \"integrity\": \"sha512-Z53Oah9A3TdLoblT7VKJaTDdXdT+lQO+cNpKVnya5JDe9uLvzu1YyY1yFDFrcxrlRgWrEFH0jJtD/IbuwjcEVg==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"define-properties\": \"^1.1.3\",\n+                \"es-abstract\": \"^1.17.0-next.1\"\n+            }\n+        },\n         \"once\": {\n             \"version\": \"1.4.0\",\n             \"resolved\": \"https://registry.npmjs.org/once/-/once-1.4.0.tgz\",\n@@ -1269,17 +1832,17 @@\n             }\n         },\n         \"optionator\": {\n-            \"version\": \"0.8.3\",\n-            \"resolved\": \"https://registry.npmjs.org/optionator/-/optionator-0.8.3.tgz\",\n-            \"integrity\": \"sha512-+IW9pACdk3XWmmTXG8m3upGUJst5XRGzxMRjXzAuJ1XnIFNvfhjjIuYkDvysnPQ7qzqVzLt78BCruntqRhWQbA==\",\n+            \"version\": \"0.9.1\",\n+            \"resolved\": \"https://registry.npmjs.org/optionator/-/optionator-0.9.1.tgz\",\n+            \"integrity\": \"sha512-74RlY5FCnhq4jRxVUPKDaRwrVNXMqsGsiW6AJw4XK8hmtm10wC0ypZBLw5IIp85NZMr91+qd1RvvENwg7jjRFw==\",\n             \"dev\": true,\n             \"requires\": {\n-                \"deep-is\": \"~0.1.3\",\n-                \"fast-levenshtein\": \"~2.0.6\",\n-                \"levn\": \"~0.3.0\",\n-                \"prelude-ls\": \"~1.1.2\",\n-                \"type-check\": \"~0.3.2\",\n-                \"word-wrap\": \"~1.2.3\"\n+                \"deep-is\": \"^0.1.3\",\n+                \"fast-levenshtein\": \"^2.0.6\",\n+                \"levn\": \"^0.4.1\",\n+                \"prelude-ls\": \"^1.2.1\",\n+                \"type-check\": \"^0.4.0\",\n+                \"word-wrap\": \"^1.2.3\"\n             }\n         },\n         \"os\": {\n@@ -1310,6 +1873,30 @@\n                 \"os-tmpdir\": \"^1.0.0\"\n             }\n         },\n+        \"p-limit\": {\n+            \"version\": \"2.3.0\",\n+            \"resolved\": \"https://registry.npmjs.org/p-limit/-/p-limit-2.3.0.tgz\",\n+            \"integrity\": \"sha512-//88mFWSJx8lxCzwdAABTJL2MyWB12+eIY7MDL2SqLmAkeKU9qxRvWuSyTjm3FUmpBEMuFfckAIqEaVGUDxb6w==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"p-try\": \"^2.0.0\"\n+            }\n+        },\n+        \"p-locate\": {\n+            \"version\": \"3.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/p-locate/-/p-locate-3.0.0.tgz\",\n+            \"integrity\": \"sha512-x+12w/To+4GFfgJhBEpiDcLozRJGegY+Ei7/z0tSLkMmxGZNybVMSfWj9aJn8Z5Fc7dBUNJOOVgPv2H7IwulSQ==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"p-limit\": \"^2.0.0\"\n+            }\n+        },\n+        \"p-try\": {\n+            \"version\": \"2.2.0\",\n+            \"resolved\": \"https://registry.npmjs.org/p-try/-/p-try-2.2.0.tgz\",\n+            \"integrity\": \"sha512-R4nPAVTAU0B9D35/Gk3uJf/7XYbQcyohSKdvAxIRSNghFl4e71hVoGnBNQz9cWaXxO2I10KTC+3jMdvvoKw6dQ==\",\n+            \"dev\": true\n+        },\n         \"parent-module\": {\n             \"version\": \"1.0.1\",\n             \"resolved\": \"https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz\",\n@@ -1345,16 +1932,22 @@\n                 \"@types/node\": \"*\"\n             }\n         },\n+        \"path-exists\": {\n+            \"version\": \"3.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/path-exists/-/path-exists-3.0.0.tgz\",\n+            \"integrity\": \"sha1-zg6+ql94yxiSXqfYENe1mwEP1RU=\",\n+            \"dev\": true\n+        },\n         \"path-is-absolute\": {\n             \"version\": \"1.0.1\",\n             \"resolved\": \"https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz\",\n             \"integrity\": \"sha1-F0uSaHNVNP+8es5r9TpanhtcX18=\",\n             \"dev\": true\n         },\n         \"path-key\": {\n-            \"version\": \"2.0.1\",\n-            \"resolved\": \"https://registry.npmjs.org/path-key/-/path-key-2.0.1.tgz\",\n-            \"integrity\": \"sha1-QRyttXTFoUDTpLGRDUDYDMn0C0A=\",\n+            \"version\": \"3.1.1\",\n+            \"resolved\": \"https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz\",\n+            \"integrity\": \"sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==\",\n             \"dev\": true\n         },\n         \"path-parse\": {\n@@ -1376,9 +1969,9 @@\n             \"dev\": true\n         },\n         \"prelude-ls\": {\n-            \"version\": \"1.1.2\",\n-            \"resolved\": \"https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.1.2.tgz\",\n-            \"integrity\": \"sha1-IZMqVJ9eUv/ZqCf1cOBL5iqX2lQ=\",\n+            \"version\": \"1.2.1\",\n+            \"resolved\": \"https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz\",\n+            \"integrity\": \"sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==\",\n             \"dev\": true\n         },\n         \"progress\": {\n@@ -1419,16 +2012,37 @@\n                 \"util-deprecate\": \"^1.0.1\"\n             }\n         },\n+        \"readdirp\": {\n+            \"version\": \"3.2.0\",\n+            \"resolved\": \"https://registry.npmjs.org/readdirp/-/readdirp-3.2.0.tgz\",\n+            \"integrity\": \"sha512-crk4Qu3pmXwgxdSgGhgA/eXiJAPQiX4GMOZZMXnqKxHX7TaoL+3gQVo/WeuAiogr07DpnfjIMpXXa+PAIvwPGQ==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"picomatch\": \"^2.0.4\"\n+            }\n+        },\n         \"regexpp\": {\n             \"version\": \"3.1.0\",\n             \"resolved\": \"https://registry.npmjs.org/regexpp/-/regexpp-3.1.0.tgz\",\n             \"integrity\": \"sha512-ZOIzd8yVsQQA7j8GCSlPGXwg5PfmA1mrq0JP4nGhh54LaKN3xdai/vHUDu74pKwV8OxseMS65u2NImosQcSD0Q==\",\n             \"dev\": true\n         },\n+        \"require-directory\": {\n+            \"version\": \"2.1.1\",\n+            \"resolved\": \"https://registry.npmjs.org/require-directory/-/require-directory-2.1.1.tgz\",\n+            \"integrity\": \"sha1-jGStX9MNqxyXbiNE/+f3kqam30I=\",\n+            \"dev\": true\n+        },\n+        \"require-main-filename\": {\n+            \"version\": \"2.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/require-main-filename/-/require-main-filename-2.0.0.tgz\",\n+            \"integrity\": \"sha512-NKN5kMDylKuldxYLSUfrbo5Tuzh4hd+2E8NPPX02mZtn1VuREQToYe/ZdlJy+J3uCpfaiGF05e7B8W0iXbQHmg==\",\n+            \"dev\": true\n+        },\n         \"resolve\": {\n-            \"version\": \"1.16.1\",\n-            \"resolved\": \"https://registry.npmjs.org/resolve/-/resolve-1.16.1.tgz\",\n-            \"integrity\": \"sha512-rmAglCSqWWMrrBv/XM6sW0NuRFiKViw/W4d9EbC4pt+49H8JwHy+mcGmALTEg504AUDcLTvb1T2q3E9AnmY+ig==\",\n+            \"version\": \"1.17.0\",\n+            \"resolved\": \"https://registry.npmjs.org/resolve/-/resolve-1.17.0.tgz\",\n+            \"integrity\": \"sha512-ic+7JYiV8Vi2yzQGFWOkiZD5Z9z7O2Zhm9XMaTxdJExKasieFCr+yXZ/WmXsckHiKl12ar0y6XiXDx3m4RHn1w==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"path-parse\": \"^1.0.6\"\n@@ -1460,30 +2074,35 @@\n             }\n         },\n         \"rollup\": {\n-            \"version\": \"2.10.0\",\n-            \"resolved\": \"https://registry.npmjs.org/rollup/-/rollup-2.10.0.tgz\",\n-            \"integrity\": \"sha512-7BmpEfUN9P6esJzWIn3DmR//90mW6YwYB1t3y48LpF8ITpYtL8s1kEirMKqUu44dVH/6a/rs0EuwYVL3FuRDoA==\",\n+            \"version\": \"2.10.9\",\n+            \"resolved\": \"https://registry.npmjs.org/rollup/-/rollup-2.10.9.tgz\",\n+            \"integrity\": \"sha512-dY/EbjiWC17ZCUSyk14hkxATAMAShkMsD43XmZGWjLrgFj15M3Dw2kEkA9ns64BiLFm9PKN6vTQw8neHwK74eg==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"fsevents\": \"~2.1.2\"\n             }\n         },\n         \"run-async\": {\n-            \"version\": \"2.4.0\",\n-            \"resolved\": \"https://registry.npmjs.org/run-async/-/run-async-2.4.0.tgz\",\n-            \"integrity\": \"sha512-xJTbh/d7Lm7SBhc1tNvTpeCHaEzoyxPrqNlvSdMfBTYwaY++UJFyXUOxAtsRUXjlqOfj8luNaR9vjCh4KeV+pg==\",\n-            \"dev\": true,\n-            \"requires\": {\n-                \"is-promise\": \"^2.1.0\"\n-            }\n+            \"version\": \"2.4.1\",\n+            \"resolved\": \"https://registry.npmjs.org/run-async/-/run-async-2.4.1.tgz\",\n+            \"integrity\": \"sha512-tvVnVv01b8c1RrA6Ep7JkStj85Guv/YrMcwqYQnwjsAS2cTmmPGBBjAjpCW7RrSodNSoE2/qg9O4bceNvUuDgQ==\",\n+            \"dev\": true\n         },\n         \"rxjs\": {\n-            \"version\": \"6.5.4\",\n-            \"resolved\": \"https://registry.npmjs.org/rxjs/-/rxjs-6.5.4.tgz\",\n-            \"integrity\": \"sha512-naMQXcgEo3csAEGvw/NydRA0fuS2nDZJiw1YUWFKU7aPPAPGZEsD4Iimit96qwCieH6y614MCLYwdkrWx7z/7Q==\",\n+            \"version\": \"6.5.5\",\n+            \"resolved\": \"https://registry.npmjs.org/rxjs/-/rxjs-6.5.5.tgz\",\n+            \"integrity\": \"sha512-WfQI+1gohdf0Dai/Bbmk5L5ItH5tYqm3ki2c5GdWhKjalzjg93N3avFjVStyZZz+A2Em+ZxKH5bNghw9UeylGQ==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"tslib\": \"^1.9.0\"\n+            },\n+            \"dependencies\": {\n+                \"tslib\": {\n+                    \"version\": \"1.13.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/tslib/-/tslib-1.13.0.tgz\",\n+                    \"integrity\": \"sha512-i/6DQjL8Xf3be4K/E6Wgpekn5Qasl1usyw++dAA35Ue5orEn65VIxOA+YvNNl9HV3qv70T7CNwjODHZrLwvd1Q==\",\n+                    \"dev\": true\n+                }\n             }\n         },\n         \"safe-buffer\": {\n@@ -1503,19 +2122,25 @@\n             \"resolved\": \"https://registry.npmjs.org/semver/-/semver-6.3.0.tgz\",\n             \"integrity\": \"sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==\"\n         },\n+        \"set-blocking\": {\n+            \"version\": \"2.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/set-blocking/-/set-blocking-2.0.0.tgz\",\n+            \"integrity\": \"sha1-BF+XgtARrppoA93TgrJDkrPYkPc=\",\n+            \"dev\": true\n+        },\n         \"shebang-command\": {\n-            \"version\": \"1.2.0\",\n-            \"resolved\": \"https://registry.npmjs.org/shebang-command/-/shebang-command-1.2.0.tgz\",\n-            \"integrity\": \"sha1-RKrGW2lbAzmJaMOfNj/uXer98eo=\",\n+            \"version\": \"2.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz\",\n+            \"integrity\": \"sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==\",\n             \"dev\": true,\n             \"requires\": {\n-                \"shebang-regex\": \"^1.0.0\"\n+                \"shebang-regex\": \"^3.0.0\"\n             }\n         },\n         \"shebang-regex\": {\n-            \"version\": \"1.0.0\",\n-            \"resolved\": \"https://registry.npmjs.org/shebang-regex/-/shebang-regex-1.0.0.tgz\",\n-            \"integrity\": \"sha1-2kL0l0DAtC2yypcoVxyxkMmO/qM=\",\n+            \"version\": \"3.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz\",\n+            \"integrity\": \"sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==\",\n             \"dev\": true\n         },\n         \"sigmund\": {\n@@ -1525,9 +2150,9 @@\n             \"dev\": true\n         },\n         \"signal-exit\": {\n-            \"version\": \"3.0.2\",\n-            \"resolved\": \"https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.2.tgz\",\n-            \"integrity\": \"sha1-tf3AjxKH6hF4Yo5BXiUTK3NkbG0=\",\n+            \"version\": \"3.0.3\",\n+            \"resolved\": \"https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.3.tgz\",\n+            \"integrity\": \"sha512-VUJ49FC8U1OxwZLxIbTTrDvLnf/6TDgxZcK8wxR8zs13xpx7xbG60ndBlhNrFi2EMuFRoeDoJO7wthSLq42EjA==\",\n             \"dev\": true\n         },\n         \"slice-ansi\": {\n@@ -1570,17 +2195,48 @@\n                 \"emoji-regex\": \"^8.0.0\",\n                 \"is-fullwidth-code-point\": \"^3.0.0\",\n                 \"strip-ansi\": \"^6.0.0\"\n-            },\n-            \"dependencies\": {\n-                \"strip-ansi\": {\n-                    \"version\": \"6.0.0\",\n-                    \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.0.tgz\",\n-                    \"integrity\": \"sha512-AuvKTrTfQNYNIctbR1K/YGTR1756GycPsg7b9bdV9Duqur4gv6aKqHXah67Z8ImS7WEz5QVcOtlfW2rZEugt6w==\",\n-                    \"dev\": true,\n-                    \"requires\": {\n-                        \"ansi-regex\": \"^5.0.0\"\n-                    }\n-                }\n+            }\n+        },\n+        \"string.prototype.trimend\": {\n+            \"version\": \"1.0.1\",\n+            \"resolved\": \"https://registry.npmjs.org/string.prototype.trimend/-/string.prototype.trimend-1.0.1.tgz\",\n+            \"integrity\": \"sha512-LRPxFUaTtpqYsTeNKaFOw3R4bxIzWOnbQ837QfBylo8jIxtcbK/A/sMV7Q+OAV/vWo+7s25pOE10KYSjaSO06g==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"define-properties\": \"^1.1.3\",\n+                \"es-abstract\": \"^1.17.5\"\n+            }\n+        },\n+        \"string.prototype.trimleft\": {\n+            \"version\": \"2.1.2\",\n+            \"resolved\": \"https://registry.npmjs.org/string.prototype.trimleft/-/string.prototype.trimleft-2.1.2.tgz\",\n+            \"integrity\": \"sha512-gCA0tza1JBvqr3bfAIFJGqfdRTyPae82+KTnm3coDXkZN9wnuW3HjGgN386D7hfv5CHQYCI022/rJPVlqXyHSw==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"define-properties\": \"^1.1.3\",\n+                \"es-abstract\": \"^1.17.5\",\n+                \"string.prototype.trimstart\": \"^1.0.0\"\n+            }\n+        },\n+        \"string.prototype.trimright\": {\n+            \"version\": \"2.1.2\",\n+            \"resolved\": \"https://registry.npmjs.org/string.prototype.trimright/-/string.prototype.trimright-2.1.2.tgz\",\n+            \"integrity\": \"sha512-ZNRQ7sY3KroTaYjRS6EbNiiHrOkjihL9aQE/8gfQ4DtAC/aEBRHFJa44OmoWxGGqXuJlfKkZW4WcXErGr+9ZFg==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"define-properties\": \"^1.1.3\",\n+                \"es-abstract\": \"^1.17.5\",\n+                \"string.prototype.trimend\": \"^1.0.0\"\n+            }\n+        },\n+        \"string.prototype.trimstart\": {\n+            \"version\": \"1.0.1\",\n+            \"resolved\": \"https://registry.npmjs.org/string.prototype.trimstart/-/string.prototype.trimstart-1.0.1.tgz\",\n+            \"integrity\": \"sha512-XxZn+QpvrBI1FOcg6dIpxUPgWCPuNXvMD72aaRaUQv1eD4e/Qy8i/hFTe0BUmD60p/QA6bh1avmuPTfNjqVWRw==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"define-properties\": \"^1.1.3\",\n+                \"es-abstract\": \"^1.17.5\"\n             }\n         },\n         \"string_decoder\": {\n@@ -1593,26 +2249,18 @@\n             }\n         },\n         \"strip-ansi\": {\n-            \"version\": \"5.2.0\",\n-            \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-5.2.0.tgz\",\n-            \"integrity\": \"sha512-DuRs1gKbBqsMKIZlrffwlug8MHkcnpjs5VPmL1PAh+mA30U0DTotfDZ0d2UUsXpPmPmMMJ6W773MaA3J+lbiWA==\",\n+            \"version\": \"6.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.0.tgz\",\n+            \"integrity\": \"sha512-AuvKTrTfQNYNIctbR1K/YGTR1756GycPsg7b9bdV9Duqur4gv6aKqHXah67Z8ImS7WEz5QVcOtlfW2rZEugt6w==\",\n             \"dev\": true,\n             \"requires\": {\n-                \"ansi-regex\": \"^4.1.0\"\n-            },\n-            \"dependencies\": {\n-                \"ansi-regex\": {\n-                    \"version\": \"4.1.0\",\n-                    \"resolved\": \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-4.1.0.tgz\",\n-                    \"integrity\": \"sha512-1apePfXM1UOSqw0o9IiFAovVz9M5S1Dg+4TrDwfMewQ6p/rmMueb7tWZjQ1rx4Loy1ArBggoqGpfqqdI4rondg==\",\n-                    \"dev\": true\n-                }\n+                \"ansi-regex\": \"^5.0.0\"\n             }\n         },\n         \"strip-json-comments\": {\n-            \"version\": \"3.0.1\",\n-            \"resolved\": \"https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.0.1.tgz\",\n-            \"integrity\": \"sha512-VTyMAUfdm047mwKl+u79WIdrZxtFtn+nBxHeb844XBQ9uMNTuTHdx2hc5RiAJYqwTj3wc/xe5HLSdJSkJ+WfZw==\",\n+            \"version\": \"3.1.0\",\n+            \"resolved\": \"https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.0.tgz\",\n+            \"integrity\": \"sha512-e6/d0eBu7gHtdCqFt0xJr642LdToM5/cN4Qb9DbHjVx1CP5RyeM+zH7pbecEmDv/lBqb0QH+6Uqq75rxFPkM0w==\",\n             \"dev\": true\n         },\n         \"supports-color\": {\n@@ -1636,6 +2284,12 @@\n                 \"string-width\": \"^3.0.0\"\n             },\n             \"dependencies\": {\n+                \"ansi-regex\": {\n+                    \"version\": \"4.1.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-4.1.0.tgz\",\n+                    \"integrity\": \"sha512-1apePfXM1UOSqw0o9IiFAovVz9M5S1Dg+4TrDwfMewQ6p/rmMueb7tWZjQ1rx4Loy1ArBggoqGpfqqdI4rondg==\",\n+                    \"dev\": true\n+                },\n                 \"emoji-regex\": {\n                     \"version\": \"7.0.3\",\n                     \"resolved\": \"https://registry.npmjs.org/emoji-regex/-/emoji-regex-7.0.3.tgz\",\n@@ -1658,6 +2312,15 @@\n                         \"is-fullwidth-code-point\": \"^2.0.0\",\n                         \"strip-ansi\": \"^5.1.0\"\n                     }\n+                },\n+                \"strip-ansi\": {\n+                    \"version\": \"5.2.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-5.2.0.tgz\",\n+                    \"integrity\": \"sha512-DuRs1gKbBqsMKIZlrffwlug8MHkcnpjs5VPmL1PAh+mA30U0DTotfDZ0d2UUsXpPmPmMMJ6W773MaA3J+lbiWA==\",\n+                    \"dev\": true,\n+                    \"requires\": {\n+                        \"ansi-regex\": \"^4.1.0\"\n+                    }\n                 }\n             }\n         },\n@@ -1692,9 +2355,9 @@\n             }\n         },\n         \"tslib\": {\n-            \"version\": \"1.12.0\",\n-            \"resolved\": \"https://registry.npmjs.org/tslib/-/tslib-1.12.0.tgz\",\n-            \"integrity\": \"sha512-5rxCQkP0kytf4H1T4xz1imjxaUUPMvc5aWp0rJ/VMIN7ClRiH1FwFvBt8wOeMasp/epeUnmSW6CixSIePtiLqA==\",\n+            \"version\": \"2.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/tslib/-/tslib-2.0.0.tgz\",\n+            \"integrity\": \"sha512-lTqkx847PI7xEDYJntxZH89L2/aXInsyF2luSafe/+0fHOMjlBNXdH6th7f70qxLDhul7KZK0zC8V5ZIyHl0/g==\",\n             \"dev\": true\n         },\n         \"tsutils\": {\n@@ -1704,6 +2367,14 @@\n             \"dev\": true,\n             \"requires\": {\n                 \"tslib\": \"^1.8.1\"\n+            },\n+            \"dependencies\": {\n+                \"tslib\": {\n+                    \"version\": \"1.13.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/tslib/-/tslib-1.13.0.tgz\",\n+                    \"integrity\": \"sha512-i/6DQjL8Xf3be4K/E6Wgpekn5Qasl1usyw++dAA35Ue5orEn65VIxOA+YvNNl9HV3qv70T7CNwjODHZrLwvd1Q==\",\n+                    \"dev\": true\n+                }\n             }\n         },\n         \"tunnel\": {\n@@ -1713,12 +2384,12 @@\n             \"dev\": true\n         },\n         \"type-check\": {\n-            \"version\": \"0.3.2\",\n-            \"resolved\": \"https://registry.npmjs.org/type-check/-/type-check-0.3.2.tgz\",\n-            \"integrity\": \"sha1-WITKtRLPHTVeP7eE8wgEsrUg23I=\",\n+            \"version\": \"0.4.0\",\n+            \"resolved\": \"https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz\",\n+            \"integrity\": \"sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==\",\n             \"dev\": true,\n             \"requires\": {\n-                \"prelude-ls\": \"~1.1.2\"\n+                \"prelude-ls\": \"^1.2.1\"\n             }\n         },\n         \"type-fest\": {\n@@ -1738,9 +2409,9 @@\n             }\n         },\n         \"typescript\": {\n-            \"version\": \"3.9.2\",\n-            \"resolved\": \"https://registry.npmjs.org/typescript/-/typescript-3.9.2.tgz\",\n-            \"integrity\": \"sha512-q2ktq4n/uLuNNShyayit+DTobV2ApPEo/6so68JaD5ojvc/6GClBipedB9zNWYxRSAlZXAe405Rlijzl6qDiSw==\",\n+            \"version\": \"3.9.3\",\n+            \"resolved\": \"https://registry.npmjs.org/typescript/-/typescript-3.9.3.tgz\",\n+            \"integrity\": \"sha512-D/wqnB2xzNFIcoBG9FG8cXRDjiqSTbG2wd8DMZeQyJlP1vfTkIxH4GKveWaEBYySKIg+USu+E+EDIR47SqnaMQ==\",\n             \"dev\": true\n         },\n         \"typescript-formatter\": {\n@@ -1865,21 +2536,131 @@\n             \"resolved\": \"https://registry.npmjs.org/vscode-languageserver-types/-/vscode-languageserver-types-3.16.0-next.1.tgz\",\n             \"integrity\": \"sha512-tZFUSbyjUcrh+qQf13ALX4QDdOfDX0cVaBFgy7ktJ0VwS7AW/yRKgGPSxVqqP9OCMNPdqP57O5q47w2pEwfaUg==\"\n         },\n+        \"vscode-test\": {\n+            \"version\": \"1.3.0\",\n+            \"resolved\": \"https://registry.npmjs.org/vscode-test/-/vscode-test-1.3.0.tgz\",\n+            \"integrity\": \"sha512-LddukcBiSU2FVTDr3c1D8lwkiOvwlJdDL2hqVbn6gIz+rpTqUCkMZSKYm94Y1v0WXlHSDQBsXyY+tchWQgGVsw==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"http-proxy-agent\": \"^2.1.0\",\n+                \"https-proxy-agent\": \"^2.2.4\",\n+                \"rimraf\": \"^2.6.3\"\n+            }\n+        },\n         \"which\": {\n-            \"version\": \"1.3.1\",\n-            \"resolved\": \"https://registry.npmjs.org/which/-/which-1.3.1.tgz\",\n-            \"integrity\": \"sha512-HxJdYWq1MTIQbJ3nw0cqssHoTNU267KlrDuGZ1WYlxDStUtKUhOaJmh112/TZmHxxUfuJqPXSOm7tDyas0OSIQ==\",\n+            \"version\": \"2.0.2\",\n+            \"resolved\": \"https://registry.npmjs.org/which/-/which-2.0.2.tgz\",\n+            \"integrity\": \"sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"isexe\": \"^2.0.0\"\n             }\n         },\n+        \"which-module\": {\n+            \"version\": \"2.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/which-module/-/which-module-2.0.0.tgz\",\n+            \"integrity\": \"sha1-2e8H3Od7mQK4o6j6SzHD4/fm6Ho=\",\n+            \"dev\": true\n+        },\n+        \"wide-align\": {\n+            \"version\": \"1.1.3\",\n+            \"resolved\": \"https://registry.npmjs.org/wide-align/-/wide-align-1.1.3.tgz\",\n+            \"integrity\": \"sha512-QGkOQc8XL6Bt5PwnsExKBPuMKBxnGxWWW3fU55Xt4feHozMUhdUMaBCk290qpm/wG5u/RSKzwdAC4i51YigihA==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"string-width\": \"^1.0.2 || 2\"\n+            },\n+            \"dependencies\": {\n+                \"ansi-regex\": {\n+                    \"version\": \"3.0.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.0.0.tgz\",\n+                    \"integrity\": \"sha1-7QMXwyIGT3lGbAKWa922Bas32Zg=\",\n+                    \"dev\": true\n+                },\n+                \"is-fullwidth-code-point\": {\n+                    \"version\": \"2.0.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-2.0.0.tgz\",\n+                    \"integrity\": \"sha1-o7MKXE8ZkYMWeqq5O+764937ZU8=\",\n+                    \"dev\": true\n+                },\n+                \"string-width\": {\n+                    \"version\": \"2.1.1\",\n+                    \"resolved\": \"https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz\",\n+                    \"integrity\": \"sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==\",\n+                    \"dev\": true,\n+                    \"requires\": {\n+                        \"is-fullwidth-code-point\": \"^2.0.0\",\n+                        \"strip-ansi\": \"^4.0.0\"\n+                    }\n+                },\n+                \"strip-ansi\": {\n+                    \"version\": \"4.0.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz\",\n+                    \"integrity\": \"sha1-qEeQIusaw2iocTibY1JixQXuNo8=\",\n+                    \"dev\": true,\n+                    \"requires\": {\n+                        \"ansi-regex\": \"^3.0.0\"\n+                    }\n+                }\n+            }\n+        },\n         \"word-wrap\": {\n             \"version\": \"1.2.3\",\n             \"resolved\": \"https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.3.tgz\",\n             \"integrity\": \"sha512-Hz/mrNwitNRh/HUAtM/VT/5VH+ygD6DV7mYKZAtHOrbs8U7lvPS6xf7EJKMF0uW1KJCl0H701g3ZGus+muE5vQ==\",\n             \"dev\": true\n         },\n+        \"wrap-ansi\": {\n+            \"version\": \"5.1.0\",\n+            \"resolved\": \"https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-5.1.0.tgz\",\n+            \"integrity\": \"sha512-QC1/iN/2/RPVJ5jYK8BGttj5z83LmSKmvbvrXPNCLZSEb32KKVDJDl/MOt2N01qU2H/FkzEa9PKto1BqDjtd7Q==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"ansi-styles\": \"^3.2.0\",\n+                \"string-width\": \"^3.0.0\",\n+                \"strip-ansi\": \"^5.0.0\"\n+            },\n+            \"dependencies\": {\n+                \"ansi-regex\": {\n+                    \"version\": \"4.1.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-4.1.0.tgz\",\n+                    \"integrity\": \"sha512-1apePfXM1UOSqw0o9IiFAovVz9M5S1Dg+4TrDwfMewQ6p/rmMueb7tWZjQ1rx4Loy1ArBggoqGpfqqdI4rondg==\",\n+                    \"dev\": true\n+                },\n+                \"emoji-regex\": {\n+                    \"version\": \"7.0.3\",\n+                    \"resolved\": \"https://registry.npmjs.org/emoji-regex/-/emoji-regex-7.0.3.tgz\",\n+                    \"integrity\": \"sha512-CwBLREIQ7LvYFB0WyRvwhq5N5qPhc6PMjD6bYggFlI5YyDgl+0vxq5VHbMOFqLg7hfWzmu8T5Z1QofhmTIhItA==\",\n+                    \"dev\": true\n+                },\n+                \"is-fullwidth-code-point\": {\n+                    \"version\": \"2.0.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-2.0.0.tgz\",\n+                    \"integrity\": \"sha1-o7MKXE8ZkYMWeqq5O+764937ZU8=\",\n+                    \"dev\": true\n+                },\n+                \"string-width\": {\n+                    \"version\": \"3.1.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/string-width/-/string-width-3.1.0.tgz\",\n+                    \"integrity\": \"sha512-vafcv6KjVZKSgz06oM/H6GDBrAtz8vdhQakGjFIvNrHA6y3HCF1CInLy+QLq8dTJPQ1b+KDUqDFctkdRW44e1w==\",\n+                    \"dev\": true,\n+                    \"requires\": {\n+                        \"emoji-regex\": \"^7.0.1\",\n+                        \"is-fullwidth-code-point\": \"^2.0.0\",\n+                        \"strip-ansi\": \"^5.1.0\"\n+                    }\n+                },\n+                \"strip-ansi\": {\n+                    \"version\": \"5.2.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-5.2.0.tgz\",\n+                    \"integrity\": \"sha512-DuRs1gKbBqsMKIZlrffwlug8MHkcnpjs5VPmL1PAh+mA30U0DTotfDZ0d2UUsXpPmPmMMJ6W773MaA3J+lbiWA==\",\n+                    \"dev\": true,\n+                    \"requires\": {\n+                        \"ansi-regex\": \"^4.1.0\"\n+                    }\n+                }\n+            }\n+        },\n         \"wrappy\": {\n             \"version\": \"1.0.2\",\n             \"resolved\": \"https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz\",\n@@ -1895,12 +2676,97 @@\n                 \"mkdirp\": \"^0.5.1\"\n             }\n         },\n+        \"y18n\": {\n+            \"version\": \"4.0.0\",\n+            \"resolved\": \"https://registry.npmjs.org/y18n/-/y18n-4.0.0.tgz\",\n+            \"integrity\": \"sha512-r9S/ZyXu/Xu9q1tYlpsLIsa3EeLXXk0VwlxqTcFRfg9EhMW+17kbt9G0NrgCmhGb5vT2hyhJZLfDGx+7+5Uj/w==\",\n+            \"dev\": true\n+        },\n         \"yallist\": {\n             \"version\": \"2.1.2\",\n             \"resolved\": \"https://registry.npmjs.org/yallist/-/yallist-2.1.2.tgz\",\n             \"integrity\": \"sha1-HBH5IY8HYImkfdUS+TxmmaaoHVI=\",\n             \"dev\": true\n         },\n+        \"yargs\": {\n+            \"version\": \"13.3.2\",\n+            \"resolved\": \"https://registry.npmjs.org/yargs/-/yargs-13.3.2.tgz\",\n+            \"integrity\": \"sha512-AX3Zw5iPruN5ie6xGRIDgqkT+ZhnRlZMLMHAs8tg7nRruy2Nb+i5o9bwghAogtM08q1dpr2LVoS8KSTMYpWXUw==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"cliui\": \"^5.0.0\",\n+                \"find-up\": \"^3.0.0\",\n+                \"get-caller-file\": \"^2.0.1\",\n+                \"require-directory\": \"^2.1.1\",\n+                \"require-main-filename\": \"^2.0.0\",\n+                \"set-blocking\": \"^2.0.0\",\n+                \"string-width\": \"^3.0.0\",\n+                \"which-module\": \"^2.0.0\",\n+                \"y18n\": \"^4.0.0\",\n+                \"yargs-parser\": \"^13.1.2\"\n+            },\n+            \"dependencies\": {\n+                \"ansi-regex\": {\n+                    \"version\": \"4.1.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-4.1.0.tgz\",\n+                    \"integrity\": \"sha512-1apePfXM1UOSqw0o9IiFAovVz9M5S1Dg+4TrDwfMewQ6p/rmMueb7tWZjQ1rx4Loy1ArBggoqGpfqqdI4rondg==\",\n+                    \"dev\": true\n+                },\n+                \"emoji-regex\": {\n+                    \"version\": \"7.0.3\",\n+                    \"resolved\": \"https://registry.npmjs.org/emoji-regex/-/emoji-regex-7.0.3.tgz\",\n+                    \"integrity\": \"sha512-CwBLREIQ7LvYFB0WyRvwhq5N5qPhc6PMjD6bYggFlI5YyDgl+0vxq5VHbMOFqLg7hfWzmu8T5Z1QofhmTIhItA==\",\n+                    \"dev\": true\n+                },\n+                \"is-fullwidth-code-point\": {\n+                    \"version\": \"2.0.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-2.0.0.tgz\",\n+                    \"integrity\": \"sha1-o7MKXE8ZkYMWeqq5O+764937ZU8=\",\n+                    \"dev\": true\n+                },\n+                \"string-width\": {\n+                    \"version\": \"3.1.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/string-width/-/string-width-3.1.0.tgz\",\n+                    \"integrity\": \"sha512-vafcv6KjVZKSgz06oM/H6GDBrAtz8vdhQakGjFIvNrHA6y3HCF1CInLy+QLq8dTJPQ1b+KDUqDFctkdRW44e1w==\",\n+                    \"dev\": true,\n+                    \"requires\": {\n+                        \"emoji-regex\": \"^7.0.1\",\n+                        \"is-fullwidth-code-point\": \"^2.0.0\",\n+                        \"strip-ansi\": \"^5.1.0\"\n+                    }\n+                },\n+                \"strip-ansi\": {\n+                    \"version\": \"5.2.0\",\n+                    \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-5.2.0.tgz\",\n+                    \"integrity\": \"sha512-DuRs1gKbBqsMKIZlrffwlug8MHkcnpjs5VPmL1PAh+mA30U0DTotfDZ0d2UUsXpPmPmMMJ6W773MaA3J+lbiWA==\",\n+                    \"dev\": true,\n+                    \"requires\": {\n+                        \"ansi-regex\": \"^4.1.0\"\n+                    }\n+                }\n+            }\n+        },\n+        \"yargs-parser\": {\n+            \"version\": \"13.1.2\",\n+            \"resolved\": \"https://registry.npmjs.org/yargs-parser/-/yargs-parser-13.1.2.tgz\",\n+            \"integrity\": \"sha512-3lbsNRf/j+A4QuSZfDRA7HRSfWrzO0YjqTJd5kjAq37Zep1CEgaYmrH9Q3GwPiB9cHyd1Y1UwggGhJGoxipbzg==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"camelcase\": \"^5.0.0\",\n+                \"decamelize\": \"^1.2.0\"\n+            }\n+        },\n+        \"yargs-unparser\": {\n+            \"version\": \"1.6.0\",\n+            \"resolved\": \"https://registry.npmjs.org/yargs-unparser/-/yargs-unparser-1.6.0.tgz\",\n+            \"integrity\": \"sha512-W9tKgmSn0DpSatfri0nx52Joq5hVXgeLiqR/5G0sZNDoLZFOr/xjBUDcShCOGNsBnEMNo1KAMBkTej1Hm62HTw==\",\n+            \"dev\": true,\n+            \"requires\": {\n+                \"flat\": \"^4.1.0\",\n+                \"lodash\": \"^4.17.15\",\n+                \"yargs\": \"^13.3.0\"\n+            }\n+        },\n         \"yauzl\": {\n             \"version\": \"2.10.0\",\n             \"resolved\": \"https://registry.npmjs.org/yauzl/-/yauzl-2.10.0.tgz\","}, {"sha": "30ab7ba4a9f831fcd78b80cd0cae68047eb25b71", "filename": "editors/code/package.json", "status": "modified", "additions": 133, "deletions": 18, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -21,43 +21,50 @@\n         \"Programming Languages\"\n     ],\n     \"engines\": {\n-        \"vscode\": \"^1.44.0\"\n+        \"vscode\": \"^1.44.1\"\n     },\n     \"enableProposedApi\": true,\n     \"scripts\": {\n         \"vscode:prepublish\": \"tsc && rollup -c\",\n         \"package\": \"vsce package -o rust-analyzer.vsix\",\n         \"build\": \"tsc\",\n         \"watch\": \"tsc --watch\",\n-        \"lint\": \"tsfmt --verify && eslint -c .eslintrc.js --ext ts ./src\",\n-        \"fix\": \" tsfmt -r       && eslint -c .eslintrc.js --ext ts ./src --fix\"\n+        \"lint\": \"tsfmt --verify && eslint -c .eslintrc.js --ext ts ./src ./tests\",\n+        \"fix\": \" tsfmt -r       && eslint -c .eslintrc.js --ext ts ./src ./tests --fix\",\n+        \"pretest\": \"npm run build\",\n+        \"test\": \"node ./out/tests/runTests.js\"\n     },\n     \"dependencies\": {\n         \"node-fetch\": \"^2.6.0\",\n         \"vscode-languageclient\": \"7.0.0-next.1\"\n     },\n     \"devDependencies\": {\n-        \"@rollup/plugin-commonjs\": \"^11.1.0\",\n-        \"@rollup/plugin-node-resolve\": \"^7.1.3\",\n-        \"@types/node\": \"^12.12.39\",\n+        \"@rollup/plugin-commonjs\": \"^12.0.0\",\n+        \"@rollup/plugin-node-resolve\": \"^8.0.0\",\n+        \"@types/glob\": \"^7.1.1\",\n+        \"@types/mocha\": \"^7.0.2\",\n+        \"@types/node\": \"^14.0.5\",\n         \"@types/node-fetch\": \"^2.5.7\",\n-        \"@types/vscode\": \"^1.44.0\",\n-        \"@typescript-eslint/eslint-plugin\": \"^2.33.0\",\n-        \"@typescript-eslint/parser\": \"^2.33.0\",\n-        \"eslint\": \"^6.8.0\",\n-        \"rollup\": \"^2.10.0\",\n-        \"tslib\": \"^1.12.0\",\n-        \"typescript\": \"^3.9.2\",\n+        \"@types/vscode\": \"^1.44.1\",\n+        \"@typescript-eslint/eslint-plugin\": \"^3.0.0\",\n+        \"@typescript-eslint/parser\": \"^3.0.0\",\n+        \"eslint\": \"^7.0.0\",\n+        \"glob\": \"^7.1.6\",\n+        \"mocha\": \"^7.1.2\",\n+        \"rollup\": \"^2.10.7\",\n+        \"tslib\": \"^2.0.0\",\n+        \"typescript\": \"^3.9.3\",\n         \"typescript-formatter\": \"^7.2.2\",\n-        \"vsce\": \"^1.75.0\"\n+        \"vsce\": \"^1.75.0\",\n+        \"vscode-test\": \"^1.3.0\"\n     },\n     \"activationEvents\": [\n         \"onLanguage:rust\",\n         \"onCommand:rust-analyzer.analyzerStatus\",\n         \"onCommand:rust-analyzer.collectGarbage\",\n         \"workspaceContains:**/Cargo.toml\"\n     ],\n-    \"main\": \"./out/main\",\n+    \"main\": \"./out/src/main\",\n     \"contributes\": {\n         \"taskDefinitions\": [\n             {\n@@ -159,6 +166,11 @@\n                 \"command\": \"rust-analyzer.serverVersion\",\n                 \"title\": \"Show RA Version\",\n                 \"category\": \"Rust Analyzer\"\n+            },\n+            {\n+                \"command\": \"rust-analyzer.toggleInlayHints\",\n+                \"title\": \"Toggle inlay hints\",\n+                \"category\": \"Rust Analyzer\"\n             }\n         ],\n         \"keybindings\": [\n@@ -226,7 +238,7 @@\n                 },\n                 \"rust-analyzer.cargo.allFeatures\": {\n                     \"type\": \"boolean\",\n-                    \"default\": true,\n+                    \"default\": false,\n                     \"description\": \"Activate all available features\"\n                 },\n                 \"rust-analyzer.cargo.features\": {\n@@ -307,7 +319,7 @@\n                 },\n                 \"rust-analyzer.checkOnSave.allFeatures\": {\n                     \"type\": \"boolean\",\n-                    \"default\": true,\n+                    \"default\": false,\n                     \"markdownDescription\": \"Check with all features (will be passed as `--all-features`)\"\n                 },\n                 \"rust-analyzer.inlayHints.enable\": {\n@@ -463,6 +475,25 @@\n                     \"markdownDescription\": \"Whether to show Implementations lens. Only applies when `#rust-analyzer.lens.enable#` is set.\",\n                     \"type\": \"boolean\",\n                     \"default\": true\n+                },\n+                \"rust-analyzer.linkedProjects\": {\n+                    \"markdownDescription\": [\n+                        \"Disable project auto-discovery in favor of explicitly specified set of projects.\",\n+                        \"Elements must be paths pointing to Cargo.toml, rust-project.json, or JSON objects in rust-project.json format\"\n+                    ],\n+                    \"type\": \"array\",\n+                    \"items\": {\n+                        \"type\": [\n+                            \"string\",\n+                            \"object\"\n+                        ]\n+                    },\n+                    \"default\": null\n+                },\n+                \"rust-analyzer.withSysroot\": {\n+                    \"markdownDescription\": \"Internal config for debugging, disables loading of sysroot crates\",\n+                    \"type\": \"boolean\",\n+                    \"default\": true\n                 }\n             }\n         },\n@@ -574,6 +605,11 @@\n                 \"id\": \"attribute\",\n                 \"description\": \"Style for attributes\"\n             },\n+            {\n+                \"id\": \"boolean\",\n+                \"description\": \"Style for boolean literals\",\n+                \"superType\": \"keyword\"\n+            },\n             {\n                 \"id\": \"builtinType\",\n                 \"description\": \"Style for builtin types\",\n@@ -583,6 +619,11 @@\n                 \"id\": \"lifetime\",\n                 \"description\": \"Style for lifetimes\"\n             },\n+            {\n+                \"id\": \"selfKeyword\",\n+                \"description\": \"Style for the self keyword\",\n+                \"superType\": \"keyword\"\n+            },\n             {\n                 \"id\": \"typeAlias\",\n                 \"description\": \"Style for type aliases\",\n@@ -603,6 +644,10 @@\n             }\n         ],\n         \"semanticTokenModifiers\": [\n+            {\n+                \"id\": \"attribute\",\n+                \"description\": \"Style for elements within attributes\"\n+            },\n             {\n                 \"id\": \"constant\",\n                 \"description\": \"Style for compile-time constants\"\n@@ -630,6 +675,12 @@\n                     \"attribute\": [\n                         \"meta.attribute.rust\"\n                     ],\n+                    \"function.attribute\": [\n+                        \"entity.name.function.attribute.rust\"\n+                    ],\n+                    \"boolean\": [\n+                        \"constant.language.boolean.rust\"\n+                    ],\n                     \"builtinType\": [\n                         \"support.type.primitive.rust\"\n                     ],\n@@ -662,6 +713,70 @@\n                     ]\n                 }\n             }\n-        ]\n+        ],\n+        \"menus\": {\n+            \"commandPalette\": [\n+                {\n+                    \"command\": \"rust-analyzer.syntaxTree\",\n+                    \"when\": \"inRustProject\"\n+                },\n+                {\n+                    \"command\": \"rust-analyzer.expandMacro\",\n+                    \"when\": \"inRustProject\"\n+                },\n+                {\n+                    \"command\": \"rust-analyzer.matchingBrace\",\n+                    \"when\": \"inRustProject\"\n+                },\n+                {\n+                    \"command\": \"rust-analyzer.parentModule\",\n+                    \"when\": \"inRustProject\"\n+                },\n+                {\n+                    \"command\": \"rust-analyzer.joinLines\",\n+                    \"when\": \"inRustProject\"\n+                },\n+                {\n+                    \"command\": \"rust-analyzer.run\",\n+                    \"when\": \"inRustProject\"\n+                },\n+                {\n+                    \"command\": \"rust-analyzer.debug\",\n+                    \"when\": \"inRustProject\"\n+                },\n+                {\n+                    \"command\": \"rust-analyzer.newDebugConfig\",\n+                    \"when\": \"inRustProject\"\n+                },\n+                {\n+                    \"command\": \"rust-analyzer.analyzerStatus\",\n+                    \"when\": \"inRustProject\"\n+                },\n+                {\n+                    \"command\": \"rust-analyzer.collectGarbage\",\n+                    \"when\": \"inRustProject\"\n+                },\n+                {\n+                    \"command\": \"rust-analyzer.reload\",\n+                    \"when\": \"inRustProject\"\n+                },\n+                {\n+                    \"command\": \"rust-analyzer.onEnter\",\n+                    \"when\": \"inRustProject\"\n+                },\n+                {\n+                    \"command\": \"rust-analyzer.ssr\",\n+                    \"when\": \"inRustProject\"\n+                },\n+                {\n+                    \"command\": \"rust-analyzer.serverVersion\",\n+                    \"when\": \"inRustProject\"\n+                },\n+                {\n+                    \"command\": \"rust-analyzer.toggleInlayHints\",\n+                    \"when\": \"inRustProject\"\n+                }\n+            ]\n+        }\n     }\n }"}, {"sha": "58360eabbf52260f59966b553bd5f215706fa1f7", "filename": "editors/code/rollup.config.js", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Frollup.config.js", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Frollup.config.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Frollup.config.js?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -6,7 +6,7 @@ import nodeBuiltins from 'builtin-modules';\n \n /** @type { import('rollup').RollupOptions } */\n export default {\n-    input: 'out/main.js',\n+    input: 'out/src/main.js',\n     plugins: [\n         resolve({\n             preferBuiltins: true\n@@ -20,7 +20,7 @@ export default {\n     ],\n     external: [...nodeBuiltins, 'vscode'],\n     output: {\n-        file: './out/main.js',\n+        file: './out/src/main.js',\n         format: 'cjs',\n         exports: 'named'\n     }"}, {"sha": "ab87cd39f60891e3b33870588a9414424289e179", "filename": "editors/code/rust.tmGrammar.json", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Frust.tmGrammar.json", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Frust.tmGrammar.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Frust.tmGrammar.json?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -75,8 +75,13 @@\n \t\t{\n \t\t\t\"comment\": \"Attribute\",\n \t\t\t\"name\": \"meta.attribute.rust\",\n-\t\t\t\"begin\": \"#\\\\!?\\\\[\",\n+\t\t\t\"begin\": \"#\\\\!?\\\\[(\\\\w*)\",\n \t\t\t\"end\": \"\\\\]\",\n+\t\t\t\"captures\": {\n+\t\t\t\t\"1\": {\n+\t\t\t\t\t\"name\": \"entity.name.function.attribute.rust\"\n+\t\t\t\t}\n+\t\t\t},\n \t\t\t\"patterns\": [\n \t\t\t\t{\n \t\t\t\t\t\"include\": \"#string_literal\"\n@@ -202,7 +207,7 @@\n \t\t{\n \t\t\t\"comment\": \"Miscellaneous operator\",\n \t\t\t\"name\": \"keyword.operator.misc.rust\",\n-\t\t\t\"match\": \"(=>|::)\"\n+\t\t\t\"match\": \"(=>|::|\\\\?)\"\n \t\t},\n \t\t{\n \t\t\t\"comment\": \"Comparison operator\","}, {"sha": "4fdd167bd5f70bd0769807fa886d4c25612dea8d", "filename": "editors/code/src/ast_inspector.ts", "status": "renamed", "additions": 5, "deletions": 83, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Fast_inspector.ts", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Fast_inspector.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fast_inspector.ts?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,93 +1,15 @@\n import * as vscode from 'vscode';\n-import * as ra from '../rust-analyzer-api';\n-\n-import { Ctx, Cmd, Disposable } from '../ctx';\n-import { isRustDocument, RustEditor, isRustEditor, sleep } from '../util';\n-\n-const AST_FILE_SCHEME = \"rust-analyzer\";\n-\n-// Opens the virtual file that will show the syntax tree\n-//\n-// The contents of the file come from the `TextDocumentContentProvider`\n-export function syntaxTree(ctx: Ctx): Cmd {\n-    const tdcp = new TextDocumentContentProvider(ctx);\n-\n-    void new AstInspector(ctx);\n-\n-    ctx.pushCleanup(vscode.workspace.registerTextDocumentContentProvider(AST_FILE_SCHEME, tdcp));\n-    ctx.pushCleanup(vscode.languages.setLanguageConfiguration(\"ra_syntax_tree\", {\n-        brackets: [[\"[\", \")\"]],\n-    }));\n-\n-    return async () => {\n-        const editor = vscode.window.activeTextEditor;\n-        const rangeEnabled = !!editor && !editor.selection.isEmpty;\n-\n-        const uri = rangeEnabled\n-            ? vscode.Uri.parse(`${tdcp.uri.toString()}?range=true`)\n-            : tdcp.uri;\n-\n-        const document = await vscode.workspace.openTextDocument(uri);\n-\n-        tdcp.eventEmitter.fire(uri);\n-\n-        void await vscode.window.showTextDocument(document, {\n-            viewColumn: vscode.ViewColumn.Two,\n-            preserveFocus: true\n-        });\n-    };\n-}\n-\n-class TextDocumentContentProvider implements vscode.TextDocumentContentProvider {\n-    readonly uri = vscode.Uri.parse('rust-analyzer://syntaxtree/tree.rast');\n-    readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n-\n-\n-    constructor(private readonly ctx: Ctx) {\n-        vscode.workspace.onDidChangeTextDocument(this.onDidChangeTextDocument, this, ctx.subscriptions);\n-        vscode.window.onDidChangeActiveTextEditor(this.onDidChangeActiveTextEditor, this, ctx.subscriptions);\n-    }\n-\n-    private onDidChangeTextDocument(event: vscode.TextDocumentChangeEvent) {\n-        if (isRustDocument(event.document)) {\n-            // We need to order this after language server updates, but there's no API for that.\n-            // Hence, good old sleep().\n-            void sleep(10).then(() => this.eventEmitter.fire(this.uri));\n-        }\n-    }\n-    private onDidChangeActiveTextEditor(editor: vscode.TextEditor | undefined) {\n-        if (editor && isRustEditor(editor)) {\n-            this.eventEmitter.fire(this.uri);\n-        }\n-    }\n-\n-    provideTextDocumentContent(uri: vscode.Uri, ct: vscode.CancellationToken): vscode.ProviderResult<string> {\n-        const rustEditor = this.ctx.activeRustEditor;\n-        if (!rustEditor) return '';\n-\n-        // When the range based query is enabled we take the range of the selection\n-        const range = uri.query === 'range=true' && !rustEditor.selection.isEmpty\n-            ? this.ctx.client.code2ProtocolConverter.asRange(rustEditor.selection)\n-            : null;\n-\n-        const params = { textDocument: { uri: rustEditor.document.uri.toString() }, range, };\n-        return this.ctx.client.sendRequest(ra.syntaxTree, params, ct);\n-    }\n-\n-    get onDidChange(): vscode.Event<vscode.Uri> {\n-        return this.eventEmitter.event;\n-    }\n-}\n \n+import { Ctx, Disposable } from './ctx';\n+import { RustEditor, isRustEditor } from './util';\n \n // FIXME: consider implementing this via the Tree View API?\n // https://code.visualstudio.com/api/extension-guides/tree-view\n-class AstInspector implements vscode.HoverProvider, vscode.DefinitionProvider, Disposable {\n+export class AstInspector implements vscode.HoverProvider, vscode.DefinitionProvider, Disposable {\n     private readonly astDecorationType = vscode.window.createTextEditorDecorationType({\n         borderColor: new vscode.ThemeColor('rust_analyzer.syntaxTreeBorder'),\n         borderStyle: \"solid\",\n         borderWidth: \"2px\",\n-\n     });\n     private rustEditor: undefined | RustEditor;\n \n@@ -113,7 +35,7 @@ class AstInspector implements vscode.HoverProvider, vscode.DefinitionProvider, D\n     });\n \n     constructor(ctx: Ctx) {\n-        ctx.pushCleanup(vscode.languages.registerHoverProvider({ scheme: AST_FILE_SCHEME }, this));\n+        ctx.pushCleanup(vscode.languages.registerHoverProvider({ scheme: 'rust-analyzer' }, this));\n         ctx.pushCleanup(vscode.languages.registerDefinitionProvider({ language: \"rust\" }, this));\n         vscode.workspace.onDidCloseTextDocument(this.onDidCloseTextDocument, this, ctx.subscriptions);\n         vscode.workspace.onDidChangeTextDocument(this.onDidChangeTextDocument, this, ctx.subscriptions);\n@@ -146,7 +68,7 @@ class AstInspector implements vscode.HoverProvider, vscode.DefinitionProvider, D\n     }\n \n     private findAstTextEditor(): undefined | vscode.TextEditor {\n-        return vscode.window.visibleTextEditors.find(it => it.document.uri.scheme === AST_FILE_SCHEME);\n+        return vscode.window.visibleTextEditors.find(it => it.document.uri.scheme === 'rust-analyzer');\n     }\n \n     private setRustEditor(newRustEditor: undefined | RustEditor) {", "previous_filename": "editors/code/src/commands/syntax_tree.ts"}, {"sha": "534d2a9847e0dd1fd70265c2d85db405cb9855f4", "filename": "editors/code/src/commands.ts", "status": "added", "additions": 416, "deletions": 0, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands.ts?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -0,0 +1,416 @@\n+import * as vscode from 'vscode';\n+import * as lc from 'vscode-languageclient';\n+import * as ra from './lsp_ext';\n+\n+import { Ctx, Cmd } from './ctx';\n+import { applySnippetWorkspaceEdit, applySnippetTextEdits } from './snippets';\n+import { spawnSync } from 'child_process';\n+import { RunnableQuickPick, selectRunnable, createTask } from './run';\n+import { AstInspector } from './ast_inspector';\n+import { isRustDocument, sleep, isRustEditor } from './util';\n+import { startDebugSession, makeDebugConfig } from './debug';\n+\n+export * from './ast_inspector';\n+export * from './run';\n+\n+export function analyzerStatus(ctx: Ctx): Cmd {\n+    const tdcp = new class implements vscode.TextDocumentContentProvider {\n+        readonly uri = vscode.Uri.parse('rust-analyzer-status://status');\n+        readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n+\n+        provideTextDocumentContent(_uri: vscode.Uri): vscode.ProviderResult<string> {\n+            if (!vscode.window.activeTextEditor) return '';\n+\n+            return ctx.client.sendRequest(ra.analyzerStatus, null);\n+        }\n+\n+        get onDidChange(): vscode.Event<vscode.Uri> {\n+            return this.eventEmitter.event;\n+        }\n+    }();\n+\n+    let poller: NodeJS.Timer | undefined = undefined;\n+\n+    ctx.pushCleanup(\n+        vscode.workspace.registerTextDocumentContentProvider(\n+            'rust-analyzer-status',\n+            tdcp,\n+        ),\n+    );\n+\n+    ctx.pushCleanup({\n+        dispose() {\n+            if (poller !== undefined) {\n+                clearInterval(poller);\n+            }\n+        },\n+    });\n+\n+    return async () => {\n+        if (poller === undefined) {\n+            poller = setInterval(() => tdcp.eventEmitter.fire(tdcp.uri), 1000);\n+        }\n+        const document = await vscode.workspace.openTextDocument(tdcp.uri);\n+        return vscode.window.showTextDocument(document, vscode.ViewColumn.Two, true);\n+    };\n+}\n+\n+export function matchingBrace(ctx: Ctx): Cmd {\n+    return async () => {\n+        const editor = ctx.activeRustEditor;\n+        const client = ctx.client;\n+        if (!editor || !client) return;\n+\n+        const response = await client.sendRequest(ra.matchingBrace, {\n+            textDocument: { uri: editor.document.uri.toString() },\n+            positions: editor.selections.map(s =>\n+                client.code2ProtocolConverter.asPosition(s.active),\n+            ),\n+        });\n+        editor.selections = editor.selections.map((sel, idx) => {\n+            const active = client.protocol2CodeConverter.asPosition(\n+                response[idx],\n+            );\n+            const anchor = sel.isEmpty ? active : sel.anchor;\n+            return new vscode.Selection(anchor, active);\n+        });\n+        editor.revealRange(editor.selection);\n+    };\n+}\n+\n+export function joinLines(ctx: Ctx): Cmd {\n+    return async () => {\n+        const editor = ctx.activeRustEditor;\n+        const client = ctx.client;\n+        if (!editor || !client) return;\n+\n+        const items: lc.TextEdit[] = await client.sendRequest(ra.joinLines, {\n+            ranges: editor.selections.map((it) => client.code2ProtocolConverter.asRange(it)),\n+            textDocument: { uri: editor.document.uri.toString() },\n+        });\n+        editor.edit((builder) => {\n+            client.protocol2CodeConverter.asTextEdits(items).forEach((edit) => {\n+                builder.replace(edit.range, edit.newText);\n+            });\n+        });\n+    };\n+}\n+\n+export function onEnter(ctx: Ctx): Cmd {\n+    async function handleKeypress() {\n+        const editor = ctx.activeRustEditor;\n+        const client = ctx.client;\n+\n+        if (!editor || !client) return false;\n+\n+        const lcEdits = await client.sendRequest(ra.onEnter, {\n+            textDocument: { uri: editor.document.uri.toString() },\n+            position: client.code2ProtocolConverter.asPosition(\n+                editor.selection.active,\n+            ),\n+        }).catch(_error => {\n+            // client.logFailedRequest(OnEnterRequest.type, error);\n+            return null;\n+        });\n+        if (!lcEdits) return false;\n+\n+        const edits = client.protocol2CodeConverter.asTextEdits(lcEdits);\n+        await applySnippetTextEdits(editor, edits);\n+        return true;\n+    }\n+\n+    return async () => {\n+        if (await handleKeypress()) return;\n+\n+        await vscode.commands.executeCommand('default:type', { text: '\\n' });\n+    };\n+}\n+\n+export function parentModule(ctx: Ctx): Cmd {\n+    return async () => {\n+        const editor = ctx.activeRustEditor;\n+        const client = ctx.client;\n+        if (!editor || !client) return;\n+\n+        const response = await client.sendRequest(ra.parentModule, {\n+            textDocument: { uri: editor.document.uri.toString() },\n+            position: client.code2ProtocolConverter.asPosition(\n+                editor.selection.active,\n+            ),\n+        });\n+        const loc = response[0];\n+        if (!loc) return;\n+\n+        const uri = client.protocol2CodeConverter.asUri(loc.targetUri);\n+        const range = client.protocol2CodeConverter.asRange(loc.targetRange);\n+\n+        const doc = await vscode.workspace.openTextDocument(uri);\n+        const e = await vscode.window.showTextDocument(doc);\n+        e.selection = new vscode.Selection(range.start, range.start);\n+        e.revealRange(range, vscode.TextEditorRevealType.InCenter);\n+    };\n+}\n+\n+export function ssr(ctx: Ctx): Cmd {\n+    return async () => {\n+        const client = ctx.client;\n+        if (!client) return;\n+\n+        const options: vscode.InputBoxOptions = {\n+            value: \"() ==>> ()\",\n+            prompt: \"Enter request, for example 'Foo($a:expr) ==> Foo::new($a)' \",\n+            validateInput: async (x: string) => {\n+                try {\n+                    await client.sendRequest(ra.ssr, { query: x, parseOnly: true });\n+                } catch (e) {\n+                    return e.toString();\n+                }\n+                return null;\n+            }\n+        };\n+        const request = await vscode.window.showInputBox(options);\n+        if (!request) return;\n+\n+        const edit = await client.sendRequest(ra.ssr, { query: request, parseOnly: false });\n+\n+        await vscode.workspace.applyEdit(client.protocol2CodeConverter.asWorkspaceEdit(edit));\n+    };\n+}\n+\n+export function serverVersion(ctx: Ctx): Cmd {\n+    return async () => {\n+        const { stdout } = spawnSync(ctx.serverPath, [\"--version\"], { encoding: \"utf8\" });\n+        const commitHash = stdout.slice(`rust-analyzer `.length).trim();\n+        const { releaseTag } = ctx.config.package;\n+\n+        void vscode.window.showInformationMessage(\n+            `rust-analyzer version: ${releaseTag ?? \"unreleased\"} (${commitHash})`\n+        );\n+    };\n+}\n+\n+export function toggleInlayHints(ctx: Ctx): Cmd {\n+    return async () => {\n+        await vscode\n+            .workspace\n+            .getConfiguration(`${ctx.config.rootSection}.inlayHints`)\n+            .update('enable', !ctx.config.inlayHints.enable, vscode.ConfigurationTarget.Workspace);\n+    };\n+}\n+\n+// Opens the virtual file that will show the syntax tree\n+//\n+// The contents of the file come from the `TextDocumentContentProvider`\n+export function syntaxTree(ctx: Ctx): Cmd {\n+    const tdcp = new class implements vscode.TextDocumentContentProvider {\n+        readonly uri = vscode.Uri.parse('rust-analyzer://syntaxtree/tree.rast');\n+        readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n+        constructor() {\n+            vscode.workspace.onDidChangeTextDocument(this.onDidChangeTextDocument, this, ctx.subscriptions);\n+            vscode.window.onDidChangeActiveTextEditor(this.onDidChangeActiveTextEditor, this, ctx.subscriptions);\n+        }\n+\n+        private onDidChangeTextDocument(event: vscode.TextDocumentChangeEvent) {\n+            if (isRustDocument(event.document)) {\n+                // We need to order this after language server updates, but there's no API for that.\n+                // Hence, good old sleep().\n+                void sleep(10).then(() => this.eventEmitter.fire(this.uri));\n+            }\n+        }\n+        private onDidChangeActiveTextEditor(editor: vscode.TextEditor | undefined) {\n+            if (editor && isRustEditor(editor)) {\n+                this.eventEmitter.fire(this.uri);\n+            }\n+        }\n+\n+        provideTextDocumentContent(uri: vscode.Uri, ct: vscode.CancellationToken): vscode.ProviderResult<string> {\n+            const rustEditor = ctx.activeRustEditor;\n+            if (!rustEditor) return '';\n+\n+            // When the range based query is enabled we take the range of the selection\n+            const range = uri.query === 'range=true' && !rustEditor.selection.isEmpty\n+                ? ctx.client.code2ProtocolConverter.asRange(rustEditor.selection)\n+                : null;\n+\n+            const params = { textDocument: { uri: rustEditor.document.uri.toString() }, range, };\n+            return ctx.client.sendRequest(ra.syntaxTree, params, ct);\n+        }\n+\n+        get onDidChange(): vscode.Event<vscode.Uri> {\n+            return this.eventEmitter.event;\n+        }\n+    };\n+\n+    void new AstInspector(ctx);\n+\n+    ctx.pushCleanup(vscode.workspace.registerTextDocumentContentProvider('rust-analyzer', tdcp));\n+    ctx.pushCleanup(vscode.languages.setLanguageConfiguration(\"ra_syntax_tree\", {\n+        brackets: [[\"[\", \")\"]],\n+    }));\n+\n+    return async () => {\n+        const editor = vscode.window.activeTextEditor;\n+        const rangeEnabled = !!editor && !editor.selection.isEmpty;\n+\n+        const uri = rangeEnabled\n+            ? vscode.Uri.parse(`${tdcp.uri.toString()}?range=true`)\n+            : tdcp.uri;\n+\n+        const document = await vscode.workspace.openTextDocument(uri);\n+\n+        tdcp.eventEmitter.fire(uri);\n+\n+        void await vscode.window.showTextDocument(document, {\n+            viewColumn: vscode.ViewColumn.Two,\n+            preserveFocus: true\n+        });\n+    };\n+}\n+\n+\n+// Opens the virtual file that will show the syntax tree\n+//\n+// The contents of the file come from the `TextDocumentContentProvider`\n+export function expandMacro(ctx: Ctx): Cmd {\n+    function codeFormat(expanded: ra.ExpandedMacro): string {\n+        let result = `// Recursive expansion of ${expanded.name}! macro\\n`;\n+        result += '// ' + '='.repeat(result.length - 3);\n+        result += '\\n\\n';\n+        result += expanded.expansion;\n+\n+        return result;\n+    }\n+\n+    const tdcp = new class implements vscode.TextDocumentContentProvider {\n+        uri = vscode.Uri.parse('rust-analyzer://expandMacro/[EXPANSION].rs');\n+        eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n+        async provideTextDocumentContent(_uri: vscode.Uri): Promise<string> {\n+            const editor = vscode.window.activeTextEditor;\n+            const client = ctx.client;\n+            if (!editor || !client) return '';\n+\n+            const position = editor.selection.active;\n+\n+            const expanded = await client.sendRequest(ra.expandMacro, {\n+                textDocument: { uri: editor.document.uri.toString() },\n+                position,\n+            });\n+\n+            if (expanded == null) return 'Not available';\n+\n+            return codeFormat(expanded);\n+        }\n+\n+        get onDidChange(): vscode.Event<vscode.Uri> {\n+            return this.eventEmitter.event;\n+        }\n+    }();\n+\n+    ctx.pushCleanup(\n+        vscode.workspace.registerTextDocumentContentProvider(\n+            'rust-analyzer',\n+            tdcp,\n+        ),\n+    );\n+\n+    return async () => {\n+        const document = await vscode.workspace.openTextDocument(tdcp.uri);\n+        tdcp.eventEmitter.fire(tdcp.uri);\n+        return vscode.window.showTextDocument(\n+            document,\n+            vscode.ViewColumn.Two,\n+            true,\n+        );\n+    };\n+}\n+\n+export function collectGarbage(ctx: Ctx): Cmd {\n+    return async () => ctx.client.sendRequest(ra.collectGarbage, null);\n+}\n+\n+export function showReferences(ctx: Ctx): Cmd {\n+    return (uri: string, position: lc.Position, locations: lc.Location[]) => {\n+        const client = ctx.client;\n+        if (client) {\n+            vscode.commands.executeCommand(\n+                'editor.action.showReferences',\n+                vscode.Uri.parse(uri),\n+                client.protocol2CodeConverter.asPosition(position),\n+                locations.map(client.protocol2CodeConverter.asLocation),\n+            );\n+        }\n+    };\n+}\n+\n+export function applyActionGroup(_ctx: Ctx): Cmd {\n+    return async (actions: { label: string; edit: vscode.WorkspaceEdit }[]) => {\n+        const selectedAction = await vscode.window.showQuickPick(actions);\n+        if (!selectedAction) return;\n+        await applySnippetWorkspaceEdit(selectedAction.edit);\n+    };\n+}\n+\n+export function applySnippetWorkspaceEditCommand(_ctx: Ctx): Cmd {\n+    return async (edit: vscode.WorkspaceEdit) => {\n+        await applySnippetWorkspaceEdit(edit);\n+    };\n+}\n+\n+export function run(ctx: Ctx): Cmd {\n+    let prevRunnable: RunnableQuickPick | undefined;\n+\n+    return async () => {\n+        const item = await selectRunnable(ctx, prevRunnable);\n+        if (!item) return;\n+\n+        item.detail = 'rerun';\n+        prevRunnable = item;\n+        const task = createTask(item.runnable);\n+        return await vscode.tasks.executeTask(task);\n+    };\n+}\n+\n+export function runSingle(ctx: Ctx): Cmd {\n+    return async (runnable: ra.Runnable) => {\n+        const editor = ctx.activeRustEditor;\n+        if (!editor) return;\n+\n+        const task = createTask(runnable);\n+        task.group = vscode.TaskGroup.Build;\n+        task.presentationOptions = {\n+            reveal: vscode.TaskRevealKind.Always,\n+            panel: vscode.TaskPanelKind.Dedicated,\n+            clear: true,\n+        };\n+\n+        return vscode.tasks.executeTask(task);\n+    };\n+}\n+\n+export function debug(ctx: Ctx): Cmd {\n+    let prevDebuggee: RunnableQuickPick | undefined;\n+\n+    return async () => {\n+        const item = await selectRunnable(ctx, prevDebuggee, true);\n+        if (!item) return;\n+\n+        item.detail = 'restart';\n+        prevDebuggee = item;\n+        return await startDebugSession(ctx, item.runnable);\n+    };\n+}\n+\n+export function debugSingle(ctx: Ctx): Cmd {\n+    return async (config: ra.Runnable) => {\n+        await startDebugSession(ctx, config);\n+    };\n+}\n+\n+export function newDebugConfig(ctx: Ctx): Cmd {\n+    return async () => {\n+        const item = await selectRunnable(ctx, undefined, true, false);\n+        if (!item) return;\n+\n+        await makeDebugConfig(ctx, item.runnable);\n+    };\n+}"}, {"sha": "09daa3402cf674926929e746c35b12e60ba77700", "filename": "editors/code/src/commands/analyzer_status.ts", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/editors%2Fcode%2Fsrc%2Fcommands%2Fanalyzer_status.ts", "raw_url": "https://github.com/rust-lang/rust/raw/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/editors%2Fcode%2Fsrc%2Fcommands%2Fanalyzer_status.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fanalyzer_status.ts?ref=a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e", "patch": "@@ -1,51 +0,0 @@\n-import * as vscode from 'vscode';\n-\n-import * as ra from '../rust-analyzer-api';\n-import { Ctx, Cmd } from '../ctx';\n-\n-// Shows status of rust-analyzer (for debugging)\n-export function analyzerStatus(ctx: Ctx): Cmd {\n-    let poller: NodeJS.Timer | undefined = undefined;\n-    const tdcp = new TextDocumentContentProvider(ctx);\n-\n-    ctx.pushCleanup(\n-        vscode.workspace.registerTextDocumentContentProvider(\n-            'rust-analyzer-status',\n-            tdcp,\n-        ),\n-    );\n-\n-    ctx.pushCleanup({\n-        dispose() {\n-            if (poller !== undefined) {\n-                clearInterval(poller);\n-            }\n-        },\n-    });\n-\n-    return async () => {\n-        if (poller === undefined) {\n-            poller = setInterval(() => tdcp.eventEmitter.fire(tdcp.uri), 1000);\n-        }\n-        const document = await vscode.workspace.openTextDocument(tdcp.uri);\n-        return vscode.window.showTextDocument(document, vscode.ViewColumn.Two, true);\n-    };\n-}\n-\n-class TextDocumentContentProvider implements vscode.TextDocumentContentProvider {\n-    readonly uri = vscode.Uri.parse('rust-analyzer-status://status');\n-    readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n-\n-    constructor(private readonly ctx: Ctx) {\n-    }\n-\n-    provideTextDocumentContent(_uri: vscode.Uri): vscode.ProviderResult<string> {\n-        if (!vscode.window.activeTextEditor) return '';\n-\n-        return this.ctx.client.sendRequest(ra.analyzerStatus, null);\n-    }\n-\n-    get onDidChange(): vscode.Event<vscode.Uri> {\n-        return this.eventEmitter.event;\n-    }\n-}"}, {"sha": "23f2ef1d5e362c832092e532080c411b577134b8", "filename": "editors/code/src/commands/expand_macro.ts", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/editors%2Fcode%2Fsrc%2Fcommands%2Fexpand_macro.ts", "raw_url": "https://github.com/rust-lang/rust/raw/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/editors%2Fcode%2Fsrc%2Fcommands%2Fexpand_macro.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fexpand_macro.ts?ref=a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e", "patch": "@@ -1,66 +0,0 @@\n-import * as vscode from 'vscode';\n-import * as ra from '../rust-analyzer-api';\n-\n-import { Ctx, Cmd } from '../ctx';\n-\n-// Opens the virtual file that will show the syntax tree\n-//\n-// The contents of the file come from the `TextDocumentContentProvider`\n-export function expandMacro(ctx: Ctx): Cmd {\n-    const tdcp = new TextDocumentContentProvider(ctx);\n-    ctx.pushCleanup(\n-        vscode.workspace.registerTextDocumentContentProvider(\n-            'rust-analyzer',\n-            tdcp,\n-        ),\n-    );\n-\n-    return async () => {\n-        const document = await vscode.workspace.openTextDocument(tdcp.uri);\n-        tdcp.eventEmitter.fire(tdcp.uri);\n-        return vscode.window.showTextDocument(\n-            document,\n-            vscode.ViewColumn.Two,\n-            true,\n-        );\n-    };\n-}\n-\n-function codeFormat(expanded: ra.ExpandedMacro): string {\n-    let result = `// Recursive expansion of ${expanded.name}! macro\\n`;\n-    result += '// ' + '='.repeat(result.length - 3);\n-    result += '\\n\\n';\n-    result += expanded.expansion;\n-\n-    return result;\n-}\n-\n-class TextDocumentContentProvider\n-    implements vscode.TextDocumentContentProvider {\n-    uri = vscode.Uri.parse('rust-analyzer://expandMacro/[EXPANSION].rs');\n-    eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n-\n-    constructor(private readonly ctx: Ctx) {\n-    }\n-\n-    async provideTextDocumentContent(_uri: vscode.Uri): Promise<string> {\n-        const editor = vscode.window.activeTextEditor;\n-        const client = this.ctx.client;\n-        if (!editor || !client) return '';\n-\n-        const position = editor.selection.active;\n-\n-        const expanded = await client.sendRequest(ra.expandMacro, {\n-            textDocument: { uri: editor.document.uri.toString() },\n-            position,\n-        });\n-\n-        if (expanded == null) return 'Not available';\n-\n-        return codeFormat(expanded);\n-    }\n-\n-    get onDidChange(): vscode.Event<vscode.Uri> {\n-        return this.eventEmitter.event;\n-    }\n-}"}, {"sha": "0bf1ee6e671e12ba46b06663b20d9c20ee4face4", "filename": "editors/code/src/commands/join_lines.ts", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/editors%2Fcode%2Fsrc%2Fcommands%2Fjoin_lines.ts", "raw_url": "https://github.com/rust-lang/rust/raw/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/editors%2Fcode%2Fsrc%2Fcommands%2Fjoin_lines.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fjoin_lines.ts?ref=a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e", "patch": "@@ -1,22 +0,0 @@\n-import * as ra from '../rust-analyzer-api';\n-import * as lc from 'vscode-languageclient';\n-\n-import { Ctx, Cmd } from '../ctx';\n-\n-export function joinLines(ctx: Ctx): Cmd {\n-    return async () => {\n-        const editor = ctx.activeRustEditor;\n-        const client = ctx.client;\n-        if (!editor || !client) return;\n-\n-        const items: lc.TextEdit[] = await client.sendRequest(ra.joinLines, {\n-            ranges: editor.selections.map((it) => client.code2ProtocolConverter.asRange(it)),\n-            textDocument: { uri: editor.document.uri.toString() },\n-        });\n-        editor.edit((builder) => {\n-            client.protocol2CodeConverter.asTextEdits(items).forEach((edit) => {\n-                builder.replace(edit.range, edit.newText);\n-            });\n-        });\n-    };\n-}"}, {"sha": "a60776e2d4d15cf6452abad56d391b0d0ee65a8d", "filename": "editors/code/src/commands/matching_brace.ts", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/editors%2Fcode%2Fsrc%2Fcommands%2Fmatching_brace.ts", "raw_url": "https://github.com/rust-lang/rust/raw/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/editors%2Fcode%2Fsrc%2Fcommands%2Fmatching_brace.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fmatching_brace.ts?ref=a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e", "patch": "@@ -1,27 +0,0 @@\n-import * as vscode from 'vscode';\n-import * as ra from '../rust-analyzer-api';\n-\n-import { Ctx, Cmd } from '../ctx';\n-\n-export function matchingBrace(ctx: Ctx): Cmd {\n-    return async () => {\n-        const editor = ctx.activeRustEditor;\n-        const client = ctx.client;\n-        if (!editor || !client) return;\n-\n-        const response = await client.sendRequest(ra.findMatchingBrace, {\n-            textDocument: { uri: editor.document.uri.toString() },\n-            offsets: editor.selections.map(s =>\n-                client.code2ProtocolConverter.asPosition(s.active),\n-            ),\n-        });\n-        editor.selections = editor.selections.map((sel, idx) => {\n-            const active = client.protocol2CodeConverter.asPosition(\n-                response[idx],\n-            );\n-            const anchor = sel.isEmpty ? active : sel.anchor;\n-            return new vscode.Selection(anchor, active);\n-        });\n-        editor.revealRange(editor.selection);\n-    };\n-}"}, {"sha": "a7871c31eed0bde9d209833eb2e9ff82b06df673", "filename": "editors/code/src/commands/on_enter.ts", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/editors%2Fcode%2Fsrc%2Fcommands%2Fon_enter.ts", "raw_url": "https://github.com/rust-lang/rust/raw/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/editors%2Fcode%2Fsrc%2Fcommands%2Fon_enter.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fon_enter.ts?ref=a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e", "patch": "@@ -1,35 +0,0 @@\n-import * as vscode from 'vscode';\n-import * as ra from '../rust-analyzer-api';\n-\n-import { Cmd, Ctx } from '../ctx';\n-import { applySnippetWorkspaceEdit } from '.';\n-\n-async function handleKeypress(ctx: Ctx) {\n-    const editor = ctx.activeRustEditor;\n-    const client = ctx.client;\n-\n-    if (!editor || !client) return false;\n-\n-    const change = await client.sendRequest(ra.onEnter, {\n-        textDocument: { uri: editor.document.uri.toString() },\n-        position: client.code2ProtocolConverter.asPosition(\n-            editor.selection.active,\n-        ),\n-    }).catch(_error => {\n-        // client.logFailedRequest(OnEnterRequest.type, error);\n-        return null;\n-    });\n-    if (!change) return false;\n-\n-    const workspaceEdit = client.protocol2CodeConverter.asWorkspaceEdit(change);\n-    await applySnippetWorkspaceEdit(workspaceEdit);\n-    return true;\n-}\n-\n-export function onEnter(ctx: Ctx): Cmd {\n-    return async () => {\n-        if (await handleKeypress(ctx)) return;\n-\n-        await vscode.commands.executeCommand('default:type', { text: '\\n' });\n-    };\n-}"}, {"sha": "8f78ddd71c63ad19ed28342fde235a229d540543", "filename": "editors/code/src/commands/parent_module.ts", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/editors%2Fcode%2Fsrc%2Fcommands%2Fparent_module.ts", "raw_url": "https://github.com/rust-lang/rust/raw/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/editors%2Fcode%2Fsrc%2Fcommands%2Fparent_module.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fparent_module.ts?ref=a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e", "patch": "@@ -1,29 +0,0 @@\n-import * as vscode from 'vscode';\n-import * as ra from '../rust-analyzer-api';\n-\n-import { Ctx, Cmd } from '../ctx';\n-\n-export function parentModule(ctx: Ctx): Cmd {\n-    return async () => {\n-        const editor = ctx.activeRustEditor;\n-        const client = ctx.client;\n-        if (!editor || !client) return;\n-\n-        const response = await client.sendRequest(ra.parentModule, {\n-            textDocument: { uri: editor.document.uri.toString() },\n-            position: client.code2ProtocolConverter.asPosition(\n-                editor.selection.active,\n-            ),\n-        });\n-        const loc = response[0];\n-        if (loc == null) return;\n-\n-        const uri = client.protocol2CodeConverter.asUri(loc.uri);\n-        const range = client.protocol2CodeConverter.asRange(loc.range);\n-\n-        const doc = await vscode.workspace.openTextDocument(uri);\n-        const e = await vscode.window.showTextDocument(doc);\n-        e.selection = new vscode.Selection(range.start, range.start);\n-        e.revealRange(range, vscode.TextEditorRevealType.InCenter);\n-    };\n-}"}, {"sha": "d64ac726e2cc6ad8afb07ff22a1b00d18def2b9e", "filename": "editors/code/src/commands/server_version.ts", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/editors%2Fcode%2Fsrc%2Fcommands%2Fserver_version.ts", "raw_url": "https://github.com/rust-lang/rust/raw/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/editors%2Fcode%2Fsrc%2Fcommands%2Fserver_version.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fserver_version.ts?ref=a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e", "patch": "@@ -1,15 +0,0 @@\n-import * as vscode from \"vscode\";\n-import { spawnSync } from \"child_process\";\n-import { Ctx, Cmd } from '../ctx';\n-\n-export function serverVersion(ctx: Ctx): Cmd {\n-    return async () => {\n-        const { stdout } = spawnSync(ctx.serverPath, [\"--version\"], { encoding: \"utf8\" });\n-        const commitHash = stdout.slice(`rust-analyzer `.length).trim();\n-        const { releaseTag } = ctx.config.package;\n-\n-        void vscode.window.showInformationMessage(\n-            `rust-analyzer version: ${releaseTag ?? \"unreleased\"} (${commitHash})`\n-        );\n-    };\n-}"}, {"sha": "5d40a64d28e9067548f5e528a89749484c95fbea", "filename": "editors/code/src/commands/ssr.ts", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/editors%2Fcode%2Fsrc%2Fcommands%2Fssr.ts", "raw_url": "https://github.com/rust-lang/rust/raw/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/editors%2Fcode%2Fsrc%2Fcommands%2Fssr.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fssr.ts?ref=a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e", "patch": "@@ -1,30 +0,0 @@\n-import * as vscode from 'vscode';\n-import * as ra from \"../rust-analyzer-api\";\n-\n-import { Ctx, Cmd } from '../ctx';\n-\n-export function ssr(ctx: Ctx): Cmd {\n-    return async () => {\n-        const client = ctx.client;\n-        if (!client) return;\n-\n-        const options: vscode.InputBoxOptions = {\n-            value: \"() ==>> ()\",\n-            prompt: \"Enter request, for example 'Foo($a:expr) ==> Foo::new($a)' \",\n-            validateInput: async (x: string) => {\n-                try {\n-                    await client.sendRequest(ra.ssr, { query: x, parseOnly: true });\n-                } catch (e) {\n-                    return e.toString();\n-                }\n-                return null;\n-            }\n-        };\n-        const request = await vscode.window.showInputBox(options);\n-        if (!request) return;\n-\n-        const edit = await client.sendRequest(ra.ssr, { query: request, parseOnly: false });\n-\n-        await vscode.workspace.applyEdit(client.protocol2CodeConverter.asWorkspaceEdit(edit));\n-    };\n-}"}, {"sha": "e8abf8284eb7380c8f641f369c5c006fcba8c776", "filename": "editors/code/src/config.ts", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fconfig.ts?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -8,7 +8,7 @@ export const NIGHTLY_TAG = \"nightly\";\n export class Config {\n     readonly extensionId = \"matklad.rust-analyzer\";\n \n-    private readonly rootSection = \"rust-analyzer\";\n+    readonly rootSection = \"rust-analyzer\";\n     private readonly requiresReloadOpts = [\n         \"serverPath\",\n         \"cargo\","}, {"sha": "a0c9b3ab2e64a04414e6641b14e7fc74bbae44c5", "filename": "editors/code/src/debug.ts", "status": "modified", "additions": 73, "deletions": 50, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Fdebug.ts", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Fdebug.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fdebug.ts?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,48 +1,61 @@\n import * as os from \"os\";\n import * as vscode from 'vscode';\n import * as path from 'path';\n-import * as ra from './rust-analyzer-api';\n+import * as ra from './lsp_ext';\n \n-import { Cargo } from './cargo';\n+import { Cargo } from './toolchain';\n import { Ctx } from \"./ctx\";\n \n const debugOutput = vscode.window.createOutputChannel(\"Debug\");\n type DebugConfigProvider = (config: ra.Runnable, executable: string, sourceFileMap?: Record<string, string>) => vscode.DebugConfiguration;\n \n-function getLldbDebugConfig(config: ra.Runnable, executable: string, sourceFileMap?: Record<string, string>): vscode.DebugConfiguration {\n-    return {\n-        type: \"lldb\",\n-        request: \"launch\",\n-        name: config.label,\n-        program: executable,\n-        args: config.extraArgs,\n-        cwd: config.cwd,\n-        sourceMap: sourceFileMap,\n-        sourceLanguages: [\"rust\"]\n-    };\n-}\n+export async function makeDebugConfig(ctx: Ctx, runnable: ra.Runnable): Promise<void> {\n+    const scope = ctx.activeRustEditor?.document.uri;\n+    if (!scope) return;\n \n-function getCppvsDebugConfig(config: ra.Runnable, executable: string, sourceFileMap?: Record<string, string>): vscode.DebugConfiguration {\n-    return {\n-        type: (os.platform() === \"win32\") ? \"cppvsdbg\" : \"cppdbg\",\n-        request: \"launch\",\n-        name: config.label,\n-        program: executable,\n-        args: config.extraArgs,\n-        cwd: config.cwd,\n-        sourceFileMap: sourceFileMap,\n-    };\n+    const debugConfig = await getDebugConfiguration(ctx, runnable);\n+    if (!debugConfig) return;\n+\n+    const wsLaunchSection = vscode.workspace.getConfiguration(\"launch\", scope);\n+    const configurations = wsLaunchSection.get<any[]>(\"configurations\") || [];\n+\n+    const index = configurations.findIndex(c => c.name === debugConfig.name);\n+    if (index !== -1) {\n+        const answer = await vscode.window.showErrorMessage(`Launch configuration '${debugConfig.name}' already exists!`, 'Cancel', 'Update');\n+        if (answer === \"Cancel\") return;\n+\n+        configurations[index] = debugConfig;\n+    } else {\n+        configurations.push(debugConfig);\n+    }\n+\n+    await wsLaunchSection.update(\"configurations\", configurations);\n }\n \n-async function getDebugExecutable(config: ra.Runnable): Promise<string> {\n-    const cargo = new Cargo(config.cwd || '.', debugOutput);\n-    const executable = await cargo.executableFromArgs(config.args);\n+export async function startDebugSession(ctx: Ctx, runnable: ra.Runnable): Promise<boolean> {\n+    let debugConfig: vscode.DebugConfiguration | undefined = undefined;\n+    let message = \"\";\n \n-    // if we are here, there were no compilation errors.\n-    return executable;\n+    const wsLaunchSection = vscode.workspace.getConfiguration(\"launch\");\n+    const configurations = wsLaunchSection.get<any[]>(\"configurations\") || [];\n+\n+    const index = configurations.findIndex(c => c.name === runnable.label);\n+    if (-1 !== index) {\n+        debugConfig = configurations[index];\n+        message = \" (from launch.json)\";\n+        debugOutput.clear();\n+    } else {\n+        debugConfig = await getDebugConfiguration(ctx, runnable);\n+    }\n+\n+    if (!debugConfig) return false;\n+\n+    debugOutput.appendLine(`Launching debug configuration${message}:`);\n+    debugOutput.appendLine(JSON.stringify(debugConfig, null, 2));\n+    return vscode.debug.startDebugging(undefined, debugConfig);\n }\n \n-export async function getDebugConfiguration(ctx: Ctx, config: ra.Runnable): Promise<vscode.DebugConfiguration | undefined> {\n+async function getDebugConfiguration(ctx: Ctx, runnable: ra.Runnable): Promise<vscode.DebugConfiguration | undefined> {\n     const editor = ctx.activeRustEditor;\n     if (!editor) return;\n \n@@ -78,8 +91,8 @@ export async function getDebugConfiguration(ctx: Ctx, config: ra.Runnable): Prom\n         return path.normalize(p).replace(wsFolder, '${workspaceRoot}');\n     }\n \n-    const executable = await getDebugExecutable(config);\n-    const debugConfig = knownEngines[debugEngine.id](config, simplifyPath(executable), debugOptions.sourceFileMap);\n+    const executable = await getDebugExecutable(runnable);\n+    const debugConfig = knownEngines[debugEngine.id](runnable, simplifyPath(executable), debugOptions.sourceFileMap);\n     if (debugConfig.type in debugOptions.engineSettings) {\n         const settingsMap = (debugOptions.engineSettings as any)[debugConfig.type];\n         for (var key in settingsMap) {\n@@ -100,25 +113,35 @@ export async function getDebugConfiguration(ctx: Ctx, config: ra.Runnable): Prom\n     return debugConfig;\n }\n \n-export async function startDebugSession(ctx: Ctx, config: ra.Runnable): Promise<boolean> {\n-    let debugConfig: vscode.DebugConfiguration | undefined = undefined;\n-    let message = \"\";\n-\n-    const wsLaunchSection = vscode.workspace.getConfiguration(\"launch\");\n-    const configurations = wsLaunchSection.get<any[]>(\"configurations\") || [];\n+async function getDebugExecutable(runnable: ra.Runnable): Promise<string> {\n+    const cargo = new Cargo(runnable.args.workspaceRoot || '.', debugOutput);\n+    const executable = await cargo.executableFromArgs(runnable.args.cargoArgs);\n \n-    const index = configurations.findIndex(c => c.name === config.label);\n-    if (-1 !== index) {\n-        debugConfig = configurations[index];\n-        message = \" (from launch.json)\";\n-        debugOutput.clear();\n-    } else {\n-        debugConfig = await getDebugConfiguration(ctx, config);\n-    }\n+    // if we are here, there were no compilation errors.\n+    return executable;\n+}\n \n-    if (!debugConfig) return false;\n+function getLldbDebugConfig(runnable: ra.Runnable, executable: string, sourceFileMap?: Record<string, string>): vscode.DebugConfiguration {\n+    return {\n+        type: \"lldb\",\n+        request: \"launch\",\n+        name: runnable.label,\n+        program: executable,\n+        args: runnable.args.executableArgs,\n+        cwd: runnable.args.workspaceRoot,\n+        sourceMap: sourceFileMap,\n+        sourceLanguages: [\"rust\"]\n+    };\n+}\n \n-    debugOutput.appendLine(`Launching debug configuration${message}:`);\n-    debugOutput.appendLine(JSON.stringify(debugConfig, null, 2));\n-    return vscode.debug.startDebugging(undefined, debugConfig);\n+function getCppvsDebugConfig(runnable: ra.Runnable, executable: string, sourceFileMap?: Record<string, string>): vscode.DebugConfiguration {\n+    return {\n+        type: (os.platform() === \"win32\") ? \"cppvsdbg\" : \"cppdbg\",\n+        request: \"launch\",\n+        name: runnable.label,\n+        program: executable,\n+        args: runnable.args.executableArgs,\n+        cwd: runnable.args.workspaceRoot,\n+        sourceFileMap: sourceFileMap,\n+    };\n }"}, {"sha": "9e6d6045f349cf4e99a9252e7233fb0e3dec4b12", "filename": "editors/code/src/inlay_hints.ts", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Finlay_hints.ts", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Finlay_hints.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Finlay_hints.ts?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,6 +1,6 @@\n import * as lc from \"vscode-languageclient\";\n import * as vscode from 'vscode';\n-import * as ra from './rust-analyzer-api';\n+import * as ra from './lsp_ext';\n \n import { Ctx, Disposable } from './ctx';\n import { sendRequestWithRetry, isRustDocument, RustDocument, RustEditor, sleep } from './util';"}, {"sha": "c51acfccb90a664271b147ffe31d447ddd6df467", "filename": "editors/code/src/lsp_ext.ts", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Flsp_ext.ts?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -0,0 +1,86 @@\n+/**\n+ * This file mirrors `crates/rust-analyzer/src/req.rs` declarations.\n+ */\n+\n+import * as lc from \"vscode-languageclient\";\n+\n+export const analyzerStatus = new lc.RequestType<null, string, void>(\"rust-analyzer/analyzerStatus\");\n+\n+export const collectGarbage = new lc.RequestType<null, null, void>(\"rust-analyzer/collectGarbage\");\n+\n+export interface SyntaxTreeParams {\n+    textDocument: lc.TextDocumentIdentifier;\n+    range: lc.Range | null;\n+}\n+export const syntaxTree = new lc.RequestType<SyntaxTreeParams, string, void>(\"rust-analyzer/syntaxTree\");\n+\n+\n+export interface ExpandMacroParams {\n+    textDocument: lc.TextDocumentIdentifier;\n+    position: lc.Position;\n+}\n+export interface ExpandedMacro {\n+    name: string;\n+    expansion: string;\n+}\n+export const expandMacro = new lc.RequestType<ExpandMacroParams, ExpandedMacro | null, void>(\"rust-analyzer/expandMacro\");\n+\n+export interface MatchingBraceParams {\n+    textDocument: lc.TextDocumentIdentifier;\n+    positions: lc.Position[];\n+}\n+export const matchingBrace = new lc.RequestType<MatchingBraceParams, lc.Position[], void>(\"experimental/matchingBrace\");\n+\n+export const parentModule = new lc.RequestType<lc.TextDocumentPositionParams, lc.LocationLink[], void>(\"experimental/parentModule\");\n+\n+export interface JoinLinesParams {\n+    textDocument: lc.TextDocumentIdentifier;\n+    ranges: lc.Range[];\n+}\n+export const joinLines = new lc.RequestType<JoinLinesParams, lc.TextEdit[], void>(\"experimental/joinLines\");\n+\n+export const onEnter = new lc.RequestType<lc.TextDocumentPositionParams, lc.TextEdit[], void>(\"experimental/onEnter\");\n+\n+export interface RunnablesParams {\n+    textDocument: lc.TextDocumentIdentifier;\n+    position: lc.Position | null;\n+}\n+\n+export interface Runnable {\n+    label: string;\n+    location?: lc.LocationLink;\n+    kind: \"cargo\";\n+    args: {\n+        workspaceRoot?: string;\n+        cargoArgs: string[];\n+        executableArgs: string[];\n+    };\n+}\n+export const runnables = new lc.RequestType<RunnablesParams, Runnable[], void>(\"experimental/runnables\");\n+\n+export type InlayHint = InlayHint.TypeHint | InlayHint.ParamHint | InlayHint.ChainingHint;\n+\n+export namespace InlayHint {\n+    export const enum Kind {\n+        TypeHint = \"TypeHint\",\n+        ParamHint = \"ParameterHint\",\n+        ChainingHint = \"ChainingHint\",\n+    }\n+    interface Common {\n+        range: lc.Range;\n+        label: string;\n+    }\n+    export type TypeHint = Common & { kind: Kind.TypeHint };\n+    export type ParamHint = Common & { kind: Kind.ParamHint };\n+    export type ChainingHint = Common & { kind: Kind.ChainingHint };\n+}\n+export interface InlayHintsParams {\n+    textDocument: lc.TextDocumentIdentifier;\n+}\n+export const inlayHints = new lc.RequestType<InlayHintsParams, InlayHint[], void>(\"rust-analyzer/inlayHints\");\n+\n+export interface SsrParams {\n+    query: string;\n+    parseOnly: boolean;\n+}\n+export const ssr = new lc.RequestType<SsrParams, lc.WorkspaceEdit, void>('experimental/ssr');"}, {"sha": "b7337621cb61b951089af0a9e5ca6468a4e24395", "filename": "editors/code/src/main.ts", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fmain.ts?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,7 +1,7 @@\n import * as vscode from 'vscode';\n import * as path from \"path\";\n import * as os from \"os\";\n-import { promises as fs } from \"fs\";\n+import { promises as fs, PathLike } from \"fs\";\n \n import * as commands from './commands';\n import { activateInlayHints } from './inlay_hints';\n@@ -12,9 +12,13 @@ import { log, assert, isValidExecutable } from './util';\n import { PersistentState } from './persistent_state';\n import { fetchRelease, download } from './net';\n import { activateTaskProvider } from './tasks';\n+import { setContextValue } from './util';\n+import { exec } from 'child_process';\n \n let ctx: Ctx | undefined;\n \n+const RUST_PROJECT_CONTEXT_NAME = \"inRustProject\";\n+\n export async function activate(context: vscode.ExtensionContext) {\n     // Register a \"dumb\" onEnter command for the case where server fails to\n     // start.\n@@ -53,6 +57,8 @@ export async function activate(context: vscode.ExtensionContext) {\n     // This a horribly, horribly wrong way to deal with this problem.\n     ctx = await Ctx.create(config, context, serverPath, workspaceFolder.uri.fsPath);\n \n+    setContextValue(RUST_PROJECT_CONTEXT_NAME, true);\n+\n     // Commands which invokes manually via command palette, shortcut, etc.\n \n     // Reloading is inspired by @DanTup maneuver: https://github.com/microsoft/vscode/issues/45774#issuecomment-373423895\n@@ -85,12 +91,12 @@ export async function activate(context: vscode.ExtensionContext) {\n \n     ctx.registerCommand('ssr', commands.ssr);\n     ctx.registerCommand('serverVersion', commands.serverVersion);\n+    ctx.registerCommand('toggleInlayHints', commands.toggleInlayHints);\n \n     // Internal commands which are invoked by the server.\n     ctx.registerCommand('runSingle', commands.runSingle);\n     ctx.registerCommand('debugSingle', commands.debugSingle);\n     ctx.registerCommand('showReferences', commands.showReferences);\n-    ctx.registerCommand('applySourceChange', commands.applySourceChange);\n     ctx.registerCommand('applySnippetWorkspaceEdit', commands.applySnippetWorkspaceEditCommand);\n     ctx.registerCommand('applyActionGroup', commands.applyActionGroup);\n \n@@ -108,6 +114,7 @@ export async function activate(context: vscode.ExtensionContext) {\n }\n \n export async function deactivate() {\n+    setContextValue(RUST_PROJECT_CONTEXT_NAME, undefined);\n     await ctx?.client.stop();\n     ctx = undefined;\n }\n@@ -188,6 +195,46 @@ async function bootstrapServer(config: Config, state: PersistentState): Promise<\n     return path;\n }\n \n+async function patchelf(dest: PathLike): Promise<void> {\n+    await vscode.window.withProgress(\n+        {\n+            location: vscode.ProgressLocation.Notification,\n+            title: \"Patching rust-analyzer for NixOS\"\n+        },\n+        async (progress, _) => {\n+            const expression = `\n+            {src, pkgs ? import <nixpkgs> {}}:\n+                pkgs.stdenv.mkDerivation {\n+                    name = \"rust-analyzer\";\n+                    inherit src;\n+                    phases = [ \"installPhase\" \"fixupPhase\" ];\n+                    installPhase = \"cp $src $out\";\n+                    fixupPhase = ''\n+                    chmod 755 $out\n+                    patchelf --set-interpreter \"$(cat $NIX_CC/nix-support/dynamic-linker)\" $out\n+                    '';\n+                }\n+            `;\n+            const origFile = dest + \"-orig\";\n+            await fs.rename(dest, origFile);\n+            progress.report({ message: \"Patching executable\", increment: 20 });\n+            await new Promise((resolve, reject) => {\n+                const handle = exec(`nix-build -E - --arg src '${origFile}' -o ${dest}`,\n+                    (err, stdout, stderr) => {\n+                        if (err != null) {\n+                            reject(Error(stderr));\n+                        } else {\n+                            resolve(stdout);\n+                        }\n+                    });\n+                handle.stdin?.write(expression);\n+                handle.stdin?.end();\n+            });\n+            await fs.unlink(origFile);\n+        }\n+    );\n+}\n+\n async function getServer(config: Config, state: PersistentState): Promise<string | undefined> {\n     const explicitPath = process.env.__RA_LSP_SERVER_DEBUG ?? config.serverPath;\n     if (explicitPath) {\n@@ -237,6 +284,12 @@ async function getServer(config: Config, state: PersistentState): Promise<string\n     assert(!!artifact, `Bad release: ${JSON.stringify(release)}`);\n \n     await download(artifact.browser_download_url, dest, \"Downloading rust-analyzer server\", { mode: 0o755 });\n+\n+    // Patching executable if that's NixOS.\n+    if (await fs.stat(\"/etc/nixos\").then(_ => true).catch(_ => false)) {\n+        await patchelf(dest);\n+    }\n+\n     await state.updateServerVersion(config.package.version);\n     return dest;\n }"}, {"sha": "5c790741f3874b7017741e9f68f65b63359f301d", "filename": "editors/code/src/run.ts", "status": "renamed", "additions": 22, "deletions": 94, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Frun.ts", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Frun.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Frun.ts?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,13 +1,14 @@\n import * as vscode from 'vscode';\n import * as lc from 'vscode-languageclient';\n-import * as ra from '../rust-analyzer-api';\n+import * as ra from './lsp_ext';\n+import * as toolchain from \"./toolchain\";\n \n-import { Ctx, Cmd } from '../ctx';\n-import { startDebugSession, getDebugConfiguration } from '../debug';\n+import { Ctx } from './ctx';\n+import { makeDebugConfig } from './debug';\n \n const quickPickButtons = [{ iconPath: new vscode.ThemeIcon(\"save\"), tooltip: \"Save as a launch.json configurtation.\" }];\n \n-async function selectRunnable(ctx: Ctx, prevRunnable?: RunnableQuickPick, debuggeeOnly = false, showButtons: boolean = true): Promise<RunnableQuickPick | undefined> {\n+export async function selectRunnable(ctx: Ctx, prevRunnable?: RunnableQuickPick, debuggeeOnly = false, showButtons: boolean = true): Promise<RunnableQuickPick | undefined> {\n     const editor = ctx.activeRustEditor;\n     const client = ctx.client;\n     if (!editor || !client) return;\n@@ -64,7 +65,7 @@ async function selectRunnable(ctx: Ctx, prevRunnable?: RunnableQuickPick, debugg\n             quickPick.onDidHide(() => close()),\n             quickPick.onDidAccept(() => close(quickPick.selectedItems[0])),\n             quickPick.onDidTriggerButton((_button) => {\n-                (async () => await makeDebugConfig(ctx, quickPick.activeItems[0]))();\n+                (async () => await makeDebugConfig(ctx, quickPick.activeItems[0].runnable))();\n                 close();\n             }),\n             quickPick.onDidChangeActive((active) => {\n@@ -83,89 +84,7 @@ async function selectRunnable(ctx: Ctx, prevRunnable?: RunnableQuickPick, debugg\n     });\n }\n \n-export function run(ctx: Ctx): Cmd {\n-    let prevRunnable: RunnableQuickPick | undefined;\n-\n-    return async () => {\n-        const item = await selectRunnable(ctx, prevRunnable);\n-        if (!item) return;\n-\n-        item.detail = 'rerun';\n-        prevRunnable = item;\n-        const task = createTask(item.runnable);\n-        return await vscode.tasks.executeTask(task);\n-    };\n-}\n-\n-export function runSingle(ctx: Ctx): Cmd {\n-    return async (runnable: ra.Runnable) => {\n-        const editor = ctx.activeRustEditor;\n-        if (!editor) return;\n-\n-        const task = createTask(runnable);\n-        task.group = vscode.TaskGroup.Build;\n-        task.presentationOptions = {\n-            reveal: vscode.TaskRevealKind.Always,\n-            panel: vscode.TaskPanelKind.Dedicated,\n-            clear: true,\n-        };\n-\n-        return vscode.tasks.executeTask(task);\n-    };\n-}\n-\n-export function debug(ctx: Ctx): Cmd {\n-    let prevDebuggee: RunnableQuickPick | undefined;\n-\n-    return async () => {\n-        const item = await selectRunnable(ctx, prevDebuggee, true);\n-        if (!item) return;\n-\n-        item.detail = 'restart';\n-        prevDebuggee = item;\n-        return await startDebugSession(ctx, item.runnable);\n-    };\n-}\n-\n-export function debugSingle(ctx: Ctx): Cmd {\n-    return async (config: ra.Runnable) => {\n-        await startDebugSession(ctx, config);\n-    };\n-}\n-\n-async function makeDebugConfig(ctx: Ctx, item: RunnableQuickPick): Promise<void> {\n-    const scope = ctx.activeRustEditor?.document.uri;\n-    if (!scope) return;\n-\n-    const debugConfig = await getDebugConfiguration(ctx, item.runnable);\n-    if (!debugConfig) return;\n-\n-    const wsLaunchSection = vscode.workspace.getConfiguration(\"launch\", scope);\n-    const configurations = wsLaunchSection.get<any[]>(\"configurations\") || [];\n-\n-    const index = configurations.findIndex(c => c.name === debugConfig.name);\n-    if (index !== -1) {\n-        const answer = await vscode.window.showErrorMessage(`Launch configuration '${debugConfig.name}' already exists!`, 'Cancel', 'Update');\n-        if (answer === \"Cancel\") return;\n-\n-        configurations[index] = debugConfig;\n-    } else {\n-        configurations.push(debugConfig);\n-    }\n-\n-    await wsLaunchSection.update(\"configurations\", configurations);\n-}\n-\n-export function newDebugConfig(ctx: Ctx): Cmd {\n-    return async () => {\n-        const item = await selectRunnable(ctx, undefined, true, false);\n-        if (!item) return;\n-\n-        await makeDebugConfig(ctx, item);\n-    };\n-}\n-\n-class RunnableQuickPick implements vscode.QuickPickItem {\n+export class RunnableQuickPick implements vscode.QuickPickItem {\n     public label: string;\n     public description?: string | undefined;\n     public detail?: string | undefined;\n@@ -184,18 +103,27 @@ interface CargoTaskDefinition extends vscode.TaskDefinition {\n     env?: { [key: string]: string };\n }\n \n-function createTask(spec: ra.Runnable): vscode.Task {\n+export function createTask(runnable: ra.Runnable): vscode.Task {\n     const TASK_SOURCE = 'Rust';\n+\n+    let command;\n+    switch (runnable.kind) {\n+        case \"cargo\": command = toolchain.getPathForExecutable(\"cargo\");\n+    }\n+    const args = runnable.args.cargoArgs;\n+    if (runnable.args.executableArgs.length > 0) {\n+        args.push('--', ...runnable.args.executableArgs);\n+    }\n     const definition: CargoTaskDefinition = {\n         type: 'cargo',\n-        label: spec.label,\n-        command: spec.bin,\n-        args: spec.extraArgs ? [...spec.args, '--', ...spec.extraArgs] : spec.args,\n-        env: spec.env,\n+        label: runnable.label,\n+        command,\n+        args,\n+        env: Object.assign({}, process.env as { [key: string]: string }, { \"RUST_BACKTRACE\": \"short\" }),\n     };\n \n     const execOption: vscode.ShellExecutionOptions = {\n-        cwd: spec.cwd || '.',\n+        cwd: runnable.args.workspaceRoot || '.',\n         env: definition.env,\n     };\n     const exec = new vscode.ShellExecution(", "previous_filename": "editors/code/src/commands/runnables.ts"}, {"sha": "73f36432f649b06f4c6dc25597ee9783d85e137a", "filename": "editors/code/src/rust-analyzer-api.ts", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/editors%2Fcode%2Fsrc%2Frust-analyzer-api.ts", "raw_url": "https://github.com/rust-lang/rust/raw/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/editors%2Fcode%2Fsrc%2Frust-analyzer-api.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Frust-analyzer-api.ts?ref=a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e", "patch": "@@ -1,125 +0,0 @@\n-/**\n- * This file mirrors `crates/rust-analyzer/src/req.rs` declarations.\n- */\n-\n-import * as lc from \"vscode-languageclient\";\n-\n-type Option<T> = null | T;\n-type Vec<T> = T[];\n-type FxHashMap<K extends PropertyKey, V> = Record<K, V>;\n-\n-function request<TParams, TResult>(method: string) {\n-    return new lc.RequestType<TParams, TResult, unknown>(`rust-analyzer/${method}`);\n-}\n-function notification<TParam>(method: string) {\n-    return new lc.NotificationType<TParam>(method);\n-}\n-\n-\n-export const analyzerStatus = request<null, string>(\"analyzerStatus\");\n-\n-\n-export const collectGarbage = request<null, null>(\"collectGarbage\");\n-\n-\n-export interface SyntaxTreeParams {\n-    textDocument: lc.TextDocumentIdentifier;\n-    range: Option<lc.Range>;\n-}\n-export const syntaxTree = request<SyntaxTreeParams, string>(\"syntaxTree\");\n-\n-\n-export interface ExpandMacroParams {\n-    textDocument: lc.TextDocumentIdentifier;\n-    position: Option<lc.Position>;\n-}\n-export interface ExpandedMacro {\n-    name: string;\n-    expansion: string;\n-}\n-export const expandMacro = request<ExpandMacroParams, Option<ExpandedMacro>>(\"expandMacro\");\n-\n-\n-export interface FindMatchingBraceParams {\n-    textDocument: lc.TextDocumentIdentifier;\n-    offsets: Vec<lc.Position>;\n-}\n-export const findMatchingBrace = request<FindMatchingBraceParams, Vec<lc.Position>>(\"findMatchingBrace\");\n-\n-\n-export interface PublishDecorationsParams {\n-    uri: string;\n-    decorations: Vec<Decoration>;\n-}\n-export interface Decoration {\n-    range: lc.Range;\n-    tag: string;\n-    bindingHash: Option<string>;\n-}\n-export const decorationsRequest = request<lc.TextDocumentIdentifier, Vec<Decoration>>(\"decorationsRequest\");\n-\n-\n-export const parentModule = request<lc.TextDocumentPositionParams, Vec<lc.Location>>(\"parentModule\");\n-\n-\n-export interface JoinLinesParams {\n-    textDocument: lc.TextDocumentIdentifier;\n-    ranges: lc.Range[];\n-}\n-export const joinLines = new lc.RequestType<JoinLinesParams, lc.TextEdit[], unknown>('experimental/joinLines');\n-\n-\n-export const onEnter = request<lc.TextDocumentPositionParams, Option<lc.WorkspaceEdit>>(\"onEnter\");\n-\n-export interface RunnablesParams {\n-    textDocument: lc.TextDocumentIdentifier;\n-    position: Option<lc.Position>;\n-}\n-export interface Runnable {\n-    range: lc.Range;\n-    label: string;\n-    bin: string;\n-    args: Vec<string>;\n-    extraArgs: Vec<string>;\n-    env: FxHashMap<string, string>;\n-    cwd: Option<string>;\n-}\n-export const runnables = request<RunnablesParams, Vec<Runnable>>(\"runnables\");\n-\n-export type InlayHint = InlayHint.TypeHint | InlayHint.ParamHint | InlayHint.ChainingHint;\n-\n-export namespace InlayHint {\n-    export const enum Kind {\n-        TypeHint = \"TypeHint\",\n-        ParamHint = \"ParameterHint\",\n-        ChainingHint = \"ChainingHint\",\n-    }\n-    interface Common {\n-        range: lc.Range;\n-        label: string;\n-    }\n-    export type TypeHint = Common & { kind: Kind.TypeHint };\n-    export type ParamHint = Common & { kind: Kind.ParamHint };\n-    export type ChainingHint = Common & { kind: Kind.ChainingHint };\n-}\n-export interface InlayHintsParams {\n-    textDocument: lc.TextDocumentIdentifier;\n-}\n-export const inlayHints = request<InlayHintsParams, Vec<InlayHint>>(\"inlayHints\");\n-\n-\n-export interface SsrParams {\n-    query: string;\n-    parseOnly: boolean;\n-}\n-export const ssr = new lc.RequestType<SsrParams, lc.WorkspaceEdit, unknown>('experimental/ssr');\n-\n-\n-export const publishDecorations = notification<PublishDecorationsParams>(\"publishDecorations\");\n-\n-\n-export interface SourceChange {\n-    label: string;\n-    workspaceEdit: lc.WorkspaceEdit;\n-    cursorPosition: Option<lc.TextDocumentPositionParams>;\n-}"}, {"sha": "bcb3f2cc76135346814e1315450fffc661fa4574", "filename": "editors/code/src/snippets.ts", "status": "renamed", "additions": 4, "deletions": 54, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Fsnippets.ts", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Fsnippets.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fsnippets.ts?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,67 +1,17 @@\n import * as vscode from 'vscode';\n-import * as lc from 'vscode-languageclient';\n-import * as ra from '../rust-analyzer-api';\n \n-import { Ctx, Cmd } from '../ctx';\n-import * as sourceChange from '../source_change';\n-import { assert } from '../util';\n-\n-export * from './analyzer_status';\n-export * from './matching_brace';\n-export * from './join_lines';\n-export * from './on_enter';\n-export * from './parent_module';\n-export * from './syntax_tree';\n-export * from './expand_macro';\n-export * from './runnables';\n-export * from './ssr';\n-export * from './server_version';\n-\n-export function collectGarbage(ctx: Ctx): Cmd {\n-    return async () => ctx.client.sendRequest(ra.collectGarbage, null);\n-}\n-\n-export function showReferences(ctx: Ctx): Cmd {\n-    return (uri: string, position: lc.Position, locations: lc.Location[]) => {\n-        const client = ctx.client;\n-        if (client) {\n-            vscode.commands.executeCommand(\n-                'editor.action.showReferences',\n-                vscode.Uri.parse(uri),\n-                client.protocol2CodeConverter.asPosition(position),\n-                locations.map(client.protocol2CodeConverter.asLocation),\n-            );\n-        }\n-    };\n-}\n-\n-export function applySourceChange(ctx: Ctx): Cmd {\n-    return async (change: ra.SourceChange) => {\n-        await sourceChange.applySourceChange(ctx, change);\n-    };\n-}\n-\n-export function applyActionGroup(_ctx: Ctx): Cmd {\n-    return async (actions: { label: string; edit: vscode.WorkspaceEdit }[]) => {\n-        const selectedAction = await vscode.window.showQuickPick(actions);\n-        if (!selectedAction) return;\n-        await applySnippetWorkspaceEdit(selectedAction.edit);\n-    };\n-}\n-\n-export function applySnippetWorkspaceEditCommand(_ctx: Ctx): Cmd {\n-    return async (edit: vscode.WorkspaceEdit) => {\n-        await applySnippetWorkspaceEdit(edit);\n-    };\n-}\n+import { assert } from './util';\n \n export async function applySnippetWorkspaceEdit(edit: vscode.WorkspaceEdit) {\n     assert(edit.entries().length === 1, `bad ws edit: ${JSON.stringify(edit)}`);\n     const [uri, edits] = edit.entries()[0];\n \n     const editor = vscode.window.visibleTextEditors.find((it) => it.document.uri.toString() === uri.toString());\n     if (!editor) return;\n+    await applySnippetTextEdits(editor, edits);\n+}\n \n+export async function applySnippetTextEdits(editor: vscode.TextEditor, edits: vscode.TextEdit[]) {\n     let selection: vscode.Selection | undefined = undefined;\n     let lineDelta = 0;\n     await editor.edit((builder) => {", "previous_filename": "editors/code/src/commands/index.ts"}, {"sha": "af8f1df51126aac4d2cdb7971af470174aab3b56", "filename": "editors/code/src/source_change.ts", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/editors%2Fcode%2Fsrc%2Fsource_change.ts", "raw_url": "https://github.com/rust-lang/rust/raw/a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e/editors%2Fcode%2Fsrc%2Fsource_change.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fsource_change.ts?ref=a9d567584857b1be4ca8eaa5ef2c7d85f7b2845e", "patch": "@@ -1,54 +0,0 @@\n-import * as vscode from 'vscode';\n-import * as lc from 'vscode-languageclient';\n-import * as ra from './rust-analyzer-api';\n-\n-import { Ctx } from './ctx';\n-\n-export async function applySourceChange(ctx: Ctx, change: ra.SourceChange) {\n-    const client = ctx.client;\n-    if (!client) return;\n-\n-    const wsEdit = client.protocol2CodeConverter.asWorkspaceEdit(\n-        change.workspaceEdit,\n-    );\n-    let created;\n-    let moved;\n-    if (change.workspaceEdit.documentChanges) {\n-        for (const docChange of change.workspaceEdit.documentChanges) {\n-            if (lc.CreateFile.is(docChange)) {\n-                created = docChange.uri;\n-            } else if (lc.RenameFile.is(docChange)) {\n-                moved = docChange.newUri;\n-            }\n-        }\n-    }\n-    const toOpen = created || moved;\n-    const toReveal = change.cursorPosition;\n-    await vscode.workspace.applyEdit(wsEdit);\n-    if (toOpen) {\n-        const toOpenUri = vscode.Uri.parse(toOpen);\n-        const doc = await vscode.workspace.openTextDocument(toOpenUri);\n-        await vscode.window.showTextDocument(doc);\n-    } else if (toReveal) {\n-        const uri = client.protocol2CodeConverter.asUri(\n-            toReveal.textDocument.uri,\n-        );\n-        const position = client.protocol2CodeConverter.asPosition(\n-            toReveal.position,\n-        );\n-        const editor = vscode.window.activeTextEditor;\n-        if (!editor || !editor.selection.isEmpty) {\n-            return;\n-        }\n-\n-        if (editor.document.uri !== uri) {\n-            const doc = await vscode.workspace.openTextDocument(uri);\n-            await vscode.window.showTextDocument(doc);\n-        }\n-        editor.selection = new vscode.Selection(position, position);\n-        editor.revealRange(\n-            new vscode.Range(position, position),\n-            vscode.TextEditorRevealType.Default,\n-        );\n-    }\n-}"}, {"sha": "9748824df38ffb662312d258308122fb40d023cf", "filename": "editors/code/src/tasks.ts", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Ftasks.ts", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Ftasks.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftasks.ts?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,4 +1,5 @@\n import * as vscode from 'vscode';\n+import * as toolchain from \"./toolchain\";\n \n // This ends up as the `type` key in tasks.json. RLS also uses `cargo` and\n // our configuration should be compatible with it so use the same key.\n@@ -24,6 +25,8 @@ class CargoTaskProvider implements vscode.TaskProvider {\n         // set of tasks that always exist. These tasks cannot be removed in\n         // tasks.json - only tweaked.\n \n+        const cargoPath = toolchain.cargoPath();\n+\n         return [\n             { command: 'build', group: vscode.TaskGroup.Build },\n             { command: 'check', group: vscode.TaskGroup.Build },\n@@ -46,7 +49,7 @@ class CargoTaskProvider implements vscode.TaskProvider {\n                     `cargo ${command}`,\n                     'rust',\n                     // What to do when this command is executed.\n-                    new vscode.ShellExecution('cargo', [command]),\n+                    new vscode.ShellExecution(cargoPath, [command]),\n                     // Problem matchers.\n                     ['$rustc'],\n                 );\n@@ -80,4 +83,4 @@ class CargoTaskProvider implements vscode.TaskProvider {\n export function activateTaskProvider(target: vscode.WorkspaceFolder): vscode.Disposable {\n     const provider = new CargoTaskProvider(target);\n     return vscode.tasks.registerTaskProvider(TASK_TYPE, provider);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "80a7915e90e8972d30581ef419fc56ab8ce48526", "filename": "editors/code/src/toolchain.ts", "status": "renamed", "additions": 81, "deletions": 47, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Ftoolchain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Ftoolchain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftoolchain.ts?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,9 +1,10 @@\n import * as cp from 'child_process';\n import * as os from 'os';\n import * as path from 'path';\n+import * as fs from 'fs';\n import * as readline from 'readline';\n import { OutputChannel } from 'vscode';\n-import { isValidExecutable } from './util';\n+import { log, memoize } from './util';\n \n interface CompilationArtifact {\n     fileName: string;\n@@ -12,14 +13,45 @@ interface CompilationArtifact {\n     isTest: boolean;\n }\n \n+export interface ArtifactSpec {\n+    cargoArgs: string[];\n+    filter?: (artifacts: CompilationArtifact[]) => CompilationArtifact[];\n+}\n+\n export class Cargo {\n     constructor(readonly rootFolder: string, readonly output: OutputChannel) { }\n \n-    private async artifactsFromArgs(cargoArgs: string[]): Promise<CompilationArtifact[]> {\n+    // Made public for testing purposes\n+    static artifactSpec(args: readonly string[]): ArtifactSpec {\n+        const cargoArgs = [...args, \"--message-format=json\"];\n+\n+        // arguments for a runnable from the quick pick should be updated.\n+        // see crates\\rust-analyzer\\src\\main_loop\\handlers.rs, handle_code_lens\n+        switch (cargoArgs[0]) {\n+            case \"run\": cargoArgs[0] = \"build\"; break;\n+            case \"test\": {\n+                if (!cargoArgs.includes(\"--no-run\")) {\n+                    cargoArgs.push(\"--no-run\");\n+                }\n+                break;\n+            }\n+        }\n+\n+        const result: ArtifactSpec = { cargoArgs: cargoArgs };\n+        if (cargoArgs[0] === \"test\") {\n+            // for instance, `crates\\rust-analyzer\\tests\\heavy_tests\\main.rs` tests\n+            // produce 2 artifacts: {\"kind\": \"bin\"} and {\"kind\": \"test\"}\n+            result.filter = (artifacts) => artifacts.filter(it => it.isTest);\n+        }\n+\n+        return result;\n+    }\n+\n+    private async getArtifacts(spec: ArtifactSpec): Promise<CompilationArtifact[]> {\n         const artifacts: CompilationArtifact[] = [];\n \n         try {\n-            await this.runCargo(cargoArgs,\n+            await this.runCargo(spec.cargoArgs,\n                 message => {\n                     if (message.reason === 'compiler-artifact' && message.executable) {\n                         const isBinary = message.target.crate_types.includes('bin');\n@@ -43,30 +75,11 @@ export class Cargo {\n             throw new Error(`Cargo invocation has failed: ${err}`);\n         }\n \n-        return artifacts;\n+        return spec.filter?.(artifacts) ?? artifacts;\n     }\n \n     async executableFromArgs(args: readonly string[]): Promise<string> {\n-        const cargoArgs = [...args, \"--message-format=json\"];\n-\n-        // arguments for a runnable from the quick pick should be updated.\n-        // see crates\\rust-analyzer\\src\\main_loop\\handlers.rs, handle_code_lens\n-        switch (cargoArgs[0]) {\n-            case \"run\": cargoArgs[0] = \"build\"; break;\n-            case \"test\": {\n-                if (cargoArgs.indexOf(\"--no-run\") === -1) {\n-                    cargoArgs.push(\"--no-run\");\n-                }\n-                break;\n-            }\n-        }\n-\n-        let artifacts = await this.artifactsFromArgs(cargoArgs);\n-        if (cargoArgs[0] === \"test\") {\n-            // for instance, `crates\\rust-analyzer\\tests\\heavy_tests\\main.rs` tests\n-            // produce 2 artifacts: {\"kind\": \"bin\"} and {\"kind\": \"test\"}\n-            artifacts = artifacts.filter(a => a.isTest);\n-        }\n+        const artifacts = await this.getArtifacts(Cargo.artifactSpec(args));\n \n         if (artifacts.length === 0) {\n             throw new Error('No compilation artifacts');\n@@ -83,14 +96,7 @@ export class Cargo {\n         onStderrString: (data: string) => void\n     ): Promise<number> {\n         return new Promise((resolve, reject) => {\n-            let cargoPath;\n-            try {\n-                cargoPath = getCargoPathOrFail();\n-            } catch (err) {\n-                return reject(err);\n-            }\n-\n-            const cargo = cp.spawn(cargoPath, cargoArgs, {\n+            const cargo = cp.spawn(cargoPath(), cargoArgs, {\n                 stdio: ['ignore', 'pipe', 'pipe'],\n                 cwd: this.rootFolder\n             });\n@@ -115,26 +121,54 @@ export class Cargo {\n     }\n }\n \n-// Mirrors `ra_env::get_path_for_executable` implementation\n-function getCargoPathOrFail(): string {\n-    const envVar = process.env.CARGO;\n-    const executableName = \"cargo\";\n+/** Mirrors `ra_toolchain::cargo()` implementation */\n+export function cargoPath(): string {\n+    return getPathForExecutable(\"cargo\");\n+}\n+\n+/** Mirrors `ra_toolchain::get_path_for_executable()` implementation */\n+export const getPathForExecutable = memoize(\n+    // We apply caching to decrease file-system interactions\n+    (executableName: \"cargo\" | \"rustc\" | \"rustup\"): string => {\n+        {\n+            const envVar = process.env[executableName.toUpperCase()];\n+            if (envVar) return envVar;\n+        }\n+\n+        if (lookupInPath(executableName)) return executableName;\n \n-    if (envVar) {\n-        if (isValidExecutable(envVar)) return envVar;\n+        try {\n+            // hmm, `os.homedir()` seems to be infallible\n+            // it is not mentioned in docs and cannot be infered by the type signature...\n+            const standardPath = path.join(os.homedir(), \".cargo\", \"bin\", executableName);\n \n-        throw new Error(`\\`${envVar}\\` environment variable points to something that's not a valid executable`);\n+            if (isFile(standardPath)) return standardPath;\n+        } catch (err) {\n+            log.error(\"Failed to read the fs info\", err);\n+        }\n+        return executableName;\n     }\n+);\n \n-    if (isValidExecutable(executableName)) return executableName;\n+function lookupInPath(exec: string): boolean {\n+    const paths = process.env.PATH ?? \"\";;\n \n-    const standardLocation = path.join(os.homedir(), '.cargo', 'bin', executableName);\n+    const candidates = paths.split(path.delimiter).flatMap(dirInPath => {\n+        const candidate = path.join(dirInPath, exec);\n+        return os.type() === \"Windows_NT\"\n+            ? [candidate, `${candidate}.exe`]\n+            : [candidate];\n+    });\n \n-    if (isValidExecutable(standardLocation)) return standardLocation;\n+    return candidates.some(isFile);\n+}\n \n-    throw new Error(\n-        `Failed to find \\`${executableName}\\` executable. ` +\n-        `Make sure \\`${executableName}\\` is in \\`$PATH\\`, ` +\n-        `or set \\`${envVar}\\` to point to a valid executable.`\n-    );\n+function isFile(suspectPath: string): boolean {\n+    // It is not mentionned in docs, but `statSync()` throws an error when\n+    // the path doesn't exist\n+    try {\n+        return fs.statSync(suspectPath).isFile();\n+    } catch {\n+        return false;\n+    }\n }", "previous_filename": "editors/code/src/cargo.ts"}, {"sha": "fe3fb71cd7dc28c0b9493e61d81856e174d66ac2", "filename": "editors/code/src/util.ts", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Futil.ts", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Fsrc%2Futil.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Futil.ts?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -74,10 +74,11 @@ export type RustDocument = vscode.TextDocument & { languageId: \"rust\" };\n export type RustEditor = vscode.TextEditor & { document: RustDocument };\n \n export function isRustDocument(document: vscode.TextDocument): document is RustDocument {\n-    return document.languageId === 'rust'\n-        // SCM diff views have the same URI as the on-disk document but not the same content\n-        && document.uri.scheme !== 'git'\n-        && document.uri.scheme !== 'svn';\n+    // Prevent corrupted text (particularly via inlay hints) in diff views\n+    // by allowing only `file` schemes\n+    // unfortunately extensions that use diff views not always set this\n+    // to something different than 'file' (see ongoing bug: #4608)\n+    return document.languageId === 'rust' && document.uri.scheme === 'file';\n }\n \n export function isRustEditor(editor: vscode.TextEditor): editor is RustEditor {\n@@ -93,3 +94,26 @@ export function isValidExecutable(path: string): boolean {\n \n     return res.status === 0;\n }\n+\n+/** Sets ['when'](https://code.visualstudio.com/docs/getstarted/keybindings#_when-clause-contexts) clause contexts */\n+export function setContextValue(key: string, value: any): Thenable<void> {\n+    return vscode.commands.executeCommand('setContext', key, value);\n+}\n+\n+/**\n+ * Returns a higher-order function that caches the results of invoking the\n+ * underlying function.\n+ */\n+export function memoize<Ret, TThis, Param extends string>(func: (this: TThis, arg: Param) => Ret) {\n+    const cache = new Map<string, Ret>();\n+\n+    return function(this: TThis, arg: Param) {\n+        const cached = cache.get(arg);\n+        if (cached) return cached;\n+\n+        const result = func.call(this, arg);\n+        cache.set(arg, result);\n+\n+        return result;\n+    };\n+}"}, {"sha": "22df80ad318e5ef9106f9b7946daeb7507af9748", "filename": "editors/code/tests/runTests.ts", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Ftests%2FrunTests.ts", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Ftests%2FrunTests.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Ftests%2FrunTests.ts?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -0,0 +1,43 @@\n+import * as path from 'path';\n+import * as fs from 'fs';\n+\n+import { runTests } from 'vscode-test';\n+\n+async function main() {\n+    // The folder containing the Extension Manifest package.json\n+    // Passed to `--extensionDevelopmentPath`\n+    const extensionDevelopmentPath = path.resolve(__dirname, '../../');\n+\n+    // Minimum supported version.\n+    const jsonData = fs.readFileSync(path.join(extensionDevelopmentPath, 'package.json'));\n+    const json = JSON.parse(jsonData.toString());\n+    let minimalVersion: string = json.engines.vscode;\n+    if (minimalVersion.startsWith('^')) minimalVersion = minimalVersion.slice(1);\n+\n+    const launchArgs = [\"--disable-extensions\"];\n+\n+    // All test suites (either unit tests or integration tests) should be in subfolders.\n+    const extensionTestsPath = path.resolve(__dirname, './unit/index');\n+\n+    // Run tests using the minimal supported version.\n+    await runTests({\n+        version: minimalVersion,\n+        launchArgs,\n+        extensionDevelopmentPath,\n+        extensionTestsPath\n+    });\n+\n+    // and the latest one\n+    await runTests({\n+        version: 'stable',\n+        launchArgs,\n+        extensionDevelopmentPath,\n+        extensionTestsPath\n+    });\n+}\n+\n+main().catch(err => {\n+    // eslint-disable-next-line no-console\n+    console.error('Failed to run tests', err);\n+    process.exit(1);\n+});"}, {"sha": "5165720b458b89ee1ba8dc5fc17da71873f39e47", "filename": "editors/code/tests/unit/index.ts", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Ftests%2Funit%2Findex.ts", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Ftests%2Funit%2Findex.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Ftests%2Funit%2Findex.ts?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -0,0 +1,38 @@\n+import * as path from 'path';\n+import Mocha from 'mocha';\n+import glob from 'glob';\n+\n+export function run(): Promise<void> {\n+    // Create the mocha test\n+    const mocha = new Mocha({\n+        ui: 'tdd',\n+        color: true\n+    });\n+\n+    const testsRoot = __dirname;\n+\n+    return new Promise((resolve, reject) => {\n+        glob('**/**.test.js', { cwd: testsRoot }, (err, files) => {\n+            if (err) {\n+                return reject(err);\n+            }\n+\n+            // Add files to the test suite\n+            files.forEach(f => mocha.addFile(path.resolve(testsRoot, f)));\n+\n+            try {\n+                // Run the mocha test\n+                mocha.timeout(100000);\n+                mocha.run(failures => {\n+                    if (failures > 0) {\n+                        reject(new Error(`${failures} tests failed.`));\n+                    } else {\n+                        resolve();\n+                    }\n+                });\n+            } catch (err) {\n+                reject(err);\n+            }\n+        });\n+    });\n+}"}, {"sha": "68794d53ede11b9c1f062500460d24f7b2f99470", "filename": "editors/code/tests/unit/launch_config.test.ts", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Ftests%2Funit%2Flaunch_config.test.ts", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Ftests%2Funit%2Flaunch_config.test.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Ftests%2Funit%2Flaunch_config.test.ts?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -0,0 +1,52 @@\n+import * as assert from 'assert';\n+import { Cargo } from '../../src/toolchain';\n+\n+suite('Launch configuration', () => {\n+\n+    suite('Lens', () => {\n+        test('A binary', async () => {\n+            const args = Cargo.artifactSpec([\"build\", \"--package\", \"pkg_name\", \"--bin\", \"pkg_name\"]);\n+\n+            assert.deepEqual(args.cargoArgs, [\"build\", \"--package\", \"pkg_name\", \"--bin\", \"pkg_name\", \"--message-format=json\"]);\n+            assert.deepEqual(args.filter, undefined);\n+        });\n+\n+        test('One of Multiple Binaries', async () => {\n+            const args = Cargo.artifactSpec([\"build\", \"--package\", \"pkg_name\", \"--bin\", \"bin1\"]);\n+\n+            assert.deepEqual(args.cargoArgs, [\"build\", \"--package\", \"pkg_name\", \"--bin\", \"bin1\", \"--message-format=json\"]);\n+            assert.deepEqual(args.filter, undefined);\n+        });\n+\n+        test('A test', async () => {\n+            const args = Cargo.artifactSpec([\"test\", \"--package\", \"pkg_name\", \"--lib\", \"--no-run\"]);\n+\n+            assert.deepEqual(args.cargoArgs, [\"test\", \"--package\", \"pkg_name\", \"--lib\", \"--no-run\", \"--message-format=json\"]);\n+            assert.notDeepEqual(args.filter, undefined);\n+        });\n+    });\n+\n+    suite('QuickPick', () => {\n+        test('A binary', async () => {\n+            const args = Cargo.artifactSpec([\"run\", \"--package\", \"pkg_name\", \"--bin\", \"pkg_name\"]);\n+\n+            assert.deepEqual(args.cargoArgs, [\"build\", \"--package\", \"pkg_name\", \"--bin\", \"pkg_name\", \"--message-format=json\"]);\n+            assert.deepEqual(args.filter, undefined);\n+        });\n+\n+\n+        test('One of Multiple Binaries', async () => {\n+            const args = Cargo.artifactSpec([\"run\", \"--package\", \"pkg_name\", \"--bin\", \"bin2\"]);\n+\n+            assert.deepEqual(args.cargoArgs, [\"build\", \"--package\", \"pkg_name\", \"--bin\", \"bin2\", \"--message-format=json\"]);\n+            assert.deepEqual(args.filter, undefined);\n+        });\n+\n+        test('A test', async () => {\n+            const args = Cargo.artifactSpec([\"test\", \"--package\", \"pkg_name\", \"--lib\"]);\n+\n+            assert.deepEqual(args.cargoArgs, [\"test\", \"--package\", \"pkg_name\", \"--lib\", \"--message-format=json\", \"--no-run\"]);\n+            assert.notDeepEqual(args.filter, undefined);\n+        });\n+    });\n+});"}, {"sha": "32d1a865f0a1e1329a00f21da6ebf11d38767d50", "filename": "editors/code/tsconfig.json", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Ftsconfig.json", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/editors%2Fcode%2Ftsconfig.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Ftsconfig.json?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -9,7 +9,7 @@\n         \"esModuleInterop\": true,\n         \"allowSyntheticDefaultImports\": true,\n         \"sourceMap\": true,\n-        \"rootDir\": \"src\",\n+        \"rootDir\": \".\",\n         \"strict\": true,\n         \"noUnusedLocals\": true,\n         \"noUnusedParameters\": true,\n@@ -18,6 +18,11 @@\n         \"newLine\": \"LF\"\n     },\n     \"exclude\": [\n-        \"node_modules\"\n+        \"node_modules\",\n+        \".vscode-test\"\n+    ],\n+    \"include\": [\n+        \"src\",\n+        \"tests\"\n     ]\n }"}, {"sha": "f60f0fb16ce1ad92f3bfc67138cbcfd6922207d1", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1058,7 +1058,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         /// [Reference](https://doc.rust-lang.org/reference/expressions/block-expr.html)\n         /// [Labels for blocks RFC](https://github.com/rust-lang/rfcs/blob/master/text/2046-label-break-value.md)\n         struct BlockExpr: AttrsOwner, ModuleItemOwner {\n-            T!['{'], statements: [Stmt], Expr, T!['}'],\n+            Label, T!['{'], statements: [Stmt], Expr, T!['}'],\n         }\n \n         /// Return expression.\n@@ -1153,10 +1153,12 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         /// ```\n         /// \u2770 &foo \u2771;\n         /// \u2770 &mut bar \u2771;\n+        /// \u2770 &raw const bar \u2771;\n+        /// \u2770 &raw mut bar \u2771;\n         /// ```\n         ///\n         /// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#borrow-operators)\n-        struct RefExpr: AttrsOwner { T![&], T![raw], T![mut], Expr }\n+        struct RefExpr: AttrsOwner { T![&], T![raw], T![mut], T![const], Expr }\n \n         /// Prefix operator call. This is either `!` or `*` or `-`.\n         ///"}, {"sha": "f5f4b964a4c1a2a16c05b6b25821965ead780807", "filename": "xtask/src/codegen.rs", "status": "modified", "additions": 72, "deletions": 17, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/xtask%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/xtask%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -8,13 +8,19 @@\n mod gen_syntax;\n mod gen_parser_tests;\n mod gen_assists_docs;\n+mod gen_feature_docs;\n \n-use std::{mem, path::Path};\n+use std::{\n+    fmt, mem,\n+    path::{Path, PathBuf},\n+};\n \n-use crate::{not_bash::fs2, Result};\n+use crate::{not_bash::fs2, project_root, Result};\n \n pub use self::{\n-    gen_assists_docs::generate_assists_docs, gen_parser_tests::generate_parser_tests,\n+    gen_assists_docs::{generate_assists_docs, generate_assists_tests},\n+    gen_feature_docs::generate_feature_docs,\n+    gen_parser_tests::generate_parser_tests,\n     gen_syntax::generate_syntax,\n };\n \n@@ -28,7 +34,6 @@ const AST_TOKENS: &str = \"crates/ra_syntax/src/ast/generated/tokens.rs\";\n \n const ASSISTS_DIR: &str = \"crates/ra_assists/src/handlers\";\n const ASSISTS_TESTS: &str = \"crates/ra_assists/src/tests/generated.rs\";\n-const ASSISTS_DOCS: &str = \"docs/user/assists.md\";\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n pub enum Mode {\n@@ -40,7 +45,7 @@ pub enum Mode {\n /// With verify = false,\n fn update(path: &Path, contents: &str, mode: Mode) -> Result<()> {\n     match fs2::read_to_string(path) {\n-        Ok(ref old_contents) if normalize(old_contents) == normalize(contents) => {\n+        Ok(old_contents) if normalize(&old_contents) == normalize(contents) => {\n             return Ok(());\n         }\n         _ => (),\n@@ -58,35 +63,85 @@ fn update(path: &Path, contents: &str, mode: Mode) -> Result<()> {\n }\n \n fn extract_comment_blocks(text: &str) -> Vec<Vec<String>> {\n-    do_extract_comment_blocks(text, false)\n+    do_extract_comment_blocks(text, false).into_iter().map(|(_line, block)| block).collect()\n+}\n+\n+fn extract_comment_blocks_with_empty_lines(tag: &str, text: &str) -> Vec<CommentBlock> {\n+    assert!(tag.starts_with(char::is_uppercase));\n+    let tag = format!(\"{}:\", tag);\n+    let mut res = Vec::new();\n+    for (line, mut block) in do_extract_comment_blocks(text, true) {\n+        let first = block.remove(0);\n+        if first.starts_with(&tag) {\n+            let id = first[tag.len()..].trim().to_string();\n+            let block = CommentBlock { id, line, contents: block };\n+            res.push(block);\n+        }\n+    }\n+    res\n }\n \n-fn extract_comment_blocks_with_empty_lines(text: &str) -> Vec<Vec<String>> {\n-    do_extract_comment_blocks(text, true)\n+struct CommentBlock {\n+    id: String,\n+    line: usize,\n+    contents: Vec<String>,\n }\n \n-fn do_extract_comment_blocks(text: &str, allow_blocks_with_empty_lines: bool) -> Vec<Vec<String>> {\n+fn do_extract_comment_blocks(\n+    text: &str,\n+    allow_blocks_with_empty_lines: bool,\n+) -> Vec<(usize, Vec<String>)> {\n     let mut res = Vec::new();\n \n     let prefix = \"// \";\n     let lines = text.lines().map(str::trim_start);\n \n-    let mut block = vec![];\n-    for line in lines {\n+    let mut block = (0, vec![]);\n+    for (line_num, line) in lines.enumerate() {\n         if line == \"//\" && allow_blocks_with_empty_lines {\n-            block.push(String::new());\n+            block.1.push(String::new());\n             continue;\n         }\n \n         let is_comment = line.starts_with(prefix);\n         if is_comment {\n-            block.push(line[prefix.len()..].to_string());\n-        } else if !block.is_empty() {\n-            res.push(mem::replace(&mut block, Vec::new()));\n+            block.1.push(line[prefix.len()..].to_string());\n+        } else {\n+            if !block.1.is_empty() {\n+                res.push(mem::take(&mut block));\n+            }\n+            block.0 = line_num + 2;\n         }\n     }\n-    if !block.is_empty() {\n-        res.push(mem::replace(&mut block, Vec::new()))\n+    if !block.1.is_empty() {\n+        res.push(block)\n     }\n     res\n }\n+\n+#[derive(Debug)]\n+struct Location {\n+    file: PathBuf,\n+    line: usize,\n+}\n+\n+impl Location {\n+    fn new(file: PathBuf, line: usize) -> Self {\n+        Self { file, line }\n+    }\n+}\n+\n+impl fmt::Display for Location {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let path = self.file.strip_prefix(&project_root()).unwrap().display().to_string();\n+        let path = path.replace('\\\\', \"/\");\n+        let name = self.file.file_name().unwrap();\n+        write!(\n+            f,\n+            \"https://github.com/rust-analyzer/rust-analyzer/blob/master/{}#L{}[{}]\",\n+            path,\n+            self.line,\n+            name.to_str().unwrap()\n+        )\n+    }\n+}"}, {"sha": "526941f73aceb05338fe7dc7d0b234796ce0e8de", "filename": "xtask/src/codegen/gen_assists_docs.rs", "status": "modified", "additions": 106, "deletions": 104, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -1,102 +1,113 @@\n //! Generates `assists.md` documentation.\n \n-use std::{fs, path::Path};\n+use std::{fmt, fs, path::Path};\n \n use crate::{\n-    codegen::{self, extract_comment_blocks_with_empty_lines, Mode},\n+    codegen::{self, extract_comment_blocks_with_empty_lines, Location, Mode},\n     project_root, rust_files, Result,\n };\n \n+pub fn generate_assists_tests(mode: Mode) -> Result<()> {\n+    let assists = Assist::collect()?;\n+    generate_tests(&assists, mode)\n+}\n+\n pub fn generate_assists_docs(mode: Mode) -> Result<()> {\n-    let assists = collect_assists()?;\n-    generate_tests(&assists, mode)?;\n-    generate_docs(&assists, mode)?;\n-    Ok(())\n+    let assists = Assist::collect()?;\n+    let contents = assists.into_iter().map(|it| it.to_string()).collect::<Vec<_>>().join(\"\\n\\n\");\n+    let contents = contents.trim().to_string() + \"\\n\";\n+    let dst = project_root().join(\"docs/user/generated_assists.adoc\");\n+    codegen::update(&dst, &contents, mode)\n }\n \n #[derive(Debug)]\n struct Assist {\n     id: String,\n+    location: Location,\n     doc: String,\n     before: String,\n     after: String,\n }\n \n-fn hide_hash_comments(text: &str) -> String {\n-    text.split('\\n') // want final newline\n-        .filter(|&it| !(it.starts_with(\"# \") || it == \"#\"))\n-        .map(|it| format!(\"{}\\n\", it))\n-        .collect()\n-}\n-\n-fn reveal_hash_comments(text: &str) -> String {\n-    text.split('\\n') // want final newline\n-        .map(|it| {\n-            if it.starts_with(\"# \") {\n-                &it[2..]\n-            } else if it == \"#\" {\n-                \"\"\n-            } else {\n-                it\n-            }\n-        })\n-        .map(|it| format!(\"{}\\n\", it))\n-        .collect()\n-}\n-\n-fn collect_assists() -> Result<Vec<Assist>> {\n-    let mut res = Vec::new();\n-    for path in rust_files(&project_root().join(codegen::ASSISTS_DIR)) {\n-        collect_file(&mut res, path.as_path())?;\n-    }\n-    res.sort_by(|lhs, rhs| lhs.id.cmp(&rhs.id));\n-    return Ok(res);\n-\n-    fn collect_file(acc: &mut Vec<Assist>, path: &Path) -> Result<()> {\n-        let text = fs::read_to_string(path)?;\n-        let comment_blocks = extract_comment_blocks_with_empty_lines(&text);\n-\n-        for block in comment_blocks {\n-            // FIXME: doesn't support blank lines yet, need to tweak\n-            // `extract_comment_blocks` for that.\n-            let mut lines = block.iter();\n-            let first_line = lines.next().unwrap();\n-            if !first_line.starts_with(\"Assist: \") {\n-                continue;\n-            }\n-            let id = first_line[\"Assist: \".len()..].to_string();\n-            assert!(\n-                id.chars().all(|it| it.is_ascii_lowercase() || it == '_'),\n-                \"invalid assist id: {:?}\",\n-                id\n-            );\n-\n-            let doc = take_until(lines.by_ref(), \"```\").trim().to_string();\n-            assert!(\n-                doc.chars().next().unwrap().is_ascii_uppercase() && doc.ends_with('.'),\n-                \"\\n\\n{}: assist docs should be proper sentences, with capitalization and a full stop at the end.\\n\\n{}\\n\\n\",\n-                id, doc,\n-            );\n-\n-            let before = take_until(lines.by_ref(), \"```\");\n-\n-            assert_eq!(lines.next().unwrap().as_str(), \"->\");\n-            assert_eq!(lines.next().unwrap().as_str(), \"```\");\n-            let after = take_until(lines.by_ref(), \"```\");\n-            acc.push(Assist { id, doc, before, after })\n+impl Assist {\n+    fn collect() -> Result<Vec<Assist>> {\n+        let mut res = Vec::new();\n+        for path in rust_files(&project_root().join(codegen::ASSISTS_DIR)) {\n+            collect_file(&mut res, path.as_path())?;\n         }\n+        res.sort_by(|lhs, rhs| lhs.id.cmp(&rhs.id));\n+        return Ok(res);\n+\n+        fn collect_file(acc: &mut Vec<Assist>, path: &Path) -> Result<()> {\n+            let text = fs::read_to_string(path)?;\n+            let comment_blocks = extract_comment_blocks_with_empty_lines(\"Assist\", &text);\n+\n+            for block in comment_blocks {\n+                // FIXME: doesn't support blank lines yet, need to tweak\n+                // `extract_comment_blocks` for that.\n+                let id = block.id;\n+                assert!(\n+                    id.chars().all(|it| it.is_ascii_lowercase() || it == '_'),\n+                    \"invalid assist id: {:?}\",\n+                    id\n+                );\n+                let mut lines = block.contents.iter();\n+\n+                let doc = take_until(lines.by_ref(), \"```\").trim().to_string();\n+                assert!(\n+                    doc.chars().next().unwrap().is_ascii_uppercase() && doc.ends_with('.'),\n+                    \"\\n\\n{}: assist docs should be proper sentences, with capitalization and a full stop at the end.\\n\\n{}\\n\\n\",\n+                    id, doc,\n+                );\n+\n+                let before = take_until(lines.by_ref(), \"```\");\n+\n+                assert_eq!(lines.next().unwrap().as_str(), \"->\");\n+                assert_eq!(lines.next().unwrap().as_str(), \"```\");\n+                let after = take_until(lines.by_ref(), \"```\");\n+                let location = Location::new(path.to_path_buf(), block.line);\n+                acc.push(Assist { id, location, doc, before, after })\n+            }\n \n-        fn take_until<'a>(lines: impl Iterator<Item = &'a String>, marker: &str) -> String {\n-            let mut buf = Vec::new();\n-            for line in lines {\n-                if line == marker {\n-                    break;\n+            fn take_until<'a>(lines: impl Iterator<Item = &'a String>, marker: &str) -> String {\n+                let mut buf = Vec::new();\n+                for line in lines {\n+                    if line == marker {\n+                        break;\n+                    }\n+                    buf.push(line.clone());\n                 }\n-                buf.push(line.clone());\n+                buf.join(\"\\n\")\n             }\n-            buf.join(\"\\n\")\n+            Ok(())\n         }\n-        Ok(())\n+    }\n+}\n+\n+impl fmt::Display for Assist {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let before = self.before.replace(\"<|>\", \"\u2503\"); // Unicode pseudo-graphics bar\n+        let after = self.after.replace(\"<|>\", \"\u2503\");\n+        writeln!(\n+            f,\n+            \"[discrete]\\n=== `{}`\n+**Source:** {}\n+\n+{}\n+\n+.Before\n+```rust\n+{}```\n+\n+.After\n+```rust\n+{}```\",\n+            self.id,\n+            self.location,\n+            self.doc,\n+            hide_hash_comments(&before),\n+            hide_hash_comments(&after)\n+        )\n     }\n }\n \n@@ -127,33 +138,24 @@ r#####\"\n     codegen::update(&project_root().join(codegen::ASSISTS_TESTS), &buf, mode)\n }\n \n-fn generate_docs(assists: &[Assist], mode: Mode) -> Result<()> {\n-    let mut buf = String::from(\n-        \"# Assists\\n\\nCursor position or selection is signified by `\u2503` character.\\n\\n\",\n-    );\n-\n-    for assist in assists {\n-        let before = assist.before.replace(\"<|>\", \"\u2503\"); // Unicode pseudo-graphics bar\n-        let after = assist.after.replace(\"<|>\", \"\u2503\");\n-        let docs = format!(\n-            \"\n-## `{}`\n-\n-{}\n-\n-```rust\n-// BEFORE\n-{}\n-// AFTER\n-{}```\n-\",\n-            assist.id,\n-            assist.doc,\n-            hide_hash_comments(&before),\n-            hide_hash_comments(&after)\n-        );\n-        buf.push_str(&docs);\n-    }\n+fn hide_hash_comments(text: &str) -> String {\n+    text.split('\\n') // want final newline\n+        .filter(|&it| !(it.starts_with(\"# \") || it == \"#\"))\n+        .map(|it| format!(\"{}\\n\", it))\n+        .collect()\n+}\n \n-    codegen::update(&project_root().join(codegen::ASSISTS_DOCS), &buf, mode)\n+fn reveal_hash_comments(text: &str) -> String {\n+    text.split('\\n') // want final newline\n+        .map(|it| {\n+            if it.starts_with(\"# \") {\n+                &it[2..]\n+            } else if it == \"#\" {\n+                \"\"\n+            } else {\n+                it\n+            }\n+        })\n+        .map(|it| format!(\"{}\\n\", it))\n+        .collect()\n }"}, {"sha": "31bc3839d0715183057f10227802e59e55093ec7", "filename": "xtask/src/codegen/gen_feature_docs.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/xtask%2Fsrc%2Fcodegen%2Fgen_feature_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/xtask%2Fsrc%2Fcodegen%2Fgen_feature_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_feature_docs.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -0,0 +1,75 @@\n+//! Generates `assists.md` documentation.\n+\n+use std::{fmt, fs, path::PathBuf};\n+\n+use crate::{\n+    codegen::{self, extract_comment_blocks_with_empty_lines, Location, Mode},\n+    project_root, rust_files, Result,\n+};\n+\n+pub fn generate_feature_docs(mode: Mode) -> Result<()> {\n+    let features = Feature::collect()?;\n+    let contents = features.into_iter().map(|it| it.to_string()).collect::<Vec<_>>().join(\"\\n\\n\");\n+    let contents = contents.trim().to_string() + \"\\n\";\n+    let dst = project_root().join(\"docs/user/generated_features.adoc\");\n+    codegen::update(&dst, &contents, mode)?;\n+    Ok(())\n+}\n+\n+#[derive(Debug)]\n+struct Feature {\n+    id: String,\n+    location: Location,\n+    doc: String,\n+}\n+\n+impl Feature {\n+    fn collect() -> Result<Vec<Feature>> {\n+        let mut res = Vec::new();\n+        for path in rust_files(&project_root()) {\n+            collect_file(&mut res, path)?;\n+        }\n+        res.sort_by(|lhs, rhs| lhs.id.cmp(&rhs.id));\n+        return Ok(res);\n+\n+        fn collect_file(acc: &mut Vec<Feature>, path: PathBuf) -> Result<()> {\n+            let text = fs::read_to_string(&path)?;\n+            let comment_blocks = extract_comment_blocks_with_empty_lines(\"Feature\", &text);\n+\n+            for block in comment_blocks {\n+                let id = block.id;\n+                assert!(is_valid_feature_name(&id), \"invalid feature name: {:?}\", id);\n+                let doc = block.contents.join(\"\\n\");\n+                let location = Location::new(path.clone(), block.line);\n+                acc.push(Feature { id, location, doc })\n+            }\n+\n+            Ok(())\n+        }\n+    }\n+}\n+\n+fn is_valid_feature_name(feature: &str) -> bool {\n+    'word: for word in feature.split_whitespace() {\n+        for &short in [\"to\", \"and\"].iter() {\n+            if word == short {\n+                continue 'word;\n+            }\n+        }\n+        for &short in [\"To\", \"And\"].iter() {\n+            if word == short {\n+                return false;\n+            }\n+        }\n+        if !word.starts_with(char::is_uppercase) {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+impl fmt::Display for Feature {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        writeln!(f, \"=== {}\\n**Source:** {}\\n{}\", self.id, self.location, self.doc)\n+    }\n+}"}, {"sha": "739f49f7be8183dde593fafa619b0e248c218938", "filename": "xtask/src/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/xtask%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/xtask%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Flib.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -160,6 +160,8 @@ pub fn run_release(dry_run: bool) -> Result<()> {\n         run!(\"git reset --hard tags/nightly\")?;\n         run!(\"git push\")?;\n     }\n+    codegen::generate_assists_docs(Mode::Overwrite)?;\n+    codegen::generate_feature_docs(Mode::Overwrite)?;\n \n     let website_root = project_root().join(\"../rust-analyzer.github.io\");\n     let changelog_dir = website_root.join(\"./thisweek/_posts\");\n@@ -191,7 +193,11 @@ Release: release:{}[]\n     let path = changelog_dir.join(format!(\"{}-changelog-{}.adoc\", today, changelog_n));\n     fs2::write(&path, &contents)?;\n \n-    fs2::copy(project_root().join(\"./docs/user/readme.adoc\"), website_root.join(\"manual.adoc\"))?;\n+    for &adoc in [\"manual.adoc\", \"generated_features.adoc\", \"generated_assists.adoc\"].iter() {\n+        let src = project_root().join(\"./docs/user/\").join(adoc);\n+        let dst = website_root.join(adoc);\n+        fs2::copy(src, dst)?;\n+    }\n \n     let tags = run!(\"git tag --list\"; echo = false)?;\n     let prev_tag = tags.lines().filter(|line| is_release_tag(line)).last().unwrap();"}, {"sha": "81bb3a33f29e5118a10a817c181c62504793006c", "filename": "xtask/src/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/xtask%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/xtask%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmain.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -74,7 +74,9 @@ FLAGS:\n             args.finish()?;\n             codegen::generate_syntax(Mode::Overwrite)?;\n             codegen::generate_parser_tests(Mode::Overwrite)?;\n+            codegen::generate_assists_tests(Mode::Overwrite)?;\n             codegen::generate_assists_docs(Mode::Overwrite)?;\n+            codegen::generate_feature_docs(Mode::Overwrite)?;\n             Ok(())\n         }\n         \"format\" => {"}, {"sha": "d38ac7f17e78e818069db71dd0e3b07a6dd22f22", "filename": "xtask/tests/tidy.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/xtask%2Ftests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186/xtask%2Ftests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy.rs?ref=eefa10bc6bff3624ddd0bbb6bc89d8beb4bed186", "patch": "@@ -25,7 +25,7 @@ fn generated_tests_are_fresh() {\n \n #[test]\n fn generated_assists_are_fresh() {\n-    if let Err(error) = codegen::generate_assists_docs(Mode::Verify) {\n+    if let Err(error) = codegen::generate_assists_tests(Mode::Verify) {\n         panic!(\"{}. Please update assists by running `cargo xtask codegen`\", error);\n     }\n }\n@@ -95,7 +95,7 @@ impl TidyDocs {\n     fn visit(&mut self, path: &Path, text: &str) {\n         // Test hopefully don't really need comments, and for assists we already\n         // have special comments which are source of doc tests and user docs.\n-        if is_exclude_dir(path, &[\"tests\", \"test_data\", \"handlers\"]) {\n+        if is_exclude_dir(path, &[\"tests\", \"test_data\"]) {\n             return;\n         }\n \n@@ -110,9 +110,12 @@ impl TidyDocs {\n \n         if first_line.starts_with(\"//!\") {\n             if first_line.contains(\"FIXME\") {\n-                self.contains_fixme.push(path.to_path_buf())\n+                self.contains_fixme.push(path.to_path_buf());\n             }\n         } else {\n+            if text.contains(\"// Feature:\") || text.contains(\"// Assist:\") {\n+                return;\n+            }\n             self.missing_docs.push(path.display().to_string());\n         }\n \n@@ -170,13 +173,11 @@ impl TidyDocs {\n }\n \n fn is_exclude_dir(p: &Path, dirs_to_exclude: &[&str]) -> bool {\n-    let mut cur_path = p;\n-    while let Some(path) = cur_path.parent() {\n-        if dirs_to_exclude.iter().any(|dir| path.ends_with(dir)) {\n-            return true;\n-        }\n-        cur_path = path;\n-    }\n-\n-    false\n+    p.strip_prefix(project_root())\n+        .unwrap()\n+        .components()\n+        .rev()\n+        .skip(1)\n+        .filter_map(|it| it.as_os_str().to_str())\n+        .any(|it| dirs_to_exclude.contains(&it))\n }"}]}