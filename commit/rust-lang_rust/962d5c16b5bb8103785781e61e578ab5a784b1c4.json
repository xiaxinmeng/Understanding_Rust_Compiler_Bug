{"sha": "962d5c16b5bb8103785781e61e578ab5a784b1c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MmQ1YzE2YjViYjgxMDM3ODU3ODFlNjFlNTc4YWI1YTc4NGIxYzQ=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-17T02:30:01Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-17T05:21:23Z"}, "message": "Fix fallout", "tree": {"sha": "e77e50c03e6c0921111f125752b24ac0c3e0344b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e77e50c03e6c0921111f125752b24ac0c3e0344b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/962d5c16b5bb8103785781e61e578ab5a784b1c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/962d5c16b5bb8103785781e61e578ab5a784b1c4", "html_url": "https://github.com/rust-lang/rust/commit/962d5c16b5bb8103785781e61e578ab5a784b1c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/962d5c16b5bb8103785781e61e578ab5a784b1c4/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5dbe01a2c7e8ef55fe7a07103dad5c99ace199a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5dbe01a2c7e8ef55fe7a07103dad5c99ace199a", "html_url": "https://github.com/rust-lang/rust/commit/b5dbe01a2c7e8ef55fe7a07103dad5c99ace199a"}], "stats": {"total": 691, "additions": 307, "deletions": 384}, "files": [{"sha": "1387bc876e061a4df1d9cc0f1f4d86df01112966", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -237,19 +237,6 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_decl(&mut self, d: &Decl) -> P<hir::Decl> {\n-        match d.node {\n-            DeclKind::Local(ref l) => P(Spanned {\n-                node: hir::DeclLocal(self.lower_local(l)),\n-                span: d.span,\n-            }),\n-            DeclKind::Item(ref it) => P(Spanned {\n-                node: hir::DeclItem(self.lower_item_id(it)),\n-                span: d.span,\n-            }),\n-        }\n-    }\n-\n     fn lower_ty_binding(&mut self, b: &TypeBinding) -> hir::TypeBinding {\n         hir::TypeBinding {\n             id: b.id,\n@@ -1579,21 +1566,29 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_stmt(&mut self, s: &Stmt) -> hir::Stmt {\n         match s.node {\n-            StmtKind::Decl(ref d, id) => {\n-                Spanned {\n-                    node: hir::StmtDecl(self.lower_decl(d), id),\n+            StmtKind::Local(ref l) => Spanned {\n+                node: hir::StmtDecl(P(Spanned {\n+                    node: hir::DeclLocal(self.lower_local(l)),\n                     span: s.span,\n-                }\n-            }\n-            StmtKind::Expr(ref e, id) => {\n+                }), s.id),\n+                span: s.span,\n+            },\n+            StmtKind::Item(ref it) => Spanned {\n+                node: hir::StmtDecl(P(Spanned {\n+                    node: hir::DeclItem(self.lower_item_id(it)),\n+                    span: s.span,\n+                }), s.id),\n+                span: s.span,\n+            },\n+            StmtKind::Expr(ref e) => {\n                 Spanned {\n-                    node: hir::StmtExpr(self.lower_expr(e), id),\n+                    node: hir::StmtExpr(self.lower_expr(e), s.id),\n                     span: s.span,\n                 }\n             }\n-            StmtKind::Semi(ref e, id) => {\n+            StmtKind::Semi(ref e) => {\n                 Spanned {\n-                    node: hir::StmtSemi(self.lower_expr(e), id),\n+                    node: hir::StmtSemi(self.lower_expr(e), s.id),\n                     span: s.span,\n                 }\n             }"}, {"sha": "e8fe96ec12cf4ab1b83b146b9d345fdbfce650bc", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -1005,11 +1005,6 @@ impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n         ast_visit::walk_arm(self, a);\n     }\n \n-    fn visit_decl(&mut self, d: &ast::Decl) {\n-        run_lints!(self, check_decl, early_passes, d);\n-        ast_visit::walk_decl(self, d);\n-    }\n-\n     fn visit_expr_post(&mut self, e: &ast::Expr) {\n         run_lints!(self, check_expr_post, early_passes, e);\n     }"}, {"sha": "41b79f2c3ff45c5b5a05385306566f5ef8819769", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -195,7 +195,6 @@ pub trait EarlyLintPass: LintPass {\n     fn check_stmt(&mut self, _: &EarlyContext, _: &ast::Stmt) { }\n     fn check_arm(&mut self, _: &EarlyContext, _: &ast::Arm) { }\n     fn check_pat(&mut self, _: &EarlyContext, _: &ast::Pat) { }\n-    fn check_decl(&mut self, _: &EarlyContext, _: &ast::Decl) { }\n     fn check_expr(&mut self, _: &EarlyContext, _: &ast::Expr) { }\n     fn check_expr_post(&mut self, _: &EarlyContext, _: &ast::Expr) { }\n     fn check_ty(&mut self, _: &EarlyContext, _: &ast::Ty) { }"}, {"sha": "7a787ddfc524c60c43e3146bb9f326367a75f4e3", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -365,12 +365,9 @@ impl EarlyLintPass for UnusedParens {\n \n     fn check_stmt(&mut self, cx: &EarlyContext, s: &ast::Stmt) {\n         let (value, msg) = match s.node {\n-            ast::StmtKind::Decl(ref decl, _) => match decl.node {\n-                ast::DeclKind::Local(ref local) => match local.init {\n-                    Some(ref value) => (value, \"assigned value\"),\n-                    None => return\n-                },\n-                _ => return\n+            ast::StmtKind::Local(ref local) => match local.init {\n+                Some(ref value) => (value, \"assigned value\"),\n+                None => return\n             },\n             _ => return\n         };"}, {"sha": "f6cfac4304995dbf43f313784633fff872d24ed4", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -31,10 +31,10 @@ use syntax::attr;\n use syntax::parse::token;\n use syntax::codemap::{Span, DUMMY_SP};\n \n-use syntax::ast::{Block, Crate, DeclKind};\n+use syntax::ast::{Block, Crate};\n use syntax::ast::{ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, PathListItemKind};\n-use syntax::ast::{Stmt, StmtKind, TraitItemKind};\n+use syntax::ast::{StmtKind, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::visit::{self, Visitor};\n \n@@ -84,17 +84,11 @@ impl<'b> Resolver<'b> {\n     }\n \n     fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n-        fn is_item(statement: &Stmt) -> bool {\n-            if let StmtKind::Decl(ref declaration, _) = statement.node {\n-                if let DeclKind::Item(_) = declaration.node {\n-                    return true;\n-                }\n-            }\n-            false\n-        }\n-\n         // If any statements are items, we need to create an anonymous module\n-        block.stmts.iter().any(is_item)\n+        block.stmts.iter().any(|statement| match statement.node {\n+            StmtKind::Item(_) => true,\n+            _ => false,\n+        })\n     }\n \n     /// Constructs the reduced graph for one item."}, {"sha": "046cb6918b0d85507e08151192a31436a8c8c976", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -1421,8 +1421,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n     }\n \n     fn visit_stmt(&mut self, s: &ast::Stmt) {\n-        let id = s.node.id();\n-        self.process_macro_use(s.span, id.unwrap());\n+        self.process_macro_use(s.span, s.id);\n         visit::walk_stmt(self, s)\n     }\n "}, {"sha": "a3d2ba4d6fcedaaa34939871b621a1eb684159a1", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -29,7 +29,6 @@ use ptr::P;\n \n use std::fmt;\n use std::rc::Rc;\n-use std::borrow::Cow;\n use std::hash::{Hash, Hasher};\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -795,10 +794,7 @@ pub struct Stmt {\n \n impl fmt::Debug for Stmt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"stmt({}: {})\",\n-               self.node.id()\n-                   .map_or(Cow::Borrowed(\"<macro>\"),|id|Cow::Owned(id.to_string())),\n-               pprust::stmt_to_string(self))\n+        write!(f, \"stmt({}: {})\", self.id.to_string(), pprust::stmt_to_string(self))\n     }\n }\n \n@@ -821,15 +817,6 @@ pub enum StmtKind {\n }\n \n impl StmtKind {\n-    pub fn id(&self) -> Option<NodeId> {\n-        match *self {\n-            StmtKind::Decl(_, id) => Some(id),\n-            StmtKind::Expr(_, id) => Some(id),\n-            StmtKind::Semi(_, id) => Some(id),\n-            StmtKind::Mac(..) => None,\n-        }\n-    }\n-\n     pub fn attrs(&self) -> &[Attribute] {\n         HasAttrs::attrs(self)\n     }\n@@ -868,12 +855,6 @@ impl Local {\n     }\n }\n \n-impl Decl {\n-    pub fn attrs(&self) -> &[Attribute] {\n-        HasAttrs::attrs(self)\n-    }\n-}\n-\n /// represents one arm of a 'match'\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Arm {"}, {"sha": "568a76f58890ad9537b63434cd6464fa97a45f82", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 17, "deletions": 27, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -16,8 +16,8 @@ pub use self::IntType::*;\n \n use ast;\n use ast::{AttrId, Attribute, Attribute_, MetaItem, MetaItemKind};\n-use ast::{Stmt, StmtKind, DeclKind};\n-use ast::{Expr, Item, Local, Decl};\n+use ast::{Stmt, StmtKind};\n+use ast::{Expr, Item, Local};\n use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n use errors::Handler;\n@@ -924,38 +924,28 @@ impl<T: HasAttrs + 'static> HasAttrs for P<T> {\n     }\n }\n \n-impl HasAttrs for DeclKind {\n-    fn attrs(&self) -> &[Attribute] {\n-        match *self {\n-            DeclKind::Local(ref local) => local.attrs(),\n-            DeclKind::Item(ref item) => item.attrs(),\n-        }\n-    }\n-\n-    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n-        match self {\n-            DeclKind::Local(local) => DeclKind::Local(local.map_attrs(f)),\n-            DeclKind::Item(item) => DeclKind::Item(item.map_attrs(f)),\n-        }\n-    }\n-}\n-\n impl HasAttrs for StmtKind {\n     fn attrs(&self) -> &[Attribute] {\n         match *self {\n-            StmtKind::Decl(ref decl, _) => decl.attrs(),\n-            StmtKind::Expr(ref expr, _) | StmtKind::Semi(ref expr, _) => expr.attrs(),\n-            StmtKind::Mac(_, _, ref attrs) => attrs.attrs(),\n+            StmtKind::Local(ref local) => local.attrs(),\n+            StmtKind::Item(ref item) => item.attrs(),\n+            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => expr.attrs(),\n+            StmtKind::Mac(ref mac) => {\n+                let (_, _, ref attrs) = **mac;\n+                attrs.attrs()\n+            }\n         }\n     }\n \n     fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n         match self {\n-            StmtKind::Decl(decl, id) => StmtKind::Decl(decl.map_attrs(f), id),\n-            StmtKind::Expr(expr, id) => StmtKind::Expr(expr.map_attrs(f), id),\n-            StmtKind::Semi(expr, id) => StmtKind::Semi(expr.map_attrs(f), id),\n-            StmtKind::Mac(mac, style, attrs) =>\n-                StmtKind::Mac(mac, style, attrs.map_attrs(f)),\n+            StmtKind::Local(local) => StmtKind::Local(local.map_attrs(f)),\n+            StmtKind::Item(item) => StmtKind::Item(item.map_attrs(f)),\n+            StmtKind::Expr(expr) => StmtKind::Expr(expr.map_attrs(f)),\n+            StmtKind::Semi(expr) => StmtKind::Semi(expr.map_attrs(f)),\n+            StmtKind::Mac(mac) => StmtKind::Mac(mac.map(|(mac, style, attrs)| {\n+                (mac, style, attrs.map_attrs(f))\n+            })),\n         }\n     }\n }\n@@ -982,4 +972,4 @@ derive_has_attrs_from_field! {\n     Item, Expr, Local, ast::ForeignItem, ast::StructField, ast::ImplItem, ast::TraitItem, ast::Arm\n }\n \n-derive_has_attrs_from_field! { Decl: .node, Stmt: .node, ast::Variant: .node.attrs }\n+derive_has_attrs_from_field! { Stmt: .node, ast::Variant: .node.attrs }"}, {"sha": "dc3613946189a43fdf853819cfd29dc313082c9d", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -212,17 +212,10 @@ impl<'a> fold::Folder for StripUnconfigured<'a> {\n     }\n \n     fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n-        let is_item = match stmt.node {\n-            ast::StmtKind::Decl(ref decl, _) => match decl.node {\n-                ast::DeclKind::Item(_) => true,\n-                _ => false,\n-            },\n-            _ => false,\n-        };\n-\n         // avoid calling `visit_stmt_or_expr_attrs` on items\n-        if !is_item {\n-            self.visit_stmt_or_expr_attrs(stmt.attrs());\n+        match stmt.node {\n+            ast::StmtKind::Item(_) => {}\n+            _ => self.visit_stmt_or_expr_attrs(stmt.attrs()),\n         }\n \n         self.configure(stmt).map(|stmt| fold::noop_fold_stmt(stmt, self))"}, {"sha": "7fddd1f591957e1363a45f9646d831cef1975041", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -202,10 +202,11 @@ impl<F> IdentMacroExpander for F\n // Use a macro because forwarding to a simple function has type system issues\n macro_rules! make_stmts_default {\n     ($me:expr) => {\n-        $me.make_expr().map(|e| {\n-            SmallVector::one(codemap::respan(\n-                e.span, ast::StmtKind::Expr(e, ast::DUMMY_NODE_ID)))\n-        })\n+        $me.make_expr().map(|e| SmallVector::one(ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            span: e.span,\n+            node: ast::StmtKind::Expr(e),\n+        }))\n     }\n }\n \n@@ -399,10 +400,11 @@ impl MacResult for DummyResult {\n     }\n \n     fn make_stmts(self: Box<DummyResult>) -> Option<SmallVector<ast::Stmt>> {\n-        Some(SmallVector::one(\n-            codemap::respan(self.span,\n-                            ast::StmtKind::Expr(DummyResult::raw_expr(self.span),\n-                                                ast::DUMMY_NODE_ID))))\n+        Some(SmallVector::one(ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::StmtKind::Expr(DummyResult::raw_expr(self.span)),\n+            span: self.span,\n+        }))\n     }\n }\n "}, {"sha": "653a3dd79b63a1916355df81051b6039f1947be1", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -508,7 +508,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt {\n-        respan(expr.span, ast::StmtKind::Semi(expr, ast::DUMMY_NODE_ID))\n+        ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            span: expr.span,\n+            node: ast::StmtKind::Semi(expr),\n+        }\n     }\n \n     fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n@@ -527,8 +531,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             span: sp,\n             attrs: None,\n         });\n-        let decl = respan(sp, ast::DeclKind::Local(local));\n-        respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID))\n+        ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::StmtKind::Local(local),\n+            span: sp,\n+        }\n     }\n \n     fn stmt_let_typed(&self,\n@@ -552,8 +559,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             span: sp,\n             attrs: None,\n         });\n-        let decl = respan(sp, ast::DeclKind::Local(local));\n-        P(respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID)))\n+        P(ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::StmtKind::Local(local),\n+            span: sp,\n+        })\n     }\n \n     fn block(&self, span: Span, stmts: Vec<ast::Stmt>,\n@@ -562,8 +572,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt {\n-        let decl = respan(sp, ast::DeclKind::Item(item));\n-        respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID))\n+        ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::StmtKind::Item(item),\n+            span: sp,\n+        }\n     }\n \n     fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block> {"}, {"sha": "37a28c3a686fe732fcadbebd422fc4c664a38848", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 52, "deletions": 72, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Crate, DeclKind, PatKind};\n+use ast::{Block, Crate, PatKind};\n use ast::{Local, Ident, Mac_, Name, SpannedIdent};\n use ast::{MacStmtStyle, Mrk, Stmt, StmtKind, ItemKind};\n use ast::TokenTree;\n@@ -444,25 +444,25 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n     };\n \n     let (mac, style, attrs) = match stmt.node {\n-        StmtKind::Mac(mac, style, attrs) => (mac, style, attrs),\n+        StmtKind::Mac(mac) => mac.unwrap(),\n         _ => return expand_non_macro_stmt(stmt, fld)\n     };\n \n     let mut fully_expanded: SmallVector<ast::Stmt> =\n-        expand_mac_invoc(mac.unwrap(), None, attrs.into_attr_vec(), stmt.span, fld);\n+        expand_mac_invoc(mac, None, attrs.into_attr_vec(), stmt.span, fld);\n \n     // If this is a macro invocation with a semicolon, then apply that\n     // semicolon to the final statement produced by expansion.\n     if style == MacStmtStyle::Semicolon {\n         if let Some(stmt) = fully_expanded.pop() {\n-            let new_stmt = Spanned {\n+            fully_expanded.push(Stmt {\n+                id: stmt.id,\n                 node: match stmt.node {\n-                    StmtKind::Expr(e, stmt_id) => StmtKind::Semi(e, stmt_id),\n+                    StmtKind::Expr(expr) => StmtKind::Semi(expr),\n                     _ => stmt.node /* might already have a semi */\n                 },\n-                span: stmt.span\n-            };\n-            fully_expanded.push(new_stmt);\n+                span: stmt.span,\n+            });\n         }\n     }\n \n@@ -471,73 +471,53 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n \n // expand a non-macro stmt. this is essentially the fallthrough for\n // expand_stmt, above.\n-fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroExpander)\n+fn expand_non_macro_stmt(stmt: Stmt, fld: &mut MacroExpander)\n                          -> SmallVector<Stmt> {\n     // is it a let?\n-    match node {\n-        StmtKind::Decl(decl, node_id) => decl.and_then(|Spanned {node: decl, span}| match decl {\n-            DeclKind::Local(local) => {\n-                // take it apart:\n-                let rewritten_local = local.map(|Local {id, pat, ty, init, span, attrs}| {\n-                    // expand the ty since TyKind::FixedLengthVec contains an Expr\n-                    // and thus may have a macro use\n-                    let expanded_ty = ty.map(|t| fld.fold_ty(t));\n-                    // expand the pat (it might contain macro uses):\n-                    let expanded_pat = fld.fold_pat(pat);\n-                    // find the PatIdents in the pattern:\n-                    // oh dear heaven... this is going to include the enum\n-                    // names, as well... but that should be okay, as long as\n-                    // the new names are gensyms for the old ones.\n-                    // generate fresh names, push them to a new pending list\n-                    let idents = pattern_bindings(&expanded_pat);\n-                    let mut new_pending_renames =\n-                        idents.iter().map(|ident| (*ident, fresh_name(*ident))).collect();\n-                    // rewrite the pattern using the new names (the old\n-                    // ones have already been applied):\n-                    let rewritten_pat = {\n-                        // nested binding to allow borrow to expire:\n-                        let mut rename_fld = IdentRenamer{renames: &mut new_pending_renames};\n-                        rename_fld.fold_pat(expanded_pat)\n-                    };\n-                    // add them to the existing pending renames:\n-                    fld.cx.syntax_env.info().pending_renames\n-                          .extend(new_pending_renames);\n-                    Local {\n-                        id: id,\n-                        ty: expanded_ty,\n-                        pat: rewritten_pat,\n-                        // also, don't forget to expand the init:\n-                        init: init.map(|e| fld.fold_expr(e)),\n-                        span: span,\n-                        attrs: fold::fold_thin_attrs(attrs, fld),\n-                    }\n-                });\n-                SmallVector::one(Spanned {\n-                    node: StmtKind::Decl(P(Spanned {\n-                            node: DeclKind::Local(rewritten_local),\n-                            span: span\n-                        }),\n-                        node_id),\n-                    span: stmt_span\n-                })\n-            }\n-            _ => {\n-                noop_fold_stmt(Spanned {\n-                    node: StmtKind::Decl(P(Spanned {\n-                            node: decl,\n-                            span: span\n-                        }),\n-                        node_id),\n-                    span: stmt_span\n-                }, fld)\n-            }\n-        }),\n-        _ => {\n-            noop_fold_stmt(Spanned {\n-                node: node,\n-                span: stmt_span\n-            }, fld)\n+    match stmt.node {\n+        StmtKind::Local(local) => {\n+            // take it apart:\n+            let rewritten_local = local.map(|Local {id, pat, ty, init, span, attrs}| {\n+                // expand the ty since TyKind::FixedLengthVec contains an Expr\n+                // and thus may have a macro use\n+                let expanded_ty = ty.map(|t| fld.fold_ty(t));\n+                // expand the pat (it might contain macro uses):\n+                let expanded_pat = fld.fold_pat(pat);\n+                // find the PatIdents in the pattern:\n+                // oh dear heaven... this is going to include the enum\n+                // names, as well... but that should be okay, as long as\n+                // the new names are gensyms for the old ones.\n+                // generate fresh names, push them to a new pending list\n+                let idents = pattern_bindings(&expanded_pat);\n+                let mut new_pending_renames =\n+                    idents.iter().map(|ident| (*ident, fresh_name(*ident))).collect();\n+                // rewrite the pattern using the new names (the old\n+                // ones have already been applied):\n+                let rewritten_pat = {\n+                    // nested binding to allow borrow to expire:\n+                    let mut rename_fld = IdentRenamer{renames: &mut new_pending_renames};\n+                    rename_fld.fold_pat(expanded_pat)\n+                };\n+                // add them to the existing pending renames:\n+                fld.cx.syntax_env.info().pending_renames\n+                      .extend(new_pending_renames);\n+                Local {\n+                    id: id,\n+                    ty: expanded_ty,\n+                    pat: rewritten_pat,\n+                    // also, don't forget to expand the init:\n+                    init: init.map(|e| fld.fold_expr(e)),\n+                    span: span,\n+                    attrs: fold::fold_thin_attrs(attrs, fld),\n+                }\n+            });\n+            SmallVector::one(Stmt {\n+                id: stmt.id,\n+                node: StmtKind::Local(rewritten_local),\n+                span: stmt.span,\n+            })\n         }\n+        _ => noop_fold_stmt(stmt, fld),\n     }\n }\n "}, {"sha": "7ca10568291507058d975e7b2eaa8cb1a832f81b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 33, "deletions": 42, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -102,10 +102,6 @@ pub trait Folder : Sized {\n         noop_fold_pat(p, self)\n     }\n \n-    fn fold_decl(&mut self, d: P<Decl>) -> SmallVector<P<Decl>> {\n-        noop_fold_decl(d, self)\n-    }\n-\n     fn fold_expr(&mut self, e: P<Expr>) -> P<Expr> {\n         e.map(|e| noop_fold_expr(e, self))\n     }\n@@ -349,19 +345,6 @@ pub fn noop_fold_arm<T: Folder>(Arm {attrs, pats, guard, body}: Arm, fld: &mut T\n     }\n }\n \n-pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> SmallVector<P<Decl>> {\n-    d.and_then(|Spanned {node, span}| match node {\n-        DeclKind::Local(l) => SmallVector::one(P(Spanned {\n-            node: DeclKind::Local(fld.fold_local(l)),\n-            span: fld.new_span(span)\n-        })),\n-        DeclKind::Item(it) => fld.fold_item(it).into_iter().map(|i| P(Spanned {\n-            node: DeclKind::Item(i),\n-            span: fld.new_span(span)\n-        })).collect()\n-    })\n-}\n-\n pub fn noop_fold_ty_binding<T: Folder>(b: TypeBinding, fld: &mut T) -> TypeBinding {\n     TypeBinding {\n         id: fld.new_id(b.id),\n@@ -1312,44 +1295,52 @@ pub fn noop_fold_exprs<T: Folder>(es: Vec<P<Expr>>, folder: &mut T) -> Vec<P<Exp\n     es.move_flat_map(|e| folder.fold_opt_expr(e))\n }\n \n-pub fn noop_fold_stmt<T: Folder>(Spanned {node, span}: Stmt, folder: &mut T)\n+pub fn noop_fold_stmt<T: Folder>(Stmt {node, span, id}: Stmt, folder: &mut T)\n                                  -> SmallVector<Stmt> {\n+    let id = folder.new_id(id);\n     let span = folder.new_span(span);\n+\n     match node {\n-        StmtKind::Decl(d, id) => {\n-            let id = folder.new_id(id);\n-            folder.fold_decl(d).into_iter().map(|d| Spanned {\n-                node: StmtKind::Decl(d, id),\n-                span: span\n-            }).collect()\n-        }\n-        StmtKind::Expr(e, id) => {\n-            let id = folder.new_id(id);\n-            if let Some(e) = folder.fold_opt_expr(e) {\n-                SmallVector::one(Spanned {\n-                    node: StmtKind::Expr(e, id),\n-                    span: span\n+        StmtKind::Local(local) => SmallVector::one(Stmt {\n+            id: id,\n+            node: StmtKind::Local(folder.fold_local(local)),\n+            span: span,\n+        }),\n+        StmtKind::Item(item) => folder.fold_item(item).into_iter().map(|item| Stmt {\n+            id: id,\n+            node: StmtKind::Item(item),\n+            span: span,\n+        }).collect(),\n+        StmtKind::Expr(expr) => {\n+            if let Some(expr) = folder.fold_opt_expr(expr) {\n+                SmallVector::one(Stmt {\n+                    id: id,\n+                    node: StmtKind::Expr(expr),\n+                    span: span,\n                 })\n             } else {\n                 SmallVector::zero()\n             }\n         }\n-        StmtKind::Semi(e, id) => {\n-            let id = folder.new_id(id);\n-            if let Some(e) = folder.fold_opt_expr(e) {\n-                SmallVector::one(Spanned {\n-                    node: StmtKind::Semi(e, id),\n-                    span: span\n+        StmtKind::Semi(expr) => {\n+            if let Some(expr) = folder.fold_opt_expr(expr) {\n+                SmallVector::one(Stmt {\n+                    id: id,\n+                    node: StmtKind::Semi(expr),\n+                    span: span,\n                 })\n             } else {\n                 SmallVector::zero()\n             }\n         }\n-        StmtKind::Mac(mac, semi, attrs) => SmallVector::one(Spanned {\n-            node: StmtKind::Mac(mac.map(|m| folder.fold_mac(m)),\n-                                semi,\n-                                attrs.map_thin_attrs(|v| fold_attrs(v, folder))),\n-            span: span\n+        StmtKind::Mac(mac) => SmallVector::one(Stmt {\n+            id: id,\n+            node: StmtKind::Mac(mac.map(|(mac, semi, attrs)| {\n+                let mac = folder.fold_mac(mac);\n+                let attrs = attrs.map_thin_attrs(|attrs| fold_attrs(attrs, folder));\n+                (mac, semi, attrs)\n+            })),\n+            span: span,\n         })\n     }\n }"}, {"sha": "4fe4ec7e4c0ed3f785fb498ded087152b4b67892", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -47,13 +47,9 @@ pub fn expr_is_simple_block(e: &ast::Expr) -> bool {\n /// seen the semicolon, and thus don't need another.\n pub fn stmt_ends_with_semi(stmt: &ast::StmtKind) -> bool {\n     match *stmt {\n-        ast::StmtKind::Decl(ref d, _) => {\n-            match d.node {\n-                ast::DeclKind::Local(_) => true,\n-                ast::DeclKind::Item(_) => false,\n-            }\n-        }\n-        ast::StmtKind::Expr(ref e, _) => expr_requires_semi_to_be_stmt(e),\n+        ast::StmtKind::Local(_) => true,\n+        ast::StmtKind::Item(_) => false,\n+        ast::StmtKind::Expr(ref e) => expr_requires_semi_to_be_stmt(e),\n         ast::StmtKind::Semi(..) => false,\n         ast::StmtKind::Mac(..) => false,\n     }"}, {"sha": "f21d7cb8fdbe5372ad1c23cb7243353e1efa56b3", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -841,7 +841,7 @@ mod tests {\n \n     #[test] fn parse_stmt_1 () {\n         assert!(string_to_stmt(\"b;\".to_string()) ==\n-                   Some(Spanned{\n+                   Some(ast::Stmt {\n                        node: ast::StmtKind::Expr(P(ast::Expr {\n                            id: ast::DUMMY_NODE_ID,\n                            node: ast::ExprKind::Path(None, ast::Path {\n@@ -855,8 +855,8 @@ mod tests {\n                                ),\n                             }),\n                            span: sp(0,1),\n-                           attrs: None}),\n-                                           ast::DUMMY_NODE_ID),\n+                           attrs: None})),\n+                       id: ast::DUMMY_NODE_ID,\n                        span: sp(0,1)}))\n \n     }\n@@ -932,7 +932,7 @@ mod tests {\n                                         }\n                                     },\n                                     P(ast::Block {\n-                                        stmts: vec!(Spanned{\n+                                        stmts: vec!(ast::Stmt {\n                                             node: ast::StmtKind::Semi(P(ast::Expr{\n                                                 id: ast::DUMMY_NODE_ID,\n                                                 node: ast::ExprKind::Path(None,\n@@ -950,8 +950,8 @@ mod tests {\n                                                         ),\n                                                       }),\n                                                 span: sp(17,18),\n-                                                attrs: None,}),\n-                                                ast::DUMMY_NODE_ID),\n+                                                attrs: None,})),\n+                                            id: ast::DUMMY_NODE_ID,\n                                             span: sp(17,19)}),\n                                         expr: None,\n                                         id: ast::DUMMY_NODE_ID,"}, {"sha": "e74c30276ff5f0fa994db3cc423bd33cd5760767", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 97, "deletions": 86, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -16,7 +16,7 @@ use ast::{Mod, Arg, Arm, Attribute, BindingMode, TraitItemKind};\n use ast::Block;\n use ast::{BlockCheckMode, CaptureBy};\n use ast::{Constness, Crate, CrateConfig};\n-use ast::{Decl, DeclKind, Defaultness};\n+use ast::Defaultness;\n use ast::{EMPTY_CTXT, EnumDef};\n use ast::{Expr, ExprKind, RangeLimits};\n use ast::{Field, FnDecl};\n@@ -3804,13 +3804,6 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    /// Parse a \"let\" stmt\n-    fn parse_let(&mut self, attrs: ThinAttributes) -> PResult<'a, P<Decl>> {\n-        let lo = self.span.lo;\n-        let local = self.parse_local(attrs)?;\n-        Ok(P(spanned(lo, self.last_span.hi, DeclKind::Local(local))))\n-    }\n-\n     /// Parse a structure field\n     fn parse_name_and_ty(&mut self, pr: Visibility,\n                          attrs: Vec<Attribute> ) -> PResult<'a, StructField> {\n@@ -3923,12 +3916,12 @@ impl<'a> Parser<'a> {\n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.span.lo;\n \n-        Ok(Some(if self.check_keyword(keywords::Let) {\n-            self.expect_keyword(keywords::Let)?;\n-            let decl = self.parse_let(attrs.into_thin_attrs())?;\n-            let hi = decl.span.hi;\n-            let stmt = StmtKind::Decl(decl, ast::DUMMY_NODE_ID);\n-            spanned(lo, hi, stmt)\n+        Ok(Some(if self.eat_keyword(keywords::Let) {\n+            Stmt {\n+                id: ast::DUMMY_NODE_ID,\n+                node: StmtKind::Local(self.parse_local(attrs.into_thin_attrs())?),\n+                span: mk_sp(lo, self.last_span.hi),\n+            }\n         } else if self.token.is_ident()\n             && !self.token.is_any_keyword()\n             && self.look_ahead(1, |t| *t == token::Not) {\n@@ -3979,9 +3972,12 @@ impl<'a> Parser<'a> {\n             };\n \n             if id.name == keywords::Invalid.name() {\n-                let mac = P(spanned(lo, hi, Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT }));\n-                let stmt = StmtKind::Mac(mac, style, attrs.into_thin_attrs());\n-                spanned(lo, hi, stmt)\n+                let mac = spanned(lo, hi, Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT });\n+                Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: StmtKind::Mac(P((mac, style, attrs.into_thin_attrs()))),\n+                    span: mk_sp(lo, hi),\n+                }\n             } else {\n                 // if it has a special ident, it's definitely an item\n                 //\n@@ -3995,25 +3991,28 @@ impl<'a> Parser<'a> {\n                                        followed by a semicolon\");\n                     }\n                 }\n-                spanned(lo, hi, StmtKind::Decl(\n-                    P(spanned(lo, hi, DeclKind::Item(\n+                Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    span: mk_sp(lo, hi),\n+                    node: StmtKind::Item({\n                         self.mk_item(\n                             lo, hi, id /*id is good here*/,\n                             ItemKind::Mac(spanned(lo, hi,\n                                             Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT })),\n-                            Visibility::Inherited, attrs)))),\n-                    ast::DUMMY_NODE_ID))\n+                            Visibility::Inherited, attrs)\n+                    }),\n+                }\n             }\n         } else {\n             // FIXME: Bad copy of attrs\n             let restrictions = self.restrictions | Restrictions::NO_NONINLINE_MOD;\n             match self.with_res(restrictions,\n                                 |this| this.parse_item_(attrs.clone(), false, true))? {\n-                Some(i) => {\n-                    let hi = i.span.hi;\n-                    let decl = P(spanned(lo, hi, DeclKind::Item(i)));\n-                    spanned(lo, hi, StmtKind::Decl(decl, ast::DUMMY_NODE_ID))\n-                }\n+                Some(i) => Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    span: mk_sp(lo, i.span.hi),\n+                    node: StmtKind::Item(i),\n+                },\n                 None => {\n                     let unused_attrs = |attrs: &[_], s: &mut Self| {\n                         if attrs.len() > 0 {\n@@ -4037,9 +4036,11 @@ impl<'a> Parser<'a> {\n                     // Remainder are line-expr stmts.\n                     let e = self.parse_expr_res(\n                         Restrictions::RESTRICTION_STMT_EXPR, Some(attrs.into_thin_attrs()))?;\n-                    let hi = e.span.hi;\n-                    let stmt = StmtKind::Expr(e, ast::DUMMY_NODE_ID);\n-                    spanned(lo, hi, stmt)\n+                    Stmt {\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: mk_sp(lo, e.span.hi),\n+                        node: StmtKind::Expr(e),\n+                    }\n                 }\n             }\n         }))\n@@ -4085,68 +4086,21 @@ impl<'a> Parser<'a> {\n         let mut expr = None;\n \n         while !self.eat(&token::CloseDelim(token::Brace)) {\n-            let Spanned {node, span} = if let Some(s) = self.parse_stmt_() {\n+            let Stmt {node, span, ..} = if let Some(s) = self.parse_stmt_() {\n                 s\n             } else if self.token == token::Eof {\n                 break;\n             } else {\n                 // Found only `;` or `}`.\n                 continue;\n             };\n+\n             match node {\n-                StmtKind::Expr(e, _) => {\n+                StmtKind::Expr(e) => {\n                     self.handle_expression_like_statement(e, span, &mut stmts, &mut expr)?;\n                 }\n-                StmtKind::Mac(mac, MacStmtStyle::NoBraces, attrs) => {\n-                    // statement macro without braces; might be an\n-                    // expr depending on whether a semicolon follows\n-                    match self.token {\n-                        token::Semi => {\n-                            stmts.push(Spanned {\n-                                node: StmtKind::Mac(mac, MacStmtStyle::Semicolon, attrs),\n-                                span: mk_sp(span.lo, self.span.hi),\n-                            });\n-                            self.bump();\n-                        }\n-                        _ => {\n-                            let e = self.mk_mac_expr(span.lo, span.hi,\n-                                                     mac.and_then(|m| m.node),\n-                                                     None);\n-                            let lo = e.span.lo;\n-                            let e = self.parse_dot_or_call_expr_with(e, lo, attrs)?;\n-                            let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n-                            self.handle_expression_like_statement(\n-                                e,\n-                                span,\n-                                &mut stmts,\n-                                &mut expr)?;\n-                        }\n-                    }\n-                }\n-                StmtKind::Mac(m, style, attrs) => {\n-                    // statement macro; might be an expr\n-                    match self.token {\n-                        token::Semi => {\n-                            stmts.push(Spanned {\n-                                node: StmtKind::Mac(m, MacStmtStyle::Semicolon, attrs),\n-                                span: mk_sp(span.lo, self.span.hi),\n-                            });\n-                            self.bump();\n-                        }\n-                        token::CloseDelim(token::Brace) => {\n-                            // if a block ends in `m!(arg)` without\n-                            // a `;`, it must be an expr\n-                            expr = Some(self.mk_mac_expr(span.lo, span.hi,\n-                                                         m.and_then(|x| x.node),\n-                                                         attrs));\n-                        }\n-                        _ => {\n-                            stmts.push(Spanned {\n-                                node: StmtKind::Mac(m, style, attrs),\n-                                span: span\n-                            });\n-                        }\n-                    }\n+                StmtKind::Mac(mac) => {\n+                    self.handle_macro_in_block(mac.unwrap(), span, &mut stmts, &mut expr)?;\n                 }\n                 _ => { // all other kinds of statements:\n                     let mut hi = span.hi;\n@@ -4155,7 +4109,8 @@ impl<'a> Parser<'a> {\n                         hi = self.last_span.hi;\n                     }\n \n-                    stmts.push(Spanned {\n+                    stmts.push(Stmt {\n+                        id: ast::DUMMY_NODE_ID,\n                         node: node,\n                         span: mk_sp(span.lo, hi)\n                     });\n@@ -4172,6 +4127,60 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n+    fn handle_macro_in_block(&mut self,\n+                             (mac, style, attrs): (ast::Mac, MacStmtStyle, ThinAttributes),\n+                             span: Span,\n+                             stmts: &mut Vec<Stmt>,\n+                             last_block_expr: &mut Option<P<Expr>>)\n+                             -> PResult<'a, ()> {\n+        if style == MacStmtStyle::NoBraces {\n+            // statement macro without braces; might be an\n+            // expr depending on whether a semicolon follows\n+            match self.token {\n+                token::Semi => {\n+                    stmts.push(Stmt {\n+                        id: ast::DUMMY_NODE_ID,\n+                        node: StmtKind::Mac(P((mac, MacStmtStyle::Semicolon, attrs))),\n+                        span: mk_sp(span.lo, self.span.hi),\n+                    });\n+                    self.bump();\n+                }\n+                _ => {\n+                    let e = self.mk_mac_expr(span.lo, span.hi, mac.node, None);\n+                    let lo = e.span.lo;\n+                    let e = self.parse_dot_or_call_expr_with(e, lo, attrs)?;\n+                    let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n+                    self.handle_expression_like_statement(e, span, stmts, last_block_expr)?;\n+                }\n+            }\n+        } else {\n+            // statement macro; might be an expr\n+            match self.token {\n+                token::Semi => {\n+                    stmts.push(Stmt {\n+                        id: ast::DUMMY_NODE_ID,\n+                        node: StmtKind::Mac(P((mac, MacStmtStyle::Semicolon, attrs))),\n+                        span: mk_sp(span.lo, self.span.hi),\n+                    });\n+                    self.bump();\n+                }\n+                token::CloseDelim(token::Brace) => {\n+                    // if a block ends in `m!(arg)` without\n+                    // a `;`, it must be an expr\n+                    *last_block_expr = Some(self.mk_mac_expr(span.lo, span.hi, mac.node, attrs));\n+                }\n+                _ => {\n+                    stmts.push(Stmt {\n+                        id: ast::DUMMY_NODE_ID,\n+                        node: StmtKind::Mac(P((mac, style, attrs))),\n+                        span: span\n+                    });\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     fn handle_expression_like_statement(&mut self,\n                                         e: P<Expr>,\n                                         span: Span,\n@@ -4197,15 +4206,17 @@ impl<'a> Parser<'a> {\n                     hi: self.last_span.hi,\n                     expn_id: span.expn_id,\n                 };\n-                stmts.push(Spanned {\n-                    node: StmtKind::Semi(e, ast::DUMMY_NODE_ID),\n+                stmts.push(Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: StmtKind::Semi(e),\n                     span: span_with_semi,\n                 });\n             }\n             token::CloseDelim(token::Brace) => *last_block_expr = Some(e),\n             _ => {\n-                stmts.push(Spanned {\n-                    node: StmtKind::Expr(e, ast::DUMMY_NODE_ID),\n+                stmts.push(Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: StmtKind::Expr(e),\n                     span: span\n                 });\n             }"}, {"sha": "33de675767b4dda40c7e0c6e7dd928e4bcb344d0", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -1592,19 +1592,34 @@ impl<'a> State<'a> {\n     pub fn print_stmt(&mut self, st: &ast::Stmt) -> io::Result<()> {\n         try!(self.maybe_print_comment(st.span.lo));\n         match st.node {\n-            ast::StmtKind::Decl(ref decl, _) => {\n-                try!(self.print_decl(&decl));\n+            ast::StmtKind::Local(ref loc) => {\n+                try!(self.print_outer_attributes(loc.attrs.as_attr_slice()));\n+                try!(self.space_if_not_bol());\n+                try!(self.ibox(INDENT_UNIT));\n+                try!(self.word_nbsp(\"let\"));\n+\n+                try!(self.ibox(INDENT_UNIT));\n+                try!(self.print_local_decl(&loc));\n+                try!(self.end());\n+                if let Some(ref init) = loc.init {\n+                    try!(self.nbsp());\n+                    try!(self.word_space(\"=\"));\n+                    try!(self.print_expr(&init));\n+                }\n+                self.end()?;\n             }\n-            ast::StmtKind::Expr(ref expr, _) => {\n+            ast::StmtKind::Item(ref item) => self.print_item(&item)?,\n+            ast::StmtKind::Expr(ref expr) => {\n                 try!(self.space_if_not_bol());\n                 try!(self.print_expr_outer_attr_style(&expr, false));\n             }\n-            ast::StmtKind::Semi(ref expr, _) => {\n+            ast::StmtKind::Semi(ref expr) => {\n                 try!(self.space_if_not_bol());\n                 try!(self.print_expr_outer_attr_style(&expr, false));\n                 try!(word(&mut self.s, \";\"));\n             }\n-            ast::StmtKind::Mac(ref mac, style, ref attrs) => {\n+            ast::StmtKind::Mac(ref mac) => {\n+                let (ref mac, style, ref attrs) = **mac;\n                 try!(self.space_if_not_bol());\n                 try!(self.print_outer_attributes(attrs.as_attr_slice()));\n                 let delim = match style {\n@@ -2277,29 +2292,6 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_decl(&mut self, decl: &ast::Decl) -> io::Result<()> {\n-        try!(self.maybe_print_comment(decl.span.lo));\n-        match decl.node {\n-            ast::DeclKind::Local(ref loc) => {\n-                try!(self.print_outer_attributes(loc.attrs.as_attr_slice()));\n-                try!(self.space_if_not_bol());\n-                try!(self.ibox(INDENT_UNIT));\n-                try!(self.word_nbsp(\"let\"));\n-\n-                try!(self.ibox(INDENT_UNIT));\n-                try!(self.print_local_decl(&loc));\n-                try!(self.end());\n-                if let Some(ref init) = loc.init {\n-                    try!(self.nbsp());\n-                    try!(self.word_space(\"=\"));\n-                    try!(self.print_expr(&init));\n-                }\n-                self.end()\n-            }\n-            ast::DeclKind::Item(ref item) => self.print_item(&item)\n-        }\n-    }\n-\n     pub fn print_ident(&mut self, ident: ast::Ident) -> io::Result<()> {\n         try!(word(&mut self.s, &ident.name.as_str()));\n         self.ann.post(self, NodeIdent(&ident))"}, {"sha": "024864941c3fc9b10384088c8df85b215170cf4b", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -63,10 +63,6 @@ impl<'v> Visitor<'v> for NodeCounter {\n         self.count += 1;\n         walk_pat(self, p)\n     }\n-    fn visit_decl(&mut self, d: &'v Decl) {\n-        self.count += 1;\n-        walk_decl(self, d)\n-    }\n     fn visit_expr(&mut self, ex: &'v Expr) {\n         self.count += 1;\n         walk_expr(self, ex)"}, {"sha": "4152cb451aecd35d1b3a9c795ae98ca94d8ed369", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -64,7 +64,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_stmt(&mut self, s: &'v Stmt) { walk_stmt(self, s) }\n     fn visit_arm(&mut self, a: &'v Arm) { walk_arm(self, a) }\n     fn visit_pat(&mut self, p: &'v Pat) { walk_pat(self, p) }\n-    fn visit_decl(&mut self, d: &'v Decl) { walk_decl(self, d) }\n     fn visit_expr(&mut self, ex: &'v Expr) { walk_expr(self, ex) }\n     fn visit_expr_post(&mut self, _ex: &'v Expr) { }\n     fn visit_ty(&mut self, t: &'v Ty) { walk_ty(self, t) }\n@@ -613,11 +612,13 @@ pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {\n \n pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n     match statement.node {\n-        StmtKind::Decl(ref declaration, _) => visitor.visit_decl(declaration),\n-        StmtKind::Expr(ref expression, _) | StmtKind::Semi(ref expression, _) => {\n+        StmtKind::Local(ref local) => visitor.visit_local(local),\n+        StmtKind::Item(ref item) => visitor.visit_item(item),\n+        StmtKind::Expr(ref expression) | StmtKind::Semi(ref expression) => {\n             visitor.visit_expr(expression)\n         }\n-        StmtKind::Mac(ref mac, _, ref attrs) => {\n+        StmtKind::Mac(ref mac) => {\n+            let (ref mac, _, ref attrs) = **mac;\n             visitor.visit_mac(mac);\n             for attr in attrs.as_attr_slice() {\n                 visitor.visit_attribute(attr);\n@@ -626,13 +627,6 @@ pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n     }\n }\n \n-pub fn walk_decl<'v, V: Visitor<'v>>(visitor: &mut V, declaration: &'v Decl) {\n-    match declaration.node {\n-        DeclKind::Local(ref local) => visitor.visit_local(local),\n-        DeclKind::Item(ref item) => visitor.visit_item(item),\n-    }\n-}\n-\n pub fn walk_mac<'v, V: Visitor<'v>>(_: &mut V, _: &'v Mac) {\n     // Empty!\n }"}, {"sha": "a2d01d008b9130eb70e29b5c4c59cc53a12e0e58", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -13,7 +13,7 @@ use deriving::generic::ty::*;\n \n use syntax::ast;\n use syntax::ast::{MetaItem, Expr};\n-use syntax::codemap::{Span, respan, DUMMY_SP};\n+use syntax::codemap::{Span, DUMMY_SP};\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n@@ -151,6 +151,9 @@ fn stmt_let_undescore(cx: &mut ExtCtxt,\n         span: sp,\n         attrs: None,\n     });\n-    let decl = respan(sp, ast::DeclKind::Local(local));\n-    respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID))\n+    ast::Stmt {\n+        id: ast::DUMMY_NODE_ID,\n+        node: ast::StmtKind::Local(local),\n+        span: sp,\n+    }\n }"}, {"sha": "ca968f10e2eb2e6cf64ec03b26b87f3c43d3b6cf", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962d5c16b5bb8103785781e61e578ab5a784b1c4/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=962d5c16b5bb8103785781e61e578ab5a784b1c4", "patch": "@@ -14,7 +14,7 @@ use self::Position::*;\n use fmt_macros as parse;\n \n use syntax::ast;\n-use syntax::codemap::{Span, respan, DUMMY_SP};\n+use syntax::codemap::{Span, DUMMY_SP};\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n@@ -441,12 +441,14 @@ impl<'a, 'b> Context<'a, 'b> {\n \n         let name = ecx.ident_of(name);\n         let item = ecx.item(sp, name, vec![], st);\n-        let decl = respan(sp, ast::DeclKind::Item(item));\n+        let stmt = ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::StmtKind::Item(item),\n+            span: sp,\n+        };\n \n         // Wrap the declaration in a block so that it forms a single expression.\n-        ecx.expr_block(ecx.block(sp,\n-            vec![respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID))],\n-            Some(ecx.expr_ident(sp, name))))\n+        ecx.expr_block(ecx.block(sp, vec![stmt], Some(ecx.expr_ident(sp, name))))\n     }\n \n     /// Actually builds the expression which the iformat! block will be expanded"}]}