{"sha": "044b16ad68984a1c99f88ddf6701f4eaefa15bf8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NGIxNmFkNjg5ODRhMWM5OWY4OGRkZjY3MDFmNGVhZWZhMTViZjg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-10T00:19:31Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-10T01:31:13Z"}, "message": "rustc: Remove the code to generate cmp glue", "tree": {"sha": "ec19a0d272ca9fc3f1486ac38e598702836eeef2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec19a0d272ca9fc3f1486ac38e598702836eeef2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/044b16ad68984a1c99f88ddf6701f4eaefa15bf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/044b16ad68984a1c99f88ddf6701f4eaefa15bf8", "html_url": "https://github.com/rust-lang/rust/commit/044b16ad68984a1c99f88ddf6701f4eaefa15bf8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/044b16ad68984a1c99f88ddf6701f4eaefa15bf8/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5997f2eb21abdc083e0faa3adbfc44116e1014f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5997f2eb21abdc083e0faa3adbfc44116e1014f", "html_url": "https://github.com/rust-lang/rust/commit/a5997f2eb21abdc083e0faa3adbfc44116e1014f"}], "stats": {"total": 177, "additions": 5, "deletions": 172}, "files": [{"sha": "4bbd40bcaa03c96e1fd51c44b6cf404f5e833f2e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 5, "deletions": 172, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/044b16ad68984a1c99f88ddf6701f4eaefa15bf8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044b16ad68984a1c99f88ddf6701f4eaefa15bf8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=044b16ad68984a1c99f88ddf6701f4eaefa15bf8", "patch": "@@ -1092,10 +1092,7 @@ fn declare_tydesc(cx: &@local_ctxt, sp: &span, t: &ty::t, ty_params: &[uint])\n     ret info;\n }\n \n-tag make_generic_glue_helper_fn {\n-    mgghf_single(fn(&@block_ctxt, ValueRef, &ty::t) );\n-    mgghf_cmp;\n-}\n+type make_generic_glue_helper_fn = fn(&@block_ctxt, ValueRef, &ty::t);\n \n fn declare_generic_glue(cx: &@local_ctxt, t: &ty::t, llfnty: TypeRef,\n                         name: &str) -> ValueRef {\n@@ -1147,15 +1144,7 @@ fn make_generic_glue_inner(cx: &@local_ctxt, sp: &span, t: &ty::t,\n     let lltop = bcx.llbb;\n     let llrawptr0 = llvm::LLVMGetParam(llfn, 4u);\n     let llval0 = bcx.build.BitCast(llrawptr0, llty);\n-    alt helper {\n-      mgghf_single(single_fn) { single_fn(bcx, llval0, t); }\n-      mgghf_cmp. {\n-        let llrawptr1 = llvm::LLVMGetParam(llfn, 5u);\n-        let llval1 = bcx.build.BitCast(llrawptr1, llty);\n-        let llcmpval = llvm::LLVMGetParam(llfn, 6u);\n-        make_cmp_glue(bcx, llval0, llval1, t, llcmpval);\n-      }\n-    }\n+    helper(bcx, llval0, t);\n     finish_fn(fcx, lltop);\n     ret llfn;\n }\n@@ -1532,147 +1521,6 @@ fn maybe_name_value(cx: &@crate_ctxt, v: ValueRef, s: &str) {\n     }\n }\n \n-fn make_cmp_glue(cx: &@block_ctxt, lhs0: ValueRef, rhs0: ValueRef, t: &ty::t,\n-                 llop: ValueRef) {\n-    let lhs = load_if_immediate(cx, lhs0, t);\n-    let rhs = load_if_immediate(cx, rhs0, t);\n-    if ty::type_is_scalar(bcx_tcx(cx), t) {\n-        make_scalar_cmp_glue(cx, lhs, rhs, t, llop);\n-    } else if (ty::type_is_box(bcx_tcx(cx), t)) {\n-        lhs = cx.build.GEP(lhs, ~[C_int(0), C_int(abi::box_rc_field_body)]);\n-        rhs = cx.build.GEP(rhs, ~[C_int(0), C_int(abi::box_rc_field_body)]);\n-        let t_inner =\n-            alt ty::struct(bcx_tcx(cx), t) { ty::ty_box(ti) { ti.ty } };\n-        let rslt = compare(cx, lhs, rhs, t_inner, llop);\n-        rslt.bcx.build.Store(rslt.val, cx.fcx.llretptr);\n-        rslt.bcx.build.RetVoid();\n-    } else if (ty::type_is_structural(bcx_tcx(cx), t) ||\n-                   ty::type_is_sequence(bcx_tcx(cx), t)) {\n-        let scx = new_sub_block_ctxt(cx, \"structural compare start\");\n-        let next = new_sub_block_ctxt(cx, \"structural compare end\");\n-        cx.build.Br(scx.llbb);\n-        /*\n-         * We're doing lexicographic comparison here. We start with the\n-         * assumption that the two input elements are equal. Depending on\n-         * operator, this means that the result is either true or false;\n-         * equality produces 'true' for ==, <= and >=. It produces 'false' for\n-         * !=, < and >.\n-         *\n-         * We then move one element at a time through the structure checking\n-         * for pairwise element equality: If we have equality, our assumption\n-         * about overall sequence equality is not modified, so we have to move\n-         * to the next element.\n-         *\n-         * If we do not have pairwise element equality, we have reached an\n-         * element that 'decides' the lexicographic comparison. So we exit the\n-         * loop with a flag that indicates the true/false sense of that\n-         * decision, by testing the element again with the operator we're\n-         * interested in.\n-         *\n-         * When we're lucky, LLVM should be able to fold some of these two\n-         * tests together (as they're applied to the same operands and in some\n-         * cases are sometimes redundant). But we don't bother trying to\n-         * optimize combinations like that, at this level.\n-         */\n-\n-        let flag = alloca(scx, T_i1());\n-        maybe_name_value(bcx_ccx(cx), flag, \"flag\");\n-        let r;\n-        if ty::type_is_sequence(bcx_tcx(cx), t) {\n-            // If we hit == all the way through the minimum-shared-length\n-            // section, default to judging the relative sequence lengths.\n-\n-            let lhs_fill;\n-            let rhs_fill;\n-            let bcx;\n-            if ty::sequence_is_interior(bcx_tcx(cx), t) {\n-                let st = ty::sequence_element_type(bcx_tcx(cx), t);\n-                let lad = ivec::get_len_and_data(scx, lhs, st);\n-                bcx = lad.bcx;\n-                lhs_fill = lad.len;\n-                lad = ivec::get_len_and_data(bcx, rhs, st);\n-                bcx = lad.bcx;\n-                rhs_fill = lad.len;\n-            } else {\n-                lhs_fill = vec_fill(scx, lhs);\n-                rhs_fill = vec_fill(scx, rhs);\n-                bcx = scx;\n-            }\n-            r =\n-                compare_scalar_values(bcx, lhs_fill, rhs_fill, unsigned_int,\n-                                      llop);\n-            r.bcx.build.Store(r.val, flag);\n-        } else {\n-            // == and <= default to true if they find == all the way. <\n-            // defaults to false if it finds == all the way.\n-\n-            let result_if_equal =\n-                scx.build.ICmp(lib::llvm::LLVMIntNE, llop,\n-                               C_u8(abi::cmp_glue_op_lt));\n-            scx.build.Store(result_if_equal, flag);\n-            r = rslt(scx, C_nil());\n-        }\n-        fn inner(last_cx: @block_ctxt, load_inner: bool, flag: ValueRef,\n-                 llop: ValueRef, cx: &@block_ctxt, av0: ValueRef,\n-                 bv0: ValueRef, t: ty::t) -> result {\n-            let cnt_cx = new_sub_block_ctxt(cx, \"continue_comparison\");\n-            let stop_cx = new_sub_block_ctxt(cx, \"stop_comparison\");\n-            let av = av0;\n-            let bv = bv0;\n-            if load_inner {\n-                // If `load_inner` is true, then the pointer type will always\n-                // be i8, because the data part of a vector always has type\n-                // [i8]. So we need to cast it to the proper type.\n-\n-                if !ty::type_has_dynamic_size(bcx_tcx(last_cx), t) {\n-                    let llelemty =\n-                        T_ptr(type_of(bcx_ccx(last_cx), last_cx.sp, t));\n-                    av = cx.build.PointerCast(av, llelemty);\n-                    bv = cx.build.PointerCast(bv, llelemty);\n-                }\n-                av = load_if_immediate(cx, av, t);\n-                bv = load_if_immediate(cx, bv, t);\n-            }\n-\n-            // First 'eq' comparison: if so, continue to next elts.\n-            let eq_r = compare(cx, av, bv, t, C_u8(abi::cmp_glue_op_eq));\n-            eq_r.bcx.build.CondBr(eq_r.val, cnt_cx.llbb, stop_cx.llbb);\n-\n-            // Second 'op' comparison: find out how this elt-pair decides.\n-            let stop_r = compare(stop_cx, av, bv, t, llop);\n-            stop_r.bcx.build.Store(stop_r.val, flag);\n-            stop_r.bcx.build.Br(last_cx.llbb);\n-            ret rslt(cnt_cx, C_nil());\n-        }\n-        if ty::type_is_structural(bcx_tcx(cx), t) {\n-            r = iter_structural_ty_full(r.bcx, lhs, rhs, t,\n-                                        bind inner(next, false, flag, llop, _,\n-                                                   _, _, _));\n-        } else {\n-            let lhs_p0 = vec_p0(r.bcx, lhs);\n-            let rhs_p0 = vec_p0(r.bcx, rhs);\n-            let min_len =\n-                umin(r.bcx, vec_fill(r.bcx, lhs), vec_fill(r.bcx, rhs));\n-            let rhs_lim = r.bcx.build.GEP(rhs_p0, ~[min_len]);\n-            let elt_ty = ty::sequence_element_type(bcx_tcx(cx), t);\n-            r = size_of(r.bcx, elt_ty);\n-            r = iter_sequence_raw(r.bcx, lhs_p0, rhs_p0, rhs_lim, r.val,\n-                                  bind inner(next, true, flag, llop, _, _, _,\n-                                             elt_ty));\n-        }\n-        r.bcx.build.Br(next.llbb);\n-        let v = next.build.Load(flag);\n-        next.build.Store(v, cx.fcx.llretptr);\n-        next.build.RetVoid();\n-    } else {\n-        // FIXME: compare obj, fn by pointer?\n-\n-        trans_fail(cx, none[span],\n-                   \"attempt to compare values of type \" +\n-                       ty_to_str(bcx_tcx(cx), t));\n-    }\n-}\n-\n \n // Used only for creating scalar comparison glue.\n tag scalar_type { nil_type; signed_int; unsigned_int; floating_point; }\n@@ -1721,21 +1569,6 @@ fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n     }\n }\n \n-// A helper function to create scalar comparison glue.\n-fn make_scalar_cmp_glue(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef,\n-                        t: &ty::t, llop: ValueRef) {\n-    assert (ty::type_is_scalar(bcx_tcx(cx), t));\n-\n-    // In most cases, we need to know whether to do signed, unsigned, or float\n-    // comparison.\n-\n-    let rslt = compare_scalar_types(cx, lhs, rhs, t, llop);\n-    let bcx = rslt.bcx;\n-    let compare_result = rslt.val;\n-    bcx.build.Store(compare_result, cx.fcx.llretptr);\n-    bcx.build.RetVoid();\n-}\n-\n \n // A helper function to do the actual comparison of scalar values.\n fn compare_scalar_values(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef,\n@@ -2192,7 +2025,7 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n                                          \"copy\");\n                 ti.copy_glue = some[ValueRef](glue_fn);\n                 make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n-                                  mgghf_single(make_copy_glue), ti.ty_params,\n+                                  make_copy_glue, ti.ty_params,\n                                   \"take\");\n                 log #fmt(\"--- lazily_emit_tydesc_glue TAKE %s\",\n                          ty_to_str(bcx_tcx(cx), ti.ty));\n@@ -2210,7 +2043,7 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n                                          \"drop\");\n                 ti.drop_glue = some[ValueRef](glue_fn);\n                 make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n-                                  mgghf_single(make_drop_glue), ti.ty_params,\n+                                  make_drop_glue, ti.ty_params,\n                                   \"drop\");\n                 log #fmt(\"--- lazily_emit_tydesc_glue DROP %s\",\n                          ty_to_str(bcx_tcx(cx), ti.ty));\n@@ -2228,7 +2061,7 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n                                          \"free\");\n                 ti.free_glue = some[ValueRef](glue_fn);\n                 make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n-                                  mgghf_single(make_free_glue), ti.ty_params,\n+                                  make_free_glue, ti.ty_params,\n                                   \"free\");\n                 log #fmt(\"--- lazily_emit_tydesc_glue FREE %s\",\n                          ty_to_str(bcx_tcx(cx), ti.ty));"}]}