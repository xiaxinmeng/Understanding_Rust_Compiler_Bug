{"sha": "27649b70327efd0613c8de01ff0b78205473a253", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3NjQ5YjcwMzI3ZWZkMDYxM2M4ZGUwMWZmMGI3ODIwNTQ3M2EyNTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-23T17:36:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-23T17:36:28Z"}, "message": "Auto merge of #50983 - nikomatsakis:issue-50970-migration-lint-fq-path, r=alexcrichton\n\nIssue 50970 migration lint fq path\n\nSimilar issue, but for fully qualified paths.\n\nFixes #50970\n\nr? @alexcrichton", "tree": {"sha": "b33d780693548b0b9751a969a332aef037b1a801", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b33d780693548b0b9751a969a332aef037b1a801"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27649b70327efd0613c8de01ff0b78205473a253", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27649b70327efd0613c8de01ff0b78205473a253", "html_url": "https://github.com/rust-lang/rust/commit/27649b70327efd0613c8de01ff0b78205473a253", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27649b70327efd0613c8de01ff0b78205473a253/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e249596d949661791d44633eb5e78b1ae999782d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e249596d949661791d44633eb5e78b1ae999782d", "html_url": "https://github.com/rust-lang/rust/commit/e249596d949661791d44633eb5e78b1ae999782d"}, {"sha": "688324e17677be0c6f34f9c0127c79c43e733d32", "url": "https://api.github.com/repos/rust-lang/rust/commits/688324e17677be0c6f34f9c0127c79c43e733d32", "html_url": "https://github.com/rust-lang/rust/commit/688324e17677be0c6f34f9c0127c79c43e733d32"}], "stats": {"total": 409, "additions": 379, "deletions": 30}, "files": [{"sha": "a9bbcbba819215deda05f3a505ab3ab9c5c975c2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 130, "deletions": 20, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/27649b70327efd0613c8de01ff0b78205473a253/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27649b70327efd0613c8de01ff0b78205473a253/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=27649b70327efd0613c8de01ff0b78205473a253", "patch": "@@ -2222,7 +2222,7 @@ impl<'a> Resolver<'a> {\n                     segments: use_tree.prefix.make_root().into_iter().collect(),\n                     span: use_tree.span,\n                 };\n-                self.resolve_use_tree(item.id, use_tree, &path);\n+                self.resolve_use_tree(item.id, use_tree.span, item.id, use_tree, &path);\n             }\n \n             ItemKind::ExternCrate(_) | ItemKind::MacroDef(..) | ItemKind::GlobalAsm(_) => {\n@@ -2233,7 +2233,18 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn resolve_use_tree(&mut self, id: NodeId, use_tree: &ast::UseTree, prefix: &Path) {\n+    /// For the most part, use trees are desugared into `ImportDirective` instances\n+    /// when building the reduced graph (see `build_reduced_graph_for_use_tree`). But\n+    /// there is one special case we handle here: an empty nested import like\n+    /// `a::{b::{}}`, which desugares into...no import directives.\n+    fn resolve_use_tree(\n+        &mut self,\n+        root_id: NodeId,\n+        root_span: Span,\n+        id: NodeId,\n+        use_tree: &ast::UseTree,\n+        prefix: &Path,\n+    ) {\n         match use_tree.kind {\n             ast::UseTreeKind::Nested(ref items) => {\n                 let path = Path {\n@@ -2247,10 +2258,16 @@ impl<'a> Resolver<'a> {\n \n                 if items.len() == 0 {\n                     // Resolve prefix of an import with empty braces (issue #28388).\n-                    self.smart_resolve_path(id, None, &path, PathSource::ImportPrefix);\n+                    self.smart_resolve_path_with_crate_lint(\n+                        id,\n+                        None,\n+                        &path,\n+                        PathSource::ImportPrefix,\n+                        CrateLint::UsePath { root_id, root_span },\n+                    );\n                 } else {\n                     for &(ref tree, nested_id) in items {\n-                        self.resolve_use_tree(nested_id, tree, &path);\n+                        self.resolve_use_tree(root_id, root_span, nested_id, tree, &path);\n                     }\n                 }\n             }\n@@ -2354,7 +2371,8 @@ impl<'a> Resolver<'a> {\n                 None,\n                 &path,\n                 trait_ref.path.span,\n-                PathSource::Trait(AliasPossibility::No)\n+                PathSource::Trait(AliasPossibility::No),\n+                CrateLint::SimplePath(trait_ref.ref_id),\n             ).base_def();\n             if def != Def::Err {\n                 new_id = Some(def.def_id());\n@@ -2787,18 +2805,38 @@ impl<'a> Resolver<'a> {\n                           path: &Path,\n                           source: PathSource)\n                           -> PathResolution {\n+        self.smart_resolve_path_with_crate_lint(id, qself, path, source, CrateLint::SimplePath(id))\n+    }\n+\n+    /// A variant of `smart_resolve_path` where you also specify extra\n+    /// information about where the path came from; this extra info is\n+    /// sometimes needed for the lint that recommends rewriting\n+    /// absoluate paths to `crate`, so that it knows how to frame the\n+    /// suggestion. If you are just resolving a path like `foo::bar`\n+    /// that appears...somewhere, though, then you just want\n+    /// `CrateLint::SimplePath`, which is what `smart_resolve_path`\n+    /// already provides.\n+    fn smart_resolve_path_with_crate_lint(\n+        &mut self,\n+        id: NodeId,\n+        qself: Option<&QSelf>,\n+        path: &Path,\n+        source: PathSource,\n+        crate_lint: CrateLint\n+    ) -> PathResolution {\n         let segments = &path.segments.iter()\n             .map(|seg| seg.ident)\n             .collect::<Vec<_>>();\n-        self.smart_resolve_path_fragment(id, qself, segments, path.span, source)\n+        self.smart_resolve_path_fragment(id, qself, segments, path.span, source, crate_lint)\n     }\n \n     fn smart_resolve_path_fragment(&mut self,\n                                    id: NodeId,\n                                    qself: Option<&QSelf>,\n                                    path: &[Ident],\n                                    span: Span,\n-                                   source: PathSource)\n+                                   source: PathSource,\n+                                   crate_lint: CrateLint)\n                                    -> PathResolution {\n         let ident_span = path.last().map_or(span, |ident| ident.span);\n         let ns = source.namespace();\n@@ -2999,9 +3037,16 @@ impl<'a> Resolver<'a> {\n             err_path_resolution()\n         };\n \n-        let resolution = match self.resolve_qpath_anywhere(id, qself, path, ns, span,\n-                                                           source.defer_to_typeck(),\n-                                                           source.global_by_default()) {\n+        let resolution = match self.resolve_qpath_anywhere(\n+            id,\n+            qself,\n+            path,\n+            ns,\n+            span,\n+            source.defer_to_typeck(),\n+            source.global_by_default(),\n+            crate_lint,\n+        ) {\n             Some(resolution) if resolution.unresolved_segments() == 0 => {\n                 if is_expected(resolution.base_def()) || resolution.base_def() == Def::Err {\n                     resolution\n@@ -3102,14 +3147,15 @@ impl<'a> Resolver<'a> {\n                               primary_ns: Namespace,\n                               span: Span,\n                               defer_to_typeck: bool,\n-                              global_by_default: bool)\n+                              global_by_default: bool,\n+                              crate_lint: CrateLint)\n                               -> Option<PathResolution> {\n         let mut fin_res = None;\n         // FIXME: can't resolve paths in macro namespace yet, macros are\n         // processed by the little special hack below.\n         for (i, ns) in [primary_ns, TypeNS, ValueNS, /*MacroNS*/].iter().cloned().enumerate() {\n             if i == 0 || ns != primary_ns {\n-                match self.resolve_qpath(id, qself, path, ns, span, global_by_default) {\n+                match self.resolve_qpath(id, qself, path, ns, span, global_by_default, crate_lint) {\n                     // If defer_to_typeck, then resolution > no resolution,\n                     // otherwise full resolution > partial resolution > no resolution.\n                     Some(res) if res.unresolved_segments() == 0 || defer_to_typeck =>\n@@ -3137,19 +3183,60 @@ impl<'a> Resolver<'a> {\n                      path: &[Ident],\n                      ns: Namespace,\n                      span: Span,\n-                     global_by_default: bool)\n+                     global_by_default: bool,\n+                     crate_lint: CrateLint)\n                      -> Option<PathResolution> {\n+        debug!(\n+            \"resolve_qpath(id={:?}, qself={:?}, path={:?}, \\\n+             ns={:?}, span={:?}, global_by_default={:?})\",\n+            id,\n+            qself,\n+            path,\n+            ns,\n+            span,\n+            global_by_default,\n+        );\n+\n         if let Some(qself) = qself {\n             if qself.position == 0 {\n-                // FIXME: Create some fake resolution that can't possibly be a type.\n+                // This is a case like `<T>::B`, where there is no\n+                // trait to resolve.  In that case, we leave the `B`\n+                // segment to be resolved by type-check.\n                 return Some(PathResolution::with_unresolved_segments(\n                     Def::Mod(DefId::local(CRATE_DEF_INDEX)), path.len()\n                 ));\n             }\n-            // Make sure `A::B` in `<T as A>::B::C` is a trait item.\n+\n+            // Make sure `A::B` in `<T as A::B>::C` is a trait item.\n+            //\n+            // Currently, `path` names the full item (`A::B::C`, in\n+            // our example).  so we extract the prefix of that that is\n+            // the trait (the slice upto and including\n+            // `qself.position`). And then we recursively resolve that,\n+            // but with `qself` set to `None`.\n+            //\n+            // However, setting `qself` to none (but not changing the\n+            // span) loses the information about where this path\n+            // *actually* appears, so for the purposes of the crate\n+            // lint we pass along information that this is the trait\n+            // name from a fully qualified path, and this also\n+            // contains the full span (the `CrateLint::QPathTrait`).\n             let ns = if qself.position + 1 == path.len() { ns } else { TypeNS };\n-            let res = self.smart_resolve_path_fragment(id, None, &path[..qself.position + 1],\n-                                                       span, PathSource::TraitItem(ns));\n+            let res = self.smart_resolve_path_fragment(\n+                id,\n+                None,\n+                &path[..qself.position + 1],\n+                span,\n+                PathSource::TraitItem(ns),\n+                CrateLint::QPathTrait {\n+                    qpath_id: id,\n+                    qpath_span: qself.path_span,\n+                },\n+            );\n+\n+            // The remaining segments (the `C` in our example) will\n+            // have to be resolved by type-check, since that requires doing\n+            // trait resolution.\n             return Some(PathResolution::with_unresolved_segments(\n                 res.base_def(), res.unresolved_segments() + path.len() - qself.position - 1\n             ));\n@@ -3160,7 +3247,7 @@ impl<'a> Resolver<'a> {\n             Some(ns),\n             true,\n             span,\n-            CrateLint::SimplePath(id),\n+            crate_lint,\n         ) {\n             PathResult::NonModule(path_res) => path_res,\n             PathResult::Module(module) if !module.is_normal() => {\n@@ -3231,6 +3318,16 @@ impl<'a> Resolver<'a> {\n         let mut allow_super = true;\n         let mut second_binding = None;\n \n+        debug!(\n+            \"resolve_path(path={:?}, opt_ns={:?}, record_used={:?}, \\\n+             path_span={:?}, crate_lint={:?})\",\n+            path,\n+            opt_ns,\n+            record_used,\n+            path_span,\n+            crate_lint,\n+        );\n+\n         for (i, &ident) in path.iter().enumerate() {\n             debug!(\"resolve_path ident {} {:?}\", i, ident);\n             let is_last = i == path.len() - 1;\n@@ -3406,6 +3503,7 @@ impl<'a> Resolver<'a> {\n             CrateLint::No => return,\n             CrateLint::SimplePath(id) => (id, path_span),\n             CrateLint::UsePath { root_id, root_span } => (root_id, root_span),\n+            CrateLint::QPathTrait { qpath_id, qpath_span } => (qpath_id, qpath_span),\n         };\n \n         let first_name = match path.get(0) {\n@@ -4093,8 +4191,14 @@ impl<'a> Resolver<'a> {\n                 let segments = path.make_root().iter().chain(path.segments.iter())\n                     .map(|seg| seg.ident)\n                     .collect::<Vec<_>>();\n-                let def = self.smart_resolve_path_fragment(id, None, &segments, path.span,\n-                                                           PathSource::Visibility).base_def();\n+                let def = self.smart_resolve_path_fragment(\n+                    id,\n+                    None,\n+                    &segments,\n+                    path.span,\n+                    PathSource::Visibility,\n+                    CrateLint::SimplePath(id),\n+                ).base_def();\n                 if def == Def::Err {\n                     ty::Visibility::Public\n                 } else {\n@@ -4454,6 +4558,7 @@ pub enum MakeGlobMap {\n     No,\n }\n \n+#[derive(Copy, Clone, Debug)]\n enum CrateLint {\n     /// Do not issue the lint\n     No,\n@@ -4467,6 +4572,11 @@ enum CrateLint {\n     /// have nested things like `use a::{b, c}`, we care about the\n     /// `use a` part.\n     UsePath { root_id: NodeId, root_span: Span },\n+\n+    /// This is the \"trait item\" from a fully qualified path. For example,\n+    /// we might be resolving  `X::Y::Z` from a path like `<T as X::Y>::Z`.\n+    /// The `path_span` is the span of the to the trait itself (`X::Y`).\n+    QPathTrait { qpath_id: NodeId, qpath_span: Span },\n }\n \n __build_diagnostic_array! { librustc_resolve, DIAGNOSTICS }"}, {"sha": "72d5323a8722aa70a7dc4f88293ea4ed735ec2c1", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27649b70327efd0613c8de01ff0b78205473a253/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27649b70327efd0613c8de01ff0b78205473a253/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=27649b70327efd0613c8de01ff0b78205473a253", "patch": "@@ -1211,6 +1211,11 @@ pub enum ExprKind {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct QSelf {\n     pub ty: P<Ty>,\n+\n+    /// The span of `a::b::Trait` in a path like `<Vec<T> as\n+    /// a::b::Trait>::AssociatedItem`; in the case where `position ==\n+    /// 0`, this is an empty span.\n+    pub path_span: Span,\n     pub position: usize\n }\n "}, {"sha": "6664c0a5982ee5e826e0fb50166fbe79315cf84a", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27649b70327efd0613c8de01ff0b78205473a253/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27649b70327efd0613c8de01ff0b78205473a253/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=27649b70327efd0613c8de01ff0b78205473a253", "patch": "@@ -373,6 +373,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n         (ast::QSelf {\n             ty: self_type,\n+            path_span: path.span,\n             position: path.segments.len() - 1\n         }, path)\n     }"}, {"sha": "525a82b61345224353ad7734709da1cc3f327b92", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/27649b70327efd0613c8de01ff0b78205473a253/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27649b70327efd0613c8de01ff0b78205473a253/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=27649b70327efd0613c8de01ff0b78205473a253", "patch": "@@ -390,9 +390,10 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n             TyKind::Tup(tys) => TyKind::Tup(tys.move_map(|ty| fld.fold_ty(ty))),\n             TyKind::Paren(ty) => TyKind::Paren(fld.fold_ty(ty)),\n             TyKind::Path(qself, path) => {\n-                let qself = qself.map(|QSelf { ty, position }| {\n+                let qself = qself.map(|QSelf { ty, path_span, position }| {\n                     QSelf {\n                         ty: fld.fold_ty(ty),\n+                        path_span: fld.new_span(path_span),\n                         position,\n                     }\n                 });\n@@ -1131,7 +1132,11 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n             }\n             PatKind::Path(opt_qself, pth) => {\n                 let opt_qself = opt_qself.map(|qself| {\n-                    QSelf { ty: folder.fold_ty(qself.ty), position: qself.position }\n+                    QSelf {\n+                        ty: folder.fold_ty(qself.ty),\n+                        path_span: folder.new_span(qself.path_span),\n+                        position: qself.position,\n+                    }\n                 });\n                 PatKind::Path(opt_qself, folder.fold_path(pth))\n             }\n@@ -1292,9 +1297,10 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                                 lim)\n             }\n             ExprKind::Path(qself, path) => {\n-                let qself = qself.map(|QSelf { ty, position }| {\n+                let qself = qself.map(|QSelf { ty, path_span, position }| {\n                     QSelf {\n                         ty: folder.fold_ty(ty),\n+                        path_span: folder.new_span(path_span),\n                         position,\n                     }\n                 });"}, {"sha": "1429d881fe9bc9844c0f3be92a2777e9bd4a288b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/27649b70327efd0613c8de01ff0b78205473a253/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27649b70327efd0613c8de01ff0b78205473a253/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=27649b70327efd0613c8de01ff0b78205473a253", "patch": "@@ -1715,8 +1715,11 @@ impl<'a> Parser<'a> {\n         self.parse_path_segments(&mut segments, T::PATH_STYLE, true)?;\n \n         let span = ty.span.to(self.prev_span);\n-        let recovered =\n-            base.to_recovered(Some(QSelf { ty, position: 0 }), ast::Path { segments, span });\n+        let path_span = span.to(span); // use an empty path since `position` == 0\n+        let recovered = base.to_recovered(\n+            Some(QSelf { ty, path_span, position: 0 }),\n+            ast::Path { segments, span },\n+        );\n \n         self.diagnostic()\n             .struct_span_err(span, \"missing angle brackets in associated item path\")\n@@ -1905,21 +1908,32 @@ impl<'a> Parser<'a> {\n     /// `qualified_path = <type [as trait_ref]>::path`\n     ///\n     /// # Examples\n+    /// `<T>::default`\n     /// `<T as U>::a`\n     /// `<T as U>::F::a<S>` (without disambiguator)\n     /// `<T as U>::F::a::<S>` (with disambiguator)\n     fn parse_qpath(&mut self, style: PathStyle) -> PResult<'a, (QSelf, ast::Path)> {\n         let lo = self.prev_span;\n         let ty = self.parse_ty()?;\n-        let mut path = if self.eat_keyword(keywords::As) {\n-            self.parse_path(PathStyle::Type)?\n+\n+        // `path` will contain the prefix of the path up to the `>`,\n+        // if any (e.g., `U` in the `<T as U>::*` examples\n+        // above). `path_span` has the span of that path, or an empty\n+        // span in the case of something like `<T>::Bar`.\n+        let (mut path, path_span);\n+        if self.eat_keyword(keywords::As) {\n+            let path_lo = self.span;\n+            path = self.parse_path(PathStyle::Type)?;\n+            path_span = path_lo.to(self.prev_span);\n         } else {\n-            ast::Path { segments: Vec::new(), span: syntax_pos::DUMMY_SP }\n-        };\n+            path = ast::Path { segments: Vec::new(), span: syntax_pos::DUMMY_SP };\n+            path_span = self.span.to(self.span);\n+        }\n+\n         self.expect(&token::Gt)?;\n         self.expect(&token::ModSep)?;\n \n-        let qself = QSelf { ty, position: path.segments.len() };\n+        let qself = QSelf { ty, path_span, position: path.segments.len() };\n         self.parse_path_segments(&mut path.segments, style, true)?;\n \n         Ok((qself, ast::Path { segments: path.segments, span: lo.to(self.prev_span) }))"}, {"sha": "717abba6390a08291212a363f12d8d535b7ad6c5", "filename": "src/test/ui/rust-2018/edition-lint-fully-qualified-paths.fixed", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/27649b70327efd0613c8de01ff0b78205473a253/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/27649b70327efd0613c8de01ff0b78205473a253/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.fixed?ref=27649b70327efd0613c8de01ff0b78205473a253", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-rustfix\n+\n+#![feature(rust_2018_preview)]\n+#![deny(absolute_path_not_starting_with_crate)]\n+\n+mod foo {\n+    crate trait Foo {\n+        type Bar;\n+    }\n+\n+    crate struct Baz { }\n+\n+    impl Foo for Baz {\n+        type Bar = ();\n+    }\n+}\n+\n+\n+fn main() {\n+    let _: <foo::Baz as crate::foo::Foo>::Bar = ();\n+    //~^ ERROR absolute paths must start with\n+    //~| this was previously accepted\n+\n+    let _: <crate::foo::Baz as foo::Foo>::Bar = ();\n+    //~^ ERROR absolute paths must start with\n+    //~| this was previously accepted\n+}"}, {"sha": "eaa09b1f751c8bc34876151fac7531d968d48914", "filename": "src/test/ui/rust-2018/edition-lint-fully-qualified-paths.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/27649b70327efd0613c8de01ff0b78205473a253/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27649b70327efd0613c8de01ff0b78205473a253/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.rs?ref=27649b70327efd0613c8de01ff0b78205473a253", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-rustfix\n+\n+#![feature(rust_2018_preview)]\n+#![deny(absolute_path_not_starting_with_crate)]\n+\n+mod foo {\n+    crate trait Foo {\n+        type Bar;\n+    }\n+\n+    crate struct Baz { }\n+\n+    impl Foo for Baz {\n+        type Bar = ();\n+    }\n+}\n+\n+\n+fn main() {\n+    let _: <foo::Baz as ::foo::Foo>::Bar = ();\n+    //~^ ERROR absolute paths must start with\n+    //~| this was previously accepted\n+\n+    let _: <::foo::Baz as foo::Foo>::Bar = ();\n+    //~^ ERROR absolute paths must start with\n+    //~| this was previously accepted\n+}"}, {"sha": "aea920342fc64016588c4c100926cefda7fbd7db", "filename": "src/test/ui/rust-2018/edition-lint-fully-qualified-paths.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/27649b70327efd0613c8de01ff0b78205473a253/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27649b70327efd0613c8de01ff0b78205473a253/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.stderr?ref=27649b70327efd0613c8de01ff0b78205473a253", "patch": "@@ -0,0 +1,25 @@\n+error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n+  --> $DIR/edition-lint-fully-qualified-paths.rs:30:25\n+   |\n+LL |     let _: <foo::Baz as ::foo::Foo>::Bar = ();\n+   |                         ^^^^^^^^^^ help: use `crate`: `crate::foo::Foo`\n+   |\n+note: lint level defined here\n+  --> $DIR/edition-lint-fully-qualified-paths.rs:14:9\n+   |\n+LL | #![deny(absolute_path_not_starting_with_crate)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue TBD\n+\n+error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n+  --> $DIR/edition-lint-fully-qualified-paths.rs:34:13\n+   |\n+LL |     let _: <::foo::Baz as foo::Foo>::Bar = ();\n+   |             ^^^^^^^^^^ help: use `crate`: `crate::foo::Baz`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue TBD\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "1fc76fb657f27b8ab625d0c6e7ab66ae0302e239", "filename": "src/test/ui/rust-2018/edition-lint-nested-empty-paths.fixed", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/27649b70327efd0613c8de01ff0b78205473a253/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/27649b70327efd0613c8de01ff0b78205473a253/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.fixed?ref=27649b70327efd0613c8de01ff0b78205473a253", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-rustfix\n+\n+#![feature(rust_2018_preview)]\n+#![deny(absolute_path_not_starting_with_crate)]\n+#![allow(unused_imports)]\n+#![allow(dead_code)]\n+\n+crate mod foo {\n+    crate mod bar {\n+        crate mod baz { }\n+        crate mod baz1 { }\n+\n+        crate struct XX;\n+    }\n+}\n+\n+use crate::foo::{bar::{baz::{}}};\n+//~^ ERROR absolute paths must start with\n+//~| WARN this was previously accepted\n+\n+use crate::foo::{bar::{XX, baz::{}}};\n+//~^ ERROR absolute paths must start with\n+//~| WARN this was previously accepted\n+\n+use crate::foo::{bar::{baz::{}, baz1::{}}};\n+//~^ ERROR absolute paths must start with\n+//~| WARN this was previously accepted\n+\n+fn main() {\n+}"}, {"sha": "8327c62d77971b169c132cd106f3d893ef624263", "filename": "src/test/ui/rust-2018/edition-lint-nested-empty-paths.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/27649b70327efd0613c8de01ff0b78205473a253/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27649b70327efd0613c8de01ff0b78205473a253/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.rs?ref=27649b70327efd0613c8de01ff0b78205473a253", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-rustfix\n+\n+#![feature(rust_2018_preview)]\n+#![deny(absolute_path_not_starting_with_crate)]\n+#![allow(unused_imports)]\n+#![allow(dead_code)]\n+\n+crate mod foo {\n+    crate mod bar {\n+        crate mod baz { }\n+        crate mod baz1 { }\n+\n+        crate struct XX;\n+    }\n+}\n+\n+use foo::{bar::{baz::{}}};\n+//~^ ERROR absolute paths must start with\n+//~| WARN this was previously accepted\n+\n+use foo::{bar::{XX, baz::{}}};\n+//~^ ERROR absolute paths must start with\n+//~| WARN this was previously accepted\n+\n+use foo::{bar::{baz::{}, baz1::{}}};\n+//~^ ERROR absolute paths must start with\n+//~| WARN this was previously accepted\n+\n+fn main() {\n+}"}, {"sha": "82c8ef30ac37068b39b9c67850e5c134a916aa21", "filename": "src/test/ui/rust-2018/edition-lint-nested-empty-paths.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/27649b70327efd0613c8de01ff0b78205473a253/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27649b70327efd0613c8de01ff0b78205473a253/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.stderr?ref=27649b70327efd0613c8de01ff0b78205473a253", "patch": "@@ -0,0 +1,34 @@\n+error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n+  --> $DIR/edition-lint-nested-empty-paths.rs:27:5\n+   |\n+LL | use foo::{bar::{baz::{}}};\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: use `crate`: `crate::foo::{bar::{baz::{}}}`\n+   |\n+note: lint level defined here\n+  --> $DIR/edition-lint-nested-empty-paths.rs:14:9\n+   |\n+LL | #![deny(absolute_path_not_starting_with_crate)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue TBD\n+\n+error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n+  --> $DIR/edition-lint-nested-empty-paths.rs:31:5\n+   |\n+LL | use foo::{bar::{XX, baz::{}}};\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `crate`: `crate::foo::{bar::{XX, baz::{}}}`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue TBD\n+\n+error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition\n+  --> $DIR/edition-lint-nested-empty-paths.rs:35:5\n+   |\n+LL | use foo::{bar::{baz::{}, baz1::{}}};\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `crate`: `crate::foo::{bar::{baz::{}, baz1::{}}}`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue TBD\n+\n+error: aborting due to 3 previous errors\n+"}]}