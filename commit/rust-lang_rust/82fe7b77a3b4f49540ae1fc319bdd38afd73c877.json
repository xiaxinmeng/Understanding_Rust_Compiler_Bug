{"sha": "82fe7b77a3b4f49540ae1fc319bdd38afd73c877", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyZmU3Yjc3YTNiNGY0OTU0MGFlMWZjMzE5YmRkMzhhZmQ3M2M4Nzc=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-02-23T21:59:01Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-02-23T22:00:02Z"}, "message": "Refactor associated method resolution a bit and make it work with generics", "tree": {"sha": "574d01f1f7532574ed22610341b3ac79da59d93f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/574d01f1f7532574ed22610341b3ac79da59d93f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82fe7b77a3b4f49540ae1fc319bdd38afd73c877", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82fe7b77a3b4f49540ae1fc319bdd38afd73c877", "html_url": "https://github.com/rust-lang/rust/commit/82fe7b77a3b4f49540ae1fc319bdd38afd73c877", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82fe7b77a3b4f49540ae1fc319bdd38afd73c877/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1eef9fbefe44e919f6ddc7ce1c44625ffde6be1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1eef9fbefe44e919f6ddc7ce1c44625ffde6be1c", "html_url": "https://github.com/rust-lang/rust/commit/1eef9fbefe44e919f6ddc7ce1c44625ffde6be1c"}], "stats": {"total": 162, "additions": 98, "deletions": 64}, "files": [{"sha": "13080b5aa6a5453b46a2940677c7d98bf946173c", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 53, "deletions": 33, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/82fe7b77a3b4f49540ae1fc319bdd38afd73c877/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fe7b77a3b4f49540ae1fc319bdd38afd73c877/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=82fe7b77a3b4f49540ae1fc319bdd38afd73c877", "patch": "@@ -360,46 +360,66 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         // we might have resolved into a type for which\n         // we may find some associated item starting at the\n         // path.segment pointed to by `remaining_index\u00b4\n-        let resolved =\n+        let mut resolved =\n             if remaining_index.is_none() { def.take_values()? } else { def.take_types()? };\n \n+        let remaining_index = remaining_index.unwrap_or(path.segments.len());\n+\n+        // resolve intermediate segments\n+        for segment in &path.segments[remaining_index..] {\n+            let ty = match resolved {\n+                Resolution::Def(def) => {\n+                    let typable: Option<TypableDef> = def.into();\n+                    let typable = typable?;\n+\n+                    let substs =\n+                        Ty::substs_from_path_segment(self.db, &self.resolver, segment, typable);\n+                    self.db.type_for_def(typable, Namespace::Types).apply_substs(substs)\n+                }\n+                Resolution::LocalBinding(_) => {\n+                    // can't have a local binding in an associated item path\n+                    return None;\n+                }\n+                Resolution::GenericParam(..) => {\n+                    // TODO associated item of generic param\n+                    return None;\n+                }\n+                Resolution::SelfType(_) => {\n+                    // TODO associated item of self type\n+                    return None;\n+                }\n+            };\n+\n+            // Attempt to find an impl_item for the type which has a name matching\n+            // the current segment\n+            log::debug!(\"looking for path segment: {:?}\", segment);\n+            let item = ty.iterate_impl_items(self.db, |item| match item {\n+                crate::ImplItem::Method(func) => {\n+                    let sig = func.signature(self.db);\n+                    if segment.name == *sig.name() {\n+                        return Some(func);\n+                    }\n+                    None\n+                }\n+\n+                // TODO: Resolve associated const\n+                crate::ImplItem::Const(_) => None,\n+\n+                // TODO: Resolve associated types\n+                crate::ImplItem::Type(_) => None,\n+            })?;\n+            resolved = Resolution::Def(item.into());\n+        }\n+\n         match resolved {\n             Resolution::Def(def) => {\n                 let typable: Option<TypableDef> = def.into();\n                 let typable = typable?;\n \n-                if let Some(remaining_index) = remaining_index {\n-                    let ty = self.db.type_for_def(typable, Namespace::Types);\n-                    // TODO: Keep resolving the segments\n-                    // if we have more segments to process\n-                    let segment = &path.segments[remaining_index];\n-\n-                    log::debug!(\"looking for path segment: {:?}\", segment);\n-\n-                    // Attempt to find an impl_item for the type which has a name matching\n-                    // the current segment\n-                    let ty = ty.iterate_impl_items(self.db, |item| match item {\n-                        crate::ImplItem::Method(func) => {\n-                            let sig = func.signature(self.db);\n-                            if segment.name == *sig.name() {\n-                                return Some(func.ty(self.db));\n-                            }\n-                            None\n-                        }\n-\n-                        // TODO: Resolve associated const\n-                        crate::ImplItem::Const(_) => None,\n-\n-                        // TODO: Resolve associated types\n-                        crate::ImplItem::Type(_) => None,\n-                    });\n-                    ty\n-                } else {\n-                    let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n-                    let ty = self.db.type_for_def(typable, Namespace::Values).apply_substs(substs);\n-                    let ty = self.insert_type_vars(ty);\n-                    Some(ty)\n-                }\n+                let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n+                let ty = self.db.type_for_def(typable, Namespace::Values).apply_substs(substs);\n+                let ty = self.insert_type_vars(ty);\n+                Some(ty)\n             }\n             Resolution::LocalBinding(pat) => {\n                 let ty = self.type_of_pat.get(pat)?;"}, {"sha": "63e13a30e8e5deefd5bdd12a2c9276bda15b723a", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/82fe7b77a3b4f49540ae1fc319bdd38afd73c877/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fe7b77a3b4f49540ae1fc319bdd38afd73c877/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=82fe7b77a3b4f49540ae1fc319bdd38afd73c877", "patch": "@@ -16,7 +16,7 @@ use crate::{\n     name::KnownName,\n     nameres::Namespace,\n     resolve::{Resolver, Resolution},\n-    path::GenericArg,\n+    path::{ PathSegment, GenericArg},\n     generics::GenericParams,\n     adt::VariantDef,\n };\n@@ -112,36 +112,18 @@ impl Ty {\n         ty.apply_substs(substs)\n     }\n \n-    /// Collect generic arguments from a path into a `Substs`. See also\n-    /// `create_substs_for_ast_path` and `def_to_ty` in rustc.\n-    pub(super) fn substs_from_path(\n+    pub(super) fn substs_from_path_segment(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n-        path: &Path,\n+        segment: &PathSegment,\n         resolved: TypableDef,\n     ) -> Substs {\n         let mut substs = Vec::new();\n-        let last = path.segments.last().expect(\"path should have at least one segment\");\n-        let (def_generics, segment) = match resolved {\n-            TypableDef::Function(func) => (func.generic_params(db), last),\n-            TypableDef::Struct(s) => (s.generic_params(db), last),\n-            TypableDef::Enum(e) => (e.generic_params(db), last),\n-            TypableDef::EnumVariant(var) => {\n-                // the generic args for an enum variant may be either specified\n-                // on the segment referring to the enum, or on the segment\n-                // referring to the variant. So `Option::<T>::None` and\n-                // `Option::None::<T>` are both allowed (though the former is\n-                // preferred). See also `def_ids_for_path_segments` in rustc.\n-                let len = path.segments.len();\n-                let segment = if len >= 2 && path.segments[len - 2].args_and_bindings.is_some() {\n-                    // Option::<T>::None\n-                    &path.segments[len - 2]\n-                } else {\n-                    // Option::None::<T>\n-                    last\n-                };\n-                (var.parent_enum(db).generic_params(db), segment)\n-            }\n+        let def_generics = match resolved {\n+            TypableDef::Function(func) => func.generic_params(db),\n+            TypableDef::Struct(s) => s.generic_params(db),\n+            TypableDef::Enum(e) => e.generic_params(db),\n+            TypableDef::EnumVariant(var) => var.parent_enum(db).generic_params(db),\n         };\n         let parent_param_count = def_generics.count_parent_params();\n         substs.extend((0..parent_param_count).map(|_| Ty::Unknown));\n@@ -166,6 +148,39 @@ impl Ty {\n         assert_eq!(substs.len(), def_generics.count_params_including_parent());\n         Substs(substs.into())\n     }\n+\n+    /// Collect generic arguments from a path into a `Substs`. See also\n+    /// `create_substs_for_ast_path` and `def_to_ty` in rustc.\n+    pub(super) fn substs_from_path(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        path: &Path,\n+        resolved: TypableDef,\n+    ) -> Substs {\n+        let last = path.segments.last().expect(\"path should have at least one segment\");\n+        let segment = match resolved {\n+            TypableDef::Function(_) => last,\n+            TypableDef::Struct(_) => last,\n+            TypableDef::Enum(_) => last,\n+            TypableDef::EnumVariant(_) => {\n+                // the generic args for an enum variant may be either specified\n+                // on the segment referring to the enum, or on the segment\n+                // referring to the variant. So `Option::<T>::None` and\n+                // `Option::None::<T>` are both allowed (though the former is\n+                // preferred). See also `def_ids_for_path_segments` in rustc.\n+                let len = path.segments.len();\n+                let segment = if len >= 2 && path.segments[len - 2].args_and_bindings.is_some() {\n+                    // Option::<T>::None\n+                    &path.segments[len - 2]\n+                } else {\n+                    // Option::None::<T>\n+                    last\n+                };\n+                segment\n+            }\n+        };\n+        Ty::substs_from_path_segment(db, resolver, segment, resolved)\n+    }\n }\n \n /// Build the declared type of an item. This depends on the namespace; e.g. for"}, {"sha": "44694dfdb017d7a9c213f26af50cb528f37e1497", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_associated_method_generics.snap", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82fe7b77a3b4f49540ae1fc319bdd38afd73c877/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_generics.snap", "raw_url": "https://github.com/rust-lang/rust/raw/82fe7b77a3b4f49540ae1fc319bdd38afd73c877/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_generics.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_generics.snap?ref=82fe7b77a3b4f49540ae1fc319bdd38afd73c877", "patch": "@@ -1,5 +1,5 @@\n ---\n-created: \"2019-02-21T10:25:18.568887300Z\"\n+created: \"2019-02-23T21:58:35.844769207Z\"\n creator: insta@0.6.3\n source: crates/ra_hir/src/ty/tests.rs\n expression: \"&result\"\n@@ -9,8 +9,8 @@ expression: \"&result\"\n [92; 103) 'Gen { val }': Gen<T>\n [98; 101) 'val': T\n [123; 155) '{     ...32); }': ()\n-[133; 134) 'a': Gen<[unknown]>\n-[137; 146) 'Gen::make': fn make<[unknown]>(T) -> Gen<T>\n-[137; 152) 'Gen::make(0u32)': Gen<[unknown]>\n+[133; 134) 'a': Gen<u32>\n+[137; 146) 'Gen::make': fn make<u32>(T) -> Gen<T>\n+[137; 152) 'Gen::make(0u32)': Gen<u32>\n [147; 151) '0u32': u32\n "}, {"sha": "d0da346770ea20af6adbd315cd61b64839344f78", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82fe7b77a3b4f49540ae1fc319bdd38afd73c877/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fe7b77a3b4f49540ae1fc319bdd38afd73c877/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=82fe7b77a3b4f49540ae1fc319bdd38afd73c877", "patch": "@@ -719,7 +719,6 @@ fn test() {\n }\n \n #[test]\n-#[ignore] // FIXME: After https://github.com/rust-analyzer/rust-analyzer/pull/866 is merged\n fn infer_associated_method_generics() {\n     check_inference(\n         \"infer_associated_method_generics\","}]}