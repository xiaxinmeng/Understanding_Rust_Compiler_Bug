{"sha": "9340e5c1b9dee53fd32a18f7bfb54faabfe00b7b", "node_id": "C_kwDOAAsO6NoAKDkzNDBlNWMxYjlkZWU1M2ZkMzJhMThmN2JmYjU0ZmFhYmZlMDBiN2I", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-17T04:47:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-17T04:47:11Z"}, "message": "Auto merge of #103779 - the8472:simd-str-contains, r=thomcc\n\nx86_64 SSE2 fast-path for str.contains(&str) and short needles\n\nBased on Wojciech Mu\u0142a's [SIMD-friendly algorithms for substring searching](http://0x80.pl/articles/simd-strfind.html#sse-avx2)\n\nThe two-way algorithm is Big-O efficient but it needs to preprocess the needle\nto find a \"critical factorization\" of it. This additional work is significant\nfor short needles. Additionally it mostly advances needle.len() bytes at a time.\n\nThe SIMD-based approach used here on the other hand can advance based on its\nvector width, which can exceed the needle length. Except for pathological cases,\nbut due to being limited to small needles the worst case blowup is also small.\n\nbenchmarks taken on a Zen2, compiled with `-Ccodegen-units=1`:\n\n```\nOLD:\ntest str::bench_contains_16b_in_long                     ... bench:         504 ns/iter (+/- 14) = 5061 MB/s\ntest str::bench_contains_2b_repeated_long                ... bench:         948 ns/iter (+/- 175) = 2690 MB/s\ntest str::bench_contains_32b_in_long                     ... bench:         445 ns/iter (+/- 6) = 5732 MB/s\ntest str::bench_contains_bad_naive                       ... bench:         130 ns/iter (+/- 1) = 569 MB/s\ntest str::bench_contains_bad_simd                        ... bench:          84 ns/iter (+/- 8) = 880 MB/s\ntest str::bench_contains_equal                           ... bench:         142 ns/iter (+/- 7) = 394 MB/s\ntest str::bench_contains_short_long                      ... bench:         677 ns/iter (+/- 25) = 3768 MB/s\ntest str::bench_contains_short_short                     ... bench:          27 ns/iter (+/- 2) = 2074 MB/s\n\nNEW:\ntest str::bench_contains_16b_in_long                     ... bench:          82 ns/iter (+/- 0) = 31109 MB/s\ntest str::bench_contains_2b_repeated_long                ... bench:          73 ns/iter (+/- 0) = 34945 MB/s\ntest str::bench_contains_32b_in_long                     ... bench:          71 ns/iter (+/- 1) = 35929 MB/s\ntest str::bench_contains_bad_naive                       ... bench:           7 ns/iter (+/- 0) = 10571 MB/s\ntest str::bench_contains_bad_simd                        ... bench:          97 ns/iter (+/- 41) = 762 MB/s\ntest str::bench_contains_equal                           ... bench:           4 ns/iter (+/- 0) = 14000 MB/s\ntest str::bench_contains_short_long                      ... bench:          73 ns/iter (+/- 0) = 34945 MB/s\ntest str::bench_contains_short_short                     ... bench:          12 ns/iter (+/- 0) = 4666 MB/s\n```", "tree": {"sha": "c9bf676e73bc0228eff29e6aecb4ae21168646cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9bf676e73bc0228eff29e6aecb4ae21168646cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9340e5c1b9dee53fd32a18f7bfb54faabfe00b7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9340e5c1b9dee53fd32a18f7bfb54faabfe00b7b", "html_url": "https://github.com/rust-lang/rust/commit/9340e5c1b9dee53fd32a18f7bfb54faabfe00b7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9340e5c1b9dee53fd32a18f7bfb54faabfe00b7b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "251831ece9601d64172127b6caae9087358c2386", "url": "https://api.github.com/repos/rust-lang/rust/commits/251831ece9601d64172127b6caae9087358c2386", "html_url": "https://github.com/rust-lang/rust/commit/251831ece9601d64172127b6caae9087358c2386"}, {"sha": "a2b2010891224cbaf448d5d799b3c47c87e863be", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2b2010891224cbaf448d5d799b3c47c87e863be", "html_url": "https://github.com/rust-lang/rust/commit/a2b2010891224cbaf448d5d799b3c47c87e863be"}], "stats": {"total": 323, "additions": 311, "deletions": 12}, "files": [{"sha": "54af389dedcd2000664c919b7fb776dc6c2d20dc", "filename": "library/alloc/benches/str.rs", "status": "modified", "additions": 58, "deletions": 7, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9340e5c1b9dee53fd32a18f7bfb54faabfe00b7b/library%2Falloc%2Fbenches%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9340e5c1b9dee53fd32a18f7bfb54faabfe00b7b/library%2Falloc%2Fbenches%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fstr.rs?ref=9340e5c1b9dee53fd32a18f7bfb54faabfe00b7b", "patch": "@@ -1,3 +1,4 @@\n+use core::iter::Iterator;\n use test::{black_box, Bencher};\n \n #[bench]\n@@ -122,14 +123,13 @@ fn bench_contains_short_short(b: &mut Bencher) {\n     let haystack = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n     let needle = \"sit\";\n \n+    b.bytes = haystack.len() as u64;\n     b.iter(|| {\n-        assert!(haystack.contains(needle));\n+        assert!(black_box(haystack).contains(black_box(needle)));\n     })\n }\n \n-#[bench]\n-fn bench_contains_short_long(b: &mut Bencher) {\n-    let haystack = \"\\\n+static LONG_HAYSTACK: &str = \"\\\n Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n@@ -164,10 +164,48 @@ feugiat. Etiam quis mauris vel risus luctus mattis a a nunc. Nullam orci quam, i\n vehicula in, porttitor ut nibh. Duis sagittis adipiscing nisl vitae congue. Donec mollis risus eu \\\n leo suscipit, varius porttitor nulla porta. Pellentesque ut sem nec nisi euismod vehicula. Nulla \\\n malesuada sollicitudin quam eu fermentum.\";\n+\n+#[bench]\n+fn bench_contains_2b_repeated_long(b: &mut Bencher) {\n+    let haystack = LONG_HAYSTACK;\n+    let needle = \"::\";\n+\n+    b.bytes = haystack.len() as u64;\n+    b.iter(|| {\n+        assert!(!black_box(haystack).contains(black_box(needle)));\n+    })\n+}\n+\n+#[bench]\n+fn bench_contains_short_long(b: &mut Bencher) {\n+    let haystack = LONG_HAYSTACK;\n     let needle = \"english\";\n \n+    b.bytes = haystack.len() as u64;\n+    b.iter(|| {\n+        assert!(!black_box(haystack).contains(black_box(needle)));\n+    })\n+}\n+\n+#[bench]\n+fn bench_contains_16b_in_long(b: &mut Bencher) {\n+    let haystack = LONG_HAYSTACK;\n+    let needle = \"english language\";\n+\n+    b.bytes = haystack.len() as u64;\n+    b.iter(|| {\n+        assert!(!black_box(haystack).contains(black_box(needle)));\n+    })\n+}\n+\n+#[bench]\n+fn bench_contains_32b_in_long(b: &mut Bencher) {\n+    let haystack = LONG_HAYSTACK;\n+    let needle = \"the english language sample text\";\n+\n+    b.bytes = haystack.len() as u64;\n     b.iter(|| {\n-        assert!(!haystack.contains(needle));\n+        assert!(!black_box(haystack).contains(black_box(needle)));\n     })\n }\n \n@@ -176,8 +214,20 @@ fn bench_contains_bad_naive(b: &mut Bencher) {\n     let haystack = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n     let needle = \"aaaaaaaab\";\n \n+    b.bytes = haystack.len() as u64;\n+    b.iter(|| {\n+        assert!(!black_box(haystack).contains(black_box(needle)));\n+    })\n+}\n+\n+#[bench]\n+fn bench_contains_bad_simd(b: &mut Bencher) {\n+    let haystack = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n+    let needle = \"aaabaaaa\";\n+\n+    b.bytes = haystack.len() as u64;\n     b.iter(|| {\n-        assert!(!haystack.contains(needle));\n+        assert!(!black_box(haystack).contains(black_box(needle)));\n     })\n }\n \n@@ -186,8 +236,9 @@ fn bench_contains_equal(b: &mut Bencher) {\n     let haystack = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n     let needle = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n \n+    b.bytes = haystack.len() as u64;\n     b.iter(|| {\n-        assert!(haystack.contains(needle));\n+        assert!(black_box(haystack).contains(black_box(needle)));\n     })\n }\n "}, {"sha": "9689196ef21ac78d537ebb9926a249bd3fd331f6", "filename": "library/alloc/tests/str.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9340e5c1b9dee53fd32a18f7bfb54faabfe00b7b/library%2Falloc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9340e5c1b9dee53fd32a18f7bfb54faabfe00b7b/library%2Falloc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstr.rs?ref=9340e5c1b9dee53fd32a18f7bfb54faabfe00b7b", "patch": "@@ -1590,11 +1590,27 @@ fn test_bool_from_str() {\n     assert_eq!(\"not even a boolean\".parse::<bool>().ok(), None);\n }\n \n-fn check_contains_all_substrings(s: &str) {\n-    assert!(s.contains(\"\"));\n-    for i in 0..s.len() {\n-        for j in i + 1..=s.len() {\n-            assert!(s.contains(&s[i..j]));\n+fn check_contains_all_substrings(haystack: &str) {\n+    let mut modified_needle = String::new();\n+\n+    for i in 0..haystack.len() {\n+        // check different haystack lengths since we special-case short haystacks.\n+        let haystack = &haystack[0..i];\n+        assert!(haystack.contains(\"\"));\n+        for j in 0..haystack.len() {\n+            for k in j + 1..=haystack.len() {\n+                let needle = &haystack[j..k];\n+                assert!(haystack.contains(needle));\n+                modified_needle.clear();\n+                modified_needle.push_str(needle);\n+                modified_needle.replace_range(0..1, \"\\0\");\n+                assert!(!haystack.contains(&modified_needle));\n+\n+                modified_needle.clear();\n+                modified_needle.push_str(needle);\n+                modified_needle.replace_range(needle.len() - 1..needle.len(), \"\\0\");\n+                assert!(!haystack.contains(&modified_needle));\n+            }\n         }\n     }\n }"}, {"sha": "c5be32861f9a5a3441637eabec43400735b03bcc", "filename": "library/core/src/str/pattern.rs", "status": "modified", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/9340e5c1b9dee53fd32a18f7bfb54faabfe00b7b/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9340e5c1b9dee53fd32a18f7bfb54faabfe00b7b/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs?ref=9340e5c1b9dee53fd32a18f7bfb54faabfe00b7b", "patch": "@@ -39,6 +39,7 @@\n )]\n \n use crate::cmp;\n+use crate::cmp::Ordering;\n use crate::fmt;\n use crate::slice::memchr;\n \n@@ -946,6 +947,32 @@ impl<'a, 'b> Pattern<'a> for &'b str {\n         haystack.as_bytes().starts_with(self.as_bytes())\n     }\n \n+    /// Checks whether the pattern matches anywhere in the haystack\n+    #[inline]\n+    fn is_contained_in(self, haystack: &'a str) -> bool {\n+        if self.len() == 0 {\n+            return true;\n+        }\n+\n+        match self.len().cmp(&haystack.len()) {\n+            Ordering::Less => {\n+                if self.len() == 1 {\n+                    return haystack.as_bytes().contains(&self.as_bytes()[0]);\n+                }\n+\n+                #[cfg(all(target_arch = \"x86_64\", target_feature = \"sse2\"))]\n+                if self.len() <= 32 {\n+                    if let Some(result) = simd_contains(self, haystack) {\n+                        return result;\n+                    }\n+                }\n+\n+                self.into_searcher(haystack).next_match().is_some()\n+            }\n+            _ => self == haystack,\n+        }\n+    }\n+\n     /// Removes the pattern from the front of haystack, if it matches.\n     #[inline]\n     fn strip_prefix_of(self, haystack: &'a str) -> Option<&'a str> {\n@@ -1684,3 +1711,208 @@ impl TwoWayStrategy for RejectAndMatch {\n         SearchStep::Match(a, b)\n     }\n }\n+\n+/// SIMD search for short needles based on\n+/// Wojciech Mu\u0142a's \"SIMD-friendly algorithms for substring searching\"[0]\n+///\n+/// It skips ahead by the vector width on each iteration (rather than the needle length as two-way\n+/// does) by probing the first and last byte of the needle for the whole vector width\n+/// and only doing full needle comparisons when the vectorized probe indicated potential matches.\n+///\n+/// Since the x86_64 baseline only offers SSE2 we only use u8x16 here.\n+/// If we ever ship std with for x86-64-v3 or adapt this for other platforms then wider vectors\n+/// should be evaluated.\n+///\n+/// For haystacks smaller than vector-size + needle length it falls back to\n+/// a naive O(n*m) search so this implementation should not be called on larger needles.\n+///\n+/// [0]: http://0x80.pl/articles/simd-strfind.html#sse-avx2\n+#[cfg(all(target_arch = \"x86_64\", target_feature = \"sse2\"))]\n+#[inline]\n+fn simd_contains(needle: &str, haystack: &str) -> Option<bool> {\n+    let needle = needle.as_bytes();\n+    let haystack = haystack.as_bytes();\n+\n+    debug_assert!(needle.len() > 1);\n+\n+    use crate::ops::BitAnd;\n+    use crate::simd::mask8x16 as Mask;\n+    use crate::simd::u8x16 as Block;\n+    use crate::simd::{SimdPartialEq, ToBitMask};\n+\n+    let first_probe = needle[0];\n+\n+    // the offset used for the 2nd vector\n+    let second_probe_offset = if needle.len() == 2 {\n+        // never bail out on len=2 needles because the probes will fully cover them and have\n+        // no degenerate cases.\n+        1\n+    } else {\n+        // try a few bytes in case first and last byte of the needle are the same\n+        let Some(second_probe_offset) = (needle.len().saturating_sub(4)..needle.len()).rfind(|&idx| needle[idx] != first_probe) else {\n+            // fall back to other search methods if we can't find any different bytes\n+            // since we could otherwise hit some degenerate cases\n+            return None;\n+        };\n+        second_probe_offset\n+    };\n+\n+    // do a naive search if the haystack is too small to fit\n+    if haystack.len() < Block::LANES + second_probe_offset {\n+        return Some(haystack.windows(needle.len()).any(|c| c == needle));\n+    }\n+\n+    let first_probe: Block = Block::splat(first_probe);\n+    let second_probe: Block = Block::splat(needle[second_probe_offset]);\n+    // first byte are already checked by the outer loop. to verify a match only the\n+    // remainder has to be compared.\n+    let trimmed_needle = &needle[1..];\n+\n+    // this #[cold] is load-bearing, benchmark before removing it...\n+    let check_mask = #[cold]\n+    |idx, mask: u16, skip: bool| -> bool {\n+        if skip {\n+            return false;\n+        }\n+\n+        // and so is this. optimizations are weird.\n+        let mut mask = mask;\n+\n+        while mask != 0 {\n+            let trailing = mask.trailing_zeros();\n+            let offset = idx + trailing as usize + 1;\n+            // SAFETY: mask is between 0 and 15 trailing zeroes, we skip one additional byte that was already compared\n+            // and then take trimmed_needle.len() bytes. This is within the bounds defined by the outer loop\n+            unsafe {\n+                let sub = haystack.get_unchecked(offset..).get_unchecked(..trimmed_needle.len());\n+                if small_slice_eq(sub, trimmed_needle) {\n+                    return true;\n+                }\n+            }\n+            mask &= !(1 << trailing);\n+        }\n+        return false;\n+    };\n+\n+    let test_chunk = |idx| -> u16 {\n+        // SAFETY: this requires at least LANES bytes being readable at idx\n+        // that is ensured by the loop ranges (see comments below)\n+        let a: Block = unsafe { haystack.as_ptr().add(idx).cast::<Block>().read_unaligned() };\n+        // SAFETY: this requires LANES + block_offset bytes being readable at idx\n+        let b: Block = unsafe {\n+            haystack.as_ptr().add(idx).add(second_probe_offset).cast::<Block>().read_unaligned()\n+        };\n+        let eq_first: Mask = a.simd_eq(first_probe);\n+        let eq_last: Mask = b.simd_eq(second_probe);\n+        let both = eq_first.bitand(eq_last);\n+        let mask = both.to_bitmask();\n+\n+        return mask;\n+    };\n+\n+    let mut i = 0;\n+    let mut result = false;\n+    // The loop condition must ensure that there's enough headroom to read LANE bytes,\n+    // and not only at the current index but also at the index shifted by block_offset\n+    const UNROLL: usize = 4;\n+    while i + second_probe_offset + UNROLL * Block::LANES < haystack.len() && !result {\n+        let mut masks = [0u16; UNROLL];\n+        for j in 0..UNROLL {\n+            masks[j] = test_chunk(i + j * Block::LANES);\n+        }\n+        for j in 0..UNROLL {\n+            let mask = masks[j];\n+            if mask != 0 {\n+                result |= check_mask(i + j * Block::LANES, mask, result);\n+            }\n+        }\n+        i += UNROLL * Block::LANES;\n+    }\n+    while i + second_probe_offset + Block::LANES < haystack.len() && !result {\n+        let mask = test_chunk(i);\n+        if mask != 0 {\n+            result |= check_mask(i, mask, result);\n+        }\n+        i += Block::LANES;\n+    }\n+\n+    // Process the tail that didn't fit into LANES-sized steps.\n+    // This simply repeats the same procedure but as right-aligned chunk instead\n+    // of a left-aligned one. The last byte must be exactly flush with the string end so\n+    // we don't miss a single byte or read out of bounds.\n+    let i = haystack.len() - second_probe_offset - Block::LANES;\n+    let mask = test_chunk(i);\n+    if mask != 0 {\n+        result |= check_mask(i, mask, result);\n+    }\n+\n+    Some(result)\n+}\n+\n+/// Compares short slices for equality.\n+///\n+/// It avoids a call to libc's memcmp which is faster on long slices\n+/// due to SIMD optimizations but it incurs a function call overhead.\n+///\n+/// # Safety\n+///\n+/// Both slices must have the same length.\n+#[cfg(all(target_arch = \"x86_64\", target_feature = \"sse2\"))] // only called on x86\n+#[inline]\n+unsafe fn small_slice_eq(x: &[u8], y: &[u8]) -> bool {\n+    // This function is adapted from\n+    // https://github.com/BurntSushi/memchr/blob/8037d11b4357b0f07be2bb66dc2659d9cf28ad32/src/memmem/util.rs#L32\n+\n+    // If we don't have enough bytes to do 4-byte at a time loads, then\n+    // fall back to the naive slow version.\n+    //\n+    // Potential alternative: We could do a copy_nonoverlapping combined with a mask instead\n+    // of a loop. Benchmark it.\n+    if x.len() < 4 {\n+        for (&b1, &b2) in x.iter().zip(y) {\n+            if b1 != b2 {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    // When we have 4 or more bytes to compare, then proceed in chunks of 4 at\n+    // a time using unaligned loads.\n+    //\n+    // Also, why do 4 byte loads instead of, say, 8 byte loads? The reason is\n+    // that this particular version of memcmp is likely to be called with tiny\n+    // needles. That means that if we do 8 byte loads, then a higher proportion\n+    // of memcmp calls will use the slower variant above. With that said, this\n+    // is a hypothesis and is only loosely supported by benchmarks. There's\n+    // likely some improvement that could be made here. The main thing here\n+    // though is to optimize for latency, not throughput.\n+\n+    // SAFETY: Via the conditional above, we know that both `px` and `py`\n+    // have the same length, so `px < pxend` implies that `py < pyend`.\n+    // Thus, derefencing both `px` and `py` in the loop below is safe.\n+    //\n+    // Moreover, we set `pxend` and `pyend` to be 4 bytes before the actual\n+    // end of of `px` and `py`. Thus, the final dereference outside of the\n+    // loop is guaranteed to be valid. (The final comparison will overlap with\n+    // the last comparison done in the loop for lengths that aren't multiples\n+    // of four.)\n+    //\n+    // Finally, we needn't worry about alignment here, since we do unaligned\n+    // loads.\n+    unsafe {\n+        let (mut px, mut py) = (x.as_ptr(), y.as_ptr());\n+        let (pxend, pyend) = (px.add(x.len() - 4), py.add(y.len() - 4));\n+        while px < pxend {\n+            let vx = (px as *const u32).read_unaligned();\n+            let vy = (py as *const u32).read_unaligned();\n+            if vx != vy {\n+                return false;\n+            }\n+            px = px.add(4);\n+            py = py.add(4);\n+        }\n+        let vx = (pxend as *const u32).read_unaligned();\n+        let vy = (pyend as *const u32).read_unaligned();\n+        vx == vy\n+    }\n+}"}]}