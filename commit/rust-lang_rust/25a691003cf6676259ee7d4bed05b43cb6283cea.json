{"sha": "25a691003cf6676259ee7d4bed05b43cb6283cea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1YTY5MTAwM2NmNjY3NjI1OWVlN2Q0YmVkMDViNDNjYjYyODNjZWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-24T16:08:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-24T16:08:23Z"}, "message": "Auto merge of #79335 - jyn514:doctree-crate, r=GuillaumeGomez\n\nGet rid of doctree::{ExternalCrate, ForeignItem, Trait, Function}\n\nCloses #79314, closes #79331, closes #79332. Follow-up to #79264 and #79312, continues breaking up #78082.\n\nr? `@GuillaumeGomez`", "tree": {"sha": "2022066a6e97421109aea41f3fb8d7b8bae2430d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2022066a6e97421109aea41f3fb8d7b8bae2430d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25a691003cf6676259ee7d4bed05b43cb6283cea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25a691003cf6676259ee7d4bed05b43cb6283cea", "html_url": "https://github.com/rust-lang/rust/commit/25a691003cf6676259ee7d4bed05b43cb6283cea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25a691003cf6676259ee7d4bed05b43cb6283cea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53d19b37c514246acab020eaba9527cb97c421cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/53d19b37c514246acab020eaba9527cb97c421cf", "html_url": "https://github.com/rust-lang/rust/commit/53d19b37c514246acab020eaba9527cb97c421cf"}, {"sha": "66e30ec712eedc535fdb6a5394e0406ef4ddc737", "url": "https://api.github.com/repos/rust-lang/rust/commits/66e30ec712eedc535fdb6a5394e0406ef4ddc737", "html_url": "https://github.com/rust-lang/rust/commit/66e30ec712eedc535fdb6a5394e0406ef4ddc737"}], "stats": {"total": 418, "additions": 150, "deletions": 268}, "files": [{"sha": "8356e50f6374a69283c6e5cd3da24b09642aaf10", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 134, "deletions": 108, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/25a691003cf6676259ee7d4bed05b43cb6283cea/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a691003cf6676259ee7d4bed05b43cb6283cea/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=25a691003cf6676259ee7d4bed05b43cb6283cea", "patch": "@@ -14,7 +14,7 @@ use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n+use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::region_constraints::{Constraint, RegionConstraintData};\n use rustc_middle::bug;\n@@ -229,15 +229,11 @@ impl Clean<Item> for doctree::Module<'_> {\n         let attrs = self.attrs.clean(cx);\n \n         let mut items: Vec<Item> = vec![];\n-        items.extend(self.extern_crates.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.imports.iter().flat_map(|x| x.clean(cx)));\n-        items.extend(self.fns.iter().map(|x| x.clean(cx)));\n         items.extend(self.foreigns.iter().map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n         items.extend(self.items.iter().map(|x| x.clean(cx)).flatten());\n-        items.extend(self.traits.iter().map(|x| x.clean(cx)));\n         items.extend(self.macros.iter().map(|x| x.clean(cx)));\n-        items.extend(self.proc_macros.iter().map(|x| x.clean(cx)));\n \n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n@@ -871,6 +867,66 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n     }\n }\n \n+fn clean_fn_or_proc_macro(\n+    item: &hir::Item<'_>,\n+    sig: &'a hir::FnSig<'a>,\n+    generics: &'a hir::Generics<'a>,\n+    body_id: hir::BodyId,\n+    name: &mut Symbol,\n+    cx: &DocContext<'_>,\n+) -> ItemKind {\n+    let macro_kind = item.attrs.iter().find_map(|a| {\n+        if a.has_name(sym::proc_macro) {\n+            Some(MacroKind::Bang)\n+        } else if a.has_name(sym::proc_macro_derive) {\n+            Some(MacroKind::Derive)\n+        } else if a.has_name(sym::proc_macro_attribute) {\n+            Some(MacroKind::Attr)\n+        } else {\n+            None\n+        }\n+    });\n+    match macro_kind {\n+        Some(kind) => {\n+            if kind == MacroKind::Derive {\n+                *name = item\n+                    .attrs\n+                    .lists(sym::proc_macro_derive)\n+                    .find_map(|mi| mi.ident())\n+                    .expect(\"proc-macro derives require a name\")\n+                    .name;\n+            }\n+\n+            let mut helpers = Vec::new();\n+            for mi in item.attrs.lists(sym::proc_macro_derive) {\n+                if !mi.has_name(sym::attributes) {\n+                    continue;\n+                }\n+\n+                if let Some(list) = mi.meta_item_list() {\n+                    for inner_mi in list {\n+                        if let Some(ident) = inner_mi.ident() {\n+                            helpers.push(ident.name);\n+                        }\n+                    }\n+                }\n+            }\n+            ProcMacroItem(ProcMacro { kind, helpers: helpers.clean(cx) })\n+        }\n+        None => {\n+            let mut func = (sig, generics, body_id).clean(cx);\n+            let def_id = cx.tcx.hir().local_def_id(item.hir_id).to_def_id();\n+            func.header.constness =\n+                if is_const_fn(cx.tcx, def_id) && is_unstable_const_fn(cx.tcx, def_id).is_none() {\n+                    hir::Constness::Const\n+                } else {\n+                    hir::Constness::NotConst\n+                };\n+            FunctionItem(func)\n+        }\n+    }\n+}\n+\n impl<'a> Clean<Function> for (&'a hir::FnSig<'a>, &'a hir::Generics<'a>, hir::BodyId) {\n     fn clean(&self, cx: &DocContext<'_>) -> Function {\n         let (generics, decl) =\n@@ -880,34 +936,6 @@ impl<'a> Clean<Function> for (&'a hir::FnSig<'a>, &'a hir::Generics<'a>, hir::Bo\n     }\n }\n \n-impl Clean<Item> for doctree::Function<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let (generics, decl) =\n-            enter_impl_trait(cx, || (self.generics.clean(cx), (self.decl, self.body).clean(cx)));\n-\n-        let did = cx.tcx.hir().local_def_id(self.id).to_def_id();\n-        let constness = if is_const_fn(cx.tcx, did) && !is_unstable_const_fn(cx.tcx, did).is_some()\n-        {\n-            hir::Constness::Const\n-        } else {\n-            hir::Constness::NotConst\n-        };\n-        let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n-        Item::from_def_id_and_parts(\n-            did,\n-            Some(self.name),\n-            FunctionItem(Function {\n-                decl,\n-                generics,\n-                header: hir::FnHeader { constness, ..self.header },\n-                all_types,\n-                ret_types,\n-            }),\n-            cx,\n-        )\n-    }\n-}\n-\n impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], &'a [Ident]) {\n     fn clean(&self, cx: &DocContext<'_>) -> Arguments {\n         Arguments {\n@@ -992,26 +1020,6 @@ impl Clean<FnRetTy> for hir::FnRetTy<'_> {\n     }\n }\n \n-impl Clean<Item> for doctree::Trait<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let attrs = self.attrs.clean(cx);\n-        let is_spotlight = attrs.has_doc_flag(sym::spotlight);\n-        Item::from_hir_id_and_parts(\n-            self.id,\n-            Some(self.name),\n-            TraitItem(Trait {\n-                unsafety: self.unsafety,\n-                items: self.items.iter().map(|ti| ti.clean(cx)).collect(),\n-                generics: self.generics.clean(cx),\n-                bounds: self.bounds.clean(cx),\n-                is_spotlight,\n-                is_auto: self.is_auto.clean(cx),\n-            }),\n-            cx,\n-        )\n-    }\n-}\n-\n impl Clean<bool> for hir::IsAuto {\n     fn clean(&self, _: &DocContext<'_>) -> bool {\n         match *self {\n@@ -1927,7 +1935,7 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Ident>) {\n \n         let (item, renamed) = self;\n         let def_id = cx.tcx.hir().local_def_id(item.hir_id).to_def_id();\n-        let name = match renamed {\n+        let mut name = match renamed {\n             Some(ident) => ident.name,\n             None => cx.tcx.hir().name(item.hir_id),\n         };\n@@ -1977,6 +1985,27 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Ident>) {\n                 fields_stripped: false,\n             }),\n             ItemKind::Impl { .. } => return clean_impl(item, cx),\n+            // proc macros can have a name set by attributes\n+            ItemKind::Fn(ref sig, ref generics, body_id) => {\n+                clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n+            }\n+            hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref item_ids) => {\n+                let items =\n+                    item_ids.iter().map(|ti| cx.tcx.hir().trait_item(ti.id).clean(cx)).collect();\n+                let attrs = item.attrs.clean(cx);\n+                let is_spotlight = attrs.has_doc_flag(sym::spotlight);\n+                TraitItem(Trait {\n+                    unsafety,\n+                    items,\n+                    generics: generics.clean(cx),\n+                    bounds: bounds.clean(cx),\n+                    is_spotlight,\n+                    is_auto: is_auto.clean(cx),\n+                })\n+            }\n+            ItemKind::ExternCrate(orig_name) => {\n+                return clean_extern_crate(item, name, orig_name, cx);\n+            }\n             _ => unreachable!(\"not yet converted\"),\n         };\n \n@@ -2054,45 +2083,54 @@ fn clean_impl(impl_: &hir::Item<'_>, cx: &DocContext<'_>) -> Vec<Item> {\n     ret\n }\n \n-impl Clean<Vec<Item>> for doctree::ExternCrate<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n-        let please_inline = self.vis.node.is_pub()\n-            && self.attrs.iter().any(|a| {\n-                a.has_name(sym::doc)\n-                    && match a.meta_item_list() {\n-                        Some(l) => attr::list_contains_name(&l, sym::inline),\n-                        None => false,\n-                    }\n-            });\n+fn clean_extern_crate(\n+    krate: &hir::Item<'_>,\n+    name: Symbol,\n+    orig_name: Option<Symbol>,\n+    cx: &DocContext<'_>,\n+) -> Vec<Item> {\n+    // this is the ID of the `extern crate` statement\n+    let def_id = cx.tcx.hir().local_def_id(krate.hir_id);\n+    let cnum = cx.tcx.extern_mod_stmt_cnum(def_id).unwrap_or(LOCAL_CRATE);\n+    // this is the ID of the crate itself\n+    let crate_def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n+    let please_inline = krate.vis.node.is_pub()\n+        && krate.attrs.iter().any(|a| {\n+            a.has_name(sym::doc)\n+                && match a.meta_item_list() {\n+                    Some(l) => attr::list_contains_name(&l, sym::inline),\n+                    None => false,\n+                }\n+        });\n \n-        if please_inline {\n-            let mut visited = FxHashSet::default();\n+    if please_inline {\n+        let mut visited = FxHashSet::default();\n \n-            let res = Res::Def(DefKind::Mod, DefId { krate: self.cnum, index: CRATE_DEF_INDEX });\n+        let res = Res::Def(DefKind::Mod, crate_def_id);\n \n-            if let Some(items) = inline::try_inline(\n-                cx,\n-                cx.tcx.parent_module(self.hir_id).to_def_id(),\n-                res,\n-                self.name,\n-                Some(self.attrs),\n-                &mut visited,\n-            ) {\n-                return items;\n-            }\n+        if let Some(items) = inline::try_inline(\n+            cx,\n+            cx.tcx.parent_module(krate.hir_id).to_def_id(),\n+            res,\n+            name,\n+            Some(krate.attrs),\n+            &mut visited,\n+        ) {\n+            return items;\n         }\n-\n-        vec![Item {\n-            name: None,\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: DefId { krate: self.cnum, index: CRATE_DEF_INDEX },\n-            visibility: self.vis.clean(cx),\n-            stability: None,\n-            deprecation: None,\n-            kind: ExternCrateItem(self.name.clean(cx), self.path.clone()),\n-        }]\n     }\n+    let path = orig_name.map(|x| x.to_string());\n+    // FIXME: using `from_def_id_and_kind` breaks `rustdoc/masked` for some reason\n+    vec![Item {\n+        name: None,\n+        attrs: krate.attrs.clean(cx),\n+        source: krate.span.clean(cx),\n+        def_id: crate_def_id,\n+        visibility: krate.vis.clean(cx),\n+        stability: None,\n+        deprecation: None,\n+        kind: ExternCrateItem(name.clean(cx), path),\n+    }]\n }\n \n impl Clean<Vec<Item>> for doctree::Import<'_> {\n@@ -2186,11 +2224,12 @@ impl Clean<Vec<Item>> for doctree::Import<'_> {\n     }\n }\n \n-impl Clean<Item> for doctree::ForeignItem<'_> {\n+impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Ident>) {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let kind = match self.kind {\n+        let (item, renamed) = self;\n+        let kind = match item.kind {\n             hir::ForeignItemKind::Fn(ref decl, ref names, ref generics) => {\n-                let abi = cx.tcx.hir().get_foreign_abi(self.id);\n+                let abi = cx.tcx.hir().get_foreign_abi(item.hir_id);\n                 let (generics, decl) =\n                     enter_impl_trait(cx, || (generics.clean(cx), (&**decl, &names[..]).clean(cx)));\n                 let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n@@ -2207,15 +2246,13 @@ impl Clean<Item> for doctree::ForeignItem<'_> {\n                     ret_types,\n                 })\n             }\n-            hir::ForeignItemKind::Static(ref ty, mutbl) => ForeignStaticItem(Static {\n-                type_: ty.clean(cx),\n-                mutability: *mutbl,\n-                expr: String::new(),\n-            }),\n+            hir::ForeignItemKind::Static(ref ty, mutability) => {\n+                ForeignStaticItem(Static { type_: ty.clean(cx), mutability, expr: String::new() })\n+            }\n             hir::ForeignItemKind::Type => ForeignTypeItem,\n         };\n \n-        Item::from_hir_id_and_parts(self.id, Some(self.name), kind, cx)\n+        Item::from_hir_id_and_parts(item.hir_id, Some(renamed.unwrap_or(item.ident).name), kind, cx)\n     }\n }\n \n@@ -2240,17 +2277,6 @@ impl Clean<Item> for doctree::Macro {\n     }\n }\n \n-impl Clean<Item> for doctree::ProcMacro {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item::from_hir_id_and_parts(\n-            self.id,\n-            Some(self.name),\n-            ProcMacroItem(ProcMacro { kind: self.kind, helpers: self.helpers.clean(cx) }),\n-            cx,\n-        )\n-    }\n-}\n-\n impl Clean<Deprecation> for attr::Deprecation {\n     fn clean(&self, _: &DocContext<'_>) -> Deprecation {\n         Deprecation {"}, {"sha": "20f747e2014158b3712c0501e078055c9db93d0e", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 1, "deletions": 55, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/25a691003cf6676259ee7d4bed05b43cb6283cea/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a691003cf6676259ee7d4bed05b43cb6283cea/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=25a691003cf6676259ee7d4bed05b43cb6283cea", "patch": "@@ -3,29 +3,22 @@\n crate use self::StructType::*;\n \n use rustc_ast as ast;\n-use rustc_span::hygiene::MacroKind;\n use rustc_span::{self, symbol::Ident, Span, Symbol};\n \n use rustc_hir as hir;\n-use rustc_hir::def_id::CrateNum;\n-use rustc_hir::HirId;\n \n crate struct Module<'hir> {\n     crate name: Option<Symbol>,\n     crate attrs: &'hir [ast::Attribute],\n     crate where_outer: Span,\n     crate where_inner: Span,\n-    crate extern_crates: Vec<ExternCrate<'hir>>,\n     crate imports: Vec<Import<'hir>>,\n-    crate fns: Vec<Function<'hir>>,\n     crate mods: Vec<Module<'hir>>,\n     crate id: hir::HirId,\n     // (item, renamed)\n     crate items: Vec<(&'hir hir::Item<'hir>, Option<Ident>)>,\n-    crate traits: Vec<Trait<'hir>>,\n-    crate foreigns: Vec<ForeignItem<'hir>>,\n+    crate foreigns: Vec<(&'hir hir::ForeignItem<'hir>, Option<Ident>)>,\n     crate macros: Vec<Macro>,\n-    crate proc_macros: Vec<ProcMacro>,\n     crate is_crate: bool,\n }\n \n@@ -37,15 +30,11 @@ impl Module<'hir> {\n             where_outer: rustc_span::DUMMY_SP,\n             where_inner: rustc_span::DUMMY_SP,\n             attrs,\n-            extern_crates: Vec::new(),\n             imports: Vec::new(),\n-            fns: Vec::new(),\n             mods: Vec::new(),\n             items: Vec::new(),\n-            traits: Vec::new(),\n             foreigns: Vec::new(),\n             macros: Vec::new(),\n-            proc_macros: Vec::new(),\n             is_crate: false,\n         }\n     }\n@@ -67,32 +56,6 @@ crate struct Variant<'hir> {\n     crate def: &'hir hir::VariantData<'hir>,\n }\n \n-crate struct Function<'hir> {\n-    crate decl: &'hir hir::FnDecl<'hir>,\n-    crate id: hir::HirId,\n-    crate name: Symbol,\n-    crate header: hir::FnHeader,\n-    crate generics: &'hir hir::Generics<'hir>,\n-    crate body: hir::BodyId,\n-}\n-\n-crate struct Trait<'hir> {\n-    crate is_auto: hir::IsAuto,\n-    crate unsafety: hir::Unsafety,\n-    crate name: Symbol,\n-    crate items: Vec<&'hir hir::TraitItem<'hir>>,\n-    crate generics: &'hir hir::Generics<'hir>,\n-    crate bounds: &'hir [hir::GenericBound<'hir>],\n-    crate attrs: &'hir [ast::Attribute],\n-    crate id: hir::HirId,\n-}\n-\n-crate struct ForeignItem<'hir> {\n-    crate id: hir::HirId,\n-    crate name: Symbol,\n-    crate kind: &'hir hir::ForeignItemKind<'hir>,\n-}\n-\n // For Macro we store the DefId instead of the NodeId, since we also create\n // these imported macro_rules (which only have a DUMMY_NODE_ID).\n crate struct Macro {\n@@ -102,16 +65,6 @@ crate struct Macro {\n     crate imported_from: Option<Symbol>,\n }\n \n-crate struct ExternCrate<'hir> {\n-    crate name: Symbol,\n-    crate hir_id: HirId,\n-    crate cnum: CrateNum,\n-    crate path: Option<String>,\n-    crate vis: &'hir hir::Visibility<'hir>,\n-    crate attrs: &'hir [ast::Attribute],\n-    crate span: Span,\n-}\n-\n #[derive(Debug)]\n crate struct Import<'hir> {\n     crate name: Symbol,\n@@ -123,13 +76,6 @@ crate struct Import<'hir> {\n     crate span: Span,\n }\n \n-crate struct ProcMacro {\n-    crate name: Symbol,\n-    crate id: hir::HirId,\n-    crate kind: MacroKind,\n-    crate helpers: Vec<Symbol>,\n-}\n-\n crate fn struct_type_from_def(vdata: &hir::VariantData<'_>) -> StructType {\n     match *vdata {\n         hir::VariantData::Struct(..) => Plain,"}, {"sha": "e57717dab76cf65267192079611627e7bb260761", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 7, "deletions": 97, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/25a691003cf6676259ee7d4bed05b43cb6283cea/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a691003cf6676259ee7d4bed05b43cb6283cea/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=25a691003cf6676259ee7d4bed05b43cb6283cea", "patch": "@@ -5,11 +5,10 @@ use rustc_ast as ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::DefId;\n use rustc_hir::Node;\n use rustc_middle::middle::privacy::AccessLevel;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{self, Span};\n@@ -82,63 +81,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         module\n     }\n \n-    fn visit_fn(\n-        &mut self,\n-        om: &mut Module<'tcx>,\n-        item: &'tcx hir::Item<'_>,\n-        name: Symbol,\n-        decl: &'tcx hir::FnDecl<'_>,\n-        header: hir::FnHeader,\n-        generics: &'tcx hir::Generics<'_>,\n-        body: hir::BodyId,\n-    ) {\n-        debug!(\"visiting fn\");\n-        let macro_kind = item.attrs.iter().find_map(|a| {\n-            if a.has_name(sym::proc_macro) {\n-                Some(MacroKind::Bang)\n-            } else if a.has_name(sym::proc_macro_derive) {\n-                Some(MacroKind::Derive)\n-            } else if a.has_name(sym::proc_macro_attribute) {\n-                Some(MacroKind::Attr)\n-            } else {\n-                None\n-            }\n-        });\n-        match macro_kind {\n-            Some(kind) => {\n-                let name = if kind == MacroKind::Derive {\n-                    item.attrs\n-                        .lists(sym::proc_macro_derive)\n-                        .find_map(|mi| mi.ident())\n-                        .expect(\"proc-macro derives require a name\")\n-                        .name\n-                } else {\n-                    name\n-                };\n-\n-                let mut helpers = Vec::new();\n-                for mi in item.attrs.lists(sym::proc_macro_derive) {\n-                    if !mi.has_name(sym::attributes) {\n-                        continue;\n-                    }\n-\n-                    if let Some(list) = mi.meta_item_list() {\n-                        for inner_mi in list {\n-                            if let Some(ident) = inner_mi.ident() {\n-                                helpers.push(ident.name);\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                om.proc_macros.push(ProcMacro { name, id: item.hir_id, kind, helpers });\n-            }\n-            None => {\n-                om.fns.push(Function { id: item.hir_id, decl, name, generics, header, body });\n-            }\n-        }\n-    }\n-\n     fn visit_mod_contents(\n         &mut self,\n         span: Span,\n@@ -306,18 +248,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             // If we're inlining, skip private items.\n             _ if self.inlining && !item.vis.node.is_pub() => {}\n             hir::ItemKind::GlobalAsm(..) => {}\n-            hir::ItemKind::ExternCrate(orig_name) => {\n-                let def_id = self.cx.tcx.hir().local_def_id(item.hir_id);\n-                om.extern_crates.push(ExternCrate {\n-                    cnum: self.cx.tcx.extern_mod_stmt_cnum(def_id).unwrap_or(LOCAL_CRATE),\n-                    name: ident.name,\n-                    hir_id: item.hir_id,\n-                    path: orig_name.map(|x| x.to_string()),\n-                    vis: &item.vis,\n-                    attrs: &item.attrs,\n-                    span: item.span,\n-                })\n-            }\n             hir::ItemKind::Use(_, hir::UseKind::ListStem) => {}\n             hir::ItemKind::Use(ref path, kind) => {\n                 let is_glob = kind == hir::UseKind::Glob;\n@@ -370,15 +300,15 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     Some(ident.name),\n                 ));\n             }\n-            hir::ItemKind::Fn(ref sig, ref gen, body) => {\n-                self.visit_fn(om, item, ident.name, &sig.decl, sig.header, gen, body)\n-            }\n-            hir::ItemKind::Enum(..)\n+            hir::ItemKind::Fn(..)\n+            | hir::ItemKind::ExternCrate(..)\n+            | hir::ItemKind::Enum(..)\n             | hir::ItemKind::Struct(..)\n             | hir::ItemKind::Union(..)\n             | hir::ItemKind::TyAlias(..)\n             | hir::ItemKind::OpaqueTy(..)\n             | hir::ItemKind::Static(..)\n+            | hir::ItemKind::Trait(..)\n             | hir::ItemKind::TraitAlias(..) => om.items.push((item, renamed)),\n             hir::ItemKind::Const(..) => {\n                 // Underscore constants do not correspond to a nameable item and\n@@ -387,20 +317,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     om.items.push((item, renamed));\n                 }\n             }\n-            hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref item_ids) => {\n-                let items = item_ids.iter().map(|ti| self.cx.tcx.hir().trait_item(ti.id)).collect();\n-                let t = Trait {\n-                    is_auto,\n-                    unsafety,\n-                    name: ident.name,\n-                    items,\n-                    generics,\n-                    bounds,\n-                    id: item.hir_id,\n-                    attrs: &item.attrs,\n-                };\n-                om.traits.push(t);\n-            }\n             hir::ItemKind::Impl { ref of_trait, .. } => {\n                 // Don't duplicate impls when inlining or if it's implementing a trait, we'll pick\n                 // them up regardless of where they're located.\n@@ -418,15 +334,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om: &mut Module<'tcx>,\n     ) {\n         // If inlining we only want to include public functions.\n-        if self.inlining && !item.vis.node.is_pub() {\n-            return;\n+        if !self.inlining || item.vis.node.is_pub() {\n+            om.foreigns.push((item, renamed));\n         }\n-\n-        om.foreigns.push(ForeignItem {\n-            id: item.hir_id,\n-            name: renamed.unwrap_or(item.ident).name,\n-            kind: &item.kind,\n-        });\n     }\n \n     // Convert each `exported_macro` into a doc item."}, {"sha": "0b074e9d53e3d640313aa06e10fc00becfc39df6", "filename": "src/test/rustdoc-ui/intra-links-warning.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/25a691003cf6676259ee7d4bed05b43cb6283cea/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25a691003cf6676259ee7d4bed05b43cb6283cea/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr?ref=25a691003cf6676259ee7d4bed05b43cb6283cea", "patch": "@@ -36,6 +36,14 @@ warning: unresolved link to `Qux::Z`\n LL |       //! , [Uniooon::X] and [Qux::Z].\n    |                               ^^^^^^ no item named `Qux` in scope\n \n+warning: unresolved link to `Qux:Y`\n+  --> $DIR/intra-links-warning.rs:14:13\n+   |\n+LL |        /// [Qux:Y]\n+   |             ^^^^^ no item named `Qux:Y` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n warning: unresolved link to `BarA`\n   --> $DIR/intra-links-warning.rs:21:10\n    |\n@@ -90,14 +98,6 @@ LL | f!(\"Foo\\nbar [BarF] bar\\nbaz\");\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n    = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-warning: unresolved link to `Qux:Y`\n-  --> $DIR/intra-links-warning.rs:14:13\n-   |\n-LL |        /// [Qux:Y]\n-   |             ^^^^^ no item named `Qux:Y` in scope\n-   |\n-   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n-\n warning: unresolved link to `error`\n   --> $DIR/intra-links-warning.rs:58:30\n    |"}]}