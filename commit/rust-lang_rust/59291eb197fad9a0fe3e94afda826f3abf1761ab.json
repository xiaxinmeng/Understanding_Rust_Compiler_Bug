{"sha": "59291eb197fad9a0fe3e94afda826f3abf1761ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5MjkxZWIxOTdmYWQ5YTBmZTNlOTRhZmRhODI2ZjNhYmYxNzYxYWI=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@composition.al", "date": "2013-09-01T05:33:41Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@composition.al", "date": "2013-09-05T10:25:23Z"}, "message": "Minor doc cleanup.", "tree": {"sha": "32c93eb2bdc0692a33b2c98718b4dd269475e709", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32c93eb2bdc0692a33b2c98718b4dd269475e709"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59291eb197fad9a0fe3e94afda826f3abf1761ab", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59291eb197fad9a0fe3e94afda826f3abf1761ab", "html_url": "https://github.com/rust-lang/rust/commit/59291eb197fad9a0fe3e94afda826f3abf1761ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59291eb197fad9a0fe3e94afda826f3abf1761ab/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8651011b6fffb7f95a354ce85eeb1d2aa4b476a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8651011b6fffb7f95a354ce85eeb1d2aa4b476a5", "html_url": "https://github.com/rust-lang/rust/commit/8651011b6fffb7f95a354ce85eeb1d2aa4b476a5"}], "stats": {"total": 23, "additions": 12, "deletions": 11}, "files": [{"sha": "58668775136a303086dbfe460490a8b84ae3d2ea", "filename": "src/libstd/path.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/59291eb197fad9a0fe3e94afda826f3abf1761ab/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59291eb197fad9a0fe3e94afda826f3abf1761ab/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=59291eb197fad9a0fe3e94afda826f3abf1761ab", "patch": "@@ -58,10 +58,10 @@ pub fn PosixPath(s: &str) -> PosixPath {\n }\n \n pub trait GenericPath : Clone + Eq + ToStr {\n-    /// Converts a string to a Path\n+    /// Converts a string to a path.\n     fn from_str(&str) -> Self;\n \n-    /// Returns the directory component of `self`, as a string\n+    /// Returns the directory component of `self`, as a string.\n     fn dirname(&self) -> ~str {\n         let s = self.dir_path().to_str();\n         match s.len() {\n@@ -152,17 +152,17 @@ pub trait GenericPath : Clone + Eq + ToStr {\n     /// If `self` names a directory, returns the empty path.\n     fn file_path(&self) -> Self;\n \n-    /// Returns a new Path whose parent directory is `self` and whose\n+    /// Returns a new path whose parent directory is `self` and whose\n     /// file component is the given string.\n     fn push(&self, (&str)) -> Self;\n \n-    /// Returns a new Path consisting of the given path, made relative to `self`.\n+    /// Returns a new path consisting of the given path, made relative to `self`.\n     fn push_rel(&self, other: &Self) -> Self {\n         assert!(!other.is_absolute());\n         self.push_many(other.components())\n     }\n \n-    /// Returns a new Path consisting of the path given by the given vector\n+    /// Returns a new path consisting of the path given by the given vector\n     /// of strings, relative to `self`.\n     fn push_many<S: Str>(&self, (&[S])) -> Self;\n \n@@ -174,9 +174,9 @@ pub trait GenericPath : Clone + Eq + ToStr {\n     /// contain directory separators in any of its components.\n     fn unsafe_join(&self, (&Self)) -> Self;\n \n-    /// On Unix, always returns false. On Windows, returns true iff `self`'s\n+    /// On Unix, always returns `false`. On Windows, returns `true` iff `self`'s\n     /// file stem is one of: `con` `aux` `com1` `com2` `com3` `com4`\n-    /// `lpt1` `lpt2` `lpt3` `prn` `nul`\n+    /// `lpt1` `lpt2` `lpt3` `prn` `nul`.\n     fn is_restricted(&self) -> bool;\n \n     /// Returns a new path that names the same file as `self`, without containing\n@@ -187,7 +187,8 @@ pub trait GenericPath : Clone + Eq + ToStr {\n     /// Returns `true` if `self` is an absolute path.\n     fn is_absolute(&self) -> bool;\n \n-    /// True if `self` is an ancestor of `other`. See `test_is_ancestor_of` for examples\n+    /// True if `self` is an ancestor of `other`.\n+    // See `test_is_ancestor_of` for examples.\n     fn is_ancestor_of(&self, other: &Self) -> bool {\n         debug!(\"%s / %s %? %?\", self.to_str(), other.to_str(), self.is_absolute(),\n                self.components().len());\n@@ -197,7 +198,7 @@ pub trait GenericPath : Clone + Eq + ToStr {\n              self.is_ancestor_of(&other.pop()))\n     }\n \n-    /// Find the relative path from one file to another\n+    /// Finds the relative path from one file to another.\n     fn get_relative_to(&self, abs2: (&Self)) -> Self {\n         assert!(self.is_absolute());\n         assert!(abs2.is_absolute());\n@@ -516,7 +517,7 @@ impl PosixPath {\n         }\n     }\n \n-    /// Execute a function on p as well as all of its ancestors\n+    /// Executes a function `f` on `self` as well as on all of its ancestors.\n     pub fn each_parent(&self, f: &fn(&Path)) {\n         if !self.components.is_empty() {\n             f(self);\n@@ -618,7 +619,7 @@ impl WindowsPath {\n         }\n     }\n \n-    /// Execute a function on p as well as all of its ancestors\n+    /// Executes a function `f` on `self` as well as on all of its ancestors.\n     pub fn each_parent(&self, f: &fn(&Path)) {\n         if !self.components.is_empty() {\n             f(self);"}]}