{"sha": "d43bf539482b8244690824e0880a80ed578d5429", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0M2JmNTM5NDgyYjgyNDQ2OTA4MjRlMDg4MGE4MGVkNTc4ZDU0Mjk=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "root@localhost", "date": "2015-06-09T09:23:22Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "root@localhost", "date": "2015-06-10T07:15:07Z"}, "message": "Add str::split_at\n\nImplement RFC rust-lang/rfcs#1123\n\nAdd str method str::split_at(mid: usize) -> (&str, &str).", "tree": {"sha": "0d1e48d33e06ba667ceeb1b198aa774938d5765a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d1e48d33e06ba667ceeb1b198aa774938d5765a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d43bf539482b8244690824e0880a80ed578d5429", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d43bf539482b8244690824e0880a80ed578d5429", "html_url": "https://github.com/rust-lang/rust/commit/d43bf539482b8244690824e0880a80ed578d5429", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d43bf539482b8244690824e0880a80ed578d5429/comments", "author": {"login": "invalid-email-address", "id": 148100, "node_id": "MDQ6VXNlcjE0ODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/148100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/invalid-email-address", "html_url": "https://github.com/invalid-email-address", "followers_url": "https://api.github.com/users/invalid-email-address/followers", "following_url": "https://api.github.com/users/invalid-email-address/following{/other_user}", "gists_url": "https://api.github.com/users/invalid-email-address/gists{/gist_id}", "starred_url": "https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/invalid-email-address/subscriptions", "organizations_url": "https://api.github.com/users/invalid-email-address/orgs", "repos_url": "https://api.github.com/users/invalid-email-address/repos", "events_url": "https://api.github.com/users/invalid-email-address/events{/privacy}", "received_events_url": "https://api.github.com/users/invalid-email-address/received_events", "type": "User", "site_admin": false}, "committer": {"login": "invalid-email-address", "id": 148100, "node_id": "MDQ6VXNlcjE0ODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/148100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/invalid-email-address", "html_url": "https://github.com/invalid-email-address", "followers_url": "https://api.github.com/users/invalid-email-address/followers", "following_url": "https://api.github.com/users/invalid-email-address/following{/other_user}", "gists_url": "https://api.github.com/users/invalid-email-address/gists{/gist_id}", "starred_url": "https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/invalid-email-address/subscriptions", "organizations_url": "https://api.github.com/users/invalid-email-address/orgs", "repos_url": "https://api.github.com/users/invalid-email-address/repos", "events_url": "https://api.github.com/users/invalid-email-address/events{/privacy}", "received_events_url": "https://api.github.com/users/invalid-email-address/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6daf1dcb80e324df94ad4a1d263c832ab589b33a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6daf1dcb80e324df94ad4a1d263c832ab589b33a", "html_url": "https://github.com/rust-lang/rust/commit/6daf1dcb80e324df94ad4a1d263c832ab589b33a"}], "stats": {"total": 60, "additions": 60, "deletions": 0}, "files": [{"sha": "062f7992724c2002b9e68abe68578a78435360f4", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d43bf539482b8244690824e0880a80ed578d5429/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d43bf539482b8244690824e0880a80ed578d5429/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=d43bf539482b8244690824e0880a80ed578d5429", "patch": "@@ -779,6 +779,33 @@ impl str {\n         core_str::StrExt::slice_shift_char(&self[..])\n     }\n \n+    /// Divide one string slice into two at an index.\n+    ///\n+    /// The index `mid` is a byte offset from the start of the string\n+    /// that must be on a character boundary.\n+    ///\n+    /// Return slices `&self[..mid]` and `&self[mid..]`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid` is beyond the last character of the string,\n+    /// or if it is not on a character boundary.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(collections)]\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let first_space = s.find(' ').unwrap_or(s.len());\n+    /// let (a, b) = s.split_at(first_space);\n+    ///\n+    /// assert_eq!(a, \"L\u00f6we\");\n+    /// assert_eq!(b, \" \u8001\u864e L\u00e9opard\");\n+    /// ```\n+    #[inline]\n+    pub fn split_at(&self, mid: usize) -> (&str, &str) {\n+        core_str::StrExt::split_at(self, mid)\n+    }\n+\n     /// An iterator over the codepoints of `self`.\n     ///\n     /// # Examples"}, {"sha": "def7968280117da50af9a616c7b10ba89a7426ac", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d43bf539482b8244690824e0880a80ed578d5429/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d43bf539482b8244690824e0880a80ed578d5429/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=d43bf539482b8244690824e0880a80ed578d5429", "patch": "@@ -688,6 +688,26 @@ fn test_char_at_reverse() {\n     }\n }\n \n+#[test]\n+fn test_split_at() {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    for (index, _) in s.char_indices() {\n+        let (a, b) = s.split_at(index);\n+        assert_eq!(&s[..a.len()], a);\n+        assert_eq!(&s[a.len()..], b);\n+    }\n+    let (a, b) = s.split_at(s.len());\n+    assert_eq!(a, s);\n+    assert_eq!(b, \"\");\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_split_at_boundscheck() {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    let (a, b) = s.split_at(1);\n+}\n+\n #[test]\n fn test_escape_unicode() {\n     assert_eq!(\"abc\".escape_unicode(),"}, {"sha": "4db64a3097ea7dd4dd06f69382f7631e6df1216e", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d43bf539482b8244690824e0880a80ed578d5429/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d43bf539482b8244690824e0880a80ed578d5429/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=d43bf539482b8244690824e0880a80ed578d5429", "patch": "@@ -1517,6 +1517,7 @@ pub trait StrExt {\n     fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n         where P::Searcher: ReverseSearcher<'a>;\n     fn find_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>;\n+    fn split_at(&self, mid: usize) -> (&str, &str);\n     fn slice_shift_char<'a>(&'a self) -> Option<(char, &'a str)>;\n     fn subslice_offset(&self, inner: &str) -> usize;\n     fn as_ptr(&self) -> *const u8;\n@@ -1809,6 +1810,18 @@ impl StrExt for str {\n         self.find(pat)\n     }\n \n+    fn split_at(&self, mid: usize) -> (&str, &str) {\n+        // is_char_boundary checks that the index is in [0, .len()]\n+        if self.is_char_boundary(mid) {\n+            unsafe {\n+                (self.slice_unchecked(0, mid),\n+                 self.slice_unchecked(mid, self.len()))\n+            }\n+        } else {\n+            slice_error_fail(self, 0, mid)\n+        }\n+    }\n+\n     #[inline]\n     fn slice_shift_char(&self) -> Option<(char, &str)> {\n         if self.is_empty() {"}]}