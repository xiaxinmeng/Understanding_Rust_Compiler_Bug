{"sha": "1796de7bb123df3f3d32124ededf1344434f672e", "node_id": "C_kwDOAAsO6NoAKDE3OTZkZTdiYjEyM2RmM2YzZDMyMTI0ZWRlZGYxMzQ0NDM0ZjY3MmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-13T17:05:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-13T17:05:40Z"}, "message": "Auto merge of #91353 - eggyal:reuse-rcs-during-folding, r=lcnr\n\nAvoid cloning refcounted types during folding\n\nAddresses FIXME comment created in #78313\n\nr? `@lcnr`", "tree": {"sha": "3626eea1376692918a6f02b1c7862c24a6930e89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3626eea1376692918a6f02b1c7862c24a6930e89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1796de7bb123df3f3d32124ededf1344434f672e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1796de7bb123df3f3d32124ededf1344434f672e", "html_url": "https://github.com/rust-lang/rust/commit/1796de7bb123df3f3d32124ededf1344434f672e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1796de7bb123df3f3d32124ededf1344434f672e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06a6674a7de1ef7af00b0fcdfa0d77e6c3023a27", "url": "https://api.github.com/repos/rust-lang/rust/commits/06a6674a7de1ef7af00b0fcdfa0d77e6c3023a27", "html_url": "https://github.com/rust-lang/rust/commit/06a6674a7de1ef7af00b0fcdfa0d77e6c3023a27"}, {"sha": "5920a1d9482a289f7d2057237faf831c1fef0369", "url": "https://api.github.com/repos/rust-lang/rust/commits/5920a1d9482a289f7d2057237faf831c1fef0369", "html_url": "https://github.com/rust-lang/rust/commit/5920a1d9482a289f7d2057237faf831c1fef0369"}], "stats": {"total": 74, "additions": 68, "deletions": 6}, "files": [{"sha": "9d8588c9a8ea7419940178fee75b7014f50ae185", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1796de7bb123df3f3d32124ededf1344434f672e/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1796de7bb123df3f3d32124ededf1344434f672e/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=1796de7bb123df3f3d32124ededf1344434f672e", "patch": "@@ -33,6 +33,7 @@\n #![feature(derive_default_enum)]\n #![feature(discriminant_kind)]\n #![feature(exhaustive_patterns)]\n+#![feature(get_mut_unchecked)]\n #![feature(if_let_guard)]\n #![feature(map_first_last)]\n #![feature(never_type)]"}, {"sha": "28dc9767b782ee948a99cc4a0189d57583f33932", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 67, "deletions": 6, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1796de7bb123df3f3d32124ededf1344434f672e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1796de7bb123df3f3d32124ededf1344434f672e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=1796de7bb123df3f3d32124ededf1344434f672e", "patch": "@@ -13,6 +13,7 @@ use rustc_hir::def_id::CRATE_DEF_INDEX;\n use rustc_index::vec::{Idx, IndexVec};\n \n use std::fmt;\n+use std::mem::ManuallyDrop;\n use std::ops::ControlFlow;\n use std::rc::Rc;\n use std::sync::Arc;\n@@ -732,11 +733,41 @@ EnumTypeFoldableImpl! {\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n     fn try_super_fold_with<F: FallibleTypeFolder<'tcx>>(\n-        self,\n+        mut self,\n         folder: &mut F,\n     ) -> Result<Self, F::Error> {\n-        // FIXME: Reuse the `Rc` here.\n-        (*self).clone().try_fold_with(folder).map(Rc::new)\n+        // We merely want to replace the contained `T`, if at all possible,\n+        // so that we don't needlessly allocate a new `Rc` or indeed clone\n+        // the contained type.\n+        unsafe {\n+            // First step is to ensure that we have a unique reference to\n+            // the contained type, which `Rc::make_mut` will accomplish (by\n+            // allocating a new `Rc` and cloning the `T` only if required).\n+            // This is done *before* casting to `Rc<ManuallyDrop<T>>` so that\n+            // panicking during `make_mut` does not leak the `T`.\n+            Rc::make_mut(&mut self);\n+\n+            // Casting to `Rc<ManuallyDrop<T>>` is safe because `ManuallyDrop`\n+            // is `repr(transparent)`.\n+            let ptr = Rc::into_raw(self).cast::<ManuallyDrop<T>>();\n+            let mut unique = Rc::from_raw(ptr);\n+\n+            // Call to `Rc::make_mut` above guarantees that `unique` is the\n+            // sole reference to the contained value, so we can avoid doing\n+            // a checked `get_mut` here.\n+            let slot = Rc::get_mut_unchecked(&mut unique);\n+\n+            // Semantically move the contained type out from `unique`, fold\n+            // it, then move the folded value back into `unique`.  Should\n+            // folding fail, `ManuallyDrop` ensures that the \"moved-out\"\n+            // value is not re-dropped.\n+            let owned = ManuallyDrop::take(slot);\n+            let folded = owned.try_fold_with(folder)?;\n+            *slot = ManuallyDrop::new(folded);\n+\n+            // Cast back to `Rc<T>`.\n+            Ok(Rc::from_raw(Rc::into_raw(unique).cast()))\n+        }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -746,11 +777,41 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Arc<T> {\n     fn try_super_fold_with<F: FallibleTypeFolder<'tcx>>(\n-        self,\n+        mut self,\n         folder: &mut F,\n     ) -> Result<Self, F::Error> {\n-        // FIXME: Reuse the `Arc` here.\n-        (*self).clone().try_fold_with(folder).map(Arc::new)\n+        // We merely want to replace the contained `T`, if at all possible,\n+        // so that we don't needlessly allocate a new `Arc` or indeed clone\n+        // the contained type.\n+        unsafe {\n+            // First step is to ensure that we have a unique reference to\n+            // the contained type, which `Arc::make_mut` will accomplish (by\n+            // allocating a new `Arc` and cloning the `T` only if required).\n+            // This is done *before* casting to `Arc<ManuallyDrop<T>>` so that\n+            // panicking during `make_mut` does not leak the `T`.\n+            Arc::make_mut(&mut self);\n+\n+            // Casting to `Arc<ManuallyDrop<T>>` is safe because `ManuallyDrop`\n+            // is `repr(transparent)`.\n+            let ptr = Arc::into_raw(self).cast::<ManuallyDrop<T>>();\n+            let mut unique = Arc::from_raw(ptr);\n+\n+            // Call to `Arc::make_mut` above guarantees that `unique` is the\n+            // sole reference to the contained value, so we can avoid doing\n+            // a checked `get_mut` here.\n+            let slot = Arc::get_mut_unchecked(&mut unique);\n+\n+            // Semantically move the contained type out from `unique`, fold\n+            // it, then move the folded value back into `unique`.  Should\n+            // folding fail, `ManuallyDrop` ensures that the \"moved-out\"\n+            // value is not re-dropped.\n+            let owned = ManuallyDrop::take(slot);\n+            let folded = owned.try_fold_with(folder)?;\n+            *slot = ManuallyDrop::new(folded);\n+\n+            // Cast back to `Arc<T>`.\n+            Ok(Arc::from_raw(Arc::into_raw(unique).cast()))\n+        }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {"}]}