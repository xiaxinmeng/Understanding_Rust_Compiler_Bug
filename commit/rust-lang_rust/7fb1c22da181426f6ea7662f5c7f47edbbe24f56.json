{"sha": "7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmYjFjMjJkYTE4MTQyNmY2ZWE3NjYyZjVjN2Y0N2VkYmJlMjRmNTY=", "commit": {"author": {"name": "Saleem Jaffer", "email": "saleem@acko.com", "date": "2019-03-16T12:10:41Z"}, "committer": {"name": "Saleem Jaffer", "email": "saleem@acko.com", "date": "2019-03-18T09:33:29Z"}, "message": "promoted is still left in 2 places", "tree": {"sha": "fe473b57dc513f00eb6a140124cdcf1ce150398e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe473b57dc513f00eb6a140124cdcf1ce150398e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "html_url": "https://github.com/rust-lang/rust/commit/7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/comments", "author": null, "committer": null, "parents": [{"sha": "03dafa7da38decbe74fcd8a23d7ec835e637c8e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/03dafa7da38decbe74fcd8a23d7ec835e637c8e4", "html_url": "https://github.com/rust-lang/rust/commit/03dafa7da38decbe74fcd8a23d7ec835e637c8e4"}], "stats": {"total": 619, "additions": 336, "deletions": 283}, "files": [{"sha": "47b9535abc521dd133d315138a5935ec08d9fcfd", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -1913,9 +1913,6 @@ pub enum PlaceBase<'tcx> {\n \n     /// static or static mut variable\n     Static(Box<Static<'tcx>>),\n-\n-    /// Constant code promoted to an injected static\n-    Promoted(Box<(Promoted, Ty<'tcx>)>),\n }\n \n /// The `DefId` of a static, along with its normalized type (which is\n@@ -1924,11 +1921,13 @@ pub enum PlaceBase<'tcx> {\n pub struct Static<'tcx> {\n     pub def_id: DefId,\n     pub ty: Ty<'tcx>,\n+    pub promoted: Option<Promoted>,\n }\n \n impl_stable_hash_for!(struct Static<'tcx> {\n     def_id,\n-    ty\n+    ty,\n+    promoted\n });\n \n /// The `Projection` data structure defines things of the form `B.x`\n@@ -2048,7 +2047,7 @@ impl<'tcx> Place<'tcx> {\n         match self {\n             Place::Base(PlaceBase::Local(local)) => Some(*local),\n             Place::Projection(box Projection { base, elem: _ }) => base.base_local(),\n-            Place::Base(PlaceBase::Promoted(..)) | Place::Base(PlaceBase::Static(..)) => None,\n+            Place::Base(PlaceBase::Static(..)) => None,\n         }\n     }\n }\n@@ -2059,18 +2058,22 @@ impl<'tcx> Debug for Place<'tcx> {\n \n         match *self {\n             Base(PlaceBase::Local(id)) => write!(fmt, \"{:?}\", id),\n-            Base(PlaceBase::Static(box self::Static { def_id, ty })) => write!(\n-                fmt,\n-                \"({}: {:?})\",\n-                ty::tls::with(|tcx| tcx.def_path_str(def_id)),\n-                ty\n-            ),\n-            Base(PlaceBase::Promoted(ref promoted)) => write!(\n-                fmt,\n-                \"({:?}: {:?})\",\n-                promoted.0,\n-                promoted.1\n-            ),\n+            Base(PlaceBase::Static(box self::Static { def_id, ty, promoted })) => {\n+                match promoted {\n+                    None => write!(\n+                        fmt,\n+                        \"({}: {:?})\",\n+                        ty::tls::with(|tcx| tcx.def_path_str(def_id)),\n+                        ty\n+                    ),\n+                    Some(pr) => write!(\n+                        fmt,\n+                        \"({:?}: {:?})\",\n+                        pr,\n+                        ty\n+                    ),\n+                }\n+            },\n             Projection(ref data) => match data.elem {\n                 ProjectionElem::Downcast(ref adt_def, index) => {\n                     write!(fmt, \"({:?} as {})\", data.base, adt_def.variants[index].ident)"}, {"sha": "ac42eacacd7bfff0adbdd96c5f1f4f5446727de8", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -160,7 +160,6 @@ impl<'tcx> Place<'tcx> {\n         match *self {\n             Place::Base(PlaceBase::Local(index)) =>\n                 PlaceTy::Ty { ty: local_decls.local_decls()[index].ty },\n-            Place::Base(PlaceBase::Promoted(ref data)) => PlaceTy::Ty { ty: data.1 },\n             Place::Base(PlaceBase::Static(ref data)) =>\n                 PlaceTy::Ty { ty: data.ty },\n             Place::Projection(ref proj) =>"}, {"sha": "cddf578212159c490c59b9f75aaab5829096400c", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -737,11 +737,18 @@ macro_rules! make_mir_visitor {\n                         self.visit_local(local, context, location);\n                     }\n                     Place::Base(PlaceBase::Static(static_)) => {\n+                        match static_.promoted {\n+                            None => {\n+                                self.visit_static(static_, context, location);\n+                            }\n+                            Some(_) => {\n+                                self.visit_ty(\n+                                    & $($mutability)? static_.ty, TyContext::Location(location)\n+                                );\n+                            }\n+                        }\n                         self.visit_static(static_, context, location);\n                     }\n-                    Place::Base(PlaceBase::Promoted(promoted)) => {\n-                        self.visit_ty(& $($mutability)? promoted.1, TyContext::Location(location));\n-                    },\n                     Place::Projection(proj) => {\n                         self.visit_projection(proj, context, location);\n                     }\n@@ -752,7 +759,7 @@ macro_rules! make_mir_visitor {\n                             static_: & $($mutability)? Static<'tcx>,\n                             _context: PlaceContext<'tcx>,\n                             location: Location) {\n-                let Static { def_id, ty } = static_;\n+                let Static { def_id, ty, promoted: _ } = static_;\n                 self.visit_def_id(def_id, location);\n                 self.visit_ty(ty, TyContext::Location(location));\n             }"}, {"sha": "8f83c025ceb40bc962af0c01038f7742049623d3", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -1598,14 +1598,18 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         including_downcast: &IncludingDowncast,\n     ) -> Result<(), ()> {\n         match *place {\n-            Place::Base(PlaceBase::Promoted(_)) => {\n-                buf.push_str(\"promoted\");\n-            }\n             Place::Base(PlaceBase::Local(local)) => {\n                 self.append_local_to_string(local, buf)?;\n             }\n             Place::Base(PlaceBase::Static(ref static_)) => {\n-                buf.push_str(&self.infcx.tcx.item_name(static_.def_id).to_string());\n+                match static_.promoted {\n+                    Some(_) => {\n+                        buf.push_str(\"promoted\");\n+                    }\n+                    None => {\n+                        buf.push_str(&self.infcx.tcx.item_name(static_.def_id).to_string());\n+                    }\n+                }\n             }\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n@@ -1744,8 +1748,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let local = &self.mir.local_decls[local];\n                 self.describe_field_from_ty(&local.ty, field)\n             }\n-            Place::Base(PlaceBase::Promoted(ref prom)) =>\n-                self.describe_field_from_ty(&prom.1, field),\n             Place::Base(PlaceBase::Static(ref static_)) =>\n                 self.describe_field_from_ty(&static_.ty, field),\n             Place::Projection(ref proj) => match proj.elem {\n@@ -1828,8 +1830,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let tcx = self.infcx.tcx;\n         match place {\n             Place::Base(PlaceBase::Local(_)) |\n-            Place::Base(PlaceBase::Static(_)) |\n-            Place::Base(PlaceBase::Promoted(_)) => {\n+            Place::Base(PlaceBase::Static(_)) => {\n                 StorageDeadOrDrop::LocalStorageDead\n             }\n             Place::Projection(box PlaceProjection { base, elem }) => {"}, {"sha": "5726eba9bdaf6c5d6579b6f15bde5e24b1fc44c4", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -1226,8 +1226,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 }\n                                 Operand::Move(Place::Base(PlaceBase::Static(..)))\n                                 | Operand::Copy(Place::Base(PlaceBase::Static(..)))\n-                                | Operand::Move(Place::Base(PlaceBase::Promoted(..)))\n-                                | Operand::Copy(Place::Base(PlaceBase::Promoted(..)))\n                                 | Operand::Constant(..) => {}\n                             }\n                         }\n@@ -1310,12 +1308,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         //\n         // FIXME: allow thread-locals to borrow other thread locals?\n         let (might_be_alive, will_be_dropped) = match root_place {\n-            Place::Base(PlaceBase::Promoted(_)) => (true, false),\n-            Place::Base(PlaceBase::Static(_)) => {\n-                // Thread-locals might be dropped after the function exits, but\n-                // \"true\" statics will never be.\n-                let is_thread_local = self.is_place_thread_local(&root_place);\n-                (true, is_thread_local)\n+            Place::Base(PlaceBase::Static(st)) => {\n+                match st.promoted {\n+                    None => {\n+                        // Thread-locals might be dropped after the function exits, but\n+                        // \"true\" statics will never be.\n+                        let is_thread_local = self.is_place_thread_local(&root_place);\n+                        (true, is_thread_local)\n+                    }\n+                    Some(_) => (true, false),\n+                }\n             }\n             Place::Base(PlaceBase::Local(_)) => {\n                 // Locals are always dropped at function exit, and if they\n@@ -1578,7 +1580,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         match *last_prefix {\n             Place::Base(PlaceBase::Local(_)) => panic!(\"should have move path for every Local\"),\n             Place::Projection(_) => panic!(\"PrefixSet::All meant don't stop for Projection\"),\n-            Place::Base(PlaceBase::Promoted(_)) |\n             Place::Base(PlaceBase::Static(_)) => Err(NoMovePathFound::ReachedStatic),\n         }\n     }\n@@ -1605,7 +1606,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let mut place = place;\n         loop {\n             match *place {\n-                Place::Base(PlaceBase::Promoted(_)) |\n                 Place::Base(PlaceBase::Local(_)) | Place::Base(PlaceBase::Static(_)) => {\n                     // assigning to `x` does not require `x` be initialized.\n                     break;\n@@ -1953,10 +1953,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     self.used_mut_upvars.push(field);\n                 }\n             }\n-            RootPlace {\n-                place: Place::Base(PlaceBase::Promoted(..)),\n-                is_local_mutation_allowed: _,\n-            } => {}\n             RootPlace {\n                 place: Place::Base(PlaceBase::Static(..)),\n                 is_local_mutation_allowed: _,\n@@ -1994,18 +1990,28 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n             // The rules for promotion are made by `qualify_consts`, there wouldn't even be a\n             // `Place::Promoted` if the promotion weren't 100% legal. So we just forward this\n-            Place::Base(PlaceBase::Promoted(_)) => Ok(RootPlace {\n-                place,\n-                is_local_mutation_allowed,\n-            }),\n+//            Place::Base(PlaceBase::Promoted(_)) => Ok(RootPlace {\n+//                place,\n+//                is_local_mutation_allowed,\n+//            }),\n             Place::Base(PlaceBase::Static(ref static_)) => {\n-                if self.infcx.tcx.is_static(static_.def_id) != Some(hir::Mutability::MutMutable) {\n-                    Err(place)\n-                } else {\n-                    Ok(RootPlace {\n-                        place,\n-                        is_local_mutation_allowed,\n-                    })\n+                match static_.promoted {\n+                    Some(_) => {\n+                        Ok(RootPlace {\n+                            place,\n+                            is_local_mutation_allowed,\n+                        })\n+                    }\n+                    None => {\n+                        if self.infcx.tcx.is_static(static_.def_id) != Some(hir::Mutability::MutMutable) {\n+                            Err(place)\n+                        } else {\n+                            Ok(RootPlace {\n+                                place,\n+                                is_local_mutation_allowed,\n+                            })\n+                        }\n+                    }\n                 }\n             }\n             Place::Projection(ref proj) => {"}, {"sha": "d8c39e0715ad1e39c94713ab2153d213b04de720", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -129,16 +129,19 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            Place::Base(PlaceBase::Promoted(_)) => unreachable!(),\n-\n-            Place::Base(PlaceBase::Static(box Static { def_id, ty: _ })) => {\n-                if let Place::Base(PlaceBase::Static(_)) = access_place {\n-                    item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n-                    reason = String::new();\n-                } else {\n-                    item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                    let static_name = &self.infcx.tcx.item_name(*def_id);\n-                    reason = format!(\", as `{}` is an immutable static item\", static_name);\n+            Place::Base(PlaceBase::Static(box Static { def_id, ty: _, promoted })) => {\n+                match promoted {\n+                    Some(_) => unreachable!(),\n+                    None => {\n+                        if let Place::Base(PlaceBase::Static(_)) = access_place {\n+                            item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n+                            reason = String::new();\n+                        } else {\n+                            item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n+                            let static_name = &self.infcx.tcx.item_name(*def_id);\n+                            reason = format!(\", as `{}` is an immutable static item\", static_name);\n+                        }\n+                    }\n                 }\n             }\n "}, {"sha": "334c20761e7bb3564a068a5219f26946c0a136ea", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 48, "deletions": 44, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -453,51 +453,55 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             Place::Base(PlaceBase::Local(index)) => PlaceTy::Ty {\n                 ty: self.mir.local_decls[index].ty,\n             },\n-            Place::Base(PlaceBase::Promoted(box (index, sty))) => {\n-                let sty = self.sanitize_type(place, sty);\n-\n-                if !self.errors_reported {\n-                    let promoted_mir = &self.mir.promoted[index];\n-                    self.sanitize_promoted(promoted_mir, location);\n-\n-                    let promoted_ty = promoted_mir.return_ty();\n-\n-                    if let Err(terr) = self.cx.eq_types(\n-                        sty,\n-                        promoted_ty,\n-                        location.to_locations(),\n-                        ConstraintCategory::Boring,\n-                    ) {\n-                        span_mirbug!(\n-                            self,\n-                            place,\n-                            \"bad promoted type ({:?}: {:?}): {:?}\",\n-                            promoted_ty,\n-                            sty,\n-                            terr\n-                        );\n-                    };\n-                }\n-                PlaceTy::Ty { ty: sty }\n-            }\n-            Place::Base(PlaceBase::Static(box Static { def_id, ty: sty })) => {\n-                let sty = self.sanitize_type(place, sty);\n-                let ty = self.tcx().type_of(def_id);\n-                let ty = self.cx.normalize(ty, location);\n-                if let Err(terr) =\n-                    self.cx\n-                        .eq_types(ty, sty, location.to_locations(), ConstraintCategory::Boring)\n-                {\n-                    span_mirbug!(\n-                        self,\n-                        place,\n-                        \"bad static type ({:?}: {:?}): {:?}\",\n-                        ty,\n-                        sty,\n-                        terr\n-                    );\n+            Place::Base(PlaceBase::Static(box Static { def_id, ty: sty, promoted })) => {\n+                match promoted {\n+                    Some(pr) => {\n+                        let sty = self.sanitize_type(place, sty);\n+\n+                        if !self.errors_reported {\n+                            let promoted_mir = &self.mir.promoted[pr];\n+                            self.sanitize_promoted(promoted_mir, location);\n+\n+                            let promoted_ty = promoted_mir.return_ty();\n+\n+                            if let Err(terr) = self.cx.eq_types(\n+                                sty,\n+                                promoted_ty,\n+                                location.to_locations(),\n+                                ConstraintCategory::Boring,\n+                            ) {\n+                                span_mirbug!(\n+                                    self,\n+                                    place,\n+                                    \"bad promoted type ({:?}: {:?}): {:?}\",\n+                                    promoted_ty,\n+                                    sty,\n+                                    terr\n+                                );\n+                            };\n+                        }\n+                        PlaceTy::Ty { ty: sty }\n+                    }\n+                    None => {\n+                        let sty = self.sanitize_type(place, sty);\n+                        let ty = self.tcx().type_of(def_id);\n+                        let ty = self.cx.normalize(ty, location);\n+                        if let Err(terr) =\n+                            self.cx\n+                                .eq_types(ty, sty, location.to_locations(), ConstraintCategory::Boring)\n+                        {\n+                            span_mirbug!(\n+                                self,\n+                                place,\n+                                \"bad static type ({:?}: {:?}): {:?}\",\n+                                ty,\n+                                sty,\n+                                terr\n+                            );\n+                        }\n+                        PlaceTy::Ty { ty: sty }\n+                    }\n                 }\n-                PlaceTy::Ty { ty: sty }\n             }\n             Place::Projection(ref proj) => {\n                 let base_context = if context.is_mutating_use() {"}, {"sha": "42eb502b9076d6636d42d3c7d61904e6e13f1e92", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -138,7 +138,6 @@ pub(super) fn is_active<'tcx>(\n /// This is called for all Yield statements on movable generators\n pub(super) fn borrow_of_local_data<'tcx>(place: &Place<'tcx>) -> bool {\n     match place {\n-        Place::Base(PlaceBase::Promoted(_)) |\n         Place::Base(PlaceBase::Static(..)) => false,\n         Place::Base(PlaceBase::Local(..)) => true,\n         Place::Projection(box proj) => {"}, {"sha": "0bbd147d8243b4e6c4bec04595e2e84a28d75e34", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -30,8 +30,6 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool {\n         match self {\n-            Place::Base(PlaceBase::Promoted(_)) => false,\n-\n             // If a local variable is immutable, then we only need to track borrows to guard\n             // against two kinds of errors:\n             // * The variable being dropped while still borrowed (e.g., because the fn returns\n@@ -52,7 +50,12 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                 }\n             }\n             Place::Base(PlaceBase::Static(static_)) => {\n-                tcx.is_static(static_.def_id) == Some(hir::Mutability::MutMutable)\n+                match static_.promoted {\n+                    Some(_) => false,\n+                    None => {\n+                        tcx.is_static(static_.def_id) == Some(hir::Mutability::MutMutable)\n+                    }\n+                }\n             }\n             Place::Projection(proj) => match proj.elem {\n                 ProjectionElem::Field(..)\n@@ -88,7 +91,6 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         loop {\n             match p {\n                 Place::Projection(pi) => p = &pi.base,\n-                Place::Base(PlaceBase::Promoted(_)) |\n                 Place::Base(PlaceBase::Static(_)) => return None,\n                 Place::Base(PlaceBase::Local(l)) => return Some(*l),\n             }"}, {"sha": "7babdfcdd68adbb09275ded96014ff3f04227062", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 35, "deletions": 32, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -338,7 +338,6 @@ fn unroll_place<'tcx, R>(\n             op,\n         ),\n \n-        Place::Base(PlaceBase::Promoted(_)) |\n         Place::Base(PlaceBase::Local(_)) | Place::Base(PlaceBase::Static(_)) => {\n             let list = PlaceComponents {\n                 component: place,\n@@ -371,41 +370,45 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                 Overlap::Disjoint\n             }\n         }\n-        (Place::Base(PlaceBase::Static(static1)), Place::Base(PlaceBase::Static(static2))) => {\n-            if static1.def_id != static2.def_id {\n-                debug!(\"place_element_conflict: DISJOINT-STATIC\");\n-                Overlap::Disjoint\n-            } else if tcx.is_static(static1.def_id) == Some(hir::Mutability::MutMutable) {\n-                // We ignore mutable statics - they can only be unsafe code.\n-                debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n-                Overlap::Disjoint\n-            } else {\n-                debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n-                Overlap::EqualOrDisjoint\n-            }\n-        }\n-        (Place::Base(PlaceBase::Promoted(p1)), Place::Base(PlaceBase::Promoted(p2))) => {\n-            if p1.0 == p2.0 {\n-                if let ty::Array(_, size) = p1.1.sty {\n-                    if size.unwrap_usize(tcx) == 0 {\n-                        // Ignore conflicts with promoted [T; 0].\n-                        debug!(\"place_element_conflict: IGNORE-LEN-0-PROMOTED\");\n-                        return Overlap::Disjoint;\n+        (Place::Base(PlaceBase::Static(s1)), Place::Base(PlaceBase::Static(s2))) => {\n+            match (s1.promoted, s2.promoted) {\n+                (None, None) => {\n+                    if s1.def_id != s2.def_id {\n+                        debug!(\"place_element_conflict: DISJOINT-STATIC\");\n+                        Overlap::Disjoint\n+                    } else if tcx.is_static(s1.def_id) == Some(hir::Mutability::MutMutable) {\n+                        // We ignore mutable statics - they can only be unsafe code.\n+                        debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n+                        Overlap::Disjoint\n+                    } else {\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n+                        Overlap::EqualOrDisjoint\n                     }\n+                },\n+                (Some(p1), Some(p2)) => {\n+                    if p1 == p2 {\n+                        if let ty::Array(_, size) =s1.ty.sty {\n+                            if size.unwrap_usize(tcx) == 0 {\n+                                // Ignore conflicts with promoted [T; 0].\n+                                debug!(\"place_element_conflict: IGNORE-LEN-0-PROMOTED\");\n+                                return Overlap::Disjoint;\n+                            }\n+                        }\n+                        // the same promoted - base case, equal\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-PROMOTED\");\n+                        Overlap::EqualOrDisjoint\n+                    } else {\n+                        // different promoteds - base case, disjoint\n+                        debug!(\"place_element_conflict: DISJOINT-PROMOTED\");\n+                        Overlap::Disjoint\n+                    }\n+                },\n+                (p1_, p2_) => {\n+                    debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL-PROMOTED\");\n+                    Overlap::Disjoint\n                 }\n-                // the same promoted - base case, equal\n-                debug!(\"place_element_conflict: DISJOINT-OR-EQ-PROMOTED\");\n-                Overlap::EqualOrDisjoint\n-            } else {\n-                // different promoteds - base case, disjoint\n-                debug!(\"place_element_conflict: DISJOINT-PROMOTED\");\n-                Overlap::Disjoint\n             }\n         }\n-        (Place::Base(PlaceBase::Local(_)), Place::Base(PlaceBase::Promoted(_))) |\n-        (Place::Base(PlaceBase::Promoted(_)), Place::Base(PlaceBase::Local(_))) |\n-        (Place::Base(PlaceBase::Promoted(_)), Place::Base(PlaceBase::Static(_))) |\n-        (Place::Base(PlaceBase::Static(_)), Place::Base(PlaceBase::Promoted(_))) |\n         (Place::Base(PlaceBase::Local(_)), Place::Base(PlaceBase::Static(_))) |\n         (Place::Base(PlaceBase::Static(_)), Place::Base(PlaceBase::Local(_))) => {\n             debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL-PROMOTED\");"}, {"sha": "e70c9e81ebd16b8beff33970851e172eb2d2eaef", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -26,7 +26,6 @@ impl<'tcx> IsPrefixOf<'tcx> for Place<'tcx> {\n             }\n \n             match *cursor {\n-                Place::Base(PlaceBase::Promoted(_)) |\n                 Place::Base(PlaceBase::Local(_)) |\n                 Place::Base(PlaceBase::Static(_)) => return false,\n                 Place::Projection(ref proj) => {\n@@ -87,7 +86,6 @@ impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n \n         'cursor: loop {\n             let proj = match *cursor {\n-                Place::Base(PlaceBase::Promoted(_)) |\n                 Place::Base(PlaceBase::Local(_)) | // search yielded this leaf\n                 Place::Base(PlaceBase::Static(_)) => {\n                     self.next = None;"}, {"sha": "83e1d3ebb3e068a514d946da6182d75d24690084", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -128,6 +128,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::StaticRef { id } => block.and(Place::Base(PlaceBase::Static(Box::new(Static {\n                 def_id: id,\n                 ty: expr.ty,\n+                promoted: None,\n             })))),\n \n             ExprKind::PlaceTypeAscription { source, user_ty } => {"}, {"sha": "9d4600d13ac138a169daf3cb6476abdb2a797f50", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -93,7 +93,6 @@ struct BorrowedLocalsVisitor<'b, 'c: 'b> {\n fn find_local<'tcx>(place: &Place<'tcx>) -> Option<Local> {\n     match *place {\n         Place::Base(PlaceBase::Local(l)) => Some(l),\n-        Place::Base(PlaceBase::Promoted(_)) |\n         Place::Base(PlaceBase::Static(..)) => None,\n         Place::Projection(ref proj) => {\n             match proj.elem {"}, {"sha": "71805fd02b85714e650ced49e7e590a363c91996", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -97,7 +97,6 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n         debug!(\"lookup({:?})\", place);\n         match *place {\n             Place::Base(PlaceBase::Local(local)) => Ok(self.builder.data.rev_lookup.locals[local]),\n-            Place::Base(PlaceBase::Promoted(..)) |\n             Place::Base(PlaceBase::Static(..)) => {\n                 Err(MoveError::cannot_move_out_of(self.loc, Static))\n             }"}, {"sha": "7eef68e5f807350dcd59491eaf314a03e7a822be", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -286,7 +286,6 @@ impl<'tcx> MovePathLookup<'tcx> {\n     pub fn find(&self, place: &Place<'tcx>) -> LookupResult {\n         match *place {\n             Place::Base(PlaceBase::Local(local)) => LookupResult::Exact(self.locals[local]),\n-            Place::Base(PlaceBase::Promoted(_)) |\n             Place::Base(PlaceBase::Static(..)) => LookupResult::Parent(None),\n             Place::Projection(ref proj) => {\n                 match self.find(&proj.base) {"}, {"sha": "62e2cdffadf347ff5c4da942bffec8f3e6fe9981", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -583,35 +583,38 @@ where\n         use rustc::mir::Place::*;\n         use rustc::mir::PlaceBase;\n         Ok(match *mir_place {\n-            Base(PlaceBase::Promoted(ref promoted)) => {\n-                let instance = self.frame().instance;\n-                self.const_eval_raw(GlobalId {\n-                    instance,\n-                    promoted: Some(promoted.0),\n-                })?\n-            }\n-\n             Base(PlaceBase::Static(ref static_)) => {\n-                assert!(!static_.ty.needs_subst());\n-                let layout = self.layout_of(static_.ty)?;\n-                let instance = ty::Instance::mono(*self.tcx, static_.def_id);\n-                let cid = GlobalId {\n-                    instance,\n-                    promoted: None\n-                };\n-                // Just create a lazy reference, so we can support recursive statics.\n-                // tcx takes are of assigning every static one and only one unique AllocId.\n-                // When the data here is ever actually used, memory will notice,\n-                // and it knows how to deal with alloc_id that are present in the\n-                // global table but not in its local memory: It calls back into tcx through\n-                // a query, triggering the CTFE machinery to actually turn this lazy reference\n-                // into a bunch of bytes.  IOW, statics are evaluated with CTFE even when\n-                // this EvalContext uses another Machine (e.g., in miri).  This is what we\n-                // want!  This way, computing statics works concistently between codegen\n-                // and miri: They use the same query to eventually obtain a `ty::Const`\n-                // and use that for further computation.\n-                let alloc = self.tcx.alloc_map.lock().intern_static(cid.instance.def_id());\n-                MPlaceTy::from_aligned_ptr(Pointer::from(alloc).with_default_tag(), layout)\n+                match static_.promoted {\n+                    Some(promoted) => {\n+                        let instance = self.frame().instance;\n+                        self.const_eval_raw(GlobalId {\n+                            instance,\n+                            promoted: Some(promoted),\n+                        })?\n+                    }\n+                    None => {\n+                        assert!(!static_.ty.needs_subst());\n+                        let layout = self.layout_of(static_.ty)?;\n+                        let instance = ty::Instance::mono(*self.tcx, static_.def_id);\n+                        let cid = GlobalId {\n+                            instance,\n+                            promoted: None\n+                        };\n+                        // Just create a lazy reference, so we can support recursive statics.\n+                        // tcx takes are of assigning every static one and only one unique AllocId.\n+                        // When the data here is ever actually used, memory will notice,\n+                        // and it knows how to deal with alloc_id that are present in the\n+                        // global table but not in its local memory: It calls back into tcx through\n+                        // a query, triggering the CTFE machinery to actually turn this lazy reference\n+                        // into a bunch of bytes.  IOW, statics are evaluated with CTFE even when\n+                        // this EvalContext uses another Machine (e.g., in miri).  This is what we\n+                        // want!  This way, computing statics works concistently between codegen\n+                        // and miri: They use the same query to eventually obtain a `ty::Const`\n+                        // and use that for further computation.\n+                        let alloc = self.tcx.alloc_map.lock().intern_static(cid.instance.def_id());\n+                        MPlaceTy::from_aligned_ptr(Pointer::from(alloc).with_default_tag(), layout)\n+                    }\n+                }\n             }\n \n             _ => bug!(\"eval_place_to_mplace called on {:?}\", mir_place),"}, {"sha": "b13a5fd2fd1c0994fc1c603539504472b04b73f1", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -22,7 +22,6 @@ fn is_stable<'tcx>(\n     match *place {\n         // Locals and statics have stable addresses, for sure\n         Base(PlaceBase::Local { .. }) |\n-        Base(PlaceBase::Promoted { .. }) |\n         Base(PlaceBase::Static { .. }) =>\n             true,\n         // Recurse for projections"}, {"sha": "01cb58a481a319c8a2f2590c5d8df7c7e0b79e68", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -300,29 +300,33 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             &Place::Base(PlaceBase::Local(..)) => {\n                 // locals are safe\n             }\n-            &Place::Base(PlaceBase::Promoted(_)) => {\n-                bug!(\"unsafety checking should happen before promotion\")\n-            }\n-            &Place::Base(PlaceBase::Static(box Static { def_id, ty: _ })) => {\n-                if self.tcx.is_static(def_id) == Some(hir::Mutability::MutMutable) {\n-                    self.require_unsafe(\"use of mutable static\",\n-                        \"mutable statics can be mutated by multiple threads: aliasing violations \\\n-                         or data races will cause undefined behavior\",\n-                         UnsafetyViolationKind::General);\n-                } else if self.tcx.is_foreign_item(def_id) {\n-                    let source_info = self.source_info;\n-                    let lint_root =\n-                        self.source_scope_local_data[source_info.scope].lint_root;\n-                    self.register_violations(&[UnsafetyViolation {\n-                        source_info,\n-                        description: Symbol::intern(\"use of extern static\").as_interned_str(),\n-                        details:\n-                            Symbol::intern(\"extern statics are not controlled by the Rust type \\\n-                                            system: invalid data, aliasing violations or data \\\n-                                            races will cause undefined behavior\")\n-                                .as_interned_str(),\n-                        kind: UnsafetyViolationKind::ExternStatic(lint_root)\n-                    }], &[]);\n+            &Place::Base(PlaceBase::Static(box Static { def_id, ty: _, promoted })) => {\n+                match promoted {\n+                    Some(..) => {\n+                        bug!(\"unsafety checking should happen before promotion\")\n+                    }\n+                    None => {\n+                        if self.tcx.is_static(def_id) == Some(hir::Mutability::MutMutable) {\n+                            self.require_unsafe(\"use of mutable static\",\n+                                \"mutable statics can be mutated by multiple threads: aliasing violations \\\n+                                 or data races will cause undefined behavior\",\n+                                 UnsafetyViolationKind::General);\n+                        } else if self.tcx.is_foreign_item(def_id) {\n+                            let source_info = self.source_info;\n+                            let lint_root =\n+                                self.source_scope_local_data[source_info.scope].lint_root;\n+                            self.register_violations(&[UnsafetyViolation {\n+                                source_info,\n+                                description: Symbol::intern(\"use of extern static\").as_interned_str(),\n+                                details:\n+                                    Symbol::intern(\"extern statics are not controlled by the Rust type \\\n+                                                    system: invalid data, aliasing violations or data \\\n+                                                    races will cause undefined behavior\")\n+                                        .as_interned_str(),\n+                                kind: UnsafetyViolationKind::ExternStatic(lint_root)\n+                            }], &[]);\n+                        }\n+                    }\n                 }\n             }\n         };"}, {"sha": "bbe62fa2d7b37e23e26baf40c8092ecac399950f", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -282,25 +282,31 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 // an `Index` projection would throw us off-track.\n                 _ => None,\n             },\n-            Place::Base(PlaceBase::Promoted(ref promoted)) => {\n-                let generics = self.tcx.generics_of(self.source.def_id());\n-                if generics.requires_monomorphization(self.tcx) {\n-                    // FIXME: can't handle code with generics\n-                    return None;\n+            Place::Base(PlaceBase::Static(ref static_)) => {\n+                match static_.promoted {\n+                    Some(promoted) => {\n+                        let generics = self.tcx.generics_of(self.source.def_id());\n+                        if generics.requires_monomorphization(self.tcx) {\n+                            // FIXME: can't handle code with generics\n+                            return None;\n+                        }\n+                        let substs = InternalSubsts::identity_for_item(self.tcx, self.source.def_id());\n+                        let instance = Instance::new(self.source.def_id(), substs);\n+                        let cid = GlobalId {\n+                            instance,\n+                            promoted: Some(promoted),\n+                        };\n+                        // cannot use `const_eval` here, because that would require having the MIR\n+                        // for the current function available, but we're producing said MIR right now\n+                        let res = self.use_ecx(source_info, |this| {\n+                            eval_promoted(this.tcx, cid, this.mir, this.param_env)\n+                        })?;\n+                        trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n+                        Some((res.into(), source_info.span))\n+                    }\n+                    None => None\n                 }\n-                let substs = InternalSubsts::identity_for_item(self.tcx, self.source.def_id());\n-                let instance = Instance::new(self.source.def_id(), substs);\n-                let cid = GlobalId {\n-                    instance,\n-                    promoted: Some(promoted.0),\n-                };\n-                // cannot use `const_eval` here, because that would require having the MIR\n-                // for the current function available, but we're producing said MIR right now\n-                let res = self.use_ecx(source_info, |this| {\n-                    eval_promoted(this.tcx, cid, this.mir, this.param_env)\n-                })?;\n-                trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n-                Some((res.into(), source_info.span))\n+\n             },\n             _ => None,\n         }"}, {"sha": "0b2a34d5fb97555568de6bffd5fcfdece1fa4237", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -692,12 +692,16 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n                 // Return pointer; update the place itself\n                 *place = self.destination.clone();\n             },\n-            Place::Base(PlaceBase::Promoted(ref mut promoted)) => {\n-                if let Some(p) = self.promoted_map.get(promoted.0).cloned() {\n-                    promoted.0 = p;\n+            Place::Base(PlaceBase::Static(ref mut static_)) => {\n+                match static_.promoted {\n+                    Some(promoted) => {\n+                        if let Some(p) = self.promoted_map.get(promoted).cloned() {\n+                            static_.promoted = Some(p);\n+                        }\n+                    }\n+                    None => self.super_place(place, _ctxt, _location)\n                 }\n             },\n-            _ => self.super_place(place, _ctxt, _location),\n         }\n     }\n "}, {"sha": "f0ba1306c99fc9114e298c0a911eab77abc6341b", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 65, "deletions": 54, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -188,8 +188,12 @@ trait Qualif {\n     fn in_place(cx: &ConstCx<'_, 'tcx>, place: &Place<'tcx>) -> bool {\n         match *place {\n             Place::Base(PlaceBase::Local(local)) => Self::in_local(cx, local),\n-            Place::Base(PlaceBase::Promoted(_)) => bug!(\"qualifying already promoted MIR\"),\n-            Place::Base(PlaceBase::Static(ref static_)) => Self::in_static(cx, static_),\n+            Place::Base(PlaceBase::Static(ref static_)) => {\n+                match static_.promoted {\n+                    Some(..) => bug!(\"qualifying already promoted MIR\"),\n+                    None => Self::in_static(cx, static_),\n+                 }\n+            },\n             Place::Projection(ref proj) => Self::in_projection(cx, proj),\n         }\n     }\n@@ -768,17 +772,20 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     );\n                     dest = &proj.base;\n                 },\n-                Place::Base(PlaceBase::Promoted(..)) =>\n-                    bug!(\"promoteds don't exist yet during promotion\"),\n-                Place::Base(PlaceBase::Static(..)) => {\n-                    // Catch more errors in the destination. `visit_place` also checks that we\n-                    // do not try to access statics from constants or try to mutate statics\n-                    self.visit_place(\n-                        dest,\n-                        PlaceContext::MutatingUse(MutatingUseContext::Store),\n-                        location\n-                    );\n-                    return;\n+                Place::Base(PlaceBase::Static(st)) => {\n+                    match st.promoted {\n+                        Some(..) => bug!(\"promoteds don't exist yet during promotion\"),\n+                        None => {\n+                            // Catch more errors in the destination. `visit_place` also checks that we\n+                            // do not try to access statics from constants or try to mutate statics\n+                            self.visit_place(\n+                                dest,\n+                                PlaceContext::MutatingUse(MutatingUseContext::Store),\n+                                location\n+                            );\n+                            return;\n+                        }\n+                    }\n                 }\n             }\n         };\n@@ -919,51 +926,55 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         debug!(\"visit_place: place={:?} context={:?} location={:?}\", place, context, location);\n         self.super_place(place, context, location);\n         match *place {\n-            Place::Base(PlaceBase::Local(_)) |\n-            Place::Base(PlaceBase::Promoted(_)) => {}\n+            Place::Base(PlaceBase::Local(_)) => {}\n             Place::Base(PlaceBase::Static(ref global)) => {\n-                if self.tcx\n-                       .get_attrs(global.def_id)\n-                       .iter()\n-                       .any(|attr| attr.check_name(\"thread_local\")) {\n-                    if self.mode != Mode::Fn {\n-                        span_err!(self.tcx.sess, self.span, E0625,\n-                                  \"thread-local statics cannot be \\\n-                                   accessed at compile-time\");\n-                    }\n-                    return;\n-                }\n+                match global.promoted {\n+                    Some(..) => {}\n+                    None => {\n+                        if self.tcx\n+                               .get_attrs(global.def_id)\n+                               .iter()\n+                               .any(|attr| attr.check_name(\"thread_local\")) {\n+                            if self.mode != Mode::Fn {\n+                                span_err!(self.tcx.sess, self.span, E0625,\n+                                          \"thread-local statics cannot be \\\n+                                           accessed at compile-time\");\n+                            }\n+                            return;\n+                        }\n \n-                // Only allow statics (not consts) to refer to other statics.\n-                if self.mode == Mode::Static || self.mode == Mode::StaticMut {\n-                    if self.mode == Mode::Static && context.is_mutating_use() {\n-                        // this is not strictly necessary as miri will also bail out\n-                        // For interior mutability we can't really catch this statically as that\n-                        // goes through raw pointers and intermediate temporaries, so miri has\n-                        // to catch this anyway\n-                        self.tcx.sess.span_err(\n-                            self.span,\n-                            \"cannot mutate statics in the initializer of another static\",\n-                        );\n-                    }\n-                    return;\n-                }\n-                unleash_miri!(self);\n+                        // Only allow statics (not consts) to refer to other statics.\n+                        if self.mode == Mode::Static || self.mode == Mode::StaticMut {\n+                            if self.mode == Mode::Static && context.is_mutating_use() {\n+                                // this is not strictly necessary as miri will also bail out\n+                                // For interior mutability we can't really catch this statically as that\n+                                // goes through raw pointers and intermediate temporaries, so miri has\n+                                // to catch this anyway\n+                                self.tcx.sess.span_err(\n+                                    self.span,\n+                                    \"cannot mutate statics in the initializer of another static\",\n+                                );\n+                            }\n+                            return;\n+                        }\n+                        unleash_miri!(self);\n \n-                if self.mode != Mode::Fn {\n-                    let mut err = struct_span_err!(self.tcx.sess, self.span, E0013,\n-                                                   \"{}s cannot refer to statics, use \\\n-                                                    a constant instead\", self.mode);\n-                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                        err.note(\n-                            \"Static and const variables can refer to other const variables. But a \\\n-                             const variable cannot refer to a static variable.\"\n-                        );\n-                        err.help(\n-                            \"To fix this, the value can be extracted as a const and then used.\"\n-                        );\n+                        if self.mode != Mode::Fn {\n+                            let mut err = struct_span_err!(self.tcx.sess, self.span, E0013,\n+                                                           \"{}s cannot refer to statics, use \\\n+                                                            a constant instead\", self.mode);\n+                            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                                err.note(\n+                                    \"Static and const variables can refer to other const variables. But a \\\n+                                     const variable cannot refer to a static variable.\"\n+                                );\n+                                err.help(\n+                                    \"To fix this, the value can be extracted as a const and then used.\"\n+                                );\n+                            }\n+                            err.emit()\n+                        }\n                     }\n-                    err.emit()\n                 }\n             }\n             Place::Projection(ref proj) => {"}, {"sha": "ea5bbaeb4008e67981c0b9a1be54ad5f0e344469", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb1c22da181426f6ea7662f5c7f47edbbe24f56/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=7fb1c22da181426f6ea7662f5c7f47edbbe24f56", "patch": "@@ -256,10 +256,13 @@ fn check_place(\n ) -> McfResult {\n     match place {\n         Place::Base(PlaceBase::Local(_)) => Ok(()),\n-        // promoteds are always fine, they are essentially constants\n-        Place::Base(PlaceBase::Promoted(_)) => Ok(()),\n-        Place::Base(PlaceBase::Static(_)) =>\n-            Err((span, \"cannot access `static` items in const fn\".into())),\n+        Place::Base(PlaceBase::Static(st)) => {\n+            match st.promoted {\n+                // promoteds are always fine, they are essentially constants\n+                Some(..) => Ok(()),\n+                None => Err((span, \"cannot access `static` items in const fn\".into())),\n+            }\n+        }\n         Place::Projection(proj) => {\n             match proj.elem {\n                 | ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. }"}]}