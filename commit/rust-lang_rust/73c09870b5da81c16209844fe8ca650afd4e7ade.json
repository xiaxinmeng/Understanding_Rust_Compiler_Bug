{"sha": "73c09870b5da81c16209844fe8ca650afd4e7ade", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczYzA5ODcwYjVkYTgxYzE2MjA5ODQ0ZmU4Y2E2NTBhZmQ0ZTdhZGU=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-09-29T20:34:22Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-10-02T19:55:38Z"}, "message": "Do not mark unitinitialized locals as requiring storage", "tree": {"sha": "1ae2ef5c3c81b25acc5d2ed5550fbd9c88a35081", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ae2ef5c3c81b25acc5d2ed5550fbd9c88a35081"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73c09870b5da81c16209844fe8ca650afd4e7ade", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73c09870b5da81c16209844fe8ca650afd4e7ade", "html_url": "https://github.com/rust-lang/rust/commit/73c09870b5da81c16209844fe8ca650afd4e7ade", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73c09870b5da81c16209844fe8ca650afd4e7ade/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1dfc3e79628e8faa67617adc02928af809602cd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dfc3e79628e8faa67617adc02928af809602cd9", "html_url": "https://github.com/rust-lang/rust/commit/1dfc3e79628e8faa67617adc02928af809602cd9"}], "stats": {"total": 157, "additions": 140, "deletions": 17}, "files": [{"sha": "c1695ba66d0d536e54142f907043c66ddbe975e3", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/73c09870b5da81c16209844fe8ca650afd4e7ade/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c09870b5da81c16209844fe8ca650afd4e7ade/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=73c09870b5da81c16209844fe8ca650afd4e7ade", "patch": "@@ -109,15 +109,13 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         assert_eq!(1, self.body.arg_count);\n     }\n \n-    fn statement_effect(&self,\n-                        sets: &mut GenKillSet<Local>,\n-                        loc: Location) {\n-        self.check_for_move(sets, loc);\n+    fn before_statement_effect(&self, sets: &mut GenKillSet<Self::Idx>, loc: Location) {\n+        // If we borrow or assign to a place then it needs storage for that\n+        // statement.\n         self.check_for_borrow(sets, loc);\n \n         let stmt = &self.body[loc.block].statements[loc.statement_index];\n         match stmt.kind {\n-            StatementKind::StorageLive(l) => sets.gen(l),\n             StatementKind::StorageDead(l) => sets.kill(l),\n             StatementKind::Assign(box(ref place, _))\n             | StatementKind::SetDiscriminant { box ref place, .. } => {\n@@ -136,11 +134,35 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         }\n     }\n \n-    fn terminator_effect(&self,\n-                         sets: &mut GenKillSet<Local>,\n-                         loc: Location) {\n+    fn statement_effect(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n+        // If we move from a place then only stops needing storage *after*\n+        // that statement.\n         self.check_for_move(sets, loc);\n+    }\n+\n+    fn before_terminator_effect(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n         self.check_for_borrow(sets, loc);\n+\n+        if let TerminatorKind::Call {\n+            destination: Some((Place { base: PlaceBase::Local(local), .. }, _)),\n+            ..\n+        } = self.body[loc.block].terminator().kind {\n+            sets.gen(local);\n+        }\n+    }\n+\n+    fn terminator_effect(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n+        // For call terminators the destination requires storage for the call\n+        // and after the call returns successfully, but not after a panic.\n+        // Since `propagate_call_unwind` doesn't exist, we have to kill the\n+        // destination here, and then gen it again in `propagate_call_return`.\n+        if let TerminatorKind::Call {\n+            destination: Some((Place { base: PlaceBase::Local(local), projection: box [] }, _)),\n+            ..\n+        } = self.body[loc.block].terminator().kind {\n+            sets.kill(local);\n+        }\n+        self.check_for_move(sets, loc);\n     }\n \n     fn propagate_call_return("}, {"sha": "f304ac4e9e16e0aa69cad0d3fc151a696bc1a3dc", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/73c09870b5da81c16209844fe8ca650afd4e7ade/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c09870b5da81c16209844fe8ca650afd4e7ade/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=73c09870b5da81c16209844fe8ca650afd4e7ade", "patch": "@@ -508,10 +508,7 @@ fn locals_live_across_suspend_points(\n             storage_liveness_map.insert(block, storage_liveness.clone());\n \n             requires_storage_cursor.seek(loc);\n-            let mut storage_required = requires_storage_cursor.get().clone();\n-\n-            // Mark locals without storage statements as always requiring storage\n-            storage_required.union(&ignored.0);\n+            let storage_required = requires_storage_cursor.get().clone();\n \n             // Locals live are live at this point only if they are used across\n             // suspension points (the `liveness` variable)"}, {"sha": "c266644fd702c87ab6f2e2820ca881c443307150", "filename": "src/test/ui/async-await/async-fn-size-moved-locals.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/73c09870b5da81c16209844fe8ca650afd4e7ade/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c09870b5da81c16209844fe8ca650afd4e7ade/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs?ref=73c09870b5da81c16209844fe8ca650afd4e7ade", "patch": "@@ -22,7 +22,8 @@ struct BigFut([u8; BIG_FUT_SIZE]);\n impl BigFut {\n     fn new() -> Self {\n         BigFut([0; BIG_FUT_SIZE])\n-    } }\n+    }\n+}\n \n impl Drop for BigFut {\n     fn drop(&mut self) {}"}, {"sha": "a489fb11630cd3e04306bae743251bbb47ccfdcb", "filename": "src/test/ui/async-await/async-fn-size-uninit-locals.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/73c09870b5da81c16209844fe8ca650afd4e7ade/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-uninit-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c09870b5da81c16209844fe8ca650afd4e7ade/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-uninit-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-uninit-locals.rs?ref=73c09870b5da81c16209844fe8ca650afd4e7ade", "patch": "@@ -0,0 +1,103 @@\n+// Test that we don't store uninitialized locals in futures from `async fn`.\n+//\n+// The exact sizes can change by a few bytes (we'd like to know when they do).\n+// What we don't want to see is the wrong multiple of 1024 (the size of `Big`)\n+// being reflected in the size.\n+\n+// ignore-wasm32-bare (sizes don't match)\n+// run-pass\n+\n+// edition:2018\n+\n+#![allow(unused_variables, unused_assignments)]\n+\n+use std::future::Future;\n+use std::pin::Pin;\n+use std::task::{Context, Poll};\n+\n+const BIG_FUT_SIZE: usize = 1024;\n+struct Big([u8; BIG_FUT_SIZE]);\n+\n+impl Big {\n+    fn new() -> Self {\n+        Big([0; BIG_FUT_SIZE])\n+    }\n+}\n+\n+impl Drop for Big {\n+    fn drop(&mut self) {}\n+}\n+\n+#[allow(dead_code)]\n+struct Joiner {\n+    a: Option<Big>,\n+    b: Option<Big>,\n+    c: Option<Big>,\n+}\n+\n+impl Future for Joiner {\n+    type Output = ();\n+\n+    fn poll(self: Pin<&mut Self>, _ctx: &mut Context<'_>) -> Poll<Self::Output> {\n+        Poll::Ready(())\n+    }\n+}\n+\n+fn noop() {}\n+async fn fut() {}\n+\n+async fn single() {\n+    let x;\n+    fut().await;\n+    x = Big::new();\n+}\n+\n+async fn single_with_noop() {\n+    let x;\n+    fut().await;\n+    noop();\n+    x = Big::new();\n+    noop();\n+}\n+\n+async fn joined() {\n+    let joiner;\n+    let a = Big::new();\n+    let b = Big::new();\n+    let c = Big::new();\n+\n+    fut().await;\n+    noop();\n+    joiner = Joiner { a: Some(a), b: Some(b), c: Some(c) };\n+    noop();\n+}\n+\n+async fn joined_with_noop() {\n+    let joiner;\n+    let a = Big::new();\n+    let b = Big::new();\n+    let c = Big::new();\n+\n+    fut().await;\n+    noop();\n+    joiner = Joiner { a: Some(a), b: Some(b), c: Some(c) };\n+    noop();\n+}\n+\n+async fn join_retval() -> Joiner {\n+    let a = Big::new();\n+    let b = Big::new();\n+    let c = Big::new();\n+\n+    fut().await;\n+    noop();\n+    Joiner { a: Some(a), b: Some(b), c: Some(c) }\n+}\n+\n+fn main() {\n+    assert_eq!(8, std::mem::size_of_val(&single()));\n+    assert_eq!(12, std::mem::size_of_val(&single_with_noop()));\n+    assert_eq!(3084, std::mem::size_of_val(&joined()));\n+    assert_eq!(3084, std::mem::size_of_val(&joined_with_noop()));\n+    assert_eq!(3084, std::mem::size_of_val(&join_retval()));\n+}"}, {"sha": "b313992db4ecbc38883d389a3d365735ac0c3dce", "filename": "src/test/ui/async-await/async-fn-size.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/73c09870b5da81c16209844fe8ca650afd4e7ade/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c09870b5da81c16209844fe8ca650afd4e7ade/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size.rs?ref=73c09870b5da81c16209844fe8ca650afd4e7ade", "patch": "@@ -89,10 +89,10 @@ fn main() {\n     assert_eq!(8, std::mem::size_of_val(&await1_level1()));\n     assert_eq!(12, std::mem::size_of_val(&await2_level1()));\n     assert_eq!(12, std::mem::size_of_val(&await3_level1()));\n-    assert_eq!(20, std::mem::size_of_val(&await3_level2()));\n-    assert_eq!(28, std::mem::size_of_val(&await3_level3()));\n-    assert_eq!(36, std::mem::size_of_val(&await3_level4()));\n-    assert_eq!(44, std::mem::size_of_val(&await3_level5()));\n+    assert_eq!(24, std::mem::size_of_val(&await3_level2()));\n+    assert_eq!(36, std::mem::size_of_val(&await3_level3()));\n+    assert_eq!(48, std::mem::size_of_val(&await3_level4()));\n+    assert_eq!(60, std::mem::size_of_val(&await3_level5()));\n \n     assert_eq!(1,   wait(base()));\n     assert_eq!(1,   wait(await1_level1()));"}]}