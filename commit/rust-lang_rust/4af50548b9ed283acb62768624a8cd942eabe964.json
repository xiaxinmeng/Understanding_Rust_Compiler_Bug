{"sha": "4af50548b9ed283acb62768624a8cd942eabe964", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhZjUwNTQ4YjllZDI4M2FjYjYyNzY4NjI0YThjZDk0MmVhYmU5NjQ=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-12-04T18:29:47Z"}, "committer": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2014-12-29T00:40:47Z"}, "message": "liballoc: Use NonZero in Arc.", "tree": {"sha": "5aef71b845c938a7087df51b718519e5eea77c53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5aef71b845c938a7087df51b718519e5eea77c53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4af50548b9ed283acb62768624a8cd942eabe964", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4af50548b9ed283acb62768624a8cd942eabe964", "html_url": "https://github.com/rust-lang/rust/commit/4af50548b9ed283acb62768624a8cd942eabe964", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4af50548b9ed283acb62768624a8cd942eabe964/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d48f76224371e884496182f6cfb3e2dad7690a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d48f76224371e884496182f6cfb3e2dad7690a2", "html_url": "https://github.com/rust-lang/rust/commit/0d48f76224371e884496182f6cfb3e2dad7690a2"}], "stats": {"total": 29, "additions": 17, "deletions": 12}, "files": [{"sha": "290617535bb643661e47ac77d17237e0d48ba45d", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4af50548b9ed283acb62768624a8cd942eabe964/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af50548b9ed283acb62768624a8cd942eabe964/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=4af50548b9ed283acb62768624a8cd942eabe964", "patch": "@@ -79,8 +79,7 @@ use core::mem;\n use core::ops::{Drop, Deref};\n use core::option::Option;\n use core::option::Option::{Some, None};\n-use core::ptr::RawPtr;\n-use core::ptr;\n+use core::ptr::{mod, NonZero, RawPtr};\n use heap::deallocate;\n \n /// An atomically reference counted wrapper for shared state.\n@@ -114,7 +113,7 @@ use heap::deallocate;\n pub struct Arc<T> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n-    _ptr: *mut ArcInner<T>,\n+    _ptr: NonZero<*mut ArcInner<T>>,\n }\n \n unsafe impl<T: Sync + Send> Send for Arc<T> { }\n@@ -130,7 +129,7 @@ unsafe impl<T: Sync + Send> Sync for Arc<T> { }\n pub struct Weak<T> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n-    _ptr: *mut ArcInner<T>,\n+    _ptr: NonZero<*mut ArcInner<T>>,\n }\n \n unsafe impl<T: Sync + Send> Send for Weak<T> { }\n@@ -165,7 +164,7 @@ impl<T> Arc<T> {\n             weak: atomic::AtomicUint::new(1),\n             data: data,\n         };\n-        Arc { _ptr: unsafe { mem::transmute(x) } }\n+        Arc { _ptr: NonZero(unsafe { mem::transmute(x) }) }\n     }\n \n     /// Downgrades the `Arc<T>` to a `Weak<T>` reference.\n@@ -194,7 +193,8 @@ impl<T> Arc<T> {\n         // pointer is valid. Furthermore, we know that the `ArcInner` structure itself is `Sync`\n         // because the inner data is `Sync` as well, so we're ok loaning out an immutable pointer\n         // to these contents.\n-        unsafe { &*self._ptr }\n+        let NonZero(ptr) = self._ptr;\n+        unsafe { &*ptr }\n     }\n }\n \n@@ -281,7 +281,8 @@ impl<T: Send + Sync + Clone> Arc<T> {\n         // pointer that will ever be returned to T. Our reference count is guaranteed to be 1 at\n         // this point, and we required the Arc itself to be `mut`, so we're returning the only\n         // possible reference to the inner data.\n-        let inner = unsafe { &mut *self._ptr };\n+        let NonZero(ptr) = self._ptr;\n+        let inner = unsafe { &mut *ptr };\n         &mut inner.data\n     }\n }\n@@ -316,7 +317,8 @@ impl<T: Sync + Send> Drop for Arc<T> {\n     fn drop(&mut self) {\n         // This structure has #[unsafe_no_drop_flag], so this drop glue may run more than once (but\n         // it is guaranteed to be zeroed after the first if it's run more than once)\n-        if self._ptr.is_null() { return }\n+        let NonZero(ptr) = self._ptr;\n+        if ptr.is_null() { return }\n \n         // Because `fetch_sub` is already atomic, we do not need to synchronize with other threads\n         // unless we are going to delete the object. This same logic applies to the below\n@@ -346,7 +348,7 @@ impl<T: Sync + Send> Drop for Arc<T> {\n \n         if self.inner().weak.fetch_sub(1, atomic::Release) == 1 {\n             atomic::fence(atomic::Acquire);\n-            unsafe { deallocate(self._ptr as *mut u8, size_of::<ArcInner<T>>(),\n+            unsafe { deallocate(ptr as *mut u8, size_of::<ArcInner<T>>(),\n                                 min_align_of::<ArcInner<T>>()) }\n         }\n     }\n@@ -386,7 +388,8 @@ impl<T: Sync + Send> Weak<T> {\n     #[inline]\n     fn inner(&self) -> &ArcInner<T> {\n         // See comments above for why this is \"safe\"\n-        unsafe { &*self._ptr }\n+        let NonZero(ptr) = self._ptr;\n+        unsafe { &*ptr }\n     }\n }\n \n@@ -442,14 +445,16 @@ impl<T: Sync + Send> Drop for Weak<T> {\n     /// } // implicit drop\n     /// ```\n     fn drop(&mut self) {\n+        let NonZero(ptr) = self._ptr;\n+\n         // see comments above for why this check is here\n-        if self._ptr.is_null() { return }\n+        if ptr.is_null() { return }\n \n         // If we find out that we were the last weak pointer, then its time to deallocate the data\n         // entirely. See the discussion in Arc::drop() about the memory orderings\n         if self.inner().weak.fetch_sub(1, atomic::Release) == 1 {\n             atomic::fence(atomic::Acquire);\n-            unsafe { deallocate(self._ptr as *mut u8, size_of::<ArcInner<T>>(),\n+            unsafe { deallocate(ptr as *mut u8, size_of::<ArcInner<T>>(),\n                                 min_align_of::<ArcInner<T>>()) }\n         }\n     }"}]}