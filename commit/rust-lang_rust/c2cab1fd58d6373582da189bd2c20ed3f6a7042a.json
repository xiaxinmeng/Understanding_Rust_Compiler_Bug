{"sha": "c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyY2FiMWZkNThkNjM3MzU4MmRhMTg5YmQyYzIwZWQzZjZhNzA0MmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-01T13:21:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-01T13:21:53Z"}, "message": "Auto merge of #33794 - petrochenkov:sanity, r=nrc\n\nAdd AST validation pass and move some checks to it\n\nThe purpose of this pass is to catch constructions that fit into AST data structures, but not permitted by the language. As an example, `impl`s don't have visibilities, but for convenience and uniformity with other items they are represented with a structure `Item` which has `Visibility` field.\n\nThis pass is intended to run after expansion of macros and syntax extensions (and before lowering to HIR), so it can catch erroneous constructions that were generated by them. This pass allows to remove ad hoc semantic checks from the parser, which can be overruled by syntax extensions and occasionally macros.\n\nThe checks can be put here if they are simple, local, don't require results of any complex analysis like name resolution or type checking and maybe don't logically fall into other passes. I expect most of errors generated by this pass to be non-fatal and allowing the compilation to proceed.\n\nI intend to move some more checks to this pass later and maybe extend it with new checks, like, for example, identifier validity. Given that syntax extensions are going to be stabilized in the measurable future, it's important that they would not be able to subvert usual language rules.\n\nIn this patch I've added two new checks - a check for labels named `'static` and a check for lifetimes and labels named `'_`. The first one gives a hard error, the second one - a future compatibility warning.\nFixes https://github.com/rust-lang/rust/issues/33059 ([breaking-change])\ncc https://github.com/rust-lang/rfcs/pull/1177\n\nr? @nrc", "tree": {"sha": "f8184bb569150d8f7769e1bbbd1bd19a22584d8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8184bb569150d8f7769e1bbbd1bd19a22584d8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "html_url": "https://github.com/rust-lang/rust/commit/c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "806a5535dac1afe79176ea7053661953c89eaa5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/806a5535dac1afe79176ea7053661953c89eaa5e", "html_url": "https://github.com/rust-lang/rust/commit/806a5535dac1afe79176ea7053661953c89eaa5e"}, {"sha": "731144b95a1040ca692296d064c5be47fa927d3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/731144b95a1040ca692296d064c5be47fa927d3c", "html_url": "https://github.com/rust-lang/rust/commit/731144b95a1040ca692296d064c5be47fa927d3c"}], "stats": {"total": 526, "additions": 312, "deletions": 214}, "files": [{"sha": "41086b5d1c990651cfdb774e595b3335ee5330a7", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -204,6 +204,12 @@ declare_lint! {\n     \"object-unsafe non-principal fragments in object types were erroneously allowed\"\n }\n \n+declare_lint! {\n+    pub LIFETIME_UNDERSCORE,\n+    Warn,\n+    \"lifetimes or labels named `'_` were erroneously allowed\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -242,7 +248,8 @@ impl LintPass for HardwiredLints {\n             SUPER_OR_SELF_IN_GLOBAL_PATH,\n             UNSIZED_IN_TUPLE,\n             OBJECT_UNSAFE_FRAGMENT,\n-            HR_LIFETIME_IN_ASSOC_TYPE\n+            HR_LIFETIME_IN_ASSOC_TYPE,\n+            LIFETIME_UNDERSCORE\n         )\n     }\n }"}, {"sha": "911626bd2c2cc8391d797ca9079b8e420061e73e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -38,7 +38,7 @@ use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n use rustc::hir::lowering::lower_crate;\n-use rustc_passes::{no_asm, loops, consts, rvalues, static_recursion};\n+use rustc_passes::{ast_validation, no_asm, loops, consts, rvalues, static_recursion};\n use rustc_const_eval::check_match;\n use super::Compilation;\n \n@@ -165,6 +165,10 @@ pub fn compile_input(sess: &Session,\n              \"early lint checks\",\n              || lint::check_ast_crate(sess, &expanded_crate));\n \n+        time(sess.time_passes(),\n+             \"AST validation\",\n+             || ast_validation::check_crate(sess, &expanded_crate));\n+\n         let (analysis, resolutions, mut hir_forest) = {\n             lower_and_resolve(sess, &id, &mut defs, &expanded_crate,\n                               &sess.dep_graph, control.make_glob_map)"}, {"sha": "ed12d0d9f3c11230f0b08d465f75c11f18065f1a", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -202,6 +202,10 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(HR_LIFETIME_IN_ASSOC_TYPE),\n             reference: \"issue #33685 <https://github.com/rust-lang/rust/issues/33685>\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(LIFETIME_UNDERSCORE),\n+            reference: \"RFC 1177 <https://github.com/rust-lang/rfcs/pull/1177>\",\n+        },\n         ]);\n \n     // We have one lint pass defined specially"}, {"sha": "919c717f888ffc77e34a3d181f33cb9b694dd915", "filename": "src/librustc_passes/ast_validation.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -0,0 +1,171 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Validate AST before lowering it to HIR\n+//\n+// This pass is supposed to catch things that fit into AST data structures,\n+// but not permitted by the language. It runs after expansion when AST is frozen,\n+// so it can check for erroneous constructions produced by syntax extensions.\n+// This pass is supposed to perform only simple checks not requiring name resolution\n+// or type checking or some other kind of complex analysis.\n+\n+use rustc::lint;\n+use rustc::session::Session;\n+use syntax::ast::*;\n+use syntax::codemap::Span;\n+use syntax::errors;\n+use syntax::parse::token::{self, keywords};\n+use syntax::visit::{self, Visitor};\n+\n+struct AstValidator<'a> {\n+    session: &'a Session,\n+}\n+\n+impl<'a> AstValidator<'a> {\n+    fn err_handler(&self) -> &errors::Handler {\n+        &self.session.parse_sess.span_diagnostic\n+    }\n+\n+    fn check_label(&self, label: Ident, span: Span, id: NodeId) {\n+        if label.name == keywords::StaticLifetime.name() {\n+            self.err_handler().span_err(span, &format!(\"invalid label name `{}`\", label.name));\n+        }\n+        if label.name.as_str() == \"'_\" {\n+            self.session.add_lint(\n+                lint::builtin::LIFETIME_UNDERSCORE, id, span,\n+                format!(\"invalid label name `{}`\", label.name)\n+            );\n+        }\n+    }\n+\n+    fn invalid_visibility(&self, vis: &Visibility, span: Span, note: Option<&str>) {\n+        if vis != &Visibility::Inherited {\n+            let mut err = struct_span_err!(self.session, span, E0449,\n+                                           \"unnecessary visibility qualifier\");\n+            if let Some(note) = note {\n+                err.span_note(span, note);\n+            }\n+            err.emit();\n+        }\n+    }\n+}\n+\n+impl<'a, 'v> Visitor<'v> for AstValidator<'a> {\n+    fn visit_lifetime(&mut self, lt: &Lifetime) {\n+        if lt.name.as_str() == \"'_\" {\n+            self.session.add_lint(\n+                lint::builtin::LIFETIME_UNDERSCORE, lt.id, lt.span,\n+                format!(\"invalid lifetime name `{}`\", lt.name)\n+            );\n+        }\n+\n+        visit::walk_lifetime(self, lt)\n+    }\n+\n+    fn visit_expr(&mut self, expr: &Expr) {\n+        match expr.node {\n+            ExprKind::While(_, _, Some(ident)) | ExprKind::Loop(_, Some(ident)) |\n+            ExprKind::WhileLet(_, _, _, Some(ident)) | ExprKind::ForLoop(_, _, _, Some(ident)) |\n+            ExprKind::Break(Some(ident)) | ExprKind::Again(Some(ident)) => {\n+                self.check_label(ident.node, ident.span, expr.id);\n+            }\n+            _ => {}\n+        }\n+\n+        visit::walk_expr(self, expr)\n+    }\n+\n+    fn visit_path(&mut self, path: &Path, id: NodeId) {\n+        if path.global && path.segments.len() > 0 {\n+            let ident = path.segments[0].identifier;\n+            if token::Ident(ident).is_path_segment_keyword() {\n+                self.session.add_lint(\n+                    lint::builtin::SUPER_OR_SELF_IN_GLOBAL_PATH, id, path.span,\n+                    format!(\"global paths cannot start with `{}`\", ident)\n+                );\n+            }\n+        }\n+\n+        visit::walk_path(self, path)\n+    }\n+\n+    fn visit_item(&mut self, item: &Item) {\n+        match item.node {\n+            ItemKind::Use(ref view_path) => {\n+                let path = view_path.node.path();\n+                if !path.segments.iter().all(|segment| segment.parameters.is_empty()) {\n+                    self.err_handler().span_err(path.span, \"type or lifetime parameters \\\n+                                                            in import path\");\n+                }\n+            }\n+            ItemKind::Impl(_, _, _, Some(..), _, ref impl_items) => {\n+                self.invalid_visibility(&item.vis, item.span, None);\n+                for impl_item in impl_items {\n+                    self.invalid_visibility(&impl_item.vis, impl_item.span, None);\n+                }\n+            }\n+            ItemKind::Impl(_, _, _, None, _, _) => {\n+                self.invalid_visibility(&item.vis, item.span, Some(\"place qualifiers on individual \\\n+                                                                    impl items instead\"));\n+            }\n+            ItemKind::DefaultImpl(..) => {\n+                self.invalid_visibility(&item.vis, item.span, None);\n+            }\n+            ItemKind::ForeignMod(..) => {\n+                self.invalid_visibility(&item.vis, item.span, Some(\"place qualifiers on individual \\\n+                                                                    foreign items instead\"));\n+            }\n+            ItemKind::Enum(ref def, _) => {\n+                for variant in &def.variants {\n+                    for field in variant.node.data.fields() {\n+                        self.invalid_visibility(&field.vis, field.span, None);\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        visit::walk_item(self, item)\n+    }\n+\n+    fn visit_variant_data(&mut self, vdata: &VariantData, _: Ident,\n+                          _: &Generics, _: NodeId, span: Span) {\n+        if vdata.fields().is_empty() {\n+            if vdata.is_tuple() {\n+                self.err_handler().struct_span_err(span, \"empty tuple structs and enum variants \\\n+                                                          are not allowed, use unit structs and \\\n+                                                          enum variants instead\")\n+                                         .span_help(span, \"remove trailing `()` to make a unit \\\n+                                                           struct or unit enum variant\")\n+                                         .emit();\n+            }\n+        }\n+\n+        visit::walk_struct_def(self, vdata)\n+    }\n+\n+    fn visit_vis(&mut self, vis: &Visibility) {\n+        match *vis {\n+            Visibility::Restricted{ref path, ..} => {\n+                if !path.segments.iter().all(|segment| segment.parameters.is_empty()) {\n+                    self.err_handler().span_err(path.span, \"type or lifetime parameters \\\n+                                                            in visibility path\");\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        visit::walk_vis(self, vis)\n+    }\n+}\n+\n+pub fn check_crate(session: &Session, krate: &Crate) {\n+    visit::walk_crate(&mut AstValidator { session: session }, krate)\n+}"}, {"sha": "918e17d21ea998e35ca91df67c1115bd564d70a9", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -143,6 +143,46 @@ fn some_func() {\n ```\n \"##,\n \n+E0449: r##\"\n+A visibility qualifier was used when it was unnecessary. Erroneous code\n+examples:\n+\n+```compile_fail\n+struct Bar;\n+\n+trait Foo {\n+    fn foo();\n+}\n+\n+pub impl Bar {} // error: unnecessary visibility qualifier\n+\n+pub impl Foo for Bar { // error: unnecessary visibility qualifier\n+    pub fn foo() {} // error: unnecessary visibility qualifier\n+}\n+```\n+\n+To fix this error, please remove the visibility qualifier when it is not\n+required. Example:\n+\n+```ignore\n+struct Bar;\n+\n+trait Foo {\n+    fn foo();\n+}\n+\n+// Directly implemented methods share the visibility of the type itself,\n+// so `pub` is unnecessary here\n+impl Bar {}\n+\n+// Trait methods share the visibility of the trait, so `pub` is\n+// unnecessary in either case\n+pub impl Foo for Bar {\n+    pub fn foo() {}\n+}\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {"}, {"sha": "1576ca6bdeaa4459359ef459dcf68f78e9248020", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -37,6 +37,7 @@ extern crate rustc_const_math;\n \n pub mod diagnostics;\n \n+pub mod ast_validation;\n pub mod consts;\n pub mod loops;\n pub mod no_asm;"}, {"sha": "ac33c23f023d81720ed72b2355dce230ad5ca658", "filename": "src/librustc_privacy/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibrustc_privacy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibrustc_privacy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2FCargo.toml?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -9,6 +9,5 @@ path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n-log = { path = \"../liblog\" }\n rustc = { path = \"../librustc\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "36ece929413dbd23668c8e002dc1276e825cf30e", "filename": "src/librustc_privacy/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibrustc_privacy%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibrustc_privacy%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Fdiagnostics.rs?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -115,46 +115,6 @@ pub enum Foo {\n ```\n \"##,\n \n-E0449: r##\"\n-A visibility qualifier was used when it was unnecessary. Erroneous code\n-examples:\n-\n-```compile_fail\n-struct Bar;\n-\n-trait Foo {\n-    fn foo();\n-}\n-\n-pub impl Bar {} // error: unnecessary visibility qualifier\n-\n-pub impl Foo for Bar { // error: unnecessary visibility qualifier\n-    pub fn foo() {} // error: unnecessary visibility qualifier\n-}\n-```\n-\n-To fix this error, please remove the visibility qualifier when it is not\n-required. Example:\n-\n-```ignore\n-struct Bar;\n-\n-trait Foo {\n-    fn foo();\n-}\n-\n-// Directly implemented methods share the visibility of the type itself,\n-// so `pub` is unnecessary here\n-impl Bar {}\n-\n-// Trait methods share the visibility of the trait, so `pub` is\n-// unnecessary in either case\n-pub impl Foo for Bar {\n-    pub fn foo() {}\n-}\n-```\n-\"##,\n-\n E0450: r##\"\n A tuple constructor was invoked while some of its fields are private. Erroneous\n code example:"}, {"sha": "7e76842a9f4a789251b3ee864cd98079ff9dfa8b", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 8, "deletions": 94, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -21,37 +21,26 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n \n-#[macro_use] extern crate log;\n+extern crate rustc;\n #[macro_use] extern crate syntax;\n \n-#[macro_use] extern crate rustc;\n-\n-use std::cmp;\n-use std::mem::replace;\n-\n+use rustc::dep_graph::DepNode;\n use rustc::hir::{self, PatKind};\n+use rustc::hir::def::{self, Def};\n+use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n-use rustc::dep_graph::DepNode;\n use rustc::lint;\n-use rustc::hir::def::{self, Def};\n-use rustc::hir::def_id::DefId;\n use rustc::middle::privacy::{AccessLevel, AccessLevels};\n use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::NodeSet;\n-use rustc::hir::map as ast_map;\n-\n use syntax::ast;\n use syntax::codemap::Span;\n \n-pub mod diagnostics;\n-\n-type Context<'a, 'tcx> = (&'a ty::MethodMap<'tcx>, &'a def::ExportMap);\n+use std::cmp;\n+use std::mem::replace;\n \n-/// Result of a checking operation - None => no errors were found. Some => an\n-/// error and contains the span and message for reporting that error and\n-/// optionally the same for a note about the error.\n-type CheckResult = Option<(Span, String, Option<(Span, String)>)>;\n+pub mod diagnostics;\n \n ////////////////////////////////////////////////////////////////////////////////\n /// The embargo visitor, used to determine the exports of the ast\n@@ -433,7 +422,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n                 let method = self.tcx.tables.borrow().method_map[&method_call];\n-                debug!(\"(privacy checking) checking impl method\");\n                 self.check_method(expr.span, method.def_id);\n             }\n             hir::ExprStruct(..) => {\n@@ -518,74 +506,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-/// The privacy sanity check visitor, ensures unnecessary visibility isn't here\n-////////////////////////////////////////////////////////////////////////////////\n-\n-struct SanePrivacyVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for SanePrivacyVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n-        self.check_sane_privacy(item);\n-        intravisit::walk_item(self, item);\n-    }\n-}\n-\n-impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n-    /// Validate that items that shouldn't have visibility qualifiers don't have them.\n-    /// Such qualifiers can be set by syntax extensions even if the parser doesn't allow them,\n-    /// so we check things like variant fields too.\n-    fn check_sane_privacy(&self, item: &hir::Item) {\n-        let check_inherited = |sp, vis: &hir::Visibility, note: &str| {\n-            if *vis != hir::Inherited {\n-                let mut err = struct_span_err!(self.tcx.sess, sp, E0449,\n-                                               \"unnecessary visibility qualifier\");\n-                if !note.is_empty() {\n-                    err.span_note(sp, note);\n-                }\n-                err.emit();\n-            }\n-        };\n-\n-        match item.node {\n-            hir::ItemImpl(_, _, _, Some(..), _, ref impl_items) => {\n-                check_inherited(item.span, &item.vis,\n-                                \"visibility qualifiers have no effect on trait impls\");\n-                for impl_item in impl_items {\n-                    check_inherited(impl_item.span, &impl_item.vis,\n-                                    \"visibility qualifiers have no effect on trait impl items\");\n-                }\n-            }\n-            hir::ItemImpl(_, _, _, None, _, _) => {\n-                check_inherited(item.span, &item.vis,\n-                                \"place qualifiers on individual methods instead\");\n-            }\n-            hir::ItemDefaultImpl(..) => {\n-                check_inherited(item.span, &item.vis,\n-                                \"visibility qualifiers have no effect on trait impls\");\n-            }\n-            hir::ItemForeignMod(..) => {\n-                check_inherited(item.span, &item.vis,\n-                                \"place qualifiers on individual functions instead\");\n-            }\n-            hir::ItemEnum(ref def, _) => {\n-                for variant in &def.variants {\n-                    for field in variant.node.data.fields() {\n-                        check_inherited(field.span, &field.vis,\n-                                        \"visibility qualifiers have no effect on variant fields\");\n-                    }\n-                }\n-            }\n-            hir::ItemStruct(..) | hir::ItemTrait(..) |\n-            hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemFn(..) |\n-            hir::ItemMod(..) | hir::ItemExternCrate(..) |\n-            hir::ItemUse(..) | hir::ItemTy(..) => {}\n-        }\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////////\n /// Obsolete visitors for checking for private items in public interfaces.\n /// These visitors are supposed to be kept in frozen state and produce an\n@@ -626,7 +546,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             // .. and it corresponds to a private type in the AST (this returns\n             // None for type parameters)\n             match self.tcx.map.find(node_id) {\n-                Some(ast_map::NodeItem(ref item)) => item.vis != hir::Public,\n+                Some(hir::map::NodeItem(ref item)) => item.vis != hir::Public,\n                 Some(_) | None => false,\n             }\n         } else {\n@@ -860,7 +780,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n         // any `visit_ty`'s will be called on things that are in\n         // public signatures, i.e. things that we're interested in for\n         // this visitor.\n-        debug!(\"VisiblePrivateTypesVisitor entering item {:?}\", item);\n         intravisit::walk_item(self, item);\n     }\n \n@@ -892,7 +811,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n     }\n \n     fn visit_ty(&mut self, t: &hir::Ty) {\n-        debug!(\"VisiblePrivateTypesVisitor checking ty {:?}\", t);\n         if let hir::TyPath(..) = t.node {\n             if self.path_is_private_type(t.id) {\n                 self.old_error_set.insert(t.id);\n@@ -1177,10 +1095,6 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let krate = tcx.map.krate();\n \n-    // Sanity check to make sure that all privacy usage is reasonable.\n-    let mut visitor = SanePrivacyVisitor { tcx: tcx };\n-    krate.visit_all_items(&mut visitor);\n-\n     // Use the parent map to check the privacy of everything\n     let mut visitor = PrivacyVisitor {\n         curitem: ast::DUMMY_NODE_ID,"}, {"sha": "c7b113689fde956a28fbfff64882d1bd3d6c3121", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 36, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -22,21 +22,20 @@ use Resolver;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n use rustc::middle::cstore::{ChildItem, DlDef};\n-use rustc::lint;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::ty::{self, VariantKind};\n \n-use syntax::ast::{Name, NodeId};\n+use syntax::ast::Name;\n use syntax::attr::AttrMetaMethods;\n-use syntax::parse::token::{self, keywords};\n+use syntax::parse::token;\n use syntax::codemap::{Span, DUMMY_SP};\n \n use syntax::ast::{Block, Crate, DeclKind};\n use syntax::ast::{ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, PathListItemKind};\n use syntax::ast::{Stmt, StmtKind, TraitItemKind};\n-use syntax::ast::{Variant, ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::visit::{self, Visitor};\n \n trait ToNameBinding<'a> {\n@@ -95,36 +94,6 @@ impl<'b> Resolver<'b> {\n         block.stmts.iter().any(is_item)\n     }\n \n-    fn sanity_check_import(&self, view_path: &ViewPath, id: NodeId) {\n-        let path = match view_path.node {\n-            ViewPathSimple(_, ref path) |\n-            ViewPathGlob (ref path) |\n-            ViewPathList(ref path, _) => path\n-        };\n-\n-        // Check for type parameters\n-        let found_param = path.segments.iter().any(|segment| {\n-            !segment.parameters.types().is_empty() ||\n-            !segment.parameters.lifetimes().is_empty() ||\n-            !segment.parameters.bindings().is_empty()\n-        });\n-        if found_param {\n-            self.session.span_err(path.span, \"type or lifetime parameters in import path\");\n-        }\n-\n-        // Checking for special identifiers in path\n-        // prevent `self` or `super` at beginning of global path\n-        if path.global && path.segments.len() > 0 {\n-            let first = path.segments[0].identifier.name;\n-            if first == keywords::Super.name() || first == keywords::SelfValue.name() {\n-                self.session.add_lint(\n-                    lint::builtin::SUPER_OR_SELF_IN_GLOBAL_PATH, id, path.span,\n-                    format!(\"expected identifier, found keyword `{}`\", first)\n-                );\n-            }\n-        }\n-    }\n-\n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &Item, parent_ref: &mut Module<'b>) {\n         let parent = *parent_ref;\n@@ -158,8 +127,6 @@ impl<'b> Resolver<'b> {\n                     }\n                 };\n \n-                self.sanity_check_import(view_path, item.id);\n-\n                 // Build up the import directives.\n                 let is_prelude = item.attrs.iter().any(|attr| attr.name() == \"prelude_import\");\n "}, {"sha": "40c98206c16e9f9e0cc0fe95f76e5841133160c6", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -1903,6 +1903,16 @@ pub enum ViewPath_ {\n     ViewPathList(Path, Vec<PathListItem>)\n }\n \n+impl ViewPath_ {\n+    pub fn path(&self) -> &Path {\n+        match *self {\n+            ViewPathSimple(_, ref path) |\n+            ViewPathGlob (ref path) |\n+            ViewPathList(ref path, _) => path\n+        }\n+    }\n+}\n+\n /// Meta-data associated with an item\n pub type Attribute = Spanned<Attribute_>;\n "}, {"sha": "c11347f5762ba1e129e892e06164f95652a0e90f", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -956,22 +956,6 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n         visit::walk_item(self, i);\n     }\n \n-    fn visit_variant_data(&mut self, s: &'v ast::VariantData, _: ast::Ident,\n-                          _: &'v ast::Generics, _: ast::NodeId, span: Span) {\n-        if s.fields().is_empty() {\n-            if s.is_tuple() {\n-                self.context.span_handler.struct_span_err(span, \"empty tuple structs and enum \\\n-                                                                 variants are not allowed, use \\\n-                                                                 unit structs and enum variants \\\n-                                                                 instead\")\n-                                         .span_help(span, \"remove trailing `()` to make a unit \\\n-                                                           struct or unit enum variant\")\n-                                         .emit();\n-            }\n-        }\n-        visit::walk_struct_def(self, s)\n-    }\n-\n     fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n         let links_to_llvm = match attr::first_attr_value_str_by_name(&i.attrs,\n                                                                      \"link_name\") {\n@@ -1142,22 +1126,12 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     fn visit_vis(&mut self, vis: &'v ast::Visibility) {\n         let span = match *vis {\n             ast::Visibility::Crate(span) => span,\n-            ast::Visibility::Restricted { ref path, .. } => {\n-                // Check for type parameters\n-                let found_param = path.segments.iter().any(|segment| {\n-                    !segment.parameters.types().is_empty() ||\n-                    !segment.parameters.lifetimes().is_empty() ||\n-                    !segment.parameters.bindings().is_empty()\n-                });\n-                if found_param {\n-                    self.context.span_handler.span_err(path.span, \"type or lifetime parameters \\\n-                                                                   in visibility path\");\n-                }\n-                path.span\n-            }\n+            ast::Visibility::Restricted { ref path, .. } => path.span,\n             _ => return,\n         };\n         gate_feature_post!(&self, pub_restricted, span, \"`pub(restricted)` syntax is experimental\");\n+\n+        visit::walk_vis(self, vis)\n     }\n }\n "}, {"sha": "931f90a239421b02d841db0ca3c7f1e34f764b32", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -246,7 +246,6 @@ dependencies = [\n name = \"rustc_privacy\"\n version = \"0.0.0\"\n dependencies = [\n- \"log 0.0.0\",\n  \"rustc 0.0.0\",\n  \"syntax 0.0.0\",\n ]"}, {"sha": "80f551ebd1f7c9b2962db0c6df0cfc6fa7bcecf2", "filename": "src/test/compile-fail/issue-12560-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Ftest%2Fcompile-fail%2Fissue-12560-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Ftest%2Fcompile-fail%2Fissue-12560-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12560-1.rs?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -21,5 +21,5 @@ enum Foo {\n }\n \n fn main() {\n-    println!(\"{}\", match Bar { Bar => 1, Baz => 2, Bazar => 3 })\n+    println!(\"{}\", match Bar { Bar => 1, Baz => 2, Bazar => 3 }) //~ ERROR unresolved name `Bar`\n }"}, {"sha": "bc09f61a754c2b081a04986205105bc4764c5cf3", "filename": "src/test/compile-fail/issue-29161.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Ftest%2Fcompile-fail%2Fissue-29161.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Ftest%2Fcompile-fail%2Fissue-29161.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-29161.rs?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -12,7 +12,7 @@ mod a {\n     struct A;\n \n     impl Default for A {\n-        pub fn default() -> A {\n+        pub fn default() -> A { //~ ERROR unnecessary visibility qualifier\n             A;\n         }\n     }"}, {"sha": "a0fb25ea06eac2546f697e3c82221d8569c78a55", "filename": "src/test/compile-fail/label-static.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Ftest%2Fcompile-fail%2Flabel-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Ftest%2Fcompile-fail%2Flabel-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flabel-static.rs?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    'static: loop { //~ ERROR invalid label name `'static`\n+        break 'static //~ ERROR invalid label name `'static`\n+    }\n+}"}, {"sha": "102d3576e5467922bb8afb530b8d8c197f3300df", "filename": "src/test/compile-fail/lifetime-underscore.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Ftest%2Fcompile-fail%2Flifetime-underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Ftest%2Fcompile-fail%2Flifetime-underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-underscore.rs?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(lifetime_underscore)]\n+\n+fn _f<'_>() //~ ERROR invalid lifetime name `'_`\n+//~^ WARN this was previously accepted\n+    -> &'_ u8 //~ ERROR invalid lifetime name `'_`\n+    //~^ WARN this was previously accepted\n+{\n+    panic!();\n+}\n+\n+fn main() {\n+    '_: loop { //~ ERROR invalid label name `'_`\n+    //~^ WARN this was previously accepted\n+        break '_ //~ ERROR invalid label name `'_`\n+        //~^ WARN this was previously accepted\n+    }\n+}"}, {"sha": "8901d8c08e50cef5e5375d001964b38a1eaab6cb", "filename": "src/test/compile-fail/priv-in-bad-locations.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Ftest%2Fcompile-fail%2Fpriv-in-bad-locations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Ftest%2Fcompile-fail%2Fpriv-in-bad-locations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpriv-in-bad-locations.rs?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub extern {\n-    //~^ ERROR unnecessary visibility\n+pub extern { //~ ERROR unnecessary visibility qualifier\n     pub fn bar();\n }\n \n@@ -19,10 +18,10 @@ trait A {\n \n struct B;\n \n-pub impl B {} //~ ERROR: unnecessary visibility\n+pub impl B {} //~ ERROR unnecessary visibility qualifier\n \n-pub impl A for B { //~ ERROR: unnecessary visibility\n-    pub fn foo(&self) {} //~ ERROR: unnecessary visibility\n+pub impl A for B { //~ ERROR unnecessary visibility qualifier\n+    pub fn foo(&self) {} //~ ERROR unnecessary visibility qualifier\n }\n \n pub fn main() {}"}, {"sha": "ae60c4366ee33521583cac84de334014064e3e92", "filename": "src/test/compile-fail/privacy/restricted/ty-params.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Fty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Fty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Fty-params.rs?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -16,9 +16,11 @@ macro_rules! m {\n \n struct S<T>(T);\n m!{ S<u8> } //~ ERROR type or lifetime parameters in visibility path\n+//~^ ERROR failed to resolve module path. Not a module `S`\n \n mod foo {\n     struct S(pub(foo<T>) ()); //~ ERROR type or lifetime parameters in visibility path\n+    //~^ ERROR type name `T` is undefined or not in scope\n }\n \n fn main() {}"}, {"sha": "1d0d60a775fda7d02699ee2bcf682ea72a1fa92b", "filename": "src/test/compile-fail/use-super-global-path.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Ftest%2Fcompile-fail%2Fuse-super-global-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Ftest%2Fcompile-fail%2Fuse-super-global-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-super-global-path.rs?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -9,10 +9,17 @@\n // except according to those terms.\n \n #![feature(rustc_attrs)]\n+#![allow(unused_imports, dead_code)]\n+\n+struct S;\n+struct Z;\n \n mod foo {\n+    use ::super::{S, Z}; //~ WARN global paths cannot start with `super`\n+    //~^ WARN this was previously accepted by the compiler but is being phased out\n+\n     pub fn g() {\n-        use ::super::main; //~ WARN expected identifier, found keyword `super`\n+        use ::super::main; //~ WARN global paths cannot start with `super`\n         //~^ WARN this was previously accepted by the compiler but is being phased out\n         main();\n     }"}, {"sha": "064062df753b6761b5bf7557355e381e975fef05", "filename": "src/test/compile-fail/useless-pub.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Ftest%2Fcompile-fail%2Fuseless-pub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cab1fd58d6373582da189bd2c20ed3f6a7042a/src%2Ftest%2Fcompile-fail%2Fuseless-pub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuseless-pub.rs?ref=c2cab1fd58d6373582da189bd2c20ed3f6a7042a", "patch": "@@ -15,14 +15,12 @@ pub trait E {\n }\n \n impl E for A {\n-    pub fn foo(&self) {}             //~ ERROR: unnecessary visibility\n+    pub fn foo(&self) {} //~ ERROR: unnecessary visibility qualifier\n }\n \n enum Foo {\n     V1 { pub f: i32 }, //~ ERROR unnecessary visibility qualifier\n-                       //| NOTE visibility qualifiers have no effect on variant fields\n     V2(pub i32), //~ ERROR unnecessary visibility qualifier\n-                 //| NOTE visibility qualifiers have no effect on variant fields\n }\n \n fn main() {}"}]}