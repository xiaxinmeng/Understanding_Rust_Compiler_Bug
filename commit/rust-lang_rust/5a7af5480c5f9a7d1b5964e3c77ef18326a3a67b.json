{"sha": "5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhN2FmNTQ4MGM1ZjlhN2QxYjU5NjRlM2M3N2VmMTgzMjZhM2E2N2I=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-04-02T23:04:51Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-04-25T17:28:09Z"}, "message": "Support variantful generators\n\nThis allows generators to overlap fields using variants.", "tree": {"sha": "af664ff51a4d7189ac0522668c8eb283ccc2847e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af664ff51a4d7189ac0522668c8eb283ccc2847e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b", "html_url": "https://github.com/rust-lang/rust/commit/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4de2d8a86909cec4279c4054790c62c66ca033d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4de2d8a86909cec4279c4054790c62c66ca033d7", "html_url": "https://github.com/rust-lang/rust/commit/4de2d8a86909cec4279c4054790c62c66ca033d7"}], "stats": {"total": 436, "additions": 281, "deletions": 155}, "files": [{"sha": "79e143b5c24a58609df47bfd40cdf4703f3ea09e", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b", "patch": "@@ -2028,6 +2028,10 @@ impl<'tcx> Place<'tcx> {\n             variant_index))\n     }\n \n+    pub fn downcast_unnamed(self, variant_index: VariantIdx) -> Place<'tcx> {\n+        self.elem(ProjectionElem::Downcast(None, variant_index))\n+    }\n+\n     pub fn index(self, index: Local) -> Place<'tcx> {\n         self.elem(ProjectionElem::Index(index))\n     }\n@@ -2553,11 +2557,6 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                                     let var_name = tcx.hir().name_by_hir_id(freevar.var_id());\n                                     struct_fmt.field(&var_name.as_str(), place);\n                                 }\n-                                struct_fmt.field(\"$state\", &places[freevars.len()]);\n-                                for i in (freevars.len() + 1)..places.len() {\n-                                    struct_fmt\n-                                        .field(&format!(\"${}\", i - freevars.len() - 1), &places[i]);\n-                                }\n                             });\n \n                             struct_fmt.finish()"}, {"sha": "199ee3e04b32adfd45c8aef7e97ebfc958c00130", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b", "patch": "@@ -177,11 +177,13 @@ impl<'tcx> Rvalue<'tcx> {\n             }\n             Rvalue::Discriminant(ref place) => {\n                 let ty = place.ty(local_decls, tcx).ty;\n-                if let ty::Adt(adt_def, _) = ty.sty {\n-                    adt_def.repr.discr_type().to_ty(tcx)\n-                } else {\n-                    // This can only be `0`, for now, so `u8` will suffice.\n-                    tcx.types.u8\n+                match ty.sty {\n+                    ty::Adt(adt_def, _) => adt_def.repr.discr_type().to_ty(tcx),\n+                    ty::Generator(_, substs, _) => substs.discr_ty(tcx),\n+                    _ => {\n+                        // This can only be `0`, for now, so `u8` will suffice.\n+                        tcx.types.u8\n+                    }\n                 }\n             }\n             Rvalue::NullaryOp(NullOp::Box, t) => tcx.mk_box(t),"}, {"sha": "10afaebc91a9186867d60a18b476279ef11eb62e", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 71, "deletions": 10, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b", "patch": "@@ -604,12 +604,57 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 tcx.intern_layout(unit)\n             }\n \n-            // Tuples, generators and closures.\n             ty::Generator(def_id, ref substs, _) => {\n-                let tys = substs.field_tys(def_id, tcx);\n-                univariant(&tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n+                let discr_index = substs.prefix_tys(def_id, tcx).count();\n+                let prefix_tys = substs.prefix_tys(def_id, tcx)\n+                    .chain(iter::once(substs.discr_ty(tcx)));\n+                let prefix = univariant_uninterned(\n+                    &prefix_tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(),\n-                    StructKind::AlwaysSized)?\n+                    StructKind::AlwaysSized)?;\n+\n+                let mut size = prefix.size;\n+                let mut align = prefix.align;\n+                let variants_tys = substs.state_tys(def_id, tcx);\n+                let variants = variants_tys.enumerate().map(|(i, variant_tys)| {\n+                    let mut variant = univariant_uninterned(\n+                        &variant_tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n+                        &ReprOptions::default(),\n+                        StructKind::Prefixed(prefix.size, prefix.align.abi))?;\n+\n+                    variant.variants = Variants::Single { index: VariantIdx::new(i) };\n+\n+                    size = size.max(variant.size);\n+                    align = align.max(variant.align);\n+\n+                    Ok(variant)\n+                }).collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n+\n+                let abi = if prefix.abi.is_uninhabited() ||\n+                             variants.iter().all(|v| v.abi.is_uninhabited()) {\n+                    Abi::Uninhabited\n+                } else {\n+                    Abi::Aggregate { sized: true }\n+                };\n+                let discr = match &self.layout_of(substs.discr_ty(tcx))?.abi {\n+                    Abi::Scalar(s) => s.clone(),\n+                    _ => bug!(),\n+                };\n+\n+                let layout = tcx.intern_layout(LayoutDetails {\n+                    variants: Variants::Multiple {\n+                        discr,\n+                        discr_kind: DiscriminantKind::Tag,\n+                        discr_index,\n+                        variants,\n+                    },\n+                    fields: prefix.fields,\n+                    abi,\n+                    size,\n+                    align,\n+                });\n+                debug!(\"generator layout: {:#?}\", layout);\n+                layout\n             }\n \n             ty::Closure(def_id, ref substs) => {\n@@ -1646,6 +1691,14 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n \n     fn field(this: TyLayout<'tcx>, cx: &C, i: usize) -> C::TyLayout {\n         let tcx = cx.tcx();\n+        let handle_discriminant = |discr: &Scalar| -> C::TyLayout {\n+            let layout = LayoutDetails::scalar(cx, discr.clone());\n+            MaybeResult::from_ok(TyLayout {\n+                details: tcx.intern_layout(layout),\n+                ty: discr.value.to_ty(tcx)\n+            })\n+        };\n+\n         cx.layout_of(match this.ty.sty {\n             ty::Bool |\n             ty::Char |\n@@ -1720,7 +1773,19 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n             }\n \n             ty::Generator(def_id, ref substs, _) => {\n-                substs.field_tys(def_id, tcx).nth(i).unwrap()\n+                match this.variants {\n+                    Variants::Single { index } => {\n+                        substs.state_tys(def_id, tcx)\n+                            .nth(index.as_usize()).unwrap()\n+                            .nth(i).unwrap()\n+                    }\n+                    Variants::Multiple { ref discr, discr_index, .. } => {\n+                        if i == discr_index {\n+                            return handle_discriminant(discr);\n+                        }\n+                        substs.prefix_tys(def_id, tcx).nth(i).unwrap()\n+                    }\n+                }\n             }\n \n             ty::Tuple(tys) => tys[i],\n@@ -1740,11 +1805,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                     // Discriminant field for enums (where applicable).\n                     Variants::Multiple { ref discr, .. } => {\n                         assert_eq!(i, 0);\n-                        let layout = LayoutDetails::scalar(cx, discr.clone());\n-                        return MaybeResult::from_ok(TyLayout {\n-                            details: tcx.intern_layout(layout),\n-                            ty: discr.value.to_ty(tcx)\n-                        });\n+                        return handle_discriminant(discr);\n                     }\n                 }\n             }"}, {"sha": "842e49dfc0865d6c409d65e2545119263ad108b2", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b", "patch": "@@ -15,7 +15,6 @@ use crate::util::captures::Captures;\n use crate::mir::interpret::{Scalar, Pointer};\n \n use smallvec::SmallVec;\n-use std::iter;\n use std::cmp::Ordering;\n use std::marker::PhantomData;\n use rustc_target::spec::abi;\n@@ -475,30 +474,23 @@ impl<'a, 'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     /// This returns the types of the MIR locals which had to be stored across suspension points.\n     /// It is calculated in rustc_mir::transform::generator::StateTransform.\n     /// All the types here must be in the tuple in GeneratorInterior.\n+    ///\n+    /// The locals are grouped by their variant number. Note that some locals may\n+    /// be repeated in multiple variants.\n     pub fn state_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n-        impl Iterator<Item=Ty<'tcx>> + Captures<'gcx> + 'a\n+        impl Iterator<Item=impl Iterator<Item=Ty<'tcx>> + Captures<'gcx> + 'a>\n     {\n-        // TODO remove so we can handle variants properly\n         tcx.generator_layout(def_id)\n-            .variant_fields[0].iter()\n-            .map(move |d| d.ty.subst(tcx, self.substs))\n+            .variant_fields.iter()\n+            .map(move |v| v.iter().map(move |d| d.ty.subst(tcx, self.substs)))\n     }\n \n-    /// This is the types of the fields of a generator which\n-    /// is available before the generator transformation.\n-    /// It includes the upvars and the state discriminant.\n-    pub fn pre_transforms_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n+    /// This is the types of the fields of a generator which are not stored in a\n+    /// variant.\n+    pub fn prefix_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n         impl Iterator<Item=Ty<'tcx>> + 'a\n     {\n-        self.upvar_tys(def_id, tcx).chain(iter::once(self.discr_ty(tcx)))\n-    }\n-\n-    /// This is the types of all the fields stored in a generator.\n-    /// It includes the upvars, state types and the state discriminant.\n-    pub fn field_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n-        impl Iterator<Item=Ty<'tcx>> + Captures<'gcx> + 'a\n-    {\n-        self.pre_transforms_tys(def_id, tcx).chain(self.state_tys(def_id, tcx))\n+        self.upvar_tys(def_id, tcx)\n     }\n }\n "}, {"sha": "bbcd3c220d67cf12dc3dc3a9fd019577e8029b1c", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b", "patch": "@@ -691,9 +691,12 @@ pub fn type_metadata(\n                                    usage_site_span).finalize(cx)\n         }\n         ty::Generator(def_id, substs,  _) => {\n-            let upvar_tys : Vec<_> = substs.field_tys(def_id, cx.tcx).map(|t| {\n+            // TODO handle variant fields\n+            let upvar_tys : Vec<_> = substs.prefix_tys(def_id, cx.tcx).map(|t| {\n                 cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t)\n             }).collect();\n+            // TODO use prepare_enum_metadata and update it to handle multiple\n+            // fields in the outer layout.\n             prepare_tuple_metadata(cx,\n                                    t,\n                                    &upvar_tys,\n@@ -1818,6 +1821,7 @@ fn prepare_enum_metadata(\n     };\n \n     // The variant part must be wrapped in a struct according to DWARF.\n+    // TODO create remaining fields here, if any.\n     let type_array = create_DIArray(DIB(cx), &[Some(variant_part)]);\n     let struct_wrapper = unsafe {\n         llvm::LLVMRustDIBuilderCreateStructType("}, {"sha": "080f78ff112adcff3bc1c85d1168716a26afc776", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b", "patch": "@@ -63,6 +63,11 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                     write!(&mut name, \"::{}\", def.variants[index].ident).unwrap();\n                 }\n             }\n+            if let (&ty::Generator(..), &layout::Variants::Single { index })\n+                 = (&layout.ty.sty, &layout.variants)\n+            {\n+                write!(&mut name, \"::variant#{:?}\", index).unwrap();\n+            }\n             Some(name)\n         }\n         _ => None"}, {"sha": "52429294852e2202369e6bf6e970963440cbbbe5", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b", "patch": "@@ -4,6 +4,7 @@ use rustc::mir::{self, Mir};\n use rustc::session::config::DebugInfo;\n use rustc_mir::monomorphize::Instance;\n use rustc_target::abi::call::{FnType, PassMode, IgnoreMode};\n+use rustc_target::abi::{Variants, VariantIdx};\n use crate::base;\n use crate::debuginfo::{self, VariableAccess, VariableKind, FunctionDebugContext};\n use crate::traits::*;\n@@ -648,7 +649,7 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n                     .iter()\n                     .zip(upvar_tys)\n                     .enumerate()\n-                    .map(|(i, (upvar, ty))| (i, upvar.debug_name, upvar.by_ref, ty));\n+                    .map(|(i, (upvar, ty))| (None, i, upvar.debug_name, upvar.by_ref, ty));\n \n                 let generator_fields = mir.generator_layout.as_ref().map(|generator_layout| {\n                     let (def_id, gen_substs) = match closure_layout.ty.sty {\n@@ -658,23 +659,39 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n                     // TODO handle variant scopes here\n                     let state_tys = gen_substs.state_tys(def_id, tcx);\n \n-                    // TODO remove assumption of only one variant\n-                    let upvar_count = mir.upvar_decls.len();\n-                    generator_layout.variant_fields[0]\n-                        .iter()\n+                    generator_layout.variant_fields.iter()\n                         .zip(state_tys)\n                         .enumerate()\n-                        .filter_map(move |(i, (decl, ty))| {\n-                            let ty = fx.monomorphize(&ty);\n-                            decl.name.map(|name| (i + upvar_count + 1, name, false, ty))\n+                        .flat_map(move |(variant_idx, (decls, tys))| {\n+                            let variant_idx = Some(VariantIdx::from(variant_idx));\n+                            decls.iter()\n+                                .zip(tys)\n+                                .enumerate()\n+                                .filter_map(move |(i, (decl, ty))| {\n+                                    let ty = fx.monomorphize(&ty);\n+                                    decl.name.map(|name| {\n+                                        (variant_idx, i, name, false, ty)\n+                                })\n+                            })\n                         })\n                 }).into_iter().flatten();\n \n                 upvars.chain(generator_fields)\n             };\n \n-            for (field, name, by_ref, ty) in extra_locals {\n-                let byte_offset_of_var_in_env = closure_layout.fields.offset(field).bytes();\n+            for (variant_idx, field, name, by_ref, ty) in extra_locals {\n+                let fields = match variant_idx {\n+                    Some(variant_idx) => {\n+                        match &closure_layout.variants {\n+                            Variants::Multiple { variants, .. } => {\n+                                &variants[variant_idx].fields\n+                            },\n+                            _ => bug!(\"variant index on univariant layout\"),\n+                        }\n+                    }\n+                    None => &closure_layout.fields,\n+                };\n+                let byte_offset_of_var_in_env = fields.offset(field).bytes();\n \n                 let ops = bx.debuginfo_upvar_ops_sequence(byte_offset_of_var_in_env);\n "}, {"sha": "2875468127e812ec1c1a76e56b19d3f00c2522d1", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b", "patch": "@@ -296,9 +296,15 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n                 ..\n             } => {\n                 let ptr = self.project_field(bx, discr_index);\n-                let to = self.layout.ty.ty_adt_def().unwrap()\n-                    .discriminant_for_variant(bx.tcx(), variant_index)\n-                    .val;\n+                let to = match self.layout.ty.sty {\n+                    ty::TyKind::Adt(adt_def, _) => adt_def\n+                        .discriminant_for_variant(bx.tcx(), variant_index)\n+                        .val,\n+                    // Generators don't support explicit discriminant values, so\n+                    // they are the same as the variant index.\n+                    ty::TyKind::Generator(..) => variant_index.as_u32() as u128,\n+                    _ => bug!(),\n+                };\n                 bx.store(\n                     bx.cx().const_uint_big(bx.cx().backend_type(ptr.layout), to),\n                     ptr.llval,"}, {"sha": "94900b98a52d5659dba7d2ba0bbf924e21bcd4ef", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 51, "deletions": 26, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b", "patch": "@@ -684,6 +684,25 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         }\n                     }\n                 }\n+                ty::Generator(def_id, substs, _) => {\n+                    let variants = substs.state_tys(def_id, tcx).count();\n+                    if index.as_usize() >= variants {\n+                        PlaceTy::from_ty(\n+                            span_mirbug_and_err!(\n+                                self,\n+                                place,\n+                                \"cast to variant #{:?} but generator only has {:?}\",\n+                                index,\n+                                variants\n+                            ),\n+                        )\n+                    } else {\n+                        PlaceTy {\n+                            ty: base_ty,\n+                            variant_index: Some(index),\n+                        }\n+                    }\n+                }\n                 _ => {\n                     let ty = if let Some(name) = maybe_name {\n                         span_mirbug_and_err!(\n@@ -745,11 +764,26 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         let tcx = self.tcx();\n \n         let (variant, substs) = match base_ty {\n-            PlaceTy { ty, variant_index: Some(variant_index) } => {\n-                match ty.sty {\n-                    ty::Adt(adt_def, substs) => (&adt_def.variants[variant_index], substs),\n-                    _ => bug!(\"can't have downcast of non-adt type\"),\n+            PlaceTy { ty, variant_index: Some(variant_index) } => match ty.sty {\n+                ty::Adt(adt_def, substs) => (&adt_def.variants[variant_index], substs),\n+                ty::Generator(def_id, substs, _) => {\n+                    let mut variants = substs.state_tys(def_id, tcx);\n+                    let mut variant = match variants.nth(variant_index.into()) {\n+                        Some(v) => v,\n+                        None => {\n+                            bug!(\"variant_index of generator out of range: {:?}/{:?}\",\n+                                 variant_index,\n+                                 substs.state_tys(def_id, tcx).count())\n+                        }\n+                    };\n+                    return match variant.nth(field.index()) {\n+                        Some(ty) => Ok(ty),\n+                        None => Err(FieldAccessError::OutOfRange {\n+                            field_count: variant.count(),\n+                        }),\n+                    }\n                 }\n+                _ => bug!(\"can't have downcast of non-adt non-generator type\"),\n             }\n             PlaceTy { ty, variant_index: None } => match ty.sty {\n                 ty::Adt(adt_def, substs) if !adt_def.is_enum() =>\n@@ -763,19 +797,14 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     }\n                 }\n                 ty::Generator(def_id, substs, _) => {\n-                    // Try pre-transform fields first (upvars and current state)\n-                    if let Some(ty) = substs.pre_transforms_tys(def_id, tcx).nth(field.index()) {\n-                        return Ok(ty);\n-                    }\n-\n-                    // Then try `field_tys` which contains all the fields, but it\n-                    // requires the final optimized MIR.\n-                    return match substs.field_tys(def_id, tcx).nth(field.index()) {\n+                    // Only prefix fields (upvars and current state) are\n+                    // accessible without a variant index.\n+                    return match substs.prefix_tys(def_id, tcx).nth(field.index()) {\n                         Some(ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n-                            field_count: substs.field_tys(def_id, tcx).count(),\n+                            field_count: substs.prefix_tys(def_id, tcx).count(),\n                         }),\n-                    };\n+                    }\n                 }\n                 ty::Tuple(tys) => {\n                     return match tys.get(field.index()) {\n@@ -1908,18 +1937,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n             }\n             AggregateKind::Generator(def_id, substs, _) => {\n-                // Try pre-transform fields first (upvars and current state)\n-                if let Some(ty) = substs.pre_transforms_tys(def_id, tcx).nth(field_index) {\n-                    Ok(ty)\n-                } else {\n-                    // Then try `field_tys` which contains all the fields, but it\n-                    // requires the final optimized MIR.\n-                    match substs.field_tys(def_id, tcx).nth(field_index) {\n-                        Some(ty) => Ok(ty),\n-                        None => Err(FieldAccessError::OutOfRange {\n-                            field_count: substs.field_tys(def_id, tcx).count(),\n-                        }),\n-                    }\n+                // It doesn't make sense to look at a field beyond the prefix;\n+                // these require a variant index, and are not initialized in\n+                // aggregate rvalues.\n+                match substs.prefix_tys(def_id, tcx).nth(field_index) {\n+                    Some(ty) => Ok(ty),\n+                    None => Err(FieldAccessError::OutOfRange {\n+                        field_count: substs.prefix_tys(def_id, tcx).count(),\n+                    }),\n                 }\n             }\n             AggregateKind::Array(ty) => Ok(ty),"}, {"sha": "201bc4a43e4a4dcc6020d06557350204647d51e8", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b", "patch": "@@ -211,7 +211,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 movability,\n             } => {\n                 // see (*) above\n-                let mut operands: Vec<_> = upvars\n+                let operands: Vec<_> = upvars\n                     .into_iter()\n                     .map(|upvar| {\n                         let upvar = this.hir.mirror(upvar);\n@@ -252,22 +252,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }).collect();\n                 let result = match substs {\n                     UpvarSubsts::Generator(substs) => {\n+                        // We implicitly set the discriminant to 0. See\n+                        // librustc_mir/transform/deaggregator.rs for details.\n                         let movability = movability.unwrap();\n-                        // Add the state operand since it follows the upvars in the generator\n-                        // struct. See librustc_mir/transform/generator.rs for more details.\n-                        let discr_ty = substs.discr_ty(this.hir.tcx());\n-                        operands.push(Operand::Constant(box Constant {\n-                            span: expr_span,\n-                            ty: discr_ty,\n-                            user_ty: None,\n-                            literal: this.hir.tcx().mk_const(\n-                                ty::Const::from_bits(\n-                                    this.hir.tcx(),\n-                                    0,\n-                                    ty::ParamEnv::empty().and(discr_ty),\n-                                ),\n-                            ),\n-                        }));\n                         box AggregateKind::Generator(closure_id, substs, movability)\n                     }\n                     UpvarSubsts::Closure(substs) => box AggregateKind::Closure(closure_id, substs),"}, {"sha": "9f8d40bf4cdd5e191626270f22e4c21778c22098", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b", "patch": "@@ -1,5 +1,6 @@\n-use rustc::ty::TyCtxt;\n use rustc::mir::*;\n+use rustc::ty::TyCtxt;\n+use rustc::ty::layout::VariantIdx;\n use rustc_data_structures::indexed_vec::Idx;\n use crate::transform::{MirPass, MirSource};\n \n@@ -55,6 +56,23 @@ impl MirPass for Deaggregator {\n                         }\n                         active_field_index\n                     }\n+                    AggregateKind::Generator(..) => {\n+                        // Right now we only support initializing generators to\n+                        // variant#0.\n+                        let variant_index = VariantIdx::new(0);\n+                        set_discriminant = Some(Statement {\n+                            kind: StatementKind::SetDiscriminant {\n+                                place: lhs.clone(),\n+                                variant_index,\n+                            },\n+                            source_info,\n+                        });\n+\n+                        // Operands are upvars stored on the base place, so no\n+                        // downcast is necessary.\n+\n+                        None\n+                    }\n                     _ => None\n                 };\n "}, {"sha": "b7c4bfd5126e88095abd5ebf2650d85ece1ee96e", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 68, "deletions": 59, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b", "patch": "@@ -60,7 +60,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::bit_set::BitSet;\n use std::borrow::Cow;\n-use std::iter::once;\n+use std::iter;\n use std::mem;\n use crate::transform::{MirPass, MirSource};\n use crate::transform::simplify;\n@@ -145,14 +145,14 @@ fn self_arg() -> Local {\n }\n \n /// Generator have not been resumed yet\n-const UNRESUMED: u32 = 0;\n+const UNRESUMED: usize = 0;\n /// Generator has returned / is completed\n-const RETURNED: u32 = 1;\n+const RETURNED: usize = 1;\n /// Generator has been poisoned\n-const POISONED: u32 = 2;\n+const POISONED: usize = 2;\n \n struct SuspensionPoint {\n-    state: u32,\n+    state: usize,\n     resume: BasicBlock,\n     drop: Option<BasicBlock>,\n     storage_liveness: liveness::LiveVarSet,\n@@ -163,15 +163,12 @@ struct TransformVisitor<'a, 'tcx: 'a> {\n     state_adt_ref: &'tcx AdtDef,\n     state_substs: SubstsRef<'tcx>,\n \n-    // The index of the generator state in the generator struct\n-    state_field: usize,\n-\n-    // The type of the generator state in the generator struct\n+    // The type of the discriminant in the generator struct\n     discr_ty: Ty<'tcx>,\n \n     // Mapping from Local to (type of local, generator struct index)\n     // FIXME(eddyb) This should use `IndexVec<Local, Option<_>>`.\n-    remap: FxHashMap<Local, (Ty<'tcx>, usize)>,\n+    remap: FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n \n     // A map from a suspension point in a block to the locals which have live storage at that point\n     // FIXME(eddyb) This should use `IndexVec<BasicBlock, Option<_>>`.\n@@ -192,33 +189,38 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n     }\n \n     // Create a Place referencing a generator struct field\n-    fn make_field(&self, idx: usize, ty: Ty<'tcx>) -> Place<'tcx> {\n-        let base = Place::Base(PlaceBase::Local(self_arg()));\n+    fn make_field(&self, variant_index: VariantIdx, idx: usize, ty: Ty<'tcx>) -> Place<'tcx> {\n+        let self_place = Place::Base(PlaceBase::Local(self_arg()));\n+        let base = self_place.downcast_unnamed(variant_index);\n         let field = Projection {\n             base: base,\n             elem: ProjectionElem::Field(Field::new(idx), ty),\n         };\n         Place::Projection(Box::new(field))\n     }\n \n-    // Create a statement which changes the generator state\n-    fn set_state(&self, state_disc: u32, source_info: SourceInfo) -> Statement<'tcx> {\n-        let state = self.make_field(self.state_field, self.discr_ty);\n-        let val = Operand::Constant(box Constant {\n-            span: source_info.span,\n-            ty: self.discr_ty,\n-            user_ty: None,\n-            literal: self.tcx.mk_const(ty::Const::from_bits(\n-                self.tcx,\n-                state_disc.into(),\n-                ty::ParamEnv::empty().and(self.discr_ty)\n-            )),\n-        });\n+    // Create a statement which changes the discriminant\n+    fn set_discr(&self, state_disc: VariantIdx, source_info: SourceInfo) -> Statement<'tcx> {\n+        let self_place = Place::Base(PlaceBase::Local(self_arg()));\n         Statement {\n             source_info,\n-            kind: StatementKind::Assign(state, box Rvalue::Use(val)),\n+            kind: StatementKind::SetDiscriminant { place: self_place, variant_index: state_disc },\n         }\n     }\n+\n+    // Create a statement which reads the discriminant into a temporary\n+    fn get_discr(&self, mir: &mut Mir<'tcx>) -> (Statement<'tcx>, Place<'tcx>) {\n+        let temp_decl = LocalDecl::new_internal(self.tcx.types.isize, mir.span);\n+        let temp = Place::Base(PlaceBase::Local(Local::new(mir.local_decls.len())));\n+        mir.local_decls.push(temp_decl);\n+\n+        let self_place = Place::Base(PlaceBase::Local(self_arg()));\n+        let assign = Statement {\n+            source_info: source_info(mir),\n+            kind: StatementKind::Assign(temp.clone(), box Rvalue::Discriminant(self_place)),\n+        };\n+        (assign, temp)\n+    }\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n@@ -235,8 +237,8 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n                     location: Location) {\n         if let Place::Base(PlaceBase::Local(l)) = *place {\n             // Replace an Local in the remap with a generator struct access\n-            if let Some(&(ty, idx)) = self.remap.get(&l) {\n-                *place = self.make_field(idx, ty);\n+            if let Some(&(ty, variant_index, idx)) = self.remap.get(&l) {\n+                *place = self.make_field(variant_index, idx, ty);\n             }\n         } else {\n             self.super_place(place, context, location);\n@@ -277,7 +279,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n                                             box self.make_state(state_idx, v)),\n             });\n             let state = if let Some(resume) = resume { // Yield\n-                let state = 3 + self.suspension_points.len() as u32;\n+                let state = 3 + self.suspension_points.len();\n \n                 self.suspension_points.push(SuspensionPoint {\n                     state,\n@@ -286,11 +288,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n                     storage_liveness: self.storage_liveness.get(&block).unwrap().clone(),\n                 });\n \n-                state\n+                VariantIdx::new(state)\n             } else { // Return\n-                RETURNED // state for returned\n+                VariantIdx::new(RETURNED) // state for returned\n             };\n-            data.statements.push(self.set_state(state, source_info));\n+            data.statements.push(self.set_discr(state, source_info));\n             data.terminator.as_mut().unwrap().kind = TerminatorKind::Return;\n         }\n \n@@ -391,6 +393,7 @@ fn locals_live_across_suspend_points(\n ) -> (\n     liveness::LiveVarSet,\n     FxHashMap<BasicBlock, liveness::LiveVarSet>,\n+    BitSet<BasicBlock>,\n ) {\n     let dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n     let def_id = source.def_id();\n@@ -435,8 +438,12 @@ fn locals_live_across_suspend_points(\n \n     let mut storage_liveness_map = FxHashMap::default();\n \n+    let mut suspending_blocks = BitSet::new_empty(mir.basic_blocks().len());\n+\n     for (block, data) in mir.basic_blocks().iter_enumerated() {\n         if let TerminatorKind::Yield { .. } = data.terminator().kind {\n+            suspending_blocks.insert(block);\n+\n             let loc = Location {\n                 block: block,\n                 statement_index: data.statements.len(),\n@@ -488,7 +495,7 @@ fn locals_live_across_suspend_points(\n     // The generator argument is ignored\n     set.remove(self_arg());\n \n-    (set, storage_liveness_map)\n+    (set, storage_liveness_map, suspending_blocks)\n }\n \n fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -497,15 +504,14 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             interior: Ty<'tcx>,\n                             movable: bool,\n                             mir: &mut Mir<'tcx>)\n-    -> (FxHashMap<Local, (Ty<'tcx>, usize)>,\n+    -> (FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n         GeneratorLayout<'tcx>,\n         FxHashMap<BasicBlock, liveness::LiveVarSet>)\n {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n-    let (live_locals, storage_liveness) = locals_live_across_suspend_points(tcx,\n-                                                                            mir,\n-                                                                            source,\n-                                                                            movable);\n+    let (live_locals, storage_liveness, suspending_blocks) =\n+        locals_live_across_suspend_points(tcx, mir, source, movable);\n+\n     // Erase regions from the types passed in from typeck so we can compare them with\n     // MIR types\n     let allowed_upvars = tcx.erase_regions(upvars);\n@@ -531,7 +537,6 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    let upvar_len = upvars.len();\n     let dummy_local = LocalDecl::new_internal(tcx.mk_unit(), mir.span);\n \n     // Gather live locals and their indices replacing values in mir.local_decls with a dummy\n@@ -541,38 +546,44 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         (local, var)\n     });\n \n+    // For now we will access everything via variant #3, leaving empty variants\n+    // for the UNRESUMED, RETURNED, and POISONED states.\n+    // If there were a yield-less generator without a variant #3, it would not\n+    // have any vars to remap, so we would never use this.\n+    let variant_index = VariantIdx::new(3);\n+\n     // Create a map from local indices to generator struct indices.\n-    // These are offset by (upvar_len + 1) because of fields which comes before locals.\n     // We also create a vector of the LocalDecls of these locals.\n     let (remap, vars) = live_decls.enumerate().map(|(idx, (local, var))| {\n-        ((local, (var.ty, upvar_len + 1 + idx)), var)\n+        ((local, (var.ty, variant_index, idx)), var)\n     }).unzip();\n \n+    // Put every var in each variant, for now.\n+    let empty_variants = iter::repeat(vec![]).take(3);\n+    let state_variants = iter::repeat(vars).take(suspending_blocks.count());\n     let layout = GeneratorLayout {\n-        // Put everything in one variant, for now.\n-        variant_fields: vec![vars]\n+        variant_fields: empty_variants.chain(state_variants).collect()\n     };\n \n     (remap, layout, storage_liveness)\n }\n \n-fn insert_switch<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           mir: &mut Mir<'tcx>,\n-                           cases: Vec<(u32, BasicBlock)>,\n+fn insert_switch<'a, 'tcx>(mir: &mut Mir<'tcx>,\n+                           cases: Vec<(usize, BasicBlock)>,\n                            transform: &TransformVisitor<'a, 'tcx>,\n                            default: TerminatorKind<'tcx>) {\n     let default_block = insert_term_block(mir, default);\n-\n+    let (assign, discr) = transform.get_discr(mir);\n     let switch = TerminatorKind::SwitchInt {\n-        discr: Operand::Copy(transform.make_field(transform.state_field, tcx.types.u32)),\n-        switch_ty: tcx.types.u32,\n-        values: Cow::from(cases.iter().map(|&(i, _)| i.into()).collect::<Vec<_>>()),\n-        targets: cases.iter().map(|&(_, d)| d).chain(once(default_block)).collect(),\n+        discr: Operand::Move(discr),\n+        switch_ty: transform.discr_ty,\n+        values: Cow::from(cases.iter().map(|&(i, _)| i as u128).collect::<Vec<_>>()),\n+        targets: cases.iter().map(|&(_, d)| d).chain(iter::once(default_block)).collect(),\n     };\n \n     let source_info = source_info(mir);\n     mir.basic_blocks_mut().raw.insert(0, BasicBlockData {\n-        statements: Vec::new(),\n+        statements: vec![assign],\n         terminator: Some(Terminator {\n             source_info,\n             kind: switch,\n@@ -657,7 +668,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n     // The returned state and the poisoned state fall through to the default\n     // case which is just to return\n \n-    insert_switch(tcx, &mut mir, cases, &transform, TerminatorKind::Return);\n+    insert_switch(&mut mir, cases, &transform, TerminatorKind::Return);\n \n     for block in mir.basic_blocks_mut() {\n         let kind = &mut block.terminator_mut().kind;\n@@ -771,7 +782,8 @@ fn create_generator_resume_function<'a, 'tcx>(\n     for block in mir.basic_blocks_mut() {\n         let source_info = block.terminator().source_info;\n         if let &TerminatorKind::Resume = &block.terminator().kind {\n-            block.statements.push(transform.set_state(POISONED, source_info));\n+            block.statements.push(\n+                transform.set_discr(VariantIdx::new(POISONED), source_info));\n         }\n     }\n \n@@ -789,7 +801,7 @@ fn create_generator_resume_function<'a, 'tcx>(\n     // Panic when resumed on the poisoned state\n     cases.insert(2, (POISONED, insert_panic_block(tcx, mir, GeneratorResumedAfterPanic)));\n \n-    insert_switch(tcx, mir, cases, &transform, TerminatorKind::Unreachable);\n+    insert_switch(mir, cases, &transform, TerminatorKind::Unreachable);\n \n     make_generator_state_argument_indirect(tcx, def_id, mir);\n     make_generator_state_argument_pinned(tcx, mir);\n@@ -835,7 +847,7 @@ fn insert_clean_drop<'a, 'tcx>(mir: &mut Mir<'tcx>) -> BasicBlock {\n \n fn create_cases<'a, 'tcx, F>(mir: &mut Mir<'tcx>,\n                           transform: &TransformVisitor<'a, 'tcx>,\n-                          target: F) -> Vec<(u32, BasicBlock)>\n+                          target: F) -> Vec<(usize, BasicBlock)>\n     where F: Fn(&SuspensionPoint) -> Option<BasicBlock> {\n     let source_info = source_info(mir);\n \n@@ -927,8 +939,6 @@ impl MirPass for StateTransform {\n             movable,\n             mir);\n \n-        let state_field = upvars.len();\n-\n         // Run the transformation which converts Places from Local to generator struct\n         // accesses for locals in `remap`.\n         // It also rewrites `return x` and `yield y` as writing a new generator state and returning\n@@ -941,7 +951,6 @@ impl MirPass for StateTransform {\n             storage_liveness,\n             suspension_points: Vec::new(),\n             new_ret_local,\n-            state_field,\n             discr_ty,\n         };\n         transform.visit_mir(mir);"}, {"sha": "9cc4272fafabf1526af662f3aaf039178d732eaf", "filename": "src/test/mir-opt/generator-drop-cleanup.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Ftest%2Fmir-opt%2Fgenerator-drop-cleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b/src%2Ftest%2Fmir-opt%2Fgenerator-drop-cleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgenerator-drop-cleanup.rs?ref=5a7af5480c5f9a7d1b5964e3c77ef18326a3a67b", "patch": "@@ -13,7 +13,8 @@ fn main() {\n \n // START rustc.main-{{closure}}.generator_drop.0.mir\n // bb0: {\n-//     switchInt(((*_1).0: u32)) -> [0u32: bb4, 3u32: bb7, otherwise: bb8];\n+//     _5 = discriminant((*_1));\n+//     switchInt(move _5) -> [0u32: bb4, 3u32: bb7, otherwise: bb8];\n // }\n // bb1: {\n //     goto -> bb5;"}]}