{"sha": "c88a20d171b407aa6a88b516c213e93b7dda5c94", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4OGEyMGQxNzFiNDA3YWE2YTg4YjUxNmMyMTNlOTNiN2RkYTVjOTQ=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-03-26T15:11:48Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-03-26T15:24:15Z"}, "message": "Added missing lifetime annotations, doc and whitespace cleanups", "tree": {"sha": "54bddf4f076edf2079ed01117a42a25c0eb93ed8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54bddf4f076edf2079ed01117a42a25c0eb93ed8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c88a20d171b407aa6a88b516c213e93b7dda5c94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c88a20d171b407aa6a88b516c213e93b7dda5c94", "html_url": "https://github.com/rust-lang/rust/commit/c88a20d171b407aa6a88b516c213e93b7dda5c94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c88a20d171b407aa6a88b516c213e93b7dda5c94/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06c371605b3e2ad8068e359f28d4c77dccad0237", "url": "https://api.github.com/repos/rust-lang/rust/commits/06c371605b3e2ad8068e359f28d4c77dccad0237", "html_url": "https://github.com/rust-lang/rust/commit/06c371605b3e2ad8068e359f28d4c77dccad0237"}], "stats": {"total": 132, "additions": 66, "deletions": 66}, "files": [{"sha": "bbedf65ea0a611905c3546c1bd95216efad80ca8", "filename": "src/libcore/str.rs", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/c88a20d171b407aa6a88b516c213e93b7dda5c94/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c88a20d171b407aa6a88b516c213e93b7dda5c94/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=c88a20d171b407aa6a88b516c213e93b7dda5c94", "patch": "@@ -186,6 +186,7 @@ pub fn push_str_no_overallocate(lhs: &mut ~str, rhs: &str) {\n         raw::set_len(lhs, llen + rlen);\n     }\n }\n+\n /// Appends a string slice to the back of a string\n #[inline(always)]\n pub fn push_str(lhs: &mut ~str, rhs: &str) {\n@@ -214,7 +215,6 @@ pub fn append(lhs: ~str, rhs: &str) -> ~str {\n     v\n }\n \n-\n /// Concatenate a vector of strings\n pub fn concat(v: &[~str]) -> ~str {\n     let mut s: ~str = ~\"\";\n@@ -435,35 +435,32 @@ pub fn slice(s: &'a str, begin: uint, end: uint) -> &'a str {\n }\n \n /// Splits a string into substrings at each occurrence of a given character\n-pub fn each_split_char(s: &str, sep: char, it: &fn(&str) -> bool) {\n+pub fn each_split_char(s: &'a str, sep: char, it: &fn(&'a str) -> bool) {\n     each_split_char_inner(s, sep, len(s), true, true, it)\n }\n \n-/**\n- * Like `split_char`, but a trailing empty string is omitted\n- * (e.g. `split_char_no_trailing(\"A B \",' ') == ~[~\"A\",~\"B\"]`)\n- */\n-pub fn each_split_char_no_trailing(s: &str, sep: char, it: &fn(&str) -> bool) {\n+/// Like `each_split_char`, but a trailing empty string is omitted\n+pub fn each_split_char_no_trailing(s: &'a str, sep: char, it: &fn(&'a str) -> bool) {\n     each_split_char_inner(s, sep, len(s), true, false, it)\n }\n \n /**\n  * Splits a string into substrings at each occurrence of a given\n  * character up to 'count' times.\n  *\n- * The byte must be a valid UTF-8/ASCII byte\n+ * The character must be a valid UTF-8/ASCII character\n  */\n-pub fn each_splitn_char(s: &str, sep: char, count: uint, it: &fn(&str) -> bool) {\n+pub fn each_splitn_char(s: &'a str, sep: char, count: uint, it: &fn(&'a str) -> bool) {\n     each_split_char_inner(s, sep, count, true, true, it)\n }\n \n-/// Like `split_char`, but omits empty strings from the returned vector\n-pub fn each_split_char_nonempty(s: &str, sep: char, it: &fn(&str) -> bool) {\n+/// Like `each_split_char`, but omits empty strings\n+pub fn each_split_char_nonempty(s: &'a str, sep: char, it: &fn(&'a str) -> bool) {\n     each_split_char_inner(s, sep, len(s), false, false, it)\n }\n \n-fn each_split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool,\n-                         allow_trailing_empty: bool, it: &fn(&str) -> bool) {\n+fn each_split_char_inner(s: &'a str, sep: char, count: uint, allow_empty: bool,\n+                         allow_trailing_empty: bool, it: &fn(&'a str) -> bool) {\n     if sep < 128u as char {\n         let b = sep as u8, l = len(s);\n         let mut done = 0u;\n@@ -478,7 +475,7 @@ fn each_split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool,\n             }\n             i += 1u;\n         }\n-        // only push a non-empty trailing substring\n+        // only slice a non-empty trailing substring\n         if allow_trailing_empty || start < l {\n             if !it( unsafe{ raw::slice_bytes(s, start, l) } ) { return; }\n         }\n@@ -488,33 +485,30 @@ fn each_split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool,\n }\n \n /// Splits a string into substrings using a character function\n-pub fn each_split(s: &str, sepfn: &fn(char) -> bool, it: &fn(&str) -> bool) {\n+pub fn each_split(s: &'a str, sepfn: &fn(char) -> bool, it: &fn(&'a str) -> bool) {\n     each_split_inner(s, sepfn, len(s), true, true, it)\n }\n \n-/**\n- * Like `split`, but a trailing empty string is omitted\n- * (e.g. `split_no_trailing(\"A B \",' ') == ~[~\"A\",~\"B\"]`)\n- */\n-pub fn each_split_no_trailing(s: &str, sepfn: &fn(char) -> bool, it: &fn(&str) -> bool) {\n+/// Like `each_split`, but a trailing empty string is omitted\n+pub fn each_split_no_trailing(s: &'a str, sepfn: &fn(char) -> bool, it: &fn(&'a str) -> bool) {\n     each_split_inner(s, sepfn, len(s), true, false, it)\n }\n \n /**\n  * Splits a string into substrings using a character function, cutting at\n  * most `count` times.\n  */\n-pub fn each_splitn(s: &str, sepfn: &fn(char) -> bool, count: uint, it: &fn(&str) -> bool) {\n+pub fn each_splitn(s: &'a str, sepfn: &fn(char) -> bool, count: uint, it: &fn(&'a str) -> bool) {\n     each_split_inner(s, sepfn, count, true, true, it)\n }\n \n-/// Like `split`, but omits empty strings from the returned vector\n-pub fn each_split_nonempty(s: &str, sepfn: &fn(char) -> bool, it: &fn(&str) -> bool) {\n+/// Like `each_split`, but omits empty strings\n+pub fn each_split_nonempty(s: &'a str, sepfn: &fn(char) -> bool, it: &fn(&'a str) -> bool) {\n     each_split_inner(s, sepfn, len(s), false, false, it)\n }\n \n-fn each_split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n-               allow_empty: bool, allow_trailing_empty: bool, it: &fn(&str) -> bool) {\n+fn each_split_inner(s: &'a str, sepfn: &fn(cc: char) -> bool, count: uint,\n+                    allow_empty: bool, allow_trailing_empty: bool, it: &fn(&'a str) -> bool) {\n     let l = len(s);\n     let mut i = 0u, start = 0u, done = 0u;\n     while i < l && done < count {\n@@ -576,16 +570,18 @@ fn iter_between_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint) -> bool) {\n  * # Example\n  *\n  * ~~~\n- * fail_unless!([\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\"))\n+ * let mut v = ~[];\n+ * for each_split_str(\".XXX.YYY.\", \".\") |subs| { v.push(subs); }\n+ * fail_unless!(v == [\"\", \"XXX\", \"YYY\", \"\"]);\n  * ~~~\n  */\n-pub fn each_split_str(s: &'a str, sep: &'b str, it: &fn(&str) -> bool) {\n+pub fn each_split_str(s: &'a str, sep: &'b str, it: &fn(&'a str) -> bool) {\n     for iter_between_matches(s, sep) |from, to| {\n         if !it( unsafe { raw::slice_bytes(s, from, to) } ) { return; }\n     }\n }\n \n-pub fn each_split_str_nonempty(s: &'a str, sep: &'b str, it: &fn(&str) -> bool) {\n+pub fn each_split_str_nonempty(s: &'a str, sep: &'b str, it: &fn(&'a str) -> bool) {\n     for iter_between_matches(s, sep) |from, to| {\n         if to > from {\n             if !it( unsafe { raw::slice_bytes(s, from, to) } ) { return; }\n@@ -628,15 +624,17 @@ pub fn levdistance(s: &str, t: &str) -> uint {\n }\n \n /**\n- * Splits a string into a vector of the substrings separated by LF ('\\n').\n+ * Splits a string into substrings separated by LF ('\\n').\n  */\n-pub fn each_line(s: &str, it: &fn(&str) -> bool) { each_split_char_no_trailing(s, '\\n', it) }\n+pub fn each_line(s: &'a str, it: &fn(&'a str) -> bool) {\n+    each_split_char_no_trailing(s, '\\n', it)\n+}\n \n /**\n- * Splits a string into a vector of the substrings separated by LF ('\\n')\n+ * Splits a string into substrings separated by LF ('\\n')\n  * and/or CR LF (\"\\r\\n\")\n  */\n-pub fn each_line_any(s: &str, it: &fn(&str) -> bool) {\n+pub fn each_line_any(s: &'a str, it: &fn(&'a str) -> bool) {\n     for each_line(s) |s| {\n         let l = s.len();\n         if l > 0u && s[l - 1u] == '\\r' as u8 {\n@@ -647,33 +645,46 @@ pub fn each_line_any(s: &str, it: &fn(&str) -> bool) {\n     }\n }\n \n-/// Splits a string into a vector of the substrings separated by whitespace\n-pub fn each_word(s: &str, it: &fn(&str) -> bool) {\n-    each_split_nonempty(s, |c| char::is_whitespace(c), it)\n+/// Splits a string into substrings separated by whitespace\n+pub fn each_word(s: &'a str, it: &fn(&'a str) -> bool) {\n+    each_split_nonempty(s, char::is_whitespace, it)\n }\n \n-/** Split a string into a vector of substrings,\n- *  each of which is less bytes long than a limit\n+/** Splits a string into substrings with possibly internal whitespace,\n+ *  each of them at most `lim` bytes long. The substrings have leading and trailing\n+ *  whitespace removed, and are only cut at whitespace boundaries.\n+ *\n+ *  #Failure:\n+ *\n+ *  Fails during iteration if the string contains a non-whitespace\n+ *  sequence longer than the limit.\n  */\n-pub fn each_split_within(ss: &str, lim: uint, it: &fn(&str) -> bool) {\n-    // Just for fun, let's write this as an automaton\n+pub fn each_split_within(ss: &'a str, lim: uint, it: &fn(&'a str) -> bool) {\n+    // Just for fun, let's write this as an state machine:\n+\n     enum SplitWithinState {\n-        A, // Leading whitespace, initial state\n-        B, // Words\n-        C, // Internal and trailing whitespace\n+        A,  // leading whitespace, initial state\n+        B,  // words\n+        C,  // internal and trailing whitespace\n+    }\n+    enum Whitespace {\n+        Ws, // current char is whitespace\n+        Cr  // current char is not whitespace\n+    }\n+    enum LengthLimit {\n+        UnderLim, // current char makes current substring still fit in limit\n+        OverLim   // current char makes current substring no longer fit in limit\n     }\n-    enum Whitespace { Ws, Cr }\n-    enum LengthLimit { UnderLim, OverLim }\n \n     let mut slice_start = 0;\n     let mut last_start = 0;\n     let mut last_end = 0;\n     let mut state = A;\n \n     let mut cont = true;\n-    let slice = || { cont = it(ss.slice(slice_start, last_end)) };\n+    let slice: &fn() = || { cont = it(slice(ss, slice_start, last_end)) };\n \n-    let machine = |i: uint, c: char| {\n+    let machine: &fn(uint, char) -> bool = |i, c| {\n         let whitespace = if char::is_whitespace(c)       { Ws }       else { Cr };\n         let limit      = if (i - slice_start + 1) <= lim { UnderLim } else { OverLim };\n \n@@ -693,12 +704,13 @@ pub fn each_split_within(ss: &str, lim: uint, it: &fn(&str) -> bool) {\n             (C, Ws, OverLim)  => { slice(); A }\n             (C, Ws, UnderLim) => { C }\n         };\n+\n         cont\n     };\n \n     str::each_chari(ss, machine);\n \n-    // Let the automaton 'run out'\n+    // Let the automaton 'run out' by supplying trailing whitespace\n     let mut fake_i = ss.len();\n     while cont && match state { B | C => true, A => false } {\n         machine(fake_i, ' ');\n@@ -1186,8 +1198,7 @@ pub fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n  * or equal to `len(s)`. `start` must be the index of a character boundary,\n  * as defined by `is_char_boundary`.\n  */\n-pub fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n-    -> Option<uint> {\n+pub fn rfind_char_between(s: &str, c: char, start: uint, end: uint) -> Option<uint> {\n     if c < 128u as char {\n         fail_unless!(start >= end);\n         fail_unless!(start <= len(s));\n@@ -1268,11 +1279,7 @@ pub fn find_from(s: &str, start: uint, f: &fn(char)\n  * or equal to `len(s)`. `start` must be the index of a character\n  * boundary, as defined by `is_char_boundary`.\n  */\n-pub fn find_between(s: &str,\n-                         start: uint,\n-                         end: uint,\n-                         f: &fn(char) -> bool)\n-                      -> Option<uint> {\n+pub fn find_between(s: &str, start: uint, end: uint, f: &fn(char) -> bool) -> Option<uint> {\n     fail_unless!(start <= end);\n     fail_unless!(end <= len(s));\n     fail_unless!(is_char_boundary(s, start));\n@@ -1323,8 +1330,7 @@ pub fn rfind(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)', `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`\n  */\n-pub fn rfind_from(s: &str, start: uint, f: &fn(char) -> bool)\n-    -> Option<uint> {\n+pub fn rfind_from(s: &str, start: uint, f: &fn(char) -> bool) -> Option<uint> {\n     rfind_between(s, start, 0u, f)\n }\n \n@@ -1350,9 +1356,7 @@ pub fn rfind_from(s: &str, start: uint, f: &fn(char) -> bool)\n  * than or equal to `len(s)`. `start` must be the index of a character\n  * boundary, as defined by `is_char_boundary`\n  */\n-pub fn rfind_between(s: &str, start: uint, end: uint,\n-                          f: &fn(char) -> bool)\n-    -> Option<uint> {\n+pub fn rfind_between(s: &str, start: uint, end: uint, f: &fn(char) -> bool) -> Option<uint> {\n     fail_unless!(start >= end);\n     fail_unless!(start <= len(s));\n     fail_unless!(is_char_boundary(s, start));\n@@ -1408,8 +1412,7 @@ pub fn find_str(haystack: &'a str, needle: &'b str) -> Option<uint> {\n  *\n  * `start` must be less than or equal to `len(s)`\n  */\n-pub fn find_str_from(haystack: &'a str, needle: &'b str, start: uint)\n-  -> Option<uint> {\n+pub fn find_str_from(haystack: &'a str, needle: &'b str, start: uint) -> Option<uint> {\n     find_str_between(haystack, needle, start, len(haystack))\n }\n \n@@ -1433,9 +1436,8 @@ pub fn find_str_from(haystack: &'a str, needle: &'b str, start: uint)\n  * `start` must be less than or equal to `end` and `end` must be less than\n  * or equal to `len(s)`.\n  */\n-pub fn find_str_between(haystack: &'a str, needle: &'b str, start: uint,\n-                         end:uint)\n-  -> Option<uint> {\n+pub fn find_str_between(haystack: &'a str, needle: &'b str, start: uint, end:uint)\n+        -> Option<uint> {\n     // See Issue #1932 for why this is a naive search\n     fail_unless!(end <= len(haystack));\n     let needle_len = len(needle);\n@@ -1638,7 +1640,6 @@ pub fn utf16_chars(v: &[u16], f: &fn(char)) {\n     }\n }\n \n-\n pub fn from_utf16(v: &[u16]) -> ~str {\n     let mut buf = ~\"\";\n     unsafe {\n@@ -1955,7 +1956,6 @@ pub fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T {\n     }\n }\n \n-\n /**\n  * Work with the byte buffer and length of a slice.\n  *"}]}