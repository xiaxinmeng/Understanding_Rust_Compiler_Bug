{"sha": "703ff60d9f885dfe317e3d271d9f341509efac92", "node_id": "C_kwDOAAsO6NoAKDcwM2ZmNjBkOWY4ODVkZmUzMTdlM2QyNzFkOWYzNDE1MDllZmFjOTI", "commit": {"author": {"name": "Lukas Bergdoll", "email": "lukas.bergdoll@gmail.com", "date": "2023-01-21T09:17:06Z"}, "committer": {"name": "Lukas Bergdoll", "email": "lukas.bergdoll@gmail.com", "date": "2023-01-21T09:17:06Z"}, "message": "Use NonNull in merge_sort\n\nThis is more clear about the intent of the pointer and avoids problems\nif the allocation returns a null pointer.", "tree": {"sha": "257debf1c165db61f9e529e31cddea06f6da444f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/257debf1c165db61f9e529e31cddea06f6da444f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/703ff60d9f885dfe317e3d271d9f341509efac92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/703ff60d9f885dfe317e3d271d9f341509efac92", "html_url": "https://github.com/rust-lang/rust/commit/703ff60d9f885dfe317e3d271d9f341509efac92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/703ff60d9f885dfe317e3d271d9f341509efac92/comments", "author": {"login": "Voultapher", "id": 6864584, "node_id": "MDQ6VXNlcjY4NjQ1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6864584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Voultapher", "html_url": "https://github.com/Voultapher", "followers_url": "https://api.github.com/users/Voultapher/followers", "following_url": "https://api.github.com/users/Voultapher/following{/other_user}", "gists_url": "https://api.github.com/users/Voultapher/gists{/gist_id}", "starred_url": "https://api.github.com/users/Voultapher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Voultapher/subscriptions", "organizations_url": "https://api.github.com/users/Voultapher/orgs", "repos_url": "https://api.github.com/users/Voultapher/repos", "events_url": "https://api.github.com/users/Voultapher/events{/privacy}", "received_events_url": "https://api.github.com/users/Voultapher/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Voultapher", "id": 6864584, "node_id": "MDQ6VXNlcjY4NjQ1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6864584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Voultapher", "html_url": "https://github.com/Voultapher", "followers_url": "https://api.github.com/users/Voultapher/followers", "following_url": "https://api.github.com/users/Voultapher/following{/other_user}", "gists_url": "https://api.github.com/users/Voultapher/gists{/gist_id}", "starred_url": "https://api.github.com/users/Voultapher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Voultapher/subscriptions", "organizations_url": "https://api.github.com/users/Voultapher/orgs", "repos_url": "https://api.github.com/users/Voultapher/repos", "events_url": "https://api.github.com/users/Voultapher/events{/privacy}", "received_events_url": "https://api.github.com/users/Voultapher/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e098eb17e1514bcd604ac4bd57cec362944687af", "url": "https://api.github.com/repos/rust-lang/rust/commits/e098eb17e1514bcd604ac4bd57cec362944687af", "html_url": "https://github.com/rust-lang/rust/commit/e098eb17e1514bcd604ac4bd57cec362944687af"}], "stats": {"total": 34, "additions": 19, "deletions": 15}, "files": [{"sha": "7f8895b150fe7b55f484198425ac5e6bd504adbd", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/703ff60d9f885dfe317e3d271d9f341509efac92/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/703ff60d9f885dfe317e3d271d9f341509efac92/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=703ff60d9f885dfe317e3d271d9f341509efac92", "patch": "@@ -1203,7 +1203,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n     // `is_less` panics. When merging two sorted runs, this buffer holds a copy of the shorter run,\n     // which will always have length at most `len / 2`.\n     let buf = BufGuard::new(len / 2, elem_alloc_fn, elem_dealloc_fn);\n-    let buf_ptr = buf.buf_ptr;\n+    let buf_ptr = buf.buf_ptr.as_ptr();\n \n     let mut runs = RunVec::new(run_alloc_fn, run_dealloc_fn);\n \n@@ -1298,7 +1298,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n     where\n         ElemDeallocF: Fn(*mut T, usize),\n     {\n-        buf_ptr: *mut T,\n+        buf_ptr: ptr::NonNull<T>,\n         capacity: usize,\n         elem_dealloc_fn: ElemDeallocF,\n     }\n@@ -1315,7 +1315,11 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n         where\n             ElemAllocF: Fn(usize) -> *mut T,\n         {\n-            Self { buf_ptr: elem_alloc_fn(len), capacity: len, elem_dealloc_fn }\n+            Self {\n+                buf_ptr: ptr::NonNull::new(elem_alloc_fn(len)).unwrap(),\n+                capacity: len,\n+                elem_dealloc_fn,\n+            }\n         }\n     }\n \n@@ -1324,7 +1328,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n         ElemDeallocF: Fn(*mut T, usize),\n     {\n         fn drop(&mut self) {\n-            (self.elem_dealloc_fn)(self.buf_ptr, self.capacity);\n+            (self.elem_dealloc_fn)(self.buf_ptr.as_ptr(), self.capacity);\n         }\n     }\n \n@@ -1333,7 +1337,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n         RunAllocF: Fn(usize) -> *mut TimSortRun,\n         RunDeallocF: Fn(*mut TimSortRun, usize),\n     {\n-        buf_ptr: *mut TimSortRun,\n+        buf_ptr: ptr::NonNull<TimSortRun>,\n         capacity: usize,\n         len: usize,\n         run_alloc_fn: RunAllocF,\n@@ -1350,7 +1354,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n             const START_RUN_CAPACITY: usize = 16;\n \n             Self {\n-                buf_ptr: run_alloc_fn(START_RUN_CAPACITY),\n+                buf_ptr: ptr::NonNull::new(run_alloc_fn(START_RUN_CAPACITY)).unwrap(),\n                 capacity: START_RUN_CAPACITY,\n                 len: 0,\n                 run_alloc_fn,\n@@ -1361,23 +1365,23 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n         fn push(&mut self, val: TimSortRun) {\n             if self.len == self.capacity {\n                 let old_capacity = self.capacity;\n-                let old_buf_ptr = self.buf_ptr;\n+                let old_buf_ptr = self.buf_ptr.as_ptr();\n \n                 self.capacity = self.capacity * 2;\n-                self.buf_ptr = (self.run_alloc_fn)(self.capacity);\n+                self.buf_ptr = ptr::NonNull::new((self.run_alloc_fn)(self.capacity)).unwrap();\n \n                 // SAFETY: buf_ptr new and old were correctly allocated and old_buf_ptr has\n                 // old_capacity valid elements.\n                 unsafe {\n-                    ptr::copy_nonoverlapping(old_buf_ptr, self.buf_ptr, old_capacity);\n+                    ptr::copy_nonoverlapping(old_buf_ptr, self.buf_ptr.as_ptr(), old_capacity);\n                 }\n \n                 (self.run_dealloc_fn)(old_buf_ptr, old_capacity);\n             }\n \n             // SAFETY: The invariant was just checked.\n             unsafe {\n-                self.buf_ptr.add(self.len).write(val);\n+                self.buf_ptr.as_ptr().add(self.len).write(val);\n             }\n             self.len += 1;\n         }\n@@ -1390,7 +1394,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n             // SAFETY: buf_ptr needs to be valid and len invariant upheld.\n             unsafe {\n                 // the place we are taking from.\n-                let ptr = self.buf_ptr.add(index);\n+                let ptr = self.buf_ptr.as_ptr().add(index);\n \n                 // Shift everything down to fill in that spot.\n                 ptr::copy(ptr.add(1), ptr, self.len - index - 1);\n@@ -1400,7 +1404,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n \n         fn as_slice(&self) -> &[TimSortRun] {\n             // SAFETY: Safe as long as buf_ptr is valid and len invariant was upheld.\n-            unsafe { &*ptr::slice_from_raw_parts(self.buf_ptr, self.len) }\n+            unsafe { &*ptr::slice_from_raw_parts(self.buf_ptr.as_ptr(), self.len) }\n         }\n \n         fn len(&self) -> usize {\n@@ -1419,7 +1423,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n             if index < self.len {\n                 // SAFETY: buf_ptr and len invariant must be upheld.\n                 unsafe {\n-                    return &*(self.buf_ptr.add(index));\n+                    return &*(self.buf_ptr.as_ptr().add(index));\n                 }\n             }\n \n@@ -1436,7 +1440,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n             if index < self.len {\n                 // SAFETY: buf_ptr and len invariant must be upheld.\n                 unsafe {\n-                    return &mut *(self.buf_ptr.add(index));\n+                    return &mut *(self.buf_ptr.as_ptr().add(index));\n                 }\n             }\n \n@@ -1452,7 +1456,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n         fn drop(&mut self) {\n             // As long as TimSortRun is Copy we don't need to drop them individually but just the\n             // whole allocation.\n-            (self.run_dealloc_fn)(self.buf_ptr, self.capacity);\n+            (self.run_dealloc_fn)(self.buf_ptr.as_ptr(), self.capacity);\n         }\n     }\n }"}]}