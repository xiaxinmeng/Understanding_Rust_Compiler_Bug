{"sha": "09ff88b600713a2bfca7cfdfd1828b519c907247", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZmY4OGI2MDA3MTNhMmJmY2E3Y2ZkZmQxODI4YjUxOWM5MDcyNDc=", "commit": {"author": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2021-04-03T02:56:18Z"}, "committer": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2021-04-06T02:09:51Z"}, "message": "Add `FromIterator` and `IntoIterator` impls for `ThinVec`\n\nThese should make using `ThinVec` feel much more like using `Vec`.\nThey will allow users of `Vec` to switch to `ThinVec` while continuing\nto use `collect()`, `for` loops, and other parts of the iterator API.\n\nI don't know if there were use cases before for using the iterator API\nwith `ThinVec`, but I would like to start using `ThinVec` in rustdoc,\nand having it conform to the iterator API would make the transition\n*a lot* easier.\n\nI added a `FromIterator` impl, an `IntoIterator` impl that yields owned\nelements, and `IntoIterator` impls that yield immutable or mutable\nreferences to elements. I also added some unit tests for `ThinVec`.", "tree": {"sha": "f6c137a1f7fb5d3dd7a82dbc4179919615d0657b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6c137a1f7fb5d3dd7a82dbc4179919615d0657b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09ff88b600713a2bfca7cfdfd1828b519c907247", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09ff88b600713a2bfca7cfdfd1828b519c907247", "html_url": "https://github.com/rust-lang/rust/commit/09ff88b600713a2bfca7cfdfd1828b519c907247", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09ff88b600713a2bfca7cfdfd1828b519c907247/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36bcf4069717b9dff90270d13b53a3b130329960", "url": "https://api.github.com/repos/rust-lang/rust/commits/36bcf4069717b9dff90270d13b53a3b130329960", "html_url": "https://github.com/rust-lang/rust/commit/36bcf4069717b9dff90270d13b53a3b130329960"}], "stats": {"total": 91, "additions": 91, "deletions": 0}, "files": [{"sha": "00e304734983ff15a0cb3e78dd76a8649f692508", "filename": "compiler/rustc_data_structures/src/thin_vec.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/09ff88b600713a2bfca7cfdfd1828b519c907247/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ff88b600713a2bfca7cfdfd1828b519c907247/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs?ref=09ff88b600713a2bfca7cfdfd1828b519c907247", "patch": "@@ -1,5 +1,7 @@\n use crate::stable_hasher::{HashStable, StableHasher};\n \n+use std::iter::FromIterator;\n+\n /// A vector type optimized for cases where this size is usually 0 (cf. `SmallVector`).\n /// The `Option<Box<..>>` wrapping allows us to represent a zero sized vector with `None`,\n /// which uses only a single (null) pointer.\n@@ -10,6 +12,14 @@ impl<T> ThinVec<T> {\n     pub fn new() -> Self {\n         ThinVec(None)\n     }\n+\n+    pub fn iter(&self) -> std::slice::Iter<'_, T> {\n+        self.into_iter()\n+    }\n+\n+    pub fn iter_mut(&mut self) -> std::slice::IterMut<'_, T> {\n+        self.into_iter()\n+    }\n }\n \n impl<T> From<Vec<T>> for ThinVec<T> {\n@@ -46,6 +56,42 @@ impl<T> ::std::ops::DerefMut for ThinVec<T> {\n     }\n }\n \n+impl<T> FromIterator<T> for ThinVec<T> {\n+    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n+        // `Vec::from_iter()` should not allocate if the iterator is empty.\n+        let vec: Vec<_> = iter.into_iter().collect();\n+        if vec.is_empty() { ThinVec(None) } else { ThinVec(Some(Box::new(vec))) }\n+    }\n+}\n+\n+impl<T> IntoIterator for ThinVec<T> {\n+    type Item = T;\n+    type IntoIter = std::vec::IntoIter<T>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        // This is still performant because `Vec::new()` does not allocate.\n+        self.0.map_or_else(Vec::new, |ptr| *ptr).into_iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a ThinVec<T> {\n+    type Item = &'a T;\n+    type IntoIter = std::slice::Iter<'a, T>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.as_ref().iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a mut ThinVec<T> {\n+    type Item = &'a mut T;\n+    type IntoIter = std::slice::IterMut<'a, T>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.as_mut().iter_mut()\n+    }\n+}\n+\n impl<T> Extend<T> for ThinVec<T> {\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         match *self {\n@@ -80,3 +126,6 @@ impl<T> Default for ThinVec<T> {\n         Self(None)\n     }\n }\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "5abfd939373c7668ff5657be21343c220f18cba3", "filename": "compiler/rustc_data_structures/src/thin_vec/tests.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/09ff88b600713a2bfca7cfdfd1828b519c907247/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ff88b600713a2bfca7cfdfd1828b519c907247/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec%2Ftests.rs?ref=09ff88b600713a2bfca7cfdfd1828b519c907247", "patch": "@@ -0,0 +1,42 @@\n+use super::*;\n+\n+impl<T> ThinVec<T> {\n+    fn into_vec(self) -> Vec<T> {\n+        self.into()\n+    }\n+}\n+\n+#[test]\n+fn test_from_iterator() {\n+    assert_eq!(std::iter::empty().collect::<ThinVec<String>>().into_vec(), Vec::<String>::new());\n+    assert_eq!(std::iter::once(42).collect::<ThinVec<_>>().into_vec(), vec![42]);\n+    assert_eq!(vec![1, 2].into_iter().collect::<ThinVec<_>>().into_vec(), vec![1, 2]);\n+    assert_eq!(vec![1, 2, 3].into_iter().collect::<ThinVec<_>>().into_vec(), vec![1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_into_iterator_owned() {\n+    assert_eq!(ThinVec::new().into_iter().collect::<Vec<String>>(), Vec::<String>::new());\n+    assert_eq!(ThinVec::from(vec![1]).into_iter().collect::<Vec<_>>(), vec![1]);\n+    assert_eq!(ThinVec::from(vec![1, 2]).into_iter().collect::<Vec<_>>(), vec![1, 2]);\n+    assert_eq!(ThinVec::from(vec![1, 2, 3]).into_iter().collect::<Vec<_>>(), vec![1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_into_iterator_ref() {\n+    assert_eq!(ThinVec::new().iter().collect::<Vec<&String>>(), Vec::<&String>::new());\n+    assert_eq!(ThinVec::from(vec![1]).iter().collect::<Vec<_>>(), vec![&1]);\n+    assert_eq!(ThinVec::from(vec![1, 2]).iter().collect::<Vec<_>>(), vec![&1, &2]);\n+    assert_eq!(ThinVec::from(vec![1, 2, 3]).iter().collect::<Vec<_>>(), vec![&1, &2, &3]);\n+}\n+\n+#[test]\n+fn test_into_iterator_ref_mut() {\n+    assert_eq!(ThinVec::new().iter_mut().collect::<Vec<&mut String>>(), Vec::<&mut String>::new());\n+    assert_eq!(ThinVec::from(vec![1]).iter_mut().collect::<Vec<_>>(), vec![&mut 1]);\n+    assert_eq!(ThinVec::from(vec![1, 2]).iter_mut().collect::<Vec<_>>(), vec![&mut 1, &mut 2]);\n+    assert_eq!(\n+        ThinVec::from(vec![1, 2, 3]).iter_mut().collect::<Vec<_>>(),\n+        vec![&mut 1, &mut 2, &mut 3],\n+    );\n+}"}]}