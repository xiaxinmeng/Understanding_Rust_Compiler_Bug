{"sha": "96e361f6f4319782159164ceac6e1d660e383fcb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2ZTM2MWY2ZjQzMTk3ODIxNTkxNjRjZWFjNmUxZDY2MGUzODNmY2I=", "commit": {"author": {"name": "Andr\u00e9 Vicente Milack", "email": "andrevicente.m@gmail.com", "date": "2019-03-04T13:37:15Z"}, "committer": {"name": "Andr\u00e9 Vicente Milack", "email": "andre@jungledevs.com", "date": "2019-03-06T16:04:48Z"}, "message": "Fix buffer invalidation for BufRead\n\nThere are two moments when a BufRead object needs to empty it's internal\nbuffer:\n\n- In a seek call;\n- In a read call when all data in the internal buffer had been already\n  consumed and the output buffer has a greater or equal size than the\n  internal buffer.\n\nIn both cases, the buffer was not being properly emptied, but only\nmarked as consumed (self.pos = self.cap). That should be no problem if\nthe inner reader is only Read, but if it is Seek as well, then it's\npossible to access the data in the buffer by using the seek_relative\nmethod. In order to prevent this from happening, both self.pos and\nself.cap should be set to 0.\n\nTwo test cases were added to detect that failure:\n\n- test_buffered_reader_invalidated_after_read\n- test_buffered_reader_invalidated_after_seek\n\nBoth tests are very similar to each other. The inner reader contains the\nfollowing data: [5, 6, 7, 0, 1, 2, 3, 4]. The buffer capacity is 3\nbytes.\n\n- First, we call fill_buffer, which loads [5, 6, 7] into the internal\n  buffer, and then consume those 3 bytes.\n- Then we either read the 5 remaining bytes in a single read call or we\n  move to the end of the stream by calling seek. In both cases the\n  buffer should be emptied to prevent the previous data [5, 6, 7] from\n  being read.\n- We now call seek_relative(-2) and read two bytes, which should give us\n  the last 2 bytes of the stream: [3, 4].\n\nBefore this commit, the the seek_relative method would consider that\nwe're still in the range of the internal buffer, so instead of fetching\ndata from the inner reader, it would return the two last bytes that were\nincorrectly still in the buffer: [6, 7]. Therefore, the test would fail.\n\nNow, when seek_relative is called the buffer is empty. So the expected\ndata [3, 4] is fetched from the inner reader and the test passes.", "tree": {"sha": "48355a082cd394aec823b102a4f9d6c50e474ada", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48355a082cd394aec823b102a4f9d6c50e474ada"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96e361f6f4319782159164ceac6e1d660e383fcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96e361f6f4319782159164ceac6e1d660e383fcb", "html_url": "https://github.com/rust-lang/rust/commit/96e361f6f4319782159164ceac6e1d660e383fcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96e361f6f4319782159164ceac6e1d660e383fcb/comments", "author": {"login": "andre-vm", "id": 10947510, "node_id": "MDQ6VXNlcjEwOTQ3NTEw", "avatar_url": "https://avatars.githubusercontent.com/u/10947510?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andre-vm", "html_url": "https://github.com/andre-vm", "followers_url": "https://api.github.com/users/andre-vm/followers", "following_url": "https://api.github.com/users/andre-vm/following{/other_user}", "gists_url": "https://api.github.com/users/andre-vm/gists{/gist_id}", "starred_url": "https://api.github.com/users/andre-vm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andre-vm/subscriptions", "organizations_url": "https://api.github.com/users/andre-vm/orgs", "repos_url": "https://api.github.com/users/andre-vm/repos", "events_url": "https://api.github.com/users/andre-vm/events{/privacy}", "received_events_url": "https://api.github.com/users/andre-vm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "andre-vm", "id": 10947510, "node_id": "MDQ6VXNlcjEwOTQ3NTEw", "avatar_url": "https://avatars.githubusercontent.com/u/10947510?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andre-vm", "html_url": "https://github.com/andre-vm", "followers_url": "https://api.github.com/users/andre-vm/followers", "following_url": "https://api.github.com/users/andre-vm/following{/other_user}", "gists_url": "https://api.github.com/users/andre-vm/gists{/gist_id}", "starred_url": "https://api.github.com/users/andre-vm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andre-vm/subscriptions", "organizations_url": "https://api.github.com/users/andre-vm/orgs", "repos_url": "https://api.github.com/users/andre-vm/repos", "events_url": "https://api.github.com/users/andre-vm/events{/privacy}", "received_events_url": "https://api.github.com/users/andre-vm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9da8fc9c267c08cfdb8cf5b39da14f154d12939", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9da8fc9c267c08cfdb8cf5b39da14f154d12939", "html_url": "https://github.com/rust-lang/rust/commit/a9da8fc9c267c08cfdb8cf5b39da14f154d12939"}], "stats": {"total": 45, "additions": 43, "deletions": 2}, "files": [{"sha": "365b1e59747371093625315a8090fd55eada3044", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/96e361f6f4319782159164ceac6e1d660e383fcb/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96e361f6f4319782159164ceac6e1d660e383fcb/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=96e361f6f4319782159164ceac6e1d660e383fcb", "patch": "@@ -225,6 +225,9 @@ impl<R: Read> Read for BufReader<R> {\n         // (larger than our internal buffer), bypass our internal buffer\n         // entirely.\n         if self.pos == self.cap && buf.len() >= self.buf.len() {\n+            // Empty the buffer\n+            self.cap = 0;\n+            self.pos = 0;\n             return self.inner.read(buf);\n         }\n         let nread = {\n@@ -323,14 +326,18 @@ impl<R: Seek> Seek for BufReader<R> {\n             } else {\n                 // seek backwards by our remainder, and then by the offset\n                 self.inner.seek(SeekFrom::Current(-remainder))?;\n-                self.pos = self.cap; // empty the buffer\n+                // Empty the buffer\n+                self.cap = 0;\n+                self.pos = 0;\n                 result = self.inner.seek(SeekFrom::Current(n))?;\n             }\n         } else {\n             // Seeking with Start/End doesn't care about our buffer length.\n             result = self.inner.seek(pos)?;\n         }\n-        self.pos = self.cap; // empty the buffer\n+        // Empty the buffer\n+        self.cap = 0;\n+        self.pos = 0;\n         Ok(result)\n     }\n }\n@@ -1066,6 +1073,40 @@ mod tests {\n         assert_eq!(reader.fill_buf().ok(), Some(&[2, 3][..]));\n     }\n \n+    #[test]\n+    fn test_buffered_reader_invalidated_after_read() {\n+        let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n+        let mut reader = BufReader::with_capacity(3, io::Cursor::new(inner));\n+\n+        assert_eq!(reader.fill_buf().ok(), Some(&[5, 6, 7][..]));\n+        reader.consume(3);\n+\n+        let mut buffer = [0, 0, 0, 0, 0];\n+        assert_eq!(reader.read(&mut buffer).ok(), Some(5));\n+        assert_eq!(buffer, [0, 1, 2, 3, 4]);\n+\n+        assert!(reader.seek_relative(-2).is_ok());\n+        let mut buffer = [0, 0];\n+        assert_eq!(reader.read(&mut buffer).ok(), Some(2));\n+        assert_eq!(buffer, [3, 4]);\n+    }\n+\n+    #[test]\n+    fn test_buffered_reader_invalidated_after_seek() {\n+        let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n+        let mut reader = BufReader::with_capacity(3, io::Cursor::new(inner));\n+\n+        assert_eq!(reader.fill_buf().ok(), Some(&[5, 6, 7][..]));\n+        reader.consume(3);\n+\n+        assert!(reader.seek(SeekFrom::Current(5)).is_ok());\n+\n+        assert!(reader.seek_relative(-2).is_ok());\n+        let mut buffer = [0, 0];\n+        assert_eq!(reader.read(&mut buffer).ok(), Some(2));\n+        assert_eq!(buffer, [3, 4]);\n+    }\n+\n     #[test]\n     fn test_buffered_reader_seek_underflow() {\n         // gimmick reader that yields its position modulo 256 for each byte"}]}