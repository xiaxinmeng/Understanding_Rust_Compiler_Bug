{"sha": "d539fafaf602c35d9dec0a7e509fed19d03f054b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1MzlmYWZhZjYwMmMzNWQ5ZGVjMGE3ZTUwOWZlZDE5ZDAzZjA1NGI=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-06-21T14:22:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-21T14:22:15Z"}, "message": "Merge pull request #200 from oli-obk/master\n\nGet rid of the integer allocation (Round 2)", "tree": {"sha": "4d301c5ca6e3ee20a9ce3fc89931cdc8803b969a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d301c5ca6e3ee20a9ce3fc89931cdc8803b969a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d539fafaf602c35d9dec0a7e509fed19d03f054b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d539fafaf602c35d9dec0a7e509fed19d03f054b", "html_url": "https://github.com/rust-lang/rust/commit/d539fafaf602c35d9dec0a7e509fed19d03f054b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d539fafaf602c35d9dec0a7e509fed19d03f054b/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2302f2b81e5d57b9dafd68ad9a6769d85a888e57", "url": "https://api.github.com/repos/rust-lang/rust/commits/2302f2b81e5d57b9dafd68ad9a6769d85a888e57", "html_url": "https://github.com/rust-lang/rust/commit/2302f2b81e5d57b9dafd68ad9a6769d85a888e57"}, {"sha": "a6cd7a2e085eeaf7d928a463a76126cd6542b314", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6cd7a2e085eeaf7d928a463a76126cd6542b314", "html_url": "https://github.com/rust-lang/rust/commit/a6cd7a2e085eeaf7d928a463a76126cd6542b314"}], "stats": {"total": 991, "additions": 691, "deletions": 300}, "files": [{"sha": "5bc7f291d7629e01389b38d93647c0b30f7e7e4c", "filename": ".travis.yml", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -10,6 +10,11 @@ before_script:\n - cargo install xargo\n - export RUST_SYSROOT=$HOME/rust\n script:\n+- |\n+  # get ourselves a MIR-ful libstd\n+  cd xargo &&\n+  RUSTFLAGS='-Zalways-encode-mir' xargo build &&\n+  cd ..\n - |\n   # Test plain miri\n   cargo build &&\n@@ -22,11 +27,7 @@ script:\n   cargo miri test &&\n   cd ..\n - |\n-  # get ourselves a MIR-ful libstd\n-  cd xargo &&\n-  RUSTFLAGS='-Zalways-encode-mir' xargo build &&\n-  cd .. &&\n-  # and run the tests with it\n+  # and run all tests with full mir\n   MIRI_SYSROOT=~/.xargo/HOST cargo test\n notifications:\n   email:"}, {"sha": "aa24de944a7c0f52a1d267519a299f953ac1dfa4", "filename": "src/cast.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcast.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -3,7 +3,6 @@ use syntax::ast::{FloatTy, IntTy, UintTy};\n \n use error::{EvalResult, EvalError};\n use eval_context::EvalContext;\n-use memory::Pointer;\n use value::PrimVal;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n@@ -24,7 +23,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Bool | Char | U8 | U16 | U32 | U64 | U128 => self.cast_int(val.to_u128()?, dest_ty, false),\n \n-            FnPtr | Ptr => self.cast_ptr(val.to_ptr()?, dest_ty),\n+            FnPtr | Ptr => self.cast_ptr(val, dest_ty),\n         }\n     }\n \n@@ -71,7 +70,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             TyChar if v as u8 as u128 == v => Ok(PrimVal::Bytes(v)),\n             TyChar => Err(EvalError::InvalidChar(v)),\n \n-            TyRawPtr(_) => Ok(PrimVal::Ptr(Pointer::from_int(v as u64))),\n+            TyRawPtr(_) => Ok(PrimVal::Bytes(v % (1 << self.memory.pointer_size()))),\n \n             _ => Err(EvalError::Unimplemented(format!(\"int to {:?} cast\", ty))),\n         }\n@@ -92,11 +91,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn cast_ptr(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    fn cast_ptr(&self, ptr: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         use rustc::ty::TypeVariants::*;\n         match ty.sty {\n             TyRef(..) | TyRawPtr(_) | TyFnPtr(_) | TyInt(_) | TyUint(_) =>\n-                Ok(PrimVal::Ptr(ptr)),\n+                Ok(ptr),\n             _ => Err(EvalError::Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n         }\n     }"}, {"sha": "e7e446e93ad7c655064879f6067c573dd157226d", "filename": "src/error.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -22,6 +22,7 @@ pub enum EvalError<'tcx> {\n         allocation_size: u64,\n     },\n     ReadPointerAsBytes,\n+    ReadBytesAsPointer,\n     InvalidPointerMath,\n     ReadUndefBytes,\n     DeadLocal,\n@@ -81,6 +82,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"pointer offset outside bounds of allocation\",\n             EvalError::ReadPointerAsBytes =>\n                 \"a raw memory access tried to access part of a pointer value as raw bytes\",\n+            EvalError::ReadBytesAsPointer =>\n+                \"a memory access tried to interpret some bytes as a pointer\",\n             EvalError::InvalidPointerMath =>\n                 \"attempted to do math or a comparison on pointers into different allocations\",\n             EvalError::ReadUndefBytes =>"}, {"sha": "30a4be7b4b8663dec958cc22530ea9d555547600", "filename": "src/eval_context.rs", "status": "modified", "additions": 62, "deletions": 37, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -17,7 +17,7 @@ use syntax::abi::Abi;\n \n use error::{EvalError, EvalResult};\n use lvalue::{Global, GlobalId, Lvalue, LvalueExtra};\n-use memory::{Memory, Pointer};\n+use memory::{Memory, Pointer, TlsKey};\n use operator;\n use value::{PrimVal, PrimValKind, Value};\n \n@@ -99,6 +99,11 @@ pub enum StackPopCleanup {\n     /// A regular stackframe added due to a function call will need to get forwarded to the next\n     /// block\n     Goto(mir::BasicBlock),\n+    /// After finishing a tls destructor, find the next one instead of starting from the beginning\n+    /// and thus just rerunning the first one until its `data` argument is null\n+    ///\n+    /// The index is the current tls destructor's index\n+    Tls(Option<TlsKey>),\n     /// The main function and diverging functions have nowhere to return to\n     None,\n }\n@@ -350,6 +355,25 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             },\n             StackPopCleanup::Goto(target) => self.goto_block(target),\n             StackPopCleanup::None => {},\n+            StackPopCleanup::Tls(key) => {\n+                // either fetch the next dtor or start new from the beginning, if any are left with a non-null data\n+                if let Some((instance, ptr, key)) = self.memory.fetch_tls_dtor(key).or_else(|| self.memory.fetch_tls_dtor(None)) {\n+                    trace!(\"Running TLS dtor {:?} on {:?}\", instance, ptr);\n+                    // TODO: Potentially, this has to support all the other possible instances? See eval_fn_call in terminator/mod.rs\n+                    let mir = self.load_mir(instance.def)?;\n+                    self.push_stack_frame(\n+                        instance,\n+                        mir.span,\n+                        mir,\n+                        Lvalue::zst(),\n+                        StackPopCleanup::Tls(Some(key)),\n+                    )?;\n+                    let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()))?;\n+                    let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+                    let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n+                    self.write_primval(dest, ptr, ty)?;\n+                }\n+            }\n         }\n         // deallocate all locals that are backed by an allocation\n         for local in frame.locals {\n@@ -389,13 +413,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         where J::IntoIter: ExactSizeIterator,\n     {\n         // FIXME(solson)\n-        let dest_ptr = self.force_allocation(dest)?.to_ptr();\n+        let dest_ptr = self.force_allocation(dest)?.to_ptr()?;\n \n         let discr_dest = dest_ptr.offset(discr_offset, self.memory.layout)?;\n         self.memory.write_uint(discr_dest, discr_val, discr_size)?;\n \n         let dest = Lvalue::Ptr {\n-            ptr: dest_ptr,\n+            ptr: PrimVal::Ptr(dest_ptr),\n             extra: LvalueExtra::DowncastVariant(variant_idx),\n         };\n \n@@ -481,7 +505,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 match *dest_layout {\n                     Univariant { ref variant, .. } => {\n                         if variant.packed {\n-                            let ptr = self.force_allocation(dest)?.to_ptr_and_extra().0;\n+                            let ptr = self.force_allocation(dest)?.to_ptr_and_extra().0.to_ptr()?;\n                             self.memory.mark_packed(ptr, variant.stride().bytes());\n                         }\n                         self.assign_fields(dest, dest_ty, operands)?;\n@@ -499,7 +523,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 .to_u128_unchecked();\n                             let discr_size = discr.size().bytes();\n                             if variants[variant].packed {\n-                                let ptr = self.force_allocation(dest)?.to_ptr_and_extra().0;\n+                                let ptr = self.force_allocation(dest)?.to_ptr_and_extra().0.to_ptr()?;\n                                 self.memory.mark_packed(ptr, variants[variant].stride().bytes());\n                             }\n \n@@ -541,7 +565,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     StructWrappedNullablePointer { nndiscr, ref nonnull, ref discrfield, .. } => {\n                         if let mir::AggregateKind::Adt(_, variant, _, _) = **kind {\n                             if nonnull.packed {\n-                                let ptr = self.force_allocation(dest)?.to_ptr_and_extra().0;\n+                                let ptr = self.force_allocation(dest)?.to_ptr_and_extra().0.to_ptr()?;\n                                 self.memory.mark_packed(ptr, nonnull.stride().bytes());\n                             }\n                             if nndiscr == variant as u64 {\n@@ -554,7 +578,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 let (offset, ty) = self.nonnull_offset_and_ty(dest_ty, nndiscr, discrfield)?;\n \n                                 // FIXME(solson)\n-                                let dest = self.force_allocation(dest)?.to_ptr();\n+                                let dest = self.force_allocation(dest)?.to_ptr()?;\n \n                                 let dest = dest.offset(offset.bytes(), self.memory.layout)?;\n                                 let dest_size = self.type_size(ty)?\n@@ -613,7 +637,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let value = self.eval_operand(operand)?;\n \n                 // FIXME(solson)\n-                let dest = self.force_allocation(dest)?.to_ptr();\n+                let dest = PrimVal::Ptr(self.force_allocation(dest)?.to_ptr()?);\n \n                 for i in 0..length {\n                     let elem_dest = dest.offset(i * elem_size, self.memory.layout)?;\n@@ -630,8 +654,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Ref(_, _, ref lvalue) => {\n                 let src = self.eval_lvalue(lvalue)?;\n-                let (raw_ptr, extra) = self.force_allocation(src)?.to_ptr_and_extra();\n-                let ptr = PrimVal::Ptr(raw_ptr);\n+                let (ptr, extra) = self.force_allocation(src)?.to_ptr_and_extra();\n \n                 let val = match extra {\n                     LvalueExtra::None => Value::ByVal(ptr),\n@@ -726,7 +749,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Discriminant(ref lvalue) => {\n                 let lval = self.eval_lvalue(lvalue)?;\n                 let ty = self.lvalue_ty(lvalue);\n-                let ptr = self.force_allocation(lval)?.to_ptr();\n+                let ptr = self.force_allocation(lval)?.to_ptr()?;\n                 let discr_val = self.read_discriminant_value(ptr, ty)?;\n                 if let ty::TyAdt(adt_def, _) = ty.sty {\n                     if adt_def.discriminants(self.tcx).all(|v| discr_val != v.to_u128_unchecked()) {\n@@ -856,23 +879,27 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn wrapping_pointer_offset(&self, ptr: Pointer, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, Pointer> {\n+    pub(super) fn wrapping_pointer_offset(&self, ptr: PrimVal, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, PrimVal> {\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n         let offset = offset.overflowing_mul(pointee_size).0;\n-        Ok(ptr.wrapping_signed_offset(offset, self.memory.layout))\n+        ptr.wrapping_signed_offset(offset, self.memory.layout)\n     }\n \n-    pub(super) fn pointer_offset(&self, ptr: Pointer, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, Pointer> {\n+    pub(super) fn pointer_offset(&self, ptr: PrimVal, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, PrimVal> {\n         if offset == 0 {\n             // rustc relies on Offset-by-0 to be well-defined even for \"bad\" pointers like Unique::empty().\n             return Ok(ptr);\n         }\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n+        if pointee_size == 0 {\n+            // rustc relies on offsetting pointers to zsts to be a nop\n+            return Ok(ptr);\n+        }\n         return if let Some(offset) = offset.checked_mul(pointee_size) {\n             let ptr = ptr.signed_offset(offset, self.memory.layout)?;\n-            self.memory.check_bounds(ptr, false)?;\n+            self.memory.check_bounds(ptr.to_ptr()?, false)?;\n             Ok(ptr)\n         } else {\n             Err(EvalError::OverflowingMath)\n@@ -920,7 +947,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.monomorphize(operand.ty(self.mir(), self.tcx), self.substs())\n     }\n \n-    fn copy(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n+    fn copy(&mut self, src: PrimVal, dest: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n         let size = self.type_size(ty)?.expect(\"cannot copy from an unsized type\");\n         let align = self.type_align(ty)?;\n         self.memory.copy(src, dest, size, align)?;\n@@ -946,7 +973,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let substs = self.stack[frame].instance.substs;\n                         let ptr = self.alloc_ptr_with_substs(ty, substs)?;\n                         self.stack[frame].locals[local.index() - 1] = Some(Value::ByRef(ptr)); // it stays live\n-                        self.write_value_to_ptr(val, ptr, ty)?;\n+                        self.write_value_to_ptr(val, PrimVal::Ptr(ptr), ty)?;\n                         let lval = Lvalue::from_ptr(ptr);\n                         if let Some((field, field_ty)) = field {\n                             self.lvalue_field(lval, field, ty, field_ty)?\n@@ -964,7 +991,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     _ => {\n                         let ptr = self.alloc_ptr_with_substs(global_val.ty, cid.instance.substs)?;\n                         self.memory.mark_static(ptr.alloc_id);\n-                        self.write_value_to_ptr(global_val.value, ptr, global_val.ty)?;\n+                        self.write_value_to_ptr(global_val.value, PrimVal::Ptr(ptr), global_val.ty)?;\n                         // see comment on `initialized` field\n                         if global_val.initialized {\n                             self.memory.mark_static_initalized(ptr.alloc_id, global_val.mutable)?;\n@@ -1067,7 +1094,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             //\n             // Thus, it would be an error to replace the `ByRef` with a `ByVal`, unless we\n             // knew for certain that there were no outstanding pointers to this allocation.\n-            self.write_value_to_ptr(src_val, dest_ptr, dest_ty)?;\n+            self.write_value_to_ptr(src_val, PrimVal::Ptr(dest_ptr), dest_ty)?;\n \n         } else if let Value::ByRef(src_ptr) = src_val {\n             // If the value is not `ByRef`, then we know there are no pointers to it\n@@ -1085,7 +1112,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 write_dest(self, src_val)?;\n             } else {\n                 let dest_ptr = self.alloc_ptr(dest_ty)?;\n-                self.copy(src_ptr, dest_ptr, dest_ty)?;\n+                self.copy(PrimVal::Ptr(src_ptr), PrimVal::Ptr(dest_ptr), dest_ty)?;\n                 write_dest(self, Value::ByRef(dest_ptr))?;\n             }\n \n@@ -1100,16 +1127,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn write_value_to_ptr(\n         &mut self,\n         value: Value,\n-        dest: Pointer,\n+        dest: PrimVal,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         match value {\n-            Value::ByRef(ptr) => self.copy(ptr, dest, dest_ty),\n+            Value::ByRef(ptr) => self.copy(PrimVal::Ptr(ptr), dest, dest_ty),\n             Value::ByVal(primval) => {\n                 let size = self.type_size(dest_ty)?.expect(\"dest type must be sized\");\n                 self.memory.write_primval(dest, primval, size)\n             }\n-            Value::ByValPair(a, b) => self.write_pair_to_ptr(a, b, dest, dest_ty),\n+            Value::ByValPair(a, b) => self.write_pair_to_ptr(a, b, dest.to_ptr()?, dest_ty),\n         }\n     }\n \n@@ -1130,8 +1157,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let field_1_ty = self.get_field_ty(ty, 1)?;\n         let field_0_size = self.type_size(field_0_ty)?.expect(\"pair element type must be sized\");\n         let field_1_size = self.type_size(field_1_ty)?.expect(\"pair element type must be sized\");\n-        self.memory.write_primval(ptr.offset(field_0, self.memory.layout)?, a, field_0_size)?;\n-        self.memory.write_primval(ptr.offset(field_1, self.memory.layout)?, b, field_1_size)?;\n+        self.memory.write_primval(PrimVal::Ptr(ptr.offset(field_0, self.memory.layout)?), a, field_0_size)?;\n+        self.memory.write_primval(PrimVal::Ptr(ptr.offset(field_1, self.memory.layout)?), b, field_1_size)?;\n         Ok(())\n     }\n \n@@ -1242,20 +1269,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn read_ptr(&mut self, ptr: Pointer, pointee_ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub(crate) fn read_ptr(&self, ptr: Pointer, pointee_ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         let p = self.memory.read_ptr(ptr)?;\n         if self.type_is_sized(pointee_ty) {\n-            Ok(Value::ByVal(PrimVal::Ptr(p)))\n+            Ok(Value::ByVal(p))\n         } else {\n             trace!(\"reading fat pointer extra of type {}\", pointee_ty);\n             let extra = ptr.offset(self.memory.pointer_size(), self.memory.layout)?;\n             let extra = match self.tcx.struct_tail(pointee_ty).sty {\n-                ty::TyDynamic(..) => PrimVal::Ptr(self.memory.read_ptr(extra)?),\n+                ty::TyDynamic(..) => self.memory.read_ptr(extra)?,\n                 ty::TySlice(..) |\n                 ty::TyStr => PrimVal::from_u128(self.memory.read_usize(extra)? as u128),\n                 _ => bug!(\"unsized primval ptr read from {:?}\", pointee_ty),\n             };\n-            Ok(Value::ByValPair(PrimVal::Ptr(p), extra))\n+            Ok(Value::ByValPair(p, extra))\n         }\n     }\n \n@@ -1301,7 +1328,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             ty::TyFloat(FloatTy::F32) => PrimVal::from_f32(self.memory.read_f32(ptr)?),\n             ty::TyFloat(FloatTy::F64) => PrimVal::from_f64(self.memory.read_f64(ptr)?),\n \n-            ty::TyFnPtr(_) => self.memory.read_ptr(ptr).map(PrimVal::Ptr)?,\n+            ty::TyFnPtr(_) => self.memory.read_ptr(ptr)?,\n             ty::TyRef(_, ref tam) |\n             ty::TyRawPtr(ref tam) => return self.read_ptr(ptr, tam.ty).map(Some),\n \n@@ -1360,7 +1387,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n                 let ptr = src.read_ptr(&self.memory)?;\n                 let len = PrimVal::from_u128(length as u128);\n-                let ptr = PrimVal::Ptr(ptr);\n                 self.write_value(Value::ByValPair(ptr, len), dest, dest_ty)\n             }\n             (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n@@ -1374,7 +1400,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let trait_ref = self.tcx.erase_regions(&trait_ref);\n                 let vtable = self.get_vtable(src_pointee_ty, trait_ref)?;\n                 let ptr = src.read_ptr(&self.memory)?;\n-                let ptr = PrimVal::Ptr(ptr);\n                 let extra = PrimVal::Ptr(vtable);\n                 self.write_value(Value::ByValPair(ptr, extra), dest, dest_ty)\n             },\n@@ -1423,7 +1448,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n \n                 // FIXME(solson)\n-                let dest = self.force_allocation(dest)?.to_ptr();\n+                let dest = self.force_allocation(dest)?.to_ptr()?;\n                 let iter = src_fields.zip(dst_fields).enumerate();\n                 for (i, (src_f, dst_f)) in iter {\n                     let src_fty = monomorphize_field_ty(self.tcx, src_f, substs_a);\n@@ -1436,7 +1461,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let src_f_ptr = src_ptr.offset(src_field_offset, self.memory.layout)?;\n                     let dst_f_ptr = dest.offset(dst_field_offset, self.memory.layout)?;\n                     if src_fty == dst_fty {\n-                        self.copy(src_f_ptr, dst_f_ptr, src_fty)?;\n+                        self.copy(PrimVal::Ptr(src_f_ptr), PrimVal::Ptr(dst_f_ptr), src_fty)?;\n                     } else {\n                         self.unsize_into(Value::ByRef(src_f_ptr), src_fty, Lvalue::from_ptr(dst_f_ptr), dst_fty)?;\n                     }\n@@ -1633,7 +1658,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                 start_mir.span,\n                 start_mir,\n                 Lvalue::from_ptr(ret_ptr),\n-                StackPopCleanup::None,\n+                StackPopCleanup::Tls(None),\n             )?;\n \n             let mut args = ecx.frame().mir.args_iter();\n@@ -1659,8 +1684,8 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                 main_instance,\n                 main_mir.span,\n                 main_mir,\n-                Lvalue::from_ptr(Pointer::zst_ptr()),\n-                StackPopCleanup::None,\n+                Lvalue::zst(),\n+                StackPopCleanup::Tls(None),\n             )?;\n         }\n "}, {"sha": "f409f3734848a514f74dcbc9d6b2851a9251a0ad", "filename": "src/lvalue.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -12,7 +12,10 @@ use value::{PrimVal, Value};\n pub enum Lvalue<'tcx> {\n     /// An lvalue referring to a value allocated in the `Memory` system.\n     Ptr {\n-        ptr: Pointer,\n+        /// An lvalue may have an invalid (integral or undef) pointer,\n+        /// since it might be turned back into a reference\n+        /// before ever being dereferenced.\n+        ptr: PrimVal,\n         extra: LvalueExtra,\n     },\n \n@@ -61,22 +64,35 @@ pub struct Global<'tcx> {\n }\n \n impl<'tcx> Lvalue<'tcx> {\n-    pub fn from_ptr(ptr: Pointer) -> Self {\n+    /// Produces an Lvalue that will error if attempted to be read from\n+    pub fn undef() -> Self {\n+        Self::from_primval_ptr(PrimVal::Undef)\n+    }\n+\n+    fn from_primval_ptr(ptr: PrimVal) -> Self {\n         Lvalue::Ptr { ptr, extra: LvalueExtra::None }\n     }\n \n-    pub(super) fn to_ptr_and_extra(self) -> (Pointer, LvalueExtra) {\n+    pub fn zst() -> Self {\n+        Self::from_ptr(Pointer::zst_ptr())\n+    }\n+\n+    pub fn from_ptr(ptr: Pointer) -> Self {\n+        Self::from_primval_ptr(PrimVal::Ptr(ptr))\n+    }\n+\n+    pub(super) fn to_ptr_and_extra(self) -> (PrimVal, LvalueExtra) {\n         match self {\n             Lvalue::Ptr { ptr, extra } => (ptr, extra),\n             _ => bug!(\"to_ptr_and_extra: expected Lvalue::Ptr, got {:?}\", self),\n \n         }\n     }\n \n-    pub(super) fn to_ptr(self) -> Pointer {\n+    pub(super) fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n         let (ptr, extra) = self.to_ptr_and_extra();\n         assert_eq!(extra, LvalueExtra::None);\n-        ptr\n+        ptr.to_ptr()\n     }\n \n     pub(super) fn elem_ty_and_len(self, ty: Ty<'tcx>) -> (Ty<'tcx>, u64) {\n@@ -127,7 +143,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match lvalue {\n             Lvalue::Ptr { ptr, extra } => {\n                 assert_eq!(extra, LvalueExtra::None);\n-                Ok(Value::ByRef(ptr))\n+                Ok(Value::ByRef(ptr.to_ptr()?))\n             }\n             Lvalue::Local { frame, local, field } => {\n                 self.stack[frame].get_local(local, field.map(|(i, _)| i))\n@@ -167,7 +183,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         field_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n         let base_layout = self.type_layout(base_ty)?;\n-\n         use rustc::ty::layout::Layout::*;\n         let (offset, packed) = match *base_layout {\n             Univariant { ref variant, .. } => {\n@@ -229,19 +244,24 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Lvalue::Local { frame, local, field } => match self.stack[frame].get_local(local, field.map(|(i, _)| i))? {\n                 Value::ByRef(ptr) => {\n                     assert!(field.is_none(), \"local can't be ByRef and have a field offset\");\n-                    (ptr, LvalueExtra::None)\n+                    (PrimVal::Ptr(ptr), LvalueExtra::None)\n                 },\n                 Value::ByVal(PrimVal::Undef) => {\n                     // FIXME: allocate in fewer cases\n                     if self.ty_to_primval_kind(base_ty).is_ok() {\n                         return Ok(base);\n                     } else {\n-                        (self.force_allocation(base)?.to_ptr(), LvalueExtra::None)\n+                        (PrimVal::Ptr(self.force_allocation(base)?.to_ptr()?), LvalueExtra::None)\n                     }\n                 },\n                 Value::ByVal(_) => {\n-                    assert_eq!(field_index, 0, \"ByVal can only have 1 non zst field with offset 0\");\n-                    return Ok(base);\n+                    if self.get_field_count(base_ty)? == 1 {\n+                        assert_eq!(field_index, 0, \"ByVal can only have 1 non zst field with offset 0\");\n+                        return Ok(base);\n+                    }\n+                    // this branch is taken when a union creates a large ByVal which is then\n+                    // accessed as a struct with multiple small fields\n+                    (PrimVal::Ptr(self.force_allocation(base)?.to_ptr()?), LvalueExtra::None)\n                 },\n                 Value::ByValPair(_, _) => {\n                     let field_count = self.get_field_count(base_ty)?;\n@@ -264,7 +284,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         let offset = match base_extra {\n             LvalueExtra::Vtable(tab) => {\n-                let (_, align) = self.size_and_align_of_dst(base_ty, Value::ByValPair(PrimVal::Ptr(base_ptr), PrimVal::Ptr(tab)))?;\n+                let (_, align) = self.size_and_align_of_dst(base_ty, Value::ByValPair(base_ptr, PrimVal::Ptr(tab)))?;\n                 offset.abi_align(Align::from_bytes(align, align).unwrap()).bytes()\n             }\n             _ => offset.bytes(),\n@@ -276,7 +296,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         if packed {\n             let size = self.type_size(field_ty)?.expect(\"packed struct must be sized\");\n-            self.memory.mark_packed(ptr, size);\n+            self.memory.mark_packed(ptr.to_ptr()?, size);\n         }\n \n         let extra = if self.type_is_sized(field_ty) {"}, {"sha": "ac2d391f4217ec7b683612020891e57d3a226aa3", "filename": "src/memory.rs", "status": "modified", "additions": 73, "deletions": 84, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -6,7 +6,7 @@ use rustc::ty;\n use rustc::ty::layout::{self, TargetDataLayout};\n \n use error::{EvalError, EvalResult};\n-use value::PrimVal;\n+use value::{PrimVal, self};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Allocations and pointers\n@@ -61,70 +61,31 @@ impl Pointer {\n     }\n \n     pub fn wrapping_signed_offset<'tcx>(self, i: i64, layout: &TargetDataLayout) -> Self {\n-        Pointer::new(self.alloc_id, (self.offset.wrapping_add(i as u64) as u128 % (1u128 << layout.pointer_size.bits())) as u64)\n+        Pointer::new(self.alloc_id, value::wrapping_signed_offset(self.offset, i, layout))\n     }\n \n     pub fn signed_offset<'tcx>(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n-        // FIXME: is it possible to over/underflow here?\n-        if i < 0 {\n-            // trickery to ensure that i64::min_value() works fine\n-            // this formula only works for true negative values, it panics for zero!\n-            let n = u64::max_value() - (i as u64) + 1;\n-            if let Some(res) = self.offset.checked_sub(n) {\n-                Ok(Pointer::new(self.alloc_id, res))\n-            } else {\n-                Err(EvalError::OverflowingMath)\n-            }\n-        } else {\n-            self.offset(i as u64, layout)\n-        }\n+        Ok(Pointer::new(self.alloc_id, value::signed_offset(self.offset, i, layout)?))\n     }\n \n     pub fn offset<'tcx>(self, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n-        if let Some(res) = self.offset.checked_add(i) {\n-            if res as u128 >= (1u128 << layout.pointer_size.bits()) {\n-                Err(EvalError::OverflowingMath)\n-            } else {\n-                Ok(Pointer::new(self.alloc_id, res))\n-            }\n-        } else {\n-            Err(EvalError::OverflowingMath)\n-        }\n+        Ok(Pointer::new(self.alloc_id, value::offset(self.offset, i, layout)?))\n     }\n \n     pub fn points_to_zst(&self) -> bool {\n         self.alloc_id == ZST_ALLOC_ID\n     }\n \n-    pub fn to_int<'tcx>(&self) -> EvalResult<'tcx, u64> {\n-        match self.alloc_id {\n-            NEVER_ALLOC_ID => Ok(self.offset),\n-            _ => Err(EvalError::ReadPointerAsBytes),\n-        }\n-    }\n-\n-    pub fn from_int(i: u64) -> Self {\n-        Pointer::new(NEVER_ALLOC_ID, i)\n-    }\n-\n     pub fn zst_ptr() -> Self {\n         Pointer::new(ZST_ALLOC_ID, 0)\n     }\n-\n-    pub fn never_ptr() -> Self {\n-        Pointer::new(NEVER_ALLOC_ID, 0)\n-    }\n-    \n-    pub fn is_null_ptr(&self) -> bool {\n-        return *self == Pointer::from_int(0)\n-    }\n }\n \n pub type TlsKey = usize;\n \n #[derive(Copy, Clone, Debug)]\n pub struct TlsEntry<'tcx> {\n-    data: Pointer, // Will eventually become a map from thread IDs to pointers, if we ever support more than one thread.\n+    data: PrimVal, // Will eventually become a map from thread IDs to `PrimVal`s, if we ever support more than one thread.\n     dtor: Option<ty::Instance<'tcx>>,\n }\n \n@@ -180,14 +141,13 @@ pub struct Memory<'a, 'tcx> {\n     literal_alloc_cache: HashMap<Vec<u8>, AllocId>,\n \n     /// pthreads-style thread-local storage.\n-    thread_local: HashMap<TlsKey, TlsEntry<'tcx>>,\n+    thread_local: BTreeMap<TlsKey, TlsEntry<'tcx>>,\n \n     /// The Key to use for the next thread-local allocation.\n     next_thread_local: TlsKey,\n }\n \n const ZST_ALLOC_ID: AllocId = AllocId(0);\n-const NEVER_ALLOC_ID: AllocId = AllocId(1);\n \n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn new(layout: &'a TargetDataLayout, max_memory: u64) -> Self {\n@@ -202,7 +162,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             packed: BTreeSet::new(),\n             static_alloc: HashSet::new(),\n             literal_alloc_cache: HashMap::new(),\n-            thread_local: HashMap::new(),\n+            thread_local: BTreeMap::new(),\n             next_thread_local: 0,\n         }\n     }\n@@ -395,7 +355,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub(crate) fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n         let new_key = self.next_thread_local;\n         self.next_thread_local += 1;\n-        self.thread_local.insert(new_key, TlsEntry { data: Pointer::from_int(0), dtor });\n+        self.thread_local.insert(new_key, TlsEntry { data: PrimVal::Bytes(0), dtor });\n         trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n         return new_key;\n     }\n@@ -410,7 +370,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub(crate) fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer> {\n+    pub(crate) fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, PrimVal> {\n         return match self.thread_local.get(&key) {\n             Some(&TlsEntry { data, .. }) => {\n                 trace!(\"TLS key {} loaded: {:?}\", key, data);\n@@ -420,7 +380,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub(crate) fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx> {\n+    pub(crate) fn store_tls(&mut self, key: TlsKey, new_data: PrimVal) -> EvalResult<'tcx> {\n         return match self.thread_local.get_mut(&key) {\n             Some(&mut TlsEntry { ref mut data, .. }) => {\n                 trace!(\"TLS key {} stored: {:?}\", key, new_data);\n@@ -431,14 +391,36 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n     \n-    // Returns a dtor and its argument, if one is supposed to run\n-    pub(crate) fn fetch_tls_dtor(&mut self) -> Option<(ty::Instance<'tcx>, Pointer)> {\n-        for (_, &mut TlsEntry { ref mut data, dtor }) in self.thread_local.iter_mut() {\n-            if !data.is_null_ptr() {\n+    /// Returns a dtor, its argument and its index, if one is supposed to run\n+    ///\n+    /// An optional destructor function may be associated with each key value.\n+    /// At thread exit, if a key value has a non-NULL destructor pointer,\n+    /// and the thread has a non-NULL value associated with that key,\n+    /// the value of the key is set to NULL, and then the function pointed\n+    /// to is called with the previously associated value as its sole argument.\n+    /// The order of destructor calls is unspecified if more than one destructor\n+    /// exists for a thread when it exits.\n+    ///\n+    /// If, after all the destructors have been called for all non-NULL values\n+    /// with associated destructors, there are still some non-NULL values with\n+    /// associated destructors, then the process is repeated.\n+    /// If, after at least {PTHREAD_DESTRUCTOR_ITERATIONS} iterations of destructor\n+    /// calls for outstanding non-NULL values, there are still some non-NULL values\n+    /// with associated destructors, implementations may stop calling destructors,\n+    /// or they may continue calling destructors until no non-NULL values with\n+    /// associated destructors exist, even though this might result in an infinite loop.\n+    pub(crate) fn fetch_tls_dtor(&mut self, key: Option<TlsKey>) -> Option<(ty::Instance<'tcx>, PrimVal, TlsKey)> {\n+        use std::collections::Bound::*;\n+        let start = match key {\n+            Some(key) => Excluded(key),\n+            None => Unbounded,\n+        };\n+        for (&key, &mut TlsEntry { ref mut data, dtor }) in self.thread_local.range_mut((start, Unbounded)) {\n+            if *data != PrimVal::Bytes(0) {\n                 if let Some(dtor) = dtor {\n-                    let old_data = *data;\n-                    *data = Pointer::from_int(0);\n-                    return Some((dtor, old_data));\n+                    let ret = Some((dtor, *data, key));\n+                    *data = PrimVal::Bytes(0);\n+                    return ret;\n                 }\n             }\n         }\n@@ -467,7 +449,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             Some(alloc) => Ok(alloc),\n             None => match self.functions.get(&id) {\n                 Some(_) => Err(EvalError::DerefFunctionPointer),\n-                None if id == NEVER_ALLOC_ID || id == ZST_ALLOC_ID => Err(EvalError::InvalidMemoryAccess),\n+                None if id == ZST_ALLOC_ID => Err(EvalError::InvalidMemoryAccess),\n                 None => Err(EvalError::DanglingPointerDeref),\n             }\n         }\n@@ -482,7 +464,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             },\n             None => match self.functions.get(&id) {\n                 Some(_) => Err(EvalError::DerefFunctionPointer),\n-                None if id == NEVER_ALLOC_ID || id == ZST_ALLOC_ID => Err(EvalError::InvalidMemoryAccess),\n+                None if id == ZST_ALLOC_ID => Err(EvalError::InvalidMemoryAccess),\n                 None => Err(EvalError::DanglingPointerDeref),\n             }\n         }\n@@ -513,7 +495,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         let mut allocs_seen = HashSet::new();\n \n         while let Some(id) = allocs_to_print.pop_front() {\n-            if id == ZST_ALLOC_ID || id == NEVER_ALLOC_ID { continue; }\n+            if id == ZST_ALLOC_ID { continue; }\n             let mut msg = format!(\"Alloc {:<5} \", format!(\"{}:\", id));\n             let prefix_len = msg.len();\n             let mut relocations = vec![];\n@@ -563,7 +545,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                     write!(msg, \"{:1$}\", \"\", ((i - pos) * 3) as usize).unwrap();\n                     let target = match target_id {\n                         ZST_ALLOC_ID => String::from(\"zst\"),\n-                        NEVER_ALLOC_ID => String::from(\"int ptr\"),\n                         _ => format!(\"({})\", target_id),\n                     };\n                     // this `as usize` is fine, since we can't print more chars than `usize::MAX`\n@@ -622,9 +603,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     fn get_bytes(&self, ptr: Pointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {\n-        if size == 0 {\n-            return Ok(&[]);\n-        }\n+        assert_ne!(size, 0);\n         if self.relocations(ptr, size)?.count() != 0 {\n             return Err(EvalError::ReadPointerAsBytes);\n         }\n@@ -633,11 +612,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     fn get_bytes_mut(&mut self, ptr: Pointer, size: u64, align: u64) -> EvalResult<'tcx, &mut [u8]> {\n-        if size == 0 {\n-            return Ok(&mut []);\n-        }\n+        assert_ne!(size, 0);\n         self.clear_relocations(ptr, size)?;\n-        self.mark_definedness(ptr, size, true)?;\n+        self.mark_definedness(PrimVal::Ptr(ptr), size, true)?;\n         self.get_bytes_unchecked_mut(ptr, size, align)\n     }\n }\n@@ -647,7 +624,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     /// mark an allocation as being the entry point to a static (see `static_alloc` field)\n     pub fn mark_static(&mut self, alloc_id: AllocId) {\n         trace!(\"mark_static: {:?}\", alloc_id);\n-        if alloc_id != NEVER_ALLOC_ID && alloc_id != ZST_ALLOC_ID && !self.static_alloc.insert(alloc_id) {\n+        if alloc_id != ZST_ALLOC_ID && !self.static_alloc.insert(alloc_id) {\n             bug!(\"tried to mark an allocation ({:?}) as static twice\", alloc_id);\n         }\n     }\n@@ -677,7 +654,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                 // mark recursively\n                 mem::replace(relocations, Default::default())\n             },\n-            None if alloc_id == NEVER_ALLOC_ID || alloc_id == ZST_ALLOC_ID => return Ok(()),\n+            None if alloc_id == ZST_ALLOC_ID => return Ok(()),\n             None if !self.functions.contains_key(&alloc_id) => return Err(EvalError::DanglingPointerDeref),\n             _ => return Ok(()),\n         };\n@@ -690,10 +667,12 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn copy(&mut self, src: Pointer, dest: Pointer, size: u64, align: u64) -> EvalResult<'tcx> {\n+    pub fn copy(&mut self, src: PrimVal, dest: PrimVal, size: u64, align: u64) -> EvalResult<'tcx> {\n         if size == 0 {\n             return Ok(());\n         }\n+        let src = src.to_ptr()?;\n+        let dest = dest.to_ptr()?;\n         self.check_relocation_edges(src, size)?;\n \n         let src_bytes = self.get_bytes_unchecked(src, size, align)?.as_ptr();\n@@ -733,55 +712,64 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn read_bytes(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, &[u8]> {\n-        self.get_bytes(ptr, size, 1)\n+    pub fn read_bytes(&self, ptr: PrimVal, size: u64) -> EvalResult<'tcx, &[u8]> {\n+        if size == 0 {\n+            return Ok(&[]);\n+        }\n+        self.get_bytes(ptr.to_ptr()?, size, 1)\n     }\n \n     pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<'tcx> {\n+        if src.is_empty() {\n+            return Ok(());\n+        }\n         let bytes = self.get_bytes_mut(ptr, src.len() as u64, 1)?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n \n     pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: u64) -> EvalResult<'tcx> {\n+        if count == 0 {\n+            return Ok(());\n+        }\n         let bytes = self.get_bytes_mut(ptr, count, 1)?;\n         for b in bytes { *b = val; }\n         Ok(())\n     }\n \n-    pub fn read_ptr(&self, ptr: Pointer) -> EvalResult<'tcx, Pointer> {\n+    pub fn read_ptr(&self, ptr: Pointer) -> EvalResult<'tcx, PrimVal> {\n         let size = self.pointer_size();\n-        self.check_defined(ptr, size)?;\n+        if self.check_defined(ptr, size).is_err() {\n+            return Ok(PrimVal::Undef);\n+        }\n         let endianess = self.endianess();\n         let bytes = self.get_bytes_unchecked(ptr, size, size)?;\n         let offset = read_target_uint(endianess, bytes).unwrap();\n         assert_eq!(offset as u64 as u128, offset);\n         let offset = offset as u64;\n         let alloc = self.get(ptr.alloc_id)?;\n         match alloc.relocations.get(&ptr.offset) {\n-            Some(&alloc_id) => Ok(Pointer::new(alloc_id, offset)),\n-            None => Ok(Pointer::from_int(offset)),\n+            Some(&alloc_id) => Ok(PrimVal::Ptr(Pointer::new(alloc_id, offset))),\n+            None => Ok(PrimVal::Bytes(offset as u128)),\n         }\n     }\n \n     pub fn write_ptr(&mut self, dest: Pointer, ptr: Pointer) -> EvalResult<'tcx> {\n         self.write_usize(dest, ptr.offset as u64)?;\n-        if ptr.alloc_id != NEVER_ALLOC_ID {\n-            self.get_mut(dest.alloc_id)?.relocations.insert(dest.offset, ptr.alloc_id);\n-        }\n+        self.get_mut(dest.alloc_id)?.relocations.insert(dest.offset, ptr.alloc_id);\n         Ok(())\n     }\n \n     pub fn write_primval(\n         &mut self,\n-        dest: Pointer,\n+        dest: PrimVal,\n         val: PrimVal,\n         size: u64,\n     ) -> EvalResult<'tcx> {\n         match val {\n             PrimVal::Ptr(ptr) => {\n                 assert_eq!(size, self.pointer_size());\n-                self.write_ptr(dest, ptr)\n+                self.write_ptr(dest.to_ptr()?, ptr)\n             }\n \n             PrimVal::Bytes(bytes) => {\n@@ -795,7 +783,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                     16 => !0,\n                     _ => bug!(\"unexpected PrimVal::Bytes size\"),\n                 };\n-                self.write_uint(dest, bytes & mask, size)\n+                self.write_uint(dest.to_ptr()?, bytes & mask, size)\n             }\n \n             PrimVal::Undef => self.mark_definedness(dest, size, false),\n@@ -981,13 +969,14 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn mark_definedness(\n         &mut self,\n-        ptr: Pointer,\n+        ptr: PrimVal,\n         size: u64,\n         new_state: bool\n     ) -> EvalResult<'tcx> {\n         if size == 0 {\n             return Ok(())\n         }\n+        let ptr = ptr.to_ptr()?;\n         let mut alloc = self.get_mut(ptr.alloc_id)?;\n         alloc.undef_mask.set_range(ptr.offset, ptr.offset + size, new_state);\n         Ok(())"}, {"sha": "0303fbe1f79f62ac11cbcc89dbfd02f7efb46d77", "filename": "src/operator.rs", "status": "modified", "additions": 41, "deletions": 54, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -4,7 +4,6 @@ use rustc::ty::{self, Ty};\n use error::{EvalError, EvalResult};\n use eval_context::EvalContext;\n use lvalue::Lvalue;\n-use memory::Pointer;\n use value::{\n     PrimVal,\n     PrimValKind,\n@@ -73,6 +72,7 @@ macro_rules! int_arithmetic {\n     ($kind:expr, $int_op:ident, $l:expr, $r:expr) => ({\n         let l = $l;\n         let r = $r;\n+        use value::PrimValKind::*;\n         match $kind {\n             I8  => overflow!($int_op, l as i8,  r as i8),\n             I16 => overflow!($int_op, l as i16, r as i16),\n@@ -143,48 +143,50 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         use rustc::mir::BinOp::*;\n         use value::PrimValKind::*;\n \n-        // FIXME(solson): Temporary hack. It will go away when we get rid of Pointer's ability to store\n-        // plain bytes, and leave that to PrimVal::Bytes.\n-        fn normalize(val: PrimVal) -> PrimVal {\n-            if let PrimVal::Ptr(ptr) = val {\n-                if let Ok(bytes) = ptr.to_int() {\n-                    return PrimVal::Bytes(bytes as u128);\n-                }\n-            }\n-            val\n-        }\n-        let (left, right) = (normalize(left), normalize(right));\n-\n         let left_kind  = self.ty_to_primval_kind(left_ty)?;\n         let right_kind = self.ty_to_primval_kind(right_ty)?;\n \n         // Offset is handled early, before we dispatch to unrelated_ptr_ops.  We have to also catch the case where both arguments *are* convertible to integers.\n         if bin_op == Offset {\n             if left_kind == Ptr && right_kind == PrimValKind::from_uint_size(self.memory.pointer_size()) {\n                 let pointee_ty = left_ty.builtin_deref(true, ty::LvaluePreference::NoPreference).expect(\"Offset called on non-ptr type\").ty;\n-                let ptr = self.pointer_offset(left.to_ptr()?, pointee_ty, right.to_bytes()? as i64)?;\n-                return Ok((PrimVal::Ptr(ptr), false));\n+                let ptr = self.pointer_offset(left, pointee_ty, right.to_bytes()? as i64)?;\n+                return Ok((ptr, false));\n             } else {\n                 bug!(\"Offset used with wrong type\");\n             }\n         }\n \n-        let (l, r) = match (left, right) {\n-            (PrimVal::Bytes(left_bytes), PrimVal::Bytes(right_bytes)) => (left_bytes, right_bytes),\n-\n-            // One argument is a pointer value -- this is handled separately\n-            (PrimVal::Ptr(left_ptr), PrimVal::Ptr(right_ptr)) => {\n-                return self.ptr_ops(bin_op, left_ptr, left_kind, right_ptr, right_kind);\n-            }\n-            (PrimVal::Ptr(ptr), PrimVal::Bytes(bytes)) => {\n-                return self.ptr_ops(bin_op, ptr, left_kind, Pointer::from_int(bytes as u64), right_kind);\n+        // unrelated pointer ops\n+        let op: Option<fn(&PrimVal, &PrimVal) -> bool> = match bin_op {\n+            Eq => Some(PrimVal::eq),\n+            Ne => Some(PrimVal::ne),\n+            _ => None,\n+        };\n+        if let Some(op) = op {\n+            // only floats can't be binary compared\n+            let ok = left_kind != F32 && left_kind != F64;\n+            let ok = ok && right_kind != F32 && right_kind != F64;\n+            if ok {\n+                return Ok((PrimVal::from_bool(op(&left, &right)), false));\n             }\n-            (PrimVal::Bytes(bytes), PrimVal::Ptr(ptr)) => {\n-                return self.ptr_ops(bin_op, Pointer::from_int(bytes as u64), left_kind, ptr, right_kind);\n+        }\n+\n+        \n+        if let (Ok(left), Ok(right)) = (left.to_ptr(), right.to_ptr()) {\n+            if left.alloc_id == right.alloc_id {\n+                return self.ptr_ops(\n+                    bin_op,\n+                    left.offset,\n+                    right.offset,\n+                );\n+            } else {\n+                return Err(EvalError::InvalidPointerMath);\n             }\n+        }\n \n-            (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n-        };\n+        let l = left.to_bytes()?;\n+        let r = right.to_bytes()?;\n \n         // These ops can have an RHS with a different numeric type.\n         if right_kind.is_int() && (bin_op == Shl || bin_op == Shr) {\n@@ -260,41 +262,26 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn ptr_ops(\n         &self,\n         bin_op: mir::BinOp,\n-        left: Pointer,\n-        left_kind: PrimValKind,\n-        right: Pointer,\n-        right_kind: PrimValKind,\n+        left: u64,\n+        right: u64,\n     ) -> EvalResult<'tcx, (PrimVal, bool)> {\n         use rustc::mir::BinOp::*;\n-        use value::PrimValKind::*;\n-\n-        if left_kind != right_kind || !(left_kind.is_ptr() || left_kind == PrimValKind::from_uint_size(self.memory.pointer_size())) {\n-            let msg = format!(\"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n-            return Err(EvalError::Unimplemented(msg));\n-        }\n \n         let val = match bin_op {\n             Eq => PrimVal::from_bool(left == right),\n             Ne => PrimVal::from_bool(left != right),\n             Lt | Le | Gt | Ge => {\n-                if left.alloc_id == right.alloc_id {\n-                    PrimVal::from_bool(match bin_op {\n-                        Lt => left.offset < right.offset,\n-                        Le => left.offset <= right.offset,\n-                        Gt => left.offset > right.offset,\n-                        Ge => left.offset >= right.offset,\n-                        _ => bug!(\"We already established it has to be a comparison operator.\"),\n-                    })\n-                } else {\n-                    return Err(EvalError::InvalidPointerMath);\n-                }\n+                PrimVal::from_bool(match bin_op {\n+                    Lt => left < right,\n+                    Le => left <= right,\n+                    Gt => left > right,\n+                    Ge => left >= right,\n+                    _ => bug!(\"We already established it has to be a comparison operator.\"),\n+                })\n             }\n             Sub => {\n-                if left.alloc_id == right.alloc_id {\n-                    return int_arithmetic!(left_kind, overflowing_sub, left.offset, right.offset);\n-                } else {\n-                    return Err(EvalError::InvalidPointerMath);\n-                }\n+                let usize = PrimValKind::from_uint_size(self.memory.pointer_size());\n+                return int_arithmetic!(usize, overflowing_sub, left, right);\n             }\n             _ => {\n                 return Err(EvalError::ReadPointerAsBytes);"}, {"sha": "48b9fecd3d39e47cd4e42ab972ff841ed410b8e7", "filename": "src/step.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -14,7 +14,6 @@ use error::{EvalResult, EvalError};\n use eval_context::{EvalContext, StackPopCleanup};\n use lvalue::{Global, GlobalId, Lvalue};\n use value::{Value, PrimVal};\n-use memory::Pointer;\n use syntax::codemap::Span;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n@@ -33,23 +32,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.memory.clear_packed();\n         self.inc_step_counter_and_check_limit(1)?;\n         if self.stack.is_empty() {\n-            if let Some((instance, ptr)) = self.memory.fetch_tls_dtor() {\n-                trace!(\"Running TLS dtor {:?} on {:?}\", instance, ptr);\n-                // TODO: Potientially, this has to support all the other possible instances? See eval_fn_call in terminator/mod.rs\n-                let mir = self.load_mir(instance.def)?;\n-                self.push_stack_frame(\n-                    instance,\n-                    mir.span,\n-                    mir,\n-                    Lvalue::from_ptr(Pointer::zst_ptr()),\n-                    StackPopCleanup::None,\n-                )?;\n-                let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()))?;\n-                let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n-                self.write_value(Value::ByVal(PrimVal::Ptr(ptr)), dest, ty)?;\n-                return Ok(true);\n-            }\n             return Ok(false);\n         }\n \n@@ -141,6 +123,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.deallocate_local(old_val)?;\n             }\n \n+            // Just a borrowck thing\n             EndRegion(..) => {}\n \n             // Defined to do nothing. These are added by optimization passes, to avoid changing the\n@@ -191,7 +174,7 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n         }\n         if self.ecx.tcx.has_attr(def_id, \"linkage\") {\n             trace!(\"Initializing an extern global with NULL\");\n-            self.ecx.globals.insert(cid, Global::initialized(self.ecx.tcx.type_of(def_id), Value::ByVal(PrimVal::Ptr(Pointer::from_int(0))), !shared));\n+            self.ecx.globals.insert(cid, Global::initialized(self.ecx.tcx.type_of(def_id), Value::ByVal(PrimVal::Bytes(0)), !shared));\n             return;\n         }\n         self.try(|this| {"}, {"sha": "663d05254e5ccd0fee6e4a8485ce4e7b8986e8b6", "filename": "src/terminator/drop.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fdrop.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -5,17 +5,16 @@ use syntax::codemap::Span;\n use error::EvalResult;\n use eval_context::{EvalContext, StackPopCleanup};\n use lvalue::{Lvalue, LvalueExtra};\n-use memory::Pointer;\n use value::PrimVal;\n use value::Value;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(crate) fn drop_lvalue(&mut self, lval: Lvalue<'tcx>, instance: ty::Instance<'tcx>, ty: Ty<'tcx>, span: Span) -> EvalResult<'tcx> {\n         trace!(\"drop_lvalue: {:#?}\", lval);\n         let val = match self.force_allocation(lval)? {\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Ptr(vtable)),\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len as u128)),\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::None } => Value::ByVal(PrimVal::Ptr(ptr)),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => Value::ByValPair(ptr, PrimVal::Ptr(vtable)),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => Value::ByValPair(ptr, PrimVal::Bytes(len as u128)),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::None } => Value::ByVal(ptr),\n             _ => bug!(\"force_allocation broken\"),\n         };\n         self.drop(val, instance, ty, span)\n@@ -50,7 +49,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             instance,\n             span,\n             mir,\n-            Lvalue::from_ptr(Pointer::zst_ptr()),\n+            Lvalue::zst(),\n             StackPopCleanup::None,\n         )?;\n "}, {"sha": "f6ef46ecbfb8e774b27da73a38207d62a5e899fd", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let result_ptr = self.wrapping_pointer_offset(ptr, substs.type_at(0), offset)?;\n-                self.write_primval(dest, PrimVal::Ptr(result_ptr), dest_ty)?;\n+                self.write_primval(dest, result_ptr, dest_ty)?;\n             }\n \n             \"assume\" => {\n@@ -60,7 +60,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_load_acq\" |\n             \"volatile_load\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].read_ptr(&self.memory)?.to_ptr()?;\n                 self.write_value(Value::ByRef(ptr), dest, ty)?;\n             }\n \n@@ -79,7 +79,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             _ if intrinsic_name.starts_with(\"atomic_xchg\") => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].read_ptr(&self.memory)?.to_ptr()?;\n                 let change = self.value_to_primval(arg_vals[1], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n@@ -93,7 +93,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].read_ptr(&self.memory)?.to_ptr()?;\n                 let expect_old = self.value_to_primval(arg_vals[1], ty)?;\n                 let change = self.value_to_primval(arg_vals[2], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n@@ -103,7 +103,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Value::ByValPair(..) => bug!(\"atomic_cxchg doesn't work with nonprimitives\"),\n                 };\n                 let (val, _) = self.binary_op(mir::BinOp::Eq, old, ty, expect_old, ty)?;\n-                let dest = self.force_allocation(dest)?.to_ptr();\n+                let dest = self.force_allocation(dest)?.to_ptr()?;\n                 self.write_pair_to_ptr(old, val, dest, dest_ty)?;\n                 self.write_primval(Lvalue::from_ptr(ptr), change, ty)?;\n             }\n@@ -114,7 +114,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_xadd\" | \"atomic_xadd_acq\" | \"atomic_xadd_rel\" | \"atomic_xadd_acqrel\" | \"atomic_xadd_relaxed\" |\n             \"atomic_xsub\" | \"atomic_xsub_acq\" | \"atomic_xsub_rel\" | \"atomic_xsub_acqrel\" | \"atomic_xsub_relaxed\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].read_ptr(&self.memory)?.to_ptr()?;\n                 let change = self.value_to_primval(arg_vals[1], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n@@ -143,11 +143,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // FIXME: check whether overlapping occurs\n                 let elem_ty = substs.type_at(0);\n                 let elem_size = self.type_size(elem_ty)?.expect(\"cannot copy unsized value\");\n-                let elem_align = self.type_align(elem_ty)?;\n-                let src = arg_vals[0].read_ptr(&self.memory)?;\n-                let dest = arg_vals[1].read_ptr(&self.memory)?;\n-                let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n-                self.memory.copy(src, dest, count * elem_size, elem_align)?;\n+                if elem_size != 0 {\n+                    let elem_align = self.type_align(elem_ty)?;\n+                    let src = arg_vals[0].read_ptr(&self.memory)?;\n+                    let dest = arg_vals[1].read_ptr(&self.memory)?;\n+                    let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n+                    self.memory.copy(src, dest, count * elem_size, elem_align)?;\n+                }\n             }\n \n             \"ctpop\" |\n@@ -163,7 +165,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"discriminant_value\" => {\n                 let ty = substs.type_at(0);\n-                let adt_ptr = arg_vals[0].read_ptr(&self.memory)?;\n+                let adt_ptr = arg_vals[0].read_ptr(&self.memory)?.to_ptr()?;\n                 let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n                 self.write_primval(dest, PrimVal::Bytes(discr_val), dest_ty)?;\n             }\n@@ -259,7 +261,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 match dest {\n                     Lvalue::Local { frame, local, field } => self.modify_local(frame, local, field.map(|(i, _)| i), init)?,\n-                    Lvalue::Ptr { ptr, extra: LvalueExtra::None } => self.memory.write_repeat(ptr, 0, size)?,\n+                    Lvalue::Ptr { ptr, extra: LvalueExtra::None } => self.memory.write_repeat(ptr.to_ptr()?, 0, size)?,\n                     Lvalue::Ptr { .. } => bug!(\"init intrinsic tried to write to fat ptr target\"),\n                     Lvalue::Global(cid) => self.modify_global(cid, init)?,\n                 }\n@@ -297,7 +299,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let result_ptr = self.pointer_offset(ptr, substs.type_at(0), offset)?;\n-                self.write_primval(dest, PrimVal::Ptr(result_ptr), dest_ty)?;\n+                self.write_primval(dest, result_ptr, dest_ty)?;\n             }\n \n             \"overflowing_sub\" => {\n@@ -388,9 +390,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let dest_align = self.type_align(dest_ty)?;\n                 let size = self.type_size(dest_ty)?.expect(\"transmute() type must be sized\");\n                 if dest_align < src_align {\n-                    let ptr = self.force_allocation(dest)?.to_ptr();\n+                    let ptr = self.force_allocation(dest)?.to_ptr()?;\n                     self.memory.mark_packed(ptr, size);\n-                    self.write_value_to_ptr(arg_vals[0], ptr, dest_ty)?;\n+                    self.write_value_to_ptr(arg_vals[0], PrimVal::Ptr(ptr), dest_ty)?;\n                 } else {\n                     self.write_value(arg_vals[0], dest, dest_ty)?;\n                 }\n@@ -401,7 +403,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let uninit = |this: &mut Self, val: Value| {\n                     match val {\n                         Value::ByRef(ptr) => {\n-                            this.memory.mark_definedness(ptr, size, false)?;\n+                            this.memory.mark_definedness(PrimVal::Ptr(ptr), size, false)?;\n                             Ok(Value::ByRef(ptr))\n                         },\n                         _ => Ok(Value::ByVal(PrimVal::Undef)),\n@@ -422,7 +424,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty_align = self.type_align(ty)?;\n                 let val_byte = self.value_to_primval(arg_vals[1], u8)?.to_u128()? as u8;\n                 let size = self.type_size(ty)?.expect(\"write_bytes() type must be sized\");\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].read_ptr(&self.memory)?.to_ptr()?;\n                 let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n                 if count > 0 {\n                     self.memory.check_align(ptr, ty_align, size * count)?;"}, {"sha": "d4e169cbcfb63d2fd3ce56e17887151e56eee85f", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -388,7 +388,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ptr_size = self.memory.pointer_size();\n                 let (_, vtable) = self.eval_operand(&arg_operands[0])?.expect_ptr_vtable_pair(&self.memory)?;\n                 let fn_ptr = self.memory.read_ptr(vtable.offset(ptr_size * (idx as u64 + 3), self.memory.layout)?)?;\n-                let instance = self.memory.get_fn(fn_ptr.alloc_id)?;\n+                let instance = self.memory.get_fn(fn_ptr.to_ptr()?.alloc_id)?;\n                 let mut arg_operands = arg_operands.to_vec();\n                 let ty = self.operand_ty(&arg_operands[0]);\n                 let ty = self.get_field_ty(ty, 0)?;\n@@ -431,11 +431,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         };\n         let (return_lvalue, return_to_block) = match destination {\n             Some((lvalue, block)) => (lvalue, StackPopCleanup::Goto(block)),\n-            None => {\n-                // FIXME(solson)\n-                let lvalue = Lvalue::from_ptr(Pointer::never_ptr());\n-                (lvalue, StackPopCleanup::None)\n-            }\n+            None => (Lvalue::undef(), StackPopCleanup::None),\n         };\n \n         self.push_stack_frame(\n@@ -579,15 +575,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"__rust_deallocate\" => {\n-                let ptr = args[0].read_ptr(&self.memory)?;\n+                let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n                 // FIXME: insert sanity check for size and align?\n                 let _old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n                 let _align = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 self.memory.deallocate(ptr)?;\n             },\n \n             \"__rust_reallocate\" => {\n-                let ptr = args[0].read_ptr(&self.memory)?;\n+                let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n                 let size = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 let align = self.value_to_primval(args[3], usize)?.to_u64()?;\n                 let new_ptr = self.memory.reallocate(ptr, size, align)?;\n@@ -598,7 +594,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // fn __rust_maybe_catch_panic(f: fn(*mut u8), data: *mut u8, data_ptr: *mut usize, vtable_ptr: *mut usize) -> u32\n                 // We abort on panic, so not much is going on here, but we still have to call the closure\n                 let u8_ptr_ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n-                let f = args[0].read_ptr(&self.memory)?;\n+                let f = args[0].read_ptr(&self.memory)?.to_ptr()?;\n                 let data = args[1].read_ptr(&self.memory)?;\n                 let f_instance = self.memory.get_fn(f.alloc_id)?;\n                 self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n@@ -610,13 +606,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     f_instance,\n                     mir.span,\n                     mir,\n-                    Lvalue::from_ptr(Pointer::zst_ptr()),\n+                    Lvalue::zst(),\n                     StackPopCleanup::Goto(dest_block),\n                 )?;\n \n                 let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\".to_owned()))?;\n                 let arg_dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                self.write_value(Value::ByVal(PrimVal::Ptr(data)), arg_dest, u8_ptr_ty)?;\n+                self.write_primval(arg_dest, data, u8_ptr_ty)?;\n \n                 // We ourselbes return 0\n                 self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n@@ -655,7 +651,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n                     let new_ptr = ptr.offset(num - idx as u64 - 1, self.memory.layout)?;\n-                    self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n+                    self.write_primval(dest, new_ptr, dest_ty)?;\n                 } else {\n                     self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n                 }\n@@ -667,15 +663,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n                     let new_ptr = ptr.offset(idx as u64, self.memory.layout)?;\n-                    self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n+                    self.write_primval(dest, new_ptr, dest_ty)?;\n                 } else {\n                     self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n                 }\n             }\n \n             \"getenv\" => {\n                 {\n-                    let name_ptr = args[0].read_ptr(&self.memory)?;\n+                    let name_ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n                     let name = self.memory.read_c_str(name_ptr)?;\n                     info!(\"ignored env var request for `{:?}`\", ::std::str::from_utf8(name));\n                 }\n@@ -718,16 +714,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"mmap\" => {\n                 // This is a horrible hack, but well... the guard page mechanism calls mmap and expects a particular return value, so we give it that value\n                 let addr = args[0].read_ptr(&self.memory)?;\n-                self.write_primval(dest, PrimVal::Ptr(addr), dest_ty)?;\n+                self.write_primval(dest, addr, dest_ty)?;\n             }\n \n             // Hook pthread calls that go to the thread-local storage memory subsystem\n             \"pthread_key_create\" => {\n                 let key_ptr = args[0].read_ptr(&self.memory)?;\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n-                let dtor_ptr = args[1].read_ptr(&self.memory)?;\n-                let dtor = if dtor_ptr.is_null_ptr() { None } else { Some(self.memory.get_fn(dtor_ptr.alloc_id)?) };\n+                let dtor = match args[1].read_ptr(&self.memory)? {\n+                    PrimVal::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr.alloc_id)?),\n+                    PrimVal::Bytes(0) => None,\n+                    PrimVal::Bytes(_) => return Err(EvalError::ReadBytesAsPointer),\n+                    PrimVal::Undef => return Err(EvalError::ReadUndefBytes),\n+                };\n \n                 // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n                 let key_type = self.operand_ty(&arg_operands[0]).builtin_deref(true, ty::LvaluePreference::NoPreference)\n@@ -743,7 +743,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     return Err(EvalError::OutOfTls);\n                 }\n                 // TODO: Does this need checking for alignment?\n-                self.memory.write_uint(key_ptr, key, key_size.bytes())?;\n+                self.memory.write_uint(key_ptr.to_ptr()?, key, key_size.bytes())?;\n \n                 // Return success (0)\n                 self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n@@ -759,7 +759,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n                 let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n                 let ptr = self.memory.load_tls(key)?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+                self.write_primval(dest, ptr, dest_ty)?;\n             }\n             \"pthread_setspecific\" => {\n                 // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t"}, {"sha": "3862e8c631a6e417f7bcb4251713a3f5f2cf0000", "filename": "src/traits.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftraits.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -2,14 +2,15 @@ use rustc::traits::{self, Reveal};\n \n use eval_context::EvalContext;\n use memory::Pointer;\n+use value::{Value, PrimVal};\n \n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n use syntax::codemap::DUMMY_SP;\n use syntax::ast;\n \n-use error::EvalResult;\n+use error::{EvalResult, EvalError};\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n@@ -73,16 +74,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     pub fn read_drop_type_from_vtable(&self, vtable: Pointer) -> EvalResult<'tcx, Option<ty::Instance<'tcx>>> {\n-        let drop_fn = self.memory.read_ptr(vtable)?;\n-\n-        // just a sanity check\n-        assert_eq!(drop_fn.offset, 0);\n-\n-        // some values don't need to call a drop impl, so the value is null\n-        if drop_fn == Pointer::from_int(0) {\n-            Ok(None)\n-        } else {\n-            self.memory.get_fn(drop_fn.alloc_id).map(Some)\n+        // we don't care about the pointee type, we just want a pointer\n+        match self.read_ptr(vtable, self.tcx.mk_nil_ptr())? {\n+            // some values don't need to call a drop impl, so the value is null\n+            Value::ByVal(PrimVal::Bytes(0)) => Ok(None),\n+            Value::ByVal(PrimVal::Ptr(drop_fn)) => self.memory.get_fn(drop_fn.alloc_id).map(Some),\n+            _ => Err(EvalError::ReadBytesAsPointer),\n         }\n     }\n "}, {"sha": "ef11c7a8e4752c80415ade9eaefba6833871d1bc", "filename": "src/value.rs", "status": "modified", "additions": 72, "deletions": 10, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -2,6 +2,7 @@\n #![allow(float_cmp)]\n \n use std::mem::transmute;\n+use rustc::ty::layout::TargetDataLayout;\n \n use error::{EvalError, EvalResult};\n use memory::{Memory, Pointer};\n@@ -47,7 +48,7 @@ pub enum Value {\n /// `memory::Allocation`. It is in many ways like a small chunk of a `Allocation`, up to 8 bytes in\n /// size. Like a range of bytes in an `Allocation`, a `PrimVal` can either represent the raw bytes\n /// of a simple value, a pointer into another `Allocation`, or be undefined.\n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n pub enum PrimVal {\n     /// The raw bytes of a simple value.\n     Bytes(u128),\n@@ -74,33 +75,33 @@ pub enum PrimValKind {\n }\n \n impl<'a, 'tcx: 'a> Value {\n-    pub(super) fn read_ptr(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n+    pub(super) fn read_ptr(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, PrimVal> {\n         use self::Value::*;\n         match *self {\n             ByRef(ptr) => mem.read_ptr(ptr),\n-            ByVal(ptr) | ByValPair(ptr, _) => ptr.to_ptr(),\n+            ByVal(ptr) | ByValPair(ptr, _) => Ok(ptr),\n         }\n     }\n \n     pub(super) fn expect_ptr_vtable_pair(\n         &self,\n         mem: &Memory<'a, 'tcx>\n-    ) -> EvalResult<'tcx, (Pointer, Pointer)> {\n+    ) -> EvalResult<'tcx, (PrimVal, Pointer)> {\n         use self::Value::*;\n         match *self {\n             ByRef(ref_ptr) => {\n                 let ptr = mem.read_ptr(ref_ptr)?;\n                 let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size(), mem.layout)?)?;\n-                Ok((ptr, vtable))\n+                Ok((ptr, vtable.to_ptr()?))\n             }\n \n-            ByValPair(ptr, vtable) => Ok((ptr.to_ptr()?, vtable.to_ptr()?)),\n+            ByValPair(ptr, vtable) => Ok((ptr, vtable.to_ptr()?)),\n \n             _ => bug!(\"expected ptr and vtable, got {:?}\", self),\n         }\n     }\n \n-    pub(super) fn expect_slice(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, (Pointer, u64)> {\n+    pub(super) fn expect_slice(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, (PrimVal, u64)> {\n         use self::Value::*;\n         match *self {\n             ByRef(ref_ptr) => {\n@@ -111,7 +112,7 @@ impl<'a, 'tcx: 'a> Value {\n             ByValPair(ptr, val) => {\n                 let len = val.to_u128()?;\n                 assert_eq!(len as u64 as u128, len);\n-                Ok((ptr.to_ptr()?, len as u64))\n+                Ok((ptr, len as u64))\n             },\n             _ => unimplemented!(),\n         }\n@@ -146,14 +147,14 @@ impl<'tcx> PrimVal {\n     pub fn to_bytes(self) -> EvalResult<'tcx, u128> {\n         match self {\n             PrimVal::Bytes(b) => Ok(b),\n-            PrimVal::Ptr(p) => p.to_int().map(|b| b as u128),\n+            PrimVal::Ptr(_) => Err(EvalError::ReadPointerAsBytes),\n             PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n         }\n     }\n \n     pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n         match self {\n-            PrimVal::Bytes(b) => Ok(Pointer::from_int(b as u64)),\n+            PrimVal::Bytes(_) => Err(EvalError::ReadBytesAsPointer),\n             PrimVal::Ptr(p) => Ok(p),\n             PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n         }\n@@ -203,6 +204,67 @@ impl<'tcx> PrimVal {\n             _ => Err(EvalError::InvalidBool),\n         }\n     }\n+\n+    pub fn signed_offset(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n+        match self {\n+            PrimVal::Bytes(b) => {\n+                assert_eq!(b as u64 as u128, b);\n+                Ok(PrimVal::Bytes(signed_offset(b as u64, i, layout)? as u128))\n+            },\n+            PrimVal::Ptr(ptr) => ptr.signed_offset(i, layout).map(PrimVal::Ptr),\n+            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n+        }\n+    }\n+\n+    pub fn offset(self, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n+        match self {\n+            PrimVal::Bytes(b) => {\n+                assert_eq!(b as u64 as u128, b);\n+                Ok(PrimVal::Bytes(offset(b as u64, i, layout)? as u128))\n+            },\n+            PrimVal::Ptr(ptr) => ptr.offset(i, layout).map(PrimVal::Ptr),\n+            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n+        }\n+    }\n+\n+    pub fn wrapping_signed_offset(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n+        match self {\n+            PrimVal::Bytes(b) => {\n+                assert_eq!(b as u64 as u128, b);\n+                Ok(PrimVal::Bytes(wrapping_signed_offset(b as u64, i, layout) as u128))\n+            },\n+            PrimVal::Ptr(ptr) => Ok(PrimVal::Ptr(ptr.wrapping_signed_offset(i, layout))),\n+            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n+        }\n+    }\n+}\n+\n+pub fn signed_offset<'tcx>(val: u64, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, u64> {\n+    // FIXME: is it possible to over/underflow here?\n+    if i < 0 {\n+        // trickery to ensure that i64::min_value() works fine\n+        // this formula only works for true negative values, it panics for zero!\n+        let n = u64::max_value() - (i as u64) + 1;\n+        val.checked_sub(n).ok_or(EvalError::OverflowingMath)\n+    } else {\n+        offset(val, i as u64, layout)\n+    }\n+}\n+\n+pub fn offset<'tcx>(val: u64, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, u64> {\n+    if let Some(res) = val.checked_add(i) {\n+        if res as u128 >= (1u128 << layout.pointer_size.bits()) {\n+            Err(EvalError::OverflowingMath)\n+        } else {\n+            Ok(res)\n+        }\n+    } else {\n+        Err(EvalError::OverflowingMath)\n+    }\n+}\n+\n+pub fn wrapping_signed_offset<'tcx>(val: u64, i: i64, layout: &TargetDataLayout) -> u64 {\n+    (val.wrapping_add(i as u64) as u128 % (1u128 << layout.pointer_size.bits())) as u64\n }\n \n impl PrimValKind {"}, {"sha": "f8b6f7f4aec13331b47a245ee6b7cba2d73c9083", "filename": "tests/compile-fail-fullmir/undefined_byte_read.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Fcompile-fail-fullmir%2Fundefined_byte_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Fcompile-fail-fullmir%2Fundefined_byte_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fundefined_byte_read.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "previous_filename": "tests/compile-fail/undefined_byte_read.rs"}, {"sha": "96469814be29b04c198e5b46548131bdc6ad4049", "filename": "tests/compile-fail/cast_box_int_to_fn_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -4,5 +4,5 @@ fn main() {\n         std::mem::transmute::<&usize, &fn(i32)>(&b)\n     };\n \n-    (*g)(42) //~ ERROR tried to use an integer pointer or a dangling pointer as a function pointer\n+    (*g)(42) //~ ERROR a memory access tried to interpret some bytes as a pointer\n }"}, {"sha": "28d56a2cb6271815f85b332888a2b870eed930d0", "filename": "tests/compile-fail/cast_int_to_fn_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -3,5 +3,5 @@ fn main() {\n         std::mem::transmute::<usize, fn(i32)>(42)\n     };\n \n-    g(42) //~ ERROR tried to use an integer pointer or a dangling pointer as a function pointer\n+    g(42) //~ ERROR a memory access tried to interpret some bytes as a pointer\n }"}, {"sha": "20b93aab1607dd90d19f1c8f2101f3f114e84e00", "filename": "tests/compile-fail/null_pointer_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Fcompile-fail%2Fnull_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Fcompile-fail%2Fnull_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnull_pointer_deref.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n-    let x: i32 = unsafe { *std::ptr::null() }; //~ ERROR: tried to access memory through an invalid pointer\n+    let x: i32 = unsafe { *std::ptr::null() }; //~ ERROR: a memory access tried to interpret some bytes as a pointer\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "373e308e1c02d0f817caa99bbb7ab49f25e160c2", "filename": "tests/compile-fail/wild_pointer_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Fcompile-fail%2Fwild_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Fcompile-fail%2Fwild_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fwild_pointer_deref.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     let p = 42 as *const i32;\n-    let x = unsafe { *p }; //~ ERROR: tried to access memory through an invalid pointer\n+    let x = unsafe { *p }; //~ ERROR: a memory access tried to interpret some bytes as a pointer\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "56435bbc4ac36461087309cb90dc465fc31ceba0", "filename": "tests/compiletest.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -3,19 +3,24 @@ extern crate compiletest_rs as compiletest;\n use std::path::{PathBuf, Path};\n use std::io::Write;\n \n-fn compile_fail(sysroot: &Path) {\n-    let flags = format!(\"--sysroot {} -Dwarnings\", sysroot.to_str().expect(\"non utf8 path\"));\n-    for_all_targets(sysroot, |target| {\n-        let mut config = compiletest::default_config();\n-        config.host_rustcflags = Some(flags.clone());\n-        config.mode = \"compile-fail\".parse().expect(\"Invalid mode\");\n-        config.run_lib_path = Path::new(sysroot).join(\"lib\").join(\"rustlib\").join(&target).join(\"lib\");\n-        config.rustc_path = \"target/debug/miri\".into();\n-        config.src_base = PathBuf::from(\"tests/compile-fail\".to_string());\n-        config.target = target.to_owned();\n-        config.target_rustcflags = Some(flags.clone());\n-        compiletest::run_tests(&config);\n-    });\n+fn compile_fail(sysroot: &Path, path: &str, target: &str, host: &str, fullmir: bool) {\n+    let mut config = compiletest::default_config();\n+    config.mode = \"compile-fail\".parse().expect(\"Invalid mode\");\n+    config.rustc_path = \"target/debug/miri\".into();\n+    if fullmir {\n+        if host != target {\n+            // skip fullmir on nonhost\n+            return;\n+        }\n+        let sysroot = Path::new(&std::env::var(\"HOME\").unwrap()).join(\".xargo\").join(\"HOST\");\n+        config.target_rustcflags = Some(format!(\"--sysroot {}\", sysroot.to_str().unwrap()));\n+        config.src_base = PathBuf::from(path.to_string());\n+    } else {\n+        config.target_rustcflags = Some(format!(\"--sysroot {}\", sysroot.to_str().unwrap()));\n+        config.src_base = PathBuf::from(path.to_string());\n+    }\n+    config.target = target.to_owned();\n+    compiletest::run_tests(&config);\n }\n \n fn run_pass() {\n@@ -27,13 +32,21 @@ fn run_pass() {\n     compiletest::run_tests(&config);\n }\n \n-fn miri_pass(path: &str, target: &str, host: &str) {\n+fn miri_pass(path: &str, target: &str, host: &str, fullmir: bool) {\n     let mut config = compiletest::default_config();\n     config.mode = \"mir-opt\".parse().expect(\"Invalid mode\");\n     config.src_base = PathBuf::from(path);\n     config.target = target.to_owned();\n     config.host = host.to_owned();\n     config.rustc_path = PathBuf::from(\"target/debug/miri\");\n+    if fullmir {\n+        if host != target {\n+            // skip fullmir on nonhost\n+            return;\n+        }\n+        let sysroot = Path::new(&std::env::var(\"HOME\").unwrap()).join(\".xargo\").join(\"HOST\");\n+        config.target_rustcflags = Some(format!(\"--sysroot {}\", sysroot.to_str().unwrap()));\n+    }\n     // don't actually execute the final binary, it might be for other targets and we only care\n     // about running miri, not the binary.\n     config.runtool = Some(\"echo \\\"\\\" || \".to_owned());\n@@ -116,6 +129,7 @@ fn compile_test() {\n             let sysroot = libs.join(\"rustlib\").join(&host).join(\"lib\");\n             let paths = std::env::join_paths(&[libs, sysroot]).unwrap();\n             cmd.env(compiletest::procsrv::dylib_env_var(), paths);\n+            cmd.env(\"MIRI_SYSROOT\", Path::new(&std::env::var(\"HOME\").unwrap()).join(\".xargo\").join(\"HOST\"));\n \n             match cmd.output() {\n                 Ok(ref output) if output.status.success() => {\n@@ -197,9 +211,11 @@ fn compile_test() {\n     } else {\n         run_pass();\n         for_all_targets(sysroot, |target| {\n-            miri_pass(\"tests/run-pass\", &target, host);\n+            miri_pass(\"tests/run-pass\", &target, host, false);\n+            compile_fail(sysroot, \"tests/compile-fail\", &target, host, false);\n         });\n-        compile_fail(sysroot);\n+        miri_pass(\"tests/run-pass-fullmir\", host, host, true);\n+        compile_fail(sysroot, \"tests/compile-fail-fullmir\", host, host, true);\n     }\n }\n "}, {"sha": "b533f916469881a96c23657ea33f4d65f6e2d218", "filename": "tests/run-pass-fullmir/heap.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Frun-pass-fullmir%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Frun-pass-fullmir%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fheap.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "previous_filename": "tests/run-pass/heap.rs"}, {"sha": "cee0caeb465f56d3206266d85cc4f6f769730fb3", "filename": "tests/run-pass-fullmir/issue-15080.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Frun-pass-fullmir%2Fissue-15080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Frun-pass-fullmir%2Fissue-15080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fissue-15080.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "previous_filename": "tests/run-pass/issue-15080.rs"}, {"sha": "8631909a2a96612f234205c6ee7026b6d79f4893", "filename": "tests/run-pass-fullmir/loop-break-value.rs", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Frun-pass-fullmir%2Floop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Frun-pass-fullmir%2Floop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Floop-break-value.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -0,0 +1,141 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(never_type)]\n+#![allow(unreachable_code)]\n+\n+#[allow(unused)]\n+fn never_returns() {\n+    loop {\n+        break loop {};\n+    }\n+}\n+\n+pub fn main() {\n+    let value = 'outer: loop {\n+        if 1 == 1 {\n+            break 13;\n+        } else {\n+            let _never: ! = loop {\n+                break loop {\n+                    break 'outer panic!();\n+                }\n+            };\n+        }\n+    };\n+    assert_eq!(value, 13);\n+\n+    let x = [1, 3u32, 5];\n+    let y = [17];\n+    let z = [];\n+    let coerced: &[_] = loop {\n+        match 2 {\n+            1 => break &x,\n+            2 => break &y,\n+            3 => break &z,\n+            _ => (),\n+        }\n+    };\n+    assert_eq!(coerced, &[17u32]);\n+\n+    let trait_unified = loop {\n+        break if true {\n+            break Default::default()\n+        } else {\n+            break [13, 14]\n+        };\n+    };\n+    assert_eq!(trait_unified, [0, 0]);\n+\n+    let trait_unified_2 = loop {\n+        if false {\n+            break [String::from(\"Hello\")]\n+        } else {\n+            break Default::default()\n+        };\n+    };\n+    assert_eq!(trait_unified_2, [\"\"]);\n+\n+    let trait_unified_3 = loop {\n+        break if false {\n+            break [String::from(\"Hello\")]\n+        } else {\n+            [\"Yes\".into()]\n+        };\n+    };\n+    assert_eq!(trait_unified_3, [\"Yes\"]);\n+\n+    let regular_break = loop {\n+        if true {\n+            break;\n+        } else {\n+            break break Default::default();\n+        }\n+    };\n+    assert_eq!(regular_break, ());\n+\n+    let regular_break_2 = loop {\n+        if true {\n+            break Default::default();\n+        } else {\n+            break;\n+        }\n+    };\n+    assert_eq!(regular_break_2, ());\n+\n+    let regular_break_3 = loop {\n+        break if true {\n+            Default::default()\n+        } else {\n+            break;\n+        }\n+    };\n+    assert_eq!(regular_break_3, ());\n+\n+    let regular_break_4 = loop {\n+        break ();\n+        break;\n+    };\n+    assert_eq!(regular_break_4, ());\n+\n+    let regular_break_5 = loop {\n+        break;\n+        break ();\n+    };\n+    assert_eq!(regular_break_5, ());\n+\n+    let nested_break_value = 'outer2: loop {\n+        let _a: u32 = 'inner: loop {\n+            if true {\n+                break 'outer2 \"hello\";\n+            } else {\n+                break 'inner 17;\n+            }\n+        };\n+        panic!();\n+    };\n+    assert_eq!(nested_break_value, \"hello\");\n+\n+    let break_from_while_cond = loop {\n+        'inner_loop: while break 'inner_loop {\n+            panic!();\n+        }\n+        break 123;\n+    };\n+    assert_eq!(break_from_while_cond, 123);\n+\n+    let break_from_while_to_outer = 'outer_loop: loop {\n+        while break 'outer_loop 567 {\n+            panic!(\"from_inner\");\n+        }\n+        panic!(\"from outer\");\n+    };\n+    assert_eq!(break_from_while_to_outer, 567);\n+}"}, {"sha": "d44c83763b7c448875c91a2e7ac37a2c0eddb1e6", "filename": "tests/run-pass-fullmir/move-arg-2-unique.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Frun-pass-fullmir%2Fmove-arg-2-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Frun-pass-fullmir%2Fmove-arg-2-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fmove-arg-2-unique.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "previous_filename": "tests/run-pass/move-arg-2-unique.rs"}, {"sha": "fd3a00031d61e0cbfa817058e76b945abaa68796", "filename": "tests/run-pass-fullmir/vecs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Frun-pass-fullmir%2Fvecs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Frun-pass-fullmir%2Fvecs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fvecs.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "previous_filename": "tests/run-pass/vecs.rs"}, {"sha": "dbe8ec9addacc5f88ac0b269c0ead95a54b038da", "filename": "tests/run-pass/slice-of-zero-size-elements.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Frun-pass%2Fslice-of-zero-size-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Frun-pass%2Fslice-of-zero-size-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fslice-of-zero-size-elements.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C debug-assertions\n+\n+use std::slice;\n+\n+fn foo<T>(v: &[T]) -> Option<&[T]> {\n+    let mut it = v.iter();\n+    for _ in 0..5 {\n+        let _ = it.next();\n+    }\n+    Some(it.as_slice())\n+}\n+\n+fn foo_mut<T>(v: &mut [T]) -> Option<&mut [T]> {\n+    let mut it = v.iter_mut();\n+    for _ in 0..5 {\n+        let _ = it.next();\n+    }\n+    Some(it.into_slice())\n+}\n+\n+pub fn main() {\n+    // In a slice of zero-size elements the pointer is meaningless.\n+    // Ensure iteration still works even if the pointer is at the end of the address space.\n+    let slice: &[()] = unsafe { slice::from_raw_parts(-5isize as *const (), 10) };\n+    assert_eq!(slice.len(), 10);\n+    assert_eq!(slice.iter().count(), 10);\n+\n+    // .nth() on the iterator should also behave correctly\n+    let mut it = slice.iter();\n+    assert!(it.nth(5).is_some());\n+    assert_eq!(it.count(), 4);\n+\n+    // Converting Iter to a slice should never have a null pointer\n+    assert!(foo(slice).is_some());\n+\n+    // Test mutable iterators as well\n+    let slice: &mut [()] = unsafe { slice::from_raw_parts_mut(-5isize as *mut (), 10) };\n+    assert_eq!(slice.len(), 10);\n+    assert_eq!(slice.iter_mut().count(), 10);\n+\n+    {\n+        let mut it = slice.iter_mut();\n+        assert!(it.nth(5).is_some());\n+        assert_eq!(it.count(), 4);\n+    }\n+\n+    assert!(foo_mut(slice).is_some())\n+}"}, {"sha": "df2ff6e51a593a64c98323bc6ea74c7719abfce5", "filename": "tests/run-pass/union-overwrite.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Frun-pass%2Funion-overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Frun-pass%2Funion-overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Funion-overwrite.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+#![allow(unions_with_drop_fields)]\n+\n+#[repr(C)]\n+struct Pair<T, U>(T, U);\n+#[repr(C)]\n+struct Triple<T>(T, T, T);\n+\n+#[repr(C)]\n+union U<A, B> {\n+    a: Pair<A, A>,\n+    b: B,\n+}\n+\n+#[repr(C)]\n+union W<A, B> {\n+    a: A,\n+    b: B,\n+}\n+\n+#[cfg(target_endian = \"little\")]\n+unsafe fn check() {\n+    let mut u = U::<u8, u16> { b: 0xDE_DE };\n+    u.a.0 = 0xBE;\n+    assert_eq!(u.b, 0xDE_BE);\n+\n+    let mut u = U::<u16, u32> { b: 0xDEAD_DEAD };\n+    u.a.0 = 0xBEEF;\n+    assert_eq!(u.b, 0xDEAD_BEEF);\n+\n+    let mut u = U::<u32, u64> { b: 0xDEADBEEF_DEADBEEF };\n+    u.a.0 = 0xBAADF00D;\n+    assert_eq!(u.b, 0xDEADBEEF_BAADF00D);\n+\n+    let mut w = W::<Pair<Triple<u8>, u8>, u32> { b: 0xDEAD_DEAD };\n+    w.a.0 = Triple(0, 0, 0);\n+    assert_eq!(w.b, 0xDE00_0000);\n+\n+    let mut w = W::<Pair<u8, Triple<u8>>, u32> { b: 0xDEAD_DEAD };\n+    w.a.1 = Triple(0, 0, 0);\n+    assert_eq!(w.b, 0x0000_00AD);\n+}\n+\n+#[cfg(target_endian = \"big\")]\n+unsafe fn check() {\n+    let mut u = U::<u8, u16> { b: 0xDE_DE };\n+    u.a.0 = 0xBE;\n+    assert_eq!(u.b, 0xBE_DE);\n+\n+    let mut u = U::<u16, u32> { b: 0xDEAD_DEAD };\n+    u.a.0 = 0xBEEF;\n+    assert_eq!(u.b, 0xBEEF_DEAD);\n+\n+    let mut u = U::<u32, u64> { b: 0xDEADBEEF_DEADBEEF };\n+    u.a.0 = 0xBAADF00D;\n+    assert_eq!(u.b, 0xBAADF00D_DEADBEEF);\n+\n+    let mut w = W::<Pair<Triple<u8>, u8>, u32> { b: 0xDEAD_DEAD };\n+    w.a.0 = Triple(0, 0, 0);\n+    assert_eq!(w.b, 0x0000_00AD);\n+\n+    let mut w = W::<Pair<u8, Triple<u8>>, u32> { b: 0xDEAD_DEAD };\n+    w.a.1 = Triple(0, 0, 0);\n+    assert_eq!(w.b, 0xDE00_0000);\n+}\n+\n+fn main() {\n+    unsafe {\n+        check();\n+    }\n+}"}, {"sha": "63a0d65f017def8d603d05654eb20e97b97a1a87", "filename": "tests/run-pass/zero-sized-binary-heap-push.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Frun-pass%2Fzero-sized-binary-heap-push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d539fafaf602c35d9dec0a7e509fed19d03f054b/tests%2Frun-pass%2Fzero-sized-binary-heap-push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fzero-sized-binary-heap-push.rs?ref=d539fafaf602c35d9dec0a7e509fed19d03f054b", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::BinaryHeap;\n+use std::iter::Iterator;\n+\n+fn main() {\n+    const N: usize = 8;\n+\n+    for len in 0..N {\n+        let mut tester = BinaryHeap::with_capacity(len);\n+        assert_eq!(tester.len(), 0);\n+        assert!(tester.capacity() >= len);\n+        for _ in 0..len {\n+            tester.push(());\n+        }\n+        assert_eq!(tester.len(), len);\n+        assert_eq!(tester.iter().count(), len);\n+        tester.clear();\n+    }\n+}"}]}