{"sha": "09bf401f1d4f843ead4d4fe955348ce5e8215fb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5YmY0MDFmMWQ0Zjg0M2VhZDRkNGZlOTU1MzQ4Y2U1ZTgyMTVmYjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-17T01:58:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-17T01:58:39Z"}, "message": "auto merge of #6544 : thestinger/rust/new_iter, r=nikomatsakis", "tree": {"sha": "c136698fecadb359fd8086aca50490b54ba701bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c136698fecadb359fd8086aca50490b54ba701bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09bf401f1d4f843ead4d4fe955348ce5e8215fb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09bf401f1d4f843ead4d4fe955348ce5e8215fb1", "html_url": "https://github.com/rust-lang/rust/commit/09bf401f1d4f843ead4d4fe955348ce5e8215fb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09bf401f1d4f843ead4d4fe955348ce5e8215fb1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17970a91115dd30dd6ee445ef344153f46f0a946", "url": "https://api.github.com/repos/rust-lang/rust/commits/17970a91115dd30dd6ee445ef344153f46f0a946", "html_url": "https://github.com/rust-lang/rust/commit/17970a91115dd30dd6ee445ef344153f46f0a946"}, {"sha": "08ef229a65cd7b8de27a5844eee3dce8c69aa846", "url": "https://api.github.com/repos/rust-lang/rust/commits/08ef229a65cd7b8de27a5844eee3dce8c69aa846", "html_url": "https://github.com/rust-lang/rust/commit/08ef229a65cd7b8de27a5844eee3dce8c69aa846"}], "stats": {"total": 106, "additions": 106, "deletions": 0}, "files": [{"sha": "ae4af3812d2d2a91b3b5a23c908076c209bee920", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/09bf401f1d4f843ead4d4fe955348ce5e8215fb1/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bf401f1d4f843ead4d4fe955348ce5e8215fb1/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=09bf401f1d4f843ead4d4fe955348ce5e8215fb1", "patch": "@@ -43,6 +43,8 @@ much easier to implement.\n #[cfg(not(stage0))] use cmp::Ord;\n #[cfg(not(stage0))] use option::{Option, Some, None};\n #[cfg(not(stage0))] use vec::OwnedVector;\n+#[cfg(not(stage0))] use num::{One, Zero};\n+#[cfg(not(stage0))] use ops::{Add, Mul};\n \n #[cfg(stage0)]\n pub trait Times {\n@@ -212,6 +214,81 @@ pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n     result\n }\n \n+/**\n+ * Reduce an iterator to an accumulated value.\n+ *\n+ * # Example:\n+ *\n+ * ~~~~\n+ * assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n+ * ~~~~\n+ */\n+#[cfg(not(stage0))]\n+#[inline]\n+pub fn fold<T, U>(start: T, iter: &fn(f: &fn(U) -> bool) -> bool, f: &fn(&mut T, U)) -> T {\n+    let mut result = start;\n+    for iter |x| {\n+        f(&mut result, x);\n+    }\n+    result\n+}\n+\n+/**\n+ * Reduce an iterator to an accumulated value.\n+ *\n+ * `fold_ref` is usable in some generic functions where `fold` is too lenient to type-check, but it\n+ * forces the iterator to yield borrowed pointers.\n+ *\n+ * # Example:\n+ *\n+ * ~~~~\n+ * fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n+ *     fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n+ * }\n+ * ~~~~\n+ */\n+#[cfg(not(stage0))]\n+#[inline]\n+pub fn fold_ref<T, U>(start: T, iter: &fn(f: &fn(&U) -> bool) -> bool, f: &fn(&mut T, &U)) -> T {\n+    let mut result = start;\n+    for iter |x| {\n+        f(&mut result, x);\n+    }\n+    result\n+}\n+\n+/**\n+ * Return the sum of the items yielding by an iterator.\n+ *\n+ * # Example:\n+ *\n+ * ~~~~\n+ * let xs: ~[int] = ~[1, 2, 3, 4];\n+ * assert_eq!(do sum |f| { xs.each(f) }, 10);\n+ * ~~~~\n+ */\n+#[cfg(not(stage0))]\n+#[inline(always)]\n+pub fn sum<T: Zero + Add<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n+    fold_ref(Zero::zero::<T>(), iter, |a, x| *a = a.add(x))\n+}\n+\n+/**\n+ * Return the product of the items yielded by an iterator.\n+ *\n+ * # Example:\n+ *\n+ * ~~~~\n+ * let xs: ~[int] = ~[1, 2, 3, 4];\n+ * assert_eq!(do product |f| { xs.each(f) }, 24);\n+ * ~~~~\n+ */\n+#[cfg(not(stage0))]\n+#[inline(always)]\n+pub fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n+    fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -254,4 +331,33 @@ mod tests {\n         let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n         assert_eq!(min(|f| xs.each(f)).unwrap(), &-5);\n     }\n+\n+    #[test]\n+    fn test_fold() {\n+        assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n+    }\n+\n+    #[test]\n+    fn test_sum() {\n+        let xs: ~[int] = ~[1, 2, 3, 4];\n+        assert_eq!(do sum |f| { xs.each(f) }, 10);\n+    }\n+\n+    #[test]\n+    fn test_empty_sum() {\n+        let xs: ~[int] = ~[];\n+        assert_eq!(do sum |f| { xs.each(f) }, 0);\n+    }\n+\n+    #[test]\n+    fn test_product() {\n+        let xs: ~[int] = ~[1, 2, 3, 4];\n+        assert_eq!(do product |f| { xs.each(f) }, 24);\n+    }\n+\n+    #[test]\n+    fn test_empty_product() {\n+        let xs: ~[int] = ~[];\n+        assert_eq!(do product |f| { xs.each(f) }, 1);\n+    }\n }"}]}