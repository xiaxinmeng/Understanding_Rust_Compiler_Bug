{"sha": "bae091e5171c90803e9c40fb01a76d1b0b6f4321", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhZTA5MWU1MTcxYzkwODAzZTljNDBmYjAxYTc2ZDFiMGI2ZjQzMjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-06T15:26:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-06T15:26:48Z"}, "message": "auto merge of #11332 : sfackler/rust/de-at-se, r=huonw\n\nThis is necessary for #11151 to make sure dtors run before the libraries\r\nare unloaded.", "tree": {"sha": "49cce1294f972e4c012c5475b9a11741556b6a02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49cce1294f972e4c012c5475b9a11741556b6a02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bae091e5171c90803e9c40fb01a76d1b0b6f4321", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bae091e5171c90803e9c40fb01a76d1b0b6f4321", "html_url": "https://github.com/rust-lang/rust/commit/bae091e5171c90803e9c40fb01a76d1b0b6f4321", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bae091e5171c90803e9c40fb01a76d1b0b6f4321/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55bb5e584cd9e15ac5970d86be1c5dbe96f75af7", "url": "https://api.github.com/repos/rust-lang/rust/commits/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7", "html_url": "https://github.com/rust-lang/rust/commit/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7"}, {"sha": "bb49916d217fa58bcfe9c0fea4a1e4871396c301", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb49916d217fa58bcfe9c0fea4a1e4871396c301", "html_url": "https://github.com/rust-lang/rust/commit/bb49916d217fa58bcfe9c0fea4a1e4871396c301"}], "stats": {"total": 121, "additions": 60, "deletions": 61}, "files": [{"sha": "cbd7e7ca0ee5f914cea9e9f5dcf40d7937ac69d8", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bae091e5171c90803e9c40fb01a76d1b0b6f4321/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae091e5171c90803e9c40fb01a76d1b0b6f4321/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=bae091e5171c90803e9c40fb01a76d1b0b6f4321", "patch": "@@ -138,7 +138,7 @@ pub enum SyntaxExtension {\n     ItemDecorator(ItemDecorator),\n \n     // Token-tree expanders\n-    NormalTT(@SyntaxExpanderTTTrait, Option<Span>),\n+    NormalTT(~SyntaxExpanderTTTrait:'static, Option<Span>),\n \n     // An IdentTT is a macro that has an\n     // identifier in between the name of the\n@@ -148,7 +148,7 @@ pub enum SyntaxExtension {\n \n     // perhaps macro_rules! will lose its odd special identifier argument,\n     // and this can go away also\n-    IdentTT(@SyntaxExpanderTTItemTrait, Option<Span>),\n+    IdentTT(~SyntaxExpanderTTItemTrait:'static, Option<Span>),\n }\n \n \n@@ -182,20 +182,20 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n     // utility function to simplify creating NormalTT syntax extensions\n     fn builtin_normal_tt_no_ctxt(f: SyntaxExpanderTTFunNoCtxt)\n                                  -> SyntaxExtension {\n-        NormalTT(@SyntaxExpanderTT{\n+        NormalTT(~SyntaxExpanderTT{\n             expander: SyntaxExpanderTTExpanderWithoutContext(f),\n             span: None,\n-        } as @SyntaxExpanderTTTrait,\n+        },\n         None)\n     }\n \n     let mut syntax_expanders = MapChain::new();\n     syntax_expanders.insert(intern(&\"macro_rules\"),\n-                            IdentTT(@SyntaxExpanderTTItem {\n+                            IdentTT(~SyntaxExpanderTTItem {\n                                 expander: SyntaxExpanderTTItemExpanderWithContext(\n                                     ext::tt::macro_rules::add_new_extension),\n                                 span: None,\n-                            } as @SyntaxExpanderTTItemTrait,\n+                            },\n                             None));\n     syntax_expanders.insert(intern(&\"fmt\"),\n                             builtin_normal_tt_no_ctxt("}, {"sha": "ccffb11f73e094c48b47f8d78953e44ea11ede4e", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 52, "deletions": 53, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/bae091e5171c90803e9c40fb01a76d1b0b6f4321/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae091e5171c90803e9c40fb01a76d1b0b6f4321/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=bae091e5171c90803e9c40fb01a76d1b0b6f4321", "patch": "@@ -53,13 +53,13 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                     let extname = &pth.segments[0].identifier;\n                     let extnamestr = ident_to_str(extname);\n                     // leaving explicit deref here to highlight unbox op:\n-                    match fld.extsbox.find(&extname.name) {\n+                    let marked_after = match fld.extsbox.find(&extname.name) {\n                         None => {\n                             fld.cx.span_fatal(\n                                 pth.span,\n                                 format!(\"macro undefined: '{}'\", extnamestr))\n                         }\n-                        Some(&NormalTT(expandfun, exp_span)) => {\n+                        Some(&NormalTT(ref expandfun, exp_span)) => {\n                             fld.cx.bt_push(ExpnInfo {\n                                 call_site: e.span,\n                                 callee: NameAndSpan {\n@@ -79,46 +79,46 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                             // the macro.\n                             let mac_span = original_span(fld.cx);\n \n-                            let expanded =\n-                                match expandfun.expand(fld.cx,\n-                                                       mac_span.call_site,\n-                                                       marked_before,\n-                                                       marked_ctxt) {\n-                                    MRExpr(e) => e,\n-                                    MRAny(any_macro) => any_macro.make_expr(),\n-                                    _ => {\n-                                        fld.cx.span_fatal(\n-                                            pth.span,\n-                                            format!(\n-                                                \"non-expr macro in expr pos: {}\",\n-                                                extnamestr\n-                                            )\n+                            let expanded = match expandfun.expand(fld.cx,\n+                                                   mac_span.call_site,\n+                                                   marked_before,\n+                                                   marked_ctxt) {\n+                                MRExpr(e) => e,\n+                                MRAny(any_macro) => any_macro.make_expr(),\n+                                _ => {\n+                                    fld.cx.span_fatal(\n+                                        pth.span,\n+                                        format!(\n+                                            \"non-expr macro in expr pos: {}\",\n+                                            extnamestr\n                                         )\n-                                    }\n-                                };\n+                                    )\n+                                }\n+                            };\n+\n                             // mark after:\n-                            let marked_after = mark_expr(expanded,fm);\n-\n-                            // Keep going, outside-in.\n-                            //\n-                            // XXX(pcwalton): Is it necessary to clone the\n-                            // node here?\n-                            let fully_expanded =\n-                                fld.fold_expr(marked_after).node.clone();\n-                            fld.cx.bt_pop();\n-\n-                            @ast::Expr {\n-                                id: ast::DUMMY_NODE_ID,\n-                                node: fully_expanded,\n-                                span: e.span,\n-                            }\n+                            mark_expr(expanded,fm)\n                         }\n                         _ => {\n                             fld.cx.span_fatal(\n                                 pth.span,\n                                 format!(\"'{}' is not a tt-style macro\", extnamestr)\n                             )\n                         }\n+                    };\n+\n+                    // Keep going, outside-in.\n+                    //\n+                    // XXX(pcwalton): Is it necessary to clone the\n+                    // node here?\n+                    let fully_expanded =\n+                        fld.fold_expr(marked_after).node.clone();\n+                    fld.cx.bt_pop();\n+\n+                    @ast::Expr {\n+                        id: ast::DUMMY_NODE_ID,\n+                        node: fully_expanded,\n+                        span: e.span,\n                     }\n                 }\n             }\n@@ -301,7 +301,7 @@ pub fn expand_item_mac(it: @ast::item, fld: &mut MacroExpander)\n         None => fld.cx.span_fatal(pth.span,\n                                   format!(\"macro undefined: '{}!'\", extnamestr)),\n \n-        Some(&NormalTT(expander, span)) => {\n+        Some(&NormalTT(ref expander, span)) => {\n             if it.ident.name != parse::token::special_idents::invalid.name {\n                 fld.cx.span_fatal(pth.span,\n                                   format!(\"macro {}! expects no ident argument, \\\n@@ -321,7 +321,7 @@ pub fn expand_item_mac(it: @ast::item, fld: &mut MacroExpander)\n             let marked_ctxt = new_mark(fm,ctxt);\n             expander.expand(fld.cx, it.span, marked_before, marked_ctxt)\n         }\n-        Some(&IdentTT(expander, span)) => {\n+        Some(&IdentTT(ref expander, span)) => {\n             if it.ident.name == parse::token::special_idents::invalid.name {\n                 fld.cx.span_fatal(pth.span,\n                                   format!(\"macro {}! expects an ident argument\",\n@@ -361,10 +361,10 @@ pub fn expand_item_mac(it: @ast::item, fld: &mut MacroExpander)\n                     .flat_map(|i| fld.fold_item(i).move_iter())\n                     .collect()\n         }\n-        MRDef(ref mdef) => {\n+        MRDef(MacroDef { name, ext }) => {\n             // yikes... no idea how to apply the mark to this. I'm afraid\n             // we're going to have to wait-and-see on this one.\n-            fld.extsbox.insert(intern(mdef.name), (*mdef).ext);\n+            fld.extsbox.insert(intern(name), ext);\n             SmallVector::zero()\n         }\n     };\n@@ -392,12 +392,12 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n     }\n     let extname = &pth.segments[0].identifier;\n     let extnamestr = ident_to_str(extname);\n-    let fully_expanded: SmallVector<@Stmt> = match fld.extsbox.find(&extname.name) {\n+    let marked_after = match fld.extsbox.find(&extname.name) {\n         None => {\n             fld.cx.span_fatal(pth.span, format!(\"macro undefined: '{}'\", extnamestr))\n         }\n \n-        Some(&NormalTT(expandfun, exp_span)) => {\n+        Some(&NormalTT(ref expandfun, exp_span)) => {\n             fld.cx.bt_push(ExpnInfo {\n                 call_site: s.span,\n                 callee: NameAndSpan {\n@@ -430,18 +430,8 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n                     pth.span,\n                     format!(\"non-stmt macro in stmt pos: {}\", extnamestr))\n             };\n-            let marked_after = mark_stmt(expanded,fm);\n \n-            // Keep going, outside-in.\n-            let fully_expanded = fld.fold_stmt(marked_after);\n-            if fully_expanded.is_empty() {\n-                fld.cx.span_fatal(pth.span,\n-                              \"macro didn't expand to a statement\");\n-            }\n-            fld.cx.bt_pop();\n-            fully_expanded.move_iter()\n-                    .map(|s| @Spanned { span: s.span, node: s.node.clone() })\n-                    .collect()\n+            mark_stmt(expanded,fm)\n         }\n \n         _ => {\n@@ -451,6 +441,17 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n         }\n     };\n \n+    // Keep going, outside-in.\n+    let fully_expanded = fld.fold_stmt(marked_after);\n+    if fully_expanded.is_empty() {\n+        fld.cx.span_fatal(pth.span,\n+                      \"macro didn't expand to a statement\");\n+    }\n+    fld.cx.bt_pop();\n+    let fully_expanded: SmallVector<@Stmt> = fully_expanded.move_iter()\n+            .map(|s| @Spanned { span: s.span, node: s.node.clone() })\n+            .collect();\n+\n     fully_expanded.move_iter().map(|s| {\n         match s.node {\n             StmtExpr(e, stmt_id) if semi => {\n@@ -1109,10 +1110,8 @@ mod test {\n     use codemap::Spanned;\n     use fold;\n     use parse;\n-    use parse::token::{fresh_mark, gensym, intern, get_ident_interner, ident_to_str};\n+    use parse::token::{fresh_mark, gensym, intern, ident_to_str};\n     use parse::token;\n-    use print::pprust;\n-    use std;\n     use util::parser_testing::{string_to_crate, string_to_crate_and_sess};\n     use util::parser_testing::{string_to_pat, string_to_tts, strs_to_idents};\n     use visit;"}, {"sha": "a2f218325b42f902cc75b04ab4a94d7df2decc6a", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bae091e5171c90803e9c40fb01a76d1b0b6f4321/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bae091e5171c90803e9c40fb01a76d1b0b6f4321/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=bae091e5171c90803e9c40fb01a76d1b0b6f4321", "patch": "@@ -225,11 +225,11 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n       _ => cx.span_bug(sp, \"wrong-structured rhs\")\n     };\n \n-    let exp = @MacroRulesSyntaxExpanderTTFun {\n+    let exp = ~MacroRulesSyntaxExpanderTTFun {\n         name: name,\n         lhses: lhses,\n         rhses: rhses,\n-    } as @SyntaxExpanderTTTrait;\n+    };\n \n     return MRDef(MacroDef {\n         name: ident_to_str(&name),"}]}