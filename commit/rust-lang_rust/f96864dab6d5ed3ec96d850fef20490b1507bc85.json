{"sha": "f96864dab6d5ed3ec96d850fef20490b1507bc85", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5Njg2NGRhYjZkNWVkM2VjOTZkODUwZmVmMjA0OTBiMTUwN2JjODU=", "commit": {"author": {"name": "Andrea Canciani", "email": "ranma42@gmail.com", "date": "2016-05-12T17:03:15Z"}, "committer": {"name": "Andrea Canciani", "email": "ranma42@gmail.com", "date": "2016-05-13T13:19:23Z"}, "message": "Document the x87 control word\n\nExplain the meaning of the fields of the control word and provide more\ndetails about how the relevant one (Precision Control) is updated in\nthe fast path.", "tree": {"sha": "0ec6e93ebc2caf57e641073874b0b60c27c6f7f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ec6e93ebc2caf57e641073874b0b60c27c6f7f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f96864dab6d5ed3ec96d850fef20490b1507bc85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f96864dab6d5ed3ec96d850fef20490b1507bc85", "html_url": "https://github.com/rust-lang/rust/commit/f96864dab6d5ed3ec96d850fef20490b1507bc85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f96864dab6d5ed3ec96d850fef20490b1507bc85/comments", "author": {"login": "ranma42", "id": 1506030, "node_id": "MDQ6VXNlcjE1MDYwMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1506030?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ranma42", "html_url": "https://github.com/ranma42", "followers_url": "https://api.github.com/users/ranma42/followers", "following_url": "https://api.github.com/users/ranma42/following{/other_user}", "gists_url": "https://api.github.com/users/ranma42/gists{/gist_id}", "starred_url": "https://api.github.com/users/ranma42/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ranma42/subscriptions", "organizations_url": "https://api.github.com/users/ranma42/orgs", "repos_url": "https://api.github.com/users/ranma42/repos", "events_url": "https://api.github.com/users/ranma42/events{/privacy}", "received_events_url": "https://api.github.com/users/ranma42/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ranma42", "id": 1506030, "node_id": "MDQ6VXNlcjE1MDYwMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1506030?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ranma42", "html_url": "https://github.com/ranma42", "followers_url": "https://api.github.com/users/ranma42/followers", "following_url": "https://api.github.com/users/ranma42/following{/other_user}", "gists_url": "https://api.github.com/users/ranma42/gists{/gist_id}", "starred_url": "https://api.github.com/users/ranma42/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ranma42/subscriptions", "organizations_url": "https://api.github.com/users/ranma42/orgs", "repos_url": "https://api.github.com/users/ranma42/repos", "events_url": "https://api.github.com/users/ranma42/events{/privacy}", "received_events_url": "https://api.github.com/users/ranma42/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78124a2b32d61a3ab1cc5798828195970438262b", "url": "https://api.github.com/repos/rust-lang/rust/commits/78124a2b32d61a3ab1cc5798828195970438262b", "html_url": "https://github.com/rust-lang/rust/commit/78124a2b32d61a3ab1cc5798828195970438262b"}], "stats": {"total": 67, "additions": 62, "deletions": 5}, "files": [{"sha": "6c53845202fbb8018b02e26f14e0d03d96211c4b", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 62, "deletions": 5, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f96864dab6d5ed3ec96d850fef20490b1507bc85/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f96864dab6d5ed3ec96d850fef20490b1507bc85/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=f96864dab6d5ed3ec96d850fef20490b1507bc85", "patch": "@@ -32,31 +32,87 @@ fn power_of_ten(e: i16) -> Fp {\n     Fp { f: sig, e: exp }\n }\n \n+// Most architectures floating point operations with explicit bit size, therefore the precision of\n+// the computation is determined on a per-operation basis.\n #[cfg(any(not(target_arch=\"x86\"), target_feature=\"sse2\"))]\n mod fpu_precision {\n     pub fn set_precision<T>() { }\n }\n \n+// On x86, the x87 FPU is used for float operations if the SSE[2] extensions are not available.\n+// The x87 FPU operates with 80 bits of precision by default, which means that operations will\n+// round to 80 bits causing double rounding to happen when values are eventually represented as\n+// 32/64 bit float values. To overcome this, the FPU control word can be set so that the\n+// computations are performed in the desired precision.\n #[cfg(all(target_arch=\"x86\", not(target_feature=\"sse2\")))]\n mod fpu_precision {\n     use mem::size_of;\n     use ops::Drop;\n \n+    /// A structure used to preserve the original value of the FPU control word, so that it can be\n+    /// restored when the structure is dropped.\n+    ///\n+    /// The x87 FPU is a 16-bits register whose fields are as follows:\n+    ///\n+    ///    1111 11\n+    ///    5432 10 98 76 5 4 3 2 1 0\n+    ///   +----+--+--+--+-+-+-+-+-+-+\n+    ///   |    |RC|PC|  |P|U|O|Z|D|I|\n+    ///   |    |  |  |  |M|M|M|M|M|M|\n+    ///   +----+--+--+--+-+-+-+-+-+-+\n+    /// The fields are:\n+    ///  - Invalid operation Mask\n+    ///  - Denormal operand Mask\n+    ///  - Zero divide Mask\n+    ///  - Overflow Mask\n+    ///  - Underflow Mask\n+    ///  - Precision Mask\n+    ///  - Precision Control\n+    ///  - Rounding Control\n+    ///\n+    /// The fields with no name are unused (on FPUs more modern than 287).\n+    ///\n+    /// The 6 LSBs (bits 0-5) are the exception mask bits; each blocks a specific type of floating\n+    /// point exceptions from being raised.\n+    ///\n+    /// The Precision Control field determines the precision of the operations performed by the\n+    /// FPU. It can set to:\n+    ///  - 0b00, single precision i.e. 32-bits\n+    ///  - 0b10, double precision i.e. 64-bits\n+    ///  - 0b11, double extended precision i.e. 80-bits (default state)\n+    /// The 0b01 value is reserved and should not be used.\n+    ///\n+    /// The Rounding Control field determines how values which cannot be represented exactly are\n+    /// rounded. It can be set to:\n+    ///  - 0b00, round to nearest even (default state)\n+    ///  - 0b01, round down (toward -inf)\n+    ///  - 0b10, round up (toward +inf)\n+    ///  - 0b11, round toward 0 (truncate)\n     pub struct FPUControlWord(u16);\n \n     fn set_cw(cw: u16) {\n         unsafe { asm!(\"fldcw $0\" :: \"m\" (cw)) :: \"volatile\" }\n     }\n \n+    /// Set the precision field of the FPU to `T` and return a `FPUControlWord`\n     pub fn set_precision<T>() -> FPUControlWord {\n         let cw = 0u16;\n+\n+        // Compute the value for the Precision Control field that is appropriate for `T`.\n         let cw_precision = match size_of::<T>() {\n             4 => 0x0000, // 32 bits\n             8 => 0x0200, // 64 bits\n             _ => 0x0300, // default, 80 bits\n         };\n+\n+        // Get the original value of the control word to restore it later, when the\n+        // `FPUControlWord` structure is dropped\n         unsafe { asm!(\"fnstcw $0\" : \"=*m\" (&cw)) ::: \"volatile\" }\n+\n+        // Set the control word to the desired precision. This is achieved by masking away the old\n+        // precision (bits 8 and 9, 0x300) and replacing it with the precision flag computed above.\n         set_cw((cw & 0xFCFF) | cw_precision);\n+\n         FPUControlWord(cw)\n     }\n \n@@ -71,10 +127,6 @@ mod fpu_precision {\n ///\n /// This is extracted into a separate function so that it can be attempted before constructing\n /// a bignum.\n-///\n-/// The fast path crucially depends on arithmetic being correctly rounded, so on x86\n-/// without SSE or SSE2 it requires the precision of the x87 FPU stack to be changed\n-/// so that it directly rounds to 64/32 bit.\n pub fn fast_path<T: RawFloat>(integral: &[u8], fractional: &[u8], e: i64) -> Option<T> {\n     let num_digits = integral.len() + fractional.len();\n     // log_10(f64::max_sig) ~ 15.95. We compare the exact value to max_sig near the end,\n@@ -91,11 +143,16 @@ pub fn fast_path<T: RawFloat>(integral: &[u8], fractional: &[u8], e: i64) -> Opt\n         return None;\n     }\n \n+    // The fast path crucially depends on arithmetic being rounded to the correct number of bits\n+    // without any intermediate rounding. On x86 (without SSE or SSE2) this requires the precision\n+    // of the x87 FPU stack to be changed so that it directly rounds to 64/32 bit.\n+    // The `set_precision` function takes care of setting the precision on architectures which\n+    // require setting it by changing the global state (like the control word of the x87 FPU).\n     let _cw = fpu_precision::set_precision::<T>();\n \n     // The case e < 0 cannot be folded into the other branch. Negative powers result in\n     // a repeating fractional part in binary, which are rounded, which causes real\n-    // (and occasioally quite significant!) errors in the final result.\n+    // (and occasionally quite significant!) errors in the final result.\n     if e >= 0 {\n         Some(T::from_int(f) * T::short_fast_pow10(e as usize))\n     } else {"}]}