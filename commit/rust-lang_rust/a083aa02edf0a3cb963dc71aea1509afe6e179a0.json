{"sha": "a083aa02edf0a3cb963dc71aea1509afe6e179a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwODNhYTAyZWRmMGEzY2I5NjNkYzcxYWVhMTUwOWFmZTZlMTc5YTA=", "commit": {"author": {"name": "Bruno Dutra", "email": "brunocodutra@gmail.com", "date": "2018-08-04T22:01:11Z"}, "committer": {"name": "Bruno Dutra", "email": "brunocodutra@gmail.com", "date": "2018-09-03T18:02:35Z"}, "message": "Implement Hash in terms of HashStable for EvalSnapshot", "tree": {"sha": "3b9691c90c5084db29037b018ddbcfb9ac1d0a57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b9691c90c5084db29037b018ddbcfb9ac1d0a57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a083aa02edf0a3cb963dc71aea1509afe6e179a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a083aa02edf0a3cb963dc71aea1509afe6e179a0", "html_url": "https://github.com/rust-lang/rust/commit/a083aa02edf0a3cb963dc71aea1509afe6e179a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a083aa02edf0a3cb963dc71aea1509afe6e179a0/comments", "author": {"login": "brunocodutra", "id": 4043663, "node_id": "MDQ6VXNlcjQwNDM2NjM=", "avatar_url": "https://avatars.githubusercontent.com/u/4043663?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brunocodutra", "html_url": "https://github.com/brunocodutra", "followers_url": "https://api.github.com/users/brunocodutra/followers", "following_url": "https://api.github.com/users/brunocodutra/following{/other_user}", "gists_url": "https://api.github.com/users/brunocodutra/gists{/gist_id}", "starred_url": "https://api.github.com/users/brunocodutra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brunocodutra/subscriptions", "organizations_url": "https://api.github.com/users/brunocodutra/orgs", "repos_url": "https://api.github.com/users/brunocodutra/repos", "events_url": "https://api.github.com/users/brunocodutra/events{/privacy}", "received_events_url": "https://api.github.com/users/brunocodutra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brunocodutra", "id": 4043663, "node_id": "MDQ6VXNlcjQwNDM2NjM=", "avatar_url": "https://avatars.githubusercontent.com/u/4043663?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brunocodutra", "html_url": "https://github.com/brunocodutra", "followers_url": "https://api.github.com/users/brunocodutra/followers", "following_url": "https://api.github.com/users/brunocodutra/following{/other_user}", "gists_url": "https://api.github.com/users/brunocodutra/gists{/gist_id}", "starred_url": "https://api.github.com/users/brunocodutra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brunocodutra/subscriptions", "organizations_url": "https://api.github.com/users/brunocodutra/orgs", "repos_url": "https://api.github.com/users/brunocodutra/repos", "events_url": "https://api.github.com/users/brunocodutra/events{/privacy}", "received_events_url": "https://api.github.com/users/brunocodutra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "030077401d6b7c2f923b24271dc5dc80044b089a", "url": "https://api.github.com/repos/rust-lang/rust/commits/030077401d6b7c2f923b24271dc5dc80044b089a", "html_url": "https://github.com/rust-lang/rust/commit/030077401d6b7c2f923b24271dc5dc80044b089a"}], "stats": {"total": 157, "additions": 105, "deletions": 52}, "files": [{"sha": "677343a85defea46a7a1c1758c7c471e98631823", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a083aa02edf0a3cb963dc71aea1509afe6e179a0/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a083aa02edf0a3cb963dc71aea1509afe6e179a0/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=a083aa02edf0a3cb963dc71aea1509afe6e179a0", "patch": "@@ -412,7 +412,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n         ty::tls::with_opt(|tcx| {\n             trace!(\"hashing {:?}\", *self);\n             let tcx = tcx.expect(\"can't hash AllocIds during hir lowering\");\n-            let alloc_kind = tcx.alloc_map.lock().get(*self).expect(\"no value for AllocId\");\n+            let alloc_kind = tcx.alloc_map.lock().get(*self);\n             alloc_kind.hash_stable(hcx, hasher);\n         });\n     }"}, {"sha": "c70a0abe8c7e437e5ed2f92aac748d6dca74b1b3", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a083aa02edf0a3cb963dc71aea1509afe6e179a0/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a083aa02edf0a3cb963dc71aea1509afe6e179a0/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=a083aa02edf0a3cb963dc71aea1509afe6e179a0", "patch": "@@ -281,6 +281,23 @@ impl<T1, T2, T3, CTX> HashStable<CTX> for (T1, T2, T3)\n     }\n }\n \n+impl<T1, T2, T3, T4, CTX> HashStable<CTX> for (T1, T2, T3, T4)\n+     where T1: HashStable<CTX>,\n+           T2: HashStable<CTX>,\n+           T3: HashStable<CTX>,\n+           T4: HashStable<CTX>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let (ref _0, ref _1, ref _2, ref _3) = *self;\n+        _0.hash_stable(ctx, hasher);\n+        _1.hash_stable(ctx, hasher);\n+        _2.hash_stable(ctx, hasher);\n+        _3.hash_stable(ctx, hasher);\n+    }\n+}\n+\n impl<T: HashStable<CTX>, CTX> HashStable<CTX> for [T] {\n     default fn hash_stable<W: StableHasherResult>(&self,\n                                                   ctx: &mut CTX,"}, {"sha": "92ddd8777f733eb0398566b1c45fe9f1fccd6867", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a083aa02edf0a3cb963dc71aea1509afe6e179a0/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a083aa02edf0a3cb963dc71aea1509afe6e179a0/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=a083aa02edf0a3cb963dc71aea1509afe6e179a0", "patch": "@@ -196,6 +196,8 @@ impl<'tcx> Into<EvalError<'tcx>> for ConstEvalError {\n     }\n }\n \n+impl_stable_hash_for!(struct CompileTimeEvaluator {});\n+\n #[derive(Clone, Debug)]\n enum ConstEvalError {\n     NeedsRfc(String),"}, {"sha": "8d4f3baf3a9b735a1d1046f0572490692e474215", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 50, "deletions": 16, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a083aa02edf0a3cb963dc71aea1509afe6e179a0/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a083aa02edf0a3cb963dc71aea1509afe6e179a0/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=a083aa02edf0a3cb963dc71aea1509afe6e179a0", "patch": "@@ -15,15 +15,17 @@ use std::mem;\n use rustc::hir::def_id::DefId;\n use rustc::hir::def::Def;\n use rustc::hir::map::definitions::DefPathData;\n+use rustc::ich::{StableHashingContext, StableHashingContextProvider};\n use rustc::mir;\n use rustc::ty::layout::{\n     self, Size, Align, HasDataLayout, LayoutOf, TyLayout\n };\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::query::TyCtxtAt;\n-use rustc_data_structures::fx::{FxHashSet, FxHasher};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n use rustc::mir::interpret::{\n     GlobalId, Scalar, FrameInfo,\n     EvalResult, EvalErrorKind,\n@@ -134,25 +136,21 @@ impl<'mir, 'tcx: 'mir> PartialEq for Frame<'mir, 'tcx> {\n     }\n }\n \n-impl<'mir, 'tcx: 'mir> Hash for Frame<'mir, 'tcx> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n+impl<'a, 'mir, 'tcx: 'mir> HashStable<StableHashingContext<'a>> for Frame<'mir, 'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher<W>) {\n         let Frame {\n-            mir: _,\n+            mir,\n             instance,\n-            span: _,\n+            span,\n             return_to_block,\n             return_place,\n             locals,\n             block,\n             stmt,\n         } = self;\n \n-        instance.hash(state);\n-        return_to_block.hash(state);\n-        return_place.hash(state);\n-        locals.hash(state);\n-        block.hash(state);\n-        stmt.hash(state);\n+        (mir, instance, span, return_to_block).hash_stable(hcx, hasher);\n+        (return_place, locals, block, stmt).hash_stable(hcx, hasher);\n     }\n }\n \n@@ -168,6 +166,15 @@ pub enum StackPopCleanup {\n     None { cleanup: bool },\n }\n \n+impl<'a> HashStable<StableHashingContext<'a>> for StackPopCleanup {\n+    fn hash_stable<W: StableHasherResult>(&self, hcx: &mut StableHashingContext<'b>, hasher: &mut StableHasher<W>) {\n+        match self {\n+            StackPopCleanup::Goto(ref block) => block.hash_stable(hcx, hasher),\n+            StackPopCleanup::None { cleanup } => cleanup.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n // State of a local variable\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub enum LocalValue {\n@@ -195,9 +202,14 @@ impl<'tcx> LocalValue {\n     }\n }\n \n+impl_stable_hash_for!(enum self::LocalValue {\n+    Dead,\n+    Live(x),\n+});\n+\n /// The virtual machine state during const-evaluation at a given point in time.\n-#[derive(Eq, PartialEq, Hash)]\n-pub(crate) struct EvalSnapshot<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n+#[derive(Eq, PartialEq)]\n+struct EvalSnapshot<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     machine: M,\n     memory: Memory<'a, 'mir, 'tcx, M>,\n     stack: Vec<Frame<'mir, 'tcx>>,\n@@ -215,6 +227,27 @@ impl<'a, 'mir, 'tcx, M> EvalSnapshot<'a, 'mir, 'tcx, M>\n     }\n }\n \n+impl<'a, 'mir, 'tcx, M> Hash for EvalSnapshot<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+{\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        // Implement in terms of hash stable, so that k1 == k2 -> hash(k1) == hash(k2)\n+        let mut hcx = self.memory.tcx.get_stable_hashing_context();\n+        let mut hasher = StableHasher::<u64>::new();\n+        self.hash_stable(&mut hcx, &mut hasher);\n+        hasher.finish().hash(state)\n+    }\n+}\n+\n+impl<'a, 'b, 'mir, 'tcx, M> HashStable<StableHashingContext<'b>> for EvalSnapshot<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self, hcx: &mut StableHashingContext<'b>, hasher: &mut StableHasher<W>) {\n+        let EvalSnapshot{ machine, memory, stack } = self;\n+        (machine, &memory.data, stack).hash_stable(hcx, hasher);\n+    }\n+}\n+\n pub(super) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// The set of all `EvalSnapshot` *hashes* observed by this detector.\n     ///\n@@ -258,9 +291,10 @@ impl<'a, 'mir, 'tcx, M> InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n         stack: &[Frame<'mir, 'tcx>],\n     ) -> EvalResult<'tcx, ()> {\n \n-        let mut fx = FxHasher::default();\n-        (machine, memory, stack).hash(&mut fx);\n-        let hash = fx.finish();\n+        let mut hcx = memory.tcx.get_stable_hashing_context();\n+        let mut hasher = StableHasher::<u64>::new();\n+        (machine, stack).hash_stable(&mut hcx, &mut hasher);\n+        let hash = hasher.finish();\n \n         if self.hashes.insert(hash) {\n             // No collision"}, {"sha": "61963f6d3d354560828405c7cbdd9f4fa758b49f", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a083aa02edf0a3cb963dc71aea1509afe6e179a0/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a083aa02edf0a3cb963dc71aea1509afe6e179a0/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=a083aa02edf0a3cb963dc71aea1509afe6e179a0", "patch": "@@ -15,17 +15,19 @@\n use std::hash::Hash;\n \n use rustc::hir::def_id::DefId;\n+use rustc::ich::StableHashingContext;\n use rustc::mir::interpret::{Allocation, EvalResult, Scalar};\n use rustc::mir;\n use rustc::ty::{self, layout::TyLayout, query::TyCtxtAt};\n+use rustc_data_structures::stable_hasher::HashStable;\n \n use super::{EvalContext, PlaceTy, OpTy};\n \n /// Methods of this trait signifies a point where CTFE evaluation would fail\n /// and some use case dependent behaviour can instead be applied\n-pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash {\n+pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash + for<'a> HashStable<StableHashingContext<'a>> {\n     /// Additional data that can be accessed via the Memory\n-    type MemoryData: Clone + Eq + Hash;\n+    type MemoryData: Clone + Eq + Hash + for<'a> HashStable<StableHashingContext<'a>>;\n \n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n     type MemoryKinds: ::std::fmt::Debug + Copy + Clone + Eq + Hash;"}, {"sha": "4a291f164ccdad328f473208f92905ee1679221e", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a083aa02edf0a3cb963dc71aea1509afe6e179a0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a083aa02edf0a3cb963dc71aea1509afe6e179a0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=a083aa02edf0a3cb963dc71aea1509afe6e179a0", "patch": "@@ -17,7 +17,6 @@\n //! short-circuiting the empty case!\n \n use std::collections::VecDeque;\n-use std::hash::{Hash, Hasher};\n use std::ptr;\n \n use rustc::ty::{self, Instance, query::TyCtxtAt};\n@@ -26,7 +25,7 @@ use rustc::mir::interpret::{Pointer, AllocId, Allocation, ConstValue, ScalarMayb\n                             EvalResult, Scalar, EvalErrorKind, AllocType, PointerArithmetic,\n                             truncate};\n pub use rustc::mir::interpret::{write_target_uint, read_target_uint};\n-use rustc_data_structures::fx::{FxHashSet, FxHashMap, FxHasher};\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n use syntax::ast::Mutability;\n \n@@ -91,37 +90,6 @@ impl<'a, 'mir, 'tcx, M> PartialEq for Memory<'a, 'mir, 'tcx, M>\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M> Hash for Memory<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n-          'tcx: 'a + 'mir,\n-{\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        let Memory {\n-            data,\n-            alloc_map: _,\n-            tcx: _,\n-        } = self;\n-\n-        data.hash(state);\n-\n-        // We ignore some fields which don't change between evaluation steps.\n-\n-        // Since HashMaps which contain the same items may have different\n-        // iteration orders, we use a commutative operation (in this case\n-        // addition, but XOR would also work), to combine the hash of each\n-        // `Allocation`.\n-        self.alloc_map.iter()\n-            .map(|(&id, alloc)| {\n-                let mut h = FxHasher::default();\n-                id.hash(&mut h);\n-                alloc.hash(&mut h);\n-                h.finish()\n-            })\n-            .fold(0u64, |hash, x| hash.wrapping_add(x))\n-            .hash(state);\n-    }\n-}\n-\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>, data: M::MemoryData) -> Self {\n         Memory {"}, {"sha": "9970816dc2a94f86c83e3e9c8cf9d73235985f32", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a083aa02edf0a3cb963dc71aea1509afe6e179a0/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a083aa02edf0a3cb963dc71aea1509afe6e179a0/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=a083aa02edf0a3cb963dc71aea1509afe6e179a0", "patch": "@@ -81,6 +81,11 @@ impl<'tcx> Value {\n     }\n }\n \n+impl_stable_hash_for!(enum ::interpret::Value {\n+    Scalar(x),\n+    ScalarPair(x, y),\n+});\n+\n // ScalarPair needs a type to interpret, so we often have a value and a type together\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n@@ -126,6 +131,11 @@ impl Operand {\n     }\n }\n \n+impl_stable_hash_for!(enum ::interpret::Operand {\n+    Immediate(x),\n+    Indirect(x),\n+});\n+\n #[derive(Copy, Clone, Debug)]\n pub struct OpTy<'tcx> {\n     crate op: Operand, // ideally we'd make this private, but const_prop needs this"}, {"sha": "6236a4784fb704088508dac66eae5880cb97025a", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a083aa02edf0a3cb963dc71aea1509afe6e179a0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a083aa02edf0a3cb963dc71aea1509afe6e179a0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=a083aa02edf0a3cb963dc71aea1509afe6e179a0", "patch": "@@ -14,10 +14,12 @@\n \n use std::convert::TryFrom;\n \n+use rustc::ich::StableHashingContext;\n use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout};\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n \n use rustc::mir::interpret::{\n     GlobalId, Scalar, EvalResult, Pointer, ScalarMaybeUndef, PointerArithmetic\n@@ -37,6 +39,12 @@ pub struct MemPlace {\n     pub extra: Option<Scalar>,\n }\n \n+impl_stable_hash_for!(struct ::interpret::MemPlace {\n+    ptr,\n+    align,\n+    extra,\n+});\n+\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Place {\n     /// A place referring to a value allocated in the `Memory` system.\n@@ -50,6 +58,18 @@ pub enum Place {\n     },\n }\n \n+impl<'a> HashStable<StableHashingContext<'a>> for Place {\n+    fn hash_stable<W: StableHasherResult>(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher<W>) {\n+        match self {\n+            Place::Ptr(mem_place) => mem_place.hash_stable(hcx, hasher),\n+\n+            Place::Local { frame, local } => {\n+                frame.hash_stable(hcx, hasher);\n+                local.hash_stable(hcx, hasher);\n+            },\n+        }\n+    }\n+}\n #[derive(Copy, Clone, Debug)]\n pub struct PlaceTy<'tcx> {\n     place: Place,"}]}