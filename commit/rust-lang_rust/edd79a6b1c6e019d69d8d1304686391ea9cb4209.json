{"sha": "edd79a6b1c6e019d69d8d1304686391ea9cb4209", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkZDc5YTZiMWM2ZTAxOWQ2OWQ4ZDEzMDQ2ODYzOTFlYTljYjQyMDk=", "commit": {"author": {"name": "unexge", "email": "unexge@gmail.com", "date": "2020-08-02T19:56:54Z"}, "committer": {"name": "unexge", "email": "unexge@gmail.com", "date": "2020-08-02T19:56:54Z"}, "message": "Add expand glob import assist", "tree": {"sha": "b4c29f01b25034794232a5f18ced823d6fe47529", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4c29f01b25034794232a5f18ced823d6fe47529"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edd79a6b1c6e019d69d8d1304686391ea9cb4209", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edd79a6b1c6e019d69d8d1304686391ea9cb4209", "html_url": "https://github.com/rust-lang/rust/commit/edd79a6b1c6e019d69d8d1304686391ea9cb4209", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edd79a6b1c6e019d69d8d1304686391ea9cb4209/comments", "author": {"login": "unexge", "id": 16212576, "node_id": "MDQ6VXNlcjE2MjEyNTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unexge", "html_url": "https://github.com/unexge", "followers_url": "https://api.github.com/users/unexge/followers", "following_url": "https://api.github.com/users/unexge/following{/other_user}", "gists_url": "https://api.github.com/users/unexge/gists{/gist_id}", "starred_url": "https://api.github.com/users/unexge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unexge/subscriptions", "organizations_url": "https://api.github.com/users/unexge/orgs", "repos_url": "https://api.github.com/users/unexge/repos", "events_url": "https://api.github.com/users/unexge/events{/privacy}", "received_events_url": "https://api.github.com/users/unexge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "unexge", "id": 16212576, "node_id": "MDQ6VXNlcjE2MjEyNTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unexge", "html_url": "https://github.com/unexge", "followers_url": "https://api.github.com/users/unexge/followers", "following_url": "https://api.github.com/users/unexge/following{/other_user}", "gists_url": "https://api.github.com/users/unexge/gists{/gist_id}", "starred_url": "https://api.github.com/users/unexge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unexge/subscriptions", "organizations_url": "https://api.github.com/users/unexge/orgs", "repos_url": "https://api.github.com/users/unexge/repos", "events_url": "https://api.github.com/users/unexge/events{/privacy}", "received_events_url": "https://api.github.com/users/unexge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e96bfd812a0f883bc9aa6b5ebe3b0a712c860487", "url": "https://api.github.com/repos/rust-lang/rust/commits/e96bfd812a0f883bc9aa6b5ebe3b0a712c860487", "html_url": "https://github.com/rust-lang/rust/commit/e96bfd812a0f883bc9aa6b5ebe3b0a712c860487"}], "stats": {"total": 367, "additions": 366, "deletions": 1}, "files": [{"sha": "afd3fd4b9e37c8d8211aed5cf0b675b316506f7b", "filename": "crates/ra_assists/src/assist_context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/edd79a6b1c6e019d69d8d1304686391ea9cb4209/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd79a6b1c6e019d69d8d1304686391ea9cb4209/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_context.rs?ref=edd79a6b1c6e019d69d8d1304686391ea9cb4209", "patch": "@@ -73,6 +73,10 @@ impl<'a> AssistContext<'a> {\n         self.sema.db\n     }\n \n+    pub(crate) fn source_file(&self) -> &SourceFile {\n+        &self.source_file\n+    }\n+\n     // NB, this ignores active selection.\n     pub(crate) fn offset(&self) -> TextSize {\n         self.frange.range.start()"}, {"sha": "590239304e2f6aaa9e7284d2e2288642c33fc112", "filename": "crates/ra_assists/src/handlers/expand_glob_import.rs", "status": "added", "additions": 359, "deletions": 0, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/edd79a6b1c6e019d69d8d1304686391ea9cb4209/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd79a6b1c6e019d69d8d1304686391ea9cb4209/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=edd79a6b1c6e019d69d8d1304686391ea9cb4209", "patch": "@@ -0,0 +1,359 @@\n+use hir::{MacroDef, ModuleDef, Name, PathResolution, ScopeDef, SemanticsScope};\n+use ra_ide_db::{\n+    defs::{classify_name_ref, Definition, NameRefClass},\n+    RootDatabase,\n+};\n+use ra_syntax::{ast, match_ast, AstNode, SyntaxNode, SyntaxToken, T};\n+\n+use crate::{\n+    assist_context::{AssistBuilder, AssistContext, Assists},\n+    AssistId, AssistKind,\n+};\n+\n+// Assist: expand_glob_import\n+//\n+// Expands glob imports.\n+//\n+// ```\n+// mod foo {\n+//     pub struct Bar;\n+//     pub struct Baz;\n+// }\n+//\n+// use foo::*<|>;\n+//\n+// fn qux(bar: Bar, baz: Baz) {}\n+// ```\n+// ->\n+// ```\n+// mod foo {\n+//     pub struct Bar;\n+//     pub struct Baz;\n+// }\n+//\n+// use foo::{Bar, Baz};\n+//\n+// fn qux(bar: Bar, baz: Baz) {}\n+// ```\n+pub(crate) fn expand_glob_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let star = ctx.find_token_at_offset(T![*])?;\n+    let mod_path = find_mod_path(&star)?;\n+\n+    let source_file = ctx.source_file();\n+    let scope = ctx.sema.scope_at_offset(source_file.syntax(), ctx.offset());\n+\n+    let defs_in_mod = find_defs_in_mod(ctx, scope, &mod_path)?;\n+    let name_refs_in_source_file =\n+        source_file.syntax().descendants().filter_map(ast::NameRef::cast).collect();\n+    let used_names = find_used_names(ctx, defs_in_mod, name_refs_in_source_file);\n+\n+    let parent = star.parent().parent()?;\n+    acc.add(\n+        AssistId(\"expand_glob_import\", AssistKind::RefactorRewrite),\n+        \"Expand glob import\",\n+        parent.text_range(),\n+        |builder| {\n+            replace_ast(builder, &parent, mod_path, used_names);\n+        },\n+    )\n+}\n+\n+fn find_mod_path(star: &SyntaxToken) -> Option<ast::Path> {\n+    let mut node = star.parent();\n+\n+    loop {\n+        match_ast! {\n+            match node {\n+                ast::UseTree(use_tree) => {\n+                    if let Some(path) = use_tree.path() {\n+                        return Some(path);\n+                    }\n+                },\n+                ast::UseTreeList(_use_tree_list) => {},\n+                _ => return None,\n+            }\n+        }\n+\n+        node = match node.parent() {\n+            Some(node) => node,\n+            None => return None,\n+        }\n+    }\n+}\n+\n+#[derive(PartialEq)]\n+enum Def {\n+    ModuleDef(ModuleDef),\n+    MacroDef(MacroDef),\n+}\n+\n+impl Def {\n+    fn name(&self, db: &RootDatabase) -> Option<Name> {\n+        match self {\n+            Def::ModuleDef(def) => def.name(db),\n+            Def::MacroDef(def) => def.name(db),\n+        }\n+    }\n+}\n+\n+fn find_defs_in_mod(\n+    ctx: &AssistContext,\n+    from: SemanticsScope<'_>,\n+    path: &ast::Path,\n+) -> Option<Vec<Def>> {\n+    let hir_path = ctx.sema.lower_path(&path)?;\n+    let module = if let Some(PathResolution::Def(ModuleDef::Module(module))) =\n+        from.resolve_hir_path_qualifier(&hir_path)\n+    {\n+        module\n+    } else {\n+        return None;\n+    };\n+\n+    let module_scope = module.scope(ctx.db(), from.module());\n+\n+    let mut defs = vec![];\n+    for (_, def) in module_scope {\n+        match def {\n+            ScopeDef::ModuleDef(def) => defs.push(Def::ModuleDef(def)),\n+            ScopeDef::MacroDef(def) => defs.push(Def::MacroDef(def)),\n+            _ => continue,\n+        }\n+    }\n+\n+    Some(defs)\n+}\n+\n+fn find_used_names(\n+    ctx: &AssistContext,\n+    defs_in_mod: Vec<Def>,\n+    name_refs_in_source_file: Vec<ast::NameRef>,\n+) -> Vec<Name> {\n+    let defs_in_source_file = name_refs_in_source_file\n+        .iter()\n+        .filter_map(|r| classify_name_ref(&ctx.sema, r))\n+        .filter_map(|rc| match rc {\n+            NameRefClass::Definition(Definition::ModuleDef(def)) => Some(Def::ModuleDef(def)),\n+            NameRefClass::Definition(Definition::Macro(def)) => Some(Def::MacroDef(def)),\n+            _ => None,\n+        })\n+        .collect::<Vec<Def>>();\n+\n+    defs_in_mod\n+        .iter()\n+        .filter(|d| defs_in_source_file.contains(d))\n+        .filter_map(|d| d.name(ctx.db()))\n+        .collect()\n+}\n+\n+fn replace_ast(\n+    builder: &mut AssistBuilder,\n+    node: &SyntaxNode,\n+    path: ast::Path,\n+    used_names: Vec<Name>,\n+) {\n+    let new_use_tree_list = ast::make::use_tree_list(used_names.iter().map(|n| {\n+        ast::make::use_tree(ast::make::path_from_text(&n.to_string()), None, None, false)\n+    }));\n+\n+    match_ast! {\n+        match node {\n+            ast::UseTree(use_tree) => {\n+                builder.replace_ast(use_tree, make_use_tree(path, new_use_tree_list));\n+            },\n+            ast::UseTreeList(use_tree_list) => {\n+                builder.replace_ast(use_tree_list, new_use_tree_list);\n+            },\n+            ast::UseItem(use_item) => {\n+                builder.replace_ast(use_item, ast::make::use_item(make_use_tree(path, new_use_tree_list)));\n+            },\n+            _ => {},\n+        }\n+    }\n+\n+    fn make_use_tree(path: ast::Path, use_tree_list: ast::UseTreeList) -> ast::UseTree {\n+        ast::make::use_tree(path, Some(use_tree_list), None, false)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn expanding_glob_import() {\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+mod foo {\n+    pub struct Bar;\n+    pub struct Baz;\n+    pub struct Qux;\n+\n+    pub fn f() {}\n+}\n+\n+use foo::*<|>;\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+}\n+\",\n+            r\"\n+mod foo {\n+    pub struct Bar;\n+    pub struct Baz;\n+    pub struct Qux;\n+\n+    pub fn f() {}\n+}\n+\n+use foo::{Baz, Bar, f};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn expanding_glob_import_with_existing_explicit_names() {\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+mod foo {\n+    pub struct Bar;\n+    pub struct Baz;\n+    pub struct Qux;\n+\n+    pub fn f() {}\n+}\n+\n+use foo::{*<|>, f};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+}\n+\",\n+            r\"\n+mod foo {\n+    pub struct Bar;\n+    pub struct Baz;\n+    pub struct Qux;\n+\n+    pub fn f() {}\n+}\n+\n+use foo::{Baz, Bar, f};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn expanding_nested_glob_import() {\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+mod foo {\n+    mod bar {\n+        pub struct Bar;\n+        pub struct Baz;\n+        pub struct Qux;\n+\n+        pub fn f() {}\n+    }\n+\n+    mod baz {\n+        pub fn g() {}\n+    }\n+}\n+\n+use foo::{bar::{*<|>, f}, baz::*};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+    g();\n+}\n+\",\n+            r\"\n+mod foo {\n+    mod bar {\n+        pub struct Bar;\n+        pub struct Baz;\n+        pub struct Qux;\n+\n+        pub fn f() {}\n+    }\n+\n+    mod baz {\n+        pub fn g() {}\n+    }\n+}\n+\n+use foo::{bar::{Baz, Bar, f}, baz::*};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+    g();\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn expanding_glob_import_with_macro_defs() {\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+//- /lib.rs crate:foo\n+#[macro_export]\n+macro_rules! bar {\n+    () => ()\n+}\n+\n+pub fn baz() {}\n+\n+//- /main.rs crate:main deps:foo\n+use foo::*<|>;\n+\n+fn main() {\n+    bar!();\n+    baz();\n+}\n+\",\n+            r\"\n+use foo::{bar, baz};\n+\n+fn main() {\n+    bar!();\n+    baz();\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn expanding_is_not_applicable_if_cursor_is_not_in_star_token() {\n+        check_assist_not_applicable(\n+            expand_glob_import,\n+            r\"\n+    mod foo {\n+        pub struct Bar;\n+        pub struct Baz;\n+        pub struct Qux;\n+    }\n+\n+    use foo::Bar<|>;\n+\n+    fn qux(bar: Bar, baz: Baz) {}\n+    \",\n+        )\n+    }\n+}"}, {"sha": "507646cc802899573e1b8a1807b43b5fb4ea0fb1", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edd79a6b1c6e019d69d8d1304686391ea9cb4209/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd79a6b1c6e019d69d8d1304686391ea9cb4209/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=edd79a6b1c6e019d69d8d1304686391ea9cb4209", "patch": "@@ -140,6 +140,7 @@ mod handlers {\n     mod change_return_type_to_result;\n     mod change_visibility;\n     mod early_return;\n+    mod expand_glob_import;\n     mod extract_struct_from_enum_variant;\n     mod extract_variable;\n     mod fill_match_arms;\n@@ -181,6 +182,7 @@ mod handlers {\n             change_return_type_to_result::change_return_type_to_result,\n             change_visibility::change_visibility,\n             early_return::convert_to_guarded_return,\n+            expand_glob_import::expand_glob_import,\n             extract_struct_from_enum_variant::extract_struct_from_enum_variant,\n             extract_variable::extract_variable,\n             fill_match_arms::fill_match_arms,"}, {"sha": "3cb1d35eeca51fde9290661fed1ec49a94d72a6b", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edd79a6b1c6e019d69d8d1304686391ea9cb4209/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd79a6b1c6e019d69d8d1304686391ea9cb4209/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=edd79a6b1c6e019d69d8d1304686391ea9cb4209", "patch": "@@ -30,7 +30,7 @@ pub fn path_unqualified(segment: ast::PathSegment) -> ast::Path {\n pub fn path_qualified(qual: ast::Path, segment: ast::PathSegment) -> ast::Path {\n     path_from_text(&format!(\"{}::{}\", qual, segment))\n }\n-fn path_from_text(text: &str) -> ast::Path {\n+pub fn path_from_text(text: &str) -> ast::Path {\n     ast_from_text(text)\n }\n "}]}