{"sha": "8ee206a80dab320ee76a2aa9324c587368df3921", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlZTIwNmE4MGRhYjMyMGVlNzZhMmFhOTMyNGM1ODczNjhkZjM5MjE=", "commit": {"author": {"name": "csmoe", "email": "csmoe@msn.com", "date": "2020-08-20T10:42:08Z"}, "committer": {"name": "csmoe", "email": "csmoe@msn.com", "date": "2020-08-26T09:40:08Z"}, "message": "suggest await on unexpected types", "tree": {"sha": "732a8cd716ef9ce5b62cd01053f7c2d6d08d8b36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/732a8cd716ef9ce5b62cd01053f7c2d6d08d8b36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ee206a80dab320ee76a2aa9324c587368df3921", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ee206a80dab320ee76a2aa9324c587368df3921", "html_url": "https://github.com/rust-lang/rust/commit/8ee206a80dab320ee76a2aa9324c587368df3921", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ee206a80dab320ee76a2aa9324c587368df3921/comments", "author": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2271b081ebdb10af25aca0206e53931eaed92d3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2271b081ebdb10af25aca0206e53931eaed92d3a", "html_url": "https://github.com/rust-lang/rust/commit/2271b081ebdb10af25aca0206e53931eaed92d3a"}], "stats": {"total": 158, "additions": 126, "deletions": 32}, "files": [{"sha": "35b2d7e8468396452c2a03f6c8426667b8774cb3", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8ee206a80dab320ee76a2aa9324c587368df3921/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee206a80dab320ee76a2aa9324c587368df3921/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=8ee206a80dab320ee76a2aa9324c587368df3921", "patch": "@@ -50,6 +50,7 @@ use super::region_constraints::GenericKind;\n use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n \n use crate::infer;\n+use crate::infer::OriginalQueryValues;\n use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n@@ -60,8 +61,10 @@ use rustc_errors::{pluralize, struct_span_err};\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_hir::lang_items::LangItem;\n use rustc_hir::{Item, ItemKind, Node};\n use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::ParamEnvAnd;\n use rustc_middle::ty::{\n     self,\n     subst::{Subst, SubstsRef},\n@@ -1529,6 +1532,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         };\n         if let Some(exp_found) = exp_found {\n             self.suggest_as_ref_where_appropriate(span, &exp_found, diag);\n+            self.suggest_await_on_expect_found(cause, span, &exp_found, diag);\n         }\n \n         // In some (most?) cases cause.body_id points to actual body, but in some cases\n@@ -1547,6 +1551,72 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.note_error_origin(diag, cause, exp_found);\n     }\n \n+    fn suggest_await_on_expect_found(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        exp_span: Span,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+        diag: &mut DiagnosticBuilder<'tcx>,\n+    ) {\n+        debug!(\n+            \"suggest_await_on_expect_found: exp_span={:?}, expected_ty={:?}, found_ty={:?}\",\n+            exp_span, exp_found.expected, exp_found.found\n+        );\n+\n+        if let ty::Opaque(def_id, _) = exp_found.expected.kind {\n+            let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n+            // Future::Output\n+            let item_def_id = self\n+                .tcx\n+                .associated_items(future_trait)\n+                .in_definition_order()\n+                .next()\n+                .unwrap()\n+                .def_id;\n+\n+            let mut projection_ty = None;\n+            for (predicate, _) in self.tcx.predicates_of(def_id).predicates {\n+                if let ty::PredicateAtom::Projection(projection_predicate) =\n+                    predicate.skip_binders()\n+                {\n+                    if item_def_id == projection_predicate.projection_ty.item_def_id {\n+                        projection_ty = Some(projection_predicate.projection_ty);\n+                        break;\n+                    }\n+                }\n+            }\n+            if let Some(projection_ty) = projection_ty {\n+                let projection_query = self.canonicalize_query(\n+                    &ParamEnvAnd { param_env: self.tcx.param_env(def_id), value: projection_ty },\n+                    &mut OriginalQueryValues::default(),\n+                );\n+                if let Ok(resp) = self.tcx.normalize_projection_ty(projection_query) {\n+                    let normalized_ty = resp.value.value.normalized_ty;\n+                    debug!(\"suggest_await_on_expect_found: normalized={:?}\", normalized_ty);\n+                    if ty::TyS::same_type(normalized_ty, exp_found.found) {\n+                        let span = if let ObligationCauseCode::Pattern {\n+                            span,\n+                            origin_expr: _,\n+                            root_ty: _,\n+                        } = cause.code\n+                        {\n+                            // scrutinee's span\n+                            span.unwrap_or(exp_span)\n+                        } else {\n+                            exp_span\n+                        };\n+                        diag.span_suggestion_verbose(\n+                            span.shrink_to_hi(),\n+                            \"consider awaiting on the future\",\n+                            \".await\".to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     /// When encountering a case where `.as_ref()` on a `Result` or `Option` would be appropriate,\n     /// suggests it.\n     fn suggest_as_ref_where_appropriate("}, {"sha": "afd4413069ee10df5879f1eae2fb6aaba4198ab8", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ee206a80dab320ee76a2aa9324c587368df3921/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee206a80dab320ee76a2aa9324c587368df3921/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=8ee206a80dab320ee76a2aa9324c587368df3921", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         // Type check the descriminant and get its type.\n-        let scrut_ty = if force_scrutinee_bool {\n+        let scrutinee_ty = if force_scrutinee_bool {\n             // Here we want to ensure:\n             //\n             // 1. That default match bindings are *not* accepted in the condition of an\n@@ -55,7 +55,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // #55810: Type check patterns first so we get types for all bindings.\n         for arm in arms {\n-            self.check_pat_top(&arm.pat, scrut_ty, Some(scrut.span), true);\n+            self.check_pat_top(&arm.pat, scrutinee_ty, Some(scrut.span), true);\n         }\n \n         // Now typecheck the blocks."}, {"sha": "702dc30957ccf011214b98efac601cb1c62a3316", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8ee206a80dab320ee76a2aa9324c587368df3921/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee206a80dab320ee76a2aa9324c587368df3921/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=8ee206a80dab320ee76a2aa9324c587368df3921", "patch": "@@ -1518,7 +1518,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         def_id: DefId,\n     ) {\n         let param_env = self.tcx().param_env(def_id);\n-        let future_trait = self.tcx.require_lang_item(lang_items::FutureTraitLangItem, None);\n+        let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n         // Future::Output\n         let item_def_id =\n             self.tcx.associated_items(future_trait).in_definition_order().next().unwrap().def_id;\n@@ -1554,15 +1554,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             );\n             if let ty::Adt(def, _) = normalized_ty.kind {\n                 if def.non_enum_variant().fields.iter().any(|field| field.ident == field_ident) {\n-                    if let Ok(base) = self.tcx.sess.source_map().span_to_snippet(base.span) {\n-                        let suggestion = format!(\"{}.await.{}\", base, field_ident);\n-                        err.span_suggestion(\n-                            expr.span,\n-                            \"consider await before field access\",\n-                            suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n+                    err.span_suggestion_verbose(\n+                        base.span.shrink_to_hi(),\n+                        \"consider awaiting before field access\",\n+                        \".await\".to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n             }\n         }"}, {"sha": "3dd4c7c143967b144493d40c66eecab946e4d02c", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ee206a80dab320ee76a2aa9324c587368df3921/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee206a80dab320ee76a2aa9324c587368df3921/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=8ee206a80dab320ee76a2aa9324c587368df3921", "patch": "@@ -911,15 +911,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n                 let method_exists = self.method_exists(item_name, normalized_ty, call.hir_id, true);\n                 debug!(\"suggest_await_before_method: is_method_exist={}\", method_exists);\n-                if let Ok(sp) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                    if method_exists {\n-                        err.span_suggestion(\n-                            span,\n-                            \"consider await before this method call\",\n-                            format!(\"await.{}\", sp),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n+                if method_exists {\n+                    err.span_suggestion_verbose(\n+                        span.shrink_to_lo(),\n+                        \"consider awaiting before this method call\",\n+                        \"await.\".to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n             }\n         }"}, {"sha": "e383a9126f7bc2b065285b356d754ec97f78f195", "filename": "src/test/ui/async-await/issue-61076.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ee206a80dab320ee76a2aa9324c587368df3921/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee206a80dab320ee76a2aa9324c587368df3921/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs?ref=8ee206a80dab320ee76a2aa9324c587368df3921", "patch": "@@ -64,5 +64,10 @@ async fn baz() -> Result<(), ()> {\n     Ok(())\n }\n \n+async fn match_() {\n+    match tuple() {\n+        Tuple(_) => {} //~ ERROR mismatched types\n+    }\n+}\n \n fn main() {}"}, {"sha": "69b6e8c3cf5699ff8039c570dd4ad4f5ff63467c", "filename": "src/test/ui/async-await/issue-61076.stderr", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8ee206a80dab320ee76a2aa9324c587368df3921/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ee206a80dab320ee76a2aa9324c587368df3921/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr?ref=8ee206a80dab320ee76a2aa9324c587368df3921", "patch": "@@ -26,28 +26,52 @@ error[E0609]: no field `0` on type `impl std::future::Future`\n   --> $DIR/issue-61076.rs:58:26\n    |\n LL |     let _: i32 = tuple().0;\n-   |                  --------^\n-   |                  |\n-   |                  help: consider await before field access: `tuple().await.0`\n+   |                          ^\n+   |\n+help: consider awaiting before field access\n+   |\n+LL |     let _: i32 = tuple().await.0;\n+   |                         ^^^^^^\n \n error[E0609]: no field `a` on type `impl std::future::Future`\n   --> $DIR/issue-61076.rs:60:28\n    |\n LL |     let _: i32 = struct_().a;\n-   |                  ----------^\n-   |                  |\n-   |                  help: consider await before field access: `struct_().await.a`\n+   |                            ^\n+   |\n+help: consider awaiting before field access\n+   |\n+LL |     let _: i32 = struct_().await.a;\n+   |                           ^^^^^^\n \n error[E0599]: no method named `method` found for opaque type `impl std::future::Future` in the current scope\n   --> $DIR/issue-61076.rs:62:15\n    |\n LL |     struct_().method();\n+   |               ^^^^^^ method not found in `impl std::future::Future`\n+   |\n+help: consider awaiting before this method call\n+   |\n+LL |     struct_().await.method();\n    |               ^^^^^^\n-   |               |\n-   |               method not found in `impl std::future::Future`\n-   |               help: consider await before this method call: `await.method`\n \n-error: aborting due to 5 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/issue-61076.rs:69:9\n+   |\n+LL | async fn tuple() -> Tuple {\n+   |                     ----- the `Output` of this `async fn`'s expected opaque type\n+...\n+LL |         Tuple(_) => {}\n+   |         ^^^^^^^^ expected opaque type, found struct `Tuple`\n+   |\n+   = note: expected opaque type `impl std::future::Future`\n+                   found struct `Tuple`\n+help: consider awaiting on the future\n+   |\n+LL |     match tuple().await {\n+   |                  ^^^^^^\n+\n+error: aborting due to 6 previous errors\n \n-Some errors have detailed explanations: E0277, E0599, E0609.\n+Some errors have detailed explanations: E0277, E0308, E0599, E0609.\n For more information about an error, try `rustc --explain E0277`."}]}