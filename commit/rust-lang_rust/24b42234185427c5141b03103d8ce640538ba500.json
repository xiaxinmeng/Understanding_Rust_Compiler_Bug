{"sha": "24b42234185427c5141b03103d8ce640538ba500", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0YjQyMjM0MTg1NDI3YzUxNDFiMDMxMDNkOGNlNjQwNTM4YmE1MDA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-01T16:36:21Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-10T09:37:10Z"}, "message": "Migrate uv timer bindings away from ~fn()", "tree": {"sha": "44e08d13fe1f452aebcf07f00b005d881d588cb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44e08d13fe1f452aebcf07f00b005d881d588cb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24b42234185427c5141b03103d8ce640538ba500", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24b42234185427c5141b03103d8ce640538ba500", "html_url": "https://github.com/rust-lang/rust/commit/24b42234185427c5141b03103d8ce640538ba500", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24b42234185427c5141b03103d8ce640538ba500/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "653406fcf78aff6bfc4a7c025a8176919d708565", "url": "https://api.github.com/repos/rust-lang/rust/commits/653406fcf78aff6bfc4a7c025a8176919d708565", "html_url": "https://github.com/rust-lang/rust/commit/653406fcf78aff6bfc4a7c025a8176919d708565"}], "stats": {"total": 278, "additions": 151, "deletions": 127}, "files": [{"sha": "3d0ea4e6d1b89680a440f640b31fc63882b59023", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/24b42234185427c5141b03103d8ce640538ba500/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24b42234185427c5141b03103d8ce640538ba500/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=24b42234185427c5141b03103d8ce640538ba500", "patch": "@@ -45,6 +45,7 @@ via `close` and `delete` methods.\n \n #[feature(macro_rules, globs)];\n \n+use std::cast;\n use std::str::raw::from_c_str;\n use std::vec;\n use std::ptr;\n@@ -119,6 +120,42 @@ pub trait NativeHandle<T> {\n     fn native_handle(&self) -> T;\n }\n \n+/// A type that wraps a uv handle\n+pub trait UvHandle<T> {\n+    fn uv_handle(&self) -> *T;\n+\n+    // FIXME(#8888) dummy self\n+    fn alloc(_: Option<Self>, ty: uvll::uv_handle_type) -> *T {\n+        unsafe {\n+            let handle = uvll::malloc_handle(ty);\n+            assert!(!handle.is_null());\n+            handle as *T\n+        }\n+    }\n+\n+    unsafe fn from_uv_handle<'a>(h: &'a *T) -> &'a mut Self {\n+        cast::transmute(uvll::get_data_for_uv_handle(*h))\n+    }\n+\n+    fn install(~self) -> ~Self {\n+        unsafe {\n+            let myptr = cast::transmute::<&~Self, *u8>(&self);\n+            uvll::set_data_for_uv_handle(self.uv_handle(), myptr);\n+        }\n+        self\n+    }\n+\n+    fn close_async_(&mut self) {\n+        // we used malloc to allocate all handles, so we must always have at\n+        // least a callback to free all the handles we allocated.\n+        extern fn close_cb(handle: *uvll::uv_handle_t) {\n+            unsafe { uvll::free_handle(handle) }\n+        }\n+\n+        unsafe { uvll::close(self.uv_handle(), close_cb) }\n+    }\n+}\n+\n impl Loop {\n     pub fn new() -> Loop {\n         let handle = unsafe { uvll::loop_new() };\n@@ -367,7 +404,7 @@ pub fn empty_buf() -> Buf {\n /// Borrow a slice to a Buf\n pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n     let data = vec::raw::to_ptr(v);\n-    unsafe { uvll::uv_buf_init(data as *c_char, v.len() as c_uint) }\n+    uvll::uv_buf_t { base: data, len: v.len() as uvll::uv_buf_len_t }\n }\n \n // XXX: Do these conversions without copying\n@@ -383,7 +420,7 @@ pub fn vec_to_uv_buf(v: ~[u8]) -> Buf {\n             let data = data as *mut u8;\n             ptr::copy_memory(data, b, l)\n         }\n-        uvll::uv_buf_init(data as *c_char, v.len() as c_uint)\n+        uvll::uv_buf_t { base: data, len: v.len() as uvll::uv_buf_len_t }\n     }\n }\n "}, {"sha": "90b8263da79fd326614f251e6e4af11b5253bd8c", "filename": "src/librustuv/macros.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24b42234185427c5141b03103d8ce640538ba500/src%2Flibrustuv%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24b42234185427c5141b03103d8ce640538ba500/src%2Flibrustuv%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fmacros.rs?ref=24b42234185427c5141b03103d8ce640538ba500", "patch": "@@ -27,6 +27,11 @@ macro_rules! uvdebug (\n     })\n )\n \n+// get a handle for the current scheduler\n+macro_rules! get_handle_to_current_scheduler(\n+    () => (do Local::borrow |sched: &mut Scheduler| { sched.make_handle() })\n+)\n+\n pub fn dumb_println(args: &fmt::Arguments) {\n     use std::rt::io::native::stdio::stderr;\n     use std::rt::io::Writer;"}, {"sha": "f89a6c5e5c57fa7b625b0170f087bb2c49711569", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 98, "deletions": 33, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/24b42234185427c5141b03103d8ce640538ba500/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24b42234185427c5141b03103d8ce640538ba500/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=24b42234185427c5141b03103d8ce640538ba500", "patch": "@@ -8,58 +8,123 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::cell::Cell;\n+use std::comm::{oneshot, stream, PortOne, ChanOne};\n use std::libc::c_int;\n+use std::rt::BlockedTask;\n+use std::rt::local::Local;\n+use std::rt::rtio::RtioTimer;\n+use std::rt::sched::{Scheduler, SchedHandle};\n \n use uvll;\n-use super::{Watcher, Loop, NativeHandle, TimerCallback, status_to_maybe_uv_error};\n+use super::{Loop, NativeHandle, UvHandle};\n+use uvio::HomingIO;\n \n-pub struct TimerWatcher(*uvll::uv_timer_t);\n-impl Watcher for TimerWatcher { }\n+pub struct TimerWatcher {\n+    handle: *uvll::uv_timer_t,\n+    home: SchedHandle,\n+    action: Option<NextAction>,\n+}\n+\n+pub enum NextAction {\n+    WakeTask(BlockedTask),\n+    SendOnce(ChanOne<()>),\n+    SendMany(Chan<()>),\n+}\n \n impl TimerWatcher {\n-    pub fn new(loop_: &mut Loop) -> TimerWatcher {\n-        unsafe {\n-            let handle = uvll::malloc_handle(uvll::UV_TIMER);\n-            assert!(handle.is_not_null());\n-            assert!(0 == uvll::uv_timer_init(loop_.native_handle(), handle));\n-            let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n-            watcher.install_watcher_data();\n-            return watcher;\n-        }\n+    pub fn new(loop_: &mut Loop) -> ~TimerWatcher {\n+        let handle = UvHandle::alloc(None::<TimerWatcher>, uvll::UV_TIMER);\n+        assert_eq!(unsafe {\n+            uvll::timer_init(loop_.native_handle(), handle)\n+        }, 0);\n+        let me = ~TimerWatcher {\n+            handle: handle,\n+            action: None,\n+            home: get_handle_to_current_scheduler!(),\n+        };\n+        return me.install();\n     }\n \n-    pub fn start(&mut self, timeout: u64, repeat: u64, cb: TimerCallback) {\n-        {\n-            let data = self.get_watcher_data();\n-            data.timer_cb = Some(cb);\n-        }\n+    fn start(&mut self, msecs: u64, period: u64) {\n+        assert_eq!(unsafe {\n+            uvll::timer_start(self.handle, timer_cb, msecs, period)\n+        }, 0)\n+    }\n+\n+    fn stop(&mut self) {\n+        assert_eq!(unsafe { uvll::timer_stop(self.handle) }, 0)\n+    }\n+}\n+\n+impl HomingIO for TimerWatcher {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl UvHandle<uvll::uv_timer_t> for TimerWatcher {\n+    fn uv_handle(&self) -> *uvll::uv_timer_t { self.handle }\n+}\n \n-        unsafe {\n-            uvll::uv_timer_start(self.native_handle(), timer_cb, timeout, repeat);\n+impl RtioTimer for TimerWatcher {\n+    fn sleep(&mut self, msecs: u64) {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n+            do scheduler.deschedule_running_task_and_then |_sched, task| {\n+                self_.action = Some(WakeTask(task));\n+                self_.start(msecs, 0);\n+            }\n+            self_.stop();\n         }\n+    }\n+\n+    fn oneshot(&mut self, msecs: u64) -> PortOne<()> {\n+        let (port, chan) = oneshot();\n+        let chan = Cell::new(chan);\n \n-        extern fn timer_cb(handle: *uvll::uv_timer_t, status: c_int) {\n-            let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n-            let data = watcher.get_watcher_data();\n-            let cb = data.timer_cb.get_ref();\n-            let status = status_to_maybe_uv_error(status);\n-            (*cb)(watcher, status);\n+        do self.home_for_io |self_| {\n+            self_.action = Some(SendOnce(chan.take()));\n+            self_.start(msecs, 0);\n         }\n+\n+        return port;\n     }\n \n-    pub fn stop(&mut self) {\n-        unsafe {\n-            uvll::uv_timer_stop(self.native_handle());\n+    fn period(&mut self, msecs: u64) -> Port<()> {\n+        let (port, chan) = stream();\n+        let chan = Cell::new(chan);\n+\n+        do self.home_for_io |self_| {\n+            self_.action = Some(SendMany(chan.take()));\n+            self_.start(msecs, msecs);\n         }\n+\n+        return port;\n     }\n }\n \n-impl NativeHandle<*uvll::uv_timer_t> for TimerWatcher {\n-    fn from_native_handle(handle: *uvll::uv_timer_t) -> TimerWatcher {\n-        TimerWatcher(handle)\n+extern fn timer_cb(handle: *uvll::uv_timer_t, _status: c_int) {\n+    let handle = handle as *uvll::uv_handle_t;\n+    let foo: &mut TimerWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n+\n+    match foo.action.take_unwrap() {\n+        WakeTask(task) => {\n+            let sched: ~Scheduler = Local::take();\n+            sched.resume_blocked_task_immediately(task);\n+        }\n+        SendOnce(chan) => chan.send(()),\n+        SendMany(chan) => {\n+            chan.send(());\n+            foo.action = Some(SendMany(chan));\n+        }\n     }\n-    fn native_handle(&self) -> *uvll::uv_idle_t {\n-        match self { &TimerWatcher(ptr) => ptr }\n+}\n+\n+impl Drop for TimerWatcher {\n+    fn drop(&mut self) {\n+        do self.home_for_io |self_| {\n+            self_.action = None;\n+            self_.stop();\n+            self_.close_async_();\n+        }\n     }\n }\n "}, {"sha": "5e67e79c020f6ab40e2236321a9d8a8337d68bde", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 4, "deletions": 87, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/24b42234185427c5141b03103d8ce640538ba500/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24b42234185427c5141b03103d8ce640538ba500/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=24b42234185427c5141b03103d8ce640538ba500", "patch": "@@ -12,8 +12,8 @@ use std::c_str::CString;\n use std::cast::transmute;\n use std::cast;\n use std::cell::Cell;\n-use std::comm::{SendDeferred, SharedChan, Port, PortOne, GenericChan};\n-use std::libc;\n+use std::clone::Clone;\n+use std::comm::{SendDeferred, SharedChan, GenericChan};\n use std::libc::{c_int, c_uint, c_void, pid_t};\n use std::ptr;\n use std::str;\n@@ -49,7 +49,7 @@ use addrinfo::{GetAddrInfoRequest, accum_addrinfo};\n \n // XXX we should not be calling uvll functions in here.\n \n-trait HomingIO {\n+pub trait HomingIO {\n \n     fn home<'r>(&'r mut self) -> &'r mut SchedHandle;\n \n@@ -135,11 +135,6 @@ impl Drop for HomingMissile {\n     }\n }\n \n-// get a handle for the current scheduler\n-macro_rules! get_handle_to_current_scheduler(\n-    () => (do Local::borrow |sched: &mut Scheduler| { sched.make_handle() })\n-)\n-\n enum SocketNameKind {\n     TcpPeer,\n     Tcp,\n@@ -581,9 +576,7 @@ impl IoFactory for UvIoFactory {\n     }\n \n     fn timer_init(&mut self) -> Result<~RtioTimer, IoError> {\n-        let watcher = TimerWatcher::new(self.uv_loop());\n-        let home = get_handle_to_current_scheduler!();\n-        Ok(~UvTimer::new(watcher, home) as ~RtioTimer)\n+        Ok(TimerWatcher::new(self.uv_loop()) as ~RtioTimer)\n     }\n \n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n@@ -1365,82 +1358,6 @@ impl RtioUdpSocket for UvUdpSocket {\n     }\n }\n \n-pub struct UvTimer {\n-    priv watcher: timer::TimerWatcher,\n-    priv home: SchedHandle,\n-}\n-\n-impl HomingIO for UvTimer {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n-}\n-\n-impl UvTimer {\n-    fn new(w: timer::TimerWatcher, home: SchedHandle) -> UvTimer {\n-        UvTimer { watcher: w, home: home }\n-    }\n-}\n-\n-impl Drop for UvTimer {\n-    fn drop(&mut self) {\n-        let (_m, scheduler) = self.fire_homing_missile_sched();\n-        uvdebug!(\"closing UvTimer\");\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            do self.watcher.close {\n-                let scheduler: ~Scheduler = Local::take();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n-            }\n-        }\n-    }\n-}\n-\n-impl RtioTimer for UvTimer {\n-    fn sleep(&mut self, msecs: u64) {\n-        let (_m, scheduler) = self.fire_homing_missile_sched();\n-        do scheduler.deschedule_running_task_and_then |_sched, task| {\n-            uvdebug!(\"sleep: entered scheduler context\");\n-            let task_cell = Cell::new(task);\n-            do self.watcher.start(msecs, 0) |_, status| {\n-                assert!(status.is_none());\n-                let scheduler: ~Scheduler = Local::take();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n-            }\n-        }\n-        self.watcher.stop();\n-    }\n-\n-    fn oneshot(&mut self, msecs: u64) -> PortOne<()> {\n-        use std::comm::oneshot;\n-\n-        let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n-        let _m = self.fire_homing_missile();\n-        do self.watcher.start(msecs, 0) |_, status| {\n-            assert!(status.is_none());\n-            assert!(!chan.is_empty());\n-            chan.take().send_deferred(());\n-        }\n-\n-        return port;\n-    }\n-\n-    fn period(&mut self, msecs: u64) -> Port<()> {\n-        use std::comm::stream;\n-\n-        let (port, chan) = stream();\n-        let chan = Cell::new(chan);\n-        let _m = self.fire_homing_missile();\n-        do self.watcher.start(msecs, msecs) |_, status| {\n-            assert!(status.is_none());\n-            do chan.with_ref |chan| {\n-                chan.send_deferred(());\n-            }\n-        }\n-\n-        return port;\n-    }\n-}\n-\n pub struct UvFileStream {\n     priv loop_: Loop,\n     priv fd: c_int,"}, {"sha": "3028546972fe625a7f84c56fd84d9ea07501cad1", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24b42234185427c5141b03103d8ce640538ba500/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24b42234185427c5141b03103d8ce640538ba500/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=24b42234185427c5141b03103d8ce640538ba500", "patch": "@@ -80,6 +80,11 @@ pub static STDIO_INHERIT_STREAM: c_int = 0x04;\n pub static STDIO_READABLE_PIPE: c_int = 0x10;\n pub static STDIO_WRITABLE_PIPE: c_int = 0x20;\n \n+#[cfg(unix)]\n+pub type uv_buf_len_t = libc::size_t;\n+#[cfg(windows)]\n+pub type uv_buf_len_t = u32;\n+\n // see libuv/include/uv-unix.h\n #[cfg(unix)]\n pub struct uv_buf_t {"}, {"sha": "2745c6062e6e4b688da0703da95d2c4f2777f010", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24b42234185427c5141b03103d8ce640538ba500/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/24b42234185427c5141b03103d8ce640538ba500/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=24b42234185427c5141b03103d8ce640538ba500", "patch": "@@ -135,11 +135,6 @@ rust_uv_get_stream_handle_from_write_req(uv_write_t* write_req) {\n     return write_req->handle;\n }\n \n-extern \"C\" void\n-rust_uv_buf_init(uv_buf_t* out_buf, char* base, size_t len) {\n-    *out_buf = uv_buf_init(base, len);\n-}\n-\n extern \"C\" uv_loop_t*\n rust_uv_get_loop_for_uv_handle(uv_handle_t* handle) {\n     return handle->loop;"}]}