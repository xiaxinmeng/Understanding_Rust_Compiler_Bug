{"sha": "793db8fa046d2e6abf1482f0d031bea7cd40ca80", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5M2RiOGZhMDQ2ZDJlNmFiZjE0ODJmMGQwMzFiZWE3Y2Q0MGNhODA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-07-08T07:44:20Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-07-08T09:16:59Z"}, "message": "Rollup merge of #34691 - jseyfried:remove_erroneous_unit_struct_checks, r=nrc\n\nparser: Remove outdated checks for empty braced struct expressions (`S {}`)\n\nThis is a pure refactoring.\nr? @nrc", "tree": {"sha": "5e7a3f955051268d3f87262146dd5c55ed90008c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e7a3f955051268d3f87262146dd5c55ed90008c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/793db8fa046d2e6abf1482f0d031bea7cd40ca80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/793db8fa046d2e6abf1482f0d031bea7cd40ca80", "html_url": "https://github.com/rust-lang/rust/commit/793db8fa046d2e6abf1482f0d031bea7cd40ca80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/793db8fa046d2e6abf1482f0d031bea7cd40ca80/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ee6a666e42b65a0b77e463a0e5e5b550759fc5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ee6a666e42b65a0b77e463a0e5e5b550759fc5f", "html_url": "https://github.com/rust-lang/rust/commit/4ee6a666e42b65a0b77e463a0e5e5b550759fc5f"}, {"sha": "5e31617621a69c787aca12239a5b2ff4e6947f74", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e31617621a69c787aca12239a5b2ff4e6947f74", "html_url": "https://github.com/rust-lang/rust/commit/5e31617621a69c787aca12239a5b2ff4e6947f74"}], "stats": {"total": 83, "additions": 11, "deletions": 72}, "files": [{"sha": "e4875b7c244fd9cb8f641fee92312b9954a0dc07", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 72, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/793db8fa046d2e6abf1482f0d031bea7cd40ca80/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/793db8fa046d2e6abf1482f0d031bea7cd40ca80/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=793db8fa046d2e6abf1482f0d031bea7cd40ca80", "patch": "@@ -495,64 +495,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Check for erroneous `ident { }`; if matches, signal error and\n-    /// recover (without consuming any expected input token).  Returns\n-    /// true if and only if input was consumed for recovery.\n-    pub fn check_for_erroneous_unit_struct_expecting(&mut self,\n-                                                     expected: &[token::Token])\n-                                                     -> bool {\n-        if self.token == token::OpenDelim(token::Brace)\n-            && expected.iter().all(|t| *t != token::OpenDelim(token::Brace))\n-            && self.look_ahead(1, |t| *t == token::CloseDelim(token::Brace)) {\n-            // matched; signal non-fatal error and recover.\n-            let span = self.span;\n-            self.span_err(span, \"unit-like struct construction is written with no trailing `{ }`\");\n-            self.eat(&token::OpenDelim(token::Brace));\n-            self.eat(&token::CloseDelim(token::Brace));\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    /// Commit to parsing a complete expression `e` expected to be\n-    /// followed by some token from the set edible + inedible.  Recover\n-    /// from anticipated input errors, discarding erroneous characters.\n-    pub fn commit_expr(&mut self, e: &Expr, edible: &[token::Token],\n-                       inedible: &[token::Token]) -> PResult<'a, ()> {\n-        debug!(\"commit_expr {:?}\", e);\n-        if let ExprKind::Path(..) = e.node {\n-            // might be unit-struct construction; check for recoverableinput error.\n-            let expected = edible.iter()\n-                .cloned()\n-                .chain(inedible.iter().cloned())\n-                .collect::<Vec<_>>();\n-            self.check_for_erroneous_unit_struct_expecting(&expected[..]);\n-        }\n-        self.expect_one_of(edible, inedible)\n-    }\n-\n-    pub fn commit_expr_expecting(&mut self, e: &Expr, edible: token::Token) -> PResult<'a, ()> {\n-        self.commit_expr(e, &[edible], &[])\n-    }\n-\n-    /// Commit to parsing a complete statement `s`, which expects to be\n-    /// followed by some token from the set edible + inedible.  Check\n-    /// for recoverable input errors, discarding erroneous characters.\n-    pub fn commit_stmt(&mut self, edible: &[token::Token],\n-                       inedible: &[token::Token]) -> PResult<'a, ()> {\n-        if self.last_token\n-               .as_ref()\n-               .map_or(false, |t| t.is_ident() || t.is_path()) {\n-            let expected = edible.iter()\n-                .cloned()\n-                .chain(inedible.iter().cloned())\n-                .collect::<Vec<_>>();\n-            self.check_for_erroneous_unit_struct_expecting(&expected);\n-        }\n-        self.expect_one_of(edible, inedible)\n-    }\n-\n     /// returns the span of expr, if it was not interpolated or the span of the interpolated token\n     fn interpolated_or_expr_span(&self,\n                                  expr: PResult<'a, P<Expr>>)\n@@ -1247,7 +1189,7 @@ impl<'a> Parser<'a> {\n             let default = if self.check(&token::Eq) {\n                 self.bump();\n                 let expr = self.parse_expr()?;\n-                self.commit_expr_expecting(&expr, token::Semi)?;\n+                self.expect(&token::Semi)?;\n                 Some(expr)\n             } else {\n                 self.expect(&token::Semi)?;\n@@ -2195,8 +2137,7 @@ impl<'a> Parser<'a> {\n                 let mut trailing_comma = false;\n                 while self.token != token::CloseDelim(token::Paren) {\n                     es.push(self.parse_expr()?);\n-                    self.commit_expr(&es.last().unwrap(), &[],\n-                                     &[token::Comma, token::CloseDelim(token::Paren)])?;\n+                    self.expect_one_of(&[], &[token::Comma, token::CloseDelim(token::Paren)])?;\n                     if self.check(&token::Comma) {\n                         trailing_comma = true;\n \n@@ -2407,9 +2348,8 @@ impl<'a> Parser<'a> {\n                                     }\n                                 }\n \n-                                match self.commit_expr(&fields.last().unwrap().expr,\n-                                                       &[token::Comma],\n-                                                       &[token::CloseDelim(token::Brace)]) {\n+                                match self.expect_one_of(&[token::Comma],\n+                                                         &[token::CloseDelim(token::Brace)]) {\n                                     Ok(()) => {}\n                                     Err(mut e) => {\n                                         e.emit();\n@@ -2662,7 +2602,7 @@ impl<'a> Parser<'a> {\n                 self.bump();\n                 let ix = self.parse_expr()?;\n                 hi = self.span.hi;\n-                self.commit_expr_expecting(&ix, token::CloseDelim(token::Bracket))?;\n+                self.expect(&token::CloseDelim(token::Bracket))?;\n                 let index = self.mk_index(e, ix);\n                 e = self.mk_expr(lo, hi, index, ThinVec::new())\n               }\n@@ -3329,8 +3269,7 @@ impl<'a> Parser<'a> {\n         let lo = self.last_span.lo;\n         let discriminant = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL,\n                                                None)?;\n-        if let Err(mut e) = self.commit_expr_expecting(&discriminant,\n-                                                       token::OpenDelim(token::Brace)) {\n+        if let Err(mut e) = self.expect(&token::OpenDelim(token::Brace)) {\n             if self.token == token::Token::Semi {\n                 e.span_note(match_span, \"did you mean to remove this `match` keyword?\");\n             }\n@@ -3376,7 +3315,7 @@ impl<'a> Parser<'a> {\n             && self.token != token::CloseDelim(token::Brace);\n \n         if require_comma {\n-            self.commit_expr(&expr, &[token::Comma], &[token::CloseDelim(token::Brace)])?;\n+            self.expect_one_of(&[token::Comma], &[token::CloseDelim(token::Brace)])?;\n         } else {\n             self.eat(&token::Comma);\n         }\n@@ -4118,7 +4057,7 @@ impl<'a> Parser<'a> {\n                 _ => { // all other kinds of statements:\n                     let mut hi = span.hi;\n                     if classify::stmt_ends_with_semi(&node) {\n-                        self.commit_stmt(&[token::Semi], &[])?;\n+                        self.expect(&token::Semi)?;\n                         hi = self.last_span.hi;\n                     }\n \n@@ -4196,7 +4135,7 @@ impl<'a> Parser<'a> {\n         if classify::expr_requires_semi_to_be_stmt(&e) {\n             // Just check for errors and recover; do not eat semicolon yet.\n             if let Err(mut e) =\n-                self.commit_stmt(&[], &[token::Semi, token::CloseDelim(token::Brace)])\n+                self.expect_one_of(&[], &[token::Semi, token::CloseDelim(token::Brace)])\n             {\n                 e.emit();\n                 self.recover_stmt();\n@@ -4863,7 +4802,7 @@ impl<'a> Parser<'a> {\n             let typ = self.parse_ty_sum()?;\n             self.expect(&token::Eq)?;\n             let expr = self.parse_expr()?;\n-            self.commit_expr_expecting(&expr, token::Semi)?;\n+            self.expect(&token::Semi)?;\n             (name, ast::ImplItemKind::Const(typ, expr))\n         } else {\n             let (name, inner_attrs, node) = self.parse_impl_method(&vis)?;\n@@ -5287,7 +5226,7 @@ impl<'a> Parser<'a> {\n         let ty = self.parse_ty_sum()?;\n         self.expect(&token::Eq)?;\n         let e = self.parse_expr()?;\n-        self.commit_expr_expecting(&e, token::Semi)?;\n+        self.expect(&token::Semi)?;\n         let item = match m {\n             Some(m) => ItemKind::Static(ty, m, e),\n             None => ItemKind::Const(ty, e),"}]}