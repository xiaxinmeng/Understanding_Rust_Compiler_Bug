{"sha": "36c9d5ce17f352b8228f4f973118a3c6b543d4eb", "node_id": "C_kwDOAAsO6NoAKDM2YzlkNWNlMTdmMzUyYjgyMjhmNGY5NzMxMThhM2M2YjU0M2Q0ZWI", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-05-04T12:33:36Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-05-04T12:33:36Z"}, "message": "Fix pattern type mismatch in tuples", "tree": {"sha": "6520542399bee1e1484a2b010d4eb39ff170cd4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6520542399bee1e1484a2b010d4eb39ff170cd4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36c9d5ce17f352b8228f4f973118a3c6b543d4eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36c9d5ce17f352b8228f4f973118a3c6b543d4eb", "html_url": "https://github.com/rust-lang/rust/commit/36c9d5ce17f352b8228f4f973118a3c6b543d4eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9811a3af5fb90834f42f4b35b4f531746af934ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/9811a3af5fb90834f42f4b35b4f531746af934ca", "html_url": "https://github.com/rust-lang/rust/commit/9811a3af5fb90834f42f4b35b4f531746af934ca"}], "stats": {"total": 184, "additions": 139, "deletions": 45}, "files": [{"sha": "125df2ba761d983dd683cdd19827f301970319d6", "filename": "crates/hir-ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=36c9d5ce17f352b8228f4f973118a3c6b543d4eb", "patch": "@@ -148,6 +148,7 @@ impl<'a> PatCtxt<'a> {\n \n             hir_def::hir::Pat::Bind { id, subpat, .. } => {\n                 let bm = self.infer.pat_binding_modes[&pat];\n+                ty = &self.infer[id];\n                 let name = &self.body.bindings[id].name;\n                 match (bm, ty.kind(Interner)) {\n                     (BindingMode::Ref(_), TyKind::Ref(.., rty)) => ty = rty,"}, {"sha": "574803951106728ffb9937aa7aa799a3a37f1a0d", "filename": "crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=36c9d5ce17f352b8228f4f973118a3c6b543d4eb", "patch": "@@ -263,7 +263,7 @@ impl<'a> InferenceContext<'a> {\n                 // Don't emit type mismatches again, the expression lowering already did that.\n                 let ty = self.infer_lit_pat(expr, &expected);\n                 self.write_pat_ty(pat, ty.clone());\n-                return ty;\n+                return self.pat_ty_after_adjustment(pat);\n             }\n             Pat::Box { inner } => match self.resolve_boxed_box() {\n                 Some(box_adt) => {\n@@ -298,8 +298,17 @@ impl<'a> InferenceContext<'a> {\n                 .type_mismatches\n                 .insert(pat.into(), TypeMismatch { expected, actual: ty.clone() });\n         }\n-        self.write_pat_ty(pat, ty.clone());\n-        ty\n+        self.write_pat_ty(pat, ty);\n+        self.pat_ty_after_adjustment(pat)\n+    }\n+\n+    fn pat_ty_after_adjustment(&self, pat: PatId) -> Ty {\n+        self.result\n+            .pat_adjustments\n+            .get(&pat)\n+            .and_then(|x| x.first())\n+            .unwrap_or(&self.result.type_of_pat[pat])\n+            .clone()\n     }\n \n     fn infer_ref_pat(\n@@ -345,7 +354,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             BindingMode::Move => inner_ty.clone(),\n         };\n-        self.write_pat_ty(pat, bound_ty.clone());\n+        self.write_pat_ty(pat, inner_ty.clone());\n         self.write_binding_ty(binding, bound_ty);\n         return inner_ty;\n     }\n@@ -422,14 +431,6 @@ fn is_non_ref_pat(body: &hir_def::body::Body, pat: PatId) -> bool {\n         Pat::Lit(expr) => {\n             !matches!(body[*expr], Expr::Literal(Literal::String(..) | Literal::ByteString(..)))\n         }\n-        Pat::Bind { id, subpat: Some(subpat), .. }\n-            if matches!(\n-                body.bindings[*id].mode,\n-                BindingAnnotation::Mutable | BindingAnnotation::Unannotated\n-            ) =>\n-        {\n-            is_non_ref_pat(body, *subpat)\n-        }\n         Pat::Wild | Pat::Bind { .. } | Pat::Ref { .. } | Pat::Box { .. } | Pat::Missing => false,\n     }\n }"}, {"sha": "2db04024b7b64bac2040def40eea65c542c3b8c2", "filename": "crates/hir-ty/src/tests.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests.rs?ref=36c9d5ce17f352b8228f4f973118a3c6b543d4eb", "patch": "@@ -17,7 +17,7 @@ use expect_test::Expect;\n use hir_def::{\n     body::{Body, BodySourceMap, SyntheticSyntax},\n     db::{DefDatabase, InternDatabase},\n-    hir::{ExprId, PatId},\n+    hir::{ExprId, Pat, PatId},\n     item_scope::ItemScope,\n     nameres::DefMap,\n     src::HasSource,\n@@ -149,10 +149,13 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n     });\n     let mut unexpected_type_mismatches = String::new();\n     for def in defs {\n-        let (_body, body_source_map) = db.body_with_source_map(def);\n+        let (body, body_source_map) = db.body_with_source_map(def);\n         let inference_result = db.infer(def);\n \n-        for (pat, ty) in inference_result.type_of_pat.iter() {\n+        for (pat, mut ty) in inference_result.type_of_pat.iter() {\n+            if let Pat::Bind { id, .. } = body.pats[pat] {\n+                ty = &inference_result.type_of_binding[id];\n+            }\n             let node = match pat_node(&body_source_map, pat, &db) {\n                 Some(value) => value,\n                 None => continue,\n@@ -284,11 +287,15 @@ fn infer_with_mismatches(content: &str, include_mismatches: bool) -> String {\n     let mut buf = String::new();\n \n     let mut infer_def = |inference_result: Arc<InferenceResult>,\n+                         body: Arc<Body>,\n                          body_source_map: Arc<BodySourceMap>| {\n         let mut types: Vec<(InFile<SyntaxNode>, &Ty)> = Vec::new();\n         let mut mismatches: Vec<(InFile<SyntaxNode>, &TypeMismatch)> = Vec::new();\n \n-        for (pat, ty) in inference_result.type_of_pat.iter() {\n+        for (pat, mut ty) in inference_result.type_of_pat.iter() {\n+            if let Pat::Bind { id, .. } = body.pats[pat] {\n+                ty = &inference_result.type_of_binding[id];\n+            }\n             let syntax_ptr = match body_source_map.pat_syntax(pat) {\n                 Ok(sp) => {\n                     let root = db.parse_or_expand(sp.file_id);\n@@ -386,9 +393,9 @@ fn infer_with_mismatches(content: &str, include_mismatches: bool) -> String {\n         }\n     });\n     for def in defs {\n-        let (_body, source_map) = db.body_with_source_map(def);\n+        let (body, source_map) = db.body_with_source_map(def);\n         let infer = db.infer(def);\n-        infer_def(infer, source_map);\n+        infer_def(infer, body, source_map);\n     }\n \n     buf.truncate(buf.trim_end().len());"}, {"sha": "72e98138a349e87b0882ab1efd75276c4ec6bbeb", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=36c9d5ce17f352b8228f4f973118a3c6b543d4eb", "patch": "@@ -2033,6 +2033,56 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn tuple_pattern_nested_match_ergonomics() {\n+    check_no_mismatches(\n+        r#\"\n+fn f(x: (&i32, &i32)) -> i32 {\n+    match x {\n+        (3, 4) => 5,\n+        _ => 12,\n+    }\n+}\n+        \"#,\n+    );\n+    check_types(\n+        r#\"\n+fn f(x: (&&&&i32, &&&i32)) {\n+    let f = match x {\n+        t @ (3, 4) => t,\n+        _ => loop {},\n+    };\n+    f;\n+  //^ (&&&&i32, &&&i32)\n+}\n+        \"#,\n+    );\n+    check_types(\n+        r#\"\n+fn f() {\n+    let x = &&&(&&&2, &&&&&3);\n+    let (y, z) = x;\n+       //^ &&&&i32\n+    let t @ (y, z) = x;\n+    t;\n+  //^ &&&(&&&i32, &&&&&i32)\n+}\n+        \"#,\n+    );\n+    check_types(\n+        r#\"\n+fn f() {\n+    let x = &&&(&&&2, &&&&&3);\n+    let (y, z) = x;\n+       //^ &&&&i32\n+    let t @ (y, z) = x;\n+    t;\n+  //^ &&&(&&&i32, &&&&&i32)\n+}\n+        \"#,\n+    );\n+}\n+\n #[test]\n fn fn_pointer_return() {\n     check_infer("}, {"sha": "b3a8a33cac9e17f34f68027fd4ed1c74538923b3", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=36c9d5ce17f352b8228f4f973118a3c6b543d4eb", "patch": "@@ -1535,9 +1535,6 @@ impl DefWithBody {\n         for (pat_or_expr, mismatch) in infer.type_mismatches() {\n             let expr_or_pat = match pat_or_expr {\n                 ExprOrPatId::ExprId(expr) => source_map.expr_syntax(expr).map(Either::Left),\n-                // FIXME: Re-enable these once we have less false positives\n-                ExprOrPatId::PatId(_pat) => continue,\n-                #[allow(unreachable_patterns)]\n                 ExprOrPatId::PatId(pat) => source_map.pat_syntax(pat).map(Either::Right),\n             };\n             let expr_or_pat = match expr_or_pat {"}, {"sha": "81ea99522f759ac8cc2e13381d923eca96d3c735", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=36c9d5ce17f352b8228f4f973118a3c6b543d4eb", "patch": "@@ -350,6 +350,13 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.type_of_pat(pat)\n     }\n \n+    /// It also includes the changes that binding mode makes in the type. For example in\n+    /// `let ref x @ Some(_) = None` the result of `type_of_pat` is `Option<T>` but the result\n+    /// of this function is `&mut Option<T>`\n+    pub fn type_of_binding_in_pat(&self, pat: &ast::IdentPat) -> Option<Type> {\n+        self.imp.type_of_binding_in_pat(pat)\n+    }\n+\n     pub fn type_of_self(&self, param: &ast::SelfParam) -> Option<Type> {\n         self.imp.type_of_self(param)\n     }\n@@ -1138,6 +1145,10 @@ impl<'db> SemanticsImpl<'db> {\n             .map(|(ty, coerced)| TypeInfo { original: ty, adjusted: coerced })\n     }\n \n+    fn type_of_binding_in_pat(&self, pat: &ast::IdentPat) -> Option<Type> {\n+        self.analyze(pat.syntax())?.type_of_binding_in_pat(self.db, pat)\n+    }\n+\n     fn type_of_self(&self, param: &ast::SelfParam) -> Option<Type> {\n         self.analyze(param.syntax())?.type_of_self(self.db, param)\n     }"}, {"sha": "159601955f83654b1febae3b23908bbac4976444", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=36c9d5ce17f352b8228f4f973118a3c6b543d4eb", "patch": "@@ -13,7 +13,7 @@ use hir_def::{\n         scope::{ExprScopes, ScopeId},\n         Body, BodySourceMap,\n     },\n-    hir::{ExprId, Pat, PatId},\n+    hir::{BindingId, ExprId, Pat, PatId},\n     lang_item::LangItem,\n     lower::LowerCtx,\n     macro_id_to_def_id,\n@@ -133,6 +133,15 @@ impl SourceAnalyzer {\n         self.body_source_map()?.node_pat(src)\n     }\n \n+    fn binding_id_of_pat(&self, pat: &ast::IdentPat) -> Option<BindingId> {\n+        let pat_id = self.pat_id(&pat.clone().into())?;\n+        if let Pat::Bind { id, .. } = self.body()?.pats[pat_id] {\n+            Some(id)\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn expand_expr(\n         &self,\n         db: &dyn HirDatabase,\n@@ -198,6 +207,18 @@ impl SourceAnalyzer {\n         Some((mk_ty(ty), coerced.map(mk_ty)))\n     }\n \n+    pub(crate) fn type_of_binding_in_pat(\n+        &self,\n+        db: &dyn HirDatabase,\n+        pat: &ast::IdentPat,\n+    ) -> Option<Type> {\n+        let binding_id = self.binding_id_of_pat(pat)?;\n+        let infer = self.infer.as_ref()?;\n+        let ty = infer[binding_id].clone();\n+        let mk_ty = |ty| Type::new_with_resolver(db, &self.resolver, ty);\n+        Some(mk_ty(ty))\n+    }\n+\n     pub(crate) fn type_of_self(\n         &self,\n         db: &dyn HirDatabase,"}, {"sha": "ea71d165e6aa68c65a88ab0c2e066de5998be6d2", "filename": "crates/ide-assists/src/handlers/destructure_tuple_binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs?ref=36c9d5ce17f352b8228f4f973118a3c6b543d4eb", "patch": "@@ -91,7 +91,7 @@ fn collect_data(ident_pat: IdentPat, ctx: &AssistContext<'_>) -> Option<TupleDat\n         return None;\n     }\n \n-    let ty = ctx.sema.type_of_pat(&ident_pat.clone().into())?.adjusted();\n+    let ty = ctx.sema.type_of_binding_in_pat(&ident_pat)?;\n     let ref_type = if ty.is_mutable_reference() {\n         Some(RefType::Mutable)\n     } else if ty.is_reference() {"}, {"sha": "aae9f20d4ea5c3f5c008b74b11e9ffeec7d68d21", "filename": "crates/ide-assists/src/handlers/merge_match_arms.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs?ref=36c9d5ce17f352b8228f4f973118a3c6b543d4eb", "patch": "@@ -1,4 +1,4 @@\n-use hir::TypeInfo;\n+use hir::Type;\n use std::{collections::HashMap, iter::successors};\n use syntax::{\n     algo::neighbor,\n@@ -95,15 +95,15 @@ fn contains_placeholder(a: &ast::MatchArm) -> bool {\n }\n \n fn are_same_types(\n-    current_arm_types: &HashMap<String, Option<TypeInfo>>,\n+    current_arm_types: &HashMap<String, Option<Type>>,\n     arm: &ast::MatchArm,\n     ctx: &AssistContext<'_>,\n ) -> bool {\n     let arm_types = get_arm_types(ctx, arm);\n     for (other_arm_type_name, other_arm_type) in arm_types {\n         match (current_arm_types.get(&other_arm_type_name), other_arm_type) {\n             (Some(Some(current_arm_type)), Some(other_arm_type))\n-                if other_arm_type.original == current_arm_type.original => {}\n+                if other_arm_type == *current_arm_type => {}\n             _ => return false,\n         }\n     }\n@@ -114,44 +114,44 @@ fn are_same_types(\n fn get_arm_types(\n     context: &AssistContext<'_>,\n     arm: &ast::MatchArm,\n-) -> HashMap<String, Option<TypeInfo>> {\n-    let mut mapping: HashMap<String, Option<TypeInfo>> = HashMap::new();\n+) -> HashMap<String, Option<Type>> {\n+    let mut mapping: HashMap<String, Option<Type>> = HashMap::new();\n \n     fn recurse(\n-        map: &mut HashMap<String, Option<TypeInfo>>,\n+        map: &mut HashMap<String, Option<Type>>,\n         ctx: &AssistContext<'_>,\n         pat: &Option<ast::Pat>,\n     ) {\n         if let Some(local_pat) = pat {\n-            match pat {\n-                Some(ast::Pat::TupleStructPat(tuple)) => {\n+            match local_pat {\n+                ast::Pat::TupleStructPat(tuple) => {\n                     for field in tuple.fields() {\n                         recurse(map, ctx, &Some(field));\n                     }\n                 }\n-                Some(ast::Pat::TuplePat(tuple)) => {\n+                ast::Pat::TuplePat(tuple) => {\n                     for field in tuple.fields() {\n                         recurse(map, ctx, &Some(field));\n                     }\n                 }\n-                Some(ast::Pat::RecordPat(record)) => {\n+                ast::Pat::RecordPat(record) => {\n                     if let Some(field_list) = record.record_pat_field_list() {\n                         for field in field_list.fields() {\n                             recurse(map, ctx, &field.pat());\n                         }\n                     }\n                 }\n-                Some(ast::Pat::ParenPat(parentheses)) => {\n+                ast::Pat::ParenPat(parentheses) => {\n                     recurse(map, ctx, &parentheses.pat());\n                 }\n-                Some(ast::Pat::SlicePat(slice)) => {\n+                ast::Pat::SlicePat(slice) => {\n                     for slice_pat in slice.pats() {\n                         recurse(map, ctx, &Some(slice_pat));\n                     }\n                 }\n-                Some(ast::Pat::IdentPat(ident_pat)) => {\n+                ast::Pat::IdentPat(ident_pat) => {\n                     if let Some(name) = ident_pat.name() {\n-                        let pat_type = ctx.sema.type_of_pat(local_pat);\n+                        let pat_type = ctx.sema.type_of_binding_in_pat(ident_pat);\n                         map.insert(name.text().to_string(), pat_type);\n                     }\n                 }"}, {"sha": "b5e619e2a039cfe116791947845e5e76264c5197", "filename": "crates/ide-diagnostics/src/handlers/missing_match_arms.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs?ref=36c9d5ce17f352b8228f4f973118a3c6b543d4eb", "patch": "@@ -271,15 +271,20 @@ enum Either2 { C, D }\n fn main() {\n     match Either::A {\n         Either2::C => (),\n+      //^^^^^^^^^^ error: expected Either, found Either2\n         Either2::D => (),\n+      //^^^^^^^^^^ error: expected Either, found Either2\n     }\n     match (true, false) {\n         (true, false, true) => (),\n+      //^^^^^^^^^^^^^^^^^^^ error: expected (bool, bool), found (bool, bool, bool)\n         (true) => (),\n       // ^^^^  error: expected (bool, bool), found bool\n     }\n     match (true, false) { (true,) => {} }\n+                        //^^^^^^^ error: expected (bool, bool), found (bool,)\n     match (0) { () => () }\n+              //^^ error: expected i32, found ()\n     match Unresolved::Bar { Unresolved::Baz => () }\n }\n         \"#,\n@@ -293,7 +298,9 @@ fn main() {\n             r#\"\n fn main() {\n     match false { true | () => {} }\n+                       //^^ error: expected bool, found ()\n     match (false,) { (true | (),) => {} }\n+                           //^^ error: expected bool, found ()\n }\n \"#,\n         );\n@@ -738,17 +745,13 @@ fn main() {\n \n     #[test]\n     fn binding_ref_has_correct_type() {\n-        cov_mark::check_count!(validate_match_bailed_out, 1);\n-\n         // Asserts `PatKind::Binding(ref _x): bool`, not &bool.\n         // If that's not true match checking will panic with \"incompatible constructors\"\n         // FIXME: make facilities to test this directly like `tests::check_infer(..)`\n-        check_diagnostics(\n+        check_diagnostics_no_bails(\n             r#\"\n enum Foo { A }\n fn main() {\n-    // FIXME: this should not bail out but current behavior is such as the old algorithm.\n-    // ExprValidator::validate_match(..) checks types of top level patterns incorrectly.\n     match Foo::A {\n         ref _x => {}\n         Foo::A => {}\n@@ -1035,11 +1038,12 @@ fn main() {\n \n         #[test]\n         fn reference_patterns_in_fields() {\n-            cov_mark::check_count!(validate_match_bailed_out, 2);\n+            cov_mark::check_count!(validate_match_bailed_out, 1);\n             check_diagnostics(\n                 r#\"\n fn main() {\n     match (&false,) {\n+        //^^^^^^^^^ error: missing match arm: `(&false,)` not covered\n         (true,) => {}\n     }\n     match (&false,) {"}, {"sha": "fee160c3e7f78247920b0aff8593f4301d454dde", "filename": "crates/ide-diagnostics/src/handlers/type_mismatch.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs?ref=36c9d5ce17f352b8228f4f973118a3c6b543d4eb", "patch": "@@ -650,8 +650,11 @@ fn h() {\n             r#\"\n fn f() {\n     let &() = &mut ();\n+      //^^^ error: expected &mut (), found &()\n     match &() {\n+        // FIXME: we should only show the deep one.\n         &9 => ()\n+      //^^ error: expected &(), found &i32\n        //^ error: expected (), found i32\n     }\n }"}, {"sha": "6991a66c7c211c8b3a2123e26785f254aaa6ec23", "filename": "crates/ide/src/inlay_hints/bind_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs?ref=36c9d5ce17f352b8228f4f973118a3c6b543d4eb", "patch": "@@ -30,7 +30,7 @@ pub(super) fn hints(\n \n     let descended = sema.descend_node_into_attributes(pat.clone()).pop();\n     let desc_pat = descended.as_ref().unwrap_or(pat);\n-    let ty = sema.type_of_pat(&desc_pat.clone().into())?.original;\n+    let ty = sema.type_of_binding_in_pat(desc_pat)?;\n \n     if should_not_display_type_hint(sema, config, pat, &ty) {\n         return None;"}, {"sha": "dada4dd0485378811c79c4c356d94e10f966d04b", "filename": "crates/ide/src/inlay_hints/binding_mode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fide%2Fsrc%2Finlay_hints%2Fbinding_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c9d5ce17f352b8228f4f973118a3c6b543d4eb/crates%2Fide%2Fsrc%2Finlay_hints%2Fbinding_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fbinding_mode.rs?ref=36c9d5ce17f352b8228f4f973118a3c6b543d4eb", "patch": "@@ -148,7 +148,6 @@ struct Struct {\n     field: &'static str,\n }\n fn foo(s @ Struct { field, .. }: &Struct) {}\n-     //^^^^^^^^^^^^^^^^^^^^^^^^ref\n          //^^^^^^^^^^^^^^^^^^^^&\n                   //^^^^^ref\n \"#,"}]}