{"sha": "a3e087cefacb1b92476543fe7d6ef68f0ca82dd8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZTA4N2NlZmFjYjFiOTI0NzY1NDNmZTdkNmVmNjhmMGNhODJkZDg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-01-22T03:16:01Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-01-24T01:35:34Z"}, "message": "core: Remove private::chan_from_global_ptr. #3915", "tree": {"sha": "b96921cefa429e1f59881fff78c0c6550e5a4755", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b96921cefa429e1f59881fff78c0c6550e5a4755"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3e087cefacb1b92476543fe7d6ef68f0ca82dd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3e087cefacb1b92476543fe7d6ef68f0ca82dd8", "html_url": "https://github.com/rust-lang/rust/commit/a3e087cefacb1b92476543fe7d6ef68f0ca82dd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3e087cefacb1b92476543fe7d6ef68f0ca82dd8/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9608fe4232c4014daa540849d471b1791b41fa6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9608fe4232c4014daa540849d471b1791b41fa6", "html_url": "https://github.com/rust-lang/rust/commit/b9608fe4232c4014daa540849d471b1791b41fa6"}], "stats": {"total": 156, "additions": 2, "deletions": 154}, "files": [{"sha": "c3068d6f61b0d462065d2ef6691b6c5c5b0dd0d6", "filename": "src/libcore/private.rs", "status": "modified", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/a3e087cefacb1b92476543fe7d6ef68f0ca82dd8/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3e087cefacb1b92476543fe7d6ef68f0ca82dd8/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=a3e087cefacb1b92476543fe7d6ef68f0ca82dd8", "patch": "@@ -95,163 +95,11 @@ fn test_run_in_bare_thread() unsafe {\n #[allow(non_camel_case_types)] // runtime type\n type rust_port_id = uint;\n \n-type GlobalPtr = *libc::uintptr_t;\n-\n fn compare_and_swap(address: &mut int, oldval: int, newval: int) -> bool {\n     let old = rusti::atomic_cxchg(address, oldval, newval);\n     old == oldval\n }\n \n-/**\n- * Atomically gets a channel from a pointer to a pointer-sized memory location\n- * or, if no channel exists creates and installs a new channel and sets up a\n- * new task to receive from it.\n- */\n-pub unsafe fn chan_from_global_ptr<T: Owned>(\n-    global: GlobalPtr,\n-    task_fn: fn() -> task::TaskBuilder,\n-    f: fn~(oldcomm::Port<T>)\n-) -> oldcomm::Chan<T> {\n-\n-    enum Msg {\n-        Proceed,\n-        Abort\n-    }\n-\n-    log(debug,~\"ENTERING chan_from_global_ptr, before is_prob_zero check\");\n-    let is_probably_zero = *global == 0u;\n-    log(debug,~\"after is_prob_zero check\");\n-    if is_probably_zero {\n-        log(debug,~\"is probably zero...\");\n-        // There's no global channel. We must make it\n-\n-        let (setup1_po, setup1_ch) = pipes::stream();\n-        let (setup2_po, setup2_ch) = pipes::stream();\n-\n-        // FIXME #4422: Ugly type inference hint\n-        let setup2_po: pipes::Port<Msg> = setup2_po;\n-\n-        do task_fn().spawn |move f, move setup1_ch, move setup2_po| {\n-            let po = oldcomm::Port::<T>();\n-            let ch = oldcomm::Chan(&po);\n-            setup1_ch.send(ch);\n-\n-            // Wait to hear if we are the official instance of\n-            // this global task\n-            match setup2_po.recv() {\n-              Proceed => f(move po),\n-              Abort => ()\n-            }\n-        };\n-\n-        log(debug,~\"before setup recv..\");\n-        // This is the proposed global channel\n-        let ch = setup1_po.recv();\n-        // 0 is our sentinal value. It is not a valid channel\n-        assert *ch != 0;\n-\n-        // Install the channel\n-        log(debug,~\"BEFORE COMPARE AND SWAP\");\n-        let swapped = compare_and_swap(\n-            cast::reinterpret_cast(&global),\n-            0, cast::reinterpret_cast(&ch));\n-        log(debug,fmt!(\"AFTER .. swapped? %?\", swapped));\n-\n-        if swapped {\n-            // Success!\n-            setup2_ch.send(Proceed);\n-            ch\n-        } else {\n-            // Somebody else got in before we did\n-            setup2_ch.send(Abort);\n-            cast::reinterpret_cast(&*global)\n-        }\n-    } else {\n-        log(debug, ~\"global != 0\");\n-        cast::reinterpret_cast(&*global)\n-    }\n-}\n-\n-#[test]\n-pub fn test_from_global_chan1() {\n-\n-    // This is unreadable, right?\n-\n-    // The global channel\n-    let globchan = 0;\n-    let globchanp = ptr::addr_of(&globchan);\n-\n-    // Create the global channel, attached to a new task\n-    let ch = unsafe {\n-        do chan_from_global_ptr(globchanp, task::task) |po| {\n-            let ch = oldcomm::recv(po);\n-            oldcomm::send(ch, true);\n-            let ch = oldcomm::recv(po);\n-            oldcomm::send(ch, true);\n-        }\n-    };\n-    // Talk to it\n-    let po = oldcomm::Port();\n-    oldcomm::send(ch, oldcomm::Chan(&po));\n-    assert oldcomm::recv(po) == true;\n-\n-    // This one just reuses the previous channel\n-    let ch = unsafe {\n-        do chan_from_global_ptr(globchanp, task::task) |po| {\n-            let ch = oldcomm::recv(po);\n-            oldcomm::send(ch, false);\n-        }\n-    };\n-\n-    // Talk to the original global task\n-    let po = oldcomm::Port();\n-    oldcomm::send(ch, oldcomm::Chan(&po));\n-    assert oldcomm::recv(po) == true;\n-}\n-\n-#[test]\n-pub fn test_from_global_chan2() {\n-\n-    for iter::repeat(100) {\n-        // The global channel\n-        let globchan = 0;\n-        let globchanp = ptr::addr_of(&globchan);\n-\n-        let resultpo = oldcomm::Port();\n-        let resultch = oldcomm::Chan(&resultpo);\n-\n-        // Spawn a bunch of tasks that all want to compete to\n-        // create the global channel\n-        for uint::range(0, 10) |i| {\n-            do task::spawn {\n-                let ch = unsafe {\n-                    do chan_from_global_ptr(\n-                        globchanp, task::task) |po| {\n-\n-                        for uint::range(0, 10) |_j| {\n-                            let ch = oldcomm::recv(po);\n-                            oldcomm::send(ch, {i});\n-                        }\n-                    }\n-                };\n-                let po = oldcomm::Port();\n-                oldcomm::send(ch, oldcomm::Chan(&po));\n-                // We are The winner if our version of the\n-                // task was installed\n-                let winner = oldcomm::recv(po);\n-                oldcomm::send(resultch, winner == i);\n-            }\n-        }\n-        // There should be only one winner\n-        let mut winners = 0u;\n-        for uint::range(0u, 10u) |_i| {\n-            let res = oldcomm::recv(resultpo);\n-            if res { winners += 1u };\n-        }\n-        assert winners == 1u;\n-    }\n-}\n-\n /**\n  * Convert the current task to a 'weak' task temporarily\n  *"}, {"sha": "c99bcaa54fac64892389df380babf8c170fee472", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3e087cefacb1b92476543fe7d6ef68f0ca82dd8/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3e087cefacb1b92476543fe7d6ef68f0ca82dd8/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=a3e087cefacb1b92476543fe7d6ef68f0ca82dd8", "patch": "@@ -75,10 +75,10 @@ fn get_monitor_task_gl() -> IoTask unsafe {\n                     debug!(\"global monitor task starting\");\n                     // As a weak task the runtime will notify us when to exit\n                     do weaken_task |weak_exit_po| {\n-                        debug!(\"global monitor task is now weak\");\n+                        debug!(\"global monitor task is weak\");\n                         weak_exit_po.recv();\n                         iotask::exit(&iotask);\n-                        debug!(\"global monitor task is leaving weakend state\");\n+                        debug!(\"global monitor task is unweak\");\n                     };\n                     debug!(\"global monitor task exiting\");\n                 }"}]}