{"sha": "658637baf45b41e4cff049440bc07f267d810218", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1ODYzN2JhZjQ1YjQxZTRjZmYwNDk0NDBiYzA3ZjI2N2Q4MTAyMTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-04T20:21:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-04T20:21:11Z"}, "message": "auto merge of #10179 : alexcrichton/rust/rt-improvements, r=cmr\n\nThis fleshes out the io::file module a fair bit more, adding all of the functionality that I can think of that we would want. Some questions about the representation which I'm curious about:\r\n\r\n* I modified `FileStat` to be a little less platform-agnostic, but it's still fairly platform-specific. I don't want to hide information that we have, but I don't want to depend on this information being available. One possible route is to have an `extra` field which has all this os-dependent stuff which is clearly documented as it should be avoided.\r\n\r\n* Does it make sense for directory functions to be top-level functions instead of static methods? It seems silly to import `std::rt::io::file` and `std::rt::io::File` at the top of files that need to deal with directories and files.", "tree": {"sha": "019eee1761d43461ef06f1e5307b57b0b8b47019", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/019eee1761d43461ef06f1e5307b57b0b8b47019"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/658637baf45b41e4cff049440bc07f267d810218", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/658637baf45b41e4cff049440bc07f267d810218", "html_url": "https://github.com/rust-lang/rust/commit/658637baf45b41e4cff049440bc07f267d810218", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/658637baf45b41e4cff049440bc07f267d810218/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70e9b5ab3912da84a32557bc1a34db5fb2178927", "url": "https://api.github.com/repos/rust-lang/rust/commits/70e9b5ab3912da84a32557bc1a34db5fb2178927", "html_url": "https://github.com/rust-lang/rust/commit/70e9b5ab3912da84a32557bc1a34db5fb2178927"}, {"sha": "3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b", "html_url": "https://github.com/rust-lang/rust/commit/3c3ed1499a9b9e23d4a2d2243a7b0b1c9015f34b"}], "stats": {"total": 5174, "additions": 2724, "deletions": 2450}, "files": [{"sha": "a24791d76af975d8a54c26d161fdba7be6aa58f7", "filename": "mk/tests.mk", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -517,8 +517,8 @@ CTEST_BUILD_BASE_rpass = run-pass\n CTEST_MODE_rpass = run-pass\n CTEST_RUNTOOL_rpass = $(CTEST_RUNTOOL)\n \n-CTEST_SRC_BASE_rpass-full = run-pass-full\n-CTEST_BUILD_BASE_rpass-full = run-pass-full\n+CTEST_SRC_BASE_rpass-full = run-pass-fulldeps\n+CTEST_BUILD_BASE_rpass-full = run-pass-fulldeps\n CTEST_MODE_rpass-full = run-pass\n CTEST_RUNTOOL_rpass-full = $(CTEST_RUNTOOL)\n \n@@ -673,7 +673,7 @@ PRETTY_DEPS_pretty-rfail = $(RFAIL_TESTS)\n PRETTY_DEPS_pretty-bench = $(BENCH_TESTS)\n PRETTY_DEPS_pretty-pretty = $(PRETTY_TESTS)\n PRETTY_DIRNAME_pretty-rpass = run-pass\n-PRETTY_DIRNAME_pretty-rpass-full = run-pass-full\n+PRETTY_DIRNAME_pretty-rpass-full = run-pass-fulldeps\n PRETTY_DIRNAME_pretty-rfail = run-fail\n PRETTY_DIRNAME_pretty-bench = bench\n PRETTY_DIRNAME_pretty-pretty = pretty"}, {"sha": "f4bd668690eef20e96f9827ca16f0b725a3c3fc4", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -17,6 +17,7 @@ extern mod extra;\n \n use std::os;\n use std::rt;\n+use std::rt::io::fs;\n \n use extra::getopts;\n use extra::getopts::groups::{optopt, optflag, reqopt};\n@@ -247,7 +248,7 @@ pub fn make_tests(config: &config) -> ~[test::TestDescAndFn] {\n     debug!(\"making tests from {}\",\n            config.src_base.display());\n     let mut tests = ~[];\n-    let dirs = os::list_dir_path(&config.src_base);\n+    let dirs = fs::readdir(&config.src_base);\n     for file in dirs.iter() {\n         let file = file.clone();\n         debug!(\"inspecting file {}\", file.display());"}, {"sha": "8bfef9da805f25ac270c2efbe706a9faf04aaebd", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -8,16 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::rt::io::buffered::BufferedReader;\n+use std::rt::io::File;\n+\n pub struct ExpectedError { line: uint, kind: ~str, msg: ~str }\n \n // Load any test directives embedded in the file\n pub fn load_errors(testfile: &Path) -> ~[ExpectedError] {\n-    use std::rt::io::Open;\n-    use std::rt::io::file::FileInfo;\n-    use std::rt::io::buffered::BufferedReader;\n \n     let mut error_patterns = ~[];\n-    let mut rdr = BufferedReader::new(testfile.open_reader(Open).unwrap());\n+    let mut rdr = BufferedReader::new(File::open(testfile).unwrap());\n     let mut line_num = 1u;\n     loop {\n         let ln = match rdr.read_line() {"}, {"sha": "5571e159ee31dcaa27071508298ede3cea5a3d34", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -103,11 +103,10 @@ pub fn is_test_ignored(config: &config, testfile: &Path) -> bool {\n }\n \n fn iter_header(testfile: &Path, it: &fn(&str) -> bool) -> bool {\n-    use std::rt::io::Open;\n-    use std::rt::io::file::FileInfo;\n     use std::rt::io::buffered::BufferedReader;\n+    use std::rt::io::File;\n \n-    let mut rdr = BufferedReader::new(testfile.open_reader(Open).unwrap());\n+    let mut rdr = BufferedReader::new(File::open(testfile).unwrap());\n     loop {\n         let ln = match rdr.read_line() {\n             Some(ln) => ln, None => break"}, {"sha": "1b3e34ad81934c5f05906e5c5c79b15da78f5279", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 11, "deletions": 39, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -20,44 +20,18 @@ use procsrv;\n use util;\n use util::logv;\n \n-use std::cell::Cell;\n use std::rt::io;\n-use std::rt::io::Writer;\n-use std::rt::io::Reader;\n-use std::rt::io::file::FileInfo;\n+use std::rt::io::fs;\n+use std::rt::io::File;\n use std::os;\n use std::str;\n-use std::task::{spawn_sched, SingleThreaded};\n use std::vec;\n-use std::unstable::running_on_valgrind;\n \n use extra::test::MetricMap;\n \n pub fn run(config: config, testfile: ~str) {\n-    let config = Cell::new(config);\n-    let testfile = Cell::new(testfile);\n-    // FIXME #6436: Creating another thread to run the test because this\n-    // is going to call waitpid. The new scheduler has some strange\n-    // interaction between the blocking tasks and 'friend' schedulers\n-    // that destroys parallelism if we let normal schedulers block.\n-    // It should be possible to remove this spawn once std::run is\n-    // rewritten to be non-blocking.\n-    //\n-    // We do _not_ create another thread if we're running on V because\n-    // it serializes all threads anyways.\n-    if running_on_valgrind() {\n-        let config = config.take();\n-        let testfile = testfile.take();\n-        let mut _mm = MetricMap::new();\n-        run_metrics(config, testfile, &mut _mm);\n-    } else {\n-        do spawn_sched(SingleThreaded) {\n-            let config = config.take();\n-            let testfile = testfile.take();\n-            let mut _mm = MetricMap::new();\n-            run_metrics(config, testfile, &mut _mm);\n-        }\n-    }\n+    let mut _mm = MetricMap::new();\n+    run_metrics(config, testfile, &mut _mm);\n }\n \n pub fn run_metrics(config: config, testfile: ~str, mm: &mut MetricMap) {\n@@ -173,7 +147,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     let rounds =\n         match props.pp_exact { Some(_) => 1, None => 2 };\n \n-    let src = testfile.open_reader(io::Open).read_to_end();\n+    let src = File::open(testfile).read_to_end();\n     let src = str::from_utf8_owned(src);\n     let mut srcs = ~[src];\n \n@@ -195,7 +169,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     let mut expected = match props.pp_exact {\n         Some(ref file) => {\n             let filepath = testfile.dir_path().join(file);\n-            let s = filepath.open_reader(io::Open).read_to_end();\n+            let s = File::open(&filepath).read_to_end();\n             str::from_utf8_owned(s)\n           }\n           None => { srcs[srcs.len() - 2u].clone() }\n@@ -651,10 +625,8 @@ fn compose_and_run_compiler(\n }\n \n fn ensure_dir(path: &Path) {\n-    if os::path_is_dir(path) { return; }\n-    if !os::make_dir(path, 0x1c0i32) {\n-        fail!(\"can't make dir {}\", path.display());\n-    }\n+    if path.is_dir() { return; }\n+    fs::mkdir(path, io::UserRWX);\n }\n \n fn compose_and_run(config: &config, testfile: &Path,\n@@ -768,7 +740,7 @@ fn dump_output(config: &config, testfile: &Path, out: &str, err: &str) {\n fn dump_output_file(config: &config, testfile: &Path,\n                     out: &str, extension: &str) {\n     let outfile = make_out_name(config, testfile, extension);\n-    outfile.open_writer(io::CreateOrTruncate).write(out.as_bytes());\n+    File::create(&outfile).write(out.as_bytes());\n }\n \n fn make_out_name(config: &config, testfile: &Path, extension: &str) -> Path {\n@@ -924,7 +896,7 @@ fn _dummy_exec_compiled_test(config: &config, props: &TestProps,\n fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n     let tdir = aux_output_dir_name(config, testfile);\n \n-    let dirs = os::list_dir_path(&tdir);\n+    let dirs = fs::readdir(&tdir);\n     for file in dirs.iter() {\n         if file.extension_str() == Some(\"so\") {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -1019,7 +991,7 @@ fn disassemble_extract(config: &config, _props: &TestProps,\n \n \n fn count_extracted_lines(p: &Path) -> uint {\n-    let x = p.with_extension(\"ll\").open_reader(io::Open).read_to_end();\n+    let x = File::open(&p.with_extension(\"ll\")).read_to_end();\n     let x = str::from_utf8_owned(x);\n     x.line_iter().len()\n }"}, {"sha": "d86ed510361cc3fd0a1e048cd8201b46362270be", "filename": "src/etc/libc.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Fetc%2Flibc.c", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Fetc%2Flibc.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flibc.c?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -143,6 +143,7 @@ void posix88_consts() {\n   put_const(S_IFBLK, int);\n   put_const(S_IFDIR, int);\n   put_const(S_IFREG, int);\n+  put_const(S_IFLNK, int);\n   put_const(S_IFMT, int);\n \n   put_const(S_IEXEC, int);"}, {"sha": "1edef5ddbe1b4f4d8de22da761c9cbfbd803c332", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -24,6 +24,8 @@\n  */\n \n use std::{os, path};\n+use std::rt::io;\n+use std::rt::io::fs;\n use std::path::is_sep;\n \n use sort;\n@@ -146,9 +148,14 @@ impl Iterator<Path> for GlobIterator {\n }\n \n fn list_dir_sorted(path: &Path) -> ~[Path] {\n-    let mut children = os::list_dir_path(path);\n-    sort::quick_sort(children, |p1, p2| p2.filename().unwrap() <= p1.filename().unwrap());\n-    children\n+    match io::result(|| fs::readdir(path)) {\n+        Ok(children) => {\n+            let mut children = children;\n+            sort::quick_sort(children, |p1, p2| p2.filename() <= p1.filename());\n+            children\n+        }\n+        Err(*) => ~[]\n+    }\n }\n \n /**"}, {"sha": "fbd65cab98ca7858f522446b3f727762fe647ec9", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -14,6 +14,8 @@\n use std::os;\n use std::rand::Rng;\n use std::rand;\n+use std::rt::io;\n+use std::rt::io::fs;\n \n /// A wrapper for a path to temporary directory implementing automatic\n /// scope-pased deletion.\n@@ -36,8 +38,9 @@ impl TempDir {\n         let mut r = rand::rng();\n         for _ in range(0u, 1000) {\n             let p = tmpdir.join(r.gen_ascii_str(16) + suffix);\n-            if os::make_dir(&p, 0x1c0) { // 700\n-                return Some(TempDir { path: Some(p) });\n+            match io::result(|| fs::mkdir(&p, io::UserRWX)) {\n+                Err(*) => {}\n+                Ok(()) => return Some(TempDir { path: Some(p) })\n             }\n         }\n         None\n@@ -69,7 +72,9 @@ impl TempDir {\n impl Drop for TempDir {\n     fn drop(&mut self) {\n         for path in self.path.iter() {\n-            os::remove_dir_recursive(path);\n+            if path.exists() {\n+                fs::rmdir_recursive(path);\n+            }\n         }\n     }\n }"}, {"sha": "04b30e5ef7474c911d22541adde858792135902d", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -329,6 +329,6 @@ mod test {\n     #[ignore(reason = \"no ncurses on buildbots, needs a bundled terminfo file to test against\")]\n     fn test_parse() {\n         // FIXME #6870: Distribute a compiled file in src/tests and test there\n-        // parse(io::file_reader(&p(\"/usr/share/terminfo/r/rxvt-256color\")).unwrap(), false);\n+        // parse(io::fs_reader(&p(\"/usr/share/terminfo/r/rxvt-256color\")).unwrap(), false);\n     }\n }"}, {"sha": "09ceae66bb12d355ee95c0bc02ec874fa96e08ce", "filename": "src/libextra/terminfo/searcher.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -14,7 +14,7 @@\n use std::{os, str};\n use std::os::getenv;\n use std::rt::io;\n-use std::rt::io::file::FileInfo;\n+use std::rt::io::File;\n \n /// Return path to database entry for `term`\n pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n@@ -56,16 +56,16 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n \n     // Look for the terminal in all of the search directories\n     for p in dirs_to_search.iter() {\n-        if os::path_exists(p) {\n+        if p.exists() {\n             let f = str::from_char(first_char);\n             let newp = p.join_many([f.as_slice(), term]);\n-            if os::path_exists(&newp) {\n+            if newp.exists() {\n                 return Some(~newp);\n             }\n             // on some installations the dir is named after the hex of the char (e.g. OS X)\n             let f = format!(\"{:x}\", first_char as uint);\n             let newp = p.join_many([f.as_slice(), term]);\n-            if os::path_exists(&newp) {\n+            if newp.exists() {\n                 return Some(~newp);\n             }\n         }\n@@ -76,7 +76,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n /// Return open file for `term`\n pub fn open(term: &str) -> Result<@mut io::Reader, ~str> {\n     match get_dbpath_for_term(term) {\n-        Some(x) => Ok(@mut x.open_reader(io::Open).unwrap() as @mut io::Reader),\n+        Some(x) => Ok(@mut File::open(x) as @mut io::Reader),\n         None => Err(format!(\"could not find terminfo entry for {}\", term))\n     }\n }"}, {"sha": "4cdb3841acf9b0c91c0c3b67df78d0315e907292", "filename": "src/libextra/test.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -31,7 +31,7 @@ use treemap::TreeMap;\n use std::clone::Clone;\n use std::comm::{stream, SharedChan, GenericPort, GenericChan};\n use std::rt::io;\n-use std::rt::io::file::FileInfo;\n+use std::rt::io::File;\n use std::task;\n use std::to_str::ToStr;\n use std::f64;\n@@ -353,10 +353,7 @@ struct ConsoleTestState {\n impl ConsoleTestState {\n     pub fn new(opts: &TestOpts) -> ConsoleTestState {\n         let log_out = match opts.logfile {\n-            Some(ref path) => {\n-                let out = path.open_writer(io::CreateOrTruncate);\n-                Some(@mut out as @mut io::Writer)\n-            },\n+            Some(ref path) => Some(@mut File::create(path) as @mut io::Writer),\n             None => None\n         };\n         let out = @mut io::stdio::stdout() as @mut io::Writer;\n@@ -938,16 +935,15 @@ impl MetricMap {\n \n     /// Load MetricDiff from a file.\n     pub fn load(p: &Path) -> MetricMap {\n-        assert!(os::path_exists(p));\n-        let f = @mut p.open_reader(io::Open) as @mut io::Reader;\n+        assert!(p.exists());\n+        let f = @mut File::open(p) as @mut io::Reader;\n         let mut decoder = json::Decoder(json::from_reader(f).unwrap());\n         MetricMap(Decodable::decode(&mut decoder))\n     }\n \n     /// Write MetricDiff to a file.\n     pub fn save(&self, p: &Path) {\n-        let f = @mut p.open_writer(io::CreateOrTruncate);\n-        self.to_json().to_pretty_writer(f as @mut io::Writer);\n+        self.to_json().to_pretty_writer(@mut File::create(p) as @mut io::Writer);\n     }\n \n     /// Compare against another MetricMap. Optionally compare all\n@@ -1032,7 +1028,7 @@ impl MetricMap {\n     /// `MetricChange`s are `Regression`. Returns the diff as well\n     /// as a boolean indicating whether the ratchet succeeded.\n     pub fn ratchet(&self, p: &Path, pct: Option<f64>) -> (MetricDiff, bool) {\n-        let old = if os::path_exists(p) {\n+        let old = if p.exists() {\n             MetricMap::load(p)\n         } else {\n             MetricMap::new()"}, {"sha": "54ce349a0b484dd722cb9ada18f891ea47de9129", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -792,7 +792,6 @@ mod test {\n \n     #[test]\n     fn test_serialize_round_trip() {\n-        use std;\n         use ebml;\n         use serialize::{Encodable, Decodable};\n "}, {"sha": "eed37a426be2db6252354e5d4541203be6ef24d3", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -17,13 +17,10 @@ use arc::{Arc,RWArc};\n use treemap::TreeMap;\n use std::cell::Cell;\n use std::comm::{PortOne, oneshot};\n-use std::{os, str, task};\n+use std::{str, task};\n use std::rt::io;\n-use std::rt::io::Writer;\n-use std::rt::io::Reader;\n-use std::rt::io::Decorator;\n+use std::rt::io::{File, Decorator};\n use std::rt::io::mem::MemWriter;\n-use std::rt::io::file::FileInfo;\n \n /**\n *\n@@ -145,7 +142,7 @@ impl Database {\n             db_cache: TreeMap::new(),\n             db_dirty: false\n         };\n-        if os::path_exists(&rslt.db_filename) {\n+        if rslt.db_filename.exists() {\n             rslt.load();\n         }\n         rslt\n@@ -178,19 +175,19 @@ impl Database {\n \n     // FIXME #4330: This should have &mut self and should set self.db_dirty to false.\n     fn save(&self) {\n-        let f = @mut self.db_filename.open_writer(io::CreateOrTruncate);\n+        let f = @mut File::create(&self.db_filename);\n         self.db_cache.to_json().to_pretty_writer(f as @mut io::Writer);\n     }\n \n     fn load(&mut self) {\n         assert!(!self.db_dirty);\n-        assert!(os::path_exists(&self.db_filename));\n-        let f = self.db_filename.open_reader(io::Open);\n-        match f {\n-            None => fail!(\"Couldn't load workcache database {}\",\n-                          self.db_filename.display()),\n-            Some(r) =>\n-                match json::from_reader(@mut r as @mut io::Reader) {\n+        assert!(self.db_filename.exists());\n+        match io::result(|| File::open(&self.db_filename)) {\n+            Err(e) => fail!(\"Couldn't load workcache database {}: {}\",\n+                            self.db_filename.display(),\n+                            e.desc),\n+            Ok(r) =>\n+                match json::from_reader(@mut r.unwrap() as @mut io::Reader) {\n                     Err(e) => fail!(\"Couldn't parse workcache database (from file {}): {}\",\n                                     self.db_filename.display(), e.to_str()),\n                     Ok(r) => {\n@@ -482,23 +479,21 @@ impl<'self, T:Send +\n #[test]\n fn test() {\n     use std::{os, run};\n-    use std::rt::io::Reader;\n+    use std::rt::io::fs;\n     use std::str::from_utf8_owned;\n \n     // Create a path to a new file 'filename' in the directory in which\n     // this test is running.\n     fn make_path(filename: ~str) -> Path {\n         let pth = os::self_exe_path().expect(\"workcache::test failed\").with_filename(filename);\n-        if os::path_exists(&pth) {\n-            os::remove_file(&pth);\n+        if pth.exists() {\n+            fs::unlink(&pth);\n         }\n         return pth;\n     }\n \n     let pth = make_path(~\"foo.c\");\n-    {\n-        pth.open_writer(io::Create).write(bytes!(\"int main() { return 0; }\"));\n-    }\n+    File::create(&pth).write(bytes!(\"int main() { return 0; }\"));\n \n     let db_path = make_path(~\"db.json\");\n \n@@ -511,7 +506,7 @@ fn test() {\n         let subcx = cx.clone();\n         let pth = pth.clone();\n \n-        let file_content = from_utf8_owned(pth.open_reader(io::Open).read_to_end());\n+        let file_content = from_utf8_owned(File::open(&pth).read_to_end());\n \n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prep.declare_input(\"file\", pth.as_str().unwrap(), file_content);"}, {"sha": "5b0f424360b1ebb6398d91ad9f68f672c89bc419", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -27,12 +27,11 @@ use std::char;\n use std::hash::Streaming;\n use std::hash;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n-use std::os;\n use std::ptr;\n-use std::rt::io::Writer;\n use std::run;\n use std::str;\n use std::vec;\n+use std::rt::io::fs;\n use syntax::ast;\n use syntax::ast_map::{path, path_mod, path_name, path_pretty_name};\n use syntax::attr;\n@@ -951,20 +950,17 @@ pub fn link_binary(sess: Session,\n \n     // Remove the temporary object file if we aren't saving temps\n     if !sess.opts.save_temps {\n-        if ! os::remove_file(obj_filename) {\n-            sess.warn(format!(\"failed to delete object file `{}`\",\n-                           obj_filename.display()));\n-        }\n+        fs::unlink(obj_filename);\n     }\n }\n \n fn is_writeable(p: &Path) -> bool {\n-    use std::libc::consts::os::posix88::S_IWUSR;\n+    use std::rt::io;\n \n-    !os::path_exists(p) ||\n-        (match p.get_mode() {\n-            None => false,\n-            Some(m) => m & S_IWUSR as uint == S_IWUSR as uint\n+    !p.exists() ||\n+        (match io::result(|| p.stat()) {\n+            Err(*) => false,\n+            Ok(m) => m.perm & io::UserWrite == io::UserWrite\n         })\n }\n "}, {"sha": "47f9fcc3ca03be2444f680d065bcb0b6376cdaf7", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -27,6 +27,7 @@ use util::ppaux;\n \n use std::hashmap::{HashMap,HashSet};\n use std::rt::io;\n+use std::rt::io::fs;\n use std::rt::io::mem::MemReader;\n use std::os;\n use std::vec;\n@@ -369,7 +370,7 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n \n         // Remove assembly source unless --save-temps was specified\n         if !sess.opts.save_temps {\n-            os::remove_file(&asm_filename);\n+            fs::unlink(&asm_filename);\n         }\n     } else {\n         time(sess.time_passes(), \"LLVM passes\", (), |_|"}, {"sha": "c9bd5eff4a771f3bf89591aecf6ffd8017a1bf3b", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -11,6 +11,8 @@\n \n use std::option;\n use std::os;\n+use std::rt::io;\n+use std::rt::io::fs;\n use std::hashmap::HashSet;\n \n pub enum FileMatch { FileMatches, FileDoesntMatch }\n@@ -117,22 +119,26 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n pub fn search(filesearch: @FileSearch, pick: pick) {\n     do filesearch.for_each_lib_search_path() |lib_search_path| {\n         debug!(\"searching {}\", lib_search_path.display());\n-        let r = os::list_dir_path(lib_search_path);\n-        let mut rslt = FileDoesntMatch;\n-        for path in r.iter() {\n-            debug!(\"testing {}\", path.display());\n-            let maybe_picked = pick(path);\n-            match maybe_picked {\n-                FileMatches => {\n-                    debug!(\"picked {}\", path.display());\n-                    rslt = FileMatches;\n-                }\n-                FileDoesntMatch => {\n-                    debug!(\"rejected {}\", path.display());\n+        match io::result(|| fs::readdir(lib_search_path)) {\n+            Ok(files) => {\n+                let mut rslt = FileDoesntMatch;\n+                for path in files.iter() {\n+                    debug!(\"testing {}\", path.display());\n+                    let maybe_picked = pick(path);\n+                    match maybe_picked {\n+                        FileMatches => {\n+                            debug!(\"picked {}\", path.display());\n+                            rslt = FileMatches;\n+                        }\n+                        FileDoesntMatch => {\n+                            debug!(\"rejected {}\", path.display());\n+                        }\n+                    }\n                 }\n+                rslt\n             }\n+            Err(*) => FileDoesntMatch,\n         }\n-        rslt\n     };\n }\n \n@@ -210,15 +216,15 @@ pub fn rust_path() -> ~[Path] {\n             break\n         }\n         cwd.set_filename(\".rust\");\n-        if !env_rust_path.contains(&cwd) && os::path_exists(&cwd) {\n+        if !env_rust_path.contains(&cwd) && cwd.exists() {\n             env_rust_path.push(cwd.clone());\n         }\n         cwd.pop();\n     }\n     let h = os::homedir();\n     for h in h.iter() {\n         let p = h.join(\".rust\");\n-        if !env_rust_path.contains(&p) && os::path_exists(&p) {\n+        if !env_rust_path.contains(&p) && p.exists() {\n             env_rust_path.push(p);\n         }\n     }"}, {"sha": "0efc52bbe4a676332075f017af341449b541dc03", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 30, "deletions": 38, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -40,10 +40,9 @@ use std::fmt;\n use std::hashmap::{HashMap, HashSet};\n use std::local_data;\n use std::rt::io::buffered::BufferedWriter;\n-use std::rt::io::file::{FileInfo, DirectoryInfo};\n-use std::rt::io::file;\n use std::rt::io;\n-use std::rt::io::Reader;\n+use std::rt::io::fs;\n+use std::rt::io::File;\n use std::os;\n use std::str;\n use std::task;\n@@ -265,8 +264,8 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n     // Publish the search index\n     {\n         dst.push(\"search-index.js\");\n-        let mut w = BufferedWriter::new(dst.open_writer(io::CreateOrTruncate));\n-        let w = &mut w as &mut io::Writer;\n+        let mut w = BufferedWriter::new(File::create(&dst).unwrap());\n+        let w = &mut w as &mut Writer;\n         write!(w, \"var searchIndex = [\");\n         for (i, item) in cache.search_index.iter().enumerate() {\n             if i > 0 { write!(w, \",\"); }\n@@ -315,8 +314,7 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n /// Writes the entire contents of a string to a destination, not attempting to\n /// catch any errors.\n fn write(dst: Path, contents: &str) {\n-    let mut w = dst.open_writer(io::CreateOrTruncate);\n-    w.write(contents.as_bytes());\n+    File::create(&dst).write(contents.as_bytes());\n }\n \n /// Makes a directory on the filesystem, failing the task if an error occurs and\n@@ -328,7 +326,7 @@ fn mkdir(path: &Path) {\n         fail!()\n     }).inside {\n         if !path.is_dir() {\n-            file::mkdir(path);\n+            fs::mkdir(path, io::UserRWX);\n         }\n     }\n }\n@@ -419,16 +417,13 @@ impl<'self> SourceCollector<'self> {\n         let mut contents = ~[];\n         {\n             let mut buf = [0, ..1024];\n-            let r = do io::io_error::cond.trap(|_| {}).inside {\n-                p.open_reader(io::Open)\n-            };\n             // If we couldn't open this file, then just returns because it\n             // probably means that it's some standard library macro thing and we\n             // can't have the source to it anyway.\n-            let mut r = match r {\n-                Some(r) => r,\n+            let mut r = match io::result(|| File::open(&p)) {\n+                Ok(r) => r,\n                 // eew macro hacks\n-                None => return filename == \"<std-macros>\"\n+                Err(*) => return filename == \"<std-macros>\"\n             };\n \n             // read everything\n@@ -451,16 +446,15 @@ impl<'self> SourceCollector<'self> {\n         }\n \n         cur.push(p.filename().expect(\"source has no filename\") + bytes!(\".html\"));\n-        let w = cur.open_writer(io::CreateOrTruncate);\n-        let mut w = BufferedWriter::new(w);\n+        let mut w = BufferedWriter::new(File::create(&cur).unwrap());\n \n         let title = cur.filename_display().with_str(|s| format!(\"{} -- source\", s));\n         let page = layout::Page {\n             title: title,\n             ty: \"source\",\n             root_path: root_path,\n         };\n-        layout::render(&mut w as &mut io::Writer, &self.cx.layout,\n+        layout::render(&mut w as &mut Writer, &self.cx.layout,\n                        &page, &(\"\"), &Source(contents.as_slice()));\n         w.flush();\n         return true;\n@@ -774,7 +768,7 @@ impl Context {\n     ///\n     /// The rendering driver uses this closure to queue up more work.\n     fn item(&mut self, item: clean::Item, f: &fn(&mut Context, clean::Item)) {\n-        fn render(w: io::file::FileWriter, cx: &mut Context, it: &clean::Item,\n+        fn render(w: io::File, cx: &mut Context, it: &clean::Item,\n                   pushname: bool) {\n             // A little unfortunate that this is done like this, but it sure\n             // does make formatting *a lot* nicer.\n@@ -796,7 +790,7 @@ impl Context {\n             // of the pain by using a buffered writer instead of invoking the\n             // write sycall all the time.\n             let mut writer = BufferedWriter::new(w);\n-            layout::render(&mut writer as &mut io::Writer, &cx.layout, &page,\n+            layout::render(&mut writer as &mut Writer, &cx.layout, &page,\n                            &Sidebar{ cx: cx, item: it },\n                            &Item{ cx: cx, item: it });\n             writer.flush();\n@@ -811,8 +805,7 @@ impl Context {\n                 do self.recurse(name) |this| {\n                     let item = item.take();\n                     let dst = this.dst.join(\"index.html\");\n-                    let writer = dst.open_writer(io::CreateOrTruncate);\n-                    render(writer.unwrap(), this, &item, false);\n+                    render(File::create(&dst).unwrap(), this, &item, false);\n \n                     let m = match item.inner {\n                         clean::ModuleItem(m) => m,\n@@ -829,8 +822,7 @@ impl Context {\n             // pages dedicated to them.\n             _ if item.name.is_some() => {\n                 let dst = self.dst.join(item_path(&item));\n-                let writer = dst.open_writer(io::CreateOrTruncate);\n-                render(writer.unwrap(), self, &item, true);\n+                render(File::create(&dst).unwrap(), self, &item, true);\n             }\n \n             _ => {}\n@@ -967,7 +959,7 @@ fn shorter<'a>(s: Option<&'a str>) -> &'a str {\n     }\n }\n \n-fn document(w: &mut io::Writer, item: &clean::Item) {\n+fn document(w: &mut Writer, item: &clean::Item) {\n     match item.doc_value() {\n         Some(s) => {\n             write!(w, \"<div class='docblock'>{}</div>\", Markdown(s));\n@@ -976,7 +968,7 @@ fn document(w: &mut io::Writer, item: &clean::Item) {\n     }\n }\n \n-fn item_module(w: &mut io::Writer, cx: &Context,\n+fn item_module(w: &mut Writer, cx: &Context,\n                item: &clean::Item, items: &[clean::Item]) {\n     document(w, item);\n     debug!(\"{:?}\", items);\n@@ -1123,7 +1115,7 @@ fn item_module(w: &mut io::Writer, cx: &Context,\n     write!(w, \"</table>\");\n }\n \n-fn item_function(w: &mut io::Writer, it: &clean::Item, f: &clean::Function) {\n+fn item_function(w: &mut Writer, it: &clean::Item, f: &clean::Function) {\n     write!(w, \"<pre class='fn'>{vis}{purity}fn {name}{generics}{decl}</pre>\",\n            vis = VisSpace(it.visibility),\n            purity = PuritySpace(f.purity),\n@@ -1133,7 +1125,7 @@ fn item_function(w: &mut io::Writer, it: &clean::Item, f: &clean::Function) {\n     document(w, it);\n }\n \n-fn item_trait(w: &mut io::Writer, it: &clean::Item, t: &clean::Trait) {\n+fn item_trait(w: &mut Writer, it: &clean::Item, t: &clean::Trait) {\n     let mut parents = ~\"\";\n     if t.parents.len() > 0 {\n         parents.push_str(\": \");\n@@ -1176,7 +1168,7 @@ fn item_trait(w: &mut io::Writer, it: &clean::Item, t: &clean::Trait) {\n     // Trait documentation\n     document(w, it);\n \n-    fn meth(w: &mut io::Writer, m: &clean::TraitMethod) {\n+    fn meth(w: &mut Writer, m: &clean::TraitMethod) {\n         write!(w, \"<h3 id='{}.{}' class='method'><code>\",\n                shortty(m.item()),\n                *m.item().name.get_ref());\n@@ -1234,8 +1226,8 @@ fn item_trait(w: &mut io::Writer, it: &clean::Item, t: &clean::Trait) {\n     }\n }\n \n-fn render_method(w: &mut io::Writer, meth: &clean::Item, withlink: bool) {\n-    fn fun(w: &mut io::Writer, it: &clean::Item, purity: ast::purity,\n+fn render_method(w: &mut Writer, meth: &clean::Item, withlink: bool) {\n+    fn fun(w: &mut Writer, it: &clean::Item, purity: ast::purity,\n            g: &clean::Generics, selfty: &clean::SelfTy, d: &clean::FnDecl,\n            withlink: bool) {\n         write!(w, \"{}fn {withlink, select,\n@@ -1264,7 +1256,7 @@ fn render_method(w: &mut io::Writer, meth: &clean::Item, withlink: bool) {\n     }\n }\n \n-fn item_struct(w: &mut io::Writer, it: &clean::Item, s: &clean::Struct) {\n+fn item_struct(w: &mut Writer, it: &clean::Item, s: &clean::Struct) {\n     write!(w, \"<pre class='struct'>\");\n     render_struct(w, it, Some(&s.generics), s.struct_type, s.fields,\n                   s.fields_stripped, \"\", true);\n@@ -1288,7 +1280,7 @@ fn item_struct(w: &mut io::Writer, it: &clean::Item, s: &clean::Struct) {\n     render_methods(w, it);\n }\n \n-fn item_enum(w: &mut io::Writer, it: &clean::Item, e: &clean::Enum) {\n+fn item_enum(w: &mut Writer, it: &clean::Item, e: &clean::Enum) {\n     write!(w, \"<pre class='enum'>{}enum {}{}\",\n            VisSpace(it.visibility),\n            it.name.get_ref().as_slice(),\n@@ -1365,7 +1357,7 @@ fn item_enum(w: &mut io::Writer, it: &clean::Item, e: &clean::Enum) {\n     render_methods(w, it);\n }\n \n-fn render_struct(w: &mut io::Writer, it: &clean::Item,\n+fn render_struct(w: &mut Writer, it: &clean::Item,\n                  g: Option<&clean::Generics>,\n                  ty: doctree::StructType,\n                  fields: &[clean::Item],\n@@ -1418,7 +1410,7 @@ fn render_struct(w: &mut io::Writer, it: &clean::Item,\n     }\n }\n \n-fn render_methods(w: &mut io::Writer, it: &clean::Item) {\n+fn render_methods(w: &mut Writer, it: &clean::Item) {\n     do local_data::get(cache_key) |cache| {\n         let cache = cache.unwrap();\n         do cache.read |c| {\n@@ -1453,7 +1445,7 @@ fn render_methods(w: &mut io::Writer, it: &clean::Item) {\n     }\n }\n \n-fn render_impl(w: &mut io::Writer, i: &clean::Impl, dox: &Option<~str>) {\n+fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n     write!(w, \"<h3 class='impl'><code>impl{} \", i.generics);\n     let trait_id = match i.trait_ {\n         Some(ref ty) => {\n@@ -1474,7 +1466,7 @@ fn render_impl(w: &mut io::Writer, i: &clean::Impl, dox: &Option<~str>) {\n         None => {}\n     }\n \n-    fn docmeth(w: &mut io::Writer, item: &clean::Item) -> bool {\n+    fn docmeth(w: &mut Writer, item: &clean::Item) -> bool {\n         write!(w, \"<h4 id='method.{}' class='method'><code>\",\n                *item.name.get_ref());\n         render_method(w, item, false);\n@@ -1552,7 +1544,7 @@ fn render_impl(w: &mut io::Writer, i: &clean::Impl, dox: &Option<~str>) {\n     write!(w, \"</div>\");\n }\n \n-fn item_typedef(w: &mut io::Writer, it: &clean::Item, t: &clean::Typedef) {\n+fn item_typedef(w: &mut Writer, it: &clean::Item, t: &clean::Typedef) {\n     write!(w, \"<pre class='typedef'>type {}{} = {};</pre>\",\n            it.name.get_ref().as_slice(),\n            t.generics,\n@@ -1574,7 +1566,7 @@ impl<'self> fmt::Default for Sidebar<'self> {\n         }\n         write!(fmt.buf, \"</p>\");\n \n-        fn block(w: &mut io::Writer, short: &str, longty: &str,\n+        fn block(w: &mut Writer, short: &str, longty: &str,\n                  cur: &clean::Item, cx: &Context) {\n             let items = match cx.sidebar.find_equiv(&short) {\n                 Some(items) => items.as_slice(),"}, {"sha": "c69fd9879ce2f6378c6e406be8ace46036402170", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -25,9 +25,8 @@ extern mod extra;\n \n use std::cell::Cell;\n use std::local_data;\n-use std::rt::io::Writer;\n-use std::rt::io::file::FileInfo;\n use std::rt::io;\n+use std::rt::io::File;\n use std::rt::io::mem::MemWriter;\n use std::rt::io::Decorator;\n use std::str;\n@@ -260,7 +259,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n /// This input format purely deserializes the json output file. No passes are\n /// run over the deserialized output.\n fn json_input(input: &str) -> Result<Output, ~str> {\n-    let input = match Path::new(input).open_reader(io::Open) {\n+    let input = match File::open(&Path::new(input)) {\n         Some(f) => f,\n         None => return Err(format!(\"couldn't open {} for reading\", input)),\n     };\n@@ -322,7 +321,7 @@ fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n     json.insert(~\"crate\", crate_json);\n     json.insert(~\"plugins\", json::Object(plugins_json));\n \n-    let mut file = dst.open_writer(io::Create).unwrap();\n+    let mut file = File::create(&dst).unwrap();\n     let output = json::Object(json).to_str();\n     file.write(output.as_bytes());\n }"}, {"sha": "c0ffd66d22e43e72d86f8a66dd7cb6c78637442f", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -21,7 +21,7 @@ pub use path_util::default_workspace;\n \n pub use source_control::{safe_git_clone, git_clone_url};\n \n-use std::{os, run};\n+use std::run;\n use extra::arc::{Arc,RWArc};\n use extra::workcache;\n use extra::workcache::{Database, Logger, FreshnessMap};\n@@ -57,12 +57,12 @@ pub fn new_default_context(c: workcache::Context, p: Path) -> BuildContext {\n \n fn file_is_fresh(path: &str, in_hash: &str) -> bool {\n     let path = Path::new(path);\n-    os::path_exists(&path) && in_hash == digest_file_with_date(&path)\n+    path.exists() && in_hash == digest_file_with_date(&path)\n }\n \n fn binary_is_fresh(path: &str, in_hash: &str) -> bool {\n     let path = Path::new(path);\n-    os::path_exists(&path) && in_hash == digest_only_date(&path)\n+    path.exists() && in_hash == digest_only_date(&path)\n }\n \n pub fn new_workcache_context(p: &Path) -> workcache::Context {"}, {"sha": "0ae08731546f13f69ea0db9c719ff524deb5c041", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -14,7 +14,6 @@ use extra::workcache;\n use rustc::driver::session::{OptLevel, No};\n \n use std::hashmap::HashSet;\n-use std::os;\n \n #[deriving(Clone)]\n pub struct Context {\n@@ -176,7 +175,7 @@ pub fn in_target(sysroot: &Path) -> bool {\n     debug!(\"Checking whether {} is in target\", sysroot.display());\n     let mut p = sysroot.dir_path();\n     p.set_filename(\"rustc\");\n-    os::path_is_dir(&p)\n+    p.is_dir()\n }\n \n impl RustcFlags {"}, {"sha": "576d5abe8bdade3960f4d61665fe17d11cbce01c", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -13,11 +13,13 @@\n use rustc::metadata::filesearch::rust_path;\n use path_util::*;\n use std::os;\n+use std::rt::io;\n+use std::rt::io::fs;\n \n pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n     let workspaces = rust_path();\n     for p in workspaces.iter() {\n-        let binfiles = os::list_dir(&p.join(\"bin\"));\n+        let binfiles = do io::ignore_io_error { fs::readdir(&p.join(\"bin\")) };\n         for exec in binfiles.iter() {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             match exec.filestem_str() {\n@@ -29,7 +31,7 @@ pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n                 }\n             }\n         }\n-        let libfiles = os::list_dir(&p.join(\"lib\"));\n+        let libfiles = do io::ignore_io_error { fs::readdir(&p.join(\"lib\")) };\n         for lib in libfiles.iter() {\n             debug!(\"Full name: {}\", lib.display());\n             match has_library(lib) {\n@@ -53,7 +55,7 @@ pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n }\n \n pub fn has_library(p: &Path) -> Option<~str> {\n-    let files = os::list_dir(p);\n+    let files = do io::ignore_io_error { fs::readdir(p) };\n     for path in files.iter() {\n         if path.extension_str() == Some(os::consts::DLL_EXTENSION) {\n             let stuff : &str = path.filestem_str().expect(\"has_library: weird path\");"}, {"sha": "b493d562b8b13eb005692138083ee040e1d9d723", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -26,6 +26,8 @@ extern mod syntax;\n \n use std::{os, result, run, str, task};\n use std::hashmap::HashSet;\n+use std::rt::io;\n+use std::rt::io::fs;\n pub use std::path::Path;\n \n use extra::workcache;\n@@ -36,7 +38,7 @@ use extra::{getopts};\n use syntax::{ast, diagnostic};\n use messages::{error, warn, note};\n use path_util::{build_pkg_id_in_workspace, built_test_in_workspace};\n-use path_util::{U_RWX, in_rust_path};\n+use path_util::in_rust_path;\n use path_util::{built_executable_in_workspace, built_library_in_workspace, default_workspace};\n use path_util::{target_executable_in_workspace, target_library_in_workspace, dir_has_crate_file};\n use source_control::{CheckedOutSources, is_git_dir, make_read_only};\n@@ -513,7 +515,7 @@ impl CtxMethods for BuildContext {\n                     // We expect that p is relative to the package source's start directory,\n                     // so check that assumption\n                     debug!(\"JustOne: p = {}\", p.display());\n-                    assert!(os::path_exists(&pkg_src.start_dir.join(p)));\n+                    assert!(pkg_src.start_dir.join(p).exists());\n                     if is_lib(p) {\n                         PkgSrc::push_crate(&mut pkg_src.libs, 0, p);\n                     } else if is_main(p) {\n@@ -541,8 +543,8 @@ impl CtxMethods for BuildContext {\n         let dir = build_pkg_id_in_workspace(id, workspace);\n         note(format!(\"Cleaning package {} (removing directory {})\",\n                         id.to_str(), dir.display()));\n-        if os::path_exists(&dir) {\n-            os::remove_dir_recursive(&dir);\n+        if dir.exists() {\n+            fs::rmdir_recursive(&dir);\n             note(format!(\"Removed directory {}\", dir.display()));\n         }\n \n@@ -600,7 +602,6 @@ impl CtxMethods for BuildContext {\n                         build_inputs: &[Path],\n                         target_workspace: &Path,\n                         id: &PkgId) -> ~[~str] {\n-        use conditions::copy_failed::cond;\n \n         debug!(\"install_no_build: assuming {} comes from {} with target {}\",\n                id.to_str(), build_workspace.display(), target_workspace.display());\n@@ -659,10 +660,8 @@ impl CtxMethods for BuildContext {\n \n                 for exec in subex.iter() {\n                     debug!(\"Copying: {} -> {}\", exec.display(), sub_target_ex.display());\n-                    if !(os::mkdir_recursive(&sub_target_ex.dir_path(), U_RWX) &&\n-                         os::copy_file(exec, &sub_target_ex)) {\n-                        cond.raise(((*exec).clone(), sub_target_ex.clone()));\n-                    }\n+                    fs::mkdir_recursive(&sub_target_ex.dir_path(), io::UserRWX);\n+                    fs::copy(exec, &sub_target_ex);\n                     // FIXME (#9639): This needs to handle non-utf8 paths\n                     exe_thing.discover_output(\"binary\",\n                         sub_target_ex.as_str().unwrap(),\n@@ -674,10 +673,8 @@ impl CtxMethods for BuildContext {\n                         .clone().expect(format!(\"I built {} but apparently \\\n                                              didn't install it!\", lib.display()));\n                     target_lib.set_filename(lib.filename().expect(\"weird target lib\"));\n-                    if !(os::mkdir_recursive(&target_lib.dir_path(), U_RWX) &&\n-                         os::copy_file(lib, &target_lib)) {\n-                        cond.raise(((*lib).clone(), target_lib.clone()));\n-                    }\n+                    fs::mkdir_recursive(&target_lib.dir_path(), io::UserRWX);\n+                    fs::copy(lib, &target_lib);\n                     debug!(\"3. discovering output {}\", target_lib.display());\n                     exe_thing.discover_output(\"binary\",\n                                               target_lib.as_str().unwrap(),\n@@ -712,10 +709,10 @@ impl CtxMethods for BuildContext {\n     }\n \n     fn init(&self) {\n-        os::mkdir_recursive(&Path::new(\"src\"),   U_RWX);\n-        os::mkdir_recursive(&Path::new(\"lib\"),   U_RWX);\n-        os::mkdir_recursive(&Path::new(\"bin\"),   U_RWX);\n-        os::mkdir_recursive(&Path::new(\"build\"), U_RWX);\n+        fs::mkdir_recursive(&Path::new(\"src\"), io::UserRWX);\n+        fs::mkdir_recursive(&Path::new(\"bin\"), io::UserRWX);\n+        fs::mkdir_recursive(&Path::new(\"lib\"), io::UserRWX);\n+        fs::mkdir_recursive(&Path::new(\"build\"), io::UserRWX);\n     }\n \n     fn uninstall(&self, _id: &str, _vers: Option<~str>)  {"}, {"sha": "0da343a27bfcafccf0710e55715e1796642d3b1b", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -10,7 +10,6 @@\n \n use version::{try_getting_version, try_getting_local_version,\n               Version, NoVersion, split_version};\n-use std::rt::io::Writer;\n use std::hash::Streaming;\n use std::hash;\n "}, {"sha": "3023f3ed60c5cd193f5aebd1b79872c050a96bf1", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -12,7 +12,8 @@ extern mod extra;\n \n use target::*;\n use package_id::PkgId;\n-use std::path::Path;\n+use std::rt::io;\n+use std::rt::io::fs;\n use std::os;\n use context::*;\n use crate::Crate;\n@@ -117,7 +118,7 @@ impl PkgSrc {\n \n         debug!(\"Checking dirs: {:?}\", to_try.map(|p| p.display().to_str()).connect(\":\"));\n \n-        let path = to_try.iter().find(|&d| os::path_exists(d));\n+        let path = to_try.iter().find(|&d| d.exists());\n \n         // See the comments on the definition of PkgSrc\n         let mut build_in_destination = use_rust_path_hack;\n@@ -132,7 +133,7 @@ impl PkgSrc {\n                     let package_id = PkgId::new(prefix.as_str().unwrap());\n                     let path = build_dir.join(&package_id.path);\n                     debug!(\"in loop: checking if {} is a directory\", path.display());\n-                    if os::path_is_dir(&path) {\n+                    if path.is_dir() {\n                         let ps = PkgSrc::new(source_workspace,\n                                              destination_workspace,\n                                              use_rust_path_hack,\n@@ -237,7 +238,7 @@ impl PkgSrc {\n \n         debug!(\"For package id {}, returning {}\", id.to_str(), dir.display());\n \n-        if !os::path_is_dir(&dir) {\n+        if !dir.is_dir() {\n             cond.raise((id.clone(), ~\"supplied path for package dir is a \\\n                                         non-directory\"));\n         }\n@@ -267,7 +268,7 @@ impl PkgSrc {\n         debug!(\"Checking whether {} (path = {}) exists locally. Cwd = {}, does it? {:?}\",\n                 pkgid.to_str(), pkgid.path.display(),\n                 cwd.display(),\n-                os::path_exists(&pkgid.path));\n+                pkgid.path.exists());\n \n         match safe_git_clone(&pkgid.path, &pkgid.version, local) {\n             CheckedOutSources => {\n@@ -300,7 +301,7 @@ impl PkgSrc {\n                 // Move clone_target to local.\n                 // First, create all ancestor directories.\n                 let moved = make_dir_rwx_recursive(&local.dir_path())\n-                    && os::rename_file(&clone_target, local);\n+                    && io::result(|| fs::rename(&clone_target, local)).is_ok();\n                 if moved { Some(local.clone()) }\n                     else { None }\n             }\n@@ -312,7 +313,7 @@ impl PkgSrc {\n     pub fn package_script_option(&self) -> Option<Path> {\n         let maybe_path = self.start_dir.join(\"pkg.rs\");\n         debug!(\"package_script_option: checking whether {} exists\", maybe_path.display());\n-        if os::path_exists(&maybe_path) {\n+        if maybe_path.exists() {\n             Some(maybe_path)\n         } else {\n             None\n@@ -349,7 +350,7 @@ impl PkgSrc {\n \n         let prefix = self.start_dir.component_iter().len();\n         debug!(\"Matching against {}\", self.id.short_name);\n-        do os::walk_dir(&self.start_dir) |pth| {\n+        for pth in fs::walk_dir(&self.start_dir) {\n             let maybe_known_crate_set = match pth.filename_str() {\n                 Some(filename) if filter(filename) => match filename {\n                     \"lib.rs\" => Some(&mut self.libs),\n@@ -362,11 +363,10 @@ impl PkgSrc {\n             };\n \n             match maybe_known_crate_set {\n-                Some(crate_set) => PkgSrc::push_crate(crate_set, prefix, pth),\n+                Some(crate_set) => PkgSrc::push_crate(crate_set, prefix, &pth),\n                 None => ()\n             }\n-            true\n-        };\n+        }\n \n         let crate_sets = [&self.libs, &self.mains, &self.tests, &self.benchs];\n         if crate_sets.iter().all(|crate_set| crate_set.is_empty()) {"}, {"sha": "949efacaa1196f7e9c53317fc0f2d70611ba231d", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -18,8 +18,9 @@ use rustc::driver::driver::host_triple;\n \n use std::libc;\n use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n-use std::os::mkdir_recursive;\n use std::os;\n+use std::rt::io;\n+use std::rt::io::fs;\n use messages::*;\n \n pub fn default_workspace() -> Path {\n@@ -28,8 +29,8 @@ pub fn default_workspace() -> Path {\n         fail!(\"Empty RUST_PATH\");\n     }\n     let result = p[0];\n-    if !os::path_is_dir(&result) {\n-        os::mkdir_recursive(&result, U_RWX);\n+    if !result.is_dir() {\n+        fs::mkdir_recursive(&result, io::UserRWX);\n     }\n     result\n }\n@@ -43,9 +44,13 @@ pub static U_RWX: i32 = (S_IRUSR | S_IWUSR | S_IXUSR) as i32;\n /// Creates a directory that is readable, writeable,\n /// and executable by the user. Returns true iff creation\n /// succeeded.\n-pub fn make_dir_rwx(p: &Path) -> bool { os::make_dir(p, U_RWX) }\n+pub fn make_dir_rwx(p: &Path) -> bool {\n+    io::result(|| fs::mkdir(p, io::UserRWX)).is_ok()\n+}\n \n-pub fn make_dir_rwx_recursive(p: &Path) -> bool { os::mkdir_recursive(p, U_RWX) }\n+pub fn make_dir_rwx_recursive(p: &Path) -> bool {\n+    io::result(|| fs::mkdir_recursive(p, io::UserRWX)).is_ok()\n+}\n \n // n.b. The next three functions ignore the package version right\n // now. Should fix that.\n@@ -59,16 +64,17 @@ pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n // Returns the directory it was actually found in\n              workspace_to_src_dir: &fn(&Path) -> Path) -> Option<Path> {\n-    if !os::path_is_dir(workspace) {\n+    if !workspace.is_dir() {\n         return None;\n     }\n \n     let src_dir = workspace_to_src_dir(workspace);\n+    if !src_dir.is_dir() { return None }\n \n     let mut found = None;\n-    do os::walk_dir(&src_dir) |p| {\n-        if os::path_is_dir(p) {\n-            if *p == src_dir.join(&pkgid.path) || {\n+    for p in fs::walk_dir(&src_dir) {\n+        if p.is_dir() {\n+            if p == src_dir.join(&pkgid.path) || {\n                 let pf = p.filename_str();\n                 do pf.iter().any |&g| {\n                     match split_version_general(g, '-') {\n@@ -83,9 +89,8 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n                 found = Some(p.clone());\n             }\n \n-        };\n-        true\n-    };\n+        }\n+    }\n \n     if found.is_some() {\n         debug!(\"Found {} in {}\", pkgid.to_str(), workspace.display());\n@@ -125,7 +130,7 @@ pub fn built_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<\n     result = mk_output_path(Main, Build, pkgid, result);\n     debug!(\"built_executable_in_workspace: checking whether {} exists\",\n            result.display());\n-    if os::path_exists(&result) {\n+    if result.exists() {\n         Some(result)\n     }\n     else {\n@@ -152,7 +157,7 @@ fn output_in_workspace(pkgid: &PkgId, workspace: &Path, what: OutputType) -> Opt\n     result = mk_output_path(what, Build, pkgid, result);\n     debug!(\"output_in_workspace: checking whether {} exists\",\n            result.display());\n-    if os::path_exists(&result) {\n+    if result.exists() {\n         Some(result)\n     }\n     else {\n@@ -210,7 +215,7 @@ pub fn system_library(sysroot: &Path, lib_name: &str) -> Option<Path> {\n \n fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Option<Path> {\n     debug!(\"Listing directory {}\", dir_to_search.display());\n-    let dir_contents = os::list_dir(dir_to_search);\n+    let dir_contents = do io::ignore_io_error { fs::readdir(dir_to_search) };\n     debug!(\"dir has {:?} entries\", dir_contents.len());\n \n     let lib_prefix = format!(\"{}{}\", os::consts::DLL_PREFIX, short_name);\n@@ -294,7 +299,7 @@ pub fn target_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n /// As a side effect, creates the lib-dir if it doesn't exist\n pub fn target_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     use conditions::bad_path::cond;\n-    if !os::path_is_dir(workspace) {\n+    if !workspace.is_dir() {\n         cond.raise(((*workspace).clone(),\n                     format!(\"Workspace supplied to target_library_in_workspace \\\n                              is not a directory! {}\", workspace.display())));\n@@ -333,7 +338,7 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n                 (Install, Lib)  => target_lib_dir(workspace),\n                 (Install, _)    => target_bin_dir(workspace)\n     };\n-    if !os::path_exists(&result) && !mkdir_recursive(&result, U_RWX) {\n+    if io::result(|| fs::mkdir_recursive(&result, io::UserRWX)).is_err() {\n         cond.raise((result.clone(), format!(\"target_file_in_workspace couldn't \\\n             create the {} dir (pkgid={}, workspace={}, what={:?}, where={:?}\",\n             subdir, pkgid.to_str(), workspace.display(), what, where)));\n@@ -344,18 +349,12 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n /// Return the directory for <pkgid>'s build artifacts in <workspace>.\n /// Creates it if it doesn't exist.\n pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n-    use conditions::bad_path::cond;\n-\n     let mut result = target_build_dir(workspace);\n     result.push(&pkgid.path);\n     debug!(\"Creating build dir {} for package id {}\", result.display(),\n            pkgid.to_str());\n-    if os::path_exists(&result) || os::mkdir_recursive(&result, U_RWX) {\n-        result\n-    }\n-    else {\n-        cond.raise((result, format!(\"Could not create directory for package {}\", pkgid.to_str())))\n-    }\n+    fs::mkdir_recursive(&result, io::UserRWX);\n+    return result;\n }\n \n /// Return the output file for a given directory name,\n@@ -398,13 +397,13 @@ pub fn mk_output_path(what: OutputType, where: Target,\n pub fn uninstall_package_from(workspace: &Path, pkgid: &PkgId) {\n     let mut did_something = false;\n     let installed_bin = target_executable_in_workspace(pkgid, workspace);\n-    if os::path_exists(&installed_bin) {\n-        os::remove_file(&installed_bin);\n+    if installed_bin.exists() {\n+        fs::unlink(&installed_bin);\n         did_something = true;\n     }\n     let installed_lib = target_library_in_workspace(pkgid, workspace);\n-    if os::path_exists(&installed_lib) {\n-        os::remove_file(&installed_lib);\n+    if installed_lib.exists() {\n+        fs::unlink(&installed_lib);\n         did_something = true;\n     }\n     if !did_something {\n@@ -421,7 +420,7 @@ pub fn dir_has_crate_file(dir: &Path) -> bool {\n \n fn dir_has_file(dir: &Path, file: &str) -> bool {\n     assert!(dir.is_absolute());\n-    os::path_exists(&dir.join(file))\n+    dir.join(file).exists()\n }\n \n pub fn find_dir_using_rust_path_hack(p: &PkgId) -> Option<Path> {"}, {"sha": "bcda3168bd855c8e686cb3ebef87bdba89129c03", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -10,8 +10,9 @@\n \n // Utils for working with version control repositories. Just git right now.\n \n-use std::{os, run, str};\n+use std::{run, str};\n use std::run::{ProcessOutput, ProcessOptions, Process};\n+use std::rt::io::fs;\n use extra::tempfile::TempDir;\n use version::*;\n use path_util::chmod_read_only;\n@@ -22,14 +23,14 @@ use path_util::chmod_read_only;\n /// directory (that the callee may use, for example, to check out remote sources into).\n /// Returns `CheckedOutSources` if the clone succeeded.\n pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult {\n-    if os::path_exists(source) {\n+    if source.exists() {\n         debug!(\"{} exists locally! Cloning it into {}\",\n                 source.display(), target.display());\n         // Ok to use target here; we know it will succeed\n-        assert!(os::path_is_dir(source));\n+        assert!(source.is_dir());\n         assert!(is_git_dir(source));\n \n-        if !os::path_exists(target) {\n+        if !target.exists() {\n             debug!(\"Running: git clone {} {}\", source.display(), target.display());\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let outp = run::process_output(\"git\", [~\"clone\",\n@@ -95,12 +96,11 @@ pub enum CloneResult {\n \n pub fn make_read_only(target: &Path) {\n     // Now, make all the files in the target dir read-only\n-    do os::walk_dir(target) |p| {\n-        if !os::path_is_dir(p) {\n-            assert!(chmod_read_only(p));\n-        };\n-        true\n-    };\n+    for p in fs::walk_dir(target) {\n+        if !p.is_dir() {\n+            assert!(chmod_read_only(&p));\n+        }\n+    }\n }\n \n /// Source can be either a URL or a local file path.\n@@ -138,5 +138,5 @@ fn process_output_in_cwd(prog: &str, args: &[~str], cwd: &Path) -> ProcessOutput\n }\n \n pub fn is_git_dir(p: &Path) -> bool {\n-    os::path_is_dir(&p.join(\".git\"))\n+    p.join(\".git\").is_dir()\n }"}, {"sha": "6555fb88c9023e9cff8edd3f378c4a8a9a14f60e", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 103, "deletions": 129, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -13,8 +13,8 @@\n use context::{BuildContext, Context, RustcFlags};\n use std::{os, run, str, task};\n use std::rt::io;\n-use std::rt::io::Writer;\n-use std::rt::io::file::FileInfo;\n+use std::rt::io::fs;\n+use std::rt::io::File;\n use extra::arc::Arc;\n use extra::arc::RWArc;\n use extra::tempfile::TempDir;\n@@ -27,7 +27,7 @@ use installed_packages::list_installed_packages;\n use package_id::{PkgId};\n use version::{ExactRevision, NoVersion, Version, Tagged};\n use path_util::{target_executable_in_workspace, target_test_in_workspace,\n-               target_bench_in_workspace, make_dir_rwx, U_RWX,\n+               target_bench_in_workspace, make_dir_rwx,\n                library_in_workspace, installed_library_in_workspace,\n                built_bench_in_workspace, built_test_in_workspace,\n                built_library_in_workspace, built_executable_in_workspace, target_build_dir,\n@@ -84,15 +84,15 @@ fn git_repo_pkg_with_tag(a_tag: ~str) -> PkgId {\n }\n \n fn writeFile(file_path: &Path, contents: &str) {\n-    let mut out = file_path.open_writer(io::CreateOrTruncate);\n+    let mut out = File::create(file_path);\n     out.write(contents.as_bytes());\n     out.write(['\\n' as u8]);\n }\n \n fn mk_emptier_workspace(tag: &str) -> TempDir {\n     let workspace = TempDir::new(tag).expect(\"couldn't create temp dir\");\n     let package_dir = workspace.path().join(\"src\");\n-    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n+    fs::mkdir_recursive(&package_dir, io::UserRWX);\n     workspace\n }\n \n@@ -107,7 +107,7 @@ fn mk_workspace(workspace: &Path, short_name: &Path, version: &Version) -> Path\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let package_dir = workspace.join_many([~\"src\", format!(\"{}-{}\",\n                                            short_name.as_str().unwrap(), version.to_str())]);\n-    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n+    fs::mkdir_recursive(&package_dir, io::UserRWX);\n     package_dir\n }\n \n@@ -120,12 +120,12 @@ fn mk_temp_workspace(short_name: &Path, version: &Version) -> (TempDir, Path) {\n                                                               version.to_str())]);\n \n     debug!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n-          os::path_is_dir(&package_dir));\n+           package_dir.is_dir());\n     // Create main, lib, test, and bench files\n     debug!(\"mk_workspace: creating {}\", package_dir.display());\n-    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n+    fs::mkdir_recursive(&package_dir, io::UserRWX);\n     debug!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n-          os::path_is_dir(&package_dir));\n+           package_dir.is_dir());\n     // Create main, lib, test, and bench files\n \n     writeFile(&package_dir.join(\"main.rs\"),\n@@ -162,7 +162,7 @@ fn init_git_repo(p: &Path) -> TempDir {\n     let tmp = TempDir::new(\"git_local\").expect(\"couldn't create temp dir\");\n     let work_dir = tmp.path().join(p);\n     let work_dir_for_opts = work_dir.clone();\n-    assert!(os::mkdir_recursive(&work_dir, U_RWX));\n+    fs::mkdir_recursive(&work_dir, io::UserRWX);\n     debug!(\"Running: git init in {}\", work_dir.display());\n     run_git([~\"init\"], None, &work_dir_for_opts,\n         format!(\"Couldn't initialize git repository in {}\", work_dir.display()));\n@@ -197,27 +197,13 @@ fn add_git_tag(repo: &Path, tag: ~str) {\n }\n \n fn is_rwx(p: &Path) -> bool {\n-    use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n-\n-    match p.get_mode() {\n-        None => return false,\n-        Some(m) =>\n-            ((m & S_IRUSR as uint) == S_IRUSR as uint\n-            && (m & S_IWUSR as uint) == S_IWUSR as uint\n-            && (m & S_IXUSR as uint) == S_IXUSR as uint)\n-    }\n+    if !p.exists() { return false }\n+    p.stat().perm & io::UserRWX == io::UserRWX\n }\n \n fn is_read_only(p: &Path) -> bool {\n-    use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n-\n-    match p.get_mode() {\n-        None => return false,\n-        Some(m) =>\n-            ((m & S_IRUSR as uint) == S_IRUSR as uint\n-            && (m & S_IWUSR as uint) == 0 as uint\n-            && (m & S_IXUSR as uint) == 0 as uint)\n-    }\n+    if !p.exists() { return false }\n+    p.stat().perm & io::UserRWX == io::UserRead\n }\n \n fn test_sysroot() -> Path {\n@@ -289,7 +275,7 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n         None        => ~\"\"\n     };\n     debug!(\"{} cd {}; {} {}\", env_str, cwd.display(), cmd, args.connect(\" \"));\n-    assert!(os::path_is_dir(&*cwd));\n+    assert!(cwd.is_dir());\n     let cwd = (*cwd).clone();\n     let mut prog = run::Process::new(cmd, args, run::ProcessOptions {\n         env: env.map(|e| e + os::env()),\n@@ -325,9 +311,9 @@ fn create_local_package_in(pkgid: &PkgId, pkgdir: &Path) -> Path {\n     let package_dir = pkgdir.join_many([~\"src\", pkgid.to_str()]);\n \n     // Create main, lib, test, and bench files\n-    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n+    fs::mkdir_recursive(&package_dir, io::UserRWX);\n     debug!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n-          os::path_is_dir(&package_dir));\n+           package_dir.is_dir());\n     // Create main, lib, test, and bench files\n \n     writeFile(&package_dir.join(\"main.rs\"),\n@@ -378,7 +364,7 @@ fn lib_exists(repo: &Path, pkg_path: &Path, _v: Version) -> bool { // ??? versio\n     debug!(\"assert_lib_exists: checking whether {:?} exists\", lib);\n     lib.is_some() && {\n         let libname = lib.get_ref();\n-        os::path_exists(libname) && is_rwx(libname)\n+        libname.exists() && is_rwx(libname)\n     }\n }\n \n@@ -389,21 +375,21 @@ fn assert_executable_exists(repo: &Path, short_name: &str) {\n fn executable_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n     let exec = target_executable_in_workspace(&PkgId::new(short_name), repo);\n-    os::path_exists(&exec) && is_rwx(&exec)\n+    exec.exists() && is_rwx(&exec)\n }\n \n fn test_executable_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"test_executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n     let exec = built_test_in_workspace(&PkgId::new(short_name), repo);\n     do exec.map_default(false) |exec| {\n-        os::path_exists(&exec) && is_rwx(&exec)\n+        exec.exists() && is_rwx(&exec)\n     }\n }\n \n fn remove_executable_file(p: &PkgId, workspace: &Path) {\n     let exec = target_executable_in_workspace(&PkgId::new(p.short_name), workspace);\n-    if os::path_exists(&exec) {\n-        assert!(os::remove_file(&exec));\n+    if exec.exists() {\n+        fs::unlink(&exec);\n     }\n }\n \n@@ -417,14 +403,14 @@ fn built_executable_exists(repo: &Path, short_name: &str) -> bool {\n     let exec = built_executable_in_workspace(&PkgId::new(short_name), repo);\n     exec.is_some() && {\n        let execname = exec.get_ref();\n-       os::path_exists(execname) && is_rwx(execname)\n+       execname.exists() && is_rwx(execname)\n     }\n }\n \n fn remove_built_executable_file(p: &PkgId, workspace: &Path) {\n     let exec = built_executable_in_workspace(&PkgId::new(p.short_name), workspace);\n     match exec {\n-        Some(r) => assert!(os::remove_file(&r)),\n+        Some(r) => fs::unlink(&r),\n         None    => ()\n     }\n }\n@@ -446,8 +432,9 @@ fn llvm_bitcode_file_exists(repo: &Path, short_name: &str) -> bool {\n }\n \n fn file_exists(repo: &Path, short_name: &str, extension: &str) -> bool {\n-    os::path_exists(&target_build_dir(repo).join_many([short_name.to_owned(),\n-                                     format!(\"{}.{}\", short_name, extension)]))\n+    target_build_dir(repo).join_many([short_name.to_owned(),\n+                                     format!(\"{}.{}\", short_name, extension)])\n+                          .exists()\n }\n \n fn assert_built_library_exists(repo: &Path, short_name: &str) {\n@@ -459,7 +446,7 @@ fn built_library_exists(repo: &Path, short_name: &str) -> bool {\n     let lib = built_library_in_workspace(&PkgId::new(short_name), repo);\n     lib.is_some() && {\n         let libname = lib.get_ref();\n-        os::path_exists(libname) && is_rwx(libname)\n+        libname.exists() && is_rwx(libname)\n     }\n }\n \n@@ -508,7 +495,7 @@ fn output_file_name(workspace: &Path, short_name: ~str) -> Path {\n fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n     use conditions::bad_path::cond;\n     let pkg_src_dir = workspace.join_many([~\"src\", pkgid.to_str()]);\n-    let contents = os::list_dir_path(&pkg_src_dir);\n+    let contents = fs::readdir(&pkg_src_dir);\n     for p in contents.iter() {\n         if p.extension_str() == Some(\"rs\") {\n             // should be able to do this w/o a process\n@@ -527,7 +514,7 @@ fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n     use conditions::bad_path::cond;\n     let pkg_src_dir = workspace.join_many([~\"src\", pkgid.to_str()]);\n-    let contents = os::list_dir_path(&pkg_src_dir);\n+    let contents = fs::readdir(&pkg_src_dir);\n     for p in contents.iter() {\n         if p.extension_str() == Some(\"rs\") {\n             // should be able to do this w/o a process\n@@ -548,7 +535,7 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n     let mut maybe_p = None;\n     let maybe_file = pkg_src_dir.join(filename);\n     debug!(\"Trying to frob {} -- {}\", pkg_src_dir.display(), filename);\n-    if os::path_exists(&maybe_file) {\n+    if maybe_file.exists() {\n         maybe_p = Some(maybe_file);\n     }\n     debug!(\"Frobbed? {:?}\", maybe_p);\n@@ -557,7 +544,7 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n             do io::io_error::cond.trap(|e| {\n                 cond.raise((p.clone(), format!(\"Bad path: {}\", e.desc)));\n             }).inside {\n-                let mut w = p.open_writer(io::Append);\n+                let mut w = File::open_mode(p, io::Append, io::Write);\n                 w.write(bytes!(\"/* hi */\\n\"));\n             }\n         }\n@@ -570,13 +557,14 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n fn test_make_dir_rwx() {\n     let temp = &os::tmpdir();\n     let dir = temp.join(\"quux\");\n-    assert!(!os::path_exists(&dir) ||\n-            os::remove_dir_recursive(&dir));\n+    if dir.exists() {\n+        fs::rmdir_recursive(&dir);\n+    }\n     debug!(\"Trying to make {}\", dir.display());\n     assert!(make_dir_rwx(&dir));\n-    assert!(os::path_is_dir(&dir));\n+    assert!(dir.is_dir());\n     assert!(is_rwx(&dir));\n-    assert!(os::remove_dir_recursive(&dir));\n+    fs::rmdir_recursive(&dir);\n }\n \n // n.b. I ignored the next two tests for now because something funny happens on linux\n@@ -603,19 +591,19 @@ fn test_install_valid() {\n     // Check that all files exist\n     let exec = target_executable_in_workspace(&temp_pkg_id, temp_workspace);\n     debug!(\"exec = {}\", exec.display());\n-    assert!(os::path_exists(&exec));\n+    assert!(exec.exists());\n     assert!(is_rwx(&exec));\n \n     let lib = installed_library_in_workspace(&temp_pkg_id.path, temp_workspace);\n     debug!(\"lib = {:?}\", lib);\n-    assert!(lib.as_ref().map_default(false, |l| os::path_exists(l)));\n+    assert!(lib.as_ref().map_default(false, |l| l.exists()));\n     assert!(lib.as_ref().map_default(false, |l| is_rwx(l)));\n \n     // And that the test and bench executables aren't installed\n-    assert!(!os::path_exists(&target_test_in_workspace(&temp_pkg_id, temp_workspace)));\n+    assert!(!target_test_in_workspace(&temp_pkg_id, temp_workspace).exists());\n     let bench = target_bench_in_workspace(&temp_pkg_id, temp_workspace);\n     debug!(\"bench = {}\", bench.display());\n-    assert!(!os::path_exists(&bench));\n+    assert!(!bench.exists());\n \n     // Make sure the db isn't dirty, so that it doesn't try to save()\n     // asynchronously after the temporary directory that it wants to save\n@@ -655,19 +643,19 @@ fn test_install_valid_external() {\n     // Check that all files exist\n     let exec = target_executable_in_workspace(&temp_pkg_id, temp_workspace);\n     debug!(\"exec = {}\", exec.display());\n-    assert!(os::path_exists(&exec));\n+    assert!(exec.exists());\n     assert!(is_rwx(&exec));\n \n     let lib = installed_library_in_workspace(&temp_pkg_id.path, temp_workspace);\n     debug!(\"lib = {:?}\", lib);\n-    assert!(lib.as_ref().map_default(false, |l| os::path_exists(l)));\n+    assert!(lib.as_ref().map_default(false, |l| l.exists()));\n     assert!(lib.as_ref().map_default(false, |l| is_rwx(l)));\n \n     // And that the test and bench executables aren't installed\n-    assert!(!os::path_exists(&target_test_in_workspace(&temp_pkg_id, temp_workspace)));\n+    assert!(!target_test_in_workspace(&temp_pkg_id, temp_workspace).exists());\n     let bench = target_bench_in_workspace(&temp_pkg_id, temp_workspace);\n     debug!(\"bench = {}\", bench.display());\n-    assert!(!os::path_exists(&bench));\n+    assert!(!bench.exists());\n \n }\n \n@@ -711,25 +699,25 @@ fn test_install_git() {\n     debug!(\"Checking for files in {}\", ws.display());\n     let exec = target_executable_in_workspace(&temp_pkg_id, &ws);\n     debug!(\"exec = {}\", exec.display());\n-    assert!(os::path_exists(&exec));\n+    assert!(exec.exists());\n     assert!(is_rwx(&exec));\n     let _built_lib =\n         built_library_in_workspace(&temp_pkg_id,\n                                    &ws).expect(\"test_install_git: built lib should exist\");\n     assert_lib_exists(&ws, &temp_pkg_id.path, temp_pkg_id.version.clone());\n     let built_test = built_test_in_workspace(&temp_pkg_id,\n                          &ws).expect(\"test_install_git: built test should exist\");\n-    assert!(os::path_exists(&built_test));\n+    assert!(built_test.exists());\n     let built_bench = built_bench_in_workspace(&temp_pkg_id,\n                           &ws).expect(\"test_install_git: built bench should exist\");\n-    assert!(os::path_exists(&built_bench));\n+    assert!(built_bench.exists());\n     // And that the test and bench executables aren't installed\n     let test = target_test_in_workspace(&temp_pkg_id, &ws);\n-    assert!(!os::path_exists(&test));\n+    assert!(!test.exists());\n     debug!(\"test = {}\", test.display());\n     let bench = target_bench_in_workspace(&temp_pkg_id, &ws);\n     debug!(\"bench = {}\", bench.display());\n-    assert!(!os::path_exists(&bench));\n+    assert!(!bench.exists());\n }\n \n #[test]\n@@ -783,6 +771,7 @@ fn test_package_version() {\n     let repo = repo.path();\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test_pkg_version\"]);\n     debug!(\"Writing files in: {}\", repo_subdir.display());\n+    fs::mkdir_recursive(&repo_subdir, io::UserRWX);\n     writeFile(&repo_subdir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n     writeFile(&repo_subdir.join(\"lib.rs\"),\n@@ -853,9 +842,9 @@ fn test_package_request_version() {\n     let mut dir = target_build_dir(&repo.join(\".rust\"));\n     dir.push(&Path::new(\"src/mockgithub.com/catamorphism/test_pkg_version-0.3\"));\n     debug!(\"dir = {}\", dir.display());\n-    assert!(os::path_is_dir(&dir));\n-    assert!(os::path_exists(&dir.join(\"version-0.3-file.txt\")));\n-    assert!(!os::path_exists(&dir.join(\"version-0.4-file.txt\")));\n+    assert!(dir.is_dir());\n+    assert!(dir.join(\"version-0.3-file.txt\").exists());\n+    assert!(!dir.join(\"version-0.4-file.txt\").exists());\n }\n \n #[test]\n@@ -904,24 +893,21 @@ fn package_script_with_default_build() {\n     let source = Path::new(file!()).dir_path().join_many(\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"fancy-lib\", ~\"pkg.rs\"]);\n     debug!(\"package_script_with_default_build: {}\", source.display());\n-    if !os::copy_file(&source,\n-                      &dir.join_many([\"src\", \"fancy-lib-0.1\", \"pkg.rs\"])) {\n-        fail!(\"Couldn't copy file\");\n-    }\n+    fs::copy(&source, &dir.join_many([\"src\", \"fancy-lib-0.1\", \"pkg.rs\"]));\n     command_line_test([~\"install\", ~\"fancy-lib\"], dir);\n     assert_lib_exists(dir, &Path::new(\"fancy-lib\"), NoVersion);\n-    assert!(os::path_exists(&target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"])));\n+    assert!(target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]).exists());\n     let generated_path = target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]);\n     debug!(\"generated path = {}\", generated_path.display());\n-    assert!(os::path_exists(&generated_path));\n+    assert!(generated_path.exists());\n }\n \n #[test]\n fn rustpkg_build_no_arg() {\n     let tmp = TempDir::new(\"rustpkg_build_no_arg\").expect(\"rustpkg_build_no_arg failed\");\n     let tmp = tmp.path().join(\".rust\");\n     let package_dir = tmp.join_many([\"src\", \"foo\"]);\n-    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n+    fs::mkdir_recursive(&package_dir, io::UserRWX);\n \n     writeFile(&package_dir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n@@ -935,7 +921,7 @@ fn rustpkg_install_no_arg() {\n     let tmp = TempDir::new(\"rustpkg_install_no_arg\").expect(\"rustpkg_install_no_arg failed\");\n     let tmp = tmp.path().join(\".rust\");\n     let package_dir = tmp.join_many([\"src\", \"foo\"]);\n-    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n+    fs::mkdir_recursive(&package_dir, io::UserRWX);\n     writeFile(&package_dir.join(\"lib.rs\"),\n               \"fn main() { let _x = (); }\");\n     debug!(\"install_no_arg: dir = {}\", package_dir.display());\n@@ -948,7 +934,7 @@ fn rustpkg_clean_no_arg() {\n     let tmp = TempDir::new(\"rustpkg_clean_no_arg\").expect(\"rustpkg_clean_no_arg failed\");\n     let tmp = tmp.path().join(\".rust\");\n     let package_dir = tmp.join_many([\"src\", \"foo\"]);\n-    assert!(os::mkdir_recursive(&package_dir, U_RWX));\n+    fs::mkdir_recursive(&package_dir, io::UserRWX);\n \n     writeFile(&package_dir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n@@ -957,7 +943,7 @@ fn rustpkg_clean_no_arg() {\n     assert_built_executable_exists(&tmp, \"foo\");\n     command_line_test([~\"clean\"], &package_dir);\n     let res = built_executable_in_workspace(&PkgId::new(\"foo\"), &tmp);\n-    assert!(!res.as_ref().map_default(false, |m| { os::path_exists(m) }));\n+    assert!(!res.as_ref().map_default(false, |m| m.exists()));\n }\n \n #[test]\n@@ -983,9 +969,9 @@ fn rust_path_test() {\n fn rust_path_contents() {\n     let dir = TempDir::new(\"rust_path\").expect(\"rust_path_contents failed\");\n     let abc = &dir.path().join_many([\"A\", \"B\", \"C\"]);\n-    assert!(os::mkdir_recursive(&abc.join(\".rust\"), U_RWX));\n-    assert!(os::mkdir_recursive(&abc.with_filename(\".rust\"), U_RWX));\n-    assert!(os::mkdir_recursive(&abc.dir_path().with_filename(\".rust\"), U_RWX));\n+    fs::mkdir_recursive(&abc.join(\".rust\"), io::UserRWX);\n+    fs::mkdir_recursive(&abc.with_filename(\".rust\"), io::UserRWX);\n+    fs::mkdir_recursive(&abc.dir_path().with_filename(\".rust\"), io::UserRWX);\n     assert!(os::change_dir(abc));\n \n     let p = rust_path();\n@@ -1225,8 +1211,8 @@ fn test_non_numeric_tag() {\n                                            temp_pkg_id.path.as_str().unwrap())], repo);\n     let file1 = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\", \"testbranch_only\"]);\n     let file2 = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\", \"master_only\"]);\n-    assert!(os::path_exists(&file1));\n-    assert!(!os::path_exists(&file2));\n+    assert!(file1.exists());\n+    assert!(!file2.exists());\n }\n \n #[test]\n@@ -1237,11 +1223,11 @@ fn test_extern_mod() {\n     let lib_depend_dir = TempDir::new(\"foo\").expect(\"test_extern_mod\");\n     let lib_depend_dir = lib_depend_dir.path();\n     let aux_dir = lib_depend_dir.join_many([\"src\", \"mockgithub.com\", \"catamorphism\", \"test_pkg\"]);\n-    assert!(os::mkdir_recursive(&aux_dir, U_RWX));\n+    fs::mkdir_recursive(&aux_dir, io::UserRWX);\n     let aux_pkg_file = aux_dir.join(\"lib.rs\");\n \n     writeFile(&aux_pkg_file, \"pub mod bar { pub fn assert_true() {  assert!(true); } }\\n\");\n-    assert!(os::path_exists(&aux_pkg_file));\n+    assert!(aux_pkg_file.exists());\n \n     writeFile(&main_file,\n               \"extern mod test = \\\"mockgithub.com/catamorphism/test_pkg\\\";\\nuse test::bar;\\\n@@ -1275,7 +1261,7 @@ fn test_extern_mod() {\n               str::from_utf8(outp.output),\n               str::from_utf8(outp.error));\n     }\n-    assert!(os::path_exists(&exec_file) && is_executable(&exec_file));\n+    assert!(exec_file.exists() && is_executable(&exec_file));\n }\n \n #[test]\n@@ -1286,11 +1272,11 @@ fn test_extern_mod_simpler() {\n     let lib_depend_dir = TempDir::new(\"foo\").expect(\"test_extern_mod_simpler\");\n     let lib_depend_dir = lib_depend_dir.path();\n     let aux_dir = lib_depend_dir.join_many([\"src\", \"rust-awesomeness\"]);\n-    assert!(os::mkdir_recursive(&aux_dir, U_RWX));\n+    fs::mkdir_recursive(&aux_dir, io::UserRWX);\n     let aux_pkg_file = aux_dir.join(\"lib.rs\");\n \n     writeFile(&aux_pkg_file, \"pub mod bar { pub fn assert_true() {  assert!(true); } }\\n\");\n-    assert!(os::path_exists(&aux_pkg_file));\n+    assert!(aux_pkg_file.exists());\n \n     writeFile(&main_file,\n               \"extern mod test = \\\"rust-awesomeness\\\";\\nuse test::bar;\\\n@@ -1330,7 +1316,7 @@ fn test_extern_mod_simpler() {\n               str::from_utf8(outp.output),\n               str::from_utf8(outp.error));\n     }\n-    assert!(os::path_exists(&exec_file) && is_executable(&exec_file));\n+    assert!(exec_file.exists() && is_executable(&exec_file));\n }\n \n #[test]\n@@ -1342,8 +1328,8 @@ fn test_import_rustpkg() {\n               \"extern mod rustpkg; fn main() {}\");\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n     debug!(\"workspace = {}\", workspace.display());\n-    assert!(os::path_exists(&target_build_dir(workspace).join(\"foo\").join(format!(\"pkg{}\",\n-        os::EXE_SUFFIX))));\n+    assert!(target_build_dir(workspace).join(\"foo\").join(format!(\"pkg{}\",\n+        os::EXE_SUFFIX)).exists());\n }\n \n #[test]\n@@ -1355,8 +1341,8 @@ fn test_macro_pkg_script() {\n               \"extern mod rustpkg; fn main() { debug!(\\\"Hi\\\"); }\");\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n     debug!(\"workspace = {}\", workspace.display());\n-    assert!(os::path_exists(&target_build_dir(workspace).join(\"foo\").join(format!(\"pkg{}\",\n-        os::EXE_SUFFIX))));\n+    assert!(target_build_dir(workspace).join(\"foo\").join(format!(\"pkg{}\",\n+        os::EXE_SUFFIX)).exists());\n }\n \n #[test]\n@@ -1436,7 +1422,7 @@ fn rust_path_hack_cwd() {\n    // Same as rust_path_hack_test, but the CWD is the dir to build out of\n    let cwd = TempDir::new(\"foo\").expect(\"rust_path_hack_cwd\");\n    let cwd = cwd.path().join(\"foo\");\n-   assert!(os::mkdir_recursive(&cwd, U_RWX));\n+   fs::mkdir_recursive(&cwd, io::UserRWX);\n    writeFile(&cwd.join(\"lib.rs\"), \"pub fn f() { }\");\n \n    let dest_workspace = mk_empty_workspace(&Path::new(\"bar\"), &NoVersion, \"dest_workspace\");\n@@ -1456,7 +1442,7 @@ fn rust_path_hack_multi_path() {\n    // Same as rust_path_hack_test, but with a more complex package ID\n    let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_cwd\");\n    let subdir = cwd.path().join_many([\"foo\", \"bar\", \"quux\"]);\n-   assert!(os::mkdir_recursive(&subdir, U_RWX));\n+   fs::mkdir_recursive(&subdir, io::UserRWX);\n    writeFile(&subdir.join(\"lib.rs\"), \"pub fn f() { }\");\n    let name = ~\"foo/bar/quux\";\n \n@@ -1870,21 +1856,22 @@ fn pkgid_pointing_to_subdir() {\n     // rustpkg should recognize that and treat the part after some_repo/ as a subdir\n     let workspace = TempDir::new(\"parent_repo\").expect(\"Couldn't create temp dir\");\n     let workspace = workspace.path();\n-    assert!(os::mkdir_recursive(&workspace.join_many([\"src\", \"mockgithub.com\",\n-                                                      \"mozilla\", \"some_repo\"]), U_RWX));\n+    fs::mkdir_recursive(&workspace.join_many([\"src\", \"mockgithub.com\",\n+                                                \"mozilla\", \"some_repo\"]),\n+                          io::UserRWX);\n \n     let foo_dir = workspace.join_many([\"src\", \"mockgithub.com\", \"mozilla\", \"some_repo\",\n                                        \"extras\", \"foo\"]);\n     let bar_dir = workspace.join_many([\"src\", \"mockgithub.com\", \"mozilla\", \"some_repo\",\n                                        \"extras\", \"bar\"]);\n-    assert!(os::mkdir_recursive(&foo_dir, U_RWX));\n-    assert!(os::mkdir_recursive(&bar_dir, U_RWX));\n+    fs::mkdir_recursive(&foo_dir, io::UserRWX);\n+    fs::mkdir_recursive(&bar_dir, io::UserRWX);\n     writeFile(&foo_dir.join(\"lib.rs\"), \"pub fn f() {}\");\n     writeFile(&bar_dir.join(\"lib.rs\"), \"pub fn g() {}\");\n \n     debug!(\"Creating a file in {}\", workspace.display());\n     let testpkg_dir = workspace.join_many([\"src\", \"testpkg-0.1\"]);\n-    assert!(os::mkdir_recursive(&testpkg_dir, U_RWX));\n+    fs::mkdir_recursive(&testpkg_dir, io::UserRWX);\n \n     writeFile(&testpkg_dir.join(\"main.rs\"),\n               \"extern mod foo = \\\"mockgithub.com/mozilla/some_repo/extras/foo\\\";\\n\n@@ -1957,9 +1944,9 @@ fn test_target_specific_build_dir() {\n                        ~\"build\",\n                        ~\"foo\"],\n                       workspace);\n-    assert!(os::path_is_dir(&target_build_dir(workspace)));\n+    assert!(target_build_dir(workspace).is_dir());\n     assert!(built_executable_exists(workspace, \"foo\"));\n-    assert!(os::list_dir(&workspace.join(\"build\")).len() == 1);\n+    assert!(fs::readdir(&workspace.join(\"build\")).len() == 1);\n }\n \n #[test]\n@@ -1973,10 +1960,10 @@ fn test_target_specific_install_dir() {\n                        ~\"install\",\n                        ~\"foo\"],\n                       workspace);\n-    assert!(os::path_is_dir(&workspace.join_many([~\"lib\", host_triple()])));\n+    assert!(workspace.join_many([~\"lib\", host_triple()]).is_dir());\n     assert_lib_exists(workspace, &Path::new(\"foo\"), NoVersion);\n-    assert!(os::list_dir(&workspace.join(\"lib\")).len() == 1);\n-    assert!(os::path_is_dir(&workspace.join(\"bin\")));\n+    assert!(fs::readdir(&workspace.join(\"lib\")).len() == 1);\n+    assert!(workspace.join(\"bin\").is_dir());\n     assert_executable_exists(workspace, \"foo\");\n }\n \n@@ -1988,7 +1975,7 @@ fn test_dependencies_terminate() {\n     let workspace = workspace.path();\n     let b_dir = workspace.join_many([\"src\", \"b-0.1\"]);\n     let b_subdir = b_dir.join(\"test\");\n-    assert!(os::mkdir_recursive(&b_subdir, U_RWX));\n+    fs::mkdir_recursive(&b_subdir, io::UserRWX);\n     writeFile(&b_subdir.join(\"test.rs\"),\n               \"extern mod b; use b::f; #[test] fn g() { f() }\");\n     command_line_test([~\"install\", ~\"b\"], workspace);\n@@ -2176,19 +2163,19 @@ fn test_installed_read_only() {\n     debug!(\"Checking for files in {}\", ws.display());\n     let exec = target_executable_in_workspace(&temp_pkg_id, &ws);\n     debug!(\"exec = {}\", exec.display());\n-    assert!(os::path_exists(&exec));\n+    assert!(exec.exists());\n     assert!(is_rwx(&exec));\n     let built_lib =\n         built_library_in_workspace(&temp_pkg_id,\n                                    &ws).expect(\"test_install_git: built lib should exist\");\n-    assert!(os::path_exists(&built_lib));\n+    assert!(built_lib.exists());\n     assert!(is_rwx(&built_lib));\n \n     // Make sure sources are (a) under \"build\" and (b) read-only\n     let src1 = target_build_dir(&ws).join_many([~\"src\", temp_pkg_id.to_str(), ~\"main.rs\"]);\n     let src2 = target_build_dir(&ws).join_many([~\"src\", temp_pkg_id.to_str(), ~\"lib.rs\"]);\n-    assert!(os::path_exists(&src1));\n-    assert!(os::path_exists(&src2));\n+    assert!(src1.exists());\n+    assert!(src2.exists());\n     assert!(is_read_only(&src1));\n     assert!(is_read_only(&src2));\n }\n@@ -2201,7 +2188,7 @@ fn test_installed_local_changes() {\n     debug!(\"repo = {}\", repo.display());\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n     debug!(\"repo_subdir = {}\", repo_subdir.display());\n-    assert!(os::mkdir_recursive(&repo.join_many([\".rust\", \"src\"]), U_RWX));\n+    fs::mkdir_recursive(&repo.join_many([\".rust\", \"src\"]), io::UserRWX);\n \n     writeFile(&repo_subdir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n@@ -2284,7 +2271,7 @@ fn find_sources_in_cwd() {\n     let temp_dir = TempDir::new(\"sources\").expect(\"find_sources_in_cwd failed\");\n     let temp_dir = temp_dir.path();\n     let source_dir = temp_dir.join(\"foo\");\n-    os::mkdir_recursive(&source_dir, U_RWX);\n+    fs::mkdir_recursive(&source_dir, io::UserRWX);\n     writeFile(&source_dir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n     command_line_test([~\"install\", ~\"foo\"], &source_dir);\n@@ -2307,16 +2294,13 @@ fn test_c_dependency_ok() {\n     debug!(\"dir = {}\", dir.display());\n     let source = Path::new(file!()).dir_path().join_many(\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n-    if !os::copy_file(&source,\n-                      &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"])) {\n-        fail!(\"Couldn't copy file\");\n-    }\n+    fs::copy(&source, &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]));\n     command_line_test([~\"build\", ~\"cdep\"], dir);\n     assert_executable_exists(dir, \"cdep\");\n     let out_dir = target_build_dir(dir).join(\"cdep\");\n     let c_library_path = out_dir.join(platform_library_name(\"foo\"));\n     debug!(\"c library path: {}\", c_library_path.display());\n-    assert!(os::path_exists(&c_library_path));\n+    assert!(c_library_path.exists());\n }\n \n #[test]\n@@ -2331,16 +2315,13 @@ fn test_c_dependency_no_rebuilding() {\n     debug!(\"dir = {}\", dir.display());\n     let source = Path::new(file!()).dir_path().join_many(\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n-    if !os::copy_file(&source,\n-                      &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"])) {\n-        fail!(\"Couldn't copy file\");\n-    }\n+    fs::copy(&source, &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]));\n     command_line_test([~\"build\", ~\"cdep\"], dir);\n     assert_executable_exists(dir, \"cdep\");\n     let out_dir = target_build_dir(dir).join(\"cdep\");\n     let c_library_path = out_dir.join(platform_library_name(\"foo\"));\n     debug!(\"c library path: {}\", c_library_path.display());\n-    assert!(os::path_exists(&c_library_path));\n+    assert!(c_library_path.exists());\n \n     // Now, make it read-only so rebuilding will fail\n     assert!(chmod_read_only(&c_library_path));\n@@ -2367,15 +2348,13 @@ fn test_c_dependency_yes_rebuilding() {\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n     let target = dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]);\n     debug!(\"Copying {} -> {}\", source.display(), target.display());\n-    if !os::copy_file(&source, &target) {\n-        fail!(\"Couldn't copy file\");\n-    }\n+    fs::copy(&source, &target);\n     command_line_test([~\"build\", ~\"cdep\"], dir);\n     assert_executable_exists(dir, \"cdep\");\n     let out_dir = target_build_dir(dir).join(\"cdep\");\n     let c_library_path = out_dir.join(platform_library_name(\"foo\"));\n     debug!(\"c library path: {}\", c_library_path.display());\n-    assert!(os::path_exists(&c_library_path));\n+    assert!(c_library_path.exists());\n \n     // Now, make the Rust library read-only so rebuilding will fail\n     match built_library_in_workspace(&PkgId::new(\"cdep\"), dir) {\n@@ -2393,10 +2372,5 @@ fn test_c_dependency_yes_rebuilding() {\n \n /// Returns true if p exists and is executable\n fn is_executable(p: &Path) -> bool {\n-    use std::libc::consts::os::posix88::{S_IXUSR};\n-\n-    match p.get_mode() {\n-        None => false,\n-        Some(mode) => mode & S_IXUSR as uint == S_IXUSR as uint\n-    }\n+    p.exists() && p.stat().perm & io::UserExecute == io::UserExecute\n }"}, {"sha": "3b233c9f6a88ac9788d1a74a4b3dad26911fb7b6", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Ffoo.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -9,4 +9,4 @@\n // except according to those terms.\n \n pub fn do_nothing() {\n-}\n\\ No newline at end of file\n+}"}, {"sha": "f5d6317e7a68f9567ef43e41025b37998bb3a671", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/pkg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -31,7 +31,7 @@ pub fn main() {\n \n     let sysroot_arg = args[1].clone();\n     let sysroot = Path::new(sysroot_arg);\n-    if !os::path_exists(&sysroot) {\n+    if !sysroot.exists() {\n         fail!(\"Package script requires a sysroot that exists; {} doesn't\", sysroot.display());\n     }\n "}, {"sha": "1c3bf897bec1d437a76641fd8deb353c3cb88a4c", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/pkg.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -12,9 +12,7 @@ extern mod rustpkg;\n extern mod rustc;\n \n use std::os;\n-use std::rt::io;\n-use std::rt::io::Writer;\n-use std::rt::io::file::FileInfo;\n+use std::rt::io::File;\n use rustpkg::api;\n use rustpkg::version::NoVersion;\n \n@@ -30,7 +28,7 @@ pub fn main() {\n \n     let sysroot_arg = args[1].clone();\n     let sysroot = Path::new(sysroot_arg);\n-    if !os::path_exists(&sysroot) {\n+    if !sysroot.exists() {\n         debug!(\"Failing, sysroot\");\n         fail!(\"Package script requires a sysroot that exists;{} doesn't\", sysroot.display());\n     }\n@@ -45,7 +43,7 @@ pub fn main() {\n     let out_path = os::self_exe_path().expect(\"Couldn't get self_exe path\");\n \n     debug!(\"Writing file\");\n-    let mut file = out_path.join(\"generated.rs\").open_writer(io::Create);\n+    let mut file = File::create(&out_path.join(\"generated.rs\"));\n     file.write(\"pub fn wheeeee() { let xs = [1, 2, 3]; \\\n                 for _ in xs.iter() { assert!(true); } }\".as_bytes());\n "}, {"sha": "ec7771c2ab5e470f1d6784ca6901cbf08387d36e", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -10,6 +10,8 @@\n \n use std::libc;\n use std::os;\n+use std::rt::io;\n+use std::rt::io::fs;\n use extra::workcache;\n use rustc::driver::{driver, session};\n use extra::getopts::groups::getopts;\n@@ -32,7 +34,6 @@ use path_util::{default_workspace, built_library_in_workspace};\n pub use target::{OutputType, Main, Lib, Bench, Test, JustOne, lib_name_of, lib_crate_filename};\n pub use target::{Target, Build, Install};\n use extra::treemap::TreeMap;\n-use path_util::U_RWX;\n pub use target::{lib_name_of, lib_crate_filename, WhatToBuild, MaybeCustom, Inferred};\n use workcache_support::{digest_file_with_date, digest_only_date};\n \n@@ -184,7 +185,7 @@ pub fn compile_input(context: &BuildContext,\n     let mut out_dir = target_build_dir(workspace);\n     out_dir.push(&pkg_id.path);\n     // Make the output directory if it doesn't exist already\n-    assert!(os::mkdir_recursive(&out_dir, U_RWX));\n+    fs::mkdir_recursive(&out_dir, io::UserRWX);\n \n     let binary = os::args()[0].to_managed();\n \n@@ -256,11 +257,11 @@ pub fn compile_input(context: &BuildContext,\n     // Make sure all the library directories actually exist, since the linker will complain\n     // otherwise\n     for p in addl_lib_search_paths.iter() {\n-        if os::path_exists(p) {\n-            assert!(os::path_is_dir(p));\n+        if p.exists() {\n+            assert!(p.is_dir())\n         }\n         else {\n-            assert!(os::mkdir_recursive(p, U_RWX));\n+            fs::mkdir_recursive(p, io::UserRWX);\n         }\n     }\n \n@@ -324,7 +325,7 @@ pub fn compile_input(context: &BuildContext,\n     };\n     for p in discovered_output.iter() {\n         debug!(\"About to discover output {}\", p.display());\n-        if os::path_exists(p) {\n+        if p.exists() {\n             debug!(\"4. discovering output {}\", p.display());\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             exec.discover_output(\"binary\", p.as_str().unwrap(), digest_only_date(p));\n@@ -629,10 +630,16 @@ fn debug_flags() -> ~[~str] { ~[] }\n \n /// Returns the last-modified date as an Option\n pub fn datestamp(p: &Path) -> Option<libc::time_t> {\n-    debug!(\"Scrutinizing datestamp for {} - does it exist? {:?}\", p.display(), os::path_exists(p));\n-    let out = p.stat().map(|stat| stat.modified);\n-    debug!(\"Date = {:?}\", out);\n-    out.map(|t| { t as libc::time_t })\n+    debug!(\"Scrutinizing datestamp for {} - does it exist? {:?}\", p.display(),\n+           p.exists());\n+    match io::result(|| p.stat()) {\n+        Ok(s) => {\n+            let out = s.modified;\n+            debug!(\"Date = {:?}\", out);\n+            Some(out as libc::time_t)\n+        }\n+        Err(*) => None,\n+    }\n }\n \n pub type DepMap = TreeMap<~str, ~[(~str, ~str)]>;"}, {"sha": "eff16cb99968c6a3e860462eba90d4eae7f45b35", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -14,7 +14,7 @@\n extern mod std;\n \n use extra::semver;\n-use std::{char, os, result, run, str};\n+use std::{char, result, run, str};\n use extra::tempfile::TempDir;\n use path_util::rust_path;\n \n@@ -100,7 +100,7 @@ pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n     for rp in rustpath.iter() {\n         let local_path = rp.join(local_path);\n         let git_dir = local_path.join(\".git\");\n-        if !os::path_is_dir(&git_dir) {\n+        if !git_dir.is_dir() {\n             continue;\n         }\n         // FIXME (#9639): This needs to handle non-utf8 paths"}, {"sha": "d8b35f2c0332a424e2764b48c98f3022a0862c14", "filename": "src/librustpkg/workcache_support.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Fworkcache_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Fworkcache_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkcache_support.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -9,32 +9,23 @@\n // except according to those terms.\n \n use std::rt::io;\n-use std::rt::io::Reader;\n-use std::rt::io::file::FileInfo;\n+use std::rt::io::File;\n use extra::workcache;\n use sha1::{Digest, Sha1};\n \n /// Hashes the file contents along with the last-modified time\n pub fn digest_file_with_date(path: &Path) -> ~str {\n     use conditions::bad_path::cond;\n-    use cond1 = conditions::bad_stat::cond;\n \n-    let mut err = None;\n-    let bytes = do io::io_error::cond.trap(|e| err = Some(e)).inside {\n-        path.open_reader(io::Open).read_to_end()\n-    };\n-    match err {\n-        None => {\n+    match io::result(|| File::open(path).read_to_end()) {\n+        Ok(bytes) => {\n             let mut sha = Sha1::new();\n             sha.input(bytes);\n-            let st = match path.stat() {\n-                Some(st) => st,\n-                None => cond1.raise((path.clone(), format!(\"Couldn't get file access time\")))\n-            };\n+            let st = path.stat();\n             sha.input_str(st.modified.to_str());\n             sha.result_str()\n         }\n-        Some(e) => {\n+        Err(e) => {\n             cond.raise((path.clone(), format!(\"Couldn't read file: {}\", e.desc)));\n             ~\"\"\n         }\n@@ -43,13 +34,8 @@ pub fn digest_file_with_date(path: &Path) -> ~str {\n \n /// Hashes only the last-modified time\n pub fn digest_only_date(path: &Path) -> ~str {\n-    use cond = conditions::bad_stat::cond;\n-\n     let mut sha = Sha1::new();\n-    let st = match path.stat() {\n-                Some(st) => st,\n-                None => cond.raise((path.clone(), format!(\"Couldn't get file access time\")))\n-    };\n+    let st = path.stat();\n     sha.input_str(st.modified.to_str());\n     sha.result_str()\n }"}, {"sha": "e65f3ce5bb6ab0b81f7a89abf7c0437e3f5c8fe9", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -52,7 +52,7 @@ pub fn pkg_parent_workspaces(cx: &Context, pkgid: &PkgId) -> ~[Path] {\n }\n \n pub fn is_workspace(p: &Path) -> bool {\n-    os::path_is_dir(&p.join(\"src\"))\n+    p.join(\"src\").is_dir()\n }\n \n /// Construct a workspace and package-ID name based on the current directory."}, {"sha": "8c9302e123815f8b3e5d9c6c2267f78ec495ae75", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 148, "deletions": 87, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -11,10 +11,9 @@\n use std::ptr::null;\n use std::c_str;\n use std::c_str::CString;\n-use std::libc::c_void;\n use std::cast::transmute;\n use std::libc;\n-use std::libc::{c_int};\n+use std::libc::{c_int, c_char, c_void};\n \n use super::{Request, NativeHandle, Loop, FsCallback, Buf,\n             status_to_maybe_uv_error, UvError};\n@@ -49,61 +48,56 @@ impl FsRequest {\n         assert_eq!(ret, 0);\n     }\n \n-    pub fn open_sync(self, loop_: &Loop, path: &CString,\n+    pub fn open_sync(mut self, loop_: &Loop, path: &CString,\n                      flags: int, mode: int) -> Result<c_int, UvError> {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(None)\n-        };\n+        let complete_cb_ptr = self.req_boilerplate(None);\n         let result = path.with_ref(|p| unsafe {\n             uvll::fs_open(loop_.native_handle(),\n                     self.native_handle(), p, flags, mode, complete_cb_ptr)\n         });\n         self.sync_cleanup(result)\n     }\n \n-    pub fn unlink(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n+    pub fn unlink(mut self, loop_: &Loop, path: &CString, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n         let ret = path.with_ref(|p| unsafe {\n             uvll::fs_unlink(loop_.native_handle(),\n                           self.native_handle(), p, complete_cb_ptr)\n         });\n         assert_eq!(ret, 0);\n     }\n \n-    pub fn unlink_sync(self, loop_: &Loop, path: &CString)\n+    pub fn unlink_sync(mut self, loop_: &Loop, path: &CString)\n       -> Result<c_int, UvError> {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(None)\n-        };\n+        let complete_cb_ptr = self.req_boilerplate(None);\n         let result = path.with_ref(|p| unsafe {\n             uvll::fs_unlink(loop_.native_handle(),\n                           self.native_handle(), p, complete_cb_ptr)\n         });\n         self.sync_cleanup(result)\n     }\n \n-    pub fn stat(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n+    pub fn lstat(mut self, loop_: &Loop, path: &CString, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        let ret = path.with_ref(|p| unsafe {\n+            uvll::uv_fs_lstat(loop_.native_handle(),\n+                              self.native_handle(), p, complete_cb_ptr)\n+        });\n+        assert_eq!(ret, 0);\n+    }\n+\n+    pub fn stat(mut self, loop_: &Loop, path: &CString, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n         let ret = path.with_ref(|p| unsafe {\n             uvll::fs_stat(loop_.native_handle(),\n                           self.native_handle(), p, complete_cb_ptr)\n         });\n         assert_eq!(ret, 0);\n     }\n \n-    pub fn write(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n+    pub fn write(mut self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64,\n+                 cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n         let base_ptr = buf.base as *c_void;\n         let len = buf.len as uint;\n         let ret = unsafe {\n@@ -113,12 +107,9 @@ impl FsRequest {\n         };\n         assert_eq!(ret, 0);\n     }\n-    pub fn write_sync(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n+    pub fn write_sync(mut self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n           -> Result<c_int, UvError> {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(None)\n-        };\n+        let complete_cb_ptr = self.req_boilerplate(None);\n         let base_ptr = buf.base as *c_void;\n         let len = buf.len as uint;\n         let result = unsafe {\n@@ -129,11 +120,9 @@ impl FsRequest {\n         self.sync_cleanup(result)\n     }\n \n-    pub fn read(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n+    pub fn read(mut self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64,\n+                cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n         let buf_ptr = buf.base as *c_void;\n         let len = buf.len as uint;\n         let ret = unsafe {\n@@ -143,12 +132,9 @@ impl FsRequest {\n         };\n         assert_eq!(ret, 0);\n     }\n-    pub fn read_sync(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n+    pub fn read_sync(mut self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n           -> Result<c_int, UvError> {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(None)\n-        };\n+        let complete_cb_ptr = self.req_boilerplate(None);\n         let buf_ptr = buf.base as *c_void;\n         let len = buf.len as uint;\n         let result = unsafe {\n@@ -159,64 +145,137 @@ impl FsRequest {\n         self.sync_cleanup(result)\n     }\n \n-    pub fn close(self, loop_: &Loop, fd: c_int, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = unsafe {\n+    pub fn close(mut self, loop_: &Loop, fd: c_int, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(unsafe {\n             uvll::fs_close(loop_.native_handle(), self.native_handle(),\n                            fd, complete_cb_ptr)\n-        };\n-        assert_eq!(ret, 0);\n+        }, 0);\n     }\n-    pub fn close_sync(self, loop_: &Loop, fd: c_int) -> Result<c_int, UvError> {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(None)\n-        };\n+    pub fn close_sync(mut self, loop_: &Loop,\n+                      fd: c_int) -> Result<c_int, UvError> {\n+        let complete_cb_ptr = self.req_boilerplate(None);\n         let result = unsafe {\n             uvll::fs_close(loop_.native_handle(), self.native_handle(),\n                            fd, complete_cb_ptr)\n         };\n         self.sync_cleanup(result)\n     }\n \n-    pub fn mkdir(self, loop_: &Loop, path: &CString, mode: int, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = path.with_ref(|p| unsafe {\n+    pub fn mkdir(mut self, loop_: &Loop, path: &CString, mode: c_int,\n+                 cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(path.with_ref(|p| unsafe {\n             uvll::fs_mkdir(loop_.native_handle(),\n                            self.native_handle(), p, mode, complete_cb_ptr)\n-        });\n-        assert_eq!(ret, 0);\n+        }), 0);\n     }\n \n-    pub fn rmdir(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = path.with_ref(|p| unsafe {\n+    pub fn rmdir(mut self, loop_: &Loop, path: &CString, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(path.with_ref(|p| unsafe {\n             uvll::fs_rmdir(loop_.native_handle(),\n                            self.native_handle(), p, complete_cb_ptr)\n-        });\n-        assert_eq!(ret, 0);\n+        }), 0);\n+    }\n+\n+    pub fn rename(mut self, loop_: &Loop, path: &CString, to: &CString,\n+                  cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(unsafe {\n+            uvll::fs_rename(loop_.native_handle(),\n+                            self.native_handle(),\n+                            path.with_ref(|p| p),\n+                            to.with_ref(|p| p),\n+                            complete_cb_ptr)\n+        }, 0);\n+    }\n+\n+    pub fn chmod(mut self, loop_: &Loop, path: &CString, mode: c_int,\n+                 cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(path.with_ref(|p| unsafe {\n+            uvll::fs_chmod(loop_.native_handle(), self.native_handle(), p, mode,\n+                           complete_cb_ptr)\n+        }), 0);\n     }\n \n-    pub fn readdir(self, loop_: &Loop, path: &CString,\n+    pub fn readdir(mut self, loop_: &Loop, path: &CString,\n                    flags: c_int, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = path.with_ref(|p| unsafe {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(path.with_ref(|p| unsafe {\n             uvll::fs_readdir(loop_.native_handle(),\n                              self.native_handle(), p, flags, complete_cb_ptr)\n-        });\n-        assert_eq!(ret, 0);\n+        }), 0);\n+    }\n+\n+    pub fn readlink(mut self, loop_: &Loop, path: &CString, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(path.with_ref(|p| unsafe {\n+            uvll::uv_fs_readlink(loop_.native_handle(),\n+                                 self.native_handle(), p, complete_cb_ptr)\n+        }), 0);\n+    }\n+\n+    pub fn chown(mut self, loop_: &Loop, path: &CString, uid: int, gid: int,\n+                 cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(path.with_ref(|p| unsafe {\n+            uvll::uv_fs_chown(loop_.native_handle(),\n+                              self.native_handle(), p,\n+                              uid as uvll::uv_uid_t,\n+                              gid as uvll::uv_gid_t,\n+                              complete_cb_ptr)\n+        }), 0);\n+    }\n+\n+    pub fn truncate(mut self, loop_: &Loop, file: c_int, offset: i64,\n+                    cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(unsafe {\n+            uvll::uv_fs_ftruncate(loop_.native_handle(),\n+                                  self.native_handle(), file, offset,\n+                                  complete_cb_ptr)\n+        }, 0);\n+    }\n+\n+    pub fn link(mut self, loop_: &Loop, src: &CString, dst: &CString,\n+                cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(unsafe {\n+            uvll::uv_fs_link(loop_.native_handle(), self.native_handle(),\n+                             src.with_ref(|p| p),\n+                             dst.with_ref(|p| p),\n+                             complete_cb_ptr)\n+        }, 0);\n+    }\n+\n+    pub fn symlink(mut self, loop_: &Loop, src: &CString, dst: &CString,\n+                   cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(unsafe {\n+            uvll::uv_fs_symlink(loop_.native_handle(), self.native_handle(),\n+                                src.with_ref(|p| p),\n+                                dst.with_ref(|p| p),\n+                                0,\n+                                complete_cb_ptr)\n+        }, 0);\n+    }\n+\n+    pub fn fsync(mut self, loop_: &Loop, fd: c_int, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(unsafe {\n+            uvll::uv_fs_fsync(loop_.native_handle(), self.native_handle(), fd,\n+                              complete_cb_ptr)\n+        }, 0);\n+    }\n+\n+    pub fn datasync(mut self, loop_: &Loop, fd: c_int, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(unsafe {\n+            uvll::uv_fs_fdatasync(loop_.native_handle(), self.native_handle(), fd,\n+                                  complete_cb_ptr)\n+        }, 0);\n     }\n \n     // accessors/utility funcs\n@@ -257,10 +316,12 @@ impl FsRequest {\n         }\n     }\n \n-    pub fn get_result(&mut self) -> c_int {\n-        unsafe {\n-            uvll::get_result_from_fs_req(self.native_handle())\n-        }\n+    pub fn get_path(&self) -> *c_char {\n+        unsafe { uvll::get_path_from_fs_req(self.native_handle()) }\n+    }\n+\n+    pub fn get_result(&self) -> c_int {\n+        unsafe { uvll::get_result_from_fs_req(self.native_handle()) }\n     }\n \n     pub fn get_loop(&self) -> Loop {\n@@ -353,7 +414,7 @@ extern fn compl_cb(req: *uv_fs_t) {\n mod test {\n     use super::*;\n     //use std::rt::test::*;\n-    use std::libc::{STDOUT_FILENO};\n+    use std::libc::{STDOUT_FILENO, c_int};\n     use std::vec;\n     use std::str;\n     use std::unstable::run_in_bare_thread;\n@@ -578,7 +639,7 @@ mod test {\n                 S_IRUSR;\n             let mkdir_req = FsRequest::new();\n             do mkdir_req.mkdir(&loop_, &path.to_c_str(),\n-                               mode as int) |req,uverr| {\n+                               mode as c_int) |req,uverr| {\n                 assert!(uverr.is_none());\n                 let loop_ = req.get_loop();\n                 let stat_req = FsRequest::new();\n@@ -611,12 +672,12 @@ mod test {\n             let mode = S_IWUSR |\n                 S_IRUSR;\n             let mkdir_req = FsRequest::new();\n-            do mkdir_req.mkdir(&loop_, &path.to_c_str(), mode as int) |req,uverr| {\n+            do mkdir_req.mkdir(&loop_, &path.to_c_str(), mode as c_int) |req,uverr| {\n                 assert!(uverr.is_none());\n                 let loop_ = req.get_loop();\n                 let mkdir_req = FsRequest::new();\n                 do mkdir_req.mkdir(&loop_, &path.to_c_str(),\n-                                   mode as int) |req,uverr| {\n+                                   mode as c_int) |req,uverr| {\n                     assert!(uverr.is_some());\n                     let loop_ = req.get_loop();\n                     let _stat = req.get_stat();"}, {"sha": "15d5fe702a536b0d1069a9017ee462bbe2d91840", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 192, "deletions": 155, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -8,18 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::c_str::{ToCStr, CString};\n+use std::c_str::CString;\n use std::cast::transmute;\n use std::cast;\n use std::cell::Cell;\n-use std::clone::Clone;\n use std::comm::{SendDeferred, SharedChan, Port, PortOne, GenericChan};\n+use std::libc;\n use std::libc::{c_int, c_uint, c_void, pid_t};\n-use std::ops::Drop;\n-use std::option::*;\n use std::ptr;\n use std::str;\n-use std::result::*;\n+use std::rt::io;\n use std::rt::io::IoError;\n use std::rt::io::net::ip::{SocketAddr, IpAddr};\n use std::rt::io::{standard_error, OtherIoError, SeekStyle, SeekSet, SeekCur,\n@@ -32,22 +30,16 @@ use std::rt::sched::{Scheduler, SchedHandle};\n use std::rt::tube::Tube;\n use std::rt::task::Task;\n use std::unstable::sync::Exclusive;\n-use std::path::{GenericPath, Path};\n-use std::libc::{lseek, off_t, O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY,\n-                O_WRONLY, S_IRUSR, S_IWUSR, S_IRWXU};\n-use std::rt::io::{FileMode, FileAccess, OpenOrCreate, Open, Create,\n-                  CreateOrTruncate, Append, Truncate, Read, Write, ReadWrite,\n-                  FileStat};\n+use std::libc::{lseek, off_t};\n+use std::rt::io::{FileMode, FileAccess, FileStat};\n use std::rt::io::signal::Signum;\n use std::task;\n use ai = std::rt::io::net::addrinfo;\n \n-#[cfg(test)] use std::container::Container;\n #[cfg(test)] use std::unstable::run_in_bare_thread;\n #[cfg(test)] use std::rt::test::{spawntask,\n                                  next_test_ip4,\n                                  run_in_mt_newsched_task};\n-#[cfg(test)] use std::iter::{Iterator, range};\n #[cfg(test)] use std::rt::comm::oneshot;\n \n use super::*;\n@@ -417,24 +409,25 @@ impl UvIoFactory {\n     }\n }\n \n-/// Helper for a variety of simple uv_fs_* functions that\n-/// have no ret val\n-fn uv_fs_helper(loop_: &mut Loop, path: &CString,\n-                cb: ~fn(&mut FsRequest, &mut Loop, &CString,\n-                        ~fn(&FsRequest, Option<UvError>)))\n-        -> Result<(), IoError> {\n+/// Helper for a variety of simple uv_fs_* functions that have no ret val. This\n+/// function takes the loop that it will act on, and then invokes the specified\n+/// callback in a situation where the task wil be immediately blocked\n+/// afterwards. The `FsCallback` yielded must be invoked to reschedule the task\n+/// (once the result of the operation is known).\n+fn uv_fs_helper<T>(loop_: &mut Loop,\n+                   retfn: extern \"Rust\" fn(&mut FsRequest) -> T,\n+                   cb: &fn(&mut FsRequest, &mut Loop, FsCallback))\n+        -> Result<T, IoError> {\n     let result_cell = Cell::new_empty();\n-    let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-    let path_cell = Cell::new(path);\n+    let result_cell_ptr: *Cell<Result<T, IoError>> = &result_cell;\n     do task::unkillable { // FIXME(#8674)\n         let scheduler: ~Scheduler = Local::take();\n         let mut new_req = FsRequest::new();\n         do scheduler.deschedule_running_task_and_then |_, task| {\n             let task_cell = Cell::new(task);\n-            let path = path_cell.take();\n-            do cb(&mut new_req, loop_, path) |_, err| {\n+            do cb(&mut new_req, loop_) |req, err| {\n                 let res = match err {\n-                    None => Ok(()),\n+                    None => Ok(retfn(req)),\n                     Some(err) => Err(uv_error_to_io_error(err))\n                 };\n                 unsafe { (*result_cell_ptr).put_back(res); }\n@@ -447,6 +440,45 @@ fn uv_fs_helper(loop_: &mut Loop, path: &CString,\n     return result_cell.take();\n }\n \n+fn unit(_: &mut FsRequest) {}\n+\n+fn fs_mkstat(f: &mut FsRequest) -> FileStat {\n+    let path = unsafe { Path::new(CString::new(f.get_path(), false)) };\n+    let stat = f.get_stat();\n+    fn to_msec(stat: uvll::uv_timespec_t) -> u64 {\n+        (stat.tv_sec * 1000 + stat.tv_nsec / 1000000) as u64\n+    }\n+    let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n+        libc::S_IFREG => io::TypeFile,\n+        libc::S_IFDIR => io::TypeDirectory,\n+        libc::S_IFIFO => io::TypeNamedPipe,\n+        libc::S_IFBLK => io::TypeBlockSpecial,\n+        libc::S_IFLNK => io::TypeSymlink,\n+        _ => io::TypeUnknown,\n+    };\n+    FileStat {\n+        path: path,\n+        size: stat.st_size as u64,\n+        kind: kind,\n+        perm: (stat.st_mode as io::FilePermission) & io::AllPermissions,\n+        created: to_msec(stat.st_birthtim),\n+        modified: to_msec(stat.st_mtim),\n+        accessed: to_msec(stat.st_atim),\n+        unstable: io::UnstableFileStat {\n+            device: stat.st_dev as u64,\n+            inode: stat.st_ino as u64,\n+            rdev: stat.st_rdev as u64,\n+            nlink: stat.st_nlink as u64,\n+            uid: stat.st_uid as u64,\n+            gid: stat.st_gid as u64,\n+            blksize: stat.st_blksize as u64,\n+            blocks: stat.st_blocks as u64,\n+            flags: stat.st_flags as u64,\n+            gen: stat.st_gen as u64,\n+        }\n+    }\n+}\n+\n impl IoFactory for UvIoFactory {\n     // Connect to an address and return a new stream\n     // NB: This blocks the task waiting on the connection.\n@@ -551,6 +583,41 @@ impl IoFactory for UvIoFactory {\n         Ok(~UvTimer::new(watcher, home) as ~RtioTimer)\n     }\n \n+    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n+                          hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError> {\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<~[ai::Info], IoError>> = &result_cell;\n+        let host_ptr: *Option<&str> = &host;\n+        let servname_ptr: *Option<&str> = &servname;\n+        let hint_ptr: *Option<ai::Hint> = &hint;\n+        let addrinfo_req = GetAddrInfoRequest::new();\n+        let addrinfo_req_cell = Cell::new(addrinfo_req);\n+\n+        do task::unkillable { // FIXME(#8674)\n+            let scheduler: ~Scheduler = Local::take();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                let mut addrinfo_req = addrinfo_req_cell.take();\n+                unsafe {\n+                    do addrinfo_req.getaddrinfo(self.uv_loop(),\n+                                                *host_ptr, *servname_ptr,\n+                                                *hint_ptr) |_, addrinfo, err| {\n+                        let res = match err {\n+                            None => Ok(accum_addrinfo(addrinfo)),\n+                            Some(err) => Err(uv_error_to_io_error(err))\n+                        };\n+                        (*result_cell_ptr).put_back(res);\n+                        let scheduler: ~Scheduler = Local::take();\n+                        scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    }\n+                }\n+            }\n+        }\n+        addrinfo_req.delete();\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+\n     fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior) -> ~RtioFileStream {\n         let loop_ = Loop {handle: self.uv_loop().native_handle()};\n         let home = get_handle_to_current_scheduler!();\n@@ -559,35 +626,28 @@ impl IoFactory for UvIoFactory {\n \n     fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n         -> Result<~RtioFileStream, IoError> {\n-        let mut flags = match fm {\n-            Open => 0,\n-            Create => O_CREAT,\n-            OpenOrCreate => O_CREAT,\n-            Append => O_APPEND,\n-            Truncate => O_TRUNC,\n-            CreateOrTruncate => O_TRUNC | O_CREAT\n-        };\n-        flags = match fa {\n-            Read => flags | O_RDONLY,\n-            Write => flags | O_WRONLY,\n-            ReadWrite => flags | O_RDWR\n+        let flags = match fm {\n+            io::Open => 0,\n+            io::Append => libc::O_APPEND,\n+            io::Truncate => libc::O_TRUNC,\n         };\n-        let create_mode = match fm {\n-            Create|OpenOrCreate|CreateOrTruncate =>\n-                S_IRUSR | S_IWUSR,\n-            _ => 0\n+        // Opening with a write permission must silently create the file.\n+        let (flags, mode) = match fa {\n+            io::Read => (flags | libc::O_RDONLY, 0),\n+            io::Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n+                          libc::S_IRUSR | libc::S_IWUSR),\n+            io::ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n+                              libc::S_IRUSR | libc::S_IWUSR),\n         };\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<~RtioFileStream,\n                                            IoError>> = &result_cell;\n-        let path_cell = Cell::new(path);\n         do task::unkillable { // FIXME(#8674)\n             let scheduler: ~Scheduler = Local::take();\n             let open_req = file::FsRequest::new();\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n-                let path = path_cell.take();\n-                do open_req.open(self.uv_loop(), path, flags as int, create_mode as int)\n+                do open_req.open(self.uv_loop(), path, flags as int, mode as int)\n                       |req,err| {\n                     if err.is_none() {\n                         let loop_ = Loop {handle: req.get_loop().native_handle()};\n@@ -613,105 +673,40 @@ impl IoFactory for UvIoFactory {\n     }\n \n     fn fs_unlink(&mut self, path: &CString) -> Result<(), IoError> {\n-        do uv_fs_helper(self.uv_loop(), path) |unlink_req, l, p, cb| {\n-            do unlink_req.unlink(l, p) |req, err| {\n-                cb(req, err)\n-            };\n+        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n+            req.unlink(l, path, cb)\n         }\n     }\n-    fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError> {\n-        use str::StrSlice;\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<FileStat,\n-                                           IoError>> = &result_cell;\n-        let path_cell = Cell::new(path);\n-        do task::unkillable { // FIXME(#8674)\n-            let scheduler: ~Scheduler = Local::take();\n-            let stat_req = file::FsRequest::new();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                let path = path_cell.take();\n-                // Don't pick up the null byte\n-                let slice = path.as_bytes().slice(0, path.len());\n-                let path_instance = Cell::new(Path::new(slice));\n-                do stat_req.stat(self.uv_loop(), path) |req,err| {\n-                    let res = match err {\n-                        None => {\n-                            let stat = req.get_stat();\n-                            Ok(FileStat {\n-                                path: path_instance.take(),\n-                                is_file: stat.is_file(),\n-                                is_dir: stat.is_dir(),\n-                                device: stat.st_dev,\n-                                mode: stat.st_mode,\n-                                inode: stat.st_ino,\n-                                size: stat.st_size,\n-                                created: stat.st_ctim.tv_sec as u64,\n-                                modified: stat.st_mtim.tv_sec as u64,\n-                                accessed: stat.st_atim.tv_sec as u64\n-                            })\n-                        },\n-                        Some(e) => {\n-                            Err(uv_error_to_io_error(e))\n-                        }\n-                    };\n-                    unsafe { (*result_cell_ptr).put_back(res); }\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                };\n-            };\n-        };\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n+    fn fs_lstat(&mut self, path: &CString) -> Result<FileStat, IoError> {\n+        do uv_fs_helper(self.uv_loop(), fs_mkstat) |req, l, cb| {\n+            req.lstat(l, path, cb)\n+        }\n     }\n-\n-    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<~[ai::Info], IoError>> = &result_cell;\n-        let host_ptr: *Option<&str> = &host;\n-        let servname_ptr: *Option<&str> = &servname;\n-        let hint_ptr: *Option<ai::Hint> = &hint;\n-        let addrinfo_req = GetAddrInfoRequest::new();\n-        let addrinfo_req_cell = Cell::new(addrinfo_req);\n-\n-        do task::unkillable { // FIXME(#8674)\n-            let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                let mut addrinfo_req = addrinfo_req_cell.take();\n-                unsafe {\n-                    do addrinfo_req.getaddrinfo(self.uv_loop(),\n-                                                *host_ptr, *servname_ptr,\n-                                                *hint_ptr) |_, addrinfo, err| {\n-                        let res = match err {\n-                            None => Ok(accum_addrinfo(addrinfo)),\n-                            Some(err) => Err(uv_error_to_io_error(err))\n-                        };\n-                        (*result_cell_ptr).put_back(res);\n-                        let scheduler: ~Scheduler = Local::take();\n-                        scheduler.resume_blocked_task_immediately(task_cell.take());\n-                    }\n-                }\n-            }\n+    fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError> {\n+        do uv_fs_helper(self.uv_loop(), fs_mkstat) |req, l, cb| {\n+            req.stat(l, path, cb)\n         }\n-        addrinfo_req.delete();\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n     }\n-    fn fs_mkdir(&mut self, path: &CString) -> Result<(), IoError> {\n-        let mode = S_IRWXU as int;\n-        do uv_fs_helper(self.uv_loop(), path) |mkdir_req, l, p, cb| {\n-            do mkdir_req.mkdir(l, p, mode as int) |req, err| {\n-                cb(req, err)\n-            };\n+    fn fs_mkdir(&mut self, path: &CString,\n+                perm: io::FilePermission) -> Result<(), IoError> {\n+        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n+            req.mkdir(l, path, perm as c_int, cb)\n         }\n     }\n     fn fs_rmdir(&mut self, path: &CString) -> Result<(), IoError> {\n-        do uv_fs_helper(self.uv_loop(), path) |rmdir_req, l, p, cb| {\n-            do rmdir_req.rmdir(l, p) |req, err| {\n-                cb(req, err)\n-            };\n+        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n+            req.rmdir(l, path, cb)\n+        }\n+    }\n+    fn fs_rename(&mut self, path: &CString, to: &CString) -> Result<(), IoError> {\n+        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n+            req.rename(l, path, to, cb)\n+        }\n+    }\n+    fn fs_chmod(&mut self, path: &CString,\n+                perm: io::FilePermission) -> Result<(), IoError> {\n+        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n+            req.chmod(l, path, perm as c_int, cb)\n         }\n     }\n     fn fs_readdir(&mut self, path: &CString, flags: c_int) ->\n@@ -754,6 +749,29 @@ impl IoFactory for UvIoFactory {\n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n+    fn fs_link(&mut self, src: &CString, dst: &CString) -> Result<(), IoError> {\n+        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n+            req.link(l, src, dst, cb)\n+        }\n+    }\n+    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> Result<(), IoError> {\n+        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n+            req.symlink(l, src, dst, cb)\n+        }\n+    }\n+    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) -> Result<(), IoError> {\n+        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n+            req.chown(l, path, uid, gid, cb)\n+        }\n+    }\n+    fn fs_readlink(&mut self, path: &CString) -> Result<Path, IoError> {\n+        fn getlink(f: &mut FsRequest) -> Path {\n+            Path::new(unsafe { CString::new(f.get_ptr() as *libc::c_char, false) })\n+        }\n+        do uv_fs_helper(self.uv_loop(), getlink) |req, l, cb| {\n+            req.readlink(l, path, cb)\n+        }\n+    }\n \n     fn spawn(&mut self, config: ProcessConfig)\n             -> Result<(~RtioProcess, ~[Option<~RtioPipe>]), IoError>\n@@ -1562,26 +1580,9 @@ impl UvFileStream {\n         result_cell.take()\n     }\n     fn base_write(&mut self, buf: &[u8], offset: i64) -> Result<(), IoError> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-        let buf_ptr: *&[u8] = &buf;\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-                let task_cell = Cell::new(task);\n-                let write_req = file::FsRequest::new();\n-                do write_req.write(&self_.loop_, self_.fd, buf, offset) |_, uverr| {\n-                    let res = match uverr  {\n-                        None => Ok(()),\n-                        Some(err) => Err(uv_error_to_io_error(err))\n-                    };\n-                    unsafe { (*result_cell_ptr).put_back(res); }\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n-            }\n+        do self.nop_req |self_, req, cb| {\n+            req.write(&self_.loop_, self_.fd, slice_to_uv_buf(buf), offset, cb)\n         }\n-        result_cell.take()\n     }\n     fn seek_common(&mut self, pos: i64, whence: c_int) ->\n         Result<u64, IoError>{\n@@ -1599,6 +1600,27 @@ impl UvFileStream {\n             }\n         }\n     }\n+    fn nop_req(&mut self, f: &fn(&mut UvFileStream, file::FsRequest, FsCallback))\n+            -> Result<(), IoError> {\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+        do self.home_for_io_with_sched |self_, sched| {\n+            do sched.deschedule_running_task_and_then |_, task| {\n+                let task = Cell::new(task);\n+                let req = file::FsRequest::new();\n+                do f(self_, req) |_, uverr| {\n+                    let res = match uverr  {\n+                        None => Ok(()),\n+                        Some(err) => Err(uv_error_to_io_error(err))\n+                    };\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task.take());\n+                }\n+            }\n+        }\n+        result_cell.take()\n+    }\n }\n \n impl Drop for UvFileStream {\n@@ -1653,6 +1675,21 @@ impl RtioFileStream for UvFileStream {\n         let self_ = unsafe { cast::transmute::<&UvFileStream, &mut UvFileStream>(self) };\n         self_.seek_common(0, SEEK_CUR)\n     }\n+    fn fsync(&mut self) -> Result<(), IoError> {\n+        do self.nop_req |self_, req, cb| {\n+            req.fsync(&self_.loop_, self_.fd, cb)\n+        }\n+    }\n+    fn datasync(&mut self) -> Result<(), IoError> {\n+        do self.nop_req |self_, req, cb| {\n+            req.datasync(&self_.loop_, self_.fd, cb)\n+        }\n+    }\n+    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n+        do self.nop_req |self_, req, cb| {\n+            req.truncate(&self_.loop_, self_.fd, offset, cb)\n+        }\n+    }\n }\n \n pub struct UvProcess {\n@@ -2470,13 +2507,13 @@ fn test_timer_sleep_simple() {\n }\n \n fn file_test_uvio_full_simple_impl() {\n-    use std::rt::io::{Open, Create, ReadWrite, Read};\n+    use std::rt::io::{Open, ReadWrite, Read};\n     unsafe {\n         let io = local_io();\n         let write_val = \"hello uvio!\";\n         let path = \"./tmp/file_test_uvio_full.txt\";\n         {\n-            let create_fm = Create;\n+            let create_fm = Open;\n             let create_fa = ReadWrite;\n             let mut fd = io.fs_open(&path.to_c_str(), create_fm, create_fa).unwrap();\n             let write_buf = write_val.as_bytes();"}, {"sha": "2d850383766f5ace35d22e32364e844b7a7982a8", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -222,6 +222,7 @@ pub type uv_exit_cb = extern \"C\" fn(handle: *uv_process_t,\n                                     term_signal: c_int);\n pub type uv_signal_cb = extern \"C\" fn(handle: *uv_signal_t,\n                                       signum: c_int);\n+pub type uv_fs_cb = extern \"C\" fn(req: *uv_fs_t);\n \n pub type sockaddr = c_void;\n pub type sockaddr_in = c_void;\n@@ -795,8 +796,8 @@ pub unsafe fn fs_fstat(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int, cb: *u8)\n \n     rust_uv_fs_fstat(loop_ptr, req, fd, cb)\n }\n-pub unsafe fn fs_mkdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char, mode: int,\n-                cb: *u8) -> c_int {\n+pub unsafe fn fs_mkdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                       mode: c_int, cb: *u8) -> c_int {\n     #[fixed_stack_segment]; #[inline(never)];\n \n     rust_uv_fs_mkdir(loop_ptr, req, path, mode as c_int, cb)\n@@ -807,6 +808,18 @@ pub unsafe fn fs_rmdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n \n     rust_uv_fs_rmdir(loop_ptr, req, path, cb)\n }\n+pub unsafe fn fs_rename(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                        to: *c_char, cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_rename(loop_ptr, req, path, to, cb)\n+}\n+pub unsafe fn fs_chmod(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                       mode: c_int, cb: *u8) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_fs_chmod(loop_ptr, req, path, mode as c_int, cb)\n+}\n pub unsafe fn fs_readdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n                 flags: c_int, cb: *u8) -> c_int {\n     #[fixed_stack_segment]; #[inline(never)];\n@@ -874,6 +887,11 @@ pub unsafe fn get_ptr_from_fs_req(req: *uv_fs_t) -> *libc::c_void {\n \n     rust_uv_get_ptr_from_fs_req(req)\n }\n+pub unsafe fn get_path_from_fs_req(req: *uv_fs_t) -> *c_char {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_get_path_from_fs_req(req)\n+}\n pub unsafe fn get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t {\n     #[fixed_stack_segment]; #[inline(never)];\n \n@@ -1107,12 +1125,17 @@ extern {\n                         mode: c_int, cb: *u8) -> c_int;\n     fn rust_uv_fs_rmdir(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n                         cb: *u8) -> c_int;\n+    fn rust_uv_fs_rename(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n+                         to: *c_char, cb: *u8) -> c_int;\n+    fn rust_uv_fs_chmod(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n+                        mode: c_int, cb: *u8) -> c_int;\n     fn rust_uv_fs_readdir(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n                         flags: c_int, cb: *u8) -> c_int;\n     fn rust_uv_fs_req_cleanup(req: *uv_fs_t);\n     fn rust_uv_populate_uv_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t);\n     fn rust_uv_get_result_from_fs_req(req: *uv_fs_t) -> c_int;\n     fn rust_uv_get_ptr_from_fs_req(req: *uv_fs_t) -> *libc::c_void;\n+    fn rust_uv_get_path_from_fs_req(req: *uv_fs_t) -> *c_char;\n     fn rust_uv_get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t;\n     fn rust_uv_get_loop_from_getaddrinfo_req(req: *uv_fs_t) -> *uv_loop_t;\n \n@@ -1173,7 +1196,24 @@ extern {\n                             signal_cb: uv_signal_cb,\n                             signum: c_int) -> c_int;\n     fn rust_uv_signal_stop(handle: *uv_signal_t) -> c_int;\n+\n }\n+externfn!(fn uv_fs_fsync(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n+                         cb: *u8) -> c_int)\n+externfn!(fn uv_fs_fdatasync(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n+                             cb: *u8) -> c_int)\n+externfn!(fn uv_fs_ftruncate(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n+                             offset: i64, cb: *u8) -> c_int)\n+externfn!(fn uv_fs_readlink(handle: *uv_loop_t, req: *uv_fs_t, file: *c_char,\n+                            cb: *u8) -> c_int)\n+externfn!(fn uv_fs_symlink(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n+                           dst: *c_char, flags: c_int, cb: *u8) -> c_int)\n+externfn!(fn uv_fs_link(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n+                        dst: *c_char, cb: *u8) -> c_int)\n+externfn!(fn uv_fs_chown(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n+                         uid: uv_uid_t, gid: uv_gid_t, cb: *u8) -> c_int)\n+externfn!(fn uv_fs_lstat(handle: *uv_loop_t, req: *uv_fs_t, file: *c_char,\n+                         cb: *u8) -> c_int)\n \n // libuv requires various system libraries to successfully link on some\n // platforms"}, {"sha": "7f91c5e4f9054e88e1534cb48c1dd6fb132451e6", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -317,8 +317,11 @@ impl Zero for bool {\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n-    use prelude::*;\n+    use cmp::{Equal, Greater, Less, Eq, TotalOrd};\n+    use ops::{BitAnd, BitXor, BitOr};\n+    use from_str::{FromStr, from_str};\n+    use option::{Some, None};\n+    use super::all_values;\n \n     #[test]\n     fn test_bool() {"}, {"sha": "f992b327495b55bef2b752d2bfe99451299f94bf", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -142,7 +142,7 @@ pub use libc::consts::os::c95::{SEEK_SET, TMP_MAX};\n pub use libc::consts::os::posix88::{F_OK, O_APPEND, O_CREAT, O_EXCL};\n pub use libc::consts::os::posix88::{O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY};\n pub use libc::consts::os::posix88::{R_OK, S_IEXEC, S_IFBLK, S_IFCHR};\n-pub use libc::consts::os::posix88::{S_IFDIR, S_IFIFO, S_IFMT, S_IFREG};\n+pub use libc::consts::os::posix88::{S_IFDIR, S_IFIFO, S_IFMT, S_IFREG, S_IFLNK};\n pub use libc::consts::os::posix88::{S_IREAD, S_IRUSR, S_IRWXU, S_IWUSR};\n pub use libc::consts::os::posix88::{STDERR_FILENO, STDIN_FILENO};\n pub use libc::consts::os::posix88::{STDOUT_FILENO, W_OK, X_OK};\n@@ -1168,6 +1168,7 @@ pub mod consts {\n             pub static S_IFBLK : c_int = 12288;\n             pub static S_IFDIR : c_int = 16384;\n             pub static S_IFREG : c_int = 32768;\n+            pub static S_IFLNK : c_int = 40960;\n             pub static S_IFMT : c_int = 61440;\n             pub static S_IEXEC : c_int = 64;\n             pub static S_IWRITE : c_int = 128;\n@@ -1345,6 +1346,7 @@ pub mod consts {\n             pub static S_IFBLK : c_int = 24576;\n             pub static S_IFDIR : c_int = 16384;\n             pub static S_IFREG : c_int = 32768;\n+            pub static S_IFLNK : c_int = 40960;\n             pub static S_IFMT : c_int = 61440;\n             pub static S_IEXEC : c_int = 64;\n             pub static S_IWRITE : c_int = 128;\n@@ -1555,6 +1557,7 @@ pub mod consts {\n             pub static S_IFBLK : c_int = 24576;\n             pub static S_IFDIR : c_int = 16384;\n             pub static S_IFREG : c_int = 32768;\n+            pub static S_IFLNK : c_int = 40960;\n             pub static S_IFMT : c_int = 61440;\n             pub static S_IEXEC : c_int = 64;\n             pub static S_IWRITE : c_int = 128;\n@@ -1999,6 +2002,7 @@ pub mod consts {\n             pub static S_IFBLK : c_int = 24576;\n             pub static S_IFDIR : c_int = 16384;\n             pub static S_IFREG : c_int = 32768;\n+            pub static S_IFLNK : c_int = 40960;\n             pub static S_IFMT : c_int = 61440;\n             pub static S_IEXEC : c_int = 64;\n             pub static S_IWRITE : c_int = 128;\n@@ -2341,6 +2345,7 @@ pub mod consts {\n             pub static S_IFBLK : c_int = 24576;\n             pub static S_IFDIR : c_int = 16384;\n             pub static S_IFREG : c_int = 32768;\n+            pub static S_IFLNK : c_int = 40960;\n             pub static S_IFMT : c_int = 61440;\n             pub static S_IEXEC : c_int = 64;\n             pub static S_IWRITE : c_int = 128;"}, {"sha": "b066685f6ef640d981e8bb7039e63777fd89d384", "filename": "src/libstd/os.rs", "status": "modified", "additions": 11, "deletions": 563, "changes": 574, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -35,17 +35,14 @@ use container::Container;\n use iter::range;\n use libc;\n use libc::{c_char, c_void, c_int, size_t};\n-use libc::FILE;\n use option::{Some, None};\n use os;\n use prelude::*;\n use ptr;\n use str;\n use to_str;\n use unstable::finally::Finally;\n-use vec;\n \n-pub use libc::fclose;\n pub use os::consts::*;\n \n /// Delegates to the libc close() function, returning the same return value.\n@@ -56,28 +53,6 @@ pub fn close(fd: c_int) -> c_int {\n     }\n }\n \n-// On Windows, wide character version of function must be used to support\n-// unicode, so functions should be split into at least two versions,\n-// which are for Windows and for non-Windows, if necessary.\n-// See https://github.com/mozilla/rust/issues/9822 for more information.\n-\n-mod rustrt {\n-    use libc::{c_char, c_int};\n-    use libc;\n-\n-    extern {\n-        pub fn rust_path_is_dir(path: *libc::c_char) -> c_int;\n-        pub fn rust_path_exists(path: *libc::c_char) -> c_int;\n-    }\n-\n-    // Uses _wstat instead of stat.\n-    #[cfg(windows)]\n-    extern {\n-        pub fn rust_path_is_dir_u16(path: *u16) -> c_int;\n-        pub fn rust_path_exists_u16(path: *u16) -> c_int;\n-    }\n-}\n-\n pub static TMPBUF_SZ : uint = 1000u;\n static BUF_BYTES : uint = 2048u;\n \n@@ -348,15 +323,6 @@ pub fn unsetenv(n: &str) {\n     _unsetenv(n);\n }\n \n-pub fn fdopen(fd: c_int) -> *FILE {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    do \"r\".with_c_str |modebuf| {\n-        unsafe {\n-            libc::fdopen(fd, modebuf)\n-        }\n-    }\n-}\n-\n pub struct Pipe {\n     input: c_int,\n     out: c_int\n@@ -373,8 +339,6 @@ pub fn pipe() -> Pipe {\n     }\n }\n \n-\n-\n #[cfg(windows)]\n pub fn pipe() -> Pipe {\n     #[fixed_stack_segment]; #[inline(never)];\n@@ -417,6 +381,7 @@ pub fn self_exe_path() -> Option<Path> {\n         unsafe {\n             use libc::funcs::bsd44::*;\n             use libc::consts::os::extra::*;\n+            use vec;\n             let mib = ~[CTL_KERN as c_int,\n                         KERN_PROC as c_int,\n                         KERN_PROC_PATHNAME as c_int, -1 as c_int];\n@@ -440,23 +405,11 @@ pub fn self_exe_path() -> Option<Path> {\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n     fn load_self() -> Option<~[u8]> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        unsafe {\n-            use libc::funcs::posix01::unistd::readlink;\n-\n-            let mut path: ~[u8] = vec::with_capacity(TMPBUF_SZ);\n+        use std::rt::io;\n \n-            let len = do path.as_mut_buf |buf, _| {\n-                do \"/proc/self/exe\".with_c_str |proc_self_buf| {\n-                    readlink(proc_self_buf, buf as *mut c_char, TMPBUF_SZ as size_t) as uint\n-                }\n-            };\n-            if len == -1 {\n-                None\n-            } else {\n-                vec::raw::set_len(&mut path, len as uint);\n-                Some(path)\n-            }\n+        match io::result(|| io::fs::readlink(&Path::new(\"/proc/self/exe\"))) {\n+            Ok(Some(path)) => Some(path.as_vec().to_owned()),\n+            Ok(None) | Err(*) => None\n         }\n     }\n \n@@ -465,6 +418,7 @@ pub fn self_exe_path() -> Option<Path> {\n         #[fixed_stack_segment]; #[inline(never)];\n         unsafe {\n             use libc::funcs::extra::_NSGetExecutablePath;\n+            use vec;\n             let mut sz: u32 = 0;\n             _NSGetExecutablePath(ptr::mut_null(), &mut sz);\n             if sz == 0 { return None; }\n@@ -574,58 +528,6 @@ pub fn tmpdir() -> Path {\n     }\n }\n \n-/// Recursively walk a directory structure\n-pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) -> bool {\n-    let r = list_dir(p);\n-    r.iter().advance(|q| {\n-        let path = &p.join(q);\n-        f(path) && (!path_is_dir(path) || walk_dir(path, |p| f(p)))\n-    })\n-}\n-\n-#[cfg(unix)]\n-/// Indicates whether a path represents a directory\n-pub fn path_is_dir(p: &Path) -> bool {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    unsafe {\n-        do p.with_c_str |buf| {\n-            rustrt::rust_path_is_dir(buf) != 0 as c_int\n-        }\n-    }\n-}\n-\n-\n-#[cfg(windows)]\n-pub fn path_is_dir(p: &Path) -> bool {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    unsafe {\n-        do os::win32::as_utf16_p(p.as_str().unwrap()) |buf| {\n-            rustrt::rust_path_is_dir_u16(buf) != 0 as c_int\n-        }\n-    }\n-}\n-\n-#[cfg(unix)]\n-/// Indicates whether a path exists\n-pub fn path_exists(p: &Path) -> bool {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    unsafe {\n-        do p.with_c_str |buf| {\n-            rustrt::rust_path_exists(buf) != 0 as c_int\n-        }\n-    }\n-}\n-\n-#[cfg(windows)]\n-pub fn path_exists(p: &Path) -> bool {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    unsafe {\n-        do os::win32::as_utf16_p(p.as_str().unwrap()) |buf| {\n-            rustrt::rust_path_exists_u16(buf) != 0 as c_int\n-        }\n-    }\n-}\n-\n /**\n  * Convert a relative path to an absolute path\n  *\n@@ -646,206 +548,6 @@ pub fn make_absolute(p: &Path) -> Path {\n     }\n }\n \n-\n-/// Creates a directory at the specified path\n-pub fn make_dir(p: &Path, mode: c_int) -> bool {\n-    return mkdir(p, mode);\n-\n-    #[cfg(windows)]\n-    fn mkdir(p: &Path, _mode: c_int) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        unsafe {\n-            use os::win32::as_utf16_p;\n-            // FIXME: turn mode into something useful? #2623\n-            do as_utf16_p(p.as_str().unwrap()) |buf| {\n-                libc::CreateDirectoryW(buf, ptr::mut_null())\n-                    != (0 as libc::BOOL)\n-            }\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn mkdir(p: &Path, mode: c_int) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        do p.with_c_str |buf| {\n-            unsafe {\n-                libc::mkdir(buf, mode as libc::mode_t) == (0 as c_int)\n-            }\n-        }\n-    }\n-}\n-\n-/// Creates a directory with a given mode.\n-/// Returns true iff creation\n-/// succeeded. Also creates all intermediate subdirectories\n-/// if they don't already exist, giving all of them the same mode.\n-\n-// tjc: if directory exists but with different permissions,\n-// should we return false?\n-pub fn mkdir_recursive(p: &Path, mode: c_int) -> bool {\n-    if path_is_dir(p) {\n-        return true;\n-    }\n-    if p.filename().is_some() {\n-        let mut p_ = p.clone();\n-        p_.pop();\n-        if !mkdir_recursive(&p_, mode) {\n-            return false;\n-        }\n-    }\n-    return make_dir(p, mode);\n-}\n-\n-/// Lists the contents of a directory\n-///\n-/// Each resulting Path is a relative path with no directory component.\n-pub fn list_dir(p: &Path) -> ~[Path] {\n-    unsafe {\n-        #[cfg(target_os = \"linux\")]\n-        #[cfg(target_os = \"android\")]\n-        #[cfg(target_os = \"freebsd\")]\n-        #[cfg(target_os = \"macos\")]\n-        unsafe fn get_list(p: &Path) -> ~[Path] {\n-            #[fixed_stack_segment]; #[inline(never)];\n-            use libc::{dirent_t};\n-            use libc::{opendir, readdir, closedir};\n-            extern {\n-                fn rust_list_dir_val(ptr: *dirent_t) -> *libc::c_char;\n-            }\n-            let mut paths = ~[];\n-            debug!(\"os::list_dir -- BEFORE OPENDIR\");\n-\n-            let dir_ptr = do p.with_c_str |buf| {\n-                opendir(buf)\n-            };\n-\n-            if (dir_ptr as uint != 0) {\n-                debug!(\"os::list_dir -- opendir() SUCCESS\");\n-                let mut entry_ptr = readdir(dir_ptr);\n-                while (entry_ptr as uint != 0) {\n-                    let cstr = CString::new(rust_list_dir_val(entry_ptr), false);\n-                    paths.push(Path::new(cstr));\n-                    entry_ptr = readdir(dir_ptr);\n-                }\n-                closedir(dir_ptr);\n-            }\n-            else {\n-                debug!(\"os::list_dir -- opendir() FAILURE\");\n-            }\n-            debug!(\"os::list_dir -- AFTER -- \\\\#: {}\", paths.len());\n-            paths\n-        }\n-        #[cfg(windows)]\n-        unsafe fn get_list(p: &Path) -> ~[Path] {\n-            #[fixed_stack_segment]; #[inline(never)];\n-            use libc::consts::os::extra::INVALID_HANDLE_VALUE;\n-            use libc::{wcslen, free};\n-            use libc::funcs::extra::kernel32::{\n-                FindFirstFileW,\n-                FindNextFileW,\n-                FindClose,\n-            };\n-            use libc::types::os::arch::extra::HANDLE;\n-            use os::win32::{\n-                as_utf16_p\n-            };\n-            use rt::global_heap::malloc_raw;\n-\n-            #[nolink]\n-            extern {\n-                fn rust_list_dir_wfd_size() -> libc::size_t;\n-                fn rust_list_dir_wfd_fp_buf(wfd: *libc::c_void) -> *u16;\n-            }\n-            let star = p.join(\"*\");\n-            do as_utf16_p(star.as_str().unwrap()) |path_ptr| {\n-                let mut paths = ~[];\n-                let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n-                let find_handle = FindFirstFileW(path_ptr, wfd_ptr as HANDLE);\n-                if find_handle as libc::c_int != INVALID_HANDLE_VALUE {\n-                    let mut more_files = 1 as libc::c_int;\n-                    while more_files != 0 {\n-                        let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr);\n-                        if fp_buf as uint == 0 {\n-                            fail!(\"os::list_dir() failure: got null ptr from wfd\");\n-                        }\n-                        else {\n-                            let fp_vec = vec::from_buf(\n-                                fp_buf, wcslen(fp_buf) as uint);\n-                            let fp_str = str::from_utf16(fp_vec);\n-                            paths.push(Path::new(fp_str));\n-                        }\n-                        more_files = FindNextFileW(find_handle, wfd_ptr as HANDLE);\n-                    }\n-                    FindClose(find_handle);\n-                    free(wfd_ptr)\n-                }\n-                paths\n-            }\n-        }\n-        do get_list(p).move_iter().filter |path| {\n-            path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n-        }.collect()\n-    }\n-}\n-\n-/**\n- * Lists the contents of a directory\n- *\n- * This version prepends each entry with the directory.\n- */\n-pub fn list_dir_path(p: &Path) -> ~[Path] {\n-    list_dir(p).map(|f| p.join(f))\n-}\n-\n-/// Removes a directory at the specified path, after removing\n-/// all its contents. Use carefully!\n-pub fn remove_dir_recursive(p: &Path) -> bool {\n-    let mut error_happened = false;\n-    do walk_dir(p) |inner| {\n-        if !error_happened {\n-            if path_is_dir(inner) {\n-                if !remove_dir_recursive(inner) {\n-                    error_happened = true;\n-                }\n-            }\n-            else {\n-                if !remove_file(inner) {\n-                    error_happened = true;\n-                }\n-            }\n-        }\n-        true\n-    };\n-    // Directory should now be empty\n-    !error_happened && remove_dir(p)\n-}\n-\n-/// Removes a directory at the specified path\n-pub fn remove_dir(p: &Path) -> bool {\n-   return rmdir(p);\n-\n-    #[cfg(windows)]\n-    fn rmdir(p: &Path) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        unsafe {\n-            use os::win32::as_utf16_p;\n-            return do as_utf16_p(p.as_str().unwrap()) |buf| {\n-                libc::RemoveDirectoryW(buf) != (0 as libc::BOOL)\n-            };\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn rmdir(p: &Path) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        do p.with_c_str |buf| {\n-            unsafe {\n-                libc::rmdir(buf) == (0 as c_int)\n-            }\n-        }\n-    }\n-}\n-\n /// Changes the current working directory to the specified path, returning\n /// whether the change was completed successfully or not.\n pub fn change_dir(p: &Path) -> bool {\n@@ -873,121 +575,6 @@ pub fn change_dir(p: &Path) -> bool {\n     }\n }\n \n-/// Copies a file from one location to another\n-pub fn copy_file(from: &Path, to: &Path) -> bool {\n-    return do_copy_file(from, to);\n-\n-    #[cfg(windows)]\n-    fn do_copy_file(from: &Path, to: &Path) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        unsafe {\n-            use os::win32::as_utf16_p;\n-            return do as_utf16_p(from.as_str().unwrap()) |fromp| {\n-                do as_utf16_p(to.as_str().unwrap()) |top| {\n-                    libc::CopyFileW(fromp, top, (0 as libc::BOOL)) !=\n-                        (0 as libc::BOOL)\n-                }\n-            }\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn do_copy_file(from: &Path, to: &Path) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        unsafe {\n-            let istream = do from.with_c_str |fromp| {\n-                do \"rb\".with_c_str |modebuf| {\n-                    libc::fopen(fromp, modebuf)\n-                }\n-            };\n-            if istream as uint == 0u {\n-                return false;\n-            }\n-            // Preserve permissions\n-            let from_mode = from.get_mode().expect(\"copy_file: couldn't get permissions \\\n-                                                    for source file\");\n-\n-            let ostream = do to.with_c_str |top| {\n-                do \"w+b\".with_c_str |modebuf| {\n-                    libc::fopen(top, modebuf)\n-                }\n-            };\n-            if ostream as uint == 0u {\n-                fclose(istream);\n-                return false;\n-            }\n-            let bufsize = 8192u;\n-            let mut buf = vec::with_capacity::<u8>(bufsize);\n-            let mut done = false;\n-            let mut ok = true;\n-            while !done {\n-                do buf.as_mut_buf |b, _sz| {\n-                  let nread = libc::fread(b as *mut c_void, 1u as size_t,\n-                                          bufsize as size_t,\n-                                          istream);\n-                  if nread > 0 as size_t {\n-                      if libc::fwrite(b as *c_void, 1u as size_t, nread,\n-                                      ostream) != nread {\n-                          ok = false;\n-                          done = true;\n-                      }\n-                  } else {\n-                      done = true;\n-                  }\n-              }\n-            }\n-            fclose(istream);\n-            fclose(ostream);\n-\n-            // Give the new file the old file's permissions\n-            if do to.with_c_str |to_buf| {\n-                libc::chmod(to_buf, from_mode as libc::mode_t)\n-            } != 0 {\n-                return false; // should be a condition...\n-            }\n-            return ok;\n-        }\n-    }\n-}\n-\n-/// Deletes an existing file\n-pub fn remove_file(p: &Path) -> bool {\n-    return unlink(p);\n-\n-    #[cfg(windows)]\n-    fn unlink(p: &Path) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        unsafe {\n-            use os::win32::as_utf16_p;\n-            return do as_utf16_p(p.as_str().unwrap()) |buf| {\n-                libc::DeleteFileW(buf) != (0 as libc::BOOL)\n-            };\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn unlink(p: &Path) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        unsafe {\n-            do p.with_c_str |buf| {\n-                libc::unlink(buf) == (0 as c_int)\n-            }\n-        }\n-    }\n-}\n-\n-/// Renames an existing file or directory\n-pub fn rename_file(old: &Path, new: &Path) -> bool {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    unsafe {\n-       do old.with_c_str |old_buf| {\n-            do new.with_c_str |new_buf| {\n-                libc::rename(old_buf, new_buf) == (0 as c_int)\n-            }\n-       }\n-    }\n-}\n-\n #[cfg(unix)]\n /// Returns the platform-specific value of errno\n pub fn errno() -> int {\n@@ -1216,6 +803,7 @@ fn real_args() -> ~[~str] {\n #[cfg(windows)]\n fn real_args() -> ~[~str] {\n     #[fixed_stack_segment]; #[inline(never)];\n+    use vec;\n \n     let mut nArgs: c_int = 0;\n     let lpArgCount: *mut c_int = &mut nArgs;\n@@ -1707,19 +1295,15 @@ pub mod consts {\n #[cfg(test)]\n mod tests {\n     use c_str::ToCStr;\n-    use libc::{c_int, c_void, size_t};\n-    use libc;\n     use option::Some;\n     use option;\n     use os::{env, getcwd, getenv, make_absolute, args};\n-    use os::{remove_file, setenv, unsetenv};\n+    use os::{setenv, unsetenv};\n     use os;\n     use path::Path;\n     use rand::Rng;\n     use rand;\n-    use run;\n     use str::StrSlice;\n-    use libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n \n \n     #[test]\n@@ -1875,144 +1459,6 @@ mod tests {\n         for s in olduserprofile.iter() { setenv(\"USERPROFILE\", *s) }\n     }\n \n-    #[test]\n-    fn tmpdir() {\n-        let p = os::tmpdir();\n-        let s = p.as_str();\n-        assert!(s.is_some() && s.unwrap() != \".\");\n-    }\n-\n-    // Issue #712\n-    #[test]\n-    fn test_list_dir_no_invalid_memory_access() {\n-        os::list_dir(&Path::new(\".\"));\n-    }\n-\n-    #[test]\n-    fn list_dir() {\n-        let dirs = os::list_dir(&Path::new(\".\"));\n-        // Just assuming that we've got some contents in the current directory\n-        assert!(dirs.len() > 0u);\n-\n-        for dir in dirs.iter() {\n-            debug!(\"{:?}\", (*dir).clone());\n-        }\n-    }\n-\n-    #[test]\n-    #[cfg(not(windows))]\n-    fn list_dir_root() {\n-        let dirs = os::list_dir(&Path::new(\"/\"));\n-        assert!(dirs.len() > 1);\n-    }\n-    #[test]\n-    #[cfg(windows)]\n-    fn list_dir_root() {\n-        let dirs = os::list_dir(&Path::new(\"C:\\\\\"));\n-        assert!(dirs.len() > 1);\n-    }\n-\n-\n-    #[test]\n-    fn path_is_dir() {\n-        use rt::io::file::open;\n-        use rt::io::{OpenOrCreate, Read};\n-\n-        assert!((os::path_is_dir(&Path::new(\".\"))));\n-        assert!((!os::path_is_dir(&Path::new(\"test/stdtest/fs.rs\"))));\n-\n-        let mut dirpath = os::tmpdir();\n-        dirpath.push(format!(\"rust-test-{}/test-\\uac00\\u4e00\\u30fc\\u4f60\\u597d\",\n-            rand::random::<u32>())); // \uac00\u4e00\u30fc\u4f60\u597d\n-        debug!(\"path_is_dir dirpath: {}\", dirpath.display());\n-\n-        let mkdir_result = os::mkdir_recursive(&dirpath, (S_IRUSR | S_IWUSR | S_IXUSR) as i32);\n-        debug!(\"path_is_dir mkdir_result: {}\", mkdir_result);\n-\n-        assert!((os::path_is_dir(&dirpath)));\n-\n-        let mut filepath = dirpath;\n-        filepath.push(\"unicode-file-\\uac00\\u4e00\\u30fc\\u4f60\\u597d.rs\");\n-        debug!(\"path_is_dir filepath: {}\", filepath.display());\n-\n-        open(&filepath, OpenOrCreate, Read); // ignore return; touch only\n-        assert!((!os::path_is_dir(&filepath)));\n-\n-        assert!((!os::path_is_dir(&Path::new(\n-                     \"test/unicode-bogus-dir-\\uac00\\u4e00\\u30fc\\u4f60\\u597d\"))));\n-    }\n-\n-    #[test]\n-    fn path_exists() {\n-        assert!((os::path_exists(&Path::new(\".\"))));\n-        assert!((!os::path_exists(&Path::new(\n-                     \"test/nonexistent-bogus-path\"))));\n-\n-        let mut dirpath = os::tmpdir();\n-        dirpath.push(format!(\"rust-test-{}/test-\\uac01\\u4e01\\u30fc\\u518d\\u89c1\",\n-            rand::random::<u32>())); // \uac01\u4e01\u30fc\u518d\u89c1\n-\n-        os::mkdir_recursive(&dirpath, (S_IRUSR | S_IWUSR | S_IXUSR) as i32);\n-        assert!((os::path_exists(&dirpath)));\n-        assert!((!os::path_exists(&Path::new(\n-                     \"test/unicode-bogus-path-\\uac01\\u4e01\\u30fc\\u518d\\u89c1\"))));\n-    }\n-\n-    #[test]\n-    fn copy_file_does_not_exist() {\n-      assert!(!os::copy_file(&Path::new(\"test/nonexistent-bogus-path\"),\n-                            &Path::new(\"test/other-bogus-path\")));\n-      assert!(!os::path_exists(&Path::new(\"test/other-bogus-path\")));\n-    }\n-\n-    #[test]\n-    fn copy_file_ok() {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            let tempdir = getcwd(); // would like to use $TMPDIR,\n-                                    // doesn't seem to work on Linux\n-            let input = tempdir.join(\"in.txt\");\n-            let out = tempdir.join(\"out.txt\");\n-\n-            /* Write the temp input file */\n-            let ostream = do input.with_c_str |fromp| {\n-                do \"w+b\".with_c_str |modebuf| {\n-                    libc::fopen(fromp, modebuf)\n-                }\n-            };\n-            assert!((ostream as uint != 0u));\n-            let s = ~\"hello\";\n-            do \"hello\".with_c_str |buf| {\n-                let write_len = libc::fwrite(buf as *c_void,\n-                                             1u as size_t,\n-                                             (s.len() + 1u) as size_t,\n-                                             ostream);\n-                assert_eq!(write_len, (s.len() + 1) as size_t)\n-            }\n-            assert_eq!(libc::fclose(ostream), (0u as c_int));\n-            let in_mode = input.get_mode();\n-            let rs = os::copy_file(&input, &out);\n-            if (!os::path_exists(&input)) {\n-                fail!(\"{} doesn't exist\", input.display());\n-            }\n-            assert!((rs));\n-            // FIXME (#9639): This needs to handle non-utf8 paths\n-            let rslt = run::process_status(\"diff\", [input.as_str().unwrap().to_owned(),\n-                                                    out.as_str().unwrap().to_owned()]);\n-            assert_eq!(rslt, 0);\n-            assert_eq!(out.get_mode(), in_mode);\n-            assert!((remove_file(&input)));\n-            assert!((remove_file(&out)));\n-        }\n-    }\n-\n-    #[test]\n-    fn recursive_mkdir_slash() {\n-        let path = Path::new(\"/\");\n-        assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-    }\n-\n     #[test]\n     fn memory_map_rw() {\n         use result::{Ok, Err};\n@@ -2039,6 +1485,8 @@ mod tests {\n         use result::{Ok, Err};\n         use os::*;\n         use libc::*;\n+        use rt::io;\n+        use rt::io::fs;\n \n         #[cfg(unix)]\n         #[fixed_stack_segment]\n@@ -2060,7 +1508,6 @@ mod tests {\n         let mut path = tmpdir();\n         path.push(\"mmap_file.tmp\");\n         let size = MemoryMap::granularity() * 2;\n-        remove_file(&path);\n \n         let fd = unsafe {\n             let fd = do path.with_c_str |path| {\n@@ -2088,6 +1535,7 @@ mod tests {\n             assert!(*chunk.data == 0xbe);\n             close(fd);\n         }\n+        do io::ignore_io_error { fs::unlink(&path); }\n     }\n \n     // More recursive_mkdir tests are in extra::tempfile"}, {"sha": "f14f100de73c96c688f3080c3878a430da981b1b", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -24,9 +24,6 @@ use vec;\n use vec::{CopyableVector, RSplitIterator, SplitIterator, Vector, VectorVector};\n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n \n-#[cfg(not(target_os = \"win32\"))]\n-use rt::io::{FileStat, file, io_error};\n-\n /// Iterator that yields successive components of a Path as &[u8]\n pub type ComponentIter<'self> = SplitIterator<'self, u8>;\n /// Iterator that yields components of a Path in reverse as &[u8]\n@@ -442,72 +439,6 @@ fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<~[&'a [u8]]> {\n static dot_static: &'static [u8] = bytes!(\".\");\n static dot_dot_static: &'static [u8] = bytes!(\"..\");\n \n-// Stat support\n-#[cfg(not(target_os = \"win32\"))]\n-impl Path {\n-    /// Calls stat() on the represented file and returns the resulting rt::io::FileStat\n-    pub fn stat(&self) -> Option<FileStat> {\n-        let mut file_stat: Option<FileStat> = None;\n-        do io_error::cond.trap(|_| { /* Ignore error, will return None */ }).inside {\n-            file_stat = file::stat(self);\n-        }\n-        file_stat\n-    }\n-\n-    /// Returns whether the represented file exists\n-    pub fn exists(&self) -> bool {\n-        match self.stat() {\n-            None => false,\n-            Some(_) => true\n-        }\n-    }\n-\n-    /// Returns the filesize of the represented file\n-    pub fn get_size(&self) -> Option<u64> {\n-        match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.size)\n-        }\n-    }\n-\n-    /// Returns the mode of the represented file\n-    pub fn get_mode(&self) -> Option<uint> {\n-        match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.mode as uint)\n-        }\n-    }\n-}\n-\n-#[cfg(target_os = \"freebsd\")]\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-impl Path {\n-    /// Returns the atime of the represented file, as msecs\n-    pub fn get_atime(&self) -> Option<u64> {\n-        match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.accessed)\n-        }\n-    }\n-\n-    /// Returns the mtime of the represented file, as msecs\n-    pub fn get_mtime(&self) -> Option<u64> {\n-        match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.modified)\n-        }\n-    }\n-\n-    /// Returns the ctime of the represented file, as msecs\n-    pub fn get_ctime(&self) -> Option<u64> {\n-        match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.created)\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "8483b504c0137fee61ea1057fb8f30c0caa2c11e", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -23,9 +23,6 @@ use to_bytes::IterBytes;\n use vec::Vector;\n use super::{contains_nul, BytesContainer, GenericPath, GenericPathUnsafe};\n \n-#[cfg(target_os = \"win32\")]\n-use rt::io::{FileStat, file, io_error};\n-\n /// Iterator that yields successive components of a Path as &str\n ///\n /// Each component is yielded as Option<&str> for compatibility with PosixPath, but\n@@ -1056,67 +1053,6 @@ fn prefix_is_sep(p: Option<PathPrefix>, c: u8) -> bool {\n                     else { is_sep_verbatim(c as char) }\n }\n \n-// Stat support\n-#[cfg(target_os = \"win32\")]\n-impl Path {\n-    /// Calls stat() on the represented file and returns the resulting rt::io::FileStat\n-    pub fn stat(&self) -> Option<FileStat> {\n-        let mut file_stat: Option<FileStat> = None;\n-        do io_error::cond.trap(|_| { /* Ignore error, will return None */ }).inside {\n-            file_stat = file::stat(self);\n-        }\n-        file_stat\n-    }\n-\n-    /// Returns whether the represented file exists\n-    pub fn exists(&self) -> bool {\n-        match self.stat() {\n-            None => false,\n-            Some(_) => true\n-        }\n-    }\n-\n-    /// Returns the filesize of the represented file\n-    pub fn get_size(&self) -> Option<u64> {\n-        match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.size)\n-        }\n-    }\n-\n-    /// Returns the mode of the represented file\n-    pub fn get_mode(&self) -> Option<uint> {\n-        match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.mode as uint)\n-        }\n-    }\n-\n-    /// Returns the atime of the represented file, as msecs\n-    pub fn get_atime(&self) -> Option<u64> {\n-        match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.accessed)\n-        }\n-    }\n-\n-    /// Returns the mtime of the represented file, as msecs\n-    pub fn get_mtime(&self) -> Option<u64> {\n-        match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.modified)\n-        }\n-    }\n-\n-    /// Returns the ctime of the represented file, as msecs\n-    pub fn get_ctime(&self) -> Option<u64> {\n-        match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.created)\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "0190b02fbc08f71e18e8b50df229a26cbf81a129", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -67,6 +67,7 @@ pub use num::{Orderable, Signed, Unsigned, Round};\n pub use num::{Primitive, Int, Float, ToStrRadix, ToPrimitive, FromPrimitive};\n pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n pub use ptr::RawPtr;\n+pub use rt::io::{Writer, Reader, Seek};\n pub use send_str::{SendStr, SendStrOwned, SendStrStatic, IntoSendStr};\n pub use str::{Str, StrVector, StrSlice, OwnedStr};\n pub use to_bytes::IterBytes;"}, {"sha": "a6d05ea307cdb9bb0351de8b2c14aaf1abc4ea43", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -17,7 +17,7 @@ use ops::Drop;\n #[cfg(unix)]\n use rand::reader::ReaderRng;\n #[cfg(unix)]\n-use rt::io::{file, Open, Read};\n+use rt::io::File;\n \n #[cfg(windows)]\n use cast;\n@@ -40,7 +40,7 @@ type HCRYPTPROV = c_long;\n /// This does not block.\n #[cfg(unix)]\n pub struct OSRng {\n-    priv inner: ReaderRng<file::FileStream>\n+    priv inner: ReaderRng<File>\n }\n /// A random number generator that retrieves randomness straight from\n /// the operating system. Platform sources:\n@@ -60,7 +60,9 @@ impl OSRng {\n     /// Create a new `OSRng`.\n     #[cfg(unix)]\n     pub fn new() -> OSRng {\n-        let reader = file::open(& &\"/dev/urandom\", Open, Read).expect(\"Error opening /dev/urandom\");\n+        use path::Path;\n+        let reader = File::open(&Path::new(\"/dev/urandom\"));\n+        let reader = reader.expect(\"Error opening /dev/urandom\");\n         let reader_rng = ReaderRng::new(reader);\n \n         OSRng { inner: reader_rng }"}, {"sha": "99a4a709504e48ef4e3692aeaf36badae8b27a45", "filename": "src/libstd/rt/io/file.rs", "status": "removed", "additions": 0, "deletions": 952, "changes": 952, "blob_url": "https://github.com/rust-lang/rust/blob/70e9b5ab3912da84a32557bc1a34db5fb2178927/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70e9b5ab3912da84a32557bc1a34db5fb2178927/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=70e9b5ab3912da84a32557bc1a34db5fb2178927", "patch": "@@ -1,952 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*! Synchronous File I/O\n-\n-This module provides a set of functions and traits for working\n-with regular files & directories on a filesystem.\n-\n-At the top-level of the module are a set of freestanding functions,\n-associated with various filesystem operations. They all operate\n-on a `ToCStr` object. This trait is already defined for common\n-objects such as strings and `Path` instances.\n-\n-All operations in this module, including those as part of `FileStream` et al\n-block the task during execution. Most will raise `std::rt::io::io_error`\n-conditions in the event of failure.\n-\n-Also included in this module are the `FileInfo` and `DirectoryInfo` traits. When\n-`use`'d alongside a value whose type implements them (A `std::path::Path` impl is\n-a part of this module), they expose a set of functions for operations against\n-a given file location, depending on whether the path already exists. Whenever\n-possible, the `{FileInfo, DirectoryInfo}` preserve the same semantics as their\n-free function counterparts.\n-*/\n-\n-use prelude::*;\n-use c_str::ToCStr;\n-use super::{Reader, Writer, Seek};\n-use super::{SeekStyle, Read, Write};\n-use rt::rtio::{RtioFileStream, IoFactory, with_local_io};\n-use rt::io::{io_error, EndOfFile,\n-            FileMode, FileAccess, FileStat, IoError,\n-            PathAlreadyExists, PathDoesntExist,\n-            MismatchedFileTypeForOperation, ignore_io_error};\n-use option::{Some, None};\n-use path::Path;\n-\n-/// Open a file for reading/writing, as indicated by `path`.\n-///\n-/// # Example\n-///\n-///     use std;\n-///     use std::path::Path;\n-///     use std::rt::io::file::open;\n-///     use std::rt::io::{FileMode, FileAccess};\n-///\n-///     let p = &Path(\"/some/file/path.txt\");\n-///\n-///     do io_error::cond.trap(|_| {\n-///         // hoo-boy...\n-///     }).inside {\n-///         let stream = match open(p, Create, ReadWrite) {\n-///             Some(s) => s,\n-///             None => fail!(\"whoops! I'm sure this raised, anyways..\")\n-///         };\n-///         // do some stuff with that stream\n-///\n-///         // the file stream will be closed at the end of this block\n-///     }\n-///     // ..\n-///\n-/// `FileMode` and `FileAccess` provide information about the permissions\n-/// context in which a given stream is created. More information about them\n-/// can be found in `std::rt::io`'s docs.\n-///\n-/// Note that, with this function, a `FileStream` is returned regardless of\n-/// the access-limitations indicated by `FileAccess` (e.g. calling `write` on a\n-/// `FileStream` opened as `ReadOnly` will raise an `io_error` condition at runtime). If you\n-/// desire a more-correctly-constrained interface to files, use the\n-/// `{open_stream, open_reader, open_writer}` methods that are a part of `FileInfo`\n-///\n-/// # Errors\n-///\n-/// This function will raise an `io_error` condition under a number of different circumstances,\n-/// to include but not limited to:\n-///\n-/// * Opening a file that already exists with `FileMode` of `Create` or vice versa (e.g.\n-///   opening a non-existant file with `FileMode` or `Open`)\n-/// * Attempting to open a file with a `FileAccess` that the user lacks permissions\n-///   for\n-/// * Filesystem-level errors (full disk, etc)\n-pub fn open<P: ToCStr>(path: &P,\n-                       mode: FileMode,\n-                       access: FileAccess\n-                      ) -> Option<FileStream> {\n-    do with_local_io |io| {\n-        match io.fs_open(&path.to_c_str(), mode, access) {\n-            Ok(fd) => Some(FileStream {\n-                fd: fd,\n-                last_nread: -1\n-            }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n-    }\n-}\n-\n-/// Unlink a file from the underlying filesystem.\n-///\n-/// # Example\n-///\n-///     use std;\n-///     use std::path::Path;\n-///     use std::rt::io::file::unlink;\n-///\n-///     let p = &Path(\"/some/file/path.txt\");\n-///     unlink(p);\n-///     // if we made it here without failing, then the\n-///     // unlink operation was successful\n-///\n-/// Note that, just because an unlink call was successful, it is not\n-/// guaranteed that a file is immediately deleted (e.g. depending on\n-/// platform, other open file descriptors may prevent immediate removal)\n-///\n-/// # Errors\n-///\n-/// This function will raise an `io_error` condition if the user lacks permissions to\n-/// remove the file or if some other filesystem-level error occurs\n-pub fn unlink<P: ToCStr>(path: &P) {\n-    do with_local_io |io| {\n-        match io.fs_unlink(&path.to_c_str()) {\n-            Ok(_) => Some(()),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n-    };\n-}\n-\n-/// Create a new, empty directory at the provided path\n-///\n-/// # Example\n-///\n-///     use std;\n-///     use std::path::Path;\n-///     use std::rt::io::file::mkdir;\n-///\n-///     let p = &Path(\"/some/dir\");\n-///     mkdir(p);\n-///     // If we got here, our directory exists! Horray!\n-///\n-/// # Errors\n-///\n-/// This call will raise an `io_error` condition if the user lacks permissions to make a\n-/// new directory at the provided path, or if the directory already exists\n-pub fn mkdir<P: ToCStr>(path: &P) {\n-    do with_local_io |io| {\n-        match io.fs_mkdir(&path.to_c_str()) {\n-            Ok(_) => Some(()),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n-    };\n-}\n-\n-/// Remove an existing, empty directory\n-///\n-/// # Example\n-///\n-///     use std;\n-///     use std::path::Path;\n-///     use std::rt::io::file::rmdir;\n-///\n-///     let p = &Path(\"/some/dir\");\n-///     rmdir(p);\n-///     // good riddance, you mean ol' directory\n-///\n-/// # Errors\n-///\n-/// This call will raise an `io_error` condition if the user lacks permissions to remove the\n-/// directory at the provided path, or if the directory isn't empty\n-pub fn rmdir<P: ToCStr>(path: &P) {\n-    do with_local_io |io| {\n-        match io.fs_rmdir(&path.to_c_str()) {\n-            Ok(_) => Some(()),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n-    };\n-}\n-\n-/// Get information on the file, directory, etc at the provided path\n-///\n-/// Given a path, query the file system to get information about a file,\n-/// directory, etc.\n-///\n-/// Returns a `Some(std::rt::io::PathInfo)` on success\n-///\n-/// # Example\n-///\n-///     use std;\n-///     use std::path::Path;\n-///     use std::rt::io::file::stat;\n-///\n-///     let p = &Path(\"/some/file/path.txt\");\n-///\n-///     do io_error::cond.trap(|_| {\n-///         // hoo-boy...\n-///     }).inside {\n-///         let info = match stat(p) {\n-///             Some(s) => s,\n-///             None => fail!(\"whoops! I'm sure this raised, anyways..\");\n-///         }\n-///         if stat.is_file {\n-///             // just imagine the possibilities ...\n-///         }\n-///\n-///         // the file stream will be closed at the end of this block\n-///     }\n-///     // ..\n-///\n-/// # Errors\n-///\n-/// This call will raise an `io_error` condition if the user lacks the requisite\n-/// permissions to perform a `stat` call on the given path or if there is no\n-/// entry in the filesystem at the provided path.\n-pub fn stat<P: ToCStr>(path: &P) -> Option<FileStat> {\n-    do with_local_io |io| {\n-        match io.fs_stat(&path.to_c_str()) {\n-            Ok(p) => Some(p),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n-    }\n-}\n-\n-/// Retrieve a vector containing all entries within a provided directory\n-///\n-/// # Example\n-///\n-///     use std;\n-///     use std::path::Path;\n-///     use std::rt::io::file::readdir;\n-///\n-///     fn visit_dirs(dir: &Path, cb: &fn(&Path)) {\n-///         if dir.is_dir() {\n-///             let contents = dir.readdir();\n-///             for entry in contents.iter() {\n-///                 if entry.is_dir() { visit_dirs(entry, cb); }\n-///                 else { cb(entry); }\n-///             }\n-///         }\n-///         else { fail!(\"nope\"); }\n-///     }\n-///\n-/// # Errors\n-///\n-/// Will raise an `io_error` condition if the provided `path` doesn't exist,\n-/// the process lacks permissions to view the contents or if the `path` points\n-/// at a non-directory file\n-pub fn readdir<P: ToCStr>(path: &P) -> Option<~[Path]> {\n-    do with_local_io |io| {\n-        match io.fs_readdir(&path.to_c_str(), 0) {\n-            Ok(p) => Some(p),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n-    }\n-}\n-\n-/// Constrained version of `FileStream` that only exposes read-specific operations.\n-///\n-/// Can be retreived via `FileInfo.open_reader()`.\n-pub struct FileReader { priv stream: FileStream }\n-\n-/// a `std::rt::io::Reader` trait impl for file I/O.\n-impl Reader for FileReader {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        self.stream.read(buf)\n-    }\n-\n-    fn eof(&mut self) -> bool {\n-        self.stream.eof()\n-    }\n-}\n-\n-/// a `std::rt::io::Seek` trait impl for file I/O.\n-impl Seek for FileReader {\n-    fn tell(&self) -> u64 {\n-        self.stream.tell()\n-    }\n-\n-    fn seek(&mut self, pos: i64, style: SeekStyle) {\n-        self.stream.seek(pos, style);\n-    }\n-}\n-\n-/// Constrained version of `FileStream` that only exposes write-specific operations.\n-///\n-/// Can be retreived via `FileInfo.open_writer()`.\n-pub struct FileWriter { priv stream: FileStream }\n-\n-/// a `std::rt::io::Writer` trait impl for file I/O.\n-impl Writer for FileWriter {\n-    fn write(&mut self, buf: &[u8]) {\n-        self.stream.write(buf);\n-    }\n-\n-    fn flush(&mut self) {\n-        self.stream.flush();\n-    }\n-}\n-\n-/// a `std::rt::io::Seek` trait impl for file I/O.\n-impl Seek for FileWriter {\n-    fn tell(&self) -> u64 {\n-        self.stream.tell()\n-    }\n-\n-    fn seek(&mut self, pos: i64, style: SeekStyle) {\n-        self.stream.seek(pos, style);\n-    }\n-}\n-\n-/// Unconstrained file access type that exposes read and write operations\n-///\n-/// Can be retreived via `file::open()` and `FileInfo.open_stream()`.\n-///\n-/// # Errors\n-///\n-/// This type will raise an io_error condition if operations are attempted against\n-/// it for which its underlying file descriptor was not configured at creation\n-/// time, via the `FileAccess` parameter to `file::open()`.\n-///\n-/// For this reason, it is best to use the access-constrained wrappers that are\n-/// exposed via `FileInfo.open_reader()` and `FileInfo.open_writer()`.\n-pub struct FileStream {\n-    priv fd: ~RtioFileStream,\n-    priv last_nread: int,\n-}\n-\n-/// a `std::rt::io::Reader` trait impl for file I/O.\n-impl Reader for FileStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        match self.fd.read(buf) {\n-            Ok(read) => {\n-                self.last_nread = read;\n-                match read {\n-                    0 => None,\n-                    _ => Some(read as uint)\n-                }\n-            },\n-            Err(ioerr) => {\n-                // EOF is indicated by returning None\n-                if ioerr.kind != EndOfFile {\n-                    io_error::cond.raise(ioerr);\n-                }\n-                return None;\n-            }\n-        }\n-    }\n-\n-    fn eof(&mut self) -> bool {\n-        self.last_nread == 0\n-    }\n-}\n-\n-/// a `std::rt::io::Writer` trait impl for file I/O.\n-impl Writer for FileStream {\n-    fn write(&mut self, buf: &[u8]) {\n-        match self.fd.write(buf) {\n-            Ok(_) => (),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-            }\n-        }\n-    }\n-}\n-\n-/// a `std::rt::io:Seek` trait impl for file I/O.\n-impl Seek for FileStream {\n-    fn tell(&self) -> u64 {\n-        let res = self.fd.tell();\n-        match res {\n-            Ok(cursor) => cursor,\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                return -1;\n-            }\n-        }\n-    }\n-\n-    fn seek(&mut self, pos: i64, style: SeekStyle) {\n-        match self.fd.seek(pos, style) {\n-            Ok(_) => {\n-                // successful seek resets EOF indicator\n-                self.last_nread = -1;\n-                ()\n-            },\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-            }\n-        }\n-    }\n-}\n-\n-/// Shared functionality between `FileInfo` and `DirectoryInfo`\n-pub trait FileSystemInfo {\n-    /// Get the filesystem path that this instance points at,\n-    /// whether it is valid or not. In this way, it can be used to\n-    /// to specify a path of a non-existent file which it\n-    /// later creates\n-    fn get_path<'a>(&'a self) -> &'a Path;\n-\n-    /// Get information on the file, directory, etc at the provided path\n-    ///\n-    /// Consult the `file::stat` documentation for more info.\n-    ///\n-    /// This call preserves identical runtime/error semantics with `file::stat`\n-    fn stat(&self) -> Option<FileStat> {\n-        stat(self.get_path())\n-    }\n-\n-    /// Boolean value indicator whether the underlying file exists on the filesystem\n-    ///\n-    /// # Errors\n-    ///\n-    /// Will not raise a condition\n-    fn exists(&self) -> bool {\n-        match ignore_io_error(|| self.stat()) {\n-            Some(_) => true,\n-            None => false\n-        }\n-    }\n-\n-}\n-\n-/// Represents a file, whose underlying path may or may not be valid\n-///\n-/// # Example\n-///\n-/// * Check if a file exists, reading from it if so\n-///\n-/// ```rust\n-/// use std;\n-/// use std::path::Path;\n-/// use std::rt::io::file::{FileInfo, FileReader};\n-///\n-/// let f = &Path(\"/some/file/path.txt\");\n-/// if f.exists() {\n-///     let reader = f.open_reader(Open);\n-///     let mut mem = [0u8, 8*64000];\n-///     reader.read(mem);\n-///     // ...\n-/// }\n-/// ```\n-///\n-/// * Is the given path a file?\n-///\n-/// ```rust\n-/// let f = get_file_path_from_wherever();\n-/// match f.is_file() {\n-///    true => doing_something_with_a_file(f),\n-///    _ => {}\n-/// }\n-/// ```\n-pub trait FileInfo : FileSystemInfo {\n-    /// Whether the underlying implemention (be it a file path,\n-    /// or something else) points at a \"regular file\" on the FS. Will return\n-    /// false for paths to non-existent locations or directories or\n-    /// other non-regular files (named pipes, etc).\n-    ///\n-    /// # Errors\n-    ///\n-    /// Will not raise a condition\n-    fn is_file(&self) -> bool {\n-        match ignore_io_error(|| self.stat()) {\n-            Some(s) => s.is_file,\n-            None => false\n-        }\n-    }\n-\n-    /// Attempts to open a regular file for reading/writing based\n-    /// on provided inputs\n-    ///\n-    /// See `file::open` for more information on runtime semantics and error conditions\n-    fn open_stream(&self, mode: FileMode, access: FileAccess) -> Option<FileStream> {\n-        match ignore_io_error(|| self.stat()) {\n-            Some(s) => match s.is_file {\n-                true => open(self.get_path(), mode, access),\n-                false => None\n-            },\n-            None => open(self.get_path(), mode, access)\n-        }\n-    }\n-\n-    /// Attempts to open a regular file in read-only mode, based\n-    /// on provided inputs\n-    ///\n-    /// See `file::open` for more information on runtime semantics and error conditions\n-    fn open_reader(&self, mode: FileMode) -> Option<FileReader> {\n-        match self.open_stream(mode, Read) {\n-            Some(s) => Some(FileReader { stream: s}),\n-            None => None\n-        }\n-    }\n-\n-    /// Attempts to open a regular file in write-only mode, based\n-    /// on provided inputs\n-    ///\n-    /// See `file::open` for more information on runtime semantics and error conditions\n-    fn open_writer(&self, mode: FileMode) -> Option<FileWriter> {\n-        match self.open_stream(mode, Write) {\n-            Some(s) => Some(FileWriter { stream: s}),\n-            None => None\n-        }\n-    }\n-\n-    /// Attempt to remove a file from the filesystem\n-    ///\n-    /// See `file::unlink` for more information on runtime semantics and error conditions\n-    fn unlink(&self) {\n-        unlink(self.get_path());\n-    }\n-}\n-\n-/// `FileSystemInfo` implementation for `Path`s\n-impl FileSystemInfo for Path {\n-    fn get_path<'a>(&'a self) -> &'a Path { self }\n-}\n-\n-/// `FileInfo` implementation for `Path`s\n-impl FileInfo for Path { }\n-\n-/// Represents a directory, whose underlying path may or may not be valid\n-///\n-/// # Example\n-///\n-/// * Check if a directory exists, `mkdir`'ing it if not\n-///\n-/// ```rust\n-/// use std;\n-/// use std::path::Path;\n-/// use std::rt::io::file::{DirectoryInfo};\n-///\n-/// let dir = &Path(\"/some/dir\");\n-/// if !dir.exists() {\n-///     dir.mkdir();\n-/// }\n-/// ```\n-///\n-/// * Is the given path a directory? If so, iterate on its contents\n-///\n-/// ```rust\n-/// fn visit_dirs(dir: &Path, cb: &fn(&Path)) {\n-///     if dir.is_dir() {\n-///         let contents = dir.readdir();\n-///         for entry in contents.iter() {\n-///             if entry.is_dir() { visit_dirs(entry, cb); }\n-///             else { cb(entry); }\n-///         }\n-///     }\n-///     else { fail!(\"nope\"); }\n-/// }\n-/// ```\n-pub trait DirectoryInfo : FileSystemInfo {\n-    /// Whether the underlying implemention (be it a file path,\n-    /// or something else) is pointing at a directory in the underlying FS.\n-    /// Will return false for paths to non-existent locations or if the item is\n-    /// not a directory (eg files, named pipes, links, etc)\n-    ///\n-    /// # Errors\n-    ///\n-    /// Will not raise a condition\n-    fn is_dir(&self) -> bool {\n-        match ignore_io_error(|| self.stat()) {\n-            Some(s) => s.is_dir,\n-            None => false\n-        }\n-    }\n-\n-    /// Create a directory at the location pointed to by the\n-    /// type underlying the given `DirectoryInfo`.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This method will raise a `PathAlreadyExists` kind of `io_error` condition\n-    /// if the provided path exists\n-    ///\n-    /// See `file::mkdir` for more information on runtime semantics and error conditions\n-    fn mkdir(&self) {\n-        match ignore_io_error(|| self.stat()) {\n-            Some(_) => {\n-                let path = self.get_path();\n-                io_error::cond.raise(IoError {\n-                    kind: PathAlreadyExists,\n-                    desc: \"Path already exists\",\n-                    detail:\n-                        Some(format!(\"{} already exists; can't mkdir it\",\n-                                     path.display()))\n-                })\n-            },\n-            None => mkdir(self.get_path())\n-        }\n-    }\n-\n-    /// Remove a directory at the given location.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This method will raise a `PathDoesntExist` kind of `io_error` condition\n-    /// if the provided path exists. It will raise a `MismatchedFileTypeForOperation`\n-    /// kind of `io_error` condition if the provided path points at any\n-    /// non-directory file type\n-    ///\n-    /// See `file::rmdir` for more information on runtime semantics and error conditions\n-    fn rmdir(&self) {\n-        match ignore_io_error(|| self.stat()) {\n-            Some(s) => {\n-                match s.is_dir {\n-                    true => rmdir(self.get_path()),\n-                    false => {\n-                        let path = self.get_path();\n-                        let ioerr = IoError {\n-                            kind: MismatchedFileTypeForOperation,\n-                            desc: \"Cannot do rmdir() on a non-directory\",\n-                            detail: Some(format!(\n-                                \"{} is a non-directory; can't rmdir it\",\n-                                path.display()))\n-                        };\n-                        io_error::cond.raise(ioerr);\n-                    }\n-                }\n-            },\n-            None => {\n-                let path = self.get_path();\n-                io_error::cond.raise(IoError {\n-                    kind: PathDoesntExist,\n-                    desc: \"Path doesn't exist\",\n-                    detail: Some(format!(\"{} doesn't exist; can't rmdir it\",\n-                                         path.display()))\n-                })\n-            }\n-        }\n-    }\n-\n-    // Get a collection of all entries at the given\n-    // directory\n-    fn readdir(&self) -> Option<~[Path]> {\n-        readdir(self.get_path())\n-    }\n-}\n-\n-/// `DirectoryInfo` impl for `path::Path`\n-impl DirectoryInfo for Path { }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::super::{SeekSet, SeekCur, SeekEnd,\n-                       io_error, Read, Create, Open, ReadWrite};\n-    use super::super::super::test::*;\n-    use option::{Some, None};\n-    use path::Path;\n-    use super::*;\n-    use iter::range;\n-    #[test]\n-    fn file_test_io_smoke_test() {\n-        do run_in_mt_newsched_task {\n-            let message = \"it's alright. have a good time\";\n-            let filename = &Path::new(\"./tmp/file_rt_io_file_test.txt\");\n-            {\n-                let mut write_stream = open(filename, Create, ReadWrite).unwrap();\n-                write_stream.write(message.as_bytes());\n-            }\n-            {\n-                use str;\n-                let mut read_stream = open(filename, Open, Read).unwrap();\n-                let mut read_buf = [0, .. 1028];\n-                let read_str = match read_stream.read(read_buf).unwrap() {\n-                    -1|0 => fail!(\"shouldn't happen\"),\n-                    n => str::from_utf8(read_buf.slice_to(n))\n-                };\n-                assert!(read_str == message.to_owned());\n-            }\n-            unlink(filename);\n-        }\n-    }\n-\n-    #[test]\n-    fn file_test_io_invalid_path_opened_without_create_should_raise_condition() {\n-        do run_in_mt_newsched_task {\n-            let filename = &Path::new(\"./tmp/file_that_does_not_exist.txt\");\n-            let mut called = false;\n-            do io_error::cond.trap(|_| {\n-                called = true;\n-            }).inside {\n-                let result = open(filename, Open, Read);\n-                assert!(result.is_none());\n-            }\n-            assert!(called);\n-        }\n-    }\n-\n-    #[test]\n-    fn file_test_iounlinking_invalid_path_should_raise_condition() {\n-        do run_in_mt_newsched_task {\n-            let filename = &Path::new(\"./tmp/file_another_file_that_does_not_exist.txt\");\n-            let mut called = false;\n-            do io_error::cond.trap(|_| {\n-                called = true;\n-            }).inside {\n-                unlink(filename);\n-            }\n-            assert!(called);\n-        }\n-    }\n-\n-    #[test]\n-    fn file_test_io_non_positional_read() {\n-        do run_in_mt_newsched_task {\n-            use str;\n-            let message = \"ten-four\";\n-            let mut read_mem = [0, .. 8];\n-            let filename = &Path::new(\"./tmp/file_rt_io_file_test_positional.txt\");\n-            {\n-                let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n-                rw_stream.write(message.as_bytes());\n-            }\n-            {\n-                let mut read_stream = open(filename, Open, Read).unwrap();\n-                {\n-                    let read_buf = read_mem.mut_slice(0, 4);\n-                    read_stream.read(read_buf);\n-                }\n-                {\n-                    let read_buf = read_mem.mut_slice(4, 8);\n-                    read_stream.read(read_buf);\n-                }\n-            }\n-            unlink(filename);\n-            let read_str = str::from_utf8(read_mem);\n-            assert!(read_str == message.to_owned());\n-        }\n-    }\n-\n-    #[test]\n-    fn file_test_io_seek_and_tell_smoke_test() {\n-        do run_in_mt_newsched_task {\n-            use str;\n-            let message = \"ten-four\";\n-            let mut read_mem = [0, .. 4];\n-            let set_cursor = 4 as u64;\n-            let mut tell_pos_pre_read;\n-            let mut tell_pos_post_read;\n-            let filename = &Path::new(\"./tmp/file_rt_io_file_test_seeking.txt\");\n-            {\n-                let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n-                rw_stream.write(message.as_bytes());\n-            }\n-            {\n-                let mut read_stream = open(filename, Open, Read).unwrap();\n-                read_stream.seek(set_cursor as i64, SeekSet);\n-                tell_pos_pre_read = read_stream.tell();\n-                read_stream.read(read_mem);\n-                tell_pos_post_read = read_stream.tell();\n-            }\n-            unlink(filename);\n-            let read_str = str::from_utf8(read_mem);\n-            assert!(read_str == message.slice(4, 8).to_owned());\n-            assert!(tell_pos_pre_read == set_cursor);\n-            assert!(tell_pos_post_read == message.len() as u64);\n-        }\n-    }\n-\n-    #[test]\n-    fn file_test_io_seek_and_write() {\n-        do run_in_mt_newsched_task {\n-            use str;\n-            let initial_msg =   \"food-is-yummy\";\n-            let overwrite_msg =    \"-the-bar!!\";\n-            let final_msg =     \"foo-the-bar!!\";\n-            let seek_idx = 3;\n-            let mut read_mem = [0, .. 13];\n-            let filename = &Path::new(\"./tmp/file_rt_io_file_test_seek_and_write.txt\");\n-            {\n-                let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n-                rw_stream.write(initial_msg.as_bytes());\n-                rw_stream.seek(seek_idx as i64, SeekSet);\n-                rw_stream.write(overwrite_msg.as_bytes());\n-            }\n-            {\n-                let mut read_stream = open(filename, Open, Read).unwrap();\n-                read_stream.read(read_mem);\n-            }\n-            unlink(filename);\n-            let read_str = str::from_utf8(read_mem);\n-            assert!(read_str == final_msg.to_owned());\n-        }\n-    }\n-\n-    #[test]\n-    fn file_test_io_seek_shakedown() {\n-        do run_in_mt_newsched_task {\n-            use str;          // 01234567890123\n-            let initial_msg =   \"qwer-asdf-zxcv\";\n-            let chunk_one = \"qwer\";\n-            let chunk_two = \"asdf\";\n-            let chunk_three = \"zxcv\";\n-            let mut read_mem = [0, .. 4];\n-            let filename = &Path::new(\"./tmp/file_rt_io_file_test_seek_shakedown.txt\");\n-            {\n-                let mut rw_stream = open(filename, Create, ReadWrite).unwrap();\n-                rw_stream.write(initial_msg.as_bytes());\n-            }\n-            {\n-                let mut read_stream = open(filename, Open, Read).unwrap();\n-\n-                read_stream.seek(-4, SeekEnd);\n-                read_stream.read(read_mem);\n-                let read_str = str::from_utf8(read_mem);\n-                assert!(read_str == chunk_three.to_owned());\n-\n-                read_stream.seek(-9, SeekCur);\n-                read_stream.read(read_mem);\n-                let read_str = str::from_utf8(read_mem);\n-                assert!(read_str == chunk_two.to_owned());\n-\n-                read_stream.seek(0, SeekSet);\n-                read_stream.read(read_mem);\n-                let read_str = str::from_utf8(read_mem);\n-                assert!(read_str == chunk_one.to_owned());\n-            }\n-            unlink(filename);\n-        }\n-    }\n-\n-    #[test]\n-    fn file_test_stat_is_correct_on_is_file() {\n-        do run_in_mt_newsched_task {\n-            let filename = &Path::new(\"./tmp/file_stat_correct_on_is_file.txt\");\n-            {\n-                let mut fs = open(filename, Create, ReadWrite).unwrap();\n-                let msg = \"hw\";\n-                fs.write(msg.as_bytes());\n-            }\n-            let stat_res = match stat(filename) {\n-                Some(s) => s,\n-                None => fail!(\"shouldn't happen\")\n-            };\n-            assert!(stat_res.is_file);\n-            unlink(filename);\n-        }\n-    }\n-\n-    #[test]\n-    fn file_test_stat_is_correct_on_is_dir() {\n-        do run_in_mt_newsched_task {\n-            let filename = &Path::new(\"./tmp/file_stat_correct_on_is_dir\");\n-            mkdir(filename);\n-            let stat_res = match stat(filename) {\n-                Some(s) => s,\n-                None => fail!(\"shouldn't happen\")\n-            };\n-            assert!(stat_res.is_dir);\n-            rmdir(filename);\n-        }\n-    }\n-\n-    #[test]\n-    fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n-        do run_in_mt_newsched_task {\n-            let dir = &Path::new(\"./tmp/fileinfo_false_on_dir\");\n-            mkdir(dir);\n-            assert!(dir.is_file() == false);\n-            rmdir(dir);\n-        }\n-    }\n-\n-    #[test]\n-    fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n-        do run_in_mt_newsched_task {\n-            let file = &Path::new(\"./tmp/fileinfo_check_exists_b_and_a.txt\");\n-            {\n-                let msg = \"foo\".as_bytes();\n-                let mut w = file.open_writer(Create);\n-                w.write(msg);\n-            }\n-            assert!(file.exists());\n-            file.unlink();\n-            assert!(!file.exists());\n-        }\n-    }\n-\n-    #[test]\n-    fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n-        do run_in_mt_newsched_task {\n-            let dir = &Path::new(\"./tmp/before_and_after_dir\");\n-            assert!(!dir.exists());\n-            dir.mkdir();\n-            assert!(dir.exists());\n-            assert!(dir.is_dir());\n-            dir.rmdir();\n-            assert!(!dir.exists());\n-        }\n-    }\n-\n-    #[test]\n-    fn file_test_directoryinfo_readdir() {\n-        use str;\n-        do run_in_mt_newsched_task {\n-            let dir = &Path::new(\"./tmp/di_readdir\");\n-            dir.mkdir();\n-            let prefix = \"foo\";\n-            for n in range(0,3) {\n-                let f = dir.join(format!(\"{}.txt\", n));\n-                let mut w = f.open_writer(Create);\n-                let msg_str = (prefix + n.to_str().to_owned()).to_owned();\n-                let msg = msg_str.as_bytes();\n-                w.write(msg);\n-            }\n-            match dir.readdir() {\n-                Some(files) => {\n-                    let mut mem = [0u8, .. 4];\n-                    for f in files.iter() {\n-                        {\n-                            let n = f.filestem_str();\n-                            let mut r = f.open_reader(Open);\n-                            r.read(mem);\n-                            let read_str = str::from_utf8(mem);\n-                            let expected = match n {\n-                                None|Some(\"\") => fail!(\"really shouldn't happen..\"),\n-                                Some(n) => prefix+n\n-                            };\n-                            assert!(expected == read_str);\n-                        }\n-                        f.unlink();\n-                    }\n-                },\n-                None => fail!(\"shouldn't happen\")\n-            }\n-            dir.rmdir();\n-        }\n-    }\n-}"}, {"sha": "22d7ea55f3b450859f2f8d95c78064390e3e30a2", "filename": "src/libstd/rt/io/fs.rs", "status": "added", "additions": 1247, "deletions": 0, "changes": 1247, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frt%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frt%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffs.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -0,0 +1,1247 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*! Synchronous File I/O\n+\n+This module provides a set of functions and traits for working\n+with regular files & directories on a filesystem.\n+\n+At the top-level of the module are a set of freestanding functions, associated\n+with various filesystem operations. They all operate on a `Path` object.\n+\n+All operations in this module, including those as part of `File` et al\n+block the task during execution. Most will raise `std::rt::io::io_error`\n+conditions in the event of failure.\n+\n+Also included in this module is an implementation block on the `Path` object\n+defined in `std::path::Path`. The impl adds useful methods about inspecting the\n+metadata of a file. This includes getting the `stat` information, reading off\n+particular bits of it, etc.\n+\n+# Example\n+\n+    use std::rt::io::{File, fs};\n+\n+    let path = Path::new(\"foo.txt\");\n+\n+    // create the file, whether it exists or not\n+    let mut file = File::create(&path);\n+    file.write(bytes!(\"foobar\"));\n+\n+    // open the file in read-only mode\n+    let mut file = File::open(&path);\n+    file.read_to_end();\n+\n+    println!(\"{}\", path.stat().size);\n+    fs::symlink(&path, &Path::new(\"bar.txt\"));\n+    fs::unlink(&path);\n+\n+*/\n+\n+use c_str::ToCStr;\n+use iter::Iterator;\n+use super::{Reader, Writer, Seek};\n+use super::{SeekStyle, Read, Write, Open, IoError, Truncate,\n+            FileMode, FileAccess, FileStat, io_error, FilePermission};\n+use rt::rtio::{RtioFileStream, IoFactory, with_local_io};\n+use rt::io;\n+use option::{Some, None, Option};\n+use result::{Ok, Err, Result};\n+use path;\n+use path::{Path, GenericPath};\n+use vec::OwnedVector;\n+\n+/// Unconstrained file access type that exposes read and write operations\n+///\n+/// Can be constructed via `File::open()`, `File::create()`, and\n+/// `File::open_mode()`.\n+///\n+/// # Errors\n+///\n+/// This type will raise an io_error condition if operations are attempted against\n+/// it for which its underlying file descriptor was not configured at creation\n+/// time, via the `FileAccess` parameter to `File::open_mode()`.\n+pub struct File {\n+    priv fd: ~RtioFileStream,\n+    priv path: Path,\n+    priv last_nread: int,\n+}\n+\n+fn io_raise<T>(f: &fn(io: &mut IoFactory) -> Result<T, IoError>) -> Option<T> {\n+    do with_local_io |io| {\n+        match f(io) {\n+            Ok(t) => Some(t),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+impl File {\n+    /// Open a file at `path` in the mode specified by the `mode` and `access`\n+    /// arguments\n+    ///\n+    /// # Example\n+    ///\n+    ///     use std::rt::io::{File, io_error, Open, ReadWrite};\n+    ///\n+    ///     let p = Path::new(\"/some/file/path.txt\");\n+    ///\n+    ///     do io_error::cond.trap(|_| {\n+    ///         // hoo-boy...\n+    ///     }).inside {\n+    ///         let file = match File::open_mode(&p, Open, ReadWrite) {\n+    ///             Some(s) => s,\n+    ///             None => fail!(\"whoops! I'm sure this raised, anyways..\")\n+    ///         };\n+    ///         // do some stuff with that file\n+    ///\n+    ///         // the file will be closed at the end of this block\n+    ///     }\n+    ///     // ..\n+    ///\n+    /// `FileMode` and `FileAccess` provide information about the permissions\n+    /// context in which a given stream is created. More information about them\n+    /// can be found in `std::rt::io`'s docs. If a file is opened with `Write`\n+    /// or `ReadWrite` access, then it will be created it it does not already\n+    /// exist.\n+    ///\n+    /// Note that, with this function, a `File` is returned regardless of the\n+    /// access-limitations indicated by `FileAccess` (e.g. calling `write` on a\n+    /// `File` opened as `Read` will raise an `io_error` condition at runtime).\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will raise an `io_error` condition under a number of\n+    /// different circumstances, to include but not limited to:\n+    ///\n+    /// * Opening a file that does not exist with `Read` access.\n+    /// * Attempting to open a file with a `FileAccess` that the user lacks\n+    ///   permissions for\n+    /// * Filesystem-level errors (full disk, etc)\n+    pub fn open_mode(path: &Path,\n+                     mode: FileMode,\n+                     access: FileAccess) -> Option<File> {\n+        do with_local_io |io| {\n+            match io.fs_open(&path.to_c_str(), mode, access) {\n+                Ok(fd) => Some(File {\n+                    path: path.clone(),\n+                    fd: fd,\n+                    last_nread: -1\n+                }),\n+                Err(ioerr) => {\n+                    io_error::cond.raise(ioerr);\n+                    None\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Attempts to open a file in read-only mode. This function is equivalent to\n+    /// `File::open_mode(path, Open, Read)`, and will raise all of the same\n+    /// errors that `File::open_mode` does.\n+    ///\n+    /// For more information, see the `File::open_mode` function.\n+    ///\n+    /// # Example\n+    ///\n+    ///     use std::rt::io::File;\n+    ///\n+    ///     let contents = File::open(&Path::new(\"foo.txt\")).read_to_end();\n+    pub fn open(path: &Path) -> Option<File> {\n+        File::open_mode(path, Open, Read)\n+    }\n+\n+    /// Attempts to create a file in write-only mode. This function is\n+    /// equivalent to `File::open_mode(path, Truncate, Write)`, and will\n+    /// raise all of the same errors that `File::open_mode` does.\n+    ///\n+    /// For more information, see the `File::open_mode` function.\n+    ///\n+    /// # Example\n+    ///\n+    ///     use std::rt::io::File;\n+    ///\n+    ///     let mut f = File::create(&Path::new(\"foo.txt\"));\n+    ///     f.write(bytes!(\"This is a sample file\"));\n+    pub fn create(path: &Path) -> Option<File> {\n+        File::open_mode(path, Truncate, Write)\n+    }\n+\n+    /// Returns the original path which was used to open this file.\n+    pub fn path<'a>(&'a self) -> &'a Path {\n+        &self.path\n+    }\n+\n+    /// Synchronizes all modifications to this file to its permanent storage\n+    /// device. This will flush any internal buffers necessary to perform this\n+    /// operation.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will raise on the `io_error` condition on failure.\n+    pub fn fsync(&mut self) {\n+        self.fd.fsync();\n+    }\n+\n+    /// This function is similar to `fsync`, except that it may not synchronize\n+    /// file metadata to the filesystem. This is intended for use case which\n+    /// must synchronize content, but don't need the metadata on disk. The goal\n+    /// of this method is to reduce disk operations.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will raise on the `io_error` condition on failure.\n+    pub fn datasync(&mut self) {\n+        self.fd.datasync();\n+    }\n+\n+    /// Either truncates or extends the underlying file, as extended from the\n+    /// file's current position. This is equivalent to the unix `truncate`\n+    /// function.\n+    ///\n+    /// The offset given is added to the file's current position and the result\n+    /// is the new size of the file. If the new size is less than the current\n+    /// size, then the file is truncated. If the new size is greater than the\n+    /// current size, then the file is expanded to be filled with 0s.\n+    ///\n+    /// # Errors\n+    ///\n+    /// On error, this function will raise on the `io_error` condition.\n+    pub fn truncate(&mut self, offset: i64) {\n+        self.fd.truncate(offset);\n+    }\n+}\n+\n+/// Unlink a file from the underlying filesystem.\n+///\n+/// # Example\n+///\n+///     use std::rt::io::fs;\n+///\n+///     let p = Path::new(\"/some/file/path.txt\");\n+///     fs::unlink(&p);\n+///     // if we made it here without failing, then the\n+///     // unlink operation was successful\n+///\n+/// Note that, just because an unlink call was successful, it is not\n+/// guaranteed that a file is immediately deleted (e.g. depending on\n+/// platform, other open file descriptors may prevent immediate removal)\n+///\n+/// # Errors\n+///\n+/// This function will raise an `io_error` condition if the path points to a\n+/// directory, the user lacks permissions to remove the file, or if some\n+/// other filesystem-level error occurs.\n+pub fn unlink(path: &Path) {\n+    do io_raise |io| { io.fs_unlink(&path.to_c_str()) };\n+}\n+\n+/// Given a path, query the file system to get information about a file,\n+/// directory, etc. This function will traverse symlinks to query\n+/// information about the destination file.\n+///\n+/// Returns a fully-filled out stat structure on succes, and on failure it\n+/// will return a dummy stat structure (it is expected that the condition\n+/// raised is handled as well).\n+///\n+/// # Example\n+///\n+///     use std::rt::io;\n+///     use std::rt::io::fs;\n+///\n+///     let p = Path::new(\"/some/file/path.txt\");\n+///     match io::result(|| fs::stat(&p)) {\n+///         Ok(stat) => { /* ... */ }\n+///         Err(e) => { /* handle error */ }\n+///     }\n+///\n+/// # Errors\n+///\n+/// This call will raise an `io_error` condition if the user lacks the\n+/// requisite permissions to perform a `stat` call on the given path or if\n+/// there is no entry in the filesystem at the provided path.\n+pub fn stat(path: &Path) -> FileStat {\n+    do io_raise |io| {\n+        io.fs_stat(&path.to_c_str())\n+    }.unwrap_or_else(dummystat)\n+}\n+\n+fn dummystat() -> FileStat {\n+    FileStat {\n+        path: Path::new(\"\"),\n+        size: 0,\n+        kind: io::TypeFile,\n+        perm: 0,\n+        created: 0,\n+        modified: 0,\n+        accessed: 0,\n+        unstable: io::UnstableFileStat {\n+            device: 0,\n+            inode: 0,\n+            rdev: 0,\n+            nlink: 0,\n+            uid: 0,\n+            gid: 0,\n+            blksize: 0,\n+            blocks: 0,\n+            flags: 0,\n+            gen: 0,\n+        }\n+    }\n+}\n+\n+/// Perform the same operation as the `stat` function, except that this\n+/// function does not traverse through symlinks. This will return\n+/// information about the symlink file instead of the file that it points\n+/// to.\n+///\n+/// # Errors\n+///\n+/// See `stat`\n+pub fn lstat(path: &Path) -> FileStat {\n+    do io_raise |io| {\n+        io.fs_lstat(&path.to_c_str())\n+    }.unwrap_or_else(dummystat)\n+}\n+\n+/// Rename a file or directory to a new name.\n+///\n+/// # Example\n+///\n+///     use std::rt::io::fs;\n+///\n+///     fs::rename(&Path::new(\"foo\"), &Path::new(\"bar\"));\n+///     // Oh boy, nothing was raised!\n+///\n+/// # Errors\n+///\n+/// Will raise an `io_error` condition if the provided `path` doesn't exist,\n+/// the process lacks permissions to view the contents, or if some other\n+/// intermittent I/O error occurs.\n+pub fn rename(from: &Path, to: &Path) {\n+    do io_raise |io| {\n+        io.fs_rename(&from.to_c_str(), &to.to_c_str())\n+    };\n+}\n+\n+/// Copies the contents of one file to another. This function will also\n+/// copy the permission bits of the original file to the destination file.\n+///\n+/// Note that if `from` and `to` both point to the same file, then the file\n+/// will likely get truncated by this operation.\n+///\n+/// # Example\n+///\n+///     use std::rt::io::fs;\n+///\n+///     fs::copy(&Path::new(\"foo.txt\"), &Path::new(\"bar.txt\"));\n+///     // Oh boy, nothing was raised!\n+///\n+/// # Errors\n+///\n+/// Will raise an `io_error` condition is the following situtations, but is\n+/// not limited to just these cases:\n+///\n+/// * The `from` path is not a file\n+/// * The `from` file does not exist\n+/// * The current process does not have the permission rights to access\n+///   `from` or write `to`\n+///\n+/// Note that this copy is not atomic in that once the destination is\n+/// ensured to not exist, there is nothing preventing the destination from\n+/// being created and then destroyed by this operation.\n+pub fn copy(from: &Path, to: &Path) {\n+    if !from.is_file() {\n+        return io_error::cond.raise(IoError {\n+            kind: io::MismatchedFileTypeForOperation,\n+            desc: \"the source path is not an existing file\",\n+            detail: None,\n+        });\n+    }\n+\n+    let mut reader = match File::open(from) { Some(f) => f, None => return };\n+    let mut writer = match File::create(to) { Some(f) => f, None => return };\n+    let mut buf = [0, ..io::DEFAULT_BUF_SIZE];\n+\n+    loop {\n+        match reader.read(buf) {\n+            Some(amt) => writer.write(buf.slice_to(amt)),\n+            None => break\n+        }\n+    }\n+\n+    chmod(to, from.stat().perm)\n+}\n+\n+/// Changes the permission mode bits found on a file or a directory. This\n+/// function takes a mask from the `io` module\n+///\n+/// # Example\n+///\n+///     use std::rt::io;\n+///     use std::rt::io::fs;\n+///\n+///     fs::chmod(&Path::new(\"file.txt\"), io::UserFile);\n+///     fs::chmod(&Path::new(\"file.txt\"), io::UserRead | io::UserWrite);\n+///     fs::chmod(&Path::new(\"dir\"),      io::UserDir);\n+///     fs::chmod(&Path::new(\"file.exe\"), io::UserExec);\n+///\n+/// # Errors\n+///\n+/// If this funciton encounters an I/O error, it will raise on the `io_error`\n+/// condition. Some possible error situations are not having the permission to\n+/// change the attributes of a file or the file not existing.\n+pub fn chmod(path: &Path, mode: io::FilePermission) {\n+    do io_raise |io| {\n+        io.fs_chmod(&path.to_c_str(), mode)\n+    };\n+}\n+\n+/// Change the user and group owners of a file at the specified path.\n+///\n+/// # Errors\n+///\n+/// This funtion will raise on the `io_error` condition on failure.\n+pub fn chown(path: &Path, uid: int, gid: int) {\n+    do io_raise |io| { io.fs_chown(&path.to_c_str(), uid, gid) };\n+}\n+\n+/// Creates a new hard link on the filesystem. The `dst` path will be a\n+/// link pointing to the `src` path. Note that systems often require these\n+/// two paths to both be located on the same filesystem.\n+///\n+/// # Errors\n+///\n+/// This function will raise on the `io_error` condition on failure.\n+pub fn link(src: &Path, dst: &Path) {\n+    do io_raise |io| { io.fs_link(&src.to_c_str(), &dst.to_c_str()) };\n+}\n+\n+/// Creates a new symbolic link on the filesystem. The `dst` path will be a\n+/// symlink pointing to the `src` path.\n+///\n+/// # Errors\n+///\n+/// This function will raise on the `io_error` condition on failure.\n+pub fn symlink(src: &Path, dst: &Path) {\n+    do io_raise |io| { io.fs_symlink(&src.to_c_str(), &dst.to_c_str()) };\n+}\n+\n+/// Reads a symlink, returning the file that the symlink points to.\n+///\n+/// # Errors\n+///\n+/// This function will raise on the `io_error` condition on failure. Failure\n+/// conditions include reading a file that does not exist or reading a file\n+/// which is not a symlink.\n+pub fn readlink(path: &Path) -> Option<Path> {\n+    do io_raise |io| { io.fs_readlink(&path.to_c_str()) }\n+}\n+\n+/// Create a new, empty directory at the provided path\n+///\n+/// # Example\n+///\n+///     use std::libc::S_IRWXU;\n+///     use std::rt::io::fs;\n+///\n+///     let p = Path::new(\"/some/dir\");\n+///     fs::mkdir(&p, S_IRWXU as int);\n+///     // If we got here, our directory exists! Horray!\n+///\n+/// # Errors\n+///\n+/// This call will raise an `io_error` condition if the user lacks permissions\n+/// to make a new directory at the provided path, or if the directory already\n+/// exists.\n+pub fn mkdir(path: &Path, mode: FilePermission) {\n+    do io_raise |io| {\n+        io.fs_mkdir(&path.to_c_str(), mode)\n+    };\n+}\n+\n+/// Remove an existing, empty directory\n+///\n+/// # Example\n+///\n+///     use std::rt::io::fs;\n+///\n+///     let p = Path::new(\"/some/dir\");\n+///     fs::rmdir(&p);\n+///     // good riddance, you mean ol' directory\n+///\n+/// # Errors\n+///\n+/// This call will raise an `io_error` condition if the user lacks permissions\n+/// to remove the directory at the provided path, or if the directory isn't\n+/// empty.\n+pub fn rmdir(path: &Path) {\n+    do io_raise |io| {\n+        io.fs_rmdir(&path.to_c_str())\n+    };\n+}\n+\n+/// Retrieve a vector containing all entries within a provided directory\n+///\n+/// # Example\n+///\n+///     use std::rt::io::fs;\n+///\n+///     // one possible implementation of fs::walk_dir only visiting files\n+///     fn visit_dirs(dir: &Path, cb: &fn(&Path)) {\n+///         if dir.is_dir() {\n+///             let contents = fs::readdir(dir).unwrap();\n+///             for entry in contents.iter() {\n+///                 if entry.is_dir() { visit_dirs(entry, cb); }\n+///                 else { cb(entry); }\n+///             }\n+///         }\n+///         else { fail!(\"nope\"); }\n+///     }\n+///\n+/// # Errors\n+///\n+/// Will raise an `io_error` condition if the provided `from` doesn't exist,\n+/// the process lacks permissions to view the contents or if the `path` points\n+/// at a non-directory file\n+pub fn readdir(path: &Path) -> ~[Path] {\n+    do io_raise |io| {\n+        io.fs_readdir(&path.to_c_str(), 0)\n+    }.unwrap_or_else(|| ~[])\n+}\n+\n+/// Returns an iterator which will recursively walk the directory structure\n+/// rooted at `path`. The path given will not be iterated over, and this will\n+/// perform iteration in a top-down order.\n+pub fn walk_dir(path: &Path) -> WalkIterator {\n+    WalkIterator { stack: readdir(path) }\n+}\n+\n+/// An iterator which walks over a directory\n+pub struct WalkIterator {\n+    priv stack: ~[Path],\n+}\n+\n+impl Iterator<Path> for WalkIterator {\n+    fn next(&mut self) -> Option<Path> {\n+        match self.stack.shift_opt() {\n+            Some(path) => {\n+                if path.is_dir() {\n+                    self.stack.push_all_move(readdir(&path));\n+                }\n+                Some(path)\n+            }\n+            None => None\n+        }\n+    }\n+}\n+\n+/// Recursively create a directory and all of its parent components if they\n+/// are missing.\n+///\n+/// # Errors\n+///\n+/// This function will raise on the `io_error` condition if an error\n+/// happens, see `fs::mkdir` for more information about error conditions\n+/// and performance.\n+pub fn mkdir_recursive(path: &Path, mode: FilePermission) {\n+    // tjc: if directory exists but with different permissions,\n+    // should we return false?\n+    if path.is_dir() {\n+        return\n+    }\n+    if path.filename().is_some() {\n+        mkdir_recursive(&path.dir_path(), mode);\n+    }\n+    mkdir(path, mode)\n+}\n+\n+/// Removes a directory at this path, after removing all its contents. Use\n+/// carefully!\n+///\n+/// # Errors\n+///\n+/// This function will raise on the `io_error` condition if an error\n+/// happens. See `file::unlink` and `fs::readdir` for possible error\n+/// conditions.\n+pub fn rmdir_recursive(path: &Path) {\n+    let children = readdir(path);\n+    for child in children.iter() {\n+        if child.is_dir() {\n+            rmdir_recursive(child);\n+        } else {\n+            unlink(child);\n+        }\n+    }\n+    // Directory should now be empty\n+    rmdir(path);\n+}\n+\n+impl Reader for File {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        match self.fd.read(buf) {\n+            Ok(read) => {\n+                self.last_nread = read;\n+                match read {\n+                    0 => None,\n+                    _ => Some(read as uint)\n+                }\n+            },\n+            Err(ioerr) => {\n+                // EOF is indicated by returning None\n+                if ioerr.kind != io::EndOfFile {\n+                    io_error::cond.raise(ioerr);\n+                }\n+                return None;\n+            }\n+        }\n+    }\n+\n+    fn eof(&mut self) -> bool { self.last_nread == 0 }\n+}\n+\n+impl Writer for File {\n+    fn write(&mut self, buf: &[u8]) {\n+        match self.fd.write(buf) {\n+            Ok(()) => (),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+            }\n+        }\n+    }\n+}\n+\n+impl Seek for File {\n+    fn tell(&self) -> u64 {\n+        let res = self.fd.tell();\n+        match res {\n+            Ok(cursor) => cursor,\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                return -1;\n+            }\n+        }\n+    }\n+\n+    fn seek(&mut self, pos: i64, style: SeekStyle) {\n+        match self.fd.seek(pos, style) {\n+            Ok(_) => {\n+                // successful seek resets EOF indicator\n+                self.last_nread = -1;\n+                ()\n+            },\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+            }\n+        }\n+    }\n+}\n+\n+impl path::Path {\n+    /// Get information on the file, directory, etc at this path.\n+    ///\n+    /// Consult the `file::stat` documentation for more info.\n+    ///\n+    /// This call preserves identical runtime/error semantics with `file::stat`.\n+    pub fn stat(&self) -> FileStat { stat(self) }\n+\n+    /// Boolean value indicator whether the underlying file exists on the local\n+    /// filesystem. This will return true if the path points to either a\n+    /// directory or a file.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Will not raise a condition\n+    pub fn exists(&self) -> bool {\n+        io::result(|| self.stat()).is_ok()\n+    }\n+\n+    /// Whether the underlying implemention (be it a file path, or something\n+    /// else) points at a \"regular file\" on the FS. Will return false for paths\n+    /// to non-existent locations or directories or other non-regular files\n+    /// (named pipes, etc).\n+    ///\n+    /// # Errors\n+    ///\n+    /// Will not raise a condition\n+    pub fn is_file(&self) -> bool {\n+        match io::result(|| self.stat()) {\n+            Ok(s) => s.kind == io::TypeFile,\n+            Err(*) => false\n+        }\n+    }\n+\n+    /// Whether the underlying implemention (be it a file path,\n+    /// or something else) is pointing at a directory in the underlying FS.\n+    /// Will return false for paths to non-existent locations or if the item is\n+    /// not a directory (eg files, named pipes, links, etc)\n+    ///\n+    /// # Errors\n+    ///\n+    /// Will not raise a condition\n+    pub fn is_dir(&self) -> bool {\n+        match io::result(|| self.stat()) {\n+            Ok(s) => s.kind == io::TypeDirectory,\n+            Err(*) => false\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use prelude::*;\n+    use rt::io::{SeekSet, SeekCur, SeekEnd, io_error, Read, Open, ReadWrite};\n+    use rt::io;\n+    use str;\n+    use super::{File, rmdir, mkdir, readdir, rmdir_recursive, mkdir_recursive,\n+                copy, unlink, stat, symlink, link, readlink, chmod, chown,\n+                lstat};\n+\n+    fn tmpdir() -> Path {\n+        use os;\n+        use rand;\n+        let ret = os::tmpdir().join(format!(\"rust-{}\", rand::random::<u32>()));\n+        mkdir(&ret, io::UserRWX);\n+        ret\n+    }\n+\n+    fn free<T>(_: T) {}\n+\n+    #[test]\n+    fn file_test_io_smoke_test() {\n+        let message = \"it's alright. have a good time\";\n+        let filename = &Path::new(\"./tmp/file_rt_io_file_test.txt\");\n+        {\n+            let mut write_stream = File::open_mode(filename, Open, ReadWrite);\n+            write_stream.write(message.as_bytes());\n+        }\n+        {\n+            let mut read_stream = File::open_mode(filename, Open, Read);\n+            let mut read_buf = [0, .. 1028];\n+            let read_str = match read_stream.read(read_buf).unwrap() {\n+                -1|0 => fail!(\"shouldn't happen\"),\n+                n => str::from_utf8(read_buf.slice_to(n))\n+            };\n+            assert!(read_str == message.to_owned());\n+        }\n+        unlink(filename);\n+    }\n+\n+    #[test]\n+    fn file_test_io_invalid_path_opened_without_create_should_raise_condition() {\n+        let filename = &Path::new(\"./tmp/file_that_does_not_exist.txt\");\n+        let mut called = false;\n+        do io_error::cond.trap(|_| {\n+            called = true;\n+        }).inside {\n+            let result = File::open_mode(filename, Open, Read);\n+            assert!(result.is_none());\n+        }\n+        assert!(called);\n+    }\n+\n+    #[test]\n+    fn file_test_iounlinking_invalid_path_should_raise_condition() {\n+        let filename = &Path::new(\"./tmp/file_another_file_that_does_not_exist.txt\");\n+        let mut called = false;\n+        do io_error::cond.trap(|_| {\n+            called = true;\n+        }).inside {\n+            unlink(filename);\n+        }\n+        assert!(called);\n+    }\n+\n+    #[test]\n+    fn file_test_io_non_positional_read() {\n+        let message = \"ten-four\";\n+        let mut read_mem = [0, .. 8];\n+        let filename = &Path::new(\"./tmp/file_rt_io_file_test_positional.txt\");\n+        {\n+            let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n+            rw_stream.write(message.as_bytes());\n+        }\n+        {\n+            let mut read_stream = File::open_mode(filename, Open, Read);\n+            {\n+                let read_buf = read_mem.mut_slice(0, 4);\n+                read_stream.read(read_buf);\n+            }\n+            {\n+                let read_buf = read_mem.mut_slice(4, 8);\n+                read_stream.read(read_buf);\n+            }\n+        }\n+        unlink(filename);\n+        let read_str = str::from_utf8(read_mem);\n+        assert!(read_str == message.to_owned());\n+    }\n+\n+    #[test]\n+    fn file_test_io_seek_and_tell_smoke_test() {\n+        let message = \"ten-four\";\n+        let mut read_mem = [0, .. 4];\n+        let set_cursor = 4 as u64;\n+        let mut tell_pos_pre_read;\n+        let mut tell_pos_post_read;\n+        let filename = &Path::new(\"./tmp/file_rt_io_file_test_seeking.txt\");\n+        {\n+            let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n+            rw_stream.write(message.as_bytes());\n+        }\n+        {\n+            let mut read_stream = File::open_mode(filename, Open, Read);\n+            read_stream.seek(set_cursor as i64, SeekSet);\n+            tell_pos_pre_read = read_stream.tell();\n+            read_stream.read(read_mem);\n+            tell_pos_post_read = read_stream.tell();\n+        }\n+        unlink(filename);\n+        let read_str = str::from_utf8(read_mem);\n+        assert!(read_str == message.slice(4, 8).to_owned());\n+        assert!(tell_pos_pre_read == set_cursor);\n+        assert!(tell_pos_post_read == message.len() as u64);\n+    }\n+\n+    #[test]\n+    fn file_test_io_seek_and_write() {\n+        let initial_msg =   \"food-is-yummy\";\n+        let overwrite_msg =    \"-the-bar!!\";\n+        let final_msg =     \"foo-the-bar!!\";\n+        let seek_idx = 3;\n+        let mut read_mem = [0, .. 13];\n+        let filename = &Path::new(\"./tmp/file_rt_io_file_test_seek_and_write.txt\");\n+        {\n+            let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n+            rw_stream.write(initial_msg.as_bytes());\n+            rw_stream.seek(seek_idx as i64, SeekSet);\n+            rw_stream.write(overwrite_msg.as_bytes());\n+        }\n+        {\n+            let mut read_stream = File::open_mode(filename, Open, Read);\n+            read_stream.read(read_mem);\n+        }\n+        unlink(filename);\n+        let read_str = str::from_utf8(read_mem);\n+        assert!(read_str == final_msg.to_owned());\n+    }\n+\n+    #[test]\n+    fn file_test_io_seek_shakedown() {\n+        use std::str;          // 01234567890123\n+        let initial_msg =   \"qwer-asdf-zxcv\";\n+        let chunk_one = \"qwer\";\n+        let chunk_two = \"asdf\";\n+        let chunk_three = \"zxcv\";\n+        let mut read_mem = [0, .. 4];\n+        let filename = &Path::new(\"./tmp/file_rt_io_file_test_seek_shakedown.txt\");\n+        {\n+            let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n+            rw_stream.write(initial_msg.as_bytes());\n+        }\n+        {\n+            let mut read_stream = File::open_mode(filename, Open, Read);\n+\n+            read_stream.seek(-4, SeekEnd);\n+            read_stream.read(read_mem);\n+            let read_str = str::from_utf8(read_mem);\n+            assert!(read_str == chunk_three.to_owned());\n+\n+            read_stream.seek(-9, SeekCur);\n+            read_stream.read(read_mem);\n+            let read_str = str::from_utf8(read_mem);\n+            assert!(read_str == chunk_two.to_owned());\n+\n+            read_stream.seek(0, SeekSet);\n+            read_stream.read(read_mem);\n+            let read_str = str::from_utf8(read_mem);\n+            assert!(read_str == chunk_one.to_owned());\n+        }\n+        unlink(filename);\n+    }\n+\n+    #[test]\n+    fn file_test_stat_is_correct_on_is_file() {\n+        let filename = &Path::new(\"./tmp/file_stat_correct_on_is_file.txt\");\n+        {\n+            let mut fs = File::open_mode(filename, Open, ReadWrite);\n+            let msg = \"hw\";\n+            fs.write(msg.as_bytes());\n+        }\n+        let stat_res = stat(filename);\n+        assert_eq!(stat_res.kind, io::TypeFile);\n+        unlink(filename);\n+    }\n+\n+    #[test]\n+    fn file_test_stat_is_correct_on_is_dir() {\n+        let filename = &Path::new(\"./tmp/file_stat_correct_on_is_dir\");\n+        mkdir(filename, io::UserRWX);\n+        let stat_res = filename.stat();\n+        assert!(stat_res.kind == io::TypeDirectory);\n+        rmdir(filename);\n+    }\n+\n+    #[test]\n+    fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n+        let dir = &Path::new(\"./tmp/fileinfo_false_on_dir\");\n+        mkdir(dir, io::UserRWX);\n+        assert!(dir.is_file() == false);\n+        rmdir(dir);\n+    }\n+\n+    #[test]\n+    fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n+        let file = &Path::new(\"./tmp/fileinfo_check_exists_b_and_a.txt\");\n+        File::create(file).write(bytes!(\"foo\"));\n+        assert!(file.exists());\n+        unlink(file);\n+        assert!(!file.exists());\n+    }\n+\n+    #[test]\n+    fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n+        let dir = &Path::new(\"./tmp/before_and_after_dir\");\n+        assert!(!dir.exists());\n+        mkdir(dir, io::UserRWX);\n+        assert!(dir.exists());\n+        assert!(dir.is_dir());\n+        rmdir(dir);\n+        assert!(!dir.exists());\n+    }\n+\n+    #[test]\n+    fn file_test_directoryinfo_readdir() {\n+        use std::str;\n+        let dir = &Path::new(\"./tmp/di_readdir\");\n+        mkdir(dir, io::UserRWX);\n+        let prefix = \"foo\";\n+        for n in range(0,3) {\n+            let f = dir.join(format!(\"{}.txt\", n));\n+            let mut w = File::create(&f);\n+            let msg_str = (prefix + n.to_str().to_owned()).to_owned();\n+            let msg = msg_str.as_bytes();\n+            w.write(msg);\n+        }\n+        let files = readdir(dir);\n+        let mut mem = [0u8, .. 4];\n+        for f in files.iter() {\n+            {\n+                let n = f.filestem_str();\n+                File::open(f).read(mem);\n+                let read_str = str::from_utf8(mem);\n+                let expected = match n {\n+                    None|Some(\"\") => fail!(\"really shouldn't happen..\"),\n+                    Some(n) => prefix+n\n+                };\n+                assert!(expected == read_str);\n+            }\n+            unlink(f);\n+        }\n+        rmdir(dir);\n+    }\n+\n+    #[test]\n+    fn recursive_mkdir_slash() {\n+        mkdir_recursive(&Path::new(\"/\"), io::UserRWX);\n+    }\n+\n+    #[test]\n+    fn unicode_path_is_dir() {\n+        assert!(Path::new(\".\").is_dir());\n+        assert!(!Path::new(\"test/stdtest/fs.rs\").is_dir());\n+\n+        let tmpdir = tmpdir();\n+\n+        let mut dirpath = tmpdir.clone();\n+        dirpath.push(format!(\"test-\uac00\u4e00\u30fc\u4f60\u597d\"));\n+        mkdir(&dirpath, io::UserRWX);\n+        assert!(dirpath.is_dir());\n+\n+        let mut filepath = dirpath;\n+        filepath.push(\"unicode-file-\\uac00\\u4e00\\u30fc\\u4f60\\u597d.rs\");\n+        File::create(&filepath); // ignore return; touch only\n+        assert!(!filepath.is_dir());\n+        assert!(filepath.exists());\n+\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn unicode_path_exists() {\n+        assert!(Path::new(\".\").exists());\n+        assert!(!Path::new(\"test/nonexistent-bogus-path\").exists());\n+\n+        let tmpdir = tmpdir();\n+        let unicode = tmpdir.clone();\n+        let unicode = unicode.join(format!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n+        mkdir(&unicode, io::UserRWX);\n+        assert!(unicode.exists());\n+        assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn copy_file_does_not_exist() {\n+        let from = Path::new(\"test/nonexistent-bogus-path\");\n+        let to = Path::new(\"test/other-bogus-path\");\n+        match io::result(|| copy(&from, &to)) {\n+            Ok(*) => fail!(),\n+            Err(*) => {\n+                assert!(!from.exists());\n+                assert!(!to.exists());\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn copy_file_ok() {\n+        let tmpdir = tmpdir();\n+        let input = tmpdir.join(\"in.txt\");\n+        let out = tmpdir.join(\"out.txt\");\n+\n+        File::create(&input).write(bytes!(\"hello\"));\n+        copy(&input, &out);\n+        let contents = File::open(&out).read_to_end();\n+        assert_eq!(contents.as_slice(), bytes!(\"hello\"));\n+\n+        assert_eq!(input.stat().perm, out.stat().perm);\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn copy_file_dst_dir() {\n+        let tmpdir = tmpdir();\n+        let out = tmpdir.join(\"out\");\n+\n+        File::create(&out);\n+        match io::result(|| copy(&out, &tmpdir)) {\n+            Ok(*) => fail!(), Err(*) => {}\n+        }\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn copy_file_dst_exists() {\n+        let tmpdir = tmpdir();\n+        let input = tmpdir.join(\"in\");\n+        let output = tmpdir.join(\"out\");\n+\n+        File::create(&input).write(\"foo\".as_bytes());\n+        File::create(&output).write(\"bar\".as_bytes());\n+        copy(&input, &output);\n+\n+        assert_eq!(File::open(&output).read_to_end(),\n+                   (bytes!(\"foo\")).to_owned());\n+\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn copy_file_src_dir() {\n+        let tmpdir = tmpdir();\n+        let out = tmpdir.join(\"out\");\n+\n+        match io::result(|| copy(&tmpdir, &out)) {\n+            Ok(*) => fail!(), Err(*) => {}\n+        }\n+        assert!(!out.exists());\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn copy_file_preserves_perm_bits() {\n+        let tmpdir = tmpdir();\n+        let input = tmpdir.join(\"in.txt\");\n+        let out = tmpdir.join(\"out.txt\");\n+\n+        File::create(&input);\n+        chmod(&input, io::UserRead);\n+        copy(&input, &out);\n+        assert!(out.stat().perm & io::UserWrite == 0);\n+\n+        chmod(&input, io::UserFile);\n+        chmod(&out, io::UserFile);\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    #[ignore(cfg(windows))] // FIXME(#10264) operation not permitted?\n+    fn symlinks_work() {\n+        let tmpdir = tmpdir();\n+        let input = tmpdir.join(\"in.txt\");\n+        let out = tmpdir.join(\"out.txt\");\n+\n+        File::create(&input).write(\"foobar\".as_bytes());\n+        symlink(&input, &out);\n+        assert_eq!(lstat(&out).kind, io::TypeSymlink);\n+        assert_eq!(stat(&out).size, stat(&input).size);\n+        assert_eq!(File::open(&out).read_to_end(), (bytes!(\"foobar\")).to_owned());\n+\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    #[ignore(cfg(windows))] // apparently windows doesn't like symlinks\n+    fn symlink_noexist() {\n+        let tmpdir = tmpdir();\n+        // symlinks can point to things that don't exist\n+        symlink(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\"));\n+        assert!(readlink(&tmpdir.join(\"bar\")).unwrap() == tmpdir.join(\"foo\"));\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn readlink_not_symlink() {\n+        let tmpdir = tmpdir();\n+        match io::result(|| readlink(&tmpdir)) {\n+            Ok(*) => fail!(\"wanted a failure\"),\n+            Err(*) => {}\n+        }\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn links_work() {\n+        let tmpdir = tmpdir();\n+        let input = tmpdir.join(\"in.txt\");\n+        let out = tmpdir.join(\"out.txt\");\n+\n+        File::create(&input).write(\"foobar\".as_bytes());\n+        link(&input, &out);\n+        assert_eq!(lstat(&out).kind, io::TypeFile);\n+        assert_eq!(stat(&out).size, stat(&input).size);\n+        assert_eq!(stat(&out).unstable.nlink, 2);\n+        assert_eq!(File::open(&out).read_to_end(), (bytes!(\"foobar\")).to_owned());\n+\n+        // can't link to yourself\n+        match io::result(|| link(&input, &input)) {\n+            Ok(*) => fail!(\"wanted a failure\"),\n+            Err(*) => {}\n+        }\n+        // can't link to something that doesn't exist\n+        match io::result(|| link(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\"))) {\n+            Ok(*) => fail!(\"wanted a failure\"),\n+            Err(*) => {}\n+        }\n+\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn chmod_works() {\n+        let tmpdir = tmpdir();\n+        let file = tmpdir.join(\"in.txt\");\n+\n+        File::create(&file);\n+        assert!(stat(&file).perm & io::UserWrite == io::UserWrite);\n+        chmod(&file, io::UserRead);\n+        assert!(stat(&file).perm & io::UserWrite == 0);\n+\n+        match io::result(|| chmod(&tmpdir.join(\"foo\"), io::UserRWX)) {\n+            Ok(*) => fail!(\"wanted a failure\"),\n+            Err(*) => {}\n+        }\n+\n+        chmod(&file, io::UserFile);\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn sync_doesnt_kill_anything() {\n+        let tmpdir = tmpdir();\n+        let path = tmpdir.join(\"in.txt\");\n+\n+        let mut file = File::open_mode(&path, io::Open, io::ReadWrite).unwrap();\n+        file.fsync();\n+        file.datasync();\n+        file.write(bytes!(\"foo\"));\n+        file.fsync();\n+        file.datasync();\n+        free(file);\n+\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn truncate_works() {\n+        let tmpdir = tmpdir();\n+        let path = tmpdir.join(\"in.txt\");\n+\n+        let mut file = File::open_mode(&path, io::Open, io::ReadWrite).unwrap();\n+        file.write(bytes!(\"foo\"));\n+\n+        // Do some simple things with truncation\n+        assert_eq!(stat(&path).size, 3);\n+        file.truncate(10);\n+        assert_eq!(stat(&path).size, 10);\n+        file.write(bytes!(\"bar\"));\n+        assert_eq!(stat(&path).size, 10);\n+        assert_eq!(File::open(&path).read_to_end(),\n+                   (bytes!(\"foobar\", 0, 0, 0, 0)).to_owned());\n+\n+        // Truncate to a smaller length, don't seek, and then write something.\n+        // Ensure that the intermediate zeroes are all filled in (we're seeked\n+        // past the end of the file).\n+        file.truncate(2);\n+        assert_eq!(stat(&path).size, 2);\n+        file.write(bytes!(\"wut\"));\n+        assert_eq!(stat(&path).size, 9);\n+        assert_eq!(File::open(&path).read_to_end(),\n+                   (bytes!(\"fo\", 0, 0, 0, 0, \"wut\")).to_owned());\n+        free(file);\n+\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn open_flavors() {\n+        let tmpdir = tmpdir();\n+\n+        match io::result(|| File::open_mode(&tmpdir.join(\"a\"), io::Open,\n+                                            io::Read)) {\n+            Ok(*) => fail!(), Err(*) => {}\n+        }\n+        File::open_mode(&tmpdir.join(\"b\"), io::Open, io::Write).unwrap();\n+        File::open_mode(&tmpdir.join(\"c\"), io::Open, io::ReadWrite).unwrap();\n+        File::open_mode(&tmpdir.join(\"d\"), io::Append, io::Write).unwrap();\n+        File::open_mode(&tmpdir.join(\"e\"), io::Append, io::ReadWrite).unwrap();\n+        File::open_mode(&tmpdir.join(\"f\"), io::Truncate, io::Write).unwrap();\n+        File::open_mode(&tmpdir.join(\"g\"), io::Truncate, io::ReadWrite).unwrap();\n+\n+        File::create(&tmpdir.join(\"h\")).write(\"foo\".as_bytes());\n+        File::open_mode(&tmpdir.join(\"h\"), io::Open, io::Read).unwrap();\n+        {\n+            let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Open,\n+                                        io::Read).unwrap();\n+            match io::result(|| f.write(\"wut\".as_bytes())) {\n+                Ok(*) => fail!(), Err(*) => {}\n+            }\n+        }\n+        assert_eq!(stat(&tmpdir.join(\"h\")).size, 3);\n+        {\n+            let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Append,\n+                                        io::Write).unwrap();\n+            f.write(\"bar\".as_bytes());\n+        }\n+        assert_eq!(stat(&tmpdir.join(\"h\")).size, 6);\n+        {\n+            let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Truncate,\n+                                        io::Write).unwrap();\n+            f.write(\"bar\".as_bytes());\n+        }\n+        assert_eq!(stat(&tmpdir.join(\"h\")).size, 3);\n+\n+        rmdir_recursive(&tmpdir);\n+    }\n+}"}, {"sha": "f01ce5012eb25378918f5487848e1b77eb7643f5", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 117, "deletions": 37, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -231,8 +231,6 @@ Out of scope\n * Trait for things that are both readers and writers, Stream?\n * How to handle newline conversion\n * String conversion\n-* File vs. FileStream? File is shorter but could also be used for getting file info\n-  - maybe File is for general file querying and *also* has a static `open` method\n * open vs. connect for generic stream opening\n * Do we need `close` at all? dtors might be good enough\n * How does I/O relate to the Iterator trait?\n@@ -245,8 +243,10 @@ Out of scope\n use cast;\n use int;\n use path::Path;\n-use prelude::*;\n use str::{StrSlice, OwnedStr};\n+use option::{Option, Some, None};\n+use result::{Ok, Err, Result};\n+use iter::Iterator;\n use to_str::ToStr;\n use uint;\n use unstable::finally::Finally;\n@@ -259,7 +259,7 @@ pub use self::stdio::stderr;\n pub use self::stdio::print;\n pub use self::stdio::println;\n \n-pub use self::file::FileStream;\n+pub use self::fs::File;\n pub use self::timer::Timer;\n pub use self::net::ip::IpAddr;\n pub use self::net::tcp::TcpListener;\n@@ -268,8 +268,8 @@ pub use self::net::udp::UdpStream;\n pub use self::pipe::PipeStream;\n pub use self::process::Process;\n \n-/// Synchronous, non-blocking file I/O.\n-pub mod file;\n+/// Synchronous, non-blocking filesystem operations.\n+pub mod fs;\n \n /// Synchronous, in-memory I/O.\n pub mod pipe;\n@@ -418,6 +418,18 @@ pub fn ignore_io_error<T>(cb: &fn() -> T) -> T {\n     }\n }\n \n+/// Helper for catching an I/O error and wrapping it in a Result object. The\n+/// return result will be the last I/O error that happened or the result of the\n+/// closure if no error occurred.\n+pub fn result<T>(cb: &fn() -> T) -> Result<T, IoError> {\n+    let mut err = None;\n+    let ret = io_error::cond.trap(|e| err = Some(e)).inside(cb);\n+    match err {\n+        Some(e) => Err(e),\n+        None => Ok(ret),\n+    }\n+}\n+\n pub trait Reader {\n \n     // Only two methods which need to get implemented for this trait\n@@ -450,7 +462,7 @@ pub trait Reader {\n     ///\n     /// # Example\n     ///\n-    ///     let reader = FileStream::new()\n+    ///     let reader = File::open(&Path::new(\"foo.txt\"))\n     ///     while !reader.eof() {\n     ///         println(reader.read_line());\n     ///     }\n@@ -1089,51 +1101,119 @@ pub fn placeholder_error() -> IoError {\n     }\n }\n \n-/// Instructions on how to open a file and return a `FileStream`.\n+/// A mode specifies how a file should be opened or created. These modes are\n+/// passed to `File::open_mode` and are used to control where the file is\n+/// positioned when it is initially opened.\n pub enum FileMode {\n-    /// Opens an existing file. IoError if file does not exist.\n+    /// Opens a file positioned at the beginning.\n     Open,\n-    /// Creates a file. IoError if file exists.\n-    Create,\n-    /// Opens an existing file or creates a new one.\n-    OpenOrCreate,\n-    /// Opens an existing file or creates a new one, positioned at EOF.\n+    /// Opens a file positioned at EOF.\n     Append,\n-    /// Opens an existing file, truncating it to 0 bytes.\n+    /// Opens a file, truncating it if it already exists.\n     Truncate,\n-    /// Opens an existing file or creates a new one, truncating it to 0 bytes.\n-    CreateOrTruncate,\n }\n \n-/// Access permissions with which the file should be opened.\n-/// `FileStream`s opened with `Read` will raise an `io_error` condition if written to.\n+/// Access permissions with which the file should be opened. `File`s\n+/// opened with `Read` will raise an `io_error` condition if written to.\n pub enum FileAccess {\n     Read,\n     Write,\n-    ReadWrite\n+    ReadWrite,\n+}\n+\n+/// Different kinds of files which can be identified by a call to stat\n+#[deriving(Eq)]\n+pub enum FileType {\n+    TypeFile,\n+    TypeDirectory,\n+    TypeNamedPipe,\n+    TypeBlockSpecial,\n+    TypeSymlink,\n+    TypeUnknown,\n }\n \n pub struct FileStat {\n-    /// A `Path` object containing information about the `PathInfo`'s location\n+    /// The path that this stat structure is describing\n     path: Path,\n-    /// `true` if the file pointed at by the `PathInfo` is a regular file\n-    is_file: bool,\n-    /// `true` if the file pointed at by the `PathInfo` is a directory\n-    is_dir: bool,\n-    /// The file pointed at by the `PathInfo`'s device\n-    device: u64,\n-    /// The file pointed at by the `PathInfo`'s mode\n-    mode: u64,\n-    /// The file pointed at by the `PathInfo`'s inode\n-    inode: u64,\n-    /// The file pointed at by the `PathInfo`'s size in bytes\n+    /// The size of the file, in bytes\n     size: u64,\n-    /// The file pointed at by the `PathInfo`'s creation time\n+    /// The kind of file this path points to (directory, file, pipe, etc.)\n+    kind: FileType,\n+    /// The file permissions currently on the file\n+    perm: FilePermission,\n+\n+    // XXX: These time fields are pretty useless without an actual time\n+    //      representation, what are the milliseconds relative to?\n+\n+    /// The time that the file was created at, in platform-dependent\n+    /// milliseconds\n     created: u64,\n-    /// The file pointed at by the `PathInfo`'s last-modification time in\n-    /// platform-dependent msecs\n+    /// The time that this file was last modified, in platform-dependent\n+    /// milliseconds\n     modified: u64,\n-    /// The file pointed at by the `PathInfo`'s last-accessd time (e.g. read) in\n-    /// platform-dependent msecs\n+    /// The time that this file was last accessed, in platform-dependent\n+    /// milliseconds\n     accessed: u64,\n+\n+    /// Information returned by stat() which is not guaranteed to be\n+    /// platform-independent. This information may be useful on some platforms,\n+    /// but it may have different meanings or no meaning at all on other\n+    /// platforms.\n+    ///\n+    /// Usage of this field is discouraged, but if access is desired then the\n+    /// fields are located here.\n+    #[unstable]\n+    unstable: UnstableFileStat,\n+}\n+\n+/// This structure represents all of the possible information which can be\n+/// returned from a `stat` syscall which is not contained in the `FileStat`\n+/// structure. This information is not necessarily platform independent, and may\n+/// have different meanings or no meaning at all on some platforms.\n+#[unstable]\n+pub struct UnstableFileStat {\n+    device: u64,\n+    inode: u64,\n+    rdev: u64,\n+    nlink: u64,\n+    uid: u64,\n+    gid: u64,\n+    blksize: u64,\n+    blocks: u64,\n+    flags: u64,\n+    gen: u64,\n }\n+\n+/// A set of permissions for a file or directory is represented by a set of\n+/// flags which are or'd together.\n+pub type FilePermission = u32;\n+\n+// Each permission bit\n+pub static UserRead: FilePermission     = 0x100;\n+pub static UserWrite: FilePermission    = 0x080;\n+pub static UserExecute: FilePermission  = 0x040;\n+pub static GroupRead: FilePermission    = 0x020;\n+pub static GroupWrite: FilePermission   = 0x010;\n+pub static GroupExecute: FilePermission = 0x008;\n+pub static OtherRead: FilePermission    = 0x004;\n+pub static OtherWrite: FilePermission   = 0x002;\n+pub static OtherExecute: FilePermission = 0x001;\n+\n+// Common combinations of these bits\n+pub static UserRWX: FilePermission  = UserRead | UserWrite | UserExecute;\n+pub static GroupRWX: FilePermission = GroupRead | GroupWrite | GroupExecute;\n+pub static OtherRWX: FilePermission = OtherRead | OtherWrite | OtherExecute;\n+\n+/// A set of permissions for user owned files, this is equivalent to 0644 on\n+/// unix-like systems.\n+pub static UserFile: FilePermission = UserRead | UserWrite | GroupRead | OtherRead;\n+/// A set of permissions for user owned directories, this is equivalent to 0755\n+/// on unix-like systems.\n+pub static UserDir: FilePermission = UserRWX | GroupRead | GroupExecute |\n+                                     OtherRead | OtherExecute;\n+/// A set of permissions for user owned executables, this is equivalent to 0755\n+/// on unix-like systems.\n+pub static UserExec: FilePermission = UserDir;\n+\n+/// A mask for all possible permission bits\n+pub static AllPermissions: FilePermission = 0x1ff;"}, {"sha": "35057f475cf5a8b05f29d107dea8f39089a59c29", "filename": "src/libstd/rt/io/native/file.rs", "status": "modified", "additions": 485, "deletions": 0, "changes": 485, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -297,3 +297,488 @@ mod tests {\n         }\n     }\n }\n+\n+// n.b. these functions were all part of the old `std::os` module. There's lots\n+//      of fun little nuances that were taken care of by these functions, but\n+//      they are all thread-blocking versions that are no longer desired (we now\n+//      use a non-blocking event loop implementation backed by libuv).\n+//\n+//      In theory we will have a thread-blocking version of the event loop (if\n+//      desired), so these functions may just need to get adapted to work in\n+//      those situtations. For now, I'm leaving the code around so it doesn't\n+//      get bitrotted instantaneously.\n+mod old_os {\n+    use prelude::*;\n+    use libc::{size_t, c_void, c_int};\n+    use libc;\n+    use vec;\n+\n+    #[cfg(not(windows))] use c_str::CString;\n+    #[cfg(not(windows))] use libc::fclose;\n+    #[cfg(test)] #[cfg(windows)] use os;\n+    #[cfg(test)] use rand;\n+    #[cfg(windows)] use str;\n+    #[cfg(windows)] use ptr;\n+\n+    // On Windows, wide character version of function must be used to support\n+    // unicode, so functions should be split into at least two versions,\n+    // which are for Windows and for non-Windows, if necessary.\n+    // See https://github.com/mozilla/rust/issues/9822 for more information.\n+\n+    mod rustrt {\n+        use libc::{c_char, c_int};\n+        use libc;\n+\n+        extern {\n+            pub fn rust_path_is_dir(path: *libc::c_char) -> c_int;\n+            pub fn rust_path_exists(path: *libc::c_char) -> c_int;\n+        }\n+\n+        // Uses _wstat instead of stat.\n+        #[cfg(windows)]\n+        extern {\n+            pub fn rust_path_is_dir_u16(path: *u16) -> c_int;\n+            pub fn rust_path_exists_u16(path: *u16) -> c_int;\n+        }\n+    }\n+\n+    /// Recursively walk a directory structure\n+    pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) -> bool {\n+        let r = list_dir(p);\n+        r.iter().advance(|q| {\n+            let path = &p.join(q);\n+            f(path) && (!path_is_dir(path) || walk_dir(path, |p| f(p)))\n+        })\n+    }\n+\n+    #[cfg(unix)]\n+    /// Indicates whether a path represents a directory\n+    pub fn path_is_dir(p: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n+        unsafe {\n+            do p.with_c_str |buf| {\n+                rustrt::rust_path_is_dir(buf) != 0 as c_int\n+            }\n+        }\n+    }\n+\n+\n+    #[cfg(windows)]\n+    pub fn path_is_dir(p: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n+        unsafe {\n+            do os::win32::as_utf16_p(p.as_str().unwrap()) |buf| {\n+                rustrt::rust_path_is_dir_u16(buf) != 0 as c_int\n+            }\n+        }\n+    }\n+\n+    #[cfg(unix)]\n+    /// Indicates whether a path exists\n+    pub fn path_exists(p: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n+        unsafe {\n+            do p.with_c_str |buf| {\n+                rustrt::rust_path_exists(buf) != 0 as c_int\n+            }\n+        }\n+    }\n+\n+    #[cfg(windows)]\n+    pub fn path_exists(p: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n+        unsafe {\n+            do os::win32::as_utf16_p(p.as_str().unwrap()) |buf| {\n+                rustrt::rust_path_exists_u16(buf) != 0 as c_int\n+            }\n+        }\n+    }\n+\n+    /// Creates a directory at the specified path\n+    pub fn make_dir(p: &Path, mode: c_int) -> bool {\n+        return mkdir(p, mode);\n+\n+        #[cfg(windows)]\n+        fn mkdir(p: &Path, _mode: c_int) -> bool {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            unsafe {\n+                use os::win32::as_utf16_p;\n+                // FIXME: turn mode into something useful? #2623\n+                do as_utf16_p(p.as_str().unwrap()) |buf| {\n+                    libc::CreateDirectoryW(buf, ptr::mut_null())\n+                        != (0 as libc::BOOL)\n+                }\n+            }\n+        }\n+\n+        #[cfg(unix)]\n+        fn mkdir(p: &Path, mode: c_int) -> bool {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            do p.with_c_str |buf| {\n+                unsafe {\n+                    libc::mkdir(buf, mode as libc::mode_t) == (0 as c_int)\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Creates a directory with a given mode.\n+    /// Returns true iff creation\n+    /// succeeded. Also creates all intermediate subdirectories\n+    /// if they don't already exist, giving all of them the same mode.\n+\n+    // tjc: if directory exists but with different permissions,\n+    // should we return false?\n+    pub fn mkdir_recursive(p: &Path, mode: c_int) -> bool {\n+        if path_is_dir(p) {\n+            return true;\n+        }\n+        if p.filename().is_some() {\n+            let mut p_ = p.clone();\n+            p_.pop();\n+            if !mkdir_recursive(&p_, mode) {\n+                return false;\n+            }\n+        }\n+        return make_dir(p, mode);\n+    }\n+\n+    /// Lists the contents of a directory\n+    ///\n+    /// Each resulting Path is a relative path with no directory component.\n+    pub fn list_dir(p: &Path) -> ~[Path] {\n+        unsafe {\n+            #[cfg(target_os = \"linux\")]\n+            #[cfg(target_os = \"android\")]\n+            #[cfg(target_os = \"freebsd\")]\n+            #[cfg(target_os = \"macos\")]\n+            unsafe fn get_list(p: &Path) -> ~[Path] {\n+                #[fixed_stack_segment]; #[inline(never)];\n+                use libc::{dirent_t};\n+                use libc::{opendir, readdir, closedir};\n+                extern {\n+                    fn rust_list_dir_val(ptr: *dirent_t) -> *libc::c_char;\n+                }\n+                let mut paths = ~[];\n+                debug!(\"os::list_dir -- BEFORE OPENDIR\");\n+\n+                let dir_ptr = do p.with_c_str |buf| {\n+                    opendir(buf)\n+                };\n+\n+                if (dir_ptr as uint != 0) {\n+                    debug!(\"os::list_dir -- opendir() SUCCESS\");\n+                    let mut entry_ptr = readdir(dir_ptr);\n+                    while (entry_ptr as uint != 0) {\n+                        let cstr = CString::new(rust_list_dir_val(entry_ptr), false);\n+                        paths.push(Path::new(cstr));\n+                        entry_ptr = readdir(dir_ptr);\n+                    }\n+                    closedir(dir_ptr);\n+                }\n+                else {\n+                    debug!(\"os::list_dir -- opendir() FAILURE\");\n+                }\n+                debug!(\"os::list_dir -- AFTER -- \\\\#: {}\", paths.len());\n+                paths\n+            }\n+            #[cfg(windows)]\n+            unsafe fn get_list(p: &Path) -> ~[Path] {\n+                #[fixed_stack_segment]; #[inline(never)];\n+                use libc::consts::os::extra::INVALID_HANDLE_VALUE;\n+                use libc::{wcslen, free};\n+                use libc::funcs::extra::kernel32::{\n+                    FindFirstFileW,\n+                    FindNextFileW,\n+                    FindClose,\n+                };\n+                use libc::types::os::arch::extra::HANDLE;\n+                use os::win32::{\n+                    as_utf16_p\n+                };\n+                use rt::global_heap::malloc_raw;\n+\n+                #[nolink]\n+                extern {\n+                    fn rust_list_dir_wfd_size() -> libc::size_t;\n+                    fn rust_list_dir_wfd_fp_buf(wfd: *libc::c_void) -> *u16;\n+                }\n+                let star = p.join(\"*\");\n+                do as_utf16_p(star.as_str().unwrap()) |path_ptr| {\n+                    let mut paths = ~[];\n+                    let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n+                    let find_handle = FindFirstFileW(path_ptr, wfd_ptr as HANDLE);\n+                    if find_handle as libc::c_int != INVALID_HANDLE_VALUE {\n+                        let mut more_files = 1 as libc::c_int;\n+                        while more_files != 0 {\n+                            let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr);\n+                            if fp_buf as uint == 0 {\n+                                fail!(\"os::list_dir() failure: got null ptr from wfd\");\n+                            }\n+                            else {\n+                                let fp_vec = vec::from_buf(\n+                                    fp_buf, wcslen(fp_buf) as uint);\n+                                let fp_str = str::from_utf16(fp_vec);\n+                                paths.push(Path::new(fp_str));\n+                            }\n+                            more_files = FindNextFileW(find_handle, wfd_ptr as HANDLE);\n+                        }\n+                        FindClose(find_handle);\n+                        free(wfd_ptr)\n+                    }\n+                    paths\n+                }\n+            }\n+            do get_list(p).move_iter().filter |path| {\n+                path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n+            }.collect()\n+        }\n+    }\n+\n+    /// Removes a directory at the specified path, after removing\n+    /// all its contents. Use carefully!\n+    pub fn remove_dir_recursive(p: &Path) -> bool {\n+        let mut error_happened = false;\n+        do walk_dir(p) |inner| {\n+            if !error_happened {\n+                if path_is_dir(inner) {\n+                    if !remove_dir_recursive(inner) {\n+                        error_happened = true;\n+                    }\n+                }\n+                else {\n+                    if !remove_file(inner) {\n+                        error_happened = true;\n+                    }\n+                }\n+            }\n+            true\n+        };\n+        // Directory should now be empty\n+        !error_happened && remove_dir(p)\n+    }\n+\n+    /// Removes a directory at the specified path\n+    pub fn remove_dir(p: &Path) -> bool {\n+       return rmdir(p);\n+\n+        #[cfg(windows)]\n+        fn rmdir(p: &Path) -> bool {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            unsafe {\n+                use os::win32::as_utf16_p;\n+                return do as_utf16_p(p.as_str().unwrap()) |buf| {\n+                    libc::RemoveDirectoryW(buf) != (0 as libc::BOOL)\n+                };\n+            }\n+        }\n+\n+        #[cfg(unix)]\n+        fn rmdir(p: &Path) -> bool {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            do p.with_c_str |buf| {\n+                unsafe {\n+                    libc::rmdir(buf) == (0 as c_int)\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Deletes an existing file\n+    pub fn remove_file(p: &Path) -> bool {\n+        return unlink(p);\n+\n+        #[cfg(windows)]\n+        fn unlink(p: &Path) -> bool {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            unsafe {\n+                use os::win32::as_utf16_p;\n+                return do as_utf16_p(p.as_str().unwrap()) |buf| {\n+                    libc::DeleteFileW(buf) != (0 as libc::BOOL)\n+                };\n+            }\n+        }\n+\n+        #[cfg(unix)]\n+        fn unlink(p: &Path) -> bool {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            unsafe {\n+                do p.with_c_str |buf| {\n+                    libc::unlink(buf) == (0 as c_int)\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Renames an existing file or directory\n+    pub fn rename_file(old: &Path, new: &Path) -> bool {\n+        #[fixed_stack_segment]; #[inline(never)];\n+        unsafe {\n+           do old.with_c_str |old_buf| {\n+                do new.with_c_str |new_buf| {\n+                    libc::rename(old_buf, new_buf) == (0 as c_int)\n+                }\n+           }\n+        }\n+    }\n+\n+    /// Copies a file from one location to another\n+    pub fn copy_file(from: &Path, to: &Path) -> bool {\n+        return do_copy_file(from, to);\n+\n+        #[cfg(windows)]\n+        fn do_copy_file(from: &Path, to: &Path) -> bool {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            unsafe {\n+                use os::win32::as_utf16_p;\n+                return do as_utf16_p(from.as_str().unwrap()) |fromp| {\n+                    do as_utf16_p(to.as_str().unwrap()) |top| {\n+                        libc::CopyFileW(fromp, top, (0 as libc::BOOL)) !=\n+                            (0 as libc::BOOL)\n+                    }\n+                }\n+            }\n+        }\n+\n+        #[cfg(unix)]\n+        fn do_copy_file(from: &Path, to: &Path) -> bool {\n+            #[fixed_stack_segment]; #[inline(never)];\n+            unsafe {\n+                let istream = do from.with_c_str |fromp| {\n+                    do \"rb\".with_c_str |modebuf| {\n+                        libc::fopen(fromp, modebuf)\n+                    }\n+                };\n+                if istream as uint == 0u {\n+                    return false;\n+                }\n+                // Preserve permissions\n+                let from_mode = from.stat().perm;\n+\n+                let ostream = do to.with_c_str |top| {\n+                    do \"w+b\".with_c_str |modebuf| {\n+                        libc::fopen(top, modebuf)\n+                    }\n+                };\n+                if ostream as uint == 0u {\n+                    fclose(istream);\n+                    return false;\n+                }\n+                let bufsize = 8192u;\n+                let mut buf = vec::with_capacity::<u8>(bufsize);\n+                let mut done = false;\n+                let mut ok = true;\n+                while !done {\n+                    do buf.as_mut_buf |b, _sz| {\n+                      let nread = libc::fread(b as *mut c_void, 1u as size_t,\n+                                              bufsize as size_t,\n+                                              istream);\n+                      if nread > 0 as size_t {\n+                          if libc::fwrite(b as *c_void, 1u as size_t, nread,\n+                                          ostream) != nread {\n+                              ok = false;\n+                              done = true;\n+                          }\n+                      } else {\n+                          done = true;\n+                      }\n+                  }\n+                }\n+                fclose(istream);\n+                fclose(ostream);\n+\n+                // Give the new file the old file's permissions\n+                if do to.with_c_str |to_buf| {\n+                    libc::chmod(to_buf, from_mode as libc::mode_t)\n+                } != 0 {\n+                    return false; // should be a condition...\n+                }\n+                return ok;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn tmpdir() {\n+        let p = os::tmpdir();\n+        let s = p.as_str();\n+        assert!(s.is_some() && s.unwrap() != \".\");\n+    }\n+\n+    // Issue #712\n+    #[test]\n+    fn test_list_dir_no_invalid_memory_access() {\n+        list_dir(&Path::new(\".\"));\n+    }\n+\n+    #[test]\n+    fn test_list_dir() {\n+        let dirs = list_dir(&Path::new(\".\"));\n+        // Just assuming that we've got some contents in the current directory\n+        assert!(dirs.len() > 0u);\n+\n+        for dir in dirs.iter() {\n+            debug!(\"{:?}\", (*dir).clone());\n+        }\n+    }\n+\n+    #[test]\n+    #[cfg(not(windows))]\n+    fn test_list_dir_root() {\n+        let dirs = list_dir(&Path::new(\"/\"));\n+        assert!(dirs.len() > 1);\n+    }\n+    #[test]\n+    #[cfg(windows)]\n+    fn test_list_dir_root() {\n+        let dirs = list_dir(&Path::new(\"C:\\\\\"));\n+        assert!(dirs.len() > 1);\n+    }\n+\n+    #[test]\n+    fn test_path_is_dir() {\n+        use rt::io::fs::{mkdir_recursive};\n+        use rt::io::{File, UserRWX};\n+\n+        assert!((path_is_dir(&Path::new(\".\"))));\n+        assert!((!path_is_dir(&Path::new(\"test/stdtest/fs.rs\"))));\n+\n+        let mut dirpath = os::tmpdir();\n+        dirpath.push(format!(\"rust-test-{}/test-\\uac00\\u4e00\\u30fc\\u4f60\\u597d\",\n+            rand::random::<u32>())); // \uac00\u4e00\u30fc\u4f60\u597d\n+        debug!(\"path_is_dir dirpath: {}\", dirpath.display());\n+\n+        mkdir_recursive(&dirpath, UserRWX);\n+\n+        assert!((path_is_dir(&dirpath)));\n+\n+        let mut filepath = dirpath;\n+        filepath.push(\"unicode-file-\\uac00\\u4e00\\u30fc\\u4f60\\u597d.rs\");\n+        debug!(\"path_is_dir filepath: {}\", filepath.display());\n+\n+        File::create(&filepath); // ignore return; touch only\n+        assert!((!path_is_dir(&filepath)));\n+\n+        assert!((!path_is_dir(&Path::new(\n+                     \"test/unicode-bogus-dir-\\uac00\\u4e00\\u30fc\\u4f60\\u597d\"))));\n+    }\n+\n+    #[test]\n+    fn test_path_exists() {\n+        use rt::io::fs::mkdir_recursive;\n+        use rt::io::UserRWX;\n+\n+        assert!((path_exists(&Path::new(\".\"))));\n+        assert!((!path_exists(&Path::new(\n+                     \"test/nonexistent-bogus-path\"))));\n+\n+        let mut dirpath = os::tmpdir();\n+        dirpath.push(format!(\"rust-test-{}/test-\\uac01\\u4e01\\u30fc\\u518d\\u89c1\",\n+            rand::random::<u32>())); // \uac01\u4e01\u30fc\u518d\u89c1\n+\n+        mkdir_recursive(&dirpath, UserRWX);\n+        assert!((path_exists(&dirpath)));\n+        assert!((!path_exists(&Path::new(\n+                     \"test/unicode-bogus-path-\\uac01\\u4e01\\u30fc\\u518d\\u89c1\"))));\n+    }\n+}"}, {"sha": "dd8a999c6de07570a70e6b730bd450bc88d44abc", "filename": "src/libstd/rt/io/net/unix.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -156,7 +156,6 @@ mod tests {\n     use rt::test::*;\n     use rt::io::*;\n     use rt::comm::oneshot;\n-    use os;\n \n     fn smalltest(server: ~fn(UnixStream), client: ~fn(UnixStream)) {\n         let server = Cell::new(server);\n@@ -290,7 +289,7 @@ mod tests {\n         do run_in_mt_newsched_task {\n             let path = next_test_unix();\n             let _acceptor = UnixListener::bind(&path).listen();\n-            assert!(os::path_exists(&path));\n+            assert!(path.exists());\n         }\n     }\n }"}, {"sha": "5938252571f515927f18123e335806c7ad93c2c5", "filename": "src/libstd/rt/io/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frt%2Fio%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frt%2Fio%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Foption.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -11,7 +11,7 @@\n //! Implementations of I/O traits for the Option type\n //!\n //! I/O constructors return option types to allow errors to be handled.\n-//! These implementations allow e.g. `Option<FileStream>` to be used\n+//! These implementations allow e.g. `Option<File>` to be used\n //! as a `Reader` without unwrapping the option first.\n \n use option::*;"}, {"sha": "0f48f83a57e0e63abb6f43320596bdc31c4db818", "filename": "src/libstd/rt/io/signal.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frt%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frt%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fsignal.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -19,6 +19,7 @@ definitions for a number of signals.\n \n */\n \n+use container::{Map, MutableMap};\n use comm::{Port, SharedChan, stream};\n use hashmap;\n use option::{Some, None};\n@@ -146,10 +147,10 @@ impl Listener {\n \n #[cfg(test)]\n mod test {\n-    use super::*;\n-\n     use libc;\n     use rt::io::timer;\n+    use super::{Listener, Interrupt};\n+    use comm::{GenericPort, Peekable};\n \n     // kill is only available on Unixes\n     #[cfg(unix)]\n@@ -208,6 +209,7 @@ mod test {\n     #[test]\n     fn test_io_signal_invalid_signum() {\n         use rt::io;\n+        use super::User1;\n         let mut s = Listener::new();\n         let mut called = false;\n         do io::io_error::cond.trap(|_| {"}, {"sha": "36092dfbe34e666a7675412fe7b0b9e70b543e14", "filename": "src/libstd/rt/io/timer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ftimer.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -108,6 +108,7 @@ impl Timer {\n \n #[cfg(test)]\n mod test {\n+    use prelude::*;\n     use super::*;\n     use rt::test::*;\n     use cell::Cell;"}, {"sha": "d24de7cbfee51086fa2585e0a8c680a1fd624878", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -22,7 +22,7 @@ use super::io::process::ProcessConfig;\n use super::io::net::ip::{IpAddr, SocketAddr};\n use path::Path;\n use super::io::{SeekStyle};\n-use super::io::{FileMode, FileAccess, FileStat};\n+use super::io::{FileMode, FileAccess, FileStat, FilePermission};\n \n pub trait EventLoop {\n     fn run(&mut self);\n@@ -91,28 +91,42 @@ pub fn with_local_io<T>(f: &fn(&mut IoFactory) -> Option<T>) -> Option<T> {\n }\n \n pub trait IoFactory {\n+    // networking\n     fn tcp_connect(&mut self, addr: SocketAddr) -> Result<~RtioTcpStream, IoError>;\n     fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListener, IoError>;\n     fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocket, IoError>;\n+    fn unix_bind(&mut self, path: &CString) ->\n+        Result<~RtioUnixListener, IoError>;\n+    fn unix_connect(&mut self, path: &CString) -> Result<~RtioPipe, IoError>;\n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n                           hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError>;\n-    fn timer_init(&mut self) -> Result<~RtioTimer, IoError>;\n+\n+    // filesystem operations\n     fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior) -> ~RtioFileStream;\n     fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n         -> Result<~RtioFileStream, IoError>;\n     fn fs_unlink(&mut self, path: &CString) -> Result<(), IoError>;\n     fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError>;\n-    fn fs_mkdir(&mut self, path: &CString) -> Result<(), IoError>;\n+    fn fs_mkdir(&mut self, path: &CString,\n+                mode: FilePermission) -> Result<(), IoError>;\n+    fn fs_chmod(&mut self, path: &CString,\n+                mode: FilePermission) -> Result<(), IoError>;\n     fn fs_rmdir(&mut self, path: &CString) -> Result<(), IoError>;\n+    fn fs_rename(&mut self, path: &CString, to: &CString) -> Result<(), IoError>;\n     fn fs_readdir(&mut self, path: &CString, flags: c_int) ->\n         Result<~[Path], IoError>;\n+    fn fs_lstat(&mut self, path: &CString) -> Result<FileStat, IoError>;\n+    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) ->\n+        Result<(), IoError>;\n+    fn fs_readlink(&mut self, path: &CString) -> Result<Path, IoError>;\n+    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> Result<(), IoError>;\n+    fn fs_link(&mut self, src: &CString, dst: &CString) -> Result<(), IoError>;\n+\n+    // misc\n+    fn timer_init(&mut self) -> Result<~RtioTimer, IoError>;\n     fn spawn(&mut self, config: ProcessConfig)\n             -> Result<(~RtioProcess, ~[Option<~RtioPipe>]), IoError>;\n-\n     fn pipe_open(&mut self, fd: c_int) -> Result<~RtioPipe, IoError>;\n-    fn unix_bind(&mut self, path: &CString) ->\n-        Result<~RtioUnixListener, IoError>;\n-    fn unix_connect(&mut self, path: &CString) -> Result<~RtioPipe, IoError>;\n     fn tty_open(&mut self, fd: c_int, readable: bool)\n             -> Result<~RtioTTY, IoError>;\n     fn signal(&mut self, signal: Signum, channel: SharedChan<Signum>)\n@@ -173,6 +187,9 @@ pub trait RtioFileStream {\n     fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError>;\n     fn seek(&mut self, pos: i64, whence: SeekStyle) -> Result<u64, IoError>;\n     fn tell(&self) -> Result<u64, IoError>;\n+    fn fsync(&mut self) -> Result<(), IoError>;\n+    fn datasync(&mut self) -> Result<(), IoError>;\n+    fn truncate(&mut self, offset: i64) -> Result<(), IoError>;\n }\n \n pub trait RtioProcess {"}, {"sha": "e71cd92589c338723467cd2bf5d0d998ad42667e", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -836,7 +836,7 @@ impl ClosureConverter for UnsafeTaskReceiver {\n }\n \n // On unix, we read randomness straight from /dev/urandom, but the\n-// default constructor of an XorShiftRng does this via io::file, which\n+// default constructor of an XorShiftRng does this via io::fs, which\n // relies on the scheduler existing, so we have to manually load\n // randomness. Windows has its own C API for this, so we don't need to\n // worry there."}, {"sha": "74f4ed3d55e4bb93d163308eac6aa7c8ba38f775", "filename": "src/libstd/run.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -604,11 +604,11 @@ mod tests {\n         let parent_dir = os::getcwd();\n         let child_dir = Path::new(output.trim());\n \n-        let parent_stat = parent_dir.stat().unwrap();\n-        let child_stat = child_dir.stat().unwrap();\n+        let parent_stat = parent_dir.stat();\n+        let child_stat = child_dir.stat();\n \n-        assert_eq!(parent_stat.device, child_stat.device);\n-        assert_eq!(parent_stat.inode, child_stat.inode);\n+        assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n+        assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n     }\n \n     #[test]\n@@ -621,11 +621,11 @@ mod tests {\n         let output = str::from_utf8(prog.finish_with_output().output);\n         let child_dir = Path::new(output.trim());\n \n-        let parent_stat = parent_dir.stat().unwrap();\n-        let child_stat = child_dir.stat().unwrap();\n+        let parent_stat = parent_dir.stat();\n+        let child_stat = child_dir.stat();\n \n-        assert_eq!(parent_stat.device, child_stat.device);\n-        assert_eq!(parent_stat.inode, child_stat.inode);\n+        assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n+        assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n     }\n \n     #[cfg(unix,not(target_os=\"android\"))]"}, {"sha": "75b5ab81f9bb3324024c84cc3d9f76f8402b1357", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -20,8 +20,7 @@ use parse::token::{get_ident_interner};\n use print::pprust;\n \n use std::rt::io;\n-use std::rt::io::Reader;\n-use std::rt::io::file::FileInfo;\n+use std::rt::io::File;\n use std::str;\n \n // These macros all relate to the file system; they either return\n@@ -92,17 +91,13 @@ pub fn expand_include_str(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n     let file = res_rel_file(cx, sp, &Path::new(file));\n-    let mut error = None;\n-    let bytes = do io::io_error::cond.trap(|e| error = Some(e)).inside {\n-        file.open_reader(io::Open).read_to_end()\n-    };\n-    match error {\n-        Some(e) => {\n+    let bytes = match io::result(|| File::open(&file).read_to_end()) {\n+        Err(e) => {\n             cx.span_fatal(sp, format!(\"couldn't read {}: {}\",\n                                       file.display(), e.desc));\n         }\n-        None => {}\n-    }\n+        Ok(bytes) => bytes,\n+    };\n     match str::from_utf8_owned_opt(bytes) {\n         Some(s) => base::MRExpr(cx.expr_str(sp, s.to_managed())),\n         None => {\n@@ -118,17 +113,12 @@ pub fn expand_include_bin(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n \n     let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n     let file = res_rel_file(cx, sp, &Path::new(file));\n-\n-    let mut error = None;\n-    let bytes = do io::io_error::cond.trap(|e| error = Some(e)).inside {\n-        file.open_reader(io::Open).read_to_end()\n-    };\n-    match error {\n-        Some(e) => {\n+    match io::result(|| File::open(&file).read_to_end()) {\n+        Err(e) => {\n             cx.span_fatal(sp, format!(\"couldn't read {}: {}\",\n                                       file.display(), e.desc));\n         }\n-        None => {\n+        Ok(bytes) => {\n             let bytes = at_vec::to_managed_move(bytes);\n             base::MRExpr(cx.expr_lit(sp, ast::lit_binary(bytes)))\n         }"}, {"sha": "fbe711b5efe9e7cd5f88bf47669cfacf85ba14f5", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -19,10 +19,8 @@ use parse::attr::parser_attr;\n use parse::lexer::reader;\n use parse::parser::Parser;\n \n-use std::path::Path;\n use std::rt::io;\n-use std::rt::io::Reader;\n-use std::rt::io::file::FileInfo;\n+use std::rt::io::File;\n use std::str;\n \n pub mod lexer;\n@@ -269,16 +267,13 @@ pub fn file_to_filemap(sess: @mut ParseSess, path: &Path, spanopt: Option<Span>)\n             None => sess.span_diagnostic.handler().fatal(msg),\n         }\n     };\n-    let mut error = None;\n-    let bytes = do io::io_error::cond.trap(|e| error = Some(e)).inside {\n-        path.open_reader(io::Open).read_to_end()\n-    };\n-    match error {\n-        Some(e) => {\n+    let bytes = match io::result(|| File::open(path).read_to_end()) {\n+        Ok(bytes) => bytes,\n+        Err(e) => {\n             err(format!(\"couldn't read {}: {}\", path.display(), e.desc));\n+            unreachable!()\n         }\n-        None => {}\n-    }\n+    };\n     match str::from_utf8_owned_opt(bytes) {\n         Some(s) => {\n             return string_to_filemap(sess, s.to_managed(),"}, {"sha": "a4361f14f69b257fe2dfb6cf0898a6deb65ac5c8", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -532,6 +532,10 @@ extern \"C\" int\n rust_uv_get_result_from_fs_req(uv_fs_t* req) {\n   return req->result;\n }\n+extern \"C\" const char*\n+rust_uv_get_path_from_fs_req(uv_fs_t* req) {\n+  return req->path;\n+}\n extern \"C\" void*\n rust_uv_get_ptr_from_fs_req(uv_fs_t* req) {\n   return req->ptr;\n@@ -592,6 +596,15 @@ extern \"C\" int\n rust_uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags, uv_fs_cb cb) {\n   return uv_fs_readdir(loop, req, path, flags, cb);\n }\n+extern \"C\" int\n+rust_uv_fs_rename(uv_loop_t *loop, uv_fs_t* req, const char *path,\n+                  const char *to, uv_fs_cb cb) {\n+    return uv_fs_rename(loop, req, path, to, cb);\n+}\n+extern \"C\" int\n+rust_uv_fs_chmod(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode, uv_fs_cb cb) {\n+  return uv_fs_chmod(loop, req, path, mode, cb);\n+}\n \n extern \"C\" int\n rust_uv_spawn(uv_loop_t *loop, uv_process_t *p, uv_process_options_t options) {"}, {"sha": "2c86fdfe6ad722d8c498a801d7ee9ba0b9b9f523", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -21,6 +21,7 @@ use std::rand;\n use std::str;\n use std::util;\n use std::vec;\n+use std::rt::io::File;\n \n macro_rules! bench (\n     ($argv:expr, $id:ident) => (maybe_run_test($argv, stringify!($id).to_owned(), $id))\n@@ -69,15 +70,13 @@ fn shift_push() {\n }\n \n fn read_line() {\n-    use std::rt::io::{Reader, Open};\n-    use std::rt::io::file::FileInfo;\n     use std::rt::io::buffered::BufferedReader;\n \n     let mut path = Path::new(env!(\"CFG_SRC_DIR\"));\n     path.push(\"src/test/bench/shootout-k-nucleotide.data\");\n \n     for _ in range(0, 3) {\n-        let mut reader = BufferedReader::new(path.open_reader(Open).unwrap());\n+        let mut reader = BufferedReader::new(File::open(&path).unwrap());\n         while !reader.eof() {\n             reader.read_line();\n         }"}, {"sha": "d7d7e9a58f3ca1cce2b10ef18e207a26610ca4b1", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -19,6 +19,7 @@ extern mod extra;\n \n use std::int;\n use std::rt::io;\n+use std::rt::io::File;\n use std::os;\n use std::rand::Rng;\n use std::rand;\n@@ -111,7 +112,6 @@ fn acid(ch: char, prob: u32) -> AminoAcids {\n }\n \n fn main() {\n-    use std::rt::io::file::FileInfo;\n     let args = os::args();\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n         // alioth tests k-nucleotide with this data at 25,000,000\n@@ -123,7 +123,7 @@ fn main() {\n     };\n \n     let writer = if os::getenv(\"RUST_BENCH\").is_some() {\n-        let file = Path::new(\"./shootout-fasta.data\").open_writer(io::CreateOrTruncate);\n+        let file = File::create(&Path::new(\"./shootout-fasta.data\"));\n         @mut file as @mut io::Writer\n     } else {\n         @mut io::stdout() as @mut io::Writer"}, {"sha": "c7c8e3a19a6cd0734100691fb4a26ea2dda7c675", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // xfail-pretty\n+// xfail-test\n \n extern mod extra;\n extern mod syntax;"}, {"sha": "2e426c0413e7418d50ee6dc824b24470ee7e05d1", "filename": "src/test/run-pass-fulldeps/quote-tokens.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -8,6 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test\n+\n+#[feature(managed_boxes)];\n+\n extern mod syntax;\n \n use syntax::ext::base::ExtCtxt;\n@@ -16,11 +20,11 @@ fn syntax_extension(cx: @ExtCtxt) {\n     let e_toks : ~[syntax::ast::token_tree] = quote_tokens!(cx, 1 + 2);\n     let p_toks : ~[syntax::ast::token_tree] = quote_tokens!(cx, (x, 1 .. 4, *));\n \n-    let a: @syntax::ast::expr = quote_expr!(cx, 1 + 2);\n+    let a: @syntax::ast::Expr = quote_expr!(cx, 1 + 2);\n     let _b: Option<@syntax::ast::item> = quote_item!(cx, static foo : int = $e_toks; );\n-    let _c: @syntax::ast::pat = quote_pat!(cx, (x, 1 .. 4, *) );\n-    let _d: @syntax::ast::stmt = quote_stmt!(cx, let x = $a; );\n-    let _e: @syntax::ast::expr = quote_expr!(cx, match foo { $p_toks => 10 } );\n+    let _c: @syntax::ast::Pat = quote_pat!(cx, (x, 1 .. 4, *) );\n+    let _d: @syntax::ast::Stmt = quote_stmt!(cx, let x = $a; );\n+    let _e: @syntax::ast::Expr = quote_expr!(cx, match foo { $p_toks => 10 } );\n }\n \n fn main() {"}, {"sha": "897ee9cb88b06609f5ff16ba611cbb7e927eb1a1", "filename": "src/test/run-pass/glob-std.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Ftest%2Frun-pass%2Fglob-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Ftest%2Frun-pass%2Fglob-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fglob-std.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -17,14 +17,13 @@ use extra::tempfile::TempDir;\n use std::unstable::finally::Finally;\n use std::{os, unstable};\n use std::rt::io;\n-use std::rt::io::file::FileInfo;\n \n pub fn main() {\n     fn mk_file(path: &str, directory: bool) {\n         if directory {\n-            os::make_dir(&Path::new(path), 0xFFFF);\n+            io::fs::mkdir(&Path::new(path), io::UserRWX);\n         } else {\n-            Path::new(path).open_writer(io::Create);\n+            io::File::create(&Path::new(path));\n         }\n     }\n "}, {"sha": "fcb57152daa5faf39aa6feee4b6778e9719b7516", "filename": "src/test/run-pass/rename-directory.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Ftest%2Frun-pass%2Frename-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Ftest%2Frun-pass%2Frename-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frename-directory.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -17,6 +17,8 @@ extern mod extra;\n use extra::tempfile::TempDir;\n use std::os;\n use std::libc;\n+use std::rt::io;\n+use std::rt::io::fs;\n \n fn rename_directory() {\n     #[fixed_stack_segment];\n@@ -26,7 +28,7 @@ fn rename_directory() {\n         let tmpdir = TempDir::new(\"rename_directory\").expect(\"rename_directory failed\");\n         let tmpdir = tmpdir.path();\n         let old_path = tmpdir.join_many([\"foo\", \"bar\", \"baz\"]);\n-        assert!(os::mkdir_recursive(&old_path, U_RWX));\n+        fs::mkdir_recursive(&old_path, io::UserRWX);\n         let test_file = &old_path.join(\"temp.txt\");\n \n         /* Write the temp input file */\n@@ -47,10 +49,10 @@ fn rename_directory() {\n         assert_eq!(libc::fclose(ostream), (0u as libc::c_int));\n \n         let new_path = tmpdir.join_many([\"quux\", \"blat\"]);\n-        assert!(os::mkdir_recursive(&new_path, U_RWX));\n-        assert!(os::rename_file(&old_path, &new_path.join(\"newdir\")));\n-        assert!(os::path_is_dir(&new_path.join(\"newdir\")));\n-        assert!(os::path_exists(&new_path.join_many([\"newdir\", \"temp.txt\"])));\n+        fs::mkdir_recursive(&new_path, io::UserRWX);\n+        fs::rename(&old_path, &new_path.join(\"newdir\"));\n+        assert!(new_path.join(\"newdir\").is_dir());\n+        assert!(new_path.join_many([\"newdir\", \"temp.txt\"]).exists());\n     }\n }\n "}, {"sha": "9ce3d318064c98274be3da892ceb5af0ee821ebc", "filename": "src/test/run-pass/stat.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Ftest%2Frun-pass%2Fstat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Ftest%2Frun-pass%2Fstat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstat.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -13,17 +13,14 @@\n extern mod extra;\n \n use extra::tempfile;\n-use std::rt::io;\n-use std::rt::io::Writer;\n-use std::rt::io::file::FileInfo;\n-use std::os;\n+use std::rt::io::File;\n \n pub fn main() {\n     let dir = tempfile::TempDir::new_in(&Path::new(\".\"), \"\").unwrap();\n     let path = dir.path().join(\"file\");\n \n     {\n-        match path.open_writer(io::CreateOrTruncate) {\n+        match File::create(&path) {\n             None => unreachable!(),\n             Some(f) => {\n                 let mut f = f;\n@@ -35,5 +32,5 @@ pub fn main() {\n     }\n \n     assert!(path.exists());\n-    assert_eq!(path.get_size(), Some(1000));\n+    assert_eq!(path.stat().size, 1000);\n }"}, {"sha": "3a115ab29cf54635a06c541e6fc0fee7a3a22d34", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/658637baf45b41e4cff049440bc07f267d810218/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658637baf45b41e4cff049440bc07f267d810218/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=658637baf45b41e4cff049440bc07f267d810218", "patch": "@@ -22,9 +22,10 @@ extern mod extra;\n \n use extra::tempfile::TempDir;\n use std::os;\n-use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n use std::task;\n use std::cell::Cell;\n+use std::rt::io;\n+use std::rt::io::fs;\n \n fn test_tempdir() {\n     let path = {\n@@ -33,7 +34,7 @@ fn test_tempdir() {\n         assert!(p.as_vec().ends_with(bytes!(\"foobar\")));\n         p.clone()\n     };\n-    assert!(!os::path_exists(&path));\n+    assert!(!path.exists());\n }\n \n fn test_rm_tempdir() {\n@@ -45,7 +46,7 @@ fn test_rm_tempdir() {\n     };\n     task::try(f);\n     let path = rd.recv();\n-    assert!(!os::path_exists(&path));\n+    assert!(!path.exists());\n \n     let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n     let path = tmp.path().clone();\n@@ -55,7 +56,7 @@ fn test_rm_tempdir() {\n         fail!(\"fail to unwind past `tmp`\");\n     };\n     task::try(f);\n-    assert!(!os::path_exists(&path));\n+    assert!(!path.exists());\n \n     let path;\n     {\n@@ -64,18 +65,18 @@ fn test_rm_tempdir() {\n         };\n         let tmp = task::try(f).expect(\"test_rm_tmdir\");\n         path = tmp.path().clone();\n-        assert!(os::path_exists(&path));\n+        assert!(path.exists());\n     }\n-    assert!(!os::path_exists(&path));\n+    assert!(!path.exists());\n \n     let path;\n     {\n         let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n         path = tmp.unwrap();\n     }\n-    assert!(os::path_exists(&path));\n-    os::remove_dir_recursive(&path);\n-    assert!(!os::path_exists(&path));\n+    assert!(path.exists());\n+    fs::rmdir_recursive(&path);\n+    assert!(!path.exists());\n }\n \n // Ideally these would be in std::os but then core would need\n@@ -84,54 +85,54 @@ fn recursive_mkdir_rel() {\n     let path = Path::new(\"frob\");\n     let cwd = os::getcwd();\n     debug!(\"recursive_mkdir_rel: Making: {} in cwd {} [{:?}]\", path.display(),\n-           cwd.display(), os::path_exists(&path));\n-    assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-    assert!(os::path_is_dir(&path));\n-    assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-    assert!(os::path_is_dir(&path));\n+           cwd.display(), path.exists());\n+    fs::mkdir_recursive(&path, io::UserRWX);\n+    assert!(path.is_dir());\n+    fs::mkdir_recursive(&path, io::UserRWX);\n+    assert!(path.is_dir());\n }\n \n fn recursive_mkdir_dot() {\n     let dot = Path::new(\".\");\n-    assert!(os::mkdir_recursive(&dot,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+    fs::mkdir_recursive(&dot, io::UserRWX);\n     let dotdot = Path::new(\"..\");\n-    assert!(os::mkdir_recursive(&dotdot,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+    fs::mkdir_recursive(&dotdot, io::UserRWX);\n }\n \n fn recursive_mkdir_rel_2() {\n     let path = Path::new(\"./frob/baz\");\n     let cwd = os::getcwd();\n     debug!(\"recursive_mkdir_rel_2: Making: {} in cwd {} [{:?}]\", path.display(),\n-           cwd.display(), os::path_exists(&path));\n-    assert!(os::mkdir_recursive(&path, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-        assert!(os::path_is_dir(&path));\n-    assert!(os::path_is_dir(&path.dir_path()));\n+           cwd.display(), path.exists());\n+    fs::mkdir_recursive(&path, io::UserRWX);\n+    assert!(path.is_dir());\n+    assert!(path.dir_path().is_dir());\n     let path2 = Path::new(\"quux/blat\");\n     debug!(\"recursive_mkdir_rel_2: Making: {} in cwd {}\", path2.display(),\n            cwd.display());\n-    assert!(os::mkdir_recursive(&path2, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-        assert!(os::path_is_dir(&path2));\n-    assert!(os::path_is_dir(&path2.dir_path()));\n+    fs::mkdir_recursive(&path2, io::UserRWX);\n+    assert!(path2.is_dir());\n+    assert!(path2.dir_path().is_dir());\n }\n \n // Ideally this would be in core, but needs TempFile\n pub fn test_rmdir_recursive_ok() {\n-    let rwx = (S_IRUSR | S_IWUSR | S_IXUSR) as i32;\n+    let rwx = io::UserRWX;\n \n     let tmpdir = TempDir::new(\"test\").expect(\"test_rmdir_recursive_ok: \\\n                                               couldn't create temp dir\");\n     let tmpdir = tmpdir.path();\n     let root = tmpdir.join(\"foo\");\n \n     debug!(\"making {}\", root.display());\n-    assert!(os::make_dir(&root, rwx));\n-    assert!(os::make_dir(&root.join(\"foo\"), rwx));\n-    assert!(os::make_dir(&root.join(\"foo\").join(\"bar\"), rwx));\n-    assert!(os::make_dir(&root.join(\"foo\").join(\"bar\").join(\"blat\"), rwx));\n-    assert!(os::remove_dir_recursive(&root));\n-    assert!(!os::path_exists(&root));\n-    assert!(!os::path_exists(&root.join(\"bar\")));\n-    assert!(!os::path_exists(&root.join(\"bar\").join(\"blat\")));\n+    fs::mkdir(&root, rwx);\n+    fs::mkdir(&root.join(\"foo\"), rwx);\n+    fs::mkdir(&root.join(\"foo\").join(\"bar\"), rwx);\n+    fs::mkdir(&root.join(\"foo\").join(\"bar\").join(\"blat\"), rwx);\n+    fs::rmdir_recursive(&root);\n+    assert!(!root.exists());\n+    assert!(!root.join(\"bar\").exists());\n+    assert!(!root.join(\"bar\").join(\"blat\").exists());\n }\n \n fn in_tmpdir(f: &fn()) {"}]}