{"sha": "653e6880c96f858ff1d9a42b525bf3a903ae94c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1M2U2ODgwYzk2Zjg1OGZmMWQ5YTQyYjUyNWJmM2E5MDNhZTk0Yzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-16T19:17:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-16T19:17:30Z"}, "message": "auto merge of #21113 : alexcrichton/rust/plug-a-hole, r=brson\n\nWith the addition of separate search paths to the compiler, it was intended that\r\napplications such as Cargo could require a `--extern` flag per `extern crate`\r\ndirective in the source. The system can currently be subverted, however, due to\r\nthe `existing_match()` logic in the crate loader.\r\n\r\nWhen loading crates we first attempt to match an `extern crate` directive\r\nagainst all previously loaded crates to avoid reading metadata twice. This \"hit\r\nthe cache if possible\" step was erroneously leaking crates across the search\r\npath boundaries, however. For example:\r\n\r\n    extern crate b;\r\n    extern crate a;\r\n\r\nIf `b` depends on `a`, then it will load crate `a` when the `extern crate b`\r\ndirective is being processed. When the compiler reaches `extern crate a` it will\r\nuse the previously loaded version no matter what. If the compiler was not\r\ninvoked with `-L crate=path/to/a`, it will still succeed.\r\n\r\nThis behavior is allowing `extern crate` declarations in Cargo without a\r\ncorresponding declaration in the manifest of a dependency, which is considered\r\na bug.\r\n\r\nThis commit fixes this problem by keeping track of the origin search path for a\r\ncrate. Crates loaded from the dependency search path are not candidates for\r\ncrates which are loaded from the crate search path.", "tree": {"sha": "5401c45e403276971bf3660aa0376e1006cc144e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5401c45e403276971bf3660aa0376e1006cc144e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/653e6880c96f858ff1d9a42b525bf3a903ae94c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/653e6880c96f858ff1d9a42b525bf3a903ae94c8", "html_url": "https://github.com/rust-lang/rust/commit/653e6880c96f858ff1d9a42b525bf3a903ae94c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/653e6880c96f858ff1d9a42b525bf3a903ae94c8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "210f0dcf007104240b2e286ed0b80cb4a61d7bae", "url": "https://api.github.com/repos/rust-lang/rust/commits/210f0dcf007104240b2e286ed0b80cb4a61d7bae", "html_url": "https://github.com/rust-lang/rust/commit/210f0dcf007104240b2e286ed0b80cb4a61d7bae"}, {"sha": "cbeb77ec7a42b988703fa0b0c857f26d464fdc2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbeb77ec7a42b988703fa0b0c857f26d464fdc2f", "html_url": "https://github.com/rust-lang/rust/commit/cbeb77ec7a42b988703fa0b0c857f26d464fdc2f"}], "stats": {"total": 223, "additions": 145, "deletions": 78}, "files": [{"sha": "5de683f8a4f076b8dd857fa53982483398601b20", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=653e6880c96f858ff1d9a42b525bf3a903ae94c8", "patch": "@@ -58,8 +58,8 @@ fn dump_crates(cstore: &CStore) {\n         debug!(\"  hash: {}\", data.hash());\n         opt_source.map(|cs| {\n             let CrateSource { dylib, rlib, cnum: _ } = cs;\n-            dylib.map(|dl| debug!(\"  dylib: {}\", dl.display()));\n-            rlib.map(|rl|  debug!(\"   rlib: {}\", rl.display()));\n+            dylib.map(|dl| debug!(\"  dylib: {}\", dl.0.display()));\n+            rlib.map(|rl|  debug!(\"   rlib: {}\", rl.0.display()));\n         });\n     })\n }\n@@ -305,8 +305,8 @@ impl<'a> CrateReader<'a> {\n         }\n     }\n \n-    fn existing_match(&self, name: &str,\n-                      hash: Option<&Svh>) -> Option<ast::CrateNum> {\n+    fn existing_match(&self, name: &str, hash: Option<&Svh>, kind: PathKind)\n+                      -> Option<ast::CrateNum> {\n         let mut ret = None;\n         self.sess.cstore.iter_crate_data(|cnum, data| {\n             if data.name != name { return }\n@@ -317,27 +317,37 @@ impl<'a> CrateReader<'a> {\n                 None => {}\n             }\n \n-            // When the hash is None we're dealing with a top-level dependency in\n-            // which case we may have a specification on the command line for this\n-            // library. Even though an upstream library may have loaded something of\n-            // the same name, we have to make sure it was loaded from the exact same\n-            // location as well.\n+            // When the hash is None we're dealing with a top-level dependency\n+            // in which case we may have a specification on the command line for\n+            // this library. Even though an upstream library may have loaded\n+            // something of the same name, we have to make sure it was loaded\n+            // from the exact same location as well.\n             //\n             // We're also sure to compare *paths*, not actual byte slices. The\n             // `source` stores paths which are normalized which may be different\n             // from the strings on the command line.\n             let source = self.sess.cstore.get_used_crate_source(cnum).unwrap();\n-            match self.sess.opts.externs.get(name) {\n-                Some(locs) => {\n-                    let found = locs.iter().any(|l| {\n-                        let l = fs::realpath(&Path::new(&l[])).ok();\n-                        l == source.dylib || l == source.rlib\n-                    });\n-                    if found {\n-                        ret = Some(cnum);\n-                    }\n+            if let Some(locs) = self.sess.opts.externs.get(name) {\n+                let found = locs.iter().any(|l| {\n+                    let l = fs::realpath(&Path::new(&l[])).ok();\n+                    source.dylib.as_ref().map(|p| &p.0) == l.as_ref() ||\n+                    source.rlib.as_ref().map(|p| &p.0) == l.as_ref()\n+                });\n+                if found {\n+                    ret = Some(cnum);\n                 }\n-                None => ret = Some(cnum),\n+            }\n+\n+            // Alright, so we've gotten this far which means that `data` has the\n+            // right name, we don't have a hash, and we don't have a --extern\n+            // pointing for ourselves. We're still not quite yet done because we\n+            // have to make sure that this crate was found in the crate lookup\n+            // path (this is a top-level dependency) as we don't want to\n+            // implicitly load anything inside the dependency lookup path.\n+            let prev_kind = source.dylib.as_ref().or(source.rlib.as_ref())\n+                                  .unwrap().1;\n+            if ret.is_none() && (prev_kind == kind || prev_kind == PathKind::All) {\n+                ret = Some(cnum);\n             }\n         });\n         return ret;\n@@ -359,8 +369,8 @@ impl<'a> CrateReader<'a> {\n         let crate_paths = if root.is_none() {\n             Some(CratePaths {\n                 ident: ident.to_string(),\n-                dylib: lib.dylib.clone(),\n-                rlib:  lib.rlib.clone(),\n+                dylib: lib.dylib.clone().map(|p| p.0),\n+                rlib:  lib.rlib.clone().map(|p| p.0),\n             })\n         } else {\n             None\n@@ -400,7 +410,7 @@ impl<'a> CrateReader<'a> {\n                      kind: PathKind)\n                          -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n                              cstore::CrateSource) {\n-        match self.existing_match(name, hash) {\n+        match self.existing_match(name, hash, kind) {\n             None => {\n                 let mut load_ctxt = loader::Context {\n                     sess: self.sess,\n@@ -483,8 +493,8 @@ impl<'a> CrateReader<'a> {\n         let library = match load_ctxt.maybe_load_library_crate() {\n             Some(l) => l,\n             None if is_cross => {\n-                // Try loading from target crates. This will abort later if we try to\n-                // load a plugin registrar function,\n+                // Try loading from target crates. This will abort later if we\n+                // try to load a plugin registrar function,\n                 target_only = true;\n                 should_link = info.should_link;\n \n@@ -497,7 +507,9 @@ impl<'a> CrateReader<'a> {\n         };\n \n         let dylib = library.dylib.clone();\n-        let register = should_link && self.existing_match(info.name.as_slice(), None).is_none();\n+        let register = should_link && self.existing_match(info.name.as_slice(),\n+                                                          None,\n+                                                          PathKind::Crate).is_none();\n         let metadata = if register {\n             // Register crate now to avoid double-reading metadata\n             let (_, cmd, _) = self.register_crate(&None, &info.ident[],\n@@ -511,7 +523,7 @@ impl<'a> CrateReader<'a> {\n         PluginMetadata {\n             sess: self.sess,\n             metadata: metadata,\n-            dylib: dylib,\n+            dylib: dylib.map(|p| p.0),\n             info: info,\n             vi_span: span,\n             target_only: target_only,"}, {"sha": "49e03376a8cdd2100eb94fe8f3cd2313313f9bee", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=653e6880c96f858ff1d9a42b525bf3a903ae94c8", "patch": "@@ -20,6 +20,7 @@ pub use self::NativeLibraryKind::*;\n use back::svh::Svh;\n use metadata::decoder;\n use metadata::loader;\n+use session::search_paths::PathKind;\n use util::nodemap::{FnvHashMap, NodeMap};\n \n use std::cell::RefCell;\n@@ -65,8 +66,8 @@ pub enum NativeLibraryKind {\n // must be non-None.\n #[derive(PartialEq, Clone)]\n pub struct CrateSource {\n-    pub dylib: Option<Path>,\n-    pub rlib: Option<Path>,\n+    pub dylib: Option<(Path, PathKind)>,\n+    pub rlib: Option<(Path, PathKind)>,\n     pub cnum: ast::CrateNum,\n }\n \n@@ -178,10 +179,10 @@ impl CStore {\n         let mut libs = self.used_crate_sources.borrow()\n             .iter()\n             .map(|src| (src.cnum, match prefer {\n-                RequireDynamic => src.dylib.clone(),\n-                RequireStatic => src.rlib.clone(),\n+                RequireDynamic => src.dylib.clone().map(|p| p.0),\n+                RequireStatic => src.rlib.clone().map(|p| p.0),\n             }))\n-            .collect::<Vec<(ast::CrateNum, Option<Path>)>>();\n+            .collect::<Vec<_>>();\n         libs.sort_by(|&(a, _), &(b, _)| {\n             ordering.position_elem(&a).cmp(&ordering.position_elem(&b))\n         });"}, {"sha": "55a23aa516ecad697fe4f80e15db6e2debe4dd27", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=653e6880c96f858ff1d9a42b525bf3a903ae94c8", "patch": "@@ -39,13 +39,13 @@ pub struct FileSearch<'a> {\n \n impl<'a> FileSearch<'a> {\n     pub fn for_each_lib_search_path<F>(&self, mut f: F) where\n-        F: FnMut(&Path) -> FileMatch,\n+        F: FnMut(&Path, PathKind) -> FileMatch,\n     {\n         let mut visited_dirs = HashSet::new();\n         let mut found = false;\n \n-        for path in self.search_paths.iter(self.kind) {\n-            match f(path) {\n+        for (path, kind) in self.search_paths.iter(self.kind) {\n+            match f(path, kind) {\n                 FileMatches => found = true,\n                 FileDoesntMatch => ()\n             }\n@@ -56,7 +56,7 @@ impl<'a> FileSearch<'a> {\n         let tlib_path = make_target_lib_path(self.sysroot,\n                                              self.triple);\n         if !visited_dirs.contains(tlib_path.as_vec()) {\n-            match f(&tlib_path) {\n+            match f(&tlib_path, PathKind::All) {\n                 FileMatches => found = true,\n                 FileDoesntMatch => ()\n             }\n@@ -76,7 +76,7 @@ impl<'a> FileSearch<'a> {\n                     visited_dirs.insert(tlib_path.as_vec().to_vec());\n                     // Don't keep searching the RUST_PATH if one match turns up --\n                     // if we did, we'd get a \"multiple matching crates\" error\n-                    match f(&tlib_path) {\n+                    match f(&tlib_path, PathKind::All) {\n                        FileMatches => {\n                            break;\n                        }\n@@ -91,8 +91,10 @@ impl<'a> FileSearch<'a> {\n         make_target_lib_path(self.sysroot, self.triple)\n     }\n \n-    pub fn search<F>(&self, mut pick: F) where F: FnMut(&Path) -> FileMatch {\n-        self.for_each_lib_search_path(|lib_search_path| {\n+    pub fn search<F>(&self, mut pick: F)\n+        where F: FnMut(&Path, PathKind) -> FileMatch\n+    {\n+        self.for_each_lib_search_path(|lib_search_path, kind| {\n             debug!(\"searching {}\", lib_search_path.display());\n             match fs::readdir(lib_search_path) {\n                 Ok(files) => {\n@@ -108,7 +110,7 @@ impl<'a> FileSearch<'a> {\n                     let files2 = files.iter().filter(|p| !is_rlib(p));\n                     for path in files1.chain(files2) {\n                         debug!(\"testing {}\", path.display());\n-                        let maybe_picked = pick(path);\n+                        let maybe_picked = pick(path, kind);\n                         match maybe_picked {\n                             FileMatches => {\n                                 debug!(\"picked {}\", path.display());\n@@ -142,7 +144,7 @@ impl<'a> FileSearch<'a> {\n     // Returns a list of directories where target-specific dylibs might be located.\n     pub fn get_dylib_search_paths(&self) -> Vec<Path> {\n         let mut paths = Vec::new();\n-        self.for_each_lib_search_path(|lib_search_path| {\n+        self.for_each_lib_search_path(|lib_search_path, _| {\n             paths.push(lib_search_path.clone());\n             FileDoesntMatch\n         });"}, {"sha": "70b6ddf23fd8d96a68aae6173c9dba33a279cf61", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=653e6880c96f858ff1d9a42b525bf3a903ae94c8", "patch": "@@ -215,6 +215,7 @@\n use back::archive::{METADATA_FILENAME};\n use back::svh::Svh;\n use session::Session;\n+use session::search_paths::PathKind;\n use llvm;\n use llvm::{False, ObjectFile, mk_section_iter};\n use llvm::archive_ro::ArchiveRO;\n@@ -229,7 +230,7 @@ use rustc_back::target::Target;\n \n use std::ffi::CString;\n use std::cmp;\n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashMap;\n use std::io::fs::PathExtensions;\n use std::io;\n use std::ptr;\n@@ -260,8 +261,8 @@ pub struct Context<'a> {\n }\n \n pub struct Library {\n-    pub dylib: Option<Path>,\n-    pub rlib: Option<Path>,\n+    pub dylib: Option<(Path, PathKind)>,\n+    pub rlib: Option<(Path, PathKind)>,\n     pub metadata: MetadataBlob,\n }\n \n@@ -384,7 +385,7 @@ impl<'a> Context<'a> {\n         // of the crate id (path/name/id).\n         //\n         // The goal of this step is to look at as little metadata as possible.\n-        self.filesearch.search(|path| {\n+        self.filesearch.search(|path, kind| {\n             let file = match path.filename_str() {\n                 None => return FileDoesntMatch,\n                 Some(file) => file,\n@@ -404,12 +405,12 @@ impl<'a> Context<'a> {\n \n             let hash_str = hash.to_string();\n             let slot = candidates.entry(hash_str).get().unwrap_or_else(\n-                |vacant_entry| vacant_entry.insert((HashSet::new(), HashSet::new())));\n+                |vacant_entry| vacant_entry.insert((HashMap::new(), HashMap::new())));\n             let (ref mut rlibs, ref mut dylibs) = *slot;\n             if rlib {\n-                rlibs.insert(fs::realpath(path).unwrap());\n+                rlibs.insert(fs::realpath(path).unwrap(), kind);\n             } else {\n-                dylibs.insert(fs::realpath(path).unwrap());\n+                dylibs.insert(fs::realpath(path).unwrap(), kind);\n             }\n \n             FileMatches\n@@ -453,16 +454,16 @@ impl<'a> Context<'a> {\n                 self.sess.note(\"candidates:\");\n                 for lib in libraries.iter() {\n                     match lib.dylib {\n-                        Some(ref p) => {\n+                        Some((ref p, _)) => {\n                             self.sess.note(&format!(\"path: {}\",\n                                                    p.display())[]);\n                         }\n                         None => {}\n                     }\n                     match lib.rlib {\n-                        Some(ref p) => {\n+                        Some((ref p, _)) => {\n                             self.sess.note(&format!(\"path: {}\",\n-                                                   p.display())[]);\n+                                                    p.display())[]);\n                         }\n                         None => {}\n                     }\n@@ -483,9 +484,9 @@ impl<'a> Context<'a> {\n     // read the metadata from it if `*slot` is `None`. If the metadata couldn't\n     // be read, it is assumed that the file isn't a valid rust library (no\n     // errors are emitted).\n-    fn extract_one(&mut self, m: HashSet<Path>, flavor: &str,\n-                   slot: &mut Option<MetadataBlob>) -> Option<Path> {\n-        let mut ret = None::<Path>;\n+    fn extract_one(&mut self, m: HashMap<Path, PathKind>, flavor: &str,\n+                   slot: &mut Option<MetadataBlob>) -> Option<(Path, PathKind)> {\n+        let mut ret = None::<(Path, PathKind)>;\n         let mut error = 0u;\n \n         if slot.is_some() {\n@@ -500,7 +501,7 @@ impl<'a> Context<'a> {\n             }\n         }\n \n-        for lib in m.into_iter() {\n+        for (lib, kind) in m.into_iter() {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n             let metadata = match get_metadata_section(self.target.options.is_like_osx,\n                                                       &lib) {\n@@ -525,7 +526,7 @@ impl<'a> Context<'a> {\n                                            self.crate_name)[]);\n                 self.sess.span_note(self.span,\n                                     &format!(r\"candidate #1: {}\",\n-                                            ret.as_ref().unwrap()\n+                                            ret.as_ref().unwrap().0\n                                                .display())[]);\n                 error = 1;\n                 ret = None;\n@@ -538,7 +539,7 @@ impl<'a> Context<'a> {\n                 continue\n             }\n             *slot = Some(metadata);\n-            ret = Some(lib);\n+            ret = Some((lib, kind));\n         }\n         return if error > 0 {None} else {ret}\n     }\n@@ -606,8 +607,8 @@ impl<'a> Context<'a> {\n         // rlibs/dylibs.\n         let sess = self.sess;\n         let dylibname = self.dylibname();\n-        let mut rlibs = HashSet::new();\n-        let mut dylibs = HashSet::new();\n+        let mut rlibs = HashMap::new();\n+        let mut dylibs = HashMap::new();\n         {\n             let mut locs = locs.iter().map(|l| Path::new(&l[])).filter(|loc| {\n                 if !loc.exists() {\n@@ -637,13 +638,15 @@ impl<'a> Context<'a> {\n                 false\n             });\n \n-            // Now that we have an iterator of good candidates, make sure there's at\n-            // most one rlib and at most one dylib.\n+            // Now that we have an iterator of good candidates, make sure\n+            // there's at most one rlib and at most one dylib.\n             for loc in locs {\n                 if loc.filename_str().unwrap().ends_with(\".rlib\") {\n-                    rlibs.insert(fs::realpath(&loc).unwrap());\n+                    rlibs.insert(fs::realpath(&loc).unwrap(),\n+                                 PathKind::ExternFlag);\n                 } else {\n-                    dylibs.insert(fs::realpath(&loc).unwrap());\n+                    dylibs.insert(fs::realpath(&loc).unwrap(),\n+                                  PathKind::ExternFlag);\n                 }\n             }\n         };"}, {"sha": "0cf04fe0a006a94623155305a0b6fd2efb5805bc", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=653e6880c96f858ff1d9a42b525bf3a903ae94c8", "patch": "@@ -25,6 +25,7 @@ pub enum PathKind {\n     Native,\n     Crate,\n     Dependency,\n+    ExternFlag,\n     All,\n }\n \n@@ -54,14 +55,16 @@ impl SearchPaths {\n }\n \n impl<'a> Iterator for Iter<'a> {\n-    type Item = &'a Path;\n+    type Item = (&'a Path, PathKind);\n \n-    fn next(&mut self) -> Option<&'a Path> {\n+    fn next(&mut self) -> Option<(&'a Path, PathKind)> {\n         loop {\n             match self.iter.next() {\n                 Some(&(kind, ref p)) if self.kind == PathKind::All ||\n                                         kind == PathKind::All ||\n-                                        kind == self.kind => return Some(p),\n+                                        kind == self.kind => {\n+                    return Some((p, kind))\n+                }\n                 Some(..) => {}\n                 None => return None,\n             }"}, {"sha": "dacf620cbd1d0e1c7a5ef97465e1f65e60286159", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=653e6880c96f858ff1d9a42b525bf3a903ae94c8", "patch": "@@ -507,7 +507,7 @@ fn link_binary_output(sess: &Session,\n \n fn archive_search_paths(sess: &Session) -> Vec<Path> {\n     let mut search = Vec::new();\n-    sess.target_filesearch(PathKind::Native).for_each_lib_search_path(|path| {\n+    sess.target_filesearch(PathKind::Native).for_each_lib_search_path(|path, _| {\n         search.push(path.clone());\n         FileDoesntMatch\n     });\n@@ -1043,7 +1043,7 @@ fn link_args(cmd: &mut Command,\n // in the current crate. Upstream crates with native library dependencies\n // may have their native library pulled in above.\n fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n-    sess.target_filesearch(PathKind::All).for_each_lib_search_path(|path| {\n+    sess.target_filesearch(PathKind::All).for_each_lib_search_path(|path, _| {\n         cmd.arg(\"-L\").arg(path);\n         FileDoesntMatch\n     });\n@@ -1146,10 +1146,10 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n         match kind {\n             cstore::RequireDynamic => {\n-                add_dynamic_crate(cmd, sess, src.dylib.unwrap())\n+                add_dynamic_crate(cmd, sess, src.dylib.unwrap().0)\n             }\n             cstore::RequireStatic => {\n-                add_static_crate(cmd, sess, tmpdir, src.rlib.unwrap())\n+                add_static_crate(cmd, sess, tmpdir, src.rlib.unwrap().0)\n             }\n         }\n "}, {"sha": "bd7f62d5c2d893e2fe8332c37a3ad47220fb21fe", "filename": "src/test/run-make/compiler-lookup-paths-2/Makefile", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths-2%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths-2%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths-2%2FMakefile?ref=653e6880c96f858ff1d9a42b525bf3a903ae94c8", "patch": "@@ -0,0 +1,8 @@\n+-include ../tools.mk\n+\n+all:\n+\tmkdir -p $(TMPDIR)/a $(TMPDIR)/b\n+\t$(RUSTC) a.rs && mv $(TMPDIR)/liba.rlib $(TMPDIR)/a\n+\t$(RUSTC) b.rs -L $(TMPDIR)/a && mv $(TMPDIR)/libb.rlib $(TMPDIR)/b\n+\t$(RUSTC) c.rs -L crate=$(TMPDIR)/b -L dependency=$(TMPDIR)/a \\\n+\t\t&& exit 1 || exit 0"}, {"sha": "e7572a5f6157891289b89ffdc56ed86a237cd119", "filename": "src/test/run-make/compiler-lookup-paths-2/a.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths-2%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths-2%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths-2%2Fa.rs?ref=653e6880c96f858ff1d9a42b525bf3a903ae94c8", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]"}, {"sha": "fee0da9b4c194845a69dda18bd924a98b560d027", "filename": "src/test/run-make/compiler-lookup-paths-2/b.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths-2%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths-2%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths-2%2Fb.rs?ref=653e6880c96f858ff1d9a42b525bf3a903ae94c8", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+extern crate a;"}, {"sha": "66fe51d10991e6f4c479069fdb5789b4763276d9", "filename": "src/test/run-make/compiler-lookup-paths-2/c.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths-2%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths-2%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcompiler-lookup-paths-2%2Fc.rs?ref=653e6880c96f858ff1d9a42b525bf3a903ae94c8", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+extern crate b;\n+extern crate a;"}, {"sha": "049b76c1b648a7514625fa2e8adead8fd8004150", "filename": "src/test/run-make/extern-flag-disambiguates/Makefile", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2FMakefile?ref=653e6880c96f858ff1d9a42b525bf3a903ae94c8", "patch": "@@ -17,8 +17,10 @@ all:\n \t$(RUSTC) -C metadata=2 -C extra-filename=-2 a.rs\n \t$(RUSTC) b.rs --extern a=$(TMPDIR)/liba-1.rlib\n \t$(RUSTC) c.rs --extern a=$(TMPDIR)/liba-2.rlib\n+\t@echo before\n \t$(RUSTC) --cfg before d.rs --extern a=$(TMPDIR)/liba-1.rlib\n \t$(call RUN,d)\n+\t@echo after\n \t$(RUSTC) --cfg after  d.rs --extern a=$(TMPDIR)/liba-1.rlib\n \t$(call RUN,d)\n "}, {"sha": "ac92aede7894f72083fef91889efeaa00e8195a9", "filename": "src/test/run-make/extern-flag-disambiguates/a.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fa.rs?ref=653e6880c96f858ff1d9a42b525bf3a903ae94c8", "patch": "@@ -11,6 +11,6 @@\n #![crate_name = \"a\"]\n #![crate_type = \"rlib\"]\n \n-static FOO: uint = 3;\n+static FOO: usize = 3;\n \n-pub fn token() -> &'static uint { &FOO }\n+pub fn token() -> &'static usize { &FOO }"}, {"sha": "8ae238f5a482c2f1a063b2ac825097f842724883", "filename": "src/test/run-make/extern-flag-disambiguates/b.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fb.rs?ref=653e6880c96f858ff1d9a42b525bf3a903ae94c8", "patch": "@@ -13,7 +13,7 @@\n \n extern crate a;\n \n-static FOO: uint = 3;\n+static FOO: usize = 3;\n \n-pub fn token() -> &'static uint { &FOO }\n-pub fn a_token() -> &'static uint { a::token() }\n+pub fn token() -> &'static usize { &FOO }\n+pub fn a_token() -> &'static usize { a::token() }"}, {"sha": "6eccdf7e5c857b28b0cded71213ca98895b81747", "filename": "src/test/run-make/extern-flag-disambiguates/c.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fc.rs?ref=653e6880c96f858ff1d9a42b525bf3a903ae94c8", "patch": "@@ -13,7 +13,7 @@\n \n extern crate a;\n \n-static FOO: uint = 3;\n+static FOO: usize = 3;\n \n-pub fn token() -> &'static uint { &FOO }\n-pub fn a_token() -> &'static uint { a::token() }\n+pub fn token() -> &'static usize { &FOO }\n+pub fn a_token() -> &'static usize { a::token() }"}, {"sha": "90e1330d4ae472c8b6121704dbce97672bc3a1dc", "filename": "src/test/run-make/extern-flag-disambiguates/d.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653e6880c96f858ff1d9a42b525bf3a903ae94c8/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-flag-disambiguates%2Fd.rs?ref=653e6880c96f858ff1d9a42b525bf3a903ae94c8", "patch": "@@ -13,7 +13,7 @@ extern crate b;\n extern crate c;\n #[cfg(after)] extern crate a;\n \n-fn t(a: &'static uint) -> uint { a as *const _ as uint }\n+fn t(a: &'static usize) -> usize { a as *const _ as usize }\n \n fn main() {\n     assert!(t(a::token()) == t(b::a_token()));"}]}