{"sha": "006a4cc7670eebd63236a16fb6495060f83d1cbc", "node_id": "C_kwDOAAsO6NoAKDAwNmE0Y2M3NjcwZWViZDYzMjM2YTE2ZmI2NDk1MDYwZjgzZDFjYmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-02T14:47:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-02T14:47:43Z"}, "message": "Auto merge of #10276 - m-ou-se:manual-assert, r=Alexendoo\n\nDon't depend on FormatArgsExpn in ManualAssert.\n\nPart of https://github.com/rust-lang/rust-clippy/issues/10233\n\nchangelog: none", "tree": {"sha": "02f3e956f49135047cc1b983a60fdbcb98ae09c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02f3e956f49135047cc1b983a60fdbcb98ae09c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/006a4cc7670eebd63236a16fb6495060f83d1cbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/006a4cc7670eebd63236a16fb6495060f83d1cbc", "html_url": "https://github.com/rust-lang/rust/commit/006a4cc7670eebd63236a16fb6495060f83d1cbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/006a4cc7670eebd63236a16fb6495060f83d1cbc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2f85deba3483b38059ac18bb317d9dbe7497e76", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2f85deba3483b38059ac18bb317d9dbe7497e76", "html_url": "https://github.com/rust-lang/rust/commit/a2f85deba3483b38059ac18bb317d9dbe7497e76"}, {"sha": "ecd98bad45841d30ff83269b94da7a8c06da0516", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecd98bad45841d30ff83269b94da7a8c06da0516", "html_url": "https://github.com/rust-lang/rust/commit/ecd98bad45841d30ff83269b94da7a8c06da0516"}], "stats": {"total": 199, "additions": 125, "deletions": 74}, "files": [{"sha": "ce5d657bcf0e3cff6e44a6a65410d471e7a62852", "filename": "clippy_lints/src/manual_assert.rs", "status": "modified", "additions": 48, "deletions": 49, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/006a4cc7670eebd63236a16fb6495060f83d1cbc/clippy_lints%2Fsrc%2Fmanual_assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/006a4cc7670eebd63236a16fb6495060f83d1cbc/clippy_lints%2Fsrc%2Fmanual_assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_assert.rs?ref=006a4cc7670eebd63236a16fb6495060f83d1cbc", "patch": "@@ -1,7 +1,6 @@\n use crate::rustc_lint::LintContext;\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::macros::{root_macro_call, FormatArgsExpn};\n-use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::macros::root_macro_call;\n use clippy_utils::{is_else_clause, peel_blocks_with_stmt, span_extract_comment, sugg};\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, UnOp};\n@@ -38,57 +37,57 @@ declare_lint_pass!(ManualAssert => [MANUAL_ASSERT]);\n \n impl<'tcx> LateLintPass<'tcx> for ManualAssert {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n-        if_chain! {\n-            if let ExprKind::If(cond, then, None) = expr.kind;\n-            if !matches!(cond.kind, ExprKind::Let(_));\n-            if !expr.span.from_expansion();\n-            let then = peel_blocks_with_stmt(then);\n-            if let Some(macro_call) = root_macro_call(then.span);\n-            if cx.tcx.item_name(macro_call.def_id) == sym::panic;\n-            if !cx.tcx.sess.source_map().is_multiline(cond.span);\n-            if let Some(format_args) = FormatArgsExpn::find_nested(cx, then, macro_call.expn);\n+        if let ExprKind::If(cond, then, None) = expr.kind\n+            && !matches!(cond.kind, ExprKind::Let(_))\n+            && !expr.span.from_expansion()\n+            && let then = peel_blocks_with_stmt(then)\n+            && let Some(macro_call) = root_macro_call(then.span)\n+            && cx.tcx.item_name(macro_call.def_id) == sym::panic\n+            && !cx.tcx.sess.source_map().is_multiline(cond.span)\n+            && let Ok(panic_snippet) = cx.sess().source_map().span_to_snippet(macro_call.span)\n+            && let Some(panic_snippet) = panic_snippet.strip_suffix(')')\n+            && let Some((_, format_args_snip)) = panic_snippet.split_once('(')\n             // Don't change `else if foo { panic!(..) }` to `else { assert!(foo, ..) }` as it just\n             // shuffles the condition around.\n             // Should this have a config value?\n-            if !is_else_clause(cx.tcx, expr);\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                let format_args_snip = snippet_with_applicability(cx, format_args.inputs_span(), \"..\", &mut applicability);\n-                let cond = cond.peel_drop_temps();\n-                let mut comments = span_extract_comment(cx.sess().source_map(), expr.span);\n-                if !comments.is_empty() {\n-                    comments += \"\\n\";\n-                }\n-                let (cond, not) = match cond.kind {\n-                    ExprKind::Unary(UnOp::Not, e) => (e, \"\"),\n-                    _ => (cond, \"!\"),\n-                };\n-                let cond_sugg = sugg::Sugg::hir_with_applicability(cx, cond, \"..\", &mut applicability).maybe_par();\n-                let sugg = format!(\"assert!({not}{cond_sugg}, {format_args_snip});\");\n-                // we show to the user the suggestion without the comments, but when applicating the fix, include the comments in the block\n-                span_lint_and_then(\n-                    cx,\n-                    MANUAL_ASSERT,\n-                    expr.span,\n-                    \"only a `panic!` in `if`-then statement\",\n-                    |diag| {\n-                        // comments can be noisy, do not show them to the user\n-                        if !comments.is_empty() {\n-                            diag.tool_only_span_suggestion(\n-                                        expr.span.shrink_to_lo(),\n-                                        \"add comments back\",\n-                                        comments,\n-                                        applicability);\n-                        }\n-                        diag.span_suggestion(\n-                                    expr.span,\n-                                    \"try instead\",\n-                                    sugg,\n-                                    applicability);\n-                                     }\n-\n-                );\n+            && !is_else_clause(cx.tcx, expr)\n+        {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let cond = cond.peel_drop_temps();\n+            let mut comments = span_extract_comment(cx.sess().source_map(), expr.span);\n+            if !comments.is_empty() {\n+                comments += \"\\n\";\n             }\n+            let (cond, not) = match cond.kind {\n+                ExprKind::Unary(UnOp::Not, e) => (e, \"\"),\n+                _ => (cond, \"!\"),\n+            };\n+            let cond_sugg = sugg::Sugg::hir_with_applicability(cx, cond, \"..\", &mut applicability).maybe_par();\n+            let sugg = format!(\"assert!({not}{cond_sugg}, {format_args_snip});\");\n+            // we show to the user the suggestion without the comments, but when applicating the fix, include the comments in the block\n+            span_lint_and_then(\n+                cx,\n+                MANUAL_ASSERT,\n+                expr.span,\n+                \"only a `panic!` in `if`-then statement\",\n+                |diag| {\n+                    // comments can be noisy, do not show them to the user\n+                    if !comments.is_empty() {\n+                        diag.tool_only_span_suggestion(\n+                            expr.span.shrink_to_lo(),\n+                            \"add comments back\",\n+                            comments,\n+                            applicability\n+                        );\n+                    }\n+                    diag.span_suggestion(\n+                        expr.span,\n+                        \"try instead\",\n+                        sugg,\n+                        applicability\n+                    );\n+                }\n+            );\n         }\n     }\n }"}, {"sha": "8c7e919bf62a10d52bc6a343454b438f89c8857b", "filename": "tests/ui/manual_assert.edition2018.fixed", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/006a4cc7670eebd63236a16fb6495060f83d1cbc/tests%2Fui%2Fmanual_assert.edition2018.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/006a4cc7670eebd63236a16fb6495060f83d1cbc/tests%2Fui%2Fmanual_assert.edition2018.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_assert.edition2018.fixed?ref=006a4cc7670eebd63236a16fb6495060f83d1cbc", "patch": "@@ -29,9 +29,7 @@ fn main() {\n         panic!(\"qaqaq{:?}\", a);\n     }\n     assert!(a.is_empty(), \"qaqaq{:?}\", a);\n-    if !a.is_empty() {\n-        panic!(\"qwqwq\");\n-    }\n+    assert!(a.is_empty(), \"qwqwq\");\n     if a.len() == 3 {\n         println!(\"qwq\");\n         println!(\"qwq\");\n@@ -46,21 +44,11 @@ fn main() {\n         println!(\"qwq\");\n     }\n     let b = vec![1, 2, 3];\n-    if b.is_empty() {\n-        panic!(\"panic1\");\n-    }\n-    if b.is_empty() && a.is_empty() {\n-        panic!(\"panic2\");\n-    }\n-    if a.is_empty() && !b.is_empty() {\n-        panic!(\"panic3\");\n-    }\n-    if b.is_empty() || a.is_empty() {\n-        panic!(\"panic4\");\n-    }\n-    if a.is_empty() || !b.is_empty() {\n-        panic!(\"panic5\");\n-    }\n+    assert!(!b.is_empty(), \"panic1\");\n+    assert!(!(b.is_empty() && a.is_empty()), \"panic2\");\n+    assert!(!(a.is_empty() && !b.is_empty()), \"panic3\");\n+    assert!(!(b.is_empty() || a.is_empty()), \"panic4\");\n+    assert!(!(a.is_empty() || !b.is_empty()), \"panic5\");\n     assert!(!a.is_empty(), \"with expansion {}\", one!());\n     if a.is_empty() {\n         let _ = 0;\n@@ -71,12 +59,11 @@ fn main() {\n \n fn issue7730(a: u8) {\n     // Suggestion should preserve comment\n-    if a > 2 {\n-        // comment\n-        /* this is a\n+    // comment\n+/* this is a\n         multiline\n         comment */\n-        /// Doc comment\n-        panic!(\"panic with comment\") // comment after `panic!`\n-    }\n+/// Doc comment\n+// comment after `panic!`\n+assert!(!(a > 2), \"panic with comment\");\n }"}, {"sha": "3555ac29243a1cb0d819a368d8bb22bf02aea2de", "filename": "tests/ui/manual_assert.edition2018.stderr", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/006a4cc7670eebd63236a16fb6495060f83d1cbc/tests%2Fui%2Fmanual_assert.edition2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/006a4cc7670eebd63236a16fb6495060f83d1cbc/tests%2Fui%2Fmanual_assert.edition2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_assert.edition2018.stderr?ref=006a4cc7670eebd63236a16fb6495060f83d1cbc", "patch": "@@ -8,6 +8,54 @@ LL | |     }\n    |\n    = note: `-D clippy::manual-assert` implied by `-D warnings`\n \n+error: only a `panic!` in `if`-then statement\n+  --> $DIR/manual_assert.rs:34:5\n+   |\n+LL | /     if !a.is_empty() {\n+LL | |         panic!(\"qwqwq\");\n+LL | |     }\n+   | |_____^ help: try instead: `assert!(a.is_empty(), \"qwqwq\");`\n+\n+error: only a `panic!` in `if`-then statement\n+  --> $DIR/manual_assert.rs:51:5\n+   |\n+LL | /     if b.is_empty() {\n+LL | |         panic!(\"panic1\");\n+LL | |     }\n+   | |_____^ help: try instead: `assert!(!b.is_empty(), \"panic1\");`\n+\n+error: only a `panic!` in `if`-then statement\n+  --> $DIR/manual_assert.rs:54:5\n+   |\n+LL | /     if b.is_empty() && a.is_empty() {\n+LL | |         panic!(\"panic2\");\n+LL | |     }\n+   | |_____^ help: try instead: `assert!(!(b.is_empty() && a.is_empty()), \"panic2\");`\n+\n+error: only a `panic!` in `if`-then statement\n+  --> $DIR/manual_assert.rs:57:5\n+   |\n+LL | /     if a.is_empty() && !b.is_empty() {\n+LL | |         panic!(\"panic3\");\n+LL | |     }\n+   | |_____^ help: try instead: `assert!(!(a.is_empty() && !b.is_empty()), \"panic3\");`\n+\n+error: only a `panic!` in `if`-then statement\n+  --> $DIR/manual_assert.rs:60:5\n+   |\n+LL | /     if b.is_empty() || a.is_empty() {\n+LL | |         panic!(\"panic4\");\n+LL | |     }\n+   | |_____^ help: try instead: `assert!(!(b.is_empty() || a.is_empty()), \"panic4\");`\n+\n+error: only a `panic!` in `if`-then statement\n+  --> $DIR/manual_assert.rs:63:5\n+   |\n+LL | /     if a.is_empty() || !b.is_empty() {\n+LL | |         panic!(\"panic5\");\n+LL | |     }\n+   | |_____^ help: try instead: `assert!(!(a.is_empty() || !b.is_empty()), \"panic5\");`\n+\n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:66:5\n    |\n@@ -16,5 +64,22 @@ LL | |         panic!(\"with expansion {}\", one!())\n LL | |     }\n    | |_____^ help: try instead: `assert!(!a.is_empty(), \"with expansion {}\", one!());`\n \n-error: aborting due to 2 previous errors\n+error: only a `panic!` in `if`-then statement\n+  --> $DIR/manual_assert.rs:78:5\n+   |\n+LL | /     if a > 2 {\n+LL | |         // comment\n+LL | |         /* this is a\n+LL | |         multiline\n+...  |\n+LL | |         panic!(\"panic with comment\") // comment after `panic!`\n+LL | |     }\n+   | |_____^\n+   |\n+help: try instead\n+   |\n+LL |     assert!(!(a > 2), \"panic with comment\");\n+   |\n+\n+error: aborting due to 9 previous errors\n "}]}