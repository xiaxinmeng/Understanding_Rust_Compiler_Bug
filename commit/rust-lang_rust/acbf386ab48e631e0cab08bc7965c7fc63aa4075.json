{"sha": "acbf386ab48e631e0cab08bc7965c7fc63aa4075", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjYmYzODZhYjQ4ZTYzMWUwY2FiMDhiYzc5NjVjN2ZjNjNhYTQwNzU=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2016-03-21T07:24:07Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2016-03-23T03:03:19Z"}, "message": "term: undo conversion of user defined try!s", "tree": {"sha": "d67485acabe6885fb01e6e8a008d3a7a27bb6f25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d67485acabe6885fb01e6e8a008d3a7a27bb6f25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/acbf386ab48e631e0cab08bc7965c7fc63aa4075", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/acbf386ab48e631e0cab08bc7965c7fc63aa4075", "html_url": "https://github.com/rust-lang/rust/commit/acbf386ab48e631e0cab08bc7965c7fc63aa4075", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/acbf386ab48e631e0cab08bc7965c7fc63aa4075/comments", "author": null, "committer": null, "parents": [{"sha": "f88a1e6f21c000f2d3b2e71778a7fa655cd8423c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f88a1e6f21c000f2d3b2e71778a7fa655cd8423c", "html_url": "https://github.com/rust-lang/rust/commit/f88a1e6f21c000f2d3b2e71778a7fa655cd8423c"}], "stats": {"total": 34, "additions": 19, "deletions": 15}, "files": [{"sha": "8d1ba378521529ac87043a85dc698975ec14bcb1", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/acbf386ab48e631e0cab08bc7965c7fc63aa4075/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acbf386ab48e631e0cab08bc7965c7fc63aa4075/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=acbf386ab48e631e0cab08bc7965c7fc63aa4075", "patch": "@@ -186,7 +186,7 @@ fn read_byte(r: &mut io::Read) -> io::Result<u8> {\n /// Parse a compiled terminfo entry, using long capability names if `longnames`\n /// is true\n pub fn parse(file: &mut io::Read, longnames: bool) -> Result<TermInfo, String> {\n-    macro_rules! try( ($e:expr) => (\n+    macro_rules! t( ($e:expr) => (\n         match $e {\n             Ok(e) => e,\n             Err(e) => return Err(format!(\"{}\", e))\n@@ -200,7 +200,7 @@ pub fn parse(file: &mut io::Read, longnames: bool) -> Result<TermInfo, String> {\n     };\n \n     // Check magic number\n-    let magic = read_le_u16(file)?;\n+    let magic = t!(read_le_u16(file));\n     if magic != 0x011A {\n         return Err(format!(\"invalid magic number: expected {:x}, found {:x}\",\n                            0x011A,\n@@ -211,7 +211,7 @@ pub fn parse(file: &mut io::Read, longnames: bool) -> Result<TermInfo, String> {\n     // supported. Using 0 instead of -1 works because we skip sections with length 0.\n     macro_rules! read_nonneg {\n         () => {{\n-            match try!(read_le_u16(file)) as i16 {\n+            match t!(read_le_u16(file)) as i16 {\n                 n if n >= 0 => n as usize,\n                 -1 => 0,\n                 _ => return Err(\"incompatible file: length fields must be  >= -1\".to_string()),\n@@ -243,7 +243,7 @@ pub fn parse(file: &mut io::Read, longnames: bool) -> Result<TermInfo, String> {\n \n     // don't read NUL\n     let mut bytes = Vec::new();\n-    file.take((names_bytes - 1) as u64).read_to_end(&mut bytes)?;\n+    t!(file.take((names_bytes - 1) as u64).read_to_end(&mut bytes));\n     let names_str = match String::from_utf8(bytes) {\n         Ok(s) => s,\n         Err(_) => return Err(\"input not utf-8\".to_string()),\n@@ -253,35 +253,39 @@ pub fn parse(file: &mut io::Read, longnames: bool) -> Result<TermInfo, String> {\n                                            .map(|s| s.to_string())\n                                            .collect();\n     // consume NUL\n-    if read_byte(file)? != b'\\0' {\n+    if t!(read_byte(file)) != b'\\0' {\n         return Err(\"incompatible file: missing null terminator for names section\".to_string());\n     }\n \n-    let bools_map: HashMap<String, bool> = (0..bools_bytes).filter_map(|i| match read_byte(file) {\n+    let bools_map: HashMap<String, bool> = t! {\n+        (0..bools_bytes).filter_map(|i| match read_byte(file) {\n             Err(e) => Some(Err(e)),\n             Ok(1) => Some(Ok((bnames[i].to_string(), true))),\n             Ok(_) => None\n-        }).collect()?;\n+        }).collect()\n+    };\n \n     if (bools_bytes + names_bytes) % 2 == 1 {\n-        read_byte(file)?; // compensate for padding\n+        t!(read_byte(file)); // compensate for padding\n     }\n \n-    let numbers_map: HashMap<String, u16> = (0..numbers_count).filter_map(|i| match read_le_u16(file) {\n+    let numbers_map: HashMap<String, u16> = t! {\n+        (0..numbers_count).filter_map(|i| match read_le_u16(file) {\n             Ok(0xFFFF) => None,\n             Ok(n) => Some(Ok((nnames[i].to_string(), n))),\n             Err(e) => Some(Err(e))\n-        }).collect()?;\n+        }).collect()\n+    };\n \n     let string_map: HashMap<String, Vec<u8>> = if string_offsets_count > 0 {\n-        let string_offsets: Vec<u16> = (0..string_offsets_count)\n+        let string_offsets: Vec<u16> = t!((0..string_offsets_count)\n                                                 .map(|_| read_le_u16(file))\n-                                                .collect()?;\n+                                                .collect());\n \n         let mut string_table = Vec::new();\n-        file.take(string_table_bytes as u64).read_to_end(&mut string_table)?;\n+        t!(file.take(string_table_bytes as u64).read_to_end(&mut string_table));\n \n-        string_offsets.into_iter().enumerate().filter(|&(_, offset)| {\n+        t!(string_offsets.into_iter().enumerate().filter(|&(_, offset)| {\n             // non-entry\n             offset != 0xFFFF\n         }).map(|(i, offset)| {\n@@ -305,7 +309,7 @@ pub fn parse(file: &mut io::Read, longnames: bool) -> Result<TermInfo, String> {\n                 Some(len) => Ok((name.to_string(), string_table[offset..offset + len].to_vec())),\n                 None => Err(\"invalid file: missing NUL in string_table\".to_string()),\n             }\n-        }).collect()?\n+        }).collect())\n     } else {\n         HashMap::new()\n     };"}]}