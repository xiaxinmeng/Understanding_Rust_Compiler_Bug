{"sha": "8741303f6e50f0a596a98449138b0ffd8e345a7f", "node_id": "C_kwDOAAsO6NoAKDg3NDEzMDNmNmU1MGYwYTU5NmE5ODQ0OTEzOGIwZmZkOGUzNDVhN2Y", "commit": {"author": {"name": "Neven Villani", "email": "vanille@crans.org", "date": "2023-03-16T13:48:46Z"}, "committer": {"name": "Neven Villani", "email": "vanille@crans.org", "date": "2023-03-16T13:56:16Z"}, "message": "TB: document TB changes in README", "tree": {"sha": "3aad709ceb78f00fb9d101d312c49ff5e114b76f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3aad709ceb78f00fb9d101d312c49ff5e114b76f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8741303f6e50f0a596a98449138b0ffd8e345a7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8741303f6e50f0a596a98449138b0ffd8e345a7f", "html_url": "https://github.com/rust-lang/rust/commit/8741303f6e50f0a596a98449138b0ffd8e345a7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8741303f6e50f0a596a98449138b0ffd8e345a7f/comments", "author": {"login": "Vanille-N", "id": 58042063, "node_id": "MDQ6VXNlcjU4MDQyMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/58042063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vanille-N", "html_url": "https://github.com/Vanille-N", "followers_url": "https://api.github.com/users/Vanille-N/followers", "following_url": "https://api.github.com/users/Vanille-N/following{/other_user}", "gists_url": "https://api.github.com/users/Vanille-N/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vanille-N/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vanille-N/subscriptions", "organizations_url": "https://api.github.com/users/Vanille-N/orgs", "repos_url": "https://api.github.com/users/Vanille-N/repos", "events_url": "https://api.github.com/users/Vanille-N/events{/privacy}", "received_events_url": "https://api.github.com/users/Vanille-N/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Vanille-N", "id": 58042063, "node_id": "MDQ6VXNlcjU4MDQyMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/58042063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vanille-N", "html_url": "https://github.com/Vanille-N", "followers_url": "https://api.github.com/users/Vanille-N/followers", "following_url": "https://api.github.com/users/Vanille-N/following{/other_user}", "gists_url": "https://api.github.com/users/Vanille-N/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vanille-N/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vanille-N/subscriptions", "organizations_url": "https://api.github.com/users/Vanille-N/orgs", "repos_url": "https://api.github.com/users/Vanille-N/repos", "events_url": "https://api.github.com/users/Vanille-N/events{/privacy}", "received_events_url": "https://api.github.com/users/Vanille-N/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bbb0404f8c49c0d703492303e766d0703017bb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bbb0404f8c49c0d703492303e766d0703017bb8", "html_url": "https://github.com/rust-lang/rust/commit/8bbb0404f8c49c0d703492303e766d0703017bb8"}], "stats": {"total": 336, "additions": 218, "deletions": 118}, "files": [{"sha": "b70f7e0e55634a2bb892a3b970956a50e2f2ff5e", "filename": "src/tools/miri/README.md", "status": "modified", "additions": 13, "deletions": 118, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/8741303f6e50f0a596a98449138b0ffd8e345a7f/src%2Ftools%2Fmiri%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/8741303f6e50f0a596a98449138b0ffd8e345a7f/src%2Ftools%2Fmiri%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FREADME.md?ref=8741303f6e50f0a596a98449138b0ffd8e345a7f", "patch": "@@ -15,6 +15,8 @@ for example:\n   or an invalid enum discriminant)\n * **Experimental**: Violations of the [Stacked Borrows] rules governing aliasing\n   for reference types\n+* **Experimental**: Violations of the Tree Borrows aliasing rules, as an optional\n+  alternative to [Stacked Borrows]\n * **Experimental**: Data races\n \n On top of that, Miri will also tell you about memory leaks: when there is memory\n@@ -357,9 +359,11 @@ to Miri failing to detect cases of undefined behavior in a program.\n * `-Zmiri-disable-data-race-detector` disables checking for data races.  Using\n   this flag is **unsound**. This implies `-Zmiri-disable-weak-memory-emulation`.\n * `-Zmiri-disable-stacked-borrows` disables checking the experimental\n-  [Stacked Borrows] aliasing rules.  This can make Miri run faster, but it also\n-  means no aliasing violations will be detected.  Using this flag is **unsound**\n-  (but the affected soundness rules are experimental).\n+  aliasing rules to track borrows ([Stacked Borrows] and Tree Borrows).\n+  This can make Miri run faster, but it also means no aliasing violations will\n+  be detected. Using this flag is **unsound** (but the affected soundness rules\n+  are experimental). Later flags take precedence: borrow tracking can be reactivated\n+  by `-Zmiri-tree-borrows`.\n * `-Zmiri-disable-validation` disables enforcing validity invariants, which are\n   enforced by default.  This is mostly useful to focus on other failures (such\n   as out-of-bounds accesses) first.  Setting this flag means Miri can miss bugs\n@@ -421,6 +425,9 @@ to Miri failing to detect cases of undefined behavior in a program.\n * `-Zmiri-track-weak-memory-loads` shows a backtrace when weak memory emulation returns an outdated\n   value from a load. This can help diagnose problems that disappear under\n   `-Zmiri-disable-weak-memory-emulation`.\n+* `-Zmiri-tree-borrows` replaces [Stacked Borrows] with the Tree Borrows rules.\n+  The soundness rules are already experimental without this flag, but even more\n+  so with this flag.\n * `-Zmiri-force-page-size=<num>` overrides the default page size for an architecture, in multiples of 1k.\n   `4` is default for most targets. This value should always be a power of 2 and nonzero.\n \n@@ -435,7 +442,7 @@ Some native rustc `-Z` flags are also very relevant for Miri:\n   functions.  This is needed so that Miri can execute such functions, so Miri\n   sets this flag per default.\n * `-Zmir-emit-retag` controls whether `Retag` statements are emitted. Miri\n-  enables this per default because it is needed for [Stacked Borrows].\n+  enables this per default because it is needed for [Stacked Borrows] and Tree Borrows.\n \n Moreover, Miri recognizes some environment variables:\n \n@@ -501,120 +508,8 @@ binaries, and as such worth documenting:\n ## Miri `extern` functions\n \n Miri provides some `extern` functions that programs can import to access\n-Miri-specific functionality:\n-\n-```rust\n-#[cfg(miri)]\n-extern \"Rust\" {\n-    /// Miri-provided extern function to mark the block `ptr` points to as a \"root\"\n-    /// for some static memory. This memory and everything reachable by it is not\n-    /// considered leaking even if it still exists when the program terminates.\n-    ///\n-    /// `ptr` has to point to the beginning of an allocated block.\n-    fn miri_static_root(ptr: *const u8);\n-\n-    // Miri-provided extern function to get the amount of frames in the current backtrace.\n-    // The `flags` argument must be `0`.\n-    fn miri_backtrace_size(flags: u64) -> usize;\n-\n-    /// Miri-provided extern function to obtain a backtrace of the current call stack.\n-    /// This writes a slice of pointers into `buf` - each pointer is an opaque value\n-    /// that is only useful when passed to `miri_resolve_frame`.\n-    /// `buf` must have `miri_backtrace_size(0) * pointer_size` bytes of space.\n-    /// The `flags` argument must be `1`.\n-    fn miri_get_backtrace(flags: u64, buf: *mut *mut ());\n-\n-    /// Miri-provided extern function to resolve a frame pointer obtained\n-    /// from `miri_get_backtrace`. The `flags` argument must be `1`,\n-    /// and `MiriFrame` should be declared as follows:\n-    ///\n-    /// ```rust\n-    /// #[repr(C)]\n-    /// struct MiriFrame {\n-    ///     // The size of the name of the function being executed, encoded in UTF-8\n-    ///     name_len: usize,\n-    ///     // The size of filename of the function being executed, encoded in UTF-8\n-    ///     filename_len: usize,\n-    ///     // The line number currently being executed in `filename`, starting from '1'.\n-    ///     lineno: u32,\n-    ///     // The column number currently being executed in `filename`, starting from '1'.\n-    ///     colno: u32,\n-    ///     // The function pointer to the function currently being executed.\n-    ///     // This can be compared against function pointers obtained by\n-    ///     // casting a function (e.g. `my_fn as *mut ()`)\n-    ///     fn_ptr: *mut ()\n-    /// }\n-    /// ```\n-    ///\n-    /// The fields must be declared in exactly the same order as they appear in `MiriFrame` above.\n-    /// This function can be called on any thread (not just the one which obtained `frame`).\n-    fn miri_resolve_frame(frame: *mut (), flags: u64) -> MiriFrame;\n-\n-    /// Miri-provided extern function to get the name and filename of the frame provided by `miri_resolve_frame`.\n-    /// `name_buf` and `filename_buf` should be allocated with the `name_len` and `filename_len` fields of `MiriFrame`.\n-    /// The flags argument must be `0`.\n-    fn miri_resolve_frame_names(ptr: *mut (), flags: u64, name_buf: *mut u8, filename_buf: *mut u8);\n-\n-    /// Miri-provided extern function to begin unwinding with the given payload.\n-    ///\n-    /// This is internal and unstable and should not be used; we give it here\n-    /// just to be complete.\n-    fn miri_start_panic(payload: *mut u8) -> !;\n-\n-    /// Miri-provided extern function to get the internal unique identifier for the allocation that a pointer\n-    /// points to. If this pointer is invalid (not pointing to an allocation), interpretation will abort.\n-    ///\n-    /// This is only useful as an input to `miri_print_borrow_stacks`, and it is a separate call because\n-    /// getting a pointer to an allocation at runtime can change the borrow stacks in the allocation.\n-    /// This function should be considered unstable. It exists only to support `miri_print_borrow_stacks` and so\n-    /// inherits all of its instability.\n-    fn miri_get_alloc_id(ptr: *const ()) -> u64;\n-\n-    /// Miri-provided extern function to print (from the interpreter, not the program) the contents of all\n-    /// borrow stacks in an allocation. The leftmost tag is the bottom of the stack.\n-    /// The format of what this emits is unstable and may change at any time. In particular, users should be\n-    /// aware that Miri will periodically attempt to garbage collect the contents of all stacks. Callers of\n-    /// this function may wish to pass `-Zmiri-tag-gc=0` to disable the GC.\n-    ///\n-    /// This function is extremely unstable. At any time the format of its output may change, its signature may\n-    /// change, or it may be removed entirely.\n-    fn miri_print_borrow_stacks(alloc_id: u64);\n-\n-    /// Miri-provided extern function to print (from the interpreter, not the\n-    /// program) the contents of a section of program memory, as bytes. Bytes\n-    /// written using this function will emerge from the interpreter's stdout.\n-    fn miri_write_to_stdout(bytes: &[u8]);\n-\n-    /// Miri-provided extern function to print (from the interpreter, not the\n-    /// program) the contents of a section of program memory, as bytes. Bytes\n-    /// written using this function will emerge from the interpreter's stderr.\n-    fn miri_write_to_stderr(bytes: &[u8]);\n-\n-    /// Miri-provided extern function to allocate memory from the interpreter.\n-    /// \n-    /// This is useful when no fundamental way of allocating memory is\n-    /// available, e.g. when using `no_std` + `alloc`.\n-    fn miri_alloc(size: usize, align: usize) -> *mut u8;\n-\n-    /// Miri-provided extern function to deallocate memory.\n-    fn miri_dealloc(ptr: *mut u8, size: usize, align: usize);\n-\n-    /// Convert a path from the host Miri runs on to the target Miri interprets.\n-    /// Performs conversion of path separators as needed.\n-    ///\n-    /// Usually Miri performs this kind of conversion automatically. However, manual conversion\n-    /// might be necessary when reading an environment variable that was set on the host\n-    /// (such as TMPDIR) and using it as a target path.\n-    ///\n-    /// Only works with isolation disabled.\n-    ///\n-    /// `in` must point to a null-terminated string, and will be read as the input host path.\n-    /// `out` must point to at least `out_size` many bytes, and the result will be stored there\n-    /// with a null terminator.\n-    /// Returns 0 if the `out` buffer was large enough, and the required size otherwise.\n-    fn miri_host_to_target_path(path: *const std::ffi::c_char, out: *mut std::ffi::c_char, out_size: usize) -> usize;\n-}\n-```\n+Miri-specific functionality. They are declared in\n+[/tests/utils/miri\\_extern.rs](/tests/utils/miri_extern.rs).\n \n ## Contributing and getting help\n "}, {"sha": "de223410fba6bb62089ce648fc229608eb986c44", "filename": "src/tools/miri/tests/utils/macros.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8741303f6e50f0a596a98449138b0ffd8e345a7f/src%2Ftools%2Fmiri%2Ftests%2Futils%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8741303f6e50f0a596a98449138b0ffd8e345a7f/src%2Ftools%2Fmiri%2Ftests%2Futils%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Futils%2Fmacros.rs?ref=8741303f6e50f0a596a98449138b0ffd8e345a7f", "patch": "@@ -0,0 +1,61 @@\n+#![allow(unused_macros)]\n+#![allow(unused_macro_rules)]\n+#![allow(unused_imports)]\n+\n+/// `alloc_id!(ptr)`: obtain the allocation id from a pointer.\n+///\n+/// `ptr` should be any pointer or reference that can be converted with `_ as *const u8`.\n+///\n+/// The id obtained can be passed directly to `print_state!`.\n+macro_rules! alloc_id {\n+    ($ptr:expr) => {\n+        crate::utils::miri_extern::miri_get_alloc_id($ptr as *const u8 as *const ())\n+    };\n+}\n+\n+/// `print_state!(alloc_id, show_unnamed)`: print the internal state of the borrow\n+/// tracker (stack or tree).\n+///\n+/// `alloc_id` should be obtained from `alloc_id!`.\n+///\n+/// `show_unnamed` is an optional boolean that determines if Tree Borrows displays\n+/// tags that have not been given a name. Defaults to `false`.\n+macro_rules! print_state {\n+    ($alloc_id:expr) => {\n+        crate::utils::macros::print_state!($alloc_id, false);\n+    };\n+    ($alloc_id:expr, $show:expr) => {\n+        crate::utils::miri_extern::miri_print_borrow_state($alloc_id, $show);\n+    };\n+}\n+\n+/// `name!(ptr => nth_parent, name)`: associate `name` to the `nth_parent` of `ptr`.\n+///\n+/// `ptr` should be any pointer or reference that can be converted with `_ as *const u8`.\n+///\n+/// `nth_parent` is an optional `u8` that defaults to 0. The corresponding ancestor\n+/// of the tag of `ptr` will be searched: 0 for `ptr` itself, 1 for the direct parent\n+/// of `ptr`, 2 for the grandparent, etc. If `nth_parent` is not specified,\n+/// then `=>` should also not be included.\n+///\n+/// `name` is an optional string that will be used as the name. Defaults to\n+/// `stringify!($ptr)` the name of `ptr` in the source code.\n+macro_rules! name {\n+    ($ptr:expr, $name:expr) => {\n+        crate::utils::macros::name!($ptr => 0, $name);\n+    };\n+    ($ptr:expr) => {\n+        crate::utils::macros::name!($ptr => 0, stringify!($ptr));\n+    };\n+    ($ptr:expr => $nb:expr) => {\n+        crate::utils::macros::name!($ptr => $nb, stringify!($ptr));\n+    };\n+    ($ptr:expr => $nb:expr, $name:expr) => {\n+        let name = $name.as_bytes();\n+        crate::utils::miri_extern::miri_pointer_name($ptr as *const u8 as *const (), $nb, name);\n+    };\n+}\n+\n+pub(crate) use alloc_id;\n+pub(crate) use name;\n+pub(crate) use print_state;"}, {"sha": "6c4298c613b4526fe4b4be13bf09279b42cc9e4a", "filename": "src/tools/miri/tests/utils/miri_extern.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/8741303f6e50f0a596a98449138b0ffd8e345a7f/src%2Ftools%2Fmiri%2Ftests%2Futils%2Fmiri_extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8741303f6e50f0a596a98449138b0ffd8e345a7f/src%2Ftools%2Fmiri%2Ftests%2Futils%2Fmiri_extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Futils%2Fmiri_extern.rs?ref=8741303f6e50f0a596a98449138b0ffd8e345a7f", "patch": "@@ -0,0 +1,142 @@\n+#![allow(dead_code)]\n+\n+#[repr(C)]\n+/// Layout of the return value of `miri_resolve_frame`,\n+/// with fields in the exact same order.\n+pub struct MiriFrame {\n+    // The size of the name of the function being executed, encoded in UTF-8\n+    pub name_len: usize,\n+    // The size of filename of the function being executed, encoded in UTF-8\n+    pub filename_len: usize,\n+    // The line number currently being executed in `filename`, starting from '1'.\n+    pub lineno: u32,\n+    // The column number currently being executed in `filename`, starting from '1'.\n+    pub colno: u32,\n+    // The function pointer to the function currently being executed.\n+    // This can be compared against function pointers obtained by\n+    // casting a function (e.g. `my_fn as *mut ()`)\n+    pub fn_ptr: *mut (),\n+}\n+\n+#[cfg(miri)]\n+extern \"Rust\" {\n+    /// Miri-provided extern function to mark the block `ptr` points to as a \"root\"\n+    /// for some static memory. This memory and everything reachable by it is not\n+    /// considered leaking even if it still exists when the program terminates.\n+    ///\n+    /// `ptr` has to point to the beginning of an allocated block.\n+    pub fn miri_static_root(ptr: *const u8);\n+\n+    // Miri-provided extern function to get the amount of frames in the current backtrace.\n+    // The `flags` argument must be `0`.\n+    pub fn miri_backtrace_size(flags: u64) -> usize;\n+\n+    /// Miri-provided extern function to obtain a backtrace of the current call stack.\n+    /// This writes a slice of pointers into `buf` - each pointer is an opaque value\n+    /// that is only useful when passed to `miri_resolve_frame`.\n+    /// `buf` must have `miri_backtrace_size(0) * pointer_size` bytes of space.\n+    /// The `flags` argument must be `1`.\n+    pub fn miri_get_backtrace(flags: u64, buf: *mut *mut ());\n+\n+    /// Miri-provided extern function to resolve a frame pointer obtained\n+    /// from `miri_get_backtrace`. The `flags` argument must be `1`.\n+    ///\n+    /// This function can be called on any thread (not just the one which obtained `frame`).\n+    pub fn miri_resolve_frame(frame: *mut (), flags: u64) -> MiriFrame;\n+\n+    /// Miri-provided extern function to get the name and filename of the frame provided by `miri_resolve_frame`.\n+    /// `name_buf` and `filename_buf` should be allocated with the `name_len` and `filename_len` fields of `MiriFrame`.\n+    /// The flags argument must be `0`.\n+    pub fn miri_resolve_frame_names(\n+        ptr: *mut (),\n+        flags: u64,\n+        name_buf: *mut u8,\n+        filename_buf: *mut u8,\n+    );\n+\n+    /// Miri-provided extern function to begin unwinding with the given payload.\n+    ///\n+    /// This is internal and unstable and should not be used; we give it here\n+    /// just to be complete.\n+    pub fn miri_start_panic(payload: *mut u8) -> !;\n+\n+    /// Miri-provided extern function to get the internal unique identifier for the allocation that a pointer\n+    /// points to. If this pointer is invalid (not pointing to an allocation), interpretation will abort.\n+    ///\n+    /// This is only useful as an input to `miri_print_borrow_stacks`, and it is a separate call because\n+    /// getting a pointer to an allocation at runtime can change the borrow stacks in the allocation.\n+    /// This function should be considered unstable. It exists only to support `miri_print_borrow_stacks` and so\n+    /// inherits all of its instability.\n+    pub fn miri_get_alloc_id(ptr: *const ()) -> u64;\n+\n+    /// Miri-provided extern function to print (from the interpreter, not the program) the contents of all\n+    /// borrows in an allocation.\n+    ///\n+    /// If Stacked Borrows is running, this prints all the stacks. The leftmost tag is the bottom of the stack.\n+    ///\n+    /// If Tree borrows is running, this prints on the left the permissions of each tag on each range,\n+    /// an on the right the tree structure of the tags. If some tags were named via `miri_pointer_name`,\n+    /// their names appear here.\n+    ///\n+    /// If additionally `show_unnamed` is `false` then tags that did *not* receive a name will be hidden.\n+    /// Ensure that either the important tags have been named, or `show_unnamed = true`.\n+    /// Note: as Stacked Borrows does not have tag names at all, `show_unnamed` is ignored and all tags are shown.\n+    /// In general, unless you strongly want some tags to be hidden (as is the case in `tree-borrows` tests),\n+    /// `show_unnamed = true` should be the default.\n+    ///\n+    /// The format of what this emits is unstable and may change at any time. In particular, users should be\n+    /// aware that Miri will periodically attempt to garbage collect the contents of all stacks. Callers of\n+    /// this function may wish to pass `-Zmiri-tag-gc=0` to disable the GC.\n+    ///\n+    /// This function is extremely unstable. At any time the format of its output may change, its signature may\n+    /// change, or it may be removed entirely.\n+    pub fn miri_print_borrow_state(alloc_id: u64, show_unnamed: bool);\n+\n+    /// Miri-provided extern function to associate a name to the nth parent of a tag.\n+    /// Typically the name given would be the name of the program variable that holds the pointer.\n+    /// Unreachable tags can still be named by using nonzero `nth_parent` and a child tag.\n+    ///\n+    /// This function does nothing under Stacked Borrows, since Stacked Borrows's implementation\n+    /// of `miri_print_borrow_state` does not show the names.\n+    ///\n+    /// Under Tree Borrows, the names also appear in error messages.\n+    pub fn miri_pointer_name(ptr: *const (), nth_parent: u8, name: &[u8]);\n+\n+    /// Miri-provided extern function to print (from the interpreter, not the\n+    /// program) the contents of a section of program memory, as bytes. Bytes\n+    /// written using this function will emerge from the interpreter's stdout.\n+    pub fn miri_write_to_stdout(bytes: &[u8]);\n+\n+    /// Miri-provided extern function to print (from the interpreter, not the\n+    /// program) the contents of a section of program memory, as bytes. Bytes\n+    /// written using this function will emerge from the interpreter's stderr.\n+    pub fn miri_write_to_stderr(bytes: &[u8]);\n+\n+    /// Miri-provided extern function to allocate memory from the interpreter.\n+    ///\n+    /// This is useful when no fundamental way of allocating memory is\n+    /// available, e.g. when using `no_std` + `alloc`.\n+    pub fn miri_alloc(size: usize, align: usize) -> *mut u8;\n+\n+    /// Miri-provided extern function to deallocate memory.\n+    pub fn miri_dealloc(ptr: *mut u8, size: usize, align: usize);\n+\n+    /// Convert a path from the host Miri runs on to the target Miri interprets.\n+    /// Performs conversion of path separators as needed.\n+    ///\n+    /// Usually Miri performs this kind of conversion automatically. However, manual conversion\n+    /// might be necessary when reading an environment variable that was set on the host\n+    /// (such as TMPDIR) and using it as a target path.\n+    ///\n+    /// Only works with isolation disabled.\n+    ///\n+    /// `in` must point to a null-terminated string, and will be read as the input host path.\n+    /// `out` must point to at least `out_size` many bytes, and the result will be stored there\n+    /// with a null terminator.\n+    /// Returns 0 if the `out` buffer was large enough, and the required size otherwise.\n+    pub fn miri_host_to_target_path(\n+        path: *const std::ffi::c_char,\n+        out: *mut std::ffi::c_char,\n+        out_size: usize,\n+    ) -> usize;\n+}"}, {"sha": "e1ea77e4df8c7018a72d7a93a0c0e574e3c224cf", "filename": "src/tools/miri/tests/utils/mod.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8741303f6e50f0a596a98449138b0ffd8e345a7f/src%2Ftools%2Fmiri%2Ftests%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8741303f6e50f0a596a98449138b0ffd8e345a7f/src%2Ftools%2Fmiri%2Ftests%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Futils%2Fmod.rs?ref=8741303f6e50f0a596a98449138b0ffd8e345a7f", "patch": "@@ -0,0 +1,2 @@\n+pub mod macros;\n+pub mod miri_extern;"}]}