{"sha": "d6e5797e4130c9925734b0a42b4e8d5a1a23073a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZTU3OTdlNDEzMGM5OTI1NzM0YjBhNDJiNGU4ZDVhMWEyMzA3M2E=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-07-22T11:40:51Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-08-29T01:15:23Z"}, "message": "Introduce snapshot_vec abstraction", "tree": {"sha": "e30f226f37fa4f2c7257194389878b6fa97d8741", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e30f226f37fa4f2c7257194389878b6fa97d8741"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6e5797e4130c9925734b0a42b4e8d5a1a23073a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6e5797e4130c9925734b0a42b4e8d5a1a23073a", "html_url": "https://github.com/rust-lang/rust/commit/d6e5797e4130c9925734b0a42b4e8d5a1a23073a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6e5797e4130c9925734b0a42b4e8d5a1a23073a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "790d9c47081c9ddffaad096239e0dfee2f2d10a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/790d9c47081c9ddffaad096239e0dfee2f2d10a6", "html_url": "https://github.com/rust-lang/rust/commit/790d9c47081c9ddffaad096239e0dfee2f2d10a6"}], "stats": {"total": 362, "additions": 225, "deletions": 137}, "files": [{"sha": "ebce1a2a69b1431a0daa75716273982ded478683", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6e5797e4130c9925734b0a42b4e8d5a1a23073a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e5797e4130c9925734b0a42b4e8d5a1a23073a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=d6e5797e4130c9925734b0a42b4e8d5a1a23073a", "patch": "@@ -136,6 +136,7 @@ pub mod util {\n     pub mod common;\n     pub mod ppaux;\n     pub mod nodemap;\n+    pub mod snapshot_vec;\n }\n \n pub mod lib {"}, {"sha": "e672b8b310f5dc0be9801aec02321920dc9bd3f3", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6e5797e4130c9925734b0a42b4e8d5a1a23073a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e5797e4130c9925734b0a42b4e8d5a1a23073a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=d6e5797e4130c9925734b0a42b4e8d5a1a23073a", "patch": "@@ -555,13 +555,13 @@ impl<'a> InferCtxt<'a> {\n \n         self.type_unification_table\n             .borrow_mut()\n-            .rollback_to(self.tcx, type_snapshot);\n+            .rollback_to(type_snapshot);\n         self.int_unification_table\n             .borrow_mut()\n-            .rollback_to(self.tcx, int_snapshot);\n+            .rollback_to(int_snapshot);\n         self.float_unification_table\n             .borrow_mut()\n-            .rollback_to(self.tcx, float_snapshot);\n+            .rollback_to(float_snapshot);\n         self.region_vars\n             .rollback_to(region_vars_snapshot);\n     }"}, {"sha": "fd722d369663871a67af60f707d319d17f66902f", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 26, "deletions": 134, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/d6e5797e4130c9925734b0a42b4e8d5a1a23073a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e5797e4130c9925734b0a42b4e8d5a1a23073a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=d6e5797e4130c9925734b0a42b4e8d5a1a23073a", "patch": "@@ -16,9 +16,9 @@ use middle::typeck::infer::{Bounds, uok, ures};\n use middle::typeck::infer::InferCtxt;\n use std::cell::RefCell;\n use std::fmt::Show;\n-use std::mem;\n use syntax::ast;\n use util::ppaux::Repr;\n+use util::snapshot_vec as sv;\n \n /**\n  * This trait is implemented by any type that can serve as a type\n@@ -82,43 +82,18 @@ pub struct UnificationTable<K,V> {\n     /**\n      * Indicates the current value of each key.\n      */\n-    values: Vec<VarValue<K,V>>,\n \n-    /**\n-     * When a snapshot is active, logs each change made to the table\n-     * so that they can be unrolled.\n-     */\n-    undo_log: Vec<UndoLog<K,V>>,\n+    values: sv::SnapshotVec<VarValue<K,V>,(),Delegate>,\n }\n \n /**\n  * At any time, users may snapshot a unification table.  The changes\n  * made during the snapshot may either be *committed* or *rolled back*.\n  */\n pub struct Snapshot<K> {\n-    // Ensure that this snapshot is keyed to the table type.\n-    marker1: marker::CovariantType<K>,\n-\n-    // Snapshots are tokens that should be created/consumed linearly.\n-    marker2: marker::NoCopy,\n-\n-    // Length of the undo log at the time the snapshot was taken.\n-    length: uint,\n-}\n-\n-#[deriving(PartialEq)]\n-enum UndoLog<K,V> {\n-    /// Indicates where a snapshot started.\n-    OpenSnapshot,\n-\n-    /// Indicates a snapshot that has been committed.\n-    CommittedSnapshot,\n-\n-    /// New variable with given index was created.\n-    NewVar(uint),\n-\n-    /// Variable with given index was changed *from* the given value.\n-    SetVar(uint, VarValue<K,V>),\n+    // Link snapshot to the key type `K` of the table.\n+    marker: marker::CovariantType<K>,\n+    snapshot: sv::Snapshot,\n }\n \n /**\n@@ -131,6 +106,8 @@ pub struct Node<K,V> {\n     pub rank: uint,\n }\n \n+pub struct Delegate;\n+\n // We can't use V:LatticeValue, much as I would like to,\n // because frequently the pattern is that V=Bounds<U> for some\n // other type parameter U, and we have no way to say\n@@ -139,127 +116,46 @@ pub struct Node<K,V> {\n impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n     pub fn new() -> UnificationTable<K,V> {\n         UnificationTable {\n-            values: Vec::new(),\n-            undo_log: Vec::new()\n+            values: sv::SnapshotVec::new(Delegate),\n         }\n     }\n \n-    pub fn in_snapshot(&self) -> bool {\n-        /*! True if a snapshot has been started. */\n-\n-        self.undo_log.len() > 0\n-    }\n-\n     /**\n      * Starts a new snapshot. Each snapshot must be either\n      * rolled back or committed in a \"LIFO\" (stack) order.\n      */\n     pub fn snapshot(&mut self) -> Snapshot<K> {\n-        let length = self.undo_log.len();\n-        debug!(\"{}: snapshot at length {}\",\n-               UnifyKey::tag(None::<K>),\n-               length);\n-        self.undo_log.push(OpenSnapshot);\n-        Snapshot { length: length,\n-                   marker1: marker::CovariantType,\n-                   marker2: marker::NoCopy }\n-    }\n-\n-    fn assert_open_snapshot(&self, snapshot: &Snapshot<K>) {\n-        // Or else there was a failure to follow a stack discipline:\n-        assert!(self.undo_log.len() > snapshot.length);\n-\n-        // Invariant established by start_snapshot():\n-        assert!(*self.undo_log.get(snapshot.length) == OpenSnapshot);\n+        Snapshot { marker: marker::CovariantType::<K>,\n+                   snapshot: self.values.start_snapshot() }\n     }\n \n     /**\n      * Reverses all changes since the last snapshot. Also\n      * removes any keys that have been created since then.\n      */\n-    pub fn rollback_to(&mut self, tcx: &ty::ctxt, snapshot: Snapshot<K>) {\n-        debug!(\"{}: rollback_to({})\",\n-               UnifyKey::tag(None::<K>),\n-               snapshot.length);\n-\n-        self.assert_open_snapshot(&snapshot);\n-\n-        while self.undo_log.len() > snapshot.length + 1 {\n-            match self.undo_log.pop().unwrap() {\n-                OpenSnapshot => {\n-                    // This indicates a failure to obey the stack discipline.\n-                    tcx.sess.bug(\"Cannot rollback an uncommitted snapshot\");\n-                }\n-\n-                CommittedSnapshot => {\n-                    // This occurs when there are nested snapshots and\n-                    // the inner is committed but outer is rolled back.\n-                }\n-\n-                NewVar(i) => {\n-                    assert!(self.values.len() == i);\n-                    self.values.pop();\n-                }\n-\n-                SetVar(i, v) => {\n-                    *self.values.get_mut(i) = v;\n-                }\n-            }\n-        }\n-\n-        let v = self.undo_log.pop().unwrap();\n-        assert!(v == OpenSnapshot);\n-        assert!(self.undo_log.len() == snapshot.length);\n+    pub fn rollback_to(&mut self, snapshot: Snapshot<K>) {\n+        debug!(\"{}: rollback_to()\", UnifyKey::tag(None::<K>));\n+        self.values.rollback_to(snapshot.snapshot);\n     }\n \n     /**\n      * Commits all changes since the last snapshot. Of course, they\n      * can still be undone if there is a snapshot further out.\n      */\n     pub fn commit(&mut self, snapshot: Snapshot<K>) {\n-        debug!(\"{}: commit({})\",\n-               UnifyKey::tag(None::<K>),\n-               snapshot.length);\n-\n-        self.assert_open_snapshot(&snapshot);\n-\n-        if snapshot.length == 0 {\n-            // The root snapshot.\n-            self.undo_log.truncate(0);\n-        } else {\n-            *self.undo_log.get_mut(snapshot.length) = CommittedSnapshot;\n-        }\n+        debug!(\"{}: commit()\", UnifyKey::tag(None::<K>));\n+        self.values.commit(snapshot.snapshot);\n     }\n \n     pub fn new_key(&mut self, value: V) -> K {\n-        let index = self.values.len();\n-\n-        if self.in_snapshot() {\n-            self.undo_log.push(NewVar(index));\n-        }\n-\n-        self.values.push(Root(value, 0));\n+        let index = self.values.push(Root(value, 0));\n         let k = UnifyKey::from_index(index);\n         debug!(\"{}: created new key: {}\",\n                UnifyKey::tag(None::<K>),\n                k);\n         k\n     }\n \n-    fn swap_value(&mut self,\n-                  index: uint,\n-                  new_value: VarValue<K,V>)\n-                  -> VarValue<K,V>\n-    {\n-        /*!\n-         * Primitive operation to swap a value in the var array.\n-         * Caller should update the undo log if we are in a snapshot.\n-         */\n-\n-        let loc = self.values.get_mut(index);\n-        mem::replace(loc, new_value)\n-    }\n-\n     pub fn get(&mut self, tcx: &ty::ctxt, vid: K) -> Node<K,V> {\n         /*!\n          * Find the root node for `vid`. This uses the standard\n@@ -274,15 +170,7 @@ impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n                 let node: Node<K,V> = self.get(tcx, redirect.clone());\n                 if node.key != redirect {\n                     // Path compression\n-                    let old_value =\n-                        self.swap_value(index, Redirect(node.key.clone()));\n-\n-                    // If we are in a snapshot, record this compression,\n-                    // because it's possible that the unification which\n-                    // caused it will be rolled back later.\n-                    if self.in_snapshot() {\n-                        self.undo_log.push(SetVar(index, old_value));\n-                    }\n+                    self.values.set(index, Redirect(node.key.clone()));\n                 }\n                 node\n             }\n@@ -310,15 +198,12 @@ impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n          */\n \n         assert!(self.is_root(&key));\n-        assert!(self.in_snapshot());\n \n         debug!(\"Updating variable {} to {}\",\n                key.repr(tcx),\n                new_value.repr(tcx));\n \n-        let index = key.index();\n-        let old_value = self.swap_value(index, new_value);\n-        self.undo_log.push(SetVar(index, old_value));\n+        self.values.set(key.index(), new_value);\n     }\n \n     pub fn unify(&mut self,\n@@ -359,6 +244,12 @@ impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n     }\n }\n \n+impl<K,V> sv::SnapshotVecDelegate<VarValue<K,V>,()> for Delegate {\n+    fn reverse(&mut self, _: &mut Vec<VarValue<K,V>>, _: ()) {\n+        fail!(\"Nothing to reverse\");\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Code to handle simple keys like ints, floats---anything that\n // doesn't have a subtyping relationship we need to worry about.\n@@ -373,7 +264,8 @@ pub trait SimplyUnifiable : Clone + PartialEq + Repr {\n \n pub fn err<V:SimplyUnifiable>(a_is_expected: bool,\n                               a_t: V,\n-                              b_t: V) -> ures {\n+                              b_t: V)\n+                              -> ures {\n     if a_is_expected {\n         Err(SimplyUnifiable::to_type_err(\n             ty::expected_found {expected: a_t, found: b_t}))"}, {"sha": "60e50c84c61f50926826739b0d032f5d96243180", "filename": "src/librustc/util/snapshot_vec.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/d6e5797e4130c9925734b0a42b4e8d5a1a23073a/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e5797e4130c9925734b0a42b4e8d5a1a23073a/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=d6e5797e4130c9925734b0a42b4e8d5a1a23073a", "patch": "@@ -0,0 +1,195 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * A utility class for implementing \"snapshottable\" things; a\n+ * snapshottable data structure permits you to take a snapshot (via\n+ * `start_snapshot`) and then, after making some changes, elect either\n+ * to rollback to the start of the snapshot or commit those changes.\n+ *\n+ * This vector is intended to be used as part of an abstraction, not\n+ * serve as a complete abstraction on its own. As such, while it will\n+ * roll back most changes on its own, it also supports a `get_mut`\n+ * operation that gives you an abitrary mutable pointer into the\n+ * vector. To ensure that any changes you make this with this pointer\n+ * are rolled back, you must invoke `record` to record any changes you\n+ * make and also supplying a delegate capable of reversing those\n+ * changes.\n+ */\n+\n+use std::kinds::marker;\n+use std::mem;\n+\n+#[deriving(PartialEq)]\n+enum UndoLog<T,U> {\n+    /// Indicates where a snapshot started.\n+    OpenSnapshot,\n+\n+    /// Indicates a snapshot that has been committed.\n+    CommittedSnapshot,\n+\n+    /// New variable with given index was created.\n+    NewElem(uint),\n+\n+    /// Variable with given index was changed *from* the given value.\n+    SetElem(uint, T),\n+\n+    /// Extensible set of actions\n+    Other(U)\n+}\n+\n+pub struct SnapshotVec<T,U,D> {\n+    values: Vec<T>,\n+    undo_log: Vec<UndoLog<T,U>>,\n+    delegate: D\n+}\n+\n+pub struct Snapshot {\n+    // Snapshots are tokens that should be created/consumed linearly.\n+    marker: marker::NoCopy,\n+\n+    // Length of the undo log at the time the snapshot was taken.\n+    length: uint,\n+}\n+\n+pub trait SnapshotVecDelegate<T,U> {\n+    fn reverse(&mut self, values: &mut Vec<T>, action: U);\n+}\n+\n+impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n+    pub fn new(delegate: D) -> SnapshotVec<T,U,D> {\n+        SnapshotVec {\n+            values: Vec::new(),\n+            undo_log: Vec::new(),\n+            delegate: delegate\n+        }\n+    }\n+\n+    fn in_snapshot(&self) -> bool {\n+        !self.undo_log.is_empty()\n+    }\n+\n+    pub fn record(&mut self, action: U) {\n+        if self.in_snapshot() {\n+            self.undo_log.push(Other(action));\n+        }\n+    }\n+\n+    pub fn push(&mut self, elem: T) -> uint {\n+        let len = self.values.len();\n+        self.values.push(elem);\n+\n+        if self.in_snapshot() {\n+            self.undo_log.push(NewElem(len));\n+        }\n+\n+        len\n+    }\n+\n+    pub fn get<'a>(&'a self, index: uint) -> &'a T {\n+        self.values.get(index)\n+    }\n+\n+    pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n+        /*!\n+         * Returns a mutable pointer into the vec; whatever changes\n+         * you make here cannot be undone automatically, so you should\n+         * be sure call `record()` with some sort of suitable undo\n+         * action.\n+         */\n+\n+        self.values.get_mut(index)\n+    }\n+\n+    pub fn set(&mut self, index: uint, new_elem: T) {\n+        /*!\n+         * Updates the element at the given index. The old value will\n+         * saved (and perhaps restored) if a snapshot is active.\n+         */\n+\n+        let old_elem = mem::replace(self.values.get_mut(index), new_elem);\n+        if self.in_snapshot() {\n+            self.undo_log.push(SetElem(index, old_elem));\n+        }\n+    }\n+\n+    pub fn start_snapshot(&mut self) -> Snapshot {\n+        let length = self.undo_log.len();\n+        self.undo_log.push(OpenSnapshot);\n+        Snapshot { length: length,\n+                   marker: marker::NoCopy }\n+    }\n+\n+    fn assert_open_snapshot(&self, snapshot: &Snapshot) {\n+        // Or else there was a failure to follow a stack discipline:\n+        assert!(self.undo_log.len() > snapshot.length);\n+\n+        // Invariant established by start_snapshot():\n+        assert!(\n+            match *self.undo_log.get(snapshot.length) {\n+                OpenSnapshot => true,\n+                _ => false\n+            });\n+    }\n+\n+    pub fn rollback_to(&mut self, snapshot: Snapshot) {\n+        debug!(\"rollback_to({})\", snapshot.length);\n+\n+        self.assert_open_snapshot(&snapshot);\n+\n+        while self.undo_log.len() > snapshot.length + 1 {\n+            match self.undo_log.pop().unwrap() {\n+                OpenSnapshot => {\n+                    // This indicates a failure to obey the stack discipline.\n+                    fail!(\"Cannot rollback an uncommited snapshot\");\n+                }\n+\n+                CommittedSnapshot => {\n+                    // This occurs when there are nested snapshots and\n+                    // the inner is commited but outer is rolled back.\n+                }\n+\n+                NewElem(i) => {\n+                    self.values.pop();\n+                    assert!(self.values.len() == i);\n+                }\n+\n+                SetElem(i, v) => {\n+                    *self.values.get_mut(i) = v;\n+                }\n+\n+                Other(u) => {\n+                    self.delegate.reverse(&mut self.values, u);\n+                }\n+            }\n+        }\n+\n+        let v = self.undo_log.pop().unwrap();\n+        assert!(match v { OpenSnapshot => true, _ => false });\n+        assert!(self.undo_log.len() == snapshot.length);\n+    }\n+\n+    /**\n+     * Commits all changes since the last snapshot. Of course, they\n+     * can still be undone if there is a snapshot further out.\n+     */\n+    pub fn commit(&mut self, snapshot: Snapshot) {\n+        debug!(\"commit({})\", snapshot.length);\n+\n+        self.assert_open_snapshot(&snapshot);\n+\n+        if snapshot.length == 0 {\n+            // The root snapshot.\n+            self.undo_log.truncate(0);\n+        } else {\n+            *self.undo_log.get_mut(snapshot.length) = CommittedSnapshot;\n+        }\n+    }\n+}"}]}