{"sha": "1b51f372eb42de22676ff88fa4d8cc02dab48218", "node_id": "C_kwDOAAsO6NoAKDFiNTFmMzcyZWI0MmRlMjI2NzZmZjg4ZmE0ZDhjYzAyZGFiNDgyMTg", "commit": {"author": {"name": "DebugSteven", "email": "debugsteven@gmail.com", "date": "2022-07-11T15:29:54Z"}, "committer": {"name": "DebugSteven", "email": "debugsteven@gmail.com", "date": "2022-12-13T21:04:30Z"}, "message": "implement minimal epoll_create1 shim", "tree": {"sha": "7cc26ffb30628c75d9edab901f00c8c1109a5976", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cc26ffb30628c75d9edab901f00c8c1109a5976"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b51f372eb42de22676ff88fa4d8cc02dab48218", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b51f372eb42de22676ff88fa4d8cc02dab48218", "html_url": "https://github.com/rust-lang/rust/commit/1b51f372eb42de22676ff88fa4d8cc02dab48218", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b51f372eb42de22676ff88fa4d8cc02dab48218/comments", "author": {"login": "DebugSteven", "id": 10746702, "node_id": "MDQ6VXNlcjEwNzQ2NzAy", "avatar_url": "https://avatars.githubusercontent.com/u/10746702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DebugSteven", "html_url": "https://github.com/DebugSteven", "followers_url": "https://api.github.com/users/DebugSteven/followers", "following_url": "https://api.github.com/users/DebugSteven/following{/other_user}", "gists_url": "https://api.github.com/users/DebugSteven/gists{/gist_id}", "starred_url": "https://api.github.com/users/DebugSteven/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DebugSteven/subscriptions", "organizations_url": "https://api.github.com/users/DebugSteven/orgs", "repos_url": "https://api.github.com/users/DebugSteven/repos", "events_url": "https://api.github.com/users/DebugSteven/events{/privacy}", "received_events_url": "https://api.github.com/users/DebugSteven/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DebugSteven", "id": 10746702, "node_id": "MDQ6VXNlcjEwNzQ2NzAy", "avatar_url": "https://avatars.githubusercontent.com/u/10746702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DebugSteven", "html_url": "https://github.com/DebugSteven", "followers_url": "https://api.github.com/users/DebugSteven/followers", "following_url": "https://api.github.com/users/DebugSteven/following{/other_user}", "gists_url": "https://api.github.com/users/DebugSteven/gists{/gist_id}", "starred_url": "https://api.github.com/users/DebugSteven/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DebugSteven/subscriptions", "organizations_url": "https://api.github.com/users/DebugSteven/orgs", "repos_url": "https://api.github.com/users/DebugSteven/repos", "events_url": "https://api.github.com/users/DebugSteven/events{/privacy}", "received_events_url": "https://api.github.com/users/DebugSteven/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b19af05823a5a78241ffa792621510047a4f572", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b19af05823a5a78241ffa792621510047a4f572", "html_url": "https://github.com/rust-lang/rust/commit/8b19af05823a5a78241ffa792621510047a4f572"}], "stats": {"total": 418, "additions": 377, "deletions": 41}, "files": [{"sha": "97750cb78cdcb9ae19fea8ce13521c081aa3c519", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b51f372eb42de22676ff88fa4d8cc02dab48218/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b51f372eb42de22676ff88fa4d8cc02dab48218/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=1b51f372eb42de22676ff88fa4d8cc02dab48218", "patch": "@@ -27,6 +27,7 @@\n     clippy::single_element_loop,\n     clippy::needless_return,\n     clippy::bool_to_int_with_if,\n+    clippy::box_default,\n     // We are not implementing queries here so it's fine\n     rustc::potential_query_instability\n )]"}, {"sha": "a7a61a1f44c7d315276a80510022636b3edee512", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b51f372eb42de22676ff88fa4d8cc02dab48218/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b51f372eb42de22676ff88fa4d8cc02dab48218/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=1b51f372eb42de22676ff88fa4d8cc02dab48218", "patch": "@@ -31,6 +31,10 @@ use crate::{\n     *,\n };\n \n+/// The number of the available real-time signal with the lowest priority.\n+/// Dummy constant related to epoll, must be between 32 and 64.\n+pub const SIGRTMAX: i32 = 42;\n+\n /// Extra data stored with each stack frame\n pub struct FrameExtra<'tcx> {\n     /// Extra data for Stacked Borrows."}, {"sha": "c46506e20acd3f0b902794faffbcee72cd964774", "filename": "src/tools/miri/src/shims/unix/fs.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1b51f372eb42de22676ff88fa4d8cc02dab48218/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b51f372eb42de22676ff88fa4d8cc02dab48218/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs?ref=1b51f372eb42de22676ff88fa4d8cc02dab48218", "patch": "@@ -17,20 +17,25 @@ use crate::shims::os_str::bytes_to_os_str;\n use crate::*;\n use shims::os_str::os_str_to_bytes;\n use shims::time::system_time_to_duration;\n+use shims::unix::linux::fd::epoll::Epoll;\n \n #[derive(Debug)]\n-struct FileHandle {\n+pub struct FileHandle {\n     file: File,\n     writable: bool,\n }\n \n-trait FileDescriptor: std::fmt::Debug {\n+pub trait FileDescriptor: std::fmt::Debug {\n     fn name(&self) -> &'static str;\n \n     fn as_file_handle<'tcx>(&self) -> InterpResult<'tcx, &FileHandle> {\n         throw_unsup_format!(\"{} cannot be used as FileHandle\", self.name());\n     }\n \n+    fn as_epoll_handle<'tcx>(&mut self) -> InterpResult<'tcx, &mut Epoll> {\n+        throw_unsup_format!(\"not an epoll file descriptor\");\n+    }\n+\n     fn read<'tcx>(\n         &mut self,\n         _communicate_allowed: bool,\n@@ -274,7 +279,7 @@ impl FileDescriptor for NullOutput {\n \n #[derive(Debug)]\n pub struct FileHandler {\n-    handles: BTreeMap<i32, Box<dyn FileDescriptor>>,\n+    pub handles: BTreeMap<i32, Box<dyn FileDescriptor>>,\n }\n \n impl VisitTags for FileHandler {\n@@ -297,7 +302,7 @@ impl FileHandler {\n         FileHandler { handles }\n     }\n \n-    fn insert_fd(&mut self, file_handle: Box<dyn FileDescriptor>) -> i32 {\n+    pub fn insert_fd(&mut self, file_handle: Box<dyn FileDescriptor>) -> i32 {\n         self.insert_fd_with_min_fd(file_handle, 0)\n     }\n \n@@ -376,17 +381,6 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    /// Function used when a handle is not found inside `FileHandler`. It returns `Ok(-1)`and sets\n-    /// the last OS error to `libc::EBADF` (invalid file descriptor). This function uses\n-    /// `T: From<i32>` instead of `i32` directly because some fs functions return different integer\n-    /// types (like `read`, that returns an `i64`).\n-    fn handle_not_found<T: From<i32>>(&mut self) -> InterpResult<'tcx, T> {\n-        let this = self.eval_context_mut();\n-        let ebadf = this.eval_libc(\"EBADF\");\n-        this.set_last_error(ebadf)?;\n-        Ok((-1).into())\n-    }\n-\n     fn file_type_to_d_type(\n         &mut self,\n         file_type: std::io::Result<FileType>,\n@@ -726,6 +720,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         ))\n     }\n \n+    /// Function used when a handle is not found inside `FileHandler`. It returns `Ok(-1)`and sets\n+    /// the last OS error to `libc::EBADF` (invalid file descriptor). This function uses\n+    /// `T: From<i32>` instead of `i32` directly because some fs functions return different integer\n+    /// types (like `read`, that returns an `i64`).\n+    fn handle_not_found<T: From<i32>>(&mut self) -> InterpResult<'tcx, T> {\n+        let this = self.eval_context_mut();\n+        let ebadf = this.eval_libc(\"EBADF\");\n+        this.set_last_error(ebadf)?;\n+        Ok((-1).into())\n+    }\n+\n     fn read(\n         &mut self,\n         fd: i32,"}, {"sha": "212b7936341a709e3808c170b16eac10e4d8257f", "filename": "src/tools/miri/src/shims/unix/linux/fd.rs", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/1b51f372eb42de22676ff88fa4d8cc02dab48218/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b51f372eb42de22676ff88fa4d8cc02dab48218/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd.rs?ref=1b51f372eb42de22676ff88fa4d8cc02dab48218", "patch": "@@ -0,0 +1,191 @@\n+use rustc_middle::ty::ScalarInt;\n+\n+use crate::*;\n+use epoll::{Epoll, EpollEvent};\n+use event::Event;\n+use socketpair::SocketPair;\n+\n+use shims::unix::fs::EvalContextExt as _;\n+\n+pub mod epoll;\n+pub mod event;\n+pub mod socketpair;\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// This function returns a file descriptor referring to the new `Epoll` instance. This file\n+    /// descriptor is used for all subsequent calls to the epoll interface. If the `flags` argument\n+    /// is 0, then this function is the same as `epoll_create()`.\n+    ///\n+    /// <https://linux.die.net/man/2/epoll_create1>\n+    fn epoll_create1(\n+        &mut self,\n+        flags: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+\n+        let flags = this.read_scalar(flags)?.to_i32()?;\n+\n+        let epoll_cloexec = this.eval_libc_i32(\"EPOLL_CLOEXEC\");\n+        if flags == epoll_cloexec {\n+            // Miri does not support exec, so this flag has no effect.\n+        } else if flags != 0 {\n+            throw_unsup_format!(\"epoll_create1 flags {flags} are not implemented\");\n+        }\n+\n+        let fd = this.machine.file_handler.insert_fd(Box::new(Epoll::default()));\n+        Ok(Scalar::from_i32(fd))\n+    }\n+\n+    /// This function performs control operations on the `Epoll` instance referred to by the file\n+    /// descriptor `epfd`. It requests that the operation `op` be performed for the target file\n+    /// descriptor, `fd`.\n+    ///\n+    /// Valid values for the op argument are:\n+    /// `EPOLL_CTL_ADD` - Register the target file descriptor `fd` on the `Epoll` instance referred\n+    /// to by the file descriptor `epfd` and associate the event `event` with the internal file\n+    /// linked to `fd`.\n+    /// `EPOLL_CTL_MOD` - Change the event `event` associated with the target file descriptor `fd`.\n+    /// `EPOLL_CTL_DEL` - Deregister the target file descriptor `fd` from the `Epoll` instance\n+    /// referred to by `epfd`. The `event` is ignored and can be null.\n+    ///\n+    /// <https://linux.die.net/man/2/epoll_ctl>\n+    fn epoll_ctl(\n+        &mut self,\n+        epfd: &OpTy<'tcx, Provenance>,\n+        op: &OpTy<'tcx, Provenance>,\n+        fd: &OpTy<'tcx, Provenance>,\n+        event: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+\n+        let epfd = this.read_scalar(epfd)?.to_i32()?;\n+        let op = this.read_scalar(op)?.to_i32()?;\n+        let fd = this.read_scalar(fd)?.to_i32()?;\n+        let _event = this.read_scalar(event)?.to_pointer(this)?;\n+\n+        let epoll_ctl_add = this.eval_libc_i32(\"EPOLL_CTL_ADD\");\n+        let epoll_ctl_mod = this.eval_libc_i32(\"EPOLL_CTL_MOD\");\n+        let epoll_ctl_del = this.eval_libc_i32(\"EPOLL_CTL_DEL\");\n+\n+        if op == epoll_ctl_add || op == epoll_ctl_mod {\n+            let event = this.deref_operand(event)?;\n+\n+            let events = this.mplace_field(&event, 0)?;\n+            let events = this.read_scalar(&events.into())?.to_u32()?;\n+            let data = this.mplace_field(&event, 1)?;\n+            let data = this.read_scalar(&data.into())?;\n+            let event = EpollEvent { events, data };\n+\n+            if let Some(epfd) = this.machine.file_handler.handles.get_mut(&epfd) {\n+                let epfd = epfd.as_epoll_handle()?;\n+\n+                epfd.file_descriptors.insert(fd, event);\n+                Ok(Scalar::from_i32(0))\n+            } else {\n+                Ok(Scalar::from_i32(this.handle_not_found()?))\n+            }\n+        } else if op == epoll_ctl_del {\n+            if let Some(epfd) = this.machine.file_handler.handles.get_mut(&epfd) {\n+                let epfd = epfd.as_epoll_handle()?;\n+\n+                epfd.file_descriptors.remove(&fd);\n+                Ok(Scalar::from_i32(0))\n+            } else {\n+                Ok(Scalar::from_i32(this.handle_not_found()?))\n+            }\n+        } else {\n+            let einval = this.eval_libc(\"EINVAL\");\n+            this.set_last_error(einval)?;\n+            Ok(Scalar::from_i32(-1))\n+        }\n+    }\n+\n+    /// This function creates an `Event` that is used as an event wait/notify mechanism by\n+    /// user-space applications, and by the kernel to notify user-space applications of events.\n+    /// The `Event` contains an `u64` counter maintained by the kernel. The counter is initialized\n+    /// with the value specified in the `initval` argument.\n+    ///\n+    /// A new file descriptor referring to the `Event` is returned. The `read`, `write`, `poll`,\n+    /// `select`, and `close` operations can be performed on the file descriptor. For more\n+    /// information on these operations, see the man page linked below.\n+    ///\n+    /// The `flags` are not currently implemented for eventfd.\n+    /// The `flags` may be bitwise ORed to change the behavior of `eventfd`:\n+    /// `EFD_CLOEXEC` - Set the close-on-exec (`FD_CLOEXEC`) flag on the new file descriptor.\n+    /// `EFD_NONBLOCK` - Set the `O_NONBLOCK` file status flag on the new open file description.\n+    /// `EFD_SEMAPHORE` - miri does not support semaphore-like semantics.\n+    ///\n+    /// <https://linux.die.net/man/2/eventfd>\n+    fn eventfd(\n+        &mut self,\n+        val: &OpTy<'tcx, Provenance>,\n+        flags: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+\n+        let val = this.read_scalar(val)?.to_u32()?;\n+        let flags = this.read_scalar(flags)?.to_i32()?;\n+\n+        let efd_cloexec = this.eval_libc_i32(\"EFD_CLOEXEC\");\n+        let efd_nonblock = this.eval_libc_i32(\"EFD_NONBLOCK\");\n+        let efd_semaphore = this.eval_libc_i32(\"EFD_SEMAPHORE\");\n+\n+        if flags & (efd_cloexec | efd_nonblock | efd_semaphore) == 0 {\n+            throw_unsup_format!(\"{flags} is unsupported\");\n+        }\n+        // FIXME handle the cloexec and nonblock flags\n+        if flags & efd_cloexec == efd_cloexec {}\n+        if flags & efd_nonblock == efd_nonblock {}\n+        if flags & efd_semaphore == efd_semaphore {\n+            throw_unsup_format!(\"EFD_SEMAPHORE is unsupported\");\n+        }\n+\n+        let fh = &mut this.machine.file_handler;\n+        let fd = fh.insert_fd(Box::new(Event { val }));\n+        Ok(Scalar::from_i32(fd))\n+    }\n+\n+    /// Currently this function creates new `SocketPair`s without specifying the domain, type, or\n+    /// protocol of the new socket and these are stored in the socket values `sv` argument.\n+    ///\n+    /// This function creates an unnamed pair of connected sockets in the specified domain, of the\n+    /// specified type, and using the optionally specified protocol.\n+    ///\n+    /// The `domain` argument specified a communication domain; this selects the protocol family\n+    /// used for communication. The socket `type` specifies the communication semantics.\n+    /// The `protocol` specifies a particular protocol to use with the socket. Normally there's\n+    /// only a single protocol supported for a particular socket type within a given protocol\n+    /// family, in which case `protocol` can be specified as 0. It is possible that many protocols\n+    /// exist and in that case, a particular protocol must be specified.\n+    ///\n+    /// For more information on the arguments see the socket manpage:\n+    /// <https://linux.die.net/man/2/socket>\n+    ///\n+    /// <https://linux.die.net/man/2/socketpair>\n+    fn socketpair(\n+        &mut self,\n+        domain: &OpTy<'tcx, Provenance>,\n+        type_: &OpTy<'tcx, Provenance>,\n+        protocol: &OpTy<'tcx, Provenance>,\n+        sv: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+\n+        let _domain = this.read_scalar(domain)?.to_i32()?;\n+        let _type_ = this.read_scalar(type_)?.to_i32()?;\n+        let _protocol = this.read_scalar(protocol)?.to_i32()?;\n+        let sv = this.deref_operand(sv)?;\n+\n+        let fh = &mut this.machine.file_handler;\n+        let sv0 = fh.insert_fd(Box::new(SocketPair));\n+        let sv0 = ScalarInt::try_from_int(sv0, sv.layout.size).unwrap();\n+        let sv1 = fh.insert_fd(Box::new(SocketPair));\n+        let sv1 = ScalarInt::try_from_int(sv1, sv.layout.size).unwrap();\n+\n+        this.write_scalar(sv0, &sv.into())?;\n+        this.write_scalar(sv1, &sv.offset(sv.layout.size, sv.layout, this)?.into())?;\n+\n+        Ok(Scalar::from_i32(0))\n+    }\n+}"}, {"sha": "eb86773e6b68a0627b4750ef23e825595bd9a877", "filename": "src/tools/miri/src/shims/unix/linux/fd/epoll.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1b51f372eb42de22676ff88fa4d8cc02dab48218/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fepoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b51f372eb42de22676ff88fa4d8cc02dab48218/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fepoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fepoll.rs?ref=1b51f372eb42de22676ff88fa4d8cc02dab48218", "patch": "@@ -0,0 +1,53 @@\n+use crate::*;\n+\n+use crate::shims::unix::fs::FileDescriptor;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use std::io;\n+\n+/// An `Epoll` file descriptor connects file handles and epoll events\n+#[derive(Clone, Debug, Default)]\n+pub struct Epoll {\n+    /// The file descriptors we are watching, and what we are watching for.\n+    pub file_descriptors: FxHashMap<i32, EpollEvent>,\n+}\n+\n+/// Epoll Events associate events with data.\n+/// These fields are currently unused by miri.\n+/// This matches the `epoll_event` struct defined\n+/// by the epoll_ctl man page. For more information\n+/// see the man page:\n+///\n+/// <https://man7.org/linux/man-pages/man2/epoll_ctl.2.html>\n+#[derive(Clone, Debug)]\n+pub struct EpollEvent {\n+    pub events: u32,\n+    /// `Scalar<Provenance>` is used to represent the\n+    /// `epoll_data` type union.\n+    pub data: Scalar<Provenance>,\n+}\n+\n+impl FileDescriptor for Epoll {\n+    fn name(&self) -> &'static str {\n+        \"epoll\"\n+    }\n+\n+    fn as_epoll_handle<'tcx>(&mut self) -> InterpResult<'tcx, &mut Epoll> {\n+        Ok(self)\n+    }\n+\n+    fn dup<'tcx>(&mut self) -> io::Result<Box<dyn FileDescriptor>> {\n+        Ok(Box::new(self.clone()))\n+    }\n+\n+    fn is_tty(&self) -> bool {\n+        false\n+    }\n+\n+    fn close<'tcx>(\n+        self: Box<Self>,\n+        _communicate_allowed: bool,\n+    ) -> InterpResult<'tcx, io::Result<i32>> {\n+        Ok(Ok(0))\n+    }\n+}"}, {"sha": "e87ff56bee3a35f94f9b08b5c3c433ae4951422e", "filename": "src/tools/miri/src/shims/unix/linux/fd/event.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1b51f372eb42de22676ff88fa4d8cc02dab48218/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b51f372eb42de22676ff88fa4d8cc02dab48218/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fevent.rs?ref=1b51f372eb42de22676ff88fa4d8cc02dab48218", "patch": "@@ -0,0 +1,38 @@\n+use crate::shims::unix::fs::FileDescriptor;\n+\n+use rustc_const_eval::interpret::InterpResult;\n+\n+use std::io;\n+\n+/// A kind of file descriptor created by `eventfd`.\n+/// The `Event` type isn't currently written to by `eventfd`.\n+/// The interface is meant to keep track of objects associated\n+/// with a file descriptor. For more information see the man\n+/// page below:\n+///\n+/// <https://man.netbsd.org/eventfd.2>\n+#[derive(Debug)]\n+pub struct Event {\n+    pub val: u32,\n+}\n+\n+impl FileDescriptor for Event {\n+    fn name(&self) -> &'static str {\n+        \"event\"\n+    }\n+\n+    fn dup<'tcx>(&mut self) -> io::Result<Box<dyn FileDescriptor>> {\n+        Ok(Box::new(Event { val: self.val }))\n+    }\n+\n+    fn is_tty(&self) -> bool {\n+        false\n+    }\n+\n+    fn close<'tcx>(\n+        self: Box<Self>,\n+        _communicate_allowed: bool,\n+    ) -> InterpResult<'tcx, io::Result<i32>> {\n+        Ok(Ok(0))\n+    }\n+}"}, {"sha": "036d3a2e31ee519788705a8c9960506b4c9fb014", "filename": "src/tools/miri/src/shims/unix/linux/fd/socketpair.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1b51f372eb42de22676ff88fa4d8cc02dab48218/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fsocketpair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b51f372eb42de22676ff88fa4d8cc02dab48218/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fsocketpair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fsocketpair.rs?ref=1b51f372eb42de22676ff88fa4d8cc02dab48218", "patch": "@@ -0,0 +1,32 @@\n+use crate::*;\n+\n+use crate::shims::unix::fs::FileDescriptor;\n+\n+use std::io;\n+\n+/// Pair of connected sockets.\n+///\n+/// We currently don't allow sending any data through this pair, so this can be just a dummy.\n+#[derive(Debug)]\n+pub struct SocketPair;\n+\n+impl FileDescriptor for SocketPair {\n+    fn name(&self) -> &'static str {\n+        \"socketpair\"\n+    }\n+\n+    fn dup<'tcx>(&mut self) -> io::Result<Box<dyn FileDescriptor>> {\n+        Ok(Box::new(SocketPair))\n+    }\n+\n+    fn is_tty(&self) -> bool {\n+        false\n+    }\n+\n+    fn close<'tcx>(\n+        self: Box<Self>,\n+        _communicate_allowed: bool,\n+    ) -> InterpResult<'tcx, io::Result<i32>> {\n+        Ok(Ok(0))\n+    }\n+}"}, {"sha": "be541deae4041bdaf07b63197091cff7fbc70bbf", "filename": "src/tools/miri/src/shims/unix/linux/foreign_items.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1b51f372eb42de22676ff88fa4d8cc02dab48218/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b51f372eb42de22676ff88fa4d8cc02dab48218/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs?ref=1b51f372eb42de22676ff88fa4d8cc02dab48218", "patch": "@@ -1,9 +1,11 @@\n use rustc_span::Symbol;\n use rustc_target::spec::abi::Abi;\n \n+use crate::machine::SIGRTMAX;\n use crate::*;\n use shims::foreign_items::EmulateByNameResult;\n use shims::unix::fs::EvalContextExt as _;\n+use shims::unix::linux::fd::EvalContextExt as _;\n use shims::unix::linux::sync::futex;\n use shims::unix::sync::EvalContextExt as _;\n use shims::unix::thread::EvalContextExt as _;\n@@ -42,6 +44,35 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let result = this.sync_file_range(fd, offset, nbytes, flags)?;\n                 this.write_scalar(result, dest)?;\n             }\n+            \"epoll_create1\" => {\n+                let [flag] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.epoll_create1(flag)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"epoll_ctl\" => {\n+                let [epfd, op, fd, event] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.epoll_ctl(epfd, op, fd, event)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"eventfd\" => {\n+                let [val, flag] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.eventfd(val, flag)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"socketpair\" => {\n+                let [domain, type_, protocol, sv] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+\n+                let result = this.socketpair(domain, type_, protocol, sv)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"__libc_current_sigrtmax\" => {\n+                let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+\n+                this.write_scalar(Scalar::from_i32(SIGRTMAX), dest)?;\n+            }\n \n             // Threading\n             \"pthread_condattr_setclock\" => {"}, {"sha": "437764c3824eb00d18d880963756149ae908741a", "filename": "src/tools/miri/src/shims/unix/linux/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b51f372eb42de22676ff88fa4d8cc02dab48218/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b51f372eb42de22676ff88fa4d8cc02dab48218/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fmod.rs?ref=1b51f372eb42de22676ff88fa4d8cc02dab48218", "patch": "@@ -1,3 +1,4 @@\n pub mod dlsym;\n+pub mod fd;\n pub mod foreign_items;\n pub mod sync;"}, {"sha": "7cb42c09a9677015c6dfab3772fdd0404dcfd1ca", "filename": "src/tools/miri/tests/fail/crates/tokio_mvp.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.rs?ref=8b19af05823a5a78241ffa792621510047a4f572", "patch": "@@ -1,7 +0,0 @@\n-//@compile-flags: -Zmiri-disable-isolation\n-//@error-pattern: can't call foreign function: epoll_create1\n-//@normalize-stderr-test: \"   = note: inside .*\\n\" -> \"\"\n-//@only-target-linux: the errors differ too much between platforms\n-\n-#[tokio::main]\n-async fn main() {}"}, {"sha": "1e7dfaa7499041851561a4da9b354f1b33b6dd95", "filename": "src/tools/miri/tests/fail/crates/tokio_mvp.stderr", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8b19af05823a5a78241ffa792621510047a4f572/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.stderr?ref=8b19af05823a5a78241ffa792621510047a4f572", "patch": "@@ -1,19 +0,0 @@\n-error: unsupported operation: can't call foreign function: epoll_create1\n-  --> CARGO_REGISTRY/.../epoll.rs:LL:CC\n-   |\n-LL |         let res = syscall!(epoll_create1(libc::EPOLL_CLOEXEC));\n-   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't call foreign function: epoll_create1\n-   |\n-   = help: this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\n-   = note: BACKTRACE:\n-note: inside `main`\n-  --> $DIR/tokio_mvp.rs:LL:CC\n-   |\n-LL | #[tokio::main]\n-   | ^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `syscall` which comes from the expansion of the attribute macro `tokio::main` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n-\n-error: aborting due to previous error\n-"}, {"sha": "642168253c2fa54e3263e50a648dcb7c615ad912", "filename": "src/tools/miri/tests/pass-dep/tokio_mvp.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b51f372eb42de22676ff88fa4d8cc02dab48218/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Ftokio_mvp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b51f372eb42de22676ff88fa4d8cc02dab48218/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Ftokio_mvp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Ftokio_mvp.rs?ref=1b51f372eb42de22676ff88fa4d8cc02dab48218", "patch": "@@ -0,0 +1,6 @@\n+// Need to disable preemption to stay on the supported MVP codepath in mio.\n+//@compile-flags: -Zmiri-disable-isolation -Zmiri-permissive-provenance -Zmiri-preemption-rate=0\n+//@only-target-x86_64-unknown-linux: support for tokio exists only on linux and x86\n+\n+#[tokio::main]\n+async fn main() {}"}]}