{"sha": "1e9172d70cf714dc006c1cbc4a029ae6e848d35b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlOTE3MmQ3MGNmNzE0ZGMwMDZjMWNiYzRhMDI5YWU2ZTg0OGQzNWI=", "commit": {"author": {"name": "Simon Vandel Sillesen", "email": "simon.vandel@gmail.com", "date": "2020-05-16T19:56:08Z"}, "committer": {"name": "Simon Vandel Sillesen", "email": "simon.vandel@gmail.com", "date": "2020-05-16T20:20:44Z"}, "message": "Reuse Vec allocations", "tree": {"sha": "834325b9f11cd4a9f546d0eeb215c77d4f0141d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/834325b9f11cd4a9f546d0eeb215c77d4f0141d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e9172d70cf714dc006c1cbc4a029ae6e848d35b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e9172d70cf714dc006c1cbc4a029ae6e848d35b", "html_url": "https://github.com/rust-lang/rust/commit/1e9172d70cf714dc006c1cbc4a029ae6e848d35b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e9172d70cf714dc006c1cbc4a029ae6e848d35b/comments", "author": {"login": "simonvandel", "id": 2770647, "node_id": "MDQ6VXNlcjI3NzA2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/2770647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/simonvandel", "html_url": "https://github.com/simonvandel", "followers_url": "https://api.github.com/users/simonvandel/followers", "following_url": "https://api.github.com/users/simonvandel/following{/other_user}", "gists_url": "https://api.github.com/users/simonvandel/gists{/gist_id}", "starred_url": "https://api.github.com/users/simonvandel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/simonvandel/subscriptions", "organizations_url": "https://api.github.com/users/simonvandel/orgs", "repos_url": "https://api.github.com/users/simonvandel/repos", "events_url": "https://api.github.com/users/simonvandel/events{/privacy}", "received_events_url": "https://api.github.com/users/simonvandel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "simonvandel", "id": 2770647, "node_id": "MDQ6VXNlcjI3NzA2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/2770647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/simonvandel", "html_url": "https://github.com/simonvandel", "followers_url": "https://api.github.com/users/simonvandel/followers", "following_url": "https://api.github.com/users/simonvandel/following{/other_user}", "gists_url": "https://api.github.com/users/simonvandel/gists{/gist_id}", "starred_url": "https://api.github.com/users/simonvandel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/simonvandel/subscriptions", "organizations_url": "https://api.github.com/users/simonvandel/orgs", "repos_url": "https://api.github.com/users/simonvandel/repos", "events_url": "https://api.github.com/users/simonvandel/events{/privacy}", "received_events_url": "https://api.github.com/users/simonvandel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b606399095cc5357a93f40fb0d695eab8530bc98", "url": "https://api.github.com/repos/rust-lang/rust/commits/b606399095cc5357a93f40fb0d695eab8530bc98", "html_url": "https://github.com/rust-lang/rust/commit/b606399095cc5357a93f40fb0d695eab8530bc98"}], "stats": {"total": 33, "additions": 21, "deletions": 12}, "files": [{"sha": "7c9bb4d00e1a2f5f4d036eaa53393c8a5b77a7a9", "filename": "crates/ra_mbe/src/mbe_expander/transcriber.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1e9172d70cf714dc006c1cbc4a029ae6e848d35b/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9172d70cf714dc006c1cbc4a029ae6e848d35b/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs?ref=1e9172d70cf714dc006c1cbc4a029ae6e848d35b", "patch": "@@ -1,4 +1,4 @@\n-//! Transcraber takes a template, like `fn $ident() {}`, a set of bindings like\n+//! Transcriber takes a template, like `fn $ident() {}`, a set of bindings like\n //! `$ident => foo`, interpolates variables in the template, to get `fn foo() {}`\n \n use ra_syntax::SmolStr;\n@@ -53,7 +53,8 @@ impl Bindings {\n pub(super) fn transcribe(template: &tt::Subtree, bindings: &Bindings) -> ExpandResult<tt::Subtree> {\n     assert!(template.delimiter == None);\n     let mut ctx = ExpandCtx { bindings: &bindings, nesting: Vec::new() };\n-    expand_subtree(&mut ctx, template)\n+    let mut arena: Vec<tt::TokenTree> = Vec::new();\n+    expand_subtree(&mut ctx, template, &mut arena)\n }\n \n #[derive(Debug)]\n@@ -73,8 +74,13 @@ struct ExpandCtx<'a> {\n     nesting: Vec<NestingState>,\n }\n \n-fn expand_subtree(ctx: &mut ExpandCtx, template: &tt::Subtree) -> ExpandResult<tt::Subtree> {\n-    let mut buf: Vec<tt::TokenTree> = Vec::new();\n+fn expand_subtree(\n+    ctx: &mut ExpandCtx,\n+    template: &tt::Subtree,\n+    arena: &mut Vec<tt::TokenTree>,\n+) -> ExpandResult<tt::Subtree> {\n+    // remember how many elements are in the arena now - when returning, we want to drain exactly how many elements we added. This way, the recursive uses of the arena get their own \"view\" of the arena, but will reuse the allocation\n+    let start_elements = arena.len();\n     let mut err = None;\n     for op in parse_template(template) {\n         let op = match op {\n@@ -85,25 +91,27 @@ fn expand_subtree(ctx: &mut ExpandCtx, template: &tt::Subtree) -> ExpandResult<t\n             }\n         };\n         match op {\n-            Op::TokenTree(tt @ tt::TokenTree::Leaf(..)) => buf.push(tt.clone()),\n+            Op::TokenTree(tt @ tt::TokenTree::Leaf(..)) => arena.push(tt.clone()),\n             Op::TokenTree(tt::TokenTree::Subtree(tt)) => {\n-                let ExpandResult(tt, e) = expand_subtree(ctx, tt);\n+                let ExpandResult(tt, e) = expand_subtree(ctx, tt, arena);\n                 err = err.or(e);\n-                buf.push(tt.into());\n+                arena.push(tt.into());\n             }\n             Op::Var { name, kind: _ } => {\n                 let ExpandResult(fragment, e) = expand_var(ctx, name);\n                 err = err.or(e);\n-                push_fragment(&mut buf, fragment);\n+                push_fragment(arena, fragment);\n             }\n             Op::Repeat { subtree, kind, separator } => {\n-                let ExpandResult(fragment, e) = expand_repeat(ctx, subtree, kind, separator);\n+                let ExpandResult(fragment, e) = expand_repeat(ctx, subtree, kind, separator, arena);\n                 err = err.or(e);\n-                push_fragment(&mut buf, fragment)\n+                push_fragment(arena, fragment)\n             }\n         }\n     }\n-    ExpandResult(tt::Subtree { delimiter: template.delimiter, token_trees: buf }, err)\n+    // drain the elements added in this instance of expand_subtree\n+    let tts = arena.drain(start_elements..arena.len()).collect();\n+    ExpandResult(tt::Subtree { delimiter: template.delimiter, token_trees: tts }, err)\n }\n \n fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr) -> ExpandResult<Fragment> {\n@@ -155,6 +163,7 @@ fn expand_repeat(\n     template: &tt::Subtree,\n     kind: RepeatKind,\n     separator: Option<Separator>,\n+    arena: &mut Vec<tt::TokenTree>,\n ) -> ExpandResult<Fragment> {\n     let mut buf: Vec<tt::TokenTree> = Vec::new();\n     ctx.nesting.push(NestingState { idx: 0, at_end: false, hit: false });\n@@ -165,7 +174,7 @@ fn expand_repeat(\n     let mut counter = 0;\n \n     loop {\n-        let ExpandResult(mut t, e) = expand_subtree(ctx, template);\n+        let ExpandResult(mut t, e) = expand_subtree(ctx, template, arena);\n         let nesting_state = ctx.nesting.last_mut().unwrap();\n         if nesting_state.at_end || !nesting_state.hit {\n             break;"}]}