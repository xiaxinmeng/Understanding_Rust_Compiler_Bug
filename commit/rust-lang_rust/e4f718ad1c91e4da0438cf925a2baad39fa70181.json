{"sha": "e4f718ad1c91e4da0438cf925a2baad39fa70181", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ZjcxOGFkMWM5MWU0ZGEwNDM4Y2Y5MjVhMmJhYWQzOWZhNzAxODE=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-01T20:37:17Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-01T20:37:17Z"}, "message": "uninit cleanup", "tree": {"sha": "a841e82a251e977ad33099a709b974b6861f16ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a841e82a251e977ad33099a709b974b6861f16ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4f718ad1c91e4da0438cf925a2baad39fa70181", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4f718ad1c91e4da0438cf925a2baad39fa70181", "html_url": "https://github.com/rust-lang/rust/commit/e4f718ad1c91e4da0438cf925a2baad39fa70181", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4f718ad1c91e4da0438cf925a2baad39fa70181/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccb08a52fee9756f39696253e1cd1d1b3b55fc85", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccb08a52fee9756f39696253e1cd1d1b3b55fc85", "html_url": "https://github.com/rust-lang/rust/commit/ccb08a52fee9756f39696253e1cd1d1b3b55fc85"}], "stats": {"total": 55, "additions": 27, "deletions": 28}, "files": [{"sha": "983c320c7382c1bff93071c79c0e149a708460d5", "filename": "uninitialized.md", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e4f718ad1c91e4da0438cf925a2baad39fa70181/uninitialized.md", "raw_url": "https://github.com/rust-lang/rust/raw/e4f718ad1c91e4da0438cf925a2baad39fa70181/uninitialized.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/uninitialized.md?ref=e4f718ad1c91e4da0438cf925a2baad39fa70181", "patch": "@@ -6,7 +6,7 @@ of bits that may or may not even reflect a valid state for the type that is\n supposed to inhabit that location of memory. Attempting to interpret this memory\n as a value of *any* type will cause Undefined Behaviour. Do Not Do This.\n \n-Like C, all stack variables in Rust begin their life as uninitialized until a\n+Like C, all stack variables in Rust are uninitialized until a\n value is explicitly assigned to them. Unlike C, Rust statically prevents you\n from ever reading them until you do:\n \n@@ -32,17 +32,14 @@ or anything like that. So this compiles:\n ```rust\n fn main() {\n \tlet x: i32;\n-\tlet y: i32;\n-\n-\ty = 1;\n \n \tif true {\n \t\tx = 1;\n \t} else {\n \t\tx = 2;\n \t}\n \n-    println!(\"{} {}\", x, y);\n+    println!(\"{}\", x);\n }\n ```\n \n@@ -98,13 +95,13 @@ to call the destructor of a variable that is conditionally initialized? It turns\n out that Rust actually tracks whether a type should be dropped or not *at\n runtime*. As a variable becomes initialized and uninitialized, a *drop flag* for\n that variable is set and unset. When a variable goes out of scope or is assigned\n-it evaluates whether the current value of the variable should be dropped. Of\n-course, static analysis can remove these checks. If the compiler can prove that\n+a value, it evaluates whether the current value of the variable should be dropped.\n+Of course, static analysis can remove these checks. If the compiler can prove that\n a value is guaranteed to be either initialized or not, then it can theoretically\n generate more efficient code! As such it may be desirable to structure code to\n have *static drop semantics* when possible.\n \n-As of Rust 1.0, the drop flags are actually not-so-secretly stashed in a secret\n+As of Rust 1.0, the drop flags are actually not-so-secretly stashed in a hidden\n field of any type that implements Drop. The language sets the drop flag by\n overwriting the entire struct with a particular value. This is pretty obviously\n Not The Fastest and causes a bunch of trouble with optimizing code. As such work\n@@ -115,7 +112,7 @@ requires fairly substantial changes to the compiler.\n So in general, Rust programs don't need to worry about uninitialized values on\n the stack for correctness. Although they might care for performance. Thankfully,\n Rust makes it easy to take control here! Uninitialized values are there, and\n-Safe Rust lets you work with them, but you're never in trouble.\n+Safe Rust lets you work with them, but you're never in danger.\n \n One interesting exception to this rule is working with arrays. Safe Rust doesn't\n permit you to partially initialize an array. When you initialize an array, you\n@@ -125,23 +122,23 @@ Unfortunately this is pretty rigid, especially if you need to initialize your\n array in a more incremental or dynamic way.\n \n Unsafe Rust gives us a powerful tool to handle this problem:\n-`std::mem::uninitialized`. This function pretends to return a value when really\n+`mem::uninitialized`. This function pretends to return a value when really\n it does nothing at all. Using it, we can convince Rust that we have initialized\n a variable, allowing us to do trickier things with conditional and incremental\n initialization.\n \n-Unfortunately, this raises a tricky problem. Assignment has a different meaning\n-to Rust based on whether it believes that a variable is initialized or not. If\n-it's uninitialized, then Rust will semantically just memcopy the bits over the\n-uninit ones, and do nothing else. However if Rust believes a value to be\n-initialized, it will try to `Drop` the old value! Since we've tricked Rust into\n-believing that the value is initialized, we can no longer safely use normal\n-assignment.\n+Unfortunately, this opens us up to all kinds of problems. Assignment has a\n+different meaning to Rust based on whether it believes that a variable is\n+initialized or not. If it's uninitialized, then Rust will semantically just\n+memcopy the bits over the uninitialized ones, and do nothing else. However if Rust\n+believes a value to be initialized, it will try to `Drop` the old value!\n+Since we've tricked Rust into believing that the value is initialized, we\n+can no longer safely use normal assignment.\n \n-This is also a problem if you're working with a raw system allocator, which of\n-course returns a pointer to uninitialized memory.\n+This is also a problem if you're working with a raw system allocator, which\n+returns a pointer to uninitialized memory.\n \n-To handle this, we must use the `std::ptr` module. In particular, it provides\n+To handle this, we must use the `ptr` module. In particular, it provides\n three functions that allow us to assign bytes to a location in memory without\n evaluating the old value: `write`, `copy`, and `copy_nonoverlapping`.\n \n@@ -157,7 +154,7 @@ evaluating the old value: `write`, `copy`, and `copy_nonoverlapping`.\n It should go without saying that these functions, if misused, will cause serious\n havoc or just straight up Undefined Behaviour. The only things that these\n functions *themselves* require is that the locations you want to read and write\n-are allocated. However the ways writing arbitrary bit patterns to arbitrary\n+are allocated. However the ways writing arbitrary bits to arbitrary\n locations of memory can break things are basically uncountable!\n \n Putting this all together, we get the following:\n@@ -177,6 +174,7 @@ fn main() {\n \t\tx = mem::uninitialized();\n \t\tfor i in 0..SIZE {\n \t\t\t// very carefully overwrite each index without reading it\n+\t\t\t// NOTE: exception safety is not a concern; Box can't panic\n \t\t\tptr::write(&mut x[i], Box::new(i));\n \t\t}\n \t}\n@@ -186,15 +184,16 @@ fn main() {\n ```\n \n It's worth noting that you don't need to worry about ptr::write-style\n-shenanigans with Plain Old Data (POD; types which don't implement Drop, nor\n-contain Drop types), because Rust knows not to try to Drop them. Similarly you\n-should be able to assign the POD fields of partially initialized structs\n-directly.\n+shenanigans with types which don't implement Drop or\n+contain Drop types, because Rust knows not to try to Drop them. Similarly you\n+should be able to assign to fields of partially initialized structs\n+directly if those fields don't contain any Drop types.\n \n-However when working with uninitialized memory you need to be ever vigilant for\n+However when working with uninitialized memory you need to be ever-vigilant for\n Rust trying to Drop values you make like this before they're fully initialized.\n-So every control path through that variable's scope must initialize the value\n-before it ends. *This includes code panicking*. Again, POD types need not worry.\n+Every control path through that variable's scope must initialize the value\n+before it ends, if has a destructor.\n+*[This includes code panicking](unwinding.html)*.\n \n And that's about it for working with uninitialized memory! Basically nothing\n anywhere expects to be handed uninitialized memory, so if you're going to pass"}]}