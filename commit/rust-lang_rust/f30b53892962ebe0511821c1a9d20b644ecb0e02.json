{"sha": "f30b53892962ebe0511821c1a9d20b644ecb0e02", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMGI1Mzg5Mjk2MmViZTA1MTE4MjFjMWE5ZDIwYjY0NGVjYjBlMDI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-28T13:33:31Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-29T00:22:15Z"}, "message": "Update documentation for moves", "tree": {"sha": "346b6c0434c750de9d8b1ca00e83b6d6f19349c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/346b6c0434c750de9d8b1ca00e83b6d6f19349c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f30b53892962ebe0511821c1a9d20b644ecb0e02", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f30b53892962ebe0511821c1a9d20b644ecb0e02", "html_url": "https://github.com/rust-lang/rust/commit/f30b53892962ebe0511821c1a9d20b644ecb0e02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f30b53892962ebe0511821c1a9d20b644ecb0e02/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e35db1ab35caf9318080ef293135546af5661172", "url": "https://api.github.com/repos/rust-lang/rust/commits/e35db1ab35caf9318080ef293135546af5661172", "html_url": "https://github.com/rust-lang/rust/commit/e35db1ab35caf9318080ef293135546af5661172"}], "stats": {"total": 394, "additions": 270, "deletions": 124}, "files": [{"sha": "cb3983117e97c496c7817705df6916e8d440982a", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 222, "deletions": 35, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/f30b53892962ebe0511821c1a9d20b644ecb0e02/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30b53892962ebe0511821c1a9d20b644ecb0e02/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=f30b53892962ebe0511821c1a9d20b644ecb0e02", "patch": "@@ -19,15 +19,27 @@ how it works, and then proceed to dive into the theoretical\n background. Finally, they go into detail on some of the more subtle\n aspects.\n \n+# Table of contents\n+\n+These docs are long. Search for the section you are interested in.\n+\n+- Overview\n+- Formal model\n+- Borrowing and loans\n+- Moves and initialization\n+- Future work\n+\n # Overview\n \n The borrow checker checks one function at a time. It operates in two\n passes. The first pass, called `gather_loans`, walks over the function\n-and identifies all of the places where borrows occur (e.g., `&`\n-expressions and `ref` bindings). For each borrow, we check various\n-basic safety conditions at this time (for example, that the lifetime\n-of the borrow doesn't exceed the lifetime of the value being\n-borrowed).\n+and identifies all of the places where borrows (e.g., `&` expressions\n+and `ref` bindings) and moves (copies or captures of a linear value)\n+occur. It also tracks initialization sites. For each borrow and move,\n+it checks various basic safety conditions at this time (for example,\n+that the lifetime of the borrow doesn't exceed the lifetime of the\n+value being borrowed, or that there is no move out of an `&T`\n+pointee).\n \n It then uses the dataflow module to propagate which of those borrows\n may be in scope at each point in the procedure. A loan is considered\n@@ -41,8 +53,8 @@ it is safe with respect to the in-scope loans.\n \n # Formal model\n \n-Let's consider a simple subset of Rust in which you can only borrow\n-from lvalues like so:\n+Throughout the docs we'll consider a simple subset of Rust in which\n+you can only borrow from lvalues, defined like so:\n \n     LV = x | LV.f | *LV\n \n@@ -65,9 +77,11 @@ struct name and we assume structs are declared like so:\n \n     SD = struct S<'LT...> { (f: TY)... }\n \n-# An intuitive explanation\n+# Borrowing and loans\n \n-## Issuing loans\n+## An intuitive explanation\n+\n+### Issuing loans\n \n Now, imagine we had a program like this:\n \n@@ -83,7 +97,7 @@ This is of course dangerous because mutating `x` will free the old\n value and hence invalidate `y`. The borrow checker aims to prevent\n this sort of thing.\n \n-### Loans and restrictions\n+#### Loans and restrictions\n \n The way the borrow checker works is that it analyzes each borrow\n expression (in our simple model, that's stuff like `&LV`, though in\n@@ -120,7 +134,7 @@ prevents moves from `LV`. I chose not to make `MOVE` a fourth kind of\n action because that would imply that sometimes moves are permitted\n from restrictived values, which is not the case.\n \n-### Example\n+#### Example\n \n To give you a better feeling for what kind of restrictions derived\n from a loan, let's look at the loan `L` that would be issued as a\n@@ -159,7 +173,7 @@ because `x` is an owned pointer, the path `x` owns the path `*x`.\n Therefore, borrowing `(*x).f` yields restrictions on both\n `*x` and `x`.\n \n-## Checking for illegal assignments, moves, and reborrows\n+### Checking for illegal assignments, moves, and reborrows\n \n Once we have computed the loans introduced by each borrow, the borrow\n checker uses a data flow propagation to compute the full set of loans\n@@ -181,7 +195,7 @@ The kinds of expressions which in-scope loans can render illegal are:\n - *read-only borrows* (`&const lv`): illegal there is an in-scope restriction\n   against aliasing `lv`.\n \n-# Formal rules\n+## Formal rules\n \n Now that we hopefully have some kind of intuitive feeling for how the\n borrow checker works, let's look a bit more closely now at the precise\n@@ -202,7 +216,7 @@ of this rule: there are comments in the borrowck source referencing\n these names, so that you can cross reference to find the actual code\n that corresponds to the formal rule.\n \n-## The `gather_loans` pass\n+### The `gather_loans` pass\n \n We start with the `gather_loans` pass, which walks the AST looking for\n borrows.  For each borrow, there are three bits of information: the\n@@ -223,7 +237,7 @@ alive and for dynamically freezing `@mut` boxes.\n restrictions to maintain memory safety. These are the restrictions\n that will go into the final loan. We'll discuss in more detail below.\n \n-# Checking mutability\n+## Checking mutability\n \n Checking mutability is fairly straightforward. We just want to prevent\n immutable data from being borrowed as mutable. Note that it is ok to\n@@ -233,7 +247,7 @@ defined, means that \"borrowing `LV` with mutability `MQ` is ok. The\n Rust code corresponding to this predicate is the function\n `check_mutability` in `middle::borrowck::gather_loans`.\n \n-## Checking mutability of variables\n+### Checking mutability of variables\n \n *Code pointer:* Function `check_mutability()` in `gather_loans/mod.rs`,\n but also the code in `mem_categorization`.\n@@ -249,7 +263,7 @@ otherwise the variable must be borrowed as immutable or const:\n       DECL(X) = imm\n       MQ = imm | const\n \n-## Checking mutability of owned content\n+### Checking mutability of owned content\n \n Fields and owned pointers inherit their mutability from\n their base expressions, so both of their rules basically\n@@ -262,7 +276,7 @@ delegate the check to the base expression `LV`:\n       TYPE(LV) = ~Ty\n       MUTABILITY(LV, MQ)\n \n-## Checking mutability of immutable pointer types\n+### Checking mutability of immutable pointer types\n \n Immutable pointer types like `&T` and `@T` can only\n be borrowed if MQ is immutable or const:\n@@ -275,7 +289,7 @@ be borrowed if MQ is immutable or const:\n       TYPE(LV) = @Ty\n       MQ == imm | const\n \n-## Checking mutability of mutable pointer types\n+### Checking mutability of mutable pointer types\n \n `&mut T` and `@mut T` can be frozen, so it is acceptable to borrow\n them as either imm or mut:\n@@ -286,7 +300,7 @@ them as either imm or mut:\n     MUTABILITY(*LV, MQ)                 // M-Deref-Managed-Mut\n       TYPE(LV) = @mut Ty\n \n-# Checking lifetime\n+## Checking lifetime\n \n These rules aim to ensure that no data is borrowed for a scope that\n exceeds its lifetime. In addition, these rules manage the rooting and\n@@ -297,7 +311,7 @@ safely borrowed for the lifetime `LT` with mutability `MQ`\". The Rust\n code corresponding to this predicate is the module\n `middle::borrowck::gather_loans::lifetime`.\n \n-## The Scope function\n+### The Scope function\n \n Several of the rules refer to a helper function `SCOPE(LV)=LT`.  The\n `SCOPE(LV)` yields the lifetime `LT` for which the lvalue `LV` is\n@@ -329,15 +343,15 @@ the pointer points at may actually live longer:\n \n       SCOPE(*LV) = LT if LV has type &'LT T or &'LT mut T\n \n-## Checking lifetime of variables\n+### Checking lifetime of variables\n \n The rule for variables states that a variable can only be borrowed a\n lifetime `LT` that is a subregion of the variable's scope:\n \n     LIFETIME(X, LT, MQ)                 // L-Local\n       LT <= SCOPE(X)\n \n-## Checking lifetime for owned content\n+### Checking lifetime for owned content\n \n The lifetime of a field or owned pointer is the same as the lifetime\n of its owner:\n@@ -349,7 +363,7 @@ of its owner:\n       TYPE(LV) = ~Ty\n       LIFETIME(LV, LT, MQ)\n \n-## Checking lifetime for derefs of borrowed pointers\n+### Checking lifetime for derefs of borrowed pointers\n \n Borrowed pointers have a lifetime `LT'` associated with them.  The\n data they point at has been guaranteed to be valid for at least this\n@@ -361,7 +375,7 @@ itself:\n       TYPE(LV) = &LT' Ty OR &LT' mut Ty\n       LT <= LT'\n \n-## Checking lifetime for derefs of managed, immutable pointers\n+### Checking lifetime for derefs of managed, immutable pointers\n \n Managed pointers are valid so long as the data within them is\n *rooted*. There are two ways that this can be achieved. The first is\n@@ -410,7 +424,7 @@ makes a note in a side-table that the box `LV` must be rooted into the\n stack when `*LV` is evaluated, and that this root can be released when\n the scope `LT` exits.\n \n-## Checking lifetime for derefs of managed, mutable pointers\n+### Checking lifetime for derefs of managed, mutable pointers\n \n Loans of the contents of mutable managed pointers are simpler in some\n ways that loans of immutable managed pointers, because we can never\n@@ -433,7 +447,7 @@ borrowed and either the old loan or the new loan is a mutable loan\n (multiple immutable loans are okay). The lock is released as we exit\n the scope `LT`.\n \n-# Computing the restrictions\n+## Computing the restrictions\n \n The final rules govern the computation of *restrictions*, meaning that\n we compute the set of actions that will be illegal for the life of the\n@@ -456,15 +470,15 @@ permits other immutable borows but forbids writes and mutable borows.\n Finally, a const borrow just wants to be sure that the value is not\n moved out from under it, so no actions are forbidden.\n \n-## Restrictions for loans of a local variable\n+### Restrictions for loans of a local variable\n \n The simplest case is a borrow of a local variable `X`:\n \n     RESTRICTIONS(X, ACTIONS) = (X, ACTIONS)            // R-Variable\n \n In such cases we just record the actions that are not permitted.\n \n-## Restrictions for loans of fields\n+### Restrictions for loans of fields\n \n Restricting a field is the same as restricting the owner of that\n field:\n@@ -479,7 +493,7 @@ frozen or aliased, we cannot allow the owner to be frozen or aliased,\n since doing so indirectly freezes/aliases the field. This is the\n origin of inherited mutability.\n \n-## Restrictions for loans of owned pointees\n+### Restrictions for loans of owned pointees\n \n Because the mutability of owned pointees is inherited, restricting an\n owned pointee is similar to restricting a field, in that it implies\n@@ -494,7 +508,7 @@ on `LV`:\n       TYPE(LV) = ~Ty\n       RESTRICTIONS(LV, ACTIONS|MUTATE|CLAIM) = RS\n \n-## Restrictions for loans of immutable managed/borrowed pointees\n+### Restrictions for loans of immutable managed/borrowed pointees\n \n Immutable managed/borrowed pointees are freely aliasable, meaning that\n the compiler does not prevent you from copying the pointer.  This\n@@ -523,7 +537,7 @@ report an error because we cannot enforce a lack of aliases on a `&Ty`\n or `@Ty` type. That case is described in more detail in the section on\n mutable borrowed pointers.\n \n-## Restrictions for loans of const aliasable pointees\n+### Restrictions for loans of const aliasable pointees\n \n Const pointers are read-only. There may be `&mut` or `&` aliases, and\n we can not prevent *anything* but moves in that case. So the\n@@ -535,7 +549,7 @@ result.\n     RESTRICTIONS(*LV, []) = []                         // R-Deref-Const-Borrowed\n       TYPE(LV) = &const Ty or @const Ty\n \n-## Restrictions for loans of mutable borrowed pointees\n+### Restrictions for loans of mutable borrowed pointees\n \n Borrowing mutable borrowed pointees is a bit subtle because we permit\n users to freeze or claim `&mut` pointees. To see what I mean, consider this\n@@ -645,7 +659,7 @@ any restrictions (beyond the default of \"no move\"):\n Moving from an `&mut` pointee is never legal, so no special\n restrictions are needed.\n \n-## Restrictions for loans of mutable managed pointees\n+### Restrictions for loans of mutable managed pointees\n \n With `@mut` pointees, we don't make any static guarantees.  But as a\n convenience, we still register a restriction against `*LV`, because\n@@ -654,7 +668,159 @@ that way if we *can* find a simple static error, we will:\n     RESTRICTIONS(*LV, ACTIONS) = [*LV, ACTIONS]   // R-Deref-Managed-Borrowed\n       TYPE(LV) = @mut Ty\n \n-# Some notes for future work\n+# Moves and initialization\n+\n+The borrow checker is also in charge of ensuring that:\n+\n+- all memory which is accessed is initialized\n+- immutable local variables are assigned at most once.\n+\n+These are two separate dataflow analyses built on the same\n+framework. Let's look at checking that memory is initialized first;\n+the checking of immutable local variabe assignments works in a very\n+similar way.\n+\n+To track the initialization of memory, we actually track all the\n+points in the program that *create uninitialized memory*, meaning\n+moves and the declaration of uninitialized variables. For each of\n+these points, we create a bit in the dataflow set. Assignments to a\n+variable `x` or path `a.b.c` kill the move/uninitialization bits for\n+those paths and any subpaths (e.g., `x`, `x.y`, `a.b.c`, `*a.b.c`).\n+The bits are also killed when the root variables (`x`, `a`) go out of\n+scope. Bits are unioned when two control-flow paths join. Thus, the\n+presence of a bit indicates that the move may have occurred without an\n+intervening assignment to the same memory. At each use of a variable,\n+we examine the bits in scope, and check that none of them are\n+moves/uninitializations of the variable that is being used.\n+\n+Let's look at a simple example:\n+\n+    fn foo(a: ~int) {\n+        let b: ~int;       // Gen bit 0.\n+\n+        if cond {          // Bits: 0\n+            use(&*a);\n+            b = a;         // Gen bit 1, kill bit 0.\n+            use(&*b);\n+        } else {\n+                           // Bits: 0\n+        }\n+                           // Bits: 0,1\n+        use(&*a);          // Error.\n+        use(&*b);          // Error.\n+    }\n+\n+    fn use(a: &int) { }\n+\n+In this example, the variable `b` is created uninitialized. In one\n+branch of an `if`, we then move the variable `a` into `b`. Once we\n+exit the `if`, therefore, it is an error to use `a` or `b` since both\n+are only conditionally initialized. I have annotated the dataflow\n+state using comments. There are two dataflow bits, with bit 0\n+corresponding to the creation of `b` without an initializer, and bit 1\n+corresponding to the move of `a`. The assignment `b = a` both\n+generates bit 1, because it is a move of `a`, and kills bit 0, because\n+`b` is now initialized. On the else branch, though, `b` is never\n+initialized, and so bit 0 remains untouched. When the two flows of\n+control join, we union the bits from both sides, resulting in both\n+bits 0 and 1 being set. Thus any attempt to use `a` uncovers the bit 1\n+from the \"then\" branch, showing that `a` may be moved, and any attempt\n+to use `b` uncovers bit 0, from the \"else\" branch, showing that `b`\n+may not be initialized.\n+\n+## Initialization of immutable variables\n+\n+Initialization of immutable variables works in a very similar way,\n+except that:\n+\n+1. we generate bits for each assignment to a variable;\n+2. the bits are never killed except when the variable goes out of scope.\n+\n+Thus the presence of an assignment bit indicates that the assignment\n+may have occurred. Note that assignments are only killed when the\n+variable goes out of scope, as it is not relevant whether or not there\n+has been a move in the meantime. Using these bits, we can declare that\n+an assignment to an immutable variable is legal iff there is no other\n+assignment bit to that same variable in scope.\n+\n+## Why is the design made this way?\n+\n+It may seem surprising that we assign dataflow bits to *each move*\n+rather than *each path being moved*. This is somewhat less efficient,\n+since on each use, we must iterate through all moves and check whether\n+any of them correspond to the path in question. Similar concerns apply\n+to the analysis for double assignments to immutable variables. The\n+main reason to do it this way is that it allows us to print better\n+error messages, because when a use occurs, we can print out the\n+precise move that may be in scope, rather than simply having to say\n+\"the variable may not be initialized\".\n+\n+## Data structures used in the move analysis\n+\n+The move analysis maintains several data structures that enable it to\n+cross-reference moves and assignments to determine when they may be\n+moving/assigning the same memory. These are all collected into the\n+`MoveData` and `FlowedMoveData` structs. The former represents the set\n+of move paths, moves, and assignments, and the latter adds in the\n+results of a dataflow computation.\n+\n+### Move paths\n+\n+The `MovePath` tree tracks every path that is moved or assigned to.\n+These paths have the same form as the `LoanPath` data structure, which\n+in turn is the \"real world version of the lvalues `LV` that we\n+introduced earlier. The difference between a `MovePath` and a `LoanPath`\n+is that move paths are:\n+\n+1. Canonicalized, so that we have exactly one copy of each, and\n+   we can refer to move paths by index;\n+2. Cross-referenced with other paths into a tree, so that given a move\n+   path we can efficiently find all parent move paths and all\n+   extensions (e.g., given the `a.b` move path, we can easily find the\n+   move path `a` and also the move paths `a.b.c`)\n+3. Cross-referenced with moves and assignments, so that we can\n+   easily find all moves and assignments to a given path.\n+\n+The mechanism that we use is to create a `MovePath` record for each\n+move path. These are arranged in an array and are referenced using\n+`MovePathIndex` values, which are newtype'd indices. The `MovePath`\n+structs are arranged into a tree, representing using the standard\n+Knuth representation where each node has a child 'pointer' and a \"next\n+sibling\" 'pointer'. In addition, each `MovePath` has a parent\n+'pointer'.  In this case, the 'pointers' are just `MovePathIndex`\n+values.\n+\n+In this way, if we want to find all base paths of a given move path,\n+we can just iterate up the parent pointers (see `each_base_path()` in\n+the `move_data` module). If we want to find all extensions, we can\n+iterate through the subtree (see `each_extending_path()`).\n+\n+### Moves and assignments\n+\n+There are structs to represent moves (`Move`) and assignments\n+(`Assignment`), and these are also placed into arrays and referenced\n+by index. All moves of a particular path are arranged into a linked\n+lists, beginning with `MovePath.first_move` and continuing through\n+`Move.next_move`.\n+\n+We distinguish between \"var\" assignments, which are assignments to a\n+variable like `x = foo`, and \"path\" assignments (`x.f = foo`).  This\n+is because we need to assign dataflows to the former, but not the\n+latter, so as to check for double initialization of immutable\n+variables.\n+\n+### Gathering and checking moves\n+\n+Like loans, we distinguish two phases. The first, gathering, is where\n+we uncover all the moves and assignments. As with loans, we do some\n+basic sanity checking in this phase, so we'll report errors if you\n+attempt to move out of a borrowed pointer etc. Then we do the dataflow\n+(see `FlowedMoveData::new`). Finally, in the `check_loans.rs` code, we\n+walk back over, identify all uses, assignments, and captures, and\n+check that they are legal given the set of dataflow bits we have\n+computed for that program point.\n+\n+# Future work\n \n While writing up these docs, I encountered some rules I believe to be\n stricter than necessary:\n@@ -671,5 +837,26 @@ stricter than necessary:\n   extra error message in some cases, though.\n - I have not described how closures interact. Current code is unsound.\n   I am working on describing and implementing the fix.\n+- If we wish, we can easily extend the move checking to allow finer-grained\n+  tracking of what is initialized and what is not, enabling code like\n+  this:\n+\n+      a = x.f.g; // x.f.g is now uninitialized\n+      // here, x and x.f are not usable, but x.f.h *is*\n+      x.f.g = b; // x.f.g is not initialized\n+      // now x, x.f, x.f.g, x.f.h are all usable\n+\n+  What needs to change here, most likely, is that the `moves` module\n+  should record not only what paths are moved, but what expressions\n+  are actual *uses*. For example, the reference to `x` in `x.f.g = b`\n+  is not a true *use* in the sense that it requires `x` to be fully\n+  initialized. This is in fact why the above code produces an error\n+  today: the reference to `x` in `x.f.g = b` is considered illegal\n+  because `x` is not fully initialized.\n+\n+There are also some possible refactorings:\n+\n+- It might be nice to replace all loan paths with the MovePath mechanism,\n+  since they allow lightweight comparison using an integer.\n \n */"}, {"sha": "91962f17d596f1259cdeaa94ebec794a7310651c", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 46, "deletions": 11, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f30b53892962ebe0511821c1a9d20b644ecb0e02/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30b53892962ebe0511821c1a9d20b644ecb0e02/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=f30b53892962ebe0511821c1a9d20b644ecb0e02", "patch": "@@ -10,7 +10,8 @@\n \n /*!\n \n-Data structures used for tracking moves.\n+Data structures used for tracking moves. Please see the extensive\n+comments in the section \"Moves and initialization\" and in `doc.rs`.\n \n */\n \n@@ -29,11 +30,24 @@ use syntax::opt_vec;\n use util::ppaux::Repr;\n \n pub struct MoveData {\n+    /// Move paths. See section \"Move paths\" in `doc.rs`.\n     paths: ~[MovePath],\n+\n+    /// Cache of loan path to move path index, for easy lookup.\n     path_map: HashMap<@LoanPath, MovePathIndex>,\n+\n+    /// Each move or uninitialized variable gets an entry here.\n     moves: ~[Move],\n-    path_assignments: ~[Assignment],\n+\n+    /// Assignments to a variable, like `x = foo`. These are assigned\n+    /// bits for dataflow, since we must track them to ensure that\n+    /// immutable variables are assigned at most once along each path.\n     var_assignments: ~[Assignment],\n+\n+    /// Assignments to a path, like `x.f = foo`. These are not\n+    /// assigned dataflow bits, but we track them because they still\n+    /// kill move bits.\n+    path_assignments: ~[Assignment],\n     assignee_ids: HashSet<ast::node_id>,\n }\n \n@@ -43,34 +57,45 @@ pub struct FlowedMoveData {\n     // It makes me sad to use @mut here, except that due to\n     // the visitor design, this is what gather_loans\n     // must produce.\n+\n     dfcx_moves: MoveDataFlow,\n+\n+    // We could (and maybe should, for efficiency) combine both move\n+    // and assign data flow into one, but this way it's easier to\n+    // distinguish the bits that correspond to moves and assignments.\n     dfcx_assign: AssignDataFlow\n }\n \n+/// Index into `MoveData.paths`, used like a pointer\n #[deriving(Eq)]\n pub struct MovePathIndex(uint);\n \n static InvalidMovePathIndex: MovePathIndex =\n     MovePathIndex(uint::max_value);\n \n+/// Index into `MoveData.moves`, used like a pointer\n #[deriving(Eq)]\n pub struct MoveIndex(uint);\n \n static InvalidMoveIndex: MoveIndex =\n     MoveIndex(uint::max_value);\n \n-#[deriving(Eq)]\n-pub struct VarAssignmentIndex(uint);\n-\n-static InvalidVarAssignmentIndex: VarAssignmentIndex =\n-    VarAssignmentIndex(uint::max_value);\n-\n pub struct MovePath {\n-    index: MovePathIndex,\n+    /// Loan path corresponding to this move path\n     loan_path: @LoanPath,\n+\n+    /// Parent pointer, `InvalidMovePathIndex` if root\n     parent: MovePathIndex,\n+\n+    /// Head of linked list of moves to this path,\n+    /// `InvalidMoveIndex` if not moved\n     first_move: MoveIndex,\n+\n+    /// First node in linked list of children, `InvalidMovePathIndex` if leaf\n     first_child: MovePathIndex,\n+\n+    /// Next node in linked list of parent's children (siblings),\n+    /// `InvalidMovePathIndex` if none.\n     next_sibling: MovePathIndex,\n }\n \n@@ -82,15 +107,27 @@ pub enum MoveKind {\n }\n \n pub struct Move {\n+    /// Path being moved.\n     path: MovePathIndex,\n+\n+    /// id of node that is doing the move.\n     id: ast::node_id,\n+\n+    /// Kind of move, for error messages.\n     kind: MoveKind,\n+\n+    /// Next node in linked list of moves from `path`, or `InvalidMoveIndex`\n     next_move: MoveIndex,\n }\n \n pub struct Assignment {\n+    /// Path being assigned.\n     path: MovePathIndex,\n+\n+    /// id where assignment occurs\n     id: ast::node_id,\n+\n+    /// span of node where assignment occurs\n     span: span,\n }\n \n@@ -153,7 +190,6 @@ impl MoveData {\n                 let index = MovePathIndex(self.paths.len());\n \n                 self.paths.push(MovePath {\n-                    index: index,\n                     loan_path: lp,\n                     parent: InvalidMovePathIndex,\n                     first_move: InvalidMoveIndex,\n@@ -172,7 +208,6 @@ impl MoveData {\n                 self.mut_path(parent_index).first_child = index;\n \n                 self.paths.push(MovePath {\n-                    index: index,\n                     loan_path: lp,\n                     parent: parent_index,\n                     first_move: InvalidMoveIndex,"}, {"sha": "abec56d32d79edbd783d2e645304b8a183691987", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 2, "deletions": 78, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f30b53892962ebe0511821c1a9d20b644ecb0e02/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30b53892962ebe0511821c1a9d20b644ecb0e02/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=f30b53892962ebe0511821c1a9d20b644ecb0e02", "patch": "@@ -112,84 +112,8 @@ variables are captured and how (by ref, by copy, by move).\n \n ## Enforcement of Moves\n \n-FIXME out of date\n-\n-The enforcement of moves is somewhat complicated because it is divided\n-amongst the liveness and borrowck modules. In general, the borrow\n-checker is responsible for guaranteeing that *only owned data is\n-moved*.  The liveness checker, in contrast, is responsible for\n-checking that *no variable is used after it is moved*.\n-\n-To see the difference, let's look at a few examples.  Here is a\n-program fragment where the error would be caught by liveness:\n-\n-    struct Foo { a: int, b: ~int }\n-    let x: Foo = ...;\n-    let y = x.b; // (1)\n-    let z = x;   // (2)            //~ ERROR use of moved value `x`\n-\n-Here the liveness checker will see the assignment to `y` moves\n-invalidates the variable `x` because it moves the expression `x.b`.\n-An error is resported because `x` is not dead at the point where it is\n-invalidated.\n-\n-In more concrete terms, the `moves_map` generated from this example\n-would contain both the expression `x.b` (1) and the expression `x`\n-(2).  Note that it would not contain `x` (1), because `moves_map` only\n-contains the outermost expressions that are moved.  However, the id of\n-`x` would be present in the `moved_variables_set`.\n-\n-Now let's look at another illegal example, but one where liveness would\n-not catch the error:\n-\n-    struct Foo { a: int, b: ~int }\n-    let x: @Foo = ...;\n-    let y = x.b;                   //~ ERROR move from managed (@) box\n-\n-This is an interesting example because the only change I've made is\n-to make `x` have type `@Foo` and not `Foo`.  Thanks to auto-deref,\n-the expression `x.b` still works, but now it is short for `{x).b`,\n-and hence the move is actually moving out of the contents of a\n-managed box, which is illegal.  However, liveness knows nothing of\n-this.  It only tracks what variables are used where.  The moves\n-pass (that is, this pass) is also ignorant of such details.  From\n-the perspective of the moves pass, the `let y = x.b` line above\n-will be categorized as follows:\n-\n-    let y = {(x{Move}) {Move}).b; {Move}\n-\n-Therefore, the reference to `x` will be present in\n-`variable_moves_map`, but liveness will not report an error because\n-there is no subsequent use.\n-\n-This is where the borrow checker comes in.  When the borrow checker\n-runs, it will see that `x.b` is present in the `moves_map`.  It will\n-use the `mem_categorization` module to determine where the result of\n-this expression resides in memory and see that it is owned by managed\n-data, and report an error.\n-\n-In principle, liveness could use the `mem_categorization` module\n-itself and check that moves always originate from owned data\n-(historically, of course, this was not the case; `mem_categorization`\n-used to be private to the borrow checker).  However, there is another\n-kind of error which liveness could not possibly detect. Sometimes a\n-move is an error due to an outstanding loan, and it is borrow\n-checker's job to compute those loans.  That is, consider *this*\n-example:\n-\n-    struct Foo { a: int, b: ~int }\n-    let x: Foo = ...;\n-    let y = &x.b;                   //~ NOTE loan issued here\n-    let z = x.b;                    //~ ERROR move with outstanding loan\n-\n-In this case, `y` is a pointer into `x`, so when `z` tries to move out\n-of `x`, we get an error.  There is no way that liveness could compute\n-this information without redoing the efforts of the borrow checker.\n-\n-### Closures\n-\n-Liveness is somewhat complicated by having to deal with stack\n-closures.  More information to come!\n+The enforcement of moves is done by the borrow checker.  Please see\n+the section \"Moves and initialization\" in `middle/borrowck/doc.rs`.\n \n ## Distributive property\n "}]}