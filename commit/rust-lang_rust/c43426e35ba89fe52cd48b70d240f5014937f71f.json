{"sha": "c43426e35ba89fe52cd48b70d240f5014937f71f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0MzQyNmUzNWJhODlmZTUyY2Q0OGI3MGQyNDBmNTAxNDkzN2Y3MWY=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-09-13T05:09:55Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-13T19:05:03Z"}, "message": "CamelCase and demode json.rs and deque.rs", "tree": {"sha": "b87981f3b573bfdd647eb86cf6dd8e4a6e62c5fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b87981f3b573bfdd647eb86cf6dd8e4a6e62c5fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c43426e35ba89fe52cd48b70d240f5014937f71f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c43426e35ba89fe52cd48b70d240f5014937f71f", "html_url": "https://github.com/rust-lang/rust/commit/c43426e35ba89fe52cd48b70d240f5014937f71f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c43426e35ba89fe52cd48b70d240f5014937f71f/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4db474ea603863640dc35da38e89c8d97690f4bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/4db474ea603863640dc35da38e89c8d97690f4bd", "html_url": "https://github.com/rust-lang/rust/commit/4db474ea603863640dc35da38e89c8d97690f4bd"}], "stats": {"total": 174, "additions": 96, "deletions": 78}, "files": [{"sha": "4c4dcdeabe9e0673110ae5b6854927667c05dd8e", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 90, "deletions": 75, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/c43426e35ba89fe52cd48b70d240f5014937f71f/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43426e35ba89fe52cd48b70d240f5014937f71f/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=c43426e35ba89fe52cd48b70d240f5014937f71f", "patch": "@@ -1,7 +1,11 @@\n //! A deque. Untested as of yet. Likely buggy\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+#[forbid(non_camel_case_types)];\n \n use option::{Some, None};\n use dvec::DVec;\n+use core::cmp::{Eq};\n \n trait Deque<T> {\n     fn size() -> uint;\n@@ -24,8 +28,9 @@ fn create<T: Copy>() -> Deque<T> {\n       * Grow is only called on full elts, so nelts is also len(elts), unlike\n       * elsewhere.\n       */\n-    fn grow<T: Copy>(nelts: uint, lo: uint, -elts: ~[mut Cell<T>]) ->\n-       ~[mut Cell<T>] {\n+    fn grow<T: Copy>(nelts: uint, lo: uint, +elts: ~[mut Cell<T>])\n+      -> ~[mut Cell<T>] {\n+        let elts = move elts;\n         assert (nelts == vec::len(elts));\n         let mut rv = ~[mut];\n \n@@ -40,8 +45,8 @@ fn create<T: Copy>() -> Deque<T> {\n \n         move rv\n     }\n-    fn get<T: Copy>(elts: DVec<Cell<T>>, i: uint) -> T {\n-        match elts.get_elt(i) { Some(t) => t, _ => fail }\n+    fn get<T: Copy>(elts: &DVec<Cell<T>>, i: uint) -> T {\n+        match (*elts).get_elt(i) { Some(t) => t, _ => fail }\n     }\n \n     type Repr<T> = {mut nelts: uint,\n@@ -79,7 +84,7 @@ fn create<T: Copy>() -> Deque<T> {\n          * that we don't keep anyone's refcount up unexpectedly.\n          */\n         fn pop_front() -> T {\n-            let t: T = get(self.elts, self.lo);\n+            let t: T = get(&self.elts, self.lo);\n             self.elts.set_elt(self.lo, None);\n             self.lo = (self.lo + 1u) % self.elts.len();\n             self.nelts -= 1u;\n@@ -89,16 +94,16 @@ fn create<T: Copy>() -> Deque<T> {\n             if self.hi == 0u {\n                 self.hi = self.elts.len() - 1u;\n             } else { self.hi -= 1u; }\n-            let t: T = get(self.elts, self.hi);\n+            let t: T = get(&self.elts, self.hi);\n             self.elts.set_elt(self.hi, None);\n             self.nelts -= 1u;\n             return t;\n         }\n-        fn peek_front() -> T { return get(self.elts, self.lo); }\n-        fn peek_back() -> T { return get(self.elts, self.hi - 1u); }\n+        fn peek_front() -> T { return get(&self.elts, self.lo); }\n+        fn peek_back() -> T { return get(&self.elts, self.hi - 1u); }\n         fn get(i: int) -> T {\n             let idx = (self.lo + (i as uint)) % self.elts.len();\n-            return get(self.elts, idx);\n+            return get(&self.elts, idx);\n         }\n     }\n \n@@ -160,7 +165,13 @@ mod tests {\n         assert (d.get(3) == 4);\n     }\n \n-    fn test_boxes(a: @int, b: @int, c: @int, d: @int) {\n+    #[test]\n+    fn test_boxes() {\n+        let a: @int = @5;\n+        let b: @int = @72;\n+        let c: @int = @64;\n+        let d: @int = @175;\n+\n         let deq: deque::Deque<@int> = deque::create::<@int>();\n         assert (deq.size() == 0u);\n         deq.add_front(a);\n@@ -190,11 +201,7 @@ mod tests {\n         assert (deq.get(3) == d);\n     }\n \n-    type EqFn<T> = fn@(T, T) -> bool;\n-\n-    fn test_parameterized<T: Copy Owned>(\n-        e: EqFn<T>, a: T, b: T, c: T, d: T) {\n-\n+    fn test_parameterized<T: Copy Eq Owned>(+a: T, +b: T, +c: T, +d: T) {\n         let deq: deque::Deque<T> = deque::create::<T>();\n         assert (deq.size() == 0u);\n         deq.add_front(a);\n@@ -203,12 +210,12 @@ mod tests {\n         assert (deq.size() == 3u);\n         deq.add_back(d);\n         assert (deq.size() == 4u);\n-        assert (e(deq.peek_front(), b));\n-        assert (e(deq.peek_back(), d));\n-        assert (e(deq.pop_front(), b));\n-        assert (e(deq.pop_back(), d));\n-        assert (e(deq.pop_back(), c));\n-        assert (e(deq.pop_back(), a));\n+        assert deq.peek_front() == b;\n+        assert deq.peek_back() == d;\n+        assert deq.pop_front() == b;\n+        assert deq.pop_back() == d;\n+        assert deq.pop_back() == c;\n+        assert deq.pop_back() == a;\n         assert (deq.size() == 0u);\n         deq.add_back(c);\n         assert (deq.size() == 1u);\n@@ -218,10 +225,10 @@ mod tests {\n         assert (deq.size() == 3u);\n         deq.add_front(a);\n         assert (deq.size() == 4u);\n-        assert (e(deq.get(0), a));\n-        assert (e(deq.get(1), b));\n-        assert (e(deq.get(2), c));\n-        assert (e(deq.get(3), d));\n+        assert deq.get(0) == a;\n+        assert deq.get(1) == b;\n+        assert deq.get(2) == c;\n+        assert deq.get(3) == d;\n     }\n \n     enum Taggy { One(int), Two(int, int), Three(int, int, int), }\n@@ -232,78 +239,86 @@ mod tests {\n \n     type RecCy = {x: int, y: int, t: Taggy};\n \n-    #[test]\n-    fn test() {\n-        fn inteq(&&a: int, &&b: int) -> bool { return a == b; }\n-        fn intboxeq(&&a: @int, &&b: @int) -> bool { return a == b; }\n-        fn taggyeq(a: Taggy, b: Taggy) -> bool {\n-            match a {\n-              One(a1) => match b {\n+    impl Taggy : Eq {\n+        pure fn eq(other: Taggy) -> bool {\n+            match self {\n+              One(a1) => match other {\n                 One(b1) => return a1 == b1,\n                 _ => return false\n               },\n-              Two(a1, a2) => match b {\n+              Two(a1, a2) => match other {\n                 Two(b1, b2) => return a1 == b1 && a2 == b2,\n                 _ => return false\n               },\n-              Three(a1, a2, a3) => match b {\n+              Three(a1, a2, a3) => match other {\n                 Three(b1, b2, b3) => return a1 == b1 && a2 == b2 && a3 == b3,\n                 _ => return false\n               }\n             }\n         }\n-        fn taggypareq<T>(a: Taggypar<T>, b: Taggypar<T>) -> bool {\n-            match a {\n-              Onepar::<T>(a1) => match b {\n-                Onepar::<T>(b1) => return a1 == b1,\n-                _ => return false\n-              },\n-              Twopar::<T>(a1, a2) => match b {\n-                Twopar::<T>(b1, b2) => return a1 == b1 && a2 == b2,\n-                _ => return false\n-              },\n-              Threepar::<T>(a1, a2, a3) => match b {\n-                Threepar::<T>(b1, b2, b3) => {\n-                    return a1 == b1 && a2 == b2 && a3 == b3\n-                }\n-                _ => return false\n-              }\n-            }\n+        pure fn ne(other: Taggy) -> bool { !self.eq(other) }\n+    }\n+\n+    impl Taggypar<int> : Eq {\n+        //let eq4: EqFn<Taggypar<int>> = |x,y| taggypareq::<int>(x, y);\n+        pure fn eq(other: Taggypar<int>) -> bool {\n+                  match self {\n+                    Onepar::<int>(a1) => match other {\n+                      Onepar::<int>(b1) => return a1 == b1,\n+                      _ => return false\n+                    },\n+                    Twopar::<int>(a1, a2) => match other {\n+                      Twopar::<int>(b1, b2) => return a1 == b1 && a2 == b2,\n+                      _ => return false\n+                    },\n+                    Threepar::<int>(a1, a2, a3) => match other {\n+                      Threepar::<int>(b1, b2, b3) => {\n+                          return a1 == b1 && a2 == b2 && a3 == b3\n+                      }\n+                      _ => return false\n+                    }\n+                  }\n         }\n-        fn reccyeq(a: RecCy, b: RecCy) -> bool {\n-            return a.x == b.x && a.y == b.y && taggyeq(a.t, b.t);\n+        pure fn ne(other: Taggypar<int>) -> bool { !self.eq(other) }\n+    }\n+\n+    impl RecCy : Eq {\n+        pure fn eq(other: RecCy) -> bool {\n+          return self.x == other.x && self.y == other.y && self.t == other.t;\n         }\n-        debug!(\"*** test boxes\");\n-        test_boxes(@5, @72, @64, @175);\n-        debug!(\"*** end test boxes\");\n-        debug!(\"test parameterized: int\");\n-        let eq1: EqFn<int> = inteq;\n-        test_parameterized::<int>(eq1, 5, 72, 64, 175);\n-        debug!(\"*** test parameterized: @int\");\n-        let eq2: EqFn<@int> = intboxeq;\n-        test_parameterized::<@int>(eq2, @5, @72, @64, @175);\n-        debug!(\"*** end test parameterized @int\");\n-        debug!(\"test parameterized: taggy\");\n-        let eq3: EqFn<Taggy> = taggyeq;\n-        test_parameterized::<Taggy>(eq3, One(1), Two(1, 2), Three(1, 2, 3),\n+        pure fn ne(other: RecCy) -> bool { !self.eq(other) }\n+    }\n+\n+    #[test]\n+    fn test_param_int() {\n+        test_parameterized::<int>(5, 72, 64, 175);\n+    }\n+\n+    #[test]\n+    fn test_param_at_int() {\n+        test_parameterized::<@int>(@5, @72, @64, @175);\n+    }\n+\n+    #[test]\n+    fn test_param_taggy() {\n+        test_parameterized::<Taggy>(One(1), Two(1, 2), Three(1, 2, 3),\n                                     Two(17, 42));\n+    }\n \n-        debug!(\"*** test parameterized: taggypar<int>\");\n-        let eq4: EqFn<Taggypar<int>> = |x,y| taggypareq::<int>(x, y);\n-        test_parameterized::<Taggypar<int>>(eq4, Onepar::<int>(1),\n+    #[test]\n+    fn test_param_taggypar() {\n+        test_parameterized::<Taggypar<int>>(Onepar::<int>(1),\n                                             Twopar::<int>(1, 2),\n                                             Threepar::<int>(1, 2, 3),\n                                             Twopar::<int>(17, 42));\n-        debug!(\"*** end test parameterized: taggypar::<int>\");\n+    }\n \n-        debug!(\"*** test parameterized: reccy\");\n+    #[test]\n+    fn test_param_reccy() {\n         let reccy1: RecCy = {x: 1, y: 2, t: One(1)};\n         let reccy2: RecCy = {x: 345, y: 2, t: Two(1, 2)};\n         let reccy3: RecCy = {x: 1, y: 777, t: Three(1, 2, 3)};\n         let reccy4: RecCy = {x: 19, y: 252, t: Two(17, 42)};\n-        let eq5: EqFn<RecCy> = reccyeq;\n-        test_parameterized::<RecCy>(eq5, reccy1, reccy2, reccy3, reccy4);\n-        debug!(\"*** end test parameterized: reccy\");\n-        debug!(\"*** done\");\n+        test_parameterized::<RecCy>(reccy1, reccy2, reccy3, reccy4);\n     }\n }"}, {"sha": "8db0e0bfc10ee3100c7066d425df65be7b04d83f", "filename": "src/libstd/json.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c43426e35ba89fe52cd48b70d240f5014937f71f/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c43426e35ba89fe52cd48b70d240f5014937f71f/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=c43426e35ba89fe52cd48b70d240f5014937f71f", "patch": "@@ -1,5 +1,8 @@\n // Rust JSON serialization library\n // Copyright (c) 2011 Google Inc.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+#[forbid(non_camel_case_types)];\n \n //! json serialization\n \n@@ -174,7 +177,7 @@ fn to_writer_pretty(wr: io::Writer, j: Json, indent: uint) {\n     }\n }\n \n-fn escape_str(s: ~str) -> ~str {\n+fn escape_str(s: &str) -> ~str {\n     let mut escaped = ~\"\\\"\";\n     do str::chars_iter(s) |c| {\n         match c {\n@@ -574,7 +577,7 @@ fn from_reader(rdr: io::Reader) -> Result<Json, Error> {\n }\n \n /// Deserializes a json value from a string\n-fn from_str(s: ~str) -> Result<Json, Error> {\n+fn from_str(s: &str) -> Result<Json, Error> {\n     io::with_str_reader(s, from_reader)\n }\n \n@@ -828,7 +831,7 @@ impl Error: to_str::ToStr {\n \n #[cfg(test)]\n mod tests {\n-    fn mk_dict(items: ~[(~str, Json)]) -> Json {\n+    fn mk_dict(items: &[(~str, Json)]) -> Json {\n         let d = map::str_hash();\n \n         do vec::iter(items) |item| {"}]}