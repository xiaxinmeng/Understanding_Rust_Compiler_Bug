{"sha": "7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMjg5YWVhZGU0ODFjMDNkNDJlN2Y2ZDMxYmM2YjY0YTczY2ZhNDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-05T14:59:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-05T14:59:32Z"}, "message": "Auto merge of #76376 - Dylan-DPC:rollup-8chsbw9, r=Dylan-DPC\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #75695 (Add a regression test for issue-72793)\n - #75741 (Refactor byteorder to std in rustc_middle)\n - #75954 (Unstable Book: add links to tracking issues for FFI features)\n - #75994 (`impl Rc::new_cyclic`)\n - #76060 (Link vec doc to & reference)\n - #76078 (Remove disambiguators from intra doc link text)\n - #76082 (Fix intra-doc links on pub re-exports)\n - #76254 (Fold length constant in Rvalue::Repeat)\n - #76258 (x.py check checks tests/examples/benches)\n - #76263 (inliner: Check for codegen fn attributes compatibility)\n - #76285 (Move jointness censoring to proc_macro)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "1c73e6113a1a479b514949d9db2ff538f3661357", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c73e6113a1a479b514949d9db2ff538f3661357"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "html_url": "https://github.com/rust-lang/rust/commit/7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81a769f261047afd8e31cc488b173b0ab5ac4205", "url": "https://api.github.com/repos/rust-lang/rust/commits/81a769f261047afd8e31cc488b173b0ab5ac4205", "html_url": "https://github.com/rust-lang/rust/commit/81a769f261047afd8e31cc488b173b0ab5ac4205"}, {"sha": "85cee57fd791d670d92dc61e0ad71594128dd45a", "url": "https://api.github.com/repos/rust-lang/rust/commits/85cee57fd791d670d92dc61e0ad71594128dd45a", "html_url": "https://github.com/rust-lang/rust/commit/85cee57fd791d670d92dc61e0ad71594128dd45a"}], "stats": {"total": 800, "additions": 714, "deletions": 86}, "files": [{"sha": "b84f6ef51ac201ef8c5ad342c05cd7bb0ffc72b5", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -3722,7 +3722,6 @@ name = \"rustc_middle\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n- \"byteorder\",\n  \"chalk-ir\",\n  \"measureme\",\n  \"polonius-engine\","}, {"sha": "fb98f55a2154a5757fcb5b7d885d57a55f4612cf", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -403,8 +403,8 @@ impl Cursor {\n         self.index = index;\n     }\n \n-    pub fn look_ahead(&self, n: usize) -> Option<TokenTree> {\n-        self.stream.0[self.index..].get(n).map(|(tree, _)| tree.clone())\n+    pub fn look_ahead(&self, n: usize) -> Option<&TokenTree> {\n+        self.stream.0[self.index..].get(n).map(|(tree, _)| tree)\n     }\n }\n "}, {"sha": "765871a6396f353d8aea31812da16059a0ec9ac6", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -47,15 +47,26 @@ impl ToInternal<token::DelimToken> for Delimiter {\n     }\n }\n \n-impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n-    for TokenTree<Group, Punct, Ident, Literal>\n+impl\n+    FromInternal<(\n+        TreeAndJoint,\n+        Option<&'_ tokenstream::TokenTree>,\n+        &'_ ParseSess,\n+        &'_ mut Vec<Self>,\n+    )> for TokenTree<Group, Punct, Ident, Literal>\n {\n     fn from_internal(\n-        ((tree, is_joint), sess, stack): (TreeAndJoint, &ParseSess, &mut Vec<Self>),\n+        ((tree, is_joint), look_ahead, sess, stack): (\n+            TreeAndJoint,\n+            Option<&tokenstream::TokenTree>,\n+            &ParseSess,\n+            &mut Vec<Self>,\n+        ),\n     ) -> Self {\n         use rustc_ast::token::*;\n \n-        let joint = is_joint == Joint;\n+        let joint = is_joint == Joint\n+            && matches!(look_ahead, Some(tokenstream::TokenTree::Token(t)) if t.is_op());\n         let Token { kind, span } = match tree {\n             tokenstream::TokenTree::Delimited(span, delim, tts) => {\n                 let delimiter = Delimiter::from_internal(delim);\n@@ -445,7 +456,8 @@ impl server::TokenStreamIter for Rustc<'_> {\n         loop {\n             let tree = iter.stack.pop().or_else(|| {\n                 let next = iter.cursor.next_with_joint()?;\n-                Some(TokenTree::from_internal((next, self.sess, &mut iter.stack)))\n+                let lookahead = iter.cursor.look_ahead(0);\n+                Some(TokenTree::from_internal((next, lookahead, self.sess, &mut iter.stack)))\n             })?;\n             // A hack used to pass AST fragments to attribute and derive macros\n             // as a single nonterminal token instead of a token stream."}, {"sha": "a5a860a38b3e8f45d4d24f868ba37be82c911326", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -26,7 +26,6 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n-byteorder = { version = \"1.3\" }\n chalk-ir = \"0.21.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n measureme = \"0.7.1\""}, {"sha": "ee1ea816e019253bf7b945cf647135bef533cfbb", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -345,10 +345,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n \n     /// Reads a *non-ZST* scalar.\n     ///\n-    /// ZSTs can't be read for two reasons:\n-    /// * byte-order cannot work with zero-element buffers;\n-    /// * in order to obtain a `Pointer`, we need to check for ZSTness anyway due to integer\n-    ///   pointers being valid for ZSTs.\n+    /// ZSTs can't be read because in order to obtain a `Pointer`, we need to check\n+    /// for ZSTness anyway due to integer pointers being valid for ZSTs.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     /// Most likely, you want to call `InterpCx::read_scalar` instead of this method.\n@@ -397,10 +395,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n \n     /// Writes a *non-ZST* scalar.\n     ///\n-    /// ZSTs can't be read for two reasons:\n-    /// * byte-order cannot work with zero-element buffers;\n-    /// * in order to obtain a `Pointer`, we need to check for ZSTness anyway due to integer\n-    ///   pointers being valid for ZSTs.\n+    /// ZSTs can't be read because in order to obtain a `Pointer`, we need to check\n+    /// for ZSTness anyway due to integer pointers being valid for ZSTs.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     /// Most likely, you want to call `InterpCx::write_scalar` instead of this method."}, {"sha": "cbc362d934ff8d5c22ff7673fb211e0b4ff5417e", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -98,10 +98,10 @@ mod value;\n use std::convert::TryFrom;\n use std::fmt;\n use std::io;\n+use std::io::{Read, Write};\n use std::num::NonZeroU32;\n use std::sync::atomic::{AtomicU32, Ordering};\n \n-use byteorder::{BigEndian, LittleEndian, ReadBytesExt, WriteBytesExt};\n use rustc_ast::LitKind;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{HashMapExt, Lock};\n@@ -561,19 +561,33 @@ pub fn write_target_uint(\n     mut target: &mut [u8],\n     data: u128,\n ) -> Result<(), io::Error> {\n-    let len = target.len();\n+    // This u128 holds an \"any-size uint\" (since smaller uints can fits in it)\n+    // So we do not write all bytes of the u128, just the \"payload\".\n     match endianness {\n-        Endian::Little => target.write_uint128::<LittleEndian>(data, len),\n-        Endian::Big => target.write_uint128::<BigEndian>(data, len),\n-    }\n+        Endian::Little => target.write(&data.to_le_bytes())?,\n+        Endian::Big => target.write(&data.to_be_bytes()[16 - target.len()..])?,\n+    };\n+    debug_assert!(target.len() == 0); // We should have filled the target buffer.\n+    Ok(())\n }\n \n #[inline]\n pub fn read_target_uint(endianness: Endian, mut source: &[u8]) -> Result<u128, io::Error> {\n-    match endianness {\n-        Endian::Little => source.read_uint128::<LittleEndian>(source.len()),\n-        Endian::Big => source.read_uint128::<BigEndian>(source.len()),\n-    }\n+    // This u128 holds an \"any-size uint\" (since smaller uints can fits in it)\n+    let mut buf = [0u8; std::mem::size_of::<u128>()];\n+    // So we do not read exactly 16 bytes into the u128, just the \"payload\".\n+    let uint = match endianness {\n+        Endian::Little => {\n+            source.read(&mut buf)?;\n+            Ok(u128::from_le_bytes(buf))\n+        }\n+        Endian::Big => {\n+            source.read(&mut buf[16 - source.len()..])?;\n+            Ok(u128::from_be_bytes(buf))\n+        }\n+    };\n+    debug_assert!(source.len() == 0); // We should have consumed the source buffer.\n+    uint\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "ad2eae0298cec751cef75ca12f6f8c6e858e0795", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -175,7 +175,7 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n         use crate::mir::Rvalue::*;\n         match *self {\n             Use(ref op) => Use(op.fold_with(folder)),\n-            Repeat(ref op, len) => Repeat(op.fold_with(folder), len),\n+            Repeat(ref op, len) => Repeat(op.fold_with(folder), len.fold_with(folder)),\n             ThreadLocalRef(did) => ThreadLocalRef(did.fold_with(folder)),\n             Ref(region, bk, ref place) => {\n                 Ref(region.fold_with(folder), bk, place.fold_with(folder))"}, {"sha": "d6e6371e886c4c0bd1cb0b6b088d8e024ce79b74", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -4,7 +4,7 @@ use rustc_attr as attr;\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n@@ -45,7 +45,8 @@ impl<'tcx> MirPass<'tcx> for Inline {\n                 // based function.\n                 debug!(\"function inlining is disabled when compiling with `instrument_coverage`\");\n             } else {\n-                Inliner { tcx, source }.run_pass(body);\n+                Inliner { tcx, source, codegen_fn_attrs: tcx.codegen_fn_attrs(source.def_id()) }\n+                    .run_pass(body);\n             }\n         }\n     }\n@@ -54,6 +55,7 @@ impl<'tcx> MirPass<'tcx> for Inline {\n struct Inliner<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     source: MirSource<'tcx>,\n+    codegen_fn_attrs: &'tcx CodegenFnAttrs,\n }\n \n impl Inliner<'tcx> {\n@@ -242,9 +244,19 @@ impl Inliner<'tcx> {\n             return false;\n         }\n \n-        // Avoid inlining functions marked as no_sanitize if sanitizer is enabled,\n-        // since instrumentation might be enabled and performed on the caller.\n-        if self.tcx.sess.opts.debugging_opts.sanitizer.intersects(codegen_fn_attrs.no_sanitize) {\n+        let self_features = &self.codegen_fn_attrs.target_features;\n+        let callee_features = &codegen_fn_attrs.target_features;\n+        if callee_features.iter().any(|feature| !self_features.contains(feature)) {\n+            debug!(\"`callee has extra target features - not inlining\");\n+            return false;\n+        }\n+\n+        let self_no_sanitize =\n+            self.codegen_fn_attrs.no_sanitize & self.tcx.sess.opts.debugging_opts.sanitizer;\n+        let callee_no_sanitize =\n+            codegen_fn_attrs.no_sanitize & self.tcx.sess.opts.debugging_opts.sanitizer;\n+        if self_no_sanitize != callee_no_sanitize {\n+            debug!(\"`callee has incompatible no_sanitize attribute - not inlining\");\n             return false;\n         }\n "}, {"sha": "fb27ccfbd9429b5a168064eec2b99f5b5f601ef5", "filename": "compiler/rustc_parse/src/lexer/tokentrees.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -262,10 +262,7 @@ impl<'a> TokenTreesReader<'a> {\n             }\n             _ => {\n                 let tt = TokenTree::Token(self.token.take());\n-                let mut is_joint = self.bump();\n-                if !self.token.is_op() {\n-                    is_joint = NonJoint;\n-                }\n+                let is_joint = self.bump();\n                 Ok((tt, is_joint))\n             }\n         }"}, {"sha": "1b2067f8f256b49b182c8d38e9c0e9917113526a", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -822,15 +822,15 @@ impl<'a> Parser<'a> {\n         }\n \n         let frame = &self.token_cursor.frame;\n-        looker(&match frame.tree_cursor.look_ahead(dist - 1) {\n+        match frame.tree_cursor.look_ahead(dist - 1) {\n             Some(tree) => match tree {\n-                TokenTree::Token(token) => token,\n+                TokenTree::Token(token) => looker(token),\n                 TokenTree::Delimited(dspan, delim, _) => {\n-                    Token::new(token::OpenDelim(delim), dspan.open)\n+                    looker(&Token::new(token::OpenDelim(delim.clone()), dspan.open))\n                 }\n             },\n-            None => Token::new(token::CloseDelim(frame.delim), frame.span.close),\n-        })\n+            None => looker(&Token::new(token::CloseDelim(frame.delim), frame.span.close)),\n+        }\n     }\n \n     /// Returns whether any of the given keywords are `dist` tokens ahead of the current one."}, {"sha": "a9b293856e57bec38004457908acf0c1a2b5dff3", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -325,6 +325,50 @@ impl<T> Rc<T> {\n         )\n     }\n \n+    /// Constructs a new `Rc<T>` using a weak reference to itself. Attempting\n+    /// to upgrade the weak reference before this function returns will result\n+    /// in a `None` value. However, the weak reference may be cloned freely and\n+    /// stored for use at a later time.\n+    #[unstable(feature = \"arc_new_cyclic\", issue = \"75861\")]\n+    pub fn new_cyclic(data_fn: impl FnOnce(&Weak<T>) -> T) -> Rc<T> {\n+        // Construct the inner in the \"uninitialized\" state with a single\n+        // weak reference.\n+        let uninit_ptr: NonNull<_> = Box::leak(box RcBox {\n+            strong: Cell::new(0),\n+            weak: Cell::new(1),\n+            value: mem::MaybeUninit::<T>::uninit(),\n+        })\n+        .into();\n+\n+        let init_ptr: NonNull<RcBox<T>> = uninit_ptr.cast();\n+\n+        let weak = Weak { ptr: init_ptr };\n+\n+        // It's important we don't give up ownership of the weak pointer, or\n+        // else the memory might be freed by the time `data_fn` returns. If\n+        // we really wanted to pass ownership, we could create an additional\n+        // weak pointer for ourselves, but this would result in additional\n+        // updates to the weak reference count which might not be necessary\n+        // otherwise.\n+        let data = data_fn(&weak);\n+\n+        unsafe {\n+            let inner = init_ptr.as_ptr();\n+            ptr::write(&raw mut (*inner).value, data);\n+\n+            let prev_value = (*inner).strong.get();\n+            debug_assert_eq!(prev_value, 0, \"No prior strong references should exist\");\n+            (*inner).strong.set(1);\n+        }\n+\n+        let strong = Rc::from_inner(init_ptr);\n+\n+        // Strong references should collectively own a shared weak reference,\n+        // so don't run the destructor for our old weak reference.\n+        mem::forget(weak);\n+        strong\n+    }\n+\n     /// Constructs a new `Rc` with uninitialized contents.\n     ///\n     /// # Examples"}, {"sha": "fed48a59f809e2b13ee4db1ea13d9da03758953a", "filename": "library/alloc/src/rc/tests.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/library%2Falloc%2Fsrc%2Frc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/library%2Falloc%2Fsrc%2Frc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc%2Ftests.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -434,3 +434,69 @@ fn test_array_from_slice() {\n     let a: Result<Rc<[u32; 2]>, _> = r.clone().try_into();\n     assert!(a.is_err());\n }\n+\n+#[test]\n+fn test_rc_cyclic_with_zero_refs() {\n+    struct ZeroRefs {\n+        inner: Weak<ZeroRefs>,\n+    }\n+\n+    let zero_refs = Rc::new_cyclic(|inner| {\n+        assert_eq!(inner.strong_count(), 0);\n+        assert!(inner.upgrade().is_none());\n+        ZeroRefs { inner: Weak::new() }\n+    });\n+\n+    assert_eq!(Rc::strong_count(&zero_refs), 1);\n+    assert_eq!(Rc::weak_count(&zero_refs), 0);\n+    assert_eq!(zero_refs.inner.strong_count(), 0);\n+    assert_eq!(zero_refs.inner.weak_count(), 0);\n+}\n+\n+#[test]\n+fn test_rc_cyclic_with_one_ref() {\n+    struct OneRef {\n+        inner: Weak<OneRef>,\n+    }\n+\n+    let one_ref = Rc::new_cyclic(|inner| {\n+        assert_eq!(inner.strong_count(), 0);\n+        assert!(inner.upgrade().is_none());\n+        OneRef { inner: inner.clone() }\n+    });\n+\n+    assert_eq!(Rc::strong_count(&one_ref), 1);\n+    assert_eq!(Rc::weak_count(&one_ref), 1);\n+\n+    let one_ref2 = Weak::upgrade(&one_ref.inner).unwrap();\n+    assert!(Rc::ptr_eq(&one_ref, &one_ref2));\n+\n+    assert_eq!(one_ref.inner.strong_count(), 2);\n+    assert_eq!(one_ref.inner.weak_count(), 1);\n+}\n+\n+#[test]\n+fn test_rc_cyclic_with_two_ref() {\n+    struct TwoRefs {\n+        inner: Weak<TwoRefs>,\n+        inner1: Weak<TwoRefs>,\n+    }\n+\n+    let two_refs = Rc::new_cyclic(|inner| {\n+        assert_eq!(inner.strong_count(), 0);\n+        assert!(inner.upgrade().is_none());\n+        TwoRefs { inner: inner.clone(), inner1: inner.clone() }\n+    });\n+\n+    assert_eq!(Rc::strong_count(&two_refs), 1);\n+    assert_eq!(Rc::weak_count(&two_refs), 2);\n+\n+    let two_ref3 = Weak::upgrade(&two_refs.inner).unwrap();\n+    assert!(Rc::ptr_eq(&two_refs, &two_ref3));\n+\n+    let two_ref2 = Weak::upgrade(&two_refs.inner1).unwrap();\n+    assert!(Rc::ptr_eq(&two_refs, &two_ref2));\n+\n+    assert_eq!(Rc::strong_count(&two_refs), 3);\n+    assert_eq!(Rc::weak_count(&two_refs), 2);\n+}"}, {"sha": "011ea32d0cfc26a81dd2eacbea226502a785ee8e", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -159,7 +159,7 @@ use crate::raw_vec::RawVec;\n /// # Slicing\n ///\n /// A `Vec` can be mutable. Slices, on the other hand, are read-only objects.\n-/// To get a slice, use `&`. Example:\n+/// To get a [slice], use [`&`]. Example:\n ///\n /// ```\n /// fn read_slice(slice: &[usize]) {\n@@ -287,6 +287,8 @@ use crate::raw_vec::RawVec;\n /// [`insert`]: Vec::insert\n /// [`reserve`]: Vec::reserve\n /// [owned slice]: Box\n+/// [slice]: ../../std/primitive.slice.html\n+/// [`&`]: ../../std/primitive.reference.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"vec_type\")]\n pub struct Vec<T> {"}, {"sha": "4708b207156c97b3e71646a534f02f02553557a2", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -382,7 +382,7 @@ impl<'a> Builder<'a> {\n                 native::Lld\n             ),\n             Kind::Check | Kind::Clippy | Kind::Fix | Kind::Format => {\n-                describe!(check::Std, check::Rustc, check::Rustdoc, check::Clippy)\n+                describe!(check::Std, check::Rustc, check::Rustdoc, check::Clippy, check::Bootstrap)\n             }\n             Kind::Test => describe!(\n                 crate::toolstate::ToolStateCheck,"}, {"sha": "ead0bd0413b9c168f6e0e44a5c5d8cde561081df", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 62, "deletions": 3, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -66,6 +66,43 @@ impl Step for Std {\n         let libdir = builder.sysroot_libdir(compiler, target);\n         let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n         add_to_sysroot(&builder, &libdir, &hostdir, &libstd_stamp(builder, compiler, target));\n+\n+        // Then run cargo again, once we've put the rmeta files for the library\n+        // crates into the sysroot. This is needed because e.g., core's tests\n+        // depend on `libtest` -- Cargo presumes it will exist, but it doesn't\n+        // since we initialize with an empty sysroot.\n+        //\n+        // Currently only the \"libtest\" tree of crates does this.\n+\n+        let mut cargo = builder.cargo(\n+            compiler,\n+            Mode::Std,\n+            SourceType::InTree,\n+            target,\n+            cargo_subcommand(builder.kind),\n+        );\n+        std_cargo(builder, target, compiler.stage, &mut cargo);\n+        cargo.arg(\"--all-targets\");\n+\n+        // Explicitly pass -p for all dependencies krates -- this will force cargo\n+        // to also check the tests/benches/examples for these crates, rather\n+        // than just the leaf crate.\n+        for krate in builder.in_tree_crates(\"test\") {\n+            cargo.arg(\"-p\").arg(krate.name);\n+        }\n+\n+        builder.info(&format!(\n+            \"Checking std test/bench/example targets ({} -> {})\",\n+            &compiler.host, target\n+        ));\n+        run_cargo(\n+            builder,\n+            cargo,\n+            args(builder.kind),\n+            &libstd_test_stamp(builder, compiler, target),\n+            vec![],\n+            true,\n+        );\n     }\n }\n \n@@ -106,6 +143,14 @@ impl Step for Rustc {\n             cargo_subcommand(builder.kind),\n         );\n         rustc_cargo(builder, &mut cargo, target);\n+        cargo.arg(\"--all-targets\");\n+\n+        // Explicitly pass -p for all compiler krates -- this will force cargo\n+        // to also check the tests/benches/examples for these crates, rather\n+        // than just the leaf crate.\n+        for krate in builder.in_tree_crates(\"rustc-main\") {\n+            cargo.arg(\"-p\").arg(krate.name);\n+        }\n \n         builder.info(&format!(\"Checking compiler artifacts ({} -> {})\", &compiler.host, target));\n         run_cargo(\n@@ -149,7 +194,7 @@ macro_rules! tool_check_step {\n \n                 builder.ensure(Rustc { target });\n \n-                let cargo = prepare_tool_cargo(\n+                let mut cargo = prepare_tool_cargo(\n                     builder,\n                     compiler,\n                     Mode::ToolRustc,\n@@ -160,12 +205,14 @@ macro_rules! tool_check_step {\n                     &[],\n                 );\n \n-                println!(\n+                cargo.arg(\"--all-targets\");\n+\n+                builder.info(&format!(\n                     \"Checking {} artifacts ({} -> {})\",\n                     stringify!($name).to_lowercase(),\n                     &compiler.host.triple,\n                     target.triple\n-                );\n+                ));\n                 run_cargo(\n                     builder,\n                     cargo,\n@@ -202,12 +249,24 @@ tool_check_step!(Rustdoc, \"src/tools/rustdoc\", SourceType::InTree);\n // rejected.\n tool_check_step!(Clippy, \"src/tools/clippy\", SourceType::InTree);\n \n+tool_check_step!(Bootstrap, \"src/bootstrap\", SourceType::InTree);\n+\n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n fn libstd_stamp(builder: &Builder<'_>, compiler: Compiler, target: TargetSelection) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Std, target).join(\".libstd-check.stamp\")\n }\n \n+/// Cargo's output path for the standard library in a given stage, compiled\n+/// by a particular compiler for the specified target.\n+fn libstd_test_stamp(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    target: TargetSelection,\n+) -> PathBuf {\n+    builder.cargo_out(compiler, Mode::Std, target).join(\".libstd-check-test.stamp\")\n+}\n+\n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n fn librustc_stamp(builder: &Builder<'_>, compiler: Compiler, target: TargetSelection) -> PathBuf {"}, {"sha": "24a304437542ddad48c09c6a0bd3ccc632682d46", "filename": "src/doc/unstable-book/src/language-features/ffi-const.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-const.md", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-const.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-const.md?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -1,5 +1,9 @@\n # `ffi_const`\n \n+The tracking issue for this feature is: [#58328]\n+\n+------\n+\n The `#[ffi_const]` attribute applies clang's `const` attribute to foreign\n functions declarations.\n \n@@ -42,6 +46,7 @@ implemented in this way on all of them. It is therefore also worth verifying\n that the semantics of the C toolchain used to compile the binary being linked\n against are compatible with those of the `#[ffi_const]`.\n \n+[#58328]: https://github.com/rust-lang/rust/issues/58328\n [ARM C/C++ compiler]: http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0491c/Cacgigch.html\n [GCC]: https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-const-function-attribute\n [IBM ILE C/C++]: https://www.ibm.com/support/knowledgecenter/fr/ssw_ibm_i_71/rzarg/fn_attrib_const.htm"}, {"sha": "4aef4eeab55323f6c802d4fb48ef21bbea31222a", "filename": "src/doc/unstable-book/src/language-features/ffi-pure.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-pure.md", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-pure.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-pure.md?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -1,5 +1,9 @@\n # `ffi_pure`\n \n+The tracking issue for this feature is: [#58329]\n+\n+------\n+\n The `#[ffi_pure]` attribute applies clang's `pure` attribute to foreign\n functions declarations.\n \n@@ -46,6 +50,7 @@ that the semantics of the C toolchain used to compile the binary being linked\n against are compatible with those of the `#[ffi_pure]`.\n \n \n+[#58329]: https://github.com/rust-lang/rust/issues/58329\n [ARM C/C++ compiler]: http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0491c/Cacigdac.html\n [GCC]: https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-pure-function-attribute\n [IBM ILE C/C++]: https://www.ibm.com/support/knowledgecenter/fr/ssw_ibm_i_71/rzarg/fn_attrib_pure.htm"}, {"sha": "223fda84871e9725392f8c3c1717a34c0d3db1a9", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -118,7 +118,7 @@ impl Item {\n         self.attrs.collapsed_doc_value()\n     }\n \n-    pub fn links(&self) -> Vec<(String, String)> {\n+    pub fn links(&self) -> Vec<RenderedLink> {\n         self.attrs.links(&self.def_id.krate)\n     }\n \n@@ -425,10 +425,38 @@ pub struct Attributes {\n     pub cfg: Option<Arc<Cfg>>,\n     pub span: Option<rustc_span::Span>,\n     /// map from Rust paths to resolved defs and potential URL fragments\n-    pub links: Vec<(String, Option<DefId>, Option<String>)>,\n+    pub links: Vec<ItemLink>,\n     pub inner_docs: bool,\n }\n \n+#[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\n+/// A link that has not yet been rendered.\n+///\n+/// This link will be turned into a rendered link by [`Attributes::links`]\n+pub struct ItemLink {\n+    /// The original link written in the markdown\n+    pub(crate) link: String,\n+    /// The link text displayed in the HTML.\n+    ///\n+    /// This may not be the same as `link` if there was a disambiguator\n+    /// in an intra-doc link (e.g. \\[`fn@f`\\])\n+    pub(crate) link_text: String,\n+    pub(crate) did: Option<DefId>,\n+    /// The url fragment to append to the link\n+    pub(crate) fragment: Option<String>,\n+}\n+\n+pub struct RenderedLink {\n+    /// The text the link was original written as.\n+    ///\n+    /// This could potentially include disambiguators and backticks.\n+    pub(crate) original_text: String,\n+    /// The text to display in the HTML\n+    pub(crate) new_text: String,\n+    /// The URL to put in the `href`\n+    pub(crate) href: String,\n+}\n+\n impl Attributes {\n     /// Extracts the content from an attribute `#[doc(cfg(content))]`.\n     pub fn extract_cfg(mi: &ast::MetaItem) -> Option<&ast::MetaItem> {\n@@ -605,21 +633,25 @@ impl Attributes {\n     /// Gets links as a vector\n     ///\n     /// Cache must be populated before call\n-    pub fn links(&self, krate: &CrateNum) -> Vec<(String, String)> {\n+    pub fn links(&self, krate: &CrateNum) -> Vec<RenderedLink> {\n         use crate::html::format::href;\n         use crate::html::render::CURRENT_DEPTH;\n \n         self.links\n             .iter()\n-            .filter_map(|&(ref s, did, ref fragment)| {\n-                match did {\n+            .filter_map(|ItemLink { link: s, link_text, did, fragment }| {\n+                match *did {\n                     Some(did) => {\n                         if let Some((mut href, ..)) = href(did) {\n                             if let Some(ref fragment) = *fragment {\n                                 href.push_str(\"#\");\n                                 href.push_str(fragment);\n                             }\n-                            Some((s.clone(), href))\n+                            Some(RenderedLink {\n+                                original_text: s.clone(),\n+                                new_text: link_text.clone(),\n+                                href,\n+                            })\n                         } else {\n                             None\n                         }\n@@ -639,16 +671,17 @@ impl Attributes {\n                             };\n                             // This is a primitive so the url is done \"by hand\".\n                             let tail = fragment.find('#').unwrap_or_else(|| fragment.len());\n-                            Some((\n-                                s.clone(),\n-                                format!(\n+                            Some(RenderedLink {\n+                                original_text: s.clone(),\n+                                new_text: link_text.clone(),\n+                                href: format!(\n                                     \"{}{}std/primitive.{}.html{}\",\n                                     url,\n                                     if !url.ends_with('/') { \"/\" } else { \"\" },\n                                     &fragment[..tail],\n                                     &fragment[tail..]\n                                 ),\n-                            ))\n+                            })\n                         } else {\n                             panic!(\"This isn't a primitive?!\");\n                         }"}, {"sha": "a8c60e4a76df4d8d38c315eb0c7e51af64ad1ff1", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 97, "deletions": 20, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -34,6 +34,7 @@ use std::fmt::Write;\n use std::ops::Range;\n use std::str;\n \n+use crate::clean::RenderedLink;\n use crate::doctest;\n use crate::html::highlight;\n use crate::html::toc::TocBuilder;\n@@ -52,7 +53,7 @@ fn opts() -> Options {\n pub struct Markdown<'a>(\n     pub &'a str,\n     /// A list of link replacements.\n-    pub &'a [(String, String)],\n+    pub &'a [RenderedLink],\n     /// The current list of used header IDs.\n     pub &'a mut IdMap,\n     /// Whether to allow the use of explicit error codes in doctest lang strings.\n@@ -78,7 +79,7 @@ pub struct MarkdownHtml<'a>(\n     pub &'a Option<Playground>,\n );\n /// A tuple struct like `Markdown` that renders only the first paragraph.\n-pub struct MarkdownSummaryLine<'a>(pub &'a str, pub &'a [(String, String)]);\n+pub struct MarkdownSummaryLine<'a>(pub &'a str, pub &'a [RenderedLink]);\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum ErrorCodes {\n@@ -337,31 +338,107 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n }\n \n /// Make headings links with anchor IDs and build up TOC.\n-struct LinkReplacer<'a, 'b, I: Iterator<Item = Event<'a>>> {\n+struct LinkReplacer<'a, I: Iterator<Item = Event<'a>>> {\n     inner: I,\n-    links: &'b [(String, String)],\n+    links: &'a [RenderedLink],\n+    shortcut_link: Option<&'a RenderedLink>,\n }\n \n-impl<'a, 'b, I: Iterator<Item = Event<'a>>> LinkReplacer<'a, 'b, I> {\n-    fn new(iter: I, links: &'b [(String, String)]) -> Self {\n-        LinkReplacer { inner: iter, links }\n+impl<'a, I: Iterator<Item = Event<'a>>> LinkReplacer<'a, I> {\n+    fn new(iter: I, links: &'a [RenderedLink]) -> Self {\n+        LinkReplacer { inner: iter, links, shortcut_link: None }\n     }\n }\n \n-impl<'a, 'b, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, 'b, I> {\n+impl<'a, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, I> {\n     type Item = Event<'a>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        let event = self.inner.next();\n-        if let Some(Event::Start(Tag::Link(kind, dest, text))) = event {\n-            if let Some(&(_, ref replace)) = self.links.iter().find(|link| link.0 == *dest) {\n-                Some(Event::Start(Tag::Link(kind, replace.to_owned().into(), text)))\n-            } else {\n-                Some(Event::Start(Tag::Link(kind, dest, text)))\n+        use pulldown_cmark::LinkType;\n+\n+        let mut event = self.inner.next();\n+\n+        // Replace intra-doc links and remove disambiguators from shortcut links (`[fn@f]`).\n+        match &mut event {\n+            // This is a shortcut link that was resolved by the broken_link_callback: `[fn@f]`\n+            // Remove any disambiguator.\n+            Some(Event::Start(Tag::Link(\n+                // [fn@f] or [fn@f][]\n+                LinkType::ShortcutUnknown | LinkType::CollapsedUnknown,\n+                dest,\n+                title,\n+            ))) => {\n+                debug!(\"saw start of shortcut link to {} with title {}\", dest, title);\n+                // If this is a shortcut link, it was resolved by the broken_link_callback.\n+                // So the URL will already be updated properly.\n+                let link = self.links.iter().find(|&link| *link.href == **dest);\n+                // Since this is an external iterator, we can't replace the inner text just yet.\n+                // Store that we saw a link so we know to replace it later.\n+                if let Some(link) = link {\n+                    trace!(\"it matched\");\n+                    assert!(self.shortcut_link.is_none(), \"shortcut links cannot be nested\");\n+                    self.shortcut_link = Some(link);\n+                }\n             }\n-        } else {\n-            event\n+            // Now that we're done with the shortcut link, don't replace any more text.\n+            Some(Event::End(Tag::Link(\n+                LinkType::ShortcutUnknown | LinkType::CollapsedUnknown,\n+                dest,\n+                _,\n+            ))) => {\n+                debug!(\"saw end of shortcut link to {}\", dest);\n+                if self.links.iter().find(|&link| *link.href == **dest).is_some() {\n+                    assert!(self.shortcut_link.is_some(), \"saw closing link without opening tag\");\n+                    self.shortcut_link = None;\n+                }\n+            }\n+            // Handle backticks in inline code blocks, but only if we're in the middle of a shortcut link.\n+            // [`fn@f`]\n+            Some(Event::Code(text)) => {\n+                trace!(\"saw code {}\", text);\n+                if let Some(link) = self.shortcut_link {\n+                    trace!(\"original text was {}\", link.original_text);\n+                    // NOTE: this only replaces if the code block is the *entire* text.\n+                    // If only part of the link has code highlighting, the disambiguator will not be removed.\n+                    // e.g. [fn@`f`]\n+                    // This is a limitation from `collect_intra_doc_links`: it passes a full link,\n+                    // and does not distinguish at all between code blocks.\n+                    // So we could never be sure we weren't replacing too much:\n+                    // [fn@my_`f`unc] is treated the same as [my_func()] in that pass.\n+                    //\n+                    // NOTE: &[1..len() - 1] is to strip the backticks\n+                    if **text == link.original_text[1..link.original_text.len() - 1] {\n+                        debug!(\"replacing {} with {}\", text, link.new_text);\n+                        *text = CowStr::Borrowed(&link.new_text);\n+                    }\n+                }\n+            }\n+            // Replace plain text in links, but only in the middle of a shortcut link.\n+            // [fn@f]\n+            Some(Event::Text(text)) => {\n+                trace!(\"saw text {}\", text);\n+                if let Some(link) = self.shortcut_link {\n+                    trace!(\"original text was {}\", link.original_text);\n+                    // NOTE: same limitations as `Event::Code`\n+                    if **text == *link.original_text {\n+                        debug!(\"replacing {} with {}\", text, link.new_text);\n+                        *text = CowStr::Borrowed(&link.new_text);\n+                    }\n+                }\n+            }\n+            // If this is a link, but not a shortcut link,\n+            // replace the URL, since the broken_link_callback was not called.\n+            Some(Event::Start(Tag::Link(_, dest, _))) => {\n+                if let Some(link) = self.links.iter().find(|&link| *link.original_text == **dest) {\n+                    *dest = CowStr::Borrowed(link.href.as_ref());\n+                }\n+            }\n+            // Anything else couldn't have been a valid Rust path, so no need to replace the text.\n+            _ => {}\n         }\n+\n+        // Yield the modified event\n+        event\n     }\n }\n \n@@ -855,8 +932,8 @@ impl Markdown<'_> {\n             return String::new();\n         }\n         let replacer = |_: &str, s: &str| {\n-            if let Some(&(_, ref replace)) = links.iter().find(|link| &*link.0 == s) {\n-                Some((replace.clone(), s.to_owned()))\n+            if let Some(link) = links.iter().find(|link| &*link.original_text == s) {\n+                Some((link.href.clone(), link.new_text.clone()))\n             } else {\n                 None\n             }\n@@ -933,8 +1010,8 @@ impl MarkdownSummaryLine<'_> {\n         }\n \n         let replacer = |_: &str, s: &str| {\n-            if let Some(&(_, ref replace)) = links.iter().find(|link| &*link.0 == s) {\n-                Some((replace.clone(), s.to_owned()))\n+            if let Some(link) = links.iter().find(|link| &*link.original_text == s) {\n+                Some((link.href.clone(), link.new_text.clone()))\n             } else {\n                 None\n             }"}, {"sha": "f095f67b54c635fe44256375b671b712398ca4df", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -63,9 +63,8 @@ use rustc_span::symbol::{sym, Symbol};\n use serde::ser::SerializeSeq;\n use serde::{Serialize, Serializer};\n \n-use crate::clean::{self, AttributesExt, Deprecation, GetDefId, SelfTy, TypeKind};\n-use crate::config::RenderInfo;\n-use crate::config::RenderOptions;\n+use crate::clean::{self, AttributesExt, Deprecation, GetDefId, RenderedLink, SelfTy, TypeKind};\n+use crate::config::{RenderInfo, RenderOptions};\n use crate::docfs::{DocFS, PathError};\n use crate::doctree;\n use crate::error::Error;\n@@ -1774,7 +1773,7 @@ fn render_markdown(\n     w: &mut Buffer,\n     cx: &Context,\n     md_text: &str,\n-    links: Vec<(String, String)>,\n+    links: Vec<RenderedLink>,\n     prefix: &str,\n     is_hidden: bool,\n ) {"}, {"sha": "5d10e2e149b32ee005f2954c9bf368b5d007033c", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -582,6 +582,9 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         let parent_node = if item.is_fake() {\n             // FIXME: is this correct?\n             None\n+        // If we're documenting the crate root itself, it has no parent. Use the root instead.\n+        } else if item.def_id.is_top_level_module() {\n+            Some(item.def_id)\n         } else {\n             let mut current = item.def_id;\n             // The immediate parent might not always be a module.\n@@ -593,6 +596,12 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     }\n                     current = parent;\n                 } else {\n+                    debug!(\n+                        \"{:?} has no parent (kind={:?}, original was {:?})\",\n+                        current,\n+                        self.cx.tcx.def_kind(current),\n+                        item.def_id\n+                    );\n                     break None;\n                 }\n             }\n@@ -697,11 +706,12 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     // This is an anchor to an element of the current page, nothing to do in here!\n                     continue;\n                 }\n-                (parts[0].to_owned(), Some(parts[1].to_owned()))\n+                (parts[0], Some(parts[1].to_owned()))\n             } else {\n-                (parts[0].to_owned(), None)\n+                (parts[0], None)\n             };\n             let resolved_self;\n+            let link_text;\n             let mut path_str;\n             let disambiguator;\n             let (mut res, mut fragment) = {\n@@ -718,6 +728,12 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     continue;\n                 }\n \n+                // We stripped `()` and `!` when parsing the disambiguator.\n+                // Add them back to be displayed, but not prefix disambiguators.\n+                link_text = disambiguator\n+                    .map(|d| d.display_for(path_str))\n+                    .unwrap_or_else(|| path_str.to_owned());\n+\n                 // In order to correctly resolve intra-doc-links we need to\n                 // pick a base AST node to work from.  If the documentation for\n                 // this module came from an inner comment (//!) then we anchor\n@@ -906,7 +922,12 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             if let Res::PrimTy(_) = res {\n                 match disambiguator {\n                     Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {\n-                        item.attrs.links.push((ori_link, None, fragment))\n+                        item.attrs.links.push(ItemLink {\n+                            link: ori_link,\n+                            link_text: path_str.to_owned(),\n+                            did: None,\n+                            fragment,\n+                        });\n                     }\n                     Some(other) => {\n                         report_mismatch(other, Disambiguator::Primitive);\n@@ -957,7 +978,12 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     }\n                 }\n                 let id = register_res(cx, res);\n-                item.attrs.links.push((ori_link, Some(id), fragment));\n+                item.attrs.links.push(ItemLink {\n+                    link: ori_link,\n+                    link_text,\n+                    did: Some(id),\n+                    fragment,\n+                });\n             }\n         }\n \n@@ -985,6 +1011,18 @@ enum Disambiguator {\n }\n \n impl Disambiguator {\n+    /// The text that should be displayed when the path is rendered as HTML.\n+    ///\n+    /// NOTE: `path` is not the original link given by the user, but a name suitable for passing to `resolve`.\n+    fn display_for(&self, path: &str) -> String {\n+        match self {\n+            // FIXME: this will have different output if the user had `m!()` originally.\n+            Self::Kind(DefKind::Macro(MacroKind::Bang)) => format!(\"{}!\", path),\n+            Self::Kind(DefKind::Fn) => format!(\"{}()\", path),\n+            _ => path.to_owned(),\n+        }\n+    }\n+\n     /// (disambiguator, path_str)\n     fn from_str(link: &str) -> Result<(Self, &str), ()> {\n         use Disambiguator::{Kind, Namespace as NS, Primitive};\n@@ -1037,7 +1075,7 @@ impl Disambiguator {\n     }\n \n     /// Return (description of the change, suggestion)\n-    fn display_for(self, path_str: &str) -> (&'static str, String) {\n+    fn suggestion_for(self, path_str: &str) -> (&'static str, String) {\n         const PREFIX: &str = \"prefix with the item kind\";\n         const FUNCTION: &str = \"add parentheses\";\n         const MACRO: &str = \"add an exclamation mark\";\n@@ -1292,7 +1330,7 @@ fn suggest_disambiguator(\n     sp: Option<rustc_span::Span>,\n     link_range: &Option<Range<usize>>,\n ) {\n-    let (action, mut suggestion) = disambiguator.display_for(path_str);\n+    let (action, mut suggestion) = disambiguator.suggestion_for(path_str);\n     let help = format!(\"to link to the {}, {}\", disambiguator.descr(), action);\n \n     if let Some(sp) = sp {"}, {"sha": "ff9049edb4f2c53b584e5323d23e542393bdf036", "filename": "src/test/mir-opt/inline/inline-compatibility.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Ftest%2Fmir-opt%2Finline%2Finline-compatibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Ftest%2Fmir-opt%2Finline%2Finline-compatibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline-compatibility.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -0,0 +1,39 @@\n+// Checks that only functions with compatible attributes are inlined.\n+//\n+// only-x86_64\n+// needs-sanitizer-address\n+// compile-flags: -Zsanitizer=address\n+\n+#![crate_type = \"lib\"]\n+#![feature(no_sanitize)]\n+#![feature(target_feature_11)]\n+\n+// EMIT_MIR inline_compatibility.inlined_target_feature.Inline.diff\n+#[target_feature(enable = \"sse2\")]\n+pub unsafe fn inlined_target_feature() {\n+    target_feature();\n+}\n+\n+// EMIT_MIR inline_compatibility.not_inlined_target_feature.Inline.diff\n+pub unsafe fn not_inlined_target_feature() {\n+    target_feature();\n+}\n+\n+// EMIT_MIR inline_compatibility.inlined_no_sanitize.Inline.diff\n+#[no_sanitize(address)]\n+pub unsafe fn inlined_no_sanitize() {\n+    no_sanitize();\n+}\n+\n+// EMIT_MIR inline_compatibility.not_inlined_no_sanitize.Inline.diff\n+pub unsafe fn not_inlined_no_sanitize() {\n+    no_sanitize();\n+}\n+\n+#[inline]\n+#[target_feature(enable = \"sse2\")]\n+pub unsafe fn target_feature() {}\n+\n+#[inline]\n+#[no_sanitize(address, memory)]\n+pub unsafe fn no_sanitize() {}"}, {"sha": "7b0ecaffdd7cb6f18b3cf14f0a70664ada5baffa", "filename": "src/test/mir-opt/inline/inline_compatibility.inlined_no_sanitize.Inline.diff", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.inlined_no_sanitize.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.inlined_no_sanitize.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.inlined_no_sanitize.Inline.diff?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -0,0 +1,25 @@\n+- // MIR for `inlined_no_sanitize` before Inline\n++ // MIR for `inlined_no_sanitize` after Inline\n+  \n+  fn inlined_no_sanitize() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-compatibility.rs:24:37: 24:37\n+      let _1: ();                          // in scope 0 at $DIR/inline-compatibility.rs:25:5: 25:18\n++     scope 1 {\n++     }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/inline-compatibility.rs:25:5: 25:18\n+-         _1 = no_sanitize() -> bb1;       // scope 0 at $DIR/inline-compatibility.rs:25:5: 25:18\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/inline-compatibility.rs:25:5: 25:16\n+-                                          // + literal: Const { ty: unsafe fn() {no_sanitize}, val: Value(Scalar(<ZST>)) }\n+-     }\n+- \n+-     bb1: {\n++         _1 = const ();                   // scope 1 at $DIR/inline-compatibility.rs:39:29: 39:31\n+          StorageDead(_1);                 // scope 0 at $DIR/inline-compatibility.rs:25:18: 25:19\n+          _0 = const ();                   // scope 0 at $DIR/inline-compatibility.rs:24:37: 26:2\n+          return;                          // scope 0 at $DIR/inline-compatibility.rs:26:2: 26:2\n+      }\n+  }\n+  "}, {"sha": "f55eae6c50a5f4855f99c06e7490b5d495844423", "filename": "src/test/mir-opt/inline/inline_compatibility.inlined_target_feature.Inline.diff", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.inlined_target_feature.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.inlined_target_feature.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.inlined_target_feature.Inline.diff?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -0,0 +1,25 @@\n+- // MIR for `inlined_target_feature` before Inline\n++ // MIR for `inlined_target_feature` after Inline\n+  \n+  fn inlined_target_feature() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-compatibility.rs:13:40: 13:40\n+      let _1: ();                          // in scope 0 at $DIR/inline-compatibility.rs:14:5: 14:21\n++     scope 1 {\n++     }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/inline-compatibility.rs:14:5: 14:21\n+-         _1 = target_feature() -> bb1;    // scope 0 at $DIR/inline-compatibility.rs:14:5: 14:21\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/inline-compatibility.rs:14:5: 14:19\n+-                                          // + literal: Const { ty: unsafe fn() {target_feature}, val: Value(Scalar(<ZST>)) }\n+-     }\n+- \n+-     bb1: {\n++         _1 = const ();                   // scope 1 at $DIR/inline-compatibility.rs:35:32: 35:34\n+          StorageDead(_1);                 // scope 0 at $DIR/inline-compatibility.rs:14:21: 14:22\n+          _0 = const ();                   // scope 0 at $DIR/inline-compatibility.rs:13:40: 15:2\n+          return;                          // scope 0 at $DIR/inline-compatibility.rs:15:2: 15:2\n+      }\n+  }\n+  "}, {"sha": "651eadc1e849ca1b56613901b67a971089e86ed2", "filename": "src/test/mir-opt/inline/inline_compatibility.not_inlined_no_sanitize.Inline.diff", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.not_inlined_no_sanitize.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.not_inlined_no_sanitize.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.not_inlined_no_sanitize.Inline.diff?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -0,0 +1,22 @@\n+- // MIR for `not_inlined_no_sanitize` before Inline\n++ // MIR for `not_inlined_no_sanitize` after Inline\n+  \n+  fn not_inlined_no_sanitize() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-compatibility.rs:29:41: 29:41\n+      let _1: ();                          // in scope 0 at $DIR/inline-compatibility.rs:30:5: 30:18\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/inline-compatibility.rs:30:5: 30:18\n+          _1 = no_sanitize() -> bb1;       // scope 0 at $DIR/inline-compatibility.rs:30:5: 30:18\n+                                           // mir::Constant\n+                                           // + span: $DIR/inline-compatibility.rs:30:5: 30:16\n+                                           // + literal: Const { ty: unsafe fn() {no_sanitize}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_1);                 // scope 0 at $DIR/inline-compatibility.rs:30:18: 30:19\n+          _0 = const ();                   // scope 0 at $DIR/inline-compatibility.rs:29:41: 31:2\n+          return;                          // scope 0 at $DIR/inline-compatibility.rs:31:2: 31:2\n+      }\n+  }\n+  "}, {"sha": "55b9edf3adc1f6b59b680173d91e69ed6c463d14", "filename": "src/test/mir-opt/inline/inline_compatibility.not_inlined_target_feature.Inline.diff", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.not_inlined_target_feature.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.not_inlined_target_feature.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.not_inlined_target_feature.Inline.diff?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -0,0 +1,22 @@\n+- // MIR for `not_inlined_target_feature` before Inline\n++ // MIR for `not_inlined_target_feature` after Inline\n+  \n+  fn not_inlined_target_feature() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-compatibility.rs:18:44: 18:44\n+      let _1: ();                          // in scope 0 at $DIR/inline-compatibility.rs:19:5: 19:21\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/inline-compatibility.rs:19:5: 19:21\n+          _1 = target_feature() -> bb1;    // scope 0 at $DIR/inline-compatibility.rs:19:5: 19:21\n+                                           // mir::Constant\n+                                           // + span: $DIR/inline-compatibility.rs:19:5: 19:19\n+                                           // + literal: Const { ty: unsafe fn() {target_feature}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_1);                 // scope 0 at $DIR/inline-compatibility.rs:19:21: 19:22\n+          _0 = const ();                   // scope 0 at $DIR/inline-compatibility.rs:18:44: 20:2\n+          return;                          // scope 0 at $DIR/inline-compatibility.rs:20:2: 20:2\n+      }\n+  }\n+  "}, {"sha": "a4db2ffc445f8f9562681bd7cecd275c9a83c78e", "filename": "src/test/rustdoc/auxiliary/intra-link-pub-use.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Ftest%2Frustdoc%2Fauxiliary%2Fintra-link-pub-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Ftest%2Frustdoc%2Fauxiliary%2Fintra-link-pub-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fintra-link-pub-use.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -0,0 +1,4 @@\n+#![crate_name = \"inner\"]\n+\n+/// Documentation, including a link to [std::ptr]\n+pub fn f() {}"}, {"sha": "26d05b484b919b73ec6b0729eecfae0038b0d815", "filename": "src/test/rustdoc/intra-link-disambiguators-removed.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Ftest%2Frustdoc%2Fintra-link-disambiguators-removed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Ftest%2Frustdoc%2Fintra-link-disambiguators-removed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-disambiguators-removed.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -0,0 +1,51 @@\n+// ignore-tidy-linelength\n+#![deny(intra_doc_link_resolution_failure)]\n+// first try backticks\n+/// Trait: [`trait@Name`], fn: [`fn@Name`], [`Name`][`macro@Name`]\n+// @has intra_link_disambiguators_removed/struct.AtDisambiguator.html\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/trait.Name.html\"][code]' \"Name\"\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/fn.Name.html\"][code]' \"Name\"\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/macro.Name.html\"][code]' \"Name\"\n+pub struct AtDisambiguator;\n+\n+/// fn: [`Name()`], macro: [`Name!`]\n+// @has intra_link_disambiguators_removed/struct.SymbolDisambiguator.html\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/fn.Name.html\"][code]' \"Name()\"\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/macro.Name.html\"][code]' \"Name!\"\n+pub struct SymbolDisambiguator;\n+\n+// Now make sure that backticks aren't added if they weren't already there\n+/// [fn@Name]\n+// @has intra_link_disambiguators_removed/trait.Name.html\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/fn.Name.html\"]' \"Name\"\n+// @!has - '//a[@href=\"../intra_link_disambiguators_removed/fn.Name.html\"][code]' \"Name\"\n+\n+// FIXME: this will turn !() into ! alone\n+/// [Name!()]\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/macro.Name.html\"]' \"Name!\"\n+pub trait Name {}\n+\n+#[allow(non_snake_case)]\n+\n+// Try collapsed reference links\n+/// [macro@Name][]\n+// @has intra_link_disambiguators_removed/fn.Name.html\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/macro.Name.html\"]' \"Name\"\n+\n+// Try links that have the same text as a generated URL\n+/// Weird URL aligned [../intra_link_disambiguators_removed/macro.Name.html][trait@Name]\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/trait.Name.html\"]' \"../intra_link_disambiguators_removed/macro.Name.html\"\n+pub fn Name() {}\n+\n+#[macro_export]\n+// Rustdoc doesn't currently handle links that have weird interspersing of inline code blocks.\n+/// [fn@Na`m`e]\n+// @has intra_link_disambiguators_removed/macro.Name.html\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/fn.Name.html\"]' \"fn@Name\"\n+\n+// It also doesn't handle any case where the code block isn't the whole link text:\n+/// [trait@`Name`]\n+// @has - '//a[@href=\"../intra_link_disambiguators_removed/trait.Name.html\"]' \"trait@Name\"\n+macro_rules! Name {\n+    () => ()\n+}"}, {"sha": "dd52249abc6d0ad27cab524bd0c82325ba7fa7e5", "filename": "src/test/rustdoc/intra-link-pub-use.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Ftest%2Frustdoc%2Fintra-link-pub-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Ftest%2Frustdoc%2Fintra-link-pub-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-pub-use.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -0,0 +1,27 @@\n+// aux-build: intra-link-pub-use.rs\n+#![deny(broken_intra_doc_links)]\n+#![crate_name = \"outer\"]\n+\n+extern crate inner;\n+\n+/// [mod@std::env] [g]\n+\n+// FIXME: This can't be tested because rustdoc doesn't show documentation on pub re-exports.\n+// Until then, comment out the `htmldocck` test.\n+// This test still does something; namely check that no incorrect errors are emitted when\n+// documenting the re-export.\n+\n+// @has outer/index.html\n+// @ has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/env/fn.var.html\"]' \"std::env\"\n+// @ has - '//a[@href=\"../outer/fn.f.html\"]' \"g\"\n+pub use f as g;\n+\n+// FIXME: same as above\n+/// [std::env]\n+extern crate self as _;\n+\n+// Make sure the documentation is actually correct by documenting an inlined re-export\n+/// [mod@std::env]\n+// @has outer/fn.f.html\n+// @has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/env/index.html\"]' \"std::env\"\n+pub use inner::f;"}, {"sha": "b01a9727852cd6123017de576661f46410477592", "filename": "src/test/ui/mir/issue-76248.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Ftest%2Fui%2Fmir%2Fissue-76248.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Ftest%2Fui%2Fmir%2Fissue-76248.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fissue-76248.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -0,0 +1,29 @@\n+// This used to ICE during codegen after MIR inlining of g into f.\n+// The root cause was a missing fold of length constant in Rvalue::Repeat.\n+// Regression test for #76248.\n+//\n+// build-pass\n+// compile-flags: -Zmir-opt-level=2\n+\n+const N: usize = 1;\n+\n+pub struct Elem<M> {\n+    pub x: [usize; N],\n+    pub m: M,\n+}\n+\n+pub fn f() -> Elem<()> {\n+    g(())\n+}\n+\n+#[inline]\n+pub fn g<M>(m: M) -> Elem<M> {\n+    Elem {\n+        x: [0; N],\n+        m,\n+    }\n+}\n+\n+pub fn main() {\n+    f();\n+}"}, {"sha": "e643a8cab5b027c19e20b131063706f55945a60a", "filename": "src/test/ui/type-alias-impl-trait/issue-72793.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-72793.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d289aeade481c03d42e7f6d31bc6b64a73cfa45/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-72793.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-72793.rs?ref=7d289aeade481c03d42e7f6d31bc6b64a73cfa45", "patch": "@@ -0,0 +1,27 @@\n+// build-pass\n+\n+// Regression test for #72793.\n+// FIXME: This still shows ICE with `-Zmir-opt-level=2`.\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait T { type Item; }\n+\n+type Alias<'a> = impl T<Item = &'a ()>;\n+\n+struct S;\n+impl<'a> T for &'a S {\n+    type Item = &'a ();\n+}\n+\n+fn filter_positive<'a>() -> Alias<'a> {\n+    &S\n+}\n+\n+fn with_positive(fun: impl Fn(Alias<'_>)) {\n+    fun(filter_positive());\n+}\n+\n+fn main() {\n+    with_positive(|_| ());\n+}"}]}