{"sha": "d227506683e846cbeb872e089d660187a7a6041f", "node_id": "C_kwDOAAsO6NoAKGQyMjc1MDY2ODNlODQ2Y2JlYjg3MmUwODlkNjYwMTg3YTdhNjA0MWY", "commit": {"author": {"name": "Ali MJ Al-Nasrawy", "email": "alimjalnasrawy@gmail.com", "date": "2022-09-17T18:35:47Z"}, "committer": {"name": "Ali MJ Al-Nasrawy", "email": "alimjalnasrawy@gmail.com", "date": "2023-01-07T10:38:38Z"}, "message": "don't normalize in astconv\n\nWe delay projection normalization to further stages in order to\nregister user type annotations before normalization in HIR typeck.\n\nThere are two consumers of astconv: ItemCtxt and FnCtxt.\nThe former already expects unnormalized types from astconv, see its\nAstConv trait impl.\nThe latter needs `RawTy` for a cleaner interface.\n\nUnfortunately astconv still needs the normalization machinery in\norder to resolve enum variants that have projections in the self type,\ne.g. `<<T as Trait>::Assoc>::StructVariant {}`.\nThis is why `AstConv::normalize_ty_2` is necessary.", "tree": {"sha": "97757eecf7d6c28f320b8cfdf1bc8601be4f713f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97757eecf7d6c28f320b8cfdf1bc8601be4f713f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d227506683e846cbeb872e089d660187a7a6041f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d227506683e846cbeb872e089d660187a7a6041f", "html_url": "https://github.com/rust-lang/rust/commit/d227506683e846cbeb872e089d660187a7a6041f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d227506683e846cbeb872e089d660187a7a6041f/comments", "author": {"login": "aliemjay", "id": 28497461, "node_id": "MDQ6VXNlcjI4NDk3NDYx", "avatar_url": "https://avatars.githubusercontent.com/u/28497461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aliemjay", "html_url": "https://github.com/aliemjay", "followers_url": "https://api.github.com/users/aliemjay/followers", "following_url": "https://api.github.com/users/aliemjay/following{/other_user}", "gists_url": "https://api.github.com/users/aliemjay/gists{/gist_id}", "starred_url": "https://api.github.com/users/aliemjay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aliemjay/subscriptions", "organizations_url": "https://api.github.com/users/aliemjay/orgs", "repos_url": "https://api.github.com/users/aliemjay/repos", "events_url": "https://api.github.com/users/aliemjay/events{/privacy}", "received_events_url": "https://api.github.com/users/aliemjay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aliemjay", "id": 28497461, "node_id": "MDQ6VXNlcjI4NDk3NDYx", "avatar_url": "https://avatars.githubusercontent.com/u/28497461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aliemjay", "html_url": "https://github.com/aliemjay", "followers_url": "https://api.github.com/users/aliemjay/followers", "following_url": "https://api.github.com/users/aliemjay/following{/other_user}", "gists_url": "https://api.github.com/users/aliemjay/gists{/gist_id}", "starred_url": "https://api.github.com/users/aliemjay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aliemjay/subscriptions", "organizations_url": "https://api.github.com/users/aliemjay/orgs", "repos_url": "https://api.github.com/users/aliemjay/repos", "events_url": "https://api.github.com/users/aliemjay/events{/privacy}", "received_events_url": "https://api.github.com/users/aliemjay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93bf84c9021350608607330175d0513f71f0f967", "url": "https://api.github.com/repos/rust-lang/rust/commits/93bf84c9021350608607330175d0513f71f0f967", "html_url": "https://github.com/rust-lang/rust/commit/93bf84c9021350608607330175d0513f71f0f967"}], "stats": {"total": 633, "additions": 376, "deletions": 257}, "files": [{"sha": "bcb695cc8e3c2ad52ae12e7d067b8c6b9b567e4b", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -106,11 +106,9 @@ pub trait AstConv<'tcx> {\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Ty<'tcx>;\n \n-    /// Normalize an associated type coming from the user.\n-    ///\n-    /// This should only be used by astconv. Use `FnCtxt::normalize`\n-    /// or `ObligationCtxt::normalize` in downstream crates.\n-    fn normalize_ty(&self, span: Span, ty: Ty<'tcx>) -> Ty<'tcx>;\n+    fn normalize_ty_2(&self, _span: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        ty\n+    }\n \n     /// Invoked when we encounter an error from some prior pass\n     /// (e.g., resolve) that is translated into a ty-error. This is\n@@ -485,14 +483,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 // Avoid ICE #86756 when type error recovery goes awry.\n                                 return tcx.ty_error().into();\n                             }\n-                            self.astconv\n-                                .normalize_ty(\n-                                    self.span,\n-                                    tcx.at(self.span)\n-                                        .bound_type_of(param.def_id)\n-                                        .subst(tcx, substs),\n-                                )\n-                                .into()\n+                            tcx.at(self.span).bound_type_of(param.def_id).subst(tcx, substs).into()\n                         } else if infer_args {\n                             self.astconv.ty_infer(Some(param), self.span).into()\n                         } else {\n@@ -1254,7 +1245,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         item_segment: &hir::PathSegment<'_>,\n     ) -> Ty<'tcx> {\n         let substs = self.ast_path_substs_for_ty(span, did, item_segment);\n-        self.normalize_ty(span, self.tcx().at(span).bound_type_of(did).subst(self.tcx(), substs))\n+        self.tcx().at(span).bound_type_of(did).subst(self.tcx(), substs)\n     }\n \n     fn conv_object_ty_poly_trait_ref(\n@@ -1786,7 +1777,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Ok(bound)\n     }\n \n-    // Create a type from a path to an associated type.\n+    // Create a type from a path to an associated type or to an enum variant.\n     // For a path `A::B::C::D`, `qself_ty` and `qself_def` are the type and def for `A::B::C`\n     // and item_segment is the path segment for `D`. We return a type and a def for\n     // the whole path.\n@@ -1814,7 +1805,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         // Check if we have an enum variant.\n         let mut variant_resolution = None;\n-        if let ty::Adt(adt_def, adt_substs) = qself_ty.kind() {\n+        if let ty::Adt(adt_def, adt_substs) = self.normalize_ty_2(span, qself_ty).kind() {\n             if adt_def.is_enum() {\n                 let variant_def = adt_def\n                     .variants()\n@@ -1923,7 +1914,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     adt_substs,\n                 );\n                 let ty = tcx.bound_type_of(assoc_ty_did).subst(tcx, item_substs);\n-                let ty = self.normalize_ty(span, ty);\n                 return Ok((ty, DefKind::AssocTy, assoc_ty_did));\n             }\n         }\n@@ -2020,7 +2010,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         };\n \n         let ty = self.projected_ty_from_poly_trait_ref(span, assoc_ty_did, assoc_segment, bound);\n-        let ty = self.normalize_ty(span, ty);\n \n         if let Some(variant_def_id) = variant_resolution {\n             tcx.struct_span_lint_hir(\n@@ -2156,7 +2145,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         debug!(\"qpath_to_ty: trait_ref={:?}\", trait_ref);\n \n-        self.normalize_ty(span, tcx.mk_projection(item_def_id, item_substs))\n+        tcx.mk_projection(item_def_id, item_substs)\n     }\n \n     pub fn prohibit_generics<'a>(\n@@ -2417,7 +2406,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     err.note(\"`impl Trait` types can't have type parameters\");\n                 });\n                 let substs = self.ast_path_substs_for_ty(span, did, item_segment.0);\n-                self.normalize_ty(span, tcx.mk_opaque(did, substs))\n+                tcx.mk_opaque(did, substs)\n             }\n             Res::Def(\n                 DefKind::Enum\n@@ -2577,7 +2566,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                     tcx.ty_error_with_guaranteed(err.emit())\n                 } else {\n-                    self.normalize_ty(span, ty)\n+                    ty\n                 }\n             }\n             Res::Def(DefKind::AssocTy, def_id) => {\n@@ -2720,8 +2709,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     None,\n                     ty::BoundConstness::NotConst,\n                 );\n-                EarlyBinder(self.normalize_ty(span, tcx.at(span).type_of(def_id)))\n-                    .subst(tcx, substs)\n+                EarlyBinder(tcx.at(span).type_of(def_id)).subst(tcx, substs)\n             }\n             hir::TyKind::Array(ref ty, ref length) => {\n                 let length = match length {\n@@ -2731,8 +2719,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                 };\n \n-                let array_ty = tcx.mk_ty(ty::Array(self.ast_ty_to_ty(ty), length));\n-                self.normalize_ty(ast_ty.span, array_ty)\n+                tcx.mk_ty(ty::Array(self.ast_ty_to_ty(ty), length))\n             }\n             hir::TyKind::Typeof(ref e) => {\n                 let ty_erased = tcx.type_of(e.def_id);"}, {"sha": "fd54aec480ab61a67e0e2d291f173479da1be7f3", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -505,11 +505,6 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n         }\n     }\n \n-    fn normalize_ty(&self, _span: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        // Types in item signatures are not normalized to avoid undue dependencies.\n-        ty\n-    }\n-\n     fn set_tainted_by_errors(&self, _: ErrorGuaranteed) {\n         // There's no obvious place to track this, so just let it go.\n     }"}, {"sha": "399702fd41abcdabbeb055e5629452d6ddc3f0e8", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -647,14 +647,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ),\n             bound_vars,\n         );\n-        // Astconv can't normalize inputs or outputs with escaping bound vars,\n-        // so normalize them here, after we've wrapped them in a binder.\n-        let result = self.normalize(self.tcx.hir().span(hir_id), result);\n \n         let c_result = self.inh.infcx.canonicalize_response(result);\n         self.typeck_results.borrow_mut().user_provided_sigs.insert(expr_def_id, c_result);\n \n-        result\n+        // Normalize only after registering in `user_provided_sigs`.\n+        self.normalize(self.tcx.hir().span(hir_id), result)\n     }\n \n     /// Invoked when we are translating the generator that results"}, {"sha": "3e05f67b74bc8844935f5dc76f2d479b94e7b89d", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -1,7 +1,7 @@\n use crate::callee::{self, DeferredCallResolution};\n use crate::method::{self, MethodCallee, SelfSource};\n use crate::rvalue_scopes;\n-use crate::{BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy};\n+use crate::{BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy, RawTy};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, Diagnostic, ErrorGuaranteed, MultiSpan};\n@@ -410,23 +410,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn to_ty(&self, ast_t: &hir::Ty<'_>) -> Ty<'tcx> {\n+    pub fn create_raw_ty(&self, span: Span, ty: Ty<'tcx>) -> RawTy<'tcx> {\n+        RawTy { raw: ty, normalized: self.normalize(span, ty) }\n+    }\n+\n+    pub fn to_ty(&self, ast_t: &hir::Ty<'_>) -> RawTy<'tcx> {\n         let t = <dyn AstConv<'_>>::ast_ty_to_ty(self, ast_t);\n         self.register_wf_obligation(t.into(), ast_t.span, traits::WellFormed(None));\n-        t\n+        self.create_raw_ty(ast_t.span, t)\n     }\n \n     pub fn to_ty_saving_user_provided_ty(&self, ast_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n         let ty = self.to_ty(ast_ty);\n         debug!(\"to_ty_saving_user_provided_ty: ty={:?}\", ty);\n \n-        if Self::can_contain_user_lifetime_bounds(ty) {\n-            let c_ty = self.canonicalize_response(UserType::Ty(ty));\n+        if Self::can_contain_user_lifetime_bounds(ty.raw) {\n+            let c_ty = self.canonicalize_response(UserType::Ty(ty.raw));\n             debug!(\"to_ty_saving_user_provided_ty: c_ty={:?}\", c_ty);\n             self.typeck_results.borrow_mut().user_provided_types_mut().insert(ast_ty.hir_id, c_ty);\n         }\n \n-        ty\n+        ty.normalized\n     }\n \n     pub fn array_length_to_const(&self, length: &hir::ArrayLen) -> ty::Const<'tcx> {\n@@ -780,7 +784,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         qpath: &'tcx QPath<'tcx>,\n         hir_id: hir::HirId,\n         span: Span,\n-    ) -> (Res, Option<Ty<'tcx>>, &'tcx [hir::PathSegment<'tcx>]) {\n+    ) -> (Res, Option<RawTy<'tcx>>, &'tcx [hir::PathSegment<'tcx>]) {\n         debug!(\n             \"resolve_ty_and_res_fully_qualified_call: qpath={:?} hir_id={:?} span={:?}\",\n             qpath, hir_id, span\n@@ -803,23 +807,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // to be object-safe.\n                 // We manually call `register_wf_obligation` in the success path\n                 // below.\n-                (<dyn AstConv<'_>>::ast_ty_to_ty_in_path(self, qself), qself, segment)\n+                let ty = <dyn AstConv<'_>>::ast_ty_to_ty_in_path(self, qself);\n+                (self.create_raw_ty(span, ty), qself, segment)\n             }\n             QPath::LangItem(..) => {\n                 bug!(\"`resolve_ty_and_res_fully_qualified_call` called on `LangItem`\")\n             }\n         };\n         if let Some(&cached_result) = self.typeck_results.borrow().type_dependent_defs().get(hir_id)\n         {\n-            self.register_wf_obligation(ty.into(), qself.span, traits::WellFormed(None));\n+            self.register_wf_obligation(ty.raw.into(), qself.span, traits::WellFormed(None));\n             // Return directly on cache hit. This is useful to avoid doubly reporting\n             // errors with default match binding modes. See #44614.\n             let def = cached_result.map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id));\n             return (def, Some(ty), slice::from_ref(&**item_segment));\n         }\n         let item_name = item_segment.ident;\n         let result = self\n-            .resolve_fully_qualified_call(span, item_name, ty, qself.span, hir_id)\n+            .resolve_fully_qualified_call(span, item_name, ty.normalized, qself.span, hir_id)\n             .or_else(|error| {\n                 let result = match error {\n                     method::MethodError::PrivateMatch(kind, def_id, _) => Ok((kind, def_id)),\n@@ -830,13 +835,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // a WF obligation for `dyn MyTrait` when method lookup fails. Otherwise,\n                 // register a WF obligation so that we can detect any additional\n                 // errors in the self type.\n-                if !(matches!(error, method::MethodError::NoMatch(_)) && ty.is_trait()) {\n-                    self.register_wf_obligation(ty.into(), qself.span, traits::WellFormed(None));\n+                if !(matches!(error, method::MethodError::NoMatch(_)) && ty.normalized.is_trait()) {\n+                    self.register_wf_obligation(\n+                        ty.raw.into(),\n+                        qself.span,\n+                        traits::WellFormed(None),\n+                    );\n                 }\n                 if item_name.name != kw::Empty {\n                     if let Some(mut e) = self.report_method_error(\n                         span,\n-                        ty,\n+                        ty.normalized,\n                         item_name,\n                         SelfSource::QPath(qself),\n                         error,\n@@ -849,7 +858,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             });\n \n         if result.is_ok() {\n-            self.register_wf_obligation(ty.into(), qself.span, traits::WellFormed(None));\n+            self.register_wf_obligation(ty.raw.into(), qself.span, traits::WellFormed(None));\n         }\n \n         // Write back the new resolution.\n@@ -986,7 +995,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn instantiate_value_path(\n         &self,\n         segments: &[hir::PathSegment<'_>],\n-        self_ty: Option<Ty<'tcx>>,\n+        self_ty: Option<RawTy<'tcx>>,\n         res: Res,\n         span: Span,\n         hir_id: hir::HirId,\n@@ -996,7 +1005,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let path_segs = match res {\n             Res::Local(_) | Res::SelfCtor(_) => vec![],\n             Res::Def(kind, def_id) => <dyn AstConv<'_>>::def_ids_for_value_path_segments(\n-                self, segments, self_ty, kind, def_id,\n+                self,\n+                segments,\n+                self_ty.map(|ty| ty.normalized),\n+                kind,\n+                def_id,\n             ),\n             _ => bug!(\"instantiate_value_path on {:?}\", res),\n         };\n@@ -1007,8 +1020,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Res::Def(DefKind::Ctor(CtorOf::Variant, _), _)\n                 if let Some(self_ty) = self_ty =>\n             {\n-                let adt_def = self_ty.ty_adt_def().unwrap();\n-                user_self_ty = Some(UserSelfTy { impl_def_id: adt_def.did(), self_ty });\n+                let adt_def = self_ty.normalized.ty_adt_def().unwrap();\n+                user_self_ty = Some(UserSelfTy { impl_def_id: adt_def.did(), self_ty: self_ty.raw });\n                 is_alias_variant_ctor = true;\n             }\n             Res::Def(DefKind::AssocFn | DefKind::AssocConst, def_id) => {\n@@ -1027,7 +1040,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // inherent impl, we need to record the\n                             // `T` for posterity (see `UserSelfTy` for\n                             // details).\n-                            let self_ty = self_ty.expect(\"UFCS sugared assoc missing Self\");\n+                            let self_ty = self_ty.expect(\"UFCS sugared assoc missing Self\").raw;\n                             user_self_ty = Some(UserSelfTy { impl_def_id: container_id, self_ty });\n                         }\n                     }\n@@ -1109,7 +1122,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .unwrap_or(false);\n \n         let (res, self_ctor_substs) = if let Res::SelfCtor(impl_def_id) = res {\n-            let ty = self.normalize_ty(span, tcx.at(span).type_of(impl_def_id));\n+            let ty = self.normalize_ty_2(span, tcx.at(span).type_of(impl_def_id));\n             match *ty.kind() {\n                 ty::Adt(adt_def, substs) if adt_def.has_ctor() => {\n                     let variant = adt_def.non_enum_variant();\n@@ -1193,7 +1206,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         <dyn AstConv<'_>>::ast_region_to_region(self.fcx, lt, Some(param)).into()\n                     }\n                     (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n-                        self.fcx.to_ty(ty).into()\n+                        self.fcx.to_ty(ty).raw.into()\n                     }\n                     (GenericParamDefKind::Const { .. }, GenericArg::Const(ct)) => {\n                         self.fcx.const_arg_to_const(&ct.value, param.def_id).into()\n@@ -1227,7 +1240,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // is missing.\n                             let default = tcx.bound_type_of(param.def_id);\n                             self.fcx\n-                                .normalize_ty(self.span, default.subst(tcx, substs.unwrap()))\n+                                .normalize_ty_2(self.span, default.subst(tcx, substs.unwrap()))\n                                 .into()\n                         } else {\n                             // If no type arguments were provided, we have to infer them.\n@@ -1250,13 +1263,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        let substs = self_ctor_substs.unwrap_or_else(|| {\n+        let substs_raw = self_ctor_substs.unwrap_or_else(|| {\n             <dyn AstConv<'_>>::create_substs_for_generic_args(\n                 tcx,\n                 def_id,\n                 &[],\n                 has_self,\n-                self_ty,\n+                self_ty.map(|s| s.raw),\n                 &arg_count,\n                 &mut CreateCtorSubstsContext {\n                     fcx: self,\n@@ -1269,7 +1282,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         });\n \n         // First, store the \"user substs\" for later.\n-        self.write_user_type_annotation_from_substs(hir_id, def_id, substs, user_self_ty);\n+        self.write_user_type_annotation_from_substs(hir_id, def_id, substs_raw, user_self_ty);\n+\n+        // Normalize only after registering type annotations.\n+        let substs = self.normalize(span, substs_raw);\n \n         self.add_required_obligations_for_hir(span, def_id, &substs, hir_id);\n \n@@ -1287,6 +1303,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // with the substituted impl type.\n             // This also occurs for an enum variant on a type alias.\n             let impl_ty = self.normalize(span, tcx.bound_type_of(impl_def_id).subst(tcx, substs));\n+            let self_ty = self.normalize(span, self_ty);\n             match self.at(&self.misc(span), self.param_env).eq(impl_ty, self_ty) {\n                 Ok(ok) => self.register_infer_ok_obligations(ok),\n                 Err(_) => {"}, {"sha": "6a822568775bd3980ee55ec9d4af352737e4e023", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -5,7 +5,7 @@ use crate::method::MethodCallee;\n use crate::Expectation::*;\n use crate::TupleArgumentsFlag::*;\n use crate::{\n-    struct_span_err, BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy, Needs,\n+    struct_span_err, BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy, Needs, RawTy,\n     TupleArgumentsFlag,\n };\n use rustc_ast as ast;\n@@ -1231,13 +1231,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n                 return None;\n             }\n-            Res::Def(DefKind::Variant, _) => match ty.kind() {\n+            Res::Def(DefKind::Variant, _) => match ty.normalized.kind() {\n                 ty::Adt(adt, substs) => Some((adt.variant_of_res(def), adt.did(), substs)),\n-                _ => bug!(\"unexpected type: {:?}\", ty),\n+                _ => bug!(\"unexpected type: {:?}\", ty.normalized),\n             },\n             Res::Def(DefKind::Struct | DefKind::Union | DefKind::TyAlias | DefKind::AssocTy, _)\n             | Res::SelfTyParam { .. }\n-            | Res::SelfTyAlias { .. } => match ty.kind() {\n+            | Res::SelfTyAlias { .. } => match ty.normalized.kind() {\n                 ty::Adt(adt, substs) if !adt.is_enum() => {\n                     Some((adt.non_enum_variant(), adt.did(), substs))\n                 }\n@@ -1248,14 +1248,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if let Some((variant, did, substs)) = variant {\n             debug!(\"check_struct_path: did={:?} substs={:?}\", did, substs);\n-            self.write_user_type_annotation_from_substs(hir_id, did, substs, None);\n+\n+            // FIXME(aliemjay): We're using UserSelfTy unconditionally here because it is the only\n+            // way to register the raw user ty, because `substs` is normalized.\n+            let self_ty = ty::UserSelfTy { impl_def_id: did, self_ty: ty.raw };\n+            self.write_user_type_annotation_from_substs(hir_id, did, substs, Some(self_ty));\n \n             // Check bounds on type arguments used in the path.\n             self.add_required_obligations_for_hir(path_span, did, substs, hir_id);\n \n-            Some((variant, ty))\n+            Some((variant, ty.normalized))\n         } else {\n-            match ty.kind() {\n+            match ty.normalized.kind() {\n                 ty::Error(_) => {\n                     // E0071 might be caused by a spelling error, which will have\n                     // already caused an error message and probably a suggestion\n@@ -1268,7 +1272,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         path_span,\n                         E0071,\n                         \"expected struct, variant or union type, found {}\",\n-                        ty.sort_string(self.tcx)\n+                        ty.normalized.sort_string(self.tcx)\n                     )\n                     .span_label(path_span, \"not a struct\")\n                     .emit();\n@@ -1656,20 +1660,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         qpath: &QPath<'_>,\n         path_span: Span,\n         hir_id: hir::HirId,\n-    ) -> (Res, Ty<'tcx>) {\n+    ) -> (Res, RawTy<'tcx>) {\n         match *qpath {\n             QPath::Resolved(ref maybe_qself, ref path) => {\n-                let self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself));\n+                let self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself).raw);\n                 let ty = <dyn AstConv<'_>>::res_to_ty(self, self_ty, path, true);\n-                (path.res, ty)\n+                (path.res, self.create_raw_ty(path_span, ty))\n             }\n             QPath::TypeRelative(ref qself, ref segment) => {\n                 let ty = self.to_ty(qself);\n \n                 let result = <dyn AstConv<'_>>::associated_path_to_ty(\n-                    self, hir_id, path_span, ty, qself, segment, true,\n+                    self, hir_id, path_span, ty.raw, qself, segment, true,\n                 );\n                 let ty = result.map(|(ty, _, _)| ty).unwrap_or_else(|_| self.tcx().ty_error());\n+                let ty = self.create_raw_ty(path_span, ty);\n                 let result = result.map(|(_, kind, def_id)| (kind, def_id));\n \n                 // Write back the new resolution.\n@@ -1678,7 +1683,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (result.map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id)), ty)\n             }\n             QPath::LangItem(lang_item, span, id) => {\n-                self.resolve_lang_item_path(lang_item, span, hir_id, id)\n+                let (res, ty) = self.resolve_lang_item_path(lang_item, span, hir_id, id);\n+                (res, self.create_raw_ty(path_span, ty))\n             }\n         }\n     }"}, {"sha": "d7e53a0aa04771b9ab9d1dce83cac89a63ad7fa1", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -17,8 +17,7 @@ use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Const, Ty, TyCtxt, TypeVisitable};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n use rustc_span::{self, Span};\n@@ -298,7 +297,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         self.tcx().mk_projection(item_def_id, item_substs)\n     }\n \n-    fn normalize_ty(&self, span: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    fn normalize_ty_2(&self, span: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n         if ty.has_escaping_bound_vars() {\n             ty // FIXME: normalization and escaping regions\n         } else {\n@@ -310,7 +309,19 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         self.infcx.set_tainted_by_errors(e)\n     }\n \n-    fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, _span: Span) {\n-        self.write_ty(hir_id, ty)\n+    fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, span: Span) {\n+        self.write_ty(hir_id, self.normalize_ty_2(span, ty))\n     }\n }\n+\n+/// Represents a user-provided type in the raw form (never normalized).\n+///\n+/// This is a bridge between the interface of `AstConv`, which outputs a raw `Ty`,\n+/// and the API in this module, which expect `Ty` to be fully normalized.\n+#[derive(Clone, Copy, Debug)]\n+pub struct RawTy<'tcx> {\n+    pub raw: Ty<'tcx>,\n+\n+    /// The normalized form of `raw`, stored here for efficiency.\n+    pub normalized: Ty<'tcx>,\n+}"}, {"sha": "15dd3412c34093e062eb5b74aa36a77fd5a3010a", "filename": "compiler/rustc_hir_typeck/src/gather_locals.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_hir_typeck%2Fsrc%2Fgather_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_hir_typeck%2Fsrc%2Fgather_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgather_locals.rs?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -77,15 +77,16 @@ impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n             Some(ref ty) => {\n                 let o_ty = self.fcx.to_ty(&ty);\n \n-                let c_ty = self.fcx.inh.infcx.canonicalize_user_type_annotation(UserType::Ty(o_ty));\n+                let c_ty =\n+                    self.fcx.inh.infcx.canonicalize_user_type_annotation(UserType::Ty(o_ty.raw));\n                 debug!(\"visit_local: ty.hir_id={:?} o_ty={:?} c_ty={:?}\", ty.hir_id, o_ty, c_ty);\n                 self.fcx\n                     .typeck_results\n                     .borrow_mut()\n                     .user_provided_types_mut()\n                     .insert(ty.hir_id, c_ty);\n \n-                Some(LocalTy { decl_ty: o_ty, revealed_ty: o_ty })\n+                Some(LocalTy { decl_ty: o_ty.normalized, revealed_ty: o_ty.normalized })\n             }\n             None => None,\n         };"}, {"sha": "69929589541f5e0de0078c64806dc79bea8cdb96", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -297,7 +297,7 @@ fn typeck_with_fallback<'tcx>(\n         fcx.resolve_generator_interiors(def_id.to_def_id());\n \n         for (ty, span, code) in fcx.deferred_sized_obligations.borrow_mut().drain(..) {\n-            let ty = fcx.normalize_ty(span, ty);\n+            let ty = fcx.normalize(span, ty);\n             fcx.require_type_is_sized(ty, span, code);\n         }\n "}, {"sha": "f2a41720b605d32f42ba8a3fb61e082ba9c73ec5", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -372,7 +372,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                             .into()\n                     }\n                     (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n-                        self.cfcx.to_ty(ty).into()\n+                        self.cfcx.to_ty(ty).raw.into()\n                     }\n                     (GenericParamDefKind::Const { .. }, GenericArg::Const(ct)) => {\n                         self.cfcx.const_arg_to_const(&ct.value, param.def_id).into()\n@@ -397,15 +397,17 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 self.cfcx.var_for_def(self.cfcx.span, param)\n             }\n         }\n-        <dyn AstConv<'_>>::create_substs_for_generic_args(\n+        let substs = <dyn AstConv<'_>>::create_substs_for_generic_args(\n             self.tcx,\n             pick.item.def_id,\n             parent_substs,\n             false,\n             None,\n             &arg_count_correct,\n             &mut MethodSubstsCtxt { cfcx: self, pick, seg },\n-        )\n+        );\n+        // FIXME(aliemjay): Type annotation should be registered before normalization.\n+        self.normalize(self.span, substs)\n     }\n \n     fn unify_receivers("}, {"sha": "1075378a1595549b4fcef2d7f208406ebd576633", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -1,4 +1,4 @@\n-use crate::FnCtxt;\n+use crate::{FnCtxt, RawTy};\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{\n@@ -842,7 +842,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         pat: &Pat<'tcx>,\n         qpath: &hir::QPath<'_>,\n-        path_resolution: (Res, Option<Ty<'tcx>>, &'tcx [hir::PathSegment<'tcx>]),\n+        path_resolution: (Res, Option<RawTy<'tcx>>, &'tcx [hir::PathSegment<'tcx>]),\n         expected: Ty<'tcx>,\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {"}, {"sha": "f6eca97743035da69a77b72861426d5d1022f5ce", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -91,6 +91,7 @@ pub fn type_op_ascribe_user_type_with_span<'tcx>(\n     }\n \n     if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n+        let self_ty = ocx.normalize(&cause, param_env, self_ty);\n         let impl_self_ty = tcx.bound_type_of(impl_def_id).subst(tcx, substs);\n         let impl_self_ty = ocx.normalize(&cause, param_env, impl_self_ty);\n "}, {"sha": "7b9b9701ff115e5bb3d2b8dd06f2d9951f352655", "filename": "src/test/ui/const-generics/issue-97007.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fconst-generics%2Fissue-97007.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fconst-generics%2Fissue-97007.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-97007.rs?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -1,4 +1,8 @@\n-// check-pass\n+//~ ERROR broken MIR\n+\n+// known-bug\n+// failure-status: 101\n+// rustc-env: RUSTC_BACKTRACE=0\n \n #![feature(adt_const_params, generic_const_exprs)]\n #![allow(incomplete_features)]"}, {"sha": "adc0cb4e0423f2e5db414a7a649e0eea3c3e95d5", "filename": "src/test/ui/generic-associated-types/issue-91139.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.rs?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -14,14 +14,6 @@ fn foo<T>() {\n     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n     //~^ ERROR `T` does not live long enough\n     //~| ERROR `T` does not live long enough\n-    //~| ERROR `T` does not live long enough\n-    //~| ERROR `T` does not live long enough\n-    //~| ERROR `T` does not live long enough\n-    //~| ERROR `T` does not live long enough\n-    //~| ERROR `T` does not live long enough\n-    //~| ERROR `T` does not live long enough\n-    //~| ERROR `T` may not live long enough\n-    //~| ERROR `T` may not live long enough\n     //\n     // FIXME: This error is bogus, but it arises because we try to validate\n     // that `<() as Foo<T>>::Type<'a>` is valid, which requires proving"}, {"sha": "d9d76adfbb55280b154fd576501b4b9fccc7f96a", "filename": "src/test/ui/generic-associated-types/issue-91139.stderr", "status": "modified", "additions": 1, "deletions": 60, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.stderr?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -10,64 +10,5 @@ error: `T` does not live long enough\n LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: `T` does not live long enough\n-  --> $DIR/issue-91139.rs:14:12\n-   |\n-LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: `T` does not live long enough\n-  --> $DIR/issue-91139.rs:14:12\n-   |\n-LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/issue-91139.rs:14:58\n-   |\n-LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n-   |                                                          ^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n-   |\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL | fn foo<T: 'static>() {\n-   |         +++++++++\n-\n-error: `T` does not live long enough\n-  --> $DIR/issue-91139.rs:14:58\n-   |\n-LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n-   |                                                          ^^^^^^^^^\n-\n-error: `T` does not live long enough\n-  --> $DIR/issue-91139.rs:14:58\n-   |\n-LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n-   |                                                          ^^^^^^^^^\n-\n-error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/issue-91139.rs:14:58\n-   |\n-LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n-   |                                                          ^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n-   |\n-help: consider adding an explicit lifetime bound...\n-   |\n-LL | fn foo<T: 'static>() {\n-   |         +++++++++\n-\n-error: `T` does not live long enough\n-  --> $DIR/issue-91139.rs:14:58\n-   |\n-LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n-   |                                                          ^^^^^^^^^\n-\n-error: `T` does not live long enough\n-  --> $DIR/issue-91139.rs:14:58\n-   |\n-LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n-   |                                                          ^^^^^^^^^\n-\n-error: aborting due to 10 previous errors\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0310`."}, {"sha": "8aa29926d4f9b2b15ca0f6dbdecdb7dd6b989b42", "filename": "src/test/ui/higher-rank-trait-bounds/normalize-under-binder/issue-85455.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.rs?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -7,6 +7,7 @@ trait SomeTrait<'a> {\n fn give_me_ice<T>() {\n     callee::<fn(&()) -> <T as SomeTrait<'_>>::Associated>();\n     //~^ ERROR the trait bound `for<'a> T: SomeTrait<'a>` is not satisfied [E0277]\n+    //~| ERROR the trait bound `for<'a> T: SomeTrait<'a>` is not satisfied [E0277]\n }\n \n fn callee<T: Fn<(&'static (),)>>() {"}, {"sha": "3240518fbbe0808447ca8fe4f15ed5fca7e24efa", "filename": "src/test/ui/higher-rank-trait-bounds/normalize-under-binder/issue-85455.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.stderr?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -1,3 +1,14 @@\n+error[E0277]: the trait bound `for<'a> T: SomeTrait<'a>` is not satisfied\n+  --> $DIR/issue-85455.rs:8:14\n+   |\n+LL |     callee::<fn(&()) -> <T as SomeTrait<'_>>::Associated>();\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `for<'a> SomeTrait<'a>` is not implemented for `T`\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn give_me_ice<T: for<'a> SomeTrait<'a>>() {\n+   |                 +++++++++++++++++++++++\n+\n error[E0277]: the trait bound `for<'a> T: SomeTrait<'a>` is not satisfied\n   --> $DIR/issue-85455.rs:8:5\n    |\n@@ -9,6 +20,6 @@ help: consider restricting type parameter `T`\n LL | fn give_me_ice<T: for<'a> SomeTrait<'a>>() {\n    |                 +++++++++++++++++++++++\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "260c16c17d4a2b8c662abc1f27c47be07072b727", "filename": "src/test/ui/nll/closure-malformed-projection-input-issue-102800.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fnll%2Fclosure-malformed-projection-input-issue-102800.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fnll%2Fclosure-malformed-projection-input-issue-102800.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-malformed-projection-input-issue-102800.rs?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -16,16 +16,6 @@ impl Trait for &'static () {\n \n fn main() {\n     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-    //~^ ERROR lifetime may not live long enough\n-    //~| ERROR higher-ranked subtype error\n-    //~| ERROR higher-ranked subtype error\n-    //~| ERROR implementation of `Trait` is not general enough\n-    //~| ERROR implementation of `Trait` is not general enough\n-    //~| ERROR implementation of `Trait` is not general enough\n-    //~| ERROR implementation of `Trait` is not general enough\n-    //~| ERROR implementation of `Trait` is not general enough\n-    //~| ERROR implementation of `Trait` is not general enough\n-    //~| ERROR implementation of `Trait` is not general enough\n-    //~| ERROR implementation of `Trait` is not general enough\n+    //~^ ERROR implementation of `Trait` is not general enough\n     //~| ERROR implementation of `Trait` is not general enough\n }"}, {"sha": "46dba0064339ff783c19d7229a80afe878565d53", "filename": "src/test/ui/nll/closure-malformed-projection-input-issue-102800.stderr", "status": "modified", "additions": 1, "deletions": 85, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fnll%2Fclosure-malformed-projection-input-issue-102800.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fnll%2Fclosure-malformed-projection-input-issue-102800.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-malformed-projection-input-issue-102800.stderr?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -1,51 +1,3 @@\n-error: lifetime may not live long enough\n-  --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:48\n-   |\n-LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-   |                                                ^-^\n-   |                                                ||\n-   |                                                |has type `<&'1 () as Trait>::Ty`\n-   |                                                requires that `'1` must outlive `'static`\n-\n-error: higher-ranked subtype error\n-  --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:48\n-   |\n-LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-   |                                                ^^^\n-\n-error: higher-ranked subtype error\n-  --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:48\n-   |\n-LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-   |                                                ^^^\n-\n-error: implementation of `Trait` is not general enough\n-  --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:48\n-   |\n-LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-   |                                                ^^^^^^ implementation of `Trait` is not general enough\n-   |\n-   = note: `&'0 ()` must implement `Trait`, for any lifetime `'0`...\n-   = note: ...but `Trait` is actually implemented for the type `&'static ()`\n-\n-error: implementation of `Trait` is not general enough\n-  --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:12\n-   |\n-LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Trait` is not general enough\n-   |\n-   = note: `&'0 ()` must implement `Trait`, for any lifetime `'0`...\n-   = note: ...but `Trait` is actually implemented for the type `&'static ()`\n-\n-error: implementation of `Trait` is not general enough\n-  --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:12\n-   |\n-LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Trait` is not general enough\n-   |\n-   = note: `&'0 ()` must implement `Trait`, for any lifetime `'0`...\n-   = note: ...but `Trait` is actually implemented for the type `&'static ()`\n-\n error: implementation of `Trait` is not general enough\n   --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:12\n    |\n@@ -64,41 +16,5 @@ LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n    = note: `&'0 ()` must implement `Trait`, for any lifetime `'0`...\n    = note: ...but `Trait` is actually implemented for the type `&'static ()`\n \n-error: implementation of `Trait` is not general enough\n-  --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:48\n-   |\n-LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-   |                                                ^^^^^^ implementation of `Trait` is not general enough\n-   |\n-   = note: `&'0 ()` must implement `Trait`, for any lifetime `'0`...\n-   = note: ...but `Trait` is actually implemented for the type `&'static ()`\n-\n-error: implementation of `Trait` is not general enough\n-  --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:48\n-   |\n-LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-   |                                                ^^^^^^ implementation of `Trait` is not general enough\n-   |\n-   = note: `&'0 ()` must implement `Trait`, for any lifetime `'0`...\n-   = note: ...but `Trait` is actually implemented for the type `&'static ()`\n-\n-error: implementation of `Trait` is not general enough\n-  --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:48\n-   |\n-LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-   |                                                ^^^^^^ implementation of `Trait` is not general enough\n-   |\n-   = note: `&'0 ()` must implement `Trait`, for any lifetime `'0`...\n-   = note: ...but `Trait` is actually implemented for the type `&'static ()`\n-\n-error: implementation of `Trait` is not general enough\n-  --> $DIR/closure-malformed-projection-input-issue-102800.rs:18:48\n-   |\n-LL |     let _: for<'a> fn(<&'a () as Trait>::Ty) = |_| {};\n-   |                                                ^^^^^^ implementation of `Trait` is not general enough\n-   |\n-   = note: `&'0 ()` must implement `Trait`, for any lifetime `'0`...\n-   = note: ...but `Trait` is actually implemented for the type `&'static ()`\n-\n-error: aborting due to 12 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "5db02c46ec36954a251626317b150f7f490c2096", "filename": "src/test/ui/nll/user-annotations/ascribed-type-wf.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fascribed-type-wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fascribed-type-wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fascribed-type-wf.rs?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -1,5 +1,5 @@\n-// check-pass\n-// known-bug: #101350\n+// Regression test for #101350.\n+// check-fail\n \n trait Trait {\n     type Ty;\n@@ -11,6 +11,7 @@ impl Trait for &'static () {\n \n fn extend<'a>() {\n     None::<<&'a () as Trait>::Ty>;\n+    //~^ ERROR lifetime may not live long enough\n }\n \n fn main() {}"}, {"sha": "91e7c6b8ecf1f2ca469e3f1c80d6d94cf63f9783", "filename": "src/test/ui/nll/user-annotations/ascribed-type-wf.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fascribed-type-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fascribed-type-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fascribed-type-wf.stderr?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -0,0 +1,10 @@\n+error: lifetime may not live long enough\n+  --> $DIR/ascribed-type-wf.rs:13:5\n+   |\n+LL | fn extend<'a>() {\n+   |           -- lifetime `'a` defined here\n+LL |     None::<<&'a () as Trait>::Ty>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "8a80958fc6728835328a711cfb526f7f2d76170e", "filename": "src/test/ui/nll/user-annotations/dump-adt-brace-struct.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.rs?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -11,8 +11,10 @@ struct SomeStruct<T> { t: T }\n #[rustc_dump_user_substs]\n fn main() {\n     SomeStruct { t: 22 }; // Nothing given, no annotation.\n+    //~^ ERROR SomeStruct<^0>\n \n     SomeStruct::<_> { t: 22 }; // Nothing interesting given, no annotation.\n+    //~^ ERROR SomeStruct<^0>\n \n     SomeStruct::<u32> { t: 22 }; // No lifetime bounds given.\n "}, {"sha": "b5adc584b288a6e3c100810dd120d98f1f0c453e", "filename": "src/test/ui/nll/user-annotations/dump-adt-brace-struct.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -1,8 +1,20 @@\n-error: user substs: UserSubsts { substs: [&ReStatic u32], user_self_ty: None }\n-  --> $DIR/dump-adt-brace-struct.rs:19:5\n+error: user substs: UserSubsts { substs: [^0], user_self_ty: Some(UserSelfTy { impl_def_id: DefId(0:3 ~ dump_adt_brace_struct[4679]::SomeStruct), self_ty: SomeStruct<^0> }) }\n+  --> $DIR/dump-adt-brace-struct.rs:13:5\n+   |\n+LL |     SomeStruct { t: 22 }; // Nothing given, no annotation.\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: user substs: UserSubsts { substs: [^0], user_self_ty: Some(UserSelfTy { impl_def_id: DefId(0:3 ~ dump_adt_brace_struct[4679]::SomeStruct), self_ty: SomeStruct<^0> }) }\n+  --> $DIR/dump-adt-brace-struct.rs:16:5\n+   |\n+LL |     SomeStruct::<_> { t: 22 }; // Nothing interesting given, no annotation.\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: user substs: UserSubsts { substs: [&ReStatic u32], user_self_ty: Some(UserSelfTy { impl_def_id: DefId(0:3 ~ dump_adt_brace_struct[4679]::SomeStruct), self_ty: SomeStruct<&ReStatic u32> }) }\n+  --> $DIR/dump-adt-brace-struct.rs:21:5\n    |\n LL |     SomeStruct::<&'static u32> { t: &22 };\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 3 previous errors\n "}, {"sha": "00e9eb651cd2d955fa615498052742c277d8ead8", "filename": "src/test/ui/nll/user-annotations/normalization-2.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-2.rs?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -0,0 +1,80 @@\n+// Make sure we honor region constraints when normalizing type annotations.\n+\n+// check-fail\n+\n+#![feature(more_qualified_paths)]\n+\n+trait Trait {\n+    type Assoc;\n+}\n+\n+impl<T> Trait for T\n+where\n+    T: 'static,\n+{\n+    type Assoc = MyTy<()>;\n+}\n+\n+enum MyTy<T> {\n+    Unit,\n+    Tuple(),\n+    Struct {},\n+    Dumb(T),\n+}\n+\n+impl<T> MyTy<T> {\n+    fn method<X>() {}\n+}\n+\n+type Ty<'a> = <&'a () as Trait>::Assoc;\n+\n+fn test_local<'a>() {\n+    let _: Ty<'a> = MyTy::Unit;\n+    //~^ ERROR lifetime may not live long enough\n+}\n+\n+fn test_closure_sig<'a, 'b>() {\n+    |_: Ty<'a>| {};\n+    //~^ ERROR lifetime may not live long enough\n+    || -> Option<Ty<'b>> { None };\n+    //~^ ERROR lifetime may not live long enough\n+}\n+\n+fn test_path<'a, 'b, 'c, 'd>() {\n+    <Ty<'a>>::method::<Ty<'static>>;\n+    //~^ ERROR lifetime may not live long enough\n+    <Ty<'static>>::method::<Ty<'b>>;\n+    //~^ ERROR lifetime may not live long enough\n+}\n+\n+fn test_call<'a, 'b, 'c>() {\n+    <Ty<'a>>::method::<Ty<'static>>();\n+    //~^ ERROR lifetime may not live long enough\n+    <Ty<'static>>::method::<Ty<'b>>();\n+    //~^ ERROR lifetime may not live long enough\n+}\n+\n+fn test_variants<'a, 'b, 'c>() {\n+    <Ty<'a>>::Struct {}; //TODO\n+    //~^ ERROR lifetime may not live long enough\n+    <Ty<'b>>::Tuple();\n+    //~^ ERROR lifetime may not live long enough\n+    <Ty<'c>>::Unit;\n+    //~^ ERROR lifetime may not live long enough\n+}\n+\n+fn test_pattern<'a, 'b, 'c>() {\n+    use MyTy::*;\n+    match MyTy::Unit {\n+        Struct::<Ty<'a>> {..} => {},\n+        //~^ ERROR lifetime may not live long enough\n+        Tuple::<Ty<'b>> (..) => {},\n+        //~^ ERROR lifetime may not live long enough\n+        Unit::<Ty<'c>> => {},\n+        //~^ ERROR lifetime may not live long enough\n+        Dumb(_) => {},\n+    };\n+}\n+\n+\n+fn main() {}"}, {"sha": "3c235171ef569792ac0bc2baeb624184568da983", "filename": "src/test/ui/nll/user-annotations/normalization-2.stderr", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fnormalization-2.stderr?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -0,0 +1,141 @@\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:32:12\n+   |\n+LL | fn test_local<'a>() {\n+   |               -- lifetime `'a` defined here\n+LL |     let _: Ty<'a> = MyTy::Unit;\n+   |            ^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:37:6\n+   |\n+LL | fn test_closure_sig<'a, 'b>() {\n+   |                     -- lifetime `'a` defined here\n+LL |     |_: Ty<'a>| {};\n+   |      ^ requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:39:11\n+   |\n+LL | fn test_closure_sig<'a, 'b>() {\n+   |                         -- lifetime `'b` defined here\n+...\n+LL |     || -> Option<Ty<'b>> { None };\n+   |           ^^^^^^^^^^^^^^ requires that `'b` must outlive `'static`\n+\n+help: the following changes may resolve your lifetime errors\n+   |\n+   = help: replace `'a` with `'static`\n+   = help: replace `'b` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:44:5\n+   |\n+LL | fn test_path<'a, 'b, 'c, 'd>() {\n+   |              -- lifetime `'a` defined here\n+LL |     <Ty<'a>>::method::<Ty<'static>>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:46:5\n+   |\n+LL | fn test_path<'a, 'b, 'c, 'd>() {\n+   |                  -- lifetime `'b` defined here\n+...\n+LL |     <Ty<'static>>::method::<Ty<'b>>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'static`\n+\n+help: the following changes may resolve your lifetime errors\n+   |\n+   = help: replace `'a` with `'static`\n+   = help: replace `'b` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:51:5\n+   |\n+LL | fn test_call<'a, 'b, 'c>() {\n+   |              -- lifetime `'a` defined here\n+LL |     <Ty<'a>>::method::<Ty<'static>>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:53:5\n+   |\n+LL | fn test_call<'a, 'b, 'c>() {\n+   |                  -- lifetime `'b` defined here\n+...\n+LL |     <Ty<'static>>::method::<Ty<'b>>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'static`\n+\n+help: the following changes may resolve your lifetime errors\n+   |\n+   = help: replace `'a` with `'static`\n+   = help: replace `'b` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:58:5\n+   |\n+LL | fn test_variants<'a, 'b, 'c>() {\n+   |                  -- lifetime `'a` defined here\n+LL |     <Ty<'a>>::Struct {}; //TODO\n+   |     ^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:60:5\n+   |\n+LL | fn test_variants<'a, 'b, 'c>() {\n+   |                      -- lifetime `'b` defined here\n+...\n+LL |     <Ty<'b>>::Tuple();\n+   |     ^^^^^^^^^^^^^^^ requires that `'b` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:62:5\n+   |\n+LL | fn test_variants<'a, 'b, 'c>() {\n+   |                          -- lifetime `'c` defined here\n+...\n+LL |     <Ty<'c>>::Unit;\n+   |     ^^^^^^^^^^^^^^ requires that `'c` must outlive `'static`\n+\n+help: the following changes may resolve your lifetime errors\n+   |\n+   = help: replace `'a` with `'static`\n+   = help: replace `'b` with `'static`\n+   = help: replace `'c` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:69:9\n+   |\n+LL | fn test_pattern<'a, 'b, 'c>() {\n+   |                 -- lifetime `'a` defined here\n+...\n+LL |         Struct::<Ty<'a>> {..} => {},\n+   |         ^^^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:71:9\n+   |\n+LL | fn test_pattern<'a, 'b, 'c>() {\n+   |                     -- lifetime `'b` defined here\n+...\n+LL |         Tuple::<Ty<'b>> (..) => {},\n+   |         ^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/normalization-2.rs:73:9\n+   |\n+LL | fn test_pattern<'a, 'b, 'c>() {\n+   |                         -- lifetime `'c` defined here\n+...\n+LL |         Unit::<Ty<'c>> => {},\n+   |         ^^^^^^^^^^^^^^ requires that `'c` must outlive `'static`\n+\n+help: the following changes may resolve your lifetime errors\n+   |\n+   = help: replace `'a` with `'static`\n+   = help: replace `'b` with `'static`\n+   = help: replace `'c` with `'static`\n+\n+error: aborting due to 13 previous errors\n+"}, {"sha": "5f7f6aa9f6ec62697ef4ae895994f184dd6686de", "filename": "src/test/ui/ufcs/ufcs-partially-resolved.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d227506683e846cbeb872e089d660187a7a6041f/src%2Ftest%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr?ref=d227506683e846cbeb872e089d660187a7a6041f", "patch": "@@ -205,7 +205,7 @@ error[E0223]: ambiguous associated type\n   --> $DIR/ufcs-partially-resolved.rs:36:12\n    |\n LL |     let _: <u8 as Tr>::Y::NN;\n-   |            ^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<u16 as Trait>::NN`\n+   |            ^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<<u8 as Tr>::Y as Trait>::NN`\n \n error[E0599]: no associated item named `NN` found for type `u16` in the current scope\n   --> $DIR/ufcs-partially-resolved.rs:38:20"}]}