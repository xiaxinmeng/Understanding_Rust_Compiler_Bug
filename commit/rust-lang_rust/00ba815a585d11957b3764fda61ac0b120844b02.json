{"sha": "00ba815a585d11957b3764fda61ac0b120844b02", "node_id": "C_kwDOAAsO6NoAKDAwYmE4MTVhNTg1ZDExOTU3YjM3NjRmZGE2MWFjMGIxMjA4NDRiMDI", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-08-29T18:41:46Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-01-25T13:45:21Z"}, "message": "rustdoc: Pre-calculate traits that are in scope for doc links\n\nThis eliminates one more late use of resolver", "tree": {"sha": "9a55d2cc58311d3255d7480564efbbd0d495f8f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a55d2cc58311d3255d7480564efbbd0d495f8f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00ba815a585d11957b3764fda61ac0b120844b02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00ba815a585d11957b3764fda61ac0b120844b02", "html_url": "https://github.com/rust-lang/rust/commit/00ba815a585d11957b3764fda61ac0b120844b02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00ba815a585d11957b3764fda61ac0b120844b02/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17dfae79bbc3dabe1427073086acf7f7bd45148c", "url": "https://api.github.com/repos/rust-lang/rust/commits/17dfae79bbc3dabe1427073086acf7f7bd45148c", "html_url": "https://github.com/rust-lang/rust/commit/17dfae79bbc3dabe1427073086acf7f7bd45148c"}], "stats": {"total": 172, "additions": 131, "deletions": 41}, "files": [{"sha": "a074a0bff528792cf1386e886db3de5752cf38b1", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00ba815a585d11957b3764fda61ac0b120844b02/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ba815a585d11957b3764fda61ac0b120844b02/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=00ba815a585d11957b3764fda61ac0b120844b02", "patch": "@@ -1373,11 +1373,15 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self.root.traits.decode(self).map(move |index| self.local_def_id(index))\n     }\n \n-    fn get_trait_impls(self) -> impl Iterator<Item = (DefId, Option<SimplifiedType>)> + 'a {\n-        self.cdata.trait_impls.values().flat_map(move |impls| {\n-            impls\n-                .decode(self)\n-                .map(move |(idx, simplified_self_ty)| (self.local_def_id(idx), simplified_self_ty))\n+    fn get_trait_impls(self) -> impl Iterator<Item = (DefId, DefId, Option<SimplifiedType>)> + 'a {\n+        self.cdata.trait_impls.iter().flat_map(move |((trait_cnum_raw, trait_index), impls)| {\n+            let trait_def_id = DefId {\n+                krate: self.cnum_map[CrateNum::from_u32(*trait_cnum_raw)],\n+                index: *trait_index,\n+            };\n+            impls.decode(self).map(move |(impl_index, simplified_self_ty)| {\n+                (trait_def_id, self.local_def_id(impl_index), simplified_self_ty)\n+            })\n         })\n     }\n "}, {"sha": "2f8e35648ec2d6f8c31e5ddab6a0ba1e2feda36c", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ba815a585d11957b3764fda61ac0b120844b02/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ba815a585d11957b3764fda61ac0b120844b02/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=00ba815a585d11957b3764fda61ac0b120844b02", "patch": "@@ -493,7 +493,7 @@ impl CStore {\n     pub fn trait_impls_in_crate_untracked(\n         &self,\n         cnum: CrateNum,\n-    ) -> impl Iterator<Item = (DefId, Option<SimplifiedType>)> + '_ {\n+    ) -> impl Iterator<Item = (DefId, DefId, Option<SimplifiedType>)> + '_ {\n         self.get_crate_data(cnum).get_trait_impls()\n     }\n }"}, {"sha": "e4d8b7d528319cd3d770784132a079f7ca5355f3", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ba815a585d11957b3764fda61ac0b120844b02/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ba815a585d11957b3764fda61ac0b120844b02/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=00ba815a585d11957b3764fda61ac0b120844b02", "patch": "@@ -108,7 +108,7 @@ impl<'a> Resolver<'a> {\n     /// Reachable macros with block module parents exist due to `#[macro_export] macro_rules!`,\n     /// but they cannot use def-site hygiene, so the assumption holds\n     /// (<https://github.com/rust-lang/rust/pull/77984#issuecomment-712445508>).\n-    crate fn get_nearest_non_block_module(&mut self, mut def_id: DefId) -> Module<'a> {\n+    pub fn get_nearest_non_block_module(&mut self, mut def_id: DefId) -> Module<'a> {\n         loop {\n             match self.get_module(def_id) {\n                 Some(module) => return module,"}, {"sha": "45cc64ea194e2e50fb86976d44e2f339ef79ab30", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/00ba815a585d11957b3764fda61ac0b120844b02/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ba815a585d11957b3764fda61ac0b120844b02/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=00ba815a585d11957b3764fda61ac0b120844b02", "patch": "@@ -614,7 +614,8 @@ impl<'a> ModuleData<'a> {\n         }\n     }\n \n-    fn def_id(&self) -> DefId {\n+    // Public for rustdoc.\n+    pub fn def_id(&self) -> DefId {\n         self.opt_def_id().expect(\"`ModuleData::def_id` is called on a block module\")\n     }\n \n@@ -3407,6 +3408,16 @@ impl<'a> Resolver<'a> {\n         &self.all_macros\n     }\n \n+    /// For rustdoc.\n+    /// For local modules returns only reexports, for external modules returns all children.\n+    pub fn module_children_or_reexports(&self, def_id: DefId) -> Vec<ModChild> {\n+        if let Some(def_id) = def_id.as_local() {\n+            self.reexport_map.get(&def_id).cloned().unwrap_or_default()\n+        } else {\n+            self.cstore().module_children_untracked(def_id, self.session)\n+        }\n+    }\n+\n     /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n     #[inline]\n     pub fn opt_span(&self, def_id: DefId) -> Option<Span> {"}, {"sha": "1f14a333c005dbc67e63a272b0112497665f0351", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/00ba815a585d11957b3764fda61ac0b120844b02/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ba815a585d11957b3764fda61ac0b120844b02/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=00ba815a585d11957b3764fda61ac0b120844b02", "patch": "@@ -4,9 +4,9 @@ use rustc_errors::emitter::{Emitter, EmitterWriter};\n use rustc_errors::json::JsonEmitter;\n use rustc_feature::UnstableFeatures;\n use rustc_hir::def::Res;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{HirId, Path};\n+use rustc_hir::{HirId, Path, TraitCandidate};\n use rustc_interface::interface;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::privacy::AccessLevels;\n@@ -33,6 +33,9 @@ use crate::passes::{self, Condition::*};\n crate use rustc_session::config::{DebuggingOptions, Input, Options};\n \n crate struct ResolverCaches {\n+    /// Traits in scope for a given module.\n+    /// See `collect_intra_doc_links::traits_implemented_by` for more details.\n+    crate traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n     crate all_traits: Option<Vec<DefId>>,\n     crate all_trait_impls: Option<Vec<DefId>>,\n }\n@@ -67,11 +70,6 @@ crate struct DocContext<'tcx> {\n     crate auto_traits: Vec<DefId>,\n     /// The options given to rustdoc that could be relevant to a pass.\n     crate render_options: RenderOptions,\n-    /// The traits in scope for a given module.\n-    ///\n-    /// See `collect_intra_doc_links::traits_implemented_by` for more details.\n-    /// `map<module, set<trait>>`\n-    crate module_trait_cache: FxHashMap<DefId, FxHashSet<DefId>>,\n     /// This same cache is used throughout rustdoc, including in [`crate::html::render`].\n     crate cache: Cache,\n     /// Used by [`clean::inline`] to tell if an item has already been inlined.\n@@ -350,7 +348,6 @@ crate fn run_global_ctxt(\n         impl_trait_bounds: Default::default(),\n         generated_synthetics: Default::default(),\n         auto_traits,\n-        module_trait_cache: FxHashMap::default(),\n         cache: Cache::new(access_levels, render_options.document_private),\n         inlined: FxHashSet::default(),\n         output_format,"}, {"sha": "1d34e868781d1e0c2f45b6cd6d47db537dcb9bcd", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/00ba815a585d11957b3764fda61ac0b120844b02/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ba815a585d11957b3764fda61ac0b120844b02/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=00ba815a585d11957b3764fda61ac0b120844b02", "patch": "@@ -16,7 +16,7 @@ use rustc_middle::ty::{DefIdTree, Ty, TyCtxt};\n use rustc_middle::{bug, span_bug, ty};\n use rustc_resolve::ParentScope;\n use rustc_session::lint::Lint;\n-use rustc_span::hygiene::{MacroKind, SyntaxContext};\n+use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{BytePos, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n@@ -925,20 +925,9 @@ fn trait_impls_for<'a>(\n     ty: Ty<'a>,\n     module: DefId,\n ) -> FxHashSet<(DefId, DefId)> {\n-    let mut resolver = cx.resolver.borrow_mut();\n-    let in_scope_traits = cx.module_trait_cache.entry(module).or_insert_with(|| {\n-        resolver.access(|resolver| {\n-            let parent_scope = &ParentScope::module(resolver.expect_module(module), resolver);\n-            resolver\n-                .traits_in_scope(None, parent_scope, SyntaxContext::root(), None)\n-                .into_iter()\n-                .map(|candidate| candidate.def_id)\n-                .collect()\n-        })\n-    });\n-\n     let tcx = cx.tcx;\n-    let iter = in_scope_traits.iter().flat_map(|&trait_| {\n+    let iter = cx.resolver_caches.traits_in_scope[&module].iter().flat_map(|trait_candidate| {\n+        let trait_ = trait_candidate.def_id;\n         trace!(\"considering explicit impl for trait {:?}\", trait_);\n \n         // Look at each trait implementation to see if it's an impl for `did`"}, {"sha": "34aae4b6e39906cf0c6cb5a3f587708dd4f1793e", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 100, "deletions": 11, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/00ba815a585d11957b3764fda61ac0b120844b02/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ba815a585d11957b3764fda61ac0b120844b02/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=00ba815a585d11957b3764fda61ac0b120844b02", "patch": "@@ -7,11 +7,15 @@ use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::{self as ast, ItemKind};\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_hir::def::Namespace::TypeNS;\n-use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n-use rustc_resolve::Resolver;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, LocalDefId, CRATE_DEF_ID};\n+use rustc_hir::TraitCandidate;\n+use rustc_middle::ty::{DefIdTree, Visibility};\n+use rustc_resolve::{ParentScope, Resolver};\n use rustc_session::config::Externs;\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::{Span, SyntaxContext, DUMMY_SP};\n \n+use std::collections::hash_map::Entry;\n use std::mem;\n \n crate fn early_resolve_intra_doc_links(\n@@ -22,15 +26,18 @@ crate fn early_resolve_intra_doc_links(\n     let mut loader = IntraLinkCrateLoader {\n         resolver,\n         current_mod: CRATE_DEF_ID,\n+        visited_mods: Default::default(),\n+        traits_in_scope: Default::default(),\n         all_traits: Default::default(),\n         all_trait_impls: Default::default(),\n     };\n \n     // Overridden `visit_item` below doesn't apply to the crate root,\n-    // so we have to visit its attributes and exports separately.\n+    // so we have to visit its attributes and reexports separately.\n     loader.load_links_in_attrs(&krate.attrs, krate.span);\n+    loader.process_module_children_or_reexports(CRATE_DEF_ID.to_def_id());\n     visit::walk_crate(&mut loader, krate);\n-    loader.fill_resolver_caches();\n+    loader.add_foreign_traits_in_scope();\n \n     // FIXME: somehow rustdoc is still missing crates even though we loaded all\n     // the known necessary crates. Load them all unconditionally until we find a way to fix this.\n@@ -46,6 +53,7 @@ crate fn early_resolve_intra_doc_links(\n     }\n \n     ResolverCaches {\n+        traits_in_scope: loader.traits_in_scope,\n         all_traits: Some(loader.all_traits),\n         all_trait_impls: Some(loader.all_trait_impls),\n     }\n@@ -54,27 +62,87 @@ crate fn early_resolve_intra_doc_links(\n struct IntraLinkCrateLoader<'r, 'ra> {\n     resolver: &'r mut Resolver<'ra>,\n     current_mod: LocalDefId,\n+    visited_mods: DefIdSet,\n+    traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n     all_traits: Vec<DefId>,\n     all_trait_impls: Vec<DefId>,\n }\n \n impl IntraLinkCrateLoader<'_, '_> {\n-    fn fill_resolver_caches(&mut self) {\n-        for cnum in self.resolver.cstore().crates_untracked() {\n-            let all_traits = self.resolver.cstore().traits_in_crate_untracked(cnum);\n-            let all_trait_impls = self.resolver.cstore().trait_impls_in_crate_untracked(cnum);\n+    fn add_traits_in_scope(&mut self, def_id: DefId) {\n+        // Calls to `traits_in_scope` are expensive, so try to avoid them if only possible.\n+        // Keys in the `traits_in_scope` cache are always module IDs.\n+        if let Entry::Vacant(entry) = self.traits_in_scope.entry(def_id) {\n+            let module = self.resolver.get_nearest_non_block_module(def_id);\n+            let module_id = module.def_id();\n+            let entry = if module_id == def_id {\n+                Some(entry)\n+            } else if let Entry::Vacant(entry) = self.traits_in_scope.entry(module_id) {\n+                Some(entry)\n+            } else {\n+                None\n+            };\n+            if let Some(entry) = entry {\n+                entry.insert(self.resolver.traits_in_scope(\n+                    None,\n+                    &ParentScope::module(module, self.resolver),\n+                    SyntaxContext::root(),\n+                    None,\n+                ));\n+            }\n+        }\n+    }\n+\n+    fn add_traits_in_parent_scope(&mut self, def_id: DefId) {\n+        if let Some(module_id) = self.resolver.parent(def_id) {\n+            self.add_traits_in_scope(module_id);\n+        }\n+    }\n+\n+    /// Add traits in scope for links in impls collected by the `collect-intra-doc-links` pass.\n+    /// That pass filters impls using type-based information, but we don't yet have such\n+    /// information here, so we just conservatively calculate traits in scope for *all* modules\n+    /// having impls in them.\n+    fn add_foreign_traits_in_scope(&mut self) {\n+        for cnum in Vec::from_iter(self.resolver.cstore().crates_untracked()) {\n+            // FIXME: Due to #78696 rustdoc can query traits in scope for any crate root.\n+            self.add_traits_in_scope(cnum.as_def_id());\n+\n+            let all_traits = Vec::from_iter(self.resolver.cstore().traits_in_crate_untracked(cnum));\n+            let all_trait_impls =\n+                Vec::from_iter(self.resolver.cstore().trait_impls_in_crate_untracked(cnum));\n+\n+            // Querying traits in scope is expensive so we try to prune the impl and traits lists\n+            // using privacy, private traits and impls from other crates are never documented in\n+            // the current crate, and links in their doc comments are not resolved.\n+            for &def_id in &all_traits {\n+                if self.resolver.cstore().visibility_untracked(def_id) == Visibility::Public {\n+                    self.add_traits_in_parent_scope(def_id);\n+                }\n+            }\n+            for &(trait_def_id, impl_def_id, simplified_self_ty) in &all_trait_impls {\n+                if self.resolver.cstore().visibility_untracked(trait_def_id) == Visibility::Public\n+                    && simplified_self_ty.and_then(|ty| ty.def()).map_or(true, |ty_def_id| {\n+                        self.resolver.cstore().visibility_untracked(ty_def_id) == Visibility::Public\n+                    })\n+                {\n+                    self.add_traits_in_parent_scope(impl_def_id);\n+                }\n+            }\n \n             self.all_traits.extend(all_traits);\n-            self.all_trait_impls.extend(all_trait_impls.into_iter().map(|(def_id, _)| def_id));\n+            self.all_trait_impls.extend(all_trait_impls.into_iter().map(|(_, def_id, _)| def_id));\n         }\n     }\n \n     fn load_links_in_attrs(&mut self, attrs: &[ast::Attribute], span: Span) {\n-        // FIXME: this needs to consider export inlining.\n+        // FIXME: this needs to consider reexport inlining.\n         let attrs = clean::Attributes::from_ast(attrs, None);\n         for (parent_module, doc) in attrs.collapsed_doc_value_by_module_level() {\n             let module_id = parent_module.unwrap_or(self.current_mod.to_def_id());\n \n+            self.add_traits_in_scope(module_id);\n+\n             for link in markdown_links(&doc.as_str()) {\n                 let path_str = if let Some(Ok(x)) = preprocess_link(&link) {\n                     x.path_str\n@@ -85,6 +153,26 @@ impl IntraLinkCrateLoader<'_, '_> {\n             }\n         }\n     }\n+\n+    /// When reexports are inlined, they are replaced with item which they refer to, those items\n+    /// may have links in their doc comments, those links are resolved at the item definition site,\n+    /// so we need to know traits in scope at that definition site.\n+    fn process_module_children_or_reexports(&mut self, module_id: DefId) {\n+        if !self.visited_mods.insert(module_id) {\n+            return; // avoid infinite recursion\n+        }\n+\n+        for child in self.resolver.module_children_or_reexports(module_id) {\n+            if child.vis == Visibility::Public {\n+                if let Some(def_id) = child.res.opt_def_id() {\n+                    self.add_traits_in_parent_scope(def_id);\n+                }\n+                if let Res::Def(DefKind::Mod, module_id) = child.res {\n+                    self.process_module_children_or_reexports(module_id);\n+                }\n+            }\n+        }\n+    }\n }\n \n impl Visitor<'_> for IntraLinkCrateLoader<'_, '_> {\n@@ -93,6 +181,7 @@ impl Visitor<'_> for IntraLinkCrateLoader<'_, '_> {\n             let old_mod = mem::replace(&mut self.current_mod, self.resolver.local_def_id(item.id));\n \n             self.load_links_in_attrs(&item.attrs, item.span);\n+            self.process_module_children_or_reexports(self.current_mod.to_def_id());\n             visit::walk_item(self, item);\n \n             self.current_mod = old_mod;"}]}