{"sha": "bf97cd0338aa0de4d4e3946f7ccb68a2ac19193c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmOTdjZDAzMzhhYTBkZTRkNGUzOTQ2ZjdjY2I2OGEyYWMxOTE5M2M=", "commit": {"author": {"name": "sinkuu", "email": "sinkuu@sinkuu.xyz", "date": "2017-10-08T01:23:41Z"}, "committer": {"name": "sinkuu", "email": "sinkuu@sinkuu.xyz", "date": "2017-10-08T08:25:56Z"}, "message": "Reduce false-positives for needless_pass_by_value lint\n\nExcluding a type whose reference also fulfills the trait bound.", "tree": {"sha": "7fd025ad43021833e256381c27e47c481807287b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fd025ad43021833e256381c27e47c481807287b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf97cd0338aa0de4d4e3946f7ccb68a2ac19193c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf97cd0338aa0de4d4e3946f7ccb68a2ac19193c", "html_url": "https://github.com/rust-lang/rust/commit/bf97cd0338aa0de4d4e3946f7ccb68a2ac19193c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf97cd0338aa0de4d4e3946f7ccb68a2ac19193c/comments", "author": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12a7d1489aed893de9c6dc0a520e44cf3d349387", "url": "https://api.github.com/repos/rust-lang/rust/commits/12a7d1489aed893de9c6dc0a520e44cf3d349387", "html_url": "https://github.com/rust-lang/rust/commit/12a7d1489aed893de9c6dc0a520e44cf3d349387"}], "stats": {"total": 185, "additions": 108, "deletions": 77}, "files": [{"sha": "c16be95587b6eb5fcf4eab85a361c9b27efc6d4a", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 61, "deletions": 49, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/bf97cd0338aa0de4d4e3946f7ccb68a2ac19193c/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf97cd0338aa0de4d4e3946f7ccb68a2ac19193c/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=bf97cd0338aa0de4d4e3946f7ccb68a2ac19193c", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir::*;\n use rustc::hir::intravisit::FnKind;\n use rustc::lint::*;\n-use rustc::ty::{self, TypeFoldable};\n+use rustc::ty::{self, RegionKind, TypeFoldable};\n use rustc::traits;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n@@ -73,18 +73,25 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n             _ => return,\n         }\n \n-        // Allows these to be passed by value.\n-        let fn_trait = need!(cx.tcx.lang_items().fn_trait());\n-        let asref_trait = need!(get_trait_def_id(cx, &paths::ASREF_TRAIT));\n         let borrow_trait = need!(get_trait_def_id(cx, &paths::BORROW_TRAIT));\n+        let fn_trait = need!(cx.tcx.lang_items().fn_trait());\n+\n+        let sized_trait = need!(cx.tcx.lang_items().sized_trait());\n \n         let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n \n-        let preds: Vec<ty::Predicate> = {\n-            traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds.to_vec())\n-                .filter(|p| !p.is_global())\n-                .collect()\n-        };\n+        let preds = traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds.to_vec())\n+            .filter(|p| !p.is_global())\n+            .collect::<Vec<_>>();\n+        let preds = preds\n+            .iter()\n+            .filter_map(|pred| if let ty::Predicate::Trait(ref poly_trait_ref) = *pred {\n+                Some(poly_trait_ref.skip_binder())\n+            } else {\n+                None\n+            })\n+            .filter(|t| t.def_id() != sized_trait && !t.has_escaping_regions())\n+            .collect::<Vec<_>>();\n \n         // Collect moved variables and spans which will need dereferencings from the\n         // function body.\n@@ -103,40 +110,44 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         let fn_sig = cx.tcx.erase_late_bound_regions(&fn_sig);\n \n         for ((input, &ty), arg) in decl.inputs.iter().zip(fn_sig.inputs()).zip(&body.arguments) {\n-            // Determines whether `ty` implements `Borrow<U>` (U != ty) specifically.\n-            // This is needed due to the `Borrow<T> for T` blanket impl.\n-            let implements_borrow_trait = preds\n-                .iter()\n-                .filter_map(|pred| if let ty::Predicate::Trait(ref poly_trait_ref) = *pred {\n-                    Some(poly_trait_ref.skip_binder())\n-                } else {\n-                    None\n-                })\n-                .filter(|tpred| tpred.def_id() == borrow_trait && tpred.self_ty() == ty)\n-                .any(|tpred| {\n-                    tpred\n-                        .input_types()\n-                        .nth(1)\n-                        .expect(\"Borrow trait must have an parameter\") != ty\n-                });\n+            // * Exclude a type that is specifically bounded by `Borrow`.\n+            // * Exclude a type whose reference also fulfills its bound.\n+            //   (e.g. `std::borrow::Borrow`, `serde::Serialize`)\n+            let (implements_borrow_trait, all_borrowable_trait) = {\n+                let preds = preds\n+                    .iter()\n+                    .filter(|t| t.self_ty() == ty)\n+                    .collect::<Vec<_>>();\n+\n+                (\n+                    preds.iter().any(|t| t.def_id() == borrow_trait),\n+                    !preds.is_empty() && preds.iter().all(|t| {\n+                        implements_trait(\n+                            cx,\n+                            cx.tcx.mk_imm_ref(&RegionKind::ReErased, ty),\n+                            t.def_id(),\n+                            &t.input_types().skip(1).collect::<Vec<_>>(),\n+                        )\n+                    }),\n+                )\n+            };\n \n             if_let_chain! {[\n                 !is_self(arg),\n                 !ty.is_mutable_pointer(),\n                 !is_copy(cx, ty),\n                 !implements_trait(cx, ty, fn_trait, &[]),\n-                !implements_trait(cx, ty, asref_trait, &[]),\n                 !implements_borrow_trait,\n+                !all_borrowable_trait,\n \n                 let PatKind::Binding(mode, canonical_id, ..) = arg.pat.node,\n                 !moved_vars.contains(&canonical_id),\n             ], {\n-                // Note: `toplevel_ref_arg` warns if `BindByRef`\n                 if mode == BindingAnnotation::Mutable || mode == BindingAnnotation::RefMut {\n                     continue;\n                 }\n \n-                // Suggestion logic\n+                // Dereference suggestion\n                 let sugg = |db: &mut DiagnosticBuilder| {\n                     let deref_span = spans_need_deref.get(&canonical_id);\n                     if_let_chain! {[\n@@ -152,33 +163,37 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                                         \"consider changing the type to\",\n                                         slice_ty);\n                         assert!(deref_span.is_none());\n-                        return; // `Vec` and `String` cannot be destructured - no need for `*` suggestion\n+                        return; // `Vec` cannot be destructured - no need for `*` suggestion\n                     }}\n \n                     if match_type(cx, ty, &paths::STRING) {\n-                        db.span_suggestion(input.span,\n-                                           \"consider changing the type to\",\n-                                           \"&str\".to_string());\n+                        db.span_suggestion(input.span, \"consider changing the type to\", \"&str\".to_string());\n                         assert!(deref_span.is_none());\n-                        return;\n+                        return; // ditto\n                     }\n \n                     let mut spans = vec![(input.span, format!(\"&{}\", snippet(cx, input.span, \"_\")))];\n \n                     // Suggests adding `*` to dereference the added reference.\n                     if let Some(deref_span) = deref_span {\n-                        spans.extend(deref_span.iter().cloned()\n-                                     .map(|span| (span, format!(\"*{}\", snippet(cx, span, \"<expr>\")))));\n+                        spans.extend(\n+                            deref_span\n+                                .iter()\n+                                .cloned()\n+                                .map(|span| (span, format!(\"*{}\", snippet(cx, span, \"<expr>\")))),\n+                        );\n                         spans.sort_by_key(|&(span, _)| span);\n                     }\n                     multispan_sugg(db, \"consider taking a reference instead\".to_string(), spans);\n                 };\n \n-                span_lint_and_then(cx,\n-                          NEEDLESS_PASS_BY_VALUE,\n-                          input.span,\n-                          \"this argument is passed by value, but not consumed in the function body\",\n-                          sugg);\n+                span_lint_and_then(\n+                    cx,\n+                    NEEDLESS_PASS_BY_VALUE,\n+                    input.span,\n+                    \"this argument is passed by value, but not consumed in the function body\",\n+                    sugg,\n+                );\n             }}\n         }\n     }\n@@ -188,8 +203,7 @@ struct MovedVariablesCtxt<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n     moved_vars: HashSet<NodeId>,\n     /// Spans which need to be prefixed with `*` for dereferencing the\n-    /// suggested additional\n-    /// reference.\n+    /// suggested additional reference.\n     spans_need_deref: HashMap<NodeId, HashSet<Span>>,\n }\n \n@@ -213,9 +227,7 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n     fn non_moving_pat(&mut self, matched_pat: &Pat, cmt: mc::cmt<'tcx>) {\n         let cmt = unwrap_downcast_or_interior(cmt);\n \n-        if_let_chain! {[\n-            let mc::Categorization::Local(vid) = cmt.cat,\n-        ], {\n+        if let mc::Categorization::Local(vid) = cmt.cat {\n             let mut id = matched_pat.id;\n             loop {\n                 let parent = self.cx.tcx.hir.get_parent_node(id);\n@@ -235,7 +247,7 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n                                     .or_insert_with(HashSet::new)\n                                     .insert(c.span);\n                             }\n-                        }\n+                        },\n \n                         map::Node::NodeStmt(s) => {\n                             // `let <pat> = x;`\n@@ -251,13 +263,13 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n                                         .map(|e| e.span)\n                                         .expect(\"`let` stmt without init aren't caught by match_pat\"));\n                             }}\n-                        }\n+                        },\n \n-                        _ => {}\n+                        _ => {},\n                     }\n                 }\n             }\n-        }}\n+        }\n     }\n }\n "}, {"sha": "5916768359537bf0c827a7850b46d1c879795a0c", "filename": "tests/ui/needless_pass_by_value.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bf97cd0338aa0de4d4e3946f7ccb68a2ac19193c/tests%2Fui%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf97cd0338aa0de4d4e3946f7ccb68a2ac19193c/tests%2Fui%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_pass_by_value.rs?ref=bf97cd0338aa0de4d4e3946f7ccb68a2ac19193c", "patch": "@@ -4,6 +4,9 @@\n #![warn(needless_pass_by_value)]\n #![allow(dead_code, single_match, if_let_redundant_pattern_matching, many_single_char_names)]\n \n+use std::borrow::Borrow;\n+use std::convert::AsRef;\n+\n // `v` should be warned\n // `w`, `x` and `y` are allowed (moved or mutated)\n fn foo<T: Default>(v: Vec<T>, w: Vec<T>, mut x: Vec<T>, y: Vec<T>) -> Vec<T> {\n@@ -25,10 +28,11 @@ fn bar(x: String, y: Wrapper) {\n     assert_eq!(y.0.len(), 42);\n }\n \n-// U implements `Borrow<U>`, but should be warned correctly\n-fn test_borrow_trait<T: std::borrow::Borrow<str>, U>(t: T, u: U) {\n+// V implements `Borrow<V>`, but should be warned correctly\n+fn test_borrow_trait<T: Borrow<str>, U: AsRef<str>, V>(t: T, u: U, v: V) {\n     println!(\"{}\", t.borrow());\n-    consume(&u);\n+    println!(\"{}\", u.as_ref());\n+    consume(&v);\n }\n \n // ok\n@@ -59,4 +63,13 @@ fn test_destructure(x: Wrapper, y: Wrapper, z: Wrapper) {\n     println!(\"{}\", t);\n }\n \n+trait Foo {}\n+\n+// `S: Serialize` can be passed by value\n+trait Serialize {}\n+impl<'a, T> Serialize for &'a T where T: Serialize {}\n+impl Serialize for i32 {}\n+\n+fn test_blanket_ref<T: Foo, S: Serialize>(_foo: T, _serializable: S) {}\n+\n fn main() {}"}, {"sha": "0968b68d82f053ca6d025630672eca03d8a632ff", "filename": "tests/ui/needless_pass_by_value.stderr", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bf97cd0338aa0de4d4e3946f7ccb68a2ac19193c/tests%2Fui%2Fneedless_pass_by_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bf97cd0338aa0de4d4e3946f7ccb68a2ac19193c/tests%2Fui%2Fneedless_pass_by_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_pass_by_value.stderr?ref=bf97cd0338aa0de4d4e3946f7ccb68a2ac19193c", "patch": "@@ -1,58 +1,64 @@\n error: this argument is passed by value, but not consumed in the function body\n- --> $DIR/needless_pass_by_value.rs:9:23\n-  |\n-9 | fn foo<T: Default>(v: Vec<T>, w: Vec<T>, mut x: Vec<T>, y: Vec<T>) -> Vec<T> {\n-  |                       ^^^^^^ help: consider changing the type to: `&[T]`\n-  |\n-  = note: `-D needless-pass-by-value` implied by `-D warnings`\n+  --> $DIR/needless_pass_by_value.rs:12:23\n+   |\n+12 | fn foo<T: Default>(v: Vec<T>, w: Vec<T>, mut x: Vec<T>, y: Vec<T>) -> Vec<T> {\n+   |                       ^^^^^^ help: consider changing the type to: `&[T]`\n+   |\n+   = note: `-D needless-pass-by-value` implied by `-D warnings`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:23:11\n+  --> $DIR/needless_pass_by_value.rs:26:11\n    |\n-23 | fn bar(x: String, y: Wrapper) {\n+26 | fn bar(x: String, y: Wrapper) {\n    |           ^^^^^^ help: consider changing the type to: `&str`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:23:22\n+  --> $DIR/needless_pass_by_value.rs:26:22\n    |\n-23 | fn bar(x: String, y: Wrapper) {\n+26 | fn bar(x: String, y: Wrapper) {\n    |                      ^^^^^^^ help: consider taking a reference instead: `&Wrapper`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:29:63\n+  --> $DIR/needless_pass_by_value.rs:32:71\n    |\n-29 | fn test_borrow_trait<T: std::borrow::Borrow<str>, U>(t: T, u: U) {\n-   |                                                               ^ help: consider taking a reference instead: `&U`\n+32 | fn test_borrow_trait<T: Borrow<str>, U: AsRef<str>, V>(t: T, u: U, v: V) {\n+   |                                                                       ^ help: consider taking a reference instead: `&V`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:40:18\n+  --> $DIR/needless_pass_by_value.rs:44:18\n    |\n-40 | fn test_match(x: Option<Option<String>>, y: Option<Option<String>>) {\n+44 | fn test_match(x: Option<Option<String>>, y: Option<Option<String>>) {\n    |                  ^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: consider taking a reference instead\n    |\n-40 | fn test_match(x: &Option<Option<String>>, y: Option<Option<String>>) {\n-41 |     match *x {\n+44 | fn test_match(x: &Option<Option<String>>, y: Option<Option<String>>) {\n+45 |     match *x {\n    |\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:53:24\n+  --> $DIR/needless_pass_by_value.rs:57:24\n    |\n-53 | fn test_destructure(x: Wrapper, y: Wrapper, z: Wrapper) {\n+57 | fn test_destructure(x: Wrapper, y: Wrapper, z: Wrapper) {\n    |                        ^^^^^^^ help: consider taking a reference instead: `&Wrapper`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:53:36\n+  --> $DIR/needless_pass_by_value.rs:57:36\n    |\n-53 | fn test_destructure(x: Wrapper, y: Wrapper, z: Wrapper) {\n+57 | fn test_destructure(x: Wrapper, y: Wrapper, z: Wrapper) {\n    |                                    ^^^^^^^\n    |\n help: consider taking a reference instead\n    |\n-53 | fn test_destructure(x: Wrapper, y: &Wrapper, z: Wrapper) {\n-54 |     let Wrapper(s) = z; // moved\n-55 |     let Wrapper(ref t) = *y; // not moved\n-56 |     let Wrapper(_) = *y; // still not moved\n+57 | fn test_destructure(x: Wrapper, y: &Wrapper, z: Wrapper) {\n+58 |     let Wrapper(s) = z; // moved\n+59 |     let Wrapper(ref t) = *y; // not moved\n+60 |     let Wrapper(_) = *y; // still not moved\n+   |\n+\n+error: this argument is passed by value, but not consumed in the function body\n+  --> $DIR/needless_pass_by_value.rs:73:49\n    |\n+73 | fn test_blanket_ref<T: Foo, S: Serialize>(_foo: T, _serializable: S) {}\n+   |                                                 ^ help: consider taking a reference instead: `&T`\n "}]}