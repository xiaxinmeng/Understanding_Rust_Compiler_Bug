{"sha": "a113609bdf0f05a3f32ab2f19bed38bde0d7063a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExMTM2MDliZGYwZjA1YTNmMzJhYjJmMTliZWQzOGJkZTBkNzA2M2E=", "commit": {"author": {"name": "Giles Cope", "email": "gilescope@gmail.com", "date": "2019-12-30T22:46:07Z"}, "committer": {"name": "Giles Cope", "email": "giles.cope@gmail.com", "date": "2020-02-13T19:42:59Z"}, "message": "keyword docs for else and inkeyword docs for else and in.", "tree": {"sha": "ad542c2d31610e52260278217d8b73df29e23ae6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad542c2d31610e52260278217d8b73df29e23ae6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a113609bdf0f05a3f32ab2f19bed38bde0d7063a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a113609bdf0f05a3f32ab2f19bed38bde0d7063a", "html_url": "https://github.com/rust-lang/rust/commit/a113609bdf0f05a3f32ab2f19bed38bde0d7063a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a113609bdf0f05a3f32ab2f19bed38bde0d7063a/comments", "author": {"login": "gilescope", "id": 803976, "node_id": "MDQ6VXNlcjgwMzk3Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/803976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gilescope", "html_url": "https://github.com/gilescope", "followers_url": "https://api.github.com/users/gilescope/followers", "following_url": "https://api.github.com/users/gilescope/following{/other_user}", "gists_url": "https://api.github.com/users/gilescope/gists{/gist_id}", "starred_url": "https://api.github.com/users/gilescope/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gilescope/subscriptions", "organizations_url": "https://api.github.com/users/gilescope/orgs", "repos_url": "https://api.github.com/users/gilescope/repos", "events_url": "https://api.github.com/users/gilescope/events{/privacy}", "received_events_url": "https://api.github.com/users/gilescope/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gilescope", "id": 803976, "node_id": "MDQ6VXNlcjgwMzk3Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/803976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gilescope", "html_url": "https://github.com/gilescope", "followers_url": "https://api.github.com/users/gilescope/followers", "following_url": "https://api.github.com/users/gilescope/following{/other_user}", "gists_url": "https://api.github.com/users/gilescope/gists{/gist_id}", "starred_url": "https://api.github.com/users/gilescope/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gilescope/subscriptions", "organizations_url": "https://api.github.com/users/gilescope/orgs", "repos_url": "https://api.github.com/users/gilescope/repos", "events_url": "https://api.github.com/users/gilescope/events{/privacy}", "received_events_url": "https://api.github.com/users/gilescope/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84d8f9ddd3819501735d30b3c584c6935ef6c9da", "url": "https://api.github.com/repos/rust-lang/rust/commits/84d8f9ddd3819501735d30b3c584c6935ef6c9da", "html_url": "https://github.com/rust-lang/rust/commit/84d8f9ddd3819501735d30b3c584c6935ef6c9da"}], "stats": {"total": 61, "additions": 56, "deletions": 5}, "files": [{"sha": "2d8bea6ffafd74a777406bb9abd06ae1774dc0f1", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 56, "deletions": 5, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a113609bdf0f05a3f32ab2f19bed38bde0d7063a/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a113609bdf0f05a3f32ab2f19bed38bde0d7063a/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=a113609bdf0f05a3f32ab2f19bed38bde0d7063a", "patch": "@@ -234,12 +234,55 @@ mod crate_keyword {}\n \n #[doc(keyword = \"else\")]\n //\n-/// What to do when an [`if`] condition does not hold.\n+/// What expression to evaluate when an [`if`] condition evaluates to [`false`].\n ///\n-/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+/// `else` expressions are optional. When no else expressions are supplied it is assumed to evaluate\n+/// to the unit type `()`.\n+///\n+/// The type that the `else` blocks evaluate to must be compatible with the type that the `if` block\n+/// evaluates to.\n+///\n+/// As can be seen below, `else` must be followed by either: `if`, `if let`, or a block `{}` and it\n+/// will return the value of that expression.\n+///\n+/// ```rust\n+/// let result = if true == false {\n+///     \"oh no\"\n+/// } else if \"something\" == \"other thing\" {\n+///     \"oh dear\"\n+/// } else if let Some(200) = \"blarg\".parse::<i32>().ok() {\n+///     \"uh oh\"\n+/// } else {\n+///     println!(\"Sneaky side effect.\");\n+///     \"phew, nothing's broken\"\n+/// };\n+/// ```\n+///\n+/// Here's another example but here we do not try and return an expression:\n+///\n+/// ```rust\n+/// if true == false {\n+///     println!(\"oh no\");\n+/// } else if \"something\" == \"other thing\" {\n+///     println!(\"oh dear\");\n+/// } else if let Some(200) = \"blarg\".parse::<i32>().ok() {\n+///     println!(\"uh oh\");\n+/// } else {\n+///     println!(\"phew, nothing's broken\");\n+/// }\n+/// ```\n+///\n+/// The above is _still_ an expression but it will always evaluate to `()`.\n ///\n+/// There is possibly no limit to the number of `else` blocks that could follow an `if` expression\n+/// however if you have several then a [`match`] expression might be preferable.\n+///\n+/// Read more about control flow in the [Rust Book].\n+///\n+/// [Rust Book]: ../book/ch03-05-control-flow.html#handling-multiple-conditions-with-else-if\n+/// [`match`]: keyword.match.html\n+/// [`false`]: keyword.false.html\n /// [`if`]: keyword.if.html\n-/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n mod else_keyword {}\n \n #[doc(keyword = \"enum\")]\n@@ -637,10 +680,18 @@ mod impl_keyword {}\n //\n /// Iterate over a series of values with [`for`].\n ///\n-/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+/// The expression immediately following `in` must implement the [`Iterator`] trait.\n ///\n+/// ## Literal Examples:\n+///\n+///    * `for _ **in** 1..3 {}` - Iterate over an exclusive range up to but excluding 3.\n+///    * `for _ **in** 1..=3 {}` - Iterate over an inclusive range up to and includeing 3.\n+///\n+/// (Read more about [range patterns])\n+///\n+/// [`Iterator`]: ../book/ch13-04-performance.html\n+/// [`range patterns`]: ../reference/patterns.html?highlight=range#range-patterns\n /// [`for`]: keyword.for.html\n-/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n mod in_keyword {}\n \n #[doc(keyword = \"let\")]"}]}