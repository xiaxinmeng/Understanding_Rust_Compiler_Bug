{"sha": "d3569ddf320cc7bb33f53483892fc3f8204dc62a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzNTY5ZGRmMzIwY2M3YmIzM2Y1MzQ4Mzg5MmZjM2Y4MjA0ZGM2MmE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-05T11:53:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-05T11:53:07Z"}, "message": "Rollup merge of #62323 - Centril:clarify-read-unaligned, r=RalfJung\n\nClarify unaligned fields in ptr::{read,write}_unaligned\n\nr? @RalfJung", "tree": {"sha": "bc79c7b585546a1f981595167ce3da55991528b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc79c7b585546a1f981595167ce3da55991528b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3569ddf320cc7bb33f53483892fc3f8204dc62a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdHzojCRBK7hj4Ov3rIwAAdHIIAEcohamHMXeRTXb2vUNxjesl\nDcECftBhblkrPrpHMJk+RE+g3/A7+U+B9bX+7lawZupEw6yiS/+U5w0m0ujT0Uod\nthEfZeIFPZrExs6vwCO73wBWWyeR2JPWLtr/twgR3w3HKlUWs/lPscktn8p4FRxd\nG5Aq0GcVQ3Tp/OSKY3zU158k4bTeDR9dPwiG3FzVboXIt71TmyYOiAhCvDiWFR4q\nqpc/wTkwHYXxbjxnZ11WErERProIGEEW5lD7vPUsXvyXYsay9O9LsEHAqSZel9jM\nAS49kpmfPZMW6czK7ub4IzykTlL0pCXBycjM9uDjRe7mfALfb0bVeHLezccEOeM=\n=tUdG\n-----END PGP SIGNATURE-----\n", "payload": "tree bc79c7b585546a1f981595167ce3da55991528b6\nparent 84527e4676e21a574ff7d20d9680283cead0e828\nparent 54527db7b0316b3921f3f66bdc58cf3377c37902\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1562327587 +0200\ncommitter GitHub <noreply@github.com> 1562327587 +0200\n\nRollup merge of #62323 - Centril:clarify-read-unaligned, r=RalfJung\n\nClarify unaligned fields in ptr::{read,write}_unaligned\n\nr? @RalfJung\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3569ddf320cc7bb33f53483892fc3f8204dc62a", "html_url": "https://github.com/rust-lang/rust/commit/d3569ddf320cc7bb33f53483892fc3f8204dc62a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3569ddf320cc7bb33f53483892fc3f8204dc62a/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84527e4676e21a574ff7d20d9680283cead0e828", "url": "https://api.github.com/repos/rust-lang/rust/commits/84527e4676e21a574ff7d20d9680283cead0e828", "html_url": "https://github.com/rust-lang/rust/commit/84527e4676e21a574ff7d20d9680283cead0e828"}, {"sha": "54527db7b0316b3921f3f66bdc58cf3377c37902", "url": "https://api.github.com/repos/rust-lang/rust/commits/54527db7b0316b3921f3f66bdc58cf3377c37902", "html_url": "https://github.com/rust-lang/rust/commit/54527db7b0316b3921f3f66bdc58cf3377c37902"}], "stats": {"total": 88, "additions": 53, "deletions": 35}, "files": [{"sha": "2a6c2b1331e5c5754e8b7c5e63025a9f9e0d29ef", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 53, "deletions": 35, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/d3569ddf320cc7bb33f53483892fc3f8204dc62a/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3569ddf320cc7bb33f53483892fc3f8204dc62a/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=d3569ddf320cc7bb33f53483892fc3f8204dc62a", "patch": "@@ -625,42 +625,50 @@ pub unsafe fn read<T>(src: *const T) -> T {\n /// [read-ownership]: ./fn.read.html#ownership-of-the-returned-value\n /// [valid]: ../ptr/index.html#safety\n ///\n-/// # Examples\n+/// ## On `packed` structs\n ///\n-/// Access members of a packed struct by reference:\n+/// It is currently impossible to create raw pointers to unaligned fields\n+/// of a packed struct.\n ///\n-/// ```\n-/// use std::ptr;\n+/// Attempting to create a raw pointer to an `unaligned` struct field with\n+/// an expression such as `&packed.unaligned as *const FieldType` creates an\n+/// intermediate unaligned reference before converting that to a raw pointer.\n+/// That this reference is temporary and immediately cast is inconsequential\n+/// as the compiler always expects references to be properly aligned.\n+/// As a result, using `&packed.unaligned as *const FieldType` causes immediate\n+/// *undefined behavior* in your program.\n ///\n+/// An example of what not to do and how this relates to `read_unaligned` is:\n+///\n+/// ```no_run\n /// #[repr(packed, C)]\n /// struct Packed {\n ///     _padding: u8,\n ///     unaligned: u32,\n /// }\n ///\n-/// let x = Packed {\n+/// let packed = Packed {\n ///     _padding: 0x00,\n ///     unaligned: 0x01020304,\n /// };\n ///\n /// let v = unsafe {\n-///     // Take the address of a 32-bit integer which is not aligned.\n-///     // This must be done as a raw pointer; unaligned references are invalid.\n-///     let unaligned = &x.unaligned as *const u32;\n-///\n-///     // Dereferencing normally will emit an aligned load instruction,\n-///     // causing undefined behavior.\n-///     // let v = *unaligned; // ERROR\n+///     // Here we attempt to take the address of a 32-bit integer which is not aligned.\n+///     let unaligned =\n+///         // A temporary unaligned reference is created here which results in\n+///         // undefined behavior regardless of whether the reference is used or not.\n+///         &packed.unaligned\n+///         // Casting to a raw pointer doesn't help; the mistake already happened.\n+///         as *const u32;\n ///\n-///     // Instead, use `read_unaligned` to read improperly aligned values.\n-///     let v = ptr::read_unaligned(unaligned);\n+///     let v = std::ptr::read_unaligned(unaligned);\n ///\n ///     v\n /// };\n-///\n-/// // Accessing unaligned values directly is safe.\n-/// assert!(x.unaligned == v);\n /// ```\n+///\n+/// Accessing unaligned fields directly with e.g. `packed.unaligned` is safe however.\n+// FIXME: Update docs based on outcome of RFC #2582 and friends.\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n@@ -789,38 +797,48 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n ///\n /// [valid]: ../ptr/index.html#safety\n ///\n-/// # Examples\n+/// ## On `packed` structs\n ///\n-/// Access fields in a packed struct:\n+/// It is currently impossible to create raw pointers to unaligned fields\n+/// of a packed struct.\n ///\n-/// ```\n-/// use std::{mem, ptr};\n+/// Attempting to create a raw pointer to an `unaligned` struct field with\n+/// an expression such as `&packed.unaligned as *const FieldType` creates an\n+/// intermediate unaligned reference before converting that to a raw pointer.\n+/// That this reference is temporary and immediately cast is inconsequential\n+/// as the compiler always expects references to be properly aligned.\n+/// As a result, using `&packed.unaligned as *const FieldType` causes immediate\n+/// *undefined behavior* in your program.\n ///\n+/// An example of what not to do and how this relates to `write_unaligned` is:\n+///\n+/// ```no_run\n /// #[repr(packed, C)]\n-/// #[derive(Default)]\n /// struct Packed {\n ///     _padding: u8,\n ///     unaligned: u32,\n /// }\n ///\n /// let v = 0x01020304;\n-/// let mut x: Packed = unsafe { mem::zeroed() };\n-///\n-/// unsafe {\n-///     // Take a reference to a 32-bit integer which is not aligned.\n-///     let unaligned = &mut x.unaligned as *mut u32;\n+/// let mut packed: Packed = unsafe { std::mem::zeroed() };\n ///\n-///     // Dereferencing normally will emit an aligned store instruction,\n-///     // causing undefined behavior because the pointer is not aligned.\n-///     // *unaligned = v; // ERROR\n+/// let v = unsafe {\n+///     // Here we attempt to take the address of a 32-bit integer which is not aligned.\n+///     let unaligned =\n+///         // A temporary unaligned reference is created here which results in\n+///         // undefined behavior regardless of whether the reference is used or not.\n+///         &mut packed.unaligned\n+///         // Casting to a raw pointer doesn't help; the mistake already happened.\n+///         as *mut u32;\n ///\n-///     // Instead, use `write_unaligned` to write improperly aligned values.\n-///     ptr::write_unaligned(unaligned, v);\n-/// }\n+///     std::ptr::write_unaligned(unaligned, v);\n ///\n-/// // Accessing unaligned values directly is safe.\n-/// assert!(x.unaligned == v);\n+///     v\n+/// };\n /// ```\n+///\n+/// Accessing unaligned fields directly with e.g. `packed.unaligned` is safe however.\n+// FIXME: Update docs based on outcome of RFC #2582 and friends.\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {"}]}