{"sha": "cca84e9e21b3f021fb6a0d9dedaad270753531cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjYTg0ZTllMjFiM2YwMjFmYjZhMGQ5ZGVkYWFkMjcwNzUzNTMxY2M=", "commit": {"author": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-10-24T19:14:37Z"}, "committer": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-10-28T16:54:16Z"}, "message": "Remove ty_bot from the type system\n\nWe now instead use a fresh variable for expressions that diverge.", "tree": {"sha": "d215d514a11662ddcf63b0c60aaba90bc818d33e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d215d514a11662ddcf63b0c60aaba90bc818d33e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cca84e9e21b3f021fb6a0d9dedaad270753531cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cca84e9e21b3f021fb6a0d9dedaad270753531cc", "html_url": "https://github.com/rust-lang/rust/commit/cca84e9e21b3f021fb6a0d9dedaad270753531cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cca84e9e21b3f021fb6a0d9dedaad270753531cc/comments", "author": null, "committer": null, "parents": [{"sha": "58dc0a05abb98ae2db65ca20e70f3bab51f8bf92", "url": "https://api.github.com/repos/rust-lang/rust/commits/58dc0a05abb98ae2db65ca20e70f3bab51f8bf92", "html_url": "https://github.com/rust-lang/rust/commit/58dc0a05abb98ae2db65ca20e70f3bab51f8bf92"}], "stats": {"total": 1447, "additions": 803, "deletions": 644}, "files": [{"sha": "68b3ca96de14715dbe14abee4b099d2078e103b3", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -149,7 +149,7 @@ pub trait TyVisitor {\n     fn visit_fn_input(&mut self, i: uint, mode: uint,\n                       inner: *const TyDesc) -> bool;\n     fn visit_fn_output(&mut self, retstyle: uint, variadic: bool,\n-                       inner: *const TyDesc) -> bool;\n+                       converging: bool, inner: *const TyDesc) -> bool;\n     fn visit_leave_fn(&mut self, purity: uint, proto: uint,\n                       n_inputs: uint, retstyle: uint) -> bool;\n "}, {"sha": "f405e9df51db0e132294ddf994ac1ec24b41eaef", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -145,5 +145,6 @@ register_diagnostics!(\n     E0162,\n     E0163,\n     E0164,\n-    E0165\n+    E0165,\n+    E0166\n )"}, {"sha": "99ca5770a8a2f690f2966cbd78c28fabf4b486ee", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -683,7 +683,7 @@ impl LintPass for UnusedResults {\n         let t = ty::expr_ty(cx.tcx, expr);\n         let mut warned = false;\n         match ty::get(t).sty {\n-            ty::ty_nil | ty::ty_bot | ty::ty_bool => return,\n+            ty::ty_nil | ty::ty_bool => return,\n             ty::ty_struct(did, _) |\n             ty::ty_enum(did, _) => {\n                 if ast_util::is_local(did) {"}, {"sha": "60fb490e270b3c0193c6ba8205a4dc644675fb1d", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -359,7 +359,6 @@ fn parse_trait_ref(st: &mut PState, conv: conv_did) -> ty::TraitRef {\n fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n     match next(st) {\n       'n' => return ty::mk_nil(),\n-      'z' => return ty::mk_bot(),\n       'b' => return ty::mk_bool(),\n       'i' => return ty::mk_int(),\n       'u' => return ty::mk_uint(),\n@@ -590,10 +589,16 @@ fn parse_sig(st: &mut PState, conv: conv_did) -> ty::FnSig {\n         'N' => false,\n         r => fail!(format!(\"bad variadic: {}\", r)),\n     };\n-    let ret_ty = parse_ty(st, |x,y| conv(x,y));\n+    let output = match peek(st) {\n+        'z' => {\n+          st.pos += 1u;\n+          ty::FnDiverging\n+        }\n+        _ => ty::FnConverging(parse_ty(st, |x,y| conv(x,y)))\n+    };\n     ty::FnSig {binder_id: id,\n                inputs: inputs,\n-               output: ret_ty,\n+               output: output,\n                variadic: variadic}\n }\n "}, {"sha": "5fb1fec53400cfe2b47f3deae2e51dc92740f62e", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -200,7 +200,6 @@ pub fn enc_trait_store(w: &mut SeekableMemWriter, cx: &ctxt, s: ty::TraitStore)\n fn enc_sty(w: &mut SeekableMemWriter, cx: &ctxt, st: &ty::sty) {\n     match *st {\n         ty::ty_nil => mywrite!(w, \"n\"),\n-        ty::ty_bot => mywrite!(w, \"z\"),\n         ty::ty_bool => mywrite!(w, \"b\"),\n         ty::ty_char => mywrite!(w, \"c\"),\n         ty::ty_int(t) => {\n@@ -346,7 +345,14 @@ fn enc_fn_sig(w: &mut SeekableMemWriter, cx: &ctxt, fsig: &ty::FnSig) {\n     } else {\n         mywrite!(w, \"N\");\n     }\n-    enc_ty(w, cx, fsig.output);\n+    match fsig.output {\n+        ty::FnConverging(result_type) => {\n+            enc_ty(w, cx, result_type);\n+        }\n+        ty::FnDiverging => {\n+            mywrite!(w, \"z\");\n+        }\n+    }\n }\n \n pub fn enc_builtin_bounds(w: &mut SeekableMemWriter, _cx: &ctxt, bs: &ty::BuiltinBounds) {"}, {"sha": "146891825d6846a2b01dc2b7206efea5e4a9c9de", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -511,12 +511,15 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             pred: CFGIndex,\n             func_or_rcvr: &ast::Expr,\n             args: I) -> CFGIndex {\n+        let method_call = typeck::MethodCall::expr(call_expr.id);\n+        let return_ty = ty::ty_fn_ret(match self.tcx.method_map.borrow().find(&method_call) {\n+            Some(method) => method.ty,\n+            None => ty::expr_ty(self.tcx, func_or_rcvr)\n+        });\n+\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n-\n-        let return_ty = ty::node_id_to_type(self.tcx, call_expr.id);\n-        let fails = ty::type_is_bot(return_ty);\n-        if fails {\n+        if return_ty == ty::FnDiverging {\n             self.add_node(ast::DUMMY_NODE_ID, [])\n         } else {\n             ret"}, {"sha": "e8a85b89b58474d5d1373dd65cd761b858cd1f30", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -396,13 +396,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n                 let expr_ty = ty::expr_ty(self.tcx(), expr);\n-                if !ty::type_is_bot(expr_ty) {\n-                    let r = ty::ty_region(self.tcx(), expr.span, expr_ty);\n-                    let bk = ty::BorrowKind::from_mutbl(m);\n-                    self.borrow_expr(&**base, r, bk, AddrOf);\n-                } else {\n-                    self.walk_expr(&**base);\n-                }\n+                let r = ty::ty_region(self.tcx(), expr.span, expr_ty);\n+                let bk = ty::BorrowKind::from_mutbl(m);\n+                self.borrow_expr(&**base, r, bk, AddrOf);\n             }\n \n             ast::ExprInlineAsm(ref ia) => {"}, {"sha": "1dd823539b4c6216cf0b179085eb0ec3dd818398", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -126,9 +126,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n                         match ty::get(typ).sty {\n                             ty_bare_fn(ref bare_fn_ty)\n                                     if bare_fn_ty.abi == RustIntrinsic => {\n-                                let from = bare_fn_ty.sig.inputs[0];\n-                                let to = bare_fn_ty.sig.output;\n-                                self.check_transmute(expr.span, from, to, expr.id);\n+                                if let ty::FnConverging(to) = bare_fn_ty.sig.output {\n+                                    let from = bare_fn_ty.sig.inputs[0];\n+                                    self.check_transmute(expr.span, from, to, expr.id);\n+                                }\n                             }\n                             _ => {\n                                 self.tcx"}, {"sha": "3d031c966ae0a0a19bca5cb8fe97c0c21e82cc10", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 80, "deletions": 53, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -100,11 +100,16 @@\n  * - `no_ret_var`: a synthetic variable that is only 'read' from, the\n  *   fallthrough node.  This allows us to detect functions where we fail\n  *   to return explicitly.\n+ * - `clean_exit_var`: a synthetic variable that is only 'read' from the\n+ *   fallthrough node.  It is only live if the function could converge\n+ *   via means other than an explicit `return` expression. That is, it is\n+ *   only dead if the end of the function's block can never be reached.\n  */\n \n use middle::def::*;\n use middle::mem_categorization::Typer;\n use middle::pat_util;\n+use middle::typeck;\n use middle::ty;\n use lint;\n use util::nodemap::NodeMap;\n@@ -250,7 +255,8 @@ struct LocalInfo {\n enum VarKind {\n     Arg(NodeId, Ident),\n     Local(LocalInfo),\n-    ImplicitRet\n+    ImplicitRet,\n+    CleanExit\n }\n \n struct IrMaps<'a, 'tcx: 'a> {\n@@ -306,7 +312,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n             Local(LocalInfo { id: node_id, .. }) | Arg(node_id, _) => {\n                 self.variable_map.insert(node_id, v);\n             },\n-            ImplicitRet => {}\n+            ImplicitRet | CleanExit => {}\n         }\n \n         debug!(\"{} is {}\", v.to_string(), vk);\n@@ -331,7 +337,8 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n             Local(LocalInfo { ident: nm, .. }) | Arg(_, nm) => {\n                 token::get_ident(nm).get().to_string()\n             },\n-            ImplicitRet => \"<implicit-ret>\".to_string()\n+            ImplicitRet => \"<implicit-ret>\".to_string(),\n+            CleanExit => \"<clean-exit>\".to_string()\n         }\n     }\n \n@@ -397,7 +404,8 @@ fn visit_fn(ir: &mut IrMaps,\n     let specials = Specials {\n         exit_ln: fn_maps.add_live_node(ExitNode),\n         fallthrough_ln: fn_maps.add_live_node(ExitNode),\n-        no_ret_var: fn_maps.add_variable(ImplicitRet)\n+        no_ret_var: fn_maps.add_variable(ImplicitRet),\n+        clean_exit_var: fn_maps.add_variable(CleanExit)\n     };\n \n     // compute liveness\n@@ -546,7 +554,8 @@ fn invalid_users() -> Users {\n struct Specials {\n     exit_ln: LiveNode,\n     fallthrough_ln: LiveNode,\n-    no_ret_var: Variable\n+    no_ret_var: Variable,\n+    clean_exit_var: Variable\n }\n \n static ACC_READ: uint = 1u;\n@@ -873,6 +882,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         if blk.expr.is_none() {\n             self.acc(s.fallthrough_ln, s.no_ret_var, ACC_READ)\n         }\n+        self.acc(s.fallthrough_ln, s.clean_exit_var, ACC_READ);\n \n         self.propagate_through_block(blk, s.fallthrough_ln)\n     }\n@@ -943,9 +953,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                                   opt_expr: Option<&Expr>,\n                                   succ: LiveNode)\n                                   -> LiveNode {\n-        opt_expr.iter().fold(succ, |succ, expr| {\n-            self.propagate_through_expr(&**expr, succ)\n-        })\n+        opt_expr.map_or(succ, |expr| self.propagate_through_expr(expr, succ))\n     }\n \n     fn propagate_through_expr(&mut self, expr: &Expr, succ: LiveNode)\n@@ -1146,13 +1154,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           ExprCall(ref f, ref args) => {\n-            // calling a fn with bot return type means that the fn\n-            // will fail, and hence the successors can be ignored\n-            let is_bot = !self.ir.tcx.is_method_call(expr.id) && {\n+            let diverges = !self.ir.tcx.is_method_call(expr.id) && {\n                 let t_ret = ty::ty_fn_ret(ty::expr_ty(self.ir.tcx, &**f));\n-                ty::type_is_bot(t_ret)\n+                t_ret == ty::FnDiverging\n             };\n-            let succ = if is_bot {\n+            let succ = if diverges {\n                 self.s.exit_ln\n             } else {\n                 succ\n@@ -1162,11 +1168,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           ExprMethodCall(_, _, ref args) => {\n-            // calling a method with bot return type means that the method\n-            // will fail, and hence the successors can be ignored\n-            let t_ret = ty::node_id_to_type(self.ir.tcx, expr.id);\n-            let succ = if ty::type_is_bot(t_ret) {self.s.exit_ln}\n-                       else {succ};\n+            let method_call = typeck::MethodCall::expr(expr.id);\n+            let method_ty = self.ir.tcx.method_map.borrow().find(&method_call).unwrap().ty;\n+            let diverges = ty::ty_fn_ret(method_ty) == ty::FnDiverging;\n+            let succ = if diverges {\n+                self.s.exit_ln\n+            } else {\n+                succ\n+            };\n             self.propagate_through_exprs(args.as_slice(), succ)\n           }\n \n@@ -1507,50 +1516,68 @@ fn check_fn(_v: &Liveness,\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n+    fn fn_ret(&self, id: NodeId) -> ty::FnOutput {\n+        let fn_ty = ty::node_id_to_type(self.ir.tcx, id);\n+        match ty::get(fn_ty).sty {\n+            ty::ty_unboxed_closure(closure_def_id, _, _) =>\n+                self.ir.tcx.unboxed_closures()\n+                    .borrow()\n+                    .find(&closure_def_id)\n+                    .unwrap()\n+                    .closure_type\n+                    .sig\n+                    .output,\n+            _ => ty::ty_fn_ret(fn_ty)\n+        }\n+    }\n+\n     fn check_ret(&self,\n                  id: NodeId,\n                  sp: Span,\n                  _fk: FnKind,\n                  entry_ln: LiveNode,\n                  body: &Block) {\n-        if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n-            // if no_ret_var is live, then we fall off the end of the\n-            // function without any kind of return expression:\n-\n-            let t_ret = ty::ty_fn_ret(ty::node_id_to_type(self.ir.tcx, id));\n-            if ty::type_is_nil(t_ret) {\n-                // for nil return types, it is ok to not return a value expl.\n-            } else if ty::type_is_bot(t_ret) {\n-                // for bot return types, not ok.  Function should fail.\n-                self.ir.tcx.sess.span_err(\n-                    sp, \"some control paths may return\");\n-            } else {\n-                let ends_with_stmt = match body.expr {\n-                    None if body.stmts.len() > 0 =>\n-                        match body.stmts.last().unwrap().node {\n-                            StmtSemi(ref e, _) => {\n-                                let t_stmt = ty::expr_ty(self.ir.tcx, &**e);\n-                                ty::get(t_stmt).sty == ty::get(t_ret).sty\n+        match self.fn_ret(id) {\n+            ty::FnConverging(t_ret)\n+                if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() => {\n+\n+                if ty::type_is_nil(t_ret) {\n+                    // for nil return types, it is ok to not return a value expl.\n+                } else {\n+                    let ends_with_stmt = match body.expr {\n+                        None if body.stmts.len() > 0 =>\n+                            match body.stmts.last().unwrap().node {\n+                                StmtSemi(ref e, _) => {\n+                                    let t_stmt = ty::expr_ty(self.ir.tcx, &**e);\n+                                    ty::get(t_stmt).sty == ty::get(t_ret).sty\n+                                },\n+                                _ => false\n                             },\n-                            _ => false\n-                        },\n-                    _ => false\n-                };\n-                self.ir.tcx.sess.span_err(\n-                    sp, \"not all control paths return a value\");\n-                if ends_with_stmt {\n-                    let last_stmt = body.stmts.last().unwrap();\n-                    let original_span = original_sp(self.ir.tcx.sess.codemap(),\n-                                                    last_stmt.span, sp);\n-                    let span_semicolon = Span {\n-                        lo: original_span.hi - BytePos(1),\n-                        hi: original_span.hi,\n-                        expn_id: original_span.expn_id\n+                        _ => false\n                     };\n-                    self.ir.tcx.sess.span_note(\n-                        span_semicolon, \"consider removing this semicolon:\");\n+                    self.ir.tcx.sess.span_err(\n+                        sp, \"not all control paths return a value\");\n+                    if ends_with_stmt {\n+                        let last_stmt = body.stmts.last().unwrap();\n+                        let original_span = original_sp(self.ir.tcx.sess.codemap(),\n+                                                        last_stmt.span, sp);\n+                        let span_semicolon = Span {\n+                            lo: original_span.hi - BytePos(1),\n+                            hi: original_span.hi,\n+                            expn_id: original_span.expn_id\n+                        };\n+                        self.ir.tcx.sess.span_note(\n+                            span_semicolon, \"consider removing this semicolon:\");\n+                    }\n                 }\n-           }\n+            }\n+            ty::FnDiverging\n+                if self.live_on_entry(entry_ln, self.s.clean_exit_var).is_some() => {\n+                    self.ir.tcx.sess.span_err(sp,\n+                        \"computation may converge in a function marked as diverging\");\n+                }\n+\n+            _ => {}\n         }\n     }\n "}, {"sha": "c0188cac259ced92a9509683844e371c9103305a", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -485,7 +485,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 Some(method_ty) => {\n                     // If this is an index implemented by a method call, then it will\n                     // include an implicit deref of the result.\n-                    let ret_ty = ty::ty_fn_ret(method_ty);\n+                    let ret_ty = ty::ty_fn_ret(method_ty).unwrap();\n                     Ok(self.cat_deref(expr,\n                                       self.cat_rvalue_node(expr.id(),\n                                                            expr.span(),\n@@ -878,7 +878,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         let base_cmt = match method_ty {\n             Some(method_ty) => {\n-                let ref_ty = ty::ty_fn_ret(method_ty);\n+                let ref_ty = ty::ty_fn_ret(method_ty).unwrap();\n                 self.cat_rvalue_node(node.id(), node.span(), ref_ty)\n             }\n             None => base_cmt\n@@ -957,7 +957,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         let element_ty = match method_ty {\n             Some(method_ty) => {\n-                let ref_ty = ty::ty_fn_ret(method_ty);\n+                let ref_ty = ty::ty_fn_ret(method_ty).unwrap();\n                 base_cmt = self.cat_rvalue_node(elt.id(), elt.span(), ref_ty);\n                 ty::ty_fn_args(method_ty)[0]\n             }"}, {"sha": "8b2ddca3131971acb997194d5911956947e05ced", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -80,7 +80,6 @@ pub fn ty_is_local(tcx: &ty::ctxt,\n \n     match ty::get(ty).sty {\n         ty::ty_nil |\n-        ty::ty_bot |\n         ty::ty_bool |\n         ty::ty_char |\n         ty::ty_int(..) |"}, {"sha": "f8c1c37452b38c4e93b6ac35a75ee3cbc720b382", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -1193,7 +1193,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::ty_uint(_) |\n             ty::ty_int(_) |\n             ty::ty_nil |\n-            ty::ty_bot |\n             ty::ty_bool |\n             ty::ty_float(_) |\n             ty::ty_bare_fn(_) |\n@@ -1681,7 +1680,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             def_id: obligation.trait_ref.def_id,\n             substs: Substs::new_trait(\n                 vec![arguments_tuple.subst(self.tcx(), substs),\n-                     new_signature.output.subst(self.tcx(), substs)],\n+                     new_signature.output.unwrap().subst(self.tcx(), substs)],\n                 vec![],\n                 obligation.self_ty())\n         });"}, {"sha": "2379a5e7f53a2e6f8a04db11175a5c35cdf7394f", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -1462,15 +1462,11 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // General path.\n             let init_datum =\n                 unpack_datum!(bcx, expr::trans_to_lvalue(bcx, &**init_expr, \"let\"));\n-            if ty::type_is_bot(expr_ty(bcx, &**init_expr)) {\n-                create_dummy_locals(bcx, pat)\n-            } else {\n-                if bcx.sess().asm_comments() {\n-                    add_comment(bcx, \"creating zeroable ref llval\");\n-                }\n-                let var_scope = cleanup::var_scope(tcx, local.id);\n-                bind_irrefutable_pat(bcx, pat, init_datum.val, var_scope)\n+            if bcx.sess().asm_comments() {\n+                add_comment(bcx, \"creating zeroable ref llval\");\n             }\n+            let var_scope = cleanup::var_scope(tcx, local.id);\n+            bind_irrefutable_pat(bcx, pat, init_datum.val, var_scope)\n         }\n         None => {\n             create_dummy_locals(bcx, pat)"}, {"sha": "16ff2f901f6d59b73a3f74787a62068baf819aba", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 106, "deletions": 89, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -180,20 +180,17 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n \n // only use this for foreign function ABIs and glue, use `decl_rust_fn` for Rust functions\n pub fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n-           ty: Type, output: ty::t) -> ValueRef {\n+           ty: Type, output: ty::FnOutput) -> ValueRef {\n \n     let llfn: ValueRef = name.with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMGetOrInsertFunction(ccx.llmod(), buf, ty.to_ref())\n         }\n     });\n \n-    match ty::get(output).sty {\n-        // functions returning bottom may unwind, but can never return normally\n-        ty::ty_bot => {\n-            llvm::SetFunctionAttribute(llfn, llvm::NoReturnAttribute)\n-        }\n-        _ => {}\n+    // diverging functions may unwind, but can never return normally\n+    if output == ty::FnDiverging {\n+        llvm::SetFunctionAttribute(llfn, llvm::NoReturnAttribute);\n     }\n \n     if ccx.tcx().sess.opts.cg.no_redzone {\n@@ -216,7 +213,7 @@ pub fn decl_cdecl_fn(ccx: &CrateContext,\n                      name: &str,\n                      ty: Type,\n                      output: ty::t) -> ValueRef {\n-    decl_fn(ccx, name, llvm::CCallConv, ty, output)\n+    decl_fn(ccx, name, llvm::CCallConv, ty, ty::FnConverging(output))\n }\n \n // only use this for foreign function ABIs and glue, use `get_extern_rust_fn` for Rust functions\n@@ -231,7 +228,7 @@ pub fn get_extern_fn(ccx: &CrateContext,\n         Some(n) => return *n,\n         None => {}\n     }\n-    let f = decl_fn(ccx, name, cc, ty, output);\n+    let f = decl_fn(ccx, name, cc, ty, ty::FnConverging(output));\n     externs.insert(name.to_string(), f);\n     f\n }\n@@ -1417,7 +1414,7 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n                              llfndecl: ValueRef,\n                              id: ast::NodeId,\n                              has_env: bool,\n-                             output_type: ty::t,\n+                             output_type: ty::FnOutput,\n                              param_substs: &'a param_substs,\n                              sp: Option<Span>,\n                              block_arena: &'a TypedArena<common::BlockS<'a, 'tcx>>)\n@@ -1432,8 +1429,13 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n            },\n            id, param_substs.repr(ccx.tcx()));\n \n-    let substd_output_type = output_type.substp(ccx.tcx(), param_substs);\n-    let uses_outptr = type_of::return_uses_outptr(ccx, substd_output_type);\n+    let uses_outptr = match output_type {\n+        ty::FnConverging(output_type) => {\n+            let substd_output_type = output_type.substp(ccx.tcx(), param_substs);\n+            type_of::return_uses_outptr(ccx, substd_output_type)\n+        }\n+        ty::FnDiverging => false\n+    };\n     let debug_context = debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl);\n     let nested_returns = has_nested_returns(ccx.tcx(), id);\n \n@@ -1468,7 +1470,7 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n /// and allocating space for the return pointer.\n pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n                                skip_retptr: bool,\n-                               output_type: ty::t) -> Block<'a, 'tcx> {\n+                               output: ty::FnOutput) -> Block<'a, 'tcx> {\n     let entry_bcx = fcx.new_temp_block(\"entry-block\");\n \n     // Use a dummy instruction as the insertion point for all allocas.\n@@ -1478,18 +1480,19 @@ pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n         llvm::LLVMGetFirstInstruction(entry_bcx.llbb)\n     }));\n \n-    // This shouldn't need to recompute the return type,\n-    // as new_fn_ctxt did it already.\n-    let substd_output_type = output_type.substp(fcx.ccx.tcx(), fcx.param_substs);\n-\n-    if !return_type_is_void(fcx.ccx, substd_output_type) {\n-        // If the function returns nil/bot, there is no real return\n-        // value, so do not set `llretslotptr`.\n-        if !skip_retptr || fcx.caller_expects_out_pointer {\n-            // Otherwise, we normally allocate the llretslotptr, unless we\n-            // have been instructed to skip it for immediate return\n-            // values.\n-            fcx.llretslotptr.set(Some(make_return_slot_pointer(fcx, substd_output_type)));\n+    if let ty::FnConverging(output_type) = output {\n+        // This shouldn't need to recompute the return type,\n+        // as new_fn_ctxt did it already.\n+        let substd_output_type = output_type.substp(fcx.ccx.tcx(), fcx.param_substs);\n+        if !return_type_is_void(fcx.ccx, substd_output_type) {\n+            // If the function returns nil/bot, there is no real return\n+            // value, so do not set `llretslotptr`.\n+            if !skip_retptr || fcx.caller_expects_out_pointer {\n+                // Otherwise, we normally allocate the llretslotptr, unless we\n+                // have been instructed to skip it for immediate return\n+                // values.\n+                fcx.llretslotptr.set(Some(make_return_slot_pointer(fcx, substd_output_type)));\n+            }\n         }\n     }\n \n@@ -1693,13 +1696,9 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n // and builds the return block.\n pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n                              last_bcx: Block<'blk, 'tcx>,\n-                             retty: ty::t) {\n+                             retty: ty::FnOutput) {\n     let _icx = push_ctxt(\"finish_fn\");\n \n-    // This shouldn't need to recompute the return type,\n-    // as new_fn_ctxt did it already.\n-    let substd_retty = retty.substp(fcx.ccx.tcx(), fcx.param_substs);\n-\n     let ret_cx = match fcx.llreturn.get() {\n         Some(llreturn) => {\n             if !last_bcx.terminated.get() {\n@@ -1709,13 +1708,18 @@ pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n         }\n         None => last_bcx\n     };\n+\n+    // This shouldn't need to recompute the return type,\n+    // as new_fn_ctxt did it already.\n+    let substd_retty = retty.substp(fcx.ccx.tcx(), fcx.param_substs);\n     build_return_block(fcx, ret_cx, substd_retty);\n+\n     debuginfo::clear_source_location(fcx);\n     fcx.cleanup();\n }\n \n // Builds the return block for a function.\n-pub fn build_return_block(fcx: &FunctionContext, ret_cx: Block, retty: ty::t) {\n+pub fn build_return_block(fcx: &FunctionContext, ret_cx: Block, retty: ty::FnOutput) {\n     if fcx.llretslotptr.get().is_none() ||\n        (!fcx.needs_ret_allocas && fcx.caller_expects_out_pointer) {\n         return RetVoid(ret_cx);\n@@ -1738,26 +1742,37 @@ pub fn build_return_block(fcx: &FunctionContext, ret_cx: Block, retty: ty::t) {\n                 retptr.erase_from_parent();\n             }\n \n-            let retval = if ty::type_is_bool(retty) {\n+            let retval = if retty == ty::FnConverging(ty::mk_bool()) {\n                 Trunc(ret_cx, retval, Type::i1(fcx.ccx))\n             } else {\n                 retval\n             };\n \n             if fcx.caller_expects_out_pointer {\n-                store_ty(ret_cx, retval, get_param(fcx.llfn, 0), retty);\n-                return RetVoid(ret_cx);\n+                if let ty::FnConverging(retty) = retty {\n+                    store_ty(ret_cx, retval, get_param(fcx.llfn, 0), retty);\n+                }\n+                RetVoid(ret_cx)\n             } else {\n-                return Ret(ret_cx, retval);\n+                Ret(ret_cx, retval)\n             }\n         }\n         // Otherwise, copy the return value to the ret slot\n-        None => {\n-            if fcx.caller_expects_out_pointer {\n-                memcpy_ty(ret_cx, get_param(fcx.llfn, 0), retslot, retty);\n-                return RetVoid(ret_cx);\n-            } else {\n-                return Ret(ret_cx, load_ty(ret_cx, retslot, retty));\n+        None => match retty {\n+            ty::FnConverging(retty) => {\n+                if fcx.caller_expects_out_pointer {\n+                    memcpy_ty(ret_cx, get_param(fcx.llfn, 0), retslot, retty);\n+                    RetVoid(ret_cx)\n+                } else {\n+                    Ret(ret_cx, load_ty(ret_cx, retslot, retty))\n+                }\n+            }\n+            ty::FnDiverging => {\n+                if fcx.caller_expects_out_pointer {\n+                    RetVoid(ret_cx)\n+                } else {\n+                    Ret(ret_cx, C_undef(Type::nil(fcx.ccx)))\n+                }\n             }\n         }\n     }\n@@ -1780,7 +1795,7 @@ pub fn trans_closure(ccx: &CrateContext,\n                      fn_ast_id: ast::NodeId,\n                      _attributes: &[ast::Attribute],\n                      arg_types: Vec<ty::t>,\n-                     output_type: ty::t,\n+                     output_type: ty::FnOutput,\n                      abi: Abi,\n                      has_env: bool,\n                      is_unboxed_closure: IsUnboxedClosureFlag,\n@@ -1860,7 +1875,7 @@ pub fn trans_closure(ccx: &CrateContext,\n     debuginfo::start_emitting_source_locations(&fcx);\n \n     let dest = match fcx.llretslotptr.get() {\n-        Some(_) => expr::SaveIn(fcx.get_ret_slot(bcx, block_ty, \"iret_slot\")),\n+        Some(_) => expr::SaveIn(fcx.get_ret_slot(bcx, ty::FnConverging(block_ty), \"iret_slot\")),\n         None => {\n             assert!(type_is_zero_size(bcx.ccx(), block_ty));\n             expr::Ignore\n@@ -1965,7 +1980,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = ccx.tcx();\n \n     let result_ty = match ty::get(ctor_ty).sty {\n-        ty::ty_bare_fn(ref bft) => bft.sig.output,\n+        ty::ty_bare_fn(ref bft) => bft.sig.output.unwrap(),\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_constructor: \\\n                      unexpected ctor return type {}\",\n@@ -2055,9 +2070,9 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n \n     let arg_datums = create_datums_for_fn_args(&fcx, arg_tys.as_slice());\n \n-    if !type_is_zero_size(fcx.ccx, result_ty) {\n+    if !type_is_zero_size(fcx.ccx, result_ty.unwrap()) {\n         let dest = fcx.get_ret_slot(bcx, result_ty, \"eret_slot\");\n-        let repr = adt::represent_type(ccx, result_ty);\n+        let repr = adt::represent_type(ccx, result_ty.unwrap());\n         for (i, arg_datum) in arg_datums.into_iter().enumerate() {\n             let lldestptr = adt::trans_field_ptr(bcx,\n                                                  &*repr,\n@@ -2393,53 +2408,55 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n         _ => fn_sig.inputs.clone()\n     };\n \n-    // A function pointer is called without the declaration\n-    // available, so we have to apply any attributes with ABI\n-    // implications directly to the call instruction. Right now,\n-    // the only attribute we need to worry about is `sret`.\n-    if type_of::return_uses_outptr(ccx, ret_ty) {\n-        let llret_sz = llsize_of_real(ccx, type_of::type_of(ccx, ret_ty));\n-\n-        // The outptr can be noalias and nocapture because it's entirely\n-        // invisible to the program. We also know it's nonnull as well\n-        // as how many bytes we can dereference\n-        attrs.arg(1, llvm::StructRetAttribute)\n-             .arg(1, llvm::NoAliasAttribute)\n-             .arg(1, llvm::NoCaptureAttribute)\n-             .arg(1, llvm::DereferenceableAttribute(llret_sz));\n-\n-        // Add one more since there's an outptr\n-        first_arg_offset += 1;\n-    } else {\n-        // The `noalias` attribute on the return value is useful to a\n-        // function ptr caller.\n-        match ty::get(ret_ty).sty {\n-            // `~` pointer return values never alias because ownership\n-            // is transferred\n-            ty::ty_uniq(it) if !ty::type_is_sized(ccx.tcx(), it) => {}\n-            ty::ty_uniq(_) => {\n-                attrs.ret(llvm::NoAliasAttribute);\n+    if let ty::FnConverging(ret_ty) = ret_ty {\n+        // A function pointer is called without the declaration\n+        // available, so we have to apply any attributes with ABI\n+        // implications directly to the call instruction. Right now,\n+        // the only attribute we need to worry about is `sret`.\n+        if type_of::return_uses_outptr(ccx, ret_ty) {\n+            let llret_sz = llsize_of_real(ccx, type_of::type_of(ccx, ret_ty));\n+\n+            // The outptr can be noalias and nocapture because it's entirely\n+            // invisible to the program. We also know it's nonnull as well\n+            // as how many bytes we can dereference\n+            attrs.arg(1, llvm::StructRetAttribute)\n+                 .arg(1, llvm::NoAliasAttribute)\n+                 .arg(1, llvm::NoCaptureAttribute)\n+                 .arg(1, llvm::DereferenceableAttribute(llret_sz));\n+\n+            // Add one more since there's an outptr\n+            first_arg_offset += 1;\n+        } else {\n+            // The `noalias` attribute on the return value is useful to a\n+            // function ptr caller.\n+            match ty::get(ret_ty).sty {\n+                // `~` pointer return values never alias because ownership\n+                // is transferred\n+                ty::ty_uniq(it) if !ty::type_is_sized(ccx.tcx(), it) => {}\n+                ty::ty_uniq(_) => {\n+                    attrs.ret(llvm::NoAliasAttribute);\n+                }\n+                _ => {}\n             }\n-            _ => {}\n-        }\n \n-        // We can also mark the return value as `dereferenceable` in certain cases\n-        match ty::get(ret_ty).sty {\n-            // These are not really pointers but pairs, (pointer, len)\n-            ty::ty_uniq(it) |\n-            ty::ty_rptr(_, ty::mt { ty: it, .. }) if !ty::type_is_sized(ccx.tcx(), it) => {}\n-            ty::ty_uniq(inner) | ty::ty_rptr(_, ty::mt { ty: inner, .. }) => {\n-                let llret_sz = llsize_of_real(ccx, type_of::type_of(ccx, inner));\n-                attrs.ret(llvm::DereferenceableAttribute(llret_sz));\n+            // We can also mark the return value as `dereferenceable` in certain cases\n+            match ty::get(ret_ty).sty {\n+                // These are not really pointers but pairs, (pointer, len)\n+                ty::ty_uniq(it) |\n+                ty::ty_rptr(_, ty::mt { ty: it, .. }) if !ty::type_is_sized(ccx.tcx(), it) => {}\n+                ty::ty_uniq(inner) | ty::ty_rptr(_, ty::mt { ty: inner, .. }) => {\n+                    let llret_sz = llsize_of_real(ccx, type_of::type_of(ccx, inner));\n+                    attrs.ret(llvm::DereferenceableAttribute(llret_sz));\n+                }\n+                _ => {}\n             }\n-            _ => {}\n-        }\n \n-        match ty::get(ret_ty).sty {\n-            ty::ty_bool => {\n-                attrs.ret(llvm::ZExtAttribute);\n+            match ty::get(ret_ty).sty {\n+                ty::ty_bool => {\n+                    attrs.ret(llvm::ZExtAttribute);\n+                }\n+                _ => {}\n             }\n-            _ => {}\n         }\n     }\n \n@@ -2523,7 +2540,7 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n                           llfty: Type) -> ValueRef {\n     debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n-    let llfn = decl_fn(ccx, sym.as_slice(), cc, llfty, ty::mk_nil());\n+    let llfn = decl_fn(ccx, sym.as_slice(), cc, llfty, ty::FnConverging(ty::mk_nil()));\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }"}, {"sha": "045f50bf6b1e0013f8156d59f9bd6be125d78c8f", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 70, "deletions": 76, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -375,10 +375,9 @@ pub fn trans_unboxing_shim(bcx: Block,\n         llshimmedargs.push(get_param(fcx.llfn, fcx.arg_pos(i) as u32));\n     }\n     assert!(!fcx.needs_ret_allocas);\n-    let dest = match fcx.llretslotptr.get() {\n-        Some(_) => Some(expr::SaveIn(fcx.get_ret_slot(bcx, return_type, \"ret_slot\"))),\n-        None => None\n-    };\n+    let dest = fcx.llretslotptr.get().map(|_|\n+        expr::SaveIn(fcx.get_ret_slot(bcx, return_type, \"ret_slot\"))\n+    );\n     bcx = trans_call_inner(bcx,\n                            None,\n                            function_type,\n@@ -757,24 +756,29 @@ pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Generate a location to store the result. If the user does\n     // not care about the result, just make a stack slot.\n-    let opt_llretslot = match dest {\n-        None => {\n-            assert!(!type_of::return_uses_outptr(ccx, ret_ty));\n-            None\n-        }\n-        Some(expr::SaveIn(dst)) => Some(dst),\n-        Some(expr::Ignore) if !is_rust_fn ||\n-                type_of::return_uses_outptr(ccx, ret_ty) ||\n-                ty::type_needs_drop(bcx.tcx(), ret_ty) => {\n-            if !type_is_zero_size(ccx, ret_ty) {\n-                Some(alloc_ty(bcx, ret_ty, \"__llret\"))\n+    let opt_llretslot = dest.and_then(|dest| match dest {\n+        expr::SaveIn(dst) => Some(dst),\n+        expr::Ignore => {\n+            let ret_ty = match ret_ty {\n+                ty::FnConverging(ret_ty) => ret_ty,\n+                ty::FnDiverging => ty::mk_nil()\n+            };\n+            if !is_rust_fn ||\n+              type_of::return_uses_outptr(ccx, ret_ty) ||\n+              ty::type_needs_drop(bcx.tcx(), ret_ty) {\n+                // Push the out-pointer if we use an out-pointer for this\n+                // return type, otherwise push \"undef\".\n+                if type_is_zero_size(ccx, ret_ty) {\n+                    let llty = type_of::type_of(ccx, ret_ty);\n+                    Some(C_undef(llty.ptr_to()))\n+                } else {\n+                    Some(alloc_ty(bcx, ret_ty, \"__llret\"))\n+                }\n             } else {\n-                let llty = type_of::type_of(ccx, ret_ty);\n-                Some(C_undef(llty.ptr_to()))\n+                None\n             }\n         }\n-        Some(expr::Ignore) => None\n-    };\n+    });\n \n     let mut llresult = unsafe {\n         llvm::LLVMGetUndef(Type::nil(ccx).ptr_to().to_ref())\n@@ -789,17 +793,15 @@ pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     if is_rust_fn {\n         let mut llargs = Vec::new();\n \n-        // Push the out-pointer if we use an out-pointer for this\n-        // return type, otherwise push \"undef\".\n-        if type_of::return_uses_outptr(ccx, ret_ty) {\n-            llargs.push(opt_llretslot.unwrap());\n+        if let (ty::FnConverging(ret_ty), Some(llretslot)) = (ret_ty, opt_llretslot) {\n+            if type_of::return_uses_outptr(ccx, ret_ty) {\n+                llargs.push(llretslot);\n+            }\n         }\n \n         // Push the environment (or a trait object's self).\n         match (llenv, llself) {\n-            (Some(llenv), None) => {\n-                llargs.push(llenv)\n-            },\n+            (Some(llenv), None) => llargs.push(llenv),\n             (None, Some(llself)) => llargs.push(llself),\n             _ => {}\n         }\n@@ -827,15 +829,15 @@ pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         // If the Rust convention for this type is return via\n         // the return value, copy it into llretslot.\n-        match opt_llretslot {\n-            Some(llretslot) => {\n+        match (opt_llretslot, ret_ty) {\n+            (Some(llretslot), ty::FnConverging(ret_ty)) => {\n                 if !type_of::return_uses_outptr(bcx.ccx(), ret_ty) &&\n                     !type_is_zero_size(bcx.ccx(), ret_ty)\n                 {\n                     store_ty(bcx, llret, llretslot, ret_ty)\n                 }\n             }\n-            None => {}\n+            (_, _) => {}\n         }\n     } else {\n         // Lang items are the only case where dest is None, and\n@@ -865,17 +867,20 @@ pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // If the caller doesn't care about the result of this fn call,\n     // drop the temporary slot we made.\n-    match (dest, opt_llretslot) {\n-        (Some(expr::Ignore), Some(llretslot)) => {\n+    match (dest, opt_llretslot, ret_ty) {\n+        (Some(expr::Ignore), Some(llretslot), ty::FnConverging(ret_ty)) => {\n             // drop the value if it is not being saved.\n             bcx = glue::drop_ty(bcx, llretslot, ret_ty, call_info);\n             call_lifetime_end(bcx, llretslot);\n         }\n         _ => {}\n     }\n \n-    if ty::type_is_bot(ret_ty) {\n-        Unreachable(bcx);\n+    match ret_ty {\n+        ty::FnConverging(_) => {},\n+        ty::FnDiverging => {\n+            Unreachable(bcx);\n+        }\n     }\n \n     Result::new(bcx, llresult)\n@@ -1118,52 +1123,41 @@ pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     debug!(\"   arg datum: {}\", arg_datum.to_string(bcx.ccx()));\n \n     let mut val;\n-    if ty::type_is_bot(arg_datum_ty) {\n-        // For values of type _|_, we generate an\n-        // \"undef\" value, as such a value should never\n-        // be inspected. It's important for the value\n-        // to have type lldestty (the callee's expected type).\n-        let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, formal_arg_ty);\n-        unsafe {\n-            val = llvm::LLVMGetUndef(llformal_arg_ty.to_ref());\n+    // FIXME(#3548) use the adjustments table\n+    match autoref_arg {\n+        DoAutorefArg(arg_id) => {\n+            // We will pass argument by reference\n+            // We want an lvalue, so that we can pass by reference and\n+            let arg_datum = unpack_datum!(\n+                bcx, arg_datum.to_lvalue_datum(bcx, \"arg\", arg_id));\n+            val = arg_datum.val;\n         }\n-    } else {\n-        // FIXME(#3548) use the adjustments table\n-        match autoref_arg {\n-            DoAutorefArg(arg_id) => {\n-                // We will pass argument by reference\n-                // We want an lvalue, so that we can pass by reference and\n-                let arg_datum = unpack_datum!(\n-                    bcx, arg_datum.to_lvalue_datum(bcx, \"arg\", arg_id));\n-                val = arg_datum.val;\n-            }\n-            DontAutorefArg => {\n-                // Make this an rvalue, since we are going to be\n-                // passing ownership.\n-                let arg_datum = unpack_datum!(\n-                    bcx, arg_datum.to_rvalue_datum(bcx, \"arg\"));\n-\n-                // Now that arg_datum is owned, get it into the appropriate\n-                // mode (ref vs value).\n-                let arg_datum = unpack_datum!(\n-                    bcx, arg_datum.to_appropriate_datum(bcx));\n-\n-                // Technically, ownership of val passes to the callee.\n-                // However, we must cleanup should we fail before the\n-                // callee is actually invoked.\n-                val = arg_datum.add_clean(bcx.fcx, arg_cleanup_scope);\n-            }\n+        DontAutorefArg => {\n+            // Make this an rvalue, since we are going to be\n+            // passing ownership.\n+            let arg_datum = unpack_datum!(\n+                bcx, arg_datum.to_rvalue_datum(bcx, \"arg\"));\n+\n+            // Now that arg_datum is owned, get it into the appropriate\n+            // mode (ref vs value).\n+            let arg_datum = unpack_datum!(\n+                bcx, arg_datum.to_appropriate_datum(bcx));\n+\n+            // Technically, ownership of val passes to the callee.\n+            // However, we must cleanup should we fail before the\n+            // callee is actually invoked.\n+            val = arg_datum.add_clean(bcx.fcx, arg_cleanup_scope);\n         }\n+    }\n \n-        if formal_arg_ty != arg_datum_ty {\n-            // this could happen due to e.g. subtyping\n-            let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, formal_arg_ty);\n-            debug!(\"casting actual type ({}) to match formal ({})\",\n-                   bcx.val_to_string(val), bcx.llty_str(llformal_arg_ty));\n-            debug!(\"Rust types: {}; {}\", ty_to_string(bcx.tcx(), arg_datum_ty),\n-                                         ty_to_string(bcx.tcx(), formal_arg_ty));\n-            val = PointerCast(bcx, val, llformal_arg_ty);\n-        }\n+    if formal_arg_ty != arg_datum_ty {\n+        // this could happen due to e.g. subtyping\n+        let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, formal_arg_ty);\n+        debug!(\"casting actual type ({}) to match formal ({})\",\n+               bcx.val_to_string(val), bcx.llty_str(llformal_arg_ty));\n+        debug!(\"Rust types: {}; {}\", ty_to_string(bcx.tcx(), arg_datum_ty),\n+                                     ty_to_string(bcx.tcx(), formal_arg_ty));\n+        val = PointerCast(bcx, val, llformal_arg_ty);\n     }\n \n     debug!(\"--- trans_arg_datum passing {}\", bcx.val_to_string(val));"}, {"sha": "b6f45b2ccda774754abf154943a6acb36e089c5b", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -623,10 +623,17 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n     llargs.extend(args.iter().map(|arg| arg.val));\n \n     let retval = Call(bcx, fn_ptr, llargs.as_slice(), None);\n-    if type_is_zero_size(ccx, f.sig.output) || fcx.llretslotptr.get().is_some() {\n-        RetVoid(bcx);\n-    } else {\n-        Ret(bcx, retval);\n+    match f.sig.output {\n+        ty::FnConverging(output_type) => {\n+            if type_is_zero_size(ccx, output_type) || fcx.llretslotptr.get().is_some() {\n+                RetVoid(bcx);\n+            } else {\n+                Ret(bcx, retval);\n+            }\n+        }\n+        ty::FnDiverging => {\n+            RetVoid(bcx);\n+        }\n     }\n \n     // HACK(eddyb) finish_fn cannot be used here, we returned directly."}, {"sha": "5d386b0a706b5b34bcdbc174804e80f757e27922", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -74,7 +74,7 @@ pub fn type_is_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n     let tcx = ccx.tcx();\n     let simple = ty::type_is_scalar(ty) ||\n         ty::type_is_unique(ty) || ty::type_is_region_ptr(ty) ||\n-        type_is_newtype_immediate(ccx, ty) || ty::type_is_bot(ty) ||\n+        type_is_newtype_immediate(ccx, ty) ||\n         ty::type_is_simd(tcx, ty);\n     if simple && !ty::type_is_fat_ptr(tcx, ty) {\n         return true;\n@@ -83,7 +83,6 @@ pub fn type_is_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n         return false;\n     }\n     match ty::get(ty).sty {\n-        ty::ty_bot => true,\n         ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) |\n         ty::ty_unboxed_closure(..) => {\n             let llty = sizing_type_of(ccx, ty);\n@@ -113,7 +112,7 @@ pub fn return_type_is_void(ccx: &CrateContext, ty: ty::t) -> bool {\n      * return type (in order to aid with C ABI compatibility).\n      */\n \n-    ty::type_is_nil(ty) || ty::type_is_bot(ty) || ty::type_is_empty(ccx.tcx(), ty)\n+    ty::type_is_nil(ty) || ty::type_is_empty(ccx.tcx(), ty)\n }\n \n /// Generates a unique symbol based off the name given. This is used to create\n@@ -217,7 +216,7 @@ pub trait SubstP {\n               -> Self;\n }\n \n-impl<T:Subst+Clone> SubstP for T {\n+impl<T: Subst + Clone> SubstP for T {\n     fn substp(&self, tcx: &ty::ctxt, substs: &param_substs) -> T {\n         self.subst(tcx, &substs.substs)\n     }\n@@ -343,9 +342,12 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         self.llreturn.get().unwrap()\n     }\n \n-    pub fn get_ret_slot(&self, bcx: Block, ty: ty::t, name: &str) -> ValueRef {\n+    pub fn get_ret_slot(&self, bcx: Block, output: ty::FnOutput, name: &str) -> ValueRef {\n         if self.needs_ret_allocas {\n-            base::alloca_no_lifetime(bcx, type_of::type_of(bcx.ccx(), ty), name)\n+            base::alloca_no_lifetime(bcx, match output {\n+                ty::FnConverging(output_type) => type_of::type_of(bcx.ccx(), output_type),\n+                ty::FnDiverging => Type::void(bcx.ccx())\n+            }, name)\n         } else {\n             self.llretslotptr.get().unwrap()\n         }"}, {"sha": "f7210bb4e08bba8f2a18726905bff3f2a26c9350", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -296,7 +296,7 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                      .borrow())[method_call]\n                                      .ty;\n     let method_type = monomorphize_type(loopback_bcx_in, method_type);\n-    let method_result_type = ty::ty_fn_ret(method_type);\n+    let method_result_type = ty::ty_fn_ret(method_type).unwrap();\n     let option_cleanup_scope = body_bcx_in.fcx.push_custom_cleanup_scope();\n     let option_cleanup_scope_id = cleanup::CustomScope(option_cleanup_scope);\n \n@@ -402,10 +402,6 @@ pub fn trans_loop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     fcx.pop_loop_cleanup_scope(loop_id);\n \n-    if ty::type_is_bot(node_id_type(bcx, loop_id)) {\n-        Unreachable(next_bcx_in);\n-    }\n-\n     return next_bcx_in;\n }\n \n@@ -465,7 +461,7 @@ pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let dest = match (fcx.llretslotptr.get(), e) {\n         (Some(_), Some(e)) => {\n             let ret_ty = expr_ty(bcx, &*e);\n-            expr::SaveIn(fcx.get_ret_slot(bcx, ret_ty, \"ret_slot\"))\n+            expr::SaveIn(fcx.get_ret_slot(bcx, ty::FnConverging(ret_ty), \"ret_slot\"))\n         }\n         _ => expr::Ignore,\n     };"}, {"sha": "8ee258e77fa5d3493f0ee7d290c0eb1ac6b942c1", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -650,7 +650,7 @@ impl<K: KindOps + fmt::Show> Datum<K> {\n     }\n \n     pub fn to_llbool(self, bcx: Block) -> ValueRef {\n-        assert!(ty::type_is_bool(self.ty) || ty::type_is_bot(self.ty))\n+        assert!(ty::type_is_bool(self.ty))\n         self.to_llscalarish(bcx)\n     }\n }"}, {"sha": "5e039a3c098c70ee7e1f4e4e9c8a60eef6ae1068", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 57, "deletions": 19, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -352,7 +352,6 @@ impl TypeMap {\n \n         match ty::get(type_).sty {\n             ty::ty_nil      |\n-            ty::ty_bot      |\n             ty::ty_bool     |\n             ty::ty_char     |\n             ty::ty_str      |\n@@ -451,9 +450,16 @@ impl TypeMap {\n                 }\n \n                 unique_type_id.push_str(\")->\");\n-                let return_type_id = self.get_unique_type_id_of_type(cx, sig.output);\n-                let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                unique_type_id.push_str(return_type_id.as_slice());\n+                match sig.output {\n+                    ty::FnConverging(ret_ty) => {\n+                        let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n+                        let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n+                        unique_type_id.push_str(return_type_id.as_slice());\n+                    }\n+                    ty::FnDiverging => {\n+                        unique_type_id.push_str(\"!\");\n+                    }\n+                }\n             },\n             ty::ty_closure(box ref closure_ty) => {\n                 self.get_unique_type_id_of_closure_type(cx,\n@@ -578,9 +584,16 @@ impl TypeMap {\n \n         unique_type_id.push_str(\"|->\");\n \n-        let return_type_id = self.get_unique_type_id_of_type(cx, sig.output);\n-        let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-        unique_type_id.push_str(return_type_id.as_slice());\n+        match sig.output {\n+            ty::FnConverging(ret_ty) => {\n+                let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n+                let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n+                unique_type_id.push_str(return_type_id.as_slice());\n+            }\n+            ty::FnDiverging => {\n+                unique_type_id.push_str(\"!\");\n+            }\n+        }\n \n         unique_type_id.push(':');\n \n@@ -1707,13 +1720,25 @@ fn scope_metadata(fcx: &FunctionContext,\n     }\n }\n \n+fn diverging_type_metadata(cx: &CrateContext) -> DIType {\n+    \"!\".with_c_str(|name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateBasicType(\n+                DIB(cx),\n+                name,\n+                bytes_to_bits(0),\n+                bytes_to_bits(0),\n+                DW_ATE_unsigned)\n+        }\n+    })\n+}\n+\n fn basic_type_metadata(cx: &CrateContext, t: ty::t) -> DIType {\n \n     debug!(\"basic_type_metadata: {}\", ty::get(t));\n \n     let (name, encoding) = match ty::get(t).sty {\n         ty::ty_nil => (\"()\".to_string(), DW_ATE_unsigned),\n-        ty::ty_bot => (\"!\".to_string(), DW_ATE_unsigned),\n         ty::ty_bool => (\"bool\".to_string(), DW_ATE_boolean),\n         ty::ty_char => (\"char\".to_string(), DW_ATE_unsigned_char),\n         ty::ty_int(int_ty) => match int_ty {\n@@ -2748,9 +2773,12 @@ fn subroutine_type_metadata(cx: &CrateContext,\n     let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs.len() + 1);\n \n     // return type\n-    signature_metadata.push(match ty::get(signature.output).sty {\n-        ty::ty_nil => ptr::null_mut(),\n-        _ => type_metadata(cx, signature.output, span)\n+    signature_metadata.push(match signature.output {\n+        ty::FnConverging(ret_ty) => match ty::get(ret_ty).sty {\n+            ty::ty_nil => ptr::null_mut(),\n+            _ => type_metadata(cx, ret_ty, span)\n+        },\n+        ty::FnDiverging => diverging_type_metadata(cx)\n     });\n \n     // regular arguments\n@@ -2855,7 +2883,6 @@ fn type_metadata(cx: &CrateContext,\n     let sty = &ty::get(t).sty;\n     let MetadataCreationResult { metadata, already_stored_in_typemap } = match *sty {\n         ty::ty_nil      |\n-        ty::ty_bot      |\n         ty::ty_bool     |\n         ty::ty_char     |\n         ty::ty_int(_)   |\n@@ -3647,7 +3674,6 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n                             output:&mut String) {\n     match ty::get(t).sty {\n         ty::ty_nil               => output.push_str(\"()\"),\n-        ty::ty_bot               => output.push_str(\"!\"),\n         ty::ty_bool              => output.push_str(\"bool\"),\n         ty::ty_char              => output.push_str(\"char\"),\n         ty::ty_str               => output.push_str(\"str\"),\n@@ -3749,9 +3775,15 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n \n             output.push(')');\n \n-            if !ty::type_is_nil(sig.output) {\n-                output.push_str(\" -> \");\n-                push_debuginfo_type_name(cx, sig.output, true, output);\n+            match sig.output {\n+                ty::FnConverging(result_type) if ty::type_is_nil(result_type) => {}\n+                ty::FnConverging(result_type) => {\n+                    output.push_str(\" -> \");\n+                    push_debuginfo_type_name(cx, result_type, true, output);\n+                }\n+                ty::FnDiverging => {\n+                    output.push_str(\" -> !\");\n+                }\n             }\n         },\n         ty::ty_closure(box ty::ClosureTy { fn_style,\n@@ -3803,9 +3835,15 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n \n             output.push(param_list_closing_char);\n \n-            if !ty::type_is_nil(sig.output) {\n-                output.push_str(\" -> \");\n-                push_debuginfo_type_name(cx, sig.output, true, output);\n+            match sig.output {\n+                ty::FnConverging(result_type) if ty::type_is_nil(result_type) => {}\n+                ty::FnConverging(result_type) => {\n+                    output.push_str(\" -> \");\n+                    push_debuginfo_type_name(cx, result_type, true, output);\n+                }\n+                ty::FnDiverging => {\n+                    output.push_str(\" -> !\");\n+                }\n             }\n         },\n         ty::ty_unboxed_closure(..) => {"}, {"sha": "7d64c42a00030986ccd3baac5a35dd209c37995b", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -609,7 +609,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             start.as_ref().map(|e| args.push((unpack_datum!(bcx, trans(bcx, &**e)), e.id)));\n             end.as_ref().map(|e| args.push((unpack_datum!(bcx, trans(bcx, &**e)), e.id)));\n \n-            let result_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty.unwrap()));\n+            let result_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty.unwrap())).unwrap();\n             let scratch = rvalue_scratch_datum(bcx, result_ty, \"trans_slice\");\n \n             unpack_result!(bcx,\n@@ -757,7 +757,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                    base_datum,\n                                                    vec![(ix_datum, idx.id)],\n                                                    None));\n-            let ref_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty));\n+            let ref_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty)).unwrap();\n             let elt_ty = match ty::deref(ref_ty, true) {\n                 None => {\n                     bcx.tcx().sess.span_bug(index_expr.span,\n@@ -1614,8 +1614,7 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n     let is_simd = ty::type_is_simd(tcx, lhs_t);\n     let intype = {\n-        if ty::type_is_bot(lhs_t) { rhs_t }\n-        else if is_simd { ty::simd_type(tcx, lhs_t) }\n+        if is_simd { ty::simd_type(tcx, lhs_t) }\n         else { lhs_t }\n     };\n     let is_float = ty::type_is_fp(intype);\n@@ -1675,9 +1674,7 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         } else { LShr(bcx, lhs, rhs) }\n       }\n       ast::BiEq | ast::BiNe | ast::BiLt | ast::BiGe | ast::BiLe | ast::BiGt => {\n-        if ty::type_is_bot(rhs_t) {\n-            C_bool(bcx.ccx(), false)\n-        } else if ty::type_is_scalar(rhs_t) {\n+        if ty::type_is_scalar(rhs_t) {\n             unpack_result!(bcx, base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op))\n         } else if is_simd {\n             base::compare_simd_types(bcx, lhs, rhs, intype, ty::simd_size(tcx, lhs_t), op)\n@@ -2098,7 +2095,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 _ => datum\n             };\n \n-            let ref_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty));\n+            let ref_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty)).unwrap();\n             let scratch = rvalue_scratch_datum(bcx, ref_ty, \"overloaded_deref\");\n \n             unpack_result!(bcx, trans_overloaded_op(bcx, expr, method_call,"}, {"sha": "aa195837b67d4a3a5178c07d95910a566d03fce6", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -49,9 +49,6 @@ struct ForeignTypes {\n \n     /// LLVM types that will appear on the foreign function\n     llsig: LlvmSignature,\n-\n-    /// True if there is a return value (not bottom, not unit)\n-    ret_def: bool,\n }\n \n struct LlvmSignature {\n@@ -63,6 +60,9 @@ struct LlvmSignature {\n     // function, because the foreign function may opt to return via an\n     // out pointer.\n     llret_ty: Type,\n+\n+    /// True if there is a return value (not bottom, not unit)\n+    ret_def: bool,\n }\n \n \n@@ -286,11 +286,10 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n     };\n     let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys.as_slice());\n-    let ret_def = !return_type_is_void(bcx.ccx(), fn_sig.output);\n     let fn_type = cabi::compute_abi_info(ccx,\n                                          llsig.llarg_tys.as_slice(),\n                                          llsig.llret_ty,\n-                                         ret_def);\n+                                         llsig.ret_def);\n \n     let arg_tys: &[cabi::ArgType] = fn_type.arg_tys.as_slice();\n \n@@ -437,7 +436,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // type to match because some ABIs will use a different type than\n     // the Rust type. e.g., a {u32,u32} struct could be returned as\n     // u64.\n-    if ret_def && !fn_type.ret_ty.is_indirect() {\n+    if llsig.ret_def && !fn_type.ret_ty.is_indirect() {\n         let llrust_ret_ty = llsig.llret_ty;\n         let llforeign_ret_ty = match fn_type.ret_ty.cast {\n             Some(ty) => ty,\n@@ -450,7 +449,12 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         debug!(\"llforeign_ret_ty={}\", ccx.tn().type_to_string(llforeign_ret_ty));\n \n         if llrust_ret_ty == llforeign_ret_ty {\n-            base::store_ty(bcx, llforeign_retval, llretptr, fn_sig.output)\n+            match fn_sig.output {\n+                ty::FnConverging(result_ty) => {\n+                    base::store_ty(bcx, llforeign_retval, llretptr, result_ty)\n+                }\n+                ty::FnDiverging => {}\n+            }\n         } else {\n             // The actual return type is a struct, but the ABI\n             // adaptation code has cast it into some scalar type.  The\n@@ -549,7 +553,7 @@ pub fn decl_rust_fn_with_foreign_abi(ccx: &CrateContext,\n         }\n         _ => fail!(\"expected bare fn in decl_rust_fn_with_foreign_abi\")\n     };\n-    let llfn = base::decl_fn(ccx, name, cconv, llfn_ty, ty::mk_nil());\n+    let llfn = base::decl_fn(ccx, name, cconv, llfn_ty, ty::FnConverging(ty::mk_nil()));\n     add_argument_attributes(&tys, llfn);\n     debug!(\"decl_rust_fn_with_foreign_abi(llfn_ty={}, llfn={})\",\n            ccx.tn().type_to_string(llfn_ty), ccx.tn().val_to_string(llfn));\n@@ -698,8 +702,10 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n         };\n \n         // Push Rust return pointer, using null if it will be unused.\n-        let rust_uses_outptr =\n-            type_of::return_uses_outptr(ccx, tys.fn_sig.output);\n+        let rust_uses_outptr = match tys.fn_sig.output {\n+            ty::FnConverging(ret_ty) => type_of::return_uses_outptr(ccx, ret_ty),\n+            ty::FnDiverging => false\n+        };\n         let return_alloca: Option<ValueRef>;\n         let llrust_ret_ty = tys.llsig.llret_ty;\n         let llrust_retptr_ty = llrust_ret_ty.ptr_to();\n@@ -714,7 +720,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n                     debug!(\"out pointer, foreign={}\",\n                            ccx.tn().val_to_string(llforeign_outptr));\n                     let llrust_retptr =\n-                        builder.bitcast(llforeign_outptr, llrust_ret_ty.ptr_to());\n+                        builder.bitcast(llforeign_outptr, llrust_retptr_ty);\n                     debug!(\"out pointer, foreign={} (casted)\",\n                            ccx.tn().val_to_string(llrust_retptr));\n                     llrust_args.push(llrust_retptr);\n@@ -817,7 +823,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             None => tys.fn_ty.ret_ty.ty\n         };\n         match foreign_outptr {\n-            None if !tys.ret_def => {\n+            None if !tys.llsig.ret_def => {\n                 // Function returns `()` or `bot`, which in Rust is the LLVM\n                 // type \"{}\" but in foreign ABIs is \"Void\".\n                 builder.ret_void();\n@@ -896,10 +902,16 @@ fn foreign_signature(ccx: &CrateContext, fn_sig: &ty::FnSig, arg_tys: &[ty::t])\n      */\n \n     let llarg_tys = arg_tys.iter().map(|&arg| arg_type_of(ccx, arg)).collect();\n-    let llret_ty = type_of::arg_type_of(ccx, fn_sig.output);\n+    let (llret_ty, ret_def) = match fn_sig.output {\n+        ty::FnConverging(ret_ty) =>\n+            (type_of::arg_type_of(ccx, ret_ty), !return_type_is_void(ccx, ret_ty)),\n+        ty::FnDiverging =>\n+            (Type::nil(ccx), false)\n+    };\n     LlvmSignature {\n         llarg_tys: llarg_tys,\n-        llret_ty: llret_ty\n+        llret_ty: llret_ty,\n+        ret_def: ret_def\n     }\n }\n \n@@ -915,11 +927,10 @@ fn foreign_types_for_fn_ty(ccx: &CrateContext,\n         _ => ccx.sess().bug(\"foreign_types_for_fn_ty called on non-function type\")\n     };\n     let llsig = foreign_signature(ccx, &fn_sig, fn_sig.inputs.as_slice());\n-    let ret_def = !return_type_is_void(ccx, fn_sig.output);\n     let fn_ty = cabi::compute_abi_info(ccx,\n                                        llsig.llarg_tys.as_slice(),\n                                        llsig.llret_ty,\n-                                       ret_def);\n+                                       llsig.ret_def);\n     debug!(\"foreign_types_for_fn_ty(\\\n            ty={}, \\\n            llsig={} -> {}, \\\n@@ -930,12 +941,11 @@ fn foreign_types_for_fn_ty(ccx: &CrateContext,\n            ccx.tn().type_to_string(llsig.llret_ty),\n            ccx.tn().types_to_str(fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>().as_slice()),\n            ccx.tn().type_to_string(fn_ty.ret_ty.ty),\n-           ret_def);\n+           llsig.ret_def);\n \n     ForeignTypes {\n         fn_sig: fn_sig,\n         llsig: llsig,\n-        ret_def: ret_def,\n         fn_ty: fn_ty\n     }\n }"}, {"sha": "e914dbcc082a672333cd82a8018f637ad7e11d07", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -538,10 +538,10 @@ fn make_generic_glue(ccx: &CrateContext,\n \n     let arena = TypedArena::new();\n     let empty_param_substs = param_substs::empty();\n-    let fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false, ty::mk_nil(),\n+    let fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false, ty::FnConverging(ty::mk_nil()),\n                           &empty_param_substs, None, &arena);\n \n-    let bcx = init_function(&fcx, false, ty::mk_nil());\n+    let bcx = init_function(&fcx, false, ty::FnConverging(ty::mk_nil()));\n \n     update_linkage(ccx, llfn, None, OriginalTranslation);\n \n@@ -556,7 +556,7 @@ fn make_generic_glue(ccx: &CrateContext,\n \n     let llrawptr0 = get_param(llfn, fcx.arg_pos(0) as c_uint);\n     let bcx = helper(bcx, llrawptr0, t);\n-    finish_fn(&fcx, bcx, ty::mk_nil());\n+    finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil()));\n \n     llfn\n }"}, {"sha": "61559e12a975e7049b9a2722c2df477cd8fccd4b", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -149,12 +149,12 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n         ty::ty_bare_fn(ref f) => f.sig.output,\n         _ => fail!(\"expected bare_fn in trans_intrinsic_call\")\n     };\n-    let llret_ty = type_of::type_of(ccx, ret_ty);\n     let foreign_item = tcx.map.expect_foreign_item(node);\n     let name = token::get_ident(foreign_item.ident);\n \n     // For `transmute` we can just trans the input expr directly into dest\n     if name.get() == \"transmute\" {\n+        let llret_ty = type_of::type_of(ccx, ret_ty.unwrap());\n         match args {\n             callee::ArgExprs(arg_exprs) => {\n                 assert_eq!(arg_exprs.len(), 1);\n@@ -192,6 +192,36 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n         }\n     }\n \n+    // Push the arguments.\n+    let mut llargs = Vec::new();\n+    bcx = callee::trans_args(bcx,\n+                             args,\n+                             callee_ty,\n+                             &mut llargs,\n+                             cleanup::CustomScope(cleanup_scope),\n+                             false,\n+                             RustIntrinsic);\n+\n+    fcx.pop_custom_cleanup_scope(cleanup_scope);\n+\n+    // The only intrinsic function that diverges.\n+    if name.get() == \"abort\" {\n+        let llfn = ccx.get_intrinsic(&(\"llvm.trap\"));\n+        Call(bcx, llfn, [], None);\n+        Unreachable(bcx);\n+        return Result::new(bcx, C_undef(Type::nil(ccx).ptr_to()));\n+    } else if name.get() == \"unreachable\" {\n+        Unreachable(bcx);\n+        return Result::new(bcx, C_nil(ccx));\n+    }\n+\n+    let ret_ty = match ret_ty {\n+        ty::FnConverging(ret_ty) => ret_ty,\n+        ty::FnDiverging => unreachable!()\n+    };\n+\n+    let llret_ty = type_of::type_of(ccx, ret_ty);\n+\n     // Get location to store the result. If the user does\n     // not care about the result, just make a stack slot\n     let llresult = match dest {\n@@ -205,34 +235,11 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n         }\n     };\n \n-    // Push the arguments.\n-    let mut llargs = Vec::new();\n-    bcx = callee::trans_args(bcx,\n-                             args,\n-                             callee_ty,\n-                             &mut llargs,\n-                             cleanup::CustomScope(cleanup_scope),\n-                             false,\n-                             RustIntrinsic);\n-\n-    fcx.pop_custom_cleanup_scope(cleanup_scope);\n-\n     let simple = get_simple_intrinsic(ccx, &*foreign_item);\n-\n     let llval = match (simple, name.get()) {\n         (Some(llfn), _) => {\n             Call(bcx, llfn, llargs.as_slice(), None)\n         }\n-        (_, \"abort\") => {\n-            let llfn = ccx.get_intrinsic(&(\"llvm.trap\"));\n-            let v = Call(bcx, llfn, [], None);\n-            Unreachable(bcx);\n-            v\n-        }\n-        (_, \"unreachable\") => {\n-            Unreachable(bcx);\n-            C_nil(ccx)\n-        }\n         (_, \"breakpoint\") => {\n             let llfn = ccx.get_intrinsic(&(\"llvm.debugtrap\"));\n             Call(bcx, llfn, [], None)"}, {"sha": "64ab86721bcc7cec9eacd633022358e1a8280d24", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -97,7 +97,7 @@ pub fn untuple_arguments_if_necessary(ccx: &CrateContext,\n pub fn type_of_rust_fn(cx: &CrateContext,\n                        llenvironment_type: Option<Type>,\n                        inputs: &[ty::t],\n-                       output: ty::t,\n+                       output: ty::FnOutput,\n                        abi: abi::Abi)\n                        -> Type {\n     let mut atys: Vec<Type> = Vec::new();\n@@ -107,11 +107,22 @@ pub fn type_of_rust_fn(cx: &CrateContext,\n \n     // Arg 0: Output pointer.\n     // (if the output type is non-immediate)\n-    let use_out_pointer = return_uses_outptr(cx, output);\n-    let lloutputtype = arg_type_of(cx, output);\n-    if use_out_pointer {\n-        atys.push(lloutputtype.ptr_to());\n-    }\n+    let lloutputtype = match output {\n+        ty::FnConverging(output) => {\n+            let use_out_pointer = return_uses_outptr(cx, output);\n+            let lloutputtype = arg_type_of(cx, output);\n+            // Use the output as the actual return value if it's immediate.\n+            if use_out_pointer {\n+                atys.push(lloutputtype.ptr_to());\n+                Type::void(cx)\n+            } else if return_type_is_void(cx, output) {\n+                Type::void(cx)\n+            } else {\n+                lloutputtype\n+            }\n+        }\n+        ty::FnDiverging => Type::void(cx)\n+    };\n \n     // Arg 1: Environment\n     match llenvironment_type {\n@@ -123,12 +134,7 @@ pub fn type_of_rust_fn(cx: &CrateContext,\n     let input_tys = inputs.iter().map(|&arg_ty| type_of_explicit_arg(cx, arg_ty));\n     atys.extend(input_tys);\n \n-    // Use the output as the actual return value if it's immediate.\n-    if use_out_pointer || return_type_is_void(cx, output) {\n-        Type::func(atys.as_slice(), &Type::void(cx))\n-    } else {\n-        Type::func(atys.as_slice(), &lloutputtype)\n-    }\n+    Type::func(atys.as_slice(), &lloutputtype)\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n@@ -181,7 +187,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n                                   ppaux::ty_to_string(cx.tcx(), t)).as_slice())\n         }\n \n-        ty::ty_nil | ty::ty_bot => Type::nil(cx),\n+        ty::ty_nil => Type::nil(cx),\n         ty::ty_bool => Type::bool(cx),\n         ty::ty_char => Type::char(cx),\n         ty::ty_int(t) => Type::int_from_ty(cx, t),\n@@ -293,7 +299,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     }\n \n     let mut llty = match ty::get(t).sty {\n-      ty::ty_nil | ty::ty_bot => Type::nil(cx),\n+      ty::ty_nil => Type::nil(cx),\n       ty::ty_bool => Type::bool(cx),\n       ty::ty_char => Type::char(cx),\n       ty::ty_int(t) => Type::int_from_ty(cx, t),"}, {"sha": "6666b85879a89d330136b426f2c0d149cf118fdc", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 46, "deletions": 41, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -598,7 +598,6 @@ bitflags! {\n         const HAS_RE_INFER  = 0b1000,\n         const HAS_REGIONS   = 0b10000,\n         const HAS_TY_ERR    = 0b100000,\n-        const HAS_TY_BOT    = 0b1000000,\n         const NEEDS_SUBST   = HAS_PARAMS.bits | HAS_SELF.bits | HAS_REGIONS.bits,\n     }\n }\n@@ -672,6 +671,21 @@ pub struct ClosureTy {\n     pub abi: abi::Abi,\n }\n \n+#[deriving(Clone, PartialEq, Eq, Hash)]\n+pub enum FnOutput {\n+    FnConverging(ty::t),\n+    FnDiverging\n+}\n+\n+impl FnOutput {\n+    pub fn unwrap(&self) -> ty::t {\n+        match *self {\n+            ty::FnConverging(ref t) => *t,\n+            ty::FnDiverging => unreachable!()\n+        }\n+    }\n+}\n+\n /**\n  * Signature of a function type, which I have arbitrarily\n  * decided to use to refer to the input/output types.\n@@ -688,7 +702,7 @@ pub struct ClosureTy {\n pub struct FnSig {\n     pub binder_id: ast::NodeId,\n     pub inputs: Vec<t>,\n-    pub output: t,\n+    pub output: FnOutput,\n     pub variadic: bool\n }\n \n@@ -919,12 +933,6 @@ mod primitives {\n     def_prim_ty!(TY_F32,    super::ty_float(ast::TyF32),    14)\n     def_prim_ty!(TY_F64,    super::ty_float(ast::TyF64),    15)\n \n-    pub static TY_BOT: t_box_ = t_box_ {\n-        sty: super::ty_bot,\n-        id: 16,\n-        flags: super::HAS_TY_BOT,\n-    };\n-\n     pub static TY_ERR: t_box_ = t_box_ {\n         sty: super::ty_err,\n         id: 17,\n@@ -939,7 +947,6 @@ mod primitives {\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub enum sty {\n     ty_nil,\n-    ty_bot,\n     ty_bool,\n     ty_char,\n     ty_int(ast::IntTy),\n@@ -1044,6 +1051,7 @@ pub enum type_err {\n     terr_builtin_bounds(expected_found<BuiltinBounds>),\n     terr_variadic_mismatch(expected_found<bool>),\n     terr_cyclic_ty,\n+    terr_convergence_mismatch(expected_found<bool>)\n }\n \n /// Bounds suitable for a named type parameter like `A` in `fn foo<A>`\n@@ -1578,7 +1586,6 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n         ty_uint(u) => return mk_mach_uint(u),\n         ty_float(f) => return mk_mach_float(f),\n         ty_char => return mk_char(),\n-        ty_bot => return mk_bot(),\n         _ => {}\n     };\n \n@@ -1627,7 +1634,6 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n       // But doing so caused sporadic memory corruption, and\n       // neither I (tjc) nor nmatsakis could figure out why,\n       // so we're doing it this way.\n-      &ty_bot => flags = flags | HAS_TY_BOT,\n       &ty_err => flags = flags | HAS_TY_ERR,\n       &ty_param(ref p) => {\n           if p.space == subst::SelfSpace {\n@@ -1661,9 +1667,9 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n       &ty_tup(ref ts) => for tt in ts.iter() { flags = flags | get(*tt).flags; },\n       &ty_bare_fn(ref f) => {\n         for a in f.sig.inputs.iter() { flags = flags | get(*a).flags; }\n-        flags = flags | get(f.sig.output).flags;\n-        // T -> _|_ is *not* _|_ !\n-        flags = flags - HAS_TY_BOT;\n+        if let ty::FnConverging(output) = f.sig.output {\n+            flags = flags | get(output).flags;\n+        }\n       }\n       &ty_closure(ref f) => {\n         match f.store {\n@@ -1673,9 +1679,9 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n             _ => {}\n         }\n         for a in f.sig.inputs.iter() { flags = flags | get(*a).flags; }\n-        flags = flags | get(f.sig.output).flags;\n-        // T -> _|_ is *not* _|_ !\n-        flags = flags - HAS_TY_BOT;\n+        if let ty::FnConverging(output) = f.sig.output {\n+            flags = flags | get(output).flags;\n+        }\n         flags = flags | flags_for_bounds(&f.bounds);\n       }\n     }\n@@ -1714,9 +1720,6 @@ pub fn mk_nil() -> t { mk_prim_t(&primitives::TY_NIL) }\n #[inline]\n pub fn mk_err() -> t { mk_prim_t(&primitives::TY_ERR) }\n \n-#[inline]\n-pub fn mk_bot() -> t { mk_prim_t(&primitives::TY_BOT) }\n-\n #[inline]\n pub fn mk_bool() -> t { mk_prim_t(&primitives::TY_BOOL) }\n \n@@ -1862,7 +1865,7 @@ pub fn mk_ctor_fn(cx: &ctxt,\n                    sig: FnSig {\n                     binder_id: binder_id,\n                     inputs: input_args,\n-                    output: output,\n+                    output: ty::FnConverging(output),\n                     variadic: false\n                    }\n                 })\n@@ -1924,7 +1927,7 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n         return;\n     }\n     match get(ty).sty {\n-        ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n+        ty_nil | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n         ty_str | ty_infer(_) | ty_param(_) | ty_err => {}\n         ty_uniq(ty) | ty_vec(ty, _) | ty_open(ty) => maybe_walk_ty(ty, f),\n         ty_ptr(ref tm) | ty_rptr(_, ref tm) => {\n@@ -1939,11 +1942,15 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n         ty_tup(ref ts) => { for tt in ts.iter() { maybe_walk_ty(*tt, |x| f(x)); } }\n         ty_bare_fn(ref ft) => {\n             for a in ft.sig.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n-            maybe_walk_ty(ft.sig.output, f);\n+            if let ty::FnConverging(output) = ft.sig.output {\n+                maybe_walk_ty(output, f);\n+            }\n         }\n         ty_closure(ref ft) => {\n             for a in ft.sig.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n-            maybe_walk_ty(ft.sig.output, f);\n+            if let ty::FnConverging(output) = ft.sig.output {\n+                maybe_walk_ty(output, f);\n+            }\n         }\n     }\n }\n@@ -1995,10 +2002,6 @@ pub fn type_is_nil(ty: t) -> bool {\n     get(ty).sty == ty_nil\n }\n \n-pub fn type_is_bot(ty: t) -> bool {\n-    get(ty).flags.intersects(HAS_TY_BOT)\n-}\n-\n pub fn type_is_error(ty: t) -> bool {\n     get(ty).flags.intersects(HAS_TY_ERR)\n }\n@@ -2013,8 +2016,8 @@ pub fn trait_ref_contains_error(tref: &ty::TraitRef) -> bool {\n \n pub fn type_is_ty_var(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_infer(TyVar(_)) => true,\n-      _ => false\n+        ty_infer(TyVar(_)) => true,\n+        _ => false\n     }\n }\n \n@@ -2170,7 +2173,7 @@ pub fn type_needs_unwind_cleanup(cx: &ctxt, ty: t) -> bool {\n         let mut needs_unwind_cleanup = false;\n         maybe_walk_ty(ty, |ty| {\n             needs_unwind_cleanup |= match get(ty).sty {\n-                ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) |\n+                ty_nil | ty_bool | ty_int(_) | ty_uint(_) |\n                 ty_float(_) | ty_tup(_) | ty_ptr(_) => false,\n \n                 ty_enum(did, ref substs) =>\n@@ -2430,7 +2433,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n \n             // Scalar and unique types are sendable, and durable\n             ty_infer(ty::SkolemizedIntTy(_)) |\n-            ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n+            ty_nil | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n             ty_bare_fn(_) | ty::ty_char => {\n                 TC::None\n             }\n@@ -2560,7 +2563,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 // We only ever ask for the kind of types that are defined in\n                 // the current crate; therefore, the only type parameters that\n                 // could be in scope are those defined in the current crate.\n-                // If this assertion failures, it is likely because of a\n+                // If this assertion fails, it is likely because of a\n                 // failure in the cross-crate inlining code to translate a\n                 // def-id.\n                 assert_eq!(p.def_id.krate, ast::LOCAL_CRATE);\n@@ -2742,7 +2745,6 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n             ty_vec(ty, Some(_)) => type_requires(cx, seen, r_ty, ty),\n \n             ty_nil |\n-            ty_bot |\n             ty_bool |\n             ty_char |\n             ty_int(_) |\n@@ -3276,7 +3278,7 @@ pub fn ty_closure_store(fty: t) -> TraitStore {\n     }\n }\n \n-pub fn ty_fn_ret(fty: t) -> t {\n+pub fn ty_fn_ret(fty: t) -> FnOutput {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => f.sig.output,\n         ty_closure(ref f) => f.sig.output,\n@@ -3451,7 +3453,9 @@ pub fn adjust_ty(cx: &ctxt,\n                             let method_call = typeck::MethodCall::autoderef(expr_id, i);\n                             match method_type(method_call) {\n                                 Some(method_ty) => {\n-                                    adjusted_ty = ty_fn_ret(method_ty);\n+                                    if let ty::FnConverging(result_type) = ty_fn_ret(method_ty) {\n+                                        adjusted_ty = result_type;\n+                                    }\n                                 }\n                                 None => {}\n                             }\n@@ -3779,7 +3783,7 @@ pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n \n pub fn ty_sort_string(cx: &ctxt, t: t) -> String {\n     match get(t).sty {\n-        ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) |\n+        ty_nil | ty_bool | ty_char | ty_int(_) |\n         ty_uint(_) | ty_float(_) | ty_str => {\n             ::util::ppaux::ty_to_string(cx, t)\n         }\n@@ -3959,6 +3963,11 @@ pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> String {\n                     if values.expected { \"variadic\" } else { \"non-variadic\" },\n                     if values.found { \"variadic\" } else { \"non-variadic\" })\n         }\n+        terr_convergence_mismatch(ref values) => {\n+            format!(\"expected {} fn, found {} function\",\n+                    if values.expected { \"converging\" } else { \"diverging\" },\n+                    if values.found { \"converging\" } else { \"diverging\" })\n+        }\n     }\n }\n \n@@ -4667,7 +4676,6 @@ pub fn is_binopable(cx: &ctxt, ty: t, op: ast::BinOp) -> bool {\n     static tycat_char: int = 2;\n     static tycat_int: int = 3;\n     static tycat_float: int = 4;\n-    static tycat_bot: int = 5;\n     static tycat_raw_ptr: int = 6;\n \n     static opcat_add: int = 0;\n@@ -4712,7 +4720,6 @@ pub fn is_binopable(cx: &ctxt, ty: t, op: ast::BinOp) -> bool {\n           ty_bool => tycat_bool,\n           ty_int(_) | ty_uint(_) | ty_infer(IntVar(_)) => tycat_int,\n           ty_float(_) | ty_infer(FloatVar(_)) => tycat_float,\n-          ty_bot => tycat_bot,\n           ty_ptr(_) => tycat_raw_ptr,\n           _ => tycat_other\n         }\n@@ -5149,7 +5156,6 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n     ty::walk_ty(t, |t| {\n         match ty::get(t).sty {\n             ty_nil => byte!(0),\n-            ty_bot => byte!(1),\n             ty_bool => byte!(2),\n             ty_char => byte!(3),\n             ty_int(i) => {\n@@ -5520,7 +5526,6 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n                 accum_substs(accumulator, substs);\n             }\n             ty_nil |\n-            ty_bot |\n             ty_bool |\n             ty_char |\n             ty_int(_) |"}, {"sha": "a96e81ce20bb418a47393dbce3be4f5e99b534fa", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -91,6 +91,12 @@ pub trait TypeFolder<'tcx> {\n         super_fold_sig(self, sig)\n     }\n \n+    fn fold_output(&mut self,\n+                      output: &ty::FnOutput)\n+                      -> ty::FnOutput {\n+        super_fold_output(self, output)\n+    }\n+\n     fn fold_bare_fn_ty(&mut self,\n                        fty: &ty::BareFnTy)\n                        -> ty::BareFnTy\n@@ -207,6 +213,12 @@ impl TypeFoldable for ty::mt {\n     }\n }\n \n+impl TypeFoldable for ty::FnOutput {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnOutput {\n+        folder.fold_output(self)\n+    }\n+}\n+\n impl TypeFoldable for ty::FnSig {\n     fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig {\n         folder.fold_sig(self)\n@@ -453,6 +465,15 @@ pub fn super_fold_sig<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                 variadic: sig.variadic }\n }\n \n+pub fn super_fold_output<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                    output: &ty::FnOutput)\n+                                                    -> ty::FnOutput {\n+    match *output {\n+        ty::FnConverging(ref ty) => ty::FnConverging(ty.fold_with(this)),\n+        ty::FnDiverging => ty::FnDiverging\n+    }\n+}\n+\n pub fn super_fold_bare_fn_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                                                         fty: &ty::BareFnTy)\n                                                         -> ty::BareFnTy\n@@ -537,7 +558,7 @@ pub fn super_fold_sty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n         ty::ty_unboxed_closure(did, ref region, ref substs) => {\n             ty::ty_unboxed_closure(did, region.fold_with(this), substs.fold_with(this))\n         }\n-        ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_char | ty::ty_str |\n+        ty::ty_nil | ty::ty_bool | ty::ty_char | ty::ty_str |\n         ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n         ty::ty_err | ty::ty_infer(_) |\n         ty::ty_param(..) => {"}, {"sha": "42990ac79c005e52cee389ba6bb681fbca2383a0", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -793,7 +793,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     let typ = ast_ty_to_builtin_ty(this, rscope, ast_ty).unwrap_or_else(|| {\n         match ast_ty.node {\n             ast::TyNil => ty::mk_nil(),\n-            ast::TyBot => ty::mk_bot(),\n+            ast::TyBot => unreachable!(),\n             ast::TyUniq(ref ty) => {\n                 mk_pointer(this, rscope, ast::MutImmutable, &**ty, Uniq,\n                            |ty| ty::mk_uniq(tcx, ty))\n@@ -1171,22 +1171,21 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n                                                                    .collect();\n \n     let output_ty = match decl.output.node {\n-        ast::TyInfer => this.ty_infer(decl.output.span),\n-        _ => {\n-            match implied_output_region {\n-                Some(implied_output_region) => {\n-                    let rb = SpecificRscope::new(implied_output_region);\n-                    ast_ty_to_ty(this, &rb, &*decl.output)\n-                }\n-                None => {\n-                    // All regions must be explicitly specified in the output\n-                    // if the lifetime elision rules do not apply. This saves\n-                    // the user from potentially-confusing errors.\n-                    let rb = UnelidableRscope::new(param_lifetimes);\n-                    ast_ty_to_ty(this, &rb, &*decl.output)\n-                }\n+        ast::TyBot => ty::FnDiverging,\n+        ast::TyInfer => ty::FnConverging(this.ty_infer(decl.output.span)),\n+        _ => ty::FnConverging(match implied_output_region {\n+            Some(implied_output_region) => {\n+                let rb = SpecificRscope::new(implied_output_region);\n+                ast_ty_to_ty(this, &rb, &*decl.output)\n             }\n-        }\n+            None => {\n+                // All regions must be explicitly specified in the output\n+                // if the lifetime elision rules do not apply. This saves\n+                // the user from potentially-confusing errors.\n+                let rb = UnelidableRscope::new(param_lifetimes);\n+                ast_ty_to_ty(this, &rb, &*decl.output)\n+            }\n+        })\n     };\n \n     (ty::BareFnTy {\n@@ -1308,10 +1307,12 @@ pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n     }).collect();\n \n     let expected_ret_ty = expected_sig.map(|e| e.output);\n+\n     let output_ty = match decl.output.node {\n+        ast::TyBot => ty::FnDiverging,\n         ast::TyInfer if expected_ret_ty.is_some() => expected_ret_ty.unwrap(),\n-        ast::TyInfer => this.ty_infer(decl.output.span),\n-        _ => ast_ty_to_ty(this, &rb, &*decl.output)\n+        ast::TyInfer => ty::FnConverging(this.ty_infer(decl.output.span)),\n+        _ => ty::FnConverging(ast_ty_to_ty(this, &rb, &*decl.output))\n     };\n \n     ty::ClosureTy {"}, {"sha": "d9f8625504daf518683d238ed426dc5b6114d1dd", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -261,7 +261,7 @@ pub fn check_match(fcx: &FnCtxt,\n     // on any empty type and is therefore unreachable; should the flow\n     // of execution reach it, we will fail, so bottom is an appropriate\n     // type in that case)\n-    let result_ty = arms.iter().fold(ty::mk_bot(), |result_ty, arm| {\n+    let result_ty = arms.iter().fold(fcx.infcx().next_diverging_ty_var(), |result_ty, arm| {\n         check_expr(fcx, &*arm.body);\n         let bty = fcx.node_ty(arm.body.id);\n \n@@ -347,7 +347,10 @@ pub fn check_pat_enum(pcx: &pat_ctxt, pat: &ast::Pat,\n \n     let ctor_pty = ty::lookup_item_type(tcx, enum_def);\n     let path_ty = if ty::is_fn_ty(ctor_pty.ty) {\n-        ty::Polytype { ty: ty::ty_fn_ret(ctor_pty.ty), ..ctor_pty }\n+        ty::Polytype {\n+            ty: ty::ty_fn_ret(ctor_pty.ty).unwrap(),\n+            ..ctor_pty\n+        }\n     } else {\n         ctor_pty\n     };"}, {"sha": "6ace73931bfe86886d920700babc0270a07115e6", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -1082,7 +1082,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             ty_bare_fn(..) | ty_uniq(..) | ty_rptr(..) |\n             ty_infer(IntVar(_)) |\n             ty_infer(FloatVar(_)) |\n-            ty_param(..) | ty_nil | ty_bot | ty_bool |\n+            ty_param(..) | ty_nil | ty_bool |\n             ty_char | ty_int(..) | ty_uint(..) |\n             ty_float(..) | ty_enum(..) | ty_ptr(..) | ty_struct(..) |\n             ty_unboxed_closure(..) | ty_tup(..) | ty_open(..) |\n@@ -1603,8 +1603,10 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 return false;\n             }\n         }\n-        if !check_for_self_ty(sig.output) {\n-            return false;\n+        if let ty::FnConverging(result_type) = sig.output {\n+            if !check_for_self_ty(result_type) {\n+                return false;\n+            }\n         }\n \n         if candidate.method_ty.generics.has_type_params(subst::FnSpace) {"}, {"sha": "8843be3cf816f387c0745d0df42d5c45da4a4343", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 137, "deletions": 148, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -280,7 +280,7 @@ pub struct FnCtxt<'a, 'tcx: 'a> {\n     // expects the types within the function to be consistent.\n     err_count_on_creation: uint,\n \n-    ret_ty: ty::t,\n+    ret_ty: ty::FnOutput,\n \n     ps: RefCell<FnStyleState>,\n \n@@ -346,7 +346,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n // Used by check_const and check_enum_variants\n pub fn blank_fn_ctxt<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                                inh: &'a Inherited<'a, 'tcx>,\n-                               rty: ty::t,\n+                               rty: ty::FnOutput,\n                                body_id: ast::NodeId)\n                                -> FnCtxt<'a, 'tcx> {\n     FnCtxt {\n@@ -410,6 +410,7 @@ fn check_bare_fn(ccx: &CrateCtxt,\n \n             vtable::select_all_fcx_obligations_or_error(&fcx);\n             regionck::regionck_fn(&fcx, id, body);\n+            fcx.default_diverging_type_variables_to_nil();\n             writeback::resolve_type_vars_in_fn(&fcx, decl, body);\n         }\n         _ => ccx.tcx.sess.impossible_case(body.span,\n@@ -426,8 +427,7 @@ impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n         match ty_opt {\n             None => {\n                 // infer the variable's type\n-                let var_id = self.fcx.infcx().next_ty_var_id();\n-                let var_ty = ty::mk_var(self.fcx.tcx(), var_id);\n+                let var_ty = self.fcx.infcx().next_ty_var();\n                 self.fcx.inh.locals.borrow_mut().insert(nid, var_ty);\n                 var_ty\n             }\n@@ -551,8 +551,16 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n     };\n \n     // Remember return type so that regionck can access it later.\n-    let fn_sig_tys: Vec<ty::t> =\n-        arg_tys.iter().chain([ret_ty].iter()).map(|&ty| ty).collect();\n+    let mut fn_sig_tys: Vec<ty::t> =\n+        arg_tys.iter()\n+        .map(|&ty| ty)\n+        .collect();\n+\n+    if let ty::FnConverging(ret_ty) = ret_ty {\n+        fcx.require_type_is_sized(ret_ty, decl.output.span, traits::ReturnType);\n+        fn_sig_tys.push(ret_ty);\n+    }\n+\n     debug!(\"fn-sig-map: fn_id={} fn_sig_tys={}\",\n            fn_id,\n            fn_sig_tys.repr(tcx));\n@@ -584,9 +592,11 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n \n         visit.visit_block(body);\n     }\n-    fcx.require_type_is_sized(ret_ty, decl.output.span, traits::ReturnType);\n \n-    check_block_with_expected(&fcx, body, ExpectHasType(ret_ty));\n+    check_block_with_expected(&fcx, body, match ret_ty {\n+        ty::FnConverging(result_type) => ExpectHasType(result_type),\n+        ty::FnDiverging => NoExpectation\n+    });\n \n     for (input, arg) in decl.inputs.iter().zip(arg_tys.iter()) {\n         fcx.write_ty(input.id, *arg);\n@@ -1333,11 +1343,6 @@ fn check_cast(fcx: &FnCtxt,\n         return\n     }\n \n-    if ty::type_is_bot(t_e) {\n-        fcx.write_bot(id);\n-        return\n-    }\n-\n     if !ty::type_is_sized(fcx.tcx(), t_1) {\n         let tstr = fcx.infcx().ty_to_string(t_1);\n         fcx.type_error_message(span, |actual| {\n@@ -1562,6 +1567,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    pub fn default_diverging_type_variables_to_nil(&self) {\n+        for (_, &ref ty) in self.inh.node_types.borrow_mut().iter_mut() {\n+            if self.infcx().type_var_diverges(self.infcx().resolve_type_vars_if_possible(*ty)) {\n+                demand::eqtype(self, codemap::DUMMY_SP, *ty, ty::mk_nil());\n+            }\n+        }\n+    }\n+\n     #[inline]\n     pub fn write_ty(&self, node_id: ast::NodeId, ty: ty::t) {\n         debug!(\"write_ty({}, {}) in fcx {}\",\n@@ -1726,9 +1739,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn write_nil(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, ty::mk_nil());\n     }\n-    pub fn write_bot(&self, node_id: ast::NodeId) {\n-        self.write_ty(node_id, ty::mk_bot());\n-    }\n     pub fn write_error(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, ty::mk_err());\n     }\n@@ -2051,10 +2061,6 @@ pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: ty::t,\n     for autoderefs in range(0, fcx.tcx().sess.recursion_limit.get()) {\n         let resolved_t = structurally_resolved_type(fcx, sp, t);\n \n-        if ty::type_is_bot(resolved_t) {\n-            return (resolved_t, autoderefs, None);\n-        }\n-\n         match should_stop(resolved_t, autoderefs) {\n             Some(x) => return (resolved_t, autoderefs, Some(x)),\n             None => {}\n@@ -2197,7 +2203,12 @@ fn make_return_type(fcx: &FnCtxt,\n                 }\n                 None => {}\n             }\n-            ty::deref(ref_ty, true)\n+            match ref_ty {\n+                ty::FnConverging(ref_ty) =>\n+                    ty::deref(ref_ty, true),\n+                ty::FnDiverging =>\n+                    None\n+            }\n         }\n         None => None,\n     }\n@@ -2285,7 +2296,12 @@ fn try_overloaded_slice(fcx: &FnCtxt,\n                 }\n                 None => {}\n             }\n-            Some(ty::mt { ty: result_ty, mutbl: ast::MutImmutable })\n+            match result_ty {\n+                ty::FnConverging(result_ty) =>\n+                    Some(ty::mt { ty: result_ty, mutbl: ast::MutImmutable }),\n+                ty::FnDiverging =>\n+                    None\n+            }\n         }\n         None => None,\n     }\n@@ -2400,9 +2416,11 @@ fn lookup_method_for_for_loop(fcx: &FnCtxt,\n \n             // We expect the return type to be `Option` or something like it.\n             // Grab the first parameter of its type substitution.\n-            let return_type = structurally_resolved_type(fcx,\n-                                                         iterator_expr.span,\n-                                                         return_type);\n+            let return_type = match return_type {\n+                ty::FnConverging(return_type) =>\n+                    structurally_resolved_type(fcx, iterator_expr.span, return_type),\n+                ty::FnDiverging => ty::mk_err()\n+            };\n             match ty::get(return_type).sty {\n                 ty::ty_enum(_, ref substs)\n                         if !substs.types.is_empty_in(subst::TypeSpace) => {\n@@ -2427,7 +2445,7 @@ fn check_method_argument_types<'a>(fcx: &FnCtxt,\n                                    args_no_rcvr: &[&'a P<ast::Expr>],\n                                    deref_args: DerefArgs,\n                                    tuple_arguments: TupleArgumentsFlag)\n-                                   -> ty::t {\n+                                   -> ty::FnOutput {\n     if ty::type_is_error(method_fn_ty) {\n        let err_inputs = err_args(args_no_rcvr.len());\n         check_argument_types(fcx,\n@@ -2438,7 +2456,7 @@ fn check_method_argument_types<'a>(fcx: &FnCtxt,\n                              deref_args,\n                              false,\n                              tuple_arguments);\n-        method_fn_ty\n+        ty::FnConverging(method_fn_ty)\n     } else {\n         match ty::get(method_fn_ty).sty {\n             ty::ty_bare_fn(ref fty) => {\n@@ -2654,8 +2672,11 @@ fn err_args(len: uint) -> Vec<ty::t> {\n     Vec::from_fn(len, |_| ty::mk_err())\n }\n \n-fn write_call(fcx: &FnCtxt, call_expr: &ast::Expr, output: ty::t) {\n-    fcx.write_ty(call_expr.id, output);\n+fn write_call(fcx: &FnCtxt, call_expr: &ast::Expr, output: ty::FnOutput) {\n+    fcx.write_ty(call_expr.id, match output {\n+        ty::FnConverging(output_ty) => output_ty,\n+        ty::FnDiverging => fcx.infcx().next_diverging_ty_var()\n+    });\n }\n \n // AST fragment checking\n@@ -2845,8 +2866,8 @@ enum TupleArgumentsFlag {\n /// strict, _|_ can appear in the type of an expression that does not,\n /// itself, diverge: for example, fn() -> _|_.)\n /// Note that inspecting a type's structure *directly* may expose the fact\n-/// that there are actually multiple representations for both `ty_err` and\n-/// `ty_bot`, so avoid that when err and bot need to be handled differently.\n+/// that there are actually multiple representations for `ty_err`, so avoid\n+/// that when err needs to be handled differently.\n fn check_expr_with_unifier(fcx: &FnCtxt,\n                            expr: &ast::Expr,\n                            expected: Expectation,\n@@ -2873,7 +2894,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         let error_fn_sig = FnSig {\n             binder_id: ast::CRATE_NODE_ID,\n             inputs: err_args(args.len()),\n-            output: ty::mk_err(),\n+            output: ty::FnConverging(ty::mk_err()),\n             variadic: false\n         };\n \n@@ -3021,8 +3042,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         let cond_ty = fcx.expr_ty(cond_expr);\n         let if_ty = if ty::type_is_error(cond_ty) {\n             ty::mk_err()\n-        } else if ty::type_is_bot(cond_ty) {\n-            ty::mk_bot()\n         } else {\n             branches_ty\n         };\n@@ -3055,13 +3074,16 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 // HACK(eddyb) Fully qualified path to work around a resolve bug.\n                 let method_call = ::middle::typeck::MethodCall::expr(op_ex.id);\n                 fcx.inh.method_map.borrow_mut().insert(method_call, method);\n-                check_method_argument_types(fcx,\n+                match check_method_argument_types(fcx,\n                                             op_ex.span,\n                                             method_ty,\n                                             op_ex,\n                                             args.as_slice(),\n                                             DoDerefArgs,\n-                                            DontTupleArguments)\n+                                            DontTupleArguments) {\n+                    ty::FnConverging(result_type) => result_type,\n+                    ty::FnDiverging => ty::mk_err()\n+                }\n             }\n             None => {\n                 unbound_method();\n@@ -3663,9 +3685,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             None => {}\n             Some(base_expr) => {\n                 check_expr_has_type(fcx, &*base_expr, struct_type);\n-                if ty::type_is_bot(fcx.node_ty(base_expr.id)) {\n-                    struct_type = ty::mk_bot();\n-                }\n             }\n         }\n \n@@ -3763,10 +3782,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             ty::type_is_error(rhs_ty) {\n             fcx.write_error(id);\n         }\n-        else if ty::type_is_bot(lhs_ty) ||\n-          (ty::type_is_bot(rhs_ty) && !ast_util::lazy_binop(op)) {\n-            fcx.write_bot(id);\n-        }\n       }\n       ast::ExprAssignOp(op, ref lhs, ref rhs) => {\n         check_binop(fcx, expr, op, &**lhs, rhs, BinopAssignment);\n@@ -3785,8 +3800,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         // Overwrite result of check_binop...this preserves existing behavior\n         // but seems quite dubious with regard to user-defined methods\n         // and so forth. - Niko\n-        if !ty::type_is_error(result_t)\n-            && !ty::type_is_bot(result_t) {\n+        if !ty::type_is_error(result_t) {\n             fcx.write_nil(expr.id);\n         }\n       }\n@@ -3820,9 +3834,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         if !ty::type_is_error(oprnd_t) {\n             match unop {\n                 ast::UnUniq => {\n-                    if !ty::type_is_bot(oprnd_t) {\n-                        oprnd_t = ty::mk_uniq(tcx, oprnd_t);\n-                    }\n+                    oprnd_t = ty::mk_uniq(tcx, oprnd_t);\n                 }\n                 ast::UnDeref => {\n                     oprnd_t = structurally_resolved_type(fcx, expr.span, oprnd_t);\n@@ -3859,27 +3871,23 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     };\n                 }\n                 ast::UnNot => {\n-                    if !ty::type_is_bot(oprnd_t) {\n-                        oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n-                                                             oprnd_t);\n-                        if !(ty::type_is_integral(oprnd_t) ||\n-                             ty::get(oprnd_t).sty == ty::ty_bool) {\n-                            oprnd_t = check_user_unop(fcx, \"!\", \"not\",\n-                                                      tcx.lang_items.not_trait(),\n-                                                      expr, &**oprnd, oprnd_t);\n-                        }\n+                    oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n+                                                         oprnd_t);\n+                    if !(ty::type_is_integral(oprnd_t) ||\n+                         ty::get(oprnd_t).sty == ty::ty_bool) {\n+                        oprnd_t = check_user_unop(fcx, \"!\", \"not\",\n+                                                  tcx.lang_items.not_trait(),\n+                                                  expr, &**oprnd, oprnd_t);\n                     }\n                 }\n                 ast::UnNeg => {\n-                    if !ty::type_is_bot(oprnd_t) {\n-                        oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n-                                                             oprnd_t);\n-                        if !(ty::type_is_integral(oprnd_t) ||\n-                             ty::type_is_fp(oprnd_t)) {\n-                            oprnd_t = check_user_unop(fcx, \"-\", \"neg\",\n-                                                      tcx.lang_items.neg_trait(),\n-                                                      expr, &**oprnd, oprnd_t);\n-                        }\n+                    oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n+                                                         oprnd_t);\n+                    if !(ty::type_is_integral(oprnd_t) ||\n+                         ty::type_is_fp(oprnd_t)) {\n+                        oprnd_t = check_user_unop(fcx, \"-\", \"neg\",\n+                                                  tcx.lang_items.neg_trait(),\n+                                                  expr, &**oprnd, oprnd_t);\n                     }\n                 }\n             }\n@@ -3904,10 +3912,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         let tm = ty::mt { ty: fcx.expr_ty(&**oprnd), mutbl: mutbl };\n         let oprnd_t = if ty::type_is_error(tm.ty) {\n             ty::mk_err()\n-        } else if ty::type_is_bot(tm.ty) {\n-            ty::mk_bot()\n-        }\n-        else {\n+        } else {\n             // Note: at this point, we cannot say what the best lifetime\n             // is to use for resulting pointer.  We want to use the\n             // shortest lifetime possible so as to avoid spurious borrowck\n@@ -3961,24 +3966,32 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n           fcx.write_nil(id);\n       }\n       ast::ExprMac(_) => tcx.sess.bug(\"unexpanded macro\"),\n-      ast::ExprBreak(_) => { fcx.write_bot(id); }\n-      ast::ExprAgain(_) => { fcx.write_bot(id); }\n+      ast::ExprBreak(_) => { fcx.write_ty(id, fcx.infcx().next_diverging_ty_var()); }\n+      ast::ExprAgain(_) => { fcx.write_ty(id, fcx.infcx().next_diverging_ty_var()); }\n       ast::ExprRet(ref expr_opt) => {\n-        let ret_ty = fcx.ret_ty;\n-        match *expr_opt {\n-          None => match fcx.mk_eqty(false, infer::Misc(expr.span),\n-                                    ret_ty, ty::mk_nil()) {\n-            Ok(_) => { /* fall through */ }\n-            Err(_) => {\n-                span_err!(tcx.sess, expr.span, E0069,\n-                    \"`return;` in function returning non-nil\");\n+        match fcx.ret_ty {\n+            ty::FnConverging(result_type) => {\n+                match *expr_opt {\n+                    None =>\n+                        if let Err(_) = fcx.mk_eqty(false, infer::Misc(expr.span),\n+                                                    result_type, ty::mk_nil()) {\n+                            span_err!(tcx.sess, expr.span, E0069,\n+                                \"`return;` in function returning non-nil\");\n+                        },\n+                    Some(ref e) => {\n+                        check_expr_coercable_to_type(fcx, &**e, result_type);\n+                    }\n+                }\n+            }\n+            ty::FnDiverging => {\n+                if let Some(ref e) = *expr_opt {\n+                    check_expr(fcx, &**e);\n+                }\n+                span_err!(tcx.sess, expr.span, E0166,\n+                    \"`return` in a function declared as diverging\");\n             }\n-          },\n-          Some(ref e) => {\n-              check_expr_coercable_to_type(fcx, &**e, ret_ty);\n-          }\n         }\n-        fcx.write_bot(id);\n+        fcx.write_ty(id, fcx.infcx().next_diverging_ty_var());\n       }\n       ast::ExprParen(ref a) => {\n         check_expr_with_expectation_and_lvalue_pref(fcx,\n@@ -4004,8 +4017,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         if ty::type_is_error(lhs_ty) || ty::type_is_error(rhs_ty) {\n             fcx.write_error(id);\n-        } else if ty::type_is_bot(lhs_ty) || ty::type_is_bot(rhs_ty) {\n-            fcx.write_bot(id);\n         } else {\n             fcx.write_nil(id);\n         }\n@@ -4025,9 +4036,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         if ty::type_is_error(cond_ty) || ty::type_is_error(body_ty) {\n             fcx.write_error(id);\n         }\n-        else if ty::type_is_bot(cond_ty) {\n-            fcx.write_bot(id);\n-        }\n         else {\n             fcx.write_nil(id);\n         }\n@@ -4052,7 +4060,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprLoop(ref body, _) => {\n         check_block_no_value(fcx, &**body);\n         if !may_break(tcx, expr.id, &**body) {\n-            fcx.write_bot(id);\n+            fcx.write_ty(id, fcx.infcx().next_diverging_ty_var());\n         } else {\n             fcx.write_nil(id);\n         }\n@@ -4100,31 +4108,24 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n           let args: Vec<_> = args.iter().map(|x| x).collect();\n           if !try_overloaded_call(fcx, expr, &**f, f_ty, args.as_slice()) {\n               check_call(fcx, expr, &**f, args.as_slice());\n-              let (args_bot, args_err) = args.iter().fold((false, false),\n-                 |(rest_bot, rest_err), a| {\n+              let args_err = args.iter().fold(false,\n+                 |rest_err, a| {\n                      // is this not working?\n                      let a_ty = fcx.expr_ty(&***a);\n-                     (rest_bot || ty::type_is_bot(a_ty),\n-                      rest_err || ty::type_is_error(a_ty))});\n+                     rest_err || ty::type_is_error(a_ty)});\n               if ty::type_is_error(f_ty) || args_err {\n                   fcx.write_error(id);\n               }\n-              else if ty::type_is_bot(f_ty) || args_bot {\n-                  fcx.write_bot(id);\n-              }\n           }\n       }\n       ast::ExprMethodCall(ident, ref tps, ref args) => {\n         check_method_call(fcx, expr, ident, args.as_slice(), tps.as_slice(), lvalue_pref);\n         let mut arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n-        let (args_bot, args_err) = arg_tys.fold((false, false),\n-             |(rest_bot, rest_err), a| {\n-              (rest_bot || ty::type_is_bot(a),\n-               rest_err || ty::type_is_error(a))});\n+        let  args_err = arg_tys.fold(false,\n+             |rest_err, a| {\n+              rest_err || ty::type_is_error(a)});\n         if args_err {\n             fcx.write_error(id);\n-        } else if args_bot {\n-            fcx.write_bot(id);\n         }\n       }\n       ast::ExprCast(ref e, ref t) => {\n@@ -4203,8 +4204,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         if ty::type_is_error(element_ty) {\n             fcx.write_error(id);\n-        } else if ty::type_is_bot(element_ty) {\n-            fcx.write_bot(id);\n         } else {\n             let t = ty::mk_vec(tcx, t, Some(count));\n             fcx.write_ty(id, t);\n@@ -4218,7 +4217,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 _ => None\n             }\n         });\n-        let mut bot_field = false;\n         let mut err_field = false;\n \n         let elt_ts = elts.iter().enumerate().map(|(i, e)| {\n@@ -4234,12 +4232,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 }\n             };\n             err_field = err_field || ty::type_is_error(t);\n-            bot_field = bot_field || ty::type_is_bot(t);\n             t\n         }).collect();\n-        if bot_field {\n-            fcx.write_bot(id);\n-        } else if err_field {\n+        if err_field {\n             fcx.write_error(id);\n         } else {\n             let typ = ty::mk_tup(tcx, elt_ts);\n@@ -4352,7 +4347,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 autoderef(fcx, expr.span, raw_base_t, Some(base.id),\n                           lvalue_pref, |base_t, _| ty::index(base_t));\n               match field_ty {\n-                  Some(ty) if !ty::type_is_bot(ty) => {\n+                  Some(ty) => {\n                       check_expr_has_type(fcx, &**idx, ty::mk_uint());\n                       fcx.write_ty(id, ty);\n                       fcx.write_autoderef_adjustment(base.id, base.span, autoderefs);\n@@ -4394,7 +4389,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n           let raw_base_t = fcx.expr_ty(&**base);\n \n           let mut some_err = false;\n-          if ty::type_is_error(raw_base_t) || ty::type_is_bot(raw_base_t) {\n+          if ty::type_is_error(raw_base_t) {\n               fcx.write_ty(id, raw_base_t);\n               some_err = true;\n           }\n@@ -4403,7 +4398,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n               let check_slice_idx = |e: &ast::Expr| {\n                   check_expr(fcx, e);\n                   let e_t = fcx.expr_ty(e);\n-                  if ty::type_is_error(e_t) || ty::type_is_bot(e_t) {\n+                  if ty::type_is_error(e_t) {\n                     fcx.write_ty(id, e_t);\n                     some_err = true;\n                   }\n@@ -4543,7 +4538,7 @@ pub fn check_decl_local(fcx: &FnCtxt, local: &ast::Local)  {\n         Some(ref init) => {\n             check_decl_initializer(fcx, local.id, &**init);\n             let init_ty = fcx.expr_ty(&**init);\n-            if ty::type_is_error(init_ty) || ty::type_is_bot(init_ty) {\n+            if ty::type_is_error(init_ty) {\n                 fcx.write_ty(local.id, init_ty);\n             }\n         }\n@@ -4556,7 +4551,7 @@ pub fn check_decl_local(fcx: &FnCtxt, local: &ast::Local)  {\n     };\n     _match::check_pat(&pcx, &*local.pat, t);\n     let pat_ty = fcx.node_ty(local.pat.id);\n-    if ty::type_is_error(pat_ty) || ty::type_is_bot(pat_ty) {\n+    if ty::type_is_error(pat_ty) {\n         fcx.write_ty(local.id, pat_ty);\n     }\n }\n@@ -4572,7 +4567,7 @@ pub fn check_stmt(fcx: &FnCtxt, stmt: &ast::Stmt)  {\n           ast::DeclLocal(ref l) => {\n               check_decl_local(fcx, &**l);\n               let l_t = fcx.node_ty(l.id);\n-              saw_bot = saw_bot || ty::type_is_bot(l_t);\n+              saw_bot = saw_bot || fcx.infcx().type_var_diverges(l_t);\n               saw_err = saw_err || ty::type_is_error(l_t);\n           }\n           ast::DeclItem(_) => {/* ignore for now */ }\n@@ -4583,20 +4578,20 @@ pub fn check_stmt(fcx: &FnCtxt, stmt: &ast::Stmt)  {\n         // Check with expected type of ()\n         check_expr_has_type(fcx, &**expr, ty::mk_nil());\n         let expr_ty = fcx.expr_ty(&**expr);\n-        saw_bot = saw_bot || ty::type_is_bot(expr_ty);\n+        saw_bot = saw_bot || fcx.infcx().type_var_diverges(expr_ty);\n         saw_err = saw_err || ty::type_is_error(expr_ty);\n       }\n       ast::StmtSemi(ref expr, id) => {\n         node_id = id;\n         check_expr(fcx, &**expr);\n         let expr_ty = fcx.expr_ty(&**expr);\n-        saw_bot |= ty::type_is_bot(expr_ty);\n+        saw_bot |= fcx.infcx().type_var_diverges(expr_ty);\n         saw_err |= ty::type_is_error(expr_ty);\n       }\n       ast::StmtMac(..) => fcx.ccx.tcx.sess.bug(\"unexpanded macro\")\n     }\n     if saw_bot {\n-        fcx.write_bot(node_id);\n+        fcx.write_ty(node_id, fcx.infcx().next_diverging_ty_var());\n     }\n     else if saw_err {\n         fcx.write_error(node_id);\n@@ -4611,11 +4606,7 @@ pub fn check_block_no_value(fcx: &FnCtxt, blk: &ast::Block)  {\n     let blkty = fcx.node_ty(blk.id);\n     if ty::type_is_error(blkty) {\n         fcx.write_error(blk.id);\n-    }\n-    else if ty::type_is_bot(blkty) {\n-        fcx.write_bot(blk.id);\n-    }\n-    else {\n+    } else {\n         let nilty = ty::mk_nil();\n         demand::suptype(fcx, blk.span, nilty, blkty);\n     }\n@@ -4631,14 +4622,13 @@ fn check_block_with_expected(fcx: &FnCtxt,\n     };\n \n     let mut warned = false;\n-    let mut last_was_bot = false;\n-    let mut any_bot = false;\n+    let mut any_diverges = false;\n     let mut any_err = false;\n     for s in blk.stmts.iter() {\n         check_stmt(fcx, &**s);\n         let s_id = ast_util::stmt_id(&**s);\n         let s_ty = fcx.node_ty(s_id);\n-        if last_was_bot && !warned && match s.node {\n+        if any_diverges && !warned && match s.node {\n             ast::StmtDecl(ref decl, _) => {\n                 match decl.node {\n                     ast::DeclLocal(_) => true,\n@@ -4657,22 +4647,19 @@ fn check_block_with_expected(fcx: &FnCtxt,\n                           \"unreachable statement\".to_string());\n             warned = true;\n         }\n-        if ty::type_is_bot(s_ty) {\n-            last_was_bot = true;\n-        }\n-        any_bot = any_bot || ty::type_is_bot(s_ty);\n+        any_diverges = any_diverges || fcx.infcx().type_var_diverges(s_ty);\n         any_err = any_err || ty::type_is_error(s_ty);\n     }\n     match blk.expr {\n         None => if any_err {\n             fcx.write_error(blk.id);\n-        } else if any_bot {\n-            fcx.write_bot(blk.id);\n+        } else if any_diverges {\n+            fcx.write_ty(blk.id, fcx.infcx().next_diverging_ty_var());\n         } else {\n             fcx.write_nil(blk.id);\n         },\n         Some(ref e) => {\n-            if any_bot && !warned {\n+            if any_diverges && !warned {\n                 fcx.ccx\n                     .tcx\n                     .sess\n@@ -4692,11 +4679,12 @@ fn check_block_with_expected(fcx: &FnCtxt,\n                 }\n             };\n \n-            fcx.write_ty(blk.id, ety);\n             if any_err {\n                 fcx.write_error(blk.id);\n-            } else if any_bot {\n-                fcx.write_bot(blk.id);\n+            } else if any_diverges {\n+                fcx.write_ty(blk.id, fcx.infcx().next_diverging_ty_var());\n+            } else {\n+                fcx.write_ty(blk.id, ety);\n             }\n         }\n     };\n@@ -4718,7 +4706,7 @@ pub fn check_const_in_type(tcx: &ty::ctxt,\n         tcx: tcx,\n     };\n     let inh = static_inherited_fields(&ccx);\n-    let fcx = blank_fn_ctxt(&ccx, &inh, expected_type, expr.id);\n+    let fcx = blank_fn_ctxt(&ccx, &inh, ty::FnConverging(expected_type), expr.id);\n     check_const_with_ty(&fcx, expr.span, expr, expected_type);\n }\n \n@@ -4728,7 +4716,7 @@ pub fn check_const(ccx: &CrateCtxt,\n                    id: ast::NodeId) {\n     let inh = static_inherited_fields(ccx);\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n-    let fcx = blank_fn_ctxt(ccx, &inh, rty, e.id);\n+    let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n     let declty = (*fcx.ccx.tcx.tcache.borrow())[local_def(id)].ty;\n     check_const_with_ty(&fcx, sp, e, declty);\n }\n@@ -4892,7 +4880,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n                     debug!(\"disr expr, checking {}\", pprust::expr_to_string(&**e));\n \n                     let inh = static_inherited_fields(ccx);\n-                    let fcx = blank_fn_ctxt(ccx, &inh, rty, e.id);\n+                    let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n                     let declty = match hint {\n                         attr::ReprAny | attr::ReprPacked | attr::ReprExtern => ty::mk_int(),\n                         attr::ReprInt(_, attr::SignedInt(ity)) => {\n@@ -5494,7 +5482,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n \n         //We only care about the operation here\n-        match split[1] {\n+        let (n_tps, inputs, output) = match split[1] {\n             \"cxchg\" => (1, vec!(ty::mk_mut_ptr(tcx, param(ccx, 0)),\n                                 param(ccx, 0),\n                                 param(ccx, 0)),\n@@ -5517,12 +5505,12 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                     \"unrecognized atomic operation function: `{}`\", op);\n                 return;\n             }\n-        }\n-\n+        };\n+        (n_tps, inputs, ty::FnConverging(output))\n+    } else if name.get() == \"abort\" || name.get() == \"unreachable\" {\n+        (0, Vec::new(), ty::FnDiverging)\n     } else {\n-        match name.get() {\n-            \"abort\" => (0, Vec::new(), ty::mk_bot()),\n-            \"unreachable\" => (0, Vec::new(), ty::mk_bot()),\n+        let (n_tps, inputs, output) = match name.get() {\n             \"breakpoint\" => (0, Vec::new(), ty::mk_nil()),\n             \"size_of\" |\n             \"pref_align_of\" | \"min_align_of\" => (1u, Vec::new(), ty::mk_uint()),\n@@ -5730,7 +5718,8 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                     \"unrecognized intrinsic function: `{}`\", *other);\n                 return;\n             }\n-        }\n+        };\n+        (n_tps, inputs, ty::FnConverging(output))\n     };\n     let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n         fn_style: ast::UnsafeFn,"}, {"sha": "bcade1e74ca65d8b910b1c6cfce1ab21d28e76f8", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -334,7 +334,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     /// Try to resolve the type for the given node.\n     pub fn resolve_expr_type_adjusted(&mut self, expr: &ast::Expr) -> ty::t {\n         let ty_unadjusted = self.resolve_node_type(expr.id);\n-        if ty::type_is_error(ty_unadjusted) || ty::type_is_bot(ty_unadjusted) {\n+        if ty::type_is_error(ty_unadjusted) {\n             ty_unadjusted\n         } else {\n             let tcx = self.fcx.tcx();\n@@ -690,7 +690,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                 Some(method) => {\n                     constrain_call(rcx, expr, Some(&**base),\n                                    None::<ast::Expr>.iter(), true);\n-                    ty::ty_fn_ret(method.ty)\n+                    ty::ty_fn_ret(method.ty).unwrap()\n                 }\n                 None => rcx.resolve_node_type(base.id)\n             };\n@@ -1217,9 +1217,14 @@ fn constrain_autoderefs(rcx: &mut Rcx,\n                 // Specialized version of constrain_call.\n                 type_must_outlive(rcx, infer::CallRcvr(deref_expr.span),\n                                   self_ty, r_deref_expr);\n-                type_must_outlive(rcx, infer::CallReturn(deref_expr.span),\n-                                  fn_sig.output, r_deref_expr);\n-                fn_sig.output\n+                match fn_sig.output {\n+                    ty::FnConverging(return_type) => {\n+                        type_must_outlive(rcx, infer::CallReturn(deref_expr.span),\n+                                          return_type, r_deref_expr);\n+                        return_type\n+                    }\n+                    ty::FnDiverging => unreachable!()\n+                }\n             }\n             None => derefd_ty\n         };\n@@ -1445,7 +1450,7 @@ fn link_region_from_node_type(rcx: &Rcx,\n      */\n \n     let rptr_ty = rcx.resolve_node_type(id);\n-    if !ty::type_is_bot(rptr_ty) && !ty::type_is_error(rptr_ty) {\n+    if !ty::type_is_error(rptr_ty) {\n         let tcx = rcx.fcx.ccx.tcx;\n         debug!(\"rptr_ty={}\", ty_to_string(tcx, rptr_ty));\n         let r = ty::ty_region(tcx, span, rptr_ty);"}, {"sha": "225a3162af90470c62d7d5d617961817e4b55389", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -92,7 +92,6 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n \n         match ty::get(ty).sty {\n             ty::ty_nil |\n-            ty::ty_bot |\n             ty::ty_bool |\n             ty::ty_char |\n             ty::ty_int(..) |"}, {"sha": "b3449d658f6d6e556da15cb8914a003960f97e7f", "filename": "src/librustc/middle/typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -98,7 +98,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                                 &polytype.generics,\n                                                 item.id);\n         let inh = Inherited::new(ccx.tcx, param_env);\n-        let fcx = blank_fn_ctxt(ccx, &inh, polytype.ty, item.id);\n+        let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(polytype.ty), item.id);\n         f(self, &fcx);\n         vtable::select_all_fcx_obligations_or_error(&fcx);\n         regionck::regionck_item(&fcx, item);"}, {"sha": "92fc61cf4c034e2c5b16ae681e9ac4bb029cddf0", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -23,7 +23,7 @@ use middle::subst::{Substs};\n use middle::ty::get;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, MethodTraitItemId};\n use middle::ty::{TypeTraitItemId, lookup_item_type};\n-use middle::ty::{t, ty_bool, ty_char, ty_bot, ty_enum, ty_err};\n+use middle::ty::{t, ty_bool, ty_char, ty_enum, ty_err};\n use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_nil, ty_open};\n use middle::ty::{ty_param, Polytype, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n@@ -82,7 +82,7 @@ fn get_base_type(inference_context: &InferCtxt,\n             Some(resolved_type)\n         }\n \n-        ty_nil | ty_bot | ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n+        ty_nil | ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n         ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n         ty_infer(..) | ty_param(..) | ty_err | ty_open(..) | ty_uniq(_) |\n         ty_ptr(_) | ty_rptr(_, _) => {"}, {"sha": "4c85418669fbb789175a7d3ebd11fec15a245c87", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -2236,7 +2236,10 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                         .map(|a| ty_of_arg(ccx, &rb, a, None))\n                         .collect();\n \n-    let output_ty = ast_ty_to_ty(ccx, &rb, &*decl.output);\n+    let output = match decl.output.node {\n+        ast::TyBot => ty::FnDiverging,\n+        _ => ty::FnConverging(ast_ty_to_ty(ccx, &rb, &*decl.output))\n+    };\n \n     let t_fn = ty::mk_bare_fn(\n         ccx.tcx,\n@@ -2245,7 +2248,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n             fn_style: ast::UnsafeFn,\n             sig: ty::FnSig {binder_id: def_id.node,\n                             inputs: input_tys,\n-                            output: output_ty,\n+                            output: output,\n                             variadic: decl.variadic}\n         });\n     let pty = Polytype {"}, {"sha": "de9379a3aa763e79442d94105340877a9d1f7495", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -359,7 +359,18 @@ pub fn super_fn_sigs<'tcx, C: Combine<'tcx>>(this: &C,\n     let inputs = try!(argvecs(this,\n                                 a.inputs.as_slice(),\n                                 b.inputs.as_slice()));\n-    let output = try!(this.tys(a.output, b.output));\n+\n+    let output = try!(match (a.output, b.output) {\n+        (ty::FnConverging(a_ty), ty::FnConverging(b_ty)) =>\n+            Ok(ty::FnConverging(try!(this.tys(a_ty, b_ty)))),\n+        (ty::FnDiverging, ty::FnDiverging) =>\n+            Ok(ty::FnDiverging),\n+        (a, b) =>\n+            Err(ty::terr_convergence_mismatch(\n+                expected_found(this, a != ty::FnDiverging, b != ty::FnDiverging)\n+            )),\n+    });\n+\n     Ok(FnSig {binder_id: a.binder_id,\n               inputs: inputs,\n               output: output,\n@@ -373,9 +384,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n     let b_sty = &ty::get(b).sty;\n     debug!(\"super_tys: a_sty={} b_sty={}\", a_sty, b_sty);\n     return match (a_sty, b_sty) {\n-      // The \"subtype\" ought to be handling cases involving bot or var:\n-      (&ty::ty_bot, _) |\n-      (_, &ty::ty_bot) |\n+      // The \"subtype\" ought to be handling cases involving var:\n       (&ty::ty_infer(TyVar(_)), _) |\n       (_, &ty::ty_infer(TyVar(_))) => {\n         tcx.sess.bug("}, {"sha": "97453dc86efd442ed6fe769fedf33fd721212d07", "filename": "src/librustc/middle/typeck/infer/equate.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -112,15 +112,6 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n         let a = infcx.type_variables.borrow().replace_if_possible(a);\n         let b = infcx.type_variables.borrow().replace_if_possible(b);\n         match (&ty::get(a).sty, &ty::get(b).sty) {\n-            (&ty::ty_bot, &ty::ty_bot) => {\n-                Ok(a)\n-            }\n-\n-            (&ty::ty_bot, _) |\n-            (_, &ty::ty_bot) => {\n-                Err(ty::terr_sorts(expected_found(self, a, b)))\n-            }\n-\n             (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n                 infcx.type_variables.borrow_mut().relate_vars(a_id, EqTo, b_id);\n                 Ok(a)"}, {"sha": "4fb7bebc58f6d7e29c695f5af6afb7d14694566c", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -42,20 +42,12 @@ use util::ppaux::Repr;\n use std::collections::HashMap;\n \n pub trait LatticeDir {\n-    // Relates the bottom type to `t` and returns LUB(t, _|_) or\n-    // GLB(t, _|_) as appropriate.\n-    fn ty_bot(&self, t: ty::t) -> cres<ty::t>;\n-\n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n     fn relate_bound<'a>(&'a self, v: ty::t, a: ty::t, b: ty::t) -> cres<()>;\n }\n \n impl<'a, 'tcx> LatticeDir for Lub<'a, 'tcx> {\n-    fn ty_bot(&self, t: ty::t) -> cres<ty::t> {\n-        Ok(t)\n-    }\n-\n     fn relate_bound<'a>(&'a self, v: ty::t, a: ty::t, b: ty::t) -> cres<()> {\n         let sub = self.sub();\n         try!(sub.tys(a, v));\n@@ -65,10 +57,6 @@ impl<'a, 'tcx> LatticeDir for Lub<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> LatticeDir for Glb<'a, 'tcx> {\n-    fn ty_bot(&self, _: ty::t) -> cres<ty::t> {\n-        Ok(ty::mk_bot())\n-    }\n-\n     fn relate_bound<'a>(&'a self, v: ty::t, a: ty::t, b: ty::t) -> cres<()> {\n         let sub = self.sub();\n         try!(sub.tys(v, a));\n@@ -95,8 +83,12 @@ pub fn super_lattice_tys<'tcx, L:LatticeDir+Combine<'tcx>>(this: &L,\n     let a = infcx.type_variables.borrow().replace_if_possible(a);\n     let b = infcx.type_variables.borrow().replace_if_possible(b);\n     match (&ty::get(a).sty, &ty::get(b).sty) {\n-        (&ty::ty_bot, _) => { this.ty_bot(b) }\n-        (_, &ty::ty_bot) => { this.ty_bot(a) }\n+        (&ty::ty_infer(TyVar(..)), &ty::ty_infer(TyVar(..)))\n+            if infcx.type_var_diverges(a) && infcx.type_var_diverges(b) => {\n+            let v = infcx.next_diverging_ty_var();\n+            try!(this.relate_bound(v, a, b));\n+            Ok(v)\n+        }\n \n         (&ty::ty_infer(TyVar(..)), _) |\n         (_, &ty::ty_infer(TyVar(..))) => {"}, {"sha": "fc508db3b2ebd967d4602fc0b6cd9ea49fc70e17", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -510,6 +510,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         t.fold_with(&mut self.skolemizer())\n     }\n \n+    pub fn type_var_diverges(&'a self, ty: ty::t) -> bool {\n+        match ty::get(ty).sty {\n+            ty::ty_infer(ty::TyVar(vid)) => self.type_variables.borrow().var_diverges(vid),\n+            _ => false\n+        }\n+    }\n+\n     pub fn skolemizer<'a>(&'a self) -> TypeSkolemizer<'a, 'tcx> {\n         skolemize::TypeSkolemizer::new(self)\n     }\n@@ -684,14 +691,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn next_ty_var_id(&self) -> TyVid {\n+    pub fn next_ty_var_id(&self, diverging: bool) -> TyVid {\n         self.type_variables\n             .borrow_mut()\n-            .new_var()\n+            .new_var(diverging)\n     }\n \n     pub fn next_ty_var(&self) -> ty::t {\n-        ty::mk_var(self.tcx, self.next_ty_var_id())\n+        ty::mk_var(self.tcx, self.next_ty_var_id(false))\n+    }\n+\n+    pub fn next_diverging_ty_var(&self) -> ty::t {\n+        ty::mk_var(self.tcx, self.next_ty_var_id(true))\n     }\n \n     pub fn next_ty_vars(&self, n: uint) -> Vec<ty::t> {"}, {"sha": "db26376fc69db2144f60271a286639c842ed1ee6", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -205,7 +205,8 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n \n     pub fn resolve_ty_var(&mut self, vid: TyVid) -> ty::t {\n         let tcx = self.infcx.tcx;\n-        let t1 = match self.infcx.type_variables.borrow().probe(vid) {\n+        let tv = self.infcx.type_variables.borrow();\n+        match tv.probe(vid) {\n             Some(t) => {\n                 self.resolve_type(t)\n             }\n@@ -215,8 +216,7 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n                 }\n                 ty::mk_var(tcx, vid)\n             }\n-        };\n-        return t1;\n+        }\n     }\n \n     pub fn resolve_int_var(&mut self, vid: IntVid) -> ty::t {"}, {"sha": "0fe1e2b565befa4a12ce0588ba00778b9613de5e", "filename": "src/librustc/middle/typeck/infer/skolemize.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -149,7 +149,6 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeSkolemizer<'a, 'tcx> {\n             }\n \n             ty::ty_nil |\n-            ty::ty_bot |\n             ty::ty_bool |\n             ty::ty_char |\n             ty::ty_int(..) |"}, {"sha": "f44fa1ac1c69689272482f0e9b8472428a071823", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -129,10 +129,6 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         let a = infcx.type_variables.borrow().replace_if_possible(a);\n         let b = infcx.type_variables.borrow().replace_if_possible(b);\n         match (&ty::get(a).sty, &ty::get(b).sty) {\n-            (&ty::ty_bot, _) => {\n-                Ok(a)\n-            }\n-\n             (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n                 infcx.type_variables\n                     .borrow_mut()\n@@ -154,10 +150,6 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n                 Ok(ty::mk_err())\n             }\n \n-            (_, &ty::ty_bot) => {\n-                Err(ty::terr_sorts(expected_found(self, a, b)))\n-            }\n-\n             _ => {\n                 super_tys(self, a, b)\n             }"}, {"sha": "deeb90503df2157d9cc9d5eec971548374396ba7", "filename": "src/librustc/middle/typeck/infer/type_variable.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -17,7 +17,8 @@ pub struct TypeVariableTable {\n }\n \n struct TypeVariableData {\n-    value: TypeVariableValue\n+    value: TypeVariableValue,\n+    diverging: bool\n }\n \n enum TypeVariableValue {\n@@ -63,6 +64,10 @@ impl TypeVariableTable {\n         relations(self.values.get_mut(a.index))\n     }\n \n+    pub fn var_diverges<'a>(&'a self, vid: ty::TyVid) -> bool {\n+        self.values.get(vid.index).diverging\n+    }\n+\n     pub fn relate_vars(&mut self, a: ty::TyVid, dir: RelationDir, b: ty::TyVid) {\n         /*!\n          * Records that `a <: b`, `a :> b`, or `a == b`, depending on `dir`.\n@@ -108,10 +113,11 @@ impl TypeVariableTable {\n         self.values.record(SpecifyVar(vid, relations));\n     }\n \n-    pub fn new_var(&mut self) -> ty::TyVid {\n-        let index =\n-            self.values.push(\n-                TypeVariableData { value: Bounded(Vec::new()) });\n+    pub fn new_var(&mut self, diverging: bool) -> ty::TyVid {\n+        let index = self.values.push(TypeVariableData {\n+            value: Bounded(vec![]),\n+            diverging: diverging\n+        });\n         ty::TyVid { index: index }\n     }\n "}, {"sha": "22898221d9b53468a5839592dbafd2e7e9b6b748", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -381,7 +381,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 sig: ty::FnSig {\n                     binder_id: main_id,\n                     inputs: Vec::new(),\n-                    output: ty::mk_nil(),\n+                    output: ty::FnConverging(ty::mk_nil()),\n                     variadic: false\n                 }\n             });\n@@ -433,7 +433,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                         ty::mk_int(),\n                         ty::mk_imm_ptr(tcx, ty::mk_imm_ptr(tcx, ty::mk_u8()))\n                     ),\n-                    output: ty::mk_int(),\n+                    output: ty::FnConverging(ty::mk_int()),\n                     variadic: false\n                 }\n             });"}, {"sha": "8e4aea4463ee37633ab7abe1be3453236b01f078", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -728,7 +728,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         debug!(\"add_constraints_from_ty(ty={})\", ty.repr(self.tcx()));\n \n         match ty::get(ty).sty {\n-            ty::ty_nil | ty::ty_bot | ty::ty_bool |\n+            ty::ty_nil | ty::ty_bool |\n             ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) |\n             ty::ty_float(_) | ty::ty_str => {\n                 /* leaf type -- noop */\n@@ -882,7 +882,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         for &input in sig.inputs.iter() {\n             self.add_constraints_from_ty(input, contra);\n         }\n-        self.add_constraints_from_ty(sig.output, variance);\n+        if let ty::FnConverging(result_type) = sig.output {\n+            self.add_constraints_from_ty(result_type, variance);\n+        }\n     }\n \n     /// Adds constraints appropriate for a region appearing in a"}, {"sha": "b1f8b2de417fb464e17e3e222b8c5f63b633fc31", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -17,7 +17,7 @@ use middle::ty::{ReEarlyBound, BrFresh, ctxt};\n use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region, ReEmpty};\n use middle::ty::{ReSkolemized, ReVar, BrEnv};\n use middle::ty::{mt, t, ParamTy};\n-use middle::ty::{ty_bool, ty_char, ty_bot, ty_struct, ty_enum};\n+use middle::ty::{ty_bool, ty_char, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn, ty_closure};\n use middle::ty::{ty_nil, ty_param, ty_ptr, ty_rptr, ty_tup, ty_open};\n use middle::ty::{ty_unboxed_closure};\n@@ -352,12 +352,15 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n             s.push_str(bounds);\n         }\n \n-        if ty::get(sig.output).sty != ty_nil {\n-            s.push_str(\" -> \");\n-            if ty::type_is_bot(sig.output) {\n-                s.push('!');\n-            } else {\n-                s.push_str(ty_to_string(cx, sig.output).as_slice());\n+        match sig.output {\n+            ty::FnConverging(t) => {\n+                if !ty::type_is_nil(t) {\n+                    s.push_str(\" -> \");\n+                   s.push_str(ty_to_string(cx, t).as_slice());\n+                }\n+            }\n+            ty::FnDiverging => {\n+                s.push_str(\" -> !\");\n             }\n         }\n     }\n@@ -371,7 +374,6 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n     // pretty print the structural type representation:\n     return match ty::get(typ).sty {\n       ty_nil => \"()\".to_string(),\n-      ty_bot => \"!\".to_string(),\n       ty_bool => \"bool\".to_string(),\n       ty_char => \"char\".to_string(),\n       ty_int(t) => ast_util::int_ty_to_string(t, None).to_string(),\n@@ -952,6 +954,19 @@ impl Repr for ty::FnSig {\n     }\n }\n \n+impl Repr for ty::FnOutput {\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        match *self {\n+          ty::FnConverging(ty) => {\n+            format!(\"FnConverging({0})\", ty.repr(tcx))\n+          }\n+          ty::FnDiverging => {\n+            \"FnDiverging\".to_string()\n+          }\n+        }\n+    }\n+}\n+\n impl Repr for typeck::MethodCallee {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"MethodCallee {{origin: {}, ty: {}, {}}}\","}, {"sha": "c4d7e85904cb31e745dd0d30e1ff801c74eff622", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -880,6 +880,15 @@ impl Clean<FnDecl> for ast::FnDecl {\n     }\n }\n \n+impl<'a> Clean<Type> for ty::FnOutput {\n+    fn clean(&self, cx: &DocContext) -> Type {\n+        match *self {\n+            ty::FnConverging(ty) => ty.clean(cx),\n+            ty::FnDiverging => Bottom\n+        }\n+    }\n+}\n+\n impl<'a> Clean<FnDecl> for (ast::DefId, &'a ty::FnSig) {\n     fn clean(&self, cx: &DocContext) -> FnDecl {\n         let (did, sig) = *self;\n@@ -1258,7 +1267,6 @@ impl Clean<Type> for ast::Ty {\n impl Clean<Type> for ty::t {\n     fn clean(&self, cx: &DocContext) -> Type {\n         match ty::get(*self).sty {\n-            ty::ty_bot => Bottom,\n             ty::ty_nil => Primitive(Unit),\n             ty::ty_bool => Primitive(Bool),\n             ty::ty_char => Primitive(Char),"}, {"sha": "c2972d4c5a8e0657463b9e318ed07710c82fccff", "filename": "src/test/compile-fail/issue-13847.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Ftest%2Fcompile-fail%2Fissue-13847.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca84e9e21b3f021fb6a0d9dedaad270753531cc/src%2Ftest%2Fcompile-fail%2Fissue-13847.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13847.rs?ref=cca84e9e21b3f021fb6a0d9dedaad270753531cc", "patch": "@@ -9,6 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    return.is_failure\n-//~^ ERROR attempted access of field `is_failure` on type `!`, but no field with that name was found\n+    return.is_failure //~ ERROR unconstrained type variable\n }"}]}