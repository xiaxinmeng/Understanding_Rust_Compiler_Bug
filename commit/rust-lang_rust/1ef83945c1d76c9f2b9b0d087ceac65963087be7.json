{"sha": "1ef83945c1d76c9f2b9b0d087ceac65963087be7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlZjgzOTQ1YzFkNzZjOWYyYjliMGQwODdjZWFjNjU5NjMwODdiZTc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-01-26T01:51:53Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-01-26T02:06:30Z"}, "message": "Merge remote-tracking branch 'brson/nocommupstream'\n\nConflicts:\n\tsrc/libcore/private.rs\n\tsrc/libcore/task/mod.rs\n\tsrc/libcore/task/spawn.rs\n\tsrc/libstd/net_tcp.rs\n\tsrc/libstd/uv_global_loop.rs\n\tsrc/libstd/uv_iotask.rs", "tree": {"sha": "b114ac7f84a0a10a3d207da0bcd3e9dcc2418e7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b114ac7f84a0a10a3d207da0bcd3e9dcc2418e7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ef83945c1d76c9f2b9b0d087ceac65963087be7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ef83945c1d76c9f2b9b0d087ceac65963087be7", "html_url": "https://github.com/rust-lang/rust/commit/1ef83945c1d76c9f2b9b0d087ceac65963087be7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ef83945c1d76c9f2b9b0d087ceac65963087be7/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1f771ca341bc93e2ebe9f0ef9979a71a8e3c6d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1f771ca341bc93e2ebe9f0ef9979a71a8e3c6d8", "html_url": "https://github.com/rust-lang/rust/commit/d1f771ca341bc93e2ebe9f0ef9979a71a8e3c6d8"}, {"sha": "19aa88cd64c81b77b874f9396a43fedfa28f14ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/19aa88cd64c81b77b874f9396a43fedfa28f14ee", "html_url": "https://github.com/rust-lang/rust/commit/19aa88cd64c81b77b874f9396a43fedfa28f14ee"}], "stats": {"total": 2867, "additions": 1683, "deletions": 1184}, "files": [{"sha": "6f568e9b2a708a532b2753e08031fda9cc57ac2e", "filename": "src/libcore/os.rs", "status": "modified", "additions": 68, "deletions": 136, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -141,169 +141,101 @@ pub mod win32 {\n     }\n }\n \n-pub fn getenv(n: &str) -> Option<~str> {\n-    global_env::getenv(n)\n-}\n+/*\n+Accessing environment variables is not generally threadsafe.\n+This uses a per-runtime lock to serialize access.\n+XXX: It would probably be appropriate to make this a real global\n+*/\n+fn with_env_lock<T>(f: &fn() -> T) -> T {\n+    use private::global::global_data_clone_create;\n+    use private::{Exclusive, exclusive};\n+\n+    struct SharedValue(());\n+    type ValueMutex = Exclusive<SharedValue>;\n+    fn key(_: ValueMutex) { }\n \n-pub fn setenv(n: &str, v: &str) {\n-    global_env::setenv(n, v)\n-}\n+    unsafe {\n+        let lock: ValueMutex = global_data_clone_create(key, || {\n+            ~exclusive(SharedValue(()))\n+        });\n \n-pub fn env() -> ~[(~str,~str)] {\n-    global_env::env()\n+        lock.with_imm(|_| f() )\n+    }\n }\n \n-mod global_env {\n-    //! Internal module for serializing access to getenv/setenv\n-    use either;\n-    use libc;\n-    use oldcomm;\n-    use option::Option;\n-    use private;\n-    use str;\n-    use task;\n-\n+pub fn env() -> ~[(~str,~str)] {\n     extern mod rustrt {\n-        unsafe fn rust_global_env_chan_ptr() -> *libc::uintptr_t;\n-    }\n-\n-    enum Msg {\n-        MsgGetEnv(~str, oldcomm::Chan<Option<~str>>),\n-        MsgSetEnv(~str, ~str, oldcomm::Chan<()>),\n-        MsgEnv(oldcomm::Chan<~[(~str,~str)]>)\n-    }\n-\n-    pub fn getenv(n: &str) -> Option<~str> {\n-        let env_ch = get_global_env_chan();\n-        let po = oldcomm::Port();\n-        oldcomm::send(env_ch, MsgGetEnv(str::from_slice(n),\n-                                        oldcomm::Chan(&po)));\n-        oldcomm::recv(po)\n-    }\n-\n-    pub fn setenv(n: &str, v: &str) {\n-        let env_ch = get_global_env_chan();\n-        let po = oldcomm::Port();\n-        oldcomm::send(env_ch, MsgSetEnv(str::from_slice(n),\n-                                        str::from_slice(v),\n-                                        oldcomm::Chan(&po)));\n-        oldcomm::recv(po)\n-    }\n-\n-    pub fn env() -> ~[(~str,~str)] {\n-        let env_ch = get_global_env_chan();\n-        let po = oldcomm::Port();\n-        oldcomm::send(env_ch, MsgEnv(oldcomm::Chan(&po)));\n-        oldcomm::recv(po)\n-    }\n-\n-    fn get_global_env_chan() -> oldcomm::Chan<Msg> {\n-        unsafe {\n-            let global_ptr = rustrt::rust_global_env_chan_ptr();\n-            private::chan_from_global_ptr(global_ptr, || {\n-                // FIXME (#2621): This would be a good place to use a very\n-                // small foreign stack\n-                task::task().sched_mode(task::SingleThreaded).unlinked()\n-            }, global_env_task)\n-        }\n+        unsafe fn rust_env_pairs() -> ~[~str];\n     }\n \n-    fn global_env_task(msg_po: oldcomm::Port<Msg>) {\n-        unsafe {\n-            do private::weaken_task |weak_po| {\n-                loop {\n-                    match oldcomm::select2(msg_po, weak_po) {\n-                      either::Left(MsgGetEnv(ref n, resp_ch)) => {\n-                        oldcomm::send(resp_ch, impl_::getenv(*n))\n-                      }\n-                      either::Left(MsgSetEnv(ref n, ref v, resp_ch)) => {\n-                        oldcomm::send(resp_ch, impl_::setenv(*n, *v))\n-                      }\n-                      either::Left(MsgEnv(resp_ch)) => {\n-                        oldcomm::send(resp_ch, impl_::env())\n-                      }\n-                      either::Right(_) => break\n-                    }\n-                }\n+    unsafe {\n+        do with_env_lock {\n+            let mut pairs = ~[];\n+            for vec::each(rustrt::rust_env_pairs()) |p| {\n+                let vs = str::splitn_char(*p, '=', 1u);\n+                assert vec::len(vs) == 2u;\n+                pairs.push((copy vs[0], copy vs[1]));\n             }\n+            move pairs\n         }\n     }\n+}\n \n-    mod impl_ {\n-        use cast;\n-        use libc;\n-        use option::Option;\n-        use option;\n-        use ptr;\n-        use str;\n-        use vec;\n-\n-        extern mod rustrt {\n-            unsafe fn rust_env_pairs() -> ~[~str];\n-        }\n-\n-        pub fn env() -> ~[(~str,~str)] {\n-            unsafe {\n-                let mut pairs = ~[];\n-                for vec::each(rustrt::rust_env_pairs()) |p| {\n-                    let vs = str::splitn_char(*p, '=', 1u);\n-                    assert vec::len(vs) == 2u;\n-                    pairs.push((copy vs[0], copy vs[1]));\n-                }\n-                move pairs\n-            }\n-        }\n-\n-        #[cfg(unix)]\n-        pub fn getenv(n: &str) -> Option<~str> {\n-            unsafe {\n-                let s = str::as_c_str(n, |s| libc::getenv(s));\n-                return if ptr::null::<u8>() == cast::reinterpret_cast(&s) {\n-                    option::None::<~str>\n-                } else {\n-                    let s = cast::reinterpret_cast(&s);\n-                    option::Some::<~str>(str::raw::from_buf(s))\n-                };\n+#[cfg(unix)]\n+pub fn getenv(n: &str) -> Option<~str> {\n+    unsafe {\n+        do with_env_lock {\n+            let s = str::as_c_str(n, |s| libc::getenv(s));\n+            if ptr::null::<u8>() == cast::reinterpret_cast(&s) {\n+                option::None::<~str>\n+            } else {\n+                let s = cast::reinterpret_cast(&s);\n+                option::Some::<~str>(str::raw::from_buf(s))\n             }\n         }\n+    }\n+}\n \n-        #[cfg(windows)]\n-        pub fn getenv(n: &str) -> Option<~str> {\n-            unsafe {\n-                use os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n-                do as_utf16_p(n) |u| {\n-                    do fill_utf16_buf_and_decode() |buf, sz| {\n-                        libc::GetEnvironmentVariableW(u, buf, sz)\n-                    }\n+#[cfg(windows)]\n+pub fn getenv(n: &str) -> Option<~str> {\n+    unsafe {\n+        do with_env_lock {\n+            use os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n+            do as_utf16_p(n) |u| {\n+                do fill_utf16_buf_and_decode() |buf, sz| {\n+                    libc::GetEnvironmentVariableW(u, buf, sz)\n                 }\n             }\n         }\n+    }\n+}\n \n \n-        #[cfg(unix)]\n-        pub fn setenv(n: &str, v: &str) {\n-            unsafe {\n-                do str::as_c_str(n) |nbuf| {\n-                    do str::as_c_str(v) |vbuf| {\n-                        libc::funcs::posix01::unistd::setenv(nbuf, vbuf, 1);\n-                    }\n+#[cfg(unix)]\n+pub fn setenv(n: &str, v: &str) {\n+    unsafe {\n+        do with_env_lock {\n+            do str::as_c_str(n) |nbuf| {\n+                do str::as_c_str(v) |vbuf| {\n+                    libc::funcs::posix01::unistd::setenv(nbuf, vbuf, 1);\n                 }\n             }\n         }\n+    }\n+}\n \n \n-        #[cfg(windows)]\n-        pub fn setenv(n: &str, v: &str) {\n-            unsafe {\n-                use os::win32::as_utf16_p;\n-                do as_utf16_p(n) |nbuf| {\n-                    do as_utf16_p(v) |vbuf| {\n-                        libc::SetEnvironmentVariableW(nbuf, vbuf);\n-                    }\n+#[cfg(windows)]\n+pub fn setenv(n: &str, v: &str) {\n+    unsafe {\n+        do with_env_lock {\n+            use os::win32::as_utf16_p;\n+            do as_utf16_p(n) |nbuf| {\n+                do as_utf16_p(v) |vbuf| {\n+                    libc::SetEnvironmentVariableW(nbuf, vbuf);\n                 }\n             }\n         }\n-\n     }\n }\n "}, {"sha": "cecc954cdf3bce69e0841e7a455b2001bc19cf61", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -1286,6 +1286,16 @@ pub fn oneshot<T: Owned>() -> (PortOne<T>, ChanOne<T>) {\n     (port, chan)\n }\n \n+impl<T: Owned> PortOne<T> {\n+    fn recv(self) -> T { recv_one(self) }\n+    fn try_recv(self) -> Option<T> { try_recv_one(self) }\n+}\n+\n+impl<T: Owned> ChanOne<T> {\n+    fn send(self, data: T) { send_one(self, data) }\n+    fn try_send(self, data: T) -> bool { try_send_one(self, data) }\n+}\n+\n /**\n  * Receive a message from a oneshot pipe, failing if the connection was\n  * closed."}, {"sha": "332c763f151e85b4bbbadad69c7a4e7b733e3571", "filename": "src/libcore/private.rs", "status": "modified", "additions": 17, "deletions": 257, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -18,7 +18,6 @@\n use cast;\n use iter;\n use libc;\n-use oldcomm;\n use option;\n use pipes;\n use prelude::*;\n@@ -28,10 +27,17 @@ use task;\n use task::{TaskBuilder, atomically};\n use uint;\n \n+#[path = \"private/at_exit.rs\"]\n+pub mod at_exit;\n+#[path = \"private/global.rs\"]\n+pub mod global;\n+#[path = \"private/finally.rs\"]\n+pub mod finally;\n+#[path = \"private/weak_task.rs\"]\n+pub mod weak_task;\n+\n extern mod rustrt {\n     #[legacy_exports];\n-    unsafe fn rust_task_weaken(ch: rust_port_id);\n-    unsafe fn rust_task_unweaken(ch: rust_port_id);\n \n     unsafe fn rust_create_little_lock() -> rust_little_lock;\n     unsafe fn rust_destroy_little_lock(lock: rust_little_lock);\n@@ -87,267 +93,13 @@ fn test_run_in_bare_thread() {\n     }\n }\n \n-#[allow(non_camel_case_types)] // runtime type\n-type rust_port_id = uint;\n-\n-type GlobalPtr = *libc::uintptr_t;\n-\n fn compare_and_swap(address: &mut int, oldval: int, newval: int) -> bool {\n     unsafe {\n         let old = rusti::atomic_cxchg(address, oldval, newval);\n         old == oldval\n     }\n }\n \n-/**\n- * Atomically gets a channel from a pointer to a pointer-sized memory location\n- * or, if no channel exists creates and installs a new channel and sets up a\n- * new task to receive from it.\n- */\n-pub unsafe fn chan_from_global_ptr<T: Owned>(\n-    global: GlobalPtr,\n-    task_fn: fn() -> task::TaskBuilder,\n-    f: fn~(oldcomm::Port<T>)\n-) -> oldcomm::Chan<T> {\n-\n-    enum Msg {\n-        Proceed,\n-        Abort\n-    }\n-\n-    log(debug,~\"ENTERING chan_from_global_ptr, before is_prob_zero check\");\n-    let is_probably_zero = *global == 0u;\n-    log(debug,~\"after is_prob_zero check\");\n-    if is_probably_zero {\n-        log(debug,~\"is probably zero...\");\n-        // There's no global channel. We must make it\n-\n-        let (setup1_po, setup1_ch) = pipes::stream();\n-        let (setup2_po, setup2_ch) = pipes::stream();\n-\n-        // FIXME #4422: Ugly type inference hint\n-        let setup2_po: pipes::Port<Msg> = setup2_po;\n-\n-        do task_fn().spawn |move f, move setup1_ch, move setup2_po| {\n-            let po = oldcomm::Port::<T>();\n-            let ch = oldcomm::Chan(&po);\n-            setup1_ch.send(ch);\n-\n-            // Wait to hear if we are the official instance of\n-            // this global task\n-            match setup2_po.recv() {\n-              Proceed => f(move po),\n-              Abort => ()\n-            }\n-        };\n-\n-        log(debug,~\"before setup recv..\");\n-        // This is the proposed global channel\n-        let ch = setup1_po.recv();\n-        // 0 is our sentinal value. It is not a valid channel\n-        assert *ch != 0;\n-\n-        // Install the channel\n-        log(debug,~\"BEFORE COMPARE AND SWAP\");\n-        let swapped = compare_and_swap(\n-            cast::reinterpret_cast(&global),\n-            0, cast::reinterpret_cast(&ch));\n-        log(debug,fmt!(\"AFTER .. swapped? %?\", swapped));\n-\n-        if swapped {\n-            // Success!\n-            setup2_ch.send(Proceed);\n-            ch\n-        } else {\n-            // Somebody else got in before we did\n-            setup2_ch.send(Abort);\n-            cast::reinterpret_cast(&*global)\n-        }\n-    } else {\n-        log(debug, ~\"global != 0\");\n-        cast::reinterpret_cast(&*global)\n-    }\n-}\n-\n-#[test]\n-pub fn test_from_global_chan1() {\n-\n-    // This is unreadable, right?\n-\n-    // The global channel\n-    let globchan = 0;\n-    let globchanp = ptr::addr_of(&globchan);\n-\n-    // Create the global channel, attached to a new task\n-    let ch = unsafe {\n-        do chan_from_global_ptr(globchanp, task::task) |po| {\n-            let ch = oldcomm::recv(po);\n-            oldcomm::send(ch, true);\n-            let ch = oldcomm::recv(po);\n-            oldcomm::send(ch, true);\n-        }\n-    };\n-    // Talk to it\n-    let po = oldcomm::Port();\n-    oldcomm::send(ch, oldcomm::Chan(&po));\n-    assert oldcomm::recv(po) == true;\n-\n-    // This one just reuses the previous channel\n-    let ch = unsafe {\n-        do chan_from_global_ptr(globchanp, task::task) |po| {\n-            let ch = oldcomm::recv(po);\n-            oldcomm::send(ch, false);\n-        }\n-    };\n-\n-    // Talk to the original global task\n-    let po = oldcomm::Port();\n-    oldcomm::send(ch, oldcomm::Chan(&po));\n-    assert oldcomm::recv(po) == true;\n-}\n-\n-#[test]\n-pub fn test_from_global_chan2() {\n-\n-    for iter::repeat(100) {\n-        // The global channel\n-        let globchan = 0;\n-        let globchanp = ptr::addr_of(&globchan);\n-\n-        let resultpo = oldcomm::Port();\n-        let resultch = oldcomm::Chan(&resultpo);\n-\n-        // Spawn a bunch of tasks that all want to compete to\n-        // create the global channel\n-        for uint::range(0, 10) |i| {\n-            do task::spawn {\n-                let ch = unsafe {\n-                    do chan_from_global_ptr(\n-                        globchanp, task::task) |po| {\n-\n-                        for uint::range(0, 10) |_j| {\n-                            let ch = oldcomm::recv(po);\n-                            oldcomm::send(ch, {i});\n-                        }\n-                    }\n-                };\n-                let po = oldcomm::Port();\n-                oldcomm::send(ch, oldcomm::Chan(&po));\n-                // We are The winner if our version of the\n-                // task was installed\n-                let winner = oldcomm::recv(po);\n-                oldcomm::send(resultch, winner == i);\n-            }\n-        }\n-        // There should be only one winner\n-        let mut winners = 0u;\n-        for uint::range(0u, 10u) |_i| {\n-            let res = oldcomm::recv(resultpo);\n-            if res { winners += 1u };\n-        }\n-        assert winners == 1u;\n-    }\n-}\n-\n-/**\n- * Convert the current task to a 'weak' task temporarily\n- *\n- * As a weak task it will not be counted towards the runtime's set\n- * of live tasks. When there are no more outstanding live (non-weak) tasks\n- * the runtime will send an exit message on the provided channel.\n- *\n- * This function is super-unsafe. Do not use.\n- *\n- * # Safety notes\n- *\n- * * Weak tasks must either die on their own or exit upon receipt of\n- *   the exit message. Failure to do so will cause the runtime to never\n- *   exit\n- * * Tasks must not call `weaken_task` multiple times. This will\n- *   break the kernel's accounting of live tasks.\n- * * Weak tasks must not be supervised. A supervised task keeps\n- *   a reference to its parent, so the parent will not die.\n- */\n-pub unsafe fn weaken_task(f: fn(oldcomm::Port<()>)) {\n-    let po = oldcomm::Port();\n-    let ch = oldcomm::Chan(&po);\n-    unsafe {\n-        rustrt::rust_task_weaken(cast::reinterpret_cast(&ch));\n-    }\n-    let _unweaken = Unweaken(ch);\n-    f(po);\n-\n-    struct Unweaken {\n-      ch: oldcomm::Chan<()>,\n-      drop {\n-        unsafe {\n-            rustrt::rust_task_unweaken(cast::reinterpret_cast(&self.ch));\n-        }\n-      }\n-    }\n-\n-    fn Unweaken(ch: oldcomm::Chan<()>) -> Unweaken {\n-        Unweaken {\n-            ch: ch\n-        }\n-    }\n-}\n-\n-#[test]\n-pub fn test_weaken_task_then_unweaken() {\n-    do task::try {\n-        unsafe {\n-            do weaken_task |_po| {\n-            }\n-        }\n-    };\n-}\n-\n-#[test]\n-pub fn test_weaken_task_wait() {\n-    do task::spawn_unlinked {\n-        unsafe {\n-            do weaken_task |po| {\n-                oldcomm::recv(po);\n-            }\n-        }\n-    }\n-}\n-\n-#[test]\n-pub fn test_weaken_task_stress() {\n-    // Create a bunch of weak tasks\n-    for iter::repeat(100u) {\n-        do task::spawn {\n-            unsafe {\n-                do weaken_task |_po| {\n-                }\n-            }\n-        }\n-        do task::spawn_unlinked {\n-            unsafe {\n-                do weaken_task |po| {\n-                    // Wait for it to tell us to die\n-                    oldcomm::recv(po);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[test]\n-#[ignore(cfg(windows))]\n-pub fn test_weaken_task_fail() {\n-    let res = do task::try {\n-        unsafe {\n-            do weaken_task |_po| {\n-                fail;\n-            }\n-        }\n-    };\n-    assert result::is_err(&res);\n-}\n-\n /****************************************************************************\n  * Shared state & exclusive ARC\n  ****************************************************************************/\n@@ -533,6 +285,14 @@ pub unsafe fn clone_shared_mutable_state<T: Owned>(rc: &SharedMutableState<T>)\n     ArcDestruct((*rc).data)\n }\n \n+impl<T: Owned> SharedMutableState<T>: Clone {\n+    fn clone(&self) -> SharedMutableState<T> {\n+        unsafe {\n+            clone_shared_mutable_state(self)\n+        }\n+    }\n+}\n+\n /****************************************************************************/\n \n #[allow(non_camel_case_types)] // runtime type"}, {"sha": "a87301dbe07bb8235fc6e5dfd36afb0758de7c14", "filename": "src/libcore/private/at_exit.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibcore%2Fprivate%2Fat_exit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibcore%2Fprivate%2Fat_exit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Fat_exit.rs?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use sys;\n+use cast;\n+use ptr;\n+use task;\n+use uint;\n+use vec;\n+use rand;\n+use libc::{c_void, size_t};\n+\n+/**\n+Register a function to be run during runtime shutdown.\n+\n+After all non-weak tasks have exited, registered exit functions will\n+execute, in random order, on the primary scheduler. Each function runs\n+in its own unsupervised task.\n+*/\n+pub fn at_exit(f: ~fn()) {\n+    unsafe {\n+        let runner: &fn(*ExitFunctions) = exit_runner;\n+        let runner_pair: sys::Closure = cast::transmute(runner);\n+        let runner_ptr = runner_pair.code;\n+        let runner_ptr = cast::transmute(runner_ptr);\n+        rustrt::rust_register_exit_function(runner_ptr, ~f);\n+    }\n+}\n+\n+// NB: The double pointer indirection here is because ~fn() is a fat\n+// pointer and due to FFI problems I am more comfortable making the\n+// interface use a normal pointer\n+extern mod rustrt {\n+    fn rust_register_exit_function(runner: *c_void, f: ~~fn());\n+}\n+\n+struct ExitFunctions {\n+    // The number of exit functions\n+    count: size_t,\n+    // The buffer of exit functions\n+    start: *~~fn()\n+}\n+\n+fn exit_runner(exit_fns: *ExitFunctions) {\n+    let exit_fns = unsafe { &*exit_fns };\n+    let count = (*exit_fns).count;\n+    let start = (*exit_fns).start;\n+\n+    // NB: from_buf memcpys from the source, which will\n+    // give us ownership of the array of functions\n+    let mut exit_fns_vec = unsafe { vec::from_buf(start, count as uint) };\n+    // Let's not make any promises about execution order\n+    rand::Rng().shuffle_mut(exit_fns_vec);\n+\n+    debug!(\"running %u exit functions\", exit_fns_vec.len());\n+\n+    while !exit_fns_vec.is_empty() {\n+        match exit_fns_vec.pop() {\n+            ~f => {\n+                task::task().supervised().spawn(f);\n+            }\n+        }\n+    }\n+}\n+\n+#[abi = \"rust-intrinsic\"]\n+pub extern mod rusti {\n+    fn move_val_init<T>(dst: &mut T, -src: T);\n+    fn init<T>() -> T;\n+}\n+\n+#[test]\n+fn test_at_exit() {\n+    let i = 10;\n+    do at_exit {\n+        debug!(\"at_exit1\");\n+        assert i == 10;\n+    }\n+}\n+\n+#[test]\n+fn test_at_exit_many() {\n+    let i = 10;\n+    for uint::range(20, 100) |j| {\n+        do at_exit {\n+            debug!(\"at_exit2\");\n+            assert i == 10;\n+            assert j > i;\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "66e23ff4336021a12db5c3341c1fcb7448abaa15", "filename": "src/libcore/private/finally.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibcore%2Fprivate%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibcore%2Fprivate%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Ffinally.rs?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+The Finally trait provides a method, `finally` on\n+stack closures that emulates Java-style try/finally blocks.\n+\n+# Example\n+\n+~~~\n+do || {\n+    ...\n+}.finally {\n+    alway_run_this();\n+}\n+~~~\n+*/\n+\n+use ops::Drop;\n+use task::{spawn, failing};\n+\n+pub trait Finally<T> {\n+    fn finally(&self, +dtor: &fn()) -> T;\n+}\n+\n+impl<T> &fn() -> T: Finally<T> {\n+    // XXX: Should not require a mode here\n+    fn finally(&self, +dtor: &fn()) -> T {\n+        let _d = Finallyalizer {\n+            dtor: dtor\n+        };\n+\n+        (*self)()\n+    }\n+}\n+\n+struct Finallyalizer {\n+    dtor: &fn()\n+}\n+\n+impl Finallyalizer: Drop {\n+    fn finalize(&self) {\n+        (self.dtor)();\n+    }\n+}\n+\n+#[test]\n+fn test_success() {\n+    let mut i = 0;\n+    do (|| {\n+        i = 10;\n+    }).finally {\n+        assert !failing();\n+        assert i == 10;\n+        i = 20;\n+    }\n+    assert i == 20;\n+}\n+\n+#[test]\n+#[ignore(cfg(windows))]\n+#[should_fail]\n+fn test_fail() {\n+    let mut i = 0;\n+    do (|| {\n+        i = 10;\n+        fail;\n+    }).finally {\n+        assert failing();\n+        assert i == 10;\n+    }\n+}\n+\n+#[test]\n+fn test_retval() {\n+    let i = do (fn&() -> int {\n+        10\n+    }).finally { };\n+    assert i == 10;\n+}\n+\n+#[test]\n+fn test_compact() {\n+    // XXX Should be able to use a fn item instead\n+    // of a closure for do_some_fallible_work,\n+    // but it's a type error.\n+    let do_some_fallible_work: &fn() = || { };\n+    fn but_always_run_this_function() { }\n+    do_some_fallible_work.finally(\n+        but_always_run_this_function);\n+}\n\\ No newline at end of file"}, {"sha": "69319abc0093071e48eefaabc3c28ce74c58aa3b", "filename": "src/libcore/private/global.rs", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibcore%2Fprivate%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibcore%2Fprivate%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Fglobal.rs?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -0,0 +1,296 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+Global data\n+\n+An interface for creating and retrieving values with global\n+(per-runtime) scope.\n+\n+Global values are stored in a map and protected by a single global\n+mutex. Operations are provided for accessing and cloning the value\n+under the mutex.\n+\n+Because all globals go through a single mutex, they should be used\n+sparingly.  The interface is intended to be used with clonable,\n+atomically reference counted synchronization types, like ARCs, in\n+which case the value should be cached locally whenever possible to\n+avoid hitting the mutex.\n+*/\n+\n+use cast::{transmute, reinterpret_cast};\n+use clone::Clone;\n+use kinds::Owned;\n+use libc::{c_void, uintptr_t};\n+use option::{Option, Some, None};\n+use ops::Drop;\n+use pipes;\n+use private::{Exclusive, exclusive};\n+use private::{SharedMutableState, shared_mutable_state};\n+use private::{get_shared_immutable_state};\n+use private::at_exit::at_exit;\n+use hashmap::linear::LinearMap;\n+use sys::Closure;\n+use task::spawn;\n+use uint;\n+\n+pub type GlobalDataKey<T: Owned> = &fn(v: T);\n+\n+pub unsafe fn global_data_clone_create<T: Owned Clone>(\n+    key: GlobalDataKey<T>, create: &fn() -> ~T) -> T {\n+    /*!\n+     * Clone a global value or, if it has not been created,\n+     * first construct the value then return a clone.\n+     *\n+     * # Safety note\n+     *\n+     * Both the clone operation and the constructor are\n+     * called while the global lock is held. Recursive\n+     * use of the global interface in either of these\n+     * operations will result in deadlock.\n+     */\n+    global_data_clone_create_(key_ptr(key), create)\n+}\n+\n+unsafe fn global_data_clone_create_<T: Owned Clone>(\n+    key: uint, create: &fn() -> ~T) -> T {\n+\n+    let mut clone_value: Option<T> = None;\n+    do global_data_modify_(key) |value: Option<~T>| {\n+        match value {\n+            None => {\n+                let value = create();\n+                clone_value = Some(value.clone());\n+                Some(value)\n+            }\n+            Some(value) => {\n+                clone_value = Some(value.clone());\n+                Some(value)\n+            }\n+        }\n+    }\n+    return clone_value.unwrap();\n+}\n+\n+unsafe fn global_data_modify<T: Owned>(\n+    key: GlobalDataKey<T>, op: &fn(Option<~T>) -> Option<~T>) {\n+\n+    global_data_modify_(key_ptr(key), op)\n+}\n+\n+unsafe fn global_data_modify_<T: Owned>(\n+    key: uint, op: &fn(Option<~T>) -> Option<~T>) {\n+\n+    let mut old_dtor = None;\n+    do get_global_state().with |gs| {\n+        let (maybe_new_value, maybe_dtor) = match gs.map.pop(&key) {\n+            Some((ptr, dtor)) => {\n+                let value: ~T = transmute(ptr);\n+                (op(Some(value)), Some(dtor))\n+            }\n+            None => {\n+                (op(None), None)\n+            }\n+        };\n+        match maybe_new_value {\n+            Some(value) => {\n+                let data: *c_void = transmute(value);\n+                let dtor: ~fn() = match maybe_dtor {\n+                    Some(dtor) => dtor,\n+                    None => {\n+                        let dtor: ~fn() = || unsafe {\n+                            let _destroy_value: ~T = transmute(data);\n+                        };\n+                        dtor\n+                    }\n+                };\n+                let value = (data, dtor);\n+                gs.map.insert(key, value);\n+            }\n+            None => {\n+                match maybe_dtor {\n+                    Some(dtor) => old_dtor = Some(dtor),\n+                    None => ()\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub unsafe fn global_data_clone<T: Owned Clone>(\n+    key: GlobalDataKey<T>) -> Option<T> {\n+    let mut maybe_clone: Option<T> = None;\n+    do global_data_modify(key) |current| {\n+        match &current {\n+            &Some(~ref value) => {\n+                maybe_clone = Some(value.clone());\n+            }\n+            &None => ()\n+        }\n+        current\n+    }\n+    return maybe_clone;\n+}\n+\n+// GlobalState is a map from keys to unique pointers and a\n+// destructor. Keys are pointers derived from the type of the\n+// global value.  There is a single GlobalState instance per runtime.\n+struct GlobalState {\n+    map: LinearMap<uint, (*c_void, ~fn())>\n+}\n+\n+impl GlobalState: Drop {\n+    fn finalize(&self) {\n+        for self.map.each_value |v| {\n+            match v {\n+                &(_, ref dtor) => (*dtor)()\n+            }\n+        }\n+    }\n+}\n+\n+fn get_global_state() -> Exclusive<GlobalState> {\n+\n+    const POISON: int = -1;\n+\n+    // XXX: Doing atomic_cxchg to initialize the global state\n+    // lazily, which wouldn't be necessary with a runtime written\n+    // in Rust\n+    let global_ptr = unsafe { rust_get_global_data_ptr() };\n+\n+    if unsafe { *global_ptr } == 0 {\n+        // Global state doesn't exist yet, probably\n+\n+        // The global state object\n+        let state = GlobalState {\n+            map: LinearMap::new()\n+        };\n+\n+        // It's under a reference-counted mutex\n+        let state = ~exclusive(state);\n+\n+        // Convert it to an integer\n+        let state_ptr: &Exclusive<GlobalState> = state;\n+        let state_i: int = unsafe { transmute(state_ptr) };\n+\n+        // Swap our structure into the global pointer\n+        let prev_i = unsafe { atomic_cxchg(&mut *global_ptr, 0, state_i) };\n+\n+        // Sanity check that we're not trying to reinitialize after shutdown\n+        assert prev_i != POISON;\n+\n+        if prev_i == 0 {\n+            // Successfully installed the global pointer\n+\n+            // Take a handle to return\n+            let clone = state.clone();\n+\n+            // Install a runtime exit function to destroy the global object\n+            do at_exit {\n+                // Poison the global pointer\n+                let prev_i = unsafe {\n+                    atomic_cxchg(&mut *global_ptr, state_i, POISON)\n+                };\n+                assert prev_i == state_i;\n+\n+                // Capture the global state object in the at_exit closure\n+                // so that it is destroyed at the right time\n+                let _capture_global_state = &state;\n+            };\n+            return clone;\n+        } else {\n+            // Somebody else initialized the globals first\n+            let state: &Exclusive<GlobalState> = unsafe { transmute(prev_i) };\n+            return state.clone();\n+        }\n+    } else {\n+        let state: &Exclusive<GlobalState> = unsafe {\n+            transmute(*global_ptr)\n+        };\n+        return state.clone();\n+    }\n+}\n+\n+fn key_ptr<T: Owned>(key: GlobalDataKey<T>) -> uint {\n+    unsafe {\n+        let closure: Closure = reinterpret_cast(&key);\n+        return transmute(closure.code);\n+    }\n+}\n+\n+extern {\n+    fn rust_get_global_data_ptr() -> *mut int;\n+}\n+\n+#[abi = \"rust-intrinsic\"]\n+extern {\n+    fn atomic_cxchg(dst: &mut int, old: int, src: int) -> int;\n+}\n+\n+#[test]\n+fn test_clone_rc() {\n+    type MyType = SharedMutableState<int>;\n+\n+    fn key(_v: SharedMutableState<int>) { }\n+\n+    for uint::range(0, 100) |_| {\n+        do spawn {\n+            unsafe {\n+                let val = do global_data_clone_create(key) {\n+                    ~shared_mutable_state(10)\n+                };\n+\n+                assert get_shared_immutable_state(&val) == &10;\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_modify() {\n+    type MyType = SharedMutableState<int>;\n+\n+    fn key(_v: SharedMutableState<int>) { }\n+\n+    unsafe {\n+        do global_data_modify(key) |v| {\n+            match v {\n+                None => {\n+                    unsafe {\n+                        Some(~shared_mutable_state(10))\n+                    }\n+                }\n+                _ => fail\n+            }\n+        }\n+\n+        do global_data_modify(key) |v| {\n+            match v {\n+                Some(sms) => {\n+                    let v = get_shared_immutable_state(sms);\n+                    assert *v == 10;\n+                    None\n+                },\n+                _ => fail\n+            }\n+        }\n+\n+        do global_data_modify(key) |v| {\n+            match v {\n+                None => {\n+                    unsafe {\n+                        Some(~shared_mutable_state(10))\n+                    }\n+                }\n+                _ => fail\n+            }\n+        }\n+    }\n+}"}, {"sha": "25a03ff960f46209bbe2729e05d3c1dcd9fda255", "filename": "src/libcore/private/weak_task.rs", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibcore%2Fprivate%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibcore%2Fprivate%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Fweak_task.rs?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -0,0 +1,207 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+Weak tasks\n+\n+Weak tasks are a runtime feature for building global services that\n+do not keep the runtime alive. Normally the runtime exits when all\n+tasks exits, but if a task is weak then the runtime may exit while\n+it is running, sending a notification to the task that the runtime\n+is trying to shut down.\n+*/\n+\n+use option::{Some, None, swap_unwrap};\n+use private::at_exit::at_exit;\n+use private::global::global_data_clone_create;\n+use private::finally::Finally;\n+use pipes::{Port, Chan, SharedChan, stream};\n+use task::{Task, task, spawn};\n+use task::rt::{task_id, get_task_id};\n+use hashmap::linear::LinearMap;\n+use ops::Drop;\n+\n+type ShutdownMsg = ();\n+\n+// XXX: This could be a PortOne but I've experienced bugginess\n+// with oneshot pipes and try_send\n+pub unsafe fn weaken_task(f: &fn(Port<ShutdownMsg>)) {\n+    let service = global_data_clone_create(global_data_key,\n+                                           create_global_service);\n+    let (shutdown_port, shutdown_chan) = stream::<ShutdownMsg>();\n+    let shutdown_port = ~mut Some(shutdown_port);\n+    let task = get_task_id();\n+    // Expect the weak task service to be alive\n+    assert service.try_send(RegisterWeakTask(task, shutdown_chan));\n+    unsafe { rust_inc_weak_task_count(); }\n+    do fn&() {\n+        let shutdown_port = swap_unwrap(&mut *shutdown_port);\n+        f(shutdown_port)\n+    }.finally || {\n+        unsafe { rust_dec_weak_task_count(); }\n+        // Service my have already exited\n+        service.send(UnregisterWeakTask(task));\n+    }\n+}\n+\n+type WeakTaskService = SharedChan<ServiceMsg>;\n+type TaskHandle = task_id;\n+\n+fn global_data_key(_v: WeakTaskService) { }\n+\n+enum ServiceMsg {\n+    RegisterWeakTask(TaskHandle, Chan<ShutdownMsg>),\n+    UnregisterWeakTask(TaskHandle),\n+    Shutdown\n+}\n+\n+fn create_global_service() -> ~WeakTaskService {\n+\n+    debug!(\"creating global weak task service\");\n+    let (port, chan) = stream::<ServiceMsg>();\n+    let port = ~mut Some(port);\n+    let chan = SharedChan(chan);\n+    let chan_clone = chan.clone();\n+\n+    do task().unlinked().spawn {\n+        debug!(\"running global weak task service\");\n+        let port = swap_unwrap(&mut *port);\n+        let port = ~mut Some(port);\n+        do fn&() {\n+            let port = swap_unwrap(&mut *port);\n+            // The weak task service is itself a weak task\n+            debug!(\"weakening the weak service task\");\n+            unsafe { rust_inc_weak_task_count(); }\n+            run_weak_task_service(port);\n+        }.finally {\n+            debug!(\"unweakening the weak service task\");\n+            unsafe { rust_dec_weak_task_count(); }\n+        }\n+    }\n+\n+    do at_exit {\n+        debug!(\"shutting down weak task service\");\n+        chan.send(Shutdown);\n+    }\n+\n+    return ~chan_clone;\n+}\n+\n+fn run_weak_task_service(port: Port<ServiceMsg>) {\n+\n+    let mut shutdown_map = LinearMap::new();\n+\n+    loop {\n+        match port.recv() {\n+            RegisterWeakTask(task, shutdown_chan) => {\n+                let previously_unregistered =\n+                    shutdown_map.insert(task, shutdown_chan);\n+                assert previously_unregistered;\n+            }\n+            UnregisterWeakTask(task) => {\n+                match shutdown_map.pop(&task) {\n+                    Some(shutdown_chan) => {\n+                        // Oneshot pipes must send, even though\n+                        // nobody will receive this\n+                        shutdown_chan.send(());\n+                    }\n+                    None => fail\n+                }\n+            }\n+            Shutdown => break\n+        }\n+    }\n+\n+    do shutdown_map.consume |_, shutdown_chan| {\n+        // Weak task may have already exited\n+        shutdown_chan.send(());\n+    }\n+}\n+\n+extern {\n+    unsafe fn rust_inc_weak_task_count();\n+    unsafe fn rust_dec_weak_task_count();\n+}\n+\n+#[test]\n+fn test_simple() {\n+    let (port, chan) = stream();\n+    do spawn {\n+        unsafe {\n+            do weaken_task |_signal| {\n+            }\n+        }\n+        chan.send(());\n+    }\n+    port.recv();\n+}\n+\n+#[test]\n+fn test_weak_weak() {\n+    let (port, chan) = stream();\n+    do spawn {\n+        unsafe {\n+            do weaken_task |_signal| {\n+            }\n+            do weaken_task |_signal| {\n+            }\n+        }\n+        chan.send(());\n+    }\n+    port.recv();\n+}\n+\n+#[test]\n+fn test_wait_for_signal() {\n+    do spawn {\n+        unsafe {\n+            do weaken_task |signal| {\n+                signal.recv();\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_wait_for_signal_many() {\n+    use uint;\n+    for uint::range(0, 100) |_| {\n+        do spawn {\n+            unsafe {\n+                do weaken_task |signal| {\n+                    signal.recv();\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_select_stream_and_oneshot() {\n+    use pipes::select2i;\n+    use either::{Left, Right};\n+\n+    let (port, chan) = stream();\n+    let (waitport, waitchan) = stream();\n+    do spawn {\n+        unsafe {\n+            do weaken_task |signal| {\n+                match select2i(&port, &signal) {\n+                    Left(*) => (),\n+                    Right(*) => fail\n+                }\n+            }\n+        }\n+        waitchan.send(());\n+    }\n+    chan.send(());\n+    waitport.recv();\n+}\n+"}, {"sha": "eeae7f5b291a06d6235eb7f07c2c427af3a5b39f", "filename": "src/libcore/run.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -17,7 +17,7 @@ use io;\n use io::ReaderUtil;\n use libc;\n use libc::{pid_t, c_void, c_int};\n-use oldcomm;\n+use pipes::{stream, SharedChan};\n use option::{Some, None};\n use os;\n use prelude::*;\n@@ -336,22 +336,23 @@ pub fn program_output(prog: &str, args: &[~str]) ->\n         // in parallel so we don't deadlock while blocking on one\n         // or the other. FIXME (#2625): Surely there's a much more\n         // clever way to do this.\n-        let p = oldcomm::Port();\n-        let ch = oldcomm::Chan(&p);\n+        let (p, ch) = stream();\n+        let ch = SharedChan(ch);\n+        let ch_clone = ch.clone();\n         do task::spawn_sched(task::SingleThreaded) {\n             let errput = readclose(pipe_err.in);\n-            oldcomm::send(ch, (2, move errput));\n+            ch.send((2, move errput));\n         };\n         do task::spawn_sched(task::SingleThreaded) {\n             let output = readclose(pipe_out.in);\n-            oldcomm::send(ch, (1, move output));\n+            ch_clone.send((1, move output));\n         };\n         let status = run::waitpid(pid);\n         let mut errs = ~\"\";\n         let mut outs = ~\"\";\n         let mut count = 2;\n         while count > 0 {\n-            let stream = oldcomm::recv(p);\n+            let stream = p.recv();\n             match stream {\n                 (1, copy s) => {\n                     outs = move s;"}, {"sha": "aa82309c78aecf2fd854d8a2be7af5c4ec2cf297", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 108, "deletions": 150, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -43,16 +43,15 @@ use cmp;\n use cmp::Eq;\n use iter;\n use libc;\n-use oldcomm;\n use option;\n use result::Result;\n-use pipes::{stream, Chan, Port};\n+use pipes::{stream, Chan, Port, SharedChan};\n use pipes;\n use prelude::*;\n use ptr;\n use result;\n use task::local_data_priv::{local_get, local_set};\n-use task::rt::{task_id, rust_task};\n+use task::rt::{task_id, sched_id, rust_task};\n use task;\n use util;\n use util::replace;\n@@ -62,6 +61,12 @@ pub mod local_data;\n pub mod rt;\n pub mod spawn;\n \n+/// A handle to a scheduler\n+#[deriving_eq]\n+pub enum Scheduler {\n+    SchedulerHandle(sched_id)\n+}\n+\n /// A handle to a task\n #[deriving_eq]\n pub enum Task {\n@@ -95,7 +100,21 @@ impl TaskResult : Eq {\n }\n \n /// Scheduler modes\n+#[deriving_eq]\n pub enum SchedMode {\n+    /// Run task on the default scheduler\n+    DefaultScheduler,\n+    /// Run task on the current scheduler\n+    CurrentScheduler,\n+    /// Run task on a specific scheduler\n+    ExistingScheduler(Scheduler),\n+    /**\n+     * Tasks are scheduled on the main OS thread\n+     *\n+     * The main OS thread is the thread used to launch the runtime which,\n+     * in most cases, is the process's initial thread as created by the OS.\n+     */\n+    PlatformThread,\n     /// All tasks run in the same OS thread\n     SingleThreaded,\n     /// Tasks are distributed among available CPUs\n@@ -104,53 +123,6 @@ pub enum SchedMode {\n     ThreadPerTask,\n     /// Tasks are distributed among a fixed number of OS threads\n     ManualThreads(uint),\n-    /**\n-     * Tasks are scheduled on the main OS thread\n-     *\n-     * The main OS thread is the thread used to launch the runtime which,\n-     * in most cases, is the process's initial thread as created by the OS.\n-     */\n-    PlatformThread\n-}\n-\n-impl SchedMode : cmp::Eq {\n-    pure fn eq(&self, other: &SchedMode) -> bool {\n-        match (*self) {\n-            SingleThreaded => {\n-                match (*other) {\n-                    SingleThreaded => true,\n-                    _ => false\n-                }\n-            }\n-            ThreadPerCore => {\n-                match (*other) {\n-                    ThreadPerCore => true,\n-                    _ => false\n-                }\n-            }\n-            ThreadPerTask => {\n-                match (*other) {\n-                    ThreadPerTask => true,\n-                    _ => false\n-                }\n-            }\n-            ManualThreads(e0a) => {\n-                match (*other) {\n-                    ManualThreads(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            PlatformThread => {\n-                match (*other) {\n-                    PlatformThread => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &SchedMode) -> bool {\n-        !(*self).eq(other)\n-    }\n }\n \n /**\n@@ -204,7 +176,7 @@ pub struct TaskOpts {\n     linked: bool,\n     supervised: bool,\n     mut notify_chan: Option<Chan<TaskResult>>,\n-    sched: Option<SchedOpts>,\n+    sched: SchedOpts\n }\n \n /**\n@@ -369,11 +341,8 @@ impl TaskBuilder {\n             opts: TaskOpts {\n                 linked: self.opts.linked,\n                 supervised: self.opts.supervised,\n-                notify_chan: notify_chan,\n-                sched: Some(SchedOpts {\n-                    mode: mode,\n-                    foreign_stack_size: None,\n-                })\n+                notify_chan: move notify_chan,\n+                sched: SchedOpts { mode: mode, foreign_stack_size: None}\n             },\n             can_not_copy: None,\n             .. self.consume()\n@@ -457,18 +426,17 @@ impl TaskBuilder {\n      * Fails if a future_result was already set for this task.\n      */\n     fn try<T: Owned>(f: fn~() -> T) -> Result<T,()> {\n-        let po = oldcomm::Port();\n-        let ch = oldcomm::Chan(&po);\n+        let (po, ch) = stream::<T>();\n         let mut result = None;\n \n         let fr_task_builder = self.future_result(|+r| {\n             result = Some(move r);\n         });\n-        do fr_task_builder.spawn |move f| {\n-            oldcomm::send(ch, f());\n+        do fr_task_builder.spawn |move f, move ch| {\n+            ch.send(f());\n         }\n         match option::unwrap(move result).recv() {\n-            Success => result::Ok(oldcomm::recv(po)),\n+            Success => result::Ok(po.recv()),\n             Failure => result::Err(())\n         }\n     }\n@@ -489,7 +457,10 @@ pub fn default_task_opts() -> TaskOpts {\n         linked: true,\n         supervised: false,\n         notify_chan: None,\n-        sched: None\n+        sched: SchedOpts {\n+            mode: DefaultScheduler,\n+            foreign_stack_size: None\n+        }\n     }\n }\n \n@@ -542,10 +513,9 @@ pub fn spawn_with<A:Owned>(arg: A, f: fn~(v: A)) {\n \n pub fn spawn_sched(mode: SchedMode, f: fn~()) {\n     /*!\n-     * Creates a new scheduler and executes a task on it\n-     *\n-     * Tasks subsequently spawned by that task will also execute on\n-     * the new scheduler. When there are no more tasks to execute the\n+     * Creates a new task on a new or existing scheduler\n+\n+     * When there are no more tasks to execute the\n      * scheduler terminates.\n      *\n      * # Failure\n@@ -599,6 +569,10 @@ pub fn get_task() -> Task {\n     }\n }\n \n+pub fn get_scheduler() -> Scheduler {\n+    SchedulerHandle(unsafe { rt::rust_get_sched_id() })\n+}\n+\n /**\n  * Temporarily make the task unkillable\n  *\n@@ -711,17 +685,18 @@ fn test_cant_dup_task_builder() {\n \n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n-    let po = oldcomm::Port();\n-    let ch = oldcomm::Chan(&po);\n+    let (po, ch) = stream();\n+    let ch = SharedChan(ch);\n     do spawn_unlinked {\n+        let ch = ch.clone();\n         do spawn_unlinked {\n             // Give middle task a chance to fail-but-not-kill-us.\n             for iter::repeat(16) { task::yield(); }\n-            oldcomm::send(ch, ()); // If killed first, grandparent hangs.\n+            ch.send(()); // If killed first, grandparent hangs.\n         }\n         fail; // Shouldn't kill either (grand)parent or (grand)child.\n     }\n-    oldcomm::recv(po);\n+    po.recv();\n }\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_unsup_no_fail_up() { // child unlinked fails\n@@ -741,8 +716,7 @@ fn test_spawn_unlinked_sup_fail_down() {\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n-    let po = oldcomm::Port::<()>();\n-    let _ch = oldcomm::Chan(&po);\n+    let (po, _ch) = stream::<()>();\n     // Unidirectional \"parenting\" shouldn't override bidirectional linked.\n     // We have to cheat with opts - the interface doesn't support them because\n     // they don't make sense (redundant with task().supervised()).\n@@ -760,7 +734,7 @@ fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n         .. b0\n     };\n     do b1.spawn { fail; }\n-    oldcomm::recv(po); // We should get punted awake\n+    po.recv(); // We should get punted awake\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n@@ -784,11 +758,10 @@ fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_fail_up() { // child fails; parent fails\n-    let po = oldcomm::Port::<()>();\n-    let _ch = oldcomm::Chan(&po);\n+    let (po, _ch) = stream::<()>();\n     // Default options are to spawn linked & unsupervised.\n     do spawn { fail; }\n-    oldcomm::recv(po); // We should get punted awake\n+    po.recv(); // We should get punted awake\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n@@ -856,27 +829,25 @@ fn test_spawn_linked_sup_propagate_sibling() {\n \n #[test]\n fn test_run_basic() {\n-    let po = oldcomm::Port();\n-    let ch = oldcomm::Chan(&po);\n+    let (po, ch) = stream::<()>();\n     do task().spawn {\n-        oldcomm::send(ch, ());\n+        ch.send(());\n     }\n-    oldcomm::recv(po);\n+    po.recv();\n }\n \n #[test]\n fn test_add_wrapper() {\n-    let po = oldcomm::Port();\n-    let ch = oldcomm::Chan(&po);\n+    let (po, ch) = stream::<()>();\n     let b0 = task();\n     let b1 = do b0.add_wrapper |body| {\n         fn~(move body) {\n             body();\n-            oldcomm::send(ch, ());\n+            ch.send(());\n         }\n     };\n     do b1.spawn { }\n-    oldcomm::recv(po);\n+    po.recv();\n }\n \n #[test]\n@@ -929,52 +900,46 @@ fn test_spawn_sched_no_threads() {\n \n #[test]\n fn test_spawn_sched() {\n-    let po = oldcomm::Port();\n-    let ch = oldcomm::Chan(&po);\n+    let (po, ch) = stream::<()>();\n+    let ch = SharedChan(ch);\n \n-    fn f(i: int, ch: oldcomm::Chan<()>) {\n-        unsafe {\n-            let parent_sched_id = rt::rust_get_sched_id();\n+    fn f(i: int, ch: SharedChan<()>) {\n+        let parent_sched_id = unsafe { rt::rust_get_sched_id() };\n \n-            do spawn_sched(SingleThreaded) {\n-                unsafe {\n-                    let child_sched_id = rt::rust_get_sched_id();\n-                    assert parent_sched_id != child_sched_id;\n-\n-                    if (i == 0) {\n-                        oldcomm::send(ch, ());\n-                    } else {\n-                        f(i - 1, ch);\n-                    }\n-                }\n-            };\n-        }\n+        do spawn_sched(SingleThreaded) {\n+            let child_sched_id = unsafe { rt::rust_get_sched_id() };\n+            assert parent_sched_id != child_sched_id;\n+\n+            if (i == 0) {\n+                ch.send(());\n+            } else {\n+                f(i - 1, ch.clone());\n+            }\n+        };\n \n     }\n     f(10, ch);\n-    oldcomm::recv(po);\n+    po.recv();\n }\n \n #[test]\n-fn test_spawn_sched_childs_on_same_sched() {\n-    let po = oldcomm::Port();\n-    let ch = oldcomm::Chan(&po);\n+fn test_spawn_sched_childs_on_default_sched() {\n+    let (po, ch) = stream();\n+\n+    // Assuming tests run on the default scheduler\n+    let default_id = unsafe { rt::rust_get_sched_id() };\n \n     do spawn_sched(SingleThreaded) {\n-        unsafe {\n-            let parent_sched_id = rt::rust_get_sched_id();\n-            do spawn {\n-                unsafe {\n-                    let child_sched_id = rt::rust_get_sched_id();\n-                    // This should be on the same scheduler\n-                    assert parent_sched_id == child_sched_id;\n-                    oldcomm::send(ch, ());\n-                }\n-            };\n-        }\n+        let parent_sched_id = unsafe { rt::rust_get_sched_id() };\n+        do spawn {\n+            let child_sched_id = unsafe { rt::rust_get_sched_id() };\n+            assert parent_sched_id != child_sched_id;\n+            assert child_sched_id == default_id;\n+            ch.send(());\n+        };\n     };\n \n-    oldcomm::recv(po);\n+    po.recv();\n }\n \n #[nolink]\n@@ -996,74 +961,69 @@ fn test_spawn_sched_blocking() {\n         // without affecting other schedulers\n         for iter::repeat(20u) {\n \n-            let start_po = oldcomm::Port();\n-            let start_ch = oldcomm::Chan(&start_po);\n-            let fin_po = oldcomm::Port();\n-            let fin_ch = oldcomm::Chan(&fin_po);\n+            let (start_po, start_ch) = stream();\n+            let (fin_po, fin_ch) = stream();\n \n             let lock = testrt::rust_dbg_lock_create();\n \n             do spawn_sched(SingleThreaded) {\n                 unsafe {\n                     testrt::rust_dbg_lock_lock(lock);\n \n-                    oldcomm::send(start_ch, ());\n+                    start_ch.send(());\n \n                     // Block the scheduler thread\n                     testrt::rust_dbg_lock_wait(lock);\n                     testrt::rust_dbg_lock_unlock(lock);\n \n-                    oldcomm::send(fin_ch, ());\n+                    fin_ch.send(());\n                 }\n             };\n \n             // Wait until the other task has its lock\n-            oldcomm::recv(start_po);\n+            start_po.recv();\n \n-            fn pingpong(po: oldcomm::Port<int>, ch: oldcomm::Chan<int>) {\n+            fn pingpong(po: &Port<int>, ch: &Chan<int>) {\n                 let mut val = 20;\n                 while val > 0 {\n-                    val = oldcomm::recv(po);\n-                    oldcomm::send(ch, val - 1);\n+                    val = po.recv();\n+                    ch.send(val - 1);\n                 }\n             }\n \n-            let setup_po = oldcomm::Port();\n-            let setup_ch = oldcomm::Chan(&setup_po);\n-            let parent_po = oldcomm::Port();\n-            let parent_ch = oldcomm::Chan(&parent_po);\n+            let (setup_po, setup_ch) = stream();\n+            let (parent_po, parent_ch) = stream();\n             do spawn {\n-                let child_po = oldcomm::Port();\n-                oldcomm::send(setup_ch, oldcomm::Chan(&child_po));\n-                pingpong(child_po, parent_ch);\n+                let (child_po, child_ch) = stream();\n+                setup_ch.send(child_ch);\n+                pingpong(&child_po, &parent_ch);\n             };\n \n-            let child_ch = oldcomm::recv(setup_po);\n-            oldcomm::send(child_ch, 20);\n-            pingpong(parent_po, child_ch);\n+            let child_ch = setup_po.recv();\n+            child_ch.send(20);\n+            pingpong(&parent_po, &child_ch);\n             testrt::rust_dbg_lock_lock(lock);\n             testrt::rust_dbg_lock_signal(lock);\n             testrt::rust_dbg_lock_unlock(lock);\n-            oldcomm::recv(fin_po);\n+            fin_po.recv();\n             testrt::rust_dbg_lock_destroy(lock);\n         }\n     }\n }\n \n #[cfg(test)]\n fn avoid_copying_the_body(spawnfn: fn(v: fn~())) {\n-    let p = oldcomm::Port::<uint>();\n-    let ch = oldcomm::Chan(&p);\n+    let (p, ch) = stream::<uint>();\n \n     let x = ~1;\n     let x_in_parent = ptr::addr_of(&(*x)) as uint;\n \n     do spawnfn |move x| {\n         let x_in_child = ptr::addr_of(&(*x)) as uint;\n-        oldcomm::send(ch, x_in_child);\n+        ch.send(x_in_child);\n     }\n \n-    let x_in_child = oldcomm::recv(p);\n+    let x_in_child = p.recv();\n     assert x_in_parent == x_in_child;\n }\n \n@@ -1101,20 +1061,18 @@ fn test_avoid_copying_the_body_unlinked() {\n \n #[test]\n fn test_platform_thread() {\n-    let po = oldcomm::Port();\n-    let ch = oldcomm::Chan(&po);\n+    let (po, ch) = stream();\n     do task().sched_mode(PlatformThread).spawn {\n-        oldcomm::send(ch, ());\n+        ch.send(());\n     }\n-    oldcomm::recv(po);\n+    po.recv();\n }\n \n #[test]\n #[ignore(cfg(windows))]\n #[should_fail]\n fn test_unkillable() {\n-    let po = oldcomm::Port();\n-    let ch = po.chan();\n+    let (po, ch) = stream();\n \n     // We want to do this after failing\n     do spawn_unlinked {\n@@ -1242,7 +1200,7 @@ fn test_spawn_thread_on_demand() {\n \n             let (port2, chan2) = pipes::stream();\n \n-            do spawn() |move chan2| {\n+            do spawn_sched(CurrentScheduler) |move chan2| {\n                 chan2.send(());\n             }\n "}, {"sha": "a5ab4af40bef71b50f65f4616d5581377b6f463e", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 35, "deletions": 32, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -74,9 +74,8 @@\n #[warn(deprecated_mode)];\n \n use cast;\n-use oldcomm;\n use option;\n-use pipes::{Chan, Port};\n+use pipes::{stream, Chan, Port};\n use pipes;\n use prelude::*;\n use private;\n@@ -88,6 +87,7 @@ use task::rt::rust_closure;\n use task::rt;\n use task::{Failure, ManualThreads, PlatformThread, SchedOpts, SingleThreaded};\n use task::{Success, TaskOpts, TaskResult, ThreadPerCore, ThreadPerTask};\n+use task::{ExistingScheduler, SchedulerHandle};\n use task::{default_task_opts, unkillable};\n use uint;\n use util;\n@@ -536,9 +536,9 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n             let (child_tg, ancestors, f) = option::swap_unwrap(child_data);\n             // Create child task.\n-            let new_task = match opts.sched {\n-              None             => rt::new_task(),\n-              Some(sched_opts) => new_task_in_new_sched(sched_opts)\n+            let new_task = match opts.sched.mode {\n+                DefaultScheduler => rt::new_task(),\n+                _ => new_task_in_sched(opts.sched)\n             };\n             assert !new_task.is_null();\n             // Getting killed after here would leak the task.\n@@ -642,31 +642,35 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n         }\n     }\n \n-    fn new_task_in_new_sched(opts: SchedOpts) -> *rust_task {\n-        unsafe {\n-            if opts.foreign_stack_size != None {\n-                fail ~\"foreign_stack_size scheduler option unimplemented\";\n-            }\n+    fn new_task_in_sched(opts: SchedOpts) -> *rust_task {\n+        if opts.foreign_stack_size != None {\n+            fail ~\"foreign_stack_size scheduler option unimplemented\";\n+        }\n \n-            let num_threads = match opts.mode {\n-              SingleThreaded => 1u,\n-              ThreadPerCore => rt::rust_num_threads(),\n-              ThreadPerTask => {\n-                fail ~\"ThreadPerTask scheduling mode unimplemented\"\n-              }\n-              ManualThreads(threads) => {\n-                if threads == 0u {\n-                    fail ~\"can not create a scheduler with no threads\";\n-                }\n-                threads\n-              }\n-              PlatformThread => 0u /* Won't be used */\n-            };\n+        let num_threads = match opts.mode {\n+          DefaultScheduler\n+          | CurrentScheduler\n+          | ExistingScheduler(*)\n+          | PlatformThread => 0u, /* Won't be used */\n+          SingleThreaded => 1u,\n+          ThreadPerCore => unsafe { rt::rust_num_threads() },\n+          ThreadPerTask => {\n+            fail ~\"ThreadPerTask scheduling mode unimplemented\"\n+          }\n+          ManualThreads(threads) => {\n+            if threads == 0u {\n+                fail ~\"can not create a scheduler with no threads\";\n+            }\n+            threads\n+          }\n+        };\n \n-            let sched_id = if opts.mode != PlatformThread {\n-                rt::rust_new_sched(num_threads)\n-            } else {\n-                rt::rust_osmain_sched_id()\n+        unsafe {\n+            let sched_id = match opts.mode {\n+                CurrentScheduler => rt::rust_get_sched_id(),\n+                ExistingScheduler(SchedulerHandle(id)) => id,\n+                PlatformThread => rt::rust_osmain_sched_id(),\n+                _ => rt::rust_new_sched(num_threads)\n             };\n             rt::rust_new_task_in_sched(sched_id)\n         }\n@@ -675,12 +679,11 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n \n #[test]\n fn test_spawn_raw_simple() {\n-    let po = oldcomm::Port();\n-    let ch = oldcomm::Chan(&po);\n+    let (po, ch) = stream();\n     do spawn_raw(default_task_opts()) {\n-        oldcomm::send(ch, ());\n+        ch.send(());\n     }\n-    oldcomm::recv(po);\n+    po.recv();\n }\n \n #[test]"}, {"sha": "afc3e72e636cbfafca1258e9f0cb12c5d3ba14a1", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -792,14 +792,14 @@ mod test {\n         let (finish_port, finish_chan) = pipes::stream();\n \n         let addr = ip::v4::parse_addr(\"127.0.0.1\");\n-        let iotask = uv::global_loop::get();\n \n         let begin_connect_chan = Cell(move begin_connect_chan);\n         let accept_chan = Cell(move accept_chan);\n \n         // The server task\n         do task::spawn |copy addr, move begin_connect_chan,\n                         move accept_chan| {\n+            let iotask = &uv::global_loop::get();\n             let begin_connect_chan = begin_connect_chan.take();\n             let accept_chan = accept_chan.take();\n             let listen_res = do tcp::listen(\n@@ -831,6 +831,7 @@ mod test {\n             begin_connect_port.recv();\n \n             debug!(\"connecting\");\n+            let iotask = &uv::global_loop::get();\n             let connect_result = tcp::connect(copy addr, port, iotask);\n             assert connect_result.is_ok();\n             let sock = result::unwrap(move connect_result);"}, {"sha": "72e58cbd5d3687211019a78ff40419e9d721b220", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -114,7 +114,7 @@ enum IpGetAddrErr {\n  * a vector of `ip_addr` results, in the case of success, or an error\n  * object in the case of failure\n  */\n-pub fn get_addr(node: &str, iotask: iotask)\n+pub fn get_addr(node: &str, iotask: &iotask)\n         -> result::Result<~[IpAddr], IpGetAddrErr> {\n     do oldcomm::listen |output_ch| {\n         do str::as_buf(node) |node_ptr, len| {\n@@ -419,7 +419,7 @@ mod test {\n     #[ignore(reason = \"valgrind says it's leaky\")]\n     fn test_ip_get_addr() {\n         let localhost_name = ~\"localhost\";\n-        let iotask = uv::global_loop::get();\n+        let iotask = &uv::global_loop::get();\n         let ga_result = get_addr(localhost_name, iotask);\n         if result::is_err(&ga_result) {\n             fail ~\"got err result from net::ip::get_addr();\"\n@@ -445,7 +445,7 @@ mod test {\n     #[ignore(reason = \"valgrind says it's leaky\")]\n     fn test_ip_get_addr_bad_input() {\n         let localhost_name = ~\"sjkl234m,./sdf\";\n-        let iotask = uv::global_loop::get();\n+        let iotask = &uv::global_loop::get();\n         let ga_result = get_addr(localhost_name, iotask);\n         assert result::is_err(&ga_result);\n     }"}, {"sha": "8d6de36947934402a0e4bde7e1af643aba5876f7", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 372, "deletions": 340, "changes": 712, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -143,7 +143,7 @@ pub enum TcpConnectErrData {\n  * `net::tcp::tcp_connect_err_data` instance will be returned\n  */\n pub fn connect(input_ip: ip::IpAddr, port: uint,\n-           iotask: IoTask)\n+               iotask: &IoTask)\n     -> result::Result<TcpSocket, TcpConnectErrData> {\n     unsafe {\n         let result_po = oldcomm::Port::<ConnAttempt>();\n@@ -166,106 +166,116 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                 ip::Ipv4(_) => { false }\n                 ip::Ipv6(_) => { true }\n             },\n-            iotask: iotask\n+            iotask: iotask.clone()\n         };\n         let socket_data_ptr = ptr::addr_of(&(*socket_data));\n         log(debug, fmt!(\"tcp_connect result_ch %?\", conn_data.result_ch));\n         // get an unsafe representation of our stream_handle_ptr that\n         // we can send into the interact cb to be handled in libuv..\n         log(debug, fmt!(\"stream_handle_ptr outside interact %?\",\n-            stream_handle_ptr));\n+                        stream_handle_ptr));\n         do iotask::interact(iotask) |move input_ip, loop_ptr| {\n             unsafe {\n                 log(debug, ~\"in interact cb for tcp client connect..\");\n                 log(debug, fmt!(\"stream_handle_ptr in interact %?\",\n-                    stream_handle_ptr));\n+                                stream_handle_ptr));\n                 match uv::ll::tcp_init( loop_ptr, stream_handle_ptr) {\n-                  0i32 => {\n-                    log(debug, ~\"tcp_init successful\");\n-                    log(debug, ~\"dealing w/ ipv4 connection..\");\n-                    let connect_req_ptr =\n-                        ptr::addr_of(&((*socket_data_ptr).connect_req));\n-                    let addr_str = ip::format_addr(&input_ip);\n-                    let connect_result = match input_ip {\n-                      ip::Ipv4(ref addr) => {\n-                        // have to \"recreate\" the sockaddr_in/6\n-                        // since the ip_addr discards the port\n-                        // info.. should probably add an additional\n-                        // rust type that actually is closer to\n-                        // what the libuv API expects (ip str + port num)\n-                        log(debug, fmt!(\"addr: %?\", addr));\n-                        let in_addr = uv::ll::ip4_addr(addr_str, port as int);\n-                        uv::ll::tcp_connect(\n-                            connect_req_ptr,\n-                            stream_handle_ptr,\n-                            ptr::addr_of(&in_addr),\n-                            tcp_connect_on_connect_cb)\n-                      }\n-                      ip::Ipv6(ref addr) => {\n-                        log(debug, fmt!(\"addr: %?\", addr));\n-                        let in_addr = uv::ll::ip6_addr(addr_str, port as int);\n-                        uv::ll::tcp_connect6(\n-                            connect_req_ptr,\n-                            stream_handle_ptr,\n-                            ptr::addr_of(&in_addr),\n-                            tcp_connect_on_connect_cb)\n-                      }\n-                    };\n-                    match connect_result {\n-                      0i32 => {\n-                        log(debug, ~\"tcp_connect successful\");\n-                        // reusable data that we'll have for the\n-                        // duration..\n-                        uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n-                                                   socket_data_ptr as\n-                                                      *libc::c_void);\n-                        // just so the connect_cb can send the\n-                        // outcome..\n-                        uv::ll::set_data_for_req(connect_req_ptr,\n-                                                 conn_data_ptr);\n-                        log(debug, ~\"leaving tcp_connect interact cb...\");\n-                        // let tcp_connect_on_connect_cb send on\n-                        // the result_ch, now..\n-                      }\n-                      _ => {\n-                        // immediate connect failure.. probably a garbage\n-                        // ip or somesuch\n+                    0i32 => {\n+                        log(debug, ~\"tcp_init successful\");\n+                        log(debug, ~\"dealing w/ ipv4 connection..\");\n+                        let connect_req_ptr =\n+                            ptr::addr_of(&((*socket_data_ptr).connect_req));\n+                        let addr_str = ip::format_addr(&input_ip);\n+                        let connect_result = match input_ip {\n+                            ip::Ipv4(ref addr) => {\n+                                // have to \"recreate\" the\n+                                // sockaddr_in/6 since the ip_addr\n+                                // discards the port info.. should\n+                                // probably add an additional rust\n+                                // type that actually is closer to\n+                                // what the libuv API expects (ip str\n+                                // + port num)\n+                                log(debug, fmt!(\"addr: %?\", addr));\n+                                let in_addr = uv::ll::ip4_addr(addr_str,\n+                                                               port as int);\n+                                uv::ll::tcp_connect(\n+                                    connect_req_ptr,\n+                                    stream_handle_ptr,\n+                                    ptr::addr_of(&in_addr),\n+                                    tcp_connect_on_connect_cb)\n+                            }\n+                            ip::Ipv6(ref addr) => {\n+                                log(debug, fmt!(\"addr: %?\", addr));\n+                                let in_addr = uv::ll::ip6_addr(addr_str,\n+                                                               port as int);\n+                                uv::ll::tcp_connect6(\n+                                    connect_req_ptr,\n+                                    stream_handle_ptr,\n+                                    ptr::addr_of(&in_addr),\n+                                    tcp_connect_on_connect_cb)\n+                            }\n+                        };\n+                        match connect_result {\n+                            0i32 => {\n+                                log(debug, ~\"tcp_connect successful\");\n+                                // reusable data that we'll have for the\n+                                // duration..\n+                                uv::ll::set_data_for_uv_handle(\n+                                    stream_handle_ptr,\n+                                    socket_data_ptr as\n+                                    *libc::c_void);\n+                                // just so the connect_cb can send the\n+                                // outcome..\n+                                uv::ll::set_data_for_req(connect_req_ptr,\n+                                                         conn_data_ptr);\n+                                log(debug,\n+                                    ~\"leaving tcp_connect interact cb...\");\n+                                // let tcp_connect_on_connect_cb send on\n+                                // the result_ch, now..\n+                            }\n+                            _ => {\n+                                // immediate connect\n+                                // failure.. probably a garbage ip or\n+                                // somesuch\n+                                let err_data =\n+                                    uv::ll::get_last_err_data(loop_ptr);\n+                                oldcomm::send((*conn_data_ptr).result_ch,\n+                                              ConnFailure(err_data));\n+                                uv::ll::set_data_for_uv_handle(\n+                                    stream_handle_ptr,\n+                                    conn_data_ptr);\n+                                uv::ll::close(stream_handle_ptr,\n+                                              stream_error_close_cb);\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        // failure to create a tcp handle\n                         let err_data = uv::ll::get_last_err_data(loop_ptr);\n                         oldcomm::send((*conn_data_ptr).result_ch,\n-                                   ConnFailure(err_data));\n-                        uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n-                                                       conn_data_ptr);\n-                        uv::ll::close(stream_handle_ptr,\n-                                      stream_error_close_cb);\n-                      }\n+                                      ConnFailure(err_data));\n                     }\n-                  }\n-                  _ => {\n-                    // failure to create a tcp handle\n-                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                    oldcomm::send((*conn_data_ptr).result_ch,\n-                               ConnFailure(err_data));\n-                  }\n                 }\n             }\n-        };\n+        }\n         match oldcomm::recv(result_po) {\n-          ConnSuccess => {\n-            log(debug, ~\"tcp::connect - received success on result_po\");\n-            result::Ok(TcpSocket(socket_data))\n-          }\n-          ConnFailure(ref err_data) => {\n-            oldcomm::recv(closed_signal_po);\n-            log(debug, ~\"tcp::connect - received failure on result_po\");\n-            // still have to free the malloc'd stream handle..\n-            rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n-                                               as *libc::c_void);\n-            let tcp_conn_err = match err_data.err_name {\n-              ~\"ECONNREFUSED\" => ConnectionRefused,\n-              _ => GenericConnectErr(err_data.err_name, err_data.err_msg)\n-            };\n-            result::Err(tcp_conn_err)\n-          }\n+            ConnSuccess => {\n+                log(debug, ~\"tcp::connect - received success on result_po\");\n+                result::Ok(TcpSocket(socket_data))\n+            }\n+            ConnFailure(ref err_data) => {\n+                oldcomm::recv(closed_signal_po);\n+                log(debug, ~\"tcp::connect - received failure on result_po\");\n+                // still have to free the malloc'd stream handle..\n+                rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n+                                                    as *libc::c_void);\n+                let tcp_conn_err = match err_data.err_name {\n+                    ~\"ECONNREFUSED\" => ConnectionRefused,\n+                    _ => GenericConnectErr(err_data.err_name,\n+                                           err_data.err_msg)\n+                };\n+                result::Err(tcp_conn_err)\n+            }\n         }\n     }\n }\n@@ -506,71 +516,79 @@ fn read_future(sock: &TcpSocket, timeout_msecs: uint)\n pub fn accept(new_conn: TcpNewConnection)\n     -> result::Result<TcpSocket, TcpErrData> {\n     unsafe {\n-        match new_conn {\n-          NewTcpConn(server_handle_ptr) => {\n-            let server_data_ptr = uv::ll::get_data_for_uv_handle(\n-                server_handle_ptr) as *TcpListenFcData;\n-            let reader_po = oldcomm::Port();\n-            let iotask = (*server_data_ptr).iotask;\n-            let stream_handle_ptr = malloc_uv_tcp_t();\n-            *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n-            let client_socket_data = @TcpSocketData {\n-                reader_po: reader_po,\n-                reader_ch: oldcomm::Chan(&reader_po),\n-                stream_handle_ptr : stream_handle_ptr,\n-                connect_req : uv::ll::connect_t(),\n-                write_req : uv::ll::write_t(),\n-                ipv6: (*server_data_ptr).ipv6,\n-                iotask : iotask\n-            };\n-            let client_socket_data_ptr = ptr::addr_of(&(*client_socket_data));\n-            let client_stream_handle_ptr =\n-                (*client_socket_data_ptr).stream_handle_ptr;\n-\n-            let result_po = oldcomm::Port::<Option<TcpErrData>>();\n-            let result_ch = oldcomm::Chan(&result_po);\n-\n-            // UNSAFE LIBUV INTERACTION BEGIN\n-            // .. normally this happens within the context of\n-            // a call to uv::hl::interact.. but we're breaking\n-            // the rules here because this always has to be\n-            // called within the context of a listen() new_connect_cb\n-            // callback (or it will likely fail and drown your cat)\n-            log(debug, ~\"in interact cb for tcp::accept\");\n-            let loop_ptr = uv::ll::get_loop_for_uv_handle(\n-                server_handle_ptr);\n-            match uv::ll::tcp_init(loop_ptr, client_stream_handle_ptr) {\n-              0i32 => {\n-                log(debug, ~\"uv_tcp_init successful for client stream\");\n-                match uv::ll::accept(\n-                    server_handle_ptr as *libc::c_void,\n-                    client_stream_handle_ptr as *libc::c_void) {\n-                  0i32 => {\n-                    log(debug, ~\"successfully accepted client connection\");\n-                    uv::ll::set_data_for_uv_handle(client_stream_handle_ptr,\n-                                                   client_socket_data_ptr\n-                                                       as *libc::c_void);\n-                    oldcomm::send(result_ch, None);\n-                  }\n-                  _ => {\n-                    log(debug, ~\"failed to accept client conn\");\n-                    oldcomm::send(result_ch, Some(\n-                        uv::ll::get_last_err_data(loop_ptr).to_tcp_err()));\n-                  }\n+        match new_conn{\n+            NewTcpConn(server_handle_ptr) => {\n+                let server_data_ptr = uv::ll::get_data_for_uv_handle(\n+                    server_handle_ptr) as *TcpListenFcData;\n+                let reader_po = oldcomm::Port();\n+                let iotask = &(*server_data_ptr).iotask;\n+                let stream_handle_ptr = malloc_uv_tcp_t();\n+                *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) =\n+                    uv::ll::tcp_t();\n+                let client_socket_data: @TcpSocketData = @TcpSocketData {\n+                    reader_po: reader_po,\n+                    reader_ch: oldcomm::Chan(&reader_po),\n+                    stream_handle_ptr : stream_handle_ptr,\n+                    connect_req : uv::ll::connect_t(),\n+                    write_req : uv::ll::write_t(),\n+                    ipv6: (*server_data_ptr).ipv6,\n+                    iotask : iotask.clone()\n+                };\n+                let client_socket_data_ptr = ptr::addr_of(\n+                    &(*client_socket_data));\n+                let client_stream_handle_ptr =\n+                    (*client_socket_data_ptr).stream_handle_ptr;\n+\n+                let result_po = oldcomm::Port::<Option<TcpErrData>>();\n+                let result_ch = oldcomm::Chan(&result_po);\n+\n+                // UNSAFE LIBUV INTERACTION BEGIN\n+                // .. normally this happens within the context of\n+                // a call to uv::hl::interact.. but we're breaking\n+                // the rules here because this always has to be\n+                // called within the context of a listen() new_connect_cb\n+                // callback (or it will likely fail and drown your cat)\n+                log(debug, ~\"in interact cb for tcp::accept\");\n+                let loop_ptr = uv::ll::get_loop_for_uv_handle(\n+                    server_handle_ptr);\n+                match uv::ll::tcp_init(loop_ptr, client_stream_handle_ptr) {\n+                    0i32 => {\n+                        log(debug, ~\"uv_tcp_init successful for \\\n+                                     client stream\");\n+                        match uv::ll::accept(\n+                            server_handle_ptr as *libc::c_void,\n+                            client_stream_handle_ptr as *libc::c_void) {\n+                            0i32 => {\n+                                log(debug,\n+                                    ~\"successfully accepted client \\\n+                                      connection\");\n+                                uv::ll::set_data_for_uv_handle(\n+                                    client_stream_handle_ptr,\n+                                    client_socket_data_ptr\n+                                    as *libc::c_void);\n+                                oldcomm::send(result_ch, None);\n+                            }\n+                            _ => {\n+                                log(debug, ~\"failed to accept client conn\");\n+                                oldcomm::send(result_ch, Some(\n+                                    uv::ll::get_last_err_data(\n+                                        loop_ptr).to_tcp_err()));\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        log(debug, ~\"failed to accept client stream\");\n+                        oldcomm::send(result_ch, Some(\n+                            uv::ll::get_last_err_data(\n+                                loop_ptr).to_tcp_err()));\n+                    }\n+                }\n+                // UNSAFE LIBUV INTERACTION END\n+                match oldcomm::recv(result_po) {\n+                    Some(copy err_data) => result::Err(err_data),\n+                    None => result::Ok(TcpSocket(client_socket_data))\n                 }\n-              }\n-              _ => {\n-                log(debug, ~\"failed to init client stream\");\n-                oldcomm::send(result_ch, Some(\n-                    uv::ll::get_last_err_data(loop_ptr).to_tcp_err()));\n-              }\n-            }\n-            // UNSAFE LIBUV INTERACTION END\n-            match oldcomm::recv(result_po) {\n-              Some(copy err_data) => result::Err(err_data),\n-              None => result::Ok(TcpSocket(client_socket_data))\n             }\n-          }\n         }\n     }\n }\n@@ -604,30 +622,27 @@ pub fn accept(new_conn: TcpNewConnection)\n  * of listen exiting because of an error\n  */\n pub fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n-          iotask: IoTask,\n-          on_establish_cb: fn~(oldcomm::Chan<Option<TcpErrData>>),\n-          new_connect_cb: fn~(TcpNewConnection,\n-                               oldcomm::Chan<Option<TcpErrData>>))\n+              iotask: &IoTask,\n+              on_establish_cb: fn~(oldcomm::Chan<Option<TcpErrData>>),\n+              new_connect_cb: fn~(TcpNewConnection,\n+                                  oldcomm::Chan<Option<TcpErrData>>))\n     -> result::Result<(), TcpListenErrData> {\n-    unsafe {\n-        do listen_common(move host_ip, port, backlog, iotask,\n-                         move on_establish_cb)\n-            // on_connect_cb\n-            |move new_connect_cb, handle| {\n-                unsafe {\n-                    let server_data_ptr =\n-                        uv::ll::get_data_for_uv_handle(handle)\n-                        as *TcpListenFcData;\n-                    let new_conn = NewTcpConn(handle);\n-                    let kill_ch = (*server_data_ptr).kill_ch;\n-                    new_connect_cb(new_conn, kill_ch);\n-                }\n-            }\n+    do listen_common(move host_ip, port, backlog, iotask,\n+                     move on_establish_cb)\n+        // on_connect_cb\n+        |move new_connect_cb, handle| {\n+        unsafe {\n+            let server_data_ptr = uv::ll::get_data_for_uv_handle(handle)\n+                as *TcpListenFcData;\n+            let new_conn = NewTcpConn(handle);\n+            let kill_ch = (*server_data_ptr).kill_ch;\n+            new_connect_cb(new_conn, kill_ch);\n+        }\n     }\n }\n \n fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n-          iotask: IoTask,\n+          iotask: &IoTask,\n           on_establish_cb: fn~(oldcomm::Chan<Option<TcpErrData>>),\n           on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n     -> result::Result<(), TcpListenErrData> {\n@@ -637,12 +652,12 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n         let kill_ch = oldcomm::Chan(&kill_po);\n         let server_stream = uv::ll::tcp_t();\n         let server_stream_ptr = ptr::addr_of(&server_stream);\n-        let server_data = {\n+        let server_data: TcpListenFcData = TcpListenFcData {\n             server_stream_ptr: server_stream_ptr,\n             stream_closed_ch: oldcomm::Chan(&stream_closed_po),\n             kill_ch: kill_ch,\n             on_connect_cb: move on_connect_cb,\n-            iotask: iotask,\n+            iotask: iotask.clone(),\n             ipv6: match &host_ip {\n                 &ip::Ipv4(_) => { false }\n                 &ip::Ipv6(_) => { true }\n@@ -662,114 +677,123 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n             do iotask::interact(iotask) |move loc_ip, loop_ptr| {\n                 unsafe {\n                     match uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n-                      0i32 => {\n-                        uv::ll::set_data_for_uv_handle(\n-                            server_stream_ptr,\n-                            server_data_ptr);\n-                        let addr_str = ip::format_addr(&loc_ip);\n-                        let bind_result = match loc_ip {\n-                          ip::Ipv4(ref addr) => {\n-                            log(debug, fmt!(\"addr: %?\", addr));\n-                            let in_addr = uv::ll::ip4_addr(addr_str,\n-                                                           port as int);\n-                            uv::ll::tcp_bind(server_stream_ptr,\n-                                             ptr::addr_of(&in_addr))\n-                          }\n-                          ip::Ipv6(ref addr) => {\n-                            log(debug, fmt!(\"addr: %?\", addr));\n-                            let in_addr = uv::ll::ip6_addr(addr_str,\n-                                                           port as int);\n-                            uv::ll::tcp_bind6(server_stream_ptr,\n-                                             ptr::addr_of(&in_addr))\n-                          }\n-                        };\n-                        match bind_result {\n-                          0i32 => {\n-                            match uv::ll::listen(server_stream_ptr,\n-                                               backlog as libc::c_int,\n-                                               tcp_lfc_on_connection_cb) {\n-                              0i32 => oldcomm::send(setup_ch, None),\n-                              _ => {\n-                                log(debug, ~\"failure to uv_listen()\");\n-                                let err_data = uv::ll::get_last_err_data(\n-                                    loop_ptr);\n-                                oldcomm::send(setup_ch, Some(err_data));\n-                              }\n+                        0i32 => {\n+                            uv::ll::set_data_for_uv_handle(\n+                                server_stream_ptr,\n+                                server_data_ptr);\n+                            let addr_str = ip::format_addr(&loc_ip);\n+                            let bind_result = match loc_ip {\n+                                ip::Ipv4(ref addr) => {\n+                                    log(debug, fmt!(\"addr: %?\", addr));\n+                                    let in_addr = uv::ll::ip4_addr(\n+                                        addr_str,\n+                                        port as int);\n+                                    uv::ll::tcp_bind(server_stream_ptr,\n+                                                     ptr::addr_of(&in_addr))\n+                                }\n+                                ip::Ipv6(ref addr) => {\n+                                    log(debug, fmt!(\"addr: %?\", addr));\n+                                    let in_addr = uv::ll::ip6_addr(\n+                                        addr_str,\n+                                        port as int);\n+                                    uv::ll::tcp_bind6(server_stream_ptr,\n+                                                      ptr::addr_of(&in_addr))\n+                                }\n+                            };\n+                            match bind_result {\n+                                0i32 => {\n+                                    match uv::ll::listen(\n+                                        server_stream_ptr,\n+                                        backlog as libc::c_int,\n+                                        tcp_lfc_on_connection_cb) {\n+                                        0i32 => oldcomm::send(setup_ch, None),\n+                                        _ => {\n+                                            log(debug,\n+                                                ~\"failure to uv_tcp_init\");\n+                                            let err_data =\n+                                                uv::ll::get_last_err_data(\n+                                                    loop_ptr);\n+                                            oldcomm::send(setup_ch,\n+                                                          Some(err_data));\n+                                        }\n+                                    }\n+                                }\n+                                _ => {\n+                                    log(debug, ~\"failure to uv_tcp_bind\");\n+                                    let err_data = uv::ll::get_last_err_data(\n+                                        loop_ptr);\n+                                    oldcomm::send(setup_ch, Some(err_data));\n+                                }\n                             }\n-                          }\n-                          _ => {\n+                        }\n+                        _ => {\n                             log(debug, ~\"failure to uv_tcp_bind\");\n                             let err_data = uv::ll::get_last_err_data(\n                                 loop_ptr);\n                             oldcomm::send(setup_ch, Some(err_data));\n-                          }\n                         }\n-                      }\n-                      _ => {\n-                        log(debug, ~\"failure to uv_tcp_init\");\n-                        let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                        oldcomm::send(setup_ch, Some(err_data));\n-                      }\n                     }\n-                };\n+                }\n             }\n             setup_ch.recv()\n         };\n         match setup_result {\n-          Some(ref err_data) => {\n-            do iotask::interact(iotask) |loop_ptr| {\n-                unsafe {\n-                    log(debug,\n-                        fmt!(\"tcp::listen post-kill recv hl interact %?\",\n-                             loop_ptr));\n-                    (*server_data_ptr).active = false;\n-                    uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n+            Some(ref err_data) => {\n+                do iotask::interact(iotask) |loop_ptr| {\n+                    unsafe {\n+                        log(debug,\n+                            fmt!(\"tcp::listen post-kill recv hl interact %?\",\n+                                 loop_ptr));\n+                        (*server_data_ptr).active = false;\n+                        uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n+                    }\n+                };\n+                stream_closed_po.recv();\n+                match err_data.err_name {\n+                    ~\"EACCES\" => {\n+                        log(debug, ~\"Got EACCES error\");\n+                        result::Err(AccessDenied)\n+                    }\n+                    ~\"EADDRINUSE\" => {\n+                        log(debug, ~\"Got EADDRINUSE error\");\n+                        result::Err(AddressInUse)\n+                    }\n+                    _ => {\n+                        log(debug, fmt!(\"Got '%s' '%s' libuv error\",\n+                                        err_data.err_name, err_data.err_msg));\n+                        result::Err(\n+                            GenericListenErr(err_data.err_name,\n+                                             err_data.err_msg))\n+                    }\n                 }\n-            };\n-            stream_closed_po.recv();\n-            match err_data.err_name {\n-              ~\"EACCES\" => {\n-                log(debug, ~\"Got EACCES error\");\n-                result::Err(AccessDenied)\n-              }\n-              ~\"EADDRINUSE\" => {\n-                log(debug, ~\"Got EADDRINUSE error\");\n-                result::Err(AddressInUse)\n-              }\n-              _ => {\n-                log(debug, fmt!(\"Got '%s' '%s' libuv error\",\n-                                err_data.err_name, err_data.err_msg));\n-                result::Err(\n-                    GenericListenErr(err_data.err_name, err_data.err_msg))\n-              }\n             }\n-          }\n-          None => {\n-            on_establish_cb(kill_ch);\n-            let kill_result = oldcomm::recv(kill_po);\n-            do iotask::interact(iotask) |loop_ptr| {\n-                unsafe {\n-                    log(debug,\n-                        fmt!(\"tcp::listen post-kill recv hl interact %?\",\n-                             loop_ptr));\n-                    (*server_data_ptr).active = false;\n-                    uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n+            None => {\n+                on_establish_cb(kill_ch);\n+                let kill_result = oldcomm::recv(kill_po);\n+                do iotask::interact(iotask) |loop_ptr| {\n+                    unsafe {\n+                        log(debug,\n+                            fmt!(\"tcp::listen post-kill recv hl interact %?\",\n+                                 loop_ptr));\n+                        (*server_data_ptr).active = false;\n+                        uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n+                    }\n+                };\n+                stream_closed_po.recv();\n+                match kill_result {\n+                    // some failure post bind/listen\n+                    Some(ref err_data) => result::Err(GenericListenErr(\n+                        err_data.err_name,\n+                        err_data.err_msg)),\n+                    // clean exit\n+                    None => result::Ok(())\n                 }\n-            };\n-            stream_closed_po.recv();\n-            match kill_result {\n-              // some failure post bind/listen\n-              Some(ref err_data) => result::Err(GenericListenErr(\n-                  err_data.err_name,\n-                  err_data.err_msg)),\n-              // clean exit\n-              None => result::Ok(())\n             }\n-          }\n         }\n     }\n }\n \n+\n /**\n  * Convert a `net::tcp::tcp_socket` to a `net::tcp::tcp_socket_buf`.\n  *\n@@ -936,11 +960,11 @@ fn tear_down_socket_data(socket_data: @TcpSocketData) {\n         };\n         let close_data_ptr = ptr::addr_of(&close_data);\n         let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n-        do iotask::interact((*socket_data).iotask) |loop_ptr| {\n+        do iotask::interact(&(*socket_data).iotask) |loop_ptr| {\n             unsafe {\n                 log(debug,\n                     fmt!(\"interact dtor for tcp_socket stream %? loop %?\",\n-                    stream_handle_ptr, loop_ptr));\n+                         stream_handle_ptr, loop_ptr));\n                 uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n                                                close_data_ptr);\n                 uv::ll::close(stream_handle_ptr, tcp_socket_dtor_close_cb);\n@@ -950,7 +974,7 @@ fn tear_down_socket_data(socket_data: @TcpSocketData) {\n         //the line below will most likely crash\n         //log(debug, fmt!(\"about to free socket_data at %?\", socket_data));\n         rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n-                                           as *libc::c_void);\n+                                            as *libc::c_void);\n         log(debug, ~\"exiting dtor for tcp_socket\");\n     }\n }\n@@ -962,7 +986,7 @@ fn read_common_impl(socket_data: *TcpSocketData, timeout_msecs: uint)\n         use timer;\n \n         log(debug, ~\"starting tcp::read\");\n-        let iotask = (*socket_data).iotask;\n+        let iotask = &(*socket_data).iotask;\n         let rs_result = read_start_common_impl(socket_data);\n         if result::is_err(&rs_result) {\n             let err_data = result::get_err(&rs_result);\n@@ -972,26 +996,26 @@ fn read_common_impl(socket_data: *TcpSocketData, timeout_msecs: uint)\n             log(debug, ~\"tcp::read before recv_timeout\");\n             let read_result = if timeout_msecs > 0u {\n                 timer::recv_timeout(\n-                   iotask, timeout_msecs, result::get(&rs_result))\n+                    iotask, timeout_msecs, result::get(&rs_result))\n             } else {\n                 Some(oldcomm::recv(result::get(&rs_result)))\n             };\n             log(debug, ~\"tcp::read after recv_timeout\");\n             match move read_result {\n-              None => {\n-                log(debug, ~\"tcp::read: timed out..\");\n-                let err_data = TcpErrData {\n-                    err_name: ~\"TIMEOUT\",\n-                    err_msg: ~\"req timed out\"\n-                };\n-                read_stop_common_impl(socket_data);\n-                result::Err(err_data)\n-              }\n-              Some(move data_result) => {\n-                log(debug, ~\"tcp::read got data\");\n-                read_stop_common_impl(socket_data);\n-                data_result\n-              }\n+                None => {\n+                    log(debug, ~\"tcp::read: timed out..\");\n+                    let err_data = TcpErrData {\n+                        err_name: ~\"TIMEOUT\",\n+                        err_msg: ~\"req timed out\"\n+                    };\n+                    read_stop_common_impl(socket_data);\n+                    result::Err(err_data)\n+                }\n+                Some(move data_result) => {\n+                    log(debug, ~\"tcp::read got data\");\n+                    read_stop_common_impl(socket_data);\n+                    data_result\n+                }\n             }\n         }\n     }\n@@ -1004,27 +1028,26 @@ fn read_stop_common_impl(socket_data: *TcpSocketData) ->\n         let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n         let stop_po = oldcomm::Port::<Option<TcpErrData>>();\n         let stop_ch = oldcomm::Chan(&stop_po);\n-        do iotask::interact((*socket_data).iotask) |loop_ptr| {\n+        do iotask::interact(&(*socket_data).iotask) |loop_ptr| {\n             unsafe {\n                 log(debug, ~\"in interact cb for tcp::read_stop\");\n-                match uv::ll::read_stop(stream_handle_ptr as\n-                                        *uv::ll::uv_stream_t) {\n-                  0i32 => {\n-                    log(debug, ~\"successfully called uv_read_stop\");\n-                    oldcomm::send(stop_ch, None);\n-                  }\n-                  _ => {\n-                    log(debug, ~\"failure in calling uv_read_stop\");\n-                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                    oldcomm::send(stop_ch, Some(err_data.to_tcp_err()));\n-                  }\n+                match uv::ll::read_stop(stream_handle_ptr\n+                                        as *uv::ll::uv_stream_t) {\n+                    0i32 => {\n+                        log(debug, ~\"successfully called uv_read_stop\");\n+                        oldcomm::send(stop_ch, None);\n+                    }\n+                    _ => {\n+                        log(debug, ~\"failure in calling uv_read_stop\");\n+                        let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                        oldcomm::send(stop_ch, Some(err_data.to_tcp_err()));\n+                    }\n                 }\n             }\n-        };\n-\n+        }\n         match oldcomm::recv(stop_po) {\n-          Some(move err_data) => Err(err_data),\n-          None => Ok(())\n+            Some(move err_data) => Err(err_data),\n+            None => Ok(())\n         }\n     }\n }\n@@ -1038,29 +1061,29 @@ fn read_start_common_impl(socket_data: *TcpSocketData)\n         let start_po = oldcomm::Port::<Option<uv::ll::uv_err_data>>();\n         let start_ch = oldcomm::Chan(&start_po);\n         log(debug, ~\"in tcp::read_start before interact loop\");\n-        do iotask::interact((*socket_data).iotask) |loop_ptr| {\n+        do iotask::interact(&(*socket_data).iotask) |loop_ptr| {\n             unsafe {\n-                log(debug,\n-                    fmt!(\"in tcp::read_start interact cb %?\", loop_ptr));\n-                match uv::ll::read_start(stream_handle_ptr as\n-                                         *uv::ll::uv_stream_t,\n+                log(debug, fmt!(\"in tcp::read_start interact cb %?\",\n+                                loop_ptr));\n+                match uv::ll::read_start(stream_handle_ptr\n+                                         as *uv::ll::uv_stream_t,\n                                          on_alloc_cb,\n                                          on_tcp_read_cb) {\n-                  0i32 => {\n-                    log(debug, ~\"success doing uv_read_start\");\n-                    oldcomm::send(start_ch, None);\n-                  }\n-                  _ => {\n-                    log(debug, ~\"error attempting uv_read_start\");\n-                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                    oldcomm::send(start_ch, Some(err_data));\n-                  }\n+                    0i32 => {\n+                        log(debug, ~\"success doing uv_read_start\");\n+                        oldcomm::send(start_ch, None);\n+                    }\n+                    _ => {\n+                        log(debug, ~\"error attempting uv_read_start\");\n+                        let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                        oldcomm::send(start_ch, Some(err_data));\n+                    }\n                 }\n             }\n-        };\n+        }\n         match oldcomm::recv(start_po) {\n-          Some(ref err_data) => result::Err(err_data.to_tcp_err()),\n-          None => result::Ok((*socket_data).reader_po)\n+            Some(ref err_data) => result::Err(err_data.to_tcp_err()),\n+            None => result::Ok((*socket_data).reader_po)\n         }\n     }\n }\n@@ -1084,27 +1107,28 @@ fn write_common_impl(socket_data_ptr: *TcpSocketData,\n             result_ch: oldcomm::Chan(&result_po)\n         };\n         let write_data_ptr = ptr::addr_of(&write_data);\n-        do iotask::interact((*socket_data_ptr).iotask) |loop_ptr| {\n+        do iotask::interact(&(*socket_data_ptr).iotask) |loop_ptr| {\n             unsafe {\n                 log(debug, fmt!(\"in interact cb for tcp::write %?\",\n                                 loop_ptr));\n                 match uv::ll::write(write_req_ptr,\n-                                  stream_handle_ptr,\n-                                  write_buf_vec_ptr,\n-                                  tcp_write_complete_cb) {\n-                  0i32 => {\n-                    log(debug, ~\"uv_write() invoked successfully\");\n-                    uv::ll::set_data_for_req(write_req_ptr, write_data_ptr);\n-                  }\n-                  _ => {\n-                    log(debug, ~\"error invoking uv_write()\");\n-                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                    oldcomm::send((*write_data_ptr).result_ch,\n-                               TcpWriteError(err_data.to_tcp_err()));\n-                  }\n+                                    stream_handle_ptr,\n+                                    write_buf_vec_ptr,\n+                                    tcp_write_complete_cb) {\n+                    0i32 => {\n+                        log(debug, ~\"uv_write() invoked successfully\");\n+                        uv::ll::set_data_for_req(write_req_ptr,\n+                                                 write_data_ptr);\n+                    }\n+                    _ => {\n+                        log(debug, ~\"error invoking uv_write()\");\n+                        let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                        oldcomm::send((*write_data_ptr).result_ch,\n+                                      TcpWriteError(err_data.to_tcp_err()));\n+                    }\n                 }\n             }\n-        };\n+        }\n         // FIXME (#2656): Instead of passing unsafe pointers to local data,\n         // and waiting here for the write to complete, we should transfer\n         // ownership of everything to the I/O task and let it deal with the\n@@ -1473,7 +1497,7 @@ pub mod test {\n         }\n     }\n     pub fn impl_gl_tcp_ipv4_server_and_client() {\n-        let hl_loop = uv::global_loop::get();\n+        let hl_loop = &uv::global_loop::get();\n         let server_ip = ~\"127.0.0.1\";\n         let server_port = 8888u;\n         let expected_req = ~\"ping\";\n@@ -1485,6 +1509,7 @@ pub mod test {\n         let cont_po = oldcomm::Port::<()>();\n         let cont_ch = oldcomm::Chan(&cont_po);\n         // server\n+        let hl_loop_clone = hl_loop.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n             let actual_req = do oldcomm::listen |server_ch| {\n                 run_tcp_test_server(\n@@ -1493,7 +1518,7 @@ pub mod test {\n                     expected_resp,\n                     server_ch,\n                     cont_ch,\n-                    hl_loop)\n+                    &hl_loop_clone)\n             };\n             server_result_ch.send(actual_req);\n         };\n@@ -1519,7 +1544,7 @@ pub mod test {\n         assert str::contains(actual_resp, expected_resp);\n     }\n     pub fn impl_gl_tcp_ipv4_get_peer_addr() {\n-        let hl_loop = uv::global_loop::get();\n+        let hl_loop = &uv::global_loop::get();\n         let server_ip = ~\"127.0.0.1\";\n         let server_port = 8887u;\n         let expected_resp = ~\"pong\";\n@@ -1530,6 +1555,7 @@ pub mod test {\n         let cont_po = oldcomm::Port::<()>();\n         let cont_ch = oldcomm::Chan(&cont_po);\n         // server\n+        let hl_loop_clone = hl_loop.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n             let actual_req = do oldcomm::listen |server_ch| {\n                 run_tcp_test_server(\n@@ -1538,7 +1564,7 @@ pub mod test {\n                     expected_resp,\n                     server_ch,\n                     cont_ch,\n-                    hl_loop)\n+                    &hl_loop_clone)\n             };\n             server_result_ch.send(actual_req);\n         };\n@@ -1549,10 +1575,11 @@ pub mod test {\n             let server_ip_addr = ip::v4::parse_addr(server_ip);\n             let iotask = uv::global_loop::get();\n             let connect_result = connect(move server_ip_addr, server_port,\n-                                         iotask);\n+                                         &iotask);\n \n             let sock = result::unwrap(move connect_result);\n \n+            debug!(\"testing peer address\");\n             // This is what we are actually testing!\n             assert net::ip::format_addr(&sock.get_peer_addr()) ==\n                 ~\"127.0.0.1\";\n@@ -1561,12 +1588,14 @@ pub mod test {\n             // Fulfill the protocol the test server expects\n             let resp_bytes = str::to_bytes(~\"ping\");\n             tcp_write_single(&sock, resp_bytes);\n+            debug!(\"message sent\");\n             let read_result = sock.read(0u);\n             client_ch.send(str::from_bytes(read_result.get()));\n+            debug!(\"result read\");\n         };\n     }\n     pub fn impl_gl_tcp_ipv4_client_error_connection_refused() {\n-        let hl_loop = uv::global_loop::get();\n+        let hl_loop = &uv::global_loop::get();\n         let server_ip = ~\"127.0.0.1\";\n         let server_port = 8889u;\n         let expected_req = ~\"ping\";\n@@ -1586,7 +1615,7 @@ pub mod test {\n         }\n     }\n     pub fn impl_gl_tcp_ipv4_server_address_in_use() {\n-        let hl_loop = uv::global_loop::get();\n+        let hl_loop = &uv::global_loop::get();\n         let server_ip = ~\"127.0.0.1\";\n         let server_port = 8890u;\n         let expected_req = ~\"ping\";\n@@ -1598,6 +1627,7 @@ pub mod test {\n         let cont_po = oldcomm::Port::<()>();\n         let cont_ch = oldcomm::Chan(&cont_po);\n         // server\n+        let hl_loop_clone = hl_loop.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n             let actual_req = do oldcomm::listen |server_ch| {\n                 run_tcp_test_server(\n@@ -1606,7 +1636,7 @@ pub mod test {\n                     expected_resp,\n                     server_ch,\n                     cont_ch,\n-                    hl_loop)\n+                    &hl_loop_clone)\n             };\n             server_result_ch.send(actual_req);\n         };\n@@ -1637,7 +1667,7 @@ pub mod test {\n         }\n     }\n     pub fn impl_gl_tcp_ipv4_server_access_denied() {\n-        let hl_loop = uv::global_loop::get();\n+        let hl_loop = &uv::global_loop::get();\n         let server_ip = ~\"127.0.0.1\";\n         let server_port = 80u;\n         // this one should fail..\n@@ -1657,7 +1687,7 @@ pub mod test {\n     }\n     pub fn impl_gl_tcp_ipv4_server_client_reader_writer() {\n \n-        let iotask = uv::global_loop::get();\n+        let iotask = &uv::global_loop::get();\n         let server_ip = ~\"127.0.0.1\";\n         let server_port = 8891u;\n         let expected_req = ~\"ping\";\n@@ -1669,6 +1699,7 @@ pub mod test {\n         let cont_po = oldcomm::Port::<()>();\n         let cont_ch = oldcomm::Chan(&cont_po);\n         // server\n+        let iotask_clone = iotask.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n             let actual_req = do oldcomm::listen |server_ch| {\n                 run_tcp_test_server(\n@@ -1677,7 +1708,7 @@ pub mod test {\n                     expected_resp,\n                     server_ch,\n                     cont_ch,\n-                    iotask)\n+                    &iotask_clone)\n             };\n             server_result_ch.send(actual_req);\n         };\n@@ -1708,7 +1739,7 @@ pub mod test {\n     pub fn impl_tcp_socket_impl_reader_handles_eof() {\n         use core::io::{Reader,ReaderUtil};\n \n-        let hl_loop = uv::global_loop::get();\n+        let hl_loop = &uv::global_loop::get();\n         let server_ip = ~\"127.0.0.1\";\n         let server_port = 10041u;\n         let expected_req = ~\"GET /\";\n@@ -1720,6 +1751,7 @@ pub mod test {\n         let cont_po = oldcomm::Port::<()>();\n         let cont_ch = oldcomm::Chan(&cont_po);\n         // server\n+        let hl_loop_clone = hl_loop.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n             let actual_req = do oldcomm::listen |server_ch| {\n                 run_tcp_test_server(\n@@ -1728,7 +1760,7 @@ pub mod test {\n                     expected_resp,\n                     server_ch,\n                     cont_ch,\n-                    hl_loop)\n+                    &hl_loop_clone)\n             };\n             server_result_ch.send(actual_req);\n         };\n@@ -1768,7 +1800,7 @@ pub mod test {\n     fn run_tcp_test_server(server_ip: &str, server_port: uint, resp: ~str,\n                           server_ch: oldcomm::Chan<~str>,\n                           cont_ch: oldcomm::Chan<()>,\n-                          iotask: IoTask) -> ~str {\n+                          iotask: &IoTask) -> ~str {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n         let listen_result = listen(move server_ip_addr, server_port, 128,\n                                    iotask,\n@@ -1855,7 +1887,7 @@ pub mod test {\n     }\n \n     fn run_tcp_test_server_fail(server_ip: &str, server_port: uint,\n-                          iotask: IoTask) -> TcpListenErrData {\n+                                iotask: &IoTask) -> TcpListenErrData {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n         let listen_result = listen(move server_ip_addr, server_port, 128,\n                                    iotask,\n@@ -1879,7 +1911,7 @@ pub mod test {\n \n     fn run_tcp_test_client(server_ip: &str, server_port: uint, resp: &str,\n                           client_ch: oldcomm::Chan<~str>,\n-                          iotask: IoTask) -> result::Result<~str,\n+                          iotask: &IoTask) -> result::Result<~str,\n                                                     TcpConnectErrData> {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n "}, {"sha": "a3e39bc7bbcbc0f1331e31f9506c0ceb0c5e720f", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -39,7 +39,7 @@ use core;\n  * * ch - a channel of type T to send a `val` on\n  * * val - a value of type T to send over the provided `ch`\n  */\n-pub fn delayed_send<T: Owned>(iotask: IoTask,\n+pub fn delayed_send<T: Owned>(iotask: &IoTask,\n                               msecs: uint,\n                               ch: oldcomm::Chan<T>,\n                               val: T) {\n@@ -92,7 +92,7 @@ pub fn delayed_send<T: Owned>(iotask: IoTask,\n  * * `iotask` - a `uv::iotask` that the tcp request will run on\n  * * msecs - an amount of time, in milliseconds, for the current task to block\n  */\n-pub fn sleep(iotask: IoTask, msecs: uint) {\n+pub fn sleep(iotask: &IoTask, msecs: uint) {\n     let exit_po = oldcomm::Port::<()>();\n     let exit_ch = oldcomm::Chan(&exit_po);\n     delayed_send(iotask, msecs, exit_ch, ());\n@@ -119,7 +119,7 @@ pub fn sleep(iotask: IoTask, msecs: uint) {\n  * on the provided port in the allotted timeout period, then the result will\n  * be a `some(T)`. If not, then `none` will be returned.\n  */\n-pub fn recv_timeout<T: Copy Owned>(iotask: IoTask,\n+pub fn recv_timeout<T: Copy Owned>(iotask: &IoTask,\n                                    msecs: uint,\n                                    wait_po: oldcomm::Port<T>)\n                                 -> Option<T> {\n@@ -183,13 +183,13 @@ mod test {\n \n     #[test]\n     fn test_gl_timer_simple_sleep_test() {\n-        let hl_loop = uv::global_loop::get();\n+        let hl_loop = &uv::global_loop::get();\n         sleep(hl_loop, 1u);\n     }\n \n     #[test]\n     fn test_gl_timer_sleep_stress1() {\n-        let hl_loop = uv::global_loop::get();\n+        let hl_loop = &uv::global_loop::get();\n         for iter::repeat(50u) {\n             sleep(hl_loop, 1u);\n         }\n@@ -199,7 +199,7 @@ mod test {\n     fn test_gl_timer_sleep_stress2() {\n         let po = oldcomm::Port();\n         let ch = oldcomm::Chan(&po);\n-        let hl_loop = uv::global_loop::get();\n+        let hl_loop = &uv::global_loop::get();\n \n         let repeat = 20u;\n         let spec = {\n@@ -214,11 +214,12 @@ mod test {\n \n             for spec.each |spec| {\n                 let (times, maxms) = *spec;\n+                let hl_loop_clone = hl_loop.clone();\n                 do task::spawn {\n                     use rand::*;\n                     let rng = Rng();\n                     for iter::repeat(times) {\n-                        sleep(hl_loop, rng.next() as uint % maxms);\n+                        sleep(&hl_loop_clone, rng.next() as uint % maxms);\n                     }\n                     oldcomm::send(ch, ());\n                 }\n@@ -277,12 +278,12 @@ mod test {\n             let expected = rand::Rng().gen_str(16u);\n             let test_po = oldcomm::Port::<~str>();\n             let test_ch = oldcomm::Chan(&test_po);\n-\n+            let hl_loop_clone = hl_loop.clone();\n             do task::spawn() {\n-                delayed_send(hl_loop, 50u, test_ch, expected);\n+                delayed_send(&hl_loop_clone, 50u, test_ch, expected);\n             };\n \n-            match recv_timeout(hl_loop, 1u, test_po) {\n+            match recv_timeout(&hl_loop, 1u, test_po) {\n               None => successes += 1,\n               _ => failures += 1\n             };"}, {"sha": "8ae3e24abee40bfea28cd461fe5c6127060e10d9", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 100, "deletions": 105, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -19,16 +19,16 @@ use uv_iotask::{IoTask, spawn_iotask};\n \n use core::either::{Left, Right};\n use core::libc;\n-use core::oldcomm::{Port, Chan, select2, listen};\n-use core::private::{chan_from_global_ptr, weaken_task};\n+use core::pipes::{Port, Chan, SharedChan, select2i};\n+use core::private::global::{global_data_clone_create,\n+                            global_data_clone};\n+use core::private::weak_task::weaken_task;\n use core::str;\n-use core::task::TaskBuilder;\n+use core::task::{task, SingleThreaded, spawn};\n use core::task;\n use core::vec;\n-\n-extern mod rustrt {\n-    unsafe fn rust_uv_get_kernel_global_chan_ptr() -> *libc::uintptr_t;\n-}\n+use core::clone::Clone;\n+use core::option::{Some, None};\n \n /**\n  * Race-free helper to get access to a global task where a libuv\n@@ -48,69 +48,64 @@ pub fn get() -> IoTask {\n \n #[doc(hidden)]\n fn get_monitor_task_gl() -> IoTask {\n-    unsafe {\n-        let monitor_loop_chan_ptr =\n-            rustrt::rust_uv_get_kernel_global_chan_ptr();\n-\n-        debug!(\"ENTERING global_loop::get() loop chan: %?\",\n-               monitor_loop_chan_ptr);\n-\n-        debug!(\"before priv::chan_from_global_ptr\");\n-        type MonChan = Chan<IoTask>;\n-\n-        let monitor_ch =\n-            do chan_from_global_ptr::<MonChan>(monitor_loop_chan_ptr,\n-                                               || {\n-                                                    task::task().sched_mode\n-                                                    (task::SingleThreaded)\n-                                                    .unlinked()\n-                                               }) |msg_po| {\n-            unsafe {\n-                debug!(\"global monitor task starting\");\n-\n-                // As a weak task the runtime will notify us when to exit\n-                do weaken_task() |weak_exit_po| {\n-                    debug!(\"global monitor task is now weak\");\n-                    let hl_loop = spawn_loop();\n-                    loop {\n-                        debug!(\"in outer_loop...\");\n-                        match select2(weak_exit_po, msg_po) {\n-                          Left(weak_exit) => {\n-                            // all normal tasks have ended, tell the\n-                            // libuv loop to tear_down, then exit\n-                            debug!(\"weak_exit_po recv'd msg: %?\", weak_exit);\n-                            iotask::exit(hl_loop);\n-                            break;\n-                          }\n-                          Right(fetch_ch) => {\n-                            debug!(\"hl_loop req recv'd: %?\", fetch_ch);\n-                            fetch_ch.send(hl_loop);\n-                          }\n-                        }\n+\n+    type MonChan = Chan<IoTask>;\n+\n+    struct GlobalIoTask(IoTask);\n+\n+    impl GlobalIoTask: Clone {\n+        fn clone(&self) -> GlobalIoTask {\n+            GlobalIoTask((**self).clone())\n+        }\n+    }\n+\n+    fn key(_: GlobalIoTask) { }\n+\n+    match unsafe { global_data_clone(key) } {\n+        Some(GlobalIoTask(iotask)) => iotask,\n+        None => {\n+            let iotask: IoTask = spawn_loop();\n+            let mut installed = false;\n+            let final_iotask = unsafe {\n+                do global_data_clone_create(key) {\n+                    installed = true;\n+                    ~GlobalIoTask(iotask.clone())\n+                }\n+            };\n+            if installed {\n+                do task().unlinked().spawn() {\n+                    unsafe {\n+                        debug!(\"global monitor task starting\");\n+                        // As a weak task the runtime will notify us\n+                        // when to exit\n+                        do weaken_task |weak_exit_po| {\n+                            debug!(\"global monitor task is weak\");\n+                            weak_exit_po.recv();\n+                            iotask::exit(&iotask);\n+                            debug!(\"global monitor task is unweak\");\n+                        };\n+                        debug!(\"global monitor task exiting\");\n                     }\n-                    debug!(\"global monitor task is leaving weakend state\");\n-                };\n-                debug!(\"global monitor task exiting\");\n+                }\n+            } else {\n+                iotask::exit(&iotask);\n             }\n-        };\n \n-        // once we have a chan to the monitor loop, we ask it for\n-        // the libuv loop's async handle\n-        do listen |fetch_ch| {\n-            monitor_ch.send(fetch_ch);\n-            fetch_ch.recv()\n+            match final_iotask {\n+                GlobalIoTask(iotask) => iotask\n+            }\n         }\n     }\n }\n \n fn spawn_loop() -> IoTask {\n-    let builder = do task::task().add_wrapper |task_body| {\n+    let builder = do task().add_wrapper |task_body| {\n         fn~(move task_body) {\n             // The I/O loop task also needs to be weak so it doesn't keep\n             // the runtime alive\n             unsafe {\n-                do weaken_task |weak_exit_po| {\n-                    debug!(\"global libuv task is now weak %?\", weak_exit_po);\n+                do weaken_task |_| {\n+                    debug!(\"global libuv task is now weak\");\n                     task_body();\n \n                     // We don't wait for the exit message on weak_exit_po\n@@ -122,6 +117,7 @@ fn spawn_loop() -> IoTask {\n             }\n         }\n     };\n+    let builder = builder.unlinked();\n     spawn_iotask(move builder)\n }\n \n@@ -135,16 +131,18 @@ mod test {\n \n     use core::iter;\n     use core::libc;\n-    use core::oldcomm;\n     use core::ptr;\n     use core::task;\n+    use core::cast::transmute;\n+    use core::libc::c_void;\n+    use core::pipes::{stream, SharedChan, Chan};\n \n     extern fn simple_timer_close_cb(timer_ptr: *ll::uv_timer_t) {\n         unsafe {\n             let exit_ch_ptr = ll::get_data_for_uv_handle(\n-                timer_ptr as *libc::c_void) as *oldcomm::Chan<bool>;\n-            let exit_ch = *exit_ch_ptr;\n-            oldcomm::send(exit_ch, true);\n+                timer_ptr as *libc::c_void);\n+            let exit_ch = transmute::<*c_void, ~Chan<bool>>(exit_ch_ptr);\n+            exit_ch.send(true);\n             log(debug,\n                 fmt!(\"EXIT_CH_PTR simple_timer_close_cb exit_ch_ptr: %?\",\n                      exit_ch_ptr));\n@@ -155,26 +153,25 @@ mod test {\n         unsafe {\n             log(debug, ~\"in simple timer cb\");\n             ll::timer_stop(timer_ptr);\n-            let hl_loop = get_gl();\n+            let hl_loop = &get_gl();\n             do iotask::interact(hl_loop) |_loop_ptr| {\n+                log(debug, ~\"closing timer\");\n                 unsafe {\n-                    log(debug, ~\"closing timer\");\n                     ll::close(timer_ptr, simple_timer_close_cb);\n-                    log(debug, ~\"about to deref exit_ch_ptr\");\n-                    log(debug, ~\"after msg sent on deref'd exit_ch\");\n                 }\n+                log(debug, ~\"about to deref exit_ch_ptr\");\n+                log(debug, ~\"after msg sent on deref'd exit_ch\");\n             };\n             log(debug, ~\"exiting simple timer cb\");\n         }\n     }\n \n-    fn impl_uv_hl_simple_timer(iotask: IoTask) {\n+    fn impl_uv_hl_simple_timer(iotask: &IoTask) {\n         unsafe {\n-            let exit_po = oldcomm::Port::<bool>();\n-            let exit_ch = oldcomm::Chan(&exit_po);\n-            let exit_ch_ptr = ptr::addr_of(&exit_ch);\n+            let (exit_po, exit_ch) = stream::<bool>();\n+            let exit_ch_ptr: *libc::c_void = transmute(~exit_ch);\n             log(debug, fmt!(\"EXIT_CH_PTR newly created exit_ch_ptr: %?\",\n-                           exit_ch_ptr));\n+                            exit_ch_ptr));\n             let timer_handle = ll::timer_t();\n             let timer_ptr = ptr::addr_of(&timer_handle);\n             do iotask::interact(iotask) |loop_ptr| {\n@@ -184,62 +181,60 @@ mod test {\n                     if(init_status == 0i32) {\n                         ll::set_data_for_uv_handle(\n                             timer_ptr as *libc::c_void,\n-                            exit_ch_ptr as *libc::c_void);\n+                            exit_ch_ptr);\n                         let start_status = ll::timer_start(timer_ptr,\n                                                            simple_timer_cb,\n-                                                           1u,\n-                                                           0u);\n-                        if start_status != 0 {\n+                                                           1u, 0u);\n+                        if(start_status == 0i32) {\n+                        }\n+                        else {\n                             fail ~\"failure on ll::timer_start()\";\n                         }\n-                    } else {\n+                    }\n+                    else {\n                         fail ~\"failure on ll::timer_init()\";\n                     }\n                 }\n             };\n-            oldcomm::recv(exit_po);\n+            exit_po.recv();\n             log(debug,\n                 ~\"global_loop timer test: msg recv on exit_po, done..\");\n         }\n     }\n \n     #[test]\n     fn test_gl_uv_global_loop_high_level_global_timer() {\n-        unsafe {\n-            let hl_loop = get_gl();\n-            let exit_po = oldcomm::Port::<()>();\n-            let exit_ch = oldcomm::Chan(&exit_po);\n-            task::spawn_sched(task::ManualThreads(1u), || {\n-                impl_uv_hl_simple_timer(hl_loop);\n-                oldcomm::send(exit_ch, ());\n-            });\n+        let hl_loop = &get_gl();\n+        let (exit_po, exit_ch) = stream::<()>();\n+        task::spawn_sched(task::ManualThreads(1u), || {\n+            let hl_loop = &get_gl();\n             impl_uv_hl_simple_timer(hl_loop);\n-            oldcomm::recv(exit_po);\n-        }\n+            exit_ch.send(());\n+        });\n+        impl_uv_hl_simple_timer(hl_loop);\n+        exit_po.recv();\n     }\n \n     // keeping this test ignored until some kind of stress-test-harness\n     // is set up for the build bots\n     #[test]\n     #[ignore]\n     fn test_stress_gl_uv_global_loop_high_level_global_timer() {\n-        unsafe {\n-            let hl_loop = get_gl();\n-            let exit_po = oldcomm::Port::<()>();\n-            let exit_ch = oldcomm::Chan(&exit_po);\n-            let cycles = 5000u;\n-            for iter::repeat(cycles) {\n-                task::spawn_sched(task::ManualThreads(1u), || {\n-                    impl_uv_hl_simple_timer(hl_loop);\n-                    oldcomm::send(exit_ch, ());\n-                });\n-            };\n-            for iter::repeat(cycles) {\n-                oldcomm::recv(exit_po);\n-            };\n-            log(debug,\n-                ~\"test_stress_gl_uv_global_loop_high_level_global_timer\"+\n-                ~\" exiting sucessfully!\");\n-        }\n+        let (exit_po, exit_ch) = stream::<()>();\n+        let exit_ch = SharedChan(exit_ch);\n+        let cycles = 5000u;\n+        for iter::repeat(cycles) {\n+            let exit_ch_clone = exit_ch.clone();\n+            task::spawn_sched(task::ManualThreads(1u), || {\n+                let hl_loop = &get_gl();\n+                impl_uv_hl_simple_timer(hl_loop);\n+                exit_ch_clone.send(());\n+            });\n+        };\n+        for iter::repeat(cycles) {\n+            exit_po.recv();\n+        };\n+        log(debug, ~\"test_stress_gl_uv_global_loop_high_level_global_timer\"+\n+            ~\" exiting sucessfully!\");\n     }\n }"}, {"sha": "dc0092aadfaf2aafd54f5ce969f0f0f4e5fe34b5", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 70, "deletions": 44, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -20,7 +20,7 @@ use ll = uv_ll;\n \n use core::libc::c_void;\n use core::libc;\n-use core::oldcomm::{Port, Chan, listen};\n+use core::pipes::{stream, Port, Chan, SharedChan};\n use core::prelude::*;\n use core::ptr::addr_of;\n use core::task::TaskBuilder;\n@@ -30,22 +30,30 @@ use core::task;\n pub enum IoTask {\n     IoTask_({\n         async_handle: *ll::uv_async_t,\n-        op_chan: Chan<IoTaskMsg>\n+        op_chan: SharedChan<IoTaskMsg>\n     })\n }\n \n+impl IoTask: Clone {\n+    fn clone(&self) -> IoTask {\n+        IoTask_({\n+            async_handle: self.async_handle,\n+            op_chan: self.op_chan.clone()\n+        })\n+    }\n+}\n+\n pub fn spawn_iotask(task: task::TaskBuilder) -> IoTask {\n \n-    do listen |iotask_ch| {\n+    let (iotask_port, iotask_chan) = stream();\n \n-        do task.sched_mode(task::SingleThreaded).spawn {\n-            debug!(\"entering libuv task\");\n-            run_loop(iotask_ch);\n-            debug!(\"libuv task exiting\");\n-        };\n+    do task.sched_mode(task::SingleThreaded).spawn {\n+        debug!(\"entering libuv task\");\n+        run_loop(&iotask_chan);\n+        debug!(\"libuv task exiting\");\n+    };\n \n-        iotask_ch.recv()\n-    }\n+    iotask_port.recv()\n }\n \n \n@@ -71,7 +79,7 @@ pub fn spawn_iotask(task: task::TaskBuilder) -> IoTask {\n  * module. It is not safe to send the `loop_ptr` param to this callback out\n  * via ports/chans.\n  */\n-pub unsafe fn interact(iotask: IoTask,\n+pub unsafe fn interact(iotask: &IoTask,\n                    cb: fn~(*c_void)) {\n     send_msg(iotask, Interaction(move cb));\n }\n@@ -83,7 +91,7 @@ pub unsafe fn interact(iotask: IoTask,\n  * async handle and do a sanity check to make sure that all other handles are\n  * closed, causing a failure otherwise.\n  */\n-pub fn exit(iotask: IoTask) {\n+pub fn exit(iotask: &IoTask) {\n     unsafe {\n         send_msg(iotask, TeardownLoop);\n     }\n@@ -98,8 +106,10 @@ enum IoTaskMsg {\n }\n \n /// Run the loop and begin handling messages\n-fn run_loop(iotask_ch: Chan<IoTask>) {\n+fn run_loop(iotask_ch: &Chan<IoTask>) {\n+\n     unsafe {\n+        debug!(\"creating loop\");\n         let loop_ptr = ll::loop_new();\n \n         // set up the special async handle we'll use to allow multi-task\n@@ -110,18 +120,20 @@ fn run_loop(iotask_ch: Chan<IoTask>) {\n         // associate the async handle with the loop\n         ll::async_init(loop_ptr, async_handle, wake_up_cb);\n \n+        let (msg_po, msg_ch) = stream::<IoTaskMsg>();\n+\n         // initialize our loop data and store it in the loop\n-        let data = IoTaskLoopData {\n+        let data: IoTaskLoopData = IoTaskLoopData {\n             async_handle: async_handle,\n-            msg_po: Port()\n+            msg_po: msg_po\n         };\n         ll::set_data_for_uv_handle(async_handle, addr_of(&data));\n \n         // Send out a handle through which folks can talk to us\n         // while we dwell in the I/O loop\n         let iotask = IoTask_({\n             async_handle: async_handle,\n-            op_chan: data.msg_po.chan()\n+            op_chan: SharedChan(msg_ch)\n         });\n         iotask_ch.send(iotask);\n \n@@ -139,29 +151,31 @@ struct IoTaskLoopData {\n     msg_po: Port<IoTaskMsg>,\n }\n \n-fn send_msg(iotask: IoTask, msg: IoTaskMsg) {\n+fn send_msg(iotask: &IoTask,\n+            msg: IoTaskMsg) {\n+    iotask.op_chan.send(move msg);\n     unsafe {\n-        iotask.op_chan.send(move msg);\n         ll::async_send(iotask.async_handle);\n     }\n }\n \n /// Dispatch all pending messages\n extern fn wake_up_cb(async_handle: *ll::uv_async_t,\n                     status: int) {\n-    unsafe {\n-        log(debug, fmt!(\"wake_up_cb extern.. handle: %? status: %?\",\n-                         async_handle, status));\n \n+    log(debug, fmt!(\"wake_up_cb extern.. handle: %? status: %?\",\n+                     async_handle, status));\n+\n+    unsafe {\n         let loop_ptr = ll::get_loop_for_uv_handle(async_handle);\n-        let data = ll::get_data_for_uv_handle(async_handle)\n-            as *IoTaskLoopData;\n-        let msg_po = (*data).msg_po;\n+        let data =\n+            ll::get_data_for_uv_handle(async_handle) as *IoTaskLoopData;\n+        let msg_po = &(*data).msg_po;\n \n         while msg_po.peek() {\n             match msg_po.recv() {\n-              Interaction(ref cb) => (*cb)(loop_ptr),\n-              TeardownLoop => begin_teardown(data)\n+                Interaction(ref cb) => (*cb)(loop_ptr),\n+                TeardownLoop => begin_teardown(data)\n             }\n         }\n     }\n@@ -216,41 +230,46 @@ mod test {\n     }\n     struct AhData {\n         iotask: IoTask,\n-        exit_ch: oldcomm::Chan<()>,\n+        exit_ch: oldcomm::Chan<()>\n     }\n-    fn impl_uv_iotask_async(iotask: IoTask) {\n+    fn impl_uv_iotask_async(iotask: &IoTask) {\n         unsafe {\n             let async_handle = ll::async_t();\n             let ah_ptr = ptr::addr_of(&async_handle);\n             let exit_po = oldcomm::Port::<()>();\n             let exit_ch = oldcomm::Chan(&exit_po);\n-            let ah_data = {\n-                iotask: iotask,\n+            let ah_data = AhData {\n+                iotask: iotask.clone(),\n                 exit_ch: exit_ch\n             };\n-            let ah_data_ptr = ptr::addr_of(&ah_data);\n+            let ah_data_ptr: *AhData = unsafe {\n+                ptr::to_unsafe_ptr(&ah_data)\n+            };\n+            debug!(\"about to interact\");\n             do interact(iotask) |loop_ptr| {\n                 unsafe {\n+                    debug!(\"interacting\");\n                     ll::async_init(loop_ptr, ah_ptr, async_handle_cb);\n-                    ll::set_data_for_uv_handle(ah_ptr,\n-                                               ah_data_ptr as *libc::c_void);\n+                    ll::set_data_for_uv_handle(\n+                        ah_ptr, ah_data_ptr as *libc::c_void);\n                     ll::async_send(ah_ptr);\n                 }\n             };\n+            debug!(\"waiting for async close\");\n             oldcomm::recv(exit_po);\n         }\n     }\n \n     // this fn documents the bear minimum neccesary to roll your own\n     // high_level_loop\n     unsafe fn spawn_test_loop(exit_ch: oldcomm::Chan<()>) -> IoTask {\n-        let iotask_port = oldcomm::Port::<IoTask>();\n-        let iotask_ch = oldcomm::Chan(&iotask_port);\n+        let (iotask_port, iotask_ch) = stream::<IoTask>();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n-            run_loop(iotask_ch);\n+            debug!(\"about to run a test loop\");\n+            run_loop(&iotask_ch);\n             exit_ch.send(());\n         };\n-        return oldcomm::recv(iotask_port);\n+        return iotask_port.recv();\n     }\n \n     extern fn lifetime_handle_close(handle: *libc::c_void) {\n@@ -270,23 +289,30 @@ mod test {\n         unsafe {\n             let exit_po = oldcomm::Port::<()>();\n             let exit_ch = oldcomm::Chan(&exit_po);\n-            let iotask = spawn_test_loop(exit_ch);\n+            let iotask = &spawn_test_loop(exit_ch);\n+\n+            debug!(\"spawned iotask\");\n \n             // using this handle to manage the lifetime of the\n-            // high_level_loop, as it will exit the first time one of the\n-            // impl_uv_hl_async() is cleaned up with no one ref'd handles on\n-            // the loop (Which can happen under race-condition type\n-            // situations.. this ensures that the loop lives until, at least,\n-            // all of the impl_uv_hl_async() runs have been called, at least.\n+            // high_level_loop, as it will exit the first time one of\n+            // the impl_uv_hl_async() is cleaned up with no one ref'd\n+            // handles on the loop (Which can happen under\n+            // race-condition type situations.. this ensures that the\n+            // loop lives until, at least, all of the\n+            // impl_uv_hl_async() runs have been called, at least.\n             let work_exit_po = oldcomm::Port::<()>();\n             let work_exit_ch = oldcomm::Chan(&work_exit_po);\n             for iter::repeat(7u) {\n+                let iotask_clone = iotask.clone();\n                 do task::spawn_sched(task::ManualThreads(1u)) {\n-                    impl_uv_iotask_async(iotask);\n+                    debug!(\"async\");\n+                    impl_uv_iotask_async(&iotask_clone);\n+                    debug!(\"done async\");\n                     oldcomm::send(work_exit_ch, ());\n                 };\n             };\n             for iter::repeat(7u) {\n+                debug!(\"waiting\");\n                 oldcomm::recv(work_exit_po);\n             };\n             log(debug, ~\"sending teardown_loop msg..\");"}, {"sha": "803da32cbc8ac7cffa5c8c6631ce5fdc31b69bee", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -43,8 +43,8 @@ rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n \n     rust_kernel *kernel = new rust_kernel(env);\n \n-    // Create the main scheduler and the main task\n-    rust_sched_id sched_id = kernel->create_scheduler(env->num_sched_threads);\n+    // Create the main task\n+    rust_sched_id sched_id = kernel->main_sched_id();\n     rust_scheduler *sched = kernel->get_scheduler_by_id(sched_id);\n     assert(sched != NULL);\n     rust_task *root_task = sched->create_task(NULL, \"main\");"}, {"sha": "4fcfc11b325684903c76e7583585f01da8e49e29", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -652,7 +652,10 @@ new_task_common(rust_scheduler *sched, rust_task *parent) {\n extern \"C\" CDECL rust_task*\n new_task() {\n     rust_task *task = rust_get_current_task();\n-    return new_task_common(task->sched, task);\n+    rust_sched_id sched_id = task->kernel->main_sched_id();\n+    rust_scheduler *sched = task->kernel->get_scheduler_by_id(sched_id);\n+    assert(sched != NULL && \"should always have a main scheduler\");\n+    return new_task_common(sched, task);\n }\n \n extern \"C\" CDECL rust_task*\n@@ -855,24 +858,6 @@ rust_compare_and_swap_ptr(intptr_t *address,\n     return sync::compare_and_swap(address, oldval, newval);\n }\n \n-extern \"C\" CDECL void\n-rust_task_weaken(rust_port_id chan) {\n-    rust_task *task = rust_get_current_task();\n-    task->kernel->weaken_task(chan);\n-}\n-\n-extern \"C\" CDECL void\n-rust_task_unweaken(rust_port_id chan) {\n-    rust_task *task = rust_get_current_task();\n-    task->kernel->unweaken_task(chan);\n-}\n-\n-extern \"C\" CDECL uintptr_t*\n-rust_global_env_chan_ptr() {\n-    rust_task *task = rust_get_current_task();\n-    return task->kernel->get_global_env_chan();\n-}\n-\n extern \"C\" void\n rust_task_inhibit_kill(rust_task *task) {\n     task->inhibit_kill();\n@@ -1023,6 +1008,29 @@ rust_raw_thread_join_delete(raw_thread *thread) {\n     delete thread;\n }\n \n+extern \"C\" void\n+rust_register_exit_function(spawn_fn runner, fn_env_pair *f) {\n+    rust_task *task = rust_get_current_task();\n+    task->kernel->register_exit_function(runner, f);\n+}\n+\n+extern \"C\" void *\n+rust_get_global_data_ptr() {\n+    rust_task *task = rust_get_current_task();\n+    return &task->kernel->global_data;\n+}\n+\n+extern \"C\" void\n+rust_inc_weak_task_count() {\n+    rust_task *task = rust_get_current_task();\n+    task->kernel->inc_weak_task_count();\n+}\n+\n+extern \"C\" void\n+rust_dec_weak_task_count() {\n+    rust_task *task = rust_get_current_task();\n+    task->kernel->dec_weak_task_count();\n+}\n \n //\n // Local Variables:"}, {"sha": "c365f3cca1ef45dfd0755e8a1d3422e6c2bcc3eb", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 116, "deletions": 49, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -30,21 +30,29 @@ rust_kernel::rust_kernel(rust_env *env) :\n     rval(0),\n     max_sched_id(1),\n     killed(false),\n+    already_exiting(false),\n     sched_reaper(this),\n     osmain_driver(NULL),\n     non_weak_tasks(0),\n-    global_loop_chan(0),\n-    global_env_chan(0),\n-    env(env)\n-\n+    at_exit_runner(NULL),\n+    at_exit_started(false),\n+    env(env),\n+    global_data(0)\n {\n-\n     // Create the single threaded scheduler that will run on the platform's\n     // main thread\n-    rust_manual_sched_launcher_factory *launchfac =\n+    rust_manual_sched_launcher_factory *osmain_launchfac =\n         new rust_manual_sched_launcher_factory();\n-    osmain_scheduler = create_scheduler(launchfac, 1, false);\n-    osmain_driver = launchfac->get_driver();\n+    osmain_scheduler = create_scheduler(osmain_launchfac, 1, false);\n+    osmain_driver = osmain_launchfac->get_driver();\n+\n+    // Create the primary scheduler\n+    rust_thread_sched_launcher_factory *main_launchfac =\n+        new rust_thread_sched_launcher_factory();\n+    main_scheduler = create_scheduler(main_launchfac,\n+                                      env->num_sched_threads,\n+                                      false);\n+\n     sched_reaper.start();\n }\n \n@@ -103,15 +111,22 @@ rust_kernel::create_scheduler(rust_sched_launcher_factory *launchfac,\n     {\n         scoped_lock with(sched_lock);\n \n+        /*if (sched_table.size() == 2) {\n+            // The main and OS main schedulers may not exit while there are\n+            // other schedulers\n+            KLOG_(\"Disallowing main scheduler to exit\");\n+            rust_scheduler *main_sched =\n+                get_scheduler_by_id_nolock(main_scheduler);\n+            assert(main_sched != NULL);\n+            main_sched->disallow_exit();\n+        }\n         if (sched_table.size() == 1) {\n-            // The OS main scheduler may not exit while there are other\n-            // schedulers\n             KLOG_(\"Disallowing osmain scheduler to exit\");\n-            rust_scheduler *sched =\n+            rust_scheduler *osmain_sched =\n                 get_scheduler_by_id_nolock(osmain_scheduler);\n-            assert(sched != NULL);\n-            sched->disallow_exit();\n-        }\n+            assert(osmain_sched != NULL);\n+            osmain_sched->disallow_exit();\n+            }*/\n \n         id = max_sched_id++;\n         assert(id != INTPTR_MAX && \"Hit the maximum scheduler id\");\n@@ -175,14 +190,21 @@ rust_kernel::wait_for_schedulers()\n             sched_table.erase(iter);\n             sched->join_task_threads();\n             sched->deref();\n+            /*if (sched_table.size() == 2) {\n+                KLOG_(\"Allowing main scheduler to exit\");\n+                // It's only the main schedulers left. Tell them to exit\n+                rust_scheduler *main_sched =\n+                    get_scheduler_by_id_nolock(main_scheduler);\n+                assert(main_sched != NULL);\n+                main_sched->allow_exit();\n+            }\n             if (sched_table.size() == 1) {\n                 KLOG_(\"Allowing osmain scheduler to exit\");\n-                // It's only the osmain scheduler left. Tell it to exit\n-                rust_scheduler *sched =\n+                rust_scheduler *osmain_sched =\n                     get_scheduler_by_id_nolock(osmain_scheduler);\n-                assert(sched != NULL);\n-                sched->allow_exit();\n-            }\n+                assert(osmain_sched != NULL);\n+                osmain_sched->allow_exit();\n+            }*/\n         }\n         if (!sched_table.empty()) {\n             sched_lock.wait();\n@@ -318,60 +340,64 @@ rust_kernel::register_task() {\n     KLOG_(\"New non-weak tasks %\" PRIdPTR, new_non_weak_tasks);\n }\n \n+void\n+rust_kernel::allow_scheduler_exit() {\n+    scoped_lock with(sched_lock);\n+\n+    KLOG_(\"Allowing main scheduler to exit\");\n+    // It's only the main schedulers left. Tell them to exit\n+    rust_scheduler *main_sched =\n+        get_scheduler_by_id_nolock(main_scheduler);\n+    assert(main_sched != NULL);\n+    main_sched->allow_exit();\n+\n+    KLOG_(\"Allowing osmain scheduler to exit\");\n+    rust_scheduler *osmain_sched =\n+        get_scheduler_by_id_nolock(osmain_scheduler);\n+    assert(osmain_sched != NULL);\n+    osmain_sched->allow_exit();\n+}\n+\n void\n rust_kernel::unregister_task() {\n     KLOG_(\"Unregistering task\");\n     uintptr_t new_non_weak_tasks = sync::decrement(non_weak_tasks);\n     KLOG_(\"New non-weak tasks %\" PRIdPTR, new_non_weak_tasks);\n     if (new_non_weak_tasks == 0) {\n-        end_weak_tasks();\n+        begin_shutdown();\n     }\n }\n \n void\n-rust_kernel::weaken_task(rust_port_id chan) {\n-    {\n-        scoped_lock with(weak_task_lock);\n-        KLOG_(\"Weakening task with channel %\" PRIdPTR, chan);\n-        weak_task_chans.push_back(chan);\n-    }\n+rust_kernel::inc_weak_task_count() {\n     uintptr_t new_non_weak_tasks = sync::decrement(non_weak_tasks);\n     KLOG_(\"New non-weak tasks %\" PRIdPTR, new_non_weak_tasks);\n     if (new_non_weak_tasks == 0) {\n-        end_weak_tasks();\n+        begin_shutdown();\n     }\n }\n \n void\n-rust_kernel::unweaken_task(rust_port_id chan) {\n+rust_kernel::dec_weak_task_count() {\n     uintptr_t new_non_weak_tasks = sync::increment(non_weak_tasks);\n     KLOG_(\"New non-weak tasks %\" PRIdPTR, new_non_weak_tasks);\n-    {\n-        scoped_lock with(weak_task_lock);\n-        KLOG_(\"Unweakening task with channel %\" PRIdPTR, chan);\n-        std::vector<rust_port_id>::iterator iter =\n-            std::find(weak_task_chans.begin(), weak_task_chans.end(), chan);\n-        if (iter != weak_task_chans.end()) {\n-            weak_task_chans.erase(iter);\n-        }\n-    }\n }\n \n void\n-rust_kernel::end_weak_tasks() {\n-    std::vector<rust_port_id> chancopies;\n+rust_kernel::begin_shutdown() {\n     {\n-        scoped_lock with(weak_task_lock);\n-        chancopies = weak_task_chans;\n-        weak_task_chans.clear();\n-    }\n-    while (!chancopies.empty()) {\n-        rust_port_id chan = chancopies.back();\n-        chancopies.pop_back();\n-        KLOG_(\"Notifying weak task \" PRIdPTR, chan);\n-        uintptr_t token = 0;\n-        send_to_port(chan, &token);\n+        scoped_lock with(sched_lock);\n+        // FIXME #4410: This shouldn't be necessary, but because of\n+        // unweaken_task this may end up getting called multiple times.\n+        if (already_exiting) {\n+            return;\n+        } else {\n+            already_exiting = true;\n+        }\n     }\n+\n+    run_exit_functions();\n+    allow_scheduler_exit();\n }\n \n bool\n@@ -389,6 +415,47 @@ rust_kernel::send_to_port(rust_port_id chan, void *sptr) {\n     }\n }\n \n+void\n+rust_kernel::register_exit_function(spawn_fn runner, fn_env_pair *f) {\n+    scoped_lock with(at_exit_lock);\n+\n+    assert(!at_exit_started && \"registering at_exit function after exit\");\n+\n+    if (at_exit_runner) {\n+        assert(runner == at_exit_runner\n+               && \"there can be only one at_exit_runner\");\n+    }\n+\n+    at_exit_runner = runner;\n+    at_exit_fns.push_back(f);\n+}\n+\n+void\n+rust_kernel::run_exit_functions() {\n+    rust_task *task;\n+\n+    {\n+        scoped_lock with(at_exit_lock);\n+\n+        assert(!at_exit_started && \"running exit functions twice?\");\n+\n+        at_exit_started = true;\n+\n+        if (at_exit_runner == NULL) {\n+            return;\n+        }\n+\n+        rust_scheduler *sched = get_scheduler_by_id(main_sched_id());\n+        assert(sched);\n+        task = sched->create_task(NULL, \"at_exit\");\n+\n+        final_exit_fns.count = at_exit_fns.size();\n+        final_exit_fns.start = at_exit_fns.data();\n+    }\n+\n+    task->start(at_exit_runner, NULL, &final_exit_fns);\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "a7c6249e3dbf846efdf3d4687cac34af4aace60c", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -49,6 +49,7 @@\n #include \"memory_region.h\"\n #include \"rust_log.h\"\n #include \"rust_sched_reaper.h\"\n+#include \"rust_type.h\"\n #include \"util/hash_map.h\"\n \n class rust_scheduler;\n@@ -65,6 +66,13 @@ typedef intptr_t rust_port_id;\n \n typedef std::map<rust_sched_id, rust_scheduler*> sched_map;\n \n+// This is defined as a struct only because we need a single pointer to pass\n+// to the Rust function that runs the at_exit functions\n+struct exit_functions {\n+    size_t count;\n+    fn_env_pair **start;\n+};\n+\n class rust_kernel {\n     memory_region _region;\n     rust_log _log;\n@@ -81,7 +89,8 @@ class rust_kernel {\n     lock_and_signal rval_lock;\n     int rval;\n \n-    // Protects max_sched_id and sched_table, join_list, killed\n+    // Protects max_sched_id and sched_table, join_list, killed,\n+    // already_exiting\n     lock_and_signal sched_lock;\n     // The next scheduler id\n     rust_sched_id max_sched_id;\n@@ -94,8 +103,13 @@ class rust_kernel {\n     // task group fails). This propagates to all new schedulers and tasks\n     // created after it is set.\n     bool killed;\n+    bool already_exiting;\n+\n \n     rust_sched_reaper sched_reaper;\n+\n+    // The primary scheduler\n+    rust_sched_id main_scheduler;\n     // The single-threaded scheduler that uses the main thread\n     rust_sched_id osmain_scheduler;\n     // Runs the single-threaded scheduler that executes tasks\n@@ -104,21 +118,22 @@ class rust_kernel {\n \n     // An atomically updated count of the live, 'non-weak' tasks\n     uintptr_t non_weak_tasks;\n-    // Protects weak_task_chans\n-    lock_and_signal weak_task_lock;\n-    // A list of weak tasks that need to be told when to exit\n-    std::vector<rust_port_id> weak_task_chans;\n \n     rust_scheduler* get_scheduler_by_id_nolock(rust_sched_id id);\n-    void end_weak_tasks();\n+    void allow_scheduler_exit();\n+    void begin_shutdown();\n+\n+    lock_and_signal at_exit_lock;\n+    spawn_fn at_exit_runner;\n+    bool at_exit_started;\n+    std::vector<fn_env_pair*> at_exit_fns;\n+    exit_functions final_exit_fns;\n \n-    // Used to communicate with the process-side, global libuv loop\n-    uintptr_t global_loop_chan;\n-    // Used to serialize access to getenv/setenv\n-    uintptr_t global_env_chan;\n+    void run_exit_functions();\n \n public:\n     struct rust_env *env;\n+    uintptr_t global_data;\n \n     rust_kernel(rust_env *env);\n \n@@ -154,17 +169,17 @@ class rust_kernel {\n \n     void set_exit_status(int code);\n \n+    rust_sched_id main_sched_id() { return main_scheduler; }\n     rust_sched_id osmain_sched_id() { return osmain_scheduler; }\n \n     void register_task();\n     void unregister_task();\n-    void weaken_task(rust_port_id chan);\n-    void unweaken_task(rust_port_id chan);\n+    void inc_weak_task_count();\n+    void dec_weak_task_count();\n \n     bool send_to_port(rust_port_id chan, void *sptr);\n \n-    uintptr_t* get_global_loop() { return &global_loop_chan; }\n-    uintptr_t* get_global_env_chan() { return &global_env_chan; }\n+    void register_exit_function(spawn_fn runner, fn_env_pair *f);\n };\n \n template <typename T> struct kernel_owned {"}, {"sha": "2dc70088628f6aa9176d2e2e10c1df60961b5c59", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -513,15 +513,6 @@ rust_uv_ip6_port(struct sockaddr_in6* src) {\n     return ntohs(src->sin6_port);\n }\n \n-extern \"C\" uintptr_t*\n-rust_uv_get_kernel_global_chan_ptr() {\n-    uintptr_t* result = rust_get_current_task()->kernel->get_global_loop();\n-    rust_task* task = rust_get_current_task();\n-    LOG(task, stdlib, \"global loop: %lu\", (unsigned long int)result);\n-    LOG(task, stdlib,\"global loop val: %lu\", (unsigned long int)*result);\n-    return result;\n-}\n-\n extern \"C\" void*\n rust_uv_current_kernel_malloc(size_t size) {\n     return current_kernel_malloc(size, \"rust_uv_current_kernel_malloc\");"}, {"sha": "eb9db6c1d575563a16a6b4835b4794c35ebb24f1", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -61,8 +61,6 @@ rust_task_yield\n rust_task_is_unwinding\n rust_get_task\n rust_get_stack_segment\n-rust_task_weaken\n-rust_task_unweaken\n rust_log_str\n start_task\n vec_reserve_shared_actual\n@@ -158,7 +156,6 @@ rust_uv_get_data_for_req\n rust_uv_set_data_for_req\n rust_uv_get_base_from_buf\n rust_uv_get_len_from_buf\n-rust_uv_get_kernel_global_chan_ptr\n rust_uv_current_kernel_malloc\n rust_uv_current_kernel_free\n rust_uv_getaddrinfo\n@@ -174,7 +171,6 @@ rust_dbg_do_nothing\n rust_dbg_breakpoint\n rust_osmain_sched_id\n rust_compare_and_swap_ptr\n-rust_global_env_chan_ptr\n rust_port_take\n rust_port_drop\n rust_port_task\n@@ -210,3 +206,7 @@ linenoiseHistorySave\n linenoiseHistoryLoad\n rust_raw_thread_start\n rust_raw_thread_join_delete\n+rust_register_exit_function\n+rust_get_global_data_ptr\n+rust_inc_weak_task_count\n+rust_dec_weak_task_count\n\\ No newline at end of file"}, {"sha": "10b13d8757fa2a251339eae34b2c41fb2cf4b2ee", "filename": "src/test/run-pass/pipe-detect-term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -27,7 +27,7 @@ proto! oneshot (\n )\n \n fn main() {\n-    let iotask = uv::global_loop::get();\n+    let iotask = &uv::global_loop::get();\n     \n     pipes::spawn_service(oneshot::init, |p| { \n         match try_recv(move p) {"}, {"sha": "e138f2562aaefbaeb4a2a3c67fb354a4da875042", "filename": "src/test/run-pass/pipe-select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-select.rs?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -35,7 +35,7 @@ fn main() {\n     use oneshot::client::*;\n     use stream::client::*;\n \n-    let iotask = uv::global_loop::get();\n+    let iotask = &uv::global_loop::get();\n     \n     let c = pipes::spawn_service(stream::init, |p| { \n         error!(\"waiting for pipes\");"}, {"sha": "ae7e4e7fb0ca7d6fd06408adce78d6576a7f12a6", "filename": "src/test/run-pass/pipe-sleep.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef83945c1d76c9f2b9b0d087ceac65963087be7/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs?ref=1ef83945c1d76c9f2b9b0d087ceac65963087be7", "patch": "@@ -27,7 +27,7 @@ fn main() {\n \n     let c = pipes::spawn_service(oneshot::init, |p| { recv(move p); });\n \n-    let iotask = uv::global_loop::get();\n+    let iotask = &uv::global_loop::get();\n     sleep(iotask, 500);\n     \n     signal(move c);"}]}