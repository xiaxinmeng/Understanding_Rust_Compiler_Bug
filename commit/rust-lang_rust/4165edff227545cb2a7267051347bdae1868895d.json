{"sha": "4165edff227545cb2a7267051347bdae1868895d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNjVlZGZmMjI3NTQ1Y2IyYTcyNjcwNTEzNDdiZGFlMTg2ODg5NWQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-30T22:53:06Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-02T16:56:28Z"}, "message": "rustc: Implement translation of pattern matching for tuple structs and unit-like structs. r=nmatsakis", "tree": {"sha": "b8fc5787c1183ed97e84479dbccba82c00d8adad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8fc5787c1183ed97e84479dbccba82c00d8adad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4165edff227545cb2a7267051347bdae1868895d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4165edff227545cb2a7267051347bdae1868895d", "html_url": "https://github.com/rust-lang/rust/commit/4165edff227545cb2a7267051347bdae1868895d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4165edff227545cb2a7267051347bdae1868895d/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "106f9976ab1baec06af41f7009f539cd8371a840", "url": "https://api.github.com/repos/rust-lang/rust/commits/106f9976ab1baec06af41f7009f539cd8371a840", "html_url": "https://github.com/rust-lang/rust/commit/106f9976ab1baec06af41f7009f539cd8371a840"}], "stats": {"total": 336, "additions": 257, "deletions": 79}, "files": [{"sha": "23f0d9edbfae2b8d28a12966e856c9858959a69d", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4165edff227545cb2a7267051347bdae1868895d/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4165edff227545cb2a7267051347bdae1868895d/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=4165edff227545cb2a7267051347bdae1868895d", "patch": "@@ -441,7 +441,8 @@ impl gather_loan_ctxt {\n                   alt_id: ast::node_id) {\n         do self.bccx.cat_pattern(discr_cmt, root_pat) |cmt, pat| {\n             match pat.node {\n-              ast::pat_ident(bm, _, _) if !self.pat_is_variant(pat) => {\n+              ast::pat_ident(bm, _, _)\n+                    if !self.pat_is_variant_or_struct(pat) => {\n                 match bm {\n                   ast::bind_by_value | ast::bind_by_move => {\n                     // copying does not borrow anything, so no check\n@@ -492,8 +493,8 @@ impl gather_loan_ctxt {\n         }\n     }\n \n-    fn pat_is_variant(&self, pat: @ast::pat) -> bool {\n-        pat_util::pat_is_variant(self.bccx.tcx.def_map, pat)\n+    fn pat_is_variant_or_struct(&self, pat: @ast::pat) -> bool {\n+        pat_util::pat_is_variant_or_struct(self.bccx.tcx.def_map, pat)\n     }\n }\n "}, {"sha": "9196a0b22caf8f6ce8068245f4757155dc93f811", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4165edff227545cb2a7267051347bdae1868895d/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4165edff227545cb2a7267051347bdae1868895d/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=4165edff227545cb2a7267051347bdae1868895d", "patch": "@@ -7,7 +7,7 @@ use syntax::codemap::span;\n use std::map::HashMap;\n \n export pat_binding_ids, pat_bindings, pat_id_map, PatIdMap;\n-export pat_is_variant, pat_is_binding_or_wild;\n+export pat_is_variant_or_struct, pat_is_binding_or_wild;\n \n type PatIdMap = std::map::HashMap<ident, node_id>;\n \n@@ -21,20 +21,21 @@ fn pat_id_map(dm: resolve::DefMap, pat: @pat) -> PatIdMap {\n     return map;\n }\n \n-fn pat_is_variant(dm: resolve::DefMap, pat: @pat) -> bool {\n+fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: @pat) -> bool {\n     match pat.node {\n-      pat_enum(_, _) => true,\n-      pat_ident(_, _, None) | pat_struct(*) => match dm.find(pat.id) {\n-        Some(def_variant(_, _)) => true,\n+        pat_enum(_, _) | pat_ident(_, _, None) | pat_struct(*) => {\n+            match dm.find(pat.id) {\n+                Some(def_variant(*)) | Some(def_class(*)) => true,\n+                _ => false\n+            }\n+        }\n         _ => false\n-      },\n-      _ => false\n     }\n }\n \n fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: @pat) -> bool {\n     match pat.node {\n-        pat_ident(*) => !pat_is_variant(dm, pat),\n+        pat_ident(*) => !pat_is_variant_or_struct(dm, pat),\n         pat_wild => true,\n         _ => false\n     }\n@@ -44,7 +45,8 @@ fn pat_bindings(dm: resolve::DefMap, pat: @pat,\n                 it: fn(binding_mode, node_id, span, @path)) {\n     do walk_pat(pat) |p| {\n         match p.node {\n-          pat_ident(binding_mode, pth, _) if !pat_is_variant(dm, p) => {\n+          pat_ident(binding_mode, pth, _)\n+                if !pat_is_variant_or_struct(dm, p) => {\n             it(binding_mode, p.id, p.span, pth);\n           }\n           _ => {}"}, {"sha": "8ebebfa1121668ceeb72619d8ca4f1dce252128b", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4165edff227545cb2a7267051347bdae1868895d/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4165edff227545cb2a7267051347bdae1868895d/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=4165edff227545cb2a7267051347bdae1868895d", "patch": "@@ -288,10 +288,10 @@ impl AllowCapturingSelfFlag : cmp::Eq {\n     pure fn ne(other: &AllowCapturingSelfFlag) -> bool { !self.eq(other) }\n }\n \n-enum EnumVariantOrConstResolution {\n-    FoundEnumVariant(def),\n+enum BareIdentifierPatternResolution {\n+    FoundStructOrEnumVariant(def),\n     FoundConst,\n-    EnumVariantOrConstNotFound\n+    BareIdentifierPatternUnresolved\n }\n \n // Specifies how duplicates should be handled when adding a child item if\n@@ -4187,28 +4187,31 @@ impl Resolver {\n                         if !path.global && path.idents.len() == 1u => {\n \n                     // The meaning of pat_ident with no type parameters\n-                    // depends on whether an enum variant with that name is in\n-                    // scope. The probing lookup has to be careful not to emit\n-                    // spurious errors. Only matching patterns (match) can\n-                    // match nullary variants. For binding patterns (let),\n-                    // matching such a variant is simply disallowed (since\n-                    // it's rarely what you want).\n+                    // depends on whether an enum variant or unit-like struct\n+                    // with that name is in scope. The probing lookup has to\n+                    // be careful not to emit spurious errors. Only matching\n+                    // patterns (match) can match nullary variants or\n+                    // unit-like structs. For binding patterns (let), matching\n+                    // such a value is simply disallowed (since it's rarely\n+                    // what you want).\n \n                     let ident = path.idents[0];\n \n-                    match self.resolve_enum_variant_or_const(ident) {\n-                        FoundEnumVariant(def) if mode == RefutableMode => {\n+                    match self.resolve_bare_identifier_pattern(ident) {\n+                        FoundStructOrEnumVariant(def)\n+                                if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `%s` to \\\n-                                    enum variant\",\n+                                    struct or enum variant\",\n                                     self.session.str_of(ident));\n \n                             self.record_def(pattern.id, def);\n                         }\n-                        FoundEnumVariant(_) => {\n+                        FoundStructOrEnumVariant(_) => {\n                             self.session.span_err(pattern.span,\n                                                   fmt!(\"declaration of `%s` \\\n                                                         shadows an enum \\\n-                                                        that's in scope\",\n+                                                        variant or unit-like \\\n+                                                        struct in scope\",\n                                                         self.session\n                                                         .str_of(ident)));\n                         }\n@@ -4218,7 +4221,7 @@ impl Resolver {\n                                                    conflicts with a constant \\\n                                                    in scope\");\n                         }\n-                        EnumVariantOrConstNotFound => {\n+                        BareIdentifierPatternUnresolved => {\n                             debug!(\"(resolving pattern) binding `%s`\",\n                                    self.session.str_of(ident));\n \n@@ -4349,13 +4352,11 @@ impl Resolver {\n         }\n     }\n \n-    fn resolve_enum_variant_or_const(name: ident)\n-                                  -> EnumVariantOrConstResolution {\n-\n+    fn resolve_bare_identifier_pattern(name: ident)\n+                                    -> BareIdentifierPatternResolution {\n         match self.resolve_item_in_lexical_scope(self.current_module,\n-                                               name,\n-                                               ValueNS) {\n-\n+                                                 name,\n+                                                 ValueNS) {\n             Success(target) => {\n                 match target.bindings.value_def {\n                     None => {\n@@ -4364,14 +4365,14 @@ impl Resolver {\n                     }\n                     Some(def) => {\n                         match def.def {\n-                            def @ def_variant(*) => {\n-                                return FoundEnumVariant(def);\n+                            def @ def_variant(*) | def @ def_class(*) => {\n+                                return FoundStructOrEnumVariant(def);\n                             }\n                             def_const(*) => {\n                                 return FoundConst;\n                             }\n                             _ => {\n-                                return EnumVariantOrConstNotFound;\n+                                return BareIdentifierPatternUnresolved;\n                             }\n                         }\n                     }\n@@ -4383,7 +4384,7 @@ impl Resolver {\n             }\n \n             Failed => {\n-                return EnumVariantOrConstNotFound;\n+                return BareIdentifierPatternUnresolved;\n             }\n         }\n     }"}, {"sha": "0908eae34dcd77a9112ab1bc0b75188c17bc5460", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 167, "deletions": 30, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/4165edff227545cb2a7267051347bdae1868895d/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4165edff227545cb2a7267051347bdae1868895d/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=4165edff227545cb2a7267051347bdae1868895d", "patch": "@@ -154,16 +154,25 @@ use util::common::indenter;\n \n fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n \n+// An option identifying a literal: either a unit-like struct or an\n+// expression.\n+enum Lit {\n+    UnitLikeStructLit(ast::node_id),    // the node ID of the pattern\n+    ExprLit(@ast::expr)\n+}\n+\n // An option identifying a branch (either a literal, a enum variant or a\n // range)\n enum Opt {\n-    lit(@ast::expr),\n+    lit(Lit),\n     var(/* disr val */int, /* variant dids */{enm: def_id, var: def_id}),\n     range(@ast::expr, @ast::expr)\n }\n fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n     match (*a, *b) {\n-      (lit(a), lit(b)) => const_eval::compare_lit_exprs(tcx, a, b) == 0,\n+      (lit(ExprLit(a)), lit(ExprLit(b))) =>\n+            const_eval::compare_lit_exprs(tcx, a, b) == 0,\n+      (lit(UnitLikeStructLit(a)), lit(UnitLikeStructLit(b))) => a == b,\n       (range(a1, a2), range(b1, b2)) => {\n         const_eval::compare_lit_exprs(tcx, a1, b1) == 0 &&\n         const_eval::compare_lit_exprs(tcx, a2, b2) == 0\n@@ -182,10 +191,15 @@ fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     match *o {\n-        lit(lit_expr) => {\n+        lit(ExprLit(lit_expr)) => {\n             let datumblock = expr::trans_to_datum(bcx, lit_expr);\n             return single_result(datumblock.to_result());\n         }\n+        lit(UnitLikeStructLit(pat_id)) => {\n+            let struct_ty = ty::node_id_to_type(bcx.tcx(), pat_id);\n+            let datumblock = datum::scratch_datum(bcx, struct_ty, true);\n+            return single_result(datumblock.to_result(bcx));\n+        }\n         var(disr_val, _) => {\n             return single_result(rslt(bcx, C_int(ccx, disr_val)));\n         }\n@@ -197,12 +211,23 @@ fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n }\n \n fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> Opt {\n-    let vdef = ast_util::variant_def_ids(tcx.def_map.get(pat_id));\n-    let variants = ty::enum_variants(tcx, vdef.enm);\n-    for vec::each(*variants) |v| {\n-        if vdef.var == v.id { return var(v.disr_val, vdef); }\n+    match tcx.def_map.get(pat_id) {\n+        ast::def_variant(enum_id, var_id) => {\n+            let variants = ty::enum_variants(tcx, enum_id);\n+            for vec::each(*variants) |v| {\n+                if var_id == v.id {\n+                    return var(v.disr_val, {enm: enum_id, var: var_id});\n+                }\n+            }\n+            core::util::unreachable();\n+        }\n+        ast::def_class(_) => {\n+            return lit(UnitLikeStructLit(pat_id));\n+        }\n+        _ => {\n+            tcx.sess.bug(~\"non-variant or struct in variant_opt()\");\n+        }\n     }\n-    core::util::unreachable();\n }\n \n enum TransBindingMode {\n@@ -328,7 +353,7 @@ fn enter_match(bcx: block, dm: DefMap, m: &[@Match/&r],\n                 let self = br.pats[col];\n                 match self.node {\n                     ast::pat_ident(_, path, None) => {\n-                        if !pat_is_variant(dm, self) {\n+                        if !pat_is_variant_or_struct(dm, self) {\n                             let binding_info =\n                                 br.data.bindings_map.get(path_to_ident(path));\n                             Store(bcx, val, binding_info.llmatch);\n@@ -363,7 +388,8 @@ fn enter_default(bcx: block, dm: DefMap, m: &[@Match/&r],\n         match p.node {\n           ast::pat_wild | ast::pat_rec(_, _) | ast::pat_tup(_) |\n           ast::pat_struct(*) => Some(~[]),\n-          ast::pat_ident(_, _, None) if !pat_is_variant(dm, p) => Some(~[]),\n+          ast::pat_ident(_, _, None)\n+                if !pat_is_variant_or_struct(dm, p) => Some(~[]),\n           _ => None\n         }\n     }\n@@ -417,15 +443,16 @@ fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n                     None\n                 }\n             }\n-            ast::pat_ident(_, _, None) if pat_is_variant(tcx.def_map, p) => {\n+            ast::pat_ident(_, _, None)\n+                    if pat_is_variant_or_struct(tcx.def_map, p) => {\n                 if opt_eq(tcx, &variant_opt(tcx, p.id), opt) {\n                     Some(~[])\n                 } else {\n                     None\n                 }\n             }\n             ast::pat_lit(l) => {\n-                if opt_eq(tcx, &lit(l), opt) {Some(~[])} else {None}\n+                if opt_eq(tcx, &lit(ExprLit(l)), opt) {Some(~[])} else {None}\n             }\n             ast::pat_range(l1, l2) => {\n                 if opt_eq(tcx, &range(l1, l2), opt) {Some(~[])} else {None}\n@@ -522,6 +549,29 @@ fn enter_tup(bcx: block, dm: DefMap, m: &[@Match/&r],\n     }\n }\n \n+fn enter_tuple_struct(bcx: block, dm: DefMap, m: &[@Match/&r], col: uint,\n+                      val: ValueRef, n_elts: uint)\n+    -> ~[@Match/&r]\n+{\n+    debug!(\"enter_tuple_struct(bcx=%s, m=%s, col=%u, val=%?)\",\n+           bcx.to_str(),\n+           matches_to_str(bcx, m),\n+           col,\n+           bcx.val_str(val));\n+    let _indenter = indenter();\n+\n+    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    do enter_match(bcx, dm, m, col, val) |p| {\n+        match p.node {\n+            ast::pat_enum(_, Some(elts)) => Some(elts),\n+            _ => {\n+                assert_is_binding_or_wild(bcx, p);\n+                Some(vec::from_elem(n_elts, dummy))\n+            }\n+        }\n+    }\n+}\n+\n fn enter_box(bcx: block, dm: DefMap, m: &[@Match/&r],\n              col: uint, val: ValueRef)\n     -> ~[@Match/&r]\n@@ -597,6 +647,9 @@ fn enter_region(bcx: block, dm: DefMap, m: &[@Match/&r],\n     }\n }\n \n+// Returns the options in one column of matches. An option is something that\n+// needs to be conditionally matched at runtime; for example, the discriminant\n+// on a set of enum variants or a literal.\n fn get_options(ccx: @crate_ctxt, m: &[@Match], col: uint) -> ~[Opt] {\n     fn add_to_set(tcx: ty::ctxt, set: &DVec<Opt>, val: Opt) {\n         if set.any(|l| opt_eq(tcx, l, &val)) {return;}\n@@ -606,18 +659,40 @@ fn get_options(ccx: @crate_ctxt, m: &[@Match], col: uint) -> ~[Opt] {\n     let found = DVec();\n     for vec::each(m) |br| {\n         let cur = br.pats[col];\n-        if pat_is_variant(ccx.tcx.def_map, cur) {\n-            add_to_set(ccx.tcx, &found, variant_opt(ccx.tcx, cur.id));\n-        } else {\n-            match cur.node {\n-                ast::pat_lit(l) => {\n-                    add_to_set(ccx.tcx, &found, lit(l));\n+        match cur.node {\n+            ast::pat_lit(l) => {\n+                add_to_set(ccx.tcx, &found, lit(ExprLit(l)));\n+            }\n+            ast::pat_ident(*) => {\n+                // This is one of: an enum variant, a unit-like struct, or a\n+                // variable binding.\n+                match ccx.tcx.def_map.find(cur.id) {\n+                    Some(ast::def_variant(*)) => {\n+                        add_to_set(ccx.tcx, &found,\n+                                   variant_opt(ccx.tcx, cur.id));\n+                    }\n+                    Some(ast::def_class(*)) => {\n+                        add_to_set(ccx.tcx, &found,\n+                                   lit(UnitLikeStructLit(cur.id)));\n+                    }\n+                    _ => {}\n                 }\n-                ast::pat_range(l1, l2) => {\n-                    add_to_set(ccx.tcx, &found, range(l1, l2));\n+            }\n+            ast::pat_enum(*) | ast::pat_struct(*) => {\n+                // This could be one of: a tuple-like enum variant, a\n+                // struct-like enum variant, or a struct.\n+                match ccx.tcx.def_map.find(cur.id) {\n+                    Some(ast::def_variant(*)) => {\n+                        add_to_set(ccx.tcx, &found,\n+                                   variant_opt(ccx.tcx, cur.id));\n+                    }\n+                    _ => {}\n                 }\n-                _ => ()\n             }\n+            ast::pat_range(l1, l2) => {\n+                add_to_set(ccx.tcx, &found, range(l1, l2));\n+            }\n+            _ => {}\n         }\n     }\n     return dvec::unwrap(move found);\n@@ -733,6 +808,21 @@ fn any_tup_pat(m: &[@Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_tup(_))\n }\n \n+fn any_tuple_struct_pat(bcx: block, m: &[@Match], col: uint) -> bool {\n+    vec::any(m, |br| {\n+        let pat = br.pats[col];\n+        match pat.node {\n+            ast::pat_enum(_, Some(_)) => {\n+                match bcx.tcx().def_map.find(pat.id) {\n+                    Some(ast::def_class(*)) => true,\n+                    _ => false\n+                }\n+            }\n+            _ => false\n+        }\n+    })\n+}\n+\n type mk_fail = fn@() -> BasicBlockRef;\n \n fn pick_col(m: &[@Match]) -> uint {\n@@ -1028,6 +1118,29 @@ fn compile_submatch(bcx: block,\n         return;\n     }\n \n+    if any_tuple_struct_pat(bcx, m, col) {\n+        let struct_ty = node_id_type(bcx, pat_id);\n+        let struct_element_count;\n+        match ty::get(struct_ty).sty {\n+            ty::ty_class(struct_id, _) => {\n+                struct_element_count =\n+                    ty::lookup_class_fields(tcx, struct_id).len();\n+            }\n+            _ => {\n+                ccx.sess.bug(~\"non-struct type in tuple struct pattern\");\n+            }\n+        }\n+\n+        let llstructvals = vec::from_fn(\n+            struct_element_count, |i| GEPi(bcx, val, struct_field(i)));\n+        compile_submatch(bcx,\n+                         enter_tuple_struct(bcx, dm, m, col, val,\n+                                            struct_element_count),\n+                         vec::append(llstructvals, vals_left),\n+                         chk);\n+        return;\n+    }\n+\n     // Unbox in case of a box field\n     if any_box_pat(m, col) {\n         let llbox = Load(bcx, val);\n@@ -1316,7 +1429,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n     // Necessary since bind_irrefutable_pat is called outside trans_alt\n     match pat.node {\n         ast::pat_ident(_, _,inner) => {\n-            if pat_is_variant(bcx.tcx().def_map, pat) {\n+            if pat_is_variant_or_struct(bcx.tcx().def_map, pat) {\n                 return bcx;\n             }\n \n@@ -1335,15 +1448,39 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n             for inner.each |inner_pat| {\n                 bcx = bind_irrefutable_pat(bcx, *inner_pat, val, true);\n             }\n-      }\n+        }\n         ast::pat_enum(_, sub_pats) => {\n-            let pat_def = ccx.tcx.def_map.get(pat.id);\n-            let vdefs = ast_util::variant_def_ids(pat_def);\n-            let args = extract_variant_args(bcx, pat.id, vdefs, val);\n-            for sub_pats.each |sub_pat| {\n-                for vec::eachi(args.vals) |i, argval| {\n-                    bcx = bind_irrefutable_pat(bcx, sub_pat[i],\n-                                               *argval, make_copy);\n+            match bcx.tcx().def_map.find(pat.id) {\n+                Some(ast::def_variant(*)) => {\n+                    let pat_def = ccx.tcx.def_map.get(pat.id);\n+                    let vdefs = ast_util::variant_def_ids(pat_def);\n+                    let args = extract_variant_args(bcx, pat.id, vdefs, val);\n+                    for sub_pats.each |sub_pat| {\n+                        for vec::eachi(args.vals) |i, argval| {\n+                            bcx = bind_irrefutable_pat(bcx,\n+                                                       sub_pat[i],\n+                                                       *argval,\n+                                                       make_copy);\n+                        }\n+                    }\n+                }\n+                Some(ast::def_class(*)) => {\n+                    match sub_pats {\n+                        None => {\n+                            // This is a unit-like struct. Nothing to do here.\n+                        }\n+                        Some(elems) => {\n+                            // This is the tuple variant case.\n+                            for vec::eachi(elems) |i, elem| {\n+                                let fldptr = GEPi(bcx, val, struct_field(i));\n+                                bcx = bind_irrefutable_pat(bcx, *elem, fldptr,\n+                                                           make_copy);\n+                            }\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    // Nothing to do here.\n                 }\n             }\n         }"}, {"sha": "727958e3e5f8cc55259d7e6c167acb277f3b0e41", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4165edff227545cb2a7267051347bdae1868895d/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4165edff227545cb2a7267051347bdae1868895d/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4165edff227545cb2a7267051347bdae1868895d", "patch": "@@ -1893,12 +1893,14 @@ fn trans_struct_def(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n \n         // If this is a tuple-like struct, translate the constructor.\n         match struct_def.ctor_id {\n-            None => {}\n-            Some(ctor_id) => {\n+            // We only need to translate a constructor if there are fields;\n+            // otherwise this is a unit-like struct.\n+            Some(ctor_id) if struct_def.fields.len() > 0 => {\n                 let llfndecl = get_item_val(ccx, ctor_id);\n                 trans_tuple_struct(ccx, struct_def.fields, ctor_id, None,\n                                    llfndecl);\n             }\n+            Some(_) | None => {}\n         }\n     }\n "}, {"sha": "519aa9c44ecd8a451912722898bba51ef83f4387", "filename": "src/rustc/middle/trans/expr.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4165edff227545cb2a7267051347bdae1868895d/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4165edff227545cb2a7267051347bdae1868895d/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=4165edff227545cb2a7267051347bdae1868895d", "patch": "@@ -664,6 +664,11 @@ fn trans_def_dps_unadjusted(bcx: block, ref_expr: @ast::expr,\n                 return bcx;\n             }\n         }\n+        ast::def_class(*) => {\n+            // Nothing to do here.\n+            // XXX: May not be true in the case of classes with destructors.\n+            return bcx;\n+        }\n         _ => {\n             bcx.tcx().sess.span_bug(ref_expr.span, fmt!(\n                 \"Non-DPS def %? referened by %s\","}, {"sha": "8767c4c6253a6e450820c07ea0415190acd38265", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4165edff227545cb2a7267051347bdae1868895d/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4165edff227545cb2a7267051347bdae1868895d/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=4165edff227545cb2a7267051347bdae1868895d", "patch": "@@ -2980,7 +2980,7 @@ fn expr_kind(tcx: ctxt,\n         ast::expr_path(*) => {\n             match resolve_expr(tcx, expr) {\n                 ast::def_fn(*) | ast::def_static_method(*) |\n-                ast::def_variant(*) => RvalueDpsExpr,\n+                ast::def_variant(*) | ast::def_class(*) => RvalueDpsExpr,\n \n                 // Note: there is actually a good case to be made that\n                 // def_args, particularly those of immediate type, ought to"}, {"sha": "d4df07f7eb89734544e236643cf3ac3697aa8dbf", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4165edff227545cb2a7267051347bdae1868895d/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4165edff227545cb2a7267051347bdae1868895d/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=4165edff227545cb2a7267051347bdae1868895d", "patch": "@@ -48,7 +48,7 @@ use syntax::visit;\n use metadata::csearch;\n use util::common::{block_query, loop_query};\n use syntax::codemap::span;\n-use pat_util::{pat_is_variant, pat_id_map, PatIdMap};\n+use pat_util::{pat_id_map, PatIdMap};\n use middle::ty;\n use middle::ty::{arg, field, node_type_table, mk_nil, ty_param_bounds_and_ty};\n use middle::ty::{ty_param_substs_and_ty, vstore_uniq};"}, {"sha": "b29e85643f11cec0709bd13d951f4938eb584535", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4165edff227545cb2a7267051347bdae1868895d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4165edff227545cb2a7267051347bdae1868895d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=4165edff227545cb2a7267051347bdae1868895d", "patch": "@@ -376,7 +376,8 @@ fn check_fn(ccx: @crate_ctxt,\n         let visit_pat = fn@(p: @ast::pat, &&e: (), v: visit::vt<()>) {\n             match p.node {\n               ast::pat_ident(_, path, _)\n-                  if !pat_util::pat_is_variant(fcx.ccx.tcx.def_map, p) => {\n+                  if !pat_util::pat_is_variant_or_struct(fcx.ccx.tcx.def_map,\n+                                                         p) => {\n                 assign(p.span, p.id, None);\n                 debug!(\"Pattern binding %s is assigned to %s\",\n                        tcx.sess.str_of(path.idents[0]),\n@@ -467,10 +468,6 @@ fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n     for struct_def.methods.each |m| {\n         check_method(ccx, *m, self_ty, local_def(id));\n     }\n-    // Check that there's at least one field\n-    if struct_def.fields.len() < 1u {\n-        ccx.tcx.sess.span_err(span, ~\"a struct must have at least one field\");\n-    }\n     // Check that the class is instantiable\n     check_instantiable(ccx.tcx, span, id);\n }"}, {"sha": "41be34a713cfec57e1333894f58f680819caf0dc", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4165edff227545cb2a7267051347bdae1868895d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4165edff227545cb2a7267051347bdae1868895d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=4165edff227545cb2a7267051347bdae1868895d", "patch": "@@ -1,6 +1,6 @@\n use syntax::print::pprust;\n use syntax::ast_util::{walk_pat};\n-use pat_util::{pat_is_variant};\n+use pat_util::{pat_is_variant_or_struct};\n \n fn check_alt(fcx: @fn_ctxt,\n              expr: @ast::expr,\n@@ -74,7 +74,7 @@ fn check_legality_of_move_bindings(fcx: @fn_ctxt,\n     if !any_by_move { return; } // pointless micro-optimization\n     for pats.each |pat| {\n         do walk_pat(*pat) |p| {\n-            if !pat_is_variant(def_map, p) {\n+            if !pat_is_variant_or_struct(def_map, p) {\n                 match p.node {\n                     ast::pat_ident(ast::bind_by_move, _, sub) => {\n                         // check legality of moving out of the enum\n@@ -391,7 +391,8 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         }\n         fcx.write_ty(pat.id, b_ty);\n       }\n-      ast::pat_ident(bm, name, sub) if !pat_is_variant(tcx.def_map, pat) => {\n+      ast::pat_ident(bm, name, sub)\n+            if !pat_is_variant_or_struct(tcx.def_map, pat) => {\n         let vid = lookup_local(fcx, pat.span, pat.id);\n         let mut typ = ty::mk_var(tcx, vid);\n "}, {"sha": "cffd9d828cbb1e6f9cf96a164fb753cc84ef262b", "filename": "src/test/run-pass/tuple-struct-destructuring.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4165edff227545cb2a7267051347bdae1868895d/src%2Ftest%2Frun-pass%2Ftuple-struct-destructuring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4165edff227545cb2a7267051347bdae1868895d/src%2Ftest%2Frun-pass%2Ftuple-struct-destructuring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftuple-struct-destructuring.rs?ref=4165edff227545cb2a7267051347bdae1868895d", "patch": "@@ -0,0 +1,10 @@\n+struct Foo(int, int);\n+\n+fn main() {\n+    let x = Foo(1, 2);\n+    let Foo(y, z) = x;\n+    io::println(fmt!(\"%d %d\", y, z));\n+    assert y == 1;\n+    assert z == 2;\n+}\n+"}, {"sha": "923e8cbc09d5df377cf98c12a1093e7f8a17eaa3", "filename": "src/test/run-pass/tuple-struct-matching.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4165edff227545cb2a7267051347bdae1868895d/src%2Ftest%2Frun-pass%2Ftuple-struct-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4165edff227545cb2a7267051347bdae1868895d/src%2Ftest%2Frun-pass%2Ftuple-struct-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftuple-struct-matching.rs?ref=4165edff227545cb2a7267051347bdae1868895d", "patch": "@@ -0,0 +1,13 @@\n+struct Foo(int, int);\n+\n+fn main() {\n+    let x = Foo(1, 2);\n+    match x {\n+        Foo(a, b) => {\n+            assert a == 1;\n+            assert b == 2;\n+            io::println(fmt!(\"%d %d\", a, b));\n+        }\n+    }\n+}\n+"}, {"sha": "e5eb50a8afd163e2d36c41ae71d0ad6299904bbd", "filename": "src/test/run-pass/unit-like-struct.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4165edff227545cb2a7267051347bdae1868895d/src%2Ftest%2Frun-pass%2Funit-like-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4165edff227545cb2a7267051347bdae1868895d/src%2Ftest%2Frun-pass%2Funit-like-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funit-like-struct.rs?ref=4165edff227545cb2a7267051347bdae1868895d", "patch": "@@ -0,0 +1,9 @@\n+struct Foo;\n+\n+fn main() {\n+    let x: Foo = Foo;\n+    match x {\n+        Foo => { io::println(\"hi\"); }\n+    }\n+}\n+"}]}