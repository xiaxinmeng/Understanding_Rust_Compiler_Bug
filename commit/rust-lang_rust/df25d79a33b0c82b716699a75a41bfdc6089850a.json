{"sha": "df25d79a33b0c82b716699a75a41bfdc6089850a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmMjVkNzlhMzNiMGM4MmI3MTY2OTlhNzVhNDFiZmRjNjA4OTg1MGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-12T17:24:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-12T17:24:01Z"}, "message": "Auto merge of #59733 - cramertj:wake-by-ref, r=withoutboats\n\nFinal (one can only hope) futures_api adjustments\n\nBased on https://github.com/rust-lang/rust/pull/59119 -- this change is only the latter two commits.\ncc https://github.com/rust-lang/rust/issues/59725\n\nr? @withoutboats", "tree": {"sha": "a71c1f8295e13d2277258758fecdcba81becc25d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a71c1f8295e13d2277258758fecdcba81becc25d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df25d79a33b0c82b716699a75a41bfdc6089850a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df25d79a33b0c82b716699a75a41bfdc6089850a", "html_url": "https://github.com/rust-lang/rust/commit/df25d79a33b0c82b716699a75a41bfdc6089850a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df25d79a33b0c82b716699a75a41bfdc6089850a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a612b2348212d84fa0b839a4c18e4a13fafaf05", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a612b2348212d84fa0b839a4c18e4a13fafaf05", "html_url": "https://github.com/rust-lang/rust/commit/9a612b2348212d84fa0b839a4c18e4a13fafaf05"}, {"sha": "6786fa7795880a899d85058831a1fd719edb43e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6786fa7795880a899d85058831a1fd719edb43e1", "html_url": "https://github.com/rust-lang/rust/commit/6786fa7795880a899d85058831a1fd719edb43e1"}], "stats": {"total": 102, "additions": 78, "deletions": 24}, "files": [{"sha": "006cbbb6ce6bddfc069568446a254cb1ea4f07d6", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 49, "deletions": 11, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/df25d79a33b0c82b716699a75a41bfdc6089850a/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df25d79a33b0c82b716699a75a41bfdc6089850a/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=df25d79a33b0c82b716699a75a41bfdc6089850a", "patch": "@@ -72,10 +72,18 @@ pub struct RawWakerVTable {\n     /// This function will be called when `wake` is called on the [`Waker`].\n     /// It must wake up the task associated with this [`RawWaker`].\n     ///\n-    /// The implemention of this function must not consume the provided data\n-    /// pointer.\n+    /// The implementation of this function must make sure to release any\n+    /// resources that are associated with this instance of a [`RawWaker`] and\n+    /// associated task.\n     wake: unsafe fn(*const ()),\n \n+    /// This function will be called when `wake_by_ref` is called on the [`Waker`].\n+    /// It must wake up the task associated with this [`RawWaker`].\n+    ///\n+    /// This function is similar to `wake`, but must not consume the provided data\n+    /// pointer.\n+    wake_by_ref: unsafe fn(*const ()),\n+\n     /// This function gets called when a [`RawWaker`] gets dropped.\n     ///\n     /// The implementation of this function must make sure to release any\n@@ -85,8 +93,8 @@ pub struct RawWakerVTable {\n }\n \n impl RawWakerVTable {\n-    /// Creates a new `RawWakerVTable` from the provided `clone`, `wake`, and\n-    /// `drop` functions.\n+    /// Creates a new `RawWakerVTable` from the provided `clone`, `wake`,\n+    /// `wake_by_ref`, and `drop` functions.\n     ///\n     /// # `clone`\n     ///\n@@ -103,7 +111,16 @@ impl RawWakerVTable {\n     /// This function will be called when `wake` is called on the [`Waker`].\n     /// It must wake up the task associated with this [`RawWaker`].\n     ///\n-    /// The implemention of this function must not consume the provided data\n+    /// The implementation of this function must make sure to release any\n+    /// resources that are associated with this instance of a [`RawWaker`] and\n+    /// associated task.\n+    ///\n+    /// # `wake_by_ref`\n+    ///\n+    /// This function will be called when `wake_by_ref` is called on the [`Waker`].\n+    /// It must wake up the task associated with this [`RawWaker`].\n+    ///\n+    /// This function is similar to `wake`, but must not consume the provided data\n     /// pointer.\n     ///\n     /// # `drop`\n@@ -120,11 +137,13 @@ impl RawWakerVTable {\n     pub const fn new(\n         clone: unsafe fn(*const ()) -> RawWaker,\n         wake: unsafe fn(*const ()),\n+        wake_by_ref: unsafe fn(*const ()),\n         drop: unsafe fn(*const ()),\n     ) -> Self {\n         Self {\n             clone,\n             wake,\n+            wake_by_ref,\n             drop,\n         }\n     }\n@@ -187,14 +206,33 @@ unsafe impl Sync for Waker {}\n impl Waker {\n     /// Wake up the task associated with this `Waker`.\n     #[inline]\n-    pub fn wake(&self) {\n+    pub fn wake(self) {\n         // The actual wakeup call is delegated through a virtual function call\n         // to the implementation which is defined by the executor.\n+        let wake = self.waker.vtable.wake;\n+        let data = self.waker.data;\n \n-        // SAFETY: This is safe because `Waker::new_unchecked` is the only way\n+        // Don't call `drop` -- the waker will be consumed by `wake`.\n+        crate::mem::forget(self);\n+\n+        // SAFETY: This is safe because `Waker::from_raw` is the only way\n         // to initialize `wake` and `data` requiring the user to acknowledge\n         // that the contract of `RawWaker` is upheld.\n-        unsafe { (self.waker.vtable.wake)(self.waker.data) }\n+        unsafe { (wake)(data) };\n+    }\n+\n+    /// Wake up the task associated with this `Waker` without consuming the `Waker`.\n+    ///\n+    /// This is similar to `wake`, but may be slightly less efficient in the case\n+    /// where an owned `Waker` is available. This method should be preferred to\n+    /// calling `waker.clone().wake()`.\n+    #[inline]\n+    pub fn wake_by_ref(&self) {\n+        // The actual wakeup call is delegated through a virtual function call\n+        // to the implementation which is defined by the executor.\n+\n+        // SAFETY: see `wake`\n+        unsafe { (self.waker.vtable.wake_by_ref)(self.waker.data) }\n     }\n \n     /// Returns `true` if this `Waker` and another `Waker` have awoken the same task.\n@@ -215,7 +253,7 @@ impl Waker {\n     /// in [`RawWaker`]'s and [`RawWakerVTable`]'s documentation is not upheld.\n     /// Therefore this method is unsafe.\n     #[inline]\n-    pub unsafe fn new_unchecked(waker: RawWaker) -> Waker {\n+    pub unsafe fn from_raw(waker: RawWaker) -> Waker {\n         Waker {\n             waker,\n         }\n@@ -226,7 +264,7 @@ impl Clone for Waker {\n     #[inline]\n     fn clone(&self) -> Self {\n         Waker {\n-            // SAFETY: This is safe because `Waker::new_unchecked` is the only way\n+            // SAFETY: This is safe because `Waker::from_raw` is the only way\n             // to initialize `clone` and `data` requiring the user to acknowledge\n             // that the contract of [`RawWaker`] is upheld.\n             waker: unsafe { (self.waker.vtable.clone)(self.waker.data) },\n@@ -237,7 +275,7 @@ impl Clone for Waker {\n impl Drop for Waker {\n     #[inline]\n     fn drop(&mut self) {\n-        // SAFETY: This is safe because `Waker::new_unchecked` is the only way\n+        // SAFETY: This is safe because `Waker::from_raw` is the only way\n         // to initialize `drop` and `data` requiring the user to acknowledge\n         // that the contract of `RawWaker` is upheld.\n         unsafe { (self.waker.vtable.drop)(self.waker.data) }"}, {"sha": "518452aefc15256067e1255b7a0cb96f0605d576", "filename": "src/test/run-pass/async-await.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df25d79a33b0c82b716699a75a41bfdc6089850a/src%2Ftest%2Frun-pass%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df25d79a33b0c82b716699a75a41bfdc6089850a/src%2Ftest%2Frun-pass%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await.rs?ref=df25d79a33b0c82b716699a75a41bfdc6089850a", "patch": "@@ -19,7 +19,10 @@ struct Counter {\n }\n \n impl ArcWake for Counter {\n-    fn wake(arc_self: &Arc<Self>) {\n+    fn wake(self: Arc<Self>) {\n+        Self::wake_by_ref(&self)\n+    }\n+    fn wake_by_ref(arc_self: &Arc<Self>) {\n         arc_self.wakes.fetch_add(1, atomic::Ordering::SeqCst);\n     }\n }\n@@ -34,7 +37,7 @@ impl Future for WakeOnceThenComplete {\n         if self.0 {\n             Poll::Ready(())\n         } else {\n-            cx.waker().wake();\n+            cx.waker().wake_by_ref();\n             self.0 = true;\n             Poll::Pending\n         }"}, {"sha": "93e074e7ee55c7f49ade4fb53285b68a9321a1ca", "filename": "src/test/run-pass/auxiliary/arc_wake.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/df25d79a33b0c82b716699a75a41bfdc6089850a/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df25d79a33b0c82b716699a75a41bfdc6089850a/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs?ref=df25d79a33b0c82b716699a75a41bfdc6089850a", "patch": "@@ -12,25 +12,30 @@ macro_rules! waker_vtable {\n         &RawWakerVTable::new(\n             clone_arc_raw::<$ty>,\n             wake_arc_raw::<$ty>,\n+            wake_by_ref_arc_raw::<$ty>,\n             drop_arc_raw::<$ty>,\n         )\n     };\n }\n \n pub trait ArcWake {\n-    fn wake(arc_self: &Arc<Self>);\n+    fn wake(self: Arc<Self>);\n+\n+    fn wake_by_ref(arc_self: &Arc<Self>) {\n+        arc_self.clone().wake()\n+    }\n \n     fn into_waker(wake: Arc<Self>) -> Waker where Self: Sized\n     {\n-        let ptr = Arc::into_raw(wake) as *const();\n+        let ptr = Arc::into_raw(wake) as *const ();\n \n         unsafe {\n-            Waker::new_unchecked(RawWaker::new(ptr, waker_vtable!(Self)))\n+            Waker::from_raw(RawWaker::new(ptr, waker_vtable!(Self)))\n         }\n     }\n }\n \n-unsafe fn increase_refcount<T: ArcWake>(data: *const()) {\n+unsafe fn increase_refcount<T: ArcWake>(data: *const ()) {\n     // Retain Arc by creating a copy\n     let arc: Arc<T> = Arc::from_raw(data as *const T);\n     let arc_clone = arc.clone();\n@@ -39,18 +44,23 @@ unsafe fn increase_refcount<T: ArcWake>(data: *const()) {\n     let _ = Arc::into_raw(arc_clone);\n }\n \n-unsafe fn clone_arc_raw<T: ArcWake>(data: *const()) -> RawWaker {\n+unsafe fn clone_arc_raw<T: ArcWake>(data: *const ()) -> RawWaker {\n     increase_refcount::<T>(data);\n     RawWaker::new(data, waker_vtable!(T))\n }\n \n-unsafe fn drop_arc_raw<T: ArcWake>(data: *const()) {\n+unsafe fn drop_arc_raw<T: ArcWake>(data: *const ()) {\n     // Drop Arc\n     let _: Arc<T> = Arc::from_raw(data as *const T);\n }\n \n-unsafe fn wake_arc_raw<T: ArcWake>(data: *const()) {\n+unsafe fn wake_arc_raw<T: ArcWake>(data: *const ()) {\n+    let arc: Arc<T> = Arc::from_raw(data as *const T);\n+    ArcWake::wake(arc);\n+}\n+\n+unsafe fn wake_by_ref_arc_raw<T: ArcWake>(data: *const ()) {\n     let arc: Arc<T> = Arc::from_raw(data as *const T);\n-    ArcWake::wake(&arc);\n+    ArcWake::wake_by_ref(&arc);\n     let _ = Arc::into_raw(arc);\n }"}, {"sha": "6094f15569bb60a43a9f9d3119278db8cad720d8", "filename": "src/test/run-pass/futures-api.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/df25d79a33b0c82b716699a75a41bfdc6089850a/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df25d79a33b0c82b716699a75a41bfdc6089850a/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffutures-api.rs?ref=df25d79a33b0c82b716699a75a41bfdc6089850a", "patch": "@@ -20,7 +20,10 @@ struct Counter {\n }\n \n impl ArcWake for Counter {\n-    fn wake(arc_self: &Arc<Self>) {\n+    fn wake(self: Arc<Self>) {\n+        Self::wake_by_ref(&self)\n+    }\n+    fn wake_by_ref(arc_self: &Arc<Self>) {\n         arc_self.wakes.fetch_add(1, atomic::Ordering::SeqCst);\n     }\n }\n@@ -32,8 +35,8 @@ impl Future for MyFuture {\n     fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n         // Wake twice\n         let waker = cx.waker();\n-        waker.wake();\n-        waker.wake();\n+        waker.wake_by_ref();\n+        waker.wake_by_ref();\n         Poll::Ready(())\n     }\n }"}]}