{"sha": "6309b0f5bb558b844f45b2d313d2078fd7b7614c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzMDliMGY1YmI1NThiODQ0ZjQ1YjJkMzEzZDIwNzhmZDdiNzYxNGM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-12-13T22:17:55Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-12-16T20:35:50Z"}, "message": "move error handling from libsyntax/diagnostics.rs to libsyntax/errors/*\n\nAlso split out emitters into their own module.", "tree": {"sha": "3666b39af4692755af1cdac1bde215bbb2842f02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3666b39af4692755af1cdac1bde215bbb2842f02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6309b0f5bb558b844f45b2d313d2078fd7b7614c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6309b0f5bb558b844f45b2d313d2078fd7b7614c", "html_url": "https://github.com/rust-lang/rust/commit/6309b0f5bb558b844f45b2d313d2078fd7b7614c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6309b0f5bb558b844f45b2d313d2078fd7b7614c/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "073b0f9b852fa8b14ea4ab8c5a724043eb39fce5", "url": "https://api.github.com/repos/rust-lang/rust/commits/073b0f9b852fa8b14ea4ab8c5a724043eb39fce5", "html_url": "https://github.com/rust-lang/rust/commit/073b0f9b852fa8b14ea4ab8c5a724043eb39fce5"}], "stats": {"total": 1316, "additions": 207, "deletions": 1109}, "files": [{"sha": "054e0401b273ddfaadff2b9b61099c31a6451de4", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -47,7 +47,7 @@ use rustc_front::hir;\n use rustc_front::util;\n use rustc_front::intravisit as hir_visit;\n use syntax::visit as ast_visit;\n-use syntax::diagnostic;\n+use syntax::errors;\n \n /// Information about the registered lints.\n ///\n@@ -167,7 +167,7 @@ impl LintStore {\n                 match (sess, from_plugin) {\n                     // We load builtin lints first, so a duplicate is a compiler bug.\n                     // Use early_error when handling -W help with no crate.\n-                    (None, _) => early_error(diagnostic::Auto, &msg[..]),\n+                    (None, _) => early_error(errors::ColorConfig::Auto, &msg[..]),\n                     (Some(sess), false) => sess.bug(&msg[..]),\n \n                     // A duplicate name from a plugin is a user error.\n@@ -191,7 +191,7 @@ impl LintStore {\n             match (sess, from_plugin) {\n                 // We load builtin lints first, so a duplicate is a compiler bug.\n                 // Use early_error when handling -W help with no crate.\n-                (None, _) => early_error(diagnostic::Auto, &msg[..]),\n+                (None, _) => early_error(errors::ColorConfig::Auto, &msg[..]),\n                 (Some(sess), false) => sess.bug(&msg[..]),\n \n                 // A duplicate name from a plugin is a user error."}, {"sha": "75761dbc15adede13abc6ff653b094fbb927f944", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -27,7 +27,7 @@ use middle::cstore;\n use syntax::ast::{self, IntTy, UintTy};\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::diagnostic::{ColorConfig, Auto, Always, Never, SpanHandler};\n+use syntax::errors::{ColorConfig, Handler};\n use syntax::parse;\n use syntax::parse::token::InternedString;\n use syntax::feature_gate::UnstableFeatures;\n@@ -238,7 +238,7 @@ pub fn basic_options() -> Options {\n         debugging_opts: basic_debugging_options(),\n         prints: Vec::new(),\n         cg: basic_codegen_options(),\n-        color: Auto,\n+        color: ColorConfig::Auto,\n         show_span: None,\n         externs: HashMap::new(),\n         crate_name: None,\n@@ -687,19 +687,19 @@ pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n     v\n }\n \n-pub fn build_target_config(opts: &Options, sp: &SpanHandler) -> Config {\n+pub fn build_target_config(opts: &Options, sp: &Handler) -> Config {\n     let target = match Target::search(&opts.target_triple) {\n         Ok(t) => t,\n         Err(e) => {\n-            panic!(sp.handler().fatal(&format!(\"Error loading target specification: {}\", e)));\n+            panic!(sp.fatal(&format!(\"Error loading target specification: {}\", e)));\n         }\n     };\n \n     let (int_type, uint_type) = match &target.target_pointer_width[..] {\n         \"32\" => (ast::TyI32, ast::TyU32),\n         \"64\" => (ast::TyI64, ast::TyU64),\n-        w    => panic!(sp.handler().fatal(&format!(\"target specification was invalid: \\\n-                                                    unrecognized target-pointer-width {}\", w))),\n+        w    => panic!(sp.fatal(&format!(\"target specification was invalid: \\\n+                                          unrecognized target-pointer-width {}\", w))),\n     };\n \n     Config {\n@@ -884,16 +884,16 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n \n pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[..]) {\n-        Some(\"auto\")   => Auto,\n-        Some(\"always\") => Always,\n-        Some(\"never\")  => Never,\n+        Some(\"auto\")   => ColorConfig::Auto,\n+        Some(\"always\") => ColorConfig::Always,\n+        Some(\"never\")  => ColorConfig::Never,\n \n-        None => Auto,\n+        None => ColorConfig::Auto,\n \n         Some(arg) => {\n-            early_error(Auto, &format!(\"argument for --color must be auto, always \\\n-                                        or never (instead was `{}`)\",\n-                                       arg))\n+            early_error(ColorConfig::Auto, &format!(\"argument for --color must be auto, always \\\n+                                                     or never (instead was `{}`)\",\n+                                                    arg))\n         }\n     };\n "}, {"sha": "76d765c9626a3c1b86f2ba05887c11451eea76b3", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -16,7 +16,8 @@ use util::nodemap::{NodeMap, FnvHashMap};\n \n use syntax::ast::{NodeId, NodeIdAssigner, Name};\n use syntax::codemap::Span;\n-use syntax::diagnostic::{self, Emitter};\n+use syntax::errors;\n+use syntax::errors::emitter::{Emitter, BasicEmitter};\n use syntax::diagnostics;\n use syntax::feature_gate;\n use syntax::parse;\n@@ -99,7 +100,7 @@ impl Session {\n         if self.opts.treat_err_as_bug {\n             self.bug(msg);\n         }\n-        panic!(self.diagnostic().handler().fatal(msg))\n+        panic!(self.diagnostic().fatal(msg))\n     }\n     pub fn span_err_or_warn(&self, is_warning: bool, sp: Span, msg: &str) {\n         if is_warning {\n@@ -137,16 +138,16 @@ impl Session {\n         if self.opts.treat_err_as_bug {\n             self.bug(msg);\n         }\n-        self.diagnostic().handler().err(msg)\n+        self.diagnostic().err(msg)\n     }\n     pub fn err_count(&self) -> usize {\n-        self.diagnostic().handler().err_count()\n+        self.diagnostic().err_count()\n     }\n     pub fn has_errors(&self) -> bool {\n-        self.diagnostic().handler().has_errors()\n+        self.diagnostic().has_errors()\n     }\n     pub fn abort_if_errors(&self) {\n-        self.diagnostic().handler().abort_if_errors();\n+        self.diagnostic().abort_if_errors();\n \n         let delayed_bug = self.delayed_span_bug.borrow();\n         match *delayed_bug {\n@@ -177,7 +178,7 @@ impl Session {\n     }\n     pub fn warn(&self, msg: &str) {\n         if self.can_print_warnings {\n-            self.diagnostic().handler().warn(msg)\n+            self.diagnostic().warn(msg)\n         }\n     }\n     pub fn opt_span_warn(&self, opt_sp: Option<Span>, msg: &str) {\n@@ -195,7 +196,7 @@ impl Session {\n \n     /// Prints out a message with a suggested edit of the code.\n     ///\n-    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n+    /// See `errors::RenderSpan::Suggestion` for more information.\n     pub fn span_suggestion(&self, sp: Span, msg: &str, suggestion: String) {\n         self.diagnostic().span_suggestion(sp, msg, suggestion)\n     }\n@@ -209,10 +210,10 @@ impl Session {\n         self.diagnostic().fileline_help(sp, msg)\n     }\n     pub fn note(&self, msg: &str) {\n-        self.diagnostic().handler().note(msg)\n+        self.diagnostic().note(msg)\n     }\n     pub fn help(&self, msg: &str) {\n-        self.diagnostic().handler().help(msg)\n+        self.diagnostic().help(msg)\n     }\n     pub fn opt_span_bug(&self, opt_sp: Option<Span>, msg: &str) -> ! {\n         match opt_sp {\n@@ -229,13 +230,13 @@ impl Session {\n         self.diagnostic().span_bug(sp, msg)\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n-        self.diagnostic().handler().bug(msg)\n+        self.diagnostic().bug(msg)\n     }\n     pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n         self.diagnostic().span_unimpl(sp, msg)\n     }\n     pub fn unimpl(&self, msg: &str) -> ! {\n-        self.diagnostic().handler().unimpl(msg)\n+        self.diagnostic().unimpl(msg)\n     }\n     pub fn add_lint(&self,\n                     lint: &'static lint::Lint,\n@@ -260,7 +261,7 @@ impl Session {\n \n         id\n     }\n-    pub fn diagnostic<'a>(&'a self) -> &'a diagnostic::SpanHandler {\n+    pub fn diagnostic<'a>(&'a self) -> &'a errors::Handler {\n         &self.parse_sess.span_diagnostic\n     }\n     pub fn codemap<'a>(&'a self) -> &'a codemap::CodeMap {\n@@ -414,29 +415,27 @@ pub fn build_session(sopts: config::Options,\n         .last()\n         .unwrap_or(true);\n \n-    let codemap = codemap::CodeMap::new();\n+    let codemap = Rc::new(codemap::CodeMap::new());\n     let diagnostic_handler =\n-        diagnostic::Handler::new(sopts.color, Some(registry), can_print_warnings);\n-    let span_diagnostic_handler =\n-        diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n+        errors::Handler::new(sopts.color, Some(registry), can_print_warnings, codemap.clone());\n \n-    build_session_(sopts, local_crate_source_file, span_diagnostic_handler, cstore)\n+    build_session_(sopts, local_crate_source_file, diagnostic_handler, codemap, cstore)\n }\n \n pub fn build_session_(sopts: config::Options,\n                       local_crate_source_file: Option<PathBuf>,\n-                      span_diagnostic: diagnostic::SpanHandler,\n+                      span_diagnostic: errors::Handler,\n+                      codemap: Rc<codemap::CodeMap>,\n                       cstore: Rc<for<'a> CrateStore<'a>>)\n                       -> Session {\n     let host = match Target::search(config::host_triple()) {\n         Ok(t) => t,\n         Err(e) => {\n-            panic!(span_diagnostic.handler()\n-                                  .fatal(&format!(\"Error loading host specification: {}\", e)));\n+            panic!(span_diagnostic.fatal(&format!(\"Error loading host specification: {}\", e)));\n     }\n     };\n     let target_cfg = config::build_target_config(&sopts, &span_diagnostic);\n-    let p_s = parse::ParseSess::with_span_handler(span_diagnostic);\n+    let p_s = parse::ParseSess::with_span_handler(span_diagnostic, codemap);\n     let default_sysroot = match sopts.maybe_sysroot {\n         Some(_) => None,\n         None => Some(filesearch::get_or_default_sysroot())\n@@ -494,16 +493,16 @@ pub fn build_session_(sopts: config::Options,\n pub fn expect<T, M>(sess: &Session, opt: Option<T>, msg: M) -> T where\n     M: FnOnce() -> String,\n {\n-    diagnostic::expect(sess.diagnostic(), opt, msg)\n+    errors::expect(sess.diagnostic(), opt, msg)\n }\n \n-pub fn early_error(color: diagnostic::ColorConfig, msg: &str) -> ! {\n-    let mut emitter = diagnostic::EmitterWriter::stderr(color, None);\n-    emitter.emit(None, msg, None, diagnostic::Fatal);\n-    panic!(diagnostic::FatalError);\n+pub fn early_error(color: errors::ColorConfig, msg: &str) -> ! {\n+    let mut emitter = BasicEmitter::stderr(color);\n+    emitter.emit(None, msg, None, errors::Level::Fatal);\n+    panic!(errors::FatalError);\n }\n \n-pub fn early_warn(color: diagnostic::ColorConfig, msg: &str) {\n-    let mut emitter = diagnostic::EmitterWriter::stderr(color, None);\n-    emitter.emit(None, msg, None, diagnostic::Warning);\n+pub fn early_warn(color: errors::ColorConfig, msg: &str) {\n+    let mut emitter = BasicEmitter::stderr(color);\n+    emitter.emit(None, msg, None, errors::Level::Warning);\n }"}, {"sha": "6a787139d77aa88c3d96dfa981da7f41c9fbdfde", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -11,7 +11,7 @@\n use std::slice;\n use std::path::{Path, PathBuf};\n use session::early_error;\n-use syntax::diagnostic;\n+use syntax::errors;\n \n #[derive(Clone, Debug)]\n pub struct SearchPaths {\n@@ -38,7 +38,7 @@ impl SearchPaths {\n         SearchPaths { paths: Vec::new() }\n     }\n \n-    pub fn add_path(&mut self, path: &str, color: diagnostic::ColorConfig) {\n+    pub fn add_path(&mut self, path: &str, color: errors::ColorConfig) {\n         let (kind, path) = if path.starts_with(\"native=\") {\n             (PathKind::Native, &path[\"native=\".len()..])\n         } else if path.starts_with(\"crate=\") {"}, {"sha": "f259698a220e2be8022a92de7bc1fae45b0b3be7", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -48,7 +48,7 @@\n use serialize::json::Json;\n use std::default::Default;\n use std::io::prelude::*;\n-use syntax::{diagnostic, abi};\n+use syntax::abi;\n \n mod android_base;\n mod apple_base;\n@@ -263,17 +263,13 @@ impl Target {\n     pub fn from_json(obj: Json) -> Target {\n         // this is 1. ugly, 2. error prone.\n \n-\n-        let handler = diagnostic::Handler::new(diagnostic::Auto, None, true);\n-\n         let get_req_field = |name: &str| {\n             match obj.find(name)\n                      .map(|s| s.as_string())\n                      .and_then(|os| os.map(|s| s.to_string())) {\n                 Some(val) => val,\n                 None => {\n-                    panic!(handler.fatal(&format!(\"Field {} in target specification is required\",\n-                                                  name)))\n+                    panic!(\"Field {} in target specification is required\", name)\n                 }\n             }\n         };"}, {"sha": "8cfaec62f47754cacf5cc2eea895ca647b68f125", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -59,8 +59,6 @@ extern crate log;\n extern crate syntax;\n extern crate syntax_ext;\n \n-pub use syntax::diagnostic;\n-\n use driver::CompileController;\n use pretty::{PpMode, UserIdentifiedItem};\n \n@@ -91,7 +89,8 @@ use rustc::session::early_error;\n \n use syntax::ast;\n use syntax::parse;\n-use syntax::diagnostic::Emitter;\n+use syntax::errors;\n+use syntax::errors::emitter::Emitter;\n use syntax::diagnostics;\n use syntax::parse::token;\n \n@@ -239,7 +238,7 @@ pub trait CompilerCalls<'a> {\n     fn early_callback(&mut self,\n                       _: &getopts::Matches,\n                       _: &diagnostics::registry::Registry,\n-                      _: diagnostic::ColorConfig)\n+                      _: errors::ColorConfig)\n                       -> Compilation {\n         Compilation::Continue\n     }\n@@ -315,7 +314,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n     fn early_callback(&mut self,\n                       matches: &getopts::Matches,\n                       descriptions: &diagnostics::registry::Registry,\n-                      color: diagnostic::ColorConfig)\n+                      color: errors::ColorConfig)\n                       -> Compilation {\n         match matches.opt_str(\"explain\") {\n             Some(ref code) => {\n@@ -774,7 +773,7 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n                             &opt.opt_group.short_name\n                         };\n                         if m.opt_present(opt_name) {\n-                            early_error(diagnostic::Auto,\n+                            early_error(errors::ColorConfig::Auto,\n                                         &format!(\"use of unstable option '{}' requires -Z \\\n                                                   unstable-options\",\n                                                  opt_name));\n@@ -783,7 +782,7 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n                 }\n                 m\n             }\n-            Err(f) => early_error(diagnostic::Auto, &f.to_string()),\n+            Err(f) => early_error(errors::ColorConfig::Auto, &f.to_string()),\n         }\n     }\n \n@@ -895,25 +894,25 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n         }\n         Err(value) => {\n             // Thread panicked without emitting a fatal diagnostic\n-            if !value.is::<diagnostic::FatalError>() {\n-                let mut emitter = diagnostic::EmitterWriter::stderr(diagnostic::Auto, None);\n+            if !value.is::<errors::FatalError>() {\n+                let mut emitter = errors::emitter::BasicEmitter::stderr(errors::ColorConfig::Auto);\n \n                 // a .span_bug or .bug call has already printed what\n                 // it wants to print.\n-                if !value.is::<diagnostic::ExplicitBug>() {\n-                    emitter.emit(None, \"unexpected panic\", None, diagnostic::Bug);\n+                if !value.is::<errors::ExplicitBug>() {\n+                    emitter.emit(None, \"unexpected panic\", None, errors::Level::Bug);\n                 }\n \n                 let xs = [\"the compiler unexpectedly panicked. this is a bug.\".to_string(),\n                           format!(\"we would appreciate a bug report: {}\", BUG_REPORT_URL)];\n                 for note in &xs {\n-                    emitter.emit(None, &note[..], None, diagnostic::Note)\n+                    emitter.emit(None, &note[..], None, errors::Level::Note)\n                 }\n                 if let None = env::var_os(\"RUST_BACKTRACE\") {\n                     emitter.emit(None,\n                                  \"run with `RUST_BACKTRACE=1` for a backtrace\",\n                                  None,\n-                                 diagnostic::Note);\n+                                 errors::Level::Note);\n                 }\n \n                 println!(\"{}\", str::from_utf8(&data.lock().unwrap()).unwrap());"}, {"sha": "13ddd9ca55ce4b359ca522b43989b54b3abc7ed4", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -14,7 +14,7 @@ use syntax::abi;\n use syntax::ast;\n use syntax::owned_slice::OwnedSlice;\n use syntax::codemap::{self, CodeMap, BytePos, Spanned};\n-use syntax::diagnostic;\n+use syntax::errors;\n use syntax::parse::token::{self, BinOpToken};\n use syntax::parse::lexer::comments;\n use syntax::parse;\n@@ -121,7 +121,7 @@ pub const default_columns: usize = 78;\n /// it can scan the input text for comments and literals to\n /// copy forward.\n pub fn print_crate<'a>(cm: &'a CodeMap,\n-                       span_diagnostic: &diagnostic::SpanHandler,\n+                       span_diagnostic: &errors::Handler,\n                        krate: &hir::Crate,\n                        filename: String,\n                        input: &mut Read,\n@@ -142,7 +142,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n \n impl<'a> State<'a> {\n     pub fn new_from_input(cm: &'a CodeMap,\n-                          span_diagnostic: &diagnostic::SpanHandler,\n+                          span_diagnostic: &errors::Handler,\n                           filename: String,\n                           input: &mut Read,\n                           out: Box<Write + 'a>,"}, {"sha": "cd70172e8fa2112500da97662a9d337d2cd87451", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -44,7 +44,7 @@ use syntax::abi;\n use syntax::ast::{self, NodeId, Name, CRATE_NODE_ID, CrateNum};\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::diagnostic::SpanHandler;\n+use syntax::errors::Handler;\n use syntax::parse::token::special_idents;\n use syntax;\n use rbml::writer::Encoder;\n@@ -57,7 +57,7 @@ pub type EncodeInlinedItem<'a> =\n     Box<FnMut(&EncodeContext, &mut Encoder, InlinedItemRef) + 'a>;\n \n pub struct EncodeParams<'a, 'tcx: 'a> {\n-    pub diag: &'a SpanHandler,\n+    pub diag: &'a Handler,\n     pub tcx: &'a ty::ctxt<'tcx>,\n     pub reexports: &'a def::ExportMap,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n@@ -69,7 +69,7 @@ pub struct EncodeParams<'a, 'tcx: 'a> {\n }\n \n pub struct EncodeContext<'a, 'tcx: 'a> {\n-    pub diag: &'a SpanHandler,\n+    pub diag: &'a Handler,\n     pub tcx: &'a ty::ctxt<'tcx>,\n     pub reexports: &'a def::ExportMap,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n@@ -275,8 +275,7 @@ fn encode_symbol(ecx: &EncodeContext,\n             rbml_w.wr_tagged_str(tag_items_data_item_symbol, x);\n         }\n         None => {\n-            ecx.diag.handler().bug(\n-                &format!(\"encode_symbol: id not found {}\", id));\n+            ecx.diag.bug(&format!(\"encode_symbol: id not found {}\", id));\n         }\n     }\n }"}, {"sha": "81788e08c7ef2085135b3c90c59f2207cc8ff5d5", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -226,7 +226,7 @@ use rustc_llvm as llvm;\n use rustc_llvm::{False, ObjectFile, mk_section_iter};\n use rustc_llvm::archive_ro::ArchiveRO;\n use syntax::codemap::Span;\n-use syntax::diagnostic::SpanHandler;\n+use syntax::errors::Handler;\n use rustc_back::target::Target;\n \n use std::cmp;\n@@ -697,8 +697,8 @@ impl<'a> Context<'a> {\n     }\n }\n \n-pub fn note_crate_name(diag: &SpanHandler, name: &str) {\n-    diag.handler().note(&format!(\"crate name: {}\", name));\n+pub fn note_crate_name(diag: &Handler, name: &str) {\n+    diag.note(&format!(\"crate name: {}\", name));\n }\n \n impl ArchiveMetadata {"}, {"sha": "e1329f288b2c57ae39eda2fd8280ab470d5f316d", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -29,14 +29,14 @@ use rustc_front::hir;\n \n use syntax::abi::Abi;\n use syntax::ast;\n-use syntax::diagnostic::SpanHandler;\n+use syntax::errors::Handler;\n \n use rbml::writer::{self, Encoder};\n \n macro_rules! mywrite { ($w:expr, $($arg:tt)*) => ({ write!($w.writer, $($arg)*); }) }\n \n pub struct ctxt<'a, 'tcx: 'a> {\n-    pub diag: &'a SpanHandler,\n+    pub diag: &'a Handler,\n     // Def -> str Callback:\n     pub ds: fn(DefId) -> String,\n     // The type context.\n@@ -136,7 +136,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n             enc_bare_fn_ty(w, cx, f);\n         }\n         ty::TyInfer(_) => {\n-            cx.diag.handler().bug(\"cannot encode inference variable types\");\n+            cx.diag.bug(\"cannot encode inference variable types\");\n         }\n         ty::TyParam(ParamTy {space, idx, name}) => {\n             mywrite!(w, \"p[{}|{}|{}]\", idx, space.to_uint(), name)\n@@ -279,7 +279,7 @@ pub fn enc_region(w: &mut Encoder, cx: &ctxt, r: ty::Region) {\n         }\n         ty::ReVar(_) | ty::ReSkolemized(..) => {\n             // these should not crop up after typeck\n-            cx.diag.handler().bug(\"cannot encode region variables\");\n+            cx.diag.bug(\"cannot encode region variables\");\n         }\n     }\n }"}, {"sha": "476425a75c22df73bb61953d0bf6cb2a124130bf", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -13,7 +13,7 @@\n use syntax::ast;\n use syntax::attr;\n use syntax::codemap::Span;\n-use syntax::diagnostic;\n+use syntax::errors;\n use rustc_front::intravisit::Visitor;\n use rustc_front::hir;\n \n@@ -33,7 +33,7 @@ impl<'v> Visitor<'v> for RegistrarFinder {\n }\n \n /// Find the function marked with `#[plugin_registrar]`, if any.\n-pub fn find_plugin_registrar(diagnostic: &diagnostic::SpanHandler,\n+pub fn find_plugin_registrar(diagnostic: &errors::Handler,\n                              krate: &hir::Crate)\n                              -> Option<ast::NodeId> {\n     let mut finder = RegistrarFinder { registrars: Vec::new() };\n@@ -46,11 +46,11 @@ pub fn find_plugin_registrar(diagnostic: &diagnostic::SpanHandler,\n             Some(node_id)\n         },\n         _ => {\n-            diagnostic.handler().err(\"multiple plugin registration functions found\");\n+            diagnostic.err(\"multiple plugin registration functions found\");\n             for &(_, span) in &finder.registrars {\n                 diagnostic.span_note(span, \"one is here\");\n             }\n-            diagnostic.handler().abort_if_errors();\n+            diagnostic.abort_if_errors();\n             unreachable!();\n         }\n     }"}, {"sha": "8505c3968ee15ea761187821777340880c96416d", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -101,7 +101,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                 if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n                                                         ptr as *const libc::c_char,\n                                                         bc_decoded.len() as libc::size_t) {\n-                    write::llvm_err(sess.diagnostic().handler(),\n+                    write::llvm_err(sess.diagnostic(),\n                                     format!(\"failed to load bc of `{}`\",\n                                             &name[..]));\n                 }"}, {"sha": "26813d89915ac71205ba04d67f25013931ea64da", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -20,8 +20,8 @@ use trans::{CrateTranslation, ModuleTranslation};\n use util::common::time;\n use util::common::path2cstr;\n use syntax::codemap;\n-use syntax::diagnostic;\n-use syntax::diagnostic::{Emitter, Handler, Level};\n+use syntax::errors::{self, Handler, Level};\n+use syntax::errors::emitter::Emitter;\n \n use std::collections::HashMap;\n use std::ffi::{CStr, CString};\n@@ -34,7 +34,7 @@ use std::sync::mpsc::channel;\n use std::thread;\n use libc::{self, c_uint, c_int, c_void};\n \n-pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n+pub fn llvm_err(handler: &errors::Handler, msg: String) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n         if cstr == ptr::null() {\n@@ -49,7 +49,7 @@ pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n }\n \n pub fn write_output_file(\n-        handler: &diagnostic::Handler,\n+        handler: &errors::Handler,\n         target: llvm::TargetMachineRef,\n         pm: llvm::PassManagerRef,\n         m: ModuleRef,\n@@ -109,9 +109,9 @@ impl SharedEmitter {\n }\n \n impl Emitter for SharedEmitter {\n-    fn emit(&mut self, cmsp: Option<(&codemap::CodeMap, codemap::Span)>,\n+    fn emit(&mut self, sp: Option<codemap::Span>,\n             msg: &str, code: Option<&str>, lvl: Level) {\n-        assert!(cmsp.is_none(), \"SharedEmitter doesn't support spans\");\n+        assert!(sp.is_none(), \"SharedEmitter doesn't support spans\");\n \n         self.buffer.lock().unwrap().push(Diagnostic {\n             msg: msg.to_string(),\n@@ -120,8 +120,7 @@ impl Emitter for SharedEmitter {\n         });\n     }\n \n-    fn custom_emit(&mut self, _cm: &codemap::CodeMap,\n-                   _sp: diagnostic::RenderSpan, _msg: &str, _lvl: Level) {\n+    fn custom_emit(&mut self, _sp: errors::RenderSpan, _msg: &str, _lvl: Level) {\n         panic!(\"SharedEmitter doesn't support custom_emit\");\n     }\n }\n@@ -226,7 +225,7 @@ pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     };\n \n     if tm.is_null() {\n-        llvm_err(sess.diagnostic().handler(),\n+        llvm_err(sess.diagnostic(),\n                  format!(\"Could not create LLVM TargetMachine for triple: {}\",\n                          triple).to_string());\n     } else {\n@@ -333,7 +332,7 @@ impl<'a> CodegenContext<'a> {\n     fn new_with_session(sess: &'a Session, reachable: &'a [String]) -> CodegenContext<'a> {\n         CodegenContext {\n             lto_ctxt: Some((sess, reachable)),\n-            handler: sess.diagnostic().handler(),\n+            handler: sess.diagnostic(),\n             plugin_passes: sess.plugin_llvm_passes.borrow().clone(),\n             remark: sess.opts.cg.remark.clone(),\n             worker: 0,\n@@ -903,7 +902,7 @@ fn run_work_multithreaded(sess: &Session,\n             },\n         }\n         // Display any new diagnostics.\n-        diag_emitter.dump(sess.diagnostic().handler());\n+        diag_emitter.dump(sess.diagnostic());\n     }\n     if panicked {\n         sess.fatal(\"aborting due to worker thread panic\");"}, {"sha": "c6c98851f7c34af366a5b04575e980f171cf5836", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -22,7 +22,8 @@ use rustc_resolve as resolve;\n use rustc_front::lowering::{lower_crate, LoweringContext};\n use rustc_metadata::cstore::CStore;\n \n-use syntax::{ast, codemap, diagnostic};\n+use syntax::{ast, codemap, errors};\n+use syntax::errors::emitter::ColorConfig;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::parse::token;\n \n@@ -116,15 +117,16 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n         ..config::basic_options().clone()\n     };\n \n-    let codemap = codemap::CodeMap::new();\n-    let diagnostic_handler = diagnostic::Handler::new(diagnostic::Auto, None, true);\n-    let span_diagnostic_handler =\n-        diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n+    let codemap = Rc::new(codemap::CodeMap::new());\n+    let diagnostic_handler = errors::Handler::new(ColorConfig::Auto,\n+                                                  None,\n+                                                  true,\n+                                                  false,\n+                                                  codemap.clone());\n \n     let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n     let cstore_ = ::rustc_driver::cstore_to_cratestore(cstore.clone());\n-    let sess = session::build_session_(sessopts, cpath,\n-                                       span_diagnostic_handler, cstore_);\n+    let sess = session::build_session_(sessopts, cpath, diagnostic_handler, codemap, cstore_);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess);"}, {"sha": "31fdc1170c0261f54dc285cba4ff162f0d27eb58", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -65,7 +65,7 @@ use externalfiles::ExternalHtml;\n use serialize::Decodable;\n use serialize::json::{self, Json};\n use rustc::session::search_paths::SearchPaths;\n-use syntax::diagnostic;\n+use syntax::errors::emitter::ColorConfig;\n \n // reexported from `clean` so it can be easily updated with the mod itself\n pub use clean::SCHEMA_VERSION;\n@@ -228,7 +228,7 @@ pub fn main_args(args: &[String]) -> isize {\n \n     let mut libs = SearchPaths::new();\n     for s in &matches.opt_strs(\"L\") {\n-        libs.add_path(s, diagnostic::Auto);\n+        libs.add_path(s, ColorConfig::Auto);\n     }\n     let externs = match parse_externs(&matches) {\n         Ok(ex) => ex,\n@@ -363,7 +363,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     // First, parse the crate and extract all relevant information.\n     let mut paths = SearchPaths::new();\n     for s in &matches.opt_strs(\"L\") {\n-        paths.add_path(s, diagnostic::Auto);\n+        paths.add_path(s, ColorConfig::Auto);\n     }\n     let cfgs = matches.opt_strs(\"cfg\");\n     let triple = matches.opt_str(\"target\");"}, {"sha": "4ac20ba001b9f428e134cb925abe40859c459f38", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -34,7 +34,8 @@ use rustc_back::tempdir::TempDir;\n use rustc_driver::{driver, Compilation};\n use rustc_metadata::cstore::CStore;\n use syntax::codemap::CodeMap;\n-use syntax::diagnostic;\n+use syntax::errors;\n+use syntax::errors::emitter::ColorConfig;\n use syntax::parse::token;\n \n use core;\n@@ -71,16 +72,19 @@ pub fn run(input: &str,\n         ..config::basic_options().clone()\n     };\n \n-    let codemap = CodeMap::new();\n-    let diagnostic_handler = diagnostic::Handler::new(diagnostic::Auto, None, true);\n-    let span_diagnostic_handler =\n-    diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n+    let codemap = Rc::new(CodeMap::new());\n+    let diagnostic_handler = errors::Handler::new(ColorConfig::Auto,\n+                                                  None,\n+                                                  true,\n+                                                  false,\n+                                                  codemap.clone());\n \n     let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n     let cstore_ = ::rustc_driver::cstore_to_cratestore(cstore.clone());\n     let sess = session::build_session_(sessopts,\n                                        Some(input_path.clone()),\n-                                       span_diagnostic_handler,\n+                                       diagnostic_handler,\n+                                       codemap,\n                                        cstore_);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n@@ -220,21 +224,20 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n         }\n     }\n     let data = Arc::new(Mutex::new(Vec::new()));\n-    let emitter = diagnostic::EmitterWriter::new(box Sink(data.clone()), None);\n+    let codemap = Rc::new(CodeMap::new());\n+    let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()), None, codemap.clone());\n     let old = io::set_panic(box Sink(data.clone()));\n     let _bomb = Bomb(data, old.unwrap_or(box io::stdout()));\n \n     // Compile the code\n-    let codemap = CodeMap::new();\n-    let diagnostic_handler = diagnostic::Handler::with_emitter(true, box emitter);\n-    let span_diagnostic_handler =\n-        diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n+    let diagnostic_handler = errors::Handler::with_emitter(true, false, box emitter);\n \n     let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n     let cstore_ = ::rustc_driver::cstore_to_cratestore(cstore.clone());\n     let sess = session::build_session_(sessopts,\n                                        None,\n-                                       span_diagnostic_handler,\n+                                       diagnostic_handler,\n+                                       codemap,\n                                        cstore_);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n "}, {"sha": "ea5608b3984273086842f91a34ec1bd67c11f222", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -21,7 +21,7 @@ use ast::{Expr, Item, Local, Decl};\n use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n use config::CfgDiag;\n-use diagnostic::SpanHandler;\n+use errors::Handler;\n use feature_gate::{GatedCfg, GatedCfgAttr};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::token::{InternedString, intern_and_get_ident};\n@@ -299,14 +299,14 @@ pub fn find_crate_name(attrs: &[Attribute]) -> Option<InternedString> {\n }\n \n /// Find the value of #[export_name=*] attribute and check its validity.\n-pub fn find_export_name_attr(diag: &SpanHandler, attrs: &[Attribute]) -> Option<InternedString> {\n+pub fn find_export_name_attr(diag: &Handler, attrs: &[Attribute]) -> Option<InternedString> {\n     attrs.iter().fold(None, |ia,attr| {\n         if attr.check_name(\"export_name\") {\n             if let s@Some(_) = attr.value_str() {\n                 s\n             } else {\n                 diag.span_err(attr.span, \"export_name attribute has invalid format\");\n-                diag.handler.help(\"use #[export_name=\\\"*\\\"]\");\n+                diag.help(\"use #[export_name=\\\"*\\\"]\");\n                 None\n             }\n         } else {\n@@ -324,7 +324,7 @@ pub enum InlineAttr {\n }\n \n /// Determine what `#[inline]` attribute is present in `attrs`, if any.\n-pub fn find_inline_attr(diagnostic: Option<&SpanHandler>, attrs: &[Attribute]) -> InlineAttr {\n+pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> InlineAttr {\n     attrs.iter().fold(InlineAttr::None, |ia,attr| {\n         match attr.node.value.node {\n             MetaWord(ref n) if *n == \"inline\" => {\n@@ -426,7 +426,7 @@ impl StabilityLevel {\n     pub fn is_stable(&self) -> bool { if let Stable {..} = *self { true } else { false }}\n }\n \n-fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n+fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                                  attrs_iter: I,\n                                  item_sp: Span)\n                                  -> Option<Stability>\n@@ -612,10 +612,10 @@ fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n     stab\n }\n \n-fn find_deprecation_generic<'a, I>(diagnostic: &SpanHandler,\n-                                 attrs_iter: I,\n-                                 item_sp: Span)\n-                                 -> Option<Deprecation>\n+fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n+                                   attrs_iter: I,\n+                                   item_sp: Span)\n+                                   -> Option<Deprecation>\n     where I: Iterator<Item = &'a Attribute>\n {\n     let mut depr: Option<Deprecation> = None;\n@@ -672,18 +672,18 @@ fn find_deprecation_generic<'a, I>(diagnostic: &SpanHandler,\n }\n \n /// Find the first stability attribute. `None` if none exists.\n-pub fn find_stability(diagnostic: &SpanHandler, attrs: &[Attribute],\n+pub fn find_stability(diagnostic: &Handler, attrs: &[Attribute],\n                       item_sp: Span) -> Option<Stability> {\n     find_stability_generic(diagnostic, attrs.iter(), item_sp)\n }\n \n /// Find the deprecation attribute. `None` if none exists.\n-pub fn find_deprecation(diagnostic: &SpanHandler, attrs: &[Attribute],\n-                      item_sp: Span) -> Option<Deprecation> {\n+pub fn find_deprecation(diagnostic: &Handler, attrs: &[Attribute],\n+                        item_sp: Span) -> Option<Deprecation> {\n     find_deprecation_generic(diagnostic, attrs.iter(), item_sp)\n }\n \n-pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {\n+pub fn require_unique_names(diagnostic: &Handler, metas: &[P<MetaItem>]) {\n     let mut set = HashSet::new();\n     for meta in metas {\n         let name = meta.name();\n@@ -702,7 +702,7 @@ pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {\n /// `int_type_of_word`, below) to specify enum discriminant type; `C`, to use\n /// the same discriminant size that the corresponding C enum would or C\n /// structure layout, and `packed` to remove padding.\n-pub fn find_repr_attrs(diagnostic: &SpanHandler, attr: &Attribute) -> Vec<ReprAttr> {\n+pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr> {\n     let mut acc = Vec::new();\n     match attr.node.value.node {\n         ast::MetaList(ref s, ref items) if *s == \"repr\" => {"}, {"sha": "64b16538f05a14e0877ef28899475964ceba9b80", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use attr::AttrMetaMethods;\n-use diagnostic::SpanHandler;\n+use errors::Handler;\n use feature_gate::GatedCfgAttr;\n use fold::Folder;\n use {ast, fold, attr};\n@@ -23,12 +23,12 @@ use util::small_vector::SmallVector;\n /// configuration.\n struct Context<'a, F> where F: FnMut(&[ast::Attribute]) -> bool {\n     in_cfg: F,\n-    diagnostic: &'a SpanHandler,\n+    diagnostic: &'a Handler,\n }\n \n // Support conditional compilation by transforming the AST, stripping out\n // any items that do not belong in the current configuration\n-pub fn strip_unconfigured_items(diagnostic: &SpanHandler, krate: ast::Crate,\n+pub fn strip_unconfigured_items(diagnostic: &Handler, krate: ast::Crate,\n                                 feature_gated_cfgs: &mut Vec<GatedCfgAttr>)\n                                 -> ast::Crate\n {\n@@ -83,7 +83,7 @@ impl<'a, F> fold::Folder for Context<'a, F> where F: FnMut(&[ast::Attribute]) ->\n     }\n }\n \n-pub fn strip_items<'a, F>(diagnostic: &'a SpanHandler,\n+pub fn strip_items<'a, F>(diagnostic: &'a Handler,\n                           krate: ast::Crate, in_cfg: F) -> ast::Crate where\n     F: FnMut(&[ast::Attribute]) -> bool,\n {\n@@ -291,7 +291,7 @@ struct CfgAttrFolder<'a, T> {\n }\n \n // Process `#[cfg_attr]`.\n-fn process_cfg_attr(diagnostic: &SpanHandler, krate: ast::Crate,\n+fn process_cfg_attr(diagnostic: &Handler, krate: ast::Crate,\n                     feature_gated_cfgs: &mut Vec<GatedCfgAttr>) -> ast::Crate {\n     let mut fld = CfgAttrFolder {\n         diag: CfgDiagReal {\n@@ -463,17 +463,17 @@ impl<'v, 'a, 'b> visit::Visitor<'v> for StmtExprAttrFeatureVisitor<'a, 'b> {\n }\n \n pub trait CfgDiag {\n-    fn emit_error<F>(&mut self, f: F) where F: FnMut(&SpanHandler);\n+    fn emit_error<F>(&mut self, f: F) where F: FnMut(&Handler);\n     fn flag_gated<F>(&mut self, f: F) where F: FnMut(&mut Vec<GatedCfgAttr>);\n }\n \n pub struct CfgDiagReal<'a, 'b> {\n-    pub diag: &'a SpanHandler,\n+    pub diag: &'a Handler,\n     pub feature_gated_cfgs: &'b mut Vec<GatedCfgAttr>,\n }\n \n impl<'a, 'b> CfgDiag for CfgDiagReal<'a, 'b> {\n-    fn emit_error<F>(&mut self, mut f: F) where F: FnMut(&SpanHandler) {\n+    fn emit_error<F>(&mut self, mut f: F) where F: FnMut(&Handler) {\n         f(self.diag)\n     }\n     fn flag_gated<F>(&mut self, mut f: F) where F: FnMut(&mut Vec<GatedCfgAttr>) {\n@@ -486,7 +486,7 @@ struct CfgDiagSilent {\n }\n \n impl CfgDiag for CfgDiagSilent {\n-    fn emit_error<F>(&mut self, _: F) where F: FnMut(&SpanHandler) {\n+    fn emit_error<F>(&mut self, _: F) where F: FnMut(&Handler) {\n         self.error = true;\n     }\n     fn flag_gated<F>(&mut self, _: F) where F: FnMut(&mut Vec<GatedCfgAttr>) {}"}, {"sha": "b854a2f2a0a1730fe09667d3fcb9f8be1e4fd3d6", "filename": "src/libsyntax/diagnostic.rs", "status": "removed", "additions": 0, "deletions": 900, "changes": 900, "blob_url": "https://github.com/rust-lang/rust/blob/073b0f9b852fa8b14ea4ab8c5a724043eb39fce5/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/073b0f9b852fa8b14ea4ab8c5a724043eb39fce5/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=073b0f9b852fa8b14ea4ab8c5a724043eb39fce5", "patch": "@@ -1,900 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub use self::Level::*;\n-pub use self::RenderSpan::*;\n-pub use self::ColorConfig::*;\n-use self::Destination::*;\n-\n-use codemap::{self, COMMAND_LINE_SP, COMMAND_LINE_EXPN, Pos, Span};\n-use diagnostics;\n-\n-use std::cell::{RefCell, Cell};\n-use std::{cmp, error, fmt};\n-use std::io::prelude::*;\n-use std::io;\n-use term;\n-\n-/// maximum number of lines we will print for each error; arbitrary.\n-const MAX_LINES: usize = 6;\n-\n-#[derive(Clone)]\n-pub enum RenderSpan {\n-    /// A FullSpan renders with both with an initial line for the\n-    /// message, prefixed by file:linenum, followed by a summary of\n-    /// the source code covered by the span.\n-    FullSpan(Span),\n-\n-    /// Similar to a FullSpan, but the cited position is the end of\n-    /// the span, instead of the start. Used, at least, for telling\n-    /// compiletest/runtest to look at the last line of the span\n-    /// (since `end_highlight_lines` displays an arrow to the end\n-    /// of the span).\n-    EndSpan(Span),\n-\n-    /// A suggestion renders with both with an initial line for the\n-    /// message, prefixed by file:linenum, followed by a summary\n-    /// of hypothetical source code, where the `String` is spliced\n-    /// into the lines in place of the code covered by the span.\n-    Suggestion(Span, String),\n-\n-    /// A FileLine renders with just a line for the message prefixed\n-    /// by file:linenum.\n-    FileLine(Span),\n-}\n-\n-impl RenderSpan {\n-    fn span(&self) -> Span {\n-        match *self {\n-            FullSpan(s) |\n-            Suggestion(s, _) |\n-            EndSpan(s) |\n-            FileLine(s) =>\n-                s\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Copy)]\n-pub enum ColorConfig {\n-    Auto,\n-    Always,\n-    Never\n-}\n-\n-pub trait Emitter {\n-    fn emit(&mut self, cmsp: Option<(&codemap::CodeMap, Span)>,\n-            msg: &str, code: Option<&str>, lvl: Level);\n-    fn custom_emit(&mut self, cm: &codemap::CodeMap,\n-                   sp: RenderSpan, msg: &str, lvl: Level);\n-}\n-\n-/// Used as a return value to signify a fatal error occurred. (It is also\n-/// used as the argument to panic at the moment, but that will eventually\n-/// not be true.)\n-#[derive(Copy, Clone, Debug)]\n-#[must_use]\n-pub struct FatalError;\n-\n-impl fmt::Display for FatalError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        write!(f, \"parser fatal error\")\n-    }\n-}\n-\n-impl error::Error for FatalError {\n-    fn description(&self) -> &str {\n-        \"The parser has encountered a fatal error\"\n-    }\n-}\n-\n-/// Signifies that the compiler died with an explicit call to `.bug`\n-/// or `.span_bug` rather than a failed assertion, etc.\n-#[derive(Copy, Clone, Debug)]\n-pub struct ExplicitBug;\n-\n-impl fmt::Display for ExplicitBug {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        write!(f, \"parser internal bug\")\n-    }\n-}\n-\n-impl error::Error for ExplicitBug {\n-    fn description(&self) -> &str {\n-        \"The parser has encountered an internal bug\"\n-    }\n-}\n-\n-/// A span-handler is like a handler but also\n-/// accepts span information for source-location\n-/// reporting.\n-pub struct SpanHandler {\n-    pub handler: Handler,\n-    pub cm: codemap::CodeMap,\n-}\n-\n-impl SpanHandler {\n-    pub fn new(handler: Handler, cm: codemap::CodeMap) -> SpanHandler {\n-        SpanHandler {\n-            handler: handler,\n-            cm: cm,\n-        }\n-    }\n-    pub fn span_fatal(&self, sp: Span, msg: &str) -> FatalError {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Fatal);\n-        return FatalError;\n-    }\n-    pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> FatalError {\n-        self.handler.emit_with_code(Some((&self.cm, sp)), msg, code, Fatal);\n-        return FatalError;\n-    }\n-    pub fn span_err(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Error);\n-        self.handler.bump_err_count();\n-    }\n-    pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n-        self.handler.emit_with_code(Some((&self.cm, sp)), msg, code, Error);\n-        self.handler.bump_err_count();\n-    }\n-    pub fn span_warn(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Warning);\n-    }\n-    pub fn span_warn_with_code(&self, sp: Span, msg: &str, code: &str) {\n-        self.handler.emit_with_code(Some((&self.cm, sp)), msg, code, Warning);\n-    }\n-    pub fn span_note(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Note);\n-    }\n-    pub fn span_end_note(&self, sp: Span, msg: &str) {\n-        self.handler.custom_emit(&self.cm, EndSpan(sp), msg, Note);\n-    }\n-    pub fn span_help(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Help);\n-    }\n-    /// Prints out a message with a suggested edit of the code.\n-    ///\n-    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n-    pub fn span_suggestion(&self, sp: Span, msg: &str, suggestion: String) {\n-        self.handler.custom_emit(&self.cm, Suggestion(sp, suggestion), msg, Help);\n-    }\n-    pub fn fileline_note(&self, sp: Span, msg: &str) {\n-        self.handler.custom_emit(&self.cm, FileLine(sp), msg, Note);\n-    }\n-    pub fn fileline_help(&self, sp: Span, msg: &str) {\n-        self.handler.custom_emit(&self.cm, FileLine(sp), msg, Help);\n-    }\n-    pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Bug);\n-        panic!(ExplicitBug);\n-    }\n-    pub fn span_bug_no_panic(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Bug);\n-        self.handler.bump_err_count();\n-    }\n-    pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n-        self.span_bug(sp, &format!(\"unimplemented {}\", msg));\n-    }\n-    pub fn handler<'a>(&'a self) -> &'a Handler {\n-        &self.handler\n-    }\n-}\n-\n-/// A handler deals with errors; certain errors\n-/// (fatal, bug, unimpl) may cause immediate exit,\n-/// others log errors for later reporting.\n-pub struct Handler {\n-    err_count: Cell<usize>,\n-    emit: RefCell<Box<Emitter + Send>>,\n-    pub can_emit_warnings: bool\n-}\n-\n-impl Handler {\n-    pub fn new(color_config: ColorConfig,\n-               registry: Option<diagnostics::registry::Registry>,\n-               can_emit_warnings: bool) -> Handler {\n-        let emitter = Box::new(EmitterWriter::stderr(color_config, registry));\n-        Handler::with_emitter(can_emit_warnings, emitter)\n-    }\n-    pub fn with_emitter(can_emit_warnings: bool, e: Box<Emitter + Send>) -> Handler {\n-        Handler {\n-            err_count: Cell::new(0),\n-            emit: RefCell::new(e),\n-            can_emit_warnings: can_emit_warnings\n-        }\n-    }\n-    pub fn fatal(&self, msg: &str) -> FatalError {\n-        self.emit.borrow_mut().emit(None, msg, None, Fatal);\n-        FatalError\n-    }\n-    pub fn err(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(None, msg, None, Error);\n-        self.bump_err_count();\n-    }\n-    pub fn bump_err_count(&self) {\n-        self.err_count.set(self.err_count.get() + 1);\n-    }\n-    pub fn err_count(&self) -> usize {\n-        self.err_count.get()\n-    }\n-    pub fn has_errors(&self) -> bool {\n-        self.err_count.get() > 0\n-    }\n-    pub fn abort_if_errors(&self) {\n-        let s;\n-        match self.err_count.get() {\n-            0 => return,\n-            1 => s = \"aborting due to previous error\".to_string(),\n-            _  => {\n-                s = format!(\"aborting due to {} previous errors\",\n-                            self.err_count.get());\n-            }\n-        }\n-\n-        panic!(self.fatal(&s[..]));\n-    }\n-    pub fn warn(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(None, msg, None, Warning);\n-    }\n-    pub fn note(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(None, msg, None, Note);\n-    }\n-    pub fn help(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(None, msg, None, Help);\n-    }\n-    pub fn bug(&self, msg: &str) -> ! {\n-        self.emit.borrow_mut().emit(None, msg, None, Bug);\n-        panic!(ExplicitBug);\n-    }\n-    pub fn unimpl(&self, msg: &str) -> ! {\n-        self.bug(&format!(\"unimplemented {}\", msg));\n-    }\n-    pub fn emit(&self,\n-                cmsp: Option<(&codemap::CodeMap, Span)>,\n-                msg: &str,\n-                lvl: Level) {\n-        if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().emit(cmsp, msg, None, lvl);\n-    }\n-    pub fn emit_with_code(&self,\n-                          cmsp: Option<(&codemap::CodeMap, Span)>,\n-                          msg: &str,\n-                          code: &str,\n-                          lvl: Level) {\n-        if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().emit(cmsp, msg, Some(code), lvl);\n-    }\n-    pub fn custom_emit(&self, cm: &codemap::CodeMap,\n-                       sp: RenderSpan, msg: &str, lvl: Level) {\n-        if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().custom_emit(cm, sp, msg, lvl);\n-    }\n-}\n-\n-#[derive(Copy, PartialEq, Clone, Debug)]\n-pub enum Level {\n-    Bug,\n-    Fatal,\n-    Error,\n-    Warning,\n-    Note,\n-    Help,\n-}\n-\n-impl fmt::Display for Level {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        use std::fmt::Display;\n-\n-        match *self {\n-            Bug => \"error: internal compiler error\".fmt(f),\n-            Fatal | Error => \"error\".fmt(f),\n-            Warning => \"warning\".fmt(f),\n-            Note => \"note\".fmt(f),\n-            Help => \"help\".fmt(f),\n-        }\n-    }\n-}\n-\n-impl Level {\n-    fn color(self) -> term::color::Color {\n-        match self {\n-            Bug | Fatal | Error => term::color::BRIGHT_RED,\n-            Warning => term::color::BRIGHT_YELLOW,\n-            Note => term::color::BRIGHT_GREEN,\n-            Help => term::color::BRIGHT_CYAN,\n-        }\n-    }\n-}\n-\n-pub struct EmitterWriter {\n-    dst: Destination,\n-    registry: Option<diagnostics::registry::Registry>\n-}\n-\n-enum Destination {\n-    Terminal(Box<term::StderrTerminal>),\n-    Raw(Box<Write + Send>),\n-}\n-\n-/// Do not use this for messages that end in `\\n` \u2013 use `println_maybe_styled` instead. See\n-/// `EmitterWriter::print_maybe_styled` for details.\n-macro_rules! print_maybe_styled {\n-    ($writer: expr, $style: expr, $($arg: tt)*) => {\n-        $writer.print_maybe_styled(format_args!($($arg)*), $style, false)\n-    }\n-}\n-\n-macro_rules! println_maybe_styled {\n-    ($writer: expr, $style: expr, $($arg: tt)*) => {\n-        $writer.print_maybe_styled(format_args!($($arg)*), $style, true)\n-    }\n-}\n-\n-impl EmitterWriter {\n-    pub fn stderr(color_config: ColorConfig,\n-                  registry: Option<diagnostics::registry::Registry>) -> EmitterWriter {\n-        let stderr = io::stderr();\n-\n-        let use_color = match color_config {\n-            Always => true,\n-            Never  => false,\n-            Auto   => stderr_isatty(),\n-        };\n-\n-        if use_color {\n-            let dst = match term::stderr() {\n-                Some(t) => Terminal(t),\n-                None    => Raw(Box::new(stderr)),\n-            };\n-            EmitterWriter { dst: dst, registry: registry }\n-        } else {\n-            EmitterWriter { dst: Raw(Box::new(stderr)), registry: registry }\n-        }\n-    }\n-\n-    pub fn new(dst: Box<Write + Send>,\n-               registry: Option<diagnostics::registry::Registry>) -> EmitterWriter {\n-        EmitterWriter { dst: Raw(dst), registry: registry }\n-    }\n-\n-    fn print_maybe_styled(&mut self,\n-                          args: fmt::Arguments,\n-                          color: term::Attr,\n-                          print_newline_at_end: bool) -> io::Result<()> {\n-        match self.dst {\n-            Terminal(ref mut t) => {\n-                try!(t.attr(color));\n-                // If `msg` ends in a newline, we need to reset the color before\n-                // the newline. We're making the assumption that we end up writing\n-                // to a `LineBufferedWriter`, which means that emitting the reset\n-                // after the newline ends up buffering the reset until we print\n-                // another line or exit. Buffering the reset is a problem if we're\n-                // sharing the terminal with any other programs (e.g. other rustc\n-                // instances via `make -jN`).\n-                //\n-                // Note that if `msg` contains any internal newlines, this will\n-                // result in the `LineBufferedWriter` flushing twice instead of\n-                // once, which still leaves the opportunity for interleaved output\n-                // to be miscolored. We assume this is rare enough that we don't\n-                // have to worry about it.\n-                try!(t.write_fmt(args));\n-                try!(t.reset());\n-                if print_newline_at_end {\n-                    t.write_all(b\"\\n\")\n-                } else {\n-                    Ok(())\n-                }\n-            }\n-            Raw(ref mut w) => {\n-                try!(w.write_fmt(args));\n-                if print_newline_at_end {\n-                    w.write_all(b\"\\n\")\n-                } else {\n-                    Ok(())\n-                }\n-            }\n-        }\n-    }\n-\n-    fn print_diagnostic(&mut self, topic: &str, lvl: Level,\n-                        msg: &str, code: Option<&str>) -> io::Result<()> {\n-        if !topic.is_empty() {\n-            try!(write!(&mut self.dst, \"{} \", topic));\n-        }\n-\n-        try!(print_maybe_styled!(self, term::Attr::ForegroundColor(lvl.color()),\n-                                 \"{}: \", lvl.to_string()));\n-        try!(print_maybe_styled!(self, term::Attr::Bold, \"{}\", msg));\n-\n-        match code {\n-            Some(code) => {\n-                let style = term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n-                try!(print_maybe_styled!(self, style, \" [{}]\", code.clone()));\n-            }\n-            None => ()\n-        }\n-        try!(write!(&mut self.dst, \"\\n\"));\n-        Ok(())\n-    }\n-\n-    fn emit_(&mut self, cm: &codemap::CodeMap, rsp: RenderSpan,\n-             msg: &str, code: Option<&str>, lvl: Level) -> io::Result<()> {\n-        let sp = rsp.span();\n-\n-        // We cannot check equality directly with COMMAND_LINE_SP\n-        // since PartialEq is manually implemented to ignore the ExpnId\n-        let ss = if sp.expn_id == COMMAND_LINE_EXPN {\n-            \"<command line option>\".to_string()\n-        } else if let EndSpan(_) = rsp {\n-            let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n-            cm.span_to_string(span_end)\n-        } else {\n-            cm.span_to_string(sp)\n-        };\n-\n-        try!(self.print_diagnostic(&ss[..], lvl, msg, code));\n-\n-        match rsp {\n-            FullSpan(_) => {\n-                try!(self.highlight_lines(cm, sp, lvl, cm.span_to_lines(sp)));\n-                try!(self.print_macro_backtrace(cm, sp));\n-            }\n-            EndSpan(_) => {\n-                try!(self.end_highlight_lines(cm, sp, lvl, cm.span_to_lines(sp)));\n-                try!(self.print_macro_backtrace(cm, sp));\n-            }\n-            Suggestion(_, ref suggestion) => {\n-                try!(self.highlight_suggestion(cm, sp, suggestion));\n-                try!(self.print_macro_backtrace(cm, sp));\n-            }\n-            FileLine(..) => {\n-                // no source text in this case!\n-            }\n-        }\n-\n-        match code {\n-            Some(code) =>\n-                match self.registry.as_ref().and_then(|registry| registry.find_description(code)) {\n-                    Some(_) => {\n-                        try!(self.print_diagnostic(&ss[..], Help,\n-                                                   &format!(\"run `rustc --explain {}` to see a \\\n-                                                             detailed explanation\", code), None));\n-                    }\n-                    None => ()\n-                },\n-            None => (),\n-        }\n-        Ok(())\n-    }\n-\n-    fn highlight_suggestion(&mut self,\n-                            cm: &codemap::CodeMap,\n-                            sp: Span,\n-                            suggestion: &str)\n-                            -> io::Result<()>\n-    {\n-        let lines = cm.span_to_lines(sp).unwrap();\n-        assert!(!lines.lines.is_empty());\n-\n-        // To build up the result, we want to take the snippet from the first\n-        // line that precedes the span, prepend that with the suggestion, and\n-        // then append the snippet from the last line that trails the span.\n-        let fm = &lines.file;\n-\n-        let first_line = &lines.lines[0];\n-        let prefix = fm.get_line(first_line.line_index)\n-                       .map(|l| &l[..first_line.start_col.0])\n-                       .unwrap_or(\"\");\n-\n-        let last_line = lines.lines.last().unwrap();\n-        let suffix = fm.get_line(last_line.line_index)\n-                       .map(|l| &l[last_line.end_col.0..])\n-                       .unwrap_or(\"\");\n-\n-        let complete = format!(\"{}{}{}\", prefix, suggestion, suffix);\n-\n-        // print the suggestion without any line numbers, but leave\n-        // space for them. This helps with lining up with previous\n-        // snippets from the actual error being reported.\n-        let fm = &*lines.file;\n-        let mut lines = complete.lines();\n-        for (line, line_index) in lines.by_ref().take(MAX_LINES).zip(first_line.line_index..) {\n-            let elided_line_num = format!(\"{}\", line_index+1);\n-            try!(write!(&mut self.dst, \"{0}:{1:2$} {3}\\n\",\n-                        fm.name, \"\", elided_line_num.len(), line));\n-        }\n-\n-        // if we elided some lines, add an ellipsis\n-        if lines.next().is_some() {\n-            let elided_line_num = format!(\"{}\", first_line.line_index + MAX_LINES + 1);\n-            try!(write!(&mut self.dst, \"{0:1$} {0:2$} ...\\n\",\n-                        \"\", fm.name.len(), elided_line_num.len()));\n-        }\n-\n-        Ok(())\n-    }\n-\n-    fn highlight_lines(&mut self,\n-                       cm: &codemap::CodeMap,\n-                       sp: Span,\n-                       lvl: Level,\n-                       lines: codemap::FileLinesResult)\n-                       -> io::Result<()>\n-    {\n-        let lines = match lines {\n-            Ok(lines) => lines,\n-            Err(_) => {\n-                try!(write!(&mut self.dst, \"(internal compiler error: unprintable span)\\n\"));\n-                return Ok(());\n-            }\n-        };\n-\n-        let fm = &*lines.file;\n-\n-        let line_strings: Option<Vec<&str>> =\n-            lines.lines.iter()\n-                       .map(|info| fm.get_line(info.line_index))\n-                       .collect();\n-\n-        let line_strings = match line_strings {\n-            None => { return Ok(()); }\n-            Some(line_strings) => line_strings\n-        };\n-\n-        // Display only the first MAX_LINES lines.\n-        let all_lines = lines.lines.len();\n-        let display_lines = cmp::min(all_lines, MAX_LINES);\n-        let display_line_infos = &lines.lines[..display_lines];\n-        let display_line_strings = &line_strings[..display_lines];\n-\n-        // Calculate the widest number to format evenly and fix #11715\n-        assert!(display_line_infos.len() > 0);\n-        let mut max_line_num = display_line_infos[display_line_infos.len() - 1].line_index + 1;\n-        let mut digits = 0;\n-        while max_line_num > 0 {\n-            max_line_num /= 10;\n-            digits += 1;\n-        }\n-\n-        // Print the offending lines\n-        for (line_info, line) in display_line_infos.iter().zip(display_line_strings) {\n-            try!(write!(&mut self.dst, \"{}:{:>width$} {}\\n\",\n-                        fm.name,\n-                        line_info.line_index + 1,\n-                        line,\n-                        width=digits));\n-        }\n-\n-        // If we elided something, put an ellipsis.\n-        if display_lines < all_lines {\n-            let last_line_index = display_line_infos.last().unwrap().line_index;\n-            let s = format!(\"{}:{} \", fm.name, last_line_index + 1);\n-            try!(write!(&mut self.dst, \"{0:1$}...\\n\", \"\", s.len()));\n-        }\n-\n-        // FIXME (#3260)\n-        // If there's one line at fault we can easily point to the problem\n-        if lines.lines.len() == 1 {\n-            let lo = cm.lookup_char_pos(sp.lo);\n-            let mut digits = 0;\n-            let mut num = (lines.lines[0].line_index + 1) / 10;\n-\n-            // how many digits must be indent past?\n-            while num > 0 { num /= 10; digits += 1; }\n-\n-            let mut s = String::new();\n-            // Skip is the number of characters we need to skip because they are\n-            // part of the 'filename:line ' part of the previous line.\n-            let skip = fm.name.chars().count() + digits + 3;\n-            for _ in 0..skip {\n-                s.push(' ');\n-            }\n-            if let Some(orig) = fm.get_line(lines.lines[0].line_index) {\n-                let mut col = skip;\n-                let mut lastc = ' ';\n-                let mut iter = orig.chars().enumerate();\n-                for (pos, ch) in iter.by_ref() {\n-                    lastc = ch;\n-                    if pos >= lo.col.to_usize() { break; }\n-                    // Whenever a tab occurs on the previous line, we insert one on\n-                    // the error-point-squiggly-line as well (instead of a space).\n-                    // That way the squiggly line will usually appear in the correct\n-                    // position.\n-                    match ch {\n-                        '\\t' => {\n-                            col += 8 - col%8;\n-                            s.push('\\t');\n-                        },\n-                        _ => {\n-                            col += 1;\n-                            s.push(' ');\n-                        },\n-                    }\n-                }\n-\n-                try!(write!(&mut self.dst, \"{}\", s));\n-                let mut s = String::from(\"^\");\n-                let count = match lastc {\n-                    // Most terminals have a tab stop every eight columns by default\n-                    '\\t' => 8 - col%8,\n-                    _ => 1,\n-                };\n-                col += count;\n-                s.extend(::std::iter::repeat('~').take(count));\n-\n-                let hi = cm.lookup_char_pos(sp.hi);\n-                if hi.col != lo.col {\n-                    for (pos, ch) in iter {\n-                        if pos >= hi.col.to_usize() { break; }\n-                        let count = match ch {\n-                            '\\t' => 8 - col%8,\n-                            _ => 1,\n-                        };\n-                        col += count;\n-                        s.extend(::std::iter::repeat('~').take(count));\n-                    }\n-                }\n-\n-                if s.len() > 1 {\n-                    // One extra squiggly is replaced by a \"^\"\n-                    s.pop();\n-                }\n-\n-                try!(println_maybe_styled!(self, term::Attr::ForegroundColor(lvl.color()),\n-                                           \"{}\", s));\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    /// Here are the differences between this and the normal `highlight_lines`:\n-    /// `end_highlight_lines` will always put arrow on the last byte of the\n-    /// span (instead of the first byte). Also, when the span is too long (more\n-    /// than 6 lines), `end_highlight_lines` will print the first line, then\n-    /// dot dot dot, then last line, whereas `highlight_lines` prints the first\n-    /// six lines.\n-    #[allow(deprecated)]\n-    fn end_highlight_lines(&mut self,\n-                           cm: &codemap::CodeMap,\n-                           sp: Span,\n-                           lvl: Level,\n-                           lines: codemap::FileLinesResult)\n-                          -> io::Result<()> {\n-        let lines = match lines {\n-            Ok(lines) => lines,\n-            Err(_) => {\n-                try!(write!(&mut self.dst, \"(internal compiler error: unprintable span)\\n\"));\n-                return Ok(());\n-            }\n-        };\n-\n-        let fm = &*lines.file;\n-\n-        let lines = &lines.lines[..];\n-        if lines.len() > MAX_LINES {\n-            if let Some(line) = fm.get_line(lines[0].line_index) {\n-                try!(write!(&mut self.dst, \"{}:{} {}\\n\", fm.name,\n-                            lines[0].line_index + 1, line));\n-            }\n-            try!(write!(&mut self.dst, \"...\\n\"));\n-            let last_line_index = lines[lines.len() - 1].line_index;\n-            if let Some(last_line) = fm.get_line(last_line_index) {\n-                try!(write!(&mut self.dst, \"{}:{} {}\\n\", fm.name,\n-                            last_line_index + 1, last_line));\n-            }\n-        } else {\n-            for line_info in lines {\n-                if let Some(line) = fm.get_line(line_info.line_index) {\n-                    try!(write!(&mut self.dst, \"{}:{} {}\\n\", fm.name,\n-                                line_info.line_index + 1, line));\n-                }\n-            }\n-        }\n-        let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1].line_index + 1);\n-        let hi = cm.lookup_char_pos(sp.hi);\n-        let skip = last_line_start.chars().count();\n-        let mut s = String::new();\n-        for _ in 0..skip {\n-            s.push(' ');\n-        }\n-        if let Some(orig) = fm.get_line(lines[0].line_index) {\n-            let iter = orig.chars().enumerate();\n-            for (pos, ch) in iter {\n-                // Span seems to use half-opened interval, so subtract 1\n-                if pos >= hi.col.to_usize() - 1 { break; }\n-                // Whenever a tab occurs on the previous line, we insert one on\n-                // the error-point-squiggly-line as well (instead of a space).\n-                // That way the squiggly line will usually appear in the correct\n-                // position.\n-                match ch {\n-                    '\\t' => s.push('\\t'),\n-                    _ => s.push(' '),\n-                }\n-            }\n-        }\n-        s.push('^');\n-        println_maybe_styled!(self, term::Attr::ForegroundColor(lvl.color()),\n-                              \"{}\", s)\n-    }\n-\n-    fn print_macro_backtrace(&mut self,\n-                             cm: &codemap::CodeMap,\n-                             sp: Span)\n-                             -> io::Result<()> {\n-        let mut last_span = codemap::DUMMY_SP;\n-        let mut sp_opt = Some(sp);\n-\n-        while let Some(sp) = sp_opt {\n-            sp_opt = try!(cm.with_expn_info(sp.expn_id, |expn_info| -> io::Result<_> {\n-                match expn_info {\n-                    Some(ei) => {\n-                        let (pre, post) = match ei.callee.format {\n-                            codemap::MacroAttribute(..) => (\"#[\", \"]\"),\n-                            codemap::MacroBang(..) => (\"\", \"!\"),\n-                        };\n-                        // Don't print recursive invocations\n-                        if ei.call_site != last_span {\n-                            last_span = ei.call_site;\n-\n-                            let mut diag_string = format!(\"in this expansion of {}{}{}\",\n-                                                          pre,\n-                                                          ei.callee.name(),\n-                                                          post);\n-\n-                            if let Some(def_site_span) = ei.callee.span {\n-                                diag_string.push_str(&format!(\" (defined in {})\",\n-                                                              cm.span_to_filename(def_site_span)));\n-                            }\n-\n-                            try!(self.print_diagnostic(&cm.span_to_string(ei.call_site),\n-                                                       Note,\n-                                                       &diag_string,\n-                                                       None));\n-                        }\n-                        Ok(Some(ei.call_site))\n-                    }\n-                    None => Ok(None)\n-                }\n-            }));\n-        }\n-\n-        Ok(())\n-    }\n-}\n-\n-#[cfg(unix)]\n-fn stderr_isatty() -> bool {\n-    use libc;\n-    unsafe { libc::isatty(libc::STDERR_FILENO) != 0 }\n-}\n-#[cfg(windows)]\n-fn stderr_isatty() -> bool {\n-    type DWORD = u32;\n-    type BOOL = i32;\n-    type HANDLE = *mut u8;\n-    const STD_ERROR_HANDLE: DWORD = -12i32 as DWORD;\n-    extern \"system\" {\n-        fn GetStdHandle(which: DWORD) -> HANDLE;\n-        fn GetConsoleMode(hConsoleHandle: HANDLE,\n-                          lpMode: *mut DWORD) -> BOOL;\n-    }\n-    unsafe {\n-        let handle = GetStdHandle(STD_ERROR_HANDLE);\n-        let mut out = 0;\n-        GetConsoleMode(handle, &mut out) != 0\n-    }\n-}\n-\n-impl Write for Destination {\n-    fn write(&mut self, bytes: &[u8]) -> io::Result<usize> {\n-        match *self {\n-            Terminal(ref mut t) => t.write(bytes),\n-            Raw(ref mut w) => w.write(bytes),\n-        }\n-    }\n-    fn flush(&mut self) -> io::Result<()> {\n-        match *self {\n-            Terminal(ref mut t) => t.flush(),\n-            Raw(ref mut w) => w.flush(),\n-        }\n-    }\n-}\n-\n-impl Emitter for EmitterWriter {\n-    fn emit(&mut self,\n-            cmsp: Option<(&codemap::CodeMap, Span)>,\n-            msg: &str, code: Option<&str>, lvl: Level) {\n-        let error = match cmsp {\n-            Some((cm, COMMAND_LINE_SP)) => self.emit_(cm,\n-                                                FileLine(COMMAND_LINE_SP),\n-                                                msg, code, lvl),\n-            Some((cm, sp)) => self.emit_(cm, FullSpan(sp), msg, code, lvl),\n-            None => self.print_diagnostic(\"\", lvl, msg, code),\n-        };\n-\n-        match error {\n-            Ok(()) => {}\n-            Err(e) => panic!(\"failed to print diagnostics: {:?}\", e),\n-        }\n-    }\n-\n-    fn custom_emit(&mut self, cm: &codemap::CodeMap,\n-                   sp: RenderSpan, msg: &str, lvl: Level) {\n-        match self.emit_(cm, sp, msg, None, lvl) {\n-            Ok(()) => {}\n-            Err(e) => panic!(\"failed to print diagnostics: {:?}\", e),\n-        }\n-    }\n-}\n-\n-pub fn expect<T, M>(diag: &SpanHandler, opt: Option<T>, msg: M) -> T where\n-    M: FnOnce() -> String,\n-{\n-    match opt {\n-        Some(t) => t,\n-        None => diag.handler().bug(&msg()),\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::{EmitterWriter, Level};\n-    use codemap::{mk_sp, CodeMap};\n-    use std::sync::{Arc, Mutex};\n-    use std::io::{self, Write};\n-    use std::str::from_utf8;\n-\n-    // Diagnostic doesn't align properly in span where line number increases by one digit\n-    #[test]\n-    fn test_hilight_suggestion_issue_11715() {\n-        struct Sink(Arc<Mutex<Vec<u8>>>);\n-        impl Write for Sink {\n-            fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-                Write::write(&mut *self.0.lock().unwrap(), data)\n-            }\n-            fn flush(&mut self) -> io::Result<()> { Ok(()) }\n-        }\n-        let data = Arc::new(Mutex::new(Vec::new()));\n-        let mut ew = EmitterWriter::new(Box::new(Sink(data.clone())), None);\n-        let cm = CodeMap::new();\n-        let content = \"abcdefg\n-        koksi\n-        line3\n-        line4\n-        cinq\n-        line6\n-        line7\n-        line8\n-        line9\n-        line10\n-        e-l\u00e4-v\u00e4n\n-        tolv\n-        dreizehn\n-        \";\n-        let file = cm.new_filemap_and_lines(\"dummy.txt\", content);\n-        let start = file.lines.borrow()[7];\n-        let end = file.lines.borrow()[11];\n-        let sp = mk_sp(start, end);\n-        let lvl = Level::Error;\n-        println!(\"span_to_lines\");\n-        let lines = cm.span_to_lines(sp);\n-        println!(\"highlight_lines\");\n-        ew.highlight_lines(&cm, sp, lvl, lines).unwrap();\n-        println!(\"done\");\n-        let vec = data.lock().unwrap().clone();\n-        let vec: &[u8] = &vec;\n-        let str = from_utf8(vec).unwrap();\n-        println!(\"{}\", str);\n-        assert_eq!(str, \"dummy.txt: 8         line8\\n\\\n-                         dummy.txt: 9         line9\\n\\\n-                         dummy.txt:10         line10\\n\\\n-                         dummy.txt:11         e-l\u00e4-v\u00e4n\\n\\\n-                         dummy.txt:12         tolv\\n\");\n-    }\n-}"}, {"sha": "f198460137d5f78f070af026c1c63e66c45d90be", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -720,7 +720,7 @@ impl<'a> ExtCtxt<'a> {\n         self.parse_sess.span_diagnostic.fileline_help(sp, msg);\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n-        self.parse_sess.span_diagnostic.handler().bug(msg);\n+        self.parse_sess.span_diagnostic.bug(msg);\n     }\n     pub fn trace_macros(&self) -> bool {\n         self.ecfg.trace_mac"}, {"sha": "4f9888b746e8696c6bcd6a4dbc7422139f8f1309", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -1301,7 +1301,7 @@ pub fn expand_crate(mut cx: ExtCtxt,\n \n         let mut ret = expander.fold_crate(c);\n         ret.exported_macros = expander.cx.exported_macros.clone();\n-        cx.parse_sess.span_diagnostic.handler().abort_if_errors();\n+        cx.parse_sess.span_diagnostic.abort_if_errors();\n         ret\n     };\n     return (ret, cx.syntax_env.names);"}, {"sha": "29360f14838cc4bbaca664520f5df2cfb5962302", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -12,7 +12,7 @@ use self::LockstepIterSize::*;\n use ast;\n use ast::{TokenTree, Ident, Name};\n use codemap::{Span, DUMMY_SP};\n-use diagnostic::SpanHandler;\n+use errors::Handler;\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n use parse::token::{Eof, DocComment, Interpolated, MatchNt, SubstNt};\n use parse::token::{Token, NtIdent, SpecialMacroVar};\n@@ -34,7 +34,7 @@ struct TtFrame {\n \n #[derive(Clone)]\n pub struct TtReader<'a> {\n-    pub sp_diag: &'a SpanHandler,\n+    pub sp_diag: &'a Handler,\n     /// the unzipped tree:\n     stack: Vec<TtFrame>,\n     /* for MBE-style macro transcription */\n@@ -55,7 +55,7 @@ pub struct TtReader<'a> {\n /// This can do Macro-By-Example transcription. On the other hand, if\n /// `src` contains no `TokenTree::Sequence`s, `MatchNt`s or `SubstNt`s, `interp` can\n /// (and should) be None.\n-pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n+pub fn new_tt_reader<'a>(sp_diag: &'a Handler,\n                          interp: Option<HashMap<Name, Rc<NamedMatch>>>,\n                          imported_from: Option<Ident>,\n                          src: Vec<ast::TokenTree>)\n@@ -69,7 +69,7 @@ pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n /// This can do Macro-By-Example transcription. On the other hand, if\n /// `src` contains no `TokenTree::Sequence`s, `MatchNt`s or `SubstNt`s, `interp` can\n /// (and should) be None.\n-pub fn new_tt_reader_with_doc_flag<'a>(sp_diag: &'a SpanHandler,\n+pub fn new_tt_reader_with_doc_flag<'a>(sp_diag: &'a Handler,\n                                        interp: Option<HashMap<Name, Rc<NamedMatch>>>,\n                                        imported_from: Option<Ident>,\n                                        src: Vec<ast::TokenTree>,"}, {"sha": "89f318d09451b8b56c4890ce54bc9346ee1e525a", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -32,7 +32,7 @@ use ast;\n use attr;\n use attr::AttrMetaMethods;\n use codemap::{CodeMap, Span};\n-use diagnostic::SpanHandler;\n+use errors::Handler;\n use visit;\n use visit::{FnKind, Visitor};\n use parse::token::InternedString;\n@@ -446,7 +446,7 @@ impl PartialOrd for GatedCfgAttr {\n }\n \n impl GatedCfgAttr {\n-    pub fn check_and_emit(&self, diagnostic: &SpanHandler, features: &Features) {\n+    pub fn check_and_emit(&self, diagnostic: &Handler, features: &Features) {\n         match *self {\n             GatedCfgAttr::GatedCfg(ref cfg) => {\n                 cfg.check_and_emit(diagnostic, features);\n@@ -476,7 +476,7 @@ impl GatedCfg {\n                       }\n                   })\n     }\n-    fn check_and_emit(&self, diagnostic: &SpanHandler, features: &Features) {\n+    fn check_and_emit(&self, diagnostic: &Handler, features: &Features) {\n         let (cfg, feature, has_feature) = GATED_CFGS[self.index];\n         if !has_feature(features) {\n             let explain = format!(\"`cfg({})` is experimental and subject to change\", cfg);\n@@ -595,21 +595,21 @@ const EXPLAIN_PUSHPOP_UNSAFE: &'static str =\n const EXPLAIN_STMT_ATTR_SYNTAX: &'static str =\n     \"attributes on non-item statements and expressions are experimental.\";\n \n-pub fn check_for_box_syntax(f: Option<&Features>, diag: &SpanHandler, span: Span) {\n+pub fn check_for_box_syntax(f: Option<&Features>, diag: &Handler, span: Span) {\n     if let Some(&Features { allow_box: true, .. }) = f {\n         return;\n     }\n     emit_feature_err(diag, \"box_syntax\", span, GateIssue::Language, EXPLAIN_BOX_SYNTAX);\n }\n \n-pub fn check_for_placement_in(f: Option<&Features>, diag: &SpanHandler, span: Span) {\n+pub fn check_for_placement_in(f: Option<&Features>, diag: &Handler, span: Span) {\n     if let Some(&Features { allow_placement_in: true, .. }) = f {\n         return;\n     }\n     emit_feature_err(diag, \"placement_in_syntax\", span, GateIssue::Language, EXPLAIN_PLACEMENT_IN);\n }\n \n-pub fn check_for_pushpop_syntax(f: Option<&Features>, diag: &SpanHandler, span: Span) {\n+pub fn check_for_pushpop_syntax(f: Option<&Features>, diag: &Handler, span: Span) {\n     if let Some(&Features { allow_pushpop_unsafe: true, .. }) = f {\n         return;\n     }\n@@ -618,7 +618,7 @@ pub fn check_for_pushpop_syntax(f: Option<&Features>, diag: &SpanHandler, span:\n \n struct Context<'a> {\n     features: Vec<&'static str>,\n-    span_handler: &'a SpanHandler,\n+    span_handler: &'a Handler,\n     cm: &'a CodeMap,\n     plugin_attributes: &'a [(String, AttributeType)],\n }\n@@ -704,7 +704,7 @@ pub enum GateIssue {\n     Library(Option<u32>)\n }\n \n-pub fn emit_feature_err(diag: &SpanHandler, feature: &str, span: Span, issue: GateIssue,\n+pub fn emit_feature_err(diag: &Handler, feature: &str, span: Span, issue: GateIssue,\n                         explain: &str) {\n     let issue = match issue {\n         GateIssue::Language => find_lang_feature_issue(feature),\n@@ -1064,7 +1064,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     }\n }\n \n-fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n+fn check_crate_inner<F>(cm: &CodeMap, span_handler: &Handler,\n                         krate: &ast::Crate,\n                         plugin_attributes: &[(String, AttributeType)],\n                         check: F)\n@@ -1161,13 +1161,13 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n     }\n }\n \n-pub fn check_crate_macros(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::Crate)\n+pub fn check_crate_macros(cm: &CodeMap, span_handler: &Handler, krate: &ast::Crate)\n -> Features {\n     check_crate_inner(cm, span_handler, krate, &[] as &'static [_],\n                       |ctx, krate| visit::walk_crate(&mut MacroVisitor { context: ctx }, krate))\n }\n \n-pub fn check_crate(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::Crate,\n+pub fn check_crate(cm: &CodeMap, span_handler: &Handler, krate: &ast::Crate,\n                    plugin_attributes: &[(String, AttributeType)],\n                    unstable: UnstableFeatures) -> Features\n {\n@@ -1192,7 +1192,7 @@ pub enum UnstableFeatures {\n     Cheat\n }\n \n-fn maybe_stage_features(span_handler: &SpanHandler, krate: &ast::Crate,\n+fn maybe_stage_features(span_handler: &Handler, krate: &ast::Crate,\n                         unstable: UnstableFeatures) {\n     let allow_features = match unstable {\n         UnstableFeatures::Allow => true,"}, {"sha": "47340d312242b2b0d220baf7821874dc93f85fae", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -52,7 +52,7 @@ extern crate serialize as rustc_serialize; // used by deriving\n macro_rules! panictry {\n     ($e:expr) => ({\n         use std::result::Result::{Ok, Err};\n-        use diagnostic::FatalError;\n+        use errors::FatalError;\n         match $e {\n             Ok(e) => e,\n             Err(FatalError) => panic!(FatalError)\n@@ -78,6 +78,8 @@ pub mod diagnostics {\n     pub mod metadata;\n }\n \n+pub mod errors;\n+\n pub mod syntax {\n     pub use ext;\n     pub use parse;\n@@ -90,7 +92,6 @@ pub mod ast_util;\n pub mod attr;\n pub mod codemap;\n pub mod config;\n-pub mod diagnostic;\n pub mod entry;\n pub mod feature_gate;\n pub mod fold;"}, {"sha": "d2156d7cb68d25ae45b0420eb608b359ebe71ba7", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -12,7 +12,7 @@ pub use self::CommentStyle::*;\n \n use ast;\n use codemap::{BytePos, CharPos, CodeMap, Pos};\n-use diagnostic;\n+use errors;\n use parse::lexer::is_block_doc_comment;\n use parse::lexer::{StringReader, TokenAndSpan};\n use parse::lexer::{is_whitespace, Reader};\n@@ -334,7 +334,7 @@ pub struct Literal {\n \n // it appears this function is called only from pprust... that's\n // probably not a good thing.\n-pub fn gather_comments_and_literals(span_diagnostic: &diagnostic::SpanHandler,\n+pub fn gather_comments_and_literals(span_diagnostic: &errors::Handler,\n                                     path: String,\n                                     srdr: &mut Read)\n                                  -> (Vec<Comment>, Vec<Literal>) {"}, {"sha": "570e0882a8513ee969d21efd50ab92c666963f34", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -11,8 +11,7 @@\n use ast;\n use codemap::{BytePos, CharPos, CodeMap, Pos, Span};\n use codemap;\n-use diagnostic::FatalError;\n-use diagnostic::SpanHandler;\n+use errors::{FatalError, Handler};\n use ext::tt::transcribe::tt_next_token;\n use parse::token::str_to_ident;\n use parse::token;\n@@ -58,7 +57,7 @@ pub struct TokenAndSpan {\n }\n \n pub struct StringReader<'a> {\n-    pub span_diagnostic: &'a SpanHandler,\n+    pub span_diagnostic: &'a Handler,\n     /// The absolute offset within the codemap of the next character to read\n     pub pos: BytePos,\n     /// The absolute offset within the codemap of the last character read(curr)\n@@ -128,10 +127,10 @@ impl<'a> Reader for TtReader<'a> {\n \n impl<'a> StringReader<'a> {\n     /// For comments.rs, which hackily pokes into pos and curr\n-    pub fn new_raw<'b>(span_diagnostic: &'b SpanHandler,\n+    pub fn new_raw<'b>(span_diagnostic: &'b Handler,\n                        filemap: Rc<codemap::FileMap>) -> StringReader<'b> {\n         if filemap.src.is_none() {\n-            span_diagnostic.handler.bug(&format!(\"Cannot lex filemap without source: {}\",\n+            span_diagnostic.bug(&format!(\"Cannot lex filemap without source: {}\",\n                                                  filemap.name)[..]);\n         }\n \n@@ -153,7 +152,7 @@ impl<'a> StringReader<'a> {\n         sr\n     }\n \n-    pub fn new<'b>(span_diagnostic: &'b SpanHandler,\n+    pub fn new<'b>(span_diagnostic: &'b Handler,\n                    filemap: Rc<codemap::FileMap>) -> StringReader<'b> {\n         let mut sr = StringReader::new_raw(span_diagnostic, filemap);\n         sr.advance_token();\n@@ -1428,15 +1427,15 @@ mod tests {\n     use parse::token::{str_to_ident};\n     use std::io;\n \n-    fn mk_sh() -> diagnostic::SpanHandler {\n+    fn mk_sh() -> diagnostic::Handler {\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         let emitter = diagnostic::EmitterWriter::new(Box::new(io::sink()), None);\n         let handler = diagnostic::Handler::with_emitter(true, Box::new(emitter));\n-        diagnostic::SpanHandler::new(handler, CodeMap::new())\n+        diagnostic::Handler::new(handler, CodeMap::new())\n     }\n \n     // open a string reader for the given string\n-    fn setup<'a>(span_handler: &'a diagnostic::SpanHandler,\n+    fn setup<'a>(span_handler: &'a diagnostic::Handler,\n                  teststr: String) -> StringReader<'a> {\n         let fm = span_handler.cm.new_filemap(\"zebra.rs\".to_string(), teststr);\n         StringReader::new(span_handler, fm)"}, {"sha": "f74e9023ed18b817ac1806bccba11a109a71ad88", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -12,7 +12,7 @@\n \n use ast;\n use codemap::{self, Span, CodeMap, FileMap};\n-use diagnostic::{SpanHandler, Handler, Auto, FatalError};\n+use errors::{Handler, ColorConfig, FatalError};\n use parse::parser::Parser;\n use parse::token::InternedString;\n use ptr::P;\n@@ -40,26 +40,29 @@ pub mod obsolete;\n \n /// Info about a parsing session.\n pub struct ParseSess {\n-    pub span_diagnostic: SpanHandler, // better be the same as the one in the reader!\n+    pub span_diagnostic: Handler, // better be the same as the one in the reader!\n     /// Used to determine and report recursive mod inclusions\n     included_mod_stack: RefCell<Vec<PathBuf>>,\n+    code_map: Rc<CodeMap>,\n }\n \n impl ParseSess {\n     pub fn new() -> ParseSess {\n-        let handler = SpanHandler::new(Handler::new(Auto, None, true), CodeMap::new());\n-        ParseSess::with_span_handler(handler)\n+        let cm = Rc::new(CodeMap::new());\n+        let handler = Handler::new(ColorConfig::Auto, None, true, cm.clone());\n+        ParseSess::with_span_handler(handler, cm)\n     }\n \n-    pub fn with_span_handler(sh: SpanHandler) -> ParseSess {\n+    pub fn with_span_handler(handler: Handler, code_map: Rc<CodeMap>) -> ParseSess {\n         ParseSess {\n-            span_diagnostic: sh,\n-            included_mod_stack: RefCell::new(vec![])\n+            span_diagnostic: handler,\n+            included_mod_stack: RefCell::new(vec![]),\n+            code_map: code_map\n         }\n     }\n \n     pub fn codemap(&self) -> &CodeMap {\n-        &self.span_diagnostic.cm\n+        &self.code_map\n     }\n }\n \n@@ -235,7 +238,7 @@ fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n             let msg = format!(\"couldn't read {:?}: {}\", path.display(), e);\n             match spanopt {\n                 Some(sp) => panic!(sess.span_diagnostic.span_fatal(sp, &msg)),\n-                None => panic!(sess.span_diagnostic.handler().fatal(&msg))\n+                None => panic!(sess.span_diagnostic.fatal(&msg))\n             }\n         }\n     }\n@@ -438,7 +441,7 @@ fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n }\n \n fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n-                      sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n+                      sd: &Handler, sp: Span) -> ast::Lit_ {\n     debug!(\"filtered_float_lit: {}, {:?}\", data, suffix);\n     match suffix.as_ref().map(|s| &**s) {\n         Some(\"f32\") => ast::LitFloat(data, ast::TyF32),\n@@ -459,7 +462,7 @@ fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n     }\n }\n pub fn float_lit(s: &str, suffix: Option<InternedString>,\n-                 sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n+                 sd: &Handler, sp: Span) -> ast::Lit_ {\n     debug!(\"float_lit: {:?}, {:?}\", s, suffix);\n     // FIXME #2252: bounds checking float literals is deferred until trans\n     let s = s.chars().filter(|&c| c != '_').collect::<String>();\n@@ -561,7 +564,7 @@ pub fn byte_str_lit(lit: &str) -> Rc<Vec<u8>> {\n \n pub fn integer_lit(s: &str,\n                    suffix: Option<InternedString>,\n-                   sd: &SpanHandler,\n+                   sd: &Handler,\n                    sp: Span)\n                    -> ast::Lit_ {\n     // s can only be ascii, byte indexing is fine"}, {"sha": "5dba1e189ab156dcb8ca3c0a65c17a01ad883de7", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -66,10 +66,9 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n         }\n \n         if !self.obsolete_set.contains(&kind) &&\n-            (error || self.sess.span_diagnostic.handler().can_emit_warnings) {\n+            (error || self.sess.span_diagnostic.can_emit_warnings) {\n             self.sess\n                 .span_diagnostic\n-                .handler()\n                 .note(&format!(\"{}\", desc));\n             self.obsolete_set.insert(kind);\n         }"}, {"sha": "04b0c0fa2735b525626b4ba312d10dcf9e780855", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -60,7 +60,7 @@ use attr::{ThinAttributes, ThinAttributesExt, AttributesExt};\n use ast;\n use ast_util::{self, ident_to_path};\n use codemap::{self, Span, BytePos, Spanned, spanned, mk_sp, CodeMap};\n-use diagnostic;\n+use errors::{self, FatalError};\n use ext::tt::macro_parser;\n use parse;\n use parse::classify;\n@@ -75,7 +75,6 @@ use print::pprust;\n use ptr::P;\n use owned_slice::OwnedSlice;\n use parse::PResult;\n-use diagnostic::FatalError;\n \n use std::collections::HashSet;\n use std::io::prelude::*;\n@@ -983,16 +982,16 @@ impl<'a> Parser<'a> {\n         }\n         f(&self.buffer[((self.buffer_start + dist - 1) & 3) as usize].tok)\n     }\n-    pub fn fatal(&self, m: &str) -> diagnostic::FatalError {\n+    pub fn fatal(&self, m: &str) -> errors::FatalError {\n         self.sess.span_diagnostic.span_fatal(self.span, m)\n     }\n-    pub fn span_fatal(&self, sp: Span, m: &str) -> diagnostic::FatalError {\n+    pub fn span_fatal(&self, sp: Span, m: &str) -> errors::FatalError {\n         self.sess.span_diagnostic.span_fatal(sp, m)\n     }\n-    pub fn span_fatal_help(&self, sp: Span, m: &str, help: &str) -> diagnostic::FatalError {\n+    pub fn span_fatal_help(&self, sp: Span, m: &str, help: &str) -> errors::FatalError {\n         self.span_err(sp, m);\n         self.fileline_help(sp, help);\n-        diagnostic::FatalError\n+        errors::FatalError\n     }\n     pub fn span_note(&self, sp: Span, m: &str) {\n         self.sess.span_diagnostic.span_note(sp, m)\n@@ -1022,7 +1021,7 @@ impl<'a> Parser<'a> {\n         self.sess.span_diagnostic.span_bug(sp, m)\n     }\n     pub fn abort_if_errors(&self) {\n-        self.sess.span_diagnostic.handler().abort_if_errors();\n+        self.sess.span_diagnostic.abort_if_errors();\n     }\n \n     pub fn id_to_interned_str(&mut self, id: Ident) -> InternedString {"}, {"sha": "08448f25187c7ffe4694bf17183197f10034306c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -20,7 +20,7 @@ use attr;\n use owned_slice::OwnedSlice;\n use attr::{AttrMetaMethods, AttributeMethods};\n use codemap::{self, CodeMap, BytePos};\n-use diagnostic;\n+use errors;\n use parse::token::{self, BinOpToken, Token, InternedString};\n use parse::lexer::comments;\n use parse;\n@@ -99,7 +99,7 @@ pub const DEFAULT_COLUMNS: usize = 78;\n /// it can scan the input text for comments and literals to\n /// copy forward.\n pub fn print_crate<'a>(cm: &'a CodeMap,\n-                       span_diagnostic: &diagnostic::SpanHandler,\n+                       span_diagnostic: &errors::Handler,\n                        krate: &ast::Crate,\n                        filename: String,\n                        input: &mut Read,\n@@ -139,7 +139,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n \n impl<'a> State<'a> {\n     pub fn new_from_input(cm: &'a CodeMap,\n-                          span_diagnostic: &diagnostic::SpanHandler,\n+                          span_diagnostic: &errors::Handler,\n                           filename: String,\n                           input: &mut Read,\n                           out: Box<Write+'a>,"}, {"sha": "014c7b2a68f4f36935f96b38b726a1e6086d82c0", "filename": "src/libsyntax/show_span.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fshow_span.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -16,7 +16,7 @@\n use std::str::FromStr;\n \n use ast;\n-use diagnostic;\n+use errors;\n use visit;\n use visit::Visitor;\n \n@@ -40,7 +40,7 @@ impl FromStr for Mode {\n }\n \n struct ShowSpanVisitor<'a> {\n-    span_diagnostic: &'a diagnostic::SpanHandler,\n+    span_diagnostic: &'a errors::Handler,\n     mode: Mode,\n }\n \n@@ -71,7 +71,7 @@ impl<'a, 'v> Visitor<'v> for ShowSpanVisitor<'a> {\n     }\n }\n \n-pub fn run(span_diagnostic: &diagnostic::SpanHandler,\n+pub fn run(span_diagnostic: &errors::Handler,\n            mode: &str,\n            krate: &ast::Crate) {\n     let mode = match mode.parse().ok() {"}, {"sha": "9e1d80b3f0de4ba0b3747bb5efdb3cb96c51d5ca", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -23,7 +23,7 @@ use attr::AttrMetaMethods;\n use attr;\n use codemap::{DUMMY_SP, Span, ExpnInfo, NameAndSpan, MacroAttribute};\n use codemap;\n-use diagnostic;\n+use errors;\n use config;\n use entry::{self, EntryPointType};\n use ext::base::ExtCtxt;\n@@ -55,7 +55,7 @@ struct Test {\n \n struct TestCtxt<'a> {\n     sess: &'a ParseSess,\n-    span_diagnostic: &'a diagnostic::SpanHandler,\n+    span_diagnostic: &'a errors::Handler,\n     path: Vec<ast::Ident>,\n     ext_cx: ExtCtxt<'a>,\n     testfns: Vec<Test>,\n@@ -72,7 +72,7 @@ struct TestCtxt<'a> {\n pub fn modify_for_testing(sess: &ParseSess,\n                           cfg: &ast::CrateConfig,\n                           krate: ast::Crate,\n-                          span_diagnostic: &diagnostic::SpanHandler) -> ast::Crate {\n+                          span_diagnostic: &errors::Handler) -> ast::Crate {\n     // We generate the test harness when building in the 'test'\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n@@ -275,7 +275,7 @@ fn generate_test_harness(sess: &ParseSess,\n                          reexport_test_harness_main: Option<InternedString>,\n                          krate: ast::Crate,\n                          cfg: &ast::CrateConfig,\n-                         sd: &diagnostic::SpanHandler) -> ast::Crate {\n+                         sd: &errors::Handler) -> ast::Crate {\n     // Remove the entry points\n     let mut cleaner = EntryPointCleaner { depth: 0 };\n     let krate = cleaner.fold_crate(krate);\n@@ -315,7 +315,7 @@ fn generate_test_harness(sess: &ParseSess,\n     return res;\n }\n \n-fn strip_test_functions(diagnostic: &diagnostic::SpanHandler, krate: ast::Crate)\n+fn strip_test_functions(diagnostic: &errors::Handler, krate: ast::Crate)\n                         -> ast::Crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n@@ -688,7 +688,7 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n         Some(id) => vec![id],\n         None => {\n             let diag = cx.span_diagnostic;\n-            diag.handler.bug(\"expected to find top-level re-export name, but found None\");\n+            diag.bug(\"expected to find top-level re-export name, but found None\");\n         }\n     };\n     visible_path.extend(path);"}, {"sha": "b76384ffb4adaf3bafa52b6c2bb2195d678875d4", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6309b0f5bb558b844f45b2d313d2078fd7b7614c/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=6309b0f5bb558b844f45b2d313d2078fd7b7614c", "patch": "@@ -203,7 +203,7 @@ use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::codemap::{self, DUMMY_SP};\n use syntax::codemap::Span;\n-use syntax::diagnostic::SpanHandler;\n+use syntax::errors::Handler;\n use syntax::util::move_map::MoveMap;\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::{intern, InternedString};\n@@ -742,7 +742,7 @@ impl<'a> TraitDef<'a> {\n     }\n }\n \n-fn find_repr_type_name(diagnostic: &SpanHandler,\n+fn find_repr_type_name(diagnostic: &Handler,\n                        type_attrs: &[ast::Attribute]) -> &'static str {\n     let mut repr_type_name = \"i32\";\n     for a in type_attrs {"}]}