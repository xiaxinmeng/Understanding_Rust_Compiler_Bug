{"sha": "6461fb3308ee52a04b4856896909fb6974ae4a81", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0NjFmYjMzMDhlZTUyYTA0YjQ4NTY4OTY5MDlmYjY5NzRhZTRhODE=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-30T07:57:52Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-30T07:58:26Z"}, "message": "lifetimes lint: take \"where\" clauses into account (fixes #253)\n\nIf a where clause is present and has lifetimes mentioned, just bail out.", "tree": {"sha": "b931c0e224fd01f3d4c19cfbf0b4c68216fa29cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b931c0e224fd01f3d4c19cfbf0b4c68216fa29cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6461fb3308ee52a04b4856896909fb6974ae4a81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6461fb3308ee52a04b4856896909fb6974ae4a81", "html_url": "https://github.com/rust-lang/rust/commit/6461fb3308ee52a04b4856896909fb6974ae4a81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6461fb3308ee52a04b4856896909fb6974ae4a81/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e340584cd85afc8cd2a5d4700867fe8ed852fbf8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e340584cd85afc8cd2a5d4700867fe8ed852fbf8", "html_url": "https://github.com/rust-lang/rust/commit/e340584cd85afc8cd2a5d4700867fe8ed852fbf8"}], "stats": {"total": 36, "additions": 30, "deletions": 6}, "files": [{"sha": "bff0db14f7bbfd414be60611f22ba93407760b29", "filename": "src/lifetimes.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6461fb3308ee52a04b4856896909fb6974ae4a81/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6461fb3308ee52a04b4856896909fb6974ae4a81/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=6461fb3308ee52a04b4856896909fb6974ae4a81", "patch": "@@ -20,21 +20,21 @@ impl LintPass for LifetimePass {\n \n     fn check_item(&mut self, cx: &Context, item: &Item) {\n         if let ItemFn(ref decl, _, _, _, ref generics, _) = item.node {\n-            check_fn_inner(cx, decl, None, &generics.lifetimes, item.span);\n+            check_fn_inner(cx, decl, None, &generics, item.span);\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &Context, item: &ImplItem) {\n         if let MethodImplItem(ref sig, _) = item.node {\n             check_fn_inner(cx, &sig.decl, Some(&sig.explicit_self),\n-                           &sig.generics.lifetimes, item.span);\n+                           &sig.generics, item.span);\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &Context, item: &TraitItem) {\n         if let MethodTraitItem(ref sig, _) = item.node {\n             check_fn_inner(cx, &sig.decl, Some(&sig.explicit_self),\n-                           &sig.generics.lifetimes, item.span);\n+                           &sig.generics, item.span);\n         }\n     }\n }\n@@ -49,11 +49,11 @@ enum RefLt {\n use self::RefLt::*;\n \n fn check_fn_inner(cx: &Context, decl: &FnDecl, slf: Option<&ExplicitSelf>,\n-                  named_lts: &[LifetimeDef], span: Span) {\n-    if in_external_macro(cx, span) {\n+                  generics: &Generics, span: Span) {\n+    if in_external_macro(cx, span) || has_where_lifetimes(&generics.where_clause) {\n         return;\n     }\n-    if could_use_elision(decl, slf, named_lts) {\n+    if could_use_elision(decl, slf, &generics.lifetimes) {\n         span_lint(cx, NEEDLESS_LIFETIMES, span,\n                   \"explicit lifetimes given in parameter types where they could be elided\");\n     }\n@@ -182,3 +182,21 @@ impl<'v> Visitor<'v> for RefVisitor {\n     // for lifetime bounds; the default impl calls visit_lifetime_ref\n     fn visit_lifetime_bound(&mut self, _: &'v Lifetime) { }\n }\n+\n+/// Are any lifetimes mentioned in the `where` clause? If yes, we don't try to\n+/// reason about elision.\n+fn has_where_lifetimes(where_clause: &WhereClause) -> bool {\n+    let mut where_visitor = RefVisitor(Vec::new());\n+    for predicate in &where_clause.predicates {\n+        match *predicate {\n+            WherePredicate::RegionPredicate(..) => return true,\n+            WherePredicate::BoundPredicate(ref pred) => {\n+                walk_ty(&mut where_visitor, &pred.bounded_ty);\n+            }\n+            WherePredicate::EqPredicate(ref pred) => {\n+                walk_ty(&mut where_visitor, &pred.ty);\n+            }\n+        }\n+    }\n+    !where_visitor.into_vec().is_empty()\n+}"}, {"sha": "ae115efec04351d3d68fcc6b95d515149b17d434", "filename": "tests/compile-fail/lifetimes.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6461fb3308ee52a04b4856896909fb6974ae4a81/tests%2Fcompile-fail%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6461fb3308ee52a04b4856896909fb6974ae4a81/tests%2Fcompile-fail%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flifetimes.rs?ref=6461fb3308ee52a04b4856896909fb6974ae4a81", "patch": "@@ -31,6 +31,10 @@ fn deep_reference_2<'a>(x: Result<&'a u8, &'a u8>) -> &'a u8 { x.unwrap() } // n\n fn deep_reference_3<'a>(x: &'a u8, _y: u8) -> Result<&'a u8, ()> { Ok(x) }\n //~^ERROR explicit lifetimes given\n \n+// where clause, but without lifetimes\n+fn where_clause_without_lt<'a, T>(x: &'a u8, _y: u8) -> Result<&'a u8, ()> where T: Copy { Ok(x) }\n+//~^ERROR explicit lifetimes given\n+\n type Ref<'r> = &'r u8;\n \n fn lifetime_param_1<'a>(_x: Ref<'a>, _y: &'a u8) { } // no error, same lifetime on two params\n@@ -40,6 +44,8 @@ fn lifetime_param_2<'a, 'b>(_x: Ref<'a>, _y: &'b u8) { }\n \n fn lifetime_param_3<'a, 'b: 'a>(_x: Ref<'a>, _y: &'b u8) { } // no error, bounded lifetime\n \n+fn lifetime_param_4<'a, 'b>(_x: Ref<'a>, _y: &'b u8) where 'b: 'a { } // no error, bounded lifetime\n+\n struct X {\n     x: u8,\n }"}]}