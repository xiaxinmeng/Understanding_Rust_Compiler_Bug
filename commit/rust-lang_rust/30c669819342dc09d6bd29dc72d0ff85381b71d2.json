{"sha": "30c669819342dc09d6bd29dc72d0ff85381b71d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwYzY2OTgxOTM0MmRjMDlkNmJkMjlkYzcyZDBmZjg1MzgxYjcxZDI=", "commit": {"author": {"name": "csmoe", "email": "35686186+csmoe@users.noreply.github.com", "date": "2018-10-09T11:49:18Z"}, "committer": {"name": "csmoe", "email": "35686186+csmoe@users.noreply.github.com", "date": "2018-10-20T03:11:31Z"}, "message": "handle errors based on parse_sess", "tree": {"sha": "42a8aab73492697b9d14cab94fc9be455682b00e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42a8aab73492697b9d14cab94fc9be455682b00e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30c669819342dc09d6bd29dc72d0ff85381b71d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30c669819342dc09d6bd29dc72d0ff85381b71d2", "html_url": "https://github.com/rust-lang/rust/commit/30c669819342dc09d6bd29dc72d0ff85381b71d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30c669819342dc09d6bd29dc72d0ff85381b71d2/comments", "author": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ed2d1a7e6a04896b6b0e30f2b07d0cd5f55afde", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ed2d1a7e6a04896b6b0e30f2b07d0cd5f55afde", "html_url": "https://github.com/rust-lang/rust/commit/2ed2d1a7e6a04896b6b0e30f2b07d0cd5f55afde"}], "stats": {"total": 91, "additions": 48, "deletions": 43}, "files": [{"sha": "d496272ae3477fd81117c633a48046e2e7037749", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30c669819342dc09d6bd29dc72d0ff85381b71d2/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c669819342dc09d6bd29dc72d0ff85381b71d2/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=30c669819342dc09d6bd29dc72d0ff85381b71d2", "patch": "@@ -134,11 +134,11 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n         if self.tcx.features().staged_api {\n             // This crate explicitly wants staged API.\n             debug!(\"annotate(id = {:?}, attrs = {:?})\", id, attrs);\n-            if let Some(..) = attr::find_deprecation(self.tcx.sess.diagnostic(), attrs, item_sp) {\n+            if let Some(..) = attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp) {\n                 self.tcx.sess.span_err(item_sp, \"`#[deprecated]` cannot be used in staged api, \\\n                                                  use `#[rustc_deprecated]` instead\");\n             }\n-            if let Some(mut stab) = attr::find_stability(self.tcx.sess.diagnostic(),\n+            if let Some(mut stab) = attr::find_stability(&self.tcx.sess.parse_sess,\n                                                          attrs, item_sp) {\n                 // Error if prohibited, or can't inherit anything from a container\n                 if kind == AnnotationKind::Prohibited ||\n@@ -224,7 +224,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 }\n             }\n \n-            if let Some(depr) = attr::find_deprecation(self.tcx.sess.diagnostic(), attrs, item_sp) {\n+            if let Some(depr) = attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp) {\n                 if kind == AnnotationKind::Prohibited {\n                     self.tcx.sess.span_err(item_sp, \"This deprecation annotation is useless\");\n                 }"}, {"sha": "e2461bbf988fc744c2851f724c55d95189198a13", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30c669819342dc09d6bd29dc72d0ff85381b71d2/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c669819342dc09d6bd29dc72d0ff85381b71d2/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=30c669819342dc09d6bd29dc72d0ff85381b71d2", "patch": "@@ -1927,7 +1927,7 @@ impl ReprOptions {\n         let mut max_align = 0;\n         let mut min_pack = 0;\n         for attr in tcx.get_attrs(did).iter() {\n-            for r in attr::find_repr_attrs(tcx.sess.diagnostic(), attr) {\n+            for r in attr::find_repr_attrs(&tcx.sess.parse_sess, attr) {\n                 flags.insert(match r {\n                     attr::ReprC => ReprFlags::IS_C,\n                     attr::ReprPacked(pack) => {"}, {"sha": "40781b0771d89d72a0161bb83ed933f54b21aeb2", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30c669819342dc09d6bd29dc72d0ff85381b71d2/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c669819342dc09d6bd29dc72d0ff85381b71d2/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=30c669819342dc09d6bd29dc72d0ff85381b71d2", "patch": "@@ -121,7 +121,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCamelCaseTypes {\n         let has_repr_c = it.attrs\n             .iter()\n             .any(|attr| {\n-                attr::find_repr_attrs(cx.tcx.sess.diagnostic(), attr)\n+                attr::find_repr_attrs(&cx.tcx.sess.parse_sess, attr)\n                     .iter()\n                     .any(|r| r == &attr::ReprC)\n             });"}, {"sha": "3093a6c629f42dc683745168308d2e11a54cf3b3", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30c669819342dc09d6bd29dc72d0ff85381b71d2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c669819342dc09d6bd29dc72d0ff85381b71d2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=30c669819342dc09d6bd29dc72d0ff85381b71d2", "patch": "@@ -1713,7 +1713,7 @@ fn check_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId)\n     let repr = tcx.adt_def(def_id).repr;\n     if repr.packed() {\n         for attr in tcx.get_attrs(def_id).iter() {\n-            for r in attr::find_repr_attrs(tcx.sess.diagnostic(), attr) {\n+            for r in attr::find_repr_attrs(&tcx.sess.parse_sess, attr) {\n                 if let attr::ReprPacked(pack) = r {\n                     if pack != repr.pack {\n                         struct_span_err!(tcx.sess, sp, E0634,"}, {"sha": "0c82b5c71070576ca20b56880a274d3f23198cfd", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/30c669819342dc09d6bd29dc72d0ff85381b71d2/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c669819342dc09d6bd29dc72d0ff85381b71d2/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=30c669819342dc09d6bd29dc72d0ff85381b71d2", "patch": "@@ -27,7 +27,8 @@ enum AttrError {\n     UnsupportedLiteral\n }\n \n-fn handle_errors(diag: &Handler, span: Span, error: AttrError, is_bytestr: bool) {\n+fn handle_errors(sess: &ParseSess, span: Span, error: AttrError, is_bytestr: bool) {\n+    let diag = &sess.span_diagnostic;\n     match error {\n         AttrError::MultipleItem(item) => span_err!(diag, span, E0538,\n                                                    \"multiple '{}' items\", item),\n@@ -52,11 +53,11 @@ fn handle_errors(diag: &Handler, span: Span, error: AttrError, is_bytestr: bool)\n                 \"unsupported literal\",\n             );\n             if is_bytestr {\n-                if let Ok(lint_str) = sess.source_map.span_to_snippet(span) {\n+                if let Ok(lint_str) = sess.source_map().span_to_snippet(span) {\n                     err.span_suggestion_with_applicability(\n                         span,\n                         \"consider removing the prefix\",\n-                        format!(\"{}\", lint_str[1..]),\n+                        format!(\"{}\", &lint_str[1..]),\n                         Applicability::MaybeIncorrect,\n                     );\n                 }\n@@ -179,12 +180,12 @@ pub fn contains_feature_attr(attrs: &[Attribute], feature_name: &str) -> bool {\n }\n \n /// Find the first stability attribute. `None` if none exists.\n-pub fn find_stability(diagnostic: &Handler, attrs: &[Attribute],\n+pub fn find_stability(sess: &ParseSess, attrs: &[Attribute],\n                       item_sp: Span) -> Option<Stability> {\n-    find_stability_generic(diagnostic, attrs.iter(), item_sp)\n+    find_stability_generic(sess, attrs.iter(), item_sp)\n }\n \n-fn find_stability_generic<'a, I>(diagnostic: &Handler,\n+fn find_stability_generic<'a, I>(sess: &ParseSess,\n                                  attrs_iter: I,\n                                  item_sp: Span)\n                                  -> Option<Stability>\n@@ -196,6 +197,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n     let mut rustc_depr: Option<RustcDeprecation> = None;\n     let mut rustc_const_unstable: Option<Symbol> = None;\n     let mut promotable = false;\n+    let diagnostic = &sess.span_diagnostic;\n \n     'outer: for attr in attrs_iter {\n         if ![\n@@ -220,7 +222,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n             let meta = meta.as_ref().unwrap();\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n-                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()), false);\n+                    handle_errors(sess, meta.span, AttrError::MultipleItem(meta.name()), false);\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n@@ -247,16 +249,16 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                                 _ => {\n                                     let expected = &[ $( stringify!($name) ),+ ];\n                                     handle_errors(\n-                                        diagnostic,\n+                                        sess,\n                                         mi.span,\n                                         AttrError::UnknownMetaItem(mi.name(), expected),\n-                                        false\n+                                        false,\n                                     );\n                                     continue 'outer\n                                 }\n                             }\n                         } else {\n-                            handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral, false);\n+                            handle_errors(sess, meta.span, AttrError::UnsupportedLiteral, false);\n                             continue 'outer\n                         }\n                     }\n@@ -281,7 +283,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             })\n                         }\n                         (None, _) => {\n-                            handle_errors(diagnostic, attr.span(), AttrError::MissingSince, false);\n+                            handle_errors(sess, attr.span(), AttrError::MissingSince, false);\n                             continue\n                         }\n                         _ => {\n@@ -307,7 +309,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                 }\n                 \"unstable\" => {\n                     if stab.is_some() {\n-                        handle_errors(diagnostic, attr.span(), AttrError::MultipleStabilityLevels, false);\n+                        handle_errors(sess, attr.span(), AttrError::MultipleStabilityLevels, false);\n                         break\n                     }\n \n@@ -322,7 +324,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                                 \"issue\" => if !get(mi, &mut issue) { continue 'outer },\n                                 _ => {\n                                     handle_errors(\n-                                        diagnostic,\n+                                        sess,\n                                         meta.span,\n                                         AttrError::UnknownMetaItem(\n                                             mi.name(),\n@@ -334,7 +336,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                                 }\n                             }\n                         } else {\n-                            handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral, false);\n+                            handle_errors(sess, meta.span, AttrError::UnsupportedLiteral, false);\n                             continue 'outer\n                         }\n                     }\n@@ -361,7 +363,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             })\n                         }\n                         (None, _, _) => {\n-                            handle_errors(diagnostic, attr.span(), AttrError::MissingFeature, false);\n+                            handle_errors(sess, attr.span(), AttrError::MissingFeature, false);\n                             continue\n                         }\n                         _ => {\n@@ -372,7 +374,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                 }\n                 \"stable\" => {\n                     if stab.is_some() {\n-                        handle_errors(diagnostic, attr.span(), AttrError::MultipleStabilityLevels, false);\n+                        handle_errors(sess, attr.span(), AttrError::MultipleStabilityLevels, false);\n                         break\n                     }\n \n@@ -386,17 +388,18 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                                     \"since\" => if !get(mi, &mut since) { continue 'outer },\n                                     _ => {\n                                         handle_errors(\n-                                            diagnostic,\n+                                            sess,\n                                             meta.span,\n                                             AttrError::UnknownMetaItem(mi.name(), &[\"since\", \"note\"]),\n                                             false,\n                                         );\n                                         continue 'outer\n                                     }\n                                 }\n+                            },\n                             NestedMetaItemKind::Literal(lit) => {\n                                 handle_errors(\n-                                    diagnostic,\n+                                    sess,\n                                     meta.span,\n                                     AttrError::UnsupportedLiteral,\n                                     lit.node.is_bytestr()\n@@ -419,11 +422,11 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                             })\n                         }\n                         (None, _) => {\n-                            handle_errors(diagnostic, attr.span(), AttrError::MissingFeature, false);\n+                            handle_errors(sess, attr.span(), AttrError::MissingFeature, false);\n                             continue\n                         }\n                         _ => {\n-                            handle_errors(diagnostic, attr.span(), AttrError::MissingSince, false);\n+                            handle_errors(sess, attr.span(), AttrError::MissingSince, false);\n                             continue\n                         }\n                     }\n@@ -490,9 +493,9 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n             MetaItemKind::List(..) => {\n                 error(cfg.span, \"unexpected parentheses after `cfg` predicate key\")\n             }\n-            MetaItemKind::NameValue(lit) => if !lit.node.is_str() {\n+            MetaItemKind::NameValue(lit) if !lit.node.is_str() => {\n                 handle_errors(\n-                    &sess.span_diagnostic,\n+                    sess,\n                     lit.span, AttrError::UnsupportedLiteral,\n                     lit.node.is_bytestr(),\n                 );\n@@ -515,7 +518,7 @@ pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n         ast::MetaItemKind::List(ref mis) => {\n             for mi in mis.iter() {\n                 if !mi.is_meta_item() {\n-                    handle_errors(&sess.span_diagnostic, mi.span, AttrError::UnsupportedLiteral, false);\n+                    handle_errors(sess, mi.span, AttrError::UnsupportedLiteral, false);\n                     return false;\n                 }\n             }\n@@ -557,18 +560,19 @@ pub struct Deprecation {\n }\n \n /// Find the deprecation attribute. `None` if none exists.\n-pub fn find_deprecation(diagnostic: &Handler, attrs: &[Attribute],\n+pub fn find_deprecation(sess: &ParseSess, attrs: &[Attribute],\n                         item_sp: Span) -> Option<Deprecation> {\n-    find_deprecation_generic(diagnostic, attrs.iter(), item_sp)\n+    find_deprecation_generic(sess, attrs.iter(), item_sp)\n }\n \n-fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n+fn find_deprecation_generic<'a, I>(sess: &ParseSess,\n                                    attrs_iter: I,\n                                    item_sp: Span)\n                                    -> Option<Deprecation>\n     where I: Iterator<Item = &'a Attribute>\n {\n     let mut depr: Option<Deprecation> = None;\n+    let diagnostic = &sess.span_diagnostic;\n \n     'outer: for attr in attrs_iter {\n         if attr.path != \"deprecated\" {\n@@ -585,7 +589,7 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n         depr = if let Some(metas) = attr.meta_item_list() {\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n-                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()), false);\n+                    handle_errors(sess, meta.span, AttrError::MultipleItem(meta.name()), false);\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n@@ -607,7 +611,7 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n                             \"note\" => if !get(mi, &mut note) { continue 'outer },\n                             _ => {\n                                 handle_errors(\n-                                    diagnostic,\n+                                    sess,\n                                     meta.span,\n                                     AttrError::UnknownMetaItem(mi.name(), &[\"since\", \"note\"]),\n                                     false,\n@@ -618,7 +622,7 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n                     }\n                     NestedMetaItemKind::Literal(lit) => {\n                         let is_bytestr = lit.node.is_bytestr();\n-                        handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral, is_bytestr);\n+                        handle_errors(sess, meta.span, AttrError::UnsupportedLiteral, is_bytestr);\n                         continue 'outer\n                     }\n                 }\n@@ -668,16 +672,17 @@ impl IntType {\n /// the same discriminant size that the corresponding C enum would or C\n /// structure layout, `packed` to remove padding, and `transparent` to elegate representation\n /// concerns to the only non-ZST field.\n-pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr> {\n+pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n     use self::ReprAttr::*;\n \n     let mut acc = Vec::new();\n+    let diagnostic = &sess.span_diagnostic;\n     if attr.path == \"repr\" {\n         if let Some(items) = attr.meta_item_list() {\n             mark_used(attr);\n             for item in items {\n                 if !item.is_meta_item() {\n-                    handle_errors(diagnostic, item.span, AttrError::UnsupportedLiteral, false);\n+                    handle_errors(sess, item.span, AttrError::UnsupportedLiteral, false);\n                     continue\n                 }\n "}, {"sha": "3dec93ecf7c94521e28ab7913a6d57dcd14df5d8", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30c669819342dc09d6bd29dc72d0ff85381b71d2/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c669819342dc09d6bd29dc72d0ff85381b71d2/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=30c669819342dc09d6bd29dc72d0ff85381b71d2", "patch": "@@ -340,7 +340,7 @@ pub fn compile(sess: &ParseSess, features: &Features, def: &ast::Item, edition:\n             }\n         }\n \n-        let unstable_feature = attr::find_stability(&sess.span_diagnostic,\n+        let unstable_feature = attr::find_stability(&sess,\n                                                     &def.attrs, def.span).and_then(|stability| {\n             if let attr::StabilityLevel::Unstable { issue, .. } = stability.level {\n                 Some((stability.feature, issue))"}, {"sha": "002ecce58e6529207d0a7ca6c5b1eab8d42ff321", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/30c669819342dc09d6bd29dc72d0ff85381b71d2/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c669819342dc09d6bd29dc72d0ff85381b71d2/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=30c669819342dc09d6bd29dc72d0ff85381b71d2", "patch": "@@ -202,8 +202,8 @@ use syntax::source_map::{self, respan};\n use syntax::util::move_map::MoveMap;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n+use syntax::parse::ParseSess;\n use syntax_pos::{DUMMY_SP, Span};\n-use errors::Handler;\n \n use self::ty::{LifetimeBounds, Path, Ptr, PtrTy, Self_, Ty};\n \n@@ -412,7 +412,7 @@ impl<'a> TraitDef<'a> {\n         match *item {\n             Annotatable::Item(ref item) => {\n                 let is_packed = item.attrs.iter().any(|attr| {\n-                    for r in attr::find_repr_attrs(&cx.parse_sess.span_diagnostic, attr) {\n+                    for r in attr::find_repr_attrs(&cx.parse_sess, attr) {\n                         if let attr::ReprPacked(_) = r {\n                             return true;\n                         }\n@@ -811,10 +811,10 @@ impl<'a> TraitDef<'a> {\n     }\n }\n \n-fn find_repr_type_name(diagnostic: &Handler, type_attrs: &[ast::Attribute]) -> &'static str {\n+fn find_repr_type_name(sess: &ParseSess, type_attrs: &[ast::Attribute]) -> &'static str {\n     let mut repr_type_name = \"isize\";\n     for a in type_attrs {\n-        for r in &attr::find_repr_attrs(diagnostic, a) {\n+        for r in &attr::find_repr_attrs(sess, a) {\n             repr_type_name = match *r {\n                 attr::ReprPacked(_) | attr::ReprSimd | attr::ReprAlign(_) | attr::ReprTransparent =>\n                     continue,\n@@ -1390,7 +1390,7 @@ impl<'a> MethodDef<'a> {\n             // discriminant_test = __self0_vi == __self1_vi && __self0_vi == __self2_vi && ...\n             let mut discriminant_test = cx.expr_bool(sp, true);\n \n-            let target_type_name = find_repr_type_name(&cx.parse_sess.span_diagnostic, type_attrs);\n+            let target_type_name = find_repr_type_name(&cx.parse_sess, type_attrs);\n \n             let mut first_ident = None;\n             for (&ident, self_arg) in vi_idents.iter().zip(&self_args) {"}]}