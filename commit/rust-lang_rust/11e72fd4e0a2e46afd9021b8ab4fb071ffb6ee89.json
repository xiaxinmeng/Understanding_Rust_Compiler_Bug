{"sha": "11e72fd4e0a2e46afd9021b8ab4fb071ffb6ee89", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExZTcyZmQ0ZTBhMmU0NmFmZDkwMjFiOGFiNGZiMDcxZmZiNmVlODk=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-28T19:23:40Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-28T19:23:40Z"}, "message": "Translate literal int, char, bool and str types, as well as logging them.", "tree": {"sha": "a64cd52424d49ec52caf9548ecc2eb352097c030", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a64cd52424d49ec52caf9548ecc2eb352097c030"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11e72fd4e0a2e46afd9021b8ab4fb071ffb6ee89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11e72fd4e0a2e46afd9021b8ab4fb071ffb6ee89", "html_url": "https://github.com/rust-lang/rust/commit/11e72fd4e0a2e46afd9021b8ab4fb071ffb6ee89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11e72fd4e0a2e46afd9021b8ab4fb071ffb6ee89/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbea4d04b7053e5885d2867f1519416458a37140", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbea4d04b7053e5885d2867f1519416458a37140", "html_url": "https://github.com/rust-lang/rust/commit/fbea4d04b7053e5885d2867f1519416458a37140"}], "stats": {"total": 115, "additions": 95, "deletions": 20}, "files": [{"sha": "9596f7144fa4c116123ee8539a1f0914b7f23d15", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11e72fd4e0a2e46afd9021b8ab4fb071ffb6ee89/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11e72fd4e0a2e46afd9021b8ab4fb071ffb6ee89/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=11e72fd4e0a2e46afd9021b8ab4fb071ffb6ee89", "patch": "@@ -150,6 +150,10 @@ state fn parse_lit(parser p) -> @ast.lit {\n             p.bump();\n             ret @ast.lit_bool(b);\n         }\n+        case (token.LIT_STR(?s)) {\n+            p.bump();\n+            ret @ast.lit_str(s);\n+        }\n     }\n     p.err(\"expected literal\");\n     fail;"}, {"sha": "9da370d779bab19730e9ac1ea2e4ef7f20c9d423", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 91, "deletions": 20, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/11e72fd4e0a2e46afd9021b8ab4fb071ffb6ee89/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11e72fd4e0a2e46afd9021b8ab4fb071ffb6ee89/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=11e72fd4e0a2e46afd9021b8ab4fb071ffb6ee89", "patch": "@@ -23,22 +23,30 @@ import lib.llvm.llvm.BasicBlockRef;\n import lib.llvm.False;\n import lib.llvm.True;\n \n+state obj namegen(mutable int i) {\n+    fn next(str prefix) -> str {\n+        i += 1;\n+        ret prefix + istr(i);\n+    }\n+}\n+\n type glue_fns = rec(ValueRef activate_glue,\n                     ValueRef yield_glue,\n                     ValueRef exit_task_glue,\n                     vec[ValueRef] upcall_glues);\n \n-type trans_ctxt = rec(session.session sess,\n-                      ModuleRef llmod,\n-                      hashmap[str,ValueRef] upcalls,\n-                      hashmap[str,ValueRef] fns,\n-                      @glue_fns glues,\n-                      str path);\n+state type trans_ctxt = rec(session.session sess,\n+                            ModuleRef llmod,\n+                            hashmap[str,ValueRef] upcalls,\n+                            hashmap[str,ValueRef] fns,\n+                            @glue_fns glues,\n+                            namegen names,\n+                            str path);\n \n-type fn_ctxt = rec(ValueRef llfn,\n-                   ValueRef lloutptr,\n-                   ValueRef lltaskptr,\n-                   @trans_ctxt tcx);\n+state type fn_ctxt = rec(ValueRef llfn,\n+                         ValueRef lloutptr,\n+                         ValueRef lltaskptr,\n+                         @trans_ctxt tcx);\n \n type terminator = fn(@fn_ctxt cx, builder build);\n \n@@ -54,10 +62,27 @@ fn T_nil() -> TypeRef {\n     ret llvm.LLVMVoidType();\n }\n \n-fn T_int() -> TypeRef {\n+fn T_i8() -> TypeRef {\n+    ret llvm.LLVMInt8Type();\n+}\n+\n+fn T_i16() -> TypeRef {\n+    ret llvm.LLVMInt16Type();\n+}\n+\n+fn T_i32() -> TypeRef {\n     ret llvm.LLVMInt32Type();\n }\n \n+fn T_i64() -> TypeRef {\n+    ret llvm.LLVMInt64Type();\n+}\n+\n+fn T_int() -> TypeRef {\n+    // FIXME: switch on target type.\n+    ret T_i32();\n+}\n+\n fn T_fn(vec[TypeRef] inputs, TypeRef output) -> TypeRef {\n     ret llvm.LLVMFunctionType(output,\n                               _vec.buf[TypeRef](inputs),\n@@ -124,19 +149,26 @@ fn C_null(TypeRef t) -> ValueRef {\n     ret llvm.LLVMConstNull(t);\n }\n \n-fn C_int(int i) -> ValueRef {\n+fn C_integral(int i, TypeRef t) -> ValueRef {\n     // FIXME. We can't use LLVM.ULongLong with our existing minimal native\n     // API, which only knows word-sized args.  Lucky for us LLVM has a \"take a\n     // string encoding\" version.  Hilarious. Please fix to handle:\n     //\n     // ret llvm.LLVMConstInt(T_int(), t as LLVM.ULongLong, False);\n     //\n-    ret llvm.LLVMConstIntOfString(T_int(),\n-                                  _str.buf(istr(i)), 10);\n+    ret llvm.LLVMConstIntOfString(t, _str.buf(istr(i)), 10);\n+}\n+\n+fn C_int(int i) -> ValueRef {\n+    ret C_integral(i, T_int());\n }\n \n-fn C_str(str s) -> ValueRef {\n-    ret llvm.LLVMConstString(_str.buf(s), _str.byte_len(s), False);\n+fn C_str(@trans_ctxt cx, str s) -> ValueRef {\n+    auto sc = llvm.LLVMConstString(_str.buf(s), _str.byte_len(s), False);\n+    auto g = llvm.LLVMAddGlobal(cx.llmod, llvm.LLVMTypeOf(sc),\n+                                _str.buf(cx.names.next(\"str\")));\n+    llvm.LLVMSetInitializer(g, sc);\n+    ret g;\n }\n \n fn C_struct(vec[ValueRef] elts) -> ValueRef {\n@@ -192,7 +224,10 @@ fn trans_upcall(@block_ctxt cx, str name, vec[ValueRef] args) -> ValueRef {\n     llupcall = llvm.LLVMConstPointerCast(llupcall, T_int());\n \n     let ValueRef llglue = cx.fcx.tcx.glues.upcall_glues.(n);\n-    let vec[ValueRef] call_args = vec(cx.fcx.lltaskptr, llupcall) + args;\n+    let vec[ValueRef] call_args = vec(cx.fcx.lltaskptr, llupcall);\n+    for (ValueRef a in args) {\n+        call_args += cx.build.ZExtOrBitCast(a, T_int());\n+    }\n     log \"emitting indirect-upcall via \" + abi.upcall_glue_name(n);\n     for (ValueRef v in call_args) {\n         log \"arg: \" + lib.llvm.type_to_str(llvm.LLVMTypeOf(v));\n@@ -202,15 +237,50 @@ fn trans_upcall(@block_ctxt cx, str name, vec[ValueRef] args) -> ValueRef {\n     ret cx.build.Call(llglue, call_args);\n }\n \n-fn trans_log(@block_ctxt cx, &ast.expr e) {\n+fn trans_expr(@block_ctxt cx, &ast.expr e) -> ValueRef {\n     alt (e) {\n         case (ast.expr_lit(?lit)) {\n             alt (*lit) {\n                 case (ast.lit_int(?i)) {\n-                    trans_upcall(cx, \"upcall_log_int\", vec(C_int(i)));\n+                    ret C_int(i);\n+                }\n+                case (ast.lit_uint(?u)) {\n+                    ret C_int(u as int);\n+                }\n+                case (ast.lit_char(?c)) {\n+                    ret C_integral(c as int, T_i32());\n+                }\n+                case (ast.lit_bool(?b)) {\n+                    if (b) {\n+                        ret C_integral(1, T_i8());\n+                    } else {\n+                        ret C_integral(0, T_i8());\n+                    }\n+                }\n+                case (ast.lit_str(?s)) {\n+                    auto len = (_str.byte_len(s) as int) + 1;\n+                    ret trans_upcall(cx, \"upcall_new_str\",\n+                                     vec(p2i(C_str(cx.fcx.tcx, s)),\n+                                         C_int(len)));\n+                }\n+            }\n+        }\n+    }\n+    cx.fcx.tcx.sess.unimpl(\"expr variant in trans_expr\");\n+    fail;\n+}\n+\n+fn trans_log(@block_ctxt cx, &ast.expr e) {\n+    alt (e) {\n+        case (ast.expr_lit(?lit)) {\n+            alt (*lit) {\n+                case (ast.lit_str(_)) {\n+                    auto v = trans_expr(cx, e);\n+                    trans_upcall(cx, \"upcall_log_str\", vec(v));\n                 }\n                 case (_) {\n-                    cx.fcx.tcx.sess.unimpl(\"literal variant in trans_log\");\n+                    auto v = trans_expr(cx, e);\n+                    trans_upcall(cx, \"upcall_log_int\", vec(v));\n                 }\n             }\n         }\n@@ -432,6 +502,7 @@ fn trans_crate(session.session sess, ast.crate crate) {\n                    upcalls = new_str_hash[ValueRef](),\n                    fns = new_str_hash[ValueRef](),\n                    glues = glues,\n+                   names = namegen(0),\n                    path = \"_rust\");\n \n     trans_mod(cx, crate.module);"}]}