{"sha": "ca9cbea27a2fc0a3f9c7d820f5bd3eeac1ad25d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhOWNiZWEyN2EyZmMwYTNmOWM3ZDgyMGY1YmQzZWVhYzFhZDI1ZDI=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-04-05T11:03:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-05T11:03:38Z"}, "message": "Rollup merge of #82739 - jyn514:separate-stage0-stage1, r=Mark-Simulacrum\n\nUse the beta compiler for building bootstrap tools when `download-rustc` is set\n\n ## Motivation\n\nThis avoids having to rebuild bootstrap and tidy each time you rebase\nover master. In particular, it makes rebasing and running `x.py fmt` on\neach commit in a branch significantly faster. It also avoids having to\nrebuild bootstrap after setting `download-rustc = true`.\n\n ## Implementation\n\nInstead of extracting the CI artifacts directly to `stage0/`, extract\nthem to `ci-rustc/` instead. Continue to copy them to the proper\nsysroots as necessary for all stages except stage 0.\n\nThis also requires `bootstrap.py` to download both stage0 and CI\nartifacts and distinguish between the two when checking stamp files.\n\nNote that since tools have to be built by the same compiler that built\n`rustc-dev` and the standard library, the downloaded artifacts can't be\nreused when building with the beta compiler. To make sure this is still\na good user experience, warn when building with the beta compiler, and\ndefault to building with stage 2.\n\nI tested this by rebasing this PR from edeee915b1c52f97411e57ef6b1a8bd46548a37a over 1c77a1fa3ca574f2a40056f64d498db8efe0d8a8 and confirming that only the bootstrap library itself had to be rebuilt, not any dependencies and not `tidy`. I also tested that a clean build with `x.py build` builds rustdoc exactly once and does no other work, and that `touch src/librustdoc/lib.rs && x.py build` works. `x.py check` still behaves as before (checks using the beta compiler, even if there are changes to `compiler/`).\n\nHelps with https://github.com/rust-lang/rust/issues/81930.\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "f7c23ca9a988fadc9feee6e8715fff7e4c2c4a44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7c23ca9a988fadc9feee6e8715fff7e4c2c4a44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca9cbea27a2fc0a3f9c7d820f5bd3eeac1ad25d2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgau6LCRBK7hj4Ov3rIwAAdHIIAA6zn839hmY69oWr6LUtwePB\nPW+14HXR9U5qGNPi5omChI9QzzPNIo+e5m9HSqHVUTA/qGvyAsogH3xpTT11Id7/\nEt0dVoO92ntjCqMumbtWFeKPmPb6WrmdAC3TXrbUC6S17ML0gAv/Ok6FygvCJdPb\nk/Bhp381sZvcxdHRTZFEB/GFuvJ4lEMptV1ZnJJh8dF0SYQrZWcTbJaLDFEZWE3d\nCsmEMx006JxzZVCAXECjsWyYbpNuHdlJfBuKpnTdPYw19E5Uu071rP9fzxKnZ7I9\njdWLr1qCiUQpMu/15j39mlYxbAGGfwlMCDuc0s4lmdGG5DMYEvIe7XRgvto7zWc=\n=H7GW\n-----END PGP SIGNATURE-----\n", "payload": "tree f7c23ca9a988fadc9feee6e8715fff7e4c2c4a44\nparent e64dbb1f46a3058c6d152a35bd601685cb7cdc09\nparent 14406df189150a1a79298dd82007c6fd6186fafc\nauthor Dylan DPC <dylan.dpc@gmail.com> 1617620618 +0200\ncommitter GitHub <noreply@github.com> 1617620618 +0200\n\nRollup merge of #82739 - jyn514:separate-stage0-stage1, r=Mark-Simulacrum\n\nUse the beta compiler for building bootstrap tools when `download-rustc` is set\n\n ## Motivation\n\nThis avoids having to rebuild bootstrap and tidy each time you rebase\nover master. In particular, it makes rebasing and running `x.py fmt` on\neach commit in a branch significantly faster. It also avoids having to\nrebuild bootstrap after setting `download-rustc = true`.\n\n ## Implementation\n\nInstead of extracting the CI artifacts directly to `stage0/`, extract\nthem to `ci-rustc/` instead. Continue to copy them to the proper\nsysroots as necessary for all stages except stage 0.\n\nThis also requires `bootstrap.py` to download both stage0 and CI\nartifacts and distinguish between the two when checking stamp files.\n\nNote that since tools have to be built by the same compiler that built\n`rustc-dev` and the standard library, the downloaded artifacts can't be\nreused when building with the beta compiler. To make sure this is still\na good user experience, warn when building with the beta compiler, and\ndefault to building with stage 2.\n\nI tested this by rebasing this PR from edeee915b1c52f97411e57ef6b1a8bd46548a37a over 1c77a1fa3ca574f2a40056f64d498db8efe0d8a8 and confirming that only the bootstrap library itself had to be rebuilt, not any dependencies and not `tidy`. I also tested that a clean build with `x.py build` builds rustdoc exactly once and does no other work, and that `touch src/librustdoc/lib.rs && x.py build` works. `x.py check` still behaves as before (checks using the beta compiler, even if there are changes to `compiler/`).\n\nHelps with https://github.com/rust-lang/rust/issues/81930.\n\nr? `@Mark-Simulacrum`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca9cbea27a2fc0a3f9c7d820f5bd3eeac1ad25d2", "html_url": "https://github.com/rust-lang/rust/commit/ca9cbea27a2fc0a3f9c7d820f5bd3eeac1ad25d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca9cbea27a2fc0a3f9c7d820f5bd3eeac1ad25d2/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e64dbb1f46a3058c6d152a35bd601685cb7cdc09", "url": "https://api.github.com/repos/rust-lang/rust/commits/e64dbb1f46a3058c6d152a35bd601685cb7cdc09", "html_url": "https://github.com/rust-lang/rust/commit/e64dbb1f46a3058c6d152a35bd601685cb7cdc09"}, {"sha": "14406df189150a1a79298dd82007c6fd6186fafc", "url": "https://api.github.com/repos/rust-lang/rust/commits/14406df189150a1a79298dd82007c6fd6186fafc", "html_url": "https://github.com/rust-lang/rust/commit/14406df189150a1a79298dd82007c6fd6186fafc"}], "stats": {"total": 277, "additions": 159, "deletions": 118}, "files": [{"sha": "0b024d1333f0edfb2c16447c735ada86c1897975", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 83, "deletions": 68, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/ca9cbea27a2fc0a3f9c7d820f5bd3eeac1ad25d2/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/ca9cbea27a2fc0a3f9c7d820f5bd3eeac1ad25d2/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=ca9cbea27a2fc0a3f9c7d820f5bd3eeac1ad25d2", "patch": "@@ -383,7 +383,7 @@ def __init__(self):\n         self.nix_deps_dir = None\n         self.rustc_commit = None\n \n-    def download_stage0(self):\n+    def download_toolchain(self, stage0=True, rustc_channel=None):\n         \"\"\"Fetch the build system for Rust, written in Rust\n \n         This method will build a cache directory, then it will fetch the\n@@ -393,43 +393,47 @@ def download_stage0(self):\n         Each downloaded tarball is extracted, after that, the script\n         will move all the content to the right place.\n         \"\"\"\n-        rustc_channel = self.rustc_channel\n+        if rustc_channel is None:\n+            rustc_channel = self.rustc_channel\n         rustfmt_channel = self.rustfmt_channel\n-\n-        if self.rustc().startswith(self.bin_root()) and \\\n-                (not os.path.exists(self.rustc()) or\n-                 self.program_out_of_date(self.rustc_stamp(), self.date + str(self.rustc_commit))):\n-            if os.path.exists(self.bin_root()):\n-                shutil.rmtree(self.bin_root())\n-            download_rustc = self.rustc_commit is not None\n+        bin_root = self.bin_root(stage0)\n+\n+        key = self.date\n+        if not stage0:\n+            key += str(self.rustc_commit)\n+        if self.rustc(stage0).startswith(bin_root) and \\\n+                (not os.path.exists(self.rustc(stage0)) or\n+                 self.program_out_of_date(self.rustc_stamp(stage0), key)):\n+            if os.path.exists(bin_root):\n+                shutil.rmtree(bin_root)\n             tarball_suffix = '.tar.xz' if support_xz() else '.tar.gz'\n             filename = \"rust-std-{}-{}{}\".format(\n                 rustc_channel, self.build, tarball_suffix)\n             pattern = \"rust-std-{}\".format(self.build)\n-            self._download_component_helper(filename, pattern, tarball_suffix, download_rustc)\n+            self._download_component_helper(filename, pattern, tarball_suffix, stage0)\n             filename = \"rustc-{}-{}{}\".format(rustc_channel, self.build,\n                                               tarball_suffix)\n-            self._download_component_helper(filename, \"rustc\", tarball_suffix, download_rustc)\n+            self._download_component_helper(filename, \"rustc\", tarball_suffix, stage0)\n             filename = \"cargo-{}-{}{}\".format(rustc_channel, self.build,\n                                               tarball_suffix)\n             self._download_component_helper(filename, \"cargo\", tarball_suffix)\n-            if self.rustc_commit is not None:\n+            if not stage0:\n                 filename = \"rustc-dev-{}-{}{}\".format(rustc_channel, self.build, tarball_suffix)\n                 self._download_component_helper(\n-                    filename, \"rustc-dev\", tarball_suffix, download_rustc\n+                    filename, \"rustc-dev\", tarball_suffix, stage0\n                 )\n \n-            self.fix_bin_or_dylib(\"{}/bin/rustc\".format(self.bin_root()))\n-            self.fix_bin_or_dylib(\"{}/bin/rustdoc\".format(self.bin_root()))\n-            self.fix_bin_or_dylib(\"{}/bin/cargo\".format(self.bin_root()))\n-            lib_dir = \"{}/lib\".format(self.bin_root())\n+            self.fix_bin_or_dylib(\"{}/bin/rustc\".format(bin_root))\n+            self.fix_bin_or_dylib(\"{}/bin/rustdoc\".format(bin_root))\n+            self.fix_bin_or_dylib(\"{}/bin/cargo\".format(bin_root))\n+            lib_dir = \"{}/lib\".format(bin_root)\n             for lib in os.listdir(lib_dir):\n                 if lib.endswith(\".so\"):\n                     self.fix_bin_or_dylib(os.path.join(lib_dir, lib), rpath_libz=True)\n-            with output(self.rustc_stamp()) as rust_stamp:\n-                rust_stamp.write(self.date + str(self.rustc_commit))\n+            with output(self.rustc_stamp(stage0)) as rust_stamp:\n+                rust_stamp.write(key)\n \n-        if self.rustfmt() and self.rustfmt().startswith(self.bin_root()) and (\n+        if self.rustfmt() and self.rustfmt().startswith(bin_root) and (\n             not os.path.exists(self.rustfmt())\n             or self.program_out_of_date(self.rustfmt_stamp(), self.rustfmt_channel)\n         ):\n@@ -440,12 +444,13 @@ def download_stage0(self):\n                 self._download_component_helper(\n                     filename, \"rustfmt-preview\", tarball_suffix, key=date\n                 )\n-                self.fix_bin_or_dylib(\"{}/bin/rustfmt\".format(self.bin_root()))\n-                self.fix_bin_or_dylib(\"{}/bin/cargo-fmt\".format(self.bin_root()))\n+                self.fix_bin_or_dylib(\"{}/bin/rustfmt\".format(bin_root))\n+                self.fix_bin_or_dylib(\"{}/bin/cargo-fmt\".format(bin_root))\n                 with output(self.rustfmt_stamp()) as rustfmt_stamp:\n                     rustfmt_stamp.write(self.rustfmt_channel)\n \n-        if self.downloading_llvm():\n+        # Avoid downloading LLVM twice (once for stage0 and once for the master rustc)\n+        if self.downloading_llvm() and stage0:\n             # We want the most recent LLVM submodule update to avoid downloading\n             # LLVM more often than necessary.\n             #\n@@ -498,27 +503,26 @@ def downloading_llvm(self):\n             or (opt == \"if-available\" and self.build in supported_platforms)\n \n     def _download_component_helper(\n-        self, filename, pattern, tarball_suffix, download_rustc=False, key=None\n+        self, filename, pattern, tarball_suffix, stage0=True, key=None\n     ):\n         if key is None:\n-            if download_rustc:\n-                key = self.rustc_commit\n-            else:\n+            if stage0:\n                 key = self.date\n+            else:\n+                key = self.rustc_commit\n         cache_dst = os.path.join(self.build_dir, \"cache\")\n         rustc_cache = os.path.join(cache_dst, key)\n         if not os.path.exists(rustc_cache):\n             os.makedirs(rustc_cache)\n \n-        if download_rustc:\n-            url = \"https://ci-artifacts.rust-lang.org/rustc-builds/{}\".format(self.rustc_commit)\n-        else:\n+        if stage0:\n             url = \"{}/dist/{}\".format(self._download_url, key)\n+        else:\n+            url = \"https://ci-artifacts.rust-lang.org/rustc-builds/{}\".format(self.rustc_commit)\n         tarball = os.path.join(rustc_cache, filename)\n         if not os.path.exists(tarball):\n-            do_verify = not download_rustc\n-            get(\"{}/{}\".format(url, filename), tarball, verbose=self.verbose, do_verify=do_verify)\n-        unpack(tarball, tarball_suffix, self.bin_root(), match=pattern, verbose=self.verbose)\n+            get(\"{}/{}\".format(url, filename), tarball, verbose=self.verbose, do_verify=stage0)\n+        unpack(tarball, tarball_suffix, self.bin_root(stage0), match=pattern, verbose=self.verbose)\n \n     def _download_ci_llvm(self, llvm_sha, llvm_assertions):\n         cache_prefix = \"llvm-{}-{}\".format(llvm_sha, llvm_assertions)\n@@ -576,10 +580,10 @@ def fix_bin_or_dylib(self, fname, rpath_libz=False):\n         nix_os_msg = \"info: you seem to be running NixOS. Attempting to patch\"\n         print(nix_os_msg, fname)\n \n-        # Only build `stage0/.nix-deps` once.\n+        # Only build `.nix-deps` once.\n         nix_deps_dir = self.nix_deps_dir\n         if not nix_deps_dir:\n-            nix_deps_dir = \"{}/.nix-deps\".format(self.bin_root())\n+            nix_deps_dir = \".nix-deps\"\n             if not os.path.exists(nix_deps_dir):\n                 os.makedirs(nix_deps_dir)\n \n@@ -637,8 +641,8 @@ def fix_bin_or_dylib(self, fname, rpath_libz=False):\n             print(\"warning: failed to call patchelf:\", reason)\n             return\n \n-    # Return the stage1 compiler to download, if any.\n-    def maybe_download_rustc(self):\n+    # If `download-rustc` is set, download the most recent commit with CI artifacts\n+    def maybe_download_ci_toolchain(self):\n         # If `download-rustc` is not set, default to rebuilding.\n         if self.get_toml(\"download-rustc\", section=\"rust\") != \"true\":\n             return None\n@@ -658,17 +662,23 @@ def maybe_download_rustc(self):\n         if status != 0:\n             print(\"warning: `download-rustc` is enabled, but there are changes to compiler/\")\n \n-        return commit\n+        if self.verbose:\n+            print(\"using downloaded stage1 artifacts from CI (commit {})\".format(commit))\n+        self.rustc_commit = commit\n+        # FIXME: support downloading artifacts from the beta channel\n+        self.download_toolchain(False, \"nightly\")\n \n-    def rustc_stamp(self):\n-        \"\"\"Return the path for .rustc-stamp\n+    def rustc_stamp(self, stage0):\n+        \"\"\"Return the path for .rustc-stamp at the given stage\n \n         >>> rb = RustBuild()\n         >>> rb.build_dir = \"build\"\n-        >>> rb.rustc_stamp() == os.path.join(\"build\", \"stage0\", \".rustc-stamp\")\n+        >>> rb.rustc_stamp(True) == os.path.join(\"build\", \"stage0\", \".rustc-stamp\")\n+        True\n+        >>> rb.rustc_stamp(False) == os.path.join(\"build\", \"ci-rustc\", \".rustc-stamp\")\n         True\n         \"\"\"\n-        return os.path.join(self.bin_root(), '.rustc-stamp')\n+        return os.path.join(self.bin_root(stage0), '.rustc-stamp')\n \n     def rustfmt_stamp(self):\n         \"\"\"Return the path for .rustfmt-stamp\n@@ -678,7 +688,7 @@ def rustfmt_stamp(self):\n         >>> rb.rustfmt_stamp() == os.path.join(\"build\", \"stage0\", \".rustfmt-stamp\")\n         True\n         \"\"\"\n-        return os.path.join(self.bin_root(), '.rustfmt-stamp')\n+        return os.path.join(self.bin_root(True), '.rustfmt-stamp')\n \n     def llvm_stamp(self):\n         \"\"\"Return the path for .rustfmt-stamp\n@@ -698,21 +708,27 @@ def program_out_of_date(self, stamp_path, key):\n         with open(stamp_path, 'r') as stamp:\n             return key != stamp.read()\n \n-    def bin_root(self):\n-        \"\"\"Return the binary root directory\n+    def bin_root(self, stage0):\n+        \"\"\"Return the binary root directory for the given stage\n \n         >>> rb = RustBuild()\n         >>> rb.build_dir = \"build\"\n-        >>> rb.bin_root() == os.path.join(\"build\", \"stage0\")\n+        >>> rb.bin_root(True) == os.path.join(\"build\", \"stage0\")\n+        True\n+        >>> rb.bin_root(False) == os.path.join(\"build\", \"ci-rustc\")\n         True\n \n         When the 'build' property is given should be a nested directory:\n \n         >>> rb.build = \"devel\"\n-        >>> rb.bin_root() == os.path.join(\"build\", \"devel\", \"stage0\")\n+        >>> rb.bin_root(True) == os.path.join(\"build\", \"devel\", \"stage0\")\n         True\n         \"\"\"\n-        return os.path.join(self.build_dir, self.build, \"stage0\")\n+        if stage0:\n+            subdir = \"stage0\"\n+        else:\n+            subdir = \"ci-rustc\"\n+        return os.path.join(self.build_dir, self.build, subdir)\n \n     def llvm_root(self):\n         \"\"\"Return the CI LLVM root directory\n@@ -775,33 +791,37 @@ def cargo(self):\n         \"\"\"Return config path for cargo\"\"\"\n         return self.program_config('cargo')\n \n-    def rustc(self):\n+    def rustc(self, stage0):\n         \"\"\"Return config path for rustc\"\"\"\n-        return self.program_config('rustc')\n+        return self.program_config('rustc', stage0)\n \n     def rustfmt(self):\n         \"\"\"Return config path for rustfmt\"\"\"\n         if not self.rustfmt_channel:\n             return None\n         return self.program_config('rustfmt')\n \n-    def program_config(self, program):\n-        \"\"\"Return config path for the given program\n+    def program_config(self, program, stage0=True):\n+        \"\"\"Return config path for the given program at the given stage\n \n         >>> rb = RustBuild()\n         >>> rb.config_toml = 'rustc = \"rustc\"\\\\n'\n         >>> rb.program_config('rustc')\n         'rustc'\n         >>> rb.config_toml = ''\n-        >>> cargo_path = rb.program_config('cargo')\n-        >>> cargo_path.rstrip(\".exe\") == os.path.join(rb.bin_root(),\n+        >>> cargo_path = rb.program_config('cargo', True)\n+        >>> cargo_path.rstrip(\".exe\") == os.path.join(rb.bin_root(True),\n+        ... \"bin\", \"cargo\")\n+        True\n+        >>> cargo_path = rb.program_config('cargo', False)\n+        >>> cargo_path.rstrip(\".exe\") == os.path.join(rb.bin_root(False),\n         ... \"bin\", \"cargo\")\n         True\n         \"\"\"\n         config = self.get_toml(program)\n         if config:\n             return os.path.expanduser(config)\n-        return os.path.join(self.bin_root(), \"bin\", \"{}{}\".format(\n+        return os.path.join(self.bin_root(stage0), \"bin\", \"{}{}\".format(\n             program, self.exe_suffix()))\n \n     @staticmethod\n@@ -856,14 +876,14 @@ def build_bootstrap(self):\n         if \"CARGO_BUILD_TARGET\" in env:\n             del env[\"CARGO_BUILD_TARGET\"]\n         env[\"CARGO_TARGET_DIR\"] = build_dir\n-        env[\"RUSTC\"] = self.rustc()\n-        env[\"LD_LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\") + \\\n+        env[\"RUSTC\"] = self.rustc(True)\n+        env[\"LD_LIBRARY_PATH\"] = os.path.join(self.bin_root(True), \"lib\") + \\\n             (os.pathsep + env[\"LD_LIBRARY_PATH\"]) \\\n             if \"LD_LIBRARY_PATH\" in env else \"\"\n-        env[\"DYLD_LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\") + \\\n+        env[\"DYLD_LIBRARY_PATH\"] = os.path.join(self.bin_root(True), \"lib\") + \\\n             (os.pathsep + env[\"DYLD_LIBRARY_PATH\"]) \\\n             if \"DYLD_LIBRARY_PATH\" in env else \"\"\n-        env[\"LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\") + \\\n+        env[\"LIBRARY_PATH\"] = os.path.join(self.bin_root(True), \"lib\") + \\\n             (os.pathsep + env[\"LIBRARY_PATH\"]) \\\n             if \"LIBRARY_PATH\" in env else \"\"\n         # preserve existing RUSTFLAGS\n@@ -886,7 +906,7 @@ def build_bootstrap(self):\n         if self.get_toml(\"deny-warnings\", \"rust\") != \"false\":\n             env[\"RUSTFLAGS\"] += \" -Dwarnings\"\n \n-        env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n+        env[\"PATH\"] = os.path.join(self.bin_root(True), \"bin\") + \\\n             os.pathsep + env[\"PATH\"]\n         if not os.path.isfile(self.cargo()):\n             raise Exception(\"no cargo executable found at `{}`\".format(\n@@ -1137,14 +1157,9 @@ def bootstrap(help_triggered):\n     build.update_submodules()\n \n     # Fetch/build the bootstrap\n-    build.rustc_commit = build.maybe_download_rustc()\n-    if build.rustc_commit is not None:\n-        if build.verbose:\n-            commit = build.rustc_commit\n-            print(\"using downloaded stage1 artifacts from CI (commit {})\".format(commit))\n-        # FIXME: support downloading artifacts from the beta channel\n-        build.rustc_channel = \"nightly\"\n-    build.download_stage0()\n+    build.download_toolchain()\n+    # Download the master compiler if `download-rustc` is set\n+    build.maybe_download_ci_toolchain()\n     sys.stdout.flush()\n     build.ensure_vendored()\n     build.build_bootstrap()"}, {"sha": "8244c7710ab7b6f7f50bb555c3fe2786364b7a0c", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ca9cbea27a2fc0a3f9c7d820f5bd3eeac1ad25d2/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca9cbea27a2fc0a3f9c7d820f5bd3eeac1ad25d2/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=ca9cbea27a2fc0a3f9c7d820f5bd3eeac1ad25d2", "patch": "@@ -65,7 +65,9 @@ impl Step for Std {\n \n         // These artifacts were already copied (in `impl Step for Sysroot`).\n         // Don't recompile them.\n-        if builder.config.download_rustc {\n+        // NOTE: the ABI of the beta compiler is different from the ABI of the downloaded compiler,\n+        // so its artifacts can't be reused.\n+        if builder.config.download_rustc && compiler.stage != 0 {\n             return;\n         }\n \n@@ -513,7 +515,9 @@ impl Step for Rustc {\n         let compiler = self.compiler;\n         let target = self.target;\n \n-        if builder.config.download_rustc {\n+        // NOTE: the ABI of the beta compiler is different from the ABI of the downloaded compiler,\n+        // so its artifacts can't be reused.\n+        if builder.config.download_rustc && compiler.stage != 0 {\n             // Copy the existing artifacts instead of rebuilding them.\n             // NOTE: this path is only taken for tools linking to rustc-dev.\n             builder.ensure(Sysroot { compiler });\n@@ -934,14 +938,15 @@ impl Step for Sysroot {\n         t!(fs::create_dir_all(&sysroot));\n \n         // If we're downloading a compiler from CI, we can use the same compiler for all stages other than 0.\n-        if builder.config.download_rustc {\n+        if builder.config.download_rustc && compiler.stage != 0 {\n             assert_eq!(\n                 builder.config.build, compiler.host,\n                 \"Cross-compiling is not yet supported with `download-rustc`\",\n             );\n             // Copy the compiler into the correct sysroot.\n-            let stage0_dir = builder.config.out.join(&*builder.config.build.triple).join(\"stage0\");\n-            builder.cp_r(&stage0_dir, &sysroot);\n+            let ci_rustc_dir =\n+                builder.config.out.join(&*builder.config.build.triple).join(\"ci-rustc\");\n+            builder.cp_r(&ci_rustc_dir, &sysroot);\n             return INTERNER.intern_path(sysroot);\n         }\n "}, {"sha": "471f671fd272abd3cce0219c3986f64ee83b7d6f", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 53, "deletions": 45, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ca9cbea27a2fc0a3f9c7d820f5bd3eeac1ad25d2/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca9cbea27a2fc0a3f9c7d820f5bd3eeac1ad25d2/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=ca9cbea27a2fc0a3f9c7d820f5bd3eeac1ad25d2", "patch": "@@ -687,51 +687,6 @@ impl Config {\n         set(&mut config.print_step_timings, build.print_step_timings);\n         set(&mut config.print_step_rusage, build.print_step_rusage);\n \n-        // See https://github.com/rust-lang/compiler-team/issues/326\n-        config.stage = match config.cmd {\n-            Subcommand::Check { .. } => flags.stage.or(build.check_stage).unwrap_or(0),\n-            Subcommand::Doc { .. } => flags.stage.or(build.doc_stage).unwrap_or(0),\n-            Subcommand::Build { .. } => flags.stage.or(build.build_stage).unwrap_or(1),\n-            Subcommand::Test { .. } => flags.stage.or(build.test_stage).unwrap_or(1),\n-            Subcommand::Bench { .. } => flags.stage.or(build.bench_stage).unwrap_or(2),\n-            Subcommand::Dist { .. } => flags.stage.or(build.dist_stage).unwrap_or(2),\n-            Subcommand::Install { .. } => flags.stage.or(build.install_stage).unwrap_or(2),\n-            // These are all bootstrap tools, which don't depend on the compiler.\n-            // The stage we pass shouldn't matter, but use 0 just in case.\n-            Subcommand::Clean { .. }\n-            | Subcommand::Clippy { .. }\n-            | Subcommand::Fix { .. }\n-            | Subcommand::Run { .. }\n-            | Subcommand::Setup { .. }\n-            | Subcommand::Format { .. } => flags.stage.unwrap_or(0),\n-        };\n-\n-        // CI should always run stage 2 builds, unless it specifically states otherwise\n-        #[cfg(not(test))]\n-        if flags.stage.is_none() && crate::CiEnv::current() != crate::CiEnv::None {\n-            match config.cmd {\n-                Subcommand::Test { .. }\n-                | Subcommand::Doc { .. }\n-                | Subcommand::Build { .. }\n-                | Subcommand::Bench { .. }\n-                | Subcommand::Dist { .. }\n-                | Subcommand::Install { .. } => {\n-                    assert_eq!(\n-                        config.stage, 2,\n-                        \"x.py should be run with `--stage 2` on CI, but was run with `--stage {}`\",\n-                        config.stage,\n-                    );\n-                }\n-                Subcommand::Clean { .. }\n-                | Subcommand::Check { .. }\n-                | Subcommand::Clippy { .. }\n-                | Subcommand::Fix { .. }\n-                | Subcommand::Run { .. }\n-                | Subcommand::Setup { .. }\n-                | Subcommand::Format { .. } => {}\n-            }\n-        }\n-\n         config.verbose = cmp::max(config.verbose, flags.verbose);\n \n         if let Some(install) = toml.install {\n@@ -1005,6 +960,59 @@ impl Config {\n         let default = config.channel == \"dev\";\n         config.ignore_git = ignore_git.unwrap_or(default);\n \n+        let download_rustc = config.download_rustc;\n+        // See https://github.com/rust-lang/compiler-team/issues/326\n+        config.stage = match config.cmd {\n+            Subcommand::Check { .. } => flags.stage.or(build.check_stage).unwrap_or(0),\n+            // `download-rustc` only has a speed-up for stage2 builds. Default to stage2 unless explicitly overridden.\n+            Subcommand::Doc { .. } => {\n+                flags.stage.or(build.doc_stage).unwrap_or(if download_rustc { 2 } else { 0 })\n+            }\n+            Subcommand::Build { .. } => {\n+                flags.stage.or(build.build_stage).unwrap_or(if download_rustc { 2 } else { 1 })\n+            }\n+            Subcommand::Test { .. } => {\n+                flags.stage.or(build.test_stage).unwrap_or(if download_rustc { 2 } else { 1 })\n+            }\n+            Subcommand::Bench { .. } => flags.stage.or(build.bench_stage).unwrap_or(2),\n+            Subcommand::Dist { .. } => flags.stage.or(build.dist_stage).unwrap_or(2),\n+            Subcommand::Install { .. } => flags.stage.or(build.install_stage).unwrap_or(2),\n+            // These are all bootstrap tools, which don't depend on the compiler.\n+            // The stage we pass shouldn't matter, but use 0 just in case.\n+            Subcommand::Clean { .. }\n+            | Subcommand::Clippy { .. }\n+            | Subcommand::Fix { .. }\n+            | Subcommand::Run { .. }\n+            | Subcommand::Setup { .. }\n+            | Subcommand::Format { .. } => flags.stage.unwrap_or(0),\n+        };\n+\n+        // CI should always run stage 2 builds, unless it specifically states otherwise\n+        #[cfg(not(test))]\n+        if flags.stage.is_none() && crate::CiEnv::current() != crate::CiEnv::None {\n+            match config.cmd {\n+                Subcommand::Test { .. }\n+                | Subcommand::Doc { .. }\n+                | Subcommand::Build { .. }\n+                | Subcommand::Bench { .. }\n+                | Subcommand::Dist { .. }\n+                | Subcommand::Install { .. } => {\n+                    assert_eq!(\n+                        config.stage, 2,\n+                        \"x.py should be run with `--stage 2` on CI, but was run with `--stage {}`\",\n+                        config.stage,\n+                    );\n+                }\n+                Subcommand::Clean { .. }\n+                | Subcommand::Check { .. }\n+                | Subcommand::Clippy { .. }\n+                | Subcommand::Fix { .. }\n+                | Subcommand::Run { .. }\n+                | Subcommand::Setup { .. }\n+                | Subcommand::Format { .. } => {}\n+            }\n+        }\n+\n         config\n     }\n "}, {"sha": "f9be35d7c5e0df7619acb4feda3793a239c67f3f", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ca9cbea27a2fc0a3f9c7d820f5bd3eeac1ad25d2/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca9cbea27a2fc0a3f9c7d820f5bd3eeac1ad25d2/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=ca9cbea27a2fc0a3f9c7d820f5bd3eeac1ad25d2", "patch": "@@ -513,6 +513,19 @@ impl Step for Rustdoc {\n         // rustc compiler it's paired with, so it must be built with the previous stage compiler.\n         let build_compiler = builder.compiler(target_compiler.stage - 1, builder.config.build);\n \n+        // When using `download-rustc` and a stage0 build_compiler, copying rustc doesn't actually\n+        // build stage0 libstd (because the libstd in sysroot has the wrong ABI). Explicitly build\n+        // it.\n+        builder.ensure(compile::Std { compiler: build_compiler, target: target_compiler.host });\n+        builder.ensure(compile::Rustc { compiler: build_compiler, target: target_compiler.host });\n+        // NOTE: this implies that `download-rustc` is pretty useless when compiling with the stage0\n+        // compiler, since you do just as much work.\n+        if !builder.config.dry_run && builder.config.download_rustc && build_compiler.stage == 0 {\n+            println!(\n+                \"warning: `download-rustc` does nothing when building stage1 tools; consider using `--stage 2` instead\"\n+            );\n+        }\n+\n         // The presence of `target_compiler` ensures that the necessary libraries (codegen backends,\n         // compiler libraries, ...) are built. Rustdoc does not require the presence of any\n         // libraries within sysroot_libdir (i.e., rustlib), though doctests may want it (since"}]}