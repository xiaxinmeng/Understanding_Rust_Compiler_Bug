{"sha": "f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2YWI3NGI4ZTdlZmVkMDFjMTA0NTc3M2I2NjkzZjIzZjZlYmQ5M2M=", "commit": {"author": {"name": "Mike Hommey", "email": "mh@glandium.org", "date": "2018-05-31T06:57:43Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-06-11T20:47:23Z"}, "message": "Remove alloc::Opaque and use *mut u8 as pointer type for GlobalAlloc", "tree": {"sha": "41bdf1b52eed30d5d203bd8f95ecfa839047be74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41bdf1b52eed30d5d203bd8f95ecfa839047be74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "html_url": "https://github.com/rust-lang/rust/commit/f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/comments", "author": {"login": "glandium", "id": 1038527, "node_id": "MDQ6VXNlcjEwMzg1Mjc=", "avatar_url": "https://avatars.githubusercontent.com/u/1038527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glandium", "html_url": "https://github.com/glandium", "followers_url": "https://api.github.com/users/glandium/followers", "following_url": "https://api.github.com/users/glandium/following{/other_user}", "gists_url": "https://api.github.com/users/glandium/gists{/gist_id}", "starred_url": "https://api.github.com/users/glandium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glandium/subscriptions", "organizations_url": "https://api.github.com/users/glandium/orgs", "repos_url": "https://api.github.com/users/glandium/repos", "events_url": "https://api.github.com/users/glandium/events{/privacy}", "received_events_url": "https://api.github.com/users/glandium/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b7c9e756e8bee2efd4f6929c79f9e3ed9115689", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b7c9e756e8bee2efd4f6929c79f9e3ed9115689", "html_url": "https://github.com/rust-lang/rust/commit/0b7c9e756e8bee2efd4f6929c79f9e3ed9115689"}], "stats": {"total": 305, "additions": 130, "deletions": 175}, "files": [{"sha": "7dfdc4877316eb44135a6b53cfacd70fb68ac3a6", "filename": "src/doc/unstable-book/src/language-features/global-allocator.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md?ref=f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "patch": "@@ -29,17 +29,17 @@ looks like:\n ```rust\n #![feature(global_allocator, allocator_api, heap_api)]\n \n-use std::alloc::{GlobalAlloc, System, Layout, Opaque};\n+use std::alloc::{GlobalAlloc, System, Layout};\n use std::ptr::NonNull;\n \n struct MyAllocator;\n \n unsafe impl GlobalAlloc for MyAllocator {\n-    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n         System.alloc(layout)\n     }\n \n-    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n         System.dealloc(ptr, layout)\n     }\n }"}, {"sha": "102910f4198fa50e8bc913b5c91a15bd86a4b9a5", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "patch": "@@ -51,52 +51,49 @@ pub const Heap: Global = Global;\n \n unsafe impl GlobalAlloc for Global {\n     #[inline]\n-    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n-        let ptr = __rust_alloc(layout.size(), layout.align());\n-        ptr as *mut Opaque\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        __rust_alloc(layout.size(), layout.align())\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n-        __rust_dealloc(ptr as *mut u8, layout.size(), layout.align())\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+        __rust_dealloc(ptr, layout.size(), layout.align())\n     }\n \n     #[inline]\n-    unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n-        let ptr = __rust_realloc(ptr as *mut u8, layout.size(), layout.align(), new_size);\n-        ptr as *mut Opaque\n+    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+        __rust_realloc(ptr, layout.size(), layout.align(), new_size)\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n-        let ptr = __rust_alloc_zeroed(layout.size(), layout.align());\n-        ptr as *mut Opaque\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+        __rust_alloc_zeroed(layout.size(), layout.align())\n     }\n }\n \n unsafe impl Alloc for Global {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n         NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout) {\n+    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n         GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n     }\n \n     #[inline]\n     unsafe fn realloc(&mut self,\n-                      ptr: NonNull<Opaque>,\n+                      ptr: NonNull<u8>,\n                       layout: Layout,\n                       new_size: usize)\n-                      -> Result<NonNull<Opaque>, AllocErr>\n+                      -> Result<NonNull<u8>, AllocErr>\n     {\n         NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n         NonNull::new(GlobalAlloc::alloc_zeroed(self, layout)).ok_or(AllocErr)\n     }\n }\n@@ -113,7 +110,7 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n         let layout = Layout::from_size_align_unchecked(size, align);\n         let ptr = Global.alloc(layout);\n         if !ptr.is_null() {\n-            ptr as *mut u8\n+            ptr\n         } else {\n             oom(layout)\n         }\n@@ -129,7 +126,7 @@ pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n     // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary.\n     if size != 0 {\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        Global.dealloc(ptr as *mut Opaque, layout);\n+        Global.dealloc(ptr as *mut u8, layout);\n     }\n }\n "}, {"sha": "e3369f0a5b5bf52524b6e11d7e211ffdc4ac3f7c", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "patch": "@@ -519,7 +519,7 @@ impl<T: ?Sized> Arc<T> {\n \n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n-            Global.dealloc(self.ptr.as_opaque(), Layout::for_value(self.ptr.as_ref()))\n+            Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()))\n         }\n     }\n \n@@ -639,7 +639,7 @@ impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n \n-                    Global.dealloc(self.mem.as_opaque(), self.layout.clone());\n+                    Global.dealloc(self.mem.cast(), self.layout.clone());\n                 }\n             }\n         }\n@@ -1196,7 +1196,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n             unsafe {\n-                Global.dealloc(self.ptr.as_opaque(), Layout::for_value(self.ptr.as_ref()))\n+                Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()))\n             }\n         }\n     }"}, {"sha": "19bdcbc6ad63ea8d3f7fe7531b3f866fe019440c", "filename": "src/liballoc/btree/node.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Fliballoc%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Fliballoc%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fnode.rs?ref=f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "patch": "@@ -287,7 +287,7 @@ impl<K, V> Root<K, V> {\n         self.as_mut().as_leaf_mut().parent = ptr::null();\n \n         unsafe {\n-            Global.dealloc(NonNull::from(top).as_opaque(), Layout::new::<InternalNode<K, V>>());\n+            Global.dealloc(NonNull::from(top).cast(), Layout::new::<InternalNode<K, V>>());\n         }\n     }\n }\n@@ -478,7 +478,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n         debug_assert!(!self.is_shared_root());\n         let node = self.node;\n         let ret = self.ascend().ok();\n-        Global.dealloc(node.as_opaque(), Layout::new::<LeafNode<K, V>>());\n+        Global.dealloc(node.cast(), Layout::new::<LeafNode<K, V>>());\n         ret\n     }\n }\n@@ -499,7 +499,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n     > {\n         let node = self.node;\n         let ret = self.ascend().ok();\n-        Global.dealloc(node.as_opaque(), Layout::new::<InternalNode<K, V>>());\n+        Global.dealloc(node.cast(), Layout::new::<InternalNode<K, V>>());\n         ret\n     }\n }\n@@ -1321,12 +1321,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 }\n \n                 Global.dealloc(\n-                    right_node.node.as_opaque(),\n+                    right_node.node.cast(),\n                     Layout::new::<InternalNode<K, V>>(),\n                 );\n             } else {\n                 Global.dealloc(\n-                    right_node.node.as_opaque(),\n+                    right_node.node.cast(),\n                     Layout::new::<LeafNode<K, V>>(),\n                 );\n             }"}, {"sha": "5ea37ceeb2b200e3aeb6ad11f249528388eb2ff3", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "patch": "@@ -10,7 +10,7 @@\n \n #![allow(deprecated)]\n \n-pub use alloc::{Layout, AllocErr, CannotReallocInPlace, Opaque};\n+pub use alloc::{Layout, AllocErr, CannotReallocInPlace};\n use core::alloc::Alloc as CoreAlloc;\n use core::ptr::NonNull;\n \n@@ -54,7 +54,7 @@ unsafe impl<T> Alloc for T where T: CoreAlloc {\n     }\n \n     unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n-        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n+        let ptr = NonNull::new_unchecked(ptr);\n         CoreAlloc::dealloc(self, ptr, layout)\n     }\n \n@@ -70,7 +70,7 @@ unsafe impl<T> Alloc for T where T: CoreAlloc {\n                       ptr: *mut u8,\n                       layout: Layout,\n                       new_layout: Layout) -> Result<*mut u8, AllocErr> {\n-        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n+        let ptr = NonNull::new_unchecked(ptr);\n         CoreAlloc::realloc(self, ptr, layout, new_layout.size()).map(|ptr| ptr.cast().as_ptr())\n     }\n \n@@ -87,7 +87,7 @@ unsafe impl<T> Alloc for T where T: CoreAlloc {\n                              ptr: *mut u8,\n                              layout: Layout,\n                              new_layout: Layout) -> Result<Excess, AllocErr> {\n-        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n+        let ptr = NonNull::new_unchecked(ptr);\n         CoreAlloc::realloc_excess(self, ptr, layout, new_layout.size())\n             .map(|e| Excess(e.0 .cast().as_ptr(), e.1))\n     }\n@@ -96,15 +96,15 @@ unsafe impl<T> Alloc for T where T: CoreAlloc {\n                             ptr: *mut u8,\n                             layout: Layout,\n                             new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n+        let ptr = NonNull::new_unchecked(ptr);\n         CoreAlloc::grow_in_place(self, ptr, layout, new_layout.size())\n     }\n \n     unsafe fn shrink_in_place(&mut self,\n                               ptr: *mut u8,\n                               layout: Layout,\n                               new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n+        let ptr = NonNull::new_unchecked(ptr);\n         CoreAlloc::shrink_in_place(self, ptr, layout, new_layout.size())\n     }\n }"}, {"sha": "c09f21eeb921e826cf75d977b4a813cae6855c52", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "patch": "@@ -93,7 +93,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             // handles ZSTs and `cap = 0` alike\n             let ptr = if alloc_size == 0 {\n-                NonNull::<T>::dangling().as_opaque()\n+                NonNull::<T>::dangling().cast()\n             } else {\n                 let align = mem::align_of::<T>();\n                 let layout = Layout::from_size_align(alloc_size, align).unwrap();\n@@ -314,7 +314,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     let new_cap = 2 * self.cap;\n                     let new_size = new_cap * elem_size;\n                     alloc_guard(new_size).unwrap_or_else(|_| capacity_overflow());\n-                    let ptr_res = self.a.realloc(NonNull::from(self.ptr).as_opaque(),\n+                    let ptr_res = self.a.realloc(NonNull::from(self.ptr).cast(),\n                                                  cur,\n                                                  new_size);\n                     match ptr_res {\n@@ -373,7 +373,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let new_cap = 2 * self.cap;\n             let new_size = new_cap * elem_size;\n             alloc_guard(new_size).unwrap_or_else(|_| capacity_overflow());\n-            match self.a.grow_in_place(NonNull::from(self.ptr).as_opaque(), old_layout, new_size) {\n+            match self.a.grow_in_place(NonNull::from(self.ptr).cast(), old_layout, new_size) {\n                 Ok(_) => {\n                     // We can't directly divide `size`.\n                     self.cap = new_cap;\n@@ -546,7 +546,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // FIXME: may crash and burn on over-reserve\n             alloc_guard(new_layout.size()).unwrap_or_else(|_| capacity_overflow());\n             match self.a.grow_in_place(\n-                NonNull::from(self.ptr).as_opaque(), old_layout, new_layout.size(),\n+                NonNull::from(self.ptr).cast(), old_layout, new_layout.size(),\n             ) {\n                 Ok(_) => {\n                     self.cap = new_cap;\n@@ -607,7 +607,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 let new_size = elem_size * amount;\n                 let align = mem::align_of::<T>();\n                 let old_layout = Layout::from_size_align_unchecked(old_size, align);\n-                match self.a.realloc(NonNull::from(self.ptr).as_opaque(),\n+                match self.a.realloc(NonNull::from(self.ptr).cast(),\n                                      old_layout,\n                                      new_size) {\n                     Ok(p) => self.ptr = p.cast().into(),\n@@ -667,7 +667,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let res = match self.current_layout() {\n                 Some(layout) => {\n                     debug_assert!(new_layout.align() == layout.align());\n-                    self.a.realloc(NonNull::from(self.ptr).as_opaque(), layout, new_layout.size())\n+                    self.a.realloc(NonNull::from(self.ptr).cast(), layout, new_layout.size())\n                 }\n                 None => self.a.alloc(new_layout),\n             };\n@@ -710,7 +710,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n         let elem_size = mem::size_of::<T>();\n         if elem_size != 0 {\n             if let Some(layout) = self.current_layout() {\n-                self.a.dealloc(NonNull::from(self.ptr).as_opaque(), layout);\n+                self.a.dealloc(NonNull::from(self.ptr).cast(), layout);\n             }\n         }\n     }\n@@ -753,7 +753,6 @@ fn capacity_overflow() -> ! {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use alloc::Opaque;\n \n     #[test]\n     fn allocator_param() {\n@@ -773,7 +772,7 @@ mod tests {\n         // before allocation attempts start failing.\n         struct BoundedAlloc { fuel: usize }\n         unsafe impl Alloc for BoundedAlloc {\n-            unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n+            unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n                 let size = layout.size();\n                 if size > self.fuel {\n                     return Err(AllocErr);\n@@ -783,7 +782,7 @@ mod tests {\n                     err @ Err(_) => err,\n                 }\n             }\n-            unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout) {\n+            unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n                 Global.dealloc(ptr, layout)\n             }\n         }"}, {"sha": "84a6ecf710399d0f0fc923101da92599f7e567c4", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "patch": "@@ -259,7 +259,7 @@ use core::ops::CoerceUnsized;\n use core::ptr::{self, NonNull};\n use core::convert::From;\n \n-use alloc::{Global, Alloc, Layout, Opaque, box_free, oom};\n+use alloc::{Global, Alloc, Layout, box_free, oom};\n use string::String;\n use vec::Vec;\n \n@@ -732,7 +732,7 @@ impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n         // In the event of a panic, elements that have been written\n         // into the new RcBox will be dropped, then the memory freed.\n         struct Guard<T> {\n-            mem: NonNull<Opaque>,\n+            mem: NonNull<u8>,\n             elems: *mut T,\n             layout: Layout,\n             n_elems: usize,\n@@ -755,7 +755,7 @@ impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n             let v_ptr = v as *const [T];\n             let ptr = Self::allocate_for_ptr(v_ptr);\n \n-            let mem = ptr as *mut _ as *mut Opaque;\n+            let mem = ptr as *mut _ as *mut u8;\n             let layout = Layout::for_value(&*ptr);\n \n             // Pointer to first element\n@@ -839,7 +839,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n                 self.dec_weak();\n \n                 if self.weak() == 0 {\n-                    Global.dealloc(self.ptr.as_opaque(), Layout::for_value(self.ptr.as_ref()));\n+                    Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n                 }\n             }\n         }\n@@ -1263,7 +1263,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n             // the weak count starts at 1, and will only go to zero if all\n             // the strong pointers have disappeared.\n             if self.weak() == 0 {\n-                Global.dealloc(self.ptr.as_opaque(), Layout::for_value(self.ptr.as_ref()));\n+                Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n             }\n         }\n     }"}, {"sha": "82fda8d639ecbbc4917b344da32683ba3dc62391", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 43, "deletions": 46, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "patch": "@@ -41,7 +41,7 @@ const MIN_ALIGN: usize = 8;\n #[allow(dead_code)]\n const MIN_ALIGN: usize = 16;\n \n-use core::alloc::{Alloc, GlobalAlloc, AllocErr, Layout, Opaque};\n+use core::alloc::{Alloc, GlobalAlloc, AllocErr, Layout};\n use core::ptr::NonNull;\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n@@ -50,45 +50,45 @@ pub struct System;\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl Alloc for System {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n         NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n         NonNull::new(GlobalAlloc::alloc_zeroed(self, layout)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout) {\n+    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n         GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n     }\n \n     #[inline]\n     unsafe fn realloc(&mut self,\n-                      ptr: NonNull<Opaque>,\n+                      ptr: NonNull<u8>,\n                       layout: Layout,\n-                      new_size: usize) -> Result<NonNull<Opaque>, AllocErr> {\n+                      new_size: usize) -> Result<NonNull<u8>, AllocErr> {\n         NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n     }\n }\n \n #[cfg(any(windows, unix, target_os = \"cloudabi\", target_os = \"redox\"))]\n mod realloc_fallback {\n-    use core::alloc::{GlobalAlloc, Opaque, Layout};\n+    use core::alloc::{GlobalAlloc, Layout};\n     use core::cmp;\n     use core::ptr;\n \n     impl super::System {\n-        pub(crate) unsafe fn realloc_fallback(&self, ptr: *mut Opaque, old_layout: Layout,\n-                                              new_size: usize) -> *mut Opaque {\n+        pub(crate) unsafe fn realloc_fallback(&self, ptr: *mut u8, old_layout: Layout,\n+                                              new_size: usize) -> *mut u8 {\n             // Docs for GlobalAlloc::realloc require this to be valid:\n             let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n \n             let new_ptr = GlobalAlloc::alloc(self, new_layout);\n             if !new_ptr.is_null() {\n                 let size = cmp::min(old_layout.size(), new_size);\n-                ptr::copy_nonoverlapping(ptr as *mut u8, new_ptr as *mut u8, size);\n+                ptr::copy_nonoverlapping(ptr, new_ptr, size);\n                 GlobalAlloc::dealloc(self, ptr, old_layout);\n             }\n             new_ptr\n@@ -104,49 +104,47 @@ mod platform {\n \n     use MIN_ALIGN;\n     use System;\n-    use core::alloc::{GlobalAlloc, Layout, Opaque};\n+    use core::alloc::{GlobalAlloc, Layout};\n \n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n+        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n             if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-                libc::malloc(layout.size()) as *mut Opaque\n+                libc::malloc(layout.size()) as *mut u8\n             } else {\n                 #[cfg(target_os = \"macos\")]\n                 {\n                     if layout.align() > (1 << 31) {\n-                        // FIXME: use Opaque::null_mut\n-                        // https://github.com/rust-lang/rust/issues/49659\n-                        return 0 as *mut Opaque\n+                        return ptr::null_mut()\n                     }\n                 }\n                 aligned_malloc(&layout)\n             }\n         }\n \n         #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n             if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-                libc::calloc(layout.size(), 1) as *mut Opaque\n+                libc::calloc(layout.size(), 1) as *mut u8\n             } else {\n                 let ptr = self.alloc(layout.clone());\n                 if !ptr.is_null() {\n-                    ptr::write_bytes(ptr as *mut u8, 0, layout.size());\n+                    ptr::write_bytes(ptr, 0, layout.size());\n                 }\n                 ptr\n             }\n         }\n \n         #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut Opaque, _layout: Layout) {\n+        unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n             libc::free(ptr as *mut libc::c_void)\n         }\n \n         #[inline]\n-        unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n+        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n             if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n-                libc::realloc(ptr as *mut libc::c_void, new_size) as *mut Opaque\n+                libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8\n             } else {\n                 self.realloc_fallback(ptr, layout, new_size)\n             }\n@@ -155,7 +153,7 @@ mod platform {\n \n     #[cfg(any(target_os = \"android\", target_os = \"redox\", target_os = \"solaris\"))]\n     #[inline]\n-    unsafe fn aligned_malloc(layout: &Layout) -> *mut Opaque {\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n         // On android we currently target API level 9 which unfortunately\n         // doesn't have the `posix_memalign` API used below. Instead we use\n         // `memalign`, but this unfortunately has the property on some systems\n@@ -173,19 +171,18 @@ mod platform {\n         // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n         // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n         //                                       /memory/aligned_memory.cc\n-        libc::memalign(layout.align(), layout.size()) as *mut Opaque\n+        libc::memalign(layout.align(), layout.size()) as *mut u8\n     }\n \n     #[cfg(not(any(target_os = \"android\", target_os = \"redox\", target_os = \"solaris\")))]\n     #[inline]\n-    unsafe fn aligned_malloc(layout: &Layout) -> *mut Opaque {\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n         let mut out = ptr::null_mut();\n         let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n         if ret != 0 {\n-            // FIXME: use Opaque::null_mut https://github.com/rust-lang/rust/issues/49659\n-            0 as *mut Opaque\n+            ptr::null_mut()\n         } else {\n-            out as *mut Opaque\n+            out as *mut u8\n         }\n     }\n }\n@@ -195,7 +192,7 @@ mod platform {\n mod platform {\n     use MIN_ALIGN;\n     use System;\n-    use core::alloc::{GlobalAlloc, Opaque, Layout};\n+    use core::alloc::{GlobalAlloc, Layout};\n \n     type LPVOID = *mut u8;\n     type HANDLE = LPVOID;\n@@ -227,7 +224,7 @@ mod platform {\n     }\n \n     #[inline]\n-    unsafe fn allocate_with_flags(layout: Layout, flags: DWORD) -> *mut Opaque {\n+    unsafe fn allocate_with_flags(layout: Layout, flags: DWORD) -> *mut u8 {\n         let ptr = if layout.align() <= MIN_ALIGN {\n             HeapAlloc(GetProcessHeap(), flags, layout.size())\n         } else {\n@@ -239,39 +236,39 @@ mod platform {\n                 align_ptr(ptr, layout.align())\n             }\n         };\n-        ptr as *mut Opaque\n+        ptr as *mut u8\n     }\n \n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n+        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n             allocate_with_flags(layout, 0)\n         }\n \n         #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n             allocate_with_flags(layout, HEAP_ZERO_MEMORY)\n         }\n \n         #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n+        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n             if layout.align() <= MIN_ALIGN {\n                 let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n                 debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n                               GetLastError());\n             } else {\n-                let header = get_header(ptr as *mut u8);\n+                let header = get_header(ptr);\n                 let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n                 debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n                               GetLastError());\n             }\n         }\n \n         #[inline]\n-        unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n+        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n             if layout.align() <= MIN_ALIGN {\n-                HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, new_size) as *mut Opaque\n+                HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, new_size) as *mut u8\n             } else {\n                 self.realloc_fallback(ptr, layout, new_size)\n             }\n@@ -300,7 +297,7 @@ mod platform {\n mod platform {\n     extern crate dlmalloc;\n \n-    use core::alloc::{GlobalAlloc, Layout, Opaque};\n+    use core::alloc::{GlobalAlloc, Layout};\n     use System;\n \n     // No need for synchronization here as wasm is currently single-threaded\n@@ -309,23 +306,23 @@ mod platform {\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n-            DLMALLOC.malloc(layout.size(), layout.align()) as *mut Opaque\n+        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+            DLMALLOC.malloc(layout.size(), layout.align())\n         }\n \n         #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n-            DLMALLOC.calloc(layout.size(), layout.align()) as *mut Opaque\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+            DLMALLOC.calloc(layout.size(), layout.align())\n         }\n \n         #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n-            DLMALLOC.free(ptr as *mut u8, layout.size(), layout.align())\n+        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+            DLMALLOC.free(ptr, layout.size(), layout.align())\n         }\n \n         #[inline]\n-        unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n-            DLMALLOC.realloc(ptr as *mut u8, layout.size(), layout.align(), new_size) as *mut Opaque\n+        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+            DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size)\n         }\n     }\n }"}, {"sha": "2815ef6400de2e8b8e8343082024c20fc2b8980e", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 24, "deletions": 41, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "patch": "@@ -22,30 +22,13 @@ use usize;\n use ptr::{self, NonNull};\n use num::NonZeroUsize;\n \n-extern {\n-    /// An opaque, unsized type. Used for pointers to allocated memory.\n-    ///\n-    /// This type can only be used behind a pointer like `*mut Opaque` or `ptr::NonNull<Opaque>`.\n-    /// Such pointers are similar to C\u2019s `void*` type.\n-    pub type Opaque;\n-}\n-\n-impl Opaque {\n-    /// Similar to `std::ptr::null`, which requires `T: Sized`.\n-    pub fn null() -> *const Self {\n-        0 as _\n-    }\n-\n-    /// Similar to `std::ptr::null_mut`, which requires `T: Sized`.\n-    pub fn null_mut() -> *mut Self {\n-        0 as _\n-    }\n-}\n+#[cfg(stage0)]\n+pub type Opaque = u8;\n \n /// Represents the combination of a starting address and\n /// a total capacity of the returned block.\n #[derive(Debug)]\n-pub struct Excess(pub NonNull<Opaque>, pub usize);\n+pub struct Excess(pub NonNull<u8>, pub usize);\n \n fn size_align<T>() -> (usize, usize) {\n     (mem::size_of::<T>(), mem::align_of::<T>())\n@@ -417,21 +400,21 @@ pub unsafe trait GlobalAlloc {\n     /// # Safety\n     ///\n     /// **FIXME:** what are the exact requirements?\n-    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque;\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8;\n \n     /// Deallocate the block of memory at the given `ptr` pointer with the given `layout`.\n     ///\n     /// # Safety\n     ///\n     /// **FIXME:** what are the exact requirements?\n     /// In particular around layout *fit*. (See docs for the `Alloc` trait.)\n-    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout);\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);\n \n-    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n         let size = layout.size();\n         let ptr = self.alloc(layout);\n         if !ptr.is_null() {\n-            ptr::write_bytes(ptr as *mut u8, 0, size);\n+            ptr::write_bytes(ptr, 0, size);\n         }\n         ptr\n     }\n@@ -452,13 +435,13 @@ pub unsafe trait GlobalAlloc {\n     ///\n     /// **FIXME:** what are the exact requirements?\n     /// In particular around layout *fit*. (See docs for the `Alloc` trait.)\n-    unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n+    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n         let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n         let new_ptr = self.alloc(new_layout);\n         if !new_ptr.is_null() {\n             ptr::copy_nonoverlapping(\n-                ptr as *const u8,\n-                new_ptr as *mut u8,\n+                ptr,\n+                new_ptr,\n                 cmp::min(layout.size(), new_size),\n             );\n             self.dealloc(ptr, layout);\n@@ -598,7 +581,7 @@ pub unsafe trait Alloc {\n     /// Clients wishing to abort computation in response to an\n     /// allocation error are encouraged to call the allocator's `oom`\n     /// method, rather than directly invoking `panic!` or similar.\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr>;\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr>;\n \n     /// Deallocate the memory referenced by `ptr`.\n     ///\n@@ -615,7 +598,7 @@ pub unsafe trait Alloc {\n     /// * In addition to fitting the block of memory `layout`, the\n     ///   alignment of the `layout` must match the alignment used\n     ///   to allocate that block of memory.\n-    unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout);\n+    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout);\n \n     // == ALLOCATOR-SPECIFIC QUANTITIES AND LIMITS ==\n     // usable_size\n@@ -707,9 +690,9 @@ pub unsafe trait Alloc {\n     /// reallocation error are encouraged to call the allocator's `oom`\n     /// method, rather than directly invoking `panic!` or similar.\n     unsafe fn realloc(&mut self,\n-                      ptr: NonNull<Opaque>,\n+                      ptr: NonNull<u8>,\n                       layout: Layout,\n-                      new_size: usize) -> Result<NonNull<Opaque>, AllocErr> {\n+                      new_size: usize) -> Result<NonNull<u8>, AllocErr> {\n         let old_size = layout.size();\n \n         if new_size >= old_size {\n@@ -726,8 +709,8 @@ pub unsafe trait Alloc {\n         let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n         let result = self.alloc(new_layout);\n         if let Ok(new_ptr) = result {\n-            ptr::copy_nonoverlapping(ptr.as_ptr() as *const u8,\n-                                     new_ptr.as_ptr() as *mut u8,\n+            ptr::copy_nonoverlapping(ptr.as_ptr(),\n+                                     new_ptr.as_ptr(),\n                                      cmp::min(old_size, new_size));\n             self.dealloc(ptr, layout);\n         }\n@@ -750,11 +733,11 @@ pub unsafe trait Alloc {\n     /// Clients wishing to abort computation in response to an\n     /// allocation error are encouraged to call the allocator's `oom`\n     /// method, rather than directly invoking `panic!` or similar.\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n         let size = layout.size();\n         let p = self.alloc(layout);\n         if let Ok(p) = p {\n-            ptr::write_bytes(p.as_ptr() as *mut u8, 0, size);\n+            ptr::write_bytes(p.as_ptr(), 0, size);\n         }\n         p\n     }\n@@ -799,7 +782,7 @@ pub unsafe trait Alloc {\n     /// reallocation error are encouraged to call the allocator's `oom`\n     /// method, rather than directly invoking `panic!` or similar.\n     unsafe fn realloc_excess(&mut self,\n-                             ptr: NonNull<Opaque>,\n+                             ptr: NonNull<u8>,\n                              layout: Layout,\n                              new_size: usize) -> Result<Excess, AllocErr> {\n         let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n@@ -844,7 +827,7 @@ pub unsafe trait Alloc {\n     /// `grow_in_place` failures without aborting, or to fall back on\n     /// another reallocation method before resorting to an abort.\n     unsafe fn grow_in_place(&mut self,\n-                            ptr: NonNull<Opaque>,\n+                            ptr: NonNull<u8>,\n                             layout: Layout,\n                             new_size: usize) -> Result<(), CannotReallocInPlace> {\n         let _ = ptr; // this default implementation doesn't care about the actual address.\n@@ -899,7 +882,7 @@ pub unsafe trait Alloc {\n     /// `shrink_in_place` failures without aborting, or to fall back\n     /// on another reallocation method before resorting to an abort.\n     unsafe fn shrink_in_place(&mut self,\n-                              ptr: NonNull<Opaque>,\n+                              ptr: NonNull<u8>,\n                               layout: Layout,\n                               new_size: usize) -> Result<(), CannotReallocInPlace> {\n         let _ = ptr; // this default implementation doesn't care about the actual address.\n@@ -978,7 +961,7 @@ pub unsafe trait Alloc {\n     {\n         let k = Layout::new::<T>();\n         if k.size() > 0 {\n-            self.dealloc(ptr.as_opaque(), k);\n+            self.dealloc(ptr.cast(), k);\n         }\n     }\n \n@@ -1066,7 +1049,7 @@ pub unsafe trait Alloc {\n         match (Layout::array::<T>(n_old), Layout::array::<T>(n_new)) {\n             (Ok(ref k_old), Ok(ref k_new)) if k_old.size() > 0 && k_new.size() > 0 => {\n                 debug_assert!(k_old.align() == k_new.align());\n-                self.realloc(ptr.as_opaque(), k_old.clone(), k_new.size()).map(NonNull::cast)\n+                self.realloc(ptr.cast(), k_old.clone(), k_new.size()).map(NonNull::cast)\n             }\n             _ => {\n                 Err(AllocErr)\n@@ -1099,7 +1082,7 @@ pub unsafe trait Alloc {\n     {\n         match Layout::array::<T>(n) {\n             Ok(ref k) if k.size() > 0 => {\n-                Ok(self.dealloc(ptr.as_opaque(), k.clone()))\n+                Ok(self.dealloc(ptr.cast(), k.clone()))\n             }\n             _ => {\n                 Err(AllocErr)"}, {"sha": "81a8b3ef0474d6f7b9eb835e1cc075f7722e0676", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "patch": "@@ -2922,14 +2922,6 @@ impl<T: ?Sized> NonNull<T> {\n             NonNull::new_unchecked(self.as_ptr() as *mut U)\n         }\n     }\n-\n-    /// Cast to an `Opaque` pointer\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    pub fn as_opaque(self) -> NonNull<::alloc::Opaque> {\n-        unsafe {\n-            NonNull::new_unchecked(self.as_ptr() as _)\n-        }\n-    }\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]"}, {"sha": "ec0676259ef20845f4ae2f1f62f797cc5588268d", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "patch": "@@ -237,7 +237,7 @@ impl<'a> AllocFnFactory<'a> {\n                 let ident = ident();\n                 args.push(self.cx.arg(self.span, ident, self.ptr_u8()));\n                 let arg = self.cx.expr_ident(self.span, ident);\n-                self.cx.expr_cast(self.span, arg, self.ptr_opaque())\n+                self.cx.expr_cast(self.span, arg, self.ptr_u8())\n             }\n \n             AllocatorTy::Usize => {\n@@ -281,17 +281,4 @@ impl<'a> AllocFnFactory<'a> {\n         let ty_u8 = self.cx.ty_path(u8);\n         self.cx.ty_ptr(self.span, ty_u8, Mutability::Mutable)\n     }\n-\n-    fn ptr_opaque(&self) -> P<Ty> {\n-        let opaque = self.cx.path(\n-            self.span,\n-            vec![\n-                self.core,\n-                Ident::from_str(\"alloc\"),\n-                Ident::from_str(\"Opaque\"),\n-            ],\n-        );\n-        let ty_opaque = self.cx.ty_path(opaque);\n-        self.cx.ty_ptr(self.span, ty_opaque, Mutability::Mutable)\n-    }\n }"}, {"sha": "ac7da5e9dba1a6800669e251f05110c655baf69e", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "patch": "@@ -74,7 +74,7 @@ pub extern fn rust_oom(layout: Layout) -> ! {\n #[doc(hidden)]\n #[allow(unused_attributes)]\n pub mod __default_lib_allocator {\n-    use super::{System, Layout, GlobalAlloc, Opaque};\n+    use super::{System, Layout, GlobalAlloc};\n     // for symbol names src/librustc/middle/allocator.rs\n     // for signatures src/librustc_allocator/lib.rs\n \n@@ -85,15 +85,15 @@ pub mod __default_lib_allocator {\n     #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rdl_alloc(size: usize, align: usize) -> *mut u8 {\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        System.alloc(layout) as *mut u8\n+        System.alloc(layout)\n     }\n \n     #[no_mangle]\n     #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rdl_dealloc(ptr: *mut u8,\n                                        size: usize,\n                                        align: usize) {\n-        System.dealloc(ptr as *mut Opaque, Layout::from_size_align_unchecked(size, align))\n+        System.dealloc(ptr, Layout::from_size_align_unchecked(size, align))\n     }\n \n     #[no_mangle]\n@@ -103,13 +103,13 @@ pub mod __default_lib_allocator {\n                                        align: usize,\n                                        new_size: usize) -> *mut u8 {\n         let old_layout = Layout::from_size_align_unchecked(old_size, align);\n-        System.realloc(ptr as *mut Opaque, old_layout, new_size) as *mut u8\n+        System.realloc(ptr, old_layout, new_size)\n     }\n \n     #[no_mangle]\n     #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rdl_alloc_zeroed(size: usize, align: usize) -> *mut u8 {\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        System.alloc_zeroed(layout) as *mut u8\n+        System.alloc_zeroed(layout)\n     }\n }"}, {"sha": "55f9f4f7cfeb75d7b8a615d06d2acc0f070d00ac", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "patch": "@@ -1124,7 +1124,7 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n         let (layout, _) = calculate_layout::<K, V>(self.capacity())\n             .unwrap_or_else(|_| unsafe { hint::unreachable_unchecked() });\n         unsafe {\n-            Global.dealloc(NonNull::new_unchecked(self.hashes.ptr()).as_opaque(), layout);\n+            Global.dealloc(NonNull::new_unchecked(self.hashes.ptr()).cast(), layout);\n             // Remember how everything was allocated out of one buffer\n             // during initialization? We only need one call to free here.\n         }"}, {"sha": "4b885e5e2bb8287070a98cea7e257aaacbce9c8f", "filename": "src/test/run-make-fulldeps/std-core-cycle/bar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Ftest%2Frun-make-fulldeps%2Fstd-core-cycle%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Ftest%2Frun-make-fulldeps%2Fstd-core-cycle%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fstd-core-cycle%2Fbar.rs?ref=f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "patch": "@@ -16,11 +16,11 @@ use std::alloc::*;\n pub struct A;\n \n unsafe impl GlobalAlloc for A {\n-    unsafe fn alloc(&self, _: Layout) -> *mut Opaque {\n+    unsafe fn alloc(&self, _: Layout) -> *mut u8 {\n         loop {}\n     }\n \n-    unsafe fn dealloc(&self, _ptr: *mut Opaque, _: Layout) {\n+    unsafe fn dealloc(&self, _ptr: *mut u8, _: Layout) {\n         loop {}\n     }\n }"}, {"sha": "02e86fa19f8645a86500866088c37f41c10561e4", "filename": "src/test/run-pass/allocator/auxiliary/custom.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs?ref=f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "patch": "@@ -13,18 +13,18 @@\n #![feature(heap_api, allocator_api)]\n #![crate_type = \"rlib\"]\n \n-use std::alloc::{GlobalAlloc, System, Layout, Opaque};\n+use std::alloc::{GlobalAlloc, System, Layout};\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n pub struct A(pub AtomicUsize);\n \n unsafe impl GlobalAlloc for A {\n-    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n         self.0.fetch_add(1, Ordering::SeqCst);\n         System.alloc(layout)\n     }\n \n-    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n         self.0.fetch_add(1, Ordering::SeqCst);\n         System.dealloc(ptr, layout)\n     }"}, {"sha": "5da13bd4cb9ab51dc092cfc91eaaf53b723e9665", "filename": "src/test/run-pass/allocator/custom.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs?ref=f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "patch": "@@ -15,20 +15,20 @@\n \n extern crate helper;\n \n-use std::alloc::{self, Global, Alloc, System, Layout, Opaque};\n+use std::alloc::{self, Global, Alloc, System, Layout};\n use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n \n static HITS: AtomicUsize = ATOMIC_USIZE_INIT;\n \n struct A;\n \n unsafe impl alloc::GlobalAlloc for A {\n-    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n         HITS.fetch_add(1, Ordering::SeqCst);\n         System.alloc(layout)\n     }\n \n-    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n         HITS.fetch_add(1, Ordering::SeqCst);\n         System.dealloc(ptr, layout)\n     }"}, {"sha": "355053858cc1485bedb59364118fecd829fef35f", "filename": "src/test/run-pass/realloc-16687.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6ab74b8e7efed01c1045773b6693f23f6ebd93c/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=f6ab74b8e7efed01c1045773b6693f23f6ebd93c", "patch": "@@ -64,15 +64,15 @@ unsafe fn test_triangle() -> bool {\n             println!(\"deallocate({:?}, {:?}\", ptr, layout);\n         }\n \n-        Global.dealloc(NonNull::new_unchecked(ptr).as_opaque(), layout);\n+        Global.dealloc(NonNull::new_unchecked(ptr).cast(), layout);\n     }\n \n     unsafe fn reallocate(ptr: *mut u8, old: Layout, new: Layout) -> *mut u8 {\n         if PRINT {\n             println!(\"reallocate({:?}, old={:?}, new={:?})\", ptr, old, new);\n         }\n \n-        let ret = Global.realloc(NonNull::new_unchecked(ptr).as_opaque(), old, new.size())\n+        let ret = Global.realloc(NonNull::new_unchecked(ptr).cast(), old, new.size())\n             .unwrap_or_else(|_| oom(Layout::from_size_align_unchecked(new.size(), old.align())));\n \n         if PRINT {"}]}