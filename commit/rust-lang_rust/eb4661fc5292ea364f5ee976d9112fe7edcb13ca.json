{"sha": "eb4661fc5292ea364f5ee976d9112fe7edcb13ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNDY2MWZjNTI5MmVhMzY0ZjVlZTk3NmQ5MTEyZmU3ZWRjYjEzY2E=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-29T20:30:18Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-29T20:30:18Z"}, "message": "Factor vector-allocation code, always allocate space for at least 4 elts\n\n(This prevents the first few reallocs when growing a vector.)", "tree": {"sha": "85fda114a1ea5e1a4344ebcc587db0ae044885f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85fda114a1ea5e1a4344ebcc587db0ae044885f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb4661fc5292ea364f5ee976d9112fe7edcb13ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb4661fc5292ea364f5ee976d9112fe7edcb13ca", "html_url": "https://github.com/rust-lang/rust/commit/eb4661fc5292ea364f5ee976d9112fe7edcb13ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb4661fc5292ea364f5ee976d9112fe7edcb13ca/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5483b910d6644b8243d6db46bbd330890966f074", "url": "https://api.github.com/repos/rust-lang/rust/commits/5483b910d6644b8243d6db46bbd330890966f074", "html_url": "https://github.com/rust-lang/rust/commit/5483b910d6644b8243d6db46bbd330890966f074"}], "stats": {"total": 59, "additions": 35, "deletions": 24}, "files": [{"sha": "01d05f12c0339d4fba576d31068ca9170c00cf9a", "filename": "src/comp/middle/trans_ivec.rs", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/eb4661fc5292ea364f5ee976d9112fe7edcb13ca/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4661fc5292ea364f5ee976d9112fe7edcb13ca/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs?ref=eb4661fc5292ea364f5ee976d9112fe7edcb13ca", "patch": "@@ -31,33 +31,39 @@ fn pointer_add(bcx: &@block_ctxt, ptr: ValueRef, bytes: ValueRef)\n     ret PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n-// FIXME factor out a scaling version wrapping a non-scaling version\n-fn alloc(bcx: &@block_ctxt, vec_ty: &ty::t, vecsz: ValueRef, is_scaled: bool)\n-    -> {bcx: @block_ctxt,\n-        val: ValueRef,\n-        unit_ty: ty::t,\n-        llunitsz: ValueRef,\n-        llunitty: TypeRef} {\n+fn alloc_raw(bcx: &@block_ctxt, fill: ValueRef, alloc: ValueRef) -> result {\n+    let llvecty = T_opaque_ivec();\n+    let vecsize = Add(bcx, alloc, llsize_of(llvecty));\n+    let {bcx, val: vecptr} =\n+        trans_shared_malloc(bcx, T_ptr(llvecty), vecsize);\n+    Store(bcx, fill, InBoundsGEP\n+          (bcx, vecptr, [C_int(0), C_uint(abi::ivec_elt_fill)]));\n+    Store(bcx, alloc, InBoundsGEP\n+          (bcx, vecptr, [C_int(0), C_uint(abi::ivec_elt_alloc)]));\n+    ret {bcx: bcx, val: vecptr};\n+}\n+\n+type alloc_result = {bcx: @block_ctxt,\n+                     val: ValueRef,\n+                     unit_ty: ty::t,\n+                     llunitsz: ValueRef,\n+                     llunitty: TypeRef};\n \n+fn alloc(bcx: &@block_ctxt, vec_ty: &ty::t, elts: uint) -> alloc_result {\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n     let llvecty = T_ivec(llunitty);\n     let {bcx, val: unit_sz} = size_of(bcx, unit_ty);\n \n-    let fill = if is_scaled { vecsz }\n-               else { Mul(bcx, vecsz, unit_sz) };\n-    let vecsize = Add(bcx, fill, llsize_of(llvecty));\n-    let {bcx, val: vecptr} =\n-        trans_shared_malloc(bcx, T_ptr(llvecty), vecsize);\n-    add_clean_temp(bcx, vecptr, vec_ty);\n-\n-    Store(bcx, fill, InBoundsGEP\n-          (bcx, vecptr, [C_int(0), C_uint(abi::ivec_elt_fill)]));\n-    Store(bcx, fill, InBoundsGEP\n-          (bcx, vecptr, [C_int(0), C_uint(abi::ivec_elt_alloc)]));\n-    ret {bcx: bcx, val: vecptr,\n-         unit_ty: unit_ty, llunitsz: unit_sz, llunitty: llunitty};\n+    let fill = Mul(bcx, C_uint(elts), unit_sz);\n+    let alloc = if elts < 4u { Mul(bcx, C_int(4), unit_sz) } else { fill };\n+    let {bcx, val: vptr} = alloc_raw(bcx, fill, alloc);\n+    let vptr = PointerCast(bcx, vptr, T_ptr(llvecty));\n+    add_clean_temp(bcx, vptr, vec_ty);\n+    ret {bcx: bcx, val: vptr, unit_ty: unit_ty,\n+         llunitsz: unit_sz, llunitty: llunitty};\n }\n+\n fn duplicate(bcx: &@block_ctxt, vptrptr: ValueRef) -> @block_ctxt {\n     let vptr = Load(bcx, vptrptr);\n     let fill = get_fill(bcx, vptr);\n@@ -89,7 +95,7 @@ fn trans_ivec(bcx: &@block_ctxt, args: &[@ast::expr],\n               id: ast::node_id) -> result {\n     let vec_ty = node_id_type(bcx_ccx(bcx), id);\n     let {bcx, val: vptr, llunitsz, unit_ty, llunitty} =\n-        alloc(bcx, vec_ty, C_uint(vec::len(args)), false);\n+        alloc(bcx, vec_ty, vec::len(args));\n \n     // Store the individual elements.\n     let dataptr = get_dataptr(bcx, vptr, llunitty);\n@@ -110,7 +116,7 @@ fn trans_ivec(bcx: &@block_ctxt, args: &[@ast::expr],\n fn trans_istr(bcx: &@block_ctxt, s: istr) -> result {\n     let veclen = std::istr::byte_len(s) + 1u; // +1 for \\0\n     let {bcx, val: sptr, _} =\n-        alloc(bcx, ty::mk_istr(bcx_tcx(bcx)), C_uint(veclen), false);\n+        alloc(bcx, ty::mk_istr(bcx_tcx(bcx)), veclen);\n \n     let llcstr = C_cstr(bcx_ccx(bcx), s);\n     let bcx = call_memmove(bcx, get_dataptr(bcx, sptr, T_i8()),\n@@ -194,12 +200,17 @@ fn trans_add(bcx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n       ty::ty_istr. { true }\n       ty::ty_vec(_) { false }\n     };\n+    let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n+    let llunitty = type_of_or_i8(bcx, unit_ty);\n+    let {bcx, val: llunitsz} = size_of(bcx, unit_ty);\n+\n     let lhs_fill = get_fill(bcx, lhs);\n     if strings { lhs_fill = Sub(bcx, lhs_fill, C_int(1)); }\n     let rhs_fill = get_fill(bcx, rhs);\n     let new_fill = Add(bcx, lhs_fill, rhs_fill);\n-    let {bcx, val: new_vec, unit_ty, llunitsz, llunitty} =\n-        alloc(bcx, vec_ty, new_fill, true);\n+    let {bcx, val: new_vec} = alloc_raw(bcx, new_fill, new_fill);\n+    let new_vec = PointerCast(bcx, new_vec, T_ptr(T_ivec(llunitty)));\n+    add_clean_temp(bcx, new_vec, vec_ty);\n \n     let write_ptr_ptr = do_spill(bcx, get_dataptr(bcx, new_vec, llunitty));\n     let copy_fn = bind fn(bcx: &@block_ctxt, addr: ValueRef, _ty: ty::t,"}]}