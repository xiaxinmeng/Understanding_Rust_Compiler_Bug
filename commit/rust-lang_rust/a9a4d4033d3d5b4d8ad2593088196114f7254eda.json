{"sha": "a9a4d4033d3d5b4d8ad2593088196114f7254eda", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5YTRkNDAzM2QzZDViNGQ4YWQyNTkzMDg4MTk2MTE0ZjcyNTRlZGE=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-10-15T00:52:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-15T00:52:33Z"}, "message": "Rollup merge of #65260 - nnethercote:optimize-LexicalResolve-expansion, r=nikomatsakis\n\nOptimize `LexicalResolve::expansion`.\n\nA win for `unicode_normalization`.\n\nr? @nikomatsakis", "tree": {"sha": "16b7e9bb677e1d5700d7b0480c1894ea2487fea6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16b7e9bb677e1d5700d7b0480c1894ea2487fea6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9a4d4033d3d5b4d8ad2593088196114f7254eda", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdpRhSCRBK7hj4Ov3rIwAAdHIIADV5uRvRpUb/ObK4wfASDNqH\nxZOxBVkbIoqrKR/tSiBFjrQii3DURgtCEgiTVlFoUAegO8WJwlm3Jwiixs8QYCYu\nUMyaSORsPVIXtgqtGiRdT5E57bzhuRVwvUZjWzLX4jdbRrZw76+anLKiTiWB6Oq1\ng5zivhlpZdLWI2OfhYyQGxRKRS0HuUciN7xCMPjxeZO9jZpdmT+MCc7p1r0VFWw7\nZj/YOSzk+uLOc0TV4BqnqEheYduqPwM1PwbMVbWf5KfGyz7KF2etUQBeMO6HZJtl\nyD8mMySBmtbvd00R1hD8pOeJS6EOJjAMJBnW9H932NsDoH8i/hFxCrw5xG4S+jk=\n=fgA6\n-----END PGP SIGNATURE-----\n", "payload": "tree 16b7e9bb677e1d5700d7b0480c1894ea2487fea6\nparent d2f87e384fd77aa6f3d5769b3e852e7385fbe081\nparent 8cd25e72459a6ab25407e1fa30c4d6d42422ff3e\nauthor Tyler Mandry <tmandry@gmail.com> 1571100753 -0700\ncommitter GitHub <noreply@github.com> 1571100753 -0700\n\nRollup merge of #65260 - nnethercote:optimize-LexicalResolve-expansion, r=nikomatsakis\n\nOptimize `LexicalResolve::expansion`.\n\nA win for `unicode_normalization`.\n\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9a4d4033d3d5b4d8ad2593088196114f7254eda", "html_url": "https://github.com/rust-lang/rust/commit/a9a4d4033d3d5b4d8ad2593088196114f7254eda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9a4d4033d3d5b4d8ad2593088196114f7254eda/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2f87e384fd77aa6f3d5769b3e852e7385fbe081", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2f87e384fd77aa6f3d5769b3e852e7385fbe081", "html_url": "https://github.com/rust-lang/rust/commit/d2f87e384fd77aa6f3d5769b3e852e7385fbe081"}, {"sha": "8cd25e72459a6ab25407e1fa30c4d6d42422ff3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cd25e72459a6ab25407e1fa30c4d6d42422ff3e", "html_url": "https://github.com/rust-lang/rust/commit/8cd25e72459a6ab25407e1fa30c4d6d42422ff3e"}], "stats": {"total": 26, "additions": 16, "deletions": 10}, "files": [{"sha": "6f55ade1e8612b32fb181737d5ae313462b1629a", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a9a4d4033d3d5b4d8ad2593088196114f7254eda/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9a4d4033d3d5b4d8ad2593088196114f7254eda/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=a9a4d4033d3d5b4d8ad2593088196114f7254eda", "patch": "@@ -304,7 +304,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     }\n \n     fn expansion(&self, var_values: &mut LexicalRegionResolutions<'tcx>) {\n-        self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n+        self.iterate_until_fixed_point(|constraint| {\n             debug!(\"expansion: constraint={:?}\", constraint);\n             let (a_region, b_vid, b_data, retain) = match *constraint {\n                 Constraint::RegSubVar(a_region, b_vid) => {\n@@ -360,13 +360,21 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         match *b_data {\n             VarValue::Value(cur_region) => {\n                 // Identical scopes can show up quite often, if the fixed point\n-                // iteration converges slowly, skip them\n+                // iteration converges slowly. Skip them. This is purely an\n+                // optimization.\n                 if let (ReScope(a_scope), ReScope(cur_scope)) = (a_region, cur_region) {\n                     if a_scope == cur_scope {\n                         return false;\n                     }\n                 }\n \n+                // This is a specialized version of the `lub_concrete_regions`\n+                // check below for a common case, here purely as an\n+                // optimization.\n+                if let ReEmpty = a_region {\n+                    return false;\n+                }\n+\n                 let mut lub = self.lub_concrete_regions(a_region, cur_region);\n                 if lub == cur_region {\n                     return false;\n@@ -407,8 +415,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n     /// Returns the smallest region `c` such that `a <= c` and `b <= c`.\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n-        let tcx = self.tcx();\n-\n         match (a, b) {\n             (&ty::ReClosureBound(..), _)\n             | (_, &ty::ReClosureBound(..))\n@@ -468,15 +474,15 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n                 // otherwise, we don't know what the free region is,\n                 // so we must conservatively say the LUB is static:\n-                tcx.lifetimes.re_static\n+                self.tcx().lifetimes.re_static\n             }\n \n             (&ReScope(a_id), &ReScope(b_id)) => {\n                 // The region corresponding to an outer block is a\n                 // subtype of the region corresponding to an inner\n                 // block.\n                 let lub = self.region_rels.region_scope_tree.nearest_common_ancestor(a_id, b_id);\n-                tcx.mk_region(ReScope(lub))\n+                self.tcx().mk_region(ReScope(lub))\n             }\n \n             (&ReEarlyBound(_), &ReEarlyBound(_))\n@@ -490,7 +496,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 if a == b {\n                     a\n                 } else {\n-                    tcx.lifetimes.re_static\n+                    self.tcx().lifetimes.re_static\n                 }\n             }\n         }\n@@ -860,7 +866,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n-    fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F)\n+    fn iterate_until_fixed_point<F>(&self, mut body: F)\n     where\n         F: FnMut(&Constraint<'tcx>) -> (bool, bool),\n     {\n@@ -870,7 +876,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         while changed {\n             changed = false;\n             iteration += 1;\n-            debug!(\"---- {} Iteration {}{}\", \"#\", tag, iteration);\n+            debug!(\"---- Expansion iteration {}\", iteration);\n             constraints.retain(|constraint| {\n                 let (edge_changed, retain) = body(constraint);\n                 if edge_changed {\n@@ -880,7 +886,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 retain\n             });\n         }\n-        debug!(\"---- {} Complete after {} iteration(s)\", tag, iteration);\n+        debug!(\"---- Expansion complete after {} iteration(s)\", iteration);\n     }\n \n     fn bound_is_met("}]}