{"sha": "d9523622ff68e9a91d9cc6b225dc479d7cc8f0c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5NTIzNjIyZmY2OGU5YTkxZDljYzZiMjI1ZGM0NzlkN2NjOGYwYzc=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-11-19T03:54:31Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-12-06T23:30:23Z"}, "message": "Move handling UpvarRef to PlaceBuilder\n\n- This allows us to delay figuring out the index of a capture\n  in the closure structure when all projections to atleast form\n  a capture have been applied to the builder\n\nCo-authored-by: Roxane Fruytier <roxane.fruytier@hotmail.com>", "tree": {"sha": "784c6b29092ca702c483bbf87e7fb6c91ea2d1c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/784c6b29092ca702c483bbf87e7fb6c91ea2d1c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9523622ff68e9a91d9cc6b225dc479d7cc8f0c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9523622ff68e9a91d9cc6b225dc479d7cc8f0c7", "html_url": "https://github.com/rust-lang/rust/commit/d9523622ff68e9a91d9cc6b225dc479d7cc8f0c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9523622ff68e9a91d9cc6b225dc479d7cc8f0c7/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e5cca79fcaaa80fbaaa23ba9f9c806f2ae8f41e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e5cca79fcaaa80fbaaa23ba9f9c806f2ae8f41e", "html_url": "https://github.com/rust-lang/rust/commit/6e5cca79fcaaa80fbaaa23ba9f9c806f2ae8f41e"}], "stats": {"total": 285, "additions": 207, "deletions": 78}, "files": [{"sha": "2ab733fabb8cb827bc8f75d3582f0cfb51893028", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 207, "deletions": 78, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/d9523622ff68e9a91d9cc6b225dc479d7cc8f0c7/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9523622ff68e9a91d9cc6b225dc479d7cc8f0c7/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=d9523622ff68e9a91d9cc6b225dc479d7cc8f0c7", "patch": "@@ -4,6 +4,8 @@ use crate::build::expr::category::Category;\n use crate::build::ForGuard::{OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::thir::*;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::HirId;\n use rustc_middle::middle::region;\n use rustc_middle::mir::AssertKind::BoundsCheck;\n use rustc_middle::mir::*;\n@@ -12,6 +14,50 @@ use rustc_span::Span;\n \n use rustc_index::vec::Idx;\n \n+/// The \"outermost\" place that holds this value.\n+#[derive(Copy, Clone)]\n+pub enum PlaceBase {\n+    /// Denotes the start of a `Place`.\n+    Local(Local),\n+\n+    /// When building place for an expression within a closure, the place might start off a\n+    /// captured path. When `capture_disjoint_fields` is enabled, we might not know the capture\n+    /// index (within the desugared closure) of the captured path until most of the projections\n+    /// are applied. We use `PlaceBase::Upvar` to keep track of the root variable off of which the\n+    /// captured path starts, the closure the capture belongs to and the trait the closure\n+    /// implements.\n+    ///\n+    /// Once we have figured out the capture index, we can convert the place builder to start from\n+    /// `PlaceBase::Local`.\n+    ///\n+    /// Consider the following example\n+    /// ```rust\n+    /// let t = (10, (10, (10, 10)));\n+    ///\n+    /// let c = || {\n+    ///     println!(\"{}\", t.0.0.0);\n+    /// };\n+    /// ```\n+    /// Here the THIR expression for `t.0.0.0` will be something like\n+    ///\n+    /// ```\n+    /// * Field(0)\n+    ///     * Field(0)\n+    ///         * Field(0)\n+    ///             * UpvarRef(t)\n+    /// ```\n+    ///\n+    /// When `capture_disjoint_fields` is enabled, `t.0.0.0` is captured and we won't be able to\n+    /// figure out that it is captured until all the `Field` projections are applied.\n+    Upvar {\n+        /// HirId of the upvar\n+        var_hir_id: HirId,\n+        /// DefId of the closure\n+        closure_def_id: DefId,\n+        /// The trait closure implements, `Fn`, `FnMut`, `FnOnce`\n+        closure_kind: ty::ClosureKind },\n+}\n+\n /// `PlaceBuilder` is used to create places during MIR construction. It allows you to \"build up\" a\n /// place by pushing more and more projections onto the end, and then convert the final set into a\n /// place using the `into_place` method.\n@@ -20,13 +66,131 @@ use rustc_index::vec::Idx;\n /// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n #[derive(Clone)]\n struct PlaceBuilder<'tcx> {\n-    local: Local,\n+    base: PlaceBase,\n     projection: Vec<PlaceElem<'tcx>>,\n }\n \n+fn capture_matching_projections<'a, 'tcx>(\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n+    var_hir_id: HirId,\n+    closure_def_id: DefId,\n+    _projections: &Vec<PlaceElem<'tcx>>,\n+) -> Option<(usize, ty::UpvarCapture<'tcx>)> {\n+    typeck_results\n+    .closure_captures\n+    .get(&closure_def_id)\n+    .and_then(|captures| captures.get_full(&var_hir_id))\n+    .and_then(|(capture_index, _, _)|{\n+        let upvar_id = ty::UpvarId::new(var_hir_id, closure_def_id.expect_local());\n+        let capture_kind = typeck_results.upvar_capture(upvar_id);\n+        Some((capture_index, capture_kind))\n+    })\n+}\n+\n+/// Takes a PlaceBuilder and resolves the upvar (if any) within it,\n+/// so that the PlaceBuilder now starts from PlaceBase::Local.\n+///\n+/// Returns a Result with the error being the HirId of the\n+/// Upvar that was not found.\n+fn to_upvars_resolved_place_builder<'a, 'tcx>(\n+    from_builder: PlaceBuilder<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n+) -> Result<PlaceBuilder<'tcx>, HirId> {\n+    match from_builder.base {\n+        PlaceBase::Local(_) => Ok(from_builder),\n+        PlaceBase::Upvar { var_hir_id, closure_def_id, closure_kind } => {\n+            // Captures are represented using fields inside a structure.\n+            // This represents accessing self in the closure structure\n+            let mut upvar_resolved_place_builder = PlaceBuilder::from(Local::new(1));\n+            match closure_kind {\n+                ty::ClosureKind::Fn | ty::ClosureKind::FnMut => {\n+                    upvar_resolved_place_builder = upvar_resolved_place_builder.deref();\n+                }\n+                ty::ClosureKind::FnOnce => {}\n+            }\n+\n+            let (capture_index, capture_kind) =\n+                if let Some(capture_details) = capture_matching_projections(\n+                    typeck_results,\n+                    var_hir_id,\n+                    closure_def_id,\n+                    &from_builder.projection,\n+                ) {\n+                    capture_details\n+                } else {\n+                    if !tcx.features().capture_disjoint_fields {\n+                        bug!(\n+                            \"No associated capture found for {:?}[{:#?}] even though \\\n+                            capture_disjoint_fields isn't enabled\",\n+                            var_hir_id,\n+                            from_builder.projection\n+                        )\n+                    } else {\n+                        // FIXME(project-rfc-2229#24): Handle this case properly\n+                        debug!(\n+                            \"No associated capture found for {:?}[{:#?}]\",\n+                            var_hir_id,\n+                            from_builder.projection,\n+                        );\n+                    }\n+                    return Err(var_hir_id);\n+                };\n+\n+            let closure_ty =\n+                typeck_results.node_type(tcx.hir().local_def_id_to_hir_id(closure_def_id.expect_local()));\n+\n+            let substs = match closure_ty.kind() {\n+                ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),\n+                ty::Generator(_, substs, _) => ty::UpvarSubsts::Generator(substs),\n+                _ => bug!(\"Lowering capture for non-closure type {:?}\", closure_ty),\n+            };\n+\n+            // Access the capture by accessing the field within the Closure struct.\n+            //\n+            // We must have inferred the capture types since we are building MIR, therefore\n+            // it's safe to call `upvar_tys` and we can unwrap here because\n+            // we know that the capture exists and is the `capture_index`-th capture.\n+            let var_ty = substs.upvar_tys().nth(capture_index).unwrap();\n+\n+            upvar_resolved_place_builder = upvar_resolved_place_builder.field(Field::new(capture_index), var_ty);\n+\n+            // If the variable is captured via ByRef(Immutable/Mutable) Borrow,\n+            // we need to deref it\n+            upvar_resolved_place_builder = match capture_kind {\n+                ty::UpvarCapture::ByRef(_) => upvar_resolved_place_builder.deref(),\n+                ty::UpvarCapture::ByValue(_) => upvar_resolved_place_builder,\n+            };\n+\n+            let next_projection = 0;\n+            let mut curr_projections = from_builder.projection;\n+            upvar_resolved_place_builder.projection.extend(\n+                curr_projections.drain(next_projection..));\n+\n+            Ok(upvar_resolved_place_builder)\n+        }\n+    }\n+}\n+\n impl<'tcx> PlaceBuilder<'tcx> {\n-    fn into_place(self, tcx: TyCtxt<'tcx>) -> Place<'tcx> {\n-        Place { local: self.local, projection: tcx.intern_place_elems(&self.projection) }\n+    fn into_place<'a>(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        typeck_results: &'a ty::TypeckResults<'tcx>,\n+    ) -> Place<'tcx> {\n+        if let PlaceBase::Local(local) = self.base {\n+            Place { local, projection: tcx.intern_place_elems(&self.projection) }\n+        } else {\n+            self.expect_upvars_resolved(tcx, typeck_results).into_place(tcx, typeck_results)\n+        }\n+    }\n+\n+    fn expect_upvars_resolved<'a>(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        typeck_results: &'a ty::TypeckResults<'tcx>,\n+    ) -> PlaceBuilder<'tcx> {\n+        to_upvars_resolved_place_builder(self, tcx, typeck_results).unwrap()\n     }\n \n     fn field(self, f: Field, ty: Ty<'tcx>) -> Self {\n@@ -49,7 +213,13 @@ impl<'tcx> PlaceBuilder<'tcx> {\n \n impl<'tcx> From<Local> for PlaceBuilder<'tcx> {\n     fn from(local: Local) -> Self {\n-        Self { local, projection: Vec::new() }\n+        Self { base: PlaceBase::Local(local), projection: Vec::new() }\n+    }\n+}\n+\n+impl<'tcx> From<PlaceBase> for PlaceBuilder<'tcx> {\n+    fn from(base: PlaceBase) -> Self {\n+        Self { base, projection: Vec::new() }\n     }\n }\n \n@@ -71,7 +241,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n         let place_builder = unpack!(block = self.as_place_builder(block, expr));\n-        block.and(place_builder.into_place(self.hir.tcx()))\n+        block.and(place_builder.into_place(self.hir.tcx(), self.hir.typeck_results()))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -98,7 +268,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n         let place_builder = unpack!(block = self.as_read_only_place_builder(block, expr));\n-        block.and(place_builder.into_place(self.hir.tcx()))\n+        block.and(place_builder.into_place(self.hir.tcx(), self.hir.typeck_results()))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -161,27 +331,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 source_info,\n             ),\n             ExprKind::UpvarRef { closure_def_id, var_hir_id } => {\n-                let capture = this\n-                    .hir\n-                    .typeck_results\n-                    .closure_captures\n-                    .get(&closure_def_id)\n-                    .and_then(|captures| captures.get_full(&var_hir_id));\n-\n-                if capture.is_none() {\n-                    if !this.hir.tcx().features().capture_disjoint_fields {\n-                        bug!(\n-                            \"No associated capture found for {:?} even though \\\n-                            capture_disjoint_fields isn't enabled\",\n-                            expr.kind\n-                        )\n-                    }\n-                    // FIXME(project-rfc-2229#24): Handle this case properly\n-                }\n-\n-                // Unwrap until the FIXME has been resolved\n-                let (capture_index, _, upvar_id) = capture.unwrap();\n-                this.lower_closure_capture(block, capture_index, *upvar_id)\n+                let upvar_id = ty::UpvarId::new(var_hir_id, closure_def_id.expect_local());\n+                this.lower_captured_upvar(block, upvar_id)\n             }\n \n             ExprKind::VarRef { id } => {\n@@ -208,7 +359,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             inferred_ty: expr.ty,\n                         });\n \n-                    let place = place_builder.clone().into_place(this.hir.tcx());\n+                    let place =\n+                        place_builder.clone().into_place(this.hir.tcx(), this.hir.typeck_results());\n                     this.cfg.push(\n                         block,\n                         Statement {\n@@ -293,59 +445,31 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    /// Lower a closure/generator capture by representing it as a field\n-    /// access within the desugared closure/generator.\n-    ///\n-    /// `capture_index` is the index of the capture within the desugared\n-    /// closure/generator.\n-    fn lower_closure_capture(\n+    /// Lower a captured upvar. Note we might not know the actual capture index,\n+    /// so we create a place starting from `PlaceBase::Upvar`, which will be resolved\n+    /// once all projections that allow us to indentify a capture have been applied.\n+    fn lower_captured_upvar(\n         &mut self,\n         block: BasicBlock,\n-        capture_index: usize,\n         upvar_id: ty::UpvarId,\n-    )  -> BlockAnd<PlaceBuilder<'tcx>> {\n+    ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         let closure_ty = self\n             .hir\n             .typeck_results()\n             .node_type(self.hir.tcx().hir().local_def_id_to_hir_id(upvar_id.closure_expr_id));\n \n-        // Captures are represented using fields inside a structure.\n-        // This represents accessing self in the closure structure\n-        let mut place_builder = PlaceBuilder::from(Local::new(1));\n-\n-        // In case of Fn/FnMut closures we must deref to access the fields\n-        // Generators are considered FnOnce, so we ignore this step for them.\n-        if let ty::Closure(_, closure_substs) = closure_ty.kind() {\n-            match self.hir.infcx().closure_kind(closure_substs).unwrap() {\n-                ty::ClosureKind::Fn | ty::ClosureKind::FnMut => {\n-                    place_builder = place_builder.deref();\n-                }\n-                ty::ClosureKind::FnOnce => {}\n-            }\n-        }\n-\n-        let substs = match closure_ty.kind() {\n-            ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),\n-            ty::Generator(_, substs, _) => ty::UpvarSubsts::Generator(substs),\n-            _ => bug!(\"Lowering capture for non-closure type {:?}\", closure_ty)\n+        let closure_kind = if let ty::Closure(_, closure_substs) = closure_ty.kind() {\n+            self.hir.infcx().closure_kind(closure_substs).unwrap()\n+        } else {\n+            // Generators are considered FnOnce.\n+            ty::ClosureKind::FnOnce\n         };\n \n-        // Access the capture by accessing the field within the Closure struct.\n-        //\n-        // We must have inferred the capture types since we are building MIR, therefore\n-        // it's safe to call `upvar_tys` and we can unwrap here because\n-        // we know that the capture exists and is the `capture_index`-th capture.\n-        let var_ty = substs.upvar_tys().nth(capture_index).unwrap();\n-        place_builder = place_builder.field(Field::new(capture_index), var_ty);\n-\n-        // If the variable is captured via ByRef(Immutable/Mutable) Borrow,\n-        // we need to deref it\n-        match self.hir.typeck_results.upvar_capture(upvar_id) {\n-            ty::UpvarCapture::ByRef(_) => {\n-                block.and(place_builder.deref())\n-            }\n-            ty::UpvarCapture::ByValue(_) => block.and(place_builder),\n-        }\n+        block.and(PlaceBuilder::from(PlaceBase::Upvar {\n+            var_hir_id: upvar_id.var_path.hir_id,\n+            closure_def_id: upvar_id.closure_expr_id.to_def_id(),\n+            closure_kind,\n+        }))\n     }\n \n     /// Lower an index expression\n@@ -373,7 +497,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let is_outermost_index = fake_borrow_temps.is_none();\n         let fake_borrow_temps = fake_borrow_temps.unwrap_or(base_fake_borrow_temps);\n \n-        let base_place =\n+        let mut base_place =\n             unpack!(block = self.expr_as_place(block, lhs, mutability, Some(fake_borrow_temps),));\n \n         // Making this a *fresh* temporary means we do not have to worry about\n@@ -383,7 +507,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         block = self.bounds_check(\n             block,\n-            base_place.clone().into_place(self.hir.tcx()),\n+            base_place.clone().into_place(self.hir.tcx(), self.hir.typeck_results()),\n             idx,\n             expr_span,\n             source_info,\n@@ -392,6 +516,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         if is_outermost_index {\n             self.read_fake_borrows(block, fake_borrow_temps, source_info)\n         } else {\n+            base_place = base_place.expect_upvars_resolved(self.hir.tcx(), self.hir.typeck_results());\n             self.add_fake_borrows_of_base(\n                 &base_place,\n                 block,\n@@ -441,8 +566,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         source_info: SourceInfo,\n     ) {\n         let tcx = self.hir.tcx();\n-        let place_ty =\n-            Place::ty_from(base_place.local, &base_place.projection, &self.local_decls, tcx);\n+        let local = match base_place.base {\n+            PlaceBase::Local(local) => local,\n+            PlaceBase::Upvar { .. } => bug!(\"Expected PlacseBase::Local found Upvar\")\n+        };\n+\n+        let place_ty = Place::ty_from(local, &base_place.projection, &self.local_decls, tcx);\n         if let ty::Slice(_) = place_ty.ty.kind() {\n             // We need to create fake borrows to ensure that the bounds\n             // check that we just did stays valid. Since we can't assign to\n@@ -452,7 +581,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 match elem {\n                     ProjectionElem::Deref => {\n                         let fake_borrow_deref_ty = Place::ty_from(\n-                            base_place.local,\n+                            local,\n                             &base_place.projection[..idx],\n                             &self.local_decls,\n                             tcx,\n@@ -470,14 +599,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             Rvalue::Ref(\n                                 tcx.lifetimes.re_erased,\n                                 BorrowKind::Shallow,\n-                                Place { local: base_place.local, projection },\n+                                Place { local, projection },\n                             ),\n                         );\n                         fake_borrow_temps.push(fake_borrow_temp);\n                     }\n                     ProjectionElem::Index(_) => {\n                         let index_ty = Place::ty_from(\n-                            base_place.local,\n+                            local,\n                             &base_place.projection[..idx],\n                             &self.local_decls,\n                             tcx,"}]}