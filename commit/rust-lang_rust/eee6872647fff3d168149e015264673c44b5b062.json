{"sha": "eee6872647fff3d168149e015264673c44b5b062", "node_id": "C_kwDOAAsO6NoAKGVlZTY4NzI2NDdmZmYzZDE2ODE0OWUwMTUyNjQ2NzNjNDRiNWIwNjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-26T13:38:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-26T13:38:39Z"}, "message": "Auto merge of #14901 - Veykril:errors, r=Veykril\n\ninternal: Move flycheck and config errors to status notification\n\ncc https://github.com/rust-lang/rust-analyzer/issues/14193", "tree": {"sha": "734a24733bd8490d8e176cf699740e584d2f23aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/734a24733bd8490d8e176cf699740e584d2f23aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eee6872647fff3d168149e015264673c44b5b062", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eee6872647fff3d168149e015264673c44b5b062", "html_url": "https://github.com/rust-lang/rust/commit/eee6872647fff3d168149e015264673c44b5b062", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eee6872647fff3d168149e015264673c44b5b062/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9638466567e66f6024ffa922bf48b8aba6a33b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9638466567e66f6024ffa922bf48b8aba6a33b4", "html_url": "https://github.com/rust-lang/rust/commit/e9638466567e66f6024ffa922bf48b8aba6a33b4"}, {"sha": "f876adf617622c36586a575960627a6f6cde0335", "url": "https://api.github.com/repos/rust-lang/rust/commits/f876adf617622c36586a575960627a6f6cde0335", "html_url": "https://github.com/rust-lang/rust/commit/f876adf617622c36586a575960627a6f6cde0335"}], "stats": {"total": 225, "additions": 125, "deletions": 100}, "files": [{"sha": "b1d019cb113c7a37c249dd46c845749ba905bf0a", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eee6872647fff3d168149e015264673c44b5b062/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee6872647fff3d168149e015264673c44b5b062/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=eee6872647fff3d168149e015264673c44b5b062", "patch": "@@ -720,11 +720,11 @@ pub struct ClientCommandsConfig {\n }\n \n #[derive(Debug)]\n-pub struct ConfigUpdateError {\n+pub struct ConfigError {\n     errors: Vec<(String, serde_json::Error)>,\n }\n \n-impl fmt::Display for ConfigUpdateError {\n+impl fmt::Display for ConfigError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let errors = self.errors.iter().format_with(\"\\n\", |(key, e), f| {\n             f(key)?;\n@@ -733,8 +733,7 @@ impl fmt::Display for ConfigUpdateError {\n         });\n         write!(\n             f,\n-            \"rust-analyzer found {} invalid config value{}:\\n{}\",\n-            self.errors.len(),\n+            \"invalid config value{}:\\n{}\",\n             if self.errors.len() == 1 { \"\" } else { \"s\" },\n             errors\n         )\n@@ -777,7 +776,7 @@ impl Config {\n         self.workspace_roots.extend(paths);\n     }\n \n-    pub fn update(&mut self, mut json: serde_json::Value) -> Result<(), ConfigUpdateError> {\n+    pub fn update(&mut self, mut json: serde_json::Value) -> Result<(), ConfigError> {\n         tracing::info!(\"updating config from JSON: {:#}\", json);\n         if json.is_null() || json.as_object().map_or(false, |it| it.is_empty()) {\n             return Ok(());\n@@ -824,7 +823,7 @@ impl Config {\n         if errors.is_empty() {\n             Ok(())\n         } else {\n-            Err(ConfigUpdateError { errors })\n+            Err(ConfigError { errors })\n         }\n     }\n "}, {"sha": "9f4dc4440202d191f428109aef60a3ccc46398f8", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eee6872647fff3d168149e015264673c44b5b062/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee6872647fff3d168149e015264673c44b5b062/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=eee6872647fff3d168149e015264673c44b5b062", "patch": "@@ -19,7 +19,7 @@ use triomphe::Arc;\n use vfs::AnchoredPathBuf;\n \n use crate::{\n-    config::Config,\n+    config::{Config, ConfigError},\n     diagnostics::{CheckFixes, DiagnosticCollection},\n     from_proto,\n     line_index::{LineEndings, LineIndex},\n@@ -52,24 +52,33 @@ pub(crate) type ReqQueue = lsp_server::ReqQueue<(String, Instant), ReqHandler>;\n pub(crate) struct GlobalState {\n     sender: Sender<lsp_server::Message>,\n     req_queue: ReqQueue,\n+\n     pub(crate) task_pool: Handle<TaskPool<Task>, Receiver<Task>>,\n-    pub(crate) loader: Handle<Box<dyn vfs::loader::Handle>, Receiver<vfs::loader::Message>>,\n+\n     pub(crate) config: Arc<Config>,\n+    pub(crate) config_errors: Option<ConfigError>,\n     pub(crate) analysis_host: AnalysisHost,\n     pub(crate) diagnostics: DiagnosticCollection,\n     pub(crate) mem_docs: MemDocs,\n+    pub(crate) source_root_config: SourceRootConfig,\n     pub(crate) semantic_tokens_cache: Arc<Mutex<FxHashMap<Url, SemanticTokens>>>,\n+\n+    // status\n     pub(crate) shutdown_requested: bool,\n     pub(crate) last_reported_status: Option<lsp_ext::ServerStatusParams>,\n-    pub(crate) source_root_config: SourceRootConfig,\n \n+    // proc macros\n     pub(crate) proc_macro_changed: bool,\n     pub(crate) proc_macro_clients: Arc<[anyhow::Result<ProcMacroServer>]>,\n \n+    // Flycheck\n     pub(crate) flycheck: Arc<[FlycheckHandle]>,\n     pub(crate) flycheck_sender: Sender<flycheck::Message>,\n     pub(crate) flycheck_receiver: Receiver<flycheck::Message>,\n+    pub(crate) last_flycheck_error: Option<String>,\n \n+    // VFS\n+    pub(crate) loader: Handle<Box<dyn vfs::loader::Handle>, Receiver<vfs::loader::Message>>,\n     pub(crate) vfs: Arc<RwLock<(vfs::Vfs, IntMap<FileId, LineEndings>)>>,\n     pub(crate) vfs_config_version: u32,\n     pub(crate) vfs_progress_config_version: u32,\n@@ -102,11 +111,12 @@ pub(crate) struct GlobalState {\n     /// the user just adds comments or whitespace to Cargo.toml, we do not want\n     /// to invalidate any salsa caches.\n     pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n+\n+    // op queues\n     pub(crate) fetch_workspaces_queue: OpQueue<(), Option<Vec<anyhow::Result<ProjectWorkspace>>>>,\n     pub(crate) fetch_build_data_queue:\n         OpQueue<(), (Arc<Vec<ProjectWorkspace>>, Vec<anyhow::Result<WorkspaceBuildScripts>>)>,\n     pub(crate) fetch_proc_macros_queue: OpQueue<Vec<ProcMacroPaths>, bool>,\n-\n     pub(crate) prime_caches_queue: OpQueue,\n }\n \n@@ -160,6 +170,7 @@ impl GlobalState {\n             shutdown_requested: false,\n             last_reported_status: None,\n             source_root_config: SourceRootConfig::default(),\n+            config_errors: Default::default(),\n \n             proc_macro_changed: false,\n             // FIXME: use `Arc::from_iter` when it becomes available\n@@ -169,6 +180,7 @@ impl GlobalState {\n             flycheck: Arc::from(Vec::new()),\n             flycheck_sender,\n             flycheck_receiver,\n+            last_flycheck_error: None,\n \n             vfs: Arc::new(RwLock::new((vfs::Vfs::default(), IntMap::default()))),\n             vfs_config_version: 0,"}, {"sha": "7074ef018a13cf72a2aa9030bdb4d9f0469635aa", "filename": "crates/rust-analyzer/src/handlers/notification.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eee6872647fff3d168149e015264673c44b5b062/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Fnotification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee6872647fff3d168149e015264673c44b5b062/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Fnotification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Fnotification.rs?ref=eee6872647fff3d168149e015264673c44b5b062", "patch": "@@ -169,13 +169,7 @@ pub(crate) fn handle_did_change_configuration(\n                         // Note that json can be null according to the spec if the client can't\n                         // provide a configuration. This is handled in Config::update below.\n                         let mut config = Config::clone(&*this.config);\n-                        if let Err(error) = config.update(json.take()) {\n-                            this.show_message(\n-                                lsp_types::MessageType::WARNING,\n-                                error.to_string(),\n-                                false,\n-                            );\n-                        }\n+                        this.config_errors = config.update(json.take()).err();\n                         this.update_configuration(config);\n                     }\n                 }"}, {"sha": "16d683957f04131b7fbc820b70f9dba0534cccba", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 93, "deletions": 83, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/eee6872647fff3d168149e015264673c44b5b062/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee6872647fff3d168149e015264673c44b5b062/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=eee6872647fff3d168149e015264673c44b5b062", "patch": "@@ -77,7 +77,7 @@ pub(crate) enum PrimeCachesProgress {\n \n impl fmt::Debug for Event {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let debug_verbose_not = |not: &Notification, f: &mut fmt::Formatter<'_>| {\n+        let debug_non_verbose = |not: &Notification, f: &mut fmt::Formatter<'_>| {\n             f.debug_struct(\"Notification\").field(\"method\", &not.method).finish()\n         };\n \n@@ -86,7 +86,7 @@ impl fmt::Debug for Event {\n                 if notification_is::<lsp_types::notification::DidOpenTextDocument>(not)\n                     || notification_is::<lsp_types::notification::DidChangeTextDocument>(not)\n                 {\n-                    return debug_verbose_not(not, f);\n+                    return debug_non_verbose(not, f);\n                 }\n             }\n             Event::Task(Task::Response(resp)) => {\n@@ -112,38 +112,7 @@ impl GlobalState {\n         self.update_status_or_notify();\n \n         if self.config.did_save_text_document_dynamic_registration() {\n-            let save_registration_options = lsp_types::TextDocumentSaveRegistrationOptions {\n-                include_text: Some(false),\n-                text_document_registration_options: lsp_types::TextDocumentRegistrationOptions {\n-                    document_selector: Some(vec![\n-                        lsp_types::DocumentFilter {\n-                            language: None,\n-                            scheme: None,\n-                            pattern: Some(\"**/*.rs\".into()),\n-                        },\n-                        lsp_types::DocumentFilter {\n-                            language: None,\n-                            scheme: None,\n-                            pattern: Some(\"**/Cargo.toml\".into()),\n-                        },\n-                        lsp_types::DocumentFilter {\n-                            language: None,\n-                            scheme: None,\n-                            pattern: Some(\"**/Cargo.lock\".into()),\n-                        },\n-                    ]),\n-                },\n-            };\n-\n-            let registration = lsp_types::Registration {\n-                id: \"textDocument/didSave\".to_string(),\n-                method: \"textDocument/didSave\".to_string(),\n-                register_options: Some(serde_json::to_value(save_registration_options).unwrap()),\n-            };\n-            self.send_request::<lsp_types::request::RegisterCapability>(\n-                lsp_types::RegistrationParams { registrations: vec![registration] },\n-                |_, _| (),\n-            );\n+            self.register_did_save_capability();\n         }\n \n         self.fetch_workspaces_queue.request_op(\"startup\".to_string(), ());\n@@ -152,17 +121,54 @@ impl GlobalState {\n         }\n \n         while let Some(event) = self.next_event(&inbox) {\n-            if let Event::Lsp(lsp_server::Message::Notification(not)) = &event {\n-                if not.method == lsp_types::notification::Exit::METHOD {\n-                    return Ok(());\n-                }\n+            if matches!(\n+                &event,\n+                Event::Lsp(lsp_server::Message::Notification(Notification { method, .. }))\n+                if method == lsp_types::notification::Exit::METHOD\n+            ) {\n+                return Ok(());\n             }\n-            self.handle_event(event)?\n+            self.handle_event(event)?;\n         }\n \n         Err(\"client exited without proper shutdown sequence\".into())\n     }\n \n+    fn register_did_save_capability(&mut self) {\n+        let save_registration_options = lsp_types::TextDocumentSaveRegistrationOptions {\n+            include_text: Some(false),\n+            text_document_registration_options: lsp_types::TextDocumentRegistrationOptions {\n+                document_selector: Some(vec![\n+                    lsp_types::DocumentFilter {\n+                        language: None,\n+                        scheme: None,\n+                        pattern: Some(\"**/*.rs\".into()),\n+                    },\n+                    lsp_types::DocumentFilter {\n+                        language: None,\n+                        scheme: None,\n+                        pattern: Some(\"**/Cargo.toml\".into()),\n+                    },\n+                    lsp_types::DocumentFilter {\n+                        language: None,\n+                        scheme: None,\n+                        pattern: Some(\"**/Cargo.lock\".into()),\n+                    },\n+                ]),\n+            },\n+        };\n+\n+        let registration = lsp_types::Registration {\n+            id: \"textDocument/didSave\".to_string(),\n+            method: \"textDocument/didSave\".to_string(),\n+            register_options: Some(serde_json::to_value(save_registration_options).unwrap()),\n+        };\n+        self.send_request::<lsp_types::request::RegisterCapability>(\n+            lsp_types::RegistrationParams { registrations: vec![registration] },\n+            |_, _| (),\n+        );\n+    }\n+\n     fn next_event(&self, inbox: &Receiver<lsp_server::Message>) -> Option<Event> {\n         select! {\n             recv(inbox) -> msg =>\n@@ -184,20 +190,20 @@ impl GlobalState {\n         // NOTE: don't count blocking select! call as a loop-turn time\n         let _p = profile::span(\"GlobalState::handle_event\");\n \n-        let event_dbg = format!(\"{event:?}\");\n-        tracing::debug!(\"{:?} handle_event({:?})\", loop_start, event);\n-        let task_queue_len = self.task_pool.handle.len();\n-        if task_queue_len > 0 {\n-            tracing::info!(\"task queue len: {}\", task_queue_len);\n+        let event_dbg_msg = format!(\"{event:?}\");\n+        tracing::debug!(\"{:?} handle_event({})\", loop_start, event_dbg_msg);\n+        if tracing::enabled!(tracing::Level::INFO) {\n+            let task_queue_len = self.task_pool.handle.len();\n+            if task_queue_len > 0 {\n+                tracing::info!(\"task queue len: {}\", task_queue_len);\n+            }\n         }\n \n         let was_quiescent = self.is_quiescent();\n         match event {\n             Event::Lsp(msg) => match msg {\n                 lsp_server::Message::Request(req) => self.on_new_request(loop_start, req),\n-                lsp_server::Message::Notification(not) => {\n-                    self.on_notification(not)?;\n-                }\n+                lsp_server::Message::Notification(not) => self.on_notification(not)?,\n                 lsp_server::Message::Response(resp) => self.complete_request(resp),\n             },\n             Event::Task(task) => {\n@@ -291,7 +297,8 @@ impl GlobalState {\n                 }\n             }\n \n-            if !was_quiescent || state_changed {\n+            let client_refresh = !was_quiescent || state_changed;\n+            if client_refresh {\n                 // Refresh semantic tokens if the client supports it.\n                 if self.config.semantic_tokens_refresh() {\n                     self.semantic_tokens_cache.lock().clear();\n@@ -309,9 +316,9 @@ impl GlobalState {\n                 }\n             }\n \n-            if (!was_quiescent || state_changed || memdocs_added_or_removed)\n-                && self.config.publish_diagnostics()\n-            {\n+            let update_diagnostics = (!was_quiescent || state_changed || memdocs_added_or_removed)\n+                && self.config.publish_diagnostics();\n+            if update_diagnostics {\n                 self.update_diagnostics()\n             }\n         }\n@@ -371,46 +378,52 @@ impl GlobalState {\n         }\n \n         if let Some((cause, ())) = self.prime_caches_queue.should_start_op() {\n-            tracing::debug!(%cause, \"will prime caches\");\n-            let num_worker_threads = self.config.prime_caches_num_threads();\n-\n-            self.task_pool.handle.spawn_with_sender({\n-                let analysis = self.snapshot().analysis;\n-                move |sender| {\n-                    sender.send(Task::PrimeCaches(PrimeCachesProgress::Begin)).unwrap();\n-                    let res = analysis.parallel_prime_caches(num_worker_threads, |progress| {\n-                        let report = PrimeCachesProgress::Report(progress);\n-                        sender.send(Task::PrimeCaches(report)).unwrap();\n-                    });\n-                    sender\n-                        .send(Task::PrimeCaches(PrimeCachesProgress::End {\n-                            cancelled: res.is_err(),\n-                        }))\n-                        .unwrap();\n-                }\n-            });\n+            self.prime_caches(cause);\n         }\n \n         self.update_status_or_notify();\n \n         let loop_duration = loop_start.elapsed();\n         if loop_duration > Duration::from_millis(100) && was_quiescent {\n-            tracing::warn!(\"overly long loop turn took {loop_duration:?}: {event_dbg}\");\n+            tracing::warn!(\"overly long loop turn took {loop_duration:?}: {event_dbg_msg}\");\n             self.poke_rust_analyzer_developer(format!(\n-                \"overly long loop turn took {loop_duration:?}: {event_dbg}\"\n+                \"overly long loop turn took {loop_duration:?}: {event_dbg_msg}\"\n             ));\n         }\n         Ok(())\n     }\n \n+    fn prime_caches(&mut self, cause: String) {\n+        tracing::debug!(%cause, \"will prime caches\");\n+        let num_worker_threads = self.config.prime_caches_num_threads();\n+\n+        self.task_pool.handle.spawn_with_sender({\n+            let analysis = self.snapshot().analysis;\n+            move |sender| {\n+                sender.send(Task::PrimeCaches(PrimeCachesProgress::Begin)).unwrap();\n+                let res = analysis.parallel_prime_caches(num_worker_threads, |progress| {\n+                    let report = PrimeCachesProgress::Report(progress);\n+                    sender.send(Task::PrimeCaches(report)).unwrap();\n+                });\n+                sender\n+                    .send(Task::PrimeCaches(PrimeCachesProgress::End { cancelled: res.is_err() }))\n+                    .unwrap();\n+            }\n+        });\n+    }\n+\n     fn update_status_or_notify(&mut self) {\n         let status = self.current_status();\n         if self.last_reported_status.as_ref() != Some(&status) {\n             self.last_reported_status = Some(status.clone());\n \n             if self.config.server_status_notification() {\n                 self.send_notification::<lsp_ext::ServerStatusNotification>(status);\n-            } else if let (health, Some(message)) = (status.health, &status.message) {\n+            } else if let (\n+                health @ (lsp_ext::Health::Warning | lsp_ext::Health::Error),\n+                Some(message),\n+            ) = (status.health, &status.message)\n+            {\n                 let open_log_button = tracing::enabled!(tracing::Level::ERROR)\n                     && (self.fetch_build_data_error().is_err()\n                         || self.fetch_workspace_error().is_err());\n@@ -589,21 +602,18 @@ impl GlobalState {\n                         (Progress::Begin, None)\n                     }\n                     flycheck::Progress::DidCheckCrate(target) => (Progress::Report, Some(target)),\n-                    flycheck::Progress::DidCancel => (Progress::End, None),\n+                    flycheck::Progress::DidCancel => {\n+                        self.last_flycheck_error = None;\n+                        (Progress::End, None)\n+                    }\n                     flycheck::Progress::DidFailToRestart(err) => {\n-                        self.show_and_log_error(\n-                            \"cargo check failed to start\".to_string(),\n-                            Some(err),\n-                        );\n+                        self.last_flycheck_error =\n+                            Some(format!(\"cargo check failed to start: {err}\"));\n                         return;\n                     }\n                     flycheck::Progress::DidFinish(result) => {\n-                        if let Err(err) = result {\n-                            self.show_and_log_error(\n-                                \"cargo check failed\".to_string(),\n-                                Some(err.to_string()),\n-                            );\n-                        }\n+                        self.last_flycheck_error =\n+                            result.err().map(|err| format!(\"cargo check failed to start: {err}\"));\n                         (Progress::End, None)\n                     }\n                 };"}, {"sha": "4e29485573822fa05cbe828f6f959661e4b19c7b", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eee6872647fff3d168149e015264673c44b5b062/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee6872647fff3d168149e015264673c44b5b062/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=eee6872647fff3d168149e015264673c44b5b062", "patch": "@@ -27,6 +27,7 @@ use ide_db::{\n use itertools::Itertools;\n use proc_macro_api::{MacroDylib, ProcMacroServer};\n use project_model::{PackageRoot, ProjectWorkspace, WorkspaceBuildScripts};\n+use stdx::format_to;\n use syntax::SmolStr;\n use triomphe::Arc;\n use vfs::{file_set::FileSetConfig, AbsPath, AbsPathBuf, ChangeKind};\n@@ -134,6 +135,15 @@ impl GlobalState {\n             message.push_str(\"Failed to discover workspace.\\n\");\n             message.push_str(\"Consider adding the `Cargo.toml` of the workspace to the [`linkedProjects`](https://rust-analyzer.github.io/manual.html#rust-analyzer.linkedProjects) setting.\\n\\n\");\n         }\n+        if let Some(err) = &self.config_errors {\n+            status.health = lsp_ext::Health::Warning;\n+            format_to!(message, \"{err}\\n\");\n+        }\n+        if let Some(err) = &self.last_flycheck_error {\n+            status.health = lsp_ext::Health::Warning;\n+            message.push_str(err);\n+            message.push('\\n');\n+        }\n \n         for ws in self.workspaces.iter() {\n             let (ProjectWorkspace::Cargo { sysroot, .. }"}]}