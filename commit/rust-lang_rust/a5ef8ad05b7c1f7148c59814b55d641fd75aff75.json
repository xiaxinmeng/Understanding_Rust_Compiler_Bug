{"sha": "a5ef8ad05b7c1f7148c59814b55d641fd75aff75", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZWY4YWQwNWI3YzFmNzE0OGM1OTgxNGI1NWQ2NDFmZDc1YWZmNzU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-19T12:04:15Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-20T09:15:38Z"}, "message": "swtich lsp server to vfs", "tree": {"sha": "df6c46378d81dc7cb3242ff7f57d836353bde5ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df6c46378d81dc7cb3242ff7f57d836353bde5ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5ef8ad05b7c1f7148c59814b55d641fd75aff75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5ef8ad05b7c1f7148c59814b55d641fd75aff75", "html_url": "https://github.com/rust-lang/rust/commit/a5ef8ad05b7c1f7148c59814b55d641fd75aff75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a755ed83a583d1f70a5fbcff2d4933b52628cfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a755ed83a583d1f70a5fbcff2d4933b52628cfe", "html_url": "https://github.com/rust-lang/rust/commit/6a755ed83a583d1f70a5fbcff2d4933b52628cfe"}], "stats": {"total": 632, "additions": 234, "deletions": 398}, "files": [{"sha": "7ebe6e67f998fff708151db04db218827750db40", "filename": "Cargo.lock", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a5ef8ad05b7c1f7148c59814b55d641fd75aff75", "patch": "@@ -541,6 +541,15 @@ dependencies = [\n  \"parking_lot_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"parking_lot\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"lock_api 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"parking_lot_core\"\n version = \"0.3.1\"\n@@ -553,6 +562,18 @@ dependencies = [\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"parking_lot_core\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"percent-encoding\"\n version = \"1.0.1\"\n@@ -701,10 +722,12 @@ dependencies = [\n  \"im 12.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"languageserver-types 0.53.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_analysis 0.1.0\",\n  \"ra_editor 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n+ \"ra_vfs 0.1.0\",\n  \"rayon 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1496,7 +1519,9 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum num_cpus 1.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5a69d464bdc213aaaff628444e99578ede64e9c854025aa43b9796530afa9238\"\n \"checksum owning_ref 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"49a4b8ea2179e6a2e27411d3bca09ca6dd630821cf6894c6c7c8467a8ee7ef13\"\n \"checksum parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f0802bff09003b291ba756dc7e79313e51cc31667e94afbe847def490424cde5\"\n+\"checksum parking_lot 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9723236a9525c757d9725b993511e3fc941e33f27751942232f0058298297edf\"\n \"checksum parking_lot_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad7f7e6ebdc79edff6fdcb87a55b620174f7a989e3eb31b65231f4af57f00b8c\"\n+\"checksum parking_lot_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"94c8c7923936b28d546dfd14d4472eaf34c99b14e1c973a32b3e6d4eb04298c9\"\n \"checksum percent-encoding 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"31010dd2e1ac33d5b46a5b413495239882813e0369f8ed8a5e266f173602f831\"\n \"checksum pest 2.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a677051ad923732bb5c70f2d45f8985a96e3eee2e2bff86697e3b11b0c3fcfde\"\n \"checksum pest_derive 2.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b76f477146419bc539a63f4ef40e902166cb43b3e51cecc71d9136fd12c567e7\""}, {"sha": "54f38b2855e0bf17b8e884e2dbae1b20aaa5bb7b", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=a5ef8ad05b7c1f7148c59814b55d641fd75aff75", "patch": "@@ -43,14 +43,17 @@ impl AnalysisHostImpl {\n     pub fn apply_change(&mut self, change: AnalysisChange) {\n         log::info!(\"apply_change {:?}\", change);\n         // self.gc_syntax_trees();\n+        for root_id in change.new_roots {\n+            self.db\n+                .query_mut(ra_db::SourceRootQuery)\n+                .set(root_id, Default::default());\n+        }\n \n         for (root_id, root_change) in change.roots_changed {\n             self.apply_root_change(root_id, root_change);\n         }\n         for (file_id, text) in change.files_changed {\n-            self.db\n-                .query_mut(ra_db::FileTextQuery)\n-                .set(file_id, Arc::new(text))\n+            self.db.query_mut(ra_db::FileTextQuery).set(file_id, text)\n         }\n         if !change.libraries_added.is_empty() {\n             let mut libraries = Vec::clone(&self.db.libraries());"}, {"sha": "8882feca3f8290fd1d76a6c3a5a14036842d78fe", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=a5ef8ad05b7c1f7148c59814b55d641fd75aff75", "patch": "@@ -44,8 +44,9 @@ pub use ra_db::{\n \n #[derive(Default)]\n pub struct AnalysisChange {\n+    new_roots: Vec<SourceRootId>,\n     roots_changed: FxHashMap<SourceRootId, RootChange>,\n-    files_changed: Vec<(FileId, String)>,\n+    files_changed: Vec<(FileId, Arc<String>)>,\n     libraries_added: Vec<LibraryData>,\n     crate_graph: Option<CrateGraph>,\n }\n@@ -93,6 +94,9 @@ impl AnalysisChange {\n     pub fn new() -> AnalysisChange {\n         AnalysisChange::default()\n     }\n+    pub fn add_root(&mut self, root_id: SourceRootId) {\n+        self.new_roots.push(root_id);\n+    }\n     pub fn add_file(\n         &mut self,\n         root_id: SourceRootId,\n@@ -111,7 +115,7 @@ impl AnalysisChange {\n             .added\n             .push(file);\n     }\n-    pub fn change_file(&mut self, file_id: FileId, new_text: String) {\n+    pub fn change_file(&mut self, file_id: FileId, new_text: Arc<String>) {\n         self.files_changed.push((file_id, new_text))\n     }\n     pub fn remove_file(&mut self, root_id: SourceRootId, file_id: FileId, path: RelativePathBuf) {"}, {"sha": "fc10096e5a177484eec37b74d4f9a45ec80f58ec", "filename": "crates/ra_lsp_server/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fra_lsp_server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fra_lsp_server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2FCargo.toml?ref=a5ef8ad05b7c1f7148c59814b55d641fd75aff75", "patch": "@@ -25,13 +25,15 @@ cargo_metadata = \"0.6.0\"\n text_unit = { version = \"0.1.2\", features = [\"serde\"] }\n smol_str = { version = \"0.1.5\", features = [\"serde\"] }\n rustc-hash = \"1.0\"\n+parking_lot = \"0.7.0\"\n \n thread_worker = { path = \"../thread_worker\" }\n ra_syntax = { path = \"../ra_syntax\" }\n ra_editor = { path = \"../ra_editor\" }\n ra_text_edit = { path = \"../ra_text_edit\" }\n ra_analysis = { path = \"../ra_analysis\" }\n gen_lsp_server = { path = \"../gen_lsp_server\" }\n+ra_vfs = { path = \"../ra_vfs\" }\n \n [dev-dependencies]\n tempdir = \"0.3.7\""}, {"sha": "725b1258a97ddda2fa75cb52b365d2c6d3410d35", "filename": "crates/ra_lsp_server/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fra_lsp_server%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fra_lsp_server%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Flib.rs?ref=a5ef8ad05b7c1f7148c59814b55d641fd75aff75", "patch": "@@ -1,11 +1,9 @@\n mod caps;\n mod conv;\n mod main_loop;\n-mod path_map;\n mod project_model;\n pub mod req;\n mod server_world;\n-mod vfs;\n \n pub type Result<T> = ::std::result::Result<T, ::failure::Error>;\n pub use crate::{caps::server_capabilities, main_loop::main_loop, main_loop::LspError};"}, {"sha": "7904545d3c74dcdcee3632beed42a8ea696373ed", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 54, "deletions": 89, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=a5ef8ad05b7c1f7148c59814b55d641fd75aff75", "patch": "@@ -1,16 +1,19 @@\n mod handlers;\n mod subscriptions;\n \n-use std::path::PathBuf;\n+use std::{\n+    path::PathBuf,\n+    sync::Arc,\n+};\n \n use crossbeam_channel::{unbounded, select, Receiver, Sender};\n use gen_lsp_server::{\n     handle_shutdown, ErrorCode, RawMessage, RawNotification, RawRequest, RawResponse,\n };\n use languageserver_types::NumberOrString;\n use ra_analysis::{Canceled, FileId, LibraryData};\n+use ra_vfs::{VfsTask};\n use rayon;\n-use thread_worker::Worker;\n use threadpool::ThreadPool;\n use rustc_hash::FxHashSet;\n use serde::{de::DeserializeOwned, Serialize};\n@@ -19,10 +22,9 @@ use failure_derive::Fail;\n \n use crate::{\n     main_loop::subscriptions::Subscriptions,\n-    project_model::{workspace_loader, CargoWorkspace},\n+    project_model::{workspace_loader},\n     req,\n     server_world::{ServerWorld, ServerWorldState},\n-    vfs::{self, FileEvent},\n     Result,\n };\n \n@@ -50,32 +52,42 @@ enum Task {\n \n pub fn main_loop(\n     internal_mode: bool,\n-    root: PathBuf,\n+    ws_root: PathBuf,\n     publish_decorations: bool,\n     msg_receiver: &Receiver<RawMessage>,\n     msg_sender: &Sender<RawMessage>,\n ) -> Result<()> {\n     let pool = ThreadPool::new(8);\n     let (task_sender, task_receiver) = unbounded::<Task>();\n-    let (fs_worker, fs_watcher) = vfs::roots_loader();\n     let (ws_worker, ws_watcher) = workspace_loader();\n \n+    ws_worker.send(ws_root.clone());\n+    // FIXME: support dynamic workspace loading.\n+    let workspaces = match ws_worker.recv().unwrap() {\n+        Ok(ws) => vec![ws],\n+        Err(e) => {\n+            log::warn!(\"loading workspace failed: {}\", e);\n+            Vec::new()\n+        }\n+    };\n+    ws_worker.shutdown();\n+    ws_watcher\n+        .shutdown()\n+        .map_err(|_| format_err!(\"ws watcher died\"))?;\n+    let mut state = ServerWorldState::new(ws_root.clone(), workspaces);\n+\n     log::info!(\"server initialized, serving requests\");\n-    let mut state = ServerWorldState::default();\n \n     let mut pending_requests = FxHashSet::default();\n     let mut subs = Subscriptions::new();\n     let main_res = main_loop_inner(\n         internal_mode,\n         publish_decorations,\n-        root,\n         &pool,\n         msg_sender,\n         msg_receiver,\n         task_sender,\n         task_receiver.clone(),\n-        fs_worker,\n-        ws_worker,\n         &mut state,\n         &mut pending_requests,\n         &mut subs,\n@@ -88,41 +100,34 @@ pub fn main_loop(\n     drop(pool);\n     log::info!(\"...threadpool has finished\");\n \n-    let fs_res = fs_watcher.shutdown();\n-    let ws_res = ws_watcher.shutdown();\n+    let vfs = Arc::try_unwrap(state.vfs).expect(\"all snapshots should be dead\");\n+    let vfs_res = vfs.into_inner().shutdown();\n \n     main_res?;\n-    fs_res.map_err(|_| format_err!(\"fs watcher died\"))?;\n-    ws_res.map_err(|_| format_err!(\"ws watcher died\"))?;\n+    vfs_res.map_err(|_| format_err!(\"fs watcher died\"))?;\n \n     Ok(())\n }\n \n fn main_loop_inner(\n     internal_mode: bool,\n     publish_decorations: bool,\n-    ws_root: PathBuf,\n     pool: &ThreadPool,\n     msg_sender: &Sender<RawMessage>,\n     msg_receiver: &Receiver<RawMessage>,\n     task_sender: Sender<Task>,\n     task_receiver: Receiver<Task>,\n-    fs_worker: Worker<PathBuf, (PathBuf, Vec<FileEvent>)>,\n-    ws_worker: Worker<PathBuf, Result<CargoWorkspace>>,\n     state: &mut ServerWorldState,\n     pending_requests: &mut FxHashSet<u64>,\n     subs: &mut Subscriptions,\n ) -> Result<()> {\n     let (libdata_sender, libdata_receiver) = unbounded();\n-    ws_worker.send(ws_root.clone());\n-    fs_worker.send(ws_root.clone());\n     loop {\n         #[derive(Debug)]\n         enum Event {\n             Msg(RawMessage),\n             Task(Task),\n-            Fs(PathBuf, Vec<FileEvent>),\n-            Ws(Result<CargoWorkspace>),\n+            Vfs(VfsTask),\n             Lib(LibraryData),\n         }\n         log::trace!(\"selecting\");\n@@ -132,77 +137,19 @@ fn main_loop_inner(\n                 None => bail!(\"client exited without shutdown\"),\n             },\n             recv(task_receiver, task) => Event::Task(task.unwrap()),\n-            recv(fs_worker.out, events) => match events {\n-                None => bail!(\"roots watcher died\"),\n-                Some((pb, events)) => Event::Fs(pb, events),\n-            }\n-            recv(ws_worker.out, ws) => match ws {\n-                None => bail!(\"workspace watcher died\"),\n-                Some(ws) => Event::Ws(ws),\n+            recv(state.vfs.read().task_receiver(), task) => match task {\n+                None => bail!(\"vfs died\"),\n+                Some(task) => Event::Vfs(task),\n             }\n             recv(libdata_receiver, data) => Event::Lib(data.unwrap())\n         };\n         let mut state_changed = false;\n         match event {\n             Event::Task(task) => on_task(task, msg_sender, pending_requests),\n-            Event::Fs(root, events) => {\n-                log::info!(\"fs change, {}, {} events\", root.display(), events.len());\n-                if root == ws_root {\n-                    state.apply_fs_changes(events);\n-                } else {\n-                    let (files, resolver) = state.events_to_files(events);\n-                    let sender = libdata_sender.clone();\n-                    pool.execute(move || {\n-                        let start = ::std::time::Instant::now();\n-                        log::info!(\"indexing {} ... \", root.display());\n-                        let data = LibraryData::prepare(files, resolver);\n-                        log::info!(\"indexed {:?} {}\", start.elapsed(), root.display());\n-                        sender.send(data);\n-                    });\n-                }\n+            Event::Vfs(task) => {\n+                state.vfs.write().handle_task(task);\n                 state_changed = true;\n             }\n-            Event::Ws(ws) => match ws {\n-                Ok(ws) => {\n-                    let workspaces = vec![ws];\n-                    feedback(internal_mode, \"workspace loaded\", msg_sender);\n-                    for ws in workspaces.iter() {\n-                        // Add each library as constant input. If library is\n-                        // within the workspace, don't treat it as a library.\n-                        //\n-                        // HACK: If source roots are nested, pick the outer one.\n-\n-                        let mut roots = ws\n-                            .packages()\n-                            .filter(|pkg| !pkg.is_member(ws))\n-                            .filter_map(|pkg| {\n-                                let root = pkg.root(ws).to_path_buf();\n-                                if root.starts_with(&ws_root) {\n-                                    None\n-                                } else {\n-                                    Some(root)\n-                                }\n-                            })\n-                            .collect::<Vec<_>>();\n-                        roots.sort_by_key(|it| it.as_os_str().len());\n-                        let unique = roots\n-                            .iter()\n-                            .enumerate()\n-                            .filter(|&(idx, long)| {\n-                                !roots[..idx].iter().any(|short| long.starts_with(short))\n-                            })\n-                            .map(|(_idx, root)| root);\n-\n-                        for root in unique {\n-                            log::debug!(\"sending root, {}\", root.display());\n-                            fs_worker.send(root.to_owned());\n-                        }\n-                    }\n-                    state.set_workspaces(workspaces);\n-                    state_changed = true;\n-                }\n-                Err(e) => log::warn!(\"loading workspace failed: {}\", e),\n-            },\n             Event::Lib(lib) => {\n                 feedback(internal_mode, \"library loaded\", msg_sender);\n                 state.add_lib(lib);\n@@ -234,6 +181,18 @@ fn main_loop_inner(\n             },\n         };\n \n+        for lib in state.process_changes() {\n+            let (root, files) = lib;\n+            let sender = libdata_sender.clone();\n+            pool.execute(move || {\n+                let start = ::std::time::Instant::now();\n+                log::info!(\"indexing {:?} ... \", root);\n+                let data = LibraryData::prepare(root, files);\n+                log::info!(\"indexed {:?} {:?}\", start.elapsed(), root);\n+                sender.send(data);\n+            });\n+        }\n+\n         if state_changed {\n             update_file_notifications_on_threadpool(\n                 pool,\n@@ -336,8 +295,13 @@ fn on_notification(\n             let path = uri\n                 .to_file_path()\n                 .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n-            let file_id = state.add_mem_file(path, params.text_document.text);\n-            subs.add_sub(file_id);\n+            if let Some(file_id) = state\n+                .vfs\n+                .write()\n+                .add_file_overlay(&path, params.text_document.text)\n+            {\n+                subs.add_sub(FileId(file_id.0));\n+            }\n             return Ok(());\n         }\n         Err(not) => not,\n@@ -353,7 +317,7 @@ fn on_notification(\n                 .pop()\n                 .ok_or_else(|| format_err!(\"empty changes\"))?\n                 .text;\n-            state.change_mem_file(path.as_path(), text)?;\n+            state.vfs.write().change_file_overlay(path.as_path(), text);\n             return Ok(());\n         }\n         Err(not) => not,\n@@ -364,8 +328,9 @@ fn on_notification(\n             let path = uri\n                 .to_file_path()\n                 .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n-            let file_id = state.remove_mem_file(path.as_path())?;\n-            subs.remove_sub(file_id);\n+            if let Some(file_id) = state.vfs.write().remove_file_overlay(path.as_path()) {\n+                subs.remove_sub(FileId(file_id.0));\n+            }\n             let params = req::PublishDiagnosticsParams {\n                 uri,\n                 diagnostics: Vec::new(),"}, {"sha": "572ae7fb53992c1072ba0d866a56007e0e687ff3", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=a5ef8ad05b7c1f7148c59814b55d641fd75aff75", "patch": "@@ -326,9 +326,9 @@ pub fn handle_runnables(\n                 None => return Ok(None),\n             };\n             let file_id = world.analysis().crate_root(crate_id)?;\n-            let path = world.path_map.get_path(file_id);\n+            let path = world.vfs.read().file2path(ra_vfs::VfsFile(file_id.0));\n             let res = world.workspaces.iter().find_map(|ws| {\n-                let tgt = ws.target_by_root(path)?;\n+                let tgt = ws.target_by_root(&path)?;\n                 let res = CargoTargetSpec {\n                     package: tgt.package(ws).name(ws).to_string(),\n                     target: tgt.name(ws).to_string(),"}, {"sha": "86cf29540e42f21d2588599c55181e2fbd6d0d0b", "filename": "crates/ra_lsp_server/src/path_map.rs", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/6a755ed83a583d1f70a5fbcff2d4933b52628cfe/crates%2Fra_lsp_server%2Fsrc%2Fpath_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a755ed83a583d1f70a5fbcff2d4933b52628cfe/crates%2Fra_lsp_server%2Fsrc%2Fpath_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fpath_map.rs?ref=6a755ed83a583d1f70a5fbcff2d4933b52628cfe", "patch": "@@ -1,105 +0,0 @@\n-use std::{\n-    fmt,\n-    path::{Component, Path, PathBuf},\n-};\n-\n-use im;\n-use ra_analysis::{FileId};\n-use relative_path::RelativePath;\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum Root {\n-    Workspace,\n-    Lib,\n-}\n-\n-#[derive(Default, Clone)]\n-pub struct PathMap {\n-    next_id: u32,\n-    path2id: im::HashMap<PathBuf, FileId>,\n-    id2path: im::HashMap<FileId, PathBuf>,\n-    id2root: im::HashMap<FileId, Root>,\n-}\n-\n-impl fmt::Debug for PathMap {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(\"PathMap { ... }\")\n-    }\n-}\n-\n-impl PathMap {\n-    pub fn get_or_insert(&mut self, path: PathBuf, root: Root) -> (bool, FileId) {\n-        let mut inserted = false;\n-        let file_id = self\n-            .path2id\n-            .get(path.as_path())\n-            .map(|&id| id)\n-            .unwrap_or_else(|| {\n-                inserted = true;\n-                let id = self.new_file_id();\n-                self.insert(path, id, root);\n-                id\n-            });\n-        (inserted, file_id)\n-    }\n-    pub fn get_id(&self, path: &Path) -> Option<FileId> {\n-        self.path2id.get(path).cloned()\n-    }\n-    pub fn get_path(&self, file_id: FileId) -> &Path {\n-        self.id2path.get(&file_id).unwrap().as_path()\n-    }\n-    pub fn get_root(&self, file_id: FileId) -> Root {\n-        self.id2root[&file_id]\n-    }\n-    fn insert(&mut self, path: PathBuf, file_id: FileId, root: Root) {\n-        self.path2id.insert(path.clone(), file_id);\n-        self.id2path.insert(file_id, path.clone());\n-        self.id2root.insert(file_id, root);\n-    }\n-\n-    fn new_file_id(&mut self) -> FileId {\n-        let id = FileId(self.next_id);\n-        self.next_id += 1;\n-        id\n-    }\n-}\n-\n-fn normalize(path: &Path) -> PathBuf {\n-    let mut components = path.components().peekable();\n-    let mut ret = if let Some(c @ Component::Prefix(..)) = components.peek().cloned() {\n-        components.next();\n-        PathBuf::from(c.as_os_str())\n-    } else {\n-        PathBuf::new()\n-    };\n-\n-    for component in components {\n-        match component {\n-            Component::Prefix(..) => unreachable!(),\n-            Component::RootDir => {\n-                ret.push(component.as_os_str());\n-            }\n-            Component::CurDir => {}\n-            Component::ParentDir => {\n-                ret.pop();\n-            }\n-            Component::Normal(c) => {\n-                ret.push(c);\n-            }\n-        }\n-    }\n-    ret\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-\n-    #[test]\n-    fn test_resolve() {\n-        let mut m = PathMap::default();\n-        let (_, id1) = m.get_or_insert(PathBuf::from(\"/foo\"), Root::Workspace);\n-        let (_, id2) = m.get_or_insert(PathBuf::from(\"/foo/bar.rs\"), Root::Workspace);\n-        assert_eq!(m.resolve(id1, &RelativePath::new(\"bar.rs\")), Some(id2),)\n-    }\n-}"}, {"sha": "5852a157d198eb2bc645e6da8bd946842e45e4e8", "filename": "crates/ra_lsp_server/src/project_model.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs?ref=a5ef8ad05b7c1f7148c59814b55d641fd75aff75", "patch": "@@ -69,6 +69,7 @@ impl Package {\n     pub fn targets<'a>(self, ws: &'a CargoWorkspace) -> impl Iterator<Item = Target> + 'a {\n         ws.pkg(self).targets.iter().cloned()\n     }\n+    #[allow(unused)]\n     pub fn is_member(self, ws: &CargoWorkspace) -> bool {\n         ws.pkg(self).is_member\n     }"}, {"sha": "f2fd09e851d5f3a969d39f9b336ce5a439021b28", "filename": "crates/ra_lsp_server/src/server_world.rs", "status": "modified", "additions": 81, "deletions": 122, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs?ref=a5ef8ad05b7c1f7148c59814b55d641fd75aff75", "patch": "@@ -1,154 +1,62 @@\n use std::{\n-    fs,\n-    path::{Path, PathBuf},\n+    path::{PathBuf},\n     sync::Arc,\n };\n \n use languageserver_types::Url;\n use ra_analysis::{\n     Analysis, AnalysisChange, AnalysisHost, CrateGraph, FileId, LibraryData,\n+    SourceRootId\n };\n+use ra_vfs::{Vfs, VfsChange, VfsFile};\n use rustc_hash::FxHashMap;\n-use failure::{bail, format_err};\n+use relative_path::RelativePathBuf;\n+use parking_lot::RwLock;\n+use failure::{format_err};\n \n use crate::{\n-    path_map::{PathMap, Root},\n     project_model::{CargoWorkspace, TargetKind},\n-    vfs::{FileEvent, FileEventKind},\n     Result,\n };\n \n-#[derive(Debug, Default)]\n+#[derive(Debug)]\n pub struct ServerWorldState {\n     pub workspaces: Arc<Vec<CargoWorkspace>>,\n     pub analysis_host: AnalysisHost,\n-    pub path_map: PathMap,\n-    pub mem_map: FxHashMap<FileId, Option<String>>,\n+    pub vfs: Arc<RwLock<Vfs>>,\n }\n \n pub struct ServerWorld {\n     pub workspaces: Arc<Vec<CargoWorkspace>>,\n     pub analysis: Analysis,\n-    pub path_map: PathMap,\n+    pub vfs: Arc<RwLock<Vfs>>,\n }\n \n impl ServerWorldState {\n-    pub fn apply_fs_changes(&mut self, events: Vec<FileEvent>) {\n+    pub fn new(root: PathBuf, workspaces: Vec<CargoWorkspace>) -> ServerWorldState {\n         let mut change = AnalysisChange::new();\n-        let mut inserted = false;\n-        {\n-            let pm = &mut self.path_map;\n-            let mm = &mut self.mem_map;\n-            events\n-                .into_iter()\n-                .map(|event| {\n-                    let text = match event.kind {\n-                        FileEventKind::Add(text) => text,\n-                    };\n-                    (event.path, text)\n-                })\n-                .map(|(path, text)| {\n-                    let (ins, file_id) = pm.get_or_insert(path, Root::Workspace);\n-                    inserted |= ins;\n-                    (file_id, text)\n-                })\n-                .filter_map(|(file_id, text)| {\n-                    if mm.contains_key(&file_id) {\n-                        mm.insert(file_id, Some(text));\n-                        None\n-                    } else {\n-                        Some((file_id, text))\n-                    }\n-                })\n-                .for_each(|(file_id, text)| change.add_file(file_id, text));\n-        }\n-        if inserted {\n-            change.set_file_resolver(Arc::new(self.path_map.clone()))\n-        }\n-        self.analysis_host.apply_change(change);\n-    }\n-    pub fn events_to_files(\n-        &mut self,\n-        events: Vec<FileEvent>,\n-    ) -> (Vec<(FileId, String)>, Arc<FileResolver>) {\n-        let files = {\n-            let pm = &mut self.path_map;\n-            events\n-                .into_iter()\n-                .map(|event| {\n-                    let FileEventKind::Add(text) = event.kind;\n-                    (event.path, text)\n-                })\n-                .map(|(path, text)| (pm.get_or_insert(path, Root::Lib).1, text))\n-                .collect()\n-        };\n-        let resolver = Arc::new(self.path_map.clone());\n-        (files, resolver)\n-    }\n-    pub fn add_lib(&mut self, data: LibraryData) {\n-        let mut change = AnalysisChange::new();\n-        change.add_library(data);\n-        self.analysis_host.apply_change(change);\n-    }\n \n-    pub fn add_mem_file(&mut self, path: PathBuf, text: String) -> FileId {\n-        let (inserted, file_id) = self.path_map.get_or_insert(path, Root::Workspace);\n-        if self.path_map.get_root(file_id) != Root::Lib {\n-            let mut change = AnalysisChange::new();\n-            if inserted {\n-                change.add_file(file_id, text);\n-                change.set_file_resolver(Arc::new(self.path_map.clone()));\n-            } else {\n-                change.change_file(file_id, text);\n+        let mut roots = Vec::new();\n+        roots.push(root);\n+        for ws in workspaces.iter() {\n+            for pkg in ws.packages() {\n+                roots.push(pkg.root(&ws).to_path_buf());\n             }\n-            self.analysis_host.apply_change(change);\n         }\n-        self.mem_map.insert(file_id, None);\n-        file_id\n-    }\n-\n-    pub fn change_mem_file(&mut self, path: &Path, text: String) -> Result<()> {\n-        let file_id = self\n-            .path_map\n-            .get_id(path)\n-            .ok_or_else(|| format_err!(\"change to unknown file: {}\", path.display()))?;\n-        if self.path_map.get_root(file_id) != Root::Lib {\n-            let mut change = AnalysisChange::new();\n-            change.change_file(file_id, text);\n-            self.analysis_host.apply_change(change);\n+        let (mut vfs, roots) = Vfs::new(roots);\n+        for r in roots {\n+            change.add_root(SourceRootId(r.0));\n         }\n-        Ok(())\n-    }\n \n-    pub fn remove_mem_file(&mut self, path: &Path) -> Result<FileId> {\n-        let file_id = self\n-            .path_map\n-            .get_id(path)\n-            .ok_or_else(|| format_err!(\"change to unknown file: {}\", path.display()))?;\n-        match self.mem_map.remove(&file_id) {\n-            Some(_) => (),\n-            None => bail!(\"unmatched close notification\"),\n-        };\n-        // Do this via file watcher ideally.\n-        let text = fs::read_to_string(path).ok();\n-        if self.path_map.get_root(file_id) != Root::Lib {\n-            let mut change = AnalysisChange::new();\n-            if let Some(text) = text {\n-                change.change_file(file_id, text);\n-            }\n-            self.analysis_host.apply_change(change);\n-        }\n-        Ok(file_id)\n-    }\n-    pub fn set_workspaces(&mut self, ws: Vec<CargoWorkspace>) {\n         let mut crate_graph = CrateGraph::default();\n         let mut pkg_to_lib_crate = FxHashMap::default();\n         let mut pkg_crates = FxHashMap::default();\n-        for ws in ws.iter() {\n+        for ws in workspaces.iter() {\n             for pkg in ws.packages() {\n                 for tgt in pkg.targets(ws) {\n                     let root = tgt.root(ws);\n-                    if let Some(file_id) = self.path_map.get_id(root) {\n+                    if let Some(file_id) = vfs.load(root) {\n+                        let file_id = FileId(file_id.0);\n                         let crate_id = crate_graph.add_crate_root(file_id);\n                         if tgt.kind(ws) == TargetKind::Lib {\n                             pkg_to_lib_crate.insert(pkg, crate_id);\n@@ -170,16 +78,64 @@ impl ServerWorldState {\n                 }\n             }\n         }\n-        self.workspaces = Arc::new(ws);\n-        let mut change = AnalysisChange::new();\n         change.set_crate_graph(crate_graph);\n+\n+        let mut analysis_host = AnalysisHost::default();\n+        analysis_host.apply_change(change);\n+        ServerWorldState {\n+            workspaces: Arc::new(workspaces),\n+            analysis_host,\n+            vfs: Arc::new(RwLock::new(vfs)),\n+        }\n+    }\n+\n+    /// Returns a vec of libraries\n+    /// FIXME: better API here\n+    pub fn process_changes(\n+        &mut self,\n+    ) -> Vec<(SourceRootId, Vec<(FileId, RelativePathBuf, Arc<String>)>)> {\n+        let mut libs = Vec::new();\n+        let mut change = AnalysisChange::new();\n+        for c in self.vfs.write().commit_changes() {\n+            match c {\n+                VfsChange::AddRoot { root, files } => {\n+                    let files = files\n+                        .into_iter()\n+                        .map(|(vfsfile, path, text)| (FileId(vfsfile.0), path, text))\n+                        .collect();\n+                    libs.push((SourceRootId(root.0), files));\n+                }\n+                VfsChange::AddFile {\n+                    root,\n+                    file,\n+                    path,\n+                    text,\n+                } => {\n+                    change.add_file(SourceRootId(root.0), FileId(file.0), path, text);\n+                }\n+                VfsChange::RemoveFile { root, file, path } => {\n+                    change.remove_file(SourceRootId(root.0), FileId(file.0), path)\n+                }\n+                VfsChange::ChangeFile { file, text } => {\n+                    change.change_file(FileId(file.0), text);\n+                }\n+            }\n+        }\n         self.analysis_host.apply_change(change);\n+        libs\n     }\n+\n+    pub fn add_lib(&mut self, data: LibraryData) {\n+        let mut change = AnalysisChange::new();\n+        change.add_library(data);\n+        self.analysis_host.apply_change(change);\n+    }\n+\n     pub fn snapshot(&self) -> ServerWorld {\n         ServerWorld {\n             workspaces: Arc::clone(&self.workspaces),\n             analysis: self.analysis_host.analysis(),\n-            path_map: self.path_map.clone(),\n+            vfs: Arc::clone(&self.vfs),\n         }\n     }\n }\n@@ -193,15 +149,18 @@ impl ServerWorld {\n         let path = uri\n             .to_file_path()\n             .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n-        self.path_map\n-            .get_id(&path)\n-            .ok_or_else(|| format_err!(\"unknown file: {}\", path.display()))\n+        let file = self\n+            .vfs\n+            .read()\n+            .path2file(&path)\n+            .ok_or_else(|| format_err!(\"unknown file: {}\", path.display()))?;\n+        Ok(FileId(file.0))\n     }\n \n     pub fn file_id_to_uri(&self, id: FileId) -> Result<Url> {\n-        let path = self.path_map.get_path(id);\n-        let url = Url::from_file_path(path)\n-            .map_err(|()| format_err!(\"can't convert path to url: {}\", path.display()))?;\n+        let path = self.vfs.read().file2path(VfsFile(id.0));\n+        let url = Url::from_file_path(&path)\n+            .map_err(|_| format_err!(\"can't convert path to url: {}\", path.display()))?;\n         Ok(url)\n     }\n }"}, {"sha": "fcf7693d86855c227e939fda9275489d68a5b74f", "filename": "crates/ra_lsp_server/src/vfs.rs", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/6a755ed83a583d1f70a5fbcff2d4933b52628cfe/crates%2Fra_lsp_server%2Fsrc%2Fvfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a755ed83a583d1f70a5fbcff2d4933b52628cfe/crates%2Fra_lsp_server%2Fsrc%2Fvfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fvfs.rs?ref=6a755ed83a583d1f70a5fbcff2d4933b52628cfe", "patch": "@@ -1,67 +0,0 @@\n-use std::{\n-    fs,\n-    path::{Path, PathBuf},\n-};\n-\n-use walkdir::WalkDir;\n-use thread_worker::{WorkerHandle, Worker};\n-\n-#[derive(Debug)]\n-pub struct FileEvent {\n-    pub path: PathBuf,\n-    pub kind: FileEventKind,\n-}\n-\n-#[derive(Debug)]\n-pub enum FileEventKind {\n-    Add(String),\n-}\n-\n-pub fn roots_loader() -> (Worker<PathBuf, (PathBuf, Vec<FileEvent>)>, WorkerHandle) {\n-    thread_worker::spawn::<PathBuf, (PathBuf, Vec<FileEvent>), _>(\n-        \"roots loader\",\n-        128,\n-        |input_receiver, output_sender| {\n-            input_receiver\n-                .map(|path| {\n-                    log::debug!(\"loading {} ...\", path.as_path().display());\n-                    let events = load_root(path.as_path());\n-                    log::debug!(\"... loaded {}\", path.as_path().display());\n-                    (path, events)\n-                })\n-                .for_each(|it| output_sender.send(it))\n-        },\n-    )\n-}\n-\n-fn load_root(path: &Path) -> Vec<FileEvent> {\n-    let mut res = Vec::new();\n-    for entry in WalkDir::new(path) {\n-        let entry = match entry {\n-            Ok(entry) => entry,\n-            Err(e) => {\n-                log::warn!(\"watcher error: {}\", e);\n-                continue;\n-            }\n-        };\n-        if !entry.file_type().is_file() {\n-            continue;\n-        }\n-        let path = entry.path();\n-        if path.extension().and_then(|os| os.to_str()) != Some(\"rs\") {\n-            continue;\n-        }\n-        let text = match fs::read_to_string(path) {\n-            Ok(text) => text,\n-            Err(e) => {\n-                log::warn!(\"watcher error: {}\", e);\n-                continue;\n-            }\n-        };\n-        res.push(FileEvent {\n-            path: path.to_owned(),\n-            kind: FileEventKind::Add(text),\n-        })\n-    }\n-    res\n-}"}, {"sha": "be400bae9e7a42fc3b6437ccfc741de7f54d1914", "filename": "crates/ra_vfs/src/io.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=a5ef8ad05b7c1f7148c59814b55d641fd75aff75", "patch": "@@ -1,4 +1,5 @@\n use std::{\n+    fmt,\n     fs,\n     path::{Path, PathBuf},\n };\n@@ -20,6 +21,12 @@ pub struct TaskResult {\n     pub(crate) files: Vec<(RelativePathBuf, String)>,\n }\n \n+impl fmt::Debug for TaskResult {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(\"TaskResult { ... }\")\n+    }\n+}\n+\n pub(crate) type Worker = thread_worker::Worker<Task, TaskResult>;\n \n pub(crate) fn start() -> (Worker, WorkerHandle) {"}, {"sha": "dc980c3d2ae5b8a676e08877be9aeab34b7a8f41", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 47, "deletions": 6, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=a5ef8ad05b7c1f7148c59814b55d641fd75aff75", "patch": "@@ -15,6 +15,7 @@ mod arena;\n mod io;\n \n use std::{\n+    fmt,\n     mem,\n     thread,\n     cmp::Reverse,\n@@ -34,6 +35,8 @@ use crate::{\n     arena::{ArenaId, Arena},\n };\n \n+pub use crate::io::TaskResult as VfsTask;\n+\n /// `RootFilter` is a predicate that checks if a file can belong to a root. If\n /// several filters match a file (nested dirs), the most nested one wins.\n struct RootFilter {\n@@ -68,7 +71,7 @@ fn has_rs_extension(p: &Path) -> bool {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n-pub struct VfsRoot(u32);\n+pub struct VfsRoot(pub u32);\n \n impl ArenaId for VfsRoot {\n     fn from_u32(idx: u32) -> VfsRoot {\n@@ -80,7 +83,7 @@ impl ArenaId for VfsRoot {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n-pub struct VfsFile(u32);\n+pub struct VfsFile(pub u32);\n \n impl ArenaId for VfsFile {\n     fn from_u32(idx: u32) -> VfsFile {\n@@ -106,8 +109,14 @@ pub struct Vfs {\n     worker_handle: WorkerHandle,\n }\n \n+impl fmt::Debug for Vfs {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(\"Vfs { ... }\")\n+    }\n+}\n+\n impl Vfs {\n-    pub fn new(mut roots: Vec<PathBuf>) -> Vfs {\n+    pub fn new(mut roots: Vec<PathBuf>) -> (Vfs, Vec<VfsRoot>) {\n         let (worker, worker_handle) = io::start();\n \n         let mut res = Vfs {\n@@ -142,7 +151,32 @@ impl Vfs {\n             };\n             res.worker.inp.send(task);\n         }\n-        res\n+        let roots = res.roots.iter().map(|(id, _)| id).collect();\n+        (res, roots)\n+    }\n+\n+    pub fn path2file(&self, path: &Path) -> Option<VfsFile> {\n+        if let Some((_root, _path, Some(file))) = self.find_root(path) {\n+            return Some(file);\n+        }\n+        None\n+    }\n+\n+    pub fn file2path(&self, file: VfsFile) -> PathBuf {\n+        let rel_path = &self.files[file].path;\n+        let root_path = &self.roots[self.files[file].root].root;\n+        rel_path.to_path(root_path)\n+    }\n+\n+    pub fn file_for_path(&self, path: &Path) -> Option<VfsFile> {\n+        if let Some((_root, _path, Some(file))) = self.find_root(path) {\n+            return Some(file);\n+        }\n+        None\n+    }\n+\n+    pub fn load(&mut self, path: &Path) -> Option<VfsFile> {\n+        None\n     }\n \n     pub fn task_receiver(&self) -> &Receiver<io::TaskResult> {\n@@ -163,14 +197,17 @@ impl Vfs {\n         self.pending_changes.push(change);\n     }\n \n-    pub fn add_file_overlay(&mut self, path: &Path, text: String) {\n+    pub fn add_file_overlay(&mut self, path: &Path, text: String) -> Option<VfsFile> {\n+        let mut res = None;\n         if let Some((root, path, file)) = self.find_root(path) {\n             let text = Arc::new(text);\n             let change = if let Some(file) = file {\n+                res = Some(file);\n                 self.change_file(file, Arc::clone(&text));\n                 VfsChange::ChangeFile { file, text }\n             } else {\n                 let file = self.add_file(root, path.clone(), Arc::clone(&text));\n+                res = Some(file);\n                 VfsChange::AddFile {\n                     file,\n                     text,\n@@ -180,6 +217,7 @@ impl Vfs {\n             };\n             self.pending_changes.push(change);\n         }\n+        res\n     }\n \n     pub fn change_file_overlay(&mut self, path: &Path, new_text: String) {\n@@ -192,9 +230,11 @@ impl Vfs {\n         }\n     }\n \n-    pub fn remove_file_overlay(&mut self, path: &Path) {\n+    pub fn remove_file_overlay(&mut self, path: &Path) -> Option<VfsFile> {\n+        let mut res = None;\n         if let Some((root, path, file)) = self.find_root(path) {\n             let file = file.expect(\"can't remove a file which wasn't added\");\n+            res = Some(file);\n             let full_path = path.to_path(&self.roots[root].root);\n             let change = if let Ok(text) = fs::read_to_string(&full_path) {\n                 let text = Arc::new(text);\n@@ -206,6 +246,7 @@ impl Vfs {\n             };\n             self.pending_changes.push(change);\n         }\n+        res\n     }\n \n     pub fn commit_changes(&mut self) -> Vec<VfsChange> {"}, {"sha": "12e8bf17ed32603ab843d66a0e7f50edf3f09cf1", "filename": "crates/thread_worker/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fthread_worker%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ef8ad05b7c1f7148c59814b55d641fd75aff75/crates%2Fthread_worker%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fthread_worker%2Fsrc%2Flib.rs?ref=a5ef8ad05b7c1f7148c59814b55d641fd75aff75", "patch": "@@ -37,6 +37,9 @@ impl<I, O> Worker<I, O> {\n     pub fn send(&self, item: I) {\n         self.inp.send(item)\n     }\n+    pub fn recv(&self) -> Option<O> {\n+        self.out.recv()\n+    }\n }\n \n impl WorkerHandle {"}]}