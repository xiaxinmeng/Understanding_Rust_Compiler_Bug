{"sha": "ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "node_id": "C_kwDOAAsO6NoAKGJhMDNkYzcwZmQyMTkyNzM5MzRiNGZhMzI4MGNjYWY3YmIwZGNkOWI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-04T22:32:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-04T22:32:02Z"}, "message": "Auto merge of #8219 - camsteffen:macro-decoupling, r=llogiq\n\nNew macro utils\n\nchangelog: none\n\nSorry, this is a big one. A lot of interrelated changes and I wanted to put the new utils to use to make sure they are somewhat battle-tested. We may want to divide some of the lint-specific refactoring commits into batches for smaller reviewing tasks. I could also split into more PRs.\n\nIntroduces a bunch of new utils at `clippy_utils::macros::...`. Please read through the docs and give any feedback! I'm happy to introduce `MacroCall` and various functions to retrieve an instance. It feels like the missing puzzle piece. I'm also introducing `ExpnId` from rustc as \"useful for Clippy too\". `@rust-lang/clippy`\n\nFixes #7843 by not parsing every node of macro implementations, at least the major offenders.\n\nI probably want to get rid of `is_expn_of` at some point.", "tree": {"sha": "c726def7c8b6f61a8841af3bedf77f98adf13a37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c726def7c8b6f61a8841af3bedf77f98adf13a37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "html_url": "https://github.com/rust-lang/rust/commit/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e28e38e36134a2a7270e0f074f19fc6b096061d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e28e38e36134a2a7270e0f074f19fc6b096061d", "html_url": "https://github.com/rust-lang/rust/commit/0e28e38e36134a2a7270e0f074f19fc6b096061d"}, {"sha": "786f874c349b995ebed5e3d8f20db1cf65f20782", "url": "https://api.github.com/repos/rust-lang/rust/commits/786f874c349b995ebed5e3d8f20db1cf65f20782", "html_url": "https://github.com/rust-lang/rust/commit/786f874c349b995ebed5e3d8f20db1cf65f20782"}], "stats": {"total": 1733, "additions": 868, "deletions": 865}, "files": [{"sha": "c82837746bd5d1086ea8fbfb29a3f8b62b00abfd", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 25, "deletions": 95, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -1,12 +1,10 @@\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::higher;\n-use clippy_utils::source::snippet_opt;\n-use clippy_utils::{is_direct_expn_of, is_expn_of, match_panic_call, peel_blocks};\n-use if_chain::if_chain;\n-use rustc_hir::{Expr, ExprKind, UnOp};\n+use clippy_utils::macros::{find_assert_args, root_macro_call_first_node, PanicExpn};\n+use rustc_hir::Expr;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -36,107 +34,39 @@ declare_lint_pass!(AssertionsOnConstants => [ASSERTIONS_ON_CONSTANTS]);\n \n impl<'tcx> LateLintPass<'tcx> for AssertionsOnConstants {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        let lint_true = |is_debug: bool| {\n-            span_lint_and_help(\n-                cx,\n-                ASSERTIONS_ON_CONSTANTS,\n-                e.span,\n-                if is_debug {\n-                    \"`debug_assert!(true)` will be optimized out by the compiler\"\n-                } else {\n-                    \"`assert!(true)` will be optimized out by the compiler\"\n-                },\n-                None,\n-                \"remove it\",\n-            );\n+        let Some(macro_call) = root_macro_call_first_node(cx, e) else { return };\n+        let is_debug = match cx.tcx.get_diagnostic_name(macro_call.def_id) {\n+            Some(sym::debug_assert_macro) => true,\n+            Some(sym::assert_macro) => false,\n+            _ => return,\n         };\n-        let lint_false_without_message = || {\n+        let Some((condition, panic_expn)) = find_assert_args(cx, e, macro_call.expn) else { return };\n+        let Some((Constant::Bool(val), _)) = constant(cx, cx.typeck_results(), condition) else { return };\n+        if val {\n             span_lint_and_help(\n                 cx,\n                 ASSERTIONS_ON_CONSTANTS,\n-                e.span,\n-                \"`assert!(false)` should probably be replaced\",\n+                macro_call.span,\n+                &format!(\n+                    \"`{}!(true)` will be optimized out by the compiler\",\n+                    cx.tcx.item_name(macro_call.def_id)\n+                ),\n                 None,\n-                \"use `panic!()` or `unreachable!()`\",\n+                \"remove it\",\n             );\n-        };\n-        let lint_false_with_message = |panic_message: String| {\n+        } else if !is_debug {\n+            let (assert_arg, panic_arg) = match panic_expn {\n+                PanicExpn::Empty => (\"\", \"\"),\n+                _ => (\", ..\", \"..\"),\n+            };\n             span_lint_and_help(\n                 cx,\n                 ASSERTIONS_ON_CONSTANTS,\n-                e.span,\n-                &format!(\"`assert!(false, {})` should probably be replaced\", panic_message),\n+                macro_call.span,\n+                &format!(\"`assert!(false{})` should probably be replaced\", assert_arg),\n                 None,\n-                &format!(\"use `panic!({})` or `unreachable!({})`\", panic_message, panic_message),\n+                &format!(\"use `panic!({})` or `unreachable!({0})`\", panic_arg),\n             );\n-        };\n-\n-        if let Some(debug_assert_span) = is_expn_of(e.span, \"debug_assert\") {\n-            if debug_assert_span.from_expansion() {\n-                return;\n-            }\n-            if_chain! {\n-                if let ExprKind::Unary(_, lit) = e.kind;\n-                if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), lit);\n-                if is_true;\n-                then {\n-                    lint_true(true);\n-                }\n-            };\n-        } else if let Some(assert_span) = is_direct_expn_of(e.span, \"assert\") {\n-            if assert_span.from_expansion() {\n-                return;\n-            }\n-            if let Some(assert_match) = match_assert_with_message(cx, e) {\n-                match assert_match {\n-                    // matched assert but not message\n-                    AssertKind::WithoutMessage(false) => lint_false_without_message(),\n-                    AssertKind::WithoutMessage(true) | AssertKind::WithMessage(_, true) => lint_true(false),\n-                    AssertKind::WithMessage(panic_message, false) => lint_false_with_message(panic_message),\n-                };\n-            }\n-        }\n-    }\n-}\n-\n-/// Result of calling `match_assert_with_message`.\n-enum AssertKind {\n-    WithMessage(String, bool),\n-    WithoutMessage(bool),\n-}\n-\n-/// Check if the expression matches\n-///\n-/// ```rust,ignore\n-/// if !c {\n-///   {\n-///     ::std::rt::begin_panic(message, _)\n-///   }\n-/// }\n-/// ```\n-///\n-/// where `message` is any expression and `c` is a constant bool.\n-fn match_assert_with_message<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<AssertKind> {\n-    if_chain! {\n-        if let Some(higher::If { cond, then, .. }) = higher::If::hir(expr);\n-        if let ExprKind::Unary(UnOp::Not, expr) = cond.kind;\n-        // bind the first argument of the `assert!` macro\n-        if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), expr);\n-        let begin_panic_call = peel_blocks(then);\n-        // function call\n-        if let Some(arg) = match_panic_call(cx, begin_panic_call);\n-        // bind the second argument of the `assert!` macro if it exists\n-        if let panic_message = snippet_opt(cx, arg.span);\n-        // second argument of begin_panic is irrelevant\n-        // as is the second match arm\n-        then {\n-            // an empty message occurs when it was generated by the macro\n-            // (and not passed by the user)\n-            return panic_message\n-                .filter(|msg| !msg.is_empty())\n-                .map(|msg| AssertKind::WithMessage(msg, is_true))\n-                .or(Some(AssertKind::WithoutMessage(is_true)));\n         }\n     }\n-    None\n }"}, {"sha": "a58d12ddd6b4372278e4569126f2233d81183e28", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -1,9 +1,10 @@\n //! checks for attributes\n \n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n+use clippy_utils::macros::{is_panic, macro_backtrace};\n use clippy_utils::msrvs;\n use clippy_utils::source::{first_line_of_span, is_present_in_source, snippet_opt, without_block_comments};\n-use clippy_utils::{extract_msrv_attr, match_panic_def_id, meets_msrv};\n+use clippy_utils::{extract_msrv_attr, meets_msrv};\n use if_chain::if_chain;\n use rustc_ast::{AttrKind, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use rustc_errors::Applicability;\n@@ -443,20 +444,15 @@ fn is_relevant_block(cx: &LateContext<'_>, typeck_results: &ty::TypeckResults<'_\n }\n \n fn is_relevant_expr(cx: &LateContext<'_>, typeck_results: &ty::TypeckResults<'_>, expr: &Expr<'_>) -> bool {\n+    if macro_backtrace(expr.span).last().map_or(false, |macro_call| {\n+        is_panic(cx, macro_call.def_id) || cx.tcx.item_name(macro_call.def_id) == sym::unreachable\n+    }) {\n+        return false;\n+    }\n     match &expr.kind {\n         ExprKind::Block(block, _) => is_relevant_block(cx, typeck_results, block),\n         ExprKind::Ret(Some(e)) => is_relevant_expr(cx, typeck_results, e),\n         ExprKind::Ret(None) | ExprKind::Break(_, None) => false,\n-        ExprKind::Call(path_expr, _) => {\n-            if let ExprKind::Path(qpath) = &path_expr.kind {\n-                typeck_results\n-                    .qpath_res(qpath, path_expr.hir_id)\n-                    .opt_def_id()\n-                    .map_or(true, |fun_id| !match_panic_def_id(cx, fun_id))\n-            } else {\n-                true\n-            }\n-        },\n         _ => true,\n     }\n }"}, {"sha": "ea2cfb0bc0828412b9a90bc4e685a93fb7937427", "filename": "clippy_lints/src/bool_assert_comparison.rs", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fbool_assert_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fbool_assert_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbool_assert_comparison.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -1,4 +1,5 @@\n-use clippy_utils::{diagnostics::span_lint_and_sugg, higher, is_direct_expn_of, ty::implements_trait};\n+use clippy_utils::macros::{find_assert_eq_args, root_macro_call_first_node};\n+use clippy_utils::{diagnostics::span_lint_and_sugg, ty::implements_trait};\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, Lit};\n@@ -66,44 +67,40 @@ fn is_impl_not_trait_with_bool_out(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) ->\n \n impl<'tcx> LateLintPass<'tcx> for BoolAssertComparison {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let macros = [\"assert_eq\", \"debug_assert_eq\"];\n-        let inverted_macros = [\"assert_ne\", \"debug_assert_ne\"];\n-\n-        for mac in macros.iter().chain(inverted_macros.iter()) {\n-            if let Some(span) = is_direct_expn_of(expr.span, mac) {\n-                if let Some(args) = higher::extract_assert_macro_args(expr) {\n-                    if let [a, b, ..] = args[..] {\n-                        let nb_bool_args = usize::from(is_bool_lit(a)) + usize::from(is_bool_lit(b));\n-\n-                        if nb_bool_args != 1 {\n-                            // If there are two boolean arguments, we definitely don't understand\n-                            // what's going on, so better leave things as is...\n-                            //\n-                            // Or there is simply no boolean and then we can leave things as is!\n-                            return;\n-                        }\n-\n-                        if !is_impl_not_trait_with_bool_out(cx, a) || !is_impl_not_trait_with_bool_out(cx, b) {\n-                            // At this point the expression which is not a boolean\n-                            // literal does not implement Not trait with a bool output,\n-                            // so we cannot suggest to rewrite our code\n-                            return;\n-                        }\n+        let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return };\n+        let macro_name = cx.tcx.item_name(macro_call.def_id);\n+        if !matches!(\n+            macro_name.as_str(),\n+            \"assert_eq\" | \"debug_assert_eq\" | \"assert_ne\" | \"debug_assert_ne\"\n+        ) {\n+            return;\n+        }\n+        let Some ((a, b, _)) = find_assert_eq_args(cx, expr, macro_call.expn) else { return };\n+        if !(is_bool_lit(a) ^ is_bool_lit(b)) {\n+            // If there are two boolean arguments, we definitely don't understand\n+            // what's going on, so better leave things as is...\n+            //\n+            // Or there is simply no boolean and then we can leave things as is!\n+            return;\n+        }\n \n-                        let non_eq_mac = &mac[..mac.len() - 3];\n-                        span_lint_and_sugg(\n-                            cx,\n-                            BOOL_ASSERT_COMPARISON,\n-                            span,\n-                            &format!(\"used `{}!` with a literal bool\", mac),\n-                            \"replace it with\",\n-                            format!(\"{}!(..)\", non_eq_mac),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        return;\n-                    }\n-                }\n-            }\n+        if !is_impl_not_trait_with_bool_out(cx, a) || !is_impl_not_trait_with_bool_out(cx, b) {\n+            // At this point the expression which is not a boolean\n+            // literal does not implement Not trait with a bool output,\n+            // so we cannot suggest to rewrite our code\n+            return;\n         }\n+\n+        let macro_name = macro_name.as_str();\n+        let non_eq_mac = &macro_name[..macro_name.len() - 3];\n+        span_lint_and_sugg(\n+            cx,\n+            BOOL_ASSERT_COMPARISON,\n+            macro_call.span,\n+            &format!(\"used `{}!` with a literal bool\", macro_name),\n+            \"replace it with\",\n+            format!(\"{}!(..)\", non_eq_mac),\n+            Applicability::MaybeIncorrect,\n+        );\n     }\n }"}, {"sha": "9d4195e400dbd178b1489069c755286036aa616f", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -1,8 +1,9 @@\n use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_note, span_lint_and_then};\n+use clippy_utils::macros::{is_panic, root_macro_call_first_node};\n use clippy_utils::source::{first_line_of_span, snippet_with_applicability};\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n-use clippy_utils::{is_entrypoint_fn, is_expn_of, match_panic_def_id, method_chain_args, return_ty};\n+use clippy_utils::{is_entrypoint_fn, method_chain_args, return_ty};\n use if_chain::if_chain;\n use itertools::Itertools;\n use rustc_ast::ast::{Async, AttrKind, Attribute, Fn, FnRetTy, ItemKind};\n@@ -13,7 +14,7 @@ use rustc_errors::emitter::EmitterWriter;\n use rustc_errors::{Applicability, Handler, SuggestionStyle};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_hir::{AnonConst, Expr, ExprKind, QPath};\n+use rustc_hir::{AnonConst, Expr};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n@@ -805,24 +806,17 @@ impl<'a, 'tcx> Visitor<'tcx> for FindPanicUnwrap<'a, 'tcx> {\n             return;\n         }\n \n-        // check for `begin_panic`\n-        if_chain! {\n-            if let ExprKind::Call(func_expr, _) = expr.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, path)) = func_expr.kind;\n-            if let Some(path_def_id) = path.res.opt_def_id();\n-            if match_panic_def_id(self.cx, path_def_id);\n-            if is_expn_of(expr.span, \"unreachable\").is_none();\n-            if !is_expn_of_debug_assertions(expr.span);\n-            then {\n-                self.panic_span = Some(expr.span);\n+        if let Some(macro_call) = root_macro_call_first_node(self.cx, expr) {\n+            if is_panic(self.cx, macro_call.def_id)\n+                || matches!(\n+                    self.cx.tcx.item_name(macro_call.def_id).as_str(),\n+                    \"assert\" | \"assert_eq\" | \"assert_ne\" | \"todo\"\n+                )\n+            {\n+                self.panic_span = Some(macro_call.span);\n             }\n         }\n \n-        // check for `assert_eq` or `assert_ne`\n-        if is_expn_of(expr.span, \"assert_eq\").is_some() || is_expn_of(expr.span, \"assert_ne\").is_some() {\n-            self.panic_span = Some(expr.span);\n-        }\n-\n         // check for `unwrap`\n         if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n             let receiver_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n@@ -844,8 +838,3 @@ impl<'a, 'tcx> Visitor<'tcx> for FindPanicUnwrap<'a, 'tcx> {\n         NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n     }\n }\n-\n-fn is_expn_of_debug_assertions(span: Span) -> bool {\n-    const MACRO_NAMES: &[&str] = &[\"debug_assert\", \"debug_assert_eq\", \"debug_assert_ne\"];\n-    MACRO_NAMES.iter().any(|name| is_expn_of(span, name).is_some())\n-}"}, {"sha": "df75b815436b896bd20160303ebe983d8a79b5d0", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -1,10 +1,11 @@\n use clippy_utils::diagnostics::{multispan_sugg, span_lint, span_lint_and_then};\n+use clippy_utils::macros::{find_assert_eq_args, first_node_macro_backtrace};\n use clippy_utils::source::snippet;\n use clippy_utils::ty::{implements_trait, is_copy};\n-use clippy_utils::{ast_utils::is_useless_with_eq_exprs, eq_expr_value, higher, is_expn_of, is_in_test_function};\n+use clippy_utils::{ast_utils::is_useless_with_eq_exprs, eq_expr_value, is_in_test_function};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, StmtKind};\n+use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -68,32 +69,26 @@ declare_clippy_lint! {\n \n declare_lint_pass!(EqOp => [EQ_OP, OP_REF]);\n \n-const ASSERT_MACRO_NAMES: [&str; 4] = [\"assert_eq\", \"assert_ne\", \"debug_assert_eq\", \"debug_assert_ne\"];\n-\n impl<'tcx> LateLintPass<'tcx> for EqOp {\n     #[allow(clippy::similar_names, clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let ExprKind::Block(block, _) = e.kind {\n-            for stmt in block.stmts {\n-                for amn in &ASSERT_MACRO_NAMES {\n-                    if_chain! {\n-                        if is_expn_of(stmt.span, amn).is_some();\n-                        if let StmtKind::Semi(matchexpr) = stmt.kind;\n-                        if let Some(macro_args) = higher::extract_assert_macro_args(matchexpr);\n-                        if macro_args.len() == 2;\n-                        let (lhs, rhs) = (macro_args[0], macro_args[1]);\n-                        if eq_expr_value(cx, lhs, rhs);\n-                        if !is_in_test_function(cx.tcx, e.hir_id);\n-                        then {\n-                            span_lint(\n-                                cx,\n-                                EQ_OP,\n-                                lhs.span.to(rhs.span),\n-                                &format!(\"identical args used in this `{}!` macro call\", amn),\n-                            );\n-                        }\n-                    }\n-                }\n+        if_chain! {\n+            if let Some((macro_call, macro_name)) = first_node_macro_backtrace(cx, e).find_map(|macro_call| {\n+                let name = cx.tcx.item_name(macro_call.def_id);\n+                matches!(name.as_str(), \"assert_eq\" | \"assert_ne\" | \"debug_assert_eq\" | \"debug_assert_ne\")\n+                    .then(|| (macro_call, name))\n+            });\n+            if let Some((lhs, rhs, _)) = find_assert_eq_args(cx, e, macro_call.expn);\n+            if eq_expr_value(cx, lhs, rhs);\n+            if macro_call.is_local();\n+            if !is_in_test_function(cx.tcx, e.hir_id);\n+            then {\n+                span_lint(\n+                    cx,\n+                    EQ_OP,\n+                    lhs.span.to(rhs.span),\n+                    &format!(\"identical args used in this `{}!` macro call\", macro_name),\n+                );\n             }\n         }\n         if let ExprKind::Binary(op, left, right) = e.kind {"}, {"sha": "98e5234e0aa94640a928d5eff4814b8c9a465307", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n-use clippy_utils::higher::FormatArgsExpn;\n+use clippy_utils::macros::FormatArgsExpn;\n use clippy_utils::{is_expn_of, match_function_call, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -48,7 +48,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n             } else {\n                 None\n             };\n-            if let Some(format_args) = FormatArgsExpn::parse(write_arg);\n+            if let Some(format_args) = FormatArgsExpn::parse(cx, write_arg);\n             then {\n                 let calling_macro =\n                     // ordering is important here, since `writeln!` uses `write!` internally\n@@ -80,7 +80,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n                     )\n                 };\n                 let msg = format!(\"use of `{}.unwrap()`\", used);\n-                if let [write_output] = *format_args.format_string_symbols {\n+                if let [write_output] = *format_args.format_string_parts {\n                     let mut write_output = write_output.to_string();\n                     if write_output.ends_with('\\n') {\n                         write_output.pop();"}, {"sha": "02f1baf27fae81cc184cf64a5fdfe723d70c84cc", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -1,6 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::macros::{is_panic, root_macro_call_first_node};\n+use clippy_utils::method_chain_args;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_expn_of, match_panic_def_id, method_chain_args};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n@@ -68,7 +69,7 @@ impl<'tcx> LateLintPass<'tcx> for FallibleImplFrom {\n \n fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[hir::ImplItemRef]) {\n     use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-    use rustc_hir::{Expr, ExprKind, ImplItemKind, QPath};\n+    use rustc_hir::{Expr, ImplItemKind};\n \n     struct FindPanicUnwrap<'a, 'tcx> {\n         lcx: &'a LateContext<'tcx>,\n@@ -80,14 +81,8 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n         type Map = Map<'tcx>;\n \n         fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-            // check for `begin_panic`\n-            if_chain! {\n-                if let ExprKind::Call(func_expr, _) = expr.kind;\n-                if let ExprKind::Path(QPath::Resolved(_, path)) = func_expr.kind;\n-                if let Some(path_def_id) = path.res.opt_def_id();\n-                if match_panic_def_id(self.lcx, path_def_id);\n-                if is_expn_of(expr.span, \"unreachable\").is_none();\n-                then {\n+            if let Some(macro_call) = root_macro_call_first_node(self.lcx, expr) {\n+                if is_panic(self.lcx, macro_call.def_id) {\n                     self.result.push(expr.span);\n                 }\n             }"}, {"sha": "688d8f8630f3fa38b84e55dd4489309b62ba2f73", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher::FormatExpn;\n+use clippy_utils::macros::{root_macro_call_first_node, FormatArgsExpn};\n use clippy_utils::source::{snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use if_chain::if_chain;\n@@ -43,38 +43,41 @@ declare_lint_pass!(UselessFormat => [USELESS_FORMAT]);\n \n impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let FormatExpn { call_site, format_args } = match FormatExpn::parse(expr) {\n-            Some(e) if !e.call_site.from_expansion() => e,\n-            _ => return,\n+        let (format_args, call_site) = if_chain! {\n+            if let Some(macro_call) = root_macro_call_first_node(cx, expr);\n+            if cx.tcx.is_diagnostic_item(sym::format_macro, macro_call.def_id);\n+            if let Some(format_args) = FormatArgsExpn::find_nested(cx, expr, macro_call.expn);\n+            then {\n+                (format_args, macro_call.span)\n+            } else {\n+                return\n+            }\n         };\n \n         let mut applicability = Applicability::MachineApplicable;\n         if format_args.value_args.is_empty() {\n-            if format_args.format_string_parts.is_empty() {\n-                span_useless_format_empty(cx, call_site, \"String::new()\".to_owned(), applicability);\n-            } else {\n-                if_chain! {\n-                    if let [e] = &*format_args.format_string_parts;\n-                    if let ExprKind::Lit(lit) = &e.kind;\n-                    if let Some(s_src) = snippet_opt(cx, lit.span);\n-                    then {\n+            match *format_args.format_string_parts {\n+                [] => span_useless_format_empty(cx, call_site, \"String::new()\".to_owned(), applicability),\n+                [_] => {\n+                    if let Some(s_src) = snippet_opt(cx, format_args.format_string_span) {\n                         // Simulate macro expansion, converting {{ and }} to { and }.\n                         let s_expand = s_src.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n                         let sugg = format!(\"{}.to_string()\", s_expand);\n                         span_useless_format(cx, call_site, sugg, applicability);\n                     }\n-                }\n+                },\n+                [..] => {},\n             }\n         } else if let [value] = *format_args.value_args {\n             if_chain! {\n-                if format_args.format_string_symbols == [kw::Empty];\n+                if format_args.format_string_parts == [kw::Empty];\n                 if match cx.typeck_results().expr_ty(value).peel_refs().kind() {\n                     ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(sym::String, adt.did),\n                     ty::Str => true,\n                     _ => false,\n                 };\n                 if let Some(args) = format_args.args();\n-                if args.iter().all(|arg| arg.is_display() && !arg.has_string_formatting());\n+                if args.iter().all(|arg| arg.format_trait == sym::Display && !arg.has_string_formatting());\n                 then {\n                     let is_new_string = match value.kind {\n                         ExprKind::Binary(..) => true,"}, {"sha": "ae423d799d71a3defb511ef01a02e13c1ea84241", "filename": "clippy_lints/src/format_args.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_args.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::higher::{FormatArgsArg, FormatArgsExpn, FormatExpn};\n+use clippy_utils::macros::{FormatArgsArg, FormatArgsExpn};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::implements_trait;\n use clippy_utils::{is_diag_trait_item, match_def_path, paths};\n@@ -83,7 +83,7 @@ const FORMAT_MACRO_DIAG_ITEMS: &[Symbol] = &[sym::format_macro, sym::std_panic_m\n impl<'tcx> LateLintPass<'tcx> for FormatArgs {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         if_chain! {\n-            if let Some(format_args) = FormatArgsExpn::parse(expr);\n+            if let Some(format_args) = FormatArgsExpn::parse(cx, expr);\n             let expr_expn_data = expr.span.ctxt().outer_expn_data();\n             let outermost_expn_data = outermost_expn_data(expr_expn_data);\n             if let Some(macro_def_id) = outermost_expn_data.macro_def_id;\n@@ -97,7 +97,7 @@ impl<'tcx> LateLintPass<'tcx> for FormatArgs {\n             if let Some(args) = format_args.args();\n             then {\n                 for (i, arg) in args.iter().enumerate() {\n-                    if !arg.is_display() {\n+                    if arg.format_trait != sym::Display {\n                         continue;\n                     }\n                     if arg.has_string_formatting() {\n@@ -106,8 +106,8 @@ impl<'tcx> LateLintPass<'tcx> for FormatArgs {\n                     if is_aliased(&args, i) {\n                         continue;\n                     }\n-                    check_format_in_format_args(cx, outermost_expn_data.call_site, name, arg);\n-                    check_to_string_in_format_args(cx, name, arg);\n+                    check_format_in_format_args(cx, outermost_expn_data.call_site, name, arg.value);\n+                    check_to_string_in_format_args(cx, name, arg.value);\n                 }\n             }\n         }\n@@ -122,30 +122,31 @@ fn outermost_expn_data(expn_data: ExpnData) -> ExpnData {\n     }\n }\n \n-fn check_format_in_format_args(cx: &LateContext<'_>, call_site: Span, name: Symbol, arg: &FormatArgsArg<'_>) {\n-    if_chain! {\n-        if FormatExpn::parse(arg.value).is_some();\n-        if !arg.value.span.ctxt().outer_expn_data().call_site.from_expansion();\n-        then {\n-            span_lint_and_then(\n-                cx,\n-                FORMAT_IN_FORMAT_ARGS,\n-                call_site,\n-                &format!(\"`format!` in `{}!` args\", name),\n-                |diag| {\n-                    diag.help(&format!(\n-                        \"combine the `format!(..)` arguments with the outer `{}!(..)` call\",\n-                        name\n-                    ));\n-                    diag.help(\"or consider changing `format!` to `format_args!`\");\n-                },\n-            );\n-        }\n+fn check_format_in_format_args(cx: &LateContext<'_>, call_site: Span, name: Symbol, arg: &Expr<'_>) {\n+    let expn_data = arg.span.ctxt().outer_expn_data();\n+    if expn_data.call_site.from_expansion() {\n+        return;\n+    }\n+    let Some(mac_id) = expn_data.macro_def_id else { return };\n+    if !cx.tcx.is_diagnostic_item(sym::format_macro, mac_id) {\n+        return;\n     }\n+    span_lint_and_then(\n+        cx,\n+        FORMAT_IN_FORMAT_ARGS,\n+        call_site,\n+        &format!(\"`format!` in `{}!` args\", name),\n+        |diag| {\n+            diag.help(&format!(\n+                \"combine the `format!(..)` arguments with the outer `{}!(..)` call\",\n+                name\n+            ));\n+            diag.help(\"or consider changing `format!` to `format_args!`\");\n+        },\n+    );\n }\n \n-fn check_to_string_in_format_args<'tcx>(cx: &LateContext<'tcx>, name: Symbol, arg: &FormatArgsArg<'tcx>) {\n-    let value = arg.value;\n+fn check_to_string_in_format_args(cx: &LateContext<'_>, name: Symbol, value: &Expr<'_>) {\n     if_chain! {\n         if !value.span.from_expansion();\n         if let ExprKind::MethodCall(_, _, [receiver], _) = value.kind;"}, {"sha": "e3a34b22e325243b1fddbee9ca290275bf55e41e", "filename": "clippy_lints/src/manual_assert.rs", "status": "modified", "additions": 19, "deletions": 49, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fmanual_assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fmanual_assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_assert.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -1,11 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher::PanicExpn;\n+use clippy_utils::macros::{root_macro_call, FormatArgsExpn};\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{is_expn_of, sugg};\n+use clippy_utils::{peel_blocks_with_stmt, sugg};\n use rustc_errors::Applicability;\n-use rustc_hir::{Block, Expr, ExprKind, StmtKind, UnOp};\n+use rustc_hir::{Expr, ExprKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -35,64 +36,33 @@ declare_clippy_lint! {\n declare_lint_pass!(ManualAssert => [MANUAL_ASSERT]);\n \n impl LateLintPass<'_> for ManualAssert {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n         if_chain! {\n-            if let Expr {\n-                kind: ExprKind:: If(cond, Expr {\n-                    kind: ExprKind::Block(\n-                        Block {\n-                            stmts: [stmt],\n-                            ..\n-                        },\n-                        _),\n-                    ..\n-                }, None),\n-                ..\n-            } = &expr;\n-            if is_expn_of(stmt.span, \"panic\").is_some();\n+            if let ExprKind::If(cond, then, None) = expr.kind;\n             if !matches!(cond.kind, ExprKind::Let(_));\n-            if let StmtKind::Semi(semi) = stmt.kind;\n+            if !expr.span.from_expansion();\n+            let then = peel_blocks_with_stmt(then);\n+            if let Some(macro_call) = root_macro_call(then.span);\n+            if cx.tcx.item_name(macro_call.def_id) == sym::panic;\n             if !cx.tcx.sess.source_map().is_multiline(cond.span);\n-\n+            if let Some(format_args) = FormatArgsExpn::find_nested(cx, then, macro_call.expn);\n             then {\n-                let call = if_chain! {\n-                    if let ExprKind::Block(block, _) = semi.kind;\n-                    if let Some(init) = block.expr;\n-                    then {\n-                        init\n-                    } else {\n-                        semi\n-                    }\n-                };\n-                let span = if let Some(panic_expn) = PanicExpn::parse(call) {\n-                    match *panic_expn.format_args.value_args {\n-                        [] => panic_expn.format_args.format_string_span,\n-                        [.., last] => panic_expn.format_args.format_string_span.to(last.span),\n-                    }\n-                } else if let ExprKind::Call(_, [format_args]) = call.kind {\n-                    format_args.span\n-                } else {\n-                    return\n-                };\n                 let mut applicability = Applicability::MachineApplicable;\n-                let sugg = snippet_with_applicability(cx, span, \"..\", &mut applicability);\n-                let cond_sugg = if let ExprKind::DropTemps(e, ..) = cond.kind {\n-                    if let Expr{kind: ExprKind::Unary(UnOp::Not, not_expr), ..} = e {\n-                         sugg::Sugg::hir_with_applicability(cx, not_expr, \"..\", &mut applicability).maybe_par().to_string()\n-                    } else {\n-                       format!(\"!{}\", sugg::Sugg::hir_with_applicability(cx, e, \"..\", &mut applicability).maybe_par())\n-                    }\n-                } else {\n-                   format!(\"!{}\", sugg::Sugg::hir_with_applicability(cx, cond, \"..\", &mut applicability).maybe_par())\n+                let format_args_snip = snippet_with_applicability(cx, format_args.inputs_span(), \"..\", &mut applicability);\n+                let cond = cond.peel_drop_temps();\n+                let (cond, not) = match cond.kind {\n+                    ExprKind::Unary(UnOp::Not, e) => (e, \"\"),\n+                    _ => (cond, \"!\"),\n                 };\n-\n+                let cond_sugg = sugg::Sugg::hir_with_applicability(cx, cond, \"..\", &mut applicability).maybe_par();\n+                let sugg = format!(\"assert!({not}{cond_sugg}, {format_args_snip});\");\n                 span_lint_and_sugg(\n                     cx,\n                     MANUAL_ASSERT,\n                     expr.span,\n                     \"only a `panic!` in `if`-then statement\",\n                     \"try\",\n-                    format!(\"assert!({}, {});\", cond_sugg, sugg),\n+                    sugg,\n                     Applicability::MachineApplicable,\n                 );\n             }"}, {"sha": "0d693499bc67f3882efd5a8ee02471a4bab22046", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -2,16 +2,17 @@ use clippy_utils::consts::{constant, constant_full_int, miri_to_const, FullInt};\n use clippy_utils::diagnostics::{\n     multispan_sugg, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n };\n-use clippy_utils::higher;\n+use clippy_utils::macros::{is_panic, root_macro_call};\n use clippy_utils::source::{expr_block, indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n use clippy_utils::visitors::is_local_used;\n use clippy_utils::{\n-    get_parent_expr, is_expn_of, is_lang_ctor, is_lint_allowed, is_refutable, is_unit_expr, is_wild, meets_msrv, msrvs,\n+    get_parent_expr, is_lang_ctor, is_lint_allowed, is_refutable, is_unit_expr, is_wild, meets_msrv, msrvs,\n     path_to_local, path_to_local_id, peel_blocks, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns,\n     strip_pat_refs,\n };\n+use clippy_utils::{higher, peel_blocks_with_stmt};\n use clippy_utils::{paths, search_same, SpanlessEq, SpanlessHash};\n use core::iter::{once, ExactSizeIterator};\n use if_chain::if_chain;\n@@ -974,7 +975,8 @@ fn check_wild_err_arm<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm\n                     }\n                     if_chain! {\n                         if matching_wild;\n-                        if is_panic_call(arm.body);\n+                        if let Some(macro_call) = root_macro_call(peel_blocks_with_stmt(arm.body).span);\n+                        if is_panic(cx, macro_call.def_id);\n                         then {\n                             // `Err(_)` or `Err(_e)` arm with `panic!` found\n                             span_lint_and_note(cx,\n@@ -1179,22 +1181,6 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n     };\n }\n \n-// If the block contains only a `panic!` macro (as expression or statement)\n-fn is_panic_call(expr: &Expr<'_>) -> bool {\n-    // Unwrap any wrapping blocks\n-    let span = if let ExprKind::Block(block, _) = expr.kind {\n-        match (&block.expr, block.stmts.len(), block.stmts.first()) {\n-            (&Some(exp), 0, _) => exp.span,\n-            (&None, 1, Some(stmt)) => stmt.span,\n-            _ => return false,\n-        }\n-    } else {\n-        expr.span\n-    };\n-\n-    is_expn_of(span, \"panic\").is_some() && is_expn_of(span, \"unreachable\").is_none()\n-}\n-\n fn check_match_ref_pats<'a, 'b, I>(cx: &LateContext<'_>, ex: &Expr<'_>, pats: I, expr: &Expr<'_>)\n where\n     'b: 'a,"}, {"sha": "866eaff5b1d76134182c8617775ae1beebb1d059", "filename": "clippy_lints/src/methods/expect_fun_call.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher::FormatExpn;\n+use clippy_utils::macros::{root_macro_call_first_node, FormatArgsExpn};\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n use rustc_errors::Applicability;\n@@ -14,7 +14,13 @@ use super::EXPECT_FUN_CALL;\n \n /// Checks for the `EXPECT_FUN_CALL` lint.\n #[allow(clippy::too_many_lines)]\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_span: Span, name: &str, args: &[hir::Expr<'_>]) {\n+pub(super) fn check(\n+    cx: &LateContext<'tcx>,\n+    expr: &hir::Expr<'_>,\n+    method_span: Span,\n+    name: &str,\n+    args: &'tcx [hir::Expr<'tcx>],\n+) {\n     // Strip `&`, `as_ref()` and `as_str()` off `arg` until we're left with either a `String` or\n     // `&str`\n     fn get_arg_root<'a>(cx: &LateContext<'_>, arg: &'a hir::Expr<'a>) -> &'a hir::Expr<'a> {\n@@ -128,11 +134,12 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_span: Spa\n     let mut applicability = Applicability::MachineApplicable;\n \n     //Special handling for `format!` as arg_root\n-    if let Some(format_expn) = FormatExpn::parse(arg_root) {\n-        let span = match *format_expn.format_args.value_args {\n-            [] => format_expn.format_args.format_string_span,\n-            [.., last] => format_expn.format_args.format_string_span.to(last.span),\n-        };\n+    if let Some(macro_call) = root_macro_call_first_node(cx, arg_root) {\n+        if !cx.tcx.is_diagnostic_item(sym::format_macro, macro_call.def_id) {\n+            return;\n+        }\n+        let Some(format_args) = FormatArgsExpn::find_nested(cx, arg_root, macro_call.expn) else { return };\n+        let span = format_args.inputs_span();\n         let sugg = snippet_with_applicability(cx, span, \"..\", &mut applicability);\n         span_lint_and_sugg(\n             cx,"}, {"sha": "49d4b3a1850fe5e2fae11aa11a4287e8abf9ce58", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{higher, is_direct_expn_of};\n+use clippy_utils::macros::{find_assert_eq_args, root_macro_call_first_node};\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::{BorrowKind, Expr, ExprKind, MatchSource, Mutability};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -34,26 +34,30 @@ declare_clippy_lint! {\n \n declare_lint_pass!(DebugAssertWithMutCall => [DEBUG_ASSERT_WITH_MUT_CALL]);\n \n-const DEBUG_MACRO_NAMES: [&str; 3] = [\"debug_assert\", \"debug_assert_eq\", \"debug_assert_ne\"];\n-\n impl<'tcx> LateLintPass<'tcx> for DebugAssertWithMutCall {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        for dmn in &DEBUG_MACRO_NAMES {\n-            if is_direct_expn_of(e.span, dmn).is_some() {\n-                if let Some(macro_args) = higher::extract_assert_macro_args(e) {\n-                    for arg in macro_args {\n-                        let mut visitor = MutArgVisitor::new(cx);\n-                        visitor.visit_expr(arg);\n-                        if let Some(span) = visitor.expr_span() {\n-                            span_lint(\n-                                cx,\n-                                DEBUG_ASSERT_WITH_MUT_CALL,\n-                                span,\n-                                &format!(\"do not call a function with mutable arguments inside of `{}!`\", dmn),\n-                            );\n-                        }\n-                    }\n-                }\n+        let Some(macro_call) = root_macro_call_first_node(cx, e) else { return };\n+        let macro_name = cx.tcx.item_name(macro_call.def_id);\n+        if !matches!(\n+            macro_name.as_str(),\n+            \"debug_assert\" | \"debug_assert_eq\" | \"debug_assert_ne\"\n+        ) {\n+            return;\n+        }\n+        let Some((lhs, rhs, _)) = find_assert_eq_args(cx, e, macro_call.expn) else { return };\n+        for arg in [lhs, rhs] {\n+            let mut visitor = MutArgVisitor::new(cx);\n+            visitor.visit_expr(arg);\n+            if let Some(span) = visitor.expr_span() {\n+                span_lint(\n+                    cx,\n+                    DEBUG_ASSERT_WITH_MUT_CALL,\n+                    span,\n+                    &format!(\n+                        \"do not call a function with mutable arguments inside of `{}!`\",\n+                        macro_name\n+                    ),\n+                );\n             }\n         }\n     }"}, {"sha": "b7a56970b335520aac10736b4ca9f9f660a2fe93", "filename": "clippy_lints/src/panic_in_result_fn.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -1,8 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::macros::root_macro_call_first_node;\n+use clippy_utils::return_ty;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{find_macro_calls, is_expn_of, return_ty};\n+use clippy_utils::visitors::expr_visitor_no_bodies;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::FnKind;\n+use rustc_hir::intravisit::{FnKind, Visitor};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n@@ -55,19 +57,19 @@ impl<'tcx> LateLintPass<'tcx> for PanicInResultFn {\n }\n \n fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, body: &'tcx hir::Body<'tcx>) {\n-    let mut panics = find_macro_calls(\n-        &[\n-            \"unimplemented\",\n-            \"unreachable\",\n-            \"panic\",\n-            \"todo\",\n-            \"assert\",\n-            \"assert_eq\",\n-            \"assert_ne\",\n-        ],\n-        body,\n-    );\n-    panics.retain(|span| is_expn_of(*span, \"debug_assert\").is_none());\n+    let mut panics = Vec::new();\n+    expr_visitor_no_bodies(|expr| {\n+        let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return true };\n+        if matches!(\n+            &*cx.tcx.item_name(macro_call.def_id).as_str(),\n+            \"unimplemented\" | \"unreachable\" | \"panic\" | \"todo\" | \"assert\" | \"assert_eq\" | \"assert_ne\"\n+        ) {\n+            panics.push(macro_call.span);\n+            return false;\n+        }\n+        true\n+    })\n+    .visit_expr(&body.value);\n     if !panics.is_empty() {\n         span_lint_and_then(\n             cx,"}, {"sha": "6ef6b9a20aa4b185211eaa6c96c48dae49d11af0", "filename": "clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -1,10 +1,8 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{is_expn_of, match_panic_call};\n-use if_chain::if_chain;\n+use clippy_utils::macros::{is_panic, root_macro_call_first_node};\n use rustc_hir::Expr;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::Span;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -78,37 +76,37 @@ declare_lint_pass!(PanicUnimplemented => [UNIMPLEMENTED, UNREACHABLE, TODO, PANI\n \n impl<'tcx> LateLintPass<'tcx> for PanicUnimplemented {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if match_panic_call(cx, expr).is_some()\n-            && (is_expn_of(expr.span, \"debug_assert\").is_none() && is_expn_of(expr.span, \"assert\").is_none())\n-        {\n-            let span = get_outer_span(expr);\n-            if is_expn_of(expr.span, \"unimplemented\").is_some() {\n+        let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return };\n+        if is_panic(cx, macro_call.def_id) {\n+            span_lint(\n+                cx,\n+                PANIC,\n+                macro_call.span,\n+                \"`panic` should not be present in production code\",\n+            );\n+            return;\n+        }\n+        match cx.tcx.item_name(macro_call.def_id).as_str() {\n+            \"todo\" => {\n+                span_lint(\n+                    cx,\n+                    TODO,\n+                    macro_call.span,\n+                    \"`todo` should not be present in production code\",\n+                );\n+            },\n+            \"unimplemented\" => {\n                 span_lint(\n                     cx,\n                     UNIMPLEMENTED,\n-                    span,\n+                    macro_call.span,\n                     \"`unimplemented` should not be present in production code\",\n                 );\n-            } else if is_expn_of(expr.span, \"todo\").is_some() {\n-                span_lint(cx, TODO, span, \"`todo` should not be present in production code\");\n-            } else if is_expn_of(expr.span, \"unreachable\").is_some() {\n-                span_lint(cx, UNREACHABLE, span, \"usage of the `unreachable!` macro\");\n-            } else if is_expn_of(expr.span, \"panic\").is_some() {\n-                span_lint(cx, PANIC, span, \"`panic` should not be present in production code\");\n-            }\n-        }\n-    }\n-}\n-\n-fn get_outer_span(expr: &Expr<'_>) -> Span {\n-    if_chain! {\n-        if expr.span.from_expansion();\n-        let first = expr.span.ctxt().outer_expn_data().call_site;\n-        if first.from_expansion();\n-        then {\n-            first.ctxt().outer_expn_data().call_site\n-        } else {\n-            expr.span\n+            },\n+            \"unreachable\" => {\n+                span_lint(cx, UNREACHABLE, macro_call.span, \"usage of the `unreachable!` macro\");\n+            },\n+            _ => {},\n         }\n     }\n }"}, {"sha": "1dd8895ebd0763be6dd77e2da8f7f34fd8566030", "filename": "clippy_lints/src/unit_types/unit_cmp.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -1,35 +1,29 @@\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::macros::{find_assert_eq_args, root_macro_call_first_node};\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::LateContext;\n-use rustc_span::hygiene::{ExpnKind, MacroKind};\n \n use super::UNIT_CMP;\n \n pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if expr.span.from_expansion() {\n-        if let Some(callee) = expr.span.source_callee() {\n-            if let ExpnKind::Macro(MacroKind::Bang, symbol) = callee.kind {\n-                if let ExprKind::Binary(ref cmp, left, _) = expr.kind {\n-                    let op = cmp.node;\n-                    if op.is_comparison() && cx.typeck_results().expr_ty(left).is_unit() {\n-                        let result = match symbol.as_str() {\n-                            \"assert_eq\" | \"debug_assert_eq\" => \"succeed\",\n-                            \"assert_ne\" | \"debug_assert_ne\" => \"fail\",\n-                            _ => return,\n-                        };\n-                        span_lint(\n-                            cx,\n-                            UNIT_CMP,\n-                            expr.span,\n-                            &format!(\n-                                \"`{}` of unit values detected. This will always {}\",\n-                                symbol.as_str(),\n-                                result\n-                            ),\n-                        );\n-                    }\n-                }\n+        if let Some(macro_call) = root_macro_call_first_node(cx, expr) {\n+            let macro_name = cx.tcx.item_name(macro_call.def_id);\n+            let result = match macro_name.as_str() {\n+                \"assert_eq\" | \"debug_assert_eq\" => \"succeed\",\n+                \"assert_ne\" | \"debug_assert_ne\" => \"fail\",\n+                _ => return,\n+            };\n+            let Some ((left, _, _)) = find_assert_eq_args(cx, expr, macro_call.expn) else { return };\n+            if !cx.typeck_results().expr_ty(left).is_unit() {\n+                return;\n             }\n+            span_lint(\n+                cx,\n+                UNIT_CMP,\n+                macro_call.span,\n+                &format!(\"`{}` of unit values detected. This will always {}\", macro_name, result),\n+            );\n         }\n         return;\n     }"}, {"sha": "165004e5b413bc098440a7316dbd05d377145394", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n+use clippy_utils::macros::root_macro_call_first_node;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::match_type;\n use clippy_utils::{\n@@ -410,9 +411,13 @@ impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n                 }\n                 self.declared_lints.insert(item.ident.name, item.span);\n             }\n-        } else if is_expn_of(item.span, \"impl_lint_pass\").is_some()\n-            || is_expn_of(item.span, \"declare_lint_pass\").is_some()\n-        {\n+        } else if let Some(macro_call) = root_macro_call_first_node(cx, item) {\n+            if !matches!(\n+                &*cx.tcx.item_name(macro_call.def_id).as_str(),\n+                \"impl_lint_pass\" | \"declare_lint_pass\"\n+            ) {\n+                return;\n+            }\n             if let hir::ItemKind::Impl(hir::Impl {\n                 of_trait: None,\n                 items: impl_item_refs,"}, {"sha": "af1e2eb4dd11f1e09a51021e64e3d6528d2a9da1", "filename": "clippy_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2FCargo.toml?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -5,6 +5,7 @@ edition = \"2021\"\n publish = false\n \n [dependencies]\n+arrayvec = { version = \"0.7\", default-features = false }\n if_chain = \"1.0\"\n rustc-semver = \"1.1\"\n "}, {"sha": "3d3180521ab7a2fcb533727a1ed8a43a84971cf7", "filename": "clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -5,7 +5,6 @@\n #![allow(clippy::similar_names, clippy::wildcard_imports, clippy::enum_glob_use)]\n \n use crate::{both, over};\n-use if_chain::if_chain;\n use rustc_ast::ptr::P;\n use rustc_ast::{self as ast, *};\n use rustc_span::symbol::Ident;\n@@ -679,34 +678,3 @@ pub fn eq_mac_args(l: &MacArgs, r: &MacArgs) -> bool {\n         _ => false,\n     }\n }\n-\n-/// Extract args from an assert-like macro.\n-///\n-/// Currently working with:\n-/// - `assert_eq!` and `assert_ne!`\n-/// - `debug_assert_eq!` and `debug_assert_ne!`\n-///\n-/// For example:\n-///\n-/// `debug_assert_eq!(a, b)` will return Some([a, b])\n-pub fn extract_assert_macro_args(mut expr: &Expr) -> Option<[&Expr; 2]> {\n-    if_chain! {\n-        if let ExprKind::If(_, ref block, _) = expr.kind;\n-        if let StmtKind::Semi(ref e) = block.stmts.get(0)?.kind;\n-        then {\n-            expr = e;\n-        }\n-    }\n-    if_chain! {\n-        if let ExprKind::Block(ref block, _) = expr.kind;\n-        if let StmtKind::Expr(ref expr) = block.stmts.get(0)?.kind;\n-        if let ExprKind::Match(ref match_expr, _) = expr.kind;\n-        if let ExprKind::Tup(ref tup) = match_expr.kind;\n-        if let [a, b, ..] = tup.as_slice();\n-        if let (&ExprKind::AddrOf(_, _, ref a), &ExprKind::AddrOf(_, _, ref b)) = (&a.kind, &b.kind);\n-        then {\n-            return Some([&*a, &*b]);\n-        }\n-    }\n-    None\n-}"}, {"sha": "160a51740cd7cde24cf8f31fa13a52fb02925ff8", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 3, "deletions": 292, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -3,15 +3,13 @@\n #![deny(clippy::missing_docs_in_private_items)]\n \n use crate::ty::is_type_diagnostic_item;\n-use crate::{is_expn_of, last_path_segment, match_def_path, paths};\n+use crate::{is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::{self, LitKind};\n use rustc_hir as hir;\n-use rustc_hir::{\n-    Arm, Block, BorrowKind, Expr, ExprKind, HirId, LoopSource, MatchSource, Node, Pat, QPath, StmtKind, UnOp,\n-};\n+use rustc_hir::{Arm, Block, Expr, ExprKind, HirId, LoopSource, MatchSource, Node, Pat, QPath};\n use rustc_lint::LateContext;\n-use rustc_span::{sym, symbol, ExpnKind, Span, Symbol};\n+use rustc_span::{sym, symbol, Span};\n \n /// The essential nodes of a desugared for loop as well as the entire span:\n /// `for pat in arg { body }` becomes `(pat, arg, body)`. Return `(pat, arg, body, span)`.\n@@ -428,293 +426,6 @@ pub fn binop(op: hir::BinOpKind) -> ast::BinOpKind {\n     }\n }\n \n-/// Extract args from an assert-like macro.\n-/// Currently working with:\n-/// - `assert!`, `assert_eq!` and `assert_ne!`\n-/// - `debug_assert!`, `debug_assert_eq!` and `debug_assert_ne!`\n-/// For example:\n-/// `assert!(expr)` will return `Some([expr])`\n-/// `debug_assert_eq!(a, b)` will return `Some([a, b])`\n-pub fn extract_assert_macro_args<'tcx>(e: &'tcx Expr<'tcx>) -> Option<Vec<&'tcx Expr<'tcx>>> {\n-    /// Try to match the AST for a pattern that contains a match, for example when two args are\n-    /// compared\n-    fn ast_matchblock(matchblock_expr: &'tcx Expr<'tcx>) -> Option<Vec<&Expr<'_>>> {\n-        if_chain! {\n-            if let ExprKind::Match(headerexpr, _, _) = &matchblock_expr.kind;\n-            if let ExprKind::Tup([lhs, rhs]) = &headerexpr.kind;\n-            if let ExprKind::AddrOf(BorrowKind::Ref, _, lhs) = lhs.kind;\n-            if let ExprKind::AddrOf(BorrowKind::Ref, _, rhs) = rhs.kind;\n-            then {\n-                return Some(vec![lhs, rhs]);\n-            }\n-        }\n-        None\n-    }\n-\n-    if let ExprKind::Block(block, _) = e.kind {\n-        if block.stmts.len() == 1 {\n-            if let StmtKind::Semi(matchexpr) = block.stmts.get(0)?.kind {\n-                // macros with unique arg: `{debug_}assert!` (e.g., `debug_assert!(some_condition)`)\n-                if_chain! {\n-                    if let Some(If { cond, .. }) = If::hir(matchexpr);\n-                    if let ExprKind::Unary(UnOp::Not, condition) = cond.kind;\n-                    then {\n-                        return Some(vec![condition]);\n-                    }\n-                }\n-\n-                // debug macros with two args: `debug_assert_{ne, eq}` (e.g., `assert_ne!(a, b)`)\n-                if_chain! {\n-                    if let ExprKind::Block(matchblock,_) = matchexpr.kind;\n-                    if let Some(matchblock_expr) = matchblock.expr;\n-                    then {\n-                        return ast_matchblock(matchblock_expr);\n-                    }\n-                }\n-            }\n-        } else if let Some(matchblock_expr) = block.expr {\n-            // macros with two args: `assert_{ne, eq}` (e.g., `assert_ne!(a, b)`)\n-            return ast_matchblock(matchblock_expr);\n-        }\n-    }\n-    None\n-}\n-\n-/// A parsed `format!` expansion\n-pub struct FormatExpn<'tcx> {\n-    /// Span of `format!(..)`\n-    pub call_site: Span,\n-    /// Inner `format_args!` expansion\n-    pub format_args: FormatArgsExpn<'tcx>,\n-}\n-\n-impl FormatExpn<'tcx> {\n-    /// Parses an expanded `format!` invocation\n-    pub fn parse(expr: &'tcx Expr<'tcx>) -> Option<Self> {\n-        if_chain! {\n-            if let ExprKind::Block(block, _) = expr.kind;\n-            if let [stmt] = block.stmts;\n-            if let StmtKind::Local(local) = stmt.kind;\n-            if let Some(init) = local.init;\n-            if let ExprKind::Call(_, [format_args]) = init.kind;\n-            let expn_data = expr.span.ctxt().outer_expn_data();\n-            if let ExpnKind::Macro(_, sym::format) = expn_data.kind;\n-            if let Some(format_args) = FormatArgsExpn::parse(format_args);\n-            then {\n-                Some(FormatExpn {\n-                    call_site: expn_data.call_site,\n-                    format_args,\n-                })\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-}\n-\n-/// A parsed `format_args!` expansion\n-pub struct FormatArgsExpn<'tcx> {\n-    /// Span of the first argument, the format string\n-    pub format_string_span: Span,\n-    /// Values passed after the format string\n-    pub value_args: Vec<&'tcx Expr<'tcx>>,\n-\n-    /// String literal expressions which represent the format string split by \"{}\"\n-    pub format_string_parts: &'tcx [Expr<'tcx>],\n-    /// Symbols corresponding to [`Self::format_string_parts`]\n-    pub format_string_symbols: Vec<Symbol>,\n-    /// Expressions like `ArgumentV1::new(arg0, Debug::fmt)`\n-    pub args: &'tcx [Expr<'tcx>],\n-    /// The final argument passed to `Arguments::new_v1_formatted`, if applicable\n-    pub fmt_expr: Option<&'tcx Expr<'tcx>>,\n-}\n-\n-impl FormatArgsExpn<'tcx> {\n-    /// Parses an expanded `format_args!` or `format_args_nl!` invocation\n-    pub fn parse(expr: &'tcx Expr<'tcx>) -> Option<Self> {\n-        if_chain! {\n-            if let ExpnKind::Macro(_, name) = expr.span.ctxt().outer_expn_data().kind;\n-            let name = name.as_str();\n-            if name.ends_with(\"format_args\") || name.ends_with(\"format_args_nl\");\n-            if let ExprKind::Call(_, args) = expr.kind;\n-            if let Some((strs_ref, args, fmt_expr)) = match args {\n-                // Arguments::new_v1\n-                [strs_ref, args] => Some((strs_ref, args, None)),\n-                // Arguments::new_v1_formatted\n-                [strs_ref, args, fmt_expr, _unsafe_arg] => Some((strs_ref, args, Some(fmt_expr))),\n-                _ => None,\n-            };\n-            if let ExprKind::AddrOf(BorrowKind::Ref, _, strs_arr) = strs_ref.kind;\n-            if let ExprKind::Array(format_string_parts) = strs_arr.kind;\n-            if let Some(format_string_symbols) = format_string_parts\n-                .iter()\n-                .map(|e| {\n-                    if let ExprKind::Lit(lit) = &e.kind {\n-                        if let LitKind::Str(symbol, _style) = lit.node {\n-                            return Some(symbol);\n-                        }\n-                    }\n-                    None\n-                })\n-                .collect();\n-            if let ExprKind::AddrOf(BorrowKind::Ref, _, args) = args.kind;\n-            if let ExprKind::Match(args, [arm], _) = args.kind;\n-            if let ExprKind::Tup(value_args) = args.kind;\n-            if let Some(value_args) = value_args\n-                .iter()\n-                .map(|e| match e.kind {\n-                    ExprKind::AddrOf(_, _, e) => Some(e),\n-                    _ => None,\n-                })\n-                .collect();\n-            if let ExprKind::Array(args) = arm.body.kind;\n-            then {\n-                Some(FormatArgsExpn {\n-                    format_string_span: strs_ref.span,\n-                    value_args,\n-                    format_string_parts,\n-                    format_string_symbols,\n-                    args,\n-                    fmt_expr,\n-                })\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-\n-    /// Returns a vector of `FormatArgsArg`.\n-    pub fn args(&self) -> Option<Vec<FormatArgsArg<'tcx>>> {\n-        if let Some(expr) = self.fmt_expr {\n-            if_chain! {\n-                if let ExprKind::AddrOf(BorrowKind::Ref, _, expr) = expr.kind;\n-                if let ExprKind::Array(exprs) = expr.kind;\n-                then {\n-                    exprs.iter().map(|fmt| {\n-                        if_chain! {\n-                            // struct `core::fmt::rt::v1::Argument`\n-                            if let ExprKind::Struct(_, fields, _) = fmt.kind;\n-                            if let Some(position_field) = fields.iter().find(|f| f.ident.name == sym::position);\n-                            if let ExprKind::Lit(lit) = &position_field.expr.kind;\n-                            if let LitKind::Int(position, _) = lit.node;\n-                            if let Ok(i) = usize::try_from(position);\n-                            let arg = &self.args[i];\n-                            if let ExprKind::Call(_, [arg_name, _]) = arg.kind;\n-                            if let ExprKind::Field(_, j) = arg_name.kind;\n-                            if let Ok(j) = j.name.as_str().parse::<usize>();\n-                            then {\n-                                Some(FormatArgsArg { value: self.value_args[j], arg, fmt: Some(fmt) })\n-                            } else {\n-                                None\n-                            }\n-                        }\n-                    }).collect()\n-                } else {\n-                    None\n-                }\n-            }\n-        } else {\n-            Some(\n-                self.value_args\n-                    .iter()\n-                    .zip(self.args.iter())\n-                    .map(|(value, arg)| FormatArgsArg { value, arg, fmt: None })\n-                    .collect(),\n-            )\n-        }\n-    }\n-}\n-\n-/// Type representing a `FormatArgsExpn`'s format arguments\n-pub struct FormatArgsArg<'tcx> {\n-    /// An element of `value_args` according to `position`\n-    pub value: &'tcx Expr<'tcx>,\n-    /// An element of `args` according to `position`\n-    pub arg: &'tcx Expr<'tcx>,\n-    /// An element of `fmt_expn`\n-    pub fmt: Option<&'tcx Expr<'tcx>>,\n-}\n-\n-impl<'tcx> FormatArgsArg<'tcx> {\n-    /// Returns true if any formatting parameters are used that would have an effect on strings,\n-    /// like `{:+2}` instead of just `{}`.\n-    pub fn has_string_formatting(&self) -> bool {\n-        self.fmt.map_or(false, |fmt| {\n-            // `!` because these conditions check that `self` is unformatted.\n-            !if_chain! {\n-                // struct `core::fmt::rt::v1::Argument`\n-                if let ExprKind::Struct(_, fields, _) = fmt.kind;\n-                if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym::format);\n-                // struct `core::fmt::rt::v1::FormatSpec`\n-                if let ExprKind::Struct(_, subfields, _) = format_field.expr.kind;\n-                let mut precision_found = false;\n-                let mut width_found = false;\n-                if subfields.iter().all(|field| {\n-                    match field.ident.name {\n-                        sym::precision => {\n-                            precision_found = true;\n-                            if let ExprKind::Path(ref precision_path) = field.expr.kind {\n-                                last_path_segment(precision_path).ident.name == sym::Implied\n-                            } else {\n-                                false\n-                            }\n-                        }\n-                        sym::width => {\n-                            width_found = true;\n-                            if let ExprKind::Path(ref width_qpath) = field.expr.kind {\n-                                last_path_segment(width_qpath).ident.name == sym::Implied\n-                            } else {\n-                                false\n-                            }\n-                        }\n-                        _ => true,\n-                    }\n-                });\n-                if precision_found && width_found;\n-                then { true } else { false }\n-            }\n-        })\n-    }\n-\n-    /// Returns true if the argument is formatted using `Display::fmt`.\n-    pub fn is_display(&self) -> bool {\n-        if_chain! {\n-            if let ExprKind::Call(_, [_, format_field]) = self.arg.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, path)) = format_field.kind;\n-            if let [.., t, _] = path.segments;\n-            if t.ident.name == sym::Display;\n-            then { true } else { false }\n-        }\n-    }\n-}\n-\n-/// A parsed `panic!` expansion\n-pub struct PanicExpn<'tcx> {\n-    /// Span of `panic!(..)`\n-    pub call_site: Span,\n-    /// Inner `format_args!` expansion\n-    pub format_args: FormatArgsExpn<'tcx>,\n-}\n-\n-impl PanicExpn<'tcx> {\n-    /// Parses an expanded `panic!` invocation\n-    pub fn parse(expr: &'tcx Expr<'tcx>) -> Option<Self> {\n-        if_chain! {\n-            if let ExprKind::Call(_, [format_args]) = expr.kind;\n-            let expn_data = expr.span.ctxt().outer_expn_data();\n-            if let Some(format_args) = FormatArgsExpn::parse(format_args);\n-            then {\n-                Some(PanicExpn {\n-                    call_site: expn_data.call_site,\n-                    format_args,\n-                })\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-}\n-\n /// A parsed `Vec` initialization expression\n #[derive(Clone, Copy)]\n pub enum VecInitKind {"}, {"sha": "52e28a5679cfa332356678d37e9697c205e5877e", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -44,6 +44,7 @@ pub mod diagnostics;\n pub mod eager_or_lazy;\n pub mod higher;\n mod hir_utils;\n+pub mod macros;\n pub mod msrvs;\n pub mod numeric_literal;\n pub mod paths;\n@@ -1159,19 +1160,6 @@ pub fn contains_return(expr: &hir::Expr<'_>) -> bool {\n     found\n }\n \n-/// Finds calls of the specified macros in a function body.\n-pub fn find_macro_calls(names: &[&str], body: &Body<'_>) -> Vec<Span> {\n-    let mut result = Vec::new();\n-    expr_visitor_no_bodies(|expr| {\n-        if names.iter().any(|fun| is_expn_of(expr.span, fun).is_some()) {\n-            result.push(expr.span);\n-        }\n-        true\n-    })\n-    .visit_expr(&body.value);\n-    result\n-}\n-\n /// Extends the span to the beginning of the spans line, incl. whitespaces.\n ///\n /// ```rust\n@@ -1700,32 +1688,6 @@ pub fn match_libc_symbol(cx: &LateContext<'_>, did: DefId, name: &str) -> bool {\n     path.first().map_or(false, |s| s.as_str() == \"libc\") && path.last().map_or(false, |s| s.as_str() == name)\n }\n \n-pub fn match_panic_call(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n-    if let ExprKind::Call(func, [arg]) = expr.kind {\n-        expr_path_res(cx, func)\n-            .opt_def_id()\n-            .map_or(false, |id| match_panic_def_id(cx, id))\n-            .then(|| arg)\n-    } else {\n-        None\n-    }\n-}\n-\n-pub fn match_panic_def_id(cx: &LateContext<'_>, did: DefId) -> bool {\n-    match_any_def_paths(\n-        cx,\n-        did,\n-        &[\n-            &paths::BEGIN_PANIC,\n-            &paths::PANIC_ANY,\n-            &paths::PANICKING_PANIC,\n-            &paths::PANICKING_PANIC_FMT,\n-            &paths::PANICKING_PANIC_STR,\n-        ],\n-    )\n-    .is_some()\n-}\n-\n /// Returns the list of condition expressions and the list of blocks in a\n /// sequence of `if/else`.\n /// E.g., this returns `([a, b], [c, d, e])` for the expression"}, {"sha": "2bf43aeb995a4479af434faffdf2b400ce9480d1", "filename": "clippy_utils/src/macros.rs", "status": "added", "additions": 539, "deletions": 0, "changes": 539, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmacros.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -0,0 +1,539 @@\n+#![allow(clippy::similar_names)] // `expr` and `expn`\n+\n+use crate::visitors::expr_visitor_no_bodies;\n+\n+use arrayvec::ArrayVec;\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::{self as hir, Expr, ExprKind, HirId, Node, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::def_id::DefId;\n+use rustc_span::hygiene::{MacroKind, SyntaxContext};\n+use rustc_span::{sym, ExpnData, ExpnId, ExpnKind, Span, Symbol};\n+use std::ops::ControlFlow;\n+\n+/// A macro call, like `vec![1, 2, 3]`.\n+///\n+/// Use `tcx.item_name(macro_call.def_id)` to get the macro name.\n+/// Even better is to check if it is a diagnostic item.\n+///\n+/// This structure is similar to `ExpnData` but it precludes desugaring expansions.\n+#[derive(Debug)]\n+pub struct MacroCall {\n+    /// Macro `DefId`\n+    pub def_id: DefId,\n+    /// Kind of macro\n+    pub kind: MacroKind,\n+    /// The expansion produced by the macro call\n+    pub expn: ExpnId,\n+    /// Span of the macro call site\n+    pub span: Span,\n+}\n+\n+impl MacroCall {\n+    pub fn is_local(&self) -> bool {\n+        span_is_local(self.span)\n+    }\n+}\n+\n+/// Returns an iterator of expansions that created the given span\n+pub fn expn_backtrace(mut span: Span) -> impl Iterator<Item = (ExpnId, ExpnData)> {\n+    std::iter::from_fn(move || {\n+        let ctxt = span.ctxt();\n+        if ctxt == SyntaxContext::root() {\n+            return None;\n+        }\n+        let expn = ctxt.outer_expn();\n+        let data = expn.expn_data();\n+        span = data.call_site;\n+        Some((expn, data))\n+    })\n+}\n+\n+/// Checks whether the span is from the root expansion or a locally defined macro\n+pub fn span_is_local(span: Span) -> bool {\n+    !span.from_expansion() || expn_is_local(span.ctxt().outer_expn())\n+}\n+\n+/// Checks whether the expansion is the root expansion or a locally defined macro\n+pub fn expn_is_local(expn: ExpnId) -> bool {\n+    if expn == ExpnId::root() {\n+        return true;\n+    }\n+    let data = expn.expn_data();\n+    let backtrace = expn_backtrace(data.call_site);\n+    std::iter::once((expn, data))\n+        .chain(backtrace)\n+        .find_map(|(_, data)| data.macro_def_id)\n+        .map_or(true, DefId::is_local)\n+}\n+\n+/// Returns an iterator of macro expansions that created the given span.\n+/// Note that desugaring expansions are skipped.\n+pub fn macro_backtrace(span: Span) -> impl Iterator<Item = MacroCall> {\n+    expn_backtrace(span).filter_map(|(expn, data)| match data {\n+        ExpnData {\n+            kind: ExpnKind::Macro(kind, _),\n+            macro_def_id: Some(def_id),\n+            call_site: span,\n+            ..\n+        } => Some(MacroCall {\n+            def_id,\n+            kind,\n+            expn,\n+            span,\n+        }),\n+        _ => None,\n+    })\n+}\n+\n+/// If the macro backtrace of `span` has a macro call at the root expansion\n+/// (i.e. not a nested macro call), returns `Some` with the `MacroCall`\n+pub fn root_macro_call(span: Span) -> Option<MacroCall> {\n+    macro_backtrace(span).last()\n+}\n+\n+/// Like [`root_macro_call`], but only returns `Some` if `node` is the \"first node\"\n+/// produced by the macro call, as in [`first_node_in_macro`].\n+pub fn root_macro_call_first_node(cx: &LateContext<'_>, node: &impl HirNode) -> Option<MacroCall> {\n+    if first_node_in_macro(cx, node) != Some(ExpnId::root()) {\n+        return None;\n+    }\n+    root_macro_call(node.span())\n+}\n+\n+/// Like [`macro_backtrace`], but only returns macro calls where `node` is the \"first node\" of the\n+/// macro call, as in [`first_node_in_macro`].\n+pub fn first_node_macro_backtrace(cx: &LateContext<'_>, node: &impl HirNode) -> impl Iterator<Item = MacroCall> {\n+    let span = node.span();\n+    first_node_in_macro(cx, node)\n+        .into_iter()\n+        .flat_map(move |expn| macro_backtrace(span).take_while(move |macro_call| macro_call.expn != expn))\n+}\n+\n+/// If `node` is the \"first node\" in a macro expansion, returns `Some` with the `ExpnId` of the\n+/// macro call site (i.e. the parent of the macro expansion). This generally means that `node`\n+/// is the outermost node of an entire macro expansion, but there are some caveats noted below.\n+/// This is useful for finding macro calls while visiting the HIR without processing the macro call\n+/// at every node within its expansion.\n+///\n+/// If you already have immediate access to the parent node, it is simpler to\n+/// just check the context of that span directly (e.g. `parent.span.from_expansion()`).\n+///\n+/// If a macro call is in statement position, it expands to one or more statements.\n+/// In that case, each statement *and* their immediate descendants will all yield `Some`\n+/// with the `ExpnId` of the containing block.\n+///\n+/// A node may be the \"first node\" of multiple macro calls in a macro backtrace.\n+/// The expansion of the outermost macro call site is returned in such cases.\n+pub fn first_node_in_macro(cx: &LateContext<'_>, node: &impl HirNode) -> Option<ExpnId> {\n+    // get the macro expansion or return `None` if not found\n+    // `macro_backtrace` importantly ignores desugaring expansions\n+    let expn = macro_backtrace(node.span()).next()?.expn;\n+\n+    // get the parent node, possibly skipping over a statement\n+    // if the parent is not found, it is sensible to return `Some(root)`\n+    let hir = cx.tcx.hir();\n+    let mut parent_iter = hir.parent_iter(node.hir_id());\n+    let (parent_id, _) = match parent_iter.next() {\n+        None => return Some(ExpnId::root()),\n+        Some((_, Node::Stmt(_))) => match parent_iter.next() {\n+            None => return Some(ExpnId::root()),\n+            Some(next) => next,\n+        },\n+        Some(next) => next,\n+    };\n+\n+    // get the macro expansion of the parent node\n+    let parent_span = hir.span(parent_id);\n+    let Some(parent_macro_call) = macro_backtrace(parent_span).next() else {\n+        // the parent node is not in a macro\n+        return Some(ExpnId::root());\n+    };\n+\n+    if parent_macro_call.expn.is_descendant_of(expn) {\n+        // `node` is input to a macro call\n+        return None;\n+    }\n+\n+    Some(parent_macro_call.expn)\n+}\n+\n+/* Specific Macro Utils */\n+\n+/// Is `def_id` of `std::panic`, `core::panic` or any inner implementation macros\n+pub fn is_panic(cx: &LateContext<'_>, def_id: DefId) -> bool {\n+    let Some(name) = cx.tcx.get_diagnostic_name(def_id) else { return false };\n+    matches!(\n+        name.as_str(),\n+        \"core_panic_macro\"\n+            | \"std_panic_macro\"\n+            | \"core_panic_2015_macro\"\n+            | \"std_panic_2015_macro\"\n+            | \"core_panic_2021_macro\"\n+    )\n+}\n+\n+pub enum PanicExpn<'a> {\n+    /// No arguments - `panic!()`\n+    Empty,\n+    /// A string literal or any `&str` - `panic!(\"message\")` or `panic!(message)`\n+    Str(&'a Expr<'a>),\n+    /// A single argument that implements `Display` - `panic!(\"{}\", object)`\n+    Display(&'a Expr<'a>),\n+    /// Anything else - `panic!(\"error {}: {}\", a, b)`\n+    Format(FormatArgsExpn<'a>),\n+}\n+\n+impl<'a> PanicExpn<'a> {\n+    pub fn parse(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<Self> {\n+        if !macro_backtrace(expr.span).any(|macro_call| is_panic(cx, macro_call.def_id)) {\n+            return None;\n+        }\n+        let ExprKind::Call(callee, [arg]) = expr.kind else { return None };\n+        let ExprKind::Path(QPath::Resolved(_, path)) = callee.kind else { return None };\n+        let result = match path.segments.last().unwrap().ident.as_str() {\n+            \"panic\" if arg.span.ctxt() == expr.span.ctxt() => Self::Empty,\n+            \"panic\" | \"panic_str\" => Self::Str(arg),\n+            \"panic_display\" => {\n+                let ExprKind::AddrOf(_, _, e) = arg.kind else { return None };\n+                Self::Display(e)\n+            },\n+            \"panic_fmt\" => Self::Format(FormatArgsExpn::parse(cx, arg)?),\n+            _ => return None,\n+        };\n+        Some(result)\n+    }\n+}\n+\n+/// Finds the arguments of an `assert!` or `debug_assert!` macro call within the macro expansion\n+pub fn find_assert_args<'a>(\n+    cx: &LateContext<'_>,\n+    expr: &'a Expr<'a>,\n+    expn: ExpnId,\n+) -> Option<(&'a Expr<'a>, PanicExpn<'a>)> {\n+    find_assert_args_inner(cx, expr, expn).map(|([e], p)| (e, p))\n+}\n+\n+/// Finds the arguments of an `assert_eq!` or `debug_assert_eq!` macro call within the macro\n+/// expansion\n+pub fn find_assert_eq_args<'a>(\n+    cx: &LateContext<'_>,\n+    expr: &'a Expr<'a>,\n+    expn: ExpnId,\n+) -> Option<(&'a Expr<'a>, &'a Expr<'a>, PanicExpn<'a>)> {\n+    find_assert_args_inner(cx, expr, expn).map(|([a, b], p)| (a, b, p))\n+}\n+\n+fn find_assert_args_inner<'a, const N: usize>(\n+    cx: &LateContext<'_>,\n+    expr: &'a Expr<'a>,\n+    expn: ExpnId,\n+) -> Option<([&'a Expr<'a>; N], PanicExpn<'a>)> {\n+    let macro_id = expn.expn_data().macro_def_id?;\n+    let (expr, expn) = match cx.tcx.item_name(macro_id).as_str().strip_prefix(\"debug_\") {\n+        None => (expr, expn),\n+        Some(inner_name) => find_assert_within_debug_assert(cx, expr, expn, Symbol::intern(inner_name))?,\n+    };\n+    let mut args = ArrayVec::new();\n+    let mut panic_expn = None;\n+    expr_visitor_no_bodies(|e| {\n+        if args.is_full() {\n+            if panic_expn.is_none() && e.span.ctxt() != expr.span.ctxt() {\n+                panic_expn = PanicExpn::parse(cx, e);\n+            }\n+            panic_expn.is_none()\n+        } else if is_assert_arg(cx, e, expn) {\n+            args.push(e);\n+            false\n+        } else {\n+            true\n+        }\n+    })\n+    .visit_expr(expr);\n+    let args = args.into_inner().ok()?;\n+    // if no `panic!(..)` is found, use `PanicExpn::Empty`\n+    // to indicate that the default assertion message is used\n+    let panic_expn = panic_expn.unwrap_or(PanicExpn::Empty);\n+    Some((args, panic_expn))\n+}\n+\n+fn find_assert_within_debug_assert<'a>(\n+    cx: &LateContext<'_>,\n+    expr: &'a Expr<'a>,\n+    expn: ExpnId,\n+    assert_name: Symbol,\n+) -> Option<(&'a Expr<'a>, ExpnId)> {\n+    let mut found = None;\n+    expr_visitor_no_bodies(|e| {\n+        if found.is_some() || !e.span.from_expansion() {\n+            return false;\n+        }\n+        let e_expn = e.span.ctxt().outer_expn();\n+        if e_expn == expn {\n+            return true;\n+        }\n+        if e_expn.expn_data().macro_def_id.map(|id| cx.tcx.item_name(id)) == Some(assert_name) {\n+            found = Some((e, e_expn));\n+        }\n+        false\n+    })\n+    .visit_expr(expr);\n+    found\n+}\n+\n+fn is_assert_arg(cx: &LateContext<'_>, expr: &'a Expr<'a>, assert_expn: ExpnId) -> bool {\n+    if !expr.span.from_expansion() {\n+        return true;\n+    }\n+    let result = macro_backtrace(expr.span).try_for_each(|macro_call| {\n+        if macro_call.expn == assert_expn {\n+            ControlFlow::Break(false)\n+        } else {\n+            match cx.tcx.item_name(macro_call.def_id) {\n+                // `cfg!(debug_assertions)` in `debug_assert!`\n+                sym::cfg => ControlFlow::CONTINUE,\n+                // assert!(other_macro!(..))\n+                _ => ControlFlow::Break(true),\n+            }\n+        }\n+    });\n+    match result {\n+        ControlFlow::Break(is_assert_arg) => is_assert_arg,\n+        ControlFlow::Continue(()) => true,\n+    }\n+}\n+\n+/// A parsed `format_args!` expansion\n+pub struct FormatArgsExpn<'tcx> {\n+    /// Span of the first argument, the format string\n+    pub format_string_span: Span,\n+    /// The format string split by formatted args like `{..}`\n+    pub format_string_parts: Vec<Symbol>,\n+    /// Values passed after the format string\n+    pub value_args: Vec<&'tcx Expr<'tcx>>,\n+    /// Each element is a `value_args` index and a formatting trait (e.g. `sym::Debug`)\n+    pub formatters: Vec<(usize, Symbol)>,\n+    /// List of `fmt::v1::Argument { .. }` expressions. If this is empty,\n+    /// then `formatters` represents the format args (`{..}`).\n+    /// If this is non-empty, it represents the format args, and the `position`\n+    /// parameters within the struct expressions are indexes of `formatters`.\n+    pub specs: Vec<&'tcx Expr<'tcx>>,\n+}\n+\n+impl FormatArgsExpn<'tcx> {\n+    /// Parses an expanded `format_args!` or `format_args_nl!` invocation\n+    pub fn parse(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<Self> {\n+        macro_backtrace(expr.span).find(|macro_call| {\n+            matches!(\n+                cx.tcx.item_name(macro_call.def_id),\n+                sym::const_format_args | sym::format_args | sym::format_args_nl\n+            )\n+        })?;\n+        let mut format_string_span: Option<Span> = None;\n+        let mut format_string_parts: Vec<Symbol> = Vec::new();\n+        let mut value_args: Vec<&Expr<'_>> = Vec::new();\n+        let mut formatters: Vec<(usize, Symbol)> = Vec::new();\n+        let mut specs: Vec<&Expr<'_>> = Vec::new();\n+        expr_visitor_no_bodies(|e| {\n+            // if we're still inside of the macro definition...\n+            if e.span.ctxt() == expr.span.ctxt() {\n+                // ArgumnetV1::new(<value>, <format_trait>::fmt)\n+                if_chain! {\n+                    if let ExprKind::Call(callee, [val, fmt_path]) = e.kind;\n+                    if let ExprKind::Path(QPath::TypeRelative(ty, seg)) = callee.kind;\n+                    if seg.ident.name == sym::new;\n+                    if let hir::TyKind::Path(QPath::Resolved(_, path)) = ty.kind;\n+                    if path.segments.last().unwrap().ident.name == sym::ArgumentV1;\n+                    if let ExprKind::Path(QPath::Resolved(_, path)) = fmt_path.kind;\n+                    if let [.., fmt_trait, _fmt] = path.segments;\n+                    then {\n+                        let val_idx = if_chain! {\n+                            if val.span.ctxt() == expr.span.ctxt();\n+                            if let ExprKind::Field(_, field) = val.kind;\n+                            if let Ok(idx) = field.name.as_str().parse();\n+                            then {\n+                                // tuple index\n+                                idx\n+                            } else {\n+                                // assume the value expression is passed directly\n+                                formatters.len()\n+                            }\n+                        };\n+                        formatters.push((val_idx, fmt_trait.ident.name));\n+                    }\n+                }\n+                if let ExprKind::Struct(QPath::Resolved(_, path), ..) = e.kind {\n+                    if path.segments.last().unwrap().ident.name == sym::Argument {\n+                        specs.push(e);\n+                    }\n+                }\n+                // walk through the macro expansion\n+                return true;\n+            }\n+            // assume that the first expr with a differing context represents\n+            // (and has the span of) the format string\n+            if format_string_span.is_none() {\n+                format_string_span = Some(e.span);\n+                let span = e.span;\n+                // walk the expr and collect string literals which are format string parts\n+                expr_visitor_no_bodies(|e| {\n+                    if e.span.ctxt() != span.ctxt() {\n+                        // defensive check, probably doesn't happen\n+                        return false;\n+                    }\n+                    if let ExprKind::Lit(lit) = &e.kind {\n+                        if let LitKind::Str(symbol, _s) = lit.node {\n+                            format_string_parts.push(symbol);\n+                        }\n+                    }\n+                    true\n+                })\n+                .visit_expr(e);\n+            } else {\n+                // assume that any further exprs with a differing context are value args\n+                value_args.push(e);\n+            }\n+            // don't walk anything not from the macro expansion (e.a. inputs)\n+            false\n+        })\n+        .visit_expr(expr);\n+        Some(FormatArgsExpn {\n+            format_string_span: format_string_span?,\n+            format_string_parts,\n+            value_args,\n+            formatters,\n+            specs,\n+        })\n+    }\n+\n+    /// Finds a nested call to `format_args!` within a `format!`-like macro call\n+    pub fn find_nested(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, expn_id: ExpnId) -> Option<Self> {\n+        let mut format_args = None;\n+        expr_visitor_no_bodies(|e| {\n+            if format_args.is_some() {\n+                return false;\n+            }\n+            let e_ctxt = e.span.ctxt();\n+            if e_ctxt == expr.span.ctxt() {\n+                return true;\n+            }\n+            if e_ctxt.outer_expn().is_descendant_of(expn_id) {\n+                format_args = FormatArgsExpn::parse(cx, e);\n+            }\n+            false\n+        })\n+        .visit_expr(expr);\n+        format_args\n+    }\n+\n+    /// Returns a vector of `FormatArgsArg`.\n+    pub fn args(&self) -> Option<Vec<FormatArgsArg<'tcx>>> {\n+        if self.specs.is_empty() {\n+            let args = std::iter::zip(&self.value_args, &self.formatters)\n+                .map(|(value, &(_, format_trait))| FormatArgsArg {\n+                    value,\n+                    format_trait,\n+                    spec: None,\n+                })\n+                .collect();\n+            return Some(args);\n+        }\n+        self.specs\n+            .iter()\n+            .map(|spec| {\n+                if_chain! {\n+                    // struct `core::fmt::rt::v1::Argument`\n+                    if let ExprKind::Struct(_, fields, _) = spec.kind;\n+                    if let Some(position_field) = fields.iter().find(|f| f.ident.name == sym::position);\n+                    if let ExprKind::Lit(lit) = &position_field.expr.kind;\n+                    if let LitKind::Int(position, _) = lit.node;\n+                    if let Ok(i) = usize::try_from(position);\n+                    if let Some(&(j, format_trait)) = self.formatters.get(i);\n+                    then {\n+                        Some(FormatArgsArg { value: self.value_args[j], format_trait, spec: Some(spec) })\n+                    } else {\n+                        None\n+                    }\n+                }\n+            })\n+            .collect()\n+    }\n+\n+    /// Span of all inputs\n+    pub fn inputs_span(&self) -> Span {\n+        match *self.value_args {\n+            [] => self.format_string_span,\n+            [.., last] => self.format_string_span.to(last.span),\n+        }\n+    }\n+}\n+\n+/// Type representing a `FormatArgsExpn`'s format arguments\n+pub struct FormatArgsArg<'tcx> {\n+    /// An element of `value_args` according to `position`\n+    pub value: &'tcx Expr<'tcx>,\n+    /// An element of `args` according to `position`\n+    pub format_trait: Symbol,\n+    /// An element of `specs`\n+    pub spec: Option<&'tcx Expr<'tcx>>,\n+}\n+\n+impl<'tcx> FormatArgsArg<'tcx> {\n+    /// Returns true if any formatting parameters are used that would have an effect on strings,\n+    /// like `{:+2}` instead of just `{}`.\n+    pub fn has_string_formatting(&self) -> bool {\n+        self.spec.map_or(false, |spec| {\n+            // `!` because these conditions check that `self` is unformatted.\n+            !if_chain! {\n+                // struct `core::fmt::rt::v1::Argument`\n+                if let ExprKind::Struct(_, fields, _) = spec.kind;\n+                if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym::format);\n+                // struct `core::fmt::rt::v1::FormatSpec`\n+                if let ExprKind::Struct(_, subfields, _) = format_field.expr.kind;\n+                if subfields.iter().all(|field| match field.ident.name {\n+                    sym::precision | sym::width => match field.expr.kind {\n+                        ExprKind::Path(QPath::Resolved(_, path)) => {\n+                            path.segments.last().unwrap().ident.name == sym::Implied\n+                        }\n+                        _ => false,\n+                    }\n+                    _ => true,\n+                });\n+                then { true } else { false }\n+            }\n+        })\n+    }\n+}\n+\n+/// A node with a `HirId` and a `Span`\n+pub trait HirNode {\n+    fn hir_id(&self) -> HirId;\n+    fn span(&self) -> Span;\n+}\n+\n+macro_rules! impl_hir_node {\n+    ($($t:ident),*) => {\n+        $(impl HirNode for hir::$t<'_> {\n+            fn hir_id(&self) -> HirId {\n+                self.hir_id\n+            }\n+            fn span(&self) -> Span {\n+                self.span\n+            }\n+        })*\n+    };\n+}\n+\n+impl_hir_node!(Expr, Pat);\n+\n+impl HirNode for hir::Item<'_> {\n+    fn hir_id(&self) -> HirId {\n+        self.hir_id()\n+    }\n+\n+    fn span(&self) -> Span {\n+        self.span\n+    }\n+}"}, {"sha": "27db53a6e6d581cfde46fd6fbd2bc1403a06c2e6", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -25,7 +25,6 @@ pub const ASSERT_MACRO: [&str; 4] = [\"core\", \"macros\", \"builtin\", \"assert\"];\n pub const ASSERT_NE_MACRO: [&str; 3] = [\"core\", \"macros\", \"assert_ne\"];\n pub const ASMUT_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsMut\"];\n pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n-pub(super) const BEGIN_PANIC: [&str; 3] = [\"std\", \"panicking\", \"begin_panic\"];\n /// Preferably use the diagnostic item `sym::Borrow` where possible\n pub const BORROW_TRAIT: [&str; 3] = [\"core\", \"borrow\", \"Borrow\"];\n pub const BORROW_MUT_TRAIT: [&str; 3] = [\"core\", \"borrow\", \"BorrowMut\"];\n@@ -110,10 +109,6 @@ pub const OPTION_SOME: [&str; 4] = [\"core\", \"option\", \"Option\", \"Some\"];\n pub const ORD: [&str; 3] = [\"core\", \"cmp\", \"Ord\"];\n pub const OS_STRING_AS_OS_STR: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsString\", \"as_os_str\"];\n pub const OS_STR_TO_OS_STRING: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsStr\", \"to_os_string\"];\n-pub(super) const PANICKING_PANIC: [&str; 3] = [\"core\", \"panicking\", \"panic\"];\n-pub(super) const PANICKING_PANIC_FMT: [&str; 3] = [\"core\", \"panicking\", \"panic_fmt\"];\n-pub(super) const PANICKING_PANIC_STR: [&str; 3] = [\"core\", \"panicking\", \"panic_str\"];\n-pub(super) const PANIC_ANY: [&str; 3] = [\"std\", \"panic\", \"panic_any\"];\n pub const PARKING_LOT_RAWMUTEX: [&str; 3] = [\"parking_lot\", \"raw_mutex\", \"RawMutex\"];\n pub const PARKING_LOT_RAWRWLOCK: [&str; 3] = [\"parking_lot\", \"raw_rwlock\", \"RawRwLock\"];\n pub const PARKING_LOT_MUTEX_GUARD: [&str; 2] = [\"parking_lot\", \"MutexGuard\"];"}, {"sha": "7477c01ca78283e173392dd12c86c40a210ebe8d", "filename": "tests/ui/assertions_on_constants.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/tests%2Fui%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/tests%2Fui%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassertions_on_constants.rs?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -1,4 +1,3 @@\n-//FIXME: suggestions are wrongly expanded, this should be fixed along with #7843\n #![allow(non_fmt_panics)]\n \n macro_rules! assert_const {"}, {"sha": "e1f818814d500105c2b69e3a0d979f6ed467fe55", "filename": "tests/ui/assertions_on_constants.stderr", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/tests%2Fui%2Fassertions_on_constants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/tests%2Fui%2Fassertions_on_constants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassertions_on_constants.stderr?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -1,75 +1,75 @@\n error: `assert!(true)` will be optimized out by the compiler\n-  --> $DIR/assertions_on_constants.rs:11:5\n+  --> $DIR/assertions_on_constants.rs:10:5\n    |\n LL |     assert!(true);\n    |     ^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::assertions-on-constants` implied by `-D warnings`\n    = help: remove it\n-   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `assert!(false)` should probably be replaced\n-  --> $DIR/assertions_on_constants.rs:12:5\n+  --> $DIR/assertions_on_constants.rs:11:5\n    |\n LL |     assert!(false);\n    |     ^^^^^^^^^^^^^^\n    |\n    = help: use `panic!()` or `unreachable!()`\n-   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `assert!(true)` will be optimized out by the compiler\n-  --> $DIR/assertions_on_constants.rs:13:5\n+  --> $DIR/assertions_on_constants.rs:12:5\n    |\n LL |     assert!(true, \"true message\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: remove it\n-   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: `assert!(false, $crate::const_format_args!($($t)+))` should probably be replaced\n-  --> $DIR/assertions_on_constants.rs:14:5\n+error: `assert!(false, ..)` should probably be replaced\n+  --> $DIR/assertions_on_constants.rs:13:5\n    |\n LL |     assert!(false, \"false message\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: use `panic!($crate::const_format_args!($($t)+))` or `unreachable!($crate::const_format_args!($($t)+))`\n-   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = help: use `panic!(..)` or `unreachable!(..)`\n+\n+error: `assert!(false, ..)` should probably be replaced\n+  --> $DIR/assertions_on_constants.rs:16:5\n+   |\n+LL |     assert!(false, \"{}\", msg.to_uppercase());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `panic!(..)` or `unreachable!(..)`\n \n error: `assert!(true)` will be optimized out by the compiler\n-  --> $DIR/assertions_on_constants.rs:20:5\n+  --> $DIR/assertions_on_constants.rs:19:5\n    |\n LL |     assert!(B);\n    |     ^^^^^^^^^^\n    |\n    = help: remove it\n-   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `assert!(false)` should probably be replaced\n-  --> $DIR/assertions_on_constants.rs:23:5\n+  --> $DIR/assertions_on_constants.rs:22:5\n    |\n LL |     assert!(C);\n    |     ^^^^^^^^^^\n    |\n    = help: use `panic!()` or `unreachable!()`\n-   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: `assert!(false, $crate::const_format_args!($($t)+))` should probably be replaced\n-  --> $DIR/assertions_on_constants.rs:24:5\n+error: `assert!(false, ..)` should probably be replaced\n+  --> $DIR/assertions_on_constants.rs:23:5\n    |\n LL |     assert!(C, \"C message\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: use `panic!($crate::const_format_args!($($t)+))` or `unreachable!($crate::const_format_args!($($t)+))`\n-   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = help: use `panic!(..)` or `unreachable!(..)`\n \n error: `debug_assert!(true)` will be optimized out by the compiler\n-  --> $DIR/assertions_on_constants.rs:26:5\n+  --> $DIR/assertions_on_constants.rs:25:5\n    |\n LL |     debug_assert!(true);\n    |     ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: remove it\n-   = note: this error originates in the macro `$crate::assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 9 previous errors\n "}, {"sha": "cd9f1826e59bf292d5b00cbe4381d6c178d12a71", "filename": "tests/ui/eq_op_macros.stderr", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/tests%2Fui%2Feq_op_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/tests%2Fui%2Feq_op_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feq_op_macros.stderr?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -21,6 +21,28 @@ LL |     assert_in_macro_def!();\n    |\n    = note: this error originates in the macro `assert_in_macro_def` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n+error: identical args used in this `debug_assert_eq!` macro call\n+  --> $DIR/eq_op_macros.rs:9:26\n+   |\n+LL |         debug_assert_eq!(a, a);\n+   |                          ^^^^\n+...\n+LL |     assert_in_macro_def!();\n+   |     ---------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `assert_in_macro_def` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: identical args used in this `debug_assert_ne!` macro call\n+  --> $DIR/eq_op_macros.rs:10:26\n+   |\n+LL |         debug_assert_ne!(a, a);\n+   |                          ^^^^\n+...\n+LL |     assert_in_macro_def!();\n+   |     ---------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `assert_in_macro_def` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n error: identical args used in this `assert_eq!` macro call\n   --> $DIR/eq_op_macros.rs:22:16\n    |\n@@ -45,28 +67,6 @@ error: identical args used in this `assert_ne!` macro call\n LL |     assert_ne!(a + 1, a + 1);\n    |                ^^^^^^^^^^^^\n \n-error: identical args used in this `debug_assert_eq!` macro call\n-  --> $DIR/eq_op_macros.rs:9:26\n-   |\n-LL |         debug_assert_eq!(a, a);\n-   |                          ^^^^\n-...\n-LL |     assert_in_macro_def!();\n-   |     ---------------------- in this macro invocation\n-   |\n-   = note: this error originates in the macro `assert_in_macro_def` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error: identical args used in this `debug_assert_ne!` macro call\n-  --> $DIR/eq_op_macros.rs:10:26\n-   |\n-LL |         debug_assert_ne!(a, a);\n-   |                          ^^^^\n-...\n-LL |     assert_in_macro_def!();\n-   |     ---------------------- in this macro invocation\n-   |\n-   = note: this error originates in the macro `assert_in_macro_def` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n error: identical args used in this `debug_assert_eq!` macro call\n   --> $DIR/eq_op_macros.rs:38:22\n    |"}, {"sha": "91ebd695238bb8db80da5f73388c0659768b64a9", "filename": "tests/ui/missing_panics_doc.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/tests%2Fui%2Fmissing_panics_doc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/tests%2Fui%2Fmissing_panics_doc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_panics_doc.stderr?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -27,7 +27,6 @@ note: first possible panic found here\n    |\n LL |     panic!(\"This function panics\")\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: docs for function which may panic missing `# Panics` section\n   --> $DIR/missing_panics_doc.rs:17:1\n@@ -42,7 +41,6 @@ note: first possible panic found here\n    |\n LL |     todo!()\n    |     ^^^^^^^\n-   = note: this error originates in the macro `todo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: docs for function which may panic missing `# Panics` section\n   --> $DIR/missing_panics_doc.rs:22:1\n@@ -61,7 +59,6 @@ note: first possible panic found here\n    |\n LL |             panic!()\n    |             ^^^^^^^^\n-   = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: docs for function which may panic missing `# Panics` section\n   --> $DIR/missing_panics_doc.rs:31:1\n@@ -76,7 +73,6 @@ note: first possible panic found here\n    |\n LL |     if true { unreachable!() } else { panic!() }\n    |                                       ^^^^^^^^\n-   = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: docs for function which may panic missing `# Panics` section\n   --> $DIR/missing_panics_doc.rs:36:1\n@@ -92,7 +88,6 @@ note: first possible panic found here\n    |\n LL |     assert_eq!(x, 0);\n    |     ^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: docs for function which may panic missing `# Panics` section\n   --> $DIR/missing_panics_doc.rs:42:1\n@@ -108,7 +103,6 @@ note: first possible panic found here\n    |\n LL |     assert_ne!(x, 0);\n    |     ^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `assert_ne` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 7 previous errors\n "}, {"sha": "561503ae54fa22d67995e7dc8f60f88036f94bb5", "filename": "tests/ui/panic_in_result_fn.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/tests%2Fui%2Fpanic_in_result_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/tests%2Fui%2Fpanic_in_result_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanic_in_result_fn.stderr?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -14,7 +14,6 @@ note: return Err() instead of panicking\n    |\n LL |         panic!(\"error\");\n    |         ^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:11:5\n@@ -31,7 +30,6 @@ note: return Err() instead of panicking\n    |\n LL |         unimplemented!();\n    |         ^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `unimplemented` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:16:5\n@@ -48,7 +46,6 @@ note: return Err() instead of panicking\n    |\n LL |         unreachable!();\n    |         ^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `unreachable` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:21:5\n@@ -65,7 +62,6 @@ note: return Err() instead of panicking\n    |\n LL |         todo!(\"Finish this\");\n    |         ^^^^^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `todo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:52:1\n@@ -82,7 +78,6 @@ note: return Err() instead of panicking\n    |\n LL |     panic!(\"error\");\n    |     ^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:67:1\n@@ -99,7 +94,6 @@ note: return Err() instead of panicking\n    |\n LL |     todo!(\"finish main method\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `todo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 6 previous errors\n "}, {"sha": "b6aa005e7b521364cce80a4c6b4014eef9d83ad2", "filename": "tests/ui/panic_in_result_fn_assertions.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/tests%2Fui%2Fpanic_in_result_fn_assertions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/tests%2Fui%2Fpanic_in_result_fn_assertions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanic_in_result_fn_assertions.stderr?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -15,7 +15,6 @@ note: return Err() instead of panicking\n    |\n LL |         assert!(x == 5, \"wrong argument\");\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn_assertions.rs:13:5\n@@ -33,7 +32,6 @@ note: return Err() instead of panicking\n    |\n LL |         assert_eq!(x, 5);\n    |         ^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn_assertions.rs:19:5\n@@ -51,7 +49,6 @@ note: return Err() instead of panicking\n    |\n LL |         assert_ne!(x, 1);\n    |         ^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `assert_ne` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 3 previous errors\n "}, {"sha": "bfd1c7a380149b2cb89f6480f96b6ed1d1669808", "filename": "tests/ui/panicking_macros.stderr", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/tests%2Fui%2Fpanicking_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/tests%2Fui%2Fpanicking_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanicking_macros.stderr?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -25,23 +25,18 @@ LL |     todo!();\n    |     ^^^^^^^\n    |\n    = note: `-D clippy::todo` implied by `-D warnings`\n-   = note: this error originates in the macro `todo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `todo` should not be present in production code\n   --> $DIR/panicking_macros.rs:17:5\n    |\n LL |     todo!(\"message\");\n    |     ^^^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in the macro `todo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `todo` should not be present in production code\n   --> $DIR/panicking_macros.rs:18:5\n    |\n LL |     todo!(\"{} {}\", \"panic with\", \"multiple arguments\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in the macro `todo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `unimplemented` should not be present in production code\n   --> $DIR/panicking_macros.rs:24:5\n@@ -50,23 +45,18 @@ LL |     unimplemented!();\n    |     ^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::unimplemented` implied by `-D warnings`\n-   = note: this error originates in the macro `unimplemented` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `unimplemented` should not be present in production code\n   --> $DIR/panicking_macros.rs:25:5\n    |\n LL |     unimplemented!(\"message\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in the macro `unimplemented` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `unimplemented` should not be present in production code\n   --> $DIR/panicking_macros.rs:26:5\n    |\n LL |     unimplemented!(\"{} {}\", \"panic with\", \"multiple arguments\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in the macro `unimplemented` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: usage of the `unreachable!` macro\n   --> $DIR/panicking_macros.rs:32:5\n@@ -75,23 +65,18 @@ LL |     unreachable!();\n    |     ^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::unreachable` implied by `-D warnings`\n-   = note: this error originates in the macro `unreachable` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: usage of the `unreachable!` macro\n   --> $DIR/panicking_macros.rs:33:5\n    |\n LL |     unreachable!(\"message\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in the macro `$crate::unreachable` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: usage of the `unreachable!` macro\n   --> $DIR/panicking_macros.rs:34:5\n    |\n LL |     unreachable!(\"{} {}\", \"panic with\", \"multiple arguments\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in the macro `unreachable` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `panic` should not be present in production code\n   --> $DIR/panicking_macros.rs:40:5\n@@ -104,24 +89,18 @@ error: `todo` should not be present in production code\n    |\n LL |     todo!();\n    |     ^^^^^^^\n-   |\n-   = note: this error originates in the macro `todo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `unimplemented` should not be present in production code\n   --> $DIR/panicking_macros.rs:42:5\n    |\n LL |     unimplemented!();\n    |     ^^^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in the macro `unimplemented` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: usage of the `unreachable!` macro\n   --> $DIR/panicking_macros.rs:43:5\n    |\n LL |     unreachable!();\n    |     ^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in the macro `unreachable` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 16 previous errors\n "}, {"sha": "824506a4257efdf11a64220a7b0f513c5eeebc41", "filename": "tests/ui/unit_cmp.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/tests%2Fui%2Funit_cmp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b/tests%2Fui%2Funit_cmp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_cmp.stderr?ref=ba03dc70fd219273934b4fa3280ccaf7bb0dcd9b", "patch": "@@ -33,8 +33,6 @@ LL | |         },\n LL | |         }\n LL | |     );\n    | |_____^\n-   |\n-   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `debug_assert_eq` of unit values detected. This will always succeed\n   --> $DIR/unit_cmp.rs:32:5\n@@ -47,8 +45,6 @@ LL | |         },\n LL | |         }\n LL | |     );\n    | |_____^\n-   |\n-   = note: this error originates in the macro `$crate::assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `assert_ne` of unit values detected. This will always fail\n   --> $DIR/unit_cmp.rs:41:5\n@@ -61,8 +57,6 @@ LL | |         },\n LL | |         }\n LL | |     );\n    | |_____^\n-   |\n-   = note: this error originates in the macro `assert_ne` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `debug_assert_ne` of unit values detected. This will always fail\n   --> $DIR/unit_cmp.rs:49:5\n@@ -75,8 +69,6 @@ LL | |         },\n LL | |         }\n LL | |     );\n    | |_____^\n-   |\n-   = note: this error originates in the macro `$crate::assert_ne` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 6 previous errors\n "}]}