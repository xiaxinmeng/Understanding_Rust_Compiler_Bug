{"sha": "246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0NmM2NmE3ZjdmZDNmODVkN2Q2ZTQ3YTM2ZjE3YmFmYjBjY2IwOGE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-13T12:35:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-13T12:35:44Z"}, "message": "Merge #4867\n\n4867: Cleanup URL handling r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "106b31324ba619413a055a36bd61621b4ac1531a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/106b31324ba619413a055a36bd61621b4ac1531a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe5MggCRBK7hj4Ov3rIwAAdHIIACZvKdCLzS3GG5LdbIywE8Xx\nVoVHFW+PJitOlBk/jpEFLcr6AusvLaWw4SA4k2YNy/3c0exy6HMODD9f7Tk643kx\npMBnfFnnynPOzLlaRx/69WzONjXg17GfrhvtvlCaE21RuBSOhWtQUr65oENTjFdO\nJipdIhzuR+6ava6HlMlwoLmnCLQe+5Q217ZGKpzWiQ37WjQkpoX1Hu/qTyoZKJVu\ndGEghSZQX1uj7GEg21Dqpc//KE7Q5uMnxaXOcsFMVrF+BuUVRIBzdLvmyWCUdNK0\njjakZYBqS0m3jqBY9gOnHyXl8FttoC+z42GBETNvVvLb9siFGGBViSgXlWSyGo8=\n=Y7G/\n-----END PGP SIGNATURE-----\n", "payload": "tree 106b31324ba619413a055a36bd61621b4ac1531a\nparent d64b583e5a67e15db7151a7877871174655729a4\nparent 50bbf7233dcda8a27255f123622bf57651c9f51c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1592051744 +0000\ncommitter GitHub <noreply@github.com> 1592051744 +0000\n\nMerge #4867\n\n4867: Cleanup URL handling r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a", "html_url": "https://github.com/rust-lang/rust/commit/246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d64b583e5a67e15db7151a7877871174655729a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d64b583e5a67e15db7151a7877871174655729a4", "html_url": "https://github.com/rust-lang/rust/commit/d64b583e5a67e15db7151a7877871174655729a4"}, {"sha": "50bbf7233dcda8a27255f123622bf57651c9f51c", "url": "https://api.github.com/repos/rust-lang/rust/commits/50bbf7233dcda8a27255f123622bf57651c9f51c", "html_url": "https://github.com/rust-lang/rust/commit/50bbf7233dcda8a27255f123622bf57651c9f51c"}], "stats": {"total": 294, "additions": 134, "deletions": 160}, "files": [{"sha": "24ff9b280a808c7bcca3716aeeae454f88c7f1e2", "filename": "crates/rust-analyzer/src/diagnostics/to_proto.rs", "status": "modified", "additions": 4, "deletions": 69, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs?ref=246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a", "patch": "@@ -1,10 +1,6 @@\n //! This module provides the functionality needed to convert diagnostics from\n //! `cargo check` json format to the LSP diagnostic format.\n-use std::{\n-    collections::HashMap,\n-    path::{Component, Path, Prefix},\n-    str::FromStr,\n-};\n+use std::{collections::HashMap, path::Path};\n \n use lsp_types::{\n     Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, Location,\n@@ -13,7 +9,7 @@ use lsp_types::{\n use ra_flycheck::{Applicability, DiagnosticLevel, DiagnosticSpan, DiagnosticSpanMacroExpansion};\n use stdx::format_to;\n \n-use crate::{lsp_ext, Result};\n+use crate::{lsp_ext, to_proto::url_from_abs_path};\n \n /// Converts a Rust level string to a LSP severity\n fn map_level_to_severity(val: DiagnosticLevel) -> Option<DiagnosticSeverity> {\n@@ -65,7 +61,7 @@ fn map_span_to_location(span: &DiagnosticSpan, workspace_root: &Path) -> Locatio\n fn map_span_to_location_naive(span: &DiagnosticSpan, workspace_root: &Path) -> Location {\n     let mut file_name = workspace_root.to_path_buf();\n     file_name.push(&span.file_name);\n-    let uri = url_from_path_with_drive_lowercasing(file_name).unwrap();\n+    let uri = url_from_abs_path(&file_name);\n \n     // FIXME: this doesn't handle UTF16 offsets correctly\n     let range = Range::new(\n@@ -274,70 +270,16 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n         .collect()\n }\n \n-/// Returns a `Url` object from a given path, will lowercase drive letters if present.\n-/// This will only happen when processing windows paths.\n-///\n-/// When processing non-windows path, this is essentially the same as `Url::from_file_path`.\n-pub fn url_from_path_with_drive_lowercasing(path: impl AsRef<Path>) -> Result<Url> {\n-    let component_has_windows_drive = path.as_ref().components().any(|comp| {\n-        if let Component::Prefix(c) = comp {\n-            return matches!(c.kind(), Prefix::Disk(_) | Prefix::VerbatimDisk(_));\n-        }\n-        false\n-    });\n-\n-    // VSCode expects drive letters to be lowercased, where rust will uppercase the drive letters.\n-    let res = if component_has_windows_drive {\n-        let url_original = Url::from_file_path(&path)\n-            .map_err(|_| format!(\"can't convert path to url: {}\", path.as_ref().display()))?;\n-\n-        let drive_partition: Vec<&str> = url_original.as_str().rsplitn(2, ':').collect();\n-\n-        // There is a drive partition, but we never found a colon.\n-        // This should not happen, but in this case we just pass it through.\n-        if drive_partition.len() == 1 {\n-            return Ok(url_original);\n-        }\n-\n-        let joined = drive_partition[1].to_ascii_lowercase() + \":\" + drive_partition[0];\n-        let url = Url::from_str(&joined).expect(\"This came from a valid `Url`\");\n-\n-        url\n-    } else {\n-        Url::from_file_path(&path)\n-            .map_err(|_| format!(\"can't convert path to url: {}\", path.as_ref().display()))?\n-    };\n-    Ok(res)\n-}\n-\n #[cfg(test)]\n+#[cfg(not(windows))]\n mod tests {\n     use super::*;\n \n-    // `Url` is not able to parse windows paths on unix machines.\n-    #[test]\n-    #[cfg(target_os = \"windows\")]\n-    fn test_lowercase_drive_letter_with_drive() {\n-        let url = url_from_path_with_drive_lowercasing(\"C:\\\\Test\").unwrap();\n-\n-        assert_eq!(url.to_string(), \"file:///c:/Test\");\n-    }\n-\n-    #[test]\n-    #[cfg(target_os = \"windows\")]\n-    fn test_drive_without_colon_passthrough() {\n-        let url = url_from_path_with_drive_lowercasing(r#\"\\\\localhost\\C$\\my_dir\"#).unwrap();\n-\n-        assert_eq!(url.to_string(), \"file://localhost/C$/my_dir\");\n-    }\n-\n-    #[cfg(not(windows))]\n     fn parse_diagnostic(val: &str) -> ra_flycheck::Diagnostic {\n         serde_json::from_str::<ra_flycheck::Diagnostic>(val).unwrap()\n     }\n \n     #[test]\n-    #[cfg(not(windows))]\n     fn snap_rustc_incompatible_type_for_trait() {\n         let diag = parse_diagnostic(\n             r##\"{\n@@ -391,7 +333,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg(not(windows))]\n     fn snap_rustc_unused_variable() {\n         let diag = parse_diagnostic(\n             r##\"{\n@@ -474,7 +415,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg(not(windows))]\n     fn snap_rustc_wrong_number_of_parameters() {\n         let diag = parse_diagnostic(\n             r##\"{\n@@ -599,7 +539,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg(not(windows))]\n     fn snap_clippy_pass_by_ref() {\n         let diag = parse_diagnostic(\n             r##\"{\n@@ -720,7 +659,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg(not(windows))]\n     fn snap_rustc_mismatched_type() {\n         let diag = parse_diagnostic(\n             r##\"{\n@@ -764,7 +702,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg(not(windows))]\n     fn snap_handles_macro_location() {\n         let diag = parse_diagnostic(\n             r##\"{\n@@ -1036,7 +973,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg(not(windows))]\n     fn snap_macro_compiler_error() {\n         let diag = parse_diagnostic(\n             r##\"{\n@@ -1266,7 +1202,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg(not(windows))]\n     fn snap_multi_line_fix() {\n         let diag = parse_diagnostic(\n             r##\"{"}, {"sha": "40f856e6e86349ec8df74b006d5d3079bf4f040f", "filename": "crates/rust-analyzer/src/from_proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a", "patch": "@@ -17,7 +17,7 @@ pub(crate) fn text_range(line_index: &LineIndex, range: lsp_types::Range) -> Tex\n }\n \n pub(crate) fn file_id(world: &GlobalStateSnapshot, url: &lsp_types::Url) -> Result<FileId> {\n-    world.uri_to_file_id(url)\n+    world.url_to_file_id(url)\n }\n \n pub(crate) fn file_position("}, {"sha": "9d5685d88ed781cea5c6a54990493da3514ff699", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a", "patch": "@@ -22,10 +22,9 @@ use stdx::format_to;\n \n use crate::{\n     config::Config,\n-    diagnostics::{\n-        to_proto::url_from_path_with_drive_lowercasing, CheckFixes, DiagnosticCollection,\n-    },\n+    diagnostics::{CheckFixes, DiagnosticCollection},\n     main_loop::pending_requests::{CompletedRequest, LatestRequests},\n+    to_proto::url_from_abs_path,\n     vfs_glob::{Glob, RustPackageFilterBuilder},\n     LspError, Result,\n };\n@@ -274,8 +273,8 @@ impl GlobalStateSnapshot {\n         &self.analysis\n     }\n \n-    pub fn uri_to_file_id(&self, uri: &Url) -> Result<FileId> {\n-        let path = uri.to_file_path().map_err(|()| format!(\"invalid uri: {}\", uri))?;\n+    pub fn url_to_file_id(&self, url: &Url) -> Result<FileId> {\n+        let path = url.to_file_path().map_err(|()| format!(\"invalid uri: {}\", url))?;\n         let file = self.vfs.read().path2file(&path).ok_or_else(|| {\n             // Show warning as this file is outside current workspace\n             // FIXME: just handle such files, and remove `LspError::UNKNOWN_FILE`.\n@@ -287,11 +286,8 @@ impl GlobalStateSnapshot {\n         Ok(FileId(file.0))\n     }\n \n-    pub fn file_id_to_uri(&self, id: FileId) -> Result<Url> {\n-        let path = self.vfs.read().file2path(VfsFile(id.0));\n-        let url = url_from_path_with_drive_lowercasing(path)?;\n-\n-        Ok(url)\n+    pub fn file_id_to_url(&self, id: FileId) -> Url {\n+        file_id_to_url(&self.vfs.read(), id)\n     }\n \n     pub fn file_id_to_path(&self, id: FileId) -> PathBuf {\n@@ -302,12 +298,10 @@ impl GlobalStateSnapshot {\n         self.vfs.read().file_line_endings(VfsFile(id.0))\n     }\n \n-    pub fn path_to_uri(&self, root: SourceRootId, path: &RelativePathBuf) -> Result<Url> {\n+    pub fn path_to_url(&self, root: SourceRootId, path: &RelativePathBuf) -> Url {\n         let base = self.vfs.read().root2path(VfsRoot(root.0));\n         let path = path.to_path(base);\n-        let url = Url::from_file_path(&path)\n-            .map_err(|_| format!(\"can't convert path to url: {}\", path.display()))?;\n-        Ok(url)\n+        url_from_abs_path(&path)\n     }\n \n     pub fn status(&self) -> String {\n@@ -335,3 +329,8 @@ impl GlobalStateSnapshot {\n         self.workspaces.iter().find_map(|ws| ws.workspace_root_for(&path))\n     }\n }\n+\n+pub(crate) fn file_id_to_url(vfs: &Vfs, id: FileId) -> Url {\n+    let path = vfs.file2path(VfsFile(id.0));\n+    url_from_abs_path(&path)\n+}"}, {"sha": "8ec571b7093b0420f09410ef6017716808c6eda2", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a", "patch": "@@ -27,17 +27,17 @@ use ra_flycheck::{CheckTask, Status};\n use ra_ide::{Canceled, FileId, LibraryData, LineIndex, SourceRootId};\n use ra_prof::profile;\n use ra_project_model::{PackageRoot, ProjectWorkspace};\n-use ra_vfs::{VfsFile, VfsTask, Watch};\n+use ra_vfs::{VfsTask, Watch};\n use relative_path::RelativePathBuf;\n use rustc_hash::FxHashSet;\n use serde::{de::DeserializeOwned, Serialize};\n use threadpool::ThreadPool;\n \n use crate::{\n     config::{Config, FilesWatcher, LinkedProject},\n-    diagnostics::{to_proto::url_from_path_with_drive_lowercasing, DiagnosticTask},\n+    diagnostics::DiagnosticTask,\n     from_proto,\n-    global_state::{GlobalState, GlobalStateSnapshot},\n+    global_state::{file_id_to_url, GlobalState, GlobalStateSnapshot},\n     lsp_ext,\n     main_loop::{\n         pending_requests::{PendingRequest, PendingRequests},\n@@ -801,17 +801,9 @@ fn on_diagnostic_task(task: DiagnosticTask, msg_sender: &Sender<Message>, state:\n     let subscriptions = state.diagnostics.handle_task(task);\n \n     for file_id in subscriptions {\n-        let path = state.vfs.read().file2path(VfsFile(file_id.0));\n-        let uri = match url_from_path_with_drive_lowercasing(&path) {\n-            Ok(uri) => uri,\n-            Err(err) => {\n-                log::error!(\"Couldn't convert path to url ({}): {}\", err, path.display());\n-                continue;\n-            }\n-        };\n-\n+        let url = file_id_to_url(&state.vfs.read(), file_id);\n         let diagnostics = state.diagnostics.diagnostics_for(file_id).cloned().collect();\n-        let params = lsp_types::PublishDiagnosticsParams { uri, diagnostics, version: None };\n+        let params = lsp_types::PublishDiagnosticsParams { uri: url, diagnostics, version: None };\n         let not = notification_new::<lsp_types::notification::PublishDiagnostics>(params);\n         msg_sender.send(not.into()).unwrap();\n     }"}, {"sha": "b34b529b5ca2ef2d2e4c2fc859ea1ee8467756c1", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a", "patch": "@@ -258,7 +258,7 @@ pub fn handle_document_symbol(\n     let res = if snap.config.client_caps.hierarchical_symbols {\n         document_symbols.into()\n     } else {\n-        let url = to_proto::url(&snap, file_id)?;\n+        let url = to_proto::url(&snap, file_id);\n         let mut symbol_information = Vec::<SymbolInformation>::new();\n         for symbol in document_symbols {\n             flatten_document_symbol(&symbol, None, &url, &mut symbol_information);\n@@ -1160,7 +1160,7 @@ fn show_impl_command_link(\n ) -> Option<lsp_ext::CommandLinkGroup> {\n     if snap.config.hover.implementations {\n         if let Some(nav_data) = snap.analysis().goto_implementation(*position).unwrap_or(None) {\n-            let uri = to_proto::url(snap, position.file_id).ok()?;\n+            let uri = to_proto::url(snap, position.file_id);\n             let line_index = snap.analysis().file_line_index(position.file_id).ok()?;\n             let position = to_proto::position(&line_index, position.offset);\n             let locations: Vec<_> = nav_data"}, {"sha": "881aa1c55f9b186d62ee7eec0ab3799b9253d526", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 109, "deletions": 61, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a", "patch": "@@ -1,4 +1,7 @@\n //! Conversion of rust-analyzer specific types to lsp_types equivalents.\n+use std::path::{self, Path};\n+\n+use itertools::Itertools;\n use ra_db::{FileId, FileRange};\n use ra_ide::{\n     Assist, CompletionItem, CompletionItemKind, Documentation, FileSystemEdit, Fold, FoldKind,\n@@ -385,24 +388,55 @@ pub(crate) fn folding_range(\n     }\n }\n \n-pub(crate) fn url(snap: &GlobalStateSnapshot, file_id: FileId) -> Result<lsp_types::Url> {\n-    snap.file_id_to_uri(file_id)\n+pub(crate) fn url(snap: &GlobalStateSnapshot, file_id: FileId) -> lsp_types::Url {\n+    snap.file_id_to_url(file_id)\n+}\n+\n+/// Returns a `Url` object from a given path, will lowercase drive letters if present.\n+/// This will only happen when processing windows paths.\n+///\n+/// When processing non-windows path, this is essentially the same as `Url::from_file_path`.\n+pub(crate) fn url_from_abs_path(path: &Path) -> lsp_types::Url {\n+    assert!(path.is_absolute());\n+    let url = lsp_types::Url::from_file_path(path).unwrap();\n+    match path.components().next() {\n+        Some(path::Component::Prefix(prefix)) if matches!(prefix.kind(), path::Prefix::Disk(_) | path::Prefix::VerbatimDisk(_)) =>\n+        {\n+            // Need to lowercase driver letter\n+        }\n+        _ => return url,\n+    }\n+\n+    let driver_letter_range = {\n+        let (scheme, drive_letter, _rest) = match url.as_str().splitn(3, ':').collect_tuple() {\n+            Some(it) => it,\n+            None => return url,\n+        };\n+        let start = scheme.len() + ':'.len_utf8();\n+        start..(start + drive_letter.len())\n+    };\n+\n+    // Note: lowercasing the `path` itself doesn't help, the `Url::parse`\n+    // machinery *also* canonicalizes the drive letter. So, just massage the\n+    // string in place.\n+    let mut url = url.into_string();\n+    url[driver_letter_range].make_ascii_lowercase();\n+    lsp_types::Url::parse(&url).unwrap()\n }\n \n pub(crate) fn versioned_text_document_identifier(\n     snap: &GlobalStateSnapshot,\n     file_id: FileId,\n     version: Option<i64>,\n-) -> Result<lsp_types::VersionedTextDocumentIdentifier> {\n-    let res = lsp_types::VersionedTextDocumentIdentifier { uri: url(snap, file_id)?, version };\n-    Ok(res)\n+) -> lsp_types::VersionedTextDocumentIdentifier {\n+    lsp_types::VersionedTextDocumentIdentifier { uri: url(snap, file_id), version }\n }\n \n pub(crate) fn location(\n     snap: &GlobalStateSnapshot,\n     frange: FileRange,\n ) -> Result<lsp_types::Location> {\n-    let url = url(snap, frange.file_id)?;\n+    let url = url(snap, frange.file_id);\n     let line_index = snap.analysis().file_line_index(frange.file_id)?;\n     let range = range(&line_index, frange.range);\n     let loc = lsp_types::Location::new(url, range);\n@@ -438,7 +472,7 @@ fn location_info(\n ) -> Result<(lsp_types::Url, lsp_types::Range, lsp_types::Range)> {\n     let line_index = snap.analysis().file_line_index(target.file_id())?;\n \n-    let target_uri = url(snap, target.file_id())?;\n+    let target_uri = url(snap, target.file_id());\n     let target_range = range(&line_index, target.full_range());\n     let target_selection_range =\n         target.focus_range().map(|it| range(&line_index, it)).unwrap_or(target_range);\n@@ -478,7 +512,7 @@ pub(crate) fn snippet_text_document_edit(\n     is_snippet: bool,\n     source_file_edit: SourceFileEdit,\n ) -> Result<lsp_ext::SnippetTextDocumentEdit> {\n-    let text_document = versioned_text_document_identifier(snap, source_file_edit.file_id, None)?;\n+    let text_document = versioned_text_document_identifier(snap, source_file_edit.file_id, None);\n     let line_index = snap.analysis().file_line_index(source_file_edit.file_id)?;\n     let line_endings = snap.file_line_endings(source_file_edit.file_id);\n     let edits = source_file_edit\n@@ -492,19 +526,18 @@ pub(crate) fn snippet_text_document_edit(\n pub(crate) fn resource_op(\n     snap: &GlobalStateSnapshot,\n     file_system_edit: FileSystemEdit,\n-) -> Result<lsp_types::ResourceOp> {\n-    let res = match file_system_edit {\n+) -> lsp_types::ResourceOp {\n+    match file_system_edit {\n         FileSystemEdit::CreateFile { source_root, path } => {\n-            let uri = snap.path_to_uri(source_root, &path)?;\n+            let uri = snap.path_to_url(source_root, &path);\n             lsp_types::ResourceOp::Create(lsp_types::CreateFile { uri, options: None })\n         }\n         FileSystemEdit::MoveFile { src, dst_source_root, dst_path } => {\n-            let old_uri = snap.file_id_to_uri(src)?;\n-            let new_uri = snap.path_to_uri(dst_source_root, &dst_path)?;\n+            let old_uri = snap.file_id_to_url(src);\n+            let new_uri = snap.path_to_url(dst_source_root, &dst_path);\n             lsp_types::ResourceOp::Rename(lsp_types::RenameFile { old_uri, new_uri, options: None })\n         }\n-    };\n-    Ok(res)\n+    }\n }\n \n pub(crate) fn snippet_workspace_edit(\n@@ -513,7 +546,7 @@ pub(crate) fn snippet_workspace_edit(\n ) -> Result<lsp_ext::SnippetWorkspaceEdit> {\n     let mut document_changes: Vec<lsp_ext::SnippetDocumentChangeOperation> = Vec::new();\n     for op in source_change.file_system_edits {\n-        let op = resource_op(&snap, op)?;\n+        let op = resource_op(&snap, op);\n         document_changes.push(lsp_ext::SnippetDocumentChangeOperation::Op(op));\n     }\n     for edit in source_change.source_file_edits {\n@@ -568,7 +601,7 @@ impl From<lsp_ext::SnippetWorkspaceEdit> for lsp_types::WorkspaceEdit {\n     }\n }\n \n-pub fn call_hierarchy_item(\n+pub(crate) fn call_hierarchy_item(\n     snap: &GlobalStateSnapshot,\n     target: NavigationTarget,\n ) -> Result<lsp_types::CallHierarchyItem> {\n@@ -579,50 +612,6 @@ pub fn call_hierarchy_item(\n     Ok(lsp_types::CallHierarchyItem { name, kind, tags: None, detail, uri, range, selection_range })\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use test_utils::extract_ranges;\n-\n-    use super::*;\n-\n-    #[test]\n-    fn conv_fold_line_folding_only_fixup() {\n-        let text = r#\"<fold>mod a;\n-mod b;\n-mod c;</fold>\n-\n-fn main() <fold>{\n-    if cond <fold>{\n-        a::do_a();\n-    }</fold> else <fold>{\n-        b::do_b();\n-    }</fold>\n-}</fold>\"#;\n-\n-        let (ranges, text) = extract_ranges(text, \"fold\");\n-        assert_eq!(ranges.len(), 4);\n-        let folds = vec![\n-            Fold { range: ranges[0], kind: FoldKind::Mods },\n-            Fold { range: ranges[1], kind: FoldKind::Block },\n-            Fold { range: ranges[2], kind: FoldKind::Block },\n-            Fold { range: ranges[3], kind: FoldKind::Block },\n-        ];\n-\n-        let line_index = LineIndex::new(&text);\n-        let converted: Vec<lsp_types::FoldingRange> =\n-            folds.into_iter().map(|it| folding_range(&text, &line_index, true, it)).collect();\n-\n-        let expected_lines = [(0, 2), (4, 10), (5, 6), (7, 9)];\n-        assert_eq!(converted.len(), expected_lines.len());\n-        for (folding_range, (start_line, end_line)) in converted.iter().zip(expected_lines.iter()) {\n-            assert_eq!(folding_range.start_line, *start_line);\n-            assert_eq!(folding_range.start_character, None);\n-            assert_eq!(folding_range.end_line, *end_line);\n-            assert_eq!(folding_range.end_character, None);\n-        }\n-    }\n-}\n-\n pub(crate) fn unresolved_code_action(\n     snap: &GlobalStateSnapshot,\n     assist: Assist,\n@@ -676,3 +665,62 @@ pub(crate) fn runnable(\n         },\n     })\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use test_utils::extract_ranges;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn conv_fold_line_folding_only_fixup() {\n+        let text = r#\"<fold>mod a;\n+mod b;\n+mod c;</fold>\n+\n+fn main() <fold>{\n+    if cond <fold>{\n+        a::do_a();\n+    }</fold> else <fold>{\n+        b::do_b();\n+    }</fold>\n+}</fold>\"#;\n+\n+        let (ranges, text) = extract_ranges(text, \"fold\");\n+        assert_eq!(ranges.len(), 4);\n+        let folds = vec![\n+            Fold { range: ranges[0], kind: FoldKind::Mods },\n+            Fold { range: ranges[1], kind: FoldKind::Block },\n+            Fold { range: ranges[2], kind: FoldKind::Block },\n+            Fold { range: ranges[3], kind: FoldKind::Block },\n+        ];\n+\n+        let line_index = LineIndex::new(&text);\n+        let converted: Vec<lsp_types::FoldingRange> =\n+            folds.into_iter().map(|it| folding_range(&text, &line_index, true, it)).collect();\n+\n+        let expected_lines = [(0, 2), (4, 10), (5, 6), (7, 9)];\n+        assert_eq!(converted.len(), expected_lines.len());\n+        for (folding_range, (start_line, end_line)) in converted.iter().zip(expected_lines.iter()) {\n+            assert_eq!(folding_range.start_line, *start_line);\n+            assert_eq!(folding_range.start_character, None);\n+            assert_eq!(folding_range.end_line, *end_line);\n+            assert_eq!(folding_range.end_character, None);\n+        }\n+    }\n+\n+    // `Url` is not able to parse windows paths on unix machines.\n+    #[test]\n+    #[cfg(target_os = \"windows\")]\n+    fn test_lowercase_drive_letter_with_drive() {\n+        let url = url_from_abs_path(Path::new(\"C:\\\\Test\"));\n+        assert_eq!(url.to_string(), \"file:///c:/Test\");\n+    }\n+\n+    #[test]\n+    #[cfg(target_os = \"windows\")]\n+    fn test_drive_without_colon_passthrough() {\n+        let url = url_from_abs_path(Path::new(r#\"\\\\localhost\\C$\\my_dir\"#));\n+        assert_eq!(url.to_string(), \"file://localhost/C$/my_dir\");\n+    }\n+}"}]}