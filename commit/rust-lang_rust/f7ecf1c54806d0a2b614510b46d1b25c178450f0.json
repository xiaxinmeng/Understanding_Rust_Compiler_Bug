{"sha": "f7ecf1c54806d0a2b614510b46d1b25c178450f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3ZWNmMWM1NDgwNmQwYTJiNjE0NTEwYjQ2ZDFiMjVjMTc4NDUwZjA=", "commit": {"author": {"name": "Cedric", "email": "cedric.brancourt@gmail.com", "date": "2019-06-17T18:04:26Z"}, "committer": {"name": "Cedric", "email": "cedric.brancourt@gmail.com", "date": "2019-06-17T18:04:26Z"}, "message": "suggest tuple struct syntax", "tree": {"sha": "db780716833378b7fbfde317746736ec44cf9fb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db780716833378b7fbfde317746736ec44cf9fb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7ecf1c54806d0a2b614510b46d1b25c178450f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7ecf1c54806d0a2b614510b46d1b25c178450f0", "html_url": "https://github.com/rust-lang/rust/commit/f7ecf1c54806d0a2b614510b46d1b25c178450f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7ecf1c54806d0a2b614510b46d1b25c178450f0/comments", "author": {"login": "Electron-libre", "id": 5979, "node_id": "MDQ6VXNlcjU5Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/5979?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Electron-libre", "html_url": "https://github.com/Electron-libre", "followers_url": "https://api.github.com/users/Electron-libre/followers", "following_url": "https://api.github.com/users/Electron-libre/following{/other_user}", "gists_url": "https://api.github.com/users/Electron-libre/gists{/gist_id}", "starred_url": "https://api.github.com/users/Electron-libre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Electron-libre/subscriptions", "organizations_url": "https://api.github.com/users/Electron-libre/orgs", "repos_url": "https://api.github.com/users/Electron-libre/repos", "events_url": "https://api.github.com/users/Electron-libre/events{/privacy}", "received_events_url": "https://api.github.com/users/Electron-libre/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Electron-libre", "id": 5979, "node_id": "MDQ6VXNlcjU5Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/5979?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Electron-libre", "html_url": "https://github.com/Electron-libre", "followers_url": "https://api.github.com/users/Electron-libre/followers", "following_url": "https://api.github.com/users/Electron-libre/following{/other_user}", "gists_url": "https://api.github.com/users/Electron-libre/gists{/gist_id}", "starred_url": "https://api.github.com/users/Electron-libre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Electron-libre/subscriptions", "organizations_url": "https://api.github.com/users/Electron-libre/orgs", "repos_url": "https://api.github.com/users/Electron-libre/repos", "events_url": "https://api.github.com/users/Electron-libre/events{/privacy}", "received_events_url": "https://api.github.com/users/Electron-libre/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b01a257da1fbb3f5661029dd390fdccc49dff287", "url": "https://api.github.com/repos/rust-lang/rust/commits/b01a257da1fbb3f5661029dd390fdccc49dff287", "html_url": "https://github.com/rust-lang/rust/commit/b01a257da1fbb3f5661029dd390fdccc49dff287"}], "stats": {"total": 83, "additions": 49, "deletions": 34}, "files": [{"sha": "06d07d992427e1a7f3ab916321adba65eebc20b9", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f7ecf1c54806d0a2b614510b46d1b25c178450f0/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ecf1c54806d0a2b614510b46d1b25c178450f0/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=f7ecf1c54806d0a2b614510b46d1b25c178450f0", "patch": "@@ -1215,38 +1215,49 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             },\n             ty);\n-        // prevent all specified fields from being suggested\n-        let skip_fields = skip_fields.iter().map(|ref x| x.ident.as_str());\n-        if let Some(field_name) = Self::suggest_field_name(variant,\n-                                                           &field.ident.as_str(),\n-                                                           skip_fields.collect()) {\n-            err.span_suggestion(\n-                field.ident.span,\n-                \"a field with a similar name exists\",\n-                field_name.to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-        } else {\n-            match ty.sty {\n-                ty::Adt(adt, ..) => {\n-                    if adt.is_enum() {\n-                        err.span_label(field.ident.span,\n-                                       format!(\"`{}::{}` does not have this field\",\n-                                               ty, variant.ident));\n-                    } else {\n-                        err.span_label(field.ident.span,\n-                                       format!(\"`{}` does not have this field\", ty));\n-                    }\n-                    let available_field_names = self.available_field_names(variant);\n-                    if !available_field_names.is_empty() {\n-                        err.note(&format!(\"available fields are: {}\",\n-                                          self.name_series_display(available_field_names)));\n+        match variant.ctor_kind {\n+            CtorKind::Fn => {\n+                err.span_label(field.ident.span, \"field does not exist\");\n+                err.span_label(\n+                    field.ident.span,\n+                    format!(\"`{adt}` is a tuple {kind_name}, use the appropriate syntax: `{adt}(/* fields */)`\", adt=ty, kind_name=kind_name)\n+                );\n+            }\n+            _ => {\n+                // prevent all specified fields from being suggested\n+                let skip_fields = skip_fields.iter().map(|ref x| x.ident.as_str());\n+                if let Some(field_name) = Self::suggest_field_name(variant,\n+                                                                   &field.ident.as_str(),\n+                                                                   skip_fields.collect()) {\n+                    err.span_suggestion(\n+                        field.ident.span,\n+                        \"a field with a similar name exists\",\n+                        field_name.to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                } else {\n+                    match ty.sty {\n+                        ty::Adt(adt, ..) => {\n+                            if adt.is_enum() {\n+                                err.span_label(field.ident.span,\n+                                               format!(\"`{}::{}` does not have this field\",\n+                                                       ty, variant.ident));\n+                            } else {\n+                                err.span_label(field.ident.span,\n+                                               format!(\"`{}` does not have this field\", ty));\n+                            }\n+                            let available_field_names = self.available_field_names(variant);\n+                            if !available_field_names.is_empty() {\n+                                err.note(&format!(\"available fields are: {}\",\n+                                                  self.name_series_display(available_field_names)));\n+                            }\n+                        }\n+                        _ => bug!(\"non-ADT passed to report_unknown_field\")\n                     }\n-                }\n-                _ => bug!(\"non-ADT passed to report_unknown_field\")\n+                };\n             }\n-        };\n-        err.emit();\n+        }\n+            err.emit();\n     }\n \n     // Return an hint about the closest match in field names"}, {"sha": "557ee5593f373e3069359705c2a749a1ba3461d4", "filename": "src/test/ui/issues/issue-4736.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f7ecf1c54806d0a2b614510b46d1b25c178450f0/src%2Ftest%2Fui%2Fissues%2Fissue-4736.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f7ecf1c54806d0a2b614510b46d1b25c178450f0/src%2Ftest%2Fui%2Fissues%2Fissue-4736.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-4736.stderr?ref=f7ecf1c54806d0a2b614510b46d1b25c178450f0", "patch": "@@ -2,7 +2,10 @@ error[E0560]: struct `NonCopyable` has no field named `p`\n   --> $DIR/issue-4736.rs:4:26\n    |\n LL |     let z = NonCopyable{ p: () };\n-   |                          ^ help: a field with a similar name exists: `0`\n+   |                          ^\n+   |                          |\n+   |                          field does not exist\n+   |                          `NonCopyable` is a tuple struct, use the appropriate syntax: `NonCopyable(/* fields */)`\n \n error: aborting due to previous error\n "}, {"sha": "fef7486b8536d88562c969ac416afc3045c7d5d0", "filename": "src/test/ui/numeric/numeric-fields.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f7ecf1c54806d0a2b614510b46d1b25c178450f0/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-fields.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f7ecf1c54806d0a2b614510b46d1b25c178450f0/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-fields.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-fields.stderr?ref=f7ecf1c54806d0a2b614510b46d1b25c178450f0", "patch": "@@ -2,9 +2,10 @@ error[E0560]: struct `S` has no field named `0b1`\n   --> $DIR/numeric-fields.rs:4:15\n    |\n LL |     let s = S{0b1: 10, 0: 11};\n-   |               ^^^ `S` does not have this field\n-   |\n-   = note: available fields are: `0`, `1`\n+   |               ^^^\n+   |               |\n+   |               field does not exist\n+   |               `S` is a tuple struct, use the appropriate syntax: `S(/* fields */)`\n \n error[E0026]: struct `S` does not have a field named `0x1`\n   --> $DIR/numeric-fields.rs:7:17"}]}