{"sha": "b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2OTcxZDk0ZGZhNjdmNGUwY2U4MWMyY2Q3MGFmNmY4YjFkYWQ4ZmE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-31T17:58:30Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-31T18:00:47Z"}, "message": "Consolidate formatting functions a bit more.", "tree": {"sha": "d7828372428a6dd64f22d147cbafee4cd253fe50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7828372428a6dd64f22d147cbafee4cd253fe50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa", "html_url": "https://github.com/rust-lang/rust/commit/b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55e3cd41de71a35512bee745b4ababd8c007ac07", "url": "https://api.github.com/repos/rust-lang/rust/commits/55e3cd41de71a35512bee745b4ababd8c007ac07", "html_url": "https://github.com/rust-lang/rust/commit/55e3cd41de71a35512bee745b4ababd8c007ac07"}], "stats": {"total": 341, "additions": 132, "deletions": 209}, "files": [{"sha": "a8da7294928dfa0998af20811e1dc4f16779fd15", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa", "patch": "@@ -1597,7 +1597,7 @@ fn stmt_to_expr(@ast::stmt stmt) -> option::t[@ast::expr] {\n     ret none[@ast::expr];\n }\n \n-fn stmt_ends_with_semi(@ast::stmt stmt) -> bool {\n+fn stmt_ends_with_semi(&ast::stmt stmt) -> bool {\n     alt (stmt.node) {\n         case (ast::stmt_decl(?d,_)) {\n             alt (d.node) {\n@@ -1675,7 +1675,7 @@ fn parse_block(&parser p) -> ast::block {\n                             }\n                             case (token::RBRACE) { expr = some(e); }\n                             case (?t) {\n-                                if (stmt_ends_with_semi(stmt)) {\n+                                if (stmt_ends_with_semi(*stmt)) {\n                                     p.err(\"expected ';' or '}' after \" +\n                                           \"expression but found \" +\n                                           token::to_str(p.get_reader(), t));\n@@ -1692,7 +1692,7 @@ fn parse_block(&parser p) -> ast::block {\n                         // used in branches and binary expressions in rustboot\n                         // means we cannot use && here. I know, right?\n                         if (p.get_file_type() == SOURCE_FILE) {\n-                            if (stmt_ends_with_semi(stmt)) {\n+                            if (stmt_ends_with_semi(*stmt)) {\n                                 expect(p, token::SEMI);\n                             }\n                         }"}, {"sha": "eb44641b31190eef469a935282b2f758d202493e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa", "patch": "@@ -4642,8 +4642,8 @@ fn trans_lval(&@block_ctxt cx, &@ast::expr e) -> lval_result {\n         }\n         case (_) {\n             cx.fcx.lcx.ccx.sess.span_unimpl(e.span,\n-                                            \"expr variant in trans_lval: \" \n-                                            + util::common::expr_to_str(e));\n+                                            \"expr variant in trans_lval: \"\n+                                            + pretty::pprust::expr_to_str(e));\n         }\n     }\n     fail;\n@@ -5784,7 +5784,7 @@ fn trans_log(int lvl, &@block_ctxt cx, &@ast::expr e) -> result {\n fn trans_check_expr(&@block_ctxt cx, &@ast::expr e) -> result {\n     auto cond_res = trans_expr(cx, e);\n \n-    auto expr_str = util::common::expr_to_str(e);\n+    auto expr_str = pretty::pprust::expr_to_str(e);\n     auto fail_cx = new_sub_block_ctxt(cx, \"fail\");\n     auto fail_res = trans_fail(fail_cx, some[common::span](e.span), expr_str);\n \n@@ -6004,9 +6004,9 @@ fn trans_spawn(&@block_ctxt cx,\n     // Make the task name\n     auto tname = alt(name) {\n         case(none) {\n-            auto argss = vec::map(common::expr_to_str, args);\n+            auto argss = vec::map(pretty::pprust::expr_to_str, args);\n             #fmt(\"%s(%s)\",\n-                 common::expr_to_str(func),\n+                 pretty::pprust::expr_to_str(func),\n                  str::connect(argss, \", \"))\n         }\n         case(some(?n)) {"}, {"sha": "02da5d01bc8962a950e61595b85e0f515fcc6e2f", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa", "patch": "@@ -55,7 +55,7 @@ import aux::fixed_point_states;\n import aux::bitv_to_str;\n import aux::first_difference_string;\n \n-import util::common::ty_to_str;\n+import pretty::pprust::ty_to_str;\n import util::common::log_stmt_err;\n import aux::log_bitv_err;\n import bitvectors::promises;\n@@ -74,7 +74,7 @@ fn check_states_expr(&fn_ctxt fcx, @expr e) -> () {\n         auto diff = first_difference_string(fcx, prec, pres);\n         s += (\"Unsatisfied precondition constraint (for example, \"\n               + diff + \") for expression:\\n\");\n-        s += util::common::expr_to_str(e);\n+        s += pretty::pprust::expr_to_str(e);\n         s += (\"\\nPrecondition:\\n\");\n         s += bitv_to_str(fcx, prec);\n         s += (\"\\nPrestate:\\n\");\n@@ -102,7 +102,7 @@ fn check_states_stmt(&fn_ctxt fcx, &stmt s) -> () {\n         auto diff = first_difference_string(fcx, prec, pres);\n         ss += (\"Unsatisfied precondition constraint (for example, \"\n               + diff + \") for statement:\\n\");\n-        ss += util::common::stmt_to_str(s);\n+        ss += pretty::pprust::stmt_to_str(s);\n         ss += (\"\\nPrecondition:\\n\");\n         ss += bitv_to_str(fcx, prec);\n         ss += (\"\\nPrestate: \\n\");"}, {"sha": "38283d1f754591a386e0c048a949b5f38f21f1b3", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa", "patch": "@@ -513,7 +513,9 @@ fn cname(&ctxt cx, &t typ) -> option::t[str] {\n fn path_to_str(&ast::path pth) -> str {\n     auto result = str::connect(pth.node.idents,  \"::\");\n     if (vec::len[@ast::ty](pth.node.types) > 0u) {\n-        auto f = pretty::pprust::ty_to_str;\n+        fn f(&@ast::ty t) -> str {\n+            ret pretty::pprust::ty_to_str(*t);\n+        }\n         result += \"[\";\n         result += str::connect(vec::map(f, pth.node.types), \",\");\n         result += \"]\";"}, {"sha": "d0bf818b8275a3df9936dd80744ae3ee225ae1ec", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa", "patch": "@@ -1517,7 +1517,7 @@ mod pushdown {\n             case (_) {\n                 scx.fcx.ccx.tcx.sess.span_unimpl(e.span,\n                     #fmt(\"type unification for expression variant: %s\",\n-                         util::common::expr_to_str(e)));\n+                         pretty::pprust::expr_to_str(e)));\n                 fail;\n             }\n         }\n@@ -1803,7 +1803,7 @@ fn require_pure_function(@crate_ctxt ccx, &ast::def_id d_id, &span sp) -> () {\n \n fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n     // scx.fcx.ccx.tcx.sess.span_warn(expr.span, \"typechecking expr \" +\n-    //                                util::common::expr_to_str(expr));\n+    //                                pretty::pprust::expr_to_str(expr));\n \n     // A generic function to factor out common logic from call and bind\n     // expressions."}, {"sha": "104beee7db4db99aeaf47135fdf51714210a8e3b", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 106, "deletions": 97, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa", "patch": "@@ -41,6 +41,22 @@ type ps = @rec(pp::printer s,\n                mutable uint cur_cmnt,\n                mode mode);\n \n+fn rust_printer(io::writer writer) -> ps {\n+    ret @rec(s=pp::mk_printer(writer, default_columns),\n+             cm=option::none[codemap],\n+             comments=option::none[vec[lexer::cmnt]],\n+             mutable cur_cmnt=0u,\n+             mode=mo_untyped);\n+}\n+\n+fn to_str[T](&T t, fn(&ps s, &T s) f) -> str {\n+    auto writer = io::string_writer();\n+    auto s = rust_printer(writer.get_writer());\n+    f(s, t);\n+    eof(s.s);\n+    ret writer.get_str();\n+}\n+\n fn print_file(session sess, ast::_mod _mod, str filename, io::writer out,\n               mode mode) {\n     auto cmnts = lexer::gather_comments(sess, filename);\n@@ -53,25 +69,24 @@ fn print_file(session sess, ast::_mod _mod, str filename, io::writer out,\n     eof(s.s);\n }\n \n-fn ty_to_str(&@ast::ty ty) -> str {\n+fn ty_to_str(&ast::ty ty) -> str { be to_str(ty, print_type); }\n+fn pat_to_str(&@ast::pat ty) -> str { be to_str(ty, print_pat); }\n+fn expr_to_str(&@ast::expr ty) -> str { be to_str(ty, print_expr); }\n+fn stmt_to_str(&ast::stmt ty) -> str { be to_str(ty, print_stmt); }\n+fn item_to_str(&@ast::item ty) -> str { be to_str(ty, print_item); }\n+\n+fn fun_to_str(&ast::_fn f, str name, vec[ast::ty_param] params) -> str {\n     auto writer = io::string_writer();\n-    auto s = @rec(s=pp::mk_printer(writer.get_writer(), default_columns),\n-                  cm=option::none[codemap],\n-                  comments=option::none[vec[lexer::cmnt]],\n-                  mutable cur_cmnt=0u,\n-                  mode=mo_untyped);\n-    print_type(s, ty);\n+    auto s = rust_printer(writer.get_writer());\n+    print_fn(s, f.decl, name, params);\n     eof(s.s);\n     ret writer.get_str();\n }\n \n fn block_to_str(&ast::block blk) -> str {\n     auto writer = io::string_writer();\n-    auto s = @rec(s=pp::mk_printer(writer.get_writer(), default_columns),\n-                  cm=option::none[codemap],\n-                  comments=option::none[vec[lexer::cmnt]],\n-                  mutable cur_cmnt=0u,\n-                  mode=mo_untyped);\n+    auto s = rust_printer(writer.get_writer());\n+\n     // containing cbox, will be closed by print-block at }\n     cbox(s.s, indent_unit);\n \n@@ -82,37 +97,25 @@ fn block_to_str(&ast::block blk) -> str {\n     ret writer.get_str();\n }\n \n-fn pat_to_str(&@ast::pat p) -> str {\n-    auto writer = io::string_writer();\n-    auto s = @rec(s=pp::mk_printer(writer.get_writer(), default_columns),\n-                  cm=option::none[codemap],\n-                  comments=option::none[vec[lexer::cmnt]],\n-                  mutable cur_cmnt=0u,\n-                  mode=mo_untyped);\n-    print_pat(s, p);\n-    eof(s.s);\n-    ret writer.get_str();\n-}\n-\n-fn word_nbsp(ps s, str w) {\n+fn word_nbsp(&ps s, str w) {\n     word(s.s, w);\n     word(s.s, \" \");\n }\n \n-fn word_space(ps s, str w) {\n+fn word_space(&ps s, str w) {\n     word(s.s, w);\n     space(s.s);\n }\n \n-fn popen(ps s) {\n+fn popen(&ps s) {\n     word(s.s, \"(\");\n }\n \n-fn pclose(ps s) {\n+fn pclose(&ps s) {\n     word(s.s, \")\");\n }\n \n-fn head(ps s, str w) {\n+fn head(&ps s, str w) {\n     // outer-box is consistent\n     cbox(s.s, indent_unit);\n     // head-box is inconsistent\n@@ -121,19 +124,19 @@ fn head(ps s, str w) {\n     word_nbsp(s, w);\n }\n \n-fn bopen(ps s) {\n+fn bopen(&ps s) {\n     word(s.s, \"{\");\n     end(s.s); // close the head-box\n }\n \n-fn bclose(ps s, common::span span) {\n+fn bclose(&ps s, common::span span) {\n     maybe_print_comment(s, span.hi);\n     break_offset(s.s, 1u, -(indent_unit as int));\n     word(s.s, \"}\");\n     end(s.s); // close the outer-box\n }\n \n-fn commasep[IN](ps s, breaks b, vec[IN] elts, fn(ps, &IN) op) {\n+fn commasep[IN](&ps s, breaks b, vec[IN] elts, fn(&ps, &IN) op) {\n     box(s.s, 0u, b);\n     auto first = true;\n     for (IN elt in elts) {\n@@ -144,7 +147,7 @@ fn commasep[IN](ps s, breaks b, vec[IN] elts, fn(ps, &IN) op) {\n     end(s.s);\n }\n \n-fn commasep_cmnt[IN](ps s, breaks b, vec[IN] elts, fn(ps, &IN) op,\n+fn commasep_cmnt[IN](&ps s, breaks b, vec[IN] elts, fn(&ps, &IN) op,\n                      fn(&IN) -> common::span get_span) {\n     box(s.s, 0u, b);\n     auto len = vec::len[IN](elts);\n@@ -162,14 +165,14 @@ fn commasep_cmnt[IN](ps s, breaks b, vec[IN] elts, fn(ps, &IN) op,\n     end(s.s);\n }\n \n-fn commasep_exprs(ps s, breaks b, vec[@ast::expr] exprs) {\n+fn commasep_exprs(&ps s, breaks b, vec[@ast::expr] exprs) {\n     fn expr_span(&@ast::expr expr) -> common::span {ret expr.span;}\n     auto f = print_expr;\n     auto gs = expr_span;\n     commasep_cmnt[@ast::expr](s, b, exprs, f, gs);\n }\n \n-fn print_mod(ps s, ast::_mod _mod) {\n+fn print_mod(&ps s, ast::_mod _mod) {\n     for (@ast::view_item vitem in _mod.view_items) {\n         print_view_item(s, vitem);\n     }\n@@ -181,7 +184,8 @@ fn print_mod(ps s, ast::_mod _mod) {\n     print_remaining_comments(s);\n }\n \n-fn print_type(ps s, &@ast::ty ty) {\n+fn print_boxed_type(&ps s, &@ast::ty ty) { print_type(s, *ty); }\n+fn print_type(&ps s, &ast::ty ty) {\n \n     maybe_print_comment(s, ty.span.lo);\n     ibox(s.s, 0u);\n@@ -200,10 +204,10 @@ fn print_type(ps s, &@ast::ty ty) {\n             word(s.s, \"vec[\"); print_mt(s, mt); word(s.s, \"]\");\n         }\n         case (ast::ty_port(?t)) {\n-            word(s.s, \"port[\"); print_type(s, t); word(s.s, \"]\");\n+            word(s.s, \"port[\"); print_type(s, *t); word(s.s, \"]\");\n         }\n         case (ast::ty_chan(?t)) {\n-            word(s.s, \"chan[\"); print_type(s, t); word(s.s, \"]\");\n+            word(s.s, \"chan[\"); print_type(s, *t); word(s.s, \"]\");\n         }\n         case (ast::ty_type) {word(s.s, \"type\");}\n         case (ast::ty_tup(?elts)) {\n@@ -216,7 +220,7 @@ fn print_type(ps s, &@ast::ty ty) {\n         case (ast::ty_rec(?fields)) {\n             word(s.s, \"rec\");\n             popen(s);\n-            fn print_field(ps s, &ast::ty_field f) {\n+            fn print_field(&ps s, &ast::ty_field f) {\n                 cbox(s.s, indent_unit);\n                 print_mt(s, f.mt);\n                 space(s.s);\n@@ -257,14 +261,14 @@ fn print_type(ps s, &@ast::ty ty) {\n     end(s.s);\n }\n \n-fn print_item(ps s, @ast::item item) {\n+fn print_item(&ps s, &@ast::item item) {\n \n     hardbreak(s.s);\n     maybe_print_comment(s, item.span.lo);\n     alt (item.node) {\n         case (ast::item_const(?id, ?ty, ?expr, _, _)) {\n             head(s, \"const\");\n-            print_type(s, ty);\n+            print_type(s, *ty);\n             space(s.s);\n             word_space(s, id);\n             end(s.s); // end the head-ibox\n@@ -330,7 +334,7 @@ fn print_item(ps s, @ast::item item) {\n             end(s.s); // end the inner ibox\n             space(s.s);\n             word_space(s, \"=\");\n-            print_type(s, ty);\n+            print_type(s, *ty);\n             word(s.s, \";\");\n             end(s.s); // end the outer ibox\n             break_offset(s.s, 0u, 0);\n@@ -347,8 +351,8 @@ fn print_item(ps s, @ast::item item) {\n                 word(s.s, v.node.name);\n                 if (vec::len[ast::variant_arg](v.node.args) > 0u) {\n                     popen(s);\n-                    fn print_variant_arg(ps s, &ast::variant_arg arg) {\n-                        print_type(s, arg.ty);\n+                    fn print_variant_arg(&ps s, &ast::variant_arg arg) {\n+                        print_type(s, *arg.ty);\n                     }\n                     auto f = print_variant_arg;\n                     commasep[ast::variant_arg](s, consistent, v.node.args, f);\n@@ -364,9 +368,9 @@ fn print_item(ps s, @ast::item item) {\n             word(s.s, id);\n             print_type_params(s, params);\n             popen(s);\n-            fn print_field(ps s, &ast::obj_field field) {\n+            fn print_field(&ps s, &ast::obj_field field) {\n                 ibox(s.s, indent_unit);\n-                print_type(s, field.ty);\n+                print_type(s, *field.ty);\n                 space(s.s);\n                 word(s.s, field.ident);\n                 end(s.s);\n@@ -398,23 +402,28 @@ fn print_item(ps s, @ast::item item) {\n     }\n }\n \n-fn print_block(ps s, ast::block blk) {\n+fn print_stmt(&ps s, &ast::stmt st) {\n+    maybe_print_comment(s, st.span.lo);\n+    alt (st.node) {\n+        case (ast::stmt_decl(?decl,_)) {\n+            print_decl(s, decl);\n+        }\n+        case (ast::stmt_expr(?expr,_)) {\n+            space(s.s);\n+            print_expr(s, expr);\n+        }\n+    }\n+    if (front::parser::stmt_ends_with_semi(st)) {word(s.s, \";\");}\n+    maybe_print_trailing_comment(s, st.span);\n+}\n+\n+fn print_block(&ps s, ast::block blk) {\n     maybe_print_comment(s, blk.span.lo);\n     bopen(s);\n     auto first = true;\n     for (@ast::stmt st in blk.node.stmts) {\n-        maybe_print_comment(s, st.span.lo);\n-        alt (st.node) {\n-          case (ast::stmt_decl(?decl,_)) {\n-              print_decl(s, decl);\n-          }\n-          case (ast::stmt_expr(?expr,_)) {\n-              space(s.s);\n-              print_expr(s, expr);\n-          }\n-        }\n-        if (front::parser::stmt_ends_with_semi(st)) {word(s.s, \";\");}\n-        maybe_print_trailing_comment(s, st.span);\n+        print_stmt(s, *st)\n+\n     }\n     alt (blk.node.expr) {\n         case (option::some[@ast::expr](?expr)) {\n@@ -427,7 +436,7 @@ fn print_block(ps s, ast::block blk) {\n     bclose(s, blk.span);\n }\n \n-fn print_literal(ps s, @ast::lit lit) {\n+fn print_literal(&ps s, &@ast::lit lit) {\n     maybe_print_comment(s, lit.span.lo);\n     alt (lit.node) {\n         case (ast::lit_str(?st)) {print_string(s, st);}\n@@ -460,7 +469,7 @@ fn print_literal(ps s, @ast::lit lit) {\n     }\n }\n \n-fn print_expr(ps s, &@ast::expr expr) {\n+fn print_expr(&ps s, &@ast::expr expr) {\n     maybe_print_comment(s, expr.span.lo);\n     ibox(s.s, indent_unit);\n \n@@ -481,7 +490,7 @@ fn print_expr(ps s, &@ast::expr expr) {\n             end(s.s);\n         }\n         case (ast::expr_tup(?exprs,_)) {\n-            fn printElt(ps s, &ast::elt elt) {\n+            fn printElt(&ps s, &ast::elt elt) {\n                 ibox(s.s, indent_unit);\n                 if (elt.mut == ast::mut) {word_nbsp(s, \"mutable\");}\n                 print_expr(s, elt.expr);\n@@ -496,7 +505,7 @@ fn print_expr(ps s, &@ast::expr expr) {\n             pclose(s);\n         }\n         case (ast::expr_rec(?fields,?wth,_)) {\n-            fn print_field(ps s, &ast::field field) {\n+            fn print_field(&ps s, &ast::field field) {\n                 ibox(s.s, indent_unit);\n                 if (field.node.mut == ast::mut) {word_nbsp(s, \"mutable\");}\n                 word(s.s, field.node.ident);\n@@ -535,7 +544,7 @@ fn print_expr(ps s, &@ast::expr expr) {\n             print_ident(s, ident);\n         }\n         case (ast::expr_bind(?func,?args,_)) {\n-            fn print_opt(ps s, &option::t[@ast::expr] expr) {\n+            fn print_opt(&ps s, &option::t[@ast::expr] expr) {\n                 alt (expr) {\n                     case (option::some[@ast::expr](?expr)) {\n                         print_expr(s, expr);\n@@ -575,7 +584,7 @@ fn print_expr(ps s, &@ast::expr expr) {\n             print_maybe_parens(s, expr, front::parser::as_prec);\n             space(s.s);\n             word_space(s, \"as\");\n-            print_type(s, ty);\n+            print_type(s, *ty);\n         }\n         case (ast::expr_if(?test,?block,?elseopt,_)) {\n             head(s, \"if\");\n@@ -802,7 +811,7 @@ fn print_expr(ps s, &@ast::expr expr) {\n     end(s.s);\n }\n \n-fn print_decl(ps s, @ast::decl decl) {\n+fn print_decl(&ps s, &@ast::decl decl) {\n     maybe_print_comment(s, decl.span.lo);\n     alt (decl.node) {\n         case (ast::decl_local(?loc)) {\n@@ -811,7 +820,7 @@ fn print_decl(ps s, @ast::decl decl) {\n             alt (loc.ty) {\n                 case (option::some[@ast::ty](?ty)) {\n                     word_nbsp(s, \"let\");\n-                    print_type(s, ty);\n+                    print_type(s, *ty);\n                     space(s.s);\n                 }\n                 case (_) {\n@@ -852,21 +861,21 @@ fn print_decl(ps s, @ast::decl decl) {\n     }\n }\n \n-fn print_ident(ps s, ast::ident ident) {\n+fn print_ident(&ps s, &ast::ident ident) {\n     word(s.s, ident);\n }\n \n-fn print_for_decl(ps s, @ast::decl decl) {\n+fn print_for_decl(&ps s, @ast::decl decl) {\n     alt (decl.node) {\n         case (ast::decl_local(?loc)) {\n-            print_type(s, option::get[@ast::ty](loc.ty));\n+            print_type(s, *option::get[@ast::ty](loc.ty));\n             space(s.s);\n             word(s.s, loc.ident);\n         }\n     }\n }\n \n-fn print_path(ps s, ast::path path) {\n+fn print_path(&ps s, &ast::path path) {\n     maybe_print_comment(s, path.span.lo);\n     auto first = true;\n     for (str id in path.node.idents) {\n@@ -876,13 +885,13 @@ fn print_path(ps s, ast::path path) {\n     }\n     if (vec::len[@ast::ty](path.node.types) > 0u) {\n         word(s.s, \"[\");\n-        auto f = print_type;\n+        auto f = print_boxed_type;\n         commasep[@ast::ty](s, inconsistent, path.node.types, f);\n         word(s.s, \"]\");\n     }\n }\n \n-fn print_pat(ps s, &@ast::pat pat) {\n+fn print_pat(&ps s, &@ast::pat pat) {\n     maybe_print_comment(s, pat.span.lo);\n     alt (pat.node) {\n         case (ast::pat_wild(_)) {word(s.s, \"_\");}\n@@ -900,8 +909,8 @@ fn print_pat(ps s, &@ast::pat pat) {\n     }\n }\n \n-fn print_fn(ps s, ast::fn_decl decl, str name,\n-                   vec[ast::ty_param] typarams) {\n+fn print_fn(&ps s, ast::fn_decl decl, str name,\n+            vec[ast::ty_param] typarams) {\n     alt (decl.purity) {\n         case (ast::impure_fn) {\n             head(s, \"fn\");\n@@ -913,10 +922,10 @@ fn print_fn(ps s, ast::fn_decl decl, str name,\n     word(s.s, name);\n     print_type_params(s, typarams);\n     popen(s);\n-    fn print_arg(ps s, &ast::arg x) {\n+    fn print_arg(&ps s, &ast::arg x) {\n         ibox(s.s, indent_unit);\n         if (x.mode == ast::alias) {word(s.s, \"&\");}\n-        print_type(s, x.ty);\n+        print_type(s, *x.ty);\n         space(s.s);\n         word(s.s, x.ident);\n         end(s.s);\n@@ -928,14 +937,14 @@ fn print_fn(ps s, ast::fn_decl decl, str name,\n     if (decl.output.node != ast::ty_nil) {\n         space(s.s);\n         word_space(s, \"->\");\n-        print_type(s, decl.output);\n+        print_type(s, *decl.output);\n     }\n }\n \n-fn print_type_params(ps s, vec[ast::ty_param] params) {\n+fn print_type_params(&ps s, &vec[ast::ty_param] params) {\n     if (vec::len[ast::ty_param](params) > 0u) {\n         word(s.s, \"[\");\n-        fn printParam(ps s, &ast::ty_param param) {\n+        fn printParam(&ps s, &ast::ty_param param) {\n             word(s.s, param);\n         }\n         auto f = printParam;\n@@ -944,7 +953,7 @@ fn print_type_params(ps s, vec[ast::ty_param] params) {\n     }\n }\n \n-fn print_view_item(ps s, @ast::view_item item) {\n+fn print_view_item(&ps s, &@ast::view_item item) {\n     hardbreak(s.s);\n     maybe_print_comment(s, item.span.lo);\n     alt (item.node) {\n@@ -953,7 +962,7 @@ fn print_view_item(ps s, @ast::view_item item) {\n             word(s.s, id);\n             if (vec::len[@ast::meta_item](mta) > 0u) {\n                 popen(s);\n-                fn print_meta(ps s, &@ast::meta_item item) {\n+                fn print_meta(&ps s, &@ast::meta_item item) {\n                     ibox(s.s, indent_unit);\n                     word_space(s, item.node.name);\n                     word_space(s, \"=\");\n@@ -997,7 +1006,7 @@ fn operator_prec(ast::binop op) -> int {\n     fail;\n }\n \n-fn print_maybe_parens(ps s, @ast::expr expr, int outer_prec) {\n+fn print_maybe_parens(&ps s, &@ast::expr expr, int outer_prec) {\n     auto add_them;\n     alt (expr.node) {\n         case (ast::expr_binary(?op,_,_,_)) {\n@@ -1036,22 +1045,22 @@ fn escape_str(str st, char to_escape) -> str {\n     ret out;\n }\n \n-fn print_mt(ps s, &ast::mt mt) {\n+fn print_mt(&ps s, &ast::mt mt) {\n     alt (mt.mut) {\n         case (ast::mut)       { word_nbsp(s, \"mutable\");  }\n         case (ast::maybe_mut) { word_nbsp(s, \"mutable?\"); }\n         case (ast::imm)       { /* nothing */        }\n     }\n-    print_type(s, mt.ty);\n+    print_type(s, *mt.ty);\n }\n \n-fn print_string(ps s, str st) {\n+fn print_string(&ps s, &str st) {\n     word(s.s, \"\\\"\"); word(s.s, escape_str(st, '\"')); word(s.s, \"\\\"\");\n }\n \n-fn print_ty_fn(ps s, ast::proto proto, option::t[str] id,\n-               vec[ast::ty_arg] inputs, @ast::ty output,\n-               ast::controlflow cf) {\n+fn print_ty_fn(&ps s, &ast::proto proto, &option::t[str] id,\n+               &vec[ast::ty_arg] inputs, &@ast::ty output,\n+               &ast::controlflow cf) {\n     ibox(s.s, indent_unit);\n     if (proto == ast::proto_fn) {word(s.s, \"fn\");}\n     else {word(s.s, \"iter\");}\n@@ -1060,9 +1069,9 @@ fn print_ty_fn(ps s, ast::proto proto, option::t[str] id,\n         case (_) {}\n     }\n     popen(s);\n-    fn print_arg(ps s, &ast::ty_arg input) {\n+    fn print_arg(&ps s, &ast::ty_arg input) {\n         if (input.mode == ast::alias) {word(s.s, \"&\");}\n-        print_type(s, input.ty);\n+        print_type(s, *input.ty);\n     }\n     auto f = print_arg;\n     commasep[ast::ty_arg](s, inconsistent, inputs, f);\n@@ -1074,7 +1083,7 @@ fn print_ty_fn(ps s, ast::proto proto, option::t[str] id,\n         word_space(s, \"->\");\n         alt (cf) {\n             case (ast::return) {\n-                print_type(s, output);\n+                print_type(s, *output);\n             }\n             case (ast::noreturn) {\n                 word_nbsp(s, \"!\");\n@@ -1085,7 +1094,7 @@ fn print_ty_fn(ps s, ast::proto proto, option::t[str] id,\n     end(s.s);\n }\n \n-fn next_comment(ps s) -> option::t[lexer::cmnt] {\n+fn next_comment(&ps s) -> option::t[lexer::cmnt] {\n     alt (s.comments) {\n         case (option::some[vec[lexer::cmnt]](?cmnts)) {\n             if (s.cur_cmnt < vec::len[lexer::cmnt](cmnts)) {\n@@ -1096,7 +1105,7 @@ fn next_comment(ps s) -> option::t[lexer::cmnt] {\n     }\n }\n \n-fn maybe_print_comment(ps s, uint pos) {\n+fn maybe_print_comment(&ps s, uint pos) {\n     auto first = true;\n     while (true) {\n         alt (next_comment(s)) {\n@@ -1115,7 +1124,7 @@ fn maybe_print_comment(ps s, uint pos) {\n     }\n }\n \n-fn maybe_print_trailing_comment(ps s, common::span span) {\n+fn maybe_print_trailing_comment(&ps s, common::span span) {\n     auto cm;\n     alt (s.cm) {\n         case (option::some[codemap](?ccm)) {\n@@ -1139,7 +1148,7 @@ fn maybe_print_trailing_comment(ps s, common::span span) {\n     }\n }\n \n-fn print_remaining_comments(ps s) {\n+fn print_remaining_comments(&ps s) {\n     while (true) {\n         alt (next_comment(s)) {\n             case (option::some[lexer::cmnt](?cmnt)) {\n@@ -1151,7 +1160,7 @@ fn print_remaining_comments(ps s) {\n     }\n }\n \n-fn print_comment(ps s, lexer::cmnt cmnt) {\n+fn print_comment(&ps s, lexer::cmnt cmnt) {\n     alt (cmnt.style) {\n         case (lexer::isolated) {\n             hardbreak(s.s);"}, {"sha": "a8e1046cc915cc9f5db735b4200792a040fb584e", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 10, "deletions": 98, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa", "patch": "@@ -126,136 +126,48 @@ fn field_exprs(vec[ast::field] fields) -> vec [@ast::expr] {\n     ret vec::map[ast::field, @ast::expr](f, fields);\n }\n \n-fn expr_to_str(&@ast::expr e) -> str {\n-  let str_writer s = string_writer();\n-  auto out_ = mk_printer(s.get_writer(), 80u);\n-  auto out = @rec(s=out_,\n-                  cm=none[codemap],\n-                  comments=none[vec[front::lexer::cmnt]],\n-                  mutable cur_cmnt=0u,\n-                  mode=mo_untyped);\n-  print_expr(out, e);\n-  pretty::pp::eof(out_);\n-  ret s.get_str();\n-}\n-\n-fn ty_to_str(&ty t) -> str {\n-  let str_writer s = string_writer();\n-  auto out_ = mk_printer(s.get_writer(), 80u);\n-  auto out = @rec(s=out_,\n-                  cm=none[codemap],\n-                  comments=none[vec[front::lexer::cmnt]],\n-                  mutable cur_cmnt=0u,\n-                  mode=mo_untyped);\n-  print_type(out, @t);\n-  pretty::pp::eof(out_);\n-  ret s.get_str();\n-}\n-\n fn log_expr(&ast::expr e) -> () {\n-    log(expr_to_str(@e));\n+    log(pretty::pprust::expr_to_str(@e));\n }\n \n fn log_expr_err(&ast::expr e) -> () {\n-    log_err(expr_to_str(@e));\n+    log_err(pretty::pprust::expr_to_str(@e));\n }\n \n fn log_ty_err(&ty t) -> () {\n-    log_err(ty_to_str(t));\n+    log_err(pretty::pprust::ty_to_str(t));\n }\n \n fn log_pat_err(&@pat p) -> () {\n     log_err(pretty::pprust::pat_to_str(p));\n }\n \n-fn block_to_str(&ast::block b) -> str {\n-  let str_writer s = string_writer();\n-  auto out_ = mk_printer(s.get_writer(), 80u);\n-  auto out = @rec(s=out_,\n-                  cm=none[codemap],\n-                  comments=none[vec[front::lexer::cmnt]],\n-                  mutable cur_cmnt=0u,\n-                  mode=mo_untyped);\n-\n-  print_block(out, b);\n-  pretty::pp::eof(out_);\n-  ret s.get_str();\n-}\n-\n-fn item_to_str(&@ast::item i) -> str {\n-  let str_writer s = string_writer();\n-  auto out_ = mk_printer(s.get_writer(), 80u);\n-  auto out = @rec(s=out_,\n-                  cm=none[codemap],\n-                  comments=none[vec[front::lexer::cmnt]],\n-                  mutable cur_cmnt=0u,\n-                  mode=mo_untyped);\n-  print_item(out, i);\n-  pretty::pp::eof(out_);\n-  ret s.get_str();\n-}\n-\n fn log_block(&ast::block b) -> () {\n-    log(block_to_str(b));\n+    log(pretty::pprust::block_to_str(b));\n }\n \n fn log_block_err(&ast::block b) -> () {\n-    log_err(block_to_str(b));\n+    log_err(pretty::pprust::block_to_str(b));\n }\n \n fn log_item_err(&@ast::item i) -> () {\n-    log_err(item_to_str(i));\n-}\n-\n-fn fun_to_str(&ast::_fn f, str name, vec[ast::ty_param] params) -> str {\n- let str_writer s = string_writer();\n-  auto out_ = mk_printer(s.get_writer(), 80u);\n-  auto out = @rec(s=out_,\n-                  cm=none[codemap],\n-                  comments=none[vec[front::lexer::cmnt]],\n-                  mutable cur_cmnt=0u,\n-                  mode=mo_untyped);\n-\n-  print_fn(out, f.decl, name, params);\n-  pretty::pp::eof(out_);\n-  ret s.get_str();\n+    log_err(pretty::pprust::item_to_str(i));\n }\n \n fn log_fn(&ast::_fn f, str name, vec[ast::ty_param] params) -> () {\n-    log(fun_to_str(f, name, params));\n+    log(pretty::pprust::fun_to_str(f, name, params));\n }\n \n fn log_fn_err(&ast::_fn f, str name, vec[ast::ty_param] params) -> () {\n-    log_err(fun_to_str(f, name, params));\n-}\n-\n-fn stmt_to_str(&ast::stmt st) -> str {\n-  let str_writer s = string_writer();\n-  auto out_ = mk_printer(s.get_writer(), 80u);\n-  auto out = @rec(s=out_,\n-                  cm=none[codemap],\n-                  comments=none[vec[front::lexer::cmnt]],\n-                  mutable cur_cmnt=0u,\n-                  mode=mo_untyped);\n-  alt (st.node) {\n-    case (ast::stmt_decl(?decl,_)) {\n-      print_decl(out, decl);\n-    }\n-    case (ast::stmt_expr(?ex,_)) {\n-      print_expr(out, ex);\n-    }\n-    case (_) { /* do nothing */ }\n-  }\n-  pretty::pp::eof(out_);\n-  ret s.get_str();\n+    log_err(pretty::pprust::fun_to_str(f, name, params));\n }\n \n fn log_stmt(&ast::stmt st) -> () {\n-    log(stmt_to_str(st));\n+    log(pretty::pprust::stmt_to_str(st));\n }\n \n fn log_stmt_err(&ast::stmt st) -> () {\n-    log_err(stmt_to_str(st));\n+    log_err(pretty::pprust::stmt_to_str(st));\n }\n \n fn decl_lhs(@ast::decl d) -> ast::def_id {"}]}