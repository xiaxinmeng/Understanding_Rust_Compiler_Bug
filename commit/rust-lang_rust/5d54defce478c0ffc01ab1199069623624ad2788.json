{"sha": "5d54defce478c0ffc01ab1199069623624ad2788", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNTRkZWZjZTQ3OGMwZmZjMDFhYjExOTkwNjk2MjM2MjRhZDI3ODg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-18T01:02:45Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-30T03:56:50Z"}, "message": "core: Add extension methods for vec", "tree": {"sha": "deca44c862c308ea865b21c1263947387c50d5ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deca44c862c308ea865b21c1263947387c50d5ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d54defce478c0ffc01ab1199069623624ad2788", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d54defce478c0ffc01ab1199069623624ad2788", "html_url": "https://github.com/rust-lang/rust/commit/5d54defce478c0ffc01ab1199069623624ad2788", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d54defce478c0ffc01ab1199069623624ad2788/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f65ea0c8123d02c61f3a15188470711d49fa2b6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f65ea0c8123d02c61f3a15188470711d49fa2b6d", "html_url": "https://github.com/rust-lang/rust/commit/f65ea0c8123d02c61f3a15188470711d49fa2b6d"}], "stats": {"total": 194, "additions": 181, "deletions": 13}, "files": [{"sha": "92310166426f9ccee1c568995e66591d2ab53858", "filename": "src/libcore/core.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d54defce478c0ffc01ab1199069623624ad2788/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d54defce478c0ffc01ab1199069623624ad2788/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=5d54defce478c0ffc01ab1199069623624ad2788", "patch": "@@ -5,10 +5,11 @@\n import option::{some, none};\n import option = option::option;\n import path = path::path;\n-import vec::vec_len;\n import str::extensions;\n+import vec::extensions;\n import option::extensions;\n-export path, option, some, none, vec_len, unreachable;\n+\n+export path, option, some, none, unreachable;\n export extensions;\n \n // Export the log levels as global constants. Higher levels mean"}, {"sha": "ded7ca92ba32d9f40d169cbde708b33775955c30", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 172, "deletions": 5, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/5d54defce478c0ffc01ab1199069623624ad2788/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d54defce478c0ffc01ab1199069623624ad2788/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=5d54defce478c0ffc01ab1199069623624ad2788", "patch": "@@ -71,9 +71,9 @@ export permute;\n export windowed;\n export as_buf;\n export as_mut_buf;\n-export vec_len;\n export unsafe;\n export u8;\n+export extensions;\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n@@ -954,13 +954,180 @@ fn as_mut_buf<E,T>(v: [mut E], f: fn(*mut E) -> T) -> T unsafe {\n     let buf = unsafe::to_ptr(v) as *mut E; f(buf)\n }\n \n-#[doc = \"An extension implementation providing a `len` method\"]\n-impl vec_len<T> for [const T] {\n-    #[doc = \"Return the length of the vector\"]\n-    #[inline(always)]\n+#[doc = \"Extension methods for vectors\"]\n+impl extensions<T> for [const T] {\n+    #[doc = \"\n+    Return true if a vector contains an element with the given value\n+    \"]\n+    #[inline]\n+    fn contains(x: T) -> bool { contains(self, x) }\n+    #[doc = \"Returns the number of elements that are equal to a given value\"]\n+    #[inline]\n+    fn count(x: T) -> uint { count(self, x) }\n+    #[doc = \"Reduce a vector from left to right\"]\n+    #[inline]\n+    fn foldl<U: copy>(z: U, p: fn(U, T) -> U) -> U { foldl(z, self, p) }\n+    #[doc = \"Reduce a vector from right to left\"]\n+    #[inline]\n+    fn foldr<U: copy>(z: U, p: fn(T, U) -> U) -> U { foldr(self, z, p) }\n+    #[doc = \"Returns true if a vector contains no elements\"]\n+    #[inline]\n+    fn is_empty() -> bool { is_empty(self) }\n+    #[doc = \"Returns true if a vector contains some elements\"]\n+    #[inline]\n+    fn is_not_empty() -> bool { is_not_empty(self) }\n+    #[doc = \"\n+    Iterates over a vector\n+\n+    Iterates over vector `v` and, for each element, calls function `f` with\n+    the element's value.\n+    \"]\n+    #[inline]\n+    fn iter(f: fn(T)) { iter(self, f) }\n+    #[doc = \"\n+    Iterates over a vector's elements and indexes\n+\n+    Iterates over vector `v` and, for each element, calls function `f` with\n+    the element's value and index.\n+    \"]\n+    #[inline]\n+    fn iteri(f: fn(uint, T)) { iteri(self, f) }\n+    #[doc = \"Returns the length of a vector\"]\n+    #[inline]\n     fn len() -> uint { len(self) }\n+    #[doc = \"\n+    Find the first index matching some predicate\n+\n+    Apply function `f` to each element of `v`.  When function `f` returns true\n+    then an option containing the index is returned. If `f` matches no\n+    elements then none is returned.\n+    \"]\n+    #[inline]\n+    fn position(f: fn(T) -> bool) -> option<uint> { position(self, f) }\n+    #[doc = \"Find the first index containing a matching value\"]\n+    #[inline]\n+    fn position_elem(x: T) -> option<uint> { position_elem(self, x) }\n+    #[doc = \"\n+    Iterates over a vector in reverse\n+\n+    Iterates over vector `v` and, for each element, calls function `f` with\n+    the element's value.\n+    \"]\n+    #[inline]\n+    fn riter(f: fn(T)) { riter(self, f) }\n+    #[doc =\"\n+    Iterates over a vector's elements and indexes in reverse\n+\n+    Iterates over vector `v` and, for each element, calls function `f` with\n+    the element's value and index.\n+    \"]\n+    #[inline]\n+    fn riteri(f: fn(uint, T)) { riteri(self, f) }\n+    #[doc = \"\n+    Find the last index matching some predicate\n+\n+    Apply function `f` to each element of `v` in reverse order.  When function\n+    `f` returns true then an option containing the index is returned. If `f`\n+    matches no elements then none is returned.\n+    \"]\n+    #[inline]\n+    fn rposition(f: fn(T) -> bool) -> option<uint> { rposition(self, f) }\n+    #[doc = \"Find the last index containing a matching value\"]\n+    #[inline]\n+    fn rposition_elem(x: T) -> option<uint> { rposition_elem(self, x) }\n+}\n+\n+#[doc = \"Extension methods for vectors\"]\n+impl extensions<T: copy> for [const T] {\n+    #[doc = \"\n+    Search for the first element that matches a given predicate\n+\n+    Apply function `f` to each element of `v`, starting from the first.\n+    When function `f` returns true then an option containing the element\n+    is returned. If `f` matches no elements then none is returned.\n+    \"]\n+    #[inline]\n+    fn find(f: fn(T) -> bool) -> option<T> { find(self, f) }\n+    #[doc = \"Returns the first element of a vector\"]\n+    #[inline]\n+    fn head() -> T { head(self) }\n+    #[doc = \"Returns all but the last elemnt of a vector\"]\n+    #[inline]\n+    fn init() -> [T] { init(self) }\n+    #[doc = \"\n+    Returns the last element of a `v`, failing if the vector is empty.\n+    \"]\n+    #[inline]\n+    fn last() -> T { last(self) }\n+    #[doc = \"\n+    Search for the last element that matches a given predicate\n+\n+    Apply function `f` to each element of `v` in reverse order. When function\n+    `f` returns true then an option containing the element is returned. If `f`\n+    matches no elements then none is returned.\n+    \"]\n+    #[inline]\n+    fn rfind(f: fn(T) -> bool) -> option<T> { rfind(self, f) }\n+    #[doc = \"Returns a copy of the elements from [`start`..`end`) from `v`.\"]\n+    #[inline]\n+    fn slice(start: uint, end: uint) -> [T] { slice(self, start, end) }\n+    #[doc = \"Returns all but the first element of a vector\"]\n+    #[inline]\n+    fn tail() -> [T] { tail(self) }\n+}\n+\n+#[doc = \"Extension methods for vectors\"]\n+impl extensions<T> for [T] {\n+    #[doc = \"\n+    Return true if a predicate matches all elements\n+\n+    If the vector contains no elements then true is returned.\n+    \"]\n+    #[inline]\n+    fn all(f: fn(T) -> bool) -> bool { all(self, f) }\n+    #[doc = \"\n+    Return true if a predicate matches any elements\n+\n+    If the vector contains no elements then false is returned.\n+    \"]\n+    #[inline]\n+    fn any(f: fn(T) -> bool) -> bool { any(self, f) }\n+    #[doc = \"\n+    Apply a function to each element of a vector and return the results\n+\n+    If function `f` returns `none` then that element is excluded from\n+    the resulting vector.\n+    \"]\n+    #[inline]\n+    fn filter_map<U: copy>(f: fn(T) -> option<U>) -> [U] {\n+        filter_map(self, f)\n+    }\n+    #[doc = \"\n+    Apply a function eo each element of a vector and return a concatenation\n+    of each result vector\n+    \"]\n+    #[inline]\n+    fn flat_map<U>(f: fn(T) -> [U]) -> [U] { flat_map(self, f) }\n+    #[doc = \"\n+    Apply a function to each element of a vector and return the results\n+    \"]\n+    #[inline]\n+    fn map<U>(f: fn(T) -> U) -> [U] { map(self, f) }\n }\n \n+#[doc = \"Extension methods for vectors\"]\n+impl extensions<T: copy> for [T] {\n+    #[doc = \"\n+    Construct a new vector from the elements of a vector for which some\n+    predicate holds.\n+\n+    Apply function `f` to each element of `v` and return a vector containing\n+    only those elements for which `f` returned true.\n+    \"]\n+   #[inline]\n+    fn filter(f: fn(T) -> bool) -> [T] { filter(self, f) }\n+ }\n+\n #[doc = \"Unsafe operations\"]\n mod unsafe {\n     // FIXME: This should have crate visibility"}, {"sha": "fe184b874df1c163ab63f0d703f9ab97801d003a", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d54defce478c0ffc01ab1199069623624ad2788/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d54defce478c0ffc01ab1199069623624ad2788/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=5d54defce478c0ffc01ab1199069623624ad2788", "patch": "@@ -18,9 +18,9 @@ impl util for uint {\n }\n \n impl util<T> for [T] {\n-    fn length() -> uint { vec::len(self) }\n-    fn iter(f: fn(T)) { for x in self { f(x); } }\n-    fn map<U>(f: fn(T) -> U) -> [U] {\n+    fn length_() -> uint { vec::len(self) }\n+    fn iter_(f: fn(T)) { for x in self { f(x); } }\n+    fn map_<U>(f: fn(T) -> U) -> [U] {\n         let mut r = [];\n         for elt in self { r += [f(elt)]; }\n         r\n@@ -33,9 +33,9 @@ fn main() {\n     assert 10u.plus() == 30;\n     assert \"hi\".plus() == 200;\n \n-    assert [1].length().str() == \"1\";\n-    assert [3, 4].map({|a| a + 4})[0] == 7;\n-    assert [3, 4].map::<uint>({|a| a as uint + 4u})[0] == 7u;\n+    assert [1].length_().str() == \"1\";\n+    assert [3, 4].map_({|a| a + 4})[0] == 7;\n+    assert [3, 4].map_::<uint>({|a| a as uint + 4u})[0] == 7u;\n     let mut x = 0u;\n     10u.times {|_n| x += 2u;}\n     assert x == 20u;"}]}