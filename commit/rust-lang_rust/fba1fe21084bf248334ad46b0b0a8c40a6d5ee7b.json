{"sha": "fba1fe21084bf248334ad46b0b0a8c40a6d5ee7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYTFmZTIxMDg0YmYyNDgzMzRhZDQ2YjBiMGE4YzQwYTZkNWVlN2I=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-26T12:22:51Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-06-20T11:21:08Z"}, "message": "Remove hir::GenericParam::is_*_param", "tree": {"sha": "97aa8e78f2a351ff88f4d12dc858ee0db163e293", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97aa8e78f2a351ff88f4d12dc858ee0db163e293"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fba1fe21084bf248334ad46b0b0a8c40a6d5ee7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fba1fe21084bf248334ad46b0b0a8c40a6d5ee7b", "html_url": "https://github.com/rust-lang/rust/commit/fba1fe21084bf248334ad46b0b0a8c40a6d5ee7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fba1fe21084bf248334ad46b0b0a8c40a6d5ee7b/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c818a1df9b4e3b518dcd839d18818f25cf1237a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c818a1df9b4e3b518dcd839d18818f25cf1237a2", "html_url": "https://github.com/rust-lang/rust/commit/c818a1df9b4e3b518dcd839d18818f25cf1237a2"}], "stats": {"total": 208, "additions": 106, "deletions": 102}, "files": [{"sha": "0c378262dca553f5ce778972dcfab0fb25b50694", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fba1fe21084bf248334ad46b0b0a8c40a6d5ee7b/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba1fe21084bf248334ad46b0b0a8c40a6d5ee7b/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=fba1fe21084bf248334ad46b0b0a8c40a6d5ee7b", "patch": "@@ -497,20 +497,6 @@ pub struct GenericParam {\n }\n \n impl GenericParam {\n-    pub fn is_lifetime_param(&self) -> bool {\n-        match self.kind {\n-            GenericParamKind::Lifetime { .. } => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_type_param(&self) -> bool {\n-        match self.kind {\n-            GenericParamKind::Type { .. } => true,\n-            _ => false,\n-        }\n-    }\n-\n     pub fn name(&self) -> Name {\n         match self.kind {\n             GenericParamKind::Lifetime { name, .. } => name.name(),"}, {"sha": "9637b376b0e431a792b4a996826f3630c8487124", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fba1fe21084bf248334ad46b0b0a8c40a6d5ee7b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba1fe21084bf248334ad46b0b0a8c40a6d5ee7b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=fba1fe21084bf248334ad46b0b0a8c40a6d5ee7b", "patch": "@@ -29,7 +29,7 @@ use util::nodemap::{NodeSet, FxHashSet};\n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n-use hir;\n+use hir::{self, GenericParamKind};\n use hir::def_id::LOCAL_CRATE;\n use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::itemlikevisit::ItemLikeVisitor;\n@@ -38,7 +38,13 @@ use hir::intravisit;\n // Returns true if the given set of generics implies that the item it's\n // associated with must be inlined.\n fn generics_require_inlining(generics: &hir::Generics) -> bool {\n-    generics.params.iter().any(|param| param.is_type_param())\n+    for param in &generics.params {\n+        match param.kind {\n+            GenericParamKind::Lifetime { .. } => {}\n+            GenericParamKind::Type { .. } => return true,\n+        }\n+    }\n+    false\n }\n \n // Returns true if the given item must be inlined because it may be"}, {"sha": "dfa205e6a34d25b5cce1e5c881ac51ba143ea6ce", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 49, "deletions": 41, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/fba1fe21084bf248334ad46b0b0a8c40a6d5ee7b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba1fe21084bf248334ad46b0b0a8c40a6d5ee7b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=fba1fe21084bf248334ad46b0b0a8c40a6d5ee7b", "patch": "@@ -532,21 +532,21 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 } else {\n                     0\n                 };\n-                let mut next_early_index = index;\n+                let mut type_count = 0;\n                 let lifetimes = generics.params.iter().filter_map(|param| {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n                             Some(Region::early(&self.tcx.hir, &mut index, param))\n                         }\n                         GenericParamKind::Type { .. } => {\n-                            next_early_index += 1;\n+                            type_count += 1;\n                             None\n                         }\n                     }\n                 }).collect();\n                 let scope = Scope::Binder {\n                     lifetimes,\n-                    next_early_index,\n+                    next_early_index: index + type_count,\n                     abstract_type_parent: true,\n                     track_lifetime_uses,\n                     s: ROOT_SCOPE,\n@@ -698,7 +698,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n                 let mut elision = None;\n                 let mut lifetimes = FxHashMap();\n-                let mut next_early_index = index;\n+                let mut type_count = 0;\n                 for param in &generics.params {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n@@ -712,10 +712,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             }\n                         }\n                         GenericParamKind::Type { .. } => {\n-                            next_early_index += 1;\n+                            type_count += 1;\n                         }\n                     }\n                 }\n+                let next_early_index = index + type_count;\n \n                 if let Some(elision_region) = elision {\n                     let scope = Scope::Elision {\n@@ -773,7 +774,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let generics = &trait_item.generics;\n                 let mut index = self.next_early_index();\n                 debug!(\"visit_ty: index = {}\", index);\n-                let mut next_early_index = index;\n+                let mut type_count = 0;\n                 let lifetimes = generics.params\n                     .iter()\n                     .filter_map(|param| {\n@@ -782,7 +783,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 Some(Region::early(&self.tcx.hir, &mut index, param))\n                             }\n                             GenericParamKind::Type { .. } => {\n-                                next_early_index += 1;\n+                                type_count += 1;\n                                 None\n                             }\n                         }\n@@ -791,7 +792,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n                 let scope = Scope::Binder {\n                     lifetimes,\n-                    next_early_index,\n+                    next_early_index: index + type_count,\n                     s: self.scope,\n                     track_lifetime_uses: true,\n                     abstract_type_parent: true,\n@@ -896,7 +897,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n-\n         check_mixed_explicit_and_in_band_defs(\n             self.tcx,\n             &generics.params.iter().filter_map(|param| {\n@@ -925,21 +925,21 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     ref bound_generic_params,\n                     ..\n                 }) => {\n-                    if bound_generic_params.iter().any(|p| p.is_lifetime_param()) {\n+                    let lifetimes: FxHashMap<_, _> = bound_generic_params.iter()\n+                        .filter_map(|param| {\n+                            match param.kind {\n+                                GenericParamKind::Lifetime { .. } => {\n+                                    Some(Region::late(&self.tcx.hir, param))\n+                                }\n+                                _ => None,\n+                            }\n+                        })\n+                        .collect();\n+                    if !lifetimes.is_empty() {\n                         self.trait_ref_hack = true;\n                         let next_early_index = self.next_early_index();\n                         let scope = Scope::Binder {\n-                            lifetimes: bound_generic_params\n-                                .iter()\n-                                .filter_map(|param| {\n-                                    match param.kind {\n-                                        GenericParamKind::Lifetime { .. } => {\n-                                            Some(Region::late(&self.tcx.hir, param))\n-                                        }\n-                                        _ => None,\n-                                    }\n-                                })\n-                                .collect(),\n+                            lifetimes,\n                             s: self.scope,\n                             next_early_index,\n                             track_lifetime_uses: true,\n@@ -990,7 +990,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             || trait_ref\n                 .bound_generic_params\n                 .iter()\n-                .any(|p| p.is_lifetime_param())\n+                .any(|param| {\n+                    match param.kind {\n+                        GenericParamKind::Lifetime { .. } => true,\n+                        _ => false,\n+                    }\n+                })\n         {\n             if self.trait_ref_hack {\n                 span_err!(\n@@ -1259,10 +1264,15 @@ fn compute_object_lifetime_defaults(\n                                 let mut j = 0;\n                                 generics.params.iter().find(|param| {\n                                     match param.kind {\n-                                        GenericParamKind::Lifetime { .. } => j += 1,\n+                                        GenericParamKind::Lifetime { .. } => {\n+                                            if i == j {\n+                                                return true;\n+                                            }\n+                                            j += 1;\n+                                        }\n                                         _ => {}\n                                     }\n-                                    i == j\n+                                    false\n                                 }).unwrap()\n                                   .name()\n                                   .to_string()\n@@ -1530,25 +1540,23 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         }\n \n-        let mut next_early_index = index;\n-        let lifetimes = generics.params\n-            .iter()\n-            .filter_map(|param| {\n-                match param.kind {\n-                    GenericParamKind::Lifetime { .. } => {\n-                        if self.map.late_bound.contains(&param.id) {\n-                            Some(Region::late(&self.tcx.hir, param))\n-                        } else {\n-                            Some(Region::early(&self.tcx.hir, &mut index, param))\n-                        }\n-                    }\n-                    GenericParamKind::Type { .. } => {\n-                        next_early_index += 1;\n-                        None\n+        let mut type_count = 0;\n+        let lifetimes = generics.params.iter().filter_map(|param| {\n+            match param.kind {\n+                GenericParamKind::Lifetime { .. } => {\n+                    if self.map.late_bound.contains(&param.id) {\n+                        Some(Region::late(&self.tcx.hir, param))\n+                    } else {\n+                        Some(Region::early(&self.tcx.hir, &mut index, param))\n                     }\n                 }\n-            })\n-            .collect();\n+                GenericParamKind::Type { .. } => {\n+                    type_count += 1;\n+                    None\n+                }\n+            }\n+        }).collect();\n+        let next_early_index = index + type_count;\n \n         let scope = Scope::Binder {\n             lifetimes,"}, {"sha": "2149e65428154cdd9a496c552b15f6cef9f87405", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/fba1fe21084bf248334ad46b0b0a8c40a6d5ee7b/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba1fe21084bf248334ad46b0b0a8c40a6d5ee7b/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=fba1fe21084bf248334ad46b0b0a8c40a6d5ee7b", "patch": "@@ -810,51 +810,55 @@ impl LintPass for VariantSizeDifferences {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n-            if gens.params.iter().all(|param| param.is_lifetime_param()) {\n-                // sizes only make sense for non-generic types\n-                let item_def_id = cx.tcx.hir.local_def_id(it.id);\n-                let t = cx.tcx.type_of(item_def_id);\n-                let ty = cx.tcx.erase_regions(&t);\n-                let layout = cx.layout_of(ty).unwrap_or_else(|e| {\n-                    bug!(\"failed to get layout for `{}`: {}\", t, e)\n-                });\n-\n-                if let layout::Variants::Tagged { ref variants, ref tag, .. } = layout.variants {\n-                    let discr_size = tag.value.size(cx.tcx).bytes();\n-\n-                    debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n-                      t, layout.size.bytes(), layout);\n-\n-                    let (largest, slargest, largest_index) = enum_definition.variants\n-                        .iter()\n-                        .zip(variants)\n-                        .map(|(variant, variant_layout)| {\n-                            // Subtract the size of the enum discriminant\n-                            let bytes = variant_layout.size.bytes()\n-                                .saturating_sub(discr_size);\n-\n-                            debug!(\"- variant `{}` is {} bytes large\", variant.node.name, bytes);\n-                            bytes\n-                        })\n-                        .enumerate()\n-                        .fold((0, 0, 0), |(l, s, li), (idx, size)| if size > l {\n-                            (size, l, idx)\n-                        } else if size > s {\n-                            (l, size, li)\n-                        } else {\n-                            (l, s, li)\n-                        });\n-\n-                    // we only warn if the largest variant is at least thrice as large as\n-                    // the second-largest.\n-                    if largest > slargest * 3 && slargest > 0 {\n-                        cx.span_lint(VARIANT_SIZE_DIFFERENCES,\n-                                     enum_definition.variants[largest_index].span,\n-                                     &format!(\"enum variant is more than three times larger \\\n-                                               ({} bytes) than the next largest\",\n-                                              largest));\n-                    }\n+        if let hir::ItemEnum(ref enum_definition, ref generics) = it.node {\n+            for param in &generics.params {\n+                match param.kind {\n+                    hir::GenericParamKind::Lifetime { .. } => {},\n+                    hir::GenericParamKind::Type { .. } => return,\n+                }\n+            }\n+            // Sizes only make sense for non-generic types.\n+            let item_def_id = cx.tcx.hir.local_def_id(it.id);\n+            let t = cx.tcx.type_of(item_def_id);\n+            let ty = cx.tcx.erase_regions(&t);\n+            let layout = cx.layout_of(ty).unwrap_or_else(|e| {\n+                bug!(\"failed to get layout for `{}`: {}\", t, e)\n+            });\n+\n+            if let layout::Variants::Tagged { ref variants, ref tag, .. } = layout.variants {\n+                let discr_size = tag.value.size(cx.tcx).bytes();\n+\n+                debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n+                    t, layout.size.bytes(), layout);\n+\n+                let (largest, slargest, largest_index) = enum_definition.variants\n+                    .iter()\n+                    .zip(variants)\n+                    .map(|(variant, variant_layout)| {\n+                        // Subtract the size of the enum discriminant.\n+                        let bytes = variant_layout.size.bytes()\n+                            .saturating_sub(discr_size);\n+\n+                        debug!(\"- variant `{}` is {} bytes large\", variant.node.name, bytes);\n+                        bytes\n+                    })\n+                    .enumerate()\n+                    .fold((0, 0, 0), |(l, s, li), (idx, size)| if size > l {\n+                        (size, l, idx)\n+                    } else if size > s {\n+                        (l, size, li)\n+                    } else {\n+                        (l, s, li)\n+                    });\n+\n+                // We only warn if the largest variant is at least thrice as large as\n+                // the second-largest.\n+                if largest > slargest * 3 && slargest > 0 {\n+                    cx.span_lint(VARIANT_SIZE_DIFFERENCES,\n+                                    enum_definition.variants[largest_index].span,\n+                                    &format!(\"enum variant is more than three times larger \\\n+                                            ({} bytes) than the next largest\",\n+                                            largest));\n                 }\n             }\n         }"}]}