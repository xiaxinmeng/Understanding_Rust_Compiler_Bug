{"sha": "4a4e3e667d22442cbfdd04c9fe0adcf70e497751", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNGUzZTY2N2QyMjQ0MmNiZmRkMDRjOWZlMGFkY2Y3MGU0OTc3NTE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-03-08T12:13:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-08T12:13:19Z"}, "message": "Rollup merge of #82415 - petrochenkov:modin3, r=davidtwco\n\nexpand: Refactor module loading\n\nThis is an accompanying PR to https://github.com/rust-lang/rust/pull/82399, but they can be landed independently.\nSee individual commits for more details.\n\nAnyone should be able to review this equally well because all people actually familiar with this code left the project.", "tree": {"sha": "d55b0e1055ec687d87590422db31c095803ab446", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d55b0e1055ec687d87590422db31c095803ab446"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a4e3e667d22442cbfdd04c9fe0adcf70e497751", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgRhTgCRBK7hj4Ov3rIwAAdHIIAHUDOh32b5KIFaCOzbYNl9t9\nYG9WCWSqg4QA8JczBly0swuw8ntvNPPp+uqqFZWci9pnxwCBc0aKW9amR2GeObsR\nBMn5VePpPEiIoCEQ2ics9j49n0tvEwAFm5V4Yv2oz1/sERImcKSgbI0me+HjF2AL\nYW3rLQUz7j8LUMy2oKYgMcukj5uCnF9lN2f+ULIantME3UeTObq/qSoIgk8BrdQ1\nNT4a71L+4er9XK9oNmRvCpiJZcZrm5+f++Ev7sDZ5ODYRA7hzOyZUVHA56uOZSrr\nhhRpxPnOKx/hSSf8dZxBgVjBAv/f3TOyBrdwdo4cQaCPx3iRSa6QeDf2R9JMSeM=\n=4Ki1\n-----END PGP SIGNATURE-----\n", "payload": "tree d55b0e1055ec687d87590422db31c095803ab446\nparent da74a77622b29c056fa5a18f6e6033d9579a0e90\nparent 1fe2eb83ecfed43874b4cdf39d0be8910995dd1d\nauthor Dylan DPC <dylan.dpc@gmail.com> 1615205599 +0100\ncommitter GitHub <noreply@github.com> 1615205599 +0100\n\nRollup merge of #82415 - petrochenkov:modin3, r=davidtwco\n\nexpand: Refactor module loading\n\nThis is an accompanying PR to https://github.com/rust-lang/rust/pull/82399, but they can be landed independently.\nSee individual commits for more details.\n\nAnyone should be able to review this equally well because all people actually familiar with this code left the project.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a4e3e667d22442cbfdd04c9fe0adcf70e497751", "html_url": "https://github.com/rust-lang/rust/commit/4a4e3e667d22442cbfdd04c9fe0adcf70e497751", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da74a77622b29c056fa5a18f6e6033d9579a0e90", "url": "https://api.github.com/repos/rust-lang/rust/commits/da74a77622b29c056fa5a18f6e6033d9579a0e90", "html_url": "https://github.com/rust-lang/rust/commit/da74a77622b29c056fa5a18f6e6033d9579a0e90"}, {"sha": "1fe2eb83ecfed43874b4cdf39d0be8910995dd1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fe2eb83ecfed43874b4cdf39d0be8910995dd1d", "html_url": "https://github.com/rust-lang/rust/commit/1fe2eb83ecfed43874b4cdf39d0be8910995dd1d"}], "stats": {"total": 587, "additions": 295, "deletions": 292}, "files": [{"sha": "4aafcb2fb6dfea067783c635dacaad92d0d9f67e", "filename": "compiler/rustc_builtin_macros/src/source_util.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs?ref=4a4e3e667d22442cbfdd04c9fe0adcf70e497751", "patch": "@@ -4,7 +4,7 @@ use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::{self, *};\n-use rustc_expand::module::DirectoryOwnership;\n+use rustc_expand::module::DirOwnership;\n use rustc_parse::parser::{ForceCollect, Parser};\n use rustc_parse::{self, new_parser_from_file};\n use rustc_session::lint::builtin::INCOMPLETE_INCLUDE;\n@@ -101,7 +101,7 @@ pub fn expand_include<'cx>(\n         None => return DummyResult::any(sp),\n     };\n     // The file will be added to the code map by the parser\n-    let mut file = match cx.resolve_path(file, sp) {\n+    let file = match cx.resolve_path(file, sp) {\n         Ok(f) => f,\n         Err(mut err) => {\n             err.emit();\n@@ -114,10 +114,9 @@ pub fn expand_include<'cx>(\n     // then the path of `bar.rs` should be relative to the directory of `file`.\n     // See https://github.com/rust-lang/rust/pull/69838/files#r395217057 for a discussion.\n     // `MacroExpander::fully_expand_fragment` later restores, so \"stack discipline\" is maintained.\n-    file.pop();\n-    cx.current_expansion.directory_ownership = DirectoryOwnership::Owned { relative: None };\n-    let mod_path = cx.current_expansion.module.mod_path.clone();\n-    cx.current_expansion.module = Rc::new(ModuleData { mod_path, directory: file });\n+    let dir_path = file.parent().unwrap_or(&file).to_owned();\n+    cx.current_expansion.module = Rc::new(cx.current_expansion.module.with_dir_path(dir_path));\n+    cx.current_expansion.dir_ownership = DirOwnership::Owned { relative: None };\n \n     struct ExpandResult<'a> {\n         p: Parser<'a>,"}, {"sha": "5bd06e8e7d115f001d701a725b541d14f1023e4e", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=4a4e3e667d22442cbfdd04c9fe0adcf70e497751", "patch": "@@ -1,11 +1,11 @@\n use crate::expand::{self, AstFragment, Invocation};\n-use crate::module::DirectoryOwnership;\n+use crate::module::DirOwnership;\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Nonterminal};\n use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, LazyTokenStream, TokenStream};\n use rustc_ast::visit::{AssocCtxt, Visitor};\n-use rustc_ast::{self as ast, AstLike, Attribute, NodeId, PatKind};\n+use rustc_ast::{self as ast, AstLike, Attribute, Item, NodeId, PatKind};\n use rustc_attr::{self as attr, Deprecation, Stability};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n@@ -900,21 +900,40 @@ pub trait ResolverExpand {\n     fn cfg_accessible(&mut self, expn_id: ExpnId, path: &ast::Path) -> Result<bool, Indeterminate>;\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Default)]\n pub struct ModuleData {\n+    /// Path to the module starting from the crate name, like `my_crate::foo::bar`.\n     pub mod_path: Vec<Ident>,\n-    pub directory: PathBuf,\n+    /// Stack of paths to files loaded by out-of-line module items,\n+    /// used to detect and report recursive module inclusions.\n+    pub file_path_stack: Vec<PathBuf>,\n+    /// Directory to search child module files in,\n+    /// often (but not necessarily) the parent of the top file path on the `file_path_stack`.\n+    pub dir_path: PathBuf,\n+}\n+\n+impl ModuleData {\n+    pub fn with_dir_path(&self, dir_path: PathBuf) -> ModuleData {\n+        ModuleData {\n+            mod_path: self.mod_path.clone(),\n+            file_path_stack: self.file_path_stack.clone(),\n+            dir_path,\n+        }\n+    }\n }\n \n #[derive(Clone)]\n pub struct ExpansionData {\n     pub id: ExpnId,\n     pub depth: usize,\n     pub module: Rc<ModuleData>,\n-    pub directory_ownership: DirectoryOwnership,\n+    pub dir_ownership: DirOwnership,\n     pub prior_type_ascription: Option<(Span, bool)>,\n }\n \n+type OnExternModLoaded<'a> =\n+    Option<&'a dyn Fn(Ident, Vec<Attribute>, Vec<P<Item>>, Span) -> (Vec<Attribute>, Vec<P<Item>>)>;\n+\n /// One of these is made during expansion and incrementally updated as we go;\n /// when a macro expansion occurs, the resulting nodes have the `backtrace()\n /// -> expn_data` of their expansion context stored into their span.\n@@ -932,15 +951,15 @@ pub struct ExtCtxt<'a> {\n     /// Called directly after having parsed an external `mod foo;` in expansion.\n     ///\n     /// `Ident` is the module name.\n-    pub(super) extern_mod_loaded: Option<&'a dyn Fn(&ast::Crate, Ident)>,\n+    pub(super) extern_mod_loaded: OnExternModLoaded<'a>,\n }\n \n impl<'a> ExtCtxt<'a> {\n     pub fn new(\n         sess: &'a Session,\n         ecfg: expand::ExpansionConfig<'a>,\n         resolver: &'a mut dyn ResolverExpand,\n-        extern_mod_loaded: Option<&'a dyn Fn(&ast::Crate, Ident)>,\n+        extern_mod_loaded: OnExternModLoaded<'a>,\n     ) -> ExtCtxt<'a> {\n         ExtCtxt {\n             sess,\n@@ -952,8 +971,8 @@ impl<'a> ExtCtxt<'a> {\n             current_expansion: ExpansionData {\n                 id: ExpnId::root(),\n                 depth: 0,\n-                module: Rc::new(ModuleData { mod_path: Vec::new(), directory: PathBuf::new() }),\n-                directory_ownership: DirectoryOwnership::Owned { relative: None },\n+                module: Default::default(),\n+                dir_ownership: DirOwnership::Owned { relative: None },\n                 prior_type_ascription: None,\n             },\n             force_mode: false,"}, {"sha": "dd2eaa0f3d53c5db05197b8f5512e51b941ec5c3", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 65, "deletions": 49, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=4a4e3e667d22442cbfdd04c9fe0adcf70e497751", "patch": "@@ -3,7 +3,7 @@ use crate::config::StripUnconfigured;\n use crate::configure;\n use crate::hygiene::SyntaxContext;\n use crate::mbe::macro_rules::annotate_err_with_kind;\n-use crate::module::{parse_external_mod, push_directory, Directory, DirectoryOwnership};\n+use crate::module::{mod_dir_path, parse_external_mod, DirOwnership, ParsedExternalMod};\n use crate::placeholders::{placeholder, PlaceholderExpander};\n \n use rustc_ast as ast;\n@@ -355,16 +355,17 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     // FIXME: Avoid visiting the crate as a `Mod` item,\n     // make crate a first class expansion target instead.\n     pub fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n-        let mut module = ModuleData {\n-            mod_path: vec![Ident::from_str(&self.cx.ecfg.crate_name)],\n-            directory: match self.cx.source_map().span_to_unmapped_path(krate.span) {\n-                FileName::Real(name) => name.into_local_path(),\n-                other => PathBuf::from(other.to_string()),\n-            },\n+        let file_path = match self.cx.source_map().span_to_unmapped_path(krate.span) {\n+            FileName::Real(name) => name.into_local_path(),\n+            other => PathBuf::from(other.to_string()),\n         };\n-        module.directory.pop();\n-        self.cx.root_path = module.directory.clone();\n-        self.cx.current_expansion.module = Rc::new(module);\n+        let dir_path = file_path.parent().unwrap_or(&file_path).to_owned();\n+        self.cx.root_path = dir_path.clone();\n+        self.cx.current_expansion.module = Rc::new(ModuleData {\n+            mod_path: vec![Ident::from_str(&self.cx.ecfg.crate_name)],\n+            file_path_stack: vec![file_path],\n+            dir_path,\n+        });\n \n         let krate_item = AstFragment::Items(smallvec![P(ast::Item {\n             attrs: krate.attrs,\n@@ -1245,10 +1246,12 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     }\n \n     fn visit_block(&mut self, block: &mut P<Block>) {\n-        let old_directory_ownership = self.cx.current_expansion.directory_ownership;\n-        self.cx.current_expansion.directory_ownership = DirectoryOwnership::UnownedViaBlock;\n+        let orig_dir_ownership = mem::replace(\n+            &mut self.cx.current_expansion.dir_ownership,\n+            DirOwnership::UnownedViaBlock,\n+        );\n         noop_visit_block(block, self);\n-        self.cx.current_expansion.directory_ownership = old_directory_ownership;\n+        self.cx.current_expansion.dir_ownership = orig_dir_ownership;\n     }\n \n     fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n@@ -1276,63 +1279,76 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 })\n             }\n             ast::ItemKind::Mod(_, ref mut mod_kind) if ident != Ident::invalid() => {\n-                let sess = &self.cx.sess.parse_sess;\n-                let orig_ownership = self.cx.current_expansion.directory_ownership;\n-                let mut module = (*self.cx.current_expansion.module).clone();\n-\n-                let pushed = &mut false; // Record `parse_external_mod` pushing so we can pop.\n-                let dir = Directory { ownership: orig_ownership, path: module.directory };\n-                let Directory { ownership, path } = match mod_kind {\n-                    ModKind::Loaded(_, Inline::Yes, _) => {\n+                let (file_path, dir_path, dir_ownership) = match mod_kind {\n+                    ModKind::Loaded(_, inline, _) => {\n                         // Inline `mod foo { ... }`, but we still need to push directories.\n+                        assert!(\n+                            *inline == Inline::Yes,\n+                            \"`mod` item is loaded from a file for the second time\"\n+                        );\n+                        let (dir_path, dir_ownership) = mod_dir_path(\n+                            &self.cx.sess,\n+                            ident,\n+                            &attrs,\n+                            &self.cx.current_expansion.module,\n+                            self.cx.current_expansion.dir_ownership,\n+                        );\n                         item.attrs = attrs;\n-                        push_directory(&self.cx.sess, ident, &item.attrs, dir)\n-                    }\n-                    ModKind::Loaded(_, Inline::No, _) => {\n-                        panic!(\"`mod` item is loaded from a file for the second time\")\n+                        (None, dir_path, dir_ownership)\n                     }\n                     ModKind::Unloaded => {\n                         // We have an outline `mod foo;` so we need to parse the file.\n-                        let (items, inner_span, dir) =\n-                            parse_external_mod(&self.cx.sess, ident, span, dir, &mut attrs, pushed);\n+                        let old_attrs_len = attrs.len();\n+                        let ParsedExternalMod {\n+                            mut items,\n+                            inner_span,\n+                            file_path,\n+                            dir_path,\n+                            dir_ownership,\n+                        } = parse_external_mod(\n+                            &self.cx.sess,\n+                            ident,\n+                            span,\n+                            &self.cx.current_expansion.module,\n+                            self.cx.current_expansion.dir_ownership,\n+                            &mut attrs,\n+                        );\n \n-                        let krate =\n-                            ast::Crate { attrs, items, span: inner_span, proc_macros: vec![] };\n                         if let Some(extern_mod_loaded) = self.cx.extern_mod_loaded {\n-                            extern_mod_loaded(&krate, ident);\n+                            (attrs, items) = extern_mod_loaded(ident, attrs, items, inner_span);\n                         }\n \n-                        *mod_kind = ModKind::Loaded(krate.items, Inline::No, inner_span);\n-                        item.attrs = krate.attrs;\n-                        // File can have inline attributes, e.g., `#![cfg(...)]` & co. => Reconfigure.\n-                        item = match self.configure(item) {\n-                            Some(node) => node,\n-                            None => {\n-                                if *pushed {\n-                                    sess.included_mod_stack.borrow_mut().pop();\n-                                }\n-                                return Default::default();\n-                            }\n-                        };\n-                        dir\n+                        *mod_kind = ModKind::Loaded(items, Inline::No, inner_span);\n+                        item.attrs = attrs;\n+                        if item.attrs.len() > old_attrs_len {\n+                            // If we loaded an out-of-line module and added some inner attributes,\n+                            // then we need to re-configure it.\n+                            // FIXME: Attributes also need to be recollected\n+                            // for resolution and expansion.\n+                            item = configure!(self, item);\n+                        }\n+                        (Some(file_path), dir_path, dir_ownership)\n                     }\n                 };\n \n                 // Set the module info before we flat map.\n-                self.cx.current_expansion.directory_ownership = ownership;\n-                module.directory = path;\n+                let mut module = self.cx.current_expansion.module.with_dir_path(dir_path);\n                 module.mod_path.push(ident);\n+                if let Some(file_path) = file_path {\n+                    module.file_path_stack.push(file_path);\n+                }\n+\n                 let orig_module =\n                     mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n+                let orig_dir_ownership =\n+                    mem::replace(&mut self.cx.current_expansion.dir_ownership, dir_ownership);\n \n                 let result = noop_flat_map_item(item, self);\n \n                 // Restore the module info.\n+                self.cx.current_expansion.dir_ownership = orig_dir_ownership;\n                 self.cx.current_expansion.module = orig_module;\n-                self.cx.current_expansion.directory_ownership = orig_ownership;\n-                if *pushed {\n-                    sess.included_mod_stack.borrow_mut().pop();\n-                }\n+\n                 result\n             }\n             _ => {"}, {"sha": "1a93975533de03bbafc3c72e1c2fef3c3e55808b", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=4a4e3e667d22442cbfdd04c9fe0adcf70e497751", "patch": "@@ -1,5 +1,7 @@\n+#![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n+#![feature(destructuring_assignment)]\n #![feature(or_patterns)]\n #![feature(proc_macro_diagnostic)]\n #![feature(proc_macro_internals)]"}, {"sha": "2ec656d4895e7f0d960741bdf49cc6c934dc9a51", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 159, "deletions": 207, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=4a4e3e667d22442cbfdd04c9fe0adcf70e497751", "patch": "@@ -1,232 +1,155 @@\n+use crate::base::ModuleData;\n use rustc_ast::ptr::P;\n use rustc_ast::{token, Attribute, Item};\n-use rustc_errors::{struct_span_err, PResult};\n+use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_parse::new_parser_from_file;\n use rustc_session::parse::ParseSess;\n use rustc_session::Session;\n-use rustc_span::source_map::{FileName, Span};\n use rustc_span::symbol::{sym, Ident};\n+use rustc_span::Span;\n \n use std::path::{self, Path, PathBuf};\n \n-#[derive(Clone)]\n-pub struct Directory {\n-    pub path: PathBuf,\n-    pub ownership: DirectoryOwnership,\n-}\n-\n #[derive(Copy, Clone)]\n-pub enum DirectoryOwnership {\n+pub enum DirOwnership {\n     Owned {\n         // None if `mod.rs`, `Some(\"foo\")` if we're in `foo.rs`.\n         relative: Option<Ident>,\n     },\n     UnownedViaBlock,\n-    UnownedViaMod,\n }\n \n-/// Information about the path to a module.\n // Public for rustfmt usage.\n-pub struct ModulePath<'a> {\n-    name: String,\n-    path_exists: bool,\n-    pub result: PResult<'a, ModulePathSuccess>,\n+pub struct ModulePathSuccess {\n+    pub file_path: PathBuf,\n+    pub dir_ownership: DirOwnership,\n }\n \n-// Public for rustfmt usage.\n-pub struct ModulePathSuccess {\n-    pub path: PathBuf,\n-    pub ownership: DirectoryOwnership,\n+crate struct ParsedExternalMod {\n+    pub items: Vec<P<Item>>,\n+    pub inner_span: Span,\n+    pub file_path: PathBuf,\n+    pub dir_path: PathBuf,\n+    pub dir_ownership: DirOwnership,\n+}\n+\n+pub enum ModError<'a> {\n+    CircularInclusion(Vec<PathBuf>),\n+    ModInBlock(Option<Ident>),\n+    FileNotFound(Ident, PathBuf),\n+    MultipleCandidates(Ident, String, String),\n+    ParserError(DiagnosticBuilder<'a>),\n }\n \n crate fn parse_external_mod(\n     sess: &Session,\n-    id: Ident,\n+    ident: Ident,\n     span: Span, // The span to blame on errors.\n-    Directory { mut ownership, path }: Directory,\n+    module: &ModuleData,\n+    mut dir_ownership: DirOwnership,\n     attrs: &mut Vec<Attribute>,\n-    pop_mod_stack: &mut bool,\n-) -> (Vec<P<Item>>, Span, Directory) {\n+) -> ParsedExternalMod {\n     // We bail on the first error, but that error does not cause a fatal error... (1)\n-    let result: PResult<'_, _> = try {\n+    let result: Result<_, ModError<'_>> = try {\n         // Extract the file path and the new ownership.\n-        let mp = submod_path(sess, id, span, &attrs, ownership, &path)?;\n-        ownership = mp.ownership;\n+        let mp = mod_file_path(sess, ident, &attrs, &module.dir_path, dir_ownership)?;\n+        dir_ownership = mp.dir_ownership;\n \n         // Ensure file paths are acyclic.\n-        let mut included_mod_stack = sess.parse_sess.included_mod_stack.borrow_mut();\n-        error_on_circular_module(&sess.parse_sess, span, &mp.path, &included_mod_stack)?;\n-        included_mod_stack.push(mp.path.clone());\n-        *pop_mod_stack = true; // We have pushed, so notify caller.\n-        drop(included_mod_stack);\n+        if let Some(pos) = module.file_path_stack.iter().position(|p| p == &mp.file_path) {\n+            Err(ModError::CircularInclusion(module.file_path_stack[pos..].to_vec()))?;\n+        }\n \n         // Actually parse the external file as a module.\n-        let mut parser = new_parser_from_file(&sess.parse_sess, &mp.path, Some(span));\n-        let (mut inner_attrs, items, inner_span) = parser.parse_mod(&token::Eof)?;\n+        let mut parser = new_parser_from_file(&sess.parse_sess, &mp.file_path, Some(span));\n+        let (mut inner_attrs, items, inner_span) =\n+            parser.parse_mod(&token::Eof).map_err(|err| ModError::ParserError(err))?;\n         attrs.append(&mut inner_attrs);\n-        (items, inner_span)\n+        (items, inner_span, mp.file_path)\n     };\n     // (1) ...instead, we return a dummy module.\n-    let (items, inner_span) = result.map_err(|mut err| err.emit()).unwrap_or_default();\n+    let (items, inner_span, file_path) =\n+        result.map_err(|err| err.report(sess, span)).unwrap_or_default();\n \n-    // Extract the directory path for submodules of  the module.\n-    let path = sess.source_map().span_to_unmapped_path(inner_span);\n-    let mut path = match path {\n-        FileName::Real(name) => name.into_local_path(),\n-        other => PathBuf::from(other.to_string()),\n-    };\n-    path.pop();\n+    // Extract the directory path for submodules of the module.\n+    let dir_path = file_path.parent().unwrap_or(&file_path).to_owned();\n \n-    (items, inner_span, Directory { ownership, path })\n+    ParsedExternalMod { items, inner_span, file_path, dir_path, dir_ownership }\n }\n \n-fn error_on_circular_module<'a>(\n-    sess: &'a ParseSess,\n-    span: Span,\n-    path: &Path,\n-    included_mod_stack: &[PathBuf],\n-) -> PResult<'a, ()> {\n-    if let Some(i) = included_mod_stack.iter().position(|p| *p == path) {\n-        let mut err = String::from(\"circular modules: \");\n-        for p in &included_mod_stack[i..] {\n-            err.push_str(&p.to_string_lossy());\n-            err.push_str(\" -> \");\n-        }\n-        err.push_str(&path.to_string_lossy());\n-        return Err(sess.span_diagnostic.struct_span_err(span, &err[..]));\n-    }\n-    Ok(())\n-}\n-\n-crate fn push_directory(\n+crate fn mod_dir_path(\n     sess: &Session,\n-    id: Ident,\n+    ident: Ident,\n     attrs: &[Attribute],\n-    Directory { mut ownership, mut path }: Directory,\n-) -> Directory {\n-    if let Some(filename) = sess.first_attr_value_str_by_name(attrs, sym::path) {\n-        path.push(&*filename.as_str());\n-        ownership = DirectoryOwnership::Owned { relative: None };\n-    } else {\n-        // We have to push on the current module name in the case of relative\n-        // paths in order to ensure that any additional module paths from inline\n-        // `mod x { ... }` come after the relative extension.\n-        //\n-        // For example, a `mod z { ... }` inside `x/y.rs` should set the current\n-        // directory path to `/x/y/z`, not `/x/z` with a relative offset of `y`.\n-        if let DirectoryOwnership::Owned { relative } = &mut ownership {\n-            if let Some(ident) = relative.take() {\n-                // Remove the relative offset.\n-                path.push(&*ident.as_str());\n-            }\n+    module: &ModuleData,\n+    mut dir_ownership: DirOwnership,\n+) -> (PathBuf, DirOwnership) {\n+    if let Some(file_path) = mod_file_path_from_attr(sess, attrs, &module.dir_path) {\n+        // For inline modules file path from `#[path]` is actually the directory path\n+        // for historical reasons, so we don't pop the last segment here.\n+        return (file_path, DirOwnership::Owned { relative: None });\n+    }\n+\n+    // We have to push on the current module name in the case of relative\n+    // paths in order to ensure that any additional module paths from inline\n+    // `mod x { ... }` come after the relative extension.\n+    //\n+    // For example, a `mod z { ... }` inside `x/y.rs` should set the current\n+    // directory path to `/x/y/z`, not `/x/z` with a relative offset of `y`.\n+    let mut dir_path = module.dir_path.clone();\n+    if let DirOwnership::Owned { relative } = &mut dir_ownership {\n+        if let Some(ident) = relative.take() {\n+            // Remove the relative offset.\n+            dir_path.push(&*ident.as_str());\n         }\n-        path.push(&*id.as_str());\n     }\n-    Directory { ownership, path }\n+    dir_path.push(&*ident.as_str());\n+\n+    (dir_path, dir_ownership)\n }\n \n-fn submod_path<'a>(\n+fn mod_file_path<'a>(\n     sess: &'a Session,\n-    id: Ident,\n-    span: Span,\n+    ident: Ident,\n     attrs: &[Attribute],\n-    ownership: DirectoryOwnership,\n     dir_path: &Path,\n-) -> PResult<'a, ModulePathSuccess> {\n-    if let Some(path) = submod_path_from_attr(sess, attrs, dir_path) {\n-        let ownership = match path.file_name().and_then(|s| s.to_str()) {\n-            // All `#[path]` files are treated as though they are a `mod.rs` file.\n-            // This means that `mod foo;` declarations inside `#[path]`-included\n-            // files are siblings,\n-            //\n-            // Note that this will produce weirdness when a file named `foo.rs` is\n-            // `#[path]` included and contains a `mod foo;` declaration.\n-            // If you encounter this, it's your own darn fault :P\n-            Some(_) => DirectoryOwnership::Owned { relative: None },\n-            _ => DirectoryOwnership::UnownedViaMod,\n-        };\n-        return Ok(ModulePathSuccess { ownership, path });\n+    dir_ownership: DirOwnership,\n+) -> Result<ModulePathSuccess, ModError<'a>> {\n+    if let Some(file_path) = mod_file_path_from_attr(sess, attrs, dir_path) {\n+        // All `#[path]` files are treated as though they are a `mod.rs` file.\n+        // This means that `mod foo;` declarations inside `#[path]`-included\n+        // files are siblings,\n+        //\n+        // Note that this will produce weirdness when a file named `foo.rs` is\n+        // `#[path]` included and contains a `mod foo;` declaration.\n+        // If you encounter this, it's your own darn fault :P\n+        let dir_ownership = DirOwnership::Owned { relative: None };\n+        return Ok(ModulePathSuccess { file_path, dir_ownership });\n     }\n \n-    let relative = match ownership {\n-        DirectoryOwnership::Owned { relative } => relative,\n-        DirectoryOwnership::UnownedViaBlock | DirectoryOwnership::UnownedViaMod => None,\n+    let relative = match dir_ownership {\n+        DirOwnership::Owned { relative } => relative,\n+        DirOwnership::UnownedViaBlock => None,\n     };\n-    let ModulePath { path_exists, name, result } =\n-        default_submod_path(&sess.parse_sess, id, span, relative, dir_path);\n-    match ownership {\n-        DirectoryOwnership::Owned { .. } => Ok(result?),\n-        DirectoryOwnership::UnownedViaBlock => {\n-            let _ = result.map_err(|mut err| err.cancel());\n-            error_decl_mod_in_block(&sess.parse_sess, span, path_exists, &name)\n-        }\n-        DirectoryOwnership::UnownedViaMod => {\n-            let _ = result.map_err(|mut err| err.cancel());\n-            error_cannot_declare_mod_here(&sess.parse_sess, span, path_exists, &name)\n-        }\n+    let result = default_submod_path(&sess.parse_sess, ident, relative, dir_path);\n+    match dir_ownership {\n+        DirOwnership::Owned { .. } => result,\n+        DirOwnership::UnownedViaBlock => Err(ModError::ModInBlock(match result {\n+            Ok(_) | Err(ModError::MultipleCandidates(..)) => Some(ident),\n+            _ => None,\n+        })),\n     }\n }\n \n-fn error_decl_mod_in_block<'a, T>(\n-    sess: &'a ParseSess,\n-    span: Span,\n-    path_exists: bool,\n-    name: &str,\n-) -> PResult<'a, T> {\n-    let msg = \"Cannot declare a non-inline module inside a block unless it has a path attribute\";\n-    let mut err = sess.span_diagnostic.struct_span_err(span, msg);\n-    if path_exists {\n-        let msg = format!(\"Maybe `use` the module `{}` instead of redeclaring it\", name);\n-        err.span_note(span, &msg);\n-    }\n-    Err(err)\n-}\n-\n-fn error_cannot_declare_mod_here<'a, T>(\n-    sess: &'a ParseSess,\n-    span: Span,\n-    path_exists: bool,\n-    name: &str,\n-) -> PResult<'a, T> {\n-    let mut err =\n-        sess.span_diagnostic.struct_span_err(span, \"cannot declare a new module at this location\");\n-    if !span.is_dummy() {\n-        if let FileName::Real(src_name) = sess.source_map().span_to_filename(span) {\n-            let src_path = src_name.into_local_path();\n-            if let Some(stem) = src_path.file_stem() {\n-                let mut dest_path = src_path.clone();\n-                dest_path.set_file_name(stem);\n-                dest_path.push(\"mod.rs\");\n-                err.span_note(\n-                    span,\n-                    &format!(\n-                        \"maybe move this module `{}` to its own directory via `{}`\",\n-                        src_path.display(),\n-                        dest_path.display()\n-                    ),\n-                );\n-            }\n-        }\n-    }\n-    if path_exists {\n-        err.span_note(\n-            span,\n-            &format!(\"... or maybe `use` the module `{}` instead of possibly redeclaring it\", name),\n-        );\n-    }\n-    Err(err)\n-}\n-\n /// Derive a submodule path from the first found `#[path = \"path_string\"]`.\n /// The provided `dir_path` is joined with the `path_string`.\n-pub(super) fn submod_path_from_attr(\n+fn mod_file_path_from_attr(\n     sess: &Session,\n     attrs: &[Attribute],\n     dir_path: &Path,\n ) -> Option<PathBuf> {\n     // Extract path string from first `#[path = \"path_string\"]` attribute.\n-    let path_string = sess.first_attr_value_str_by_name(attrs, sym::path)?;\n-    let path_string = path_string.as_str();\n+    let path_string = sess.first_attr_value_str_by_name(attrs, sym::path)?.as_str();\n \n     // On windows, the base path might have the form\n     // `\\\\?\\foo\\bar` in which case it does not tolerate\n@@ -242,15 +165,14 @@ pub(super) fn submod_path_from_attr(\n // Public for rustfmt usage.\n pub fn default_submod_path<'a>(\n     sess: &'a ParseSess,\n-    id: Ident,\n-    span: Span,\n+    ident: Ident,\n     relative: Option<Ident>,\n     dir_path: &Path,\n-) -> ModulePath<'a> {\n+) -> Result<ModulePathSuccess, ModError<'a>> {\n     // If we're in a foo.rs file instead of a mod.rs file,\n     // we need to look for submodules in\n-    // `./foo/<id>.rs` and `./foo/<id>/mod.rs` rather than\n-    // `./<id>.rs` and `./<id>/mod.rs`.\n+    // `./foo/<ident>.rs` and `./foo/<ident>/mod.rs` rather than\n+    // `./<ident>.rs` and `./<ident>/mod.rs`.\n     let relative_prefix_string;\n     let relative_prefix = if let Some(ident) = relative {\n         relative_prefix_string = format!(\"{}{}\", ident.name, path::MAIN_SEPARATOR);\n@@ -259,7 +181,7 @@ pub fn default_submod_path<'a>(\n         \"\"\n     };\n \n-    let mod_name = id.name.to_string();\n+    let mod_name = ident.name.to_string();\n     let default_path_str = format!(\"{}{}.rs\", relative_prefix, mod_name);\n     let secondary_path_str =\n         format!(\"{}{}{}mod.rs\", relative_prefix, mod_name, path::MAIN_SEPARATOR);\n@@ -268,44 +190,74 @@ pub fn default_submod_path<'a>(\n     let default_exists = sess.source_map().file_exists(&default_path);\n     let secondary_exists = sess.source_map().file_exists(&secondary_path);\n \n-    let result = match (default_exists, secondary_exists) {\n+    match (default_exists, secondary_exists) {\n         (true, false) => Ok(ModulePathSuccess {\n-            path: default_path,\n-            ownership: DirectoryOwnership::Owned { relative: Some(id) },\n+            file_path: default_path,\n+            dir_ownership: DirOwnership::Owned { relative: Some(ident) },\n         }),\n         (false, true) => Ok(ModulePathSuccess {\n-            path: secondary_path,\n-            ownership: DirectoryOwnership::Owned { relative: None },\n+            file_path: secondary_path,\n+            dir_ownership: DirOwnership::Owned { relative: None },\n         }),\n-        (false, false) => {\n-            let mut err = struct_span_err!(\n-                sess.span_diagnostic,\n-                span,\n-                E0583,\n-                \"file not found for module `{}`\",\n-                mod_name,\n-            );\n-            err.help(&format!(\n-                \"to create the module `{}`, create file \\\"{}\\\"\",\n-                mod_name,\n-                default_path.display(),\n-            ));\n-            Err(err)\n-        }\n+        (false, false) => Err(ModError::FileNotFound(ident, default_path)),\n         (true, true) => {\n-            let mut err = struct_span_err!(\n-                sess.span_diagnostic,\n-                span,\n-                E0761,\n-                \"file for module `{}` found at both {} and {}\",\n-                mod_name,\n-                default_path_str,\n-                secondary_path_str,\n-            );\n-            err.help(\"delete or rename one of them to remove the ambiguity\");\n-            Err(err)\n+            Err(ModError::MultipleCandidates(ident, default_path_str, secondary_path_str))\n         }\n-    };\n+    }\n+}\n \n-    ModulePath { name: mod_name, path_exists: default_exists || secondary_exists, result }\n+impl ModError<'_> {\n+    fn report(self, sess: &Session, span: Span) {\n+        let diag = &sess.parse_sess.span_diagnostic;\n+        match self {\n+            ModError::CircularInclusion(file_paths) => {\n+                let mut msg = String::from(\"circular modules: \");\n+                for file_path in &file_paths {\n+                    msg.push_str(&file_path.display().to_string());\n+                    msg.push_str(\" -> \");\n+                }\n+                msg.push_str(&file_paths[0].display().to_string());\n+                diag.struct_span_err(span, &msg)\n+            }\n+            ModError::ModInBlock(ident) => {\n+                let msg = \"cannot declare a non-inline module inside a block unless it has a path attribute\";\n+                let mut err = diag.struct_span_err(span, msg);\n+                if let Some(ident) = ident {\n+                    let note =\n+                        format!(\"maybe `use` the module `{}` instead of redeclaring it\", ident);\n+                    err.span_note(span, &note);\n+                }\n+                err\n+            }\n+            ModError::FileNotFound(ident, default_path) => {\n+                let mut err = struct_span_err!(\n+                    diag,\n+                    span,\n+                    E0583,\n+                    \"file not found for module `{}`\",\n+                    ident,\n+                );\n+                err.help(&format!(\n+                    \"to create the module `{}`, create file \\\"{}\\\"\",\n+                    ident,\n+                    default_path.display(),\n+                ));\n+                err\n+            }\n+            ModError::MultipleCandidates(ident, default_path_short, secondary_path_short) => {\n+                let mut err = struct_span_err!(\n+                    diag,\n+                    span,\n+                    E0761,\n+                    \"file for module `{}` found at both {} and {}\",\n+                    ident,\n+                    default_path_short,\n+                    secondary_path_short,\n+                );\n+                err.help(\"delete or rename one of them to remove the ambiguity\");\n+                err\n+            }\n+            ModError::ParserError(err) => err,\n+        }.emit()\n+    }\n }"}, {"sha": "94be7a03a932b854e099f165037032b3fc4a4800", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=4a4e3e667d22442cbfdd04c9fe0adcf70e497751", "patch": "@@ -302,8 +302,10 @@ fn configure_and_expand_inner<'a>(\n             ..rustc_expand::expand::ExpansionConfig::default(crate_name.to_string())\n         };\n \n-        let extern_mod_loaded = |k: &ast::Crate, ident: Ident| {\n-            pre_expansion_lint(sess, lint_store, k, &*ident.name.as_str())\n+        let extern_mod_loaded = |ident: Ident, attrs, items, span| {\n+            let krate = ast::Crate { attrs, items, span, proc_macros: vec![] };\n+            pre_expansion_lint(sess, lint_store, &krate, &ident.name.as_str());\n+            (krate.attrs, krate.items)\n         };\n         let mut ecx = ExtCtxt::new(&sess, cfg, &mut resolver, Some(&extern_mod_loaded));\n "}, {"sha": "592773bfe1b440920df5b8bcceb5838994453f32", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=4a4e3e667d22442cbfdd04c9fe0adcf70e497751", "patch": "@@ -13,7 +13,6 @@ use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::{FilePathMapping, SourceMap};\n use rustc_span::{MultiSpan, Span, Symbol};\n \n-use std::path::PathBuf;\n use std::str;\n \n /// The set of keys (and, optionally, values) that define the compilation\n@@ -122,8 +121,6 @@ pub struct ParseSess {\n     pub missing_fragment_specifiers: Lock<FxHashMap<Span, NodeId>>,\n     /// Places where raw identifiers were used. This is used for feature-gating raw identifiers.\n     pub raw_identifier_spans: Lock<Vec<Span>>,\n-    /// Used to determine and report recursive module inclusions.\n-    pub included_mod_stack: Lock<Vec<PathBuf>>,\n     source_map: Lrc<SourceMap>,\n     pub buffered_lints: Lock<Vec<BufferedEarlyLint>>,\n     /// Contains the spans of block expressions that could have been incomplete based on the\n@@ -157,7 +154,6 @@ impl ParseSess {\n             edition: ExpnId::root().expn_data().edition,\n             missing_fragment_specifiers: Default::default(),\n             raw_identifier_spans: Lock::new(Vec::new()),\n-            included_mod_stack: Lock::new(vec![]),\n             source_map,\n             buffered_lints: Lock::new(vec![]),\n             ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),"}, {"sha": "fa81769e5a80021380f77c36d8fb66f45351c28b", "filename": "src/test/ui/directory_ownership/macro-expanded-mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs?ref=4a4e3e667d22442cbfdd04c9fe0adcf70e497751", "patch": "@@ -2,7 +2,7 @@\n \n macro_rules! mod_decl {\n     ($i:ident) => {\n-        mod $i; //~ ERROR Cannot declare a non-inline module inside a block\n+        mod $i; //~ ERROR cannot declare a non-inline module inside a block\n     };\n }\n "}, {"sha": "4039728e18ac384c22fef6784a6559e52969349c", "filename": "src/test/ui/directory_ownership/macro-expanded-mod.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr?ref=4a4e3e667d22442cbfdd04c9fe0adcf70e497751", "patch": "@@ -1,4 +1,4 @@\n-error: Cannot declare a non-inline module inside a block unless it has a path attribute\n+error: cannot declare a non-inline module inside a block unless it has a path attribute\n   --> $DIR/macro-expanded-mod.rs:5:9\n    |\n LL |         mod $i;"}, {"sha": "de4f816656cc477b21c913e831c54f41b943849a", "filename": "src/test/ui/directory_ownership/non-inline-mod-restriction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.rs?ref=4a4e3e667d22442cbfdd04c9fe0adcf70e497751", "patch": "@@ -1,5 +1,5 @@\n // Test that non-inline modules are not allowed inside blocks.\n \n fn main() {\n-    mod foo; //~ ERROR Cannot declare a non-inline module inside a block\n+    mod foo; //~ ERROR cannot declare a non-inline module inside a block\n }"}, {"sha": "64189bee43f6ebc07f1db8e02340d7d789c86a0c", "filename": "src/test/ui/directory_ownership/non-inline-mod-restriction.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.stderr?ref=4a4e3e667d22442cbfdd04c9fe0adcf70e497751", "patch": "@@ -1,4 +1,4 @@\n-error: Cannot declare a non-inline module inside a block unless it has a path attribute\n+error: cannot declare a non-inline module inside a block unless it has a path attribute\n   --> $DIR/non-inline-mod-restriction.rs:4:5\n    |\n LL |     mod foo;"}, {"sha": "f62cd2a9eb4e42e6a2b60a481b4e21b46535b76b", "filename": "src/test/ui/modules/path-no-file-name.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/src%2Ftest%2Fui%2Fmodules%2Fpath-no-file-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/src%2Ftest%2Fui%2Fmodules%2Fpath-no-file-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmodules%2Fpath-no-file-name.rs?ref=4a4e3e667d22442cbfdd04c9fe0adcf70e497751", "patch": "@@ -0,0 +1,7 @@\n+// normalize-stderr-test: \"\\.:.*\\(\" -> \".: $$ACCESS_DENIED_MSG (\"\n+// normalize-stderr-test: \"os error \\d+\" -> \"os error $$ACCESS_DENIED_CODE\"\n+\n+#[path = \".\"]\n+mod m; //~ ERROR couldn't read\n+\n+fn main() {}"}, {"sha": "32a213c68f654c2754d944a263c23919f6b161db", "filename": "src/test/ui/modules/path-no-file-name.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/src%2Ftest%2Fui%2Fmodules%2Fpath-no-file-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/src%2Ftest%2Fui%2Fmodules%2Fpath-no-file-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmodules%2Fpath-no-file-name.stderr?ref=4a4e3e667d22442cbfdd04c9fe0adcf70e497751", "patch": "@@ -0,0 +1,8 @@\n+error: couldn't read $DIR/.: $ACCESS_DENIED_MSG (os error $ACCESS_DENIED_CODE)\n+  --> $DIR/path-no-file-name.rs:5:1\n+   |\n+LL | mod m;\n+   | ^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "d4b47efe681580fa2f97d9c92f16780ec8a10812", "filename": "src/test/ui/parser/circular_modules_main.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.rs?ref=4a4e3e667d22442cbfdd04c9fe0adcf70e497751", "patch": "@@ -1,10 +1,12 @@\n+// error-pattern: circular modules\n+\n #[path = \"circular_modules_hello.rs\"]\n-mod circular_modules_hello; //~ ERROR: circular modules\n+mod circular_modules_hello;\n \n pub fn hi_str() -> String {\n     \"Hi!\".to_string()\n }\n \n fn main() {\n-    circular_modules_hello::say_hello(); //~ ERROR cannot find function `say_hello` in module\n+    circular_modules_hello::say_hello();\n }"}, {"sha": "ee45f65a3bd5ad1b079e3161e5f843b64f76cef3", "filename": "src/test/ui/parser/circular_modules_main.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4a4e3e667d22442cbfdd04c9fe0adcf70e497751/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.stderr?ref=4a4e3e667d22442cbfdd04c9fe0adcf70e497751", "patch": "@@ -1,18 +1,18 @@\n-error: circular modules: $DIR/circular_modules_hello.rs -> $DIR/circular_modules_main.rs -> $DIR/circular_modules_hello.rs\n-  --> $DIR/circular_modules_main.rs:2:1\n+error: circular modules: $DIR/circular_modules_main.rs -> $DIR/circular_modules_hello.rs -> $DIR/circular_modules_main.rs\n+  --> $DIR/circular_modules_hello.rs:4:1\n    |\n-LL | mod circular_modules_hello;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | mod circular_modules_main;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0425]: cannot find function `say_hello` in module `circular_modules_hello`\n-  --> $DIR/circular_modules_main.rs:9:29\n+error[E0425]: cannot find function `hi_str` in module `circular_modules_main`\n+  --> $DIR/circular_modules_hello.rs:7:43\n    |\n-LL |     circular_modules_hello::say_hello();\n-   |                             ^^^^^^^^^ not found in `circular_modules_hello`\n+LL |     println!(\"{}\", circular_modules_main::hi_str());\n+   |                                           ^^^^^^ not found in `circular_modules_main`\n    |\n help: consider importing this function\n    |\n-LL | use circular_modules_hello::say_hello;\n+LL | use hi_str;\n    |\n \n error: aborting due to 2 previous errors"}]}