{"sha": "a3ff52ce92f1dedea32c69afbbd3dabb6b457731", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZmY1MmNlOTJmMWRlZGVhMzJjNjlhZmJiZDNkYWJiNmI0NTc3MzE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-11-24T02:17:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-24T02:17:01Z"}, "message": "Rollup merge of #66594 - Aaron1011:fix/debug-print-cycle, r=matthewjasper\n\nFix cycle when debug-printing opaque types\n\nFixes #61577\n\nWhen printing an opaque type in non-verbose mode, we use the\n`tcx.predicates_of` query to retrieve the opaque type's bounds for\npretty-printing. However, the pervasiveness of logging within librustc\nmeans that we may already be executing `tcx.predicates_of` for the\nopaque type we're trying to print, leading to a cycle error.\n\nThis commit adds a new 'no queries' thread-local flag to the pretty\nprinter. This flag is enabled during the computation of `predicates_of`\nfor opaque types, and causes us to print the opaque type in 'verbose'\nmode (which does not require computing any additinal queries). This\nshould only affect debug logging for highly nested log messages, not any\nuser-visible output.", "tree": {"sha": "dd536bf4935d33d2652eac963df80f49e6b40cd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd536bf4935d33d2652eac963df80f49e6b40cd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3ff52ce92f1dedea32c69afbbd3dabb6b457731", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd2egdCRBK7hj4Ov3rIwAAdHIIAGC/qd2j+0VKibkefXf2OKg9\nBGJWknkP7c8onkZ+Ibk9WBNVQ34KPBxa/kg/xZF+E7OvZg4CFrVkBE2cdrPr8Z0C\nOQEi1tc+hEWZY8Aw9UgANupCvrTxB06FyxvWzXJaLbMPSEL3Dha8ZHL5maK6ygc4\nasXKb+5cgLVkbe/4Fd+XGMl3M4QNcxqy4ug3YE8XDN1Rs0wy3ZzwakJ15Z7pu+DR\naOe87jwMi0raONzpvEGmZBCakRZNFlKZDfIM/cr9D1nOb5qegTmB9O+DF+wp1QNb\nt9PEoz1VivnLVfNjtgJwZ1YycZj3GPMFgoPurc5aIxJsN5sh/sVcz2rpIGkctL8=\n=exLh\n-----END PGP SIGNATURE-----\n", "payload": "tree dd536bf4935d33d2652eac963df80f49e6b40cd4\nparent 9b0427fc943490fd0065c656afd185a219b672c4\nparent 2ba982d0e5ad87581e3685cba9207ffaf61a866e\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1574561821 +0100\ncommitter GitHub <noreply@github.com> 1574561821 +0100\n\nRollup merge of #66594 - Aaron1011:fix/debug-print-cycle, r=matthewjasper\n\nFix cycle when debug-printing opaque types\n\nFixes #61577\n\nWhen printing an opaque type in non-verbose mode, we use the\n`tcx.predicates_of` query to retrieve the opaque type's bounds for\npretty-printing. However, the pervasiveness of logging within librustc\nmeans that we may already be executing `tcx.predicates_of` for the\nopaque type we're trying to print, leading to a cycle error.\n\nThis commit adds a new 'no queries' thread-local flag to the pretty\nprinter. This flag is enabled during the computation of `predicates_of`\nfor opaque types, and causes us to print the opaque type in 'verbose'\nmode (which does not require computing any additinal queries). This\nshould only affect debug logging for highly nested log messages, not any\nuser-visible output.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3ff52ce92f1dedea32c69afbbd3dabb6b457731", "html_url": "https://github.com/rust-lang/rust/commit/a3ff52ce92f1dedea32c69afbbd3dabb6b457731", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3ff52ce92f1dedea32c69afbbd3dabb6b457731/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b0427fc943490fd0065c656afd185a219b672c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b0427fc943490fd0065c656afd185a219b672c4", "html_url": "https://github.com/rust-lang/rust/commit/9b0427fc943490fd0065c656afd185a219b672c4"}, {"sha": "2ba982d0e5ad87581e3685cba9207ffaf61a866e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ba982d0e5ad87581e3685cba9207ffaf61a866e", "html_url": "https://github.com/rust-lang/rust/commit/2ba982d0e5ad87581e3685cba9207ffaf61a866e"}], "stats": {"total": 157, "additions": 94, "deletions": 63}, "files": [{"sha": "ee05d57d239104b2b890a22647e842034a3caeaa", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 65, "deletions": 38, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/a3ff52ce92f1dedea32c69afbbd3dabb6b457731/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ff52ce92f1dedea32c69afbbd3dabb6b457731/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=a3ff52ce92f1dedea32c69afbbd3dabb6b457731", "patch": "@@ -49,6 +49,24 @@ macro_rules! define_scoped_cx {\n thread_local! {\n     static FORCE_IMPL_FILENAME_LINE: Cell<bool> = Cell::new(false);\n     static SHOULD_PREFIX_WITH_CRATE: Cell<bool> = Cell::new(false);\n+    static NO_QUERIES: Cell<bool> = Cell::new(false);\n+}\n+\n+/// Avoids running any queries during any prints that occur\n+/// during the closure. This may alter the apperance of some\n+/// types (e.g. forcing verbose printing for opaque types).\n+/// This method is used during some queries (e.g. `predicates_of`\n+/// for opaque types), to ensure that any debug printing that\n+/// occurs during the query computation does not end up recursively\n+/// calling the same query.\n+pub fn with_no_queries<F: FnOnce() -> R, R>(f: F) -> R {\n+    NO_QUERIES.with(|no_queries| {\n+        let old = no_queries.get();\n+        no_queries.set(true);\n+        let result = f();\n+        no_queries.set(old);\n+        result\n+    })\n }\n \n /// Force us to name impls with just the filename/line number. We\n@@ -556,52 +574,61 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             ty::Opaque(def_id, substs) => {\n                 // FIXME(eddyb) print this with `print_def_path`.\n-                if self.tcx().sess.verbose() {\n+                // We use verbose printing in 'NO_QUERIES' mode, to\n+                // avoid needing to call `predicates_of`. This should\n+                // only affect certain debug messages (e.g. messages printed\n+                // from `rustc::ty` during the computation of `tcx.predicates_of`),\n+                // and should have no effect on any compiler output.\n+                if self.tcx().sess.verbose() || NO_QUERIES.with(|q| q.get())  {\n                     p!(write(\"Opaque({:?}, {:?})\", def_id, substs));\n                     return Ok(self);\n                 }\n \n-                let def_key = self.tcx().def_key(def_id);\n-                if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n-                    p!(write(\"{}\", name));\n-                    let mut substs = substs.iter();\n-                    // FIXME(eddyb) print this with `print_def_path`.\n-                    if let Some(first) = substs.next() {\n-                        p!(write(\"::<\"));\n-                        p!(print(first));\n-                        for subst in substs {\n-                            p!(write(\", \"), print(subst));\n+                return Ok(with_no_queries(|| {\n+\n+                    let def_key = self.tcx().def_key(def_id);\n+                    if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n+                        p!(write(\"{}\", name));\n+                        let mut substs = substs.iter();\n+                        // FIXME(eddyb) print this with `print_def_path`.\n+                        if let Some(first) = substs.next() {\n+                            p!(write(\"::<\"));\n+                            p!(print(first));\n+                            for subst in substs {\n+                                p!(write(\", \"), print(subst));\n+                            }\n+                            p!(write(\">\"));\n                         }\n-                        p!(write(\">\"));\n+                        return Ok(self);\n                     }\n-                    return Ok(self);\n-                }\n-                // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n-                // by looking up the projections associated with the def_id.\n-                let bounds = self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n-\n-                let mut first = true;\n-                let mut is_sized = false;\n-                p!(write(\"impl\"));\n-                for predicate in bounds.predicates {\n-                    if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n-                        // Don't print +Sized, but rather +?Sized if absent.\n-                        if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n-                            is_sized = true;\n-                            continue;\n-                        }\n+                    // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n+                    // by looking up the projections associated with the def_id.\n+                    let bounds = self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n+\n+                    let mut first = true;\n+                    let mut is_sized = false;\n+                    p!(write(\"impl\"));\n+                    for predicate in bounds.predicates {\n+                        if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n+                            // Don't print +Sized, but rather +?Sized if absent.\n+                            if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n+                                is_sized = true;\n+                                continue;\n+                            }\n \n-                        p!(\n-                                write(\"{}\", if first { \" \" } else { \"+\" }),\n-                                print(trait_ref));\n-                        first = false;\n+                            p!(\n+                                    write(\"{}\", if first { \" \" } else { \"+\" }),\n+                                    print(trait_ref));\n+                            first = false;\n+                        }\n                     }\n-                }\n-                if !is_sized {\n-                    p!(write(\"{}?Sized\", if first { \" \" } else { \"+\" }));\n-                } else if first {\n-                    p!(write(\" Sized\"));\n-                }\n+                    if !is_sized {\n+                        p!(write(\"{}?Sized\", if first { \" \" } else { \"+\" }));\n+                    } else if first {\n+                        p!(write(\" Sized\"));\n+                    }\n+                    Ok(self)\n+                })?);\n             }\n             ty::Str => p!(write(\"str\")),\n             ty::Generator(did, substs, movability) => {"}, {"sha": "8dced83b987ea950b8e257d0830fae58e8453fdd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a3ff52ce92f1dedea32c69afbbd3dabb6b457731/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ff52ce92f1dedea32c69afbbd3dabb6b457731/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=a3ff52ce92f1dedea32c69afbbd3dabb6b457731", "patch": "@@ -2056,20 +2056,22 @@ fn explicit_predicates_of(\n \n         Node::ImplItem(item) => match item.kind {\n             ImplItemKind::OpaqueTy(ref bounds) => {\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                let opaque_ty = tcx.mk_opaque(def_id, substs);\n-\n-                // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n-                let bounds = AstConv::compute_bounds(\n-                    &icx,\n-                    opaque_ty,\n-                    bounds,\n-                    SizedByDefault::Yes,\n-                    tcx.def_span(def_id),\n-                );\n+                ty::print::with_no_queries(|| {\n+                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                    let opaque_ty = tcx.mk_opaque(def_id, substs);\n+\n+                    // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n+                    let bounds = AstConv::compute_bounds(\n+                        &icx,\n+                        opaque_ty,\n+                        bounds,\n+                        SizedByDefault::Yes,\n+                        tcx.def_span(def_id),\n+                    );\n \n-                predicates.extend(bounds.predicates(tcx, opaque_ty));\n-                &item.generics\n+                    predicates.extend(bounds.predicates(tcx, opaque_ty));\n+                    &item.generics\n+                })\n             }\n             _ => &item.generics,\n         },\n@@ -2102,19 +2104,21 @@ fn explicit_predicates_of(\n                     ref generics,\n                     origin: _,\n                 }) => {\n-                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                    let opaque_ty = tcx.mk_opaque(def_id, substs);\n-\n-                    // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n-                    let bounds = AstConv::compute_bounds(\n-                        &icx,\n-                        opaque_ty,\n-                        bounds,\n-                        SizedByDefault::Yes,\n-                        tcx.def_span(def_id),\n-                    );\n+                    let bounds_predicates = ty::print::with_no_queries(|| {\n+                        let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                        let opaque_ty = tcx.mk_opaque(def_id, substs);\n+\n+                        // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n+                        let bounds = AstConv::compute_bounds(\n+                            &icx,\n+                            opaque_ty,\n+                            bounds,\n+                            SizedByDefault::Yes,\n+                            tcx.def_span(def_id),\n+                        );\n \n-                    let bounds_predicates = bounds.predicates(tcx, opaque_ty);\n+                        bounds.predicates(tcx, opaque_ty)\n+                    });\n                     if impl_trait_fn.is_some() {\n                         // opaque types\n                         return ty::GenericPredicates {"}]}