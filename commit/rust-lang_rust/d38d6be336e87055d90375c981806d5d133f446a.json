{"sha": "d38d6be336e87055d90375c981806d5d133f446a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzOGQ2YmUzMzZlODcwNTVkOTAzNzVjOTgxODA2ZDVkMTMzZjQ0NmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-20T11:08:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-20T11:08:37Z"}, "message": "Auto merge of #57655 - mtak-:fix-tls-dtors-macos, r=alexcrichton\n\nOSX: fix #57534 registering thread dtors while running thread dtors\n\nr? @alexcrichton\n\n- \"fast\" `thread_local` destructors get run even on the main thread\n- \"fast\" `thread_local` dtors, can initialize other `thread_local`'s\n\nOne corner case where this fix doesn't work, is when a C++ `thread_local` triggers the initialization of a rust `thread_local`.\n\nI did not add any std::thread specific flag to indicate that the thread is currently exiting, which would be checked before registering a new dtor (I didn't really know where to stick that). I think this does the trick tho!\n\nLet me know if anything needs tweaking/fixing/etc.\n\nresolves this for macos: https://github.com/rust-lang/rust/issues/28129\nfixes: https://github.com/rust-lang/rust/issues/57534", "tree": {"sha": "633c25a2d88501d0fe178f944055264d5a36d1c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/633c25a2d88501d0fe178f944055264d5a36d1c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d38d6be336e87055d90375c981806d5d133f446a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d38d6be336e87055d90375c981806d5d133f446a", "html_url": "https://github.com/rust-lang/rust/commit/d38d6be336e87055d90375c981806d5d133f446a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d38d6be336e87055d90375c981806d5d133f446a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ab5d8ac447f1f3f865dbae5bafbdeacacdea6d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ab5d8ac447f1f3f865dbae5bafbdeacacdea6d9", "html_url": "https://github.com/rust-lang/rust/commit/2ab5d8ac447f1f3f865dbae5bafbdeacacdea6d9"}, {"sha": "1a51bb8174e97251a37fcd83ff8750b7773e762a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a51bb8174e97251a37fcd83ff8750b7773e762a", "html_url": "https://github.com/rust-lang/rust/commit/1a51bb8174e97251a37fcd83ff8750b7773e762a"}], "stats": {"total": 69, "additions": 45, "deletions": 24}, "files": [{"sha": "742ffd12b883dc89035c73c81aae9379a2a02bf7", "filename": "src/libstd/sys/unix/fast_thread_local.rs", "status": "modified", "additions": 44, "deletions": 17, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d38d6be336e87055d90375c981806d5d133f446a/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38d6be336e87055d90375c981806d5d133f446a/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs?ref=d38d6be336e87055d90375c981806d5d133f446a", "patch": "@@ -33,30 +33,57 @@ pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n     register_dtor_fallback(t, dtor);\n }\n \n-// macOS's analog of the above linux function is this _tlv_atexit function.\n-// The disassembly of thread_local globals in C++ (at least produced by\n-// clang) will have this show up in the output.\n+// This implementation is very similar to register_dtor_fallback in\n+// sys_common/thread_local.rs. The main difference is that we want to hook into\n+// macOS's analog of the above linux function, _tlv_atexit. OSX will run the\n+// registered dtors before any TLS slots get freed, and when the main thread\n+// exits.\n+//\n+// Unfortunately, calling _tlv_atexit while tls dtors are running is UB. The\n+// workaround below is to register, via _tlv_atexit, a custom DTOR list once per\n+// thread. thread_local dtors are pushed to the DTOR list without calling\n+// _tlv_atexit.\n #[cfg(target_os = \"macos\")]\n pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+    use cell::Cell;\n+    use ptr;\n+\n+    #[thread_local]\n+    static REGISTERED: Cell<bool> = Cell::new(false);\n+    if !REGISTERED.get() {\n+        _tlv_atexit(run_dtors, ptr::null_mut());\n+        REGISTERED.set(true);\n+    }\n+\n+    type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n+\n+    #[thread_local]\n+    static DTORS: Cell<*mut List> = Cell::new(ptr::null_mut());\n+    if DTORS.get().is_null() {\n+        let v: Box<List> = box Vec::new();\n+        DTORS.set(Box::into_raw(v));\n+    }\n+\n     extern {\n         fn _tlv_atexit(dtor: unsafe extern fn(*mut u8),\n                        arg: *mut u8);\n     }\n-    _tlv_atexit(dtor, t);\n+\n+    let list: &mut List = &mut *DTORS.get();\n+    list.push((t, dtor));\n+\n+    unsafe extern fn run_dtors(_: *mut u8) {\n+        let mut ptr = DTORS.replace(ptr::null_mut());\n+        while !ptr.is_null() {\n+            let list = Box::from_raw(ptr);\n+            for (ptr, dtor) in list.into_iter() {\n+                dtor(ptr);\n+            }\n+            ptr = DTORS.replace(ptr::null_mut());\n+        }\n+    }\n }\n \n pub fn requires_move_before_drop() -> bool {\n-    // The macOS implementation of TLS apparently had an odd aspect to it\n-    // where the pointer we have may be overwritten while this destructor\n-    // is running. Specifically if a TLS destructor re-accesses TLS it may\n-    // trigger a re-initialization of all TLS variables, paving over at\n-    // least some destroyed ones with initial values.\n-    //\n-    // This means that if we drop a TLS value in place on macOS that we could\n-    // revert the value to its original state halfway through the\n-    // destructor, which would be bad!\n-    //\n-    // Hence, we use `ptr::read` on macOS (to move to a \"safe\" location)\n-    // instead of drop_in_place.\n-    cfg!(target_os = \"macos\")\n+    false\n }"}, {"sha": "5d2eb5f8e7320e09210a927efd3411ff3b0b9791", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d38d6be336e87055d90375c981806d5d133f446a/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d38d6be336e87055d90375c981806d5d133f446a/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=d38d6be336e87055d90375c981806d5d133f446a", "patch": "@@ -69,9 +69,6 @@ use mem;\n ///    destroyed, but not all platforms have this guard. Those platforms that do\n ///    not guard typically have a synthetic limit after which point no more\n ///    destructors are run.\n-/// 3. On macOS, initializing TLS during destruction of other TLS slots can\n-///    sometimes cancel *all* destructors for the current thread, whether or not\n-///    the slots have already had their destructors run or not.\n ///\n /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n /// [`thread_local!`]: ../../std/macro.thread_local.html\n@@ -604,11 +601,8 @@ mod tests {\n     }\n \n     // Note that this test will deadlock if TLS destructors aren't run (this\n-    // requires the destructor to be run to pass the test). macOS has a known bug\n-    // where dtors-in-dtors may cancel other destructors, so we just ignore this\n-    // test on macOS.\n+    // requires the destructor to be run to pass the test).\n     #[test]\n-    #[cfg_attr(target_os = \"macos\", ignore)]\n     fn dtors_in_dtors_in_dtors() {\n         struct S1(Sender<()>);\n         thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));"}]}