{"sha": "c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NGVlY2Y0ZDA5MDcwOTU5MjhmYjM2ZmQzYTFkZDVmYjJkOWZmMDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-21T11:05:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-21T11:05:03Z"}, "message": "Auto merge of #66994 - Centril:stmt-polish, r=estebank\n\nrefactor expr & stmt parsing + improve recovery\n\nSummary of important changes (best read commit-by-commit, ignoring whitespace changes):\n\n- `AttrVec` is introduces as an alias for `ThinVec<Attribute>`\n- `parse_expr_bottom` and `parse_stmt` are thoroughly refactored.\n- Extract diagnostics logic for `vec![...]` in a pattern context.\n- Recovery is added for `do catch { ... }`\n- Recovery is added for `'label: non_block_expr`\n- Recovery is added for `var $local`, `auto $local`, and `mut $local`. Fixes #65257.\n- Recovery is added for `e1 and e2` and `e1 or e2`.\n- ~~`macro_legacy_warnings` is turned into an error (has been a warning for 3 years!)~~\n- Fixes #63396 by forward-porting #64105 which now works thanks to added recovery.\n- `ui-fulldeps/ast_stmt_expr_attr.rs` is turned into UI and pretty tests.\n- Recovery is fixed for `#[attr] if expr {}`\n\nr? @estebank", "tree": {"sha": "073a8038727414aed13f54622fce43ca63990ca6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/073a8038727414aed13f54622fce43ca63990ca6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "html_url": "https://github.com/rust-lang/rust/commit/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ff30a7810c586819a78188c173a7b74adbb9730", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ff30a7810c586819a78188c173a7b74adbb9730", "html_url": "https://github.com/rust-lang/rust/commit/9ff30a7810c586819a78188c173a7b74adbb9730"}, {"sha": "621661f8a63f2118f3add5c3d686d9a2b6f62e5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/621661f8a63f2118f3add5c3d686d9a2b6f62e5e", "html_url": "https://github.com/rust-lang/rust/commit/621661f8a63f2118f3add5c3d686d9a2b6f62e5e"}], "stats": {"total": 2951, "additions": 1764, "deletions": 1187}, "files": [{"sha": "6b83788298e4d6a65b9bc4dee8cac189e51f1dee", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -53,7 +53,6 @@ use crate::util::nodemap::{DefIdMap, NodeMap};\n use errors::Applicability;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_index::vec::IndexVec;\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::sync::Lrc;\n \n use std::collections::BTreeMap;\n@@ -1205,7 +1204,7 @@ impl<'a> LoweringContext<'a> {\n                                 id: ty.id,\n                                 kind: ExprKind::Path(qself.clone(), path.clone()),\n                                 span: ty.span,\n-                                attrs: ThinVec::new(),\n+                                attrs: AttrVec::new(),\n                             };\n \n                             let ct = self.with_new_scopes(|this| {\n@@ -2751,7 +2750,7 @@ impl<'a> LoweringContext<'a> {\n     /// has no attributes and is not targeted by a `break`.\n     fn lower_block_expr(&mut self, b: &Block) -> hir::Expr {\n         let block = self.lower_block(b, false);\n-        self.expr_block(block, ThinVec::new())\n+        self.expr_block(block, AttrVec::new())\n     }\n \n     fn lower_pat(&mut self, p: &Pat) -> P<hir::Pat> {\n@@ -3102,7 +3101,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn stmt_let_pat(\n         &mut self,\n-        attrs: ThinVec<Attribute>,\n+        attrs: AttrVec,\n         span: Span,\n         init: Option<P<hir::Expr>>,\n         pat: P<hir::Pat>,"}, {"sha": "04031710dc5ea30e99285a573552af478390e936", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -1318,8 +1318,7 @@ impl LoweringContext<'_> {\n         &mut self,\n         span: Span,\n         expr: P<hir::Expr>,\n-        attrs: ThinVec<Attribute>\n-    ) -> hir::Expr {\n+        attrs: AttrVec) -> hir::Expr {\n         self.expr(span, hir::ExprKind::DropTemps(expr), attrs)\n     }\n \n@@ -1333,7 +1332,7 @@ impl LoweringContext<'_> {\n         self.expr(span, hir::ExprKind::Match(arg, arms, source), ThinVec::new())\n     }\n \n-    fn expr_break(&mut self, span: Span, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n+    fn expr_break(&mut self, span: Span, attrs: AttrVec) -> P<hir::Expr> {\n         let expr_break = hir::ExprKind::Break(self.lower_loop_destination(None), None);\n         P(self.expr(span, expr_break, attrs))\n     }\n@@ -1404,7 +1403,7 @@ impl LoweringContext<'_> {\n         span: Span,\n         components: &[Symbol],\n         params: Option<P<hir::GenericArgs>>,\n-        attrs: ThinVec<Attribute>,\n+        attrs: AttrVec,\n     ) -> hir::Expr {\n         let path = self.std_path(span, components, params, true);\n         self.expr(\n@@ -1423,7 +1422,7 @@ impl LoweringContext<'_> {\n         span: Span,\n         ident: Ident,\n         binding: hir::HirId,\n-        attrs: ThinVec<Attribute>,\n+        attrs: AttrVec,\n     ) -> hir::Expr {\n         let expr_path = hir::ExprKind::Path(hir::QPath::Resolved(\n             None,\n@@ -1459,16 +1458,11 @@ impl LoweringContext<'_> {\n         self.expr_block(P(blk), ThinVec::new())\n     }\n \n-    pub(super) fn expr_block(&mut self, b: P<hir::Block>, attrs: ThinVec<Attribute>) -> hir::Expr {\n+    pub(super) fn expr_block(&mut self, b: P<hir::Block>, attrs: AttrVec) -> hir::Expr {\n         self.expr(b.span, hir::ExprKind::Block(b, None), attrs)\n     }\n \n-    pub(super) fn expr(\n-        &mut self,\n-        span: Span,\n-        kind: hir::ExprKind,\n-        attrs: ThinVec<Attribute>\n-    ) -> hir::Expr {\n+    pub(super) fn expr(&mut self, span: Span, kind: hir::ExprKind, attrs: AttrVec) -> hir::Expr {\n         hir::Expr { hir_id: self.next_id(), kind, span, attrs }\n     }\n "}, {"sha": "6cae8e2cc04e19941d0fa0438334aea8badd690d", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -11,7 +11,6 @@ use crate::hir::def_id::DefId;\n use crate::hir::def::{Res, DefKind};\n use crate::util::nodemap::NodeMap;\n \n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_target::spec::abi;\n \n use std::collections::BTreeSet;\n@@ -899,7 +898,7 @@ impl LoweringContext<'_> {\n \n     /// Construct `ExprKind::Err` for the given `span`.\n     fn expr_err(&mut self, span: Span) -> hir::Expr {\n-        self.expr(span, hir::ExprKind::Err, ThinVec::new())\n+        self.expr(span, hir::ExprKind::Err, AttrVec::new())\n     }\n \n     fn lower_impl_item(&mut self, i: &AssocItem) -> hir::ImplItem {\n@@ -1182,7 +1181,7 @@ impl LoweringContext<'_> {\n                 //\n                 // If this is the simple case, this parameter will end up being the same as the\n                 // original parameter, but with a different pattern id.\n-                let mut stmt_attrs = ThinVec::new();\n+                let mut stmt_attrs = AttrVec::new();\n                 stmt_attrs.extend(parameter.attrs.iter().cloned());\n                 let (new_parameter_pat, new_parameter_id) = this.pat_ident(desugared_span, ident);\n                 let new_parameter = hir::Param {\n@@ -1226,7 +1225,7 @@ impl LoweringContext<'_> {\n                         desugared_span, ident, hir::BindingAnnotation::Mutable);\n                     let move_expr = this.expr_ident(desugared_span, ident, new_parameter_id);\n                     let move_stmt = this.stmt_let_pat(\n-                        ThinVec::new(),\n+                        AttrVec::new(),\n                         desugared_span,\n                         Some(P(move_expr)),\n                         move_pat,\n@@ -1271,7 +1270,7 @@ impl LoweringContext<'_> {\n                     let user_body = this.expr_drop_temps(\n                         desugared_span,\n                         P(user_body),\n-                        ThinVec::new(),\n+                        AttrVec::new(),\n                     );\n \n                     // As noted above, create the final block like\n@@ -1288,9 +1287,9 @@ impl LoweringContext<'_> {\n                         statements.into(),\n                         Some(P(user_body)),\n                     );\n-                    this.expr_block(P(body), ThinVec::new())\n+                    this.expr_block(P(body), AttrVec::new())\n                 });\n-            (HirVec::from(parameters), this.expr(body_span, async_expr, ThinVec::new()))\n+            (HirVec::from(parameters), this.expr(body_span, async_expr, AttrVec::new()))\n         })\n     }\n "}, {"sha": "368269ff200819771777b858bdb83b4e41a91f92", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -20,7 +20,7 @@ use errors::FatalError;\n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use syntax::source_map::Spanned;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n-use syntax::ast::{Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n+use syntax::ast::{AttrVec, Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n pub use syntax::ast::{Mutability, Constness, Unsafety, Movability, CaptureBy};\n pub use syntax::ast::{IsAuto, ImplPolarity, BorrowKind};\n use syntax::attr::{InlineAttr, OptimizeAttr};\n@@ -29,7 +29,6 @@ use syntax::tokenstream::TokenStream;\n use syntax::util::parser::ExprPrecedence;\n use rustc_target::spec::abi::Abi;\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_macros::HashStable;\n use rustc_serialize::{self, Encoder, Encodable, Decoder, Decodable};\n use std::collections::{BTreeSet, BTreeMap};\n@@ -1274,7 +1273,7 @@ pub struct Local {\n     pub init: Option<P<Expr>>,\n     pub hir_id: HirId,\n     pub span: Span,\n-    pub attrs: ThinVec<Attribute>,\n+    pub attrs: AttrVec,\n     /// Can be `ForLoopDesugar` if the `let` statement is part of a `for` loop\n     /// desugaring. Otherwise will be `Normal`.\n     pub source: LocalSource,\n@@ -1459,7 +1458,7 @@ pub struct AnonConst {\n pub struct Expr {\n     pub hir_id: HirId,\n     pub kind: ExprKind,\n-    pub attrs: ThinVec<Attribute>,\n+    pub attrs: AttrVec,\n     pub span: Span,\n }\n "}, {"sha": "a8800082c9a734d7d4957fbbed80e2306a6431e4", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -10,7 +10,6 @@ use rustc_data_structures::jobserver;\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_errors::registry::Registry;\n use rustc_metadata::dynamic_lib::DynamicLibrary;\n@@ -24,7 +23,7 @@ use std::ops::DerefMut;\n use smallvec::SmallVec;\n use syntax::ptr::P;\n use syntax::mut_visit::{*, MutVisitor, visit_clobber};\n-use syntax::ast::BlockCheckMode;\n+use syntax::ast::{AttrVec, BlockCheckMode};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::source_map::{FileLoader, RealFileLoader, SourceMap};\n use syntax::symbol::{Symbol, sym};\n@@ -741,7 +740,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a, '_> {\n                 id: resolver.next_node_id(),\n                 kind: ast::ExprKind::Block(P(b), None),\n                 span: syntax_pos::DUMMY_SP,\n-                attrs: ThinVec::new(),\n+                attrs: AttrVec::new(),\n             });\n \n             ast::Stmt {\n@@ -756,7 +755,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a, '_> {\n             kind: ast::ExprKind::Loop(P(empty_block), None),\n             id: self.resolver.next_node_id(),\n             span: syntax_pos::DUMMY_SP,\n-                attrs: ThinVec::new(),\n+                attrs: AttrVec::new(),\n         });\n \n         let loop_stmt = ast::Stmt {"}, {"sha": "3de7f888724b4b45c044d13835d6773be4154842", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -2,6 +2,7 @@\n \n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n+#![feature(slice_patterns)]\n \n use syntax::ast;\n use syntax::print::pprust;"}, {"sha": "51310fb88f65a86f997a66e6af553c421f80d239", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -1,4 +1,4 @@\n-use super::{SeqSep, Parser, TokenType, PathStyle};\n+use super::{Parser, TokenType, PathStyle};\n use rustc_errors::PResult;\n use syntax::attr;\n use syntax::ast;\n@@ -301,8 +301,10 @@ impl<'a> Parser<'a> {\n     crate fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {\n         Ok(if self.eat(&token::Eq) {\n             ast::MetaItemKind::NameValue(self.parse_unsuffixed_lit()?)\n-        } else if self.eat(&token::OpenDelim(token::Paren)) {\n-            ast::MetaItemKind::List(self.parse_meta_seq()?)\n+        } else if self.check(&token::OpenDelim(token::Paren)) {\n+            // Matches `meta_seq = ( COMMASEP(meta_item_inner) )`.\n+            let (list, _) = self.parse_paren_comma_seq(|p| p.parse_meta_item_inner())?;\n+            ast::MetaItemKind::List(list)\n         } else {\n             ast::MetaItemKind::Word\n         })\n@@ -311,28 +313,17 @@ impl<'a> Parser<'a> {\n     /// Matches `meta_item_inner : (meta_item | UNSUFFIXED_LIT) ;`.\n     fn parse_meta_item_inner(&mut self) -> PResult<'a, ast::NestedMetaItem> {\n         match self.parse_unsuffixed_lit() {\n-            Ok(lit) => {\n-                return Ok(ast::NestedMetaItem::Literal(lit))\n-            }\n+            Ok(lit) => return Ok(ast::NestedMetaItem::Literal(lit)),\n             Err(ref mut err) => err.cancel(),\n         }\n \n         match self.parse_meta_item() {\n-            Ok(mi) => {\n-                return Ok(ast::NestedMetaItem::MetaItem(mi))\n-            }\n+            Ok(mi) => return Ok(ast::NestedMetaItem::MetaItem(mi)),\n             Err(ref mut err) => err.cancel(),\n         }\n \n         let found = self.this_token_to_string();\n         let msg = format!(\"expected unsuffixed literal or identifier, found `{}`\", found);\n         Err(self.diagnostic().struct_span_err(self.token.span, &msg))\n     }\n-\n-    /// Matches `meta_seq = ( COMMASEP(meta_item_inner) )`.\n-    fn parse_meta_seq(&mut self) -> PResult<'a, Vec<ast::NestedMetaItem>> {\n-        self.parse_seq_to_end(&token::CloseDelim(token::Paren),\n-                              SeqSep::trailing_allowed(token::Comma),\n-                              |p: &mut Parser<'a>| p.parse_meta_item_inner())\n-    }\n }"}, {"sha": "16daefd1450ab70f34dd1c651e352f0d9b4177e6", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -4,14 +4,13 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{self, PResult, Applicability, DiagnosticBuilder, Handler, pluralize};\n use rustc_error_codes::*;\n use syntax::ast::{self, Param, BinOpKind, BindingMode, BlockCheckMode, Expr, ExprKind, Ident, Item};\n-use syntax::ast::{ItemKind, Mutability, Pat, PatKind, PathSegment, QSelf, Ty, TyKind};\n+use syntax::ast::{ItemKind, Mutability, Pat, PatKind, PathSegment, QSelf, Ty, TyKind, AttrVec};\n use syntax::token::{self, TokenKind, token_can_begin_expr};\n use syntax::print::pprust;\n use syntax::ptr::P;\n-use syntax::ThinVec;\n use syntax::util::parser::AssocOp;\n use syntax::struct_span_err;\n-use syntax_pos::symbol::{kw, sym};\n+use syntax_pos::symbol::kw;\n use syntax_pos::{Span, DUMMY_SP, MultiSpan, SpanSnippetError};\n \n use log::{debug, trace};\n@@ -32,7 +31,7 @@ pub(super) fn dummy_arg(ident: Ident) -> Param {\n         id: ast::DUMMY_NODE_ID\n     };\n     Param {\n-        attrs: ThinVec::default(),\n+        attrs: AttrVec::default(),\n         id: ast::DUMMY_NODE_ID,\n         pat,\n         span: ident.span,\n@@ -164,7 +163,7 @@ impl RecoverQPath for Expr {\n         Self {\n             span: path.span,\n             kind: ExprKind::Path(qself, path),\n-            attrs: ThinVec::new(),\n+            attrs: AttrVec::new(),\n             id: ast::DUMMY_NODE_ID,\n         }\n     }\n@@ -312,22 +311,6 @@ impl<'a> Parser<'a> {\n         };\n         self.last_unexpected_token_span = Some(self.token.span);\n         let mut err = self.fatal(&msg_exp);\n-        if self.token.is_ident_named(sym::and) {\n-            err.span_suggestion_short(\n-                self.token.span,\n-                \"use `&&` instead of `and` for the boolean operator\",\n-                \"&&\".to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-        }\n-        if self.token.is_ident_named(sym::or) {\n-            err.span_suggestion_short(\n-                self.token.span,\n-                \"use `||` instead of `or` for the boolean operator\",\n-                \"||\".to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-        }\n         let sp = if self.token == token::Eof {\n             // This is EOF; don't want to point at the following char, but rather the last token.\n             self.prev_span\n@@ -567,7 +550,7 @@ impl<'a> Parser<'a> {\n         );\n \n         let mk_err_expr = |this: &Self, span| {\n-            Ok(Some(this.mk_expr(span, ExprKind::Err, ThinVec::new())))\n+            Ok(Some(this.mk_expr(span, ExprKind::Err, AttrVec::new())))\n         };\n \n         match lhs.kind {\n@@ -986,21 +969,32 @@ impl<'a> Parser<'a> {\n \n     /// Consumes alternative await syntaxes like `await!(<expr>)`, `await <expr>`,\n     /// `await? <expr>`, `await(<expr>)`, and `await { <expr> }`.\n-    pub(super) fn parse_incorrect_await_syntax(\n+    pub(super) fn recover_incorrect_await_syntax(\n         &mut self,\n         lo: Span,\n         await_sp: Span,\n-    ) -> PResult<'a, (Span, ExprKind)> {\n-        if self.token == token::Not {\n+        attrs: AttrVec,\n+    ) -> PResult<'a, P<Expr>> {\n+        let (hi, expr, is_question) = if self.token == token::Not {\n             // Handle `await!(<expr>)`.\n-            self.expect(&token::Not)?;\n-            self.expect(&token::OpenDelim(token::Paren))?;\n-            let expr = self.parse_expr()?;\n-            self.expect(&token::CloseDelim(token::Paren))?;\n-            let sp = self.error_on_incorrect_await(lo, self.prev_span, &expr, false);\n-            return Ok((sp, ExprKind::Await(expr)))\n-        }\n+            self.recover_await_macro()?\n+        } else {\n+            self.recover_await_prefix(await_sp)?\n+        };\n+        let sp = self.error_on_incorrect_await(lo, hi, &expr, is_question);\n+        let expr = self.mk_expr(lo.to(sp), ExprKind::Await(expr), attrs);\n+        self.maybe_recover_from_bad_qpath(expr, true)\n+    }\n+\n+    fn recover_await_macro(&mut self) -> PResult<'a, (Span, P<Expr>, bool)> {\n+        self.expect(&token::Not)?;\n+        self.expect(&token::OpenDelim(token::Paren))?;\n+        let expr = self.parse_expr()?;\n+        self.expect(&token::CloseDelim(token::Paren))?;\n+        Ok((self.prev_span, expr, false))\n+    }\n \n+    fn recover_await_prefix(&mut self, await_sp: Span) -> PResult<'a, (Span, P<Expr>, bool)> {\n         let is_question = self.eat(&token::Question); // Handle `await? <expr>`.\n         let expr = if self.token == token::OpenDelim(token::Brace) {\n             // Handle `await { <expr> }`.\n@@ -1010,16 +1004,15 @@ impl<'a> Parser<'a> {\n                 None,\n                 self.token.span,\n                 BlockCheckMode::Default,\n-                ThinVec::new(),\n+                AttrVec::new(),\n             )\n         } else {\n             self.parse_expr()\n         }.map_err(|mut err| {\n             err.span_label(await_sp, \"while parsing this incorrect await expression\");\n             err\n         })?;\n-        let sp = self.error_on_incorrect_await(lo, expr.span, &expr, is_question);\n-        Ok((sp, ExprKind::Await(expr)))\n+        Ok((expr.span, expr, is_question))\n     }\n \n     fn error_on_incorrect_await(&self, lo: Span, hi: Span, expr: &Expr, is_question: bool) -> Span {\n@@ -1132,7 +1125,7 @@ impl<'a> Parser<'a> {\n                 err.emit();\n                 // Recover from parse error, callers expect the closing delim to be consumed.\n                 self.consume_block(delim, ConsumeClosingDelim::Yes);\n-                self.mk_expr(lo.to(self.prev_span), ExprKind::Err, ThinVec::new())\n+                self.mk_expr(lo.to(self.prev_span), ExprKind::Err, AttrVec::new())\n             }\n         }\n     }"}, {"sha": "159c2121d36c8978f56ef610fdb0101bfd83337d", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 411, "deletions": 406, "changes": 817, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -4,11 +4,10 @@ use super::pat::{GateOr, PARAM_EXPECTED};\n use super::diagnostics::Error;\n use crate::maybe_recover_from_interpolated_ty_qpath;\n \n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::{PResult, Applicability};\n-use syntax::ast::{self, DUMMY_NODE_ID, Attribute, AttrStyle, Ident, CaptureBy, BlockCheckMode};\n-use syntax::ast::{Expr, ExprKind, RangeLimits, Label, Movability, IsAsync, Arm, Ty, TyKind};\n-use syntax::ast::{FunctionRetTy, Param, FnDecl, BinOpKind, BinOp, UnOp, Mac, AnonConst, Field, Lit};\n+use syntax::ast::{self, DUMMY_NODE_ID, AttrVec, AttrStyle, Ident, CaptureBy, Field, Lit};\n+use syntax::ast::{BlockCheckMode, Expr, ExprKind, RangeLimits, Label, Movability, IsAsync, Arm};\n+use syntax::ast::{Ty, TyKind, FunctionRetTy, Param, FnDecl, BinOpKind, BinOp, UnOp, Mac, AnonConst};\n use syntax::token::{self, Token, TokenKind};\n use syntax::print::pprust;\n use syntax::ptr::P;\n@@ -37,14 +36,14 @@ macro_rules! maybe_whole_expr {\n                     let path = path.clone();\n                     $p.bump();\n                     return Ok($p.mk_expr(\n-                        $p.token.span, ExprKind::Path(None, path), ThinVec::new()\n+                        $p.token.span, ExprKind::Path(None, path), AttrVec::new()\n                     ));\n                 }\n                 token::NtBlock(block) => {\n                     let block = block.clone();\n                     $p.bump();\n                     return Ok($p.mk_expr(\n-                        $p.token.span, ExprKind::Block(block, None), ThinVec::new()\n+                        $p.token.span, ExprKind::Block(block, None), AttrVec::new()\n                     ));\n                 }\n                 // N.B., `NtIdent(ident)` is normalized to `Ident` in `fn bump`.\n@@ -57,16 +56,16 @@ macro_rules! maybe_whole_expr {\n #[derive(Debug)]\n pub(super) enum LhsExpr {\n     NotYetParsed,\n-    AttributesParsed(ThinVec<Attribute>),\n+    AttributesParsed(AttrVec),\n     AlreadyParsed(P<Expr>),\n }\n \n-impl From<Option<ThinVec<Attribute>>> for LhsExpr {\n+impl From<Option<AttrVec>> for LhsExpr {\n     /// Converts `Some(attrs)` into `LhsExpr::AttributesParsed(attrs)`\n     /// and `None` into `LhsExpr::NotYetParsed`.\n     ///\n     /// This conversion does not allocate.\n-    fn from(o: Option<ThinVec<Attribute>>) -> Self {\n+    fn from(o: Option<AttrVec>) -> Self {\n         if let Some(attrs) = o {\n             LhsExpr::AttributesParsed(attrs)\n         } else {\n@@ -91,24 +90,29 @@ impl<'a> Parser<'a> {\n         self.parse_expr_res(Restrictions::empty(), None)\n     }\n \n+    fn parse_expr_catch_underscore(&mut self) -> PResult<'a, P<Expr>> {\n+        match self.parse_expr() {\n+            Ok(expr) => Ok(expr),\n+            Err(mut err) => match self.token.kind {\n+                token::Ident(name, false)\n+                if name == kw::Underscore && self.look_ahead(1, |t| {\n+                    t == &token::Comma\n+                }) => {\n+                    // Special-case handling of `foo(_, _, _)`\n+                    err.emit();\n+                    let sp = self.token.span;\n+                    self.bump();\n+                    Ok(self.mk_expr(sp, ExprKind::Err, AttrVec::new()))\n+                }\n+                _ => Err(err),\n+            },\n+        }\n+    }\n+\n+    /// Parses a sequence of expressions bounded by parentheses.\n     fn parse_paren_expr_seq(&mut self) -> PResult<'a, Vec<P<Expr>>> {\n         self.parse_paren_comma_seq(|p| {\n-            match p.parse_expr() {\n-                Ok(expr) => Ok(expr),\n-                Err(mut err) => match p.token.kind {\n-                    token::Ident(name, false)\n-                    if name == kw::Underscore && p.look_ahead(1, |t| {\n-                        t == &token::Comma\n-                    }) => {\n-                        // Special-case handling of `foo(_, _, _)`\n-                        err.emit();\n-                        let sp = p.token.span;\n-                        p.bump();\n-                        Ok(p.mk_expr(sp, ExprKind::Err, ThinVec::new()))\n-                    }\n-                    _ => Err(err),\n-                },\n-            }\n+            p.parse_expr_catch_underscore()\n         }).map(|(r, _)| r)\n     }\n \n@@ -117,7 +121,7 @@ impl<'a> Parser<'a> {\n     pub(super) fn parse_expr_res(\n         &mut self,\n         r: Restrictions,\n-        already_parsed_attrs: Option<ThinVec<Attribute>>\n+        already_parsed_attrs: Option<AttrVec>\n     ) -> PResult<'a, P<Expr>> {\n         self.with_res(r, |this| this.parse_assoc_expr(already_parsed_attrs))\n     }\n@@ -129,7 +133,7 @@ impl<'a> Parser<'a> {\n     #[inline]\n     fn parse_assoc_expr(\n         &mut self,\n-        already_parsed_attrs: Option<ThinVec<Attribute>>,\n+        already_parsed_attrs: Option<AttrVec>,\n     ) -> PResult<'a, P<Expr>> {\n         self.parse_assoc_expr_with(0, already_parsed_attrs.into())\n     }\n@@ -155,53 +159,13 @@ impl<'a> Parser<'a> {\n         };\n         let last_type_ascription_set = self.last_type_ascription.is_some();\n \n-        match (self.expr_is_complete(&lhs), AssocOp::from_token(&self.token)) {\n-            (true, None) => {\n-                self.last_type_ascription = None;\n-                // Semi-statement forms are odd. See https://github.com/rust-lang/rust/issues/29071\n-                return Ok(lhs);\n-            }\n-            (false, _) => {} // continue parsing the expression\n-            // An exhaustive check is done in the following block, but these are checked first\n-            // because they *are* ambiguous but also reasonable looking incorrect syntax, so we\n-            // want to keep their span info to improve diagnostics in these cases in a later stage.\n-            (true, Some(AssocOp::Multiply)) | // `{ 42 } *foo = bar;` or `{ 42 } * 3`\n-            (true, Some(AssocOp::Subtract)) | // `{ 42 } -5`\n-            (true, Some(AssocOp::LAnd)) | // `{ 42 } &&x` (#61475)\n-            (true, Some(AssocOp::Add)) // `{ 42 } + 42\n-            // If the next token is a keyword, then the tokens above *are* unambiguously incorrect:\n-            // `if x { a } else { b } && if y { c } else { d }`\n-            if !self.look_ahead(1, |t| t.is_reserved_ident()) => {\n-                self.last_type_ascription = None;\n-                // These cases are ambiguous and can't be identified in the parser alone\n-                let sp = self.sess.source_map().start_point(self.token.span);\n-                self.sess.ambiguous_block_expr_parse.borrow_mut().insert(sp, lhs.span);\n-                return Ok(lhs);\n-            }\n-            (true, Some(ref op)) if !op.can_continue_expr_unambiguously() => {\n-                self.last_type_ascription = None;\n-                return Ok(lhs);\n-            }\n-            (true, Some(_)) => {\n-                // We've found an expression that would be parsed as a statement, but the next\n-                // token implies this should be parsed as an expression.\n-                // For example: `if let Some(x) = x { x } else { 0 } / 2`\n-                let mut err = self.struct_span_err(self.token.span, &format!(\n-                    \"expected expression, found `{}`\",\n-                    pprust::token_to_string(&self.token),\n-                ));\n-                err.span_label(self.token.span, \"expected expression\");\n-                self.sess.expr_parentheses_needed(\n-                    &mut err,\n-                    lhs.span,\n-                    Some(pprust::expr_to_string(&lhs),\n-                ));\n-                err.emit();\n-            }\n+        if !self.should_continue_as_assoc_expr(&lhs) {\n+            self.last_type_ascription = None;\n+            return Ok(lhs);\n         }\n-        self.expected_tokens.push(TokenType::Operator);\n-        while let Some(op) = AssocOp::from_token(&self.token) {\n \n+        self.expected_tokens.push(TokenType::Operator);\n+        while let Some(op) = self.check_assoc_op() {\n             // Adjust the span for interpolated LHS to point to the `$lhs` token and not to what\n             // it refers to. Interpolated identifiers are unwrapped early and never show up here\n             // as `PrevTokenKind::Interpolated` so if LHS is a single identifier we always process\n@@ -272,7 +236,7 @@ impl<'a> Parser<'a> {\n                 };\n \n                 let r = self.mk_range(Some(lhs), rhs, limits)?;\n-                lhs = self.mk_expr(lhs_span.to(rhs_span), r, ThinVec::new());\n+                lhs = self.mk_expr(lhs_span.to(rhs_span), r, AttrVec::new());\n                 break\n             }\n \n@@ -306,9 +270,9 @@ impl<'a> Parser<'a> {\n                 AssocOp::Greater | AssocOp::GreaterEqual => {\n                     let ast_op = op.to_ast_binop().unwrap();\n                     let binary = self.mk_binary(source_map::respan(cur_op_span, ast_op), lhs, rhs);\n-                    self.mk_expr(span, binary, ThinVec::new())\n+                    self.mk_expr(span, binary, AttrVec::new())\n                 }\n-                AssocOp::Assign => self.mk_expr(span, ExprKind::Assign(lhs, rhs), ThinVec::new()),\n+                AssocOp::Assign => self.mk_expr(span, ExprKind::Assign(lhs, rhs), AttrVec::new()),\n                 AssocOp::AssignOp(k) => {\n                     let aop = match k {\n                         token::Plus =>    BinOpKind::Add,\n@@ -323,7 +287,7 @@ impl<'a> Parser<'a> {\n                         token::Shr =>     BinOpKind::Shr,\n                     };\n                     let aopexpr = self.mk_assign_op(source_map::respan(cur_op_span, aop), lhs, rhs);\n-                    self.mk_expr(span, aopexpr, ThinVec::new())\n+                    self.mk_expr(span, aopexpr, AttrVec::new())\n                 }\n                 AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotEq => {\n                     self.bug(\"AssocOp should have been handled by special case\")\n@@ -338,6 +302,80 @@ impl<'a> Parser<'a> {\n         Ok(lhs)\n     }\n \n+    fn should_continue_as_assoc_expr(&mut self, lhs: &Expr) -> bool {\n+        match (self.expr_is_complete(lhs), self.check_assoc_op()) {\n+            // Semi-statement forms are odd:\n+            // See https://github.com/rust-lang/rust/issues/29071\n+            (true, None) => false,\n+            (false, _) => true, // Continue parsing the expression.\n+            // An exhaustive check is done in the following block, but these are checked first\n+            // because they *are* ambiguous but also reasonable looking incorrect syntax, so we\n+            // want to keep their span info to improve diagnostics in these cases in a later stage.\n+            (true, Some(AssocOp::Multiply)) | // `{ 42 } *foo = bar;` or `{ 42 } * 3`\n+            (true, Some(AssocOp::Subtract)) | // `{ 42 } -5`\n+            (true, Some(AssocOp::LAnd)) | // `{ 42 } &&x` (#61475)\n+            (true, Some(AssocOp::Add)) // `{ 42 } + 42\n+            // If the next token is a keyword, then the tokens above *are* unambiguously incorrect:\n+            // `if x { a } else { b } && if y { c } else { d }`\n+            if !self.look_ahead(1, |t| t.is_reserved_ident()) => {\n+                // These cases are ambiguous and can't be identified in the parser alone.\n+                let sp = self.sess.source_map().start_point(self.token.span);\n+                self.sess.ambiguous_block_expr_parse.borrow_mut().insert(sp, lhs.span);\n+                false\n+            }\n+            (true, Some(ref op)) if !op.can_continue_expr_unambiguously() => false,\n+            (true, Some(_)) => {\n+                self.error_found_expr_would_be_stmt(lhs);\n+                true\n+            }\n+        }\n+    }\n+\n+    /// We've found an expression that would be parsed as a statement,\n+    /// but the next token implies this should be parsed as an expression.\n+    /// For example: `if let Some(x) = x { x } else { 0 } / 2`.\n+    fn error_found_expr_would_be_stmt(&self, lhs: &Expr) {\n+        let mut err = self.struct_span_err(self.token.span, &format!(\n+            \"expected expression, found `{}`\",\n+            pprust::token_to_string(&self.token),\n+        ));\n+        err.span_label(self.token.span, \"expected expression\");\n+        self.sess.expr_parentheses_needed(&mut err, lhs.span, Some(pprust::expr_to_string(&lhs)));\n+        err.emit();\n+    }\n+\n+    /// Possibly translate the current token to an associative operator.\n+    /// The method does not advance the current token.\n+    ///\n+    /// Also performs recovery for `and` / `or` which are mistaken for `&&` and `||` respectively.\n+    fn check_assoc_op(&self) -> Option<AssocOp> {\n+        match (AssocOp::from_token(&self.token), &self.token.kind) {\n+            (op @ Some(_), _) => op,\n+            (None, token::Ident(sym::and, false)) => {\n+                self.error_bad_logical_op(\"and\", \"&&\", \"conjunction\");\n+                Some(AssocOp::LAnd)\n+            }\n+            (None, token::Ident(sym::or, false)) => {\n+                self.error_bad_logical_op(\"or\", \"||\", \"disjunction\");\n+                Some(AssocOp::LOr)\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    /// Error on `and` and `or` suggesting `&&` and `||` respectively.\n+    fn error_bad_logical_op(&self, bad: &str, good: &str, english: &str) {\n+        self.struct_span_err(self.token.span, &format!(\"`{}` is not a logical operator\", bad))\n+            .span_suggestion_short(\n+                self.token.span,\n+                &format!(\"use `{}` to perform logical {}\", good, english),\n+                good.to_string(),\n+                Applicability::MachineApplicable,\n+            )\n+            .note(\"unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\")\n+            .emit();\n+    }\n+\n     /// Checks if this expression is a successfully parsed statement.\n     fn expr_is_complete(&self, e: &Expr) -> bool {\n         self.restrictions.contains(Restrictions::STMT_EXPR) &&\n@@ -359,7 +397,7 @@ impl<'a> Parser<'a> {\n     /// Parses prefix-forms of range notation: `..expr`, `..`, `..=expr`.\n     fn parse_prefix_range_expr(\n         &mut self,\n-        already_parsed_attrs: Option<ThinVec<Attribute>>\n+        already_parsed_attrs: Option<AttrVec>\n     ) -> PResult<'a, P<Expr>> {\n         // Check for deprecated `...` syntax.\n         if self.token == token::DotDotDot {\n@@ -396,10 +434,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a prefix-unary-operator expr.\n-    fn parse_prefix_expr(\n-        &mut self,\n-        already_parsed_attrs: Option<ThinVec<Attribute>>\n-    ) -> PResult<'a, P<Expr>> {\n+    fn parse_prefix_expr(&mut self, already_parsed_attrs: Option<AttrVec>) -> PResult<'a, P<Expr>> {\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n         let lo = self.token.span;\n         // Note: when adding new unary operators, don't forget to adjust TokenKind::can_begin_expr()\n@@ -510,7 +545,7 @@ impl<'a> Parser<'a> {\n                            expr_kind: fn(P<Expr>, P<Ty>) -> ExprKind)\n                            -> PResult<'a, P<Expr>> {\n         let mk_expr = |this: &mut Self, rhs: P<Ty>| {\n-            this.mk_expr(lhs_span.to(rhs.span), expr_kind(lhs, rhs), ThinVec::new())\n+            this.mk_expr(lhs_span.to(rhs.span), expr_kind(lhs, rhs), AttrVec::new())\n         };\n \n         // Save the state of the parser before parsing type normally, in case there is a\n@@ -611,7 +646,7 @@ impl<'a> Parser<'a> {\n     /// Parses `a.b` or `a(13)` or `a[4]` or just `a`.\n     fn parse_dot_or_call_expr(\n         &mut self,\n-        already_parsed_attrs: Option<ThinVec<Attribute>>,\n+        already_parsed_attrs: Option<AttrVec>,\n     ) -> PResult<'a, P<Expr>> {\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n \n@@ -624,7 +659,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         e0: P<Expr>,\n         lo: Span,\n-        mut attrs: ThinVec<Attribute>,\n+        mut attrs: AttrVec,\n     ) -> PResult<'a, P<Expr>> {\n         // Stitch the list of outer attributes onto the return value.\n         // A little bit ugly, but the best way given the current code\n@@ -633,27 +668,28 @@ impl<'a> Parser<'a> {\n             expr.map(|mut expr| {\n                 attrs.extend::<Vec<_>>(expr.attrs.into());\n                 expr.attrs = attrs;\n-                match expr.kind {\n-                    ExprKind::If(..) if !expr.attrs.is_empty() => {\n-                        // Just point to the first attribute in there...\n-                        let span = expr.attrs[0].span;\n-                        self.span_err(span, \"attributes are not yet allowed on `if` expressions\");\n-                    }\n-                    _ => {}\n-                }\n+                self.error_attr_on_if_expr(&expr);\n                 expr\n             })\n         )\n     }\n \n+    fn error_attr_on_if_expr(&self, expr: &Expr) {\n+        if let (ExprKind::If(..), [a0, ..]) = (&expr.kind, &*expr.attrs) {\n+            // Just point to the first attribute in there...\n+            self.struct_span_err(a0.span, \"attributes are not yet allowed on `if` expressions\")\n+                .emit();\n+        }\n+    }\n+\n     fn parse_dot_or_call_expr_with_(&mut self, e0: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n         let mut e = e0;\n         let mut hi;\n         loop {\n             // expr?\n             while self.eat(&token::Question) {\n                 let hi = self.prev_span;\n-                e = self.mk_expr(lo.to(hi), ExprKind::Try(e), ThinVec::new());\n+                e = self.mk_expr(lo.to(hi), ExprKind::Try(e), AttrVec::new());\n             }\n \n             // expr.f\n@@ -666,7 +702,7 @@ impl<'a> Parser<'a> {\n                         let span = self.token.span;\n                         self.bump();\n                         let field = ExprKind::Field(e, Ident::new(symbol, span));\n-                        e = self.mk_expr(lo.to(span), field, ThinVec::new());\n+                        e = self.mk_expr(lo.to(span), field, AttrVec::new());\n \n                         self.expect_no_suffix(span, \"a tuple index\", suffix);\n                     }\n@@ -715,7 +751,7 @@ impl<'a> Parser<'a> {\n                     let seq = self.parse_paren_expr_seq().map(|es| {\n                         let nd = self.mk_call(e, es);\n                         let hi = self.prev_span;\n-                        self.mk_expr(lo.to(hi), nd, ThinVec::new())\n+                        self.mk_expr(lo.to(hi), nd, AttrVec::new())\n                     });\n                     e = self.recover_seq_parse_error(token::Paren, lo, seq);\n                 }\n@@ -728,7 +764,7 @@ impl<'a> Parser<'a> {\n                     hi = self.token.span;\n                     self.expect(&token::CloseDelim(token::Bracket))?;\n                     let index = self.mk_index(e, ix);\n-                    e = self.mk_expr(lo.to(hi), index, ThinVec::new())\n+                    e = self.mk_expr(lo.to(hi), index, AttrVec::new())\n                 }\n                 _ => return Ok(e)\n             }\n@@ -752,7 +788,7 @@ impl<'a> Parser<'a> {\n                 args.insert(0, self_arg);\n \n                 let span = lo.to(self.prev_span);\n-                self.mk_expr(span, ExprKind::MethodCall(segment, args), ThinVec::new())\n+                self.mk_expr(span, ExprKind::MethodCall(segment, args), AttrVec::new())\n             }\n             _ => {\n                 // Field access `expr.f`\n@@ -762,7 +798,7 @@ impl<'a> Parser<'a> {\n                 }\n \n                 let span = lo.to(self.prev_span);\n-                self.mk_expr(span, ExprKind::Field(self_arg, segment.ident), ThinVec::new())\n+                self.mk_expr(span, ExprKind::Field(self_arg, segment.ident), AttrVec::new())\n             }\n         })\n     }\n@@ -781,305 +817,278 @@ impl<'a> Parser<'a> {\n         //\n         // Therefore, prevent sub-parser from parsing\n         // attributes by giving them a empty \"already-parsed\" list.\n-        let mut attrs = ThinVec::new();\n+        let attrs = AttrVec::new();\n \n+        // Note: when adding new syntax here, don't forget to adjust `TokenKind::can_begin_expr()`.\n         let lo = self.token.span;\n-        let mut hi = self.token.span;\n-\n-        let ex: ExprKind;\n-\n-        macro_rules! parse_lit {\n-            () => {\n-                match self.parse_opt_lit() {\n-                    Some(literal) => {\n-                        hi = self.prev_span;\n-                        ex = ExprKind::Lit(literal);\n-                    }\n-                    None => {\n-                        return Err(self.expected_expression_found());\n-                    }\n+        if let token::Literal(_) = self.token.kind {\n+            // This match arm is a special-case of the `_` match arm below and\n+            // could be removed without changing functionality, but it's faster\n+            // to have it here, especially for programs with large constants.\n+            self.parse_lit_expr(attrs)\n+        } else if self.check(&token::OpenDelim(token::Paren)) {\n+            self.parse_tuple_parens_expr(attrs)\n+        } else if self.check(&token::OpenDelim(token::Brace)) {\n+            self.parse_block_expr(None, lo, BlockCheckMode::Default, attrs)\n+        } else if self.check(&token::BinOp(token::Or)) || self.check(&token::OrOr) {\n+            self.parse_closure_expr(attrs)\n+        } else if self.check(&token::OpenDelim(token::Bracket)) {\n+            self.parse_array_or_repeat_expr(attrs)\n+        } else if self.eat_lt() {\n+            let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n+            Ok(self.mk_expr(lo.to(path.span), ExprKind::Path(Some(qself), path), attrs))\n+        } else if self.token.is_path_start() {\n+            self.parse_path_start_expr(attrs)\n+        } else if self.check_keyword(kw::Move) || self.check_keyword(kw::Static) {\n+            self.parse_closure_expr(attrs)\n+        } else if self.eat_keyword(kw::If) {\n+            self.parse_if_expr(attrs)\n+        } else if self.eat_keyword(kw::For) {\n+            self.parse_for_expr(None, self.prev_span, attrs)\n+        } else if self.eat_keyword(kw::While) {\n+            self.parse_while_expr(None, self.prev_span, attrs)\n+        } else if let Some(label) = self.eat_label() {\n+            self.parse_labeled_expr(label, attrs)\n+        } else if self.eat_keyword(kw::Loop) {\n+            self.parse_loop_expr(None, self.prev_span, attrs)\n+        } else if self.eat_keyword(kw::Continue) {\n+            let kind = ExprKind::Continue(self.eat_label());\n+            Ok(self.mk_expr(lo.to(self.prev_span), kind, attrs))\n+        } else if self.eat_keyword(kw::Match) {\n+            let match_sp = self.prev_span;\n+            self.parse_match_expr(attrs).map_err(|mut err| {\n+                err.span_label(match_sp, \"while parsing this match expression\");\n+                err\n+            })\n+        } else if self.eat_keyword(kw::Unsafe) {\n+            self.parse_block_expr(None, lo, BlockCheckMode::Unsafe(ast::UserProvided), attrs)\n+        } else if self.is_do_catch_block() {\n+            self.recover_do_catch(attrs)\n+        } else if self.is_try_block() {\n+            self.expect_keyword(kw::Try)?;\n+            self.parse_try_block(lo, attrs)\n+        } else if self.eat_keyword(kw::Return) {\n+            self.parse_return_expr(attrs)\n+        } else if self.eat_keyword(kw::Break) {\n+            self.parse_break_expr(attrs)\n+        } else if self.eat_keyword(kw::Yield) {\n+            self.parse_yield_expr(attrs)\n+        } else if self.eat_keyword(kw::Let) {\n+            self.parse_let_expr(attrs)\n+        } else if !self.unclosed_delims.is_empty() && self.check(&token::Semi) {\n+            // Don't complain about bare semicolons after unclosed braces\n+            // recovery in order to keep the error count down. Fixing the\n+            // delimiters will possibly also fix the bare semicolon found in\n+            // expression context. For example, silence the following error:\n+            //\n+            //     error: expected expression, found `;`\n+            //      --> file.rs:2:13\n+            //       |\n+            //     2 |     foo(bar(;\n+            //       |             ^ expected expression\n+            self.bump();\n+            Ok(self.mk_expr_err(self.token.span))\n+        } else if self.token.span.rust_2018() {\n+            // `Span::rust_2018()` is somewhat expensive; don't get it repeatedly.\n+            if self.check_keyword(kw::Async) {\n+                if self.is_async_block() { // Check for `async {` and `async move {`.\n+                    self.parse_async_block(attrs)\n+                } else {\n+                    self.parse_closure_expr(attrs)\n                 }\n+            } else if self.eat_keyword(kw::Await) {\n+                self.recover_incorrect_await_syntax(lo, self.prev_span, attrs)\n+            } else {\n+                self.parse_lit_expr(attrs)\n             }\n+        } else {\n+            self.parse_lit_expr(attrs)\n         }\n+    }\n \n-        // Note: when adding new syntax here, don't forget to adjust `TokenKind::can_begin_expr()`.\n-        match self.token.kind {\n-            // This match arm is a special-case of the `_` match arm below and\n-            // could be removed without changing functionality, but it's faster\n-            // to have it here, especially for programs with large constants.\n-            token::Literal(_) => {\n-                parse_lit!()\n+    fn parse_lit_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+        let lo = self.token.span;\n+        match self.parse_opt_lit() {\n+            Some(literal) => {\n+                let expr = self.mk_expr(lo.to(self.prev_span), ExprKind::Lit(literal), attrs);\n+                self.maybe_recover_from_bad_qpath(expr, true)\n             }\n-            token::OpenDelim(token::Paren) => {\n-                self.bump();\n+            None => return Err(self.expected_expression_found()),\n+        }\n+    }\n \n-                attrs.extend(self.parse_inner_attributes()?);\n-\n-                // `(e)` is parenthesized `e`.\n-                // `(e,)` is a tuple with only one field, `e`.\n-                let mut es = vec![];\n-                let mut trailing_comma = false;\n-                let mut recovered = false;\n-                while self.token != token::CloseDelim(token::Paren) {\n-                    es.push(match self.parse_expr() {\n-                        Ok(es) => es,\n-                        Err(mut err) => {\n-                            // Recover from parse error in tuple list.\n-                            match self.token.kind {\n-                                token::Ident(name, false)\n-                                if name == kw::Underscore && self.look_ahead(1, |t| {\n-                                    t == &token::Comma\n-                                }) => {\n-                                    // Special-case handling of `Foo<(_, _, _)>`\n-                                    err.emit();\n-                                    let sp = self.token.span;\n-                                    self.bump();\n-                                    self.mk_expr(sp, ExprKind::Err, ThinVec::new())\n-                                }\n-                                _ => return Ok(\n-                                    self.recover_seq_parse_error(token::Paren, lo, Err(err)),\n-                                ),\n-                            }\n-                        }\n-                    });\n-                    recovered = self.expect_one_of(\n-                        &[],\n-                        &[token::Comma, token::CloseDelim(token::Paren)],\n-                    )?;\n-                    if self.eat(&token::Comma) {\n-                        trailing_comma = true;\n-                    } else {\n-                        trailing_comma = false;\n-                        break;\n-                    }\n-                }\n-                if !recovered {\n-                    self.bump();\n-                }\n+    fn parse_tuple_parens_expr(&mut self, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+        let lo = self.token.span;\n+        self.expect(&token::OpenDelim(token::Paren))?;\n+        attrs.extend(self.parse_inner_attributes()?); // `(#![foo] a, b, ...)` is OK.\n+        let (es, trailing_comma) = match self.parse_seq_to_end(\n+            &token::CloseDelim(token::Paren),\n+            SeqSep::trailing_allowed(token::Comma),\n+            |p| p.parse_expr_catch_underscore(),\n+        ) {\n+            Ok(x) => x,\n+            Err(err) => return Ok(self.recover_seq_parse_error(token::Paren, lo, Err(err))),\n+        };\n+        let kind = if es.len() == 1 && !trailing_comma {\n+            // `(e)` is parenthesized `e`.\n+            ExprKind::Paren(es.into_iter().nth(0).unwrap())\n+        } else {\n+            // `(e,)` is a tuple with only one field, `e`.\n+            ExprKind::Tup(es)\n+        };\n+        let expr = self.mk_expr(lo.to(self.prev_span), kind, attrs);\n+        self.maybe_recover_from_bad_qpath(expr, true)\n+    }\n \n-                hi = self.prev_span;\n-                ex = if es.len() == 1 && !trailing_comma {\n-                    ExprKind::Paren(es.into_iter().nth(0).unwrap())\n-                } else {\n-                    ExprKind::Tup(es)\n+    fn parse_array_or_repeat_expr(&mut self, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+        let lo = self.token.span;\n+        self.bump(); // `[`\n+\n+        attrs.extend(self.parse_inner_attributes()?);\n+\n+        let close = &token::CloseDelim(token::Bracket);\n+        let kind = if self.eat(close) {\n+            // Empty vector\n+            ExprKind::Array(Vec::new())\n+        } else {\n+            // Non-empty vector\n+            let first_expr = self.parse_expr()?;\n+            if self.eat(&token::Semi) {\n+                // Repeating array syntax: `[ 0; 512 ]`\n+                let count = AnonConst {\n+                    id: DUMMY_NODE_ID,\n+                    value: self.parse_expr()?,\n                 };\n+                self.expect(close)?;\n+                ExprKind::Repeat(first_expr, count)\n+            } else if self.eat(&token::Comma) {\n+                // Vector with two or more elements.\n+                let sep = SeqSep::trailing_allowed(token::Comma);\n+                let (remaining_exprs, _) = self.parse_seq_to_end(close, sep, |p| p.parse_expr())?;\n+                let mut exprs = vec![first_expr];\n+                exprs.extend(remaining_exprs);\n+                ExprKind::Array(exprs)\n+            } else {\n+                // Vector with one element\n+                self.expect(close)?;\n+                ExprKind::Array(vec![first_expr])\n             }\n-            token::OpenDelim(token::Brace) => {\n-                return self.parse_block_expr(None, lo, BlockCheckMode::Default, attrs);\n-            }\n-            token::BinOp(token::Or) | token::OrOr => {\n-                return self.parse_closure_expr(attrs);\n+        };\n+        let expr = self.mk_expr(lo.to(self.prev_span), kind, attrs);\n+        self.maybe_recover_from_bad_qpath(expr, true)\n+    }\n+\n+    fn parse_path_start_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+        let lo = self.token.span;\n+        let path = self.parse_path(PathStyle::Expr)?;\n+\n+        // `!`, as an operator, is prefix, so we know this isn't that.\n+        let (hi, kind) = if self.eat(&token::Not) {\n+            // MACRO INVOCATION expression\n+            let mac = Mac {\n+                path,\n+                args: self.parse_mac_args()?,\n+                prior_type_ascription: self.last_type_ascription,\n+            };\n+            (self.prev_span, ExprKind::Mac(mac))\n+        } else if self.check(&token::OpenDelim(token::Brace)) {\n+            if let Some(expr) = self.maybe_parse_struct_expr(lo, &path, &attrs) {\n+                return expr;\n+            } else {\n+                (path.span, ExprKind::Path(None, path))\n             }\n-            token::OpenDelim(token::Bracket) => {\n-                self.bump();\n+        } else {\n+            (path.span, ExprKind::Path(None, path))\n+        };\n \n-                attrs.extend(self.parse_inner_attributes()?);\n+        let expr = self.mk_expr(lo.to(hi), kind, attrs);\n+        self.maybe_recover_from_bad_qpath(expr, true)\n+    }\n \n-                if self.eat(&token::CloseDelim(token::Bracket)) {\n-                    // Empty vector\n-                    ex = ExprKind::Array(Vec::new());\n-                } else {\n-                    // Non-empty vector\n-                    let first_expr = self.parse_expr()?;\n-                    if self.eat(&token::Semi) {\n-                        // Repeating array syntax: `[ 0; 512 ]`\n-                        let count = AnonConst {\n-                            id: DUMMY_NODE_ID,\n-                            value: self.parse_expr()?,\n-                        };\n-                        self.expect(&token::CloseDelim(token::Bracket))?;\n-                        ex = ExprKind::Repeat(first_expr, count);\n-                    } else if self.eat(&token::Comma) {\n-                        // Vector with two or more elements\n-                        let remaining_exprs = self.parse_seq_to_end(\n-                            &token::CloseDelim(token::Bracket),\n-                            SeqSep::trailing_allowed(token::Comma),\n-                            |p| Ok(p.parse_expr()?)\n-                        )?;\n-                        let mut exprs = vec![first_expr];\n-                        exprs.extend(remaining_exprs);\n-                        ex = ExprKind::Array(exprs);\n-                    } else {\n-                        // Vector with one element\n-                        self.expect(&token::CloseDelim(token::Bracket))?;\n-                        ex = ExprKind::Array(vec![first_expr]);\n-                    }\n-                }\n-                hi = self.prev_span;\n-            }\n-            _ => {\n-                if self.eat_lt() {\n-                    let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n-                    hi = path.span;\n-                    return Ok(self.mk_expr(lo.to(hi), ExprKind::Path(Some(qself), path), attrs));\n-                }\n-                if self.token.is_path_start() {\n-                    let path = self.parse_path(PathStyle::Expr)?;\n-\n-                    // `!`, as an operator, is prefix, so we know this isn't that.\n-                    if self.eat(&token::Not) {\n-                        // MACRO INVOCATION expression\n-                        let args = self.parse_mac_args()?;\n-                        hi = self.prev_span;\n-                        ex = ExprKind::Mac(Mac {\n-                            path,\n-                            args,\n-                            prior_type_ascription: self.last_type_ascription,\n-                        });\n-                    } else if self.check(&token::OpenDelim(token::Brace)) {\n-                        if let Some(expr) = self.maybe_parse_struct_expr(lo, &path, &attrs) {\n-                            return expr;\n-                        } else {\n-                            hi = path.span;\n-                            ex = ExprKind::Path(None, path);\n-                        }\n-                    } else {\n-                        hi = path.span;\n-                        ex = ExprKind::Path(None, path);\n-                    }\n+    fn parse_labeled_expr(&mut self, label: Label, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+        let lo = label.ident.span;\n+        self.expect(&token::Colon)?;\n+        if self.eat_keyword(kw::While) {\n+            return self.parse_while_expr(Some(label), lo, attrs)\n+        }\n+        if self.eat_keyword(kw::For) {\n+            return self.parse_for_expr(Some(label), lo, attrs)\n+        }\n+        if self.eat_keyword(kw::Loop) {\n+            return self.parse_loop_expr(Some(label), lo, attrs)\n+        }\n+        if self.token == token::OpenDelim(token::Brace) {\n+            return self.parse_block_expr(Some(label), lo, BlockCheckMode::Default, attrs);\n+        }\n \n-                    let expr = self.mk_expr(lo.to(hi), ex, attrs);\n-                    return self.maybe_recover_from_bad_qpath(expr, true);\n-                }\n-                if self.check_keyword(kw::Move) || self.check_keyword(kw::Static) {\n-                    return self.parse_closure_expr(attrs);\n-                }\n-                if self.eat_keyword(kw::If) {\n-                    return self.parse_if_expr(attrs);\n-                }\n-                if self.eat_keyword(kw::For) {\n-                    let lo = self.prev_span;\n-                    return self.parse_for_expr(None, lo, attrs);\n-                }\n-                if self.eat_keyword(kw::While) {\n-                    let lo = self.prev_span;\n-                    return self.parse_while_expr(None, lo, attrs);\n-                }\n-                if let Some(label) = self.eat_label() {\n-                    let lo = label.ident.span;\n-                    self.expect(&token::Colon)?;\n-                    if self.eat_keyword(kw::While) {\n-                        return self.parse_while_expr(Some(label), lo, attrs)\n-                    }\n-                    if self.eat_keyword(kw::For) {\n-                        return self.parse_for_expr(Some(label), lo, attrs)\n-                    }\n-                    if self.eat_keyword(kw::Loop) {\n-                        return self.parse_loop_expr(Some(label), lo, attrs)\n-                    }\n-                    if self.token == token::OpenDelim(token::Brace) {\n-                        return self.parse_block_expr(Some(label),\n-                                                     lo,\n-                                                     BlockCheckMode::Default,\n-                                                     attrs);\n-                    }\n-                    let msg = \"expected `while`, `for`, `loop` or `{` after a label\";\n-                    let mut err = self.fatal(msg);\n-                    err.span_label(self.token.span, msg);\n-                    return Err(err);\n-                }\n-                if self.eat_keyword(kw::Loop) {\n-                    let lo = self.prev_span;\n-                    return self.parse_loop_expr(None, lo, attrs);\n-                }\n-                if self.eat_keyword(kw::Continue) {\n-                    let label = self.eat_label();\n-                    let ex = ExprKind::Continue(label);\n-                    let hi = self.prev_span;\n-                    return Ok(self.mk_expr(lo.to(hi), ex, attrs));\n-                }\n-                if self.eat_keyword(kw::Match) {\n-                    let match_sp = self.prev_span;\n-                    return self.parse_match_expr(attrs).map_err(|mut err| {\n-                        err.span_label(match_sp, \"while parsing this match expression\");\n-                        err\n-                    });\n-                }\n-                if self.eat_keyword(kw::Unsafe) {\n-                    return self.parse_block_expr(\n-                        None,\n-                        lo,\n-                        BlockCheckMode::Unsafe(ast::UserProvided),\n-                        attrs);\n-                }\n-                if self.is_do_catch_block() {\n-                    let mut db = self.fatal(\"found removed `do catch` syntax\");\n-                    db.help(\"following RFC #2388, the new non-placeholder syntax is `try`\");\n-                    return Err(db);\n-                }\n-                if self.is_try_block() {\n-                    let lo = self.token.span;\n-                    assert!(self.eat_keyword(kw::Try));\n-                    return self.parse_try_block(lo, attrs);\n-                }\n+        let msg = \"expected `while`, `for`, `loop` or `{` after a label\";\n+        self.struct_span_err(self.token.span, msg)\n+            .span_label(self.token.span, msg)\n+            .emit();\n+        // Continue as an expression in an effort to recover on `'label: non_block_expr`.\n+        self.parse_expr()\n+    }\n \n-                // `Span::rust_2018()` is somewhat expensive; don't get it repeatedly.\n-                let is_span_rust_2018 = self.token.span.rust_2018();\n-                if is_span_rust_2018 && self.check_keyword(kw::Async) {\n-                    return if self.is_async_block() { // Check for `async {` and `async move {`.\n-                        self.parse_async_block(attrs)\n-                    } else {\n-                        self.parse_closure_expr(attrs)\n-                    };\n-                }\n-                if self.eat_keyword(kw::Return) {\n-                    if self.token.can_begin_expr() {\n-                        let e = self.parse_expr()?;\n-                        hi = e.span;\n-                        ex = ExprKind::Ret(Some(e));\n-                    } else {\n-                        ex = ExprKind::Ret(None);\n-                    }\n-                } else if self.eat_keyword(kw::Break) {\n-                    let label = self.eat_label();\n-                    let e = if self.token.can_begin_expr()\n-                               && !(self.token == token::OpenDelim(token::Brace)\n-                                    && self.restrictions.contains(\n-                                           Restrictions::NO_STRUCT_LITERAL)) {\n-                        Some(self.parse_expr()?)\n-                    } else {\n-                        None\n-                    };\n-                    ex = ExprKind::Break(label, e);\n-                    hi = self.prev_span;\n-                } else if self.eat_keyword(kw::Yield) {\n-                    if self.token.can_begin_expr() {\n-                        let e = self.parse_expr()?;\n-                        hi = e.span;\n-                        ex = ExprKind::Yield(Some(e));\n-                    } else {\n-                        ex = ExprKind::Yield(None);\n-                    }\n+    /// Recover on the syntax `do catch { ... }` suggesting `try { ... }` instead.\n+    fn recover_do_catch(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+        let lo = self.token.span;\n \n-                    let span = lo.to(hi);\n-                    self.sess.gated_spans.gate(sym::generators, span);\n-                } else if self.eat_keyword(kw::Let) {\n-                    return self.parse_let_expr(attrs);\n-                } else if is_span_rust_2018 && self.eat_keyword(kw::Await) {\n-                    let (await_hi, e_kind) = self.parse_incorrect_await_syntax(lo, self.prev_span)?;\n-                    hi = await_hi;\n-                    ex = e_kind;\n-                } else {\n-                    if !self.unclosed_delims.is_empty() && self.check(&token::Semi) {\n-                        // Don't complain about bare semicolons after unclosed braces\n-                        // recovery in order to keep the error count down. Fixing the\n-                        // delimiters will possibly also fix the bare semicolon found in\n-                        // expression context. For example, silence the following error:\n-                        //\n-                        //     error: expected expression, found `;`\n-                        //      --> file.rs:2:13\n-                        //       |\n-                        //     2 |     foo(bar(;\n-                        //       |             ^ expected expression\n-                        self.bump();\n-                        return Ok(self.mk_expr(self.token.span, ExprKind::Err, ThinVec::new()));\n-                    }\n-                    parse_lit!()\n-                }\n-            }\n-        }\n+        self.bump(); // `do`\n+        self.bump(); // `catch`\n+\n+        let span_dc = lo.to(self.prev_span);\n+        self.struct_span_err(span_dc, \"found removed `do catch` syntax\")\n+            .span_suggestion(\n+                span_dc,\n+                \"replace with the new syntax\",\n+                \"try\".to_string(),\n+                Applicability::MachineApplicable,\n+            )\n+            .note(\"following RFC #2388, the new non-placeholder syntax is `try`\")\n+            .emit();\n \n-        let expr = self.mk_expr(lo.to(hi), ex, attrs);\n+        self.parse_try_block(lo, attrs)\n+    }\n+\n+    /// Parse an expression if the token can begin one.\n+    fn parse_expr_opt(&mut self) -> PResult<'a, Option<P<Expr>>> {\n+        Ok(if self.token.can_begin_expr() {\n+            Some(self.parse_expr()?)\n+        } else {\n+            None\n+        })\n+    }\n+\n+    /// Parse `\"return\" expr?`.\n+    fn parse_return_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+        let lo = self.prev_span;\n+        let kind = ExprKind::Ret(self.parse_expr_opt()?);\n+        let expr = self.mk_expr(lo.to(self.prev_span), kind, attrs);\n+        self.maybe_recover_from_bad_qpath(expr, true)\n+    }\n+\n+    /// Parse `\"('label \":\")? break expr?`.\n+    fn parse_break_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+        let lo = self.prev_span;\n+        let label = self.eat_label();\n+        let kind = if self.token != token::OpenDelim(token::Brace)\n+            || !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n+        {\n+            self.parse_expr_opt()?\n+        } else {\n+            None\n+        };\n+        let expr = self.mk_expr(lo.to(self.prev_span), ExprKind::Break(label, kind), attrs);\n+        self.maybe_recover_from_bad_qpath(expr, true)\n+    }\n+\n+    /// Parse `\"yield\" expr?`.\n+    fn parse_yield_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+        let lo = self.prev_span;\n+        let kind = ExprKind::Yield(self.parse_expr_opt()?);\n+        let span = lo.to(self.prev_span);\n+        self.sess.gated_spans.gate(sym::generators, span);\n+        let expr = self.mk_expr(span, kind, attrs);\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n@@ -1282,12 +1291,12 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         let literal = self.parse_lit()?;\n         let hi = self.prev_span;\n-        let expr = self.mk_expr(lo.to(hi), ExprKind::Lit(literal), ThinVec::new());\n+        let expr = self.mk_expr(lo.to(hi), ExprKind::Lit(literal), AttrVec::new());\n \n         if minus_present {\n             let minus_hi = self.prev_span;\n             let unary = self.mk_unary(UnOp::Neg, expr);\n-            Ok(self.mk_expr(minus_lo.to(minus_hi), unary, ThinVec::new()))\n+            Ok(self.mk_expr(minus_lo.to(minus_hi), unary, AttrVec::new()))\n         } else {\n             Ok(expr)\n         }\n@@ -1299,7 +1308,7 @@ impl<'a> Parser<'a> {\n         opt_label: Option<Label>,\n         lo: Span,\n         blk_mode: BlockCheckMode,\n-        outer_attrs: ThinVec<Attribute>,\n+        outer_attrs: AttrVec,\n     ) -> PResult<'a, P<Expr>> {\n         if let Some(label) = opt_label {\n             self.sess.gated_spans.gate(sym::label_break_value, label.ident.span);\n@@ -1315,7 +1324,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a closure expression (e.g., `move |args| expr`).\n-    fn parse_closure_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn parse_closure_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n \n         let movability = if self.eat_keyword(kw::Static) {\n@@ -1345,7 +1354,7 @@ impl<'a> Parser<'a> {\n             _ => {\n                 // If an explicit return type is given, require a block to appear (RFC 968).\n                 let body_lo = self.token.span;\n-                self.parse_block_expr(None, body_lo, BlockCheckMode::Default, ThinVec::new())?\n+                self.parse_block_expr(None, body_lo, BlockCheckMode::Default, AttrVec::new())?\n             }\n         };\n \n@@ -1415,7 +1424,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses an `if` expression (`if` token already eaten).\n-    fn parse_if_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn parse_if_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_span;\n         let cond = self.parse_cond_expr()?;\n \n@@ -1461,7 +1470,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses a `let $pat = $expr` pseudo-expression.\n     /// The `let` token has already been eaten.\n-    fn parse_let_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn parse_let_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_span;\n         let pat = self.parse_top_pat(GateOr::No)?;\n         self.expect(&token::Eq)?;\n@@ -1477,10 +1486,10 @@ impl<'a> Parser<'a> {\n     /// Parses an `else { ... }` expression (`else` token already eaten).\n     fn parse_else_expr(&mut self) -> PResult<'a, P<Expr>> {\n         if self.eat_keyword(kw::If) {\n-            return self.parse_if_expr(ThinVec::new());\n+            return self.parse_if_expr(AttrVec::new());\n         } else {\n             let blk = self.parse_block()?;\n-            return Ok(self.mk_expr(blk.span, ExprKind::Block(blk, None), ThinVec::new()));\n+            return Ok(self.mk_expr(blk.span, ExprKind::Block(blk, None), AttrVec::new()));\n         }\n     }\n \n@@ -1489,7 +1498,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         opt_label: Option<Label>,\n         span_lo: Span,\n-        mut attrs: ThinVec<Attribute>\n+        mut attrs: AttrVec\n     ) -> PResult<'a, P<Expr>> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n@@ -1531,7 +1540,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         opt_label: Option<Label>,\n         span_lo: Span,\n-        mut attrs: ThinVec<Attribute>\n+        mut attrs: AttrVec\n     ) -> PResult<'a, P<Expr>> {\n         let cond = self.parse_cond_expr()?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n@@ -1545,7 +1554,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         opt_label: Option<Label>,\n         span_lo: Span,\n-        mut attrs: ThinVec<Attribute>\n+        mut attrs: AttrVec\n     ) -> PResult<'a, P<Expr>> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n@@ -1564,7 +1573,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `match ... { ... }` expression (`match` token already eaten).\n-    fn parse_match_expr(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn parse_match_expr(&mut self, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let match_span = self.prev_span;\n         let lo = self.prev_span;\n         let discriminant = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n@@ -1676,11 +1685,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `try {...}` expression (`try` token already eaten).\n-    fn parse_try_block(\n-        &mut self,\n-        span_lo: Span,\n-        mut attrs: ThinVec<Attribute>\n-    ) -> PResult<'a, P<Expr>> {\n+    fn parse_try_block(&mut self, span_lo: Span, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         if self.eat_keyword(kw::Catch) {\n@@ -1712,7 +1717,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses an `async move? {...}` expression.\n-    fn parse_async_block(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn parse_async_block(&mut self, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let span_lo = self.token.span;\n         self.expect_keyword(kw::Async)?;\n         let capture_clause = self.parse_capture_clause();\n@@ -1739,7 +1744,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         lo: Span,\n         path: &ast::Path,\n-        attrs: &ThinVec<Attribute>,\n+        attrs: &AttrVec,\n     ) -> Option<PResult<'a, P<Expr>>> {\n         let struct_allowed = !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL);\n         let certainly_not_a_block = || self.look_ahead(1, |t| t.is_ident()) && (\n@@ -1780,7 +1785,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         lo: Span,\n         pth: ast::Path,\n-        mut attrs: ThinVec<Attribute>\n+        mut attrs: AttrVec\n     ) -> PResult<'a, P<Expr>> {\n         let struct_sp = lo.to(self.prev_span);\n         self.bump();\n@@ -1826,9 +1831,9 @@ impl<'a> Parser<'a> {\n                     recovery_field = Some(ast::Field {\n                         ident: Ident::new(name, self.token.span),\n                         span: self.token.span,\n-                        expr: self.mk_expr(self.token.span, ExprKind::Err, ThinVec::new()),\n+                        expr: self.mk_expr(self.token.span, ExprKind::Err, AttrVec::new()),\n                         is_shorthand: false,\n-                        attrs: ThinVec::new(),\n+                        attrs: AttrVec::new(),\n                         id: DUMMY_NODE_ID,\n                         is_placeholder: false,\n                     });\n@@ -1907,7 +1912,7 @@ impl<'a> Parser<'a> {\n \n             // Mimic `x: x` for the `x` field shorthand.\n             let path = ast::Path::from_ident(fieldname);\n-            let expr = self.mk_expr(fieldname.span, ExprKind::Path(None, path), ThinVec::new());\n+            let expr = self.mk_expr(fieldname.span, ExprKind::Path(None, path), AttrVec::new());\n             (fieldname, expr, true)\n         };\n         Ok(ast::Field {\n@@ -1984,16 +1989,16 @@ impl<'a> Parser<'a> {\n \n     fn mk_await_expr(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n         let span = lo.to(self.prev_span);\n-        let await_expr = self.mk_expr(span, ExprKind::Await(self_arg), ThinVec::new());\n+        let await_expr = self.mk_expr(span, ExprKind::Await(self_arg), AttrVec::new());\n         self.recover_from_await_method_call();\n         Ok(await_expr)\n     }\n \n-    crate fn mk_expr(&self, span: Span, kind: ExprKind, attrs: ThinVec<Attribute>) -> P<Expr> {\n+    crate fn mk_expr(&self, span: Span, kind: ExprKind, attrs: AttrVec) -> P<Expr> {\n         P(Expr { kind, span, attrs, id: DUMMY_NODE_ID })\n     }\n \n     pub(super) fn mk_expr_err(&self, span: Span) -> P<Expr> {\n-        self.mk_expr(span, ExprKind::Err, ThinVec::new())\n+        self.mk_expr(span, ExprKind::Err, AttrVec::new())\n     }\n }"}, {"sha": "229ca07f13b51a4063610e4249f36c257b7ec986", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -5,15 +5,14 @@ use crate::maybe_whole;\n \n use rustc_errors::{PResult, Applicability, DiagnosticBuilder, StashKey};\n use rustc_error_codes::*;\n-use syntax::ast::{self, DUMMY_NODE_ID, Ident, Attribute, AttrKind, AttrStyle, AnonConst, Item};\n-use syntax::ast::{AssocItem, AssocItemKind, ItemKind, UseTree, UseTreeKind};\n+use syntax::ast::{self, DUMMY_NODE_ID, Ident, AttrVec, Attribute, AttrKind, AttrStyle, AnonConst};\n+use syntax::ast::{AssocItem, AssocItemKind, Item, ItemKind, UseTree, UseTreeKind};\n use syntax::ast::{PathSegment, IsAuto, Constness, IsAsync, Unsafety, Defaultness, Extern, StrLit};\n use syntax::ast::{Visibility, VisibilityKind, Mutability, FnHeader, ForeignItem, ForeignItemKind};\n use syntax::ast::{Ty, TyKind, Generics, TraitRef, EnumDef, Variant, VariantData, StructField};\n use syntax::ast::{Mac, MacArgs, MacDelimiter, Block, BindingMode, FnDecl, FnSig, SelfKind, Param};\n use syntax::print::pprust;\n use syntax::ptr::P;\n-use syntax::ThinVec;\n use syntax::token;\n use syntax::tokenstream::{DelimSpan, TokenTree, TokenStream};\n use syntax::struct_span_err;\n@@ -2095,7 +2094,7 @@ impl<'a> Parser<'a> {\n         };\n \n         let eself = source_map::respan(eself_lo.to(eself_hi), eself);\n-        Ok(Some(Param::from_self(ThinVec::default(), eself, eself_ident)))\n+        Ok(Some(Param::from_self(AttrVec::default(), eself, eself_ident)))\n     }\n \n     fn is_named_param(&self) -> bool {"}, {"sha": "255e789b58ea92403bae2d5b8e7b728bc135bfb8", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 33, "deletions": 38, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -15,9 +15,8 @@ use crate::{Directory, DirectoryOwnership};\n use crate::lexer::UnmatchedBrace;\n \n use rustc_errors::{PResult, Applicability, DiagnosticBuilder, FatalError};\n-use rustc_data_structures::thin_vec::ThinVec;\n-use syntax::ast::{self, DUMMY_NODE_ID, AttrStyle, Attribute, CrateSugar, Extern, Ident, StrLit};\n-use syntax::ast::{IsAsync, MacArgs, MacDelimiter, Mutability, Visibility, VisibilityKind, Unsafety};\n+use syntax::ast::{self, DUMMY_NODE_ID, AttrVec, AttrStyle, CrateSugar, Extern, Ident, Unsafety};\n+use syntax::ast::{StrLit, IsAsync, MacArgs, MacDelimiter, Mutability, Visibility, VisibilityKind};\n use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::token::{self, Token, TokenKind, DelimToken};\n@@ -740,34 +739,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses a sequence, including the closing delimiter. The function\n-    /// `f` must consume tokens until reaching the next separator or\n-    /// closing bracket.\n-    fn parse_seq_to_end<T>(\n-        &mut self,\n-        ket: &TokenKind,\n-        sep: SeqSep,\n-        f: impl FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n-    ) -> PResult<'a, Vec<T>> {\n-        let (val, _, recovered) = self.parse_seq_to_before_end(ket, sep, f)?;\n-        if !recovered {\n-            self.bump();\n-        }\n-        Ok(val)\n-    }\n-\n-    /// Parses a sequence, not including the closing delimiter. The function\n-    /// `f` must consume tokens until reaching the next separator or\n-    /// closing bracket.\n-    fn parse_seq_to_before_end<T>(\n-        &mut self,\n-        ket: &TokenKind,\n-        sep: SeqSep,\n-        f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n-    ) -> PResult<'a, (Vec<T>, bool, bool)> {\n-        self.parse_seq_to_before_tokens(&[ket], sep, TokenExpectType::Expect, f)\n-    }\n-\n     fn expect_any_with_type(&mut self, kets: &[&TokenKind], expect: TokenExpectType) -> bool {\n         kets.iter().any(|k| {\n             match expect {\n@@ -855,6 +826,34 @@ impl<'a> Parser<'a> {\n         Ok((v, trailing, recovered))\n     }\n \n+    /// Parses a sequence, not including the closing delimiter. The function\n+    /// `f` must consume tokens until reaching the next separator or\n+    /// closing bracket.\n+    fn parse_seq_to_before_end<T>(\n+        &mut self,\n+        ket: &TokenKind,\n+        sep: SeqSep,\n+        f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n+    ) -> PResult<'a, (Vec<T>, bool, bool)> {\n+        self.parse_seq_to_before_tokens(&[ket], sep, TokenExpectType::Expect, f)\n+    }\n+\n+    /// Parses a sequence, including the closing delimiter. The function\n+    /// `f` must consume tokens until reaching the next separator or\n+    /// closing bracket.\n+    fn parse_seq_to_end<T>(\n+        &mut self,\n+        ket: &TokenKind,\n+        sep: SeqSep,\n+        f: impl FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n+    ) -> PResult<'a, (Vec<T>, bool /* trailing */)> {\n+        let (val, trailing, recovered) = self.parse_seq_to_before_end(ket, sep, f)?;\n+        if !recovered {\n+            self.eat(ket);\n+        }\n+        Ok((val, trailing))\n+    }\n+\n     /// Parses a sequence, including the closing delimiter. The function\n     /// `f` must consume tokens until reaching the next separator or\n     /// closing bracket.\n@@ -866,11 +865,7 @@ impl<'a> Parser<'a> {\n         f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n     ) -> PResult<'a, (Vec<T>, bool)> {\n         self.expect(bra)?;\n-        let (result, trailing, recovered) = self.parse_seq_to_before_end(ket, sep, f)?;\n-        if !recovered {\n-            self.eat(ket);\n-        }\n-        Ok((result, trailing))\n+        self.parse_seq_to_end(ket, sep, f)\n     }\n \n     fn parse_delim_comma_seq<T>(\n@@ -1054,8 +1049,8 @@ impl<'a> Parser<'a> {\n \n     fn parse_or_use_outer_attributes(\n         &mut self,\n-        already_parsed_attrs: Option<ThinVec<Attribute>>,\n-    ) -> PResult<'a, ThinVec<Attribute>> {\n+        already_parsed_attrs: Option<AttrVec>,\n+    ) -> PResult<'a, AttrVec> {\n         if let Some(attrs) = already_parsed_attrs {\n             Ok(attrs)\n         } else {"}, {"sha": "593fb30bb752a540d779eb523130e820d299f75f", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -1,12 +1,11 @@\n use super::{Parser, PathStyle};\n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n use rustc_errors::{PResult, Applicability, DiagnosticBuilder};\n-use syntax::ast::{self, Attribute, Pat, PatKind, FieldPat, RangeEnd, RangeSyntax, Mac};\n+use syntax::ast::{self, AttrVec, Attribute, Pat, PatKind, FieldPat, RangeEnd, RangeSyntax, Mac};\n use syntax::ast::{BindingMode, Ident, Mutability, Path, QSelf, Expr, ExprKind};\n use syntax::mut_visit::{noop_visit_pat, noop_visit_mac, MutVisitor};\n use syntax::ptr::P;\n use syntax::print::pprust;\n-use syntax::ThinVec;\n use syntax::token;\n use syntax_pos::source_map::{respan, Span, Spanned};\n use syntax_pos::symbol::{kw, sym};\n@@ -636,7 +635,7 @@ impl<'a> Parser<'a> {\n         let op_span = self.token.span;\n         // Parse range\n         let span = lo.to(self.prev_span);\n-        let begin = self.mk_expr(span, ExprKind::Path(qself, path), ThinVec::new());\n+        let begin = self.mk_expr(span, ExprKind::Path(qself, path), AttrVec::new());\n         self.bump();\n         let end = self.parse_pat_range_end_opt(&begin, form)?;\n         Ok(PatKind::Range(begin, end, respan(op_span, end_kind)))\n@@ -693,7 +692,7 @@ impl<'a> Parser<'a> {\n         let lo = self.prev_span;\n         let end = self.parse_pat_range_end()?;\n         let range_span = lo.to(end.span);\n-        let begin = self.mk_expr(range_span, ExprKind::Err, ThinVec::new());\n+        let begin = self.mk_expr(range_span, ExprKind::Err, AttrVec::new());\n \n         self.diagnostic()\n             .struct_span_err(range_span, &format!(\"`{}X` range patterns are not supported\", form))\n@@ -731,7 +730,7 @@ impl<'a> Parser<'a> {\n                 )\n                 .emit();\n \n-            Ok(self.mk_expr(range_span, ExprKind::Err, ThinVec::new()))\n+            Ok(self.mk_expr(range_span, ExprKind::Err, AttrVec::new()))\n         }\n     }\n \n@@ -747,7 +746,7 @@ impl<'a> Parser<'a> {\n                 (None, self.parse_path(PathStyle::Expr)?)\n             };\n             let hi = self.prev_span;\n-            Ok(self.mk_expr(lo.to(hi), ExprKind::Path(qself, path), ThinVec::new()))\n+            Ok(self.mk_expr(lo.to(hi), ExprKind::Path(qself, path), AttrVec::new()))\n         } else {\n             self.parse_literal_maybe_minus()\n         }"}, {"sha": "802d38e2997128b2b7dcd57ce2ad745d6ff20dd7", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -3,7 +3,6 @@ use crate::maybe_whole;\n use rustc_errors::{PResult, Applicability, pluralize};\n use syntax::ast::{self, QSelf, Path, PathSegment, Ident, ParenthesizedArgs, AngleBracketedArgs};\n use syntax::ast::{AnonConst, GenericArg, AssocTyConstraint, AssocTyConstraintKind, BlockCheckMode};\n-use syntax::ThinVec;\n use syntax::token::{self, Token};\n use syntax_pos::source_map::{Span, BytePos};\n use syntax_pos::symbol::{kw, sym};\n@@ -400,7 +399,7 @@ impl<'a> Parser<'a> {\n                 // Parse const argument.\n                 let expr = if let token::OpenDelim(token::Brace) = self.token.kind {\n                     self.parse_block_expr(\n-                        None, self.token.span, BlockCheckMode::Default, ThinVec::new()\n+                        None, self.token.span, BlockCheckMode::Default, ast::AttrVec::new()\n                     )?\n                 } else if self.token.is_ident() {\n                     // FIXME(const_generics): to distinguish between idents for types and consts,"}, {"sha": "42d85e96aef57cbd046bed15a0858ed2cea0335e", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 229, "deletions": 219, "changes": 448, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -7,31 +7,26 @@ use crate::maybe_whole;\n use crate::DirectoryOwnership;\n \n use rustc_errors::{PResult, Applicability};\n-use syntax::ThinVec;\n use syntax::ptr::P;\n use syntax::ast;\n use syntax::ast::{DUMMY_NODE_ID, Stmt, StmtKind, Local, Block, BlockCheckMode, Expr, ExprKind};\n-use syntax::ast::{Attribute, AttrStyle, VisibilityKind, MacStmtStyle, Mac};\n+use syntax::ast::{AttrVec, Attribute, AttrStyle, VisibilityKind, MacStmtStyle, Mac};\n use syntax::util::classify;\n use syntax::token;\n use syntax_pos::source_map::{respan, Span};\n-use syntax_pos::symbol::{kw, sym};\n+use syntax_pos::symbol::{kw, sym, Symbol};\n \n use std::mem;\n \n impl<'a> Parser<'a> {\n     /// Parses a statement. This stops just before trailing semicolons on everything but items.\n     /// e.g., a `StmtKind::Semi` parses to a `StmtKind::Expr`, leaving the trailing `;` unconsumed.\n     pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n-        Ok(self.parse_stmt_(true))\n-    }\n-\n-    fn parse_stmt_(&mut self, macro_legacy_warnings: bool) -> Option<Stmt> {\n-        self.parse_stmt_without_recovery(macro_legacy_warnings).unwrap_or_else(|mut e| {\n+        Ok(self.parse_stmt_without_recovery(true).unwrap_or_else(|mut e| {\n             e.emit();\n             self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n             None\n-        })\n+        }))\n     }\n \n     fn parse_stmt_without_recovery(\n@@ -43,171 +38,195 @@ impl<'a> Parser<'a> {\n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.token.span;\n \n-        Ok(Some(if self.eat_keyword(kw::Let) {\n-            Stmt {\n-                id: DUMMY_NODE_ID,\n-                kind: StmtKind::Local(self.parse_local(attrs.into())?),\n-                span: lo.to(self.prev_span),\n-            }\n-        } else if let Some(macro_def) = self.eat_macro_def(\n-            &attrs,\n-            &respan(lo, VisibilityKind::Inherited),\n-            lo,\n-        )? {\n-            Stmt {\n-                id: DUMMY_NODE_ID,\n-                kind: StmtKind::Item(macro_def),\n-                span: lo.to(self.prev_span),\n-            }\n+        if self.eat_keyword(kw::Let) {\n+            return self.parse_local_mk(lo, attrs.into()).map(Some)\n+        }\n+        if self.is_kw_followed_by_ident(kw::Mut) {\n+            return self.recover_stmt_local(lo, attrs.into(), \"missing keyword\", \"let mut\");\n+        }\n+        if self.is_kw_followed_by_ident(kw::Auto) {\n+            self.bump(); // `auto`\n+            let msg = \"write `let` instead of `auto` to introduce a new variable\";\n+            return self.recover_stmt_local(lo, attrs.into(), msg, \"let\");\n+        }\n+        if self.is_kw_followed_by_ident(sym::var) {\n+            self.bump(); // `var`\n+            let msg = \"write `let` instead of `var` to introduce a new variable\";\n+            return self.recover_stmt_local(lo, attrs.into(), msg, \"let\");\n+        }\n+\n+        let mac_vis = respan(lo, VisibilityKind::Inherited);\n+        if let Some(macro_def) = self.eat_macro_def(&attrs, &mac_vis, lo)? {\n+            return Ok(Some(self.mk_stmt(lo.to(self.prev_span), StmtKind::Item(macro_def))));\n+        }\n+\n         // Starts like a simple path, being careful to avoid contextual keywords\n         // such as a union items, item with `crate` visibility or auto trait items.\n         // Our goal here is to parse an arbitrary path `a::b::c` but not something that starts\n         // like a path (1 token), but it fact not a path.\n-        // `union::b::c` - path, `union U { ... }` - not a path.\n-        // `crate::b::c` - path, `crate struct S;` - not a path.\n-        } else if self.token.is_path_start() &&\n-                  !self.token.is_qpath_start() &&\n-                  !self.is_union_item() &&\n-                  !self.is_crate_vis() &&\n-                  !self.is_auto_trait_item() &&\n-                  !self.is_async_fn() {\n+        if self.token.is_path_start()\n+            && !self.token.is_qpath_start()\n+            && !self.is_union_item() // `union::b::c` - path, `union U { ... }` - not a path.\n+            && !self.is_crate_vis() // `crate::b::c` - path, `crate struct S;` - not a path.\n+            && !self.is_auto_trait_item()\n+            && !self.is_async_fn()\n+        {\n             let path = self.parse_path(PathStyle::Expr)?;\n \n-            if !self.eat(&token::Not) {\n-                let expr = if self.check(&token::OpenDelim(token::Brace)) {\n-                    self.parse_struct_expr(lo, path, ThinVec::new())?\n-                } else {\n-                    let hi = self.prev_span;\n-                    self.mk_expr(lo.to(hi), ExprKind::Path(None, path), ThinVec::new())\n-                };\n-\n-                let expr = self.with_res(Restrictions::STMT_EXPR, |this| {\n-                    let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs.into())?;\n-                    this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n-                })?;\n-\n-                return Ok(Some(Stmt {\n-                    id: DUMMY_NODE_ID,\n-                    kind: StmtKind::Expr(expr),\n-                    span: lo.to(self.prev_span),\n-                }));\n+            if self.eat(&token::Not) {\n+                return self.parse_stmt_mac(lo, attrs.into(), path, macro_legacy_warnings);\n             }\n \n-            let args = self.parse_mac_args()?;\n-            let delim = args.delim();\n-            let hi = self.prev_span;\n-\n-            let style = if delim == token::Brace {\n-                MacStmtStyle::Braces\n+            let expr = if self.check(&token::OpenDelim(token::Brace)) {\n+                self.parse_struct_expr(lo, path, AttrVec::new())?\n             } else {\n-                MacStmtStyle::NoBraces\n+                let hi = self.prev_span;\n+                self.mk_expr(lo.to(hi), ExprKind::Path(None, path), AttrVec::new())\n             };\n \n-            let mac = Mac {\n-                path,\n-                args,\n-                prior_type_ascription: self.last_type_ascription,\n-            };\n-            let kind = if delim == token::Brace ||\n-                          self.token == token::Semi || self.token == token::Eof {\n-                StmtKind::Mac(P((mac, style, attrs.into())))\n-            }\n-            // We used to incorrectly stop parsing macro-expanded statements here.\n-            // If the next token will be an error anyway but could have parsed with the\n-            // earlier behavior, stop parsing here and emit a warning to avoid breakage.\n-            else if macro_legacy_warnings && self.token.can_begin_expr() &&\n-                match self.token.kind {\n-                    // These can continue an expression, so we can't stop parsing and warn.\n-                    token::OpenDelim(token::Paren) | token::OpenDelim(token::Bracket) |\n-                    token::BinOp(token::Minus) | token::BinOp(token::Star) |\n-                    token::BinOp(token::And) | token::BinOp(token::Or) |\n-                    token::AndAnd | token::OrOr |\n-                    token::DotDot | token::DotDotDot | token::DotDotEq => false,\n-                    _ => true,\n-                }\n-            {\n-                self.warn_missing_semicolon();\n-                StmtKind::Mac(P((mac, style, attrs.into())))\n-            } else {\n-                let e = self.mk_expr(lo.to(hi), ExprKind::Mac(mac), ThinVec::new());\n-                let e = self.maybe_recover_from_bad_qpath(e, true)?;\n-                let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n-                let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n-                StmtKind::Expr(e)\n-            };\n-            Stmt {\n-                id: DUMMY_NODE_ID,\n-                span: lo.to(hi),\n-                kind,\n+            let expr = self.with_res(Restrictions::STMT_EXPR, |this| {\n+                let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs.into())?;\n+                this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n+            })?;\n+            return Ok(Some(self.mk_stmt(lo.to(self.prev_span), StmtKind::Expr(expr))));\n+        }\n+\n+        // FIXME: Bad copy of attrs\n+        let old_directory_ownership =\n+            mem::replace(&mut self.directory.ownership, DirectoryOwnership::UnownedViaBlock);\n+        let item = self.parse_item_(attrs.clone(), false, true)?;\n+        self.directory.ownership = old_directory_ownership;\n+\n+        if let Some(item) = item {\n+            return Ok(Some(self.mk_stmt(lo.to(item.span), StmtKind::Item(item))));\n+        }\n+\n+        // Do not attempt to parse an expression if we're done here.\n+        if self.token == token::Semi {\n+            self.error_outer_attrs(&attrs);\n+            self.bump();\n+            let mut last_semi = lo;\n+            while self.token == token::Semi {\n+                last_semi = self.token.span;\n+                self.bump();\n             }\n+            // We are encoding a string of semicolons as an an empty tuple that spans\n+            // the excess semicolons to preserve this info until the lint stage.\n+            let kind = StmtKind::Semi(self.mk_expr(\n+                lo.to(last_semi),\n+                ExprKind::Tup(Vec::new()),\n+                AttrVec::new()\n+            ));\n+            return Ok(Some(self.mk_stmt(lo.to(last_semi), kind)));\n+        }\n+\n+        if self.token == token::CloseDelim(token::Brace) {\n+            self.error_outer_attrs(&attrs);\n+            return Ok(None);\n+        }\n+\n+        // Remainder are line-expr stmts.\n+        let e = self.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs.into()))?;\n+        Ok(Some(self.mk_stmt(lo.to(e.span), StmtKind::Expr(e))))\n+    }\n+\n+    /// Parses a statement macro `mac!(args)` provided a `path` representing `mac`.\n+    /// At this point, the `!` token after the path has already been eaten.\n+    fn parse_stmt_mac(\n+        &mut self,\n+        lo: Span,\n+        attrs: AttrVec,\n+        path: ast::Path,\n+        legacy_warnings: bool,\n+    ) -> PResult<'a, Option<Stmt>> {\n+        let args = self.parse_mac_args()?;\n+        let delim = args.delim();\n+        let hi = self.prev_span;\n+\n+        let style = if delim == token::Brace {\n+            MacStmtStyle::Braces\n         } else {\n-            // FIXME: Bad copy of attrs\n-            let old_directory_ownership =\n-                mem::replace(&mut self.directory.ownership, DirectoryOwnership::UnownedViaBlock);\n-            let item = self.parse_item_(attrs.clone(), false, true)?;\n-            self.directory.ownership = old_directory_ownership;\n-\n-            match item {\n-                Some(i) => Stmt {\n-                    id: DUMMY_NODE_ID,\n-                    span: lo.to(i.span),\n-                    kind: StmtKind::Item(i),\n-                },\n-                None => {\n-                    let unused_attrs = |attrs: &[Attribute], s: &mut Self| {\n-                        if !attrs.is_empty() {\n-                            if s.prev_token_kind == PrevTokenKind::DocComment {\n-                                s.span_fatal_err(s.prev_span, Error::UselessDocComment).emit();\n-                            } else if attrs.iter().any(|a| a.style == AttrStyle::Outer) {\n-                                s.span_err(\n-                                    s.token.span, \"expected statement after outer attribute\"\n-                                );\n-                            }\n-                        }\n-                    };\n-\n-                    // Do not attempt to parse an expression if we're done here.\n-                    if self.token == token::Semi {\n-                        unused_attrs(&attrs, self);\n-                        self.bump();\n-                        let mut last_semi = lo;\n-                        while self.token == token::Semi {\n-                            last_semi = self.token.span;\n-                            self.bump();\n-                        }\n-                        // We are encoding a string of semicolons as an\n-                        // an empty tuple that spans the excess semicolons\n-                        // to preserve this info until the lint stage\n-                        return Ok(Some(Stmt {\n-                            id: DUMMY_NODE_ID,\n-                            span: lo.to(last_semi),\n-                            kind: StmtKind::Semi(self.mk_expr(lo.to(last_semi),\n-                                ExprKind::Tup(Vec::new()),\n-                                ThinVec::new()\n-                            )),\n-                        }));\n-                    }\n+            MacStmtStyle::NoBraces\n+        };\n \n-                    if self.token == token::CloseDelim(token::Brace) {\n-                        unused_attrs(&attrs, self);\n-                        return Ok(None);\n-                    }\n+        let mac = Mac {\n+            path,\n+            args,\n+            prior_type_ascription: self.last_type_ascription,\n+        };\n \n-                    // Remainder are line-expr stmts.\n-                    let e = self.parse_expr_res(\n-                        Restrictions::STMT_EXPR, Some(attrs.into()))?;\n-                    Stmt {\n-                        id: DUMMY_NODE_ID,\n-                        span: lo.to(e.span),\n-                        kind: StmtKind::Expr(e),\n-                    }\n-                }\n+        let kind = if delim == token::Brace\n+            || self.token == token::Semi\n+            || self.token == token::Eof\n+        {\n+            StmtKind::Mac(P((mac, style, attrs.into())))\n+        }\n+        // We used to incorrectly stop parsing macro-expanded statements here.\n+        // If the next token will be an error anyway but could have parsed with the\n+        // earlier behavior, stop parsing here and emit a warning to avoid breakage.\n+        else if legacy_warnings\n+            && self.token.can_begin_expr()\n+            && match self.token.kind {\n+                // These can continue an expression, so we can't stop parsing and warn.\n+                token::OpenDelim(token::Paren) | token::OpenDelim(token::Bracket) |\n+                token::BinOp(token::Minus) | token::BinOp(token::Star) |\n+                token::BinOp(token::And) | token::BinOp(token::Or) |\n+                token::AndAnd | token::OrOr |\n+                token::DotDot | token::DotDotDot | token::DotDotEq => false,\n+                _ => true,\n             }\n-        }))\n+        {\n+            self.warn_missing_semicolon();\n+            StmtKind::Mac(P((mac, style, attrs)))\n+        } else {\n+            // Since none of the above applied, this is an expression statement macro.\n+            let e = self.mk_expr(lo.to(hi), ExprKind::Mac(mac), AttrVec::new());\n+            let e = self.maybe_recover_from_bad_qpath(e, true)?;\n+            let e = self.parse_dot_or_call_expr_with(e, lo, attrs)?;\n+            let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n+            StmtKind::Expr(e)\n+        };\n+        Ok(Some(self.mk_stmt(lo.to(hi), kind)))\n+    }\n+\n+    /// Error on outer attributes in this context.\n+    /// Also error if the previous token was a doc comment.\n+    fn error_outer_attrs(&self, attrs: &[Attribute]) {\n+        if !attrs.is_empty() {\n+            if self.prev_token_kind == PrevTokenKind::DocComment {\n+                self.span_fatal_err(self.prev_span, Error::UselessDocComment).emit();\n+            } else if attrs.iter().any(|a| a.style == AttrStyle::Outer) {\n+                self.span_err(self.token.span, \"expected statement after outer attribute\");\n+            }\n+        }\n+    }\n+\n+    fn is_kw_followed_by_ident(&self, kw: Symbol) -> bool {\n+        self.token.is_keyword(kw)\n+            && self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n+    }\n+\n+    fn recover_stmt_local(\n+        &mut self,\n+        lo: Span,\n+        attrs: AttrVec,\n+        msg: &str,\n+        sugg: &str,\n+    ) -> PResult<'a, Option<Stmt>> {\n+        let stmt = self.parse_local_mk(lo, attrs)?;\n+        self.struct_span_err(lo, \"invalid variable declaration\")\n+            .span_suggestion(lo, msg, sugg.to_string(), Applicability::MachineApplicable)\n+            .emit();\n+        Ok(Some(stmt))\n+    }\n+\n+    fn parse_local_mk(&mut self, lo: Span, attrs: AttrVec) -> PResult<'a, Stmt> {\n+        let local = self.parse_local(attrs.into())?;\n+        Ok(self.mk_stmt(lo.to(self.prev_span), StmtKind::Local(local)))\n     }\n \n     /// Parses a local variable declaration.\n-    fn parse_local(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Local>> {\n+    fn parse_local(&mut self, attrs: AttrVec) -> PResult<'a, P<Local>> {\n         let lo = self.prev_span;\n         let pat = self.parse_top_pat(GateOr::Yes)?;\n \n@@ -307,70 +326,58 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n \n         if !self.eat(&token::OpenDelim(token::Brace)) {\n-            let sp = self.token.span;\n-            let tok = self.this_token_descr();\n-            let mut e = self.span_fatal(sp, &format!(\"expected `{{`, found {}\", tok));\n-            let do_not_suggest_help =\n-                self.token.is_keyword(kw::In) || self.token == token::Colon;\n-\n-            if self.token.is_ident_named(sym::and) {\n-                e.span_suggestion_short(\n-                    self.token.span,\n-                    \"use `&&` instead of `and` for the boolean operator\",\n-                    \"&&\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            if self.token.is_ident_named(sym::or) {\n-                e.span_suggestion_short(\n-                    self.token.span,\n-                    \"use `||` instead of `or` for the boolean operator\",\n-                    \"||\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n+            return self.error_block_no_opening_brace();\n+        }\n \n-            // Check to see if the user has written something like\n-            //\n-            //    if (cond)\n-            //      bar;\n-            //\n-            // which is valid in other languages, but not Rust.\n-            match self.parse_stmt_without_recovery(false) {\n-                Ok(Some(stmt)) => {\n-                    if self.look_ahead(1, |t| t == &token::OpenDelim(token::Brace))\n-                        || do_not_suggest_help {\n-                        // If the next token is an open brace (e.g., `if a b {`), the place-\n-                        // inside-a-block suggestion would be more likely wrong than right.\n-                        e.span_label(sp, \"expected `{`\");\n-                        return Err(e);\n-                    }\n-                    let mut stmt_span = stmt.span;\n-                    // Expand the span to include the semicolon, if it exists.\n-                    if self.eat(&token::Semi) {\n-                        stmt_span = stmt_span.with_hi(self.prev_span.hi());\n-                    }\n-                    if let Ok(snippet) = self.span_to_snippet(stmt_span) {\n-                        e.span_suggestion(\n-                            stmt_span,\n-                            \"try placing this code inside a block\",\n-                            format!(\"{{ {} }}\", snippet),\n-                            // Speculative; has been misleading in the past (#46836).\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n+        self.parse_block_tail(lo, BlockCheckMode::Default)\n+    }\n+\n+    fn error_block_no_opening_brace<T>(&mut self) -> PResult<'a, T> {\n+        let sp = self.token.span;\n+        let tok = self.this_token_descr();\n+        let mut e = self.span_fatal(sp, &format!(\"expected `{{`, found {}\", tok));\n+        let do_not_suggest_help = self.token.is_keyword(kw::In) || self.token == token::Colon;\n+\n+        // Check to see if the user has written something like\n+        //\n+        //    if (cond)\n+        //      bar;\n+        //\n+        // which is valid in other languages, but not Rust.\n+        match self.parse_stmt_without_recovery(false) {\n+            Ok(Some(stmt)) => {\n+                if self.look_ahead(1, |t| t == &token::OpenDelim(token::Brace))\n+                    || do_not_suggest_help\n+                {\n+                    // If the next token is an open brace (e.g., `if a b {`), the place-\n+                    // inside-a-block suggestion would be more likely wrong than right.\n+                    e.span_label(sp, \"expected `{`\");\n+                    return Err(e);\n                 }\n-                Err(mut e) => {\n-                    self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n-                    e.cancel();\n+                let stmt_span = if self.eat(&token::Semi) {\n+                    // Expand the span to include the semicolon.\n+                    stmt.span.with_hi(self.prev_span.hi())\n+                } else {\n+                    stmt.span\n+                };\n+                if let Ok(snippet) = self.span_to_snippet(stmt_span) {\n+                    e.span_suggestion(\n+                        stmt_span,\n+                        \"try placing this code inside a block\",\n+                        format!(\"{{ {} }}\", snippet),\n+                        // Speculative; has been misleading in the past (#46836).\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n-                _ => ()\n             }\n-            e.span_label(sp, \"expected `{`\");\n-            return Err(e);\n+            Err(mut e) => {\n+                self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n+                e.cancel();\n+            }\n+            _ => {}\n         }\n-\n-        self.parse_block_tail(lo, BlockCheckMode::Default)\n+        e.span_label(sp, \"expected `{`\");\n+        return Err(e);\n     }\n \n     /// Parses a block. Inner attributes are allowed.\n@@ -402,11 +409,10 @@ impl<'a> Parser<'a> {\n                     self.maybe_annotate_with_ascription(&mut err, false);\n                     err.emit();\n                     self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore);\n-                    Some(Stmt {\n-                        id: DUMMY_NODE_ID,\n-                        kind: StmtKind::Expr(self.mk_expr_err(self.token.span)),\n-                        span: self.token.span,\n-                    })\n+                    Some(self.mk_stmt(\n+                        self.token.span,\n+                        StmtKind::Expr(self.mk_expr_err(self.token.span)),\n+                    ))\n                 }\n                 Ok(stmt) => stmt,\n             };\n@@ -478,4 +484,8 @@ impl<'a> Parser<'a> {\n             \"this was erroneously allowed and will become a hard error in a future release\"\n         }).emit();\n     }\n+\n+    fn mk_stmt(&self, span: Span, kind: StmtKind) -> Stmt {\n+        Stmt { id: DUMMY_NODE_ID, kind, span }\n+    }\n }"}, {"sha": "c1458236788cb11b9f3b6a8b7b1b2c46dcd0a647", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -338,7 +338,7 @@ pub enum GenericParamKind {\n pub struct GenericParam {\n     pub id: NodeId,\n     pub ident: Ident,\n-    pub attrs: ThinVec<Attribute>,\n+    pub attrs: AttrVec,\n     pub bounds: GenericBounds,\n     pub is_placeholder: bool,\n     pub kind: GenericParamKind,\n@@ -599,7 +599,7 @@ pub struct FieldPat {\n     /// The pattern the field is destructured to\n     pub pat: P<Pat>,\n     pub is_shorthand: bool,\n-    pub attrs: ThinVec<Attribute>,\n+    pub attrs: AttrVec,\n     pub id: NodeId,\n     pub span: Span,\n     pub is_placeholder: bool,\n@@ -911,7 +911,7 @@ pub enum StmtKind {\n     /// Expr with a trailing semi-colon.\n     Semi(P<Expr>),\n     /// Macro.\n-    Mac(P<(Mac, MacStmtStyle, ThinVec<Attribute>)>),\n+    Mac(P<(Mac, MacStmtStyle, AttrVec)>),\n }\n \n #[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n@@ -936,7 +936,7 @@ pub struct Local {\n     /// Initializer expression to set the value, if any.\n     pub init: Option<P<Expr>>,\n     pub span: Span,\n-    pub attrs: ThinVec<Attribute>,\n+    pub attrs: AttrVec,\n }\n \n /// An arm of a 'match'.\n@@ -966,7 +966,7 @@ pub struct Arm {\n /// Access of a named (e.g., `obj.foo`) or unnamed (e.g., `obj.0`) struct field.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Field {\n-    pub attrs: ThinVec<Attribute>,\n+    pub attrs: AttrVec,\n     pub id: NodeId,\n     pub span: Span,\n     pub ident: Ident,\n@@ -1004,7 +1004,7 @@ pub struct Expr {\n     pub id: NodeId,\n     pub kind: ExprKind,\n     pub span: Span,\n-    pub attrs: ThinVec<Attribute>,\n+    pub attrs: AttrVec,\n }\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -1961,7 +1961,7 @@ pub struct InlineAsm {\n /// E.g., `bar: usize` as in `fn foo(bar: usize)`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Param {\n-    pub attrs: ThinVec<Attribute>,\n+    pub attrs: AttrVec,\n     pub ty: P<Ty>,\n     pub pat: P<Pat>,\n     pub id: NodeId,\n@@ -2014,7 +2014,7 @@ impl Param {\n     }\n \n     /// Builds a `Param` object from `ExplicitSelf`.\n-    pub fn from_self(attrs: ThinVec<Attribute>, eself: ExplicitSelf, eself_ident: Ident) -> Param {\n+    pub fn from_self(attrs: AttrVec, eself: ExplicitSelf, eself_ident: Ident) -> Param {\n         let span = eself.span.to(eself_ident.span);\n         let infer_ty = P(Ty {\n             id: DUMMY_NODE_ID,\n@@ -2332,6 +2332,9 @@ pub struct AttrItem {\n     pub args: MacArgs,\n }\n \n+/// A list of attributes.\n+pub type AttrVec = ThinVec<Attribute>;\n+\n /// Metadata associated with an item.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Attribute {"}, {"sha": "ae6d50ba083074adb83af7fbaaa9d0b22fa347bb", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -9,15 +9,14 @@ pub use StabilityLevel::*;\n pub use crate::ast::Attribute;\n \n use crate::ast;\n-use crate::ast::{AttrItem, AttrId, AttrKind, AttrStyle, Name, Ident, Path, PathSegment};\n+use crate::ast::{AttrVec, AttrItem, AttrId, AttrKind, AttrStyle, Name, Ident, Path, PathSegment};\n use crate::ast::{MacArgs, MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Lit, LitKind, Expr, Item, Local, Stmt, StmtKind, GenericParam};\n use crate::mut_visit::visit_clobber;\n use crate::source_map::{BytePos, Spanned};\n use crate::token::{self, Token};\n use crate::ptr::P;\n use crate::symbol::{sym, Symbol};\n-use crate::ThinVec;\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n use crate::GLOBALS;\n \n@@ -665,7 +664,7 @@ impl HasAttrs for Vec<Attribute> {\n     }\n }\n \n-impl HasAttrs for ThinVec<Attribute> {\n+impl HasAttrs for AttrVec {\n     fn attrs(&self) -> &[Attribute] {\n         self\n     }"}, {"sha": "30fd23ea909acb375cca7ff0d6fb97a210efa6bb", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -24,7 +24,6 @@\n pub use errors;\n use rustc_data_structures::sync::Lock;\n use rustc_index::bit_set::GrowableBitSet;\n-pub use rustc_data_structures::thin_vec::ThinVec;\n use ast::AttrId;\n use syntax_pos::edition::Edition;\n "}, {"sha": "1d27f70f5a5443aa3d147024c1c668f4f534a48c", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -11,7 +11,6 @@ use crate::ast::*;\n use crate::source_map::{Spanned, respan};\n use crate::token::{self, Token};\n use crate::ptr::P;\n-use crate::ThinVec;\n use crate::tokenstream::*;\n use crate::util::map_in_place::MapInPlace;\n \n@@ -337,7 +336,7 @@ pub fn visit_attrs<T: MutVisitor>(attrs: &mut Vec<Attribute>, vis: &mut T) {\n }\n \n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n-pub fn visit_thin_attrs<T: MutVisitor>(attrs: &mut ThinVec<Attribute>, vis: &mut T) {\n+pub fn visit_thin_attrs<T: MutVisitor>(attrs: &mut AttrVec, vis: &mut T) {\n     for attr in attrs.iter_mut() {\n         vis.visit_attribute(attr);\n     }"}, {"sha": "2ad327e872e15f04cfc29c210b5641075640ba58", "filename": "src/libsyntax_expand/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fbase.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -9,7 +9,6 @@ use syntax::mut_visit::{self, MutVisitor};\n use syntax::ptr::P;\n use syntax::sess::ParseSess;\n use syntax::symbol::{kw, sym, Ident, Symbol};\n-use syntax::ThinVec;\n use syntax::token;\n use syntax::tokenstream::{self, TokenStream};\n use syntax::visit::Visitor;\n@@ -552,7 +551,7 @@ impl DummyResult {\n             id: ast::DUMMY_NODE_ID,\n             kind: if is_error { ast::ExprKind::Err } else { ast::ExprKind::Tup(Vec::new()) },\n             span: sp,\n-            attrs: ThinVec::new(),\n+            attrs: ast::AttrVec::new(),\n         })\n     }\n "}, {"sha": "4c539cad111a01ef3b60de6f8c07cb217ed3141c", "filename": "src/libsyntax_expand/build.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fbuild.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -1,11 +1,10 @@\n use crate::base::ExtCtxt;\n \n-use syntax::ast::{self, Ident, Expr, BlockCheckMode, UnOp, PatKind};\n+use syntax::ast::{self, AttrVec, Ident, Expr, BlockCheckMode, UnOp, PatKind};\n use syntax::attr;\n use syntax::source_map::{respan, Spanned};\n use syntax::ptr::P;\n use syntax::symbol::{kw, sym, Symbol};\n-use syntax::ThinVec;\n \n use syntax_pos::{Pos, Span};\n \n@@ -81,7 +80,7 @@ impl<'a> ExtCtxt<'a> {\n                 id: ast::DUMMY_NODE_ID,\n                 kind,\n                 span,\n-                attrs: ThinVec::new(),\n+                attrs: AttrVec::new(),\n             })\n         }\n     }\n@@ -190,7 +189,7 @@ impl<'a> ExtCtxt<'a> {\n             init: Some(ex),\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n-            attrs: ThinVec::new(),\n+            attrs: AttrVec::new(),\n         });\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -207,7 +206,7 @@ impl<'a> ExtCtxt<'a> {\n             init: None,\n             id: ast::DUMMY_NODE_ID,\n             span,\n-            attrs: ThinVec::new(),\n+            attrs: AttrVec::new(),\n         });\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -245,7 +244,7 @@ impl<'a> ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             kind,\n             span,\n-            attrs: ThinVec::new(),\n+            attrs: AttrVec::new(),\n         })\n     }\n \n@@ -304,7 +303,7 @@ impl<'a> ExtCtxt<'a> {\n             expr: e,\n             span,\n             is_shorthand: false,\n-            attrs: ThinVec::new(),\n+            attrs: AttrVec::new(),\n             id: ast::DUMMY_NODE_ID,\n             is_placeholder: false,\n         }\n@@ -549,7 +548,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn param(&self, span: Span, ident: ast::Ident, ty: P<ast::Ty>) -> ast::Param {\n         let arg_pat = self.pat_ident(span, ident);\n         ast::Param {\n-            attrs: ThinVec::default(),\n+            attrs: AttrVec::default(),\n             id: ast::DUMMY_NODE_ID,\n             pat: arg_pat,\n             span,"}, {"sha": "107fe388ed0464c75d4d6ce08650e203086dfa36", "filename": "src/libsyntax_expand/mbe/macro_rules.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fmbe%2Fmacro_rules.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -63,6 +63,30 @@ crate fn annotate_err_with_kind(\n     };\n }\n \n+/// Instead of e.g. `vec![a, b, c]` in a pattern context, suggest `[a, b, c]`.\n+fn suggest_slice_pat(e: &mut DiagnosticBuilder<'_>, site_span: Span, parser: &Parser<'_>) {\n+    let mut suggestion = None;\n+    if let Ok(code) = parser.sess.source_map().span_to_snippet(site_span) {\n+        if let Some(bang) = code.find('!') {\n+            suggestion = Some(code[bang + 1..].to_string());\n+        }\n+    }\n+    if let Some(suggestion) = suggestion {\n+        e.span_suggestion(\n+            site_span,\n+            \"use a slice pattern here instead\",\n+            suggestion,\n+            Applicability::MachineApplicable,\n+        );\n+    } else {\n+        e.span_label(site_span, \"use a slice pattern here instead\");\n+    }\n+    e.help(\n+        \"for more information, see https://doc.rust-lang.org/edition-guide/\\\n+        rust-2018/slice-patterns.html\"\n+    );\n+}\n+\n impl<'a> ParserAnyMacro<'a> {\n     crate fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n         let ParserAnyMacro { site_span, macro_ident, ref mut parser, arm_span } = *self;\n@@ -92,27 +116,7 @@ impl<'a> ParserAnyMacro<'a> {\n             }\n             match kind {\n                 AstFragmentKind::Pat if macro_ident.name == sym::vec => {\n-                    let mut suggestion = None;\n-                    if let Ok(code) = parser.sess.source_map().span_to_snippet(site_span) {\n-                        if let Some(bang) = code.find('!') {\n-                            suggestion = Some(code[bang + 1..].to_string());\n-                        }\n-                    }\n-                    if let Some(suggestion) = suggestion {\n-                        e.span_suggestion(\n-                            site_span,\n-                            \"use a slice pattern here instead\",\n-                            suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else {\n-                        e.span_label(\n-                            site_span,\n-                            \"use a slice pattern here instead\",\n-                        );\n-                    }\n-                    e.help(\"for more information, see https://doc.rust-lang.org/edition-guide/\\\n-                            rust-2018/slice-patterns.html\");\n+                    suggest_slice_pat(&mut e, site_span, parser);\n                 }\n                 _ => annotate_err_with_kind(&mut e, kind, site_span),\n             };"}, {"sha": "4298e0e74b6e613f1b16a360fceb67c58556447c", "filename": "src/libsyntax_expand/placeholders.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax_expand%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax_expand%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fplaceholders.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -5,7 +5,6 @@ use syntax::ast;\n use syntax::source_map::{DUMMY_SP, dummy_spanned};\n use syntax::mut_visit::*;\n use syntax::ptr::P;\n-use syntax::ThinVec;\n \n use smallvec::{smallvec, SmallVec};\n \n@@ -28,7 +27,7 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId, vis: Option<ast::Visi\n     let span = DUMMY_SP;\n     let expr_placeholder = || P(ast::Expr {\n         id, span,\n-        attrs: ThinVec::new(),\n+        attrs: ast::AttrVec::new(),\n         kind: ast::ExprKind::Mac(mac_placeholder()),\n     });\n     let ty = || P(ast::Ty {\n@@ -75,7 +74,7 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId, vis: Option<ast::Visi\n             id, span, kind: ast::TyKind::Mac(mac_placeholder()),\n         })),\n         AstFragmentKind::Stmts => AstFragment::Stmts(smallvec![{\n-            let mac = P((mac_placeholder(), ast::MacStmtStyle::Braces, ThinVec::new()));\n+            let mac = P((mac_placeholder(), ast::MacStmtStyle::Braces, ast::AttrVec::new()));\n             ast::Stmt { id, span, kind: ast::StmtKind::Mac(mac) }\n         }]),\n         AstFragmentKind::Arms => AstFragment::Arms(smallvec!["}, {"sha": "5ec24b7a7acc5156ed968e2921f4ef747fccd559", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -3,7 +3,6 @@\n use State::*;\n \n use errors::{DiagnosticBuilder, PResult};\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_parse::parser::Parser;\n use syntax_expand::base::*;\n use syntax_pos::Span;\n@@ -63,7 +62,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n         id: ast::DUMMY_NODE_ID,\n         kind: ast::ExprKind::InlineAsm(P(inline_asm)),\n         span: cx.with_def_site_ctxt(sp),\n-        attrs: ThinVec::new(),\n+        attrs: ast::AttrVec::new(),\n     }))\n }\n "}, {"sha": "7d8bc8b87bc2b83b3b802f4c6ea6f1a9c76fa1c1", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -1,5 +1,3 @@\n-use rustc_data_structures::thin_vec::ThinVec;\n-\n use syntax::ast;\n use syntax_expand::base::{self, *};\n use syntax::token::{self, Token};\n@@ -49,7 +47,7 @@ pub fn expand_concat_idents<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                 id: ast::DUMMY_NODE_ID,\n                 kind: ast::ExprKind::Path(None, ast::Path::from_ident(self.ident)),\n                 span: self.ident.span,\n-                attrs: ThinVec::new(),\n+                attrs: ast::AttrVec::new(),\n             }))\n         }\n "}, {"sha": "132ce76e1bb6dbcaa868e890e0680deac11d60d8", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -2,8 +2,6 @@ use crate::deriving::path_std;\n use crate::deriving::generic::*;\n use crate::deriving::generic::ty::*;\n \n-use rustc_data_structures::thin_vec::ThinVec;\n-\n use syntax::ast::{self, Ident};\n use syntax::ast::{Expr, MetaItem};\n use syntax_expand::base::{Annotatable, ExtCtxt};\n@@ -127,7 +125,7 @@ fn stmt_let_undescore(cx: &mut ExtCtxt<'_>, sp: Span, expr: P<ast::Expr>) -> ast\n         init: Some(expr),\n         id: ast::DUMMY_NODE_ID,\n         span: sp,\n-        attrs: ThinVec::new(),\n+        attrs: ast::AttrVec::new(),\n     });\n     ast::Stmt {\n         id: ast::DUMMY_NODE_ID,"}, {"sha": "5158a5b3da217791af03505860f0591968b09130", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -181,7 +181,6 @@ use std::cell::RefCell;\n use std::iter;\n use std::vec;\n \n-use rustc_data_structures::thin_vec::ThinVec;\n use syntax::ast::{self, BinOpKind, EnumDef, Expr, Generics, Ident, PatKind};\n use syntax::ast::{VariantData, GenericParamKind, GenericArg};\n use syntax::attr;\n@@ -919,7 +918,7 @@ impl<'a> MethodDef<'a> {\n         let args = {\n             let self_args = explicit_self.map(|explicit_self| {\n                 let ident = Ident::with_dummy_span(kw::SelfLower).with_span_pos(trait_.span);\n-                ast::Param::from_self(ThinVec::default(), explicit_self, ident)\n+                ast::Param::from_self(ast::AttrVec::default(), explicit_self, ident)\n             });\n             let nonself_args = arg_types.into_iter()\n                 .map(|(name, ty)| cx.param(trait_.span, name, ty));\n@@ -1608,7 +1607,7 @@ impl<'a> TraitDef<'a> {\n                         ast::FieldPat {\n                             ident: ident.unwrap(),\n                             is_shorthand: false,\n-                            attrs: ThinVec::new(),\n+                            attrs: ast::AttrVec::new(),\n                             id: ast::DUMMY_NODE_ID,\n                             span: pat.span.with_ctxt(self.span.ctxt()),\n                             pat,"}, {"sha": "d3e80fc4fddd6d6505afc24dd3b68508c2299127", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -773,6 +773,7 @@ symbols! {\n         usize,\n         v1,\n         val,\n+        var,\n         vec,\n         Vec,\n         vis,"}, {"sha": "5b975424512d45a5426d9604faafc666c9a37e4f", "filename": "src/test/pretty/ast-stmt-expr-attr.rs", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fpretty%2Fast-stmt-expr-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fpretty%2Fast-stmt-expr-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fast-stmt-expr-attr.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -0,0 +1,175 @@\n+// pp-exact\n+\n+fn main() { }\n+\n+#[cfg(FALSE)]\n+fn syntax() {\n+    let _ = #[attr] box 0;\n+    let _ = #[attr] [#![attr] ];\n+    let _ = #[attr] [#![attr] 0];\n+    let _ = #[attr] [#![attr] 0; 0];\n+    let _ = #[attr] [#![attr] 0, 0, 0];\n+    let _ = #[attr] foo();\n+    let _ = #[attr] x.foo();\n+    let _ = #[attr] (#![attr] );\n+    let _ = #[attr] (#![attr] #[attr] 0,);\n+    let _ = #[attr] (#![attr] #[attr] 0, 0);\n+    let _ = #[attr] 0 + #[attr] 0;\n+    let _ = #[attr] 0 / #[attr] 0;\n+    let _ = #[attr] 0 & #[attr] 0;\n+    let _ = #[attr] 0 % #[attr] 0;\n+    let _ = #[attr] (0 + 0);\n+    let _ = #[attr] !0;\n+    let _ = #[attr] -0;\n+    let _ = #[attr] false;\n+    let _ = #[attr] 0;\n+    let _ = #[attr] 'c';\n+    let _ = #[attr] x as Y;\n+    let _ = #[attr] (x as Y);\n+    let _ =\n+        #[attr] while true {\n+                    #![attr]\n+                };\n+    let _ =\n+        #[attr] while let Some(false) = true {\n+                    #![attr]\n+                };\n+    let _ =\n+        #[attr] for x in y {\n+                    #![attr]\n+                };\n+    let _ =\n+        #[attr] loop  {\n+                    #![attr]\n+                };\n+    let _ =\n+        #[attr] match true {\n+                    #![attr]\n+                            #[attr]\n+                            _ => false,\n+                };\n+    let _ = #[attr] || #[attr] foo;\n+    let _ = #[attr] move || #[attr] foo;\n+    let _ =\n+        #[attr] ||\n+                    #[attr] {\n+                                #![attr]\n+                                foo\n+                            };\n+    let _ =\n+        #[attr] move ||\n+                    #[attr] {\n+                                #![attr]\n+                                foo\n+                            };\n+    let _ =\n+        #[attr] ||\n+                    {\n+                        #![attr]\n+                        foo\n+                    };\n+    let _ =\n+        #[attr] move ||\n+                    {\n+                        #![attr]\n+                        foo\n+                    };\n+    let _ =\n+        #[attr] {\n+                    #![attr]\n+                };\n+    let _ =\n+        #[attr] {\n+                    #![attr]\n+                    let _ = ();\n+                };\n+    let _ =\n+        #[attr] {\n+                    #![attr]\n+                    let _ = ();\n+                    foo\n+                };\n+    let _ = #[attr] x = y;\n+    let _ = #[attr] (x = y);\n+    let _ = #[attr] x += y;\n+    let _ = #[attr] (x += y);\n+    let _ = #[attr] foo.bar;\n+    let _ = (#[attr] foo).bar;\n+    let _ = #[attr] foo.0;\n+    let _ = (#[attr] foo).0;\n+    let _ = #[attr] foo[bar];\n+    let _ = (#[attr] foo)[bar];\n+    let _ = #[attr] 0..#[attr] 0;\n+    let _ = #[attr] 0..;\n+    let _ = #[attr] (0..0);\n+    let _ = #[attr] (0..);\n+    let _ = #[attr] (..0);\n+    let _ = #[attr] (..);\n+    let _ = #[attr] foo::bar::baz;\n+    let _ = #[attr] &0;\n+    let _ = #[attr] &mut 0;\n+    let _ = #[attr] &#[attr] 0;\n+    let _ = #[attr] &mut #[attr] 0;\n+    let _ = #[attr] break ;\n+    let _ = #[attr] continue ;\n+    let _ = #[attr] return;\n+    let _ = #[attr] foo!();\n+    let _ = #[attr] foo!(# ! [attr]);\n+    let _ = #[attr] foo![];\n+    let _ = #[attr] foo![# ! [attr]];\n+    let _ = #[attr] foo! { };\n+    let _ = #[attr] foo! { # ! [attr] };\n+    let _ = #[attr] Foo{#![attr] bar: baz,};\n+    let _ = #[attr] Foo{#![attr] ..foo};\n+    let _ = #[attr] Foo{#![attr] bar: baz, ..foo};\n+    let _ = #[attr] (#![attr] 0);\n+\n+    {\n+        #[attr]\n+        let _ = 0;\n+\n+        #[attr]\n+        0;\n+\n+        #[attr]\n+        foo!();\n+\n+        #[attr]\n+        foo! { }\n+\n+        #[attr]\n+        foo![];\n+    }\n+\n+    {\n+        #[attr]\n+        let _ = 0;\n+    }\n+    {\n+\n+        #[attr]\n+        0\n+    }\n+    {\n+\n+        #[attr]\n+        {\n+            #![attr]\n+        }\n+    }\n+    {\n+\n+        #[attr]\n+        foo!()\n+    }\n+    {\n+\n+        #[attr]\n+        foo![]\n+    }\n+    {\n+\n+        #[attr]\n+        foo! { }\n+    }\n+}"}, {"sha": "d6d49df63ef1556a5f7540fc0280b1fc96b5aa31", "filename": "src/test/ui-fulldeps/ast_stmt_expr_attr.rs", "status": "removed", "additions": 0, "deletions": 311, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/9ff30a7810c586819a78188c173a7b74adbb9730/src%2Ftest%2Fui-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ff30a7810c586819a78188c173a7b74adbb9730/src%2Ftest%2Fui-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fast_stmt_expr_attr.rs?ref=9ff30a7810c586819a78188c173a7b74adbb9730", "patch": "@@ -1,311 +0,0 @@\n-// run-pass\n-\n-#![allow(unused_imports)]\n-// ignore-cross-compile\n-\n-#![feature(rustc_private)]\n-\n-extern crate syntax;\n-extern crate syntax_expand;\n-extern crate rustc_parse;\n-extern crate rustc_errors;\n-\n-use rustc_errors::PResult;\n-use rustc_parse::parser::attr::*;\n-use rustc_parse::new_parser_from_source_str;\n-use rustc_parse::parser::Parser;\n-use syntax::ast::*;\n-use syntax::attr::*;\n-use syntax::ast;\n-use syntax::sess::ParseSess;\n-use syntax::source_map::{FilePathMapping, FileName};\n-use syntax::ptr::P;\n-use syntax::print::pprust;\n-use syntax::token;\n-use std::fmt;\n-\n-// Copied out of syntax::util::parser_testing\n-\n-pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: String) -> Parser<'a> {\n-    new_parser_from_source_str(ps, FileName::Custom(source_str.clone()), source_str)\n-}\n-\n-fn with_error_checking_parse<'a, T, F>(s: String, ps: &'a ParseSess, f: F) -> PResult<'a, T> where\n-    F: FnOnce(&mut Parser<'a>) -> PResult<'a, T>,\n-{\n-    let mut p = string_to_parser(&ps, s);\n-    let x = f(&mut p);\n-\n-    if ps.span_diagnostic.has_errors() || p.token != token::Eof {\n-        if let Err(mut e) = x {\n-            e.cancel();\n-        }\n-        return Err(p.fatal(\"parse error\"));\n-    }\n-\n-    x\n-}\n-\n-fn expr<'a>(s: &str, ps: &'a ParseSess) -> PResult<'a, P<ast::Expr>> {\n-    with_error_checking_parse(s.to_string(), ps, |p| {\n-        p.parse_expr()\n-    })\n-}\n-\n-fn stmt<'a>(s: &str, ps: &'a ParseSess) -> PResult<'a, ast::Stmt> {\n-    with_error_checking_parse(s.to_string(), ps, |p| {\n-        p.parse_stmt().map(|s| s.unwrap())\n-    })\n-}\n-\n-fn attr<'a>(s: &str, ps: &'a ParseSess) -> PResult<'a, ast::Attribute> {\n-    with_error_checking_parse(s.to_string(), ps, |p| {\n-        p.parse_attribute(true)\n-    })\n-}\n-\n-fn str_compare<T, F: Fn(&T) -> String>(e: &str, expected: &[T], actual: &[T], f: F) {\n-    let expected: Vec<_> = expected.iter().map(|e| f(e)).collect();\n-    let actual: Vec<_> = actual.iter().map(|e| f(e)).collect();\n-\n-    if expected != actual {\n-        panic!(\"parsed `{}` as {:?}, expected {:?}\", e, actual, expected);\n-    }\n-}\n-\n-fn sess() -> ParseSess {\n-    ParseSess::new(FilePathMapping::empty())\n-}\n-\n-fn check_expr_attrs(es: &str, expected: &[&str]) {\n-    let ps = sess();\n-    let e = expr(es, &ps).expect(\"parse error\");\n-    let actual = &e.attrs;\n-    str_compare(es,\n-                &expected.iter().map(|r| attr(r, &ps).unwrap()).collect::<Vec<_>>(),\n-                &actual,\n-                pprust::attribute_to_string);\n-}\n-\n-fn check_stmt_attrs(es: &str, expected: &[&str]) {\n-    let ps = sess();\n-    let e = stmt(es, &ps).expect(\"parse error\");\n-    let actual = e.kind.attrs();\n-    str_compare(es,\n-                &expected.iter().map(|r| attr(r, &ps).unwrap()).collect::<Vec<_>>(),\n-                actual,\n-                pprust::attribute_to_string);\n-}\n-\n-fn reject_expr_parse(es: &str) {\n-    let ps = sess();\n-    match expr(es, &ps) {\n-        Ok(_) => panic!(\"parser did not reject `{}`\", es),\n-        Err(mut e) => e.cancel(),\n-    };\n-}\n-\n-fn reject_stmt_parse(es: &str) {\n-    let ps = sess();\n-    match stmt(es, &ps) {\n-        Ok(_) => panic!(\"parser did not reject `{}`\", es),\n-        Err(mut e) => e.cancel(),\n-    };\n-}\n-\n-fn main() {\n-    syntax::with_default_globals(|| run());\n-}\n-\n-fn run() {\n-    let both = &[\"#[attr]\", \"#![attr]\"];\n-    let outer = &[\"#[attr]\"];\n-    let none = &[];\n-\n-    check_expr_attrs(\"#[attr] box 0\", outer);\n-    reject_expr_parse(\"box #![attr] 0\");\n-\n-    check_expr_attrs(\"#[attr] [#![attr]]\", both);\n-    check_expr_attrs(\"#[attr] [#![attr] 0]\", both);\n-    check_expr_attrs(\"#[attr] [#![attr] 0; 0]\", both);\n-    check_expr_attrs(\"#[attr] [#![attr] 0, 0, 0]\", both);\n-    reject_expr_parse(\"[#[attr]]\");\n-\n-    check_expr_attrs(\"#[attr] foo()\", outer);\n-    check_expr_attrs(\"#[attr] x.foo()\", outer);\n-    reject_expr_parse(\"foo#[attr]()\");\n-    reject_expr_parse(\"foo(#![attr])\");\n-    reject_expr_parse(\"x.foo(#![attr])\");\n-    reject_expr_parse(\"x.#[attr]foo()\");\n-    reject_expr_parse(\"x.#![attr]foo()\");\n-\n-    check_expr_attrs(\"#[attr] (#![attr])\", both);\n-    check_expr_attrs(\"#[attr] (#![attr] #[attr] 0,)\", both);\n-    check_expr_attrs(\"#[attr] (#![attr] #[attr] 0, 0)\", both);\n-\n-    check_expr_attrs(\"#[attr] 0 + #[attr] 0\", none);\n-    check_expr_attrs(\"#[attr] 0 / #[attr] 0\", none);\n-    check_expr_attrs(\"#[attr] 0 & #[attr] 0\", none);\n-    check_expr_attrs(\"#[attr] 0 % #[attr] 0\", none);\n-    check_expr_attrs(\"#[attr] (0 + 0)\", outer);\n-    reject_expr_parse(\"0 + #![attr] 0\");\n-\n-    check_expr_attrs(\"#[attr] !0\", outer);\n-    check_expr_attrs(\"#[attr] -0\", outer);\n-    reject_expr_parse(\"!#![attr] 0\");\n-    reject_expr_parse(\"-#![attr] 0\");\n-\n-    check_expr_attrs(\"#[attr] false\", outer);\n-    check_expr_attrs(\"#[attr] 0\", outer);\n-    check_expr_attrs(\"#[attr] 'c'\", outer);\n-\n-    check_expr_attrs(\"#[attr] x as Y\", none);\n-    check_expr_attrs(\"#[attr] (x as Y)\", outer);\n-    reject_expr_parse(\"x #![attr] as Y\");\n-\n-    reject_expr_parse(\"#[attr] if false {}\");\n-    reject_expr_parse(\"if false #[attr] {}\");\n-    reject_expr_parse(\"if false {#![attr]}\");\n-    reject_expr_parse(\"if false {} #[attr] else {}\");\n-    reject_expr_parse(\"if false {} else #[attr] {}\");\n-    reject_expr_parse(\"if false {} else {#![attr]}\");\n-    reject_expr_parse(\"if false {} else #[attr] if true {}\");\n-    reject_expr_parse(\"if false {} else if true #[attr] {}\");\n-    reject_expr_parse(\"if false {} else if true {#![attr]}\");\n-\n-    reject_expr_parse(\"#[attr] if let Some(false) = false {}\");\n-    reject_expr_parse(\"if let Some(false) = false #[attr] {}\");\n-    reject_expr_parse(\"if let Some(false) = false {#![attr]}\");\n-    reject_expr_parse(\"if let Some(false) = false {} #[attr] else {}\");\n-    reject_expr_parse(\"if let Some(false) = false {} else #[attr] {}\");\n-    reject_expr_parse(\"if let Some(false) = false {} else {#![attr]}\");\n-    reject_expr_parse(\"if let Some(false) = false {} else #[attr] if let Some(false) = true {}\");\n-    reject_expr_parse(\"if let Some(false) = false {} else if let Some(false) = true #[attr] {}\");\n-    reject_expr_parse(\"if let Some(false) = false {} else if let Some(false) = true {#![attr]}\");\n-\n-    check_expr_attrs(\"#[attr] while true {#![attr]}\", both);\n-\n-    check_expr_attrs(\"#[attr] while let Some(false) = true {#![attr]}\", both);\n-\n-    check_expr_attrs(\"#[attr] for x in y {#![attr]}\", both);\n-\n-    check_expr_attrs(\"#[attr] loop {#![attr]}\", both);\n-\n-    check_expr_attrs(\"#[attr] match true {#![attr] #[attr] _ => false}\", both);\n-\n-    check_expr_attrs(\"#[attr]      || #[attr] foo\", outer);\n-    check_expr_attrs(\"#[attr] move || #[attr] foo\", outer);\n-    check_expr_attrs(\"#[attr]      || #[attr] { #![attr] foo }\", outer);\n-    check_expr_attrs(\"#[attr] move || #[attr] { #![attr] foo }\", outer);\n-    check_expr_attrs(\"#[attr]      || { #![attr] foo }\", outer);\n-    check_expr_attrs(\"#[attr] move || { #![attr] foo }\", outer);\n-    reject_expr_parse(\"|| #![attr] foo\");\n-    reject_expr_parse(\"move || #![attr] foo\");\n-    reject_expr_parse(\"|| #![attr] {foo}\");\n-    reject_expr_parse(\"move || #![attr] {foo}\");\n-\n-    check_expr_attrs(\"#[attr] { #![attr] }\", both);\n-    check_expr_attrs(\"#[attr] { #![attr] let _ = (); }\", both);\n-    check_expr_attrs(\"#[attr] { #![attr] let _ = (); foo }\", both);\n-\n-    check_expr_attrs(\"#[attr] x = y\", none);\n-    check_expr_attrs(\"#[attr] (x = y)\", outer);\n-\n-    check_expr_attrs(\"#[attr] x += y\", none);\n-    check_expr_attrs(\"#[attr] (x += y)\", outer);\n-\n-    check_expr_attrs(\"#[attr] foo.bar\", outer);\n-    check_expr_attrs(\"(#[attr] foo).bar\", none);\n-\n-    check_expr_attrs(\"#[attr] foo.0\", outer);\n-    check_expr_attrs(\"(#[attr] foo).0\", none);\n-\n-    check_expr_attrs(\"#[attr] foo[bar]\", outer);\n-    check_expr_attrs(\"(#[attr] foo)[bar]\", none);\n-\n-    check_expr_attrs(\"#[attr] 0..#[attr] 0\", none);\n-    check_expr_attrs(\"#[attr] 0..\", none);\n-    reject_expr_parse(\"#[attr] ..#[attr] 0\");\n-    reject_expr_parse(\"#[attr] ..\");\n-\n-    check_expr_attrs(\"#[attr] (0..0)\", outer);\n-    check_expr_attrs(\"#[attr] (0..)\", outer);\n-    check_expr_attrs(\"#[attr] (..0)\", outer);\n-    check_expr_attrs(\"#[attr] (..)\", outer);\n-\n-    check_expr_attrs(\"#[attr] foo::bar::baz\", outer);\n-\n-    check_expr_attrs(\"#[attr] &0\", outer);\n-    check_expr_attrs(\"#[attr] &mut 0\", outer);\n-    check_expr_attrs(\"#[attr] & #[attr] 0\", outer);\n-    check_expr_attrs(\"#[attr] &mut #[attr] 0\", outer);\n-    reject_expr_parse(\"#[attr] &#![attr] 0\");\n-    reject_expr_parse(\"#[attr] &mut #![attr] 0\");\n-\n-    check_expr_attrs(\"#[attr] break\", outer);\n-    check_expr_attrs(\"#[attr] continue\", outer);\n-    check_expr_attrs(\"#[attr] return\", outer);\n-\n-    check_expr_attrs(\"#[attr] foo!()\", outer);\n-    check_expr_attrs(\"#[attr] foo!(#![attr])\", outer);\n-    check_expr_attrs(\"#[attr] foo![]\", outer);\n-    check_expr_attrs(\"#[attr] foo![#![attr]]\", outer);\n-    check_expr_attrs(\"#[attr] foo!{}\", outer);\n-    check_expr_attrs(\"#[attr] foo!{#![attr]}\", outer);\n-\n-    check_expr_attrs(\"#[attr] Foo { #![attr] bar: baz }\", both);\n-    check_expr_attrs(\"#[attr] Foo { #![attr] ..foo }\", both);\n-    check_expr_attrs(\"#[attr] Foo { #![attr] bar: baz, ..foo }\", both);\n-\n-    check_expr_attrs(\"#[attr] (#![attr] 0)\", both);\n-\n-    // Look at statements in their natural habitat...\n-    check_expr_attrs(\"{\n-        #[attr] let _ = 0;\n-        #[attr] 0;\n-        #[attr] foo!();\n-        #[attr] foo!{}\n-        #[attr] foo![];\n-    }\", none);\n-\n-    check_stmt_attrs(\"#[attr] let _ = 0\", outer);\n-    check_stmt_attrs(\"#[attr] 0\",         outer);\n-    check_stmt_attrs(\"#[attr] {#![attr]}\", both);\n-    check_stmt_attrs(\"#[attr] foo!()\",    outer);\n-    check_stmt_attrs(\"#[attr] foo![]\",    outer);\n-    check_stmt_attrs(\"#[attr] foo!{}\",    outer);\n-\n-    reject_stmt_parse(\"#[attr] #![attr] let _ = 0\");\n-    reject_stmt_parse(\"#[attr] #![attr] 0\");\n-    reject_stmt_parse(\"#[attr] #![attr] foo!()\");\n-    reject_stmt_parse(\"#[attr] #![attr] foo![]\");\n-    reject_stmt_parse(\"#[attr] #![attr] foo!{}\");\n-\n-    // FIXME: Allow attributes in pattern constexprs?\n-    // note: requires parens in patterns to allow disambiguation\n-\n-    reject_expr_parse(\"match 0 {\n-        0..=#[attr] 10 => ()\n-    }\");\n-    reject_expr_parse(\"match 0 {\n-        0..=#[attr] -10 => ()\n-    }\");\n-    reject_expr_parse(\"match 0 {\n-        0..=-#[attr] 10 => ()\n-    }\");\n-    reject_expr_parse(\"match 0 {\n-        0..=#[attr] FOO => ()\n-    }\");\n-\n-    // make sure we don't catch this bug again...\n-    reject_expr_parse(\"{\n-        fn foo() {\n-            #[attr];\n-        }\n-    }\");\n-    reject_expr_parse(\"{\n-        fn foo() {\n-            #[attr]\n-        }\n-    }\");\n-}"}, {"sha": "44421b077fa26eb2c0e75f664c07be4d45cbd76f", "filename": "src/test/ui/did_you_mean/issue-54109-and_instead_of_ampersands.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-54109-and_instead_of_ampersands.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-54109-and_instead_of_ampersands.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-54109-and_instead_of_ampersands.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -1,56 +1,57 @@\n+fn main() {}\n+\n fn test_and() {\n     let a = true;\n     let b = false;\n-    if a and b {\n-        //~^ ERROR expected `{`, found `and`\n+\n+    let _ = a and b; //~ ERROR `and` is not a logical operator\n+\n+    if a and b { //~ ERROR `and` is not a logical operator\n         println!(\"both\");\n     }\n+\n+    let _recovery_witness: () = 0; //~ ERROR mismatched types\n }\n \n fn test_or() {\n     let a = true;\n     let b = false;\n-    if a or b {\n-        //~^ ERROR expected `{`, found `or`\n+\n+    let _ = a or b; //~ ERROR `or` is not a logical operator\n+\n+    if a or b { //~ ERROR `or` is not a logical operator\n         println!(\"both\");\n     }\n }\n \n fn test_and_par() {\n     let a = true;\n     let b = false;\n-    if (a and b) {\n-        //~^ ERROR expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `and`\n+    if (a and b) {  //~ ERROR `and` is not a logical operator\n         println!(\"both\");\n     }\n }\n \n fn test_or_par() {\n     let a = true;\n     let b = false;\n-    if (a or b) {\n-        //~^ ERROR expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `or`\n+    if (a or b) {  //~ ERROR `or` is not a logical operator\n         println!(\"both\");\n     }\n }\n \n fn test_while_and() {\n     let a = true;\n     let b = false;\n-    while a and b {\n-        //~^ ERROR expected one of `!`, `.`, `::`, `?`, `{`, or an operator, found `and`\n+    while a and b {  //~ ERROR `and` is not a logical operator\n         println!(\"both\");\n     }\n }\n \n fn test_while_or() {\n     let a = true;\n     let b = false;\n-    while a or b {\n-        //~^ ERROR expected one of `!`, `.`, `::`, `?`, `{`, or an operator, found `or`\n+    while a or b { //~ ERROR `or` is not a logical operator\n         println!(\"both\");\n     }\n }\n-\n-fn main() {\n-}"}, {"sha": "528c62f501e0d1bf65bcad255050b235f1255559", "filename": "src/test/ui/did_you_mean/issue-54109-and_instead_of_ampersands.stderr", "status": "modified", "additions": 56, "deletions": 39, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-54109-and_instead_of_ampersands.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-54109-and_instead_of_ampersands.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-54109-and_instead_of_ampersands.stderr?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -1,58 +1,75 @@\n-error: expected `{`, found `and`\n-  --> $DIR/issue-54109-and_instead_of_ampersands.rs:4:10\n+error: `and` is not a logical operator\n+  --> $DIR/issue-54109-and_instead_of_ampersands.rs:7:15\n+   |\n+LL |     let _ = a and b;\n+   |               ^^^ help: use `&&` to perform logical conjunction\n+   |\n+   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n+\n+error: `and` is not a logical operator\n+  --> $DIR/issue-54109-and_instead_of_ampersands.rs:9:10\n    |\n LL |     if a and b {\n-   |     --   ^^^\n-   |     |    |\n-   |     |    expected `{`\n-   |     |    help: use `&&` instead of `and` for the boolean operator\n-   |     this `if` statement has a condition, but no block\n+   |          ^^^ help: use `&&` to perform logical conjunction\n+   |\n+   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n+\n+error: `or` is not a logical operator\n+  --> $DIR/issue-54109-and_instead_of_ampersands.rs:20:15\n+   |\n+LL |     let _ = a or b;\n+   |               ^^ help: use `||` to perform logical disjunction\n+   |\n+   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n \n-error: expected `{`, found `or`\n-  --> $DIR/issue-54109-and_instead_of_ampersands.rs:13:10\n+error: `or` is not a logical operator\n+  --> $DIR/issue-54109-and_instead_of_ampersands.rs:22:10\n    |\n LL |     if a or b {\n-   |     --   ^^\n-   |     |    |\n-   |     |    expected `{`\n-   |     |    help: use `||` instead of `or` for the boolean operator\n-   |     this `if` statement has a condition, but no block\n+   |          ^^ help: use `||` to perform logical disjunction\n+   |\n+   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n \n-error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `and`\n-  --> $DIR/issue-54109-and_instead_of_ampersands.rs:22:11\n+error: `and` is not a logical operator\n+  --> $DIR/issue-54109-and_instead_of_ampersands.rs:30:11\n    |\n LL |     if (a and b) {\n-   |           ^^^\n-   |           |\n-   |           expected one of 8 possible tokens\n-   |           help: use `&&` instead of `and` for the boolean operator\n+   |           ^^^ help: use `&&` to perform logical conjunction\n+   |\n+   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n \n-error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `or`\n-  --> $DIR/issue-54109-and_instead_of_ampersands.rs:31:11\n+error: `or` is not a logical operator\n+  --> $DIR/issue-54109-and_instead_of_ampersands.rs:38:11\n    |\n LL |     if (a or b) {\n-   |           ^^\n-   |           |\n-   |           expected one of 8 possible tokens\n-   |           help: use `||` instead of `or` for the boolean operator\n+   |           ^^ help: use `||` to perform logical disjunction\n+   |\n+   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n \n-error: expected one of `!`, `.`, `::`, `?`, `{`, or an operator, found `and`\n-  --> $DIR/issue-54109-and_instead_of_ampersands.rs:40:13\n+error: `and` is not a logical operator\n+  --> $DIR/issue-54109-and_instead_of_ampersands.rs:46:13\n    |\n LL |     while a and b {\n-   |             ^^^\n-   |             |\n-   |             expected one of `!`, `.`, `::`, `?`, `{`, or an operator\n-   |             help: use `&&` instead of `and` for the boolean operator\n+   |             ^^^ help: use `&&` to perform logical conjunction\n+   |\n+   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n \n-error: expected one of `!`, `.`, `::`, `?`, `{`, or an operator, found `or`\n-  --> $DIR/issue-54109-and_instead_of_ampersands.rs:49:13\n+error: `or` is not a logical operator\n+  --> $DIR/issue-54109-and_instead_of_ampersands.rs:54:13\n    |\n LL |     while a or b {\n-   |             ^^\n-   |             |\n-   |             expected one of `!`, `.`, `::`, `?`, `{`, or an operator\n-   |             help: use `||` instead of `or` for the boolean operator\n+   |             ^^ help: use `||` to perform logical disjunction\n+   |\n+   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-54109-and_instead_of_ampersands.rs:13:33\n+   |\n+LL |     let _recovery_witness: () = 0;\n+   |                            --   ^ expected `()`, found integer\n+   |                            |\n+   |                            expected due to this\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 9 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "e5ac59ae463010b1a6aff3c0cfc0886194055d4e", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad-2.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-2.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -0,0 +1,2 @@\n+#[cfg(FALSE)] fn e() { let _ = x.#![attr]foo(); }\n+//~^ ERROR unexpected token: `#`"}, {"sha": "ca1043250ba78521178b2ec789374d7b173cfed1", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad-2.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-2.stderr?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -0,0 +1,8 @@\n+error: unexpected token: `#`\n+  --> $DIR/attr-stmt-expr-attr-bad-2.rs:1:34\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = x.#![attr]foo(); }\n+   |                                  ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "7dc71af52f4d97b234d57ca37719be438d87298a", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad-3.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-3.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -0,0 +1,2 @@\n+#[cfg(FALSE)] fn e() { let _ = x.#[attr]foo(); }\n+//~^ ERROR unexpected token: `#`"}, {"sha": "ab9366d042a2c1acae5ed5e2778c0b931126760e", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad-3.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad-3.stderr?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -0,0 +1,8 @@\n+error: unexpected token: `#`\n+  --> $DIR/attr-stmt-expr-attr-bad-3.rs:1:34\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = x.#[attr]foo(); }\n+   |                                  ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "ef10010ed0e617c7bd14d4b5aff7baca6e193455", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -0,0 +1,107 @@\n+fn main() {}\n+\n+#[cfg(FALSE)] fn e() { let _ = box #![attr] 0; }\n+//~^ ERROR an inner attribute is not permitted in this context\n+#[cfg(FALSE)] fn e() { let _ = [#[attr]]; }\n+//~^ ERROR expected expression, found `]`\n+#[cfg(FALSE)] fn e() { let _ = foo#[attr](); }\n+//~^ ERROR expected one of\n+#[cfg(FALSE)] fn e() { let _ = foo(#![attr]); }\n+//~^ ERROR an inner attribute is not permitted in this context\n+//~| ERROR expected expression, found `)`\n+#[cfg(FALSE)] fn e() { let _ = x.foo(#![attr]); }\n+//~^ ERROR an inner attribute is not permitted in this context\n+//~| ERROR expected expression, found `)`\n+#[cfg(FALSE)] fn e() { let _ = 0 + #![attr] 0; }\n+//~^ ERROR an inner attribute is not permitted in this context\n+#[cfg(FALSE)] fn e() { let _ = !#![attr] 0; }\n+//~^ ERROR an inner attribute is not permitted in this context\n+#[cfg(FALSE)] fn e() { let _ = -#![attr] 0; }\n+//~^ ERROR an inner attribute is not permitted in this context\n+#[cfg(FALSE)] fn e() { let _ = x #![attr] as Y; }\n+//~^ ERROR expected one of\n+#[cfg(FALSE)] fn e() { let _ = || #![attr] foo; }\n+//~^ ERROR an inner attribute is not permitted in this context\n+#[cfg(FALSE)] fn e() { let _ = move || #![attr] foo; }\n+//~^ ERROR an inner attribute is not permitted in this context\n+#[cfg(FALSE)] fn e() { let _ = || #![attr] {foo}; }\n+//~^ ERROR an inner attribute is not permitted in this context\n+#[cfg(FALSE)] fn e() { let _ = move || #![attr] {foo}; }\n+//~^ ERROR an inner attribute is not permitted in this context\n+#[cfg(FALSE)] fn e() { let _ = #[attr] ..#[attr] 0; }\n+//~^ ERROR expected expression, found `..`\n+#[cfg(FALSE)] fn e() { let _ = #[attr] ..; }\n+//~^ ERROR expected expression, found `..`\n+#[cfg(FALSE)] fn e() { let _ = #[attr] &#![attr] 0; }\n+//~^ ERROR an inner attribute is not permitted in this context\n+#[cfg(FALSE)] fn e() { let _ = #[attr] &mut #![attr] 0; }\n+//~^ ERROR an inner attribute is not permitted in this context\n+#[cfg(FALSE)] fn e() { let _ = #[attr] if 0 {}; }\n+//~^ ERROR attributes are not yet allowed on `if` expressions\n+#[cfg(FALSE)] fn e() { let _ = if 0 #[attr] {}; }\n+//~^ ERROR expected `{`, found `#`\n+#[cfg(FALSE)] fn e() { let _ = if 0 {#![attr]}; }\n+//~^ ERROR an inner attribute is not permitted in this context\n+#[cfg(FALSE)] fn e() { let _ = if 0 {} #[attr] else {}; }\n+//~^ ERROR expected one of\n+#[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] {}; }\n+//~^ ERROR expected `{`, found `#`\n+#[cfg(FALSE)] fn e() { let _ = if 0 {} else {#![attr]}; }\n+//~^ ERROR an inner attribute is not permitted in this context\n+#[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] if 0 {}; }\n+//~^ ERROR attributes are not yet allowed on `if` expressions\n+//~| ERROR expected `{`, found `#`\n+#[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 #[attr] {}; }\n+//~^ ERROR expected `{`, found `#`\n+#[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 {#![attr]}; }\n+//~^ ERROR an inner attribute is not permitted in this context\n+#[cfg(FALSE)] fn e() { let _ = #[attr] if let _ = 0 {}; }\n+//~^ ERROR attributes are not yet allowed on `if` expressions\n+#[cfg(FALSE)] fn e() { let _ = if let _ = 0 #[attr] {}; }\n+//~^ ERROR expected `{`, found `#`\n+#[cfg(FALSE)] fn e() { let _ = if let _ = 0 {#![attr]}; }\n+//~^ ERROR an inner attribute is not permitted in this context\n+#[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} #[attr] else {}; }\n+//~^ ERROR expected one of\n+#[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] {}; }\n+//~^ ERROR expected `{`, found `#`\n+#[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else {#![attr]}; }\n+//~^ ERROR an inner attribute is not permitted in this context\n+#[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] if let _ = 0 {}; }\n+//~^ ERROR attributes are not yet allowed on `if` expressions\n+//~| ERROR expected `{`, found `#`\n+#[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 #[attr] {}; }\n+//~^ ERROR expected `{`, found `#`\n+#[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 {#![attr]}; }\n+//~^ ERROR an inner attribute is not permitted in this context\n+\n+#[cfg(FALSE)] fn s() { #[attr] #![attr] let _ = 0; }\n+//~^ ERROR an inner attribute is not permitted following an outer attribute\n+#[cfg(FALSE)] fn s() { #[attr] #![attr] 0; }\n+//~^ ERROR an inner attribute is not permitted following an outer attribute\n+#[cfg(FALSE)] fn s() { #[attr] #![attr] foo!(); }\n+//~^ ERROR an inner attribute is not permitted following an outer attribute\n+#[cfg(FALSE)] fn s() { #[attr] #![attr] foo![]; }\n+//~^ ERROR an inner attribute is not permitted following an outer attribute\n+#[cfg(FALSE)] fn s() { #[attr] #![attr] foo!{}; }\n+//~^ ERROR an inner attribute is not permitted following an outer attribute\n+\n+// FIXME: Allow attributes in pattern constexprs?\n+// note: requires parens in patterns to allow disambiguation\n+\n+#[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] 10 => () } }\n+//~^ ERROR `X..=` range patterns are not supported\n+//~| ERROR expected one of `=>`, `if`, or `|`, found `#`\n+#[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] -10 => () } }\n+//~^ ERROR `X..=` range patterns are not supported\n+//~| ERROR expected one of `=>`, `if`, or `|`, found `#`\n+#[cfg(FALSE)] fn e() { match 0 { 0..=-#[attr] 10 => () } }\n+//~^ ERROR unexpected token: `#`\n+#[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] FOO => () } }\n+//~^ ERROR `X..=` range patterns are not supported\n+//~| ERROR expected one of `=>`, `if`, or `|`, found `#`\n+\n+// make sure we don't catch this bug again...\n+#[cfg(FALSE)] fn e() { { fn foo() { #[attr]; } } }\n+//~^ ERROR expected statement after outer attribute\n+#[cfg(FALSE)] fn e() { { fn foo() { #[attr] } } }"}, {"sha": "9a0d3176714faf9f3e5a708083c254a35f53ad45", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad.stderr", "status": "added", "additions": 390, "deletions": 0, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -0,0 +1,390 @@\n+error: an inner attribute is not permitted in this context\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:3:36\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = box #![attr] 0; }\n+   |                                    ^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: expected expression, found `]`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:5:40\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = [#[attr]]; }\n+   |                                        ^ expected expression\n+\n+error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, or an operator, found `#`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:7:35\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = foo#[attr](); }\n+   |                                   ^ expected one of 7 possible tokens\n+\n+error: an inner attribute is not permitted in this context\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:9:36\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = foo(#![attr]); }\n+   |                                    ^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: expected expression, found `)`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:9:44\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = foo(#![attr]); }\n+   |                                            ^ expected expression\n+\n+error: an inner attribute is not permitted in this context\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:12:38\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = x.foo(#![attr]); }\n+   |                                      ^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: expected expression, found `)`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:12:46\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = x.foo(#![attr]); }\n+   |                                              ^ expected expression\n+\n+error: an inner attribute is not permitted in this context\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:15:36\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = 0 + #![attr] 0; }\n+   |                                    ^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: an inner attribute is not permitted in this context\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:17:33\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = !#![attr] 0; }\n+   |                                 ^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: an inner attribute is not permitted in this context\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:19:33\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = -#![attr] 0; }\n+   |                                 ^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, or an operator, found `#`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:21:34\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = x #![attr] as Y; }\n+   |                                  ^ expected one of 7 possible tokens\n+\n+error: an inner attribute is not permitted in this context\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:23:35\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = || #![attr] foo; }\n+   |                                   ^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: an inner attribute is not permitted in this context\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:25:40\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = move || #![attr] foo; }\n+   |                                        ^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: an inner attribute is not permitted in this context\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:27:35\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = || #![attr] {foo}; }\n+   |                                   ^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: an inner attribute is not permitted in this context\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:29:40\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = move || #![attr] {foo}; }\n+   |                                        ^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: expected expression, found `..`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:31:40\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = #[attr] ..#[attr] 0; }\n+   |                                        ^^ expected expression\n+\n+error: expected expression, found `..`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:33:40\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = #[attr] ..; }\n+   |                                        ^^ expected expression\n+\n+error: an inner attribute is not permitted in this context\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:35:41\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = #[attr] &#![attr] 0; }\n+   |                                         ^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: an inner attribute is not permitted in this context\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:37:45\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = #[attr] &mut #![attr] 0; }\n+   |                                             ^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: attributes are not yet allowed on `if` expressions\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:39:32\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = #[attr] if 0 {}; }\n+   |                                ^^^^^^^\n+\n+error: expected `{`, found `#`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:41:37\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = if 0 #[attr] {}; }\n+   |                                --   ^       --- help: try placing this code inside a block: `{ {}; }`\n+   |                                |    |\n+   |                                |    expected `{`\n+   |                                this `if` statement has a condition, but no block\n+\n+error: an inner attribute is not permitted in this context\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:43:38\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = if 0 {#![attr]}; }\n+   |                                      ^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `#`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:45:40\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} #[attr] else {}; }\n+   |                                        ^ expected one of `.`, `;`, `?`, `else`, or an operator\n+\n+error: expected `{`, found `#`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:47:45\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] {}; }\n+   |                                             ^       --- help: try placing this code inside a block: `{ {}; }`\n+   |                                             |\n+   |                                             expected `{`\n+\n+error: an inner attribute is not permitted in this context\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:49:46\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else {#![attr]}; }\n+   |                                              ^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: attributes are not yet allowed on `if` expressions\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:51:45\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] if 0 {}; }\n+   |                                             ^^^^^^^\n+\n+error: expected `{`, found `#`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:51:45\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] if 0 {}; }\n+   |                                             ^       -------- help: try placing this code inside a block: `{ if 0 {}; }`\n+   |                                             |\n+   |                                             expected `{`\n+\n+error: expected `{`, found `#`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:54:50\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 #[attr] {}; }\n+   |                                             --   ^       --- help: try placing this code inside a block: `{ {}; }`\n+   |                                             |    |\n+   |                                             |    expected `{`\n+   |                                             this `if` statement has a condition, but no block\n+\n+error: an inner attribute is not permitted in this context\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:56:51\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 {#![attr]}; }\n+   |                                                   ^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: attributes are not yet allowed on `if` expressions\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:58:32\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = #[attr] if let _ = 0 {}; }\n+   |                                ^^^^^^^\n+\n+error: expected `{`, found `#`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:60:45\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 #[attr] {}; }\n+   |                                --           ^       --- help: try placing this code inside a block: `{ {}; }`\n+   |                                |            |\n+   |                                |            expected `{`\n+   |                                this `if` statement has a condition, but no block\n+\n+error: an inner attribute is not permitted in this context\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:62:46\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {#![attr]}; }\n+   |                                              ^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `#`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:64:48\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} #[attr] else {}; }\n+   |                                                ^ expected one of `.`, `;`, `?`, `else`, or an operator\n+\n+error: expected `{`, found `#`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:66:53\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] {}; }\n+   |                                                     ^       --- help: try placing this code inside a block: `{ {}; }`\n+   |                                                     |\n+   |                                                     expected `{`\n+\n+error: an inner attribute is not permitted in this context\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:68:54\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else {#![attr]}; }\n+   |                                                      ^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: attributes are not yet allowed on `if` expressions\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:70:53\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] if let _ = 0 {}; }\n+   |                                                     ^^^^^^^\n+\n+error: expected `{`, found `#`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:70:53\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] if let _ = 0 {}; }\n+   |                                                     ^       ---------------- help: try placing this code inside a block: `{ if let _ = 0 {}; }`\n+   |                                                     |\n+   |                                                     expected `{`\n+\n+error: expected `{`, found `#`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:73:66\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 #[attr] {}; }\n+   |                                                     --           ^       --- help: try placing this code inside a block: `{ {}; }`\n+   |                                                     |            |\n+   |                                                     |            expected `{`\n+   |                                                     this `if` statement has a condition, but no block\n+\n+error: an inner attribute is not permitted in this context\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:75:67\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 {#![attr]}; }\n+   |                                                                   ^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: an inner attribute is not permitted following an outer attribute\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:78:32\n+   |\n+LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] let _ = 0; }\n+   |                        ------- ^^^^^^^^ not permitted following an outer attibute\n+   |                        |\n+   |                        previous outer attribute\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: an inner attribute is not permitted following an outer attribute\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:80:32\n+   |\n+LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] 0; }\n+   |                        ------- ^^^^^^^^ not permitted following an outer attibute\n+   |                        |\n+   |                        previous outer attribute\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: an inner attribute is not permitted following an outer attribute\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:82:32\n+   |\n+LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo!(); }\n+   |                        ------- ^^^^^^^^ not permitted following an outer attibute\n+   |                        |\n+   |                        previous outer attribute\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: an inner attribute is not permitted following an outer attribute\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:84:32\n+   |\n+LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo![]; }\n+   |                        ------- ^^^^^^^^ not permitted following an outer attibute\n+   |                        |\n+   |                        previous outer attribute\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: an inner attribute is not permitted following an outer attribute\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:86:32\n+   |\n+LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo!{}; }\n+   |                        ------- ^^^^^^^^ not permitted following an outer attibute\n+   |                        |\n+   |                        previous outer attribute\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: `X..=` range patterns are not supported\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:92:34\n+   |\n+LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] 10 => () } }\n+   |                                  ^^^^ help: try using the maximum value for the type: `0..=MAX`\n+\n+error: expected one of `=>`, `if`, or `|`, found `#`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:92:38\n+   |\n+LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] 10 => () } }\n+   |                                      ^ expected one of `=>`, `if`, or `|`\n+\n+error: `X..=` range patterns are not supported\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:95:34\n+   |\n+LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] -10 => () } }\n+   |                                  ^^^^ help: try using the maximum value for the type: `0..=MAX`\n+\n+error: expected one of `=>`, `if`, or `|`, found `#`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:95:38\n+   |\n+LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] -10 => () } }\n+   |                                      ^ expected one of `=>`, `if`, or `|`\n+\n+error: unexpected token: `#`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:98:39\n+   |\n+LL | #[cfg(FALSE)] fn e() { match 0 { 0..=-#[attr] 10 => () } }\n+   |                                       ^\n+\n+error: `X..=` range patterns are not supported\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:100:34\n+   |\n+LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] FOO => () } }\n+   |                                  ^^^^ help: try using the maximum value for the type: `0..=MAX`\n+\n+error: expected one of `=>`, `if`, or `|`, found `#`\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:100:38\n+   |\n+LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] FOO => () } }\n+   |                                      ^ expected one of `=>`, `if`, or `|`\n+\n+error: expected statement after outer attribute\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:105:44\n+   |\n+LL | #[cfg(FALSE)] fn e() { { fn foo() { #[attr]; } } }\n+   |                                            ^\n+\n+error: aborting due to 52 previous errors\n+"}, {"sha": "f64568d06e96d00e3d7e6fe05e99d5b8e127ccb9", "filename": "src/test/ui/parser/do-catch-suggests-try.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fdo-catch-suggests-try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fdo-catch-suggests-try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdo-catch-suggests-try.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -1,5 +1,10 @@\n+#![feature(try_blocks)]\n+\n fn main() {\n     let _: Option<()> = do catch {};\n     //~^ ERROR found removed `do catch` syntax\n-    //~^^ HELP following RFC #2388, the new non-placeholder syntax is `try`\n+    //~| replace with the new syntax\n+    //~| following RFC #2388, the new non-placeholder syntax is `try`\n+\n+    let _recovery_witness: () = 1; //~ ERROR mismatched types\n }"}, {"sha": "cd8907b7eac9a6f1e8dd1060e2e589c3ae341566", "filename": "src/test/ui/parser/do-catch-suggests-try.stderr", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fdo-catch-suggests-try.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fdo-catch-suggests-try.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdo-catch-suggests-try.stderr?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -1,10 +1,19 @@\n error: found removed `do catch` syntax\n-  --> $DIR/do-catch-suggests-try.rs:2:25\n+  --> $DIR/do-catch-suggests-try.rs:4:25\n    |\n LL |     let _: Option<()> = do catch {};\n-   |                         ^^\n+   |                         ^^^^^^^^ help: replace with the new syntax: `try`\n    |\n-   = help: following RFC #2388, the new non-placeholder syntax is `try`\n+   = note: following RFC #2388, the new non-placeholder syntax is `try`\n \n-error: aborting due to previous error\n+error[E0308]: mismatched types\n+  --> $DIR/do-catch-suggests-try.rs:9:33\n+   |\n+LL |     let _recovery_witness: () = 1;\n+   |                            --   ^ expected `()`, found integer\n+   |                            |\n+   |                            expected due to this\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "c1826f8caae075afb48aae7dd02894bfab44f365", "filename": "src/test/ui/parser/issue-65257-invalid-var-decl-recovery.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fissue-65257-invalid-var-decl-recovery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fissue-65257-invalid-var-decl-recovery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-65257-invalid-var-decl-recovery.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -0,0 +1,21 @@\n+fn main() {\n+    auto n = 0;//~ ERROR invalid variable declaration\n+    //~^ HELP write `let` instead of `auto` to introduce a new variable\n+    auto m;//~ ERROR invalid variable declaration\n+    //~^ HELP write `let` instead of `auto` to introduce a new variable\n+    m = 0;\n+\n+    var n = 0;//~ ERROR invalid variable declaration\n+    //~^ HELP write `let` instead of `var` to introduce a new variable\n+    var m;//~ ERROR invalid variable declaration\n+    //~^ HELP write `let` instead of `var` to introduce a new variable\n+    m = 0;\n+\n+    mut n = 0;//~ ERROR invalid variable declaration\n+    //~^ HELP missing keyword\n+    mut var;//~ ERROR invalid variable declaration\n+    //~^ HELP missing keyword\n+    var = 0;\n+\n+    let _recovery_witness: () = 0; //~ ERROR mismatched types\n+}"}, {"sha": "ad72dd30542c0c91d0d0b48ec717a56cc7bad754", "filename": "src/test/ui/parser/issue-65257-invalid-var-decl-recovery.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fissue-65257-invalid-var-decl-recovery.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fissue-65257-invalid-var-decl-recovery.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-65257-invalid-var-decl-recovery.stderr?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -0,0 +1,67 @@\n+error: invalid variable declaration\n+  --> $DIR/issue-65257-invalid-var-decl-recovery.rs:2:5\n+   |\n+LL |     auto n = 0;\n+   |     ^^^^\n+   |\n+help: write `let` instead of `auto` to introduce a new variable\n+   |\n+LL |     let n = 0;\n+   |     ^^^\n+\n+error: invalid variable declaration\n+  --> $DIR/issue-65257-invalid-var-decl-recovery.rs:4:5\n+   |\n+LL |     auto m;\n+   |     ^^^^\n+   |\n+help: write `let` instead of `auto` to introduce a new variable\n+   |\n+LL |     let m;\n+   |     ^^^\n+\n+error: invalid variable declaration\n+  --> $DIR/issue-65257-invalid-var-decl-recovery.rs:8:5\n+   |\n+LL |     var n = 0;\n+   |     ^^^\n+   |\n+help: write `let` instead of `var` to introduce a new variable\n+   |\n+LL |     let n = 0;\n+   |     ^^^\n+\n+error: invalid variable declaration\n+  --> $DIR/issue-65257-invalid-var-decl-recovery.rs:10:5\n+   |\n+LL |     var m;\n+   |     ^^^\n+   |\n+help: write `let` instead of `var` to introduce a new variable\n+   |\n+LL |     let m;\n+   |     ^^^\n+\n+error: invalid variable declaration\n+  --> $DIR/issue-65257-invalid-var-decl-recovery.rs:14:5\n+   |\n+LL |     mut n = 0;\n+   |     ^^^ help: missing keyword: `let mut`\n+\n+error: invalid variable declaration\n+  --> $DIR/issue-65257-invalid-var-decl-recovery.rs:16:5\n+   |\n+LL |     mut var;\n+   |     ^^^ help: missing keyword: `let mut`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-65257-invalid-var-decl-recovery.rs:20:33\n+   |\n+LL |     let _recovery_witness: () = 0;\n+   |                            --   ^ expected `()`, found integer\n+   |                            |\n+   |                            expected due to this\n+\n+error: aborting due to 7 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "be92170acf02736796983bb9eb16f310f1f70c8b", "filename": "src/test/ui/parser/recover-labeled-non-block-expr.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    'label: 1 + 1; //~ ERROR expected `while`, `for`, `loop` or `{` after a label\n+\n+    let _recovery_witness: () = 0; //~ ERROR mismatched types\n+}"}, {"sha": "771a915288c566a73dd080d58b30cd515e3c7af7", "filename": "src/test/ui/parser/recover-labeled-non-block-expr.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-labeled-non-block-expr.stderr?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -0,0 +1,17 @@\n+error: expected `while`, `for`, `loop` or `{` after a label\n+  --> $DIR/recover-labeled-non-block-expr.rs:2:13\n+   |\n+LL |     'label: 1 + 1;\n+   |             ^ expected `while`, `for`, `loop` or `{` after a label\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-labeled-non-block-expr.rs:4:33\n+   |\n+LL |     let _recovery_witness: () = 0;\n+   |                            --   ^ expected `()`, found integer\n+   |                            |\n+   |                            expected due to this\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "0d1f5be7b4930524cf00dece81f9a8dda4efb023", "filename": "src/test/ui/parser/recovery-attr-on-if.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Frecovery-attr-on-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Frecovery-attr-on-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecovery-attr-on-if.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    #[attr] if true {};\n+    //~^ ERROR cannot find attribute\n+    //~| ERROR attributes are not yet allowed on `if` expressions\n+    #[attr] if true {};\n+    //~^ ERROR cannot find attribute\n+    //~| ERROR attributes are not yet allowed on `if` expressions\n+    let _recovery_witness: () = 0; //~ ERROR mismatched types\n+}"}, {"sha": "a02846827c9ab34072d1c86f0d5177df634c4217", "filename": "src/test/ui/parser/recovery-attr-on-if.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Frecovery-attr-on-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Frecovery-attr-on-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecovery-attr-on-if.stderr?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -0,0 +1,35 @@\n+error: attributes are not yet allowed on `if` expressions\n+  --> $DIR/recovery-attr-on-if.rs:2:5\n+   |\n+LL |     #[attr] if true {};\n+   |     ^^^^^^^\n+\n+error: attributes are not yet allowed on `if` expressions\n+  --> $DIR/recovery-attr-on-if.rs:5:5\n+   |\n+LL |     #[attr] if true {};\n+   |     ^^^^^^^\n+\n+error: cannot find attribute `attr` in this scope\n+  --> $DIR/recovery-attr-on-if.rs:5:7\n+   |\n+LL |     #[attr] if true {};\n+   |       ^^^^\n+\n+error: cannot find attribute `attr` in this scope\n+  --> $DIR/recovery-attr-on-if.rs:2:7\n+   |\n+LL |     #[attr] if true {};\n+   |       ^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recovery-attr-on-if.rs:8:33\n+   |\n+LL |     let _recovery_witness: () = 0;\n+   |                            --   ^ expected `()`, found integer\n+   |                            |\n+   |                            expected due to this\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "b8a794f4b92fa621127ebb831452ad287748aa8e", "filename": "src/test/ui/parser/stmt_expr_attrs_placement.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fstmt_expr_attrs_placement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fstmt_expr_attrs_placement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstmt_expr_attrs_placement.rs?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -0,0 +1,22 @@\n+#![feature(stmt_expr_attributes)]\n+\n+// Test that various placements of the inner attribute are parsed correctly,\n+// or not.\n+\n+fn main() {\n+    let a = #![allow(warnings)] (1, 2);\n+    //~^ ERROR an inner attribute is not permitted in this context\n+\n+    let b = (#![allow(warnings)] 1, 2);\n+\n+    let c = {\n+        #![allow(warnings)]\n+        (#![allow(warnings)] 1, 2)\n+    };\n+\n+    let d = {\n+        #![allow(warnings)]\n+        let e = (#![allow(warnings)] 1, 2);\n+        e\n+    };\n+}"}, {"sha": "1886a0f9ba0baa98fd8c2fbba8a5fb9966066a0f", "filename": "src/test/ui/parser/stmt_expr_attrs_placement.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fstmt_expr_attrs_placement.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06/src%2Ftest%2Fui%2Fparser%2Fstmt_expr_attrs_placement.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstmt_expr_attrs_placement.stderr?ref=c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "patch": "@@ -0,0 +1,10 @@\n+error: an inner attribute is not permitted in this context\n+  --> $DIR/stmt_expr_attrs_placement.rs:7:13\n+   |\n+LL |     let a = #![allow(warnings)] (1, 2);\n+   |             ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files. Outer attributes, like `#[test]`, annotate the item following them.\n+\n+error: aborting due to previous error\n+"}]}