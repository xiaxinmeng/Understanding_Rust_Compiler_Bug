{"sha": "7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiZGY3ZDA5YjAzZjg2NjRlMDJjZDFkODA5NzJlYTdiMWM5NmE0ZDU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-06-11T22:05:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-11T22:05:33Z"}, "message": "Rollup merge of #73195 - ayazhafiz:i/73145, r=estebank\n\nProvide suggestion to convert numeric op LHS rather than unwrapping RHS\n\nGiven a code\n\n```rust\nfn foo(x: u8, y: u32) -> bool {\n    x > y\n}\nfn main() {}\n```\n\nit could be more helpful to provide a suggestion to do \"u32::from(x)\"\nrather than \"y.try_into().unwrap()\", since the latter may panic.\n\nWe do this by passing the LHS of a binary expression up the stack into\nthe coercion checker.\n\nCloses #73145", "tree": {"sha": "c0b775c88d0eed84610bb103971e9fe10bbf7eed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0b775c88d0eed84610bb103971e9fe10bbf7eed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe4qqtCRBK7hj4Ov3rIwAAdHIIAB0IryitGpVBZZvgbnMBkBWK\nVpl3JCR47BMTfqOBr7hde54l3jZspM5cY67ELZdTM4PSxhSgFM75Ax+fs5WsTXwC\nTwaaNx+QgH2mPl7EF1STb4dfPDQZmf31goh6U/InRDgTCo13b2fT45P9N2ATFHyH\nRKI+gerR09ToE42OD2NwvGPA/dWe9gCjZ+y1TpSLJXARgkFQQrmeeVm4vSHWVLIQ\n3hU7PY9n8pWEIhrkriWxT6yZdqljdIhs7iIcjV86aOSky9GFOeN/nUo4Li3GeEAc\nyHdmhfgFpiE2cy4bAm5OBCGoAFfNBF0DQahYdWv6kdm4Eq0xV3Bma3vZiXQKQHs=\n=3v9j\n-----END PGP SIGNATURE-----\n", "payload": "tree c0b775c88d0eed84610bb103971e9fe10bbf7eed\nparent 838d25b5e3cfabce609d9b9cb22653c4961d94b7\nparent 0c02f8aea9d8b26ad0e02a8ba1333a794844e146\nauthor Dylan DPC <dylan.dpc@gmail.com> 1591913133 +0200\ncommitter GitHub <noreply@github.com> 1591913133 +0200\n\nRollup merge of #73195 - ayazhafiz:i/73145, r=estebank\n\nProvide suggestion to convert numeric op LHS rather than unwrapping RHS\n\nGiven a code\n\n```rust\nfn foo(x: u8, y: u32) -> bool {\n    x > y\n}\nfn main() {}\n```\n\nit could be more helpful to provide a suggestion to do \"u32::from(x)\"\nrather than \"y.try_into().unwrap()\", since the latter may panic.\n\nWe do this by passing the LHS of a binary expression up the stack into\nthe coercion checker.\n\nCloses #73145\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5", "html_url": "https://github.com/rust-lang/rust/commit/7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "838d25b5e3cfabce609d9b9cb22653c4961d94b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/838d25b5e3cfabce609d9b9cb22653c4961d94b7", "html_url": "https://github.com/rust-lang/rust/commit/838d25b5e3cfabce609d9b9cb22653c4961d94b7"}, {"sha": "0c02f8aea9d8b26ad0e02a8ba1333a794844e146", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c02f8aea9d8b26ad0e02a8ba1333a794844e146", "html_url": "https://github.com/rust-lang/rust/commit/0c02f8aea9d8b26ad0e02a8ba1333a794844e146"}], "stats": {"total": 2176, "additions": 2126, "deletions": 50}, "files": [{"sha": "96c0d98ab0618d7d19f71a9bc69277646d9f74cc", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5", "patch": "@@ -1377,7 +1377,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 }\n \n                 if let Some(expr) = expression {\n-                    fcx.emit_coerce_suggestions(&mut err, expr, found, expected);\n+                    fcx.emit_coerce_suggestions(&mut err, expr, found, expected, None);\n                 }\n \n                 // Error possibly reported in `check_assign` so avoid emitting error again."}, {"sha": "019b4ca66060c295c6b799e4e0e79dffc7790f37", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 79, "deletions": 30, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5", "patch": "@@ -24,10 +24,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         expr_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) {\n         self.annotate_expected_due_to_let_ty(err, expr);\n         self.suggest_compatible_variants(err, expr, expected, expr_ty);\n-        self.suggest_deref_ref_or_into(err, expr, expected, expr_ty);\n+        self.suggest_deref_ref_or_into(err, expr, expected, expr_ty, expected_ty_expr);\n         if self.suggest_calling_boxed_future_when_appropriate(err, expr, expected, expr_ty) {\n             return;\n         }\n@@ -102,9 +103,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n         allow_two_phase: AllowTwoPhase,\n     ) -> Ty<'tcx> {\n-        let (ty, err) = self.demand_coerce_diag(expr, checked_ty, expected, allow_two_phase);\n+        let (ty, err) =\n+            self.demand_coerce_diag(expr, checked_ty, expected, expected_ty_expr, allow_two_phase);\n         if let Some(mut err) = err {\n             err.emit();\n         }\n@@ -121,6 +124,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n         allow_two_phase: AllowTwoPhase,\n     ) -> (Ty<'tcx>, Option<DiagnosticBuilder<'tcx>>) {\n         let expected = self.resolve_vars_with_obligations(expected);\n@@ -141,7 +145,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return (expected, None);\n         }\n \n-        self.emit_coerce_suggestions(&mut err, expr, expr_ty, expected);\n+        self.emit_coerce_suggestions(&mut err, expr, expr_ty, expected, expected_ty_expr);\n \n         (expected, Some(err))\n     }\n@@ -671,6 +675,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) -> bool {\n         if self.tcx.sess.source_map().is_imported(expr.span) {\n             // Ignore if span is from within a macro.\n@@ -747,7 +752,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let msg = format!(\"you can convert an `{}` to `{}`\", checked_ty, expected_ty);\n         let cast_msg = format!(\"you can cast an `{} to `{}`\", checked_ty, expected_ty);\n-        let try_msg = format!(\"{} and panic if the converted value wouldn't fit\", msg);\n         let lit_msg = format!(\n             \"change the type of the numeric literal from `{}` to `{}`\",\n             checked_ty, expected_ty,\n@@ -761,7 +765,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n \n         let cast_suggestion = format!(\"{}{} as {}\", prefix, with_opt_paren(&src), expected_ty);\n-        let try_into_suggestion = format!(\"{}{}.try_into().unwrap()\", prefix, with_opt_paren(&src));\n         let into_suggestion = format!(\"{}{}.into()\", prefix, with_opt_paren(&src));\n         let suffix_suggestion = with_opt_paren(&format_args!(\n             \"{}{}\",\n@@ -782,22 +785,55 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         let in_const_context = self.tcx.hir().is_inside_const_context(expr.hir_id);\n+\n+        let suggest_fallible_into_or_lhs_from =\n+            |err: &mut DiagnosticBuilder<'_>, exp_to_found_is_fallible: bool| {\n+                // If we know the expression the expected type is derived from, we might be able\n+                // to suggest a widening conversion rather than a narrowing one (which may\n+                // panic). For example, given x: u8 and y: u32, if we know the span of \"x\",\n+                //   x > y\n+                // can be given the suggestion \"u32::from(x) > y\" rather than\n+                // \"x > y.try_into().unwrap()\".\n+                let lhs_expr_and_src = expected_ty_expr.and_then(|expr| {\n+                    match self.tcx.sess.source_map().span_to_snippet(expr.span).ok() {\n+                        Some(src) => Some((expr, src)),\n+                        None => None,\n+                    }\n+                });\n+                let (span, msg, suggestion) = if let (Some((lhs_expr, lhs_src)), false) =\n+                    (lhs_expr_and_src, exp_to_found_is_fallible)\n+                {\n+                    let msg = format!(\n+                        \"you can convert `{}` from `{}` to `{}`, matching the type of `{}`\",\n+                        lhs_src, expected_ty, checked_ty, src\n+                    );\n+                    let suggestion = format!(\"{}::from({})\", checked_ty, lhs_src,);\n+                    (lhs_expr.span, msg, suggestion)\n+                } else {\n+                    let msg = format!(\"{} and panic if the converted value wouldn't fit\", msg);\n+                    let suggestion =\n+                        format!(\"{}{}.try_into().unwrap()\", prefix, with_opt_paren(&src));\n+                    (expr.span, msg, suggestion)\n+                };\n+                err.span_suggestion(span, &msg, suggestion, Applicability::MachineApplicable);\n+            };\n+\n         let suggest_to_change_suffix_or_into =\n-            |err: &mut DiagnosticBuilder<'_>, is_fallible: bool| {\n+            |err: &mut DiagnosticBuilder<'_>,\n+             found_to_exp_is_fallible: bool,\n+             exp_to_found_is_fallible: bool| {\n                 let msg = if literal_is_ty_suffixed(expr) {\n                     &lit_msg\n                 } else if in_const_context {\n                     // Do not recommend `into` or `try_into` in const contexts.\n                     return;\n-                } else if is_fallible {\n-                    &try_msg\n+                } else if found_to_exp_is_fallible {\n+                    return suggest_fallible_into_or_lhs_from(err, exp_to_found_is_fallible);\n                 } else {\n                     &msg\n                 };\n                 let suggestion = if literal_is_ty_suffixed(expr) {\n                     suffix_suggestion.clone()\n-                } else if is_fallible {\n-                    try_into_suggestion\n                 } else {\n                     into_suggestion.clone()\n                 };\n@@ -806,41 +842,54 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         match (&expected_ty.kind, &checked_ty.kind) {\n             (&ty::Int(ref exp), &ty::Int(ref found)) => {\n-                let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                    (Some(exp), Some(found)) if exp < found => true,\n-                    (None, Some(8 | 16)) => false,\n-                    (None, _) | (_, None) => true,\n-                    _ => false,\n+                let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n+                {\n+                    (Some(exp), Some(found)) if exp < found => (true, false),\n+                    (Some(exp), Some(found)) if exp > found => (false, true),\n+                    (None, Some(8 | 16)) => (false, true),\n+                    (Some(8 | 16), None) => (true, false),\n+                    (None, _) | (_, None) => (true, true),\n+                    _ => (false, false),\n                 };\n-                suggest_to_change_suffix_or_into(err, is_fallible);\n+                suggest_to_change_suffix_or_into(err, f2e_is_fallible, e2f_is_fallible);\n                 true\n             }\n             (&ty::Uint(ref exp), &ty::Uint(ref found)) => {\n-                let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                    (Some(exp), Some(found)) if exp < found => true,\n-                    (None, Some(8 | 16)) => false,\n-                    (None, _) | (_, None) => true,\n-                    _ => false,\n+                let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n+                {\n+                    (Some(exp), Some(found)) if exp < found => (true, false),\n+                    (Some(exp), Some(found)) if exp > found => (false, true),\n+                    (None, Some(8 | 16)) => (false, true),\n+                    (Some(8 | 16), None) => (true, false),\n+                    (None, _) | (_, None) => (true, true),\n+                    _ => (false, false),\n                 };\n-                suggest_to_change_suffix_or_into(err, is_fallible);\n+                suggest_to_change_suffix_or_into(err, f2e_is_fallible, e2f_is_fallible);\n                 true\n             }\n             (&ty::Int(exp), &ty::Uint(found)) => {\n-                let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                    (Some(exp), Some(found)) if found < exp => false,\n-                    (None, Some(8)) => false,\n-                    _ => true,\n+                let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n+                {\n+                    (Some(exp), Some(found)) if found < exp => (false, true),\n+                    (None, Some(8)) => (false, true),\n+                    _ => (true, true),\n                 };\n-                suggest_to_change_suffix_or_into(err, is_fallible);\n+                suggest_to_change_suffix_or_into(err, f2e_is_fallible, e2f_is_fallible);\n                 true\n             }\n-            (&ty::Uint(_), &ty::Int(_)) => {\n-                suggest_to_change_suffix_or_into(err, true);\n+            (&ty::Uint(exp), &ty::Int(found)) => {\n+                let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n+                {\n+                    (Some(exp), Some(found)) if found > exp => (true, false),\n+                    (Some(8), None) => (true, false),\n+                    _ => (true, true),\n+                };\n+                suggest_to_change_suffix_or_into(err, f2e_is_fallible, e2f_is_fallible);\n                 true\n             }\n             (&ty::Float(ref exp), &ty::Float(ref found)) => {\n                 if found.bit_width() < exp.bit_width() {\n-                    suggest_to_change_suffix_or_into(err, false);\n+                    suggest_to_change_suffix_or_into(err, false, true);\n                 } else if literal_is_ty_suffixed(expr) {\n                     err.span_suggestion(\n                         expr.span,"}, {"sha": "bc3ef73d851ebcdc0258c517ea26f86de9ddda98", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n             let expr = expr.peel_drop_temps();\n-            self.suggest_deref_ref_or_into(&mut err, expr, expected_ty, ty);\n+            self.suggest_deref_ref_or_into(&mut err, expr, expected_ty, ty, None);\n             extend_err(&mut err);\n             // Error possibly reported in `check_assign` so avoid emitting error again.\n             err.emit_unless(self.is_assign_to_bool(expr, expected_ty));\n@@ -98,10 +98,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) -> Ty<'tcx> {\n         let ty = self.check_expr_with_hint(expr, expected);\n         // checks don't need two phase\n-        self.demand_coerce(expr, ty, expected, AllowTwoPhase::No)\n+        self.demand_coerce(expr, ty, expected, expected_ty_expr, AllowTwoPhase::No)\n     }\n \n     pub(super) fn check_expr_with_hint(\n@@ -776,7 +777,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: &Span,\n     ) -> Ty<'tcx> {\n         let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n-        let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n+        let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty, Some(lhs));\n \n         let expected_ty = expected.coercion_target_type(self, expr.span);\n         if expected_ty == self.tcx.types.bool {\n@@ -1026,7 +1027,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let (element_ty, t) = match uty {\n             Some(uty) => {\n-                self.check_expr_coercable_to_type(&element, uty);\n+                self.check_expr_coercable_to_type(&element, uty, None);\n                 (uty, uty)\n             }\n             None => {\n@@ -1063,7 +1064,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let elt_ts_iter = elts.iter().enumerate().map(|(i, e)| match flds {\n             Some(ref fs) if i < fs.len() => {\n                 let ety = fs[i].expect_ty();\n-                self.check_expr_coercable_to_type(&e, ety);\n+                self.check_expr_coercable_to_type(&e, ety, None);\n                 ety\n             }\n             _ => self.check_expr_with_expectation(&e, NoExpectation),\n@@ -1237,7 +1238,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Make sure to give a type to the field even if there's\n             // an error, so we can continue type-checking.\n-            self.check_expr_coercable_to_type(&field.expr, field_type);\n+            self.check_expr_coercable_to_type(&field.expr, field_type, None);\n         }\n \n         // Make sure the programmer specified correct number of fields.\n@@ -1735,7 +1736,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n                 Some((index_ty, element_ty)) => {\n                     // two-phase not needed because index_ty is never mutable\n-                    self.demand_coerce(idx, idx_t, index_ty, AllowTwoPhase::No);\n+                    self.demand_coerce(idx, idx_t, index_ty, None, AllowTwoPhase::No);\n                     element_ty\n                 }\n                 None => {\n@@ -1788,7 +1789,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         match self.resume_yield_tys {\n             Some((resume_ty, yield_ty)) => {\n-                self.check_expr_coercable_to_type(&value, yield_ty);\n+                self.check_expr_coercable_to_type(&value, yield_ty, None);\n \n                 resume_ty\n             }\n@@ -1797,7 +1798,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // information. Hence, we check the source of the yield expression here and check its\n             // value's type against `()` (this check should always hold).\n             None if src.is_await() => {\n-                self.check_expr_coercable_to_type(&value, self.tcx.mk_unit());\n+                self.check_expr_coercable_to_type(&value, self.tcx.mk_unit(), None);\n                 self.tcx.mk_unit()\n             }\n             _ => {\n@@ -1836,11 +1837,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match ty.kind {\n                 ty::FnDef(..) => {\n                     let fnptr_ty = self.tcx.mk_fn_ptr(ty.fn_sig(self.tcx));\n-                    self.demand_coerce(expr, ty, fnptr_ty, AllowTwoPhase::No);\n+                    self.demand_coerce(expr, ty, fnptr_ty, None, AllowTwoPhase::No);\n                 }\n                 ty::Ref(_, base_ty, mutbl) => {\n                     let ptr_ty = self.tcx.mk_ptr(ty::TypeAndMut { ty: base_ty, mutbl });\n-                    self.demand_coerce(expr, ty, ptr_ty, AllowTwoPhase::No);\n+                    self.demand_coerce(expr, ty, ptr_ty, None, AllowTwoPhase::No);\n                 }\n                 _ => {}\n             }"}, {"sha": "fabedc3800ae45c399bc2af3dc454a9a0ae54c05", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5", "patch": "@@ -1046,7 +1046,7 @@ fn typeck_tables_of_with_fallback<'tcx>(\n             // Gather locals in statics (because of block expressions).\n             GatherLocalsVisitor { fcx: &fcx, parent_id: id }.visit_body(body);\n \n-            fcx.check_expr_coercable_to_type(&body.value, revealed_ty);\n+            fcx.check_expr_coercable_to_type(&body.value, revealed_ty, None);\n \n             fcx.write_ty(id, revealed_ty);\n \n@@ -4123,7 +4123,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let coerce_ty = expected.only_has_type(self).unwrap_or(formal_ty);\n                 // We're processing function arguments so we definitely want to use\n                 // two-phase borrows.\n-                self.demand_coerce(&arg, checked_ty, coerce_ty, AllowTwoPhase::Yes);\n+                self.demand_coerce(&arg, checked_ty, coerce_ty, None, AllowTwoPhase::Yes);\n                 final_arg_types.push((i, checked_ty, coerce_ty));\n \n                 // 3. Relate the expected type and the formal one,\n@@ -4541,7 +4541,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.demand_eqtype(init.span, local_ty, init_ty);\n             init_ty\n         } else {\n-            self.check_expr_coercable_to_type(init, local_ty)\n+            self.check_expr_coercable_to_type(init, local_ty, None)\n         }\n     }\n \n@@ -5027,6 +5027,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) {\n         if let Some((sp, msg, suggestion, applicability)) = self.check_ref(expr, found, expected) {\n             err.span_suggestion(sp, msg, suggestion, applicability);\n@@ -5037,7 +5038,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let sp = self.sess().source_map().guess_head_span(sp);\n                 err.span_label(sp, &format!(\"{} defined here\", found));\n             }\n-        } else if !self.check_for_cast(err, expr, found, expected) {\n+        } else if !self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n             let is_struct_pat_shorthand_field =\n                 self.is_hir_id_from_struct_pattern_shorthand_field(expr.hir_id, expr.span);\n             let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);"}, {"sha": "a3a27dc138be96f11605c2b3d898905673bc3160", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5", "patch": "@@ -57,9 +57,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match BinOpCategory::from(op) {\n             BinOpCategory::Shortcircuit => {\n                 // && and || are a simple case.\n-                self.check_expr_coercable_to_type(lhs_expr, tcx.types.bool);\n+                self.check_expr_coercable_to_type(lhs_expr, tcx.types.bool, None);\n                 let lhs_diverges = self.diverges.get();\n-                self.check_expr_coercable_to_type(rhs_expr, tcx.types.bool);\n+                self.check_expr_coercable_to_type(rhs_expr, tcx.types.bool, None);\n \n                 // Depending on the LHS' value, the RHS can never execute.\n                 self.diverges.set(lhs_diverges);\n@@ -170,7 +170,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     kind: TypeVariableOriginKind::MiscVariable,\n                     span: lhs_expr.span,\n                 });\n-                self.demand_coerce(lhs_expr, lhs_ty, fresh_var, AllowTwoPhase::No)\n+                self.demand_coerce(lhs_expr, lhs_ty, fresh_var, Some(rhs_expr), AllowTwoPhase::No)\n             }\n             IsAssign::Yes => {\n                 // rust-lang/rust#52126: We have to use strict\n@@ -196,7 +196,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let result = self.lookup_op_method(lhs_ty, &[rhs_ty_var], Op::Binary(op, is_assign));\n \n         // see `NB` above\n-        let rhs_ty = self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var);\n+        let rhs_ty = self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var, Some(lhs_expr));\n         let rhs_ty = self.resolve_vars_with_obligations(rhs_ty);\n \n         let return_ty = match result {"}, {"sha": "edb085e71d324305230daea52c5e346abf44bdfa", "filename": "src/test/ui/numeric/numeric-cast-binop.fixed", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.fixed?ref=7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5", "patch": "@@ -0,0 +1,320 @@\n+// run-rustfix\n+\n+// The `try_into` suggestion doesn't include this, but we do suggest it after applying it\n+use std::convert::TryInto;\n+\n+#[allow(unused_must_use)]\n+fn main() {\n+    let x_usize: usize = 1;\n+    let x_u128: u128 = 2;\n+    let x_u64: u64 = 3;\n+    let x_u32: u32 = 4;\n+    let x_u16: u16 = 5;\n+    let x_u8: u8 = 6;\n+    let x_isize: isize = 7;\n+    let x_i64: i64 = 8;\n+    let x_i32: i32 = 9;\n+    let x_i16: i16 = 10;\n+    let x_i8: i8 = 11;\n+    let x_i128: i128 = 12;\n+\n+    /* u<->u */\n+    {\n+        u16::from(x_u8) > x_u16;\n+        //~^ ERROR mismatched types\n+        u32::from(x_u8) > x_u32;\n+        //~^ ERROR mismatched types\n+        u64::from(x_u8) > x_u64;\n+        //~^ ERROR mismatched types\n+        u128::from(x_u8) > x_u128;\n+        //~^ ERROR mismatched types\n+        usize::from(x_u8) > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_u16 > x_u8.into();\n+        //~^ ERROR mismatched types\n+        u32::from(x_u16) > x_u32;\n+        //~^ ERROR mismatched types\n+        u64::from(x_u16) > x_u64;\n+        //~^ ERROR mismatched types\n+        u128::from(x_u16) > x_u128;\n+        //~^ ERROR mismatched types\n+        usize::from(x_u16) > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_u32 > x_u8.into();\n+        //~^ ERROR mismatched types\n+        x_u32 > x_u16.into();\n+        //~^ ERROR mismatched types\n+        u64::from(x_u32) > x_u64;\n+        //~^ ERROR mismatched types\n+        u128::from(x_u32) > x_u128;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_usize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_u64 > x_u8.into();\n+        //~^ ERROR mismatched types\n+        x_u64 > x_u16.into();\n+        //~^ ERROR mismatched types\n+        x_u64 > x_u32.into();\n+        //~^ ERROR mismatched types\n+        u128::from(x_u64) > x_u128;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_usize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_u128 > x_u8.into();\n+        //~^ ERROR mismatched types\n+        x_u128 > x_u16.into();\n+        //~^ ERROR mismatched types\n+        x_u128 > x_u32.into();\n+        //~^ ERROR mismatched types\n+        x_u128 > x_u64.into();\n+        //~^ ERROR mismatched types\n+        x_u128 > x_usize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_usize > x_u8.into();\n+        //~^ ERROR mismatched types\n+        x_usize > x_u16.into();\n+        //~^ ERROR mismatched types\n+        x_usize > x_u32.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_usize > x_u64.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_usize > x_u128.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+    }\n+\n+    /* i<->i */\n+    {\n+        i16::from(x_i8) > x_i16;\n+        //~^ ERROR mismatched types\n+        i32::from(x_i8) > x_i32;\n+        //~^ ERROR mismatched types\n+        i64::from(x_i8) > x_i64;\n+        //~^ ERROR mismatched types\n+        i128::from(x_i8) > x_i128;\n+        //~^ ERROR mismatched types\n+        isize::from(x_i8) > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_i16 > x_i8.into();\n+        //~^ ERROR mismatched types\n+        i32::from(x_i16) > x_i32;\n+        //~^ ERROR mismatched types\n+        i64::from(x_i16) > x_i64;\n+        //~^ ERROR mismatched types\n+        i128::from(x_i16) > x_i128;\n+        //~^ ERROR mismatched types\n+        isize::from(x_i16) > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_i32 > x_i8.into();\n+        //~^ ERROR mismatched types\n+        x_i32 > x_i16.into();\n+        //~^ ERROR mismatched types\n+        i64::from(x_i32) > x_i64;\n+        //~^ ERROR mismatched types\n+        i128::from(x_i32) > x_i128;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_isize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_i64 > x_i8.into();\n+        //~^ ERROR mismatched types\n+        x_i64 > x_i16.into();\n+        //~^ ERROR mismatched types\n+        x_i64 > x_i32.into();\n+        //~^ ERROR mismatched types\n+        i128::from(x_i64) > x_i128;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_isize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_i128 > x_i8.into();\n+        //~^ ERROR mismatched types\n+        x_i128 > x_i16.into();\n+        //~^ ERROR mismatched types\n+        x_i128 > x_i32.into();\n+        //~^ ERROR mismatched types\n+        x_i128 > x_i64.into();\n+        //~^ ERROR mismatched types\n+        x_i128 > x_isize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_isize > x_i8.into();\n+        //~^ ERROR mismatched types\n+        x_isize > x_i16.into();\n+        //~^ ERROR mismatched types\n+        x_isize > x_i32.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_isize > x_i64.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_isize > x_i128.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+    }\n+\n+    /* u<->i */\n+    {\n+        x_u8 > x_i8.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        i16::from(x_u8) > x_i16;\n+        //~^ ERROR mismatched types\n+        i32::from(x_u8) > x_i32;\n+        //~^ ERROR mismatched types\n+        i64::from(x_u8) > x_i64;\n+        //~^ ERROR mismatched types\n+        i128::from(x_u8) > x_i128;\n+        //~^ ERROR mismatched types\n+        isize::from(x_u8) > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_u16 > x_i8.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u16 > x_i16.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        i32::from(x_u16) > x_i32;\n+        //~^ ERROR mismatched types\n+        i64::from(x_u16) > x_i64;\n+        //~^ ERROR mismatched types\n+        i128::from(x_u16) > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_isize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_u32 > x_i8.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u32 > x_i16.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u32 > x_i32.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        i64::from(x_u32) > x_i64;\n+        //~^ ERROR mismatched types\n+        i128::from(x_u32) > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_isize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_u64 > x_i8.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u64 > x_i16.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u64 > x_i32.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u64 > x_i64.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        i128::from(x_u64) > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_isize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_u128 > x_i8.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u128 > x_i16.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u128 > x_i32.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u128 > x_i64.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u128 > x_i128.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_u128 > x_isize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_usize > x_i8.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_usize > x_i16.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_usize > x_i32.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_usize > x_i64.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_usize > x_i128.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_usize > x_isize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+    }\n+\n+    /* i<->u */\n+    {\n+        x_i8 > x_u8.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i8 > x_u16.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i8 > x_u32.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i8 > x_u64.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i8 > x_u128.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i8 > x_usize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_i16 > x_u8.into();\n+        //~^ ERROR mismatched types\n+        x_i16 > x_u16.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i16 > x_u32.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i16 > x_u64.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i16 > x_u128.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i16 > x_usize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_i32 > x_u8.into();\n+        //~^ ERROR mismatched types\n+        x_i32 > x_u16.into();\n+        //~^ ERROR mismatched types\n+        x_i32 > x_u32.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i32 > x_u64.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i32 > x_u128.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i32 > x_usize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_i64 > x_u8.into();\n+        //~^ ERROR mismatched types\n+        x_i64 > x_u16.into();\n+        //~^ ERROR mismatched types\n+        x_i64 > x_u32.into();\n+        //~^ ERROR mismatched types\n+        x_i64 > x_u64.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i64 > x_u128.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i64 > x_usize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_i128 > x_u8.into();\n+        //~^ ERROR mismatched types\n+        x_i128 > x_u16.into();\n+        //~^ ERROR mismatched types\n+        x_i128 > x_u32.into();\n+        //~^ ERROR mismatched types\n+        x_i128 > x_u64.into();\n+        //~^ ERROR mismatched types\n+        x_i128 > x_u128.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_i128 > x_usize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+\n+        x_isize > x_u8.into();\n+        //~^ ERROR mismatched types\n+        x_isize > x_u16.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_isize > x_u32.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_isize > x_u64.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_isize > x_u128.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+        x_isize > x_usize.try_into().unwrap();\n+        //~^ ERROR mismatched types\n+    }\n+}"}, {"sha": "c1ed8de8ad8c3ed03a0635e7f65936597b5e07c8", "filename": "src/test/ui/numeric/numeric-cast-binop.rs", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.rs?ref=7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5", "patch": "@@ -0,0 +1,320 @@\n+// run-rustfix\n+\n+// The `try_into` suggestion doesn't include this, but we do suggest it after applying it\n+use std::convert::TryInto;\n+\n+#[allow(unused_must_use)]\n+fn main() {\n+    let x_usize: usize = 1;\n+    let x_u128: u128 = 2;\n+    let x_u64: u64 = 3;\n+    let x_u32: u32 = 4;\n+    let x_u16: u16 = 5;\n+    let x_u8: u8 = 6;\n+    let x_isize: isize = 7;\n+    let x_i64: i64 = 8;\n+    let x_i32: i32 = 9;\n+    let x_i16: i16 = 10;\n+    let x_i8: i8 = 11;\n+    let x_i128: i128 = 12;\n+\n+    /* u<->u */\n+    {\n+        x_u8 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_u16 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_u32 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_u64 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_u128 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_usize > x_u8;\n+        //~^ ERROR mismatched types\n+        x_usize > x_u16;\n+        //~^ ERROR mismatched types\n+        x_usize > x_u32;\n+        //~^ ERROR mismatched types\n+        x_usize > x_u64;\n+        //~^ ERROR mismatched types\n+        x_usize > x_u128;\n+        //~^ ERROR mismatched types\n+    }\n+\n+    /* i<->i */\n+    {\n+        x_i8 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_i16 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_i32 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_i64 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_i128 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_isize > x_i8;\n+        //~^ ERROR mismatched types\n+        x_isize > x_i16;\n+        //~^ ERROR mismatched types\n+        x_isize > x_i32;\n+        //~^ ERROR mismatched types\n+        x_isize > x_i64;\n+        //~^ ERROR mismatched types\n+        x_isize > x_i128;\n+        //~^ ERROR mismatched types\n+    }\n+\n+    /* u<->i */\n+    {\n+        x_u8 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_u16 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_u32 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_u64 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_u128 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_usize > x_i8;\n+        //~^ ERROR mismatched types\n+        x_usize > x_i16;\n+        //~^ ERROR mismatched types\n+        x_usize > x_i32;\n+        //~^ ERROR mismatched types\n+        x_usize > x_i64;\n+        //~^ ERROR mismatched types\n+        x_usize > x_i128;\n+        //~^ ERROR mismatched types\n+        x_usize > x_isize;\n+        //~^ ERROR mismatched types\n+    }\n+\n+    /* i<->u */\n+    {\n+        x_i8 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_i16 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_i32 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_i64 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_i128 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_isize > x_u8;\n+        //~^ ERROR mismatched types\n+        x_isize > x_u16;\n+        //~^ ERROR mismatched types\n+        x_isize > x_u32;\n+        //~^ ERROR mismatched types\n+        x_isize > x_u64;\n+        //~^ ERROR mismatched types\n+        x_isize > x_u128;\n+        //~^ ERROR mismatched types\n+        x_isize > x_usize;\n+        //~^ ERROR mismatched types\n+    }\n+}"}, {"sha": "47be817b78908909c17746a94310c5151da79688", "filename": "src/test/ui/numeric/numeric-cast-binop.stderr", "status": "added", "additions": 1385, "deletions": 0, "changes": 1385, "blob_url": "https://github.com/rust-lang/rust/blob/7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.stderr?ref=7bdf7d09b03f8664e02cd1d80972ea7b1c96a4d5", "patch": "@@ -0,0 +1,1385 @@\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:23:16\n+   |\n+LL |         x_u8 > x_u16;\n+   |                ^^^^^ expected `u8`, found `u16`\n+   |\n+help: you can convert `x_u8` from `u8` to `u16`, matching the type of `x_u16`\n+   |\n+LL |         u16::from(x_u8) > x_u16;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:25:16\n+   |\n+LL |         x_u8 > x_u32;\n+   |                ^^^^^ expected `u8`, found `u32`\n+   |\n+help: you can convert `x_u8` from `u8` to `u32`, matching the type of `x_u32`\n+   |\n+LL |         u32::from(x_u8) > x_u32;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:27:16\n+   |\n+LL |         x_u8 > x_u64;\n+   |                ^^^^^ expected `u8`, found `u64`\n+   |\n+help: you can convert `x_u8` from `u8` to `u64`, matching the type of `x_u64`\n+   |\n+LL |         u64::from(x_u8) > x_u64;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:29:16\n+   |\n+LL |         x_u8 > x_u128;\n+   |                ^^^^^^ expected `u8`, found `u128`\n+   |\n+help: you can convert `x_u8` from `u8` to `u128`, matching the type of `x_u128`\n+   |\n+LL |         u128::from(x_u8) > x_u128;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:31:16\n+   |\n+LL |         x_u8 > x_usize;\n+   |                ^^^^^^^ expected `u8`, found `usize`\n+   |\n+help: you can convert `x_u8` from `u8` to `usize`, matching the type of `x_usize`\n+   |\n+LL |         usize::from(x_u8) > x_usize;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:34:17\n+   |\n+LL |         x_u16 > x_u8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `u16`, found `u8`\n+   |                 help: you can convert an `u8` to `u16`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:36:17\n+   |\n+LL |         x_u16 > x_u32;\n+   |                 ^^^^^ expected `u16`, found `u32`\n+   |\n+help: you can convert `x_u16` from `u16` to `u32`, matching the type of `x_u32`\n+   |\n+LL |         u32::from(x_u16) > x_u32;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:38:17\n+   |\n+LL |         x_u16 > x_u64;\n+   |                 ^^^^^ expected `u16`, found `u64`\n+   |\n+help: you can convert `x_u16` from `u16` to `u64`, matching the type of `x_u64`\n+   |\n+LL |         u64::from(x_u16) > x_u64;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:40:17\n+   |\n+LL |         x_u16 > x_u128;\n+   |                 ^^^^^^ expected `u16`, found `u128`\n+   |\n+help: you can convert `x_u16` from `u16` to `u128`, matching the type of `x_u128`\n+   |\n+LL |         u128::from(x_u16) > x_u128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:42:17\n+   |\n+LL |         x_u16 > x_usize;\n+   |                 ^^^^^^^ expected `u16`, found `usize`\n+   |\n+help: you can convert `x_u16` from `u16` to `usize`, matching the type of `x_usize`\n+   |\n+LL |         usize::from(x_u16) > x_usize;\n+   |         ^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:45:17\n+   |\n+LL |         x_u32 > x_u8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `u32`, found `u8`\n+   |                 help: you can convert an `u8` to `u32`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:47:17\n+   |\n+LL |         x_u32 > x_u16;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `u32`, found `u16`\n+   |                 help: you can convert an `u16` to `u32`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:49:17\n+   |\n+LL |         x_u32 > x_u64;\n+   |                 ^^^^^ expected `u32`, found `u64`\n+   |\n+help: you can convert `x_u32` from `u32` to `u64`, matching the type of `x_u64`\n+   |\n+LL |         u64::from(x_u32) > x_u64;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:51:17\n+   |\n+LL |         x_u32 > x_u128;\n+   |                 ^^^^^^ expected `u32`, found `u128`\n+   |\n+help: you can convert `x_u32` from `u32` to `u128`, matching the type of `x_u128`\n+   |\n+LL |         u128::from(x_u32) > x_u128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:53:17\n+   |\n+LL |         x_u32 > x_usize;\n+   |                 ^^^^^^^ expected `u32`, found `usize`\n+   |\n+help: you can convert an `usize` to `u32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u32 > x_usize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:56:17\n+   |\n+LL |         x_u64 > x_u8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `u64`, found `u8`\n+   |                 help: you can convert an `u8` to `u64`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:58:17\n+   |\n+LL |         x_u64 > x_u16;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `u64`, found `u16`\n+   |                 help: you can convert an `u16` to `u64`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:60:17\n+   |\n+LL |         x_u64 > x_u32;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `u64`, found `u32`\n+   |                 help: you can convert an `u32` to `u64`: `x_u32.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:62:17\n+   |\n+LL |         x_u64 > x_u128;\n+   |                 ^^^^^^ expected `u64`, found `u128`\n+   |\n+help: you can convert `x_u64` from `u64` to `u128`, matching the type of `x_u128`\n+   |\n+LL |         u128::from(x_u64) > x_u128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:64:17\n+   |\n+LL |         x_u64 > x_usize;\n+   |                 ^^^^^^^ expected `u64`, found `usize`\n+   |\n+help: you can convert an `usize` to `u64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u64 > x_usize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:67:18\n+   |\n+LL |         x_u128 > x_u8;\n+   |                  ^^^^\n+   |                  |\n+   |                  expected `u128`, found `u8`\n+   |                  help: you can convert an `u8` to `u128`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:69:18\n+   |\n+LL |         x_u128 > x_u16;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `u128`, found `u16`\n+   |                  help: you can convert an `u16` to `u128`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:71:18\n+   |\n+LL |         x_u128 > x_u32;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `u128`, found `u32`\n+   |                  help: you can convert an `u32` to `u128`: `x_u32.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:73:18\n+   |\n+LL |         x_u128 > x_u64;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `u128`, found `u64`\n+   |                  help: you can convert an `u64` to `u128`: `x_u64.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:75:18\n+   |\n+LL |         x_u128 > x_usize;\n+   |                  ^^^^^^^ expected `u128`, found `usize`\n+   |\n+help: you can convert an `usize` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_usize.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:78:19\n+   |\n+LL |         x_usize > x_u8;\n+   |                   ^^^^\n+   |                   |\n+   |                   expected `usize`, found `u8`\n+   |                   help: you can convert an `u8` to `usize`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:80:19\n+   |\n+LL |         x_usize > x_u16;\n+   |                   ^^^^^\n+   |                   |\n+   |                   expected `usize`, found `u16`\n+   |                   help: you can convert an `u16` to `usize`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:82:19\n+   |\n+LL |         x_usize > x_u32;\n+   |                   ^^^^^ expected `usize`, found `u32`\n+   |\n+help: you can convert an `u32` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_u32.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:84:19\n+   |\n+LL |         x_usize > x_u64;\n+   |                   ^^^^^ expected `usize`, found `u64`\n+   |\n+help: you can convert an `u64` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_u64.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:86:19\n+   |\n+LL |         x_usize > x_u128;\n+   |                   ^^^^^^ expected `usize`, found `u128`\n+   |\n+help: you can convert an `u128` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_u128.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:92:16\n+   |\n+LL |         x_i8 > x_i16;\n+   |                ^^^^^ expected `i8`, found `i16`\n+   |\n+help: you can convert `x_i8` from `i8` to `i16`, matching the type of `x_i16`\n+   |\n+LL |         i16::from(x_i8) > x_i16;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:94:16\n+   |\n+LL |         x_i8 > x_i32;\n+   |                ^^^^^ expected `i8`, found `i32`\n+   |\n+help: you can convert `x_i8` from `i8` to `i32`, matching the type of `x_i32`\n+   |\n+LL |         i32::from(x_i8) > x_i32;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:96:16\n+   |\n+LL |         x_i8 > x_i64;\n+   |                ^^^^^ expected `i8`, found `i64`\n+   |\n+help: you can convert `x_i8` from `i8` to `i64`, matching the type of `x_i64`\n+   |\n+LL |         i64::from(x_i8) > x_i64;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:98:16\n+   |\n+LL |         x_i8 > x_i128;\n+   |                ^^^^^^ expected `i8`, found `i128`\n+   |\n+help: you can convert `x_i8` from `i8` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_i8) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:100:16\n+   |\n+LL |         x_i8 > x_isize;\n+   |                ^^^^^^^ expected `i8`, found `isize`\n+   |\n+help: you can convert `x_i8` from `i8` to `isize`, matching the type of `x_isize`\n+   |\n+LL |         isize::from(x_i8) > x_isize;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:103:17\n+   |\n+LL |         x_i16 > x_i8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `i16`, found `i8`\n+   |                 help: you can convert an `i8` to `i16`: `x_i8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:105:17\n+   |\n+LL |         x_i16 > x_i32;\n+   |                 ^^^^^ expected `i16`, found `i32`\n+   |\n+help: you can convert `x_i16` from `i16` to `i32`, matching the type of `x_i32`\n+   |\n+LL |         i32::from(x_i16) > x_i32;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:107:17\n+   |\n+LL |         x_i16 > x_i64;\n+   |                 ^^^^^ expected `i16`, found `i64`\n+   |\n+help: you can convert `x_i16` from `i16` to `i64`, matching the type of `x_i64`\n+   |\n+LL |         i64::from(x_i16) > x_i64;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:109:17\n+   |\n+LL |         x_i16 > x_i128;\n+   |                 ^^^^^^ expected `i16`, found `i128`\n+   |\n+help: you can convert `x_i16` from `i16` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_i16) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:111:17\n+   |\n+LL |         x_i16 > x_isize;\n+   |                 ^^^^^^^ expected `i16`, found `isize`\n+   |\n+help: you can convert `x_i16` from `i16` to `isize`, matching the type of `x_isize`\n+   |\n+LL |         isize::from(x_i16) > x_isize;\n+   |         ^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:114:17\n+   |\n+LL |         x_i32 > x_i8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `i32`, found `i8`\n+   |                 help: you can convert an `i8` to `i32`: `x_i8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:116:17\n+   |\n+LL |         x_i32 > x_i16;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `i32`, found `i16`\n+   |                 help: you can convert an `i16` to `i32`: `x_i16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:118:17\n+   |\n+LL |         x_i32 > x_i64;\n+   |                 ^^^^^ expected `i32`, found `i64`\n+   |\n+help: you can convert `x_i32` from `i32` to `i64`, matching the type of `x_i64`\n+   |\n+LL |         i64::from(x_i32) > x_i64;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:120:17\n+   |\n+LL |         x_i32 > x_i128;\n+   |                 ^^^^^^ expected `i32`, found `i128`\n+   |\n+help: you can convert `x_i32` from `i32` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_i32) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:122:17\n+   |\n+LL |         x_i32 > x_isize;\n+   |                 ^^^^^^^ expected `i32`, found `isize`\n+   |\n+help: you can convert an `isize` to `i32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i32 > x_isize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:125:17\n+   |\n+LL |         x_i64 > x_i8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `i64`, found `i8`\n+   |                 help: you can convert an `i8` to `i64`: `x_i8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:127:17\n+   |\n+LL |         x_i64 > x_i16;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `i64`, found `i16`\n+   |                 help: you can convert an `i16` to `i64`: `x_i16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:129:17\n+   |\n+LL |         x_i64 > x_i32;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `i64`, found `i32`\n+   |                 help: you can convert an `i32` to `i64`: `x_i32.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:131:17\n+   |\n+LL |         x_i64 > x_i128;\n+   |                 ^^^^^^ expected `i64`, found `i128`\n+   |\n+help: you can convert `x_i64` from `i64` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_i64) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:133:17\n+   |\n+LL |         x_i64 > x_isize;\n+   |                 ^^^^^^^ expected `i64`, found `isize`\n+   |\n+help: you can convert an `isize` to `i64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i64 > x_isize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:136:18\n+   |\n+LL |         x_i128 > x_i8;\n+   |                  ^^^^\n+   |                  |\n+   |                  expected `i128`, found `i8`\n+   |                  help: you can convert an `i8` to `i128`: `x_i8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:138:18\n+   |\n+LL |         x_i128 > x_i16;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `i128`, found `i16`\n+   |                  help: you can convert an `i16` to `i128`: `x_i16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:140:18\n+   |\n+LL |         x_i128 > x_i32;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `i128`, found `i32`\n+   |                  help: you can convert an `i32` to `i128`: `x_i32.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:142:18\n+   |\n+LL |         x_i128 > x_i64;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `i128`, found `i64`\n+   |                  help: you can convert an `i64` to `i128`: `x_i64.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:144:18\n+   |\n+LL |         x_i128 > x_isize;\n+   |                  ^^^^^^^ expected `i128`, found `isize`\n+   |\n+help: you can convert an `isize` to `i128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i128 > x_isize.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:147:19\n+   |\n+LL |         x_isize > x_i8;\n+   |                   ^^^^\n+   |                   |\n+   |                   expected `isize`, found `i8`\n+   |                   help: you can convert an `i8` to `isize`: `x_i8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:149:19\n+   |\n+LL |         x_isize > x_i16;\n+   |                   ^^^^^\n+   |                   |\n+   |                   expected `isize`, found `i16`\n+   |                   help: you can convert an `i16` to `isize`: `x_i16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:151:19\n+   |\n+LL |         x_isize > x_i32;\n+   |                   ^^^^^ expected `isize`, found `i32`\n+   |\n+help: you can convert an `i32` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_i32.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:153:19\n+   |\n+LL |         x_isize > x_i64;\n+   |                   ^^^^^ expected `isize`, found `i64`\n+   |\n+help: you can convert an `i64` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_i64.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:155:19\n+   |\n+LL |         x_isize > x_i128;\n+   |                   ^^^^^^ expected `isize`, found `i128`\n+   |\n+help: you can convert an `i128` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_i128.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:161:16\n+   |\n+LL |         x_u8 > x_i8;\n+   |                ^^^^ expected `u8`, found `i8`\n+   |\n+help: you can convert an `i8` to `u8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u8 > x_i8.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:163:16\n+   |\n+LL |         x_u8 > x_i16;\n+   |                ^^^^^ expected `u8`, found `i16`\n+   |\n+help: you can convert `x_u8` from `u8` to `i16`, matching the type of `x_i16`\n+   |\n+LL |         i16::from(x_u8) > x_i16;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:165:16\n+   |\n+LL |         x_u8 > x_i32;\n+   |                ^^^^^ expected `u8`, found `i32`\n+   |\n+help: you can convert `x_u8` from `u8` to `i32`, matching the type of `x_i32`\n+   |\n+LL |         i32::from(x_u8) > x_i32;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:167:16\n+   |\n+LL |         x_u8 > x_i64;\n+   |                ^^^^^ expected `u8`, found `i64`\n+   |\n+help: you can convert `x_u8` from `u8` to `i64`, matching the type of `x_i64`\n+   |\n+LL |         i64::from(x_u8) > x_i64;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:169:16\n+   |\n+LL |         x_u8 > x_i128;\n+   |                ^^^^^^ expected `u8`, found `i128`\n+   |\n+help: you can convert `x_u8` from `u8` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_u8) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:171:16\n+   |\n+LL |         x_u8 > x_isize;\n+   |                ^^^^^^^ expected `u8`, found `isize`\n+   |\n+help: you can convert `x_u8` from `u8` to `isize`, matching the type of `x_isize`\n+   |\n+LL |         isize::from(x_u8) > x_isize;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:174:17\n+   |\n+LL |         x_u16 > x_i8;\n+   |                 ^^^^ expected `u16`, found `i8`\n+   |\n+help: you can convert an `i8` to `u16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u16 > x_i8.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:176:17\n+   |\n+LL |         x_u16 > x_i16;\n+   |                 ^^^^^ expected `u16`, found `i16`\n+   |\n+help: you can convert an `i16` to `u16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u16 > x_i16.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:178:17\n+   |\n+LL |         x_u16 > x_i32;\n+   |                 ^^^^^ expected `u16`, found `i32`\n+   |\n+help: you can convert `x_u16` from `u16` to `i32`, matching the type of `x_i32`\n+   |\n+LL |         i32::from(x_u16) > x_i32;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:180:17\n+   |\n+LL |         x_u16 > x_i64;\n+   |                 ^^^^^ expected `u16`, found `i64`\n+   |\n+help: you can convert `x_u16` from `u16` to `i64`, matching the type of `x_i64`\n+   |\n+LL |         i64::from(x_u16) > x_i64;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:182:17\n+   |\n+LL |         x_u16 > x_i128;\n+   |                 ^^^^^^ expected `u16`, found `i128`\n+   |\n+help: you can convert `x_u16` from `u16` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_u16) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:184:17\n+   |\n+LL |         x_u16 > x_isize;\n+   |                 ^^^^^^^ expected `u16`, found `isize`\n+   |\n+help: you can convert an `isize` to `u16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u16 > x_isize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:187:17\n+   |\n+LL |         x_u32 > x_i8;\n+   |                 ^^^^ expected `u32`, found `i8`\n+   |\n+help: you can convert an `i8` to `u32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u32 > x_i8.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:189:17\n+   |\n+LL |         x_u32 > x_i16;\n+   |                 ^^^^^ expected `u32`, found `i16`\n+   |\n+help: you can convert an `i16` to `u32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u32 > x_i16.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:191:17\n+   |\n+LL |         x_u32 > x_i32;\n+   |                 ^^^^^ expected `u32`, found `i32`\n+   |\n+help: you can convert an `i32` to `u32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u32 > x_i32.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:193:17\n+   |\n+LL |         x_u32 > x_i64;\n+   |                 ^^^^^ expected `u32`, found `i64`\n+   |\n+help: you can convert `x_u32` from `u32` to `i64`, matching the type of `x_i64`\n+   |\n+LL |         i64::from(x_u32) > x_i64;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:195:17\n+   |\n+LL |         x_u32 > x_i128;\n+   |                 ^^^^^^ expected `u32`, found `i128`\n+   |\n+help: you can convert `x_u32` from `u32` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_u32) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:197:17\n+   |\n+LL |         x_u32 > x_isize;\n+   |                 ^^^^^^^ expected `u32`, found `isize`\n+   |\n+help: you can convert an `isize` to `u32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u32 > x_isize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:200:17\n+   |\n+LL |         x_u64 > x_i8;\n+   |                 ^^^^ expected `u64`, found `i8`\n+   |\n+help: you can convert an `i8` to `u64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u64 > x_i8.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:202:17\n+   |\n+LL |         x_u64 > x_i16;\n+   |                 ^^^^^ expected `u64`, found `i16`\n+   |\n+help: you can convert an `i16` to `u64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u64 > x_i16.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:204:17\n+   |\n+LL |         x_u64 > x_i32;\n+   |                 ^^^^^ expected `u64`, found `i32`\n+   |\n+help: you can convert an `i32` to `u64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u64 > x_i32.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:206:17\n+   |\n+LL |         x_u64 > x_i64;\n+   |                 ^^^^^ expected `u64`, found `i64`\n+   |\n+help: you can convert an `i64` to `u64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u64 > x_i64.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:208:17\n+   |\n+LL |         x_u64 > x_i128;\n+   |                 ^^^^^^ expected `u64`, found `i128`\n+   |\n+help: you can convert `x_u64` from `u64` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_u64) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:210:17\n+   |\n+LL |         x_u64 > x_isize;\n+   |                 ^^^^^^^ expected `u64`, found `isize`\n+   |\n+help: you can convert an `isize` to `u64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u64 > x_isize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:213:18\n+   |\n+LL |         x_u128 > x_i8;\n+   |                  ^^^^ expected `u128`, found `i8`\n+   |\n+help: you can convert an `i8` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_i8.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:215:18\n+   |\n+LL |         x_u128 > x_i16;\n+   |                  ^^^^^ expected `u128`, found `i16`\n+   |\n+help: you can convert an `i16` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_i16.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:217:18\n+   |\n+LL |         x_u128 > x_i32;\n+   |                  ^^^^^ expected `u128`, found `i32`\n+   |\n+help: you can convert an `i32` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_i32.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:219:18\n+   |\n+LL |         x_u128 > x_i64;\n+   |                  ^^^^^ expected `u128`, found `i64`\n+   |\n+help: you can convert an `i64` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_i64.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:221:18\n+   |\n+LL |         x_u128 > x_i128;\n+   |                  ^^^^^^ expected `u128`, found `i128`\n+   |\n+help: you can convert an `i128` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_i128.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:223:18\n+   |\n+LL |         x_u128 > x_isize;\n+   |                  ^^^^^^^ expected `u128`, found `isize`\n+   |\n+help: you can convert an `isize` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_isize.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:226:19\n+   |\n+LL |         x_usize > x_i8;\n+   |                   ^^^^ expected `usize`, found `i8`\n+   |\n+help: you can convert an `i8` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_i8.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:228:19\n+   |\n+LL |         x_usize > x_i16;\n+   |                   ^^^^^ expected `usize`, found `i16`\n+   |\n+help: you can convert an `i16` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_i16.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:230:19\n+   |\n+LL |         x_usize > x_i32;\n+   |                   ^^^^^ expected `usize`, found `i32`\n+   |\n+help: you can convert an `i32` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_i32.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:232:19\n+   |\n+LL |         x_usize > x_i64;\n+   |                   ^^^^^ expected `usize`, found `i64`\n+   |\n+help: you can convert an `i64` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_i64.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:234:19\n+   |\n+LL |         x_usize > x_i128;\n+   |                   ^^^^^^ expected `usize`, found `i128`\n+   |\n+help: you can convert an `i128` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_i128.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:236:19\n+   |\n+LL |         x_usize > x_isize;\n+   |                   ^^^^^^^ expected `usize`, found `isize`\n+   |\n+help: you can convert an `isize` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_isize.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:242:16\n+   |\n+LL |         x_i8 > x_u8;\n+   |                ^^^^ expected `i8`, found `u8`\n+   |\n+help: you can convert an `u8` to `i8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i8 > x_u8.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:244:16\n+   |\n+LL |         x_i8 > x_u16;\n+   |                ^^^^^ expected `i8`, found `u16`\n+   |\n+help: you can convert an `u16` to `i8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i8 > x_u16.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:246:16\n+   |\n+LL |         x_i8 > x_u32;\n+   |                ^^^^^ expected `i8`, found `u32`\n+   |\n+help: you can convert an `u32` to `i8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i8 > x_u32.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:248:16\n+   |\n+LL |         x_i8 > x_u64;\n+   |                ^^^^^ expected `i8`, found `u64`\n+   |\n+help: you can convert an `u64` to `i8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i8 > x_u64.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:250:16\n+   |\n+LL |         x_i8 > x_u128;\n+   |                ^^^^^^ expected `i8`, found `u128`\n+   |\n+help: you can convert an `u128` to `i8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i8 > x_u128.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:252:16\n+   |\n+LL |         x_i8 > x_usize;\n+   |                ^^^^^^^ expected `i8`, found `usize`\n+   |\n+help: you can convert an `usize` to `i8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i8 > x_usize.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:255:17\n+   |\n+LL |         x_i16 > x_u8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `i16`, found `u8`\n+   |                 help: you can convert an `u8` to `i16`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:257:17\n+   |\n+LL |         x_i16 > x_u16;\n+   |                 ^^^^^ expected `i16`, found `u16`\n+   |\n+help: you can convert an `u16` to `i16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i16 > x_u16.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:259:17\n+   |\n+LL |         x_i16 > x_u32;\n+   |                 ^^^^^ expected `i16`, found `u32`\n+   |\n+help: you can convert an `u32` to `i16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i16 > x_u32.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:261:17\n+   |\n+LL |         x_i16 > x_u64;\n+   |                 ^^^^^ expected `i16`, found `u64`\n+   |\n+help: you can convert an `u64` to `i16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i16 > x_u64.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:263:17\n+   |\n+LL |         x_i16 > x_u128;\n+   |                 ^^^^^^ expected `i16`, found `u128`\n+   |\n+help: you can convert an `u128` to `i16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i16 > x_u128.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:265:17\n+   |\n+LL |         x_i16 > x_usize;\n+   |                 ^^^^^^^ expected `i16`, found `usize`\n+   |\n+help: you can convert an `usize` to `i16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i16 > x_usize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:268:17\n+   |\n+LL |         x_i32 > x_u8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `i32`, found `u8`\n+   |                 help: you can convert an `u8` to `i32`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:270:17\n+   |\n+LL |         x_i32 > x_u16;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `i32`, found `u16`\n+   |                 help: you can convert an `u16` to `i32`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:272:17\n+   |\n+LL |         x_i32 > x_u32;\n+   |                 ^^^^^ expected `i32`, found `u32`\n+   |\n+help: you can convert an `u32` to `i32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i32 > x_u32.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:274:17\n+   |\n+LL |         x_i32 > x_u64;\n+   |                 ^^^^^ expected `i32`, found `u64`\n+   |\n+help: you can convert an `u64` to `i32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i32 > x_u64.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:276:17\n+   |\n+LL |         x_i32 > x_u128;\n+   |                 ^^^^^^ expected `i32`, found `u128`\n+   |\n+help: you can convert an `u128` to `i32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i32 > x_u128.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:278:17\n+   |\n+LL |         x_i32 > x_usize;\n+   |                 ^^^^^^^ expected `i32`, found `usize`\n+   |\n+help: you can convert an `usize` to `i32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i32 > x_usize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:281:17\n+   |\n+LL |         x_i64 > x_u8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `i64`, found `u8`\n+   |                 help: you can convert an `u8` to `i64`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:283:17\n+   |\n+LL |         x_i64 > x_u16;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `i64`, found `u16`\n+   |                 help: you can convert an `u16` to `i64`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:285:17\n+   |\n+LL |         x_i64 > x_u32;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `i64`, found `u32`\n+   |                 help: you can convert an `u32` to `i64`: `x_u32.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:287:17\n+   |\n+LL |         x_i64 > x_u64;\n+   |                 ^^^^^ expected `i64`, found `u64`\n+   |\n+help: you can convert an `u64` to `i64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i64 > x_u64.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:289:17\n+   |\n+LL |         x_i64 > x_u128;\n+   |                 ^^^^^^ expected `i64`, found `u128`\n+   |\n+help: you can convert an `u128` to `i64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i64 > x_u128.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:291:17\n+   |\n+LL |         x_i64 > x_usize;\n+   |                 ^^^^^^^ expected `i64`, found `usize`\n+   |\n+help: you can convert an `usize` to `i64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i64 > x_usize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:294:18\n+   |\n+LL |         x_i128 > x_u8;\n+   |                  ^^^^\n+   |                  |\n+   |                  expected `i128`, found `u8`\n+   |                  help: you can convert an `u8` to `i128`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:296:18\n+   |\n+LL |         x_i128 > x_u16;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `i128`, found `u16`\n+   |                  help: you can convert an `u16` to `i128`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:298:18\n+   |\n+LL |         x_i128 > x_u32;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `i128`, found `u32`\n+   |                  help: you can convert an `u32` to `i128`: `x_u32.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:300:18\n+   |\n+LL |         x_i128 > x_u64;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `i128`, found `u64`\n+   |                  help: you can convert an `u64` to `i128`: `x_u64.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:302:18\n+   |\n+LL |         x_i128 > x_u128;\n+   |                  ^^^^^^ expected `i128`, found `u128`\n+   |\n+help: you can convert an `u128` to `i128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i128 > x_u128.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:304:18\n+   |\n+LL |         x_i128 > x_usize;\n+   |                  ^^^^^^^ expected `i128`, found `usize`\n+   |\n+help: you can convert an `usize` to `i128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i128 > x_usize.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:307:19\n+   |\n+LL |         x_isize > x_u8;\n+   |                   ^^^^\n+   |                   |\n+   |                   expected `isize`, found `u8`\n+   |                   help: you can convert an `u8` to `isize`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:309:19\n+   |\n+LL |         x_isize > x_u16;\n+   |                   ^^^^^ expected `isize`, found `u16`\n+   |\n+help: you can convert an `u16` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_u16.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:311:19\n+   |\n+LL |         x_isize > x_u32;\n+   |                   ^^^^^ expected `isize`, found `u32`\n+   |\n+help: you can convert an `u32` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_u32.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:313:19\n+   |\n+LL |         x_isize > x_u64;\n+   |                   ^^^^^ expected `isize`, found `u64`\n+   |\n+help: you can convert an `u64` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_u64.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:315:19\n+   |\n+LL |         x_isize > x_u128;\n+   |                   ^^^^^^ expected `isize`, found `u128`\n+   |\n+help: you can convert an `u128` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_u128.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:317:19\n+   |\n+LL |         x_isize > x_usize;\n+   |                   ^^^^^^^ expected `isize`, found `usize`\n+   |\n+help: you can convert an `usize` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_usize.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 132 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}