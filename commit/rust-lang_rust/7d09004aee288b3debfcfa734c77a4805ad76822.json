{"sha": "7d09004aee288b3debfcfa734c77a4805ad76822", "node_id": "C_kwDOAAsO6NoAKDdkMDkwMDRhZWUyODhiM2RlYmZjZmE3MzRjNzdhNDgwNWFkNzY4MjI", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2022-06-22T05:56:50Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2022-06-22T05:57:47Z"}, "message": "Format tests with rustfmt (276-287 of 299)", "tree": {"sha": "e3e17fea3017b7f467cd59c5a8e80ddbaff7a1ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3e17fea3017b7f467cd59c5a8e80ddbaff7a1ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d09004aee288b3debfcfa734c77a4805ad76822", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAmKyr1sACgkQ+boUO5X/\nbYLVCA/7B/IYZBMyCBAzad449KBat0+3CXT3ik72ftmSxLZJoEy+dvOBvoEFThGC\nhiNiGiJHgGPF2ygRsq7qVAHLdWiLByVrIh303q6db8f7nVb2OdW69ACAh2ptdTUe\nOME+kWxoPU4M7SDel7rCpNkMYMSCMfeGisWa9HylbD9hKZEhCbHoAEr8swkr7/15\nqswICqBnfVs7BSWJtsY4qKijLnGWsySZ9L9U5d1sAonsQh+1Zx8RBDbh5Lg1XMe8\nbjNJ30qT9O4ZQx70LlBZNhDsObaqvFohdsW3NyRPaMAAGmmVOh+V3l2grZmr+puB\nKef2odnciiLuqZsS8IT8Gn+IkjRA1JqAZ+3VS3lKtXnxrFC07ntGaeUBxAe22G1H\nMf0vq+O7YfMkD1l8BL68X3P65K335Isv9v56diQBSMLsabVp+U2GvHOJL4zilSHz\nqO/8bhUb/uQdC6kdyirCupJwk/S47qUs+Q4xnlt+aiCWbILgi3BEBFvGx4YPwYB1\nXp1qnU2kbCP9NMUazMkoDviU9wYuchp8nopJ6sPa12BO87yyF4o2j7EfLLgmb4HH\nWalwy6K1+1aCcGmkPb3jy3YlpdgOnK1hr+ESwhawGyxxTb4Zy5UUJvKyuBvUXhyr\nEuJAliVjdi6/y6aICusnCc5dUIh1TtMYRcHFeaomdlNZCGcYVg0=\n=HLHK\n-----END PGP SIGNATURE-----", "payload": "tree e3e17fea3017b7f467cd59c5a8e80ddbaff7a1ee\nparent 7a1b08e46eb106480cbb0bc0a70521f273f045aa\nauthor David Tolnay <dtolnay@gmail.com> 1655877410 -0700\ncommitter David Tolnay <dtolnay@gmail.com> 1655877467 -0700\n\nFormat tests with rustfmt (276-287 of 299)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d09004aee288b3debfcfa734c77a4805ad76822", "html_url": "https://github.com/rust-lang/rust/commit/7d09004aee288b3debfcfa734c77a4805ad76822", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d09004aee288b3debfcfa734c77a4805ad76822/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a1b08e46eb106480cbb0bc0a70521f273f045aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a1b08e46eb106480cbb0bc0a70521f273f045aa", "html_url": "https://github.com/rust-lang/rust/commit/7a1b08e46eb106480cbb0bc0a70521f273f045aa"}], "stats": {"total": 482, "additions": 251, "deletions": 231}, "files": [{"sha": "b0c9c0fd72821863417ccf21b94b6711b4a1784d", "filename": "tests/fail/branchless-select-i128-pointer.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Ffail%2Fbranchless-select-i128-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Ffail%2Fbranchless-select-i128-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fbranchless-select-i128-pointer.rs?ref=7d09004aee288b3debfcfa734c77a4805ad76822", "patch": "@@ -11,8 +11,10 @@ fn main() {\n         // This is branchless code to select one or the other pointer.\n         // However, it drops provenance when transmuting to TwoPtrs, so this is UB.\n         let val = unsafe {\n-            transmute::<_, &str>( //~ERROR type validation failed: encountered a dangling reference\n-                !mask & transmute::<_, TwoPtrs>(\"false !\") | mask & transmute::<_, TwoPtrs>(\"true !\"),\n+            transmute::<_, &str>(\n+                //~ERROR type validation failed: encountered a dangling reference\n+                !mask & transmute::<_, TwoPtrs>(\"false !\")\n+                    | mask & transmute::<_, TwoPtrs>(\"true !\"),\n             )\n         };\n         println!(\"{}\", val);"}, {"sha": "38bbd81f1e2fb9c91698406918bf9895b6405a5d", "filename": "tests/fail/data_race/dealloc_read_race1.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs?ref=7d09004aee288b3debfcfa734c77a4805ad76822", "patch": "@@ -18,12 +18,14 @@ pub fn main() {\n     let ptr = EvilSend(pointer);\n \n     unsafe {\n-        let j1 = spawn(move || {\n-            *ptr.0\n-        });\n+        let j1 = spawn(move || *ptr.0);\n \n         let j2 = spawn(move || {\n-            __rust_dealloc(ptr.0 as *mut _, std::mem::size_of::<usize>(), std::mem::align_of::<usize>());  //~ ERROR Data race detected between Deallocate on Thread(id = 2) and Read on Thread(id = 1)\n+            __rust_dealloc(\n+                ptr.0 as *mut _,\n+                std::mem::size_of::<usize>(),\n+                std::mem::align_of::<usize>(),\n+            ); //~ ERROR Data race detected between Deallocate on Thread(id = 2) and Read on Thread(id = 1)\n         });\n \n         j1.join().unwrap();"}, {"sha": "1cfaeb2cb25a677bb98a3532d47c1b28276c9191", "filename": "tests/fail/data_race/dealloc_write_race1.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs?ref=7d09004aee288b3debfcfa734c77a4805ad76822", "patch": "@@ -22,7 +22,11 @@ pub fn main() {\n         });\n \n         let j2 = spawn(move || {\n-            __rust_dealloc(ptr.0 as *mut _, std::mem::size_of::<usize>(), std::mem::align_of::<usize>());  //~ ERROR Data race detected between Deallocate on Thread(id = 2) and Write on Thread(id = 1)\n+            __rust_dealloc(\n+                ptr.0 as *mut _,\n+                std::mem::size_of::<usize>(),\n+                std::mem::align_of::<usize>(),\n+            ); //~ ERROR Data race detected between Deallocate on Thread(id = 2) and Write on Thread(id = 1)\n         });\n \n         j1.join().unwrap();"}, {"sha": "f76839c34f208d09c23ba3b1b1e8e2ea7b4156a9", "filename": "tests/fail/function_calls/check_callback_abi.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Ffail%2Ffunction_calls%2Fcheck_callback_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Ffail%2Ffunction_calls%2Fcheck_callback_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Ffunction_calls%2Fcheck_callback_abi.rs?ref=7d09004aee288b3debfcfa734c77a4805ad76822", "patch": "@@ -8,7 +8,8 @@ fn main() {\n     unsafe {\n         // Make sure we check the ABI when Miri itself invokes a function\n         // as part of a shim implementation.\n-        std::intrinsics::r#try( //~ ERROR calling a function with ABI C using caller ABI Rust\n+        std::intrinsics::r#try(\n+            //~ ERROR calling a function with ABI C using caller ABI Rust\n             std::mem::transmute::<extern \"C\" fn(*mut u8), _>(try_fn),\n             std::ptr::null_mut(),\n             |_, _| unreachable!(),"}, {"sha": "7e8fb2cffecbbe2853e415988e1a2168bdcfd5fb", "filename": "tests/fail/function_calls/exported_symbol_abi_mismatch.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Ffail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Ffail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.rs?ref=7d09004aee288b3debfcfa734c77a4805ad76822", "patch": "@@ -10,12 +10,16 @@ fn main() {\n     }\n \n     #[cfg(fn_ptr)]\n-    unsafe { std::mem::transmute::<unsafe fn(), unsafe extern \"C\" fn()>(foo)() }\n+    unsafe {\n+        std::mem::transmute::<unsafe fn(), unsafe extern \"C\" fn()>(foo)()\n+    }\n     //[fn_ptr]~^ ERROR calling a function with calling convention Rust using calling convention C\n \n     // `Instance` caching should not suppress ABI check.\n     #[cfg(cache)]\n-    unsafe { foo() }\n+    unsafe {\n+        foo()\n+    }\n \n     {\n         #[cfg_attr(any(cache, fn_ptr), allow(clashing_extern_declarations))]"}, {"sha": "d9e19ed818763e677508a3ceeadae0dc2c19a242", "filename": "tests/fail/type-too-large.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Ffail%2Ftype-too-large.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Ffail%2Ftype-too-large.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Ftype-too-large.rs?ref=7d09004aee288b3debfcfa734c77a4805ad76822", "patch": "@@ -1,6 +1,5 @@\n // ignore-32bit\n \n fn main() {\n-    let _fat: [u8; (1<<61)+(1<<31)] =\n-        [0; (1u64<<61) as usize +(1u64<<31) as usize]; //~ ERROR post-monomorphization error\n+    let _fat: [u8; (1 << 61) + (1 << 31)] = [0; (1u64 << 61) as usize + (1u64 << 31) as usize]; //~ ERROR post-monomorphization error\n }"}, {"sha": "a868dac8875df3c762c0f1d41311b321961fda2e", "filename": "tests/fail/validity/invalid_char.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Ffail%2Fvalidity%2Finvalid_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Ffail%2Fvalidity%2Finvalid_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fvalidity%2Finvalid_char.rs?ref=7d09004aee288b3debfcfa734c77a4805ad76822", "patch": "@@ -1,8 +1,9 @@\n fn main() {\n     assert!(std::char::from_u32(-1_i32 as u32).is_none());\n-    let _val = match unsafe { std::mem::transmute::<i32, char>(-1) } { //~ ERROR encountered 0xffffffff, but expected a valid unicode scalar value\n-        'a' => {true},\n-        'b' => {false},\n-        _ => {true},\n+    let _val = match unsafe { std::mem::transmute::<i32, char>(-1) } {\n+        //~ ERROR encountered 0xffffffff, but expected a valid unicode scalar value\n+        'a' => true,\n+        'b' => false,\n+        _ => true,\n     };\n }"}, {"sha": "ae8d281858c2323a5bc2e5b0a6a76b64ec24b0d7", "filename": "tests/pass/0weak_memory_consistency.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Fpass%2F0weak_memory_consistency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Fpass%2F0weak_memory_consistency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2F0weak_memory_consistency.rs?ref=7d09004aee288b3debfcfa734c77a4805ad76822", "patch": "@@ -60,7 +60,8 @@ fn test_corr() {\n         r2 //                                        |                    |\n     }); //                                           |                    |\n     //                                               |synchronizes-with   |happens-before\n-    let j3 = spawn(move || { //                      |                    |\n+    let j3 = spawn(move || {\n+        //                      |                    |\n         acquires_value(&y, 1); // <------------------+                    |\n         x.load(Relaxed) // <----------------------------------------------+\n         // The two reads on x are ordered by hb, so they cannot observe values\n@@ -84,12 +85,14 @@ fn test_wrc() {\n         x.store(1, Release); // ---------------------+---------------------+\n     }); //                                           |                     |\n     //                                               |synchronizes-with    |\n-    let j2 = spawn(move || { //                      |                     |\n+    let j2 = spawn(move || {\n+        //                      |                     |\n         acquires_value(&x, 1); // <------------------+                     |\n         y.store(1, Release); // ---------------------+                     |happens-before\n     }); //                                           |                     |\n     //                                               |synchronizes-with    |\n-    let j3 = spawn(move || { //                      |                     |\n+    let j3 = spawn(move || {\n+        //                      |                     |\n         acquires_value(&y, 1); // <------------------+                     |\n         x.load(Relaxed) // <-----------------------------------------------+\n     });\n@@ -112,7 +115,8 @@ fn test_message_passing() {\n         y.store(1, Release); // ---------------------+                   |\n     }); //                                           |                   |\n     //                                               |synchronizes-with  | happens-before\n-    let j2 = spawn(move || { //                      |                   |\n+    let j2 = spawn(move || {\n+        //                      |                   |\n         acquires_value(&y, 1); // <------------------+                   |\n         unsafe { *x.0 } // <---------------------------------------------+\n     });"}, {"sha": "74fec411b4c996fb07344434977c790a7f9f5b60", "filename": "tests/pass/concurrency/linux-futex.rs", "status": "modified", "additions": 102, "deletions": 93, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs?ref=7d09004aee288b3debfcfa734c77a4805ad76822", "patch": "@@ -16,25 +16,23 @@ fn wake_nobody() {\n \n     // Wake 1 waiter. Expect zero waiters woken up, as nobody is waiting.\n     unsafe {\n-        assert_eq!(libc::syscall(\n-            libc::SYS_futex,\n-            &futex as *const i32,\n-            libc::FUTEX_WAKE,\n-            1,\n-        ), 0);\n+        assert_eq!(libc::syscall(libc::SYS_futex, &futex as *const i32, libc::FUTEX_WAKE, 1,), 0);\n     }\n \n     // Same, but without omitting the unused arguments.\n     unsafe {\n-        assert_eq!(libc::syscall(\n-            libc::SYS_futex,\n-            &futex as *const i32,\n-            libc::FUTEX_WAKE,\n-            1,\n-            ptr::null::<libc::timespec>(),\n-            0usize,\n-            0,\n-        ), 0);\n+        assert_eq!(\n+            libc::syscall(\n+                libc::SYS_futex,\n+                &futex as *const i32,\n+                libc::FUTEX_WAKE,\n+                1,\n+                ptr::null::<libc::timespec>(),\n+                0usize,\n+                0,\n+            ),\n+            0\n+        );\n     }\n }\n \n@@ -45,12 +43,7 @@ fn wake_dangling() {\n \n     // Wake 1 waiter. Expect zero waiters woken up, as nobody is waiting.\n     unsafe {\n-        assert_eq!(libc::syscall(\n-            libc::SYS_futex,\n-            ptr,\n-            libc::FUTEX_WAKE,\n-            1,\n-        ), 0);\n+        assert_eq!(libc::syscall(libc::SYS_futex, ptr, libc::FUTEX_WAKE, 1,), 0);\n     }\n }\n \n@@ -59,13 +52,16 @@ fn wait_wrong_val() {\n \n     // Only wait if the futex value is 456.\n     unsafe {\n-        assert_eq!(libc::syscall(\n-            libc::SYS_futex,\n-            &futex as *const i32,\n-            libc::FUTEX_WAIT,\n-            456,\n-            ptr::null::<libc::timespec>(),\n-        ), -1);\n+        assert_eq!(\n+            libc::syscall(\n+                libc::SYS_futex,\n+                &futex as *const i32,\n+                libc::FUTEX_WAIT,\n+                456,\n+                ptr::null::<libc::timespec>(),\n+            ),\n+            -1\n+        );\n         assert_eq!(*libc::__errno_location(), libc::EAGAIN);\n     }\n }\n@@ -77,16 +73,16 @@ fn wait_timeout() {\n \n     // Wait for 200ms, with nobody waking us up early.\n     unsafe {\n-        assert_eq!(libc::syscall(\n-            libc::SYS_futex,\n-            &futex as *const i32,\n-            libc::FUTEX_WAIT,\n-            123,\n-            &libc::timespec {\n-                tv_sec: 0,\n-                tv_nsec: 200_000_000,\n-            },\n-        ), -1);\n+        assert_eq!(\n+            libc::syscall(\n+                libc::SYS_futex,\n+                &futex as *const i32,\n+                libc::FUTEX_WAIT,\n+                123,\n+                &libc::timespec { tv_sec: 0, tv_nsec: 200_000_000 },\n+            ),\n+            -1\n+        );\n         assert_eq!(*libc::__errno_location(), libc::ETIMEDOUT);\n     }\n \n@@ -114,15 +110,18 @@ fn wait_absolute_timeout() {\n \n     // Wait for 200ms from now, with nobody waking us up early.\n     unsafe {\n-        assert_eq!(libc::syscall(\n-            libc::SYS_futex,\n-            &futex as *const i32,\n-            libc::FUTEX_WAIT_BITSET,\n-            123,\n-            &timeout,\n-            0usize,\n-            u32::MAX,\n-        ), -1);\n+        assert_eq!(\n+            libc::syscall(\n+                libc::SYS_futex,\n+                &futex as *const i32,\n+                libc::FUTEX_WAIT_BITSET,\n+                123,\n+                &timeout,\n+                0usize,\n+                u32::MAX,\n+            ),\n+            -1\n+        );\n         assert_eq!(*libc::__errno_location(), libc::ETIMEDOUT);\n     }\n \n@@ -137,23 +136,29 @@ fn wait_wake() {\n     let t = thread::spawn(move || {\n         thread::sleep(Duration::from_millis(200));\n         unsafe {\n-            assert_eq!(libc::syscall(\n-                libc::SYS_futex,\n-                &FUTEX as *const i32,\n-                libc::FUTEX_WAKE,\n-                10, // Wake up at most 10 threads.\n-            ), 1); // Woken up one thread.\n+            assert_eq!(\n+                libc::syscall(\n+                    libc::SYS_futex,\n+                    &FUTEX as *const i32,\n+                    libc::FUTEX_WAKE,\n+                    10, // Wake up at most 10 threads.\n+                ),\n+                1\n+            ); // Woken up one thread.\n         }\n     });\n \n     unsafe {\n-        assert_eq!(libc::syscall(\n-            libc::SYS_futex,\n-            &FUTEX as *const i32,\n-            libc::FUTEX_WAIT,\n-            0,\n-            ptr::null::<libc::timespec>(),\n-        ), 0);\n+        assert_eq!(\n+            libc::syscall(\n+                libc::SYS_futex,\n+                &FUTEX as *const i32,\n+                libc::FUTEX_WAIT,\n+                0,\n+                ptr::null::<libc::timespec>(),\n+            ),\n+            0\n+        );\n     }\n \n     assert!((200..1000).contains(&start.elapsed().as_millis()));\n@@ -168,40 +173,49 @@ fn wait_wake_bitset() {\n     let t = thread::spawn(move || {\n         thread::sleep(Duration::from_millis(200));\n         unsafe {\n-            assert_eq!(libc::syscall(\n-                libc::SYS_futex,\n-                &FUTEX as *const i32,\n-                libc::FUTEX_WAKE_BITSET,\n-                10, // Wake up at most 10 threads.\n-                ptr::null::<libc::timespec>(),\n-                0usize,\n-                0b1001, // bitset\n-            ), 0); // Didn't match any thread.\n+            assert_eq!(\n+                libc::syscall(\n+                    libc::SYS_futex,\n+                    &FUTEX as *const i32,\n+                    libc::FUTEX_WAKE_BITSET,\n+                    10, // Wake up at most 10 threads.\n+                    ptr::null::<libc::timespec>(),\n+                    0usize,\n+                    0b1001, // bitset\n+                ),\n+                0\n+            ); // Didn't match any thread.\n         }\n         thread::sleep(Duration::from_millis(200));\n         unsafe {\n-            assert_eq!(libc::syscall(\n-                libc::SYS_futex,\n-                &FUTEX as *const i32,\n-                libc::FUTEX_WAKE_BITSET,\n-                10, // Wake up at most 10 threads.\n-                ptr::null::<libc::timespec>(),\n-                0usize,\n-                0b0110, // bitset\n-            ), 1); // Woken up one thread.\n+            assert_eq!(\n+                libc::syscall(\n+                    libc::SYS_futex,\n+                    &FUTEX as *const i32,\n+                    libc::FUTEX_WAKE_BITSET,\n+                    10, // Wake up at most 10 threads.\n+                    ptr::null::<libc::timespec>(),\n+                    0usize,\n+                    0b0110, // bitset\n+                ),\n+                1\n+            ); // Woken up one thread.\n         }\n     });\n \n     unsafe {\n-        assert_eq!(libc::syscall(\n-            libc::SYS_futex,\n-            &FUTEX as *const i32,\n-            libc::FUTEX_WAIT_BITSET,\n-            0,\n-            ptr::null::<libc::timespec>(),\n-            0usize,\n-            0b0100, // bitset\n-        ), 0);\n+        assert_eq!(\n+            libc::syscall(\n+                libc::SYS_futex,\n+                &FUTEX as *const i32,\n+                libc::FUTEX_WAIT_BITSET,\n+                0,\n+                ptr::null::<libc::timespec>(),\n+                0usize,\n+                0b0100, // bitset\n+            ),\n+            0\n+        );\n     }\n \n     assert!((400..1000).contains(&start.elapsed().as_millis()));\n@@ -237,12 +251,7 @@ fn concurrent_wait_wake() {\n \n         FUTEX.store(FREE, Ordering::Relaxed);\n         unsafe {\n-            libc::syscall(\n-                libc::SYS_futex,\n-                &FUTEX as *const AtomicI32,\n-                libc::FUTEX_WAKE,\n-                1,\n-            );\n+            libc::syscall(libc::SYS_futex, &FUTEX as *const AtomicI32, libc::FUTEX_WAKE, 1);\n         }\n \n         t.join().unwrap();"}, {"sha": "4803792a97ceea462741aa00475e07129f0d1426", "filename": "tests/pass/deriving-associated-types.rs", "status": "modified", "additions": 37, "deletions": 76, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Fpass%2Fderiving-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Fpass%2Fderiving-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fderiving-associated-types.rs?ref=7d09004aee288b3debfcfa734c77a4805ad76822", "patch": "@@ -40,10 +40,15 @@ struct TupleStruct<A, B: DeclaredTrait, C>(\n     <C as WhereTrait>::Type,\n     Option<<C as WhereTrait>::Type>,\n     <i32 as DeclaredTrait>::Type,\n-) where C: WhereTrait;\n+)\n+where\n+    C: WhereTrait;\n \n #[derive(PartialEq, Debug)]\n-pub struct Struct<A, B: DeclaredTrait, C> where C: WhereTrait {\n+pub struct Struct<A, B: DeclaredTrait, C>\n+where\n+    C: WhereTrait,\n+{\n     m1: module::Type,\n     m2: Option<module::Type>,\n     a1: A,\n@@ -62,7 +67,10 @@ pub struct Struct<A, B: DeclaredTrait, C> where C: WhereTrait {\n }\n \n #[derive(PartialEq, Debug)]\n-enum Enum<A, B: DeclaredTrait, C> where C: WhereTrait {\n+enum Enum<A, B: DeclaredTrait, C>\n+where\n+    C: WhereTrait,\n+{\n     Unit,\n     Seq(\n         module::Type,\n@@ -101,35 +109,11 @@ enum Enum<A, B: DeclaredTrait, C> where C: WhereTrait {\n }\n \n fn main() {\n-\n-    let e: Enum<\n-        i32,\n-        i32,\n-        i32,\n-    > = Enum::Seq(\n-        0,\n-        None,\n-        0,\n-        PrivateStruct(0),\n-        0,\n-        0,\n-        None,\n-        0,\n-        None,\n-        0,\n-        0,\n-        None,\n-        0,\n-        None,\n-        0,\n-    );\n+    let e: Enum<i32, i32, i32> =\n+        Enum::Seq(0, None, 0, PrivateStruct(0), 0, 0, None, 0, None, 0, 0, None, 0, None, 0);\n     assert_eq!(e, e);\n \n-    let e: Enum<\n-        i32,\n-        i32,\n-        i32,\n-    > = Enum::Map {\n+    let e: Enum<i32, i32, i32> = Enum::Map {\n         m1: 0,\n         m2: None,\n         a1: 0,\n@@ -147,52 +131,29 @@ fn main() {\n         d: 0,\n     };\n     assert_eq!(e, e);\n-        let e: TupleStruct<\n-            i32,\n-            i32,\n-            i32,\n-        > = TupleStruct(\n-            0,\n-            None,\n-            0,\n-            PrivateStruct(0),\n-            0,\n-            0,\n-            None,\n-            0,\n-            None,\n-            0,\n-            0,\n-            None,\n-            0,\n-            None,\n-            0,\n-        );\n-        assert_eq!(e, e);\n+    let e: TupleStruct<i32, i32, i32> =\n+        TupleStruct(0, None, 0, PrivateStruct(0), 0, 0, None, 0, None, 0, 0, None, 0, None, 0);\n+    assert_eq!(e, e);\n \n-        let e: Struct<\n-            i32,\n-            i32,\n-            i32,\n-        > = Struct {\n-            m1: 0,\n-            m2: None,\n-            a1: 0,\n-            a2: PrivateStruct(0),\n-            b: 0,\n-            b1: 0,\n-            b2: None,\n-            b3: 0,\n-            b4: None,\n-            c: 0,\n-            c1: 0,\n-            c2: None,\n-            c3: 0,\n-            c4: None,\n-            d: 0,\n-        };\n-        assert_eq!(e, e);\n+    let e: Struct<i32, i32, i32> = Struct {\n+        m1: 0,\n+        m2: None,\n+        a1: 0,\n+        a2: PrivateStruct(0),\n+        b: 0,\n+        b1: 0,\n+        b2: None,\n+        b3: 0,\n+        b4: None,\n+        c: 0,\n+        c1: 0,\n+        c2: None,\n+        c3: 0,\n+        c4: None,\n+        d: 0,\n+    };\n+    assert_eq!(e, e);\n \n-        let e = Enum::Unit::<i32, i32, i32>;\n-        assert_eq!(e, e);\n+    let e = Enum::Unit::<i32, i32, i32>;\n+    assert_eq!(e, e);\n }"}, {"sha": "a3ab5b21f0b3e7699a58c76c117bee165770891a", "filename": "tests/pass/heap_allocator.rs", "status": "modified", "additions": 70, "deletions": 38, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Fpass%2Fheap_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Fpass%2Fheap_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fheap_allocator.rs?ref=7d09004aee288b3debfcfa734c77a4805ad76822", "patch": "@@ -1,58 +1,90 @@\n #![feature(allocator_api, slice_ptr_get)]\n \n+use std::alloc::{Allocator, Global, Layout, System};\n use std::ptr::NonNull;\n-use std::alloc::{Global, Allocator, Layout, System};\n use std::slice;\n \n-fn check_alloc<T: Allocator>(allocator: T) { unsafe {\n-    for &align in &[4, 8, 16, 32] {\n-        let layout_20 = Layout::from_size_align(20, align).unwrap();\n-        let layout_40 = Layout::from_size_align(40, 4*align).unwrap();\n-        let layout_10 = Layout::from_size_align(10, align/2).unwrap();\n+fn check_alloc<T: Allocator>(allocator: T) {\n+    unsafe {\n+        for &align in &[4, 8, 16, 32] {\n+            let layout_20 = Layout::from_size_align(20, align).unwrap();\n+            let layout_40 = Layout::from_size_align(40, 4 * align).unwrap();\n+            let layout_10 = Layout::from_size_align(10, align / 2).unwrap();\n \n-        for _ in 0..32 {\n-            let a = allocator.allocate(layout_20).unwrap().as_non_null_ptr();\n-            assert_eq!(a.as_ptr() as usize % layout_20.align(), 0, \"pointer is incorrectly aligned\");\n-            allocator.deallocate(a, layout_20);\n-        }\n+            for _ in 0..32 {\n+                let a = allocator.allocate(layout_20).unwrap().as_non_null_ptr();\n+                assert_eq!(\n+                    a.as_ptr() as usize % layout_20.align(),\n+                    0,\n+                    \"pointer is incorrectly aligned\"\n+                );\n+                allocator.deallocate(a, layout_20);\n+            }\n \n-        let p1 = allocator.allocate_zeroed(layout_20).unwrap().as_non_null_ptr();\n-        assert_eq!(p1.as_ptr() as usize % layout_20.align(), 0, \"pointer is incorrectly aligned\");\n-        assert_eq!(*p1.as_ptr(), 0);\n+            let p1 = allocator.allocate_zeroed(layout_20).unwrap().as_non_null_ptr();\n+            assert_eq!(\n+                p1.as_ptr() as usize % layout_20.align(),\n+                0,\n+                \"pointer is incorrectly aligned\"\n+            );\n+            assert_eq!(*p1.as_ptr(), 0);\n \n-        // old size < new size\n-        let p2 = allocator.grow(p1, layout_20, layout_40).unwrap().as_non_null_ptr();\n-        assert_eq!(p2.as_ptr() as usize % layout_40.align(), 0, \"pointer is incorrectly aligned\");\n-        let slice = slice::from_raw_parts(p2.as_ptr(), 20);\n-        assert_eq!(&slice, &[0_u8; 20]);\n+            // old size < new size\n+            let p2 = allocator.grow(p1, layout_20, layout_40).unwrap().as_non_null_ptr();\n+            assert_eq!(\n+                p2.as_ptr() as usize % layout_40.align(),\n+                0,\n+                \"pointer is incorrectly aligned\"\n+            );\n+            let slice = slice::from_raw_parts(p2.as_ptr(), 20);\n+            assert_eq!(&slice, &[0_u8; 20]);\n \n-        // old size == new size\n-        let p3 = allocator.grow(p2, layout_40, layout_40).unwrap().as_non_null_ptr();\n-        assert_eq!(p3.as_ptr() as usize % layout_40.align(), 0, \"pointer is incorrectly aligned\");\n-        let slice = slice::from_raw_parts(p3.as_ptr(), 20);\n-        assert_eq!(&slice, &[0_u8; 20]);\n+            // old size == new size\n+            let p3 = allocator.grow(p2, layout_40, layout_40).unwrap().as_non_null_ptr();\n+            assert_eq!(\n+                p3.as_ptr() as usize % layout_40.align(),\n+                0,\n+                \"pointer is incorrectly aligned\"\n+            );\n+            let slice = slice::from_raw_parts(p3.as_ptr(), 20);\n+            assert_eq!(&slice, &[0_u8; 20]);\n \n-        // old size > new size\n-        let p4 = allocator.shrink(p3, layout_40, layout_10).unwrap().as_non_null_ptr();\n-        assert_eq!(p4.as_ptr() as usize % layout_10.align(), 0, \"pointer is incorrectly aligned\");\n-        let slice = slice::from_raw_parts(p4.as_ptr(), 10);\n-        assert_eq!(&slice, &[0_u8; 10]);\n+            // old size > new size\n+            let p4 = allocator.shrink(p3, layout_40, layout_10).unwrap().as_non_null_ptr();\n+            assert_eq!(\n+                p4.as_ptr() as usize % layout_10.align(),\n+                0,\n+                \"pointer is incorrectly aligned\"\n+            );\n+            let slice = slice::from_raw_parts(p4.as_ptr(), 10);\n+            assert_eq!(&slice, &[0_u8; 10]);\n \n-        allocator.deallocate(p4, layout_10);\n+            allocator.deallocate(p4, layout_10);\n+        }\n     }\n-} }\n+}\n \n fn check_align_requests<T: Allocator>(allocator: T) {\n-    for &size in &[2, 8, 64] { // size less than and bigger than alignment\n-        for &align in &[4, 8, 16, 32] { // Be sure to cover less than and bigger than `MIN_ALIGN` for all architectures\n+    for &size in &[2, 8, 64] {\n+        // size less than and bigger than alignment\n+        for &align in &[4, 8, 16, 32] {\n+            // Be sure to cover less than and bigger than `MIN_ALIGN` for all architectures\n             let iterations = 32;\n             unsafe {\n-                let pointers: Vec<_> = (0..iterations).map(|_| {\n-                    allocator.allocate(Layout::from_size_align(size, align).unwrap()).unwrap().as_non_null_ptr()\n-                }).collect();\n+                let pointers: Vec<_> = (0..iterations)\n+                    .map(|_| {\n+                        allocator\n+                            .allocate(Layout::from_size_align(size, align).unwrap())\n+                            .unwrap()\n+                            .as_non_null_ptr()\n+                    })\n+                    .collect();\n                 for &ptr in &pointers {\n-                    assert_eq!((ptr.as_ptr() as usize) % align, 0,\n-                            \"Got a pointer less aligned than requested\")\n+                    assert_eq!(\n+                        (ptr.as_ptr() as usize) % align,\n+                        0,\n+                        \"Got a pointer less aligned than requested\"\n+                    )\n                 }\n \n                 // Clean up."}, {"sha": "8ee03d1126413cfafa9041c73d302972a1e540ca", "filename": "tests/pass/iter.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Fpass%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d09004aee288b3debfcfa734c77a4805ad76822/tests%2Fpass%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fiter.rs?ref=7d09004aee288b3debfcfa734c77a4805ad76822", "patch": "@@ -1,5 +1,6 @@\n fn iter_empty_and_zst() {\n-    for _ in Vec::<u32>::new().iter() { // this iterates over a Unique::empty()\n+    for _ in Vec::<u32>::new().iter() {\n+        // this iterates over a Unique::empty()\n         panic!(\"We should never be here.\");\n     }\n \n@@ -21,13 +22,13 @@ fn test_iterator_step_by_nth() {\n }\n \n fn iter_any() {\n-    let f = |x: &u8| { 10u8 == *x };\n+    let f = |x: &u8| 10u8 == *x;\n     f(&1u8);\n \n-    let g = |(), x: &u8| { 10u8 == *x };\n+    let g = |(), x: &u8| 10u8 == *x;\n     g((), &1u8);\n \n-    let h = |(), (), x: &u8| { 10u8 == *x };\n+    let h = |(), (), x: &u8| 10u8 == *x;\n     h((), (), &1u8);\n \n     [1, 2, 3u8].iter().any(|elt| 10 == *elt);"}]}