{"sha": "69861df831a2d0c551b46a291c2530aeeab6c704", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5ODYxZGY4MzFhMmQwYzU1MWI0NmEyOTFjMjUzMGFlZWFiNmM3MDQ=", "commit": {"author": {"name": "Alexander Light", "email": "allight@cs.brown.edu", "date": "2014-11-21T22:56:33Z"}, "committer": {"name": "Alexander Light", "email": "allight@cs.brown.edu", "date": "2014-11-21T22:56:33Z"}, "message": "Shuffle locations for Deref\n\nRemove both `strong_count` and `weak_count` from `Weak`s and make the\nmethods bare functions so as not to cause trouble with `deref`.", "tree": {"sha": "fe9457503bc7622c5d5fab66a6819153033b7b7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe9457503bc7622c5d5fab66a6819153033b7b7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69861df831a2d0c551b46a291c2530aeeab6c704", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69861df831a2d0c551b46a291c2530aeeab6c704", "html_url": "https://github.com/rust-lang/rust/commit/69861df831a2d0c551b46a291c2530aeeab6c704", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69861df831a2d0c551b46a291c2530aeeab6c704/comments", "author": null, "committer": null, "parents": [{"sha": "4c36ad01e709448e8090b79ac96d0a6bb0607b23", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c36ad01e709448e8090b79ac96d0a6bb0607b23", "html_url": "https://github.com/rust-lang/rust/commit/4c36ad01e709448e8090b79ac96d0a6bb0607b23"}], "stats": {"total": 149, "additions": 57, "deletions": 92}, "files": [{"sha": "4f744b0b2dee1b271a2e99e646871dd65cd92920", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 30, "deletions": 51, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/69861df831a2d0c551b46a291c2530aeeab6c704/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69861df831a2d0c551b46a291c2530aeeab6c704/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=69861df831a2d0c551b46a291c2530aeeab6c704", "patch": "@@ -117,17 +117,17 @@ impl<T> Arc<T> {\n         // these contents.\n         unsafe { &*self._ptr }\n     }\n+}\n \n-    /// Get the number of weak references to this value.\n-    #[inline]\n-    #[experimental]\n-    pub fn weak_count(&self) -> uint { self.inner().weak.load(atomic::SeqCst) - 1 }\n+/// Get the number of weak references to this value.\n+#[inline]\n+#[experimental]\n+pub fn weak_count<T>(this: &Arc<T>) -> uint { this.inner().weak.load(atomic::SeqCst) - 1 }\n \n-    /// Get the number of strong references to this value.\n-    #[inline]\n-    #[experimental]\n-    pub fn strong_count(&self) -> uint { self.inner().strong.load(atomic::SeqCst) }\n-}\n+/// Get the number of strong references to this value.\n+#[inline]\n+#[experimental]\n+pub fn strong_count<T>(this: &Arc<T>) -> uint { this.inner().strong.load(atomic::SeqCst) }\n \n #[unstable = \"waiting on stability of Clone\"]\n impl<T> Clone for Arc<T> {\n@@ -257,29 +257,6 @@ impl<T: Sync + Send> Weak<T> {\n         // See comments above for why this is \"safe\"\n         unsafe { &*self._ptr }\n     }\n-\n-    // Why is there no `weak_count()`?\n-    //\n-    // It is not possible to determine the number of weak references with only a weak reference\n-    // accurately in a wait-free manner. This is because we have a data-race with the last strong\n-    // reference's `drop` method. If that operation pauses between decrementing the strong\n-    // reference count to 0 and removing the implicit weak reference that the strong references\n-    // share then we will incorrectly think there is one more weak reference then there really is.\n-    //\n-    // We cannot get around this without making parts of this object no longer wait-free, since we\n-    // would either need to use locks to get mutual exclusion with `drop` or make it so that the\n-    // weak and strong reference counts can be modified atomically together. The first option\n-    // destroys wait-freedom by adding a lock and the second (in addition to being annoying to\n-    // implement) would make many operations (at least `downgrade` and both `clone`s) go from being\n-    // wait-free to merely lock-free, as we would need to do a manual CAS loop to get around other\n-    // threads modifying the other value in each of these cases.\n-\n-    /// Get the number of strong references to this value.\n-    ///\n-    /// If this function returns 0 then the value has been freed.\n-    #[inline]\n-    #[experimental]\n-    pub fn strong_count(&self) -> uint { self.inner().strong.load(atomic::SeqCst) }\n }\n \n #[experimental = \"Weak pointers may not belong in this module.\"]\n@@ -354,7 +331,7 @@ mod tests {\n     use std::sync::atomic;\n     use std::task;\n     use std::vec::Vec;\n-    use super::{Arc, Weak};\n+    use super::{Arc, Weak, weak_count, strong_count};\n     use std::sync::Mutex;\n \n     struct Canary(*mut atomic::AtomicUint);\n@@ -501,38 +478,40 @@ mod tests {\n     #[test]\n     fn test_strong_count() {\n         let a = Arc::new(0u32);\n-        assert!(a.strong_count() == 1);\n+        assert!(strong_count(&a) == 1);\n         let w = a.downgrade();\n-        assert!(a.strong_count() == 1);\n+        assert!(strong_count(&a) == 1);\n         let b = w.upgrade().expect(\"\");\n-        assert!(b.strong_count() == 2);\n-        assert!(a.strong_count() == 2);\n+        assert!(strong_count(&b) == 2);\n+        assert!(strong_count(&a) == 2);\n         drop(w);\n         drop(a);\n-        assert!(b.strong_count() == 1);\n+        assert!(strong_count(&b) == 1);\n         let c = b.clone();\n-        assert!(b.strong_count() == 2);\n-        assert!(c.strong_count() == 2);\n+        assert!(strong_count(&b) == 2);\n+        assert!(strong_count(&c) == 2);\n     }\n \n     #[test]\n     fn test_weak_count() {\n         let a = Arc::new(0u32);\n-        assert!(a.strong_count() == 1);\n-        assert!(a.weak_count() == 0);\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 0);\n         let w = a.downgrade();\n-        assert!(a.strong_count() == 1);\n-        assert!(w.strong_count() == 1);\n-        assert!(a.weak_count() == 1);\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 1);\n+        let x = w.clone();\n+        assert!(weak_count(&a) == 2);\n         drop(w);\n-        assert!(a.strong_count() == 1);\n-        assert!(a.weak_count() == 0);\n+        drop(x);\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 0);\n         let c = a.clone();\n-        assert!(a.strong_count() == 2);\n-        assert!(a.weak_count() == 0);\n+        assert!(strong_count(&a) == 2);\n+        assert!(weak_count(&a) == 0);\n         let d = c.downgrade();\n-        assert!(c.weak_count() == 1);\n-        assert!(c.strong_count() == 2);\n+        assert!(weak_count(&c) == 1);\n+        assert!(strong_count(&c) == 2);\n \n         drop(a);\n         drop(c);"}, {"sha": "df84ac9aec93550a467539c36bb312880a5f0de9", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 27, "deletions": 41, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/69861df831a2d0c551b46a291c2530aeeab6c704/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69861df831a2d0c551b46a291c2530aeeab6c704/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=69861df831a2d0c551b46a291c2530aeeab6c704", "patch": "@@ -211,17 +211,17 @@ impl<T> Rc<T> {\n             _noshare: marker::NoSync\n         }\n     }\n+}\n \n-    /// Get the number of weak references to this value.\n-    #[inline]\n-    #[experimental]\n-    pub fn weak_count(&self) -> uint { self.weak() - 1 }\n+/// Get the number of weak references to this value.\n+#[inline]\n+#[experimental]\n+pub fn weak_count<T>(this: &Rc<T>) -> uint { this.weak() - 1 }\n \n-    /// Get the number of strong references to this value.\n-    #[inline]\n-    #[experimental]\n-    pub fn strong_count(&self) -> uint { self.strong() }\n-}\n+/// Get the number of strong references to this value.\n+#[inline]\n+#[experimental]\n+pub fn strong_count<T>(this: &Rc<T>) -> uint { this.strong() }\n \n /// Returns true if the `Rc` currently has unique ownership.\n ///\n@@ -230,7 +230,7 @@ impl<T> Rc<T> {\n #[inline]\n #[experimental]\n pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n-    rc.weak_count() == 0 && rc.strong_count() == 1\n+    weak_count(rc) == 0 && strong_count(rc) == 1\n }\n \n /// Unwraps the contained value if the `Rc` has unique ownership.\n@@ -433,20 +433,6 @@ impl<T> Weak<T> {\n             Some(Rc { _ptr: self._ptr, _nosend: marker::NoSend, _noshare: marker::NoSync })\n         }\n     }\n-\n-    /// Get the number of weak references to this value.\n-    #[inline]\n-    #[experimental]\n-    pub fn weak_count(&self) -> uint {\n-        if self.strong() != 0 { self.weak() - 1 } else { self.weak() }\n-    }\n-\n-    /// Get the number of strong references to this value.\n-    ///\n-    /// If this function returns 0 then the value has been freed.\n-    #[inline]\n-    #[experimental]\n-    pub fn strong_count(&self) -> uint { self.strong() }\n }\n \n #[unsafe_destructor]\n@@ -512,7 +498,7 @@ impl<T> RcBoxPtr<T> for Weak<T> {\n #[cfg(test)]\n #[allow(experimental)]\n mod tests {\n-    use super::{Rc, Weak};\n+    use super::{Rc, Weak, weak_count, strong_count};\n     use std::cell::RefCell;\n     use std::option::{Option, Some, None};\n     use std::result::{Err, Ok};\n@@ -592,35 +578,35 @@ mod tests {\n     #[test]\n     fn test_strong_count() {\n         let a = Rc::new(0u32);\n-        assert!(a.strong_count() == 1);\n+        assert!(strong_count(&a) == 1);\n         let w = a.downgrade();\n-        assert!(a.strong_count() == 1);\n+        assert!(strong_count(&a) == 1);\n         let b = w.upgrade().expect(\"upgrade of live rc failed\");\n-        assert!(b.strong_count() == 2);\n-        assert!(a.strong_count() == 2);\n+        assert!(strong_count(&b) == 2);\n+        assert!(strong_count(&a) == 2);\n         drop(w);\n         drop(a);\n-        assert!(b.strong_count() == 1);\n+        assert!(strong_count(&b) == 1);\n         let c = b.clone();\n-        assert!(b.strong_count() == 2);\n-        assert!(c.strong_count() == 2);\n+        assert!(strong_count(&b) == 2);\n+        assert!(strong_count(&c) == 2);\n     }\n \n     #[test]\n     fn test_weak_count() {\n         let a = Rc::new(0u32);\n-        assert!(a.strong_count() == 1);\n-        assert!(a.weak_count() == 0);\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 0);\n         let w = a.downgrade();\n-        assert!(a.strong_count() == 1);\n-        assert!(w.weak_count() == 1);\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 1);\n         drop(w);\n-        assert!(a.strong_count() == 1);\n-        assert!(a.weak_count() == 0);\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 0);\n         let c = a.clone();\n-        assert!(a.strong_count() == 2);\n-        assert!(a.weak_count() == 0);\n-        assert!(c.downgrade().weak_count() == 1);\n+        assert!(strong_count(&a) == 2);\n+        assert!(weak_count(&a) == 0);\n+        drop(c);\n     }\n \n     #[test]"}]}