{"sha": "f21c08439a182cf16b60a88457dcbd3b72ea2cdc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyMWMwODQzOWExODJjZjE2YjYwYTg4NDU3ZGNiZDNiNzJlYTJjZGM=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-12-07T02:04:23Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-01-08T17:50:43Z"}, "message": "Move diagnostics out from QueryJob and optimize for the case with no diagnostics", "tree": {"sha": "f565a4e7c827d3a62afd1d19c92ec62915c905dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f565a4e7c827d3a62afd1d19c92ec62915c905dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f21c08439a182cf16b60a88457dcbd3b72ea2cdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f21c08439a182cf16b60a88457dcbd3b72ea2cdc", "html_url": "https://github.com/rust-lang/rust/commit/f21c08439a182cf16b60a88457dcbd3b72ea2cdc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f21c08439a182cf16b60a88457dcbd3b72ea2cdc/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8c8f0bdf62728198696cab7d00a8fdc3ee381d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8c8f0bdf62728198696cab7d00a8fdc3ee381d3", "html_url": "https://github.com/rust-lang/rust/commit/b8c8f0bdf62728198696cab7d00a8fdc3ee381d3"}], "stats": {"total": 113, "additions": 67, "deletions": 46}, "files": [{"sha": "501ef01d74c6e783cd5dc8e6e3ff55b72803dfdc", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f21c08439a182cf16b60a88457dcbd3b72ea2cdc/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f21c08439a182cf16b60a88457dcbd3b72ea2cdc/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=f21c08439a182cf16b60a88457dcbd3b72ea2cdc", "patch": "@@ -696,7 +696,7 @@ impl DepGraph {\n \n                 // Promote the previous diagnostics to the current session.\n                 tcx.queries.on_disk_cache\n-                   .store_diagnostics(dep_node_index, diagnostics.clone());\n+                   .store_diagnostics(dep_node_index, diagnostics.clone().into());\n \n                 for diagnostic in diagnostics {\n                     DiagnosticBuilder::new_diagnostic(handle, diagnostic).emit();"}, {"sha": "f31d644dbd96b14c2b0921f0c7f62265d119da84", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f21c08439a182cf16b60a88457dcbd3b72ea2cdc/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f21c08439a182cf16b60a88457dcbd3b72ea2cdc/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=f21c08439a182cf16b60a88457dcbd3b72ea2cdc", "patch": "@@ -1673,6 +1673,7 @@ impl<'gcx> GlobalCtxt<'gcx> {\n             let new_icx = ty::tls::ImplicitCtxt {\n                 tcx,\n                 query: icx.query.clone(),\n+                diagnostics: icx.diagnostics,\n                 layout_depth: icx.layout_depth,\n                 task_deps: icx.task_deps,\n             };\n@@ -1782,6 +1783,7 @@ pub mod tls {\n     use errors::{Diagnostic, TRACK_DIAGNOSTICS};\n     use rustc_data_structures::OnDrop;\n     use rustc_data_structures::sync::{self, Lrc, Lock};\n+    use rustc_data_structures::thin_vec::ThinVec;\n     use dep_graph::TaskDeps;\n \n     #[cfg(not(parallel_queries))]\n@@ -1801,10 +1803,14 @@ pub mod tls {\n         /// by `enter_local` with a new local interner\n         pub tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n \n-        /// The current query job, if any. This is updated by start_job in\n+        /// The current query job, if any. This is updated by JobOwner::start in\n         /// ty::query::plumbing when executing a query\n         pub query: Option<Lrc<query::QueryJob<'gcx>>>,\n \n+        /// Where to store diagnostics for the current query job, if any.\n+        /// This is updated by JobOwner::start in ty::query::plumbing when executing a query\n+        pub diagnostics: Option<&'a Lock<ThinVec<Diagnostic>>>,\n+\n         /// Used to prevent layout from recursing too deeply.\n         pub layout_depth: usize,\n \n@@ -1870,8 +1876,9 @@ pub mod tls {\n     fn track_diagnostic(diagnostic: &Diagnostic) {\n         with_context_opt(|icx| {\n             if let Some(icx) = icx {\n-                if let Some(ref query) = icx.query {\n-                    query.diagnostics.lock().push(diagnostic.clone());\n+                if let Some(ref diagnostics) = icx.diagnostics {\n+                    let mut diagnostics = diagnostics.lock();\n+                    diagnostics.extend(Some(diagnostic.clone()));\n                 }\n             }\n         })\n@@ -1938,6 +1945,7 @@ pub mod tls {\n             let icx = ImplicitCtxt {\n                 tcx,\n                 query: None,\n+                diagnostics: None,\n                 layout_depth: 0,\n                 task_deps: None,\n             };\n@@ -1967,6 +1975,7 @@ pub mod tls {\n         };\n         let icx = ImplicitCtxt {\n             query: None,\n+            diagnostics: None,\n             tcx,\n             layout_depth: 0,\n             task_deps: None,"}, {"sha": "d794429a8a7064cb12e1a3f4ac8b3f487359663e", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f21c08439a182cf16b60a88457dcbd3b72ea2cdc/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f21c08439a182cf16b60a88457dcbd3b72ea2cdc/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=f21c08439a182cf16b60a88457dcbd3b72ea2cdc", "patch": "@@ -14,7 +14,6 @@ use ty::query::{\n     config::QueryDescription,\n };\n use ty::context::TyCtxt;\n-use errors::Diagnostic;\n use std::process;\n use std::{fmt, ptr};\n \n@@ -54,9 +53,6 @@ pub struct QueryJob<'tcx> {\n     /// The parent query job which created this job and is implicitly waiting on it.\n     pub parent: Option<Lrc<QueryJob<'tcx>>>,\n \n-    /// Diagnostic messages which are emitted while the query executes\n-    pub diagnostics: Lock<Vec<Diagnostic>>,\n-\n     /// The latch which is used to wait on this job\n     #[cfg(parallel_queries)]\n     latch: QueryLatch<'tcx>,\n@@ -66,7 +62,6 @@ impl<'tcx> QueryJob<'tcx> {\n     /// Creates a new query job\n     pub fn new(info: QueryInfo<'tcx>, parent: Option<Lrc<QueryJob<'tcx>>>) -> Self {\n         QueryJob {\n-            diagnostics: Lock::new(Vec::new()),\n             info,\n             parent,\n             #[cfg(parallel_queries)]"}, {"sha": "a674e942b3893c97049123eb9d632903770d374d", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f21c08439a182cf16b60a88457dcbd3b72ea2cdc/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f21c08439a182cf16b60a88457dcbd3b72ea2cdc/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=f21c08439a182cf16b60a88457dcbd3b72ea2cdc", "patch": "@@ -7,6 +7,7 @@ use ich::{CachingSourceMapView, Fingerprint};\n use mir::{self, interpret};\n use mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::sync::{Lrc, Lock, HashMapExt, Once};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder, opaque,\n@@ -341,11 +342,13 @@ impl<'sess> OnDiskCache<'sess> {\n     /// Store a diagnostic emitted during the current compilation session.\n     /// Anything stored like this will be available via `load_diagnostics` in\n     /// the next compilation session.\n+    #[inline(never)]\n+    #[cold]\n     pub fn store_diagnostics(&self,\n                              dep_node_index: DepNodeIndex,\n-                             diagnostics: Vec<Diagnostic>) {\n+                             diagnostics: ThinVec<Diagnostic>) {\n         let mut current_diagnostics = self.current_diagnostics.borrow_mut();\n-        let prev = current_diagnostics.insert(dep_node_index, diagnostics);\n+        let prev = current_diagnostics.insert(dep_node_index, diagnostics.into());\n         debug_assert!(prev.is_none());\n     }\n \n@@ -367,16 +370,16 @@ impl<'sess> OnDiskCache<'sess> {\n     /// Since many anonymous queries can share the same `DepNode`, we aggregate\n     /// them -- as opposed to regular queries where we assume that there is a\n     /// 1:1 relationship between query-key and `DepNode`.\n+    #[inline(never)]\n+    #[cold]\n     pub fn store_diagnostics_for_anon_node(&self,\n                                            dep_node_index: DepNodeIndex,\n-                                           mut diagnostics: Vec<Diagnostic>) {\n+                                           diagnostics: ThinVec<Diagnostic>) {\n         let mut current_diagnostics = self.current_diagnostics.borrow_mut();\n \n-        let x = current_diagnostics.entry(dep_node_index).or_insert_with(|| {\n-            mem::replace(&mut diagnostics, Vec::new())\n-        });\n+        let x = current_diagnostics.entry(dep_node_index).or_insert(Vec::new());\n \n-        x.extend(diagnostics.into_iter());\n+        x.extend(Into::<Vec<_>>::into(diagnostics));\n     }\n \n     fn load_indexed<'tcx, T>(&self,"}, {"sha": "3f50758a009af622587fbd1c781d58041f2849e6", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 44, "deletions": 30, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f21c08439a182cf16b60a88457dcbd3b72ea2cdc/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f21c08439a182cf16b60a88457dcbd3b72ea2cdc/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=f21c08439a182cf16b60a88457dcbd3b72ea2cdc", "patch": "@@ -18,6 +18,7 @@ use util::common::{profq_msg, ProfileQueriesMsg, QueryMsg};\n \n use rustc_data_structures::fx::{FxHashMap};\n use rustc_data_structures::sync::{Lrc, Lock};\n+use rustc_data_structures::thin_vec::ThinVec;\n use std::mem;\n use std::ptr;\n use std::collections::hash_map::Entry;\n@@ -195,19 +196,21 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n     pub(super) fn start<'lcx, F, R>(\n         &self,\n         tcx: TyCtxt<'_, 'tcx, 'lcx>,\n+        diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n         compute: F)\n-    -> (R, Vec<Diagnostic>)\n+    -> R\n     where\n         F: for<'b> FnOnce(TyCtxt<'b, 'tcx, 'lcx>) -> R\n     {\n         // The TyCtxt stored in TLS has the same global interner lifetime\n         // as `tcx`, so we use `with_related_context` to relate the 'gcx lifetimes\n         // when accessing the ImplicitCtxt\n-        let r = tls::with_related_context(tcx, move |current_icx| {\n+        tls::with_related_context(tcx, move |current_icx| {\n             // Update the ImplicitCtxt to point to our new query job\n             let new_icx = tls::ImplicitCtxt {\n                 tcx: tcx.global_tcx(),\n                 query: Some(self.job.clone()),\n+                diagnostics,\n                 layout_depth: current_icx.layout_depth,\n                 task_deps: current_icx.task_deps,\n             };\n@@ -216,13 +219,19 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n             tls::enter_context(&new_icx, |_| {\n                 compute(tcx)\n             })\n-        });\n+        })\n+    }\n \n-        // Extract the diagnostic from the job\n-        let diagnostics = mem::replace(&mut *self.job.diagnostics.lock(), Vec::new());\n+}\n \n-        (r, diagnostics)\n-    }\n+#[inline(always)]\n+fn with_diagnostics<F, R>(f: F) -> (R, ThinVec<Diagnostic>)\n+where\n+    F: FnOnce(Option<&Lock<ThinVec<Diagnostic>>>) -> R\n+{\n+    let diagnostics = Lock::new(ThinVec::new());\n+    let result = f(Some(&diagnostics));\n+    (result, diagnostics.into_inner())\n }\n \n impl<'a, 'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'a, 'tcx, Q> {\n@@ -402,20 +411,23 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n             self.sess.profiler(|p| p.start_activity(Q::CATEGORY));\n \n-            let res = job.start(self, |tcx| {\n-                tcx.dep_graph.with_anon_task(dep_node.kind, || {\n-                    Q::compute(tcx.global_tcx(), key)\n+            let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n+                job.start(self, diagnostics, |tcx| {\n+                    tcx.dep_graph.with_anon_task(dep_node.kind, || {\n+                        Q::compute(tcx.global_tcx(), key)\n+                    })\n                 })\n             });\n \n             self.sess.profiler(|p| p.end_activity(Q::CATEGORY));\n             profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n-            let ((result, dep_node_index), diagnostics) = res;\n \n             self.dep_graph.read_index(dep_node_index);\n \n-            self.queries.on_disk_cache\n-                .store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n+            if unlikely!(!diagnostics.is_empty()) {\n+                self.queries.on_disk_cache\n+                    .store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n+            }\n \n             job.complete(&result, dep_node_index);\n \n@@ -487,7 +499,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             // The diagnostics for this query have already been\n             // promoted to the current session during\n             // try_mark_green(), so we can ignore them here.\n-            let (result, _) = job.start(self, |tcx| {\n+            let result = job.start(self, None, |tcx| {\n                 // The dep-graph for this computation is already in\n                 // place\n                 tcx.dep_graph.with_ignore(|| {\n@@ -566,32 +578,34 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n         self.sess.profiler(|p| p.start_activity(Q::CATEGORY));\n \n-        let res = job.start(self, |tcx| {\n-            if dep_node.kind.is_eval_always() {\n-                tcx.dep_graph.with_eval_always_task(dep_node,\n-                                                    tcx,\n-                                                    key,\n-                                                    Q::compute)\n-            } else {\n-                tcx.dep_graph.with_task(dep_node,\n-                                        tcx,\n-                                        key,\n-                                        Q::compute)\n-            }\n+        let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n+            job.start(self, diagnostics, |tcx| {\n+                if dep_node.kind.is_eval_always() {\n+                    tcx.dep_graph.with_eval_always_task(dep_node,\n+                                                        tcx,\n+                                                        key,\n+                                                        Q::compute)\n+                } else {\n+                    tcx.dep_graph.with_task(dep_node,\n+                                            tcx,\n+                                            key,\n+                                            Q::compute)\n+                }\n+            })\n         });\n \n         self.sess.profiler(|p| p.end_activity(Q::CATEGORY));\n         profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n \n-        let ((result, dep_node_index), diagnostics) = res;\n-\n         if unlikely!(self.sess.opts.debugging_opts.query_dep_graph) {\n             self.dep_graph.mark_loaded_from_cache(dep_node_index, false);\n         }\n \n         if dep_node.kind != ::dep_graph::DepKind::Null {\n-            self.queries.on_disk_cache\n-                .store_diagnostics(dep_node_index, diagnostics);\n+            if unlikely!(!diagnostics.is_empty()) {\n+                self.queries.on_disk_cache\n+                    .store_diagnostics(dep_node_index, diagnostics);\n+            }\n         }\n \n         job.complete(&result, dep_node_index);"}]}