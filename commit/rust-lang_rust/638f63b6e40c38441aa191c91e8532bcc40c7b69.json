{"sha": "638f63b6e40c38441aa191c91e8532bcc40c7b69", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzOGY2M2I2ZTQwYzM4NDQxYWExOTFjOTFlODUzMmJjYzQwYzdiNjk=", "commit": {"author": {"name": "chansuke", "email": "chansuke@georepublic.de", "date": "2019-06-05T18:16:41Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-16T11:17:01Z"}, "message": "Separate librustc module", "tree": {"sha": "84c68e493488ba3ab7a4c391ab70c216ee357832", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84c68e493488ba3ab7a4c391ab70c216ee357832"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/638f63b6e40c38441aa191c91e8532bcc40c7b69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/638f63b6e40c38441aa191c91e8532bcc40c7b69", "html_url": "https://github.com/rust-lang/rust/commit/638f63b6e40c38441aa191c91e8532bcc40c7b69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/638f63b6e40c38441aa191c91e8532bcc40c7b69/comments", "author": null, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8bc00772901fe19c381a636c3c1680d0363d62a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8bc00772901fe19c381a636c3c1680d0363d62a", "html_url": "https://github.com/rust-lang/rust/commit/b8bc00772901fe19c381a636c3c1680d0363d62a"}], "stats": {"total": 1415, "additions": 707, "deletions": 708}, "files": [{"sha": "aadafd2bd509e0a356052d28f4d837ecf3be10e3", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 708, "changes": 709, "blob_url": "https://github.com/rust-lang/rust/blob/638f63b6e40c38441aa191c91e8532bcc40c7b69/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/638f63b6e40c38441aa191c91e8532bcc40c7b69/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=638f63b6e40c38441aa191c91e8532bcc40c7b69", "patch": "@@ -2720,711 +2720,4 @@ mod dep_tracking {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use getopts;\n-    use crate::lint;\n-    use crate::middle::cstore;\n-    use crate::session::config::{\n-        build_configuration,\n-        build_session_options_and_crate_config,\n-        to_crate_config\n-    };\n-    use crate::session::config::{LtoCli, LinkerPluginLto, SwitchWithOptPath, ExternEntry};\n-    use crate::session::build_session;\n-    use crate::session::search_paths::SearchPath;\n-    use std::collections::{BTreeMap, BTreeSet};\n-    use std::iter::FromIterator;\n-    use std::path::PathBuf;\n-    use super::{Externs, OutputType, OutputTypes, SymbolManglingVersion};\n-    use rustc_target::spec::{MergeFunctions, PanicStrategy, RelroLevel};\n-    use syntax::symbol::sym;\n-    use syntax::edition::{Edition, DEFAULT_EDITION};\n-    use syntax;\n-    use super::Options;\n-\n-    impl ExternEntry {\n-        fn new_public<S: Into<String>,\n-                      I: IntoIterator<Item = Option<S>>>(locations: I) -> ExternEntry {\n-            let locations: BTreeSet<_> = locations.into_iter().map(|o| o.map(|s| s.into()))\n-                .collect();\n-\n-            ExternEntry {\n-                locations,\n-                is_private_dep: false\n-            }\n-        }\n-    }\n-\n-    fn optgroups() -> getopts::Options {\n-        let mut opts = getopts::Options::new();\n-        for group in super::rustc_optgroups() {\n-            (group.apply)(&mut opts);\n-        }\n-        return opts;\n-    }\n-\n-    fn mk_map<K: Ord, V>(entries: Vec<(K, V)>) -> BTreeMap<K, V> {\n-        BTreeMap::from_iter(entries.into_iter())\n-    }\n-\n-    // When the user supplies --test we should implicitly supply --cfg test\n-    #[test]\n-    fn test_switch_implies_cfg_test() {\n-        syntax::with_default_globals(|| {\n-            let matches = &match optgroups().parse(&[\"--test\".to_string()]) {\n-                Ok(m) => m,\n-                Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f),\n-            };\n-            let registry = errors::registry::Registry::new(&[]);\n-            let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n-            let sess = build_session(sessopts, None, registry);\n-            let cfg = build_configuration(&sess, to_crate_config(cfg));\n-            assert!(cfg.contains(&(sym::test, None)));\n-        });\n-    }\n-\n-    // When the user supplies --test and --cfg test, don't implicitly add\n-    // another --cfg test\n-    #[test]\n-    fn test_switch_implies_cfg_test_unless_cfg_test() {\n-        syntax::with_default_globals(|| {\n-            let matches = &match optgroups().parse(&[\"--test\".to_string(),\n-                                                     \"--cfg=test\".to_string()]) {\n-                Ok(m) => m,\n-                Err(f) => panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f),\n-            };\n-            let registry = errors::registry::Registry::new(&[]);\n-            let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n-            let sess = build_session(sessopts, None, registry);\n-            let cfg = build_configuration(&sess, to_crate_config(cfg));\n-            let mut test_items = cfg.iter().filter(|&&(name, _)| name == sym::test);\n-            assert!(test_items.next().is_some());\n-            assert!(test_items.next().is_none());\n-        });\n-    }\n-\n-    #[test]\n-    fn test_can_print_warnings() {\n-        syntax::with_default_globals(|| {\n-            let matches = optgroups().parse(&[\"-Awarnings\".to_string()]).unwrap();\n-            let registry = errors::registry::Registry::new(&[]);\n-            let (sessopts, _) = build_session_options_and_crate_config(&matches);\n-            let sess = build_session(sessopts, None, registry);\n-            assert!(!sess.diagnostic().flags.can_emit_warnings);\n-        });\n-\n-        syntax::with_default_globals(|| {\n-            let matches = optgroups()\n-                .parse(&[\"-Awarnings\".to_string(), \"-Dwarnings\".to_string()])\n-                .unwrap();\n-            let registry = errors::registry::Registry::new(&[]);\n-            let (sessopts, _) = build_session_options_and_crate_config(&matches);\n-            let sess = build_session(sessopts, None, registry);\n-            assert!(sess.diagnostic().flags.can_emit_warnings);\n-        });\n-\n-        syntax::with_default_globals(|| {\n-            let matches = optgroups().parse(&[\"-Adead_code\".to_string()]).unwrap();\n-            let registry = errors::registry::Registry::new(&[]);\n-            let (sessopts, _) = build_session_options_and_crate_config(&matches);\n-            let sess = build_session(sessopts, None, registry);\n-            assert!(sess.diagnostic().flags.can_emit_warnings);\n-        });\n-    }\n-\n-    #[test]\n-    fn test_output_types_tracking_hash_different_paths() {\n-        let mut v1 = Options::default();\n-        let mut v2 = Options::default();\n-        let mut v3 = Options::default();\n-\n-        v1.output_types =\n-            OutputTypes::new(&[(OutputType::Exe, Some(PathBuf::from(\"./some/thing\")))]);\n-        v2.output_types =\n-            OutputTypes::new(&[(OutputType::Exe, Some(PathBuf::from(\"/some/thing\")))]);\n-        v3.output_types = OutputTypes::new(&[(OutputType::Exe, None)]);\n-\n-        assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n-        assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n-        assert!(v2.dep_tracking_hash() != v3.dep_tracking_hash());\n-\n-        // Check clone\n-        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n-    }\n-\n-    #[test]\n-    fn test_output_types_tracking_hash_different_construction_order() {\n-        let mut v1 = Options::default();\n-        let mut v2 = Options::default();\n-\n-        v1.output_types = OutputTypes::new(&[\n-            (OutputType::Exe, Some(PathBuf::from(\"./some/thing\"))),\n-            (OutputType::Bitcode, Some(PathBuf::from(\"./some/thing.bc\"))),\n-        ]);\n-\n-        v2.output_types = OutputTypes::new(&[\n-            (OutputType::Bitcode, Some(PathBuf::from(\"./some/thing.bc\"))),\n-            (OutputType::Exe, Some(PathBuf::from(\"./some/thing\"))),\n-        ]);\n-\n-        assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n-\n-        // Check clone\n-        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-    }\n-\n-    #[test]\n-    fn test_externs_tracking_hash_different_construction_order() {\n-        let mut v1 = Options::default();\n-        let mut v2 = Options::default();\n-        let mut v3 = Options::default();\n-\n-        v1.externs = Externs::new(mk_map(vec![\n-            (\n-                String::from(\"a\"),\n-                ExternEntry::new_public(vec![Some(\"b\"), Some(\"c\")])\n-            ),\n-            (\n-                String::from(\"d\"),\n-                ExternEntry::new_public(vec![Some(\"e\"), Some(\"f\")])\n-            ),\n-        ]));\n-\n-        v2.externs = Externs::new(mk_map(vec![\n-            (\n-                String::from(\"d\"),\n-                ExternEntry::new_public(vec![Some(\"e\"), Some(\"f\")])\n-            ),\n-            (\n-                String::from(\"a\"),\n-                ExternEntry::new_public(vec![Some(\"b\"), Some(\"c\")])\n-            ),\n-        ]));\n-\n-        v3.externs = Externs::new(mk_map(vec![\n-            (\n-                String::from(\"a\"),\n-                ExternEntry::new_public(vec![Some(\"b\"), Some(\"c\")])\n-            ),\n-            (\n-                String::from(\"d\"),\n-                ExternEntry::new_public(vec![Some(\"f\"), Some(\"e\")])\n-            ),\n-        ]));\n-\n-        assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n-        assert_eq!(v1.dep_tracking_hash(), v3.dep_tracking_hash());\n-        assert_eq!(v2.dep_tracking_hash(), v3.dep_tracking_hash());\n-\n-        // Check clone\n-        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n-    }\n-\n-    #[test]\n-    fn test_lints_tracking_hash_different_values() {\n-        let mut v1 = Options::default();\n-        let mut v2 = Options::default();\n-        let mut v3 = Options::default();\n-\n-        v1.lint_opts = vec![\n-            (String::from(\"a\"), lint::Allow),\n-            (String::from(\"b\"), lint::Warn),\n-            (String::from(\"c\"), lint::Deny),\n-            (String::from(\"d\"), lint::Forbid),\n-        ];\n-\n-        v2.lint_opts = vec![\n-            (String::from(\"a\"), lint::Allow),\n-            (String::from(\"b\"), lint::Warn),\n-            (String::from(\"X\"), lint::Deny),\n-            (String::from(\"d\"), lint::Forbid),\n-        ];\n-\n-        v3.lint_opts = vec![\n-            (String::from(\"a\"), lint::Allow),\n-            (String::from(\"b\"), lint::Warn),\n-            (String::from(\"c\"), lint::Forbid),\n-            (String::from(\"d\"), lint::Deny),\n-        ];\n-\n-        assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n-        assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n-        assert!(v2.dep_tracking_hash() != v3.dep_tracking_hash());\n-\n-        // Check clone\n-        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n-    }\n-\n-    #[test]\n-    fn test_lints_tracking_hash_different_construction_order() {\n-        let mut v1 = Options::default();\n-        let mut v2 = Options::default();\n-\n-        v1.lint_opts = vec![\n-            (String::from(\"a\"), lint::Allow),\n-            (String::from(\"b\"), lint::Warn),\n-            (String::from(\"c\"), lint::Deny),\n-            (String::from(\"d\"), lint::Forbid),\n-        ];\n-\n-        v2.lint_opts = vec![\n-            (String::from(\"a\"), lint::Allow),\n-            (String::from(\"c\"), lint::Deny),\n-            (String::from(\"b\"), lint::Warn),\n-            (String::from(\"d\"), lint::Forbid),\n-        ];\n-\n-        assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n-\n-        // Check clone\n-        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-    }\n-\n-    #[test]\n-    fn test_search_paths_tracking_hash_different_order() {\n-        let mut v1 = Options::default();\n-        let mut v2 = Options::default();\n-        let mut v3 = Options::default();\n-        let mut v4 = Options::default();\n-\n-        const JSON: super::ErrorOutputType = super::ErrorOutputType::Json {\n-            pretty: false,\n-            json_rendered: super::HumanReadableErrorType::Default(super::ColorConfig::Never),\n-        };\n-\n-        // Reference\n-        v1.search_paths\n-            .push(SearchPath::from_cli_opt(\"native=abc\", JSON));\n-        v1.search_paths\n-            .push(SearchPath::from_cli_opt(\"crate=def\", JSON));\n-        v1.search_paths\n-            .push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n-        v1.search_paths\n-            .push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n-        v1.search_paths\n-            .push(SearchPath::from_cli_opt(\"all=mno\", JSON));\n-\n-        v2.search_paths\n-            .push(SearchPath::from_cli_opt(\"native=abc\", JSON));\n-        v2.search_paths\n-            .push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n-        v2.search_paths\n-            .push(SearchPath::from_cli_opt(\"crate=def\", JSON));\n-        v2.search_paths\n-            .push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n-        v2.search_paths\n-            .push(SearchPath::from_cli_opt(\"all=mno\", JSON));\n-\n-        v3.search_paths\n-            .push(SearchPath::from_cli_opt(\"crate=def\", JSON));\n-        v3.search_paths\n-            .push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n-        v3.search_paths\n-            .push(SearchPath::from_cli_opt(\"native=abc\", JSON));\n-        v3.search_paths\n-            .push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n-        v3.search_paths\n-            .push(SearchPath::from_cli_opt(\"all=mno\", JSON));\n-\n-        v4.search_paths\n-            .push(SearchPath::from_cli_opt(\"all=mno\", JSON));\n-        v4.search_paths\n-            .push(SearchPath::from_cli_opt(\"native=abc\", JSON));\n-        v4.search_paths\n-            .push(SearchPath::from_cli_opt(\"crate=def\", JSON));\n-        v4.search_paths\n-            .push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n-        v4.search_paths\n-            .push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n-\n-        assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n-        assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n-        assert!(v1.dep_tracking_hash() == v4.dep_tracking_hash());\n-\n-        // Check clone\n-        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n-        assert_eq!(v4.dep_tracking_hash(), v4.clone().dep_tracking_hash());\n-    }\n-\n-    #[test]\n-    fn test_native_libs_tracking_hash_different_values() {\n-        let mut v1 = Options::default();\n-        let mut v2 = Options::default();\n-        let mut v3 = Options::default();\n-        let mut v4 = Options::default();\n-\n-        // Reference\n-        v1.libs = vec![\n-            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-            (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n-            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n-        ];\n-\n-        // Change label\n-        v2.libs = vec![\n-            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-            (String::from(\"X\"), None, Some(cstore::NativeFramework)),\n-            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n-        ];\n-\n-        // Change kind\n-        v3.libs = vec![\n-            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-            (String::from(\"b\"), None, Some(cstore::NativeStatic)),\n-            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n-        ];\n-\n-        // Change new-name\n-        v4.libs = vec![\n-            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-            (\n-                String::from(\"b\"),\n-                Some(String::from(\"X\")),\n-                Some(cstore::NativeFramework),\n-            ),\n-            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n-        ];\n-\n-        assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n-        assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n-        assert!(v1.dep_tracking_hash() != v4.dep_tracking_hash());\n-\n-        // Check clone\n-        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n-        assert_eq!(v4.dep_tracking_hash(), v4.clone().dep_tracking_hash());\n-    }\n-\n-    #[test]\n-    fn test_native_libs_tracking_hash_different_order() {\n-        let mut v1 = Options::default();\n-        let mut v2 = Options::default();\n-        let mut v3 = Options::default();\n-\n-        // Reference\n-        v1.libs = vec![\n-            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-            (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n-            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n-        ];\n-\n-        v2.libs = vec![\n-            (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n-            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n-        ];\n-\n-        v3.libs = vec![\n-            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n-            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-            (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n-        ];\n-\n-        assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n-        assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n-        assert!(v2.dep_tracking_hash() == v3.dep_tracking_hash());\n-\n-        // Check clone\n-        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n-    }\n-\n-    #[test]\n-    fn test_codegen_options_tracking_hash() {\n-        let reference = Options::default();\n-        let mut opts = Options::default();\n-\n-        // Make sure the changing an [UNTRACKED] option leaves the hash unchanged\n-        opts.cg.ar = Some(String::from(\"abc\"));\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts.cg.linker = Some(PathBuf::from(\"linker\"));\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts.cg.link_args = Some(vec![String::from(\"abc\"), String::from(\"def\")]);\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts.cg.link_dead_code = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts.cg.rpath = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts.cg.extra_filename = String::from(\"extra-filename\");\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts.cg.codegen_units = Some(42);\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts.cg.remark = super::Passes::Some(vec![String::from(\"pass1\"), String::from(\"pass2\")]);\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts.cg.save_temps = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts.cg.incremental = Some(String::from(\"abc\"));\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        // Make sure changing a [TRACKED] option changes the hash\n-        opts = reference.clone();\n-        opts.cg.lto = LtoCli::Fat;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.target_cpu = Some(String::from(\"abc\"));\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.target_feature = String::from(\"all the features, all of them\");\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.passes = vec![String::from(\"1\"), String::from(\"2\")];\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.llvm_args = vec![String::from(\"1\"), String::from(\"2\")];\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.overflow_checks = Some(true);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.no_prepopulate_passes = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.no_vectorize_loops = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.no_vectorize_slp = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.soft_float = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.prefer_dynamic = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.no_integrated_as = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.no_redzone = Some(true);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.relocation_model = Some(String::from(\"relocation model\"));\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.code_model = Some(String::from(\"code model\"));\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.tls_model = Some(String::from(\"tls model\"));\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.pgo_gen = SwitchWithOptPath::Enabled(None);\n-        assert_ne!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.pgo_use = Some(PathBuf::from(\"abc\"));\n-        assert_ne!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.metadata = vec![String::from(\"A\"), String::from(\"B\")];\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.debuginfo = Some(0xdeadbeef);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.debuginfo = Some(0xba5eba11);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.force_frame_pointers = Some(false);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.debug_assertions = Some(true);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.inline_threshold = Some(0xf007ba11);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.panic = Some(PanicStrategy::Abort);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.linker_plugin_lto = LinkerPluginLto::LinkerPluginAuto;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-    }\n-\n-    #[test]\n-    fn test_debugging_options_tracking_hash() {\n-        let reference = Options::default();\n-        let mut opts = Options::default();\n-\n-        // Make sure the changing an [UNTRACKED] option leaves the hash unchanged\n-        opts.debugging_opts.verbose = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.time_passes = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.time_llvm_passes = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.input_stats = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.borrowck_stats = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.meta_stats = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.print_link_args = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.print_llvm_passes = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.ast_json = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.ast_json_noexpand = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.ls = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.save_analysis = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.flowgraph_print_loans = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.flowgraph_print_moves = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.flowgraph_print_assigns = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.flowgraph_print_all = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.print_region_graph = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.parse_only = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.incremental = Some(String::from(\"abc\"));\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.dump_dep_graph = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.query_dep_graph = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.no_analysis = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.unstable_options = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.trace_macros = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.keep_hygiene_data = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.keep_ast = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.print_mono_items = Some(String::from(\"abc\"));\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.dump_mir = Some(String::from(\"abc\"));\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.dump_mir_dir = String::from(\"abc\");\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.dump_mir_graphviz = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        // Make sure changing a [TRACKED] option changes the hash\n-        opts = reference.clone();\n-        opts.debugging_opts.asm_comments = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.verify_llvm_ir = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.no_landing_pads = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.fewer_names = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.no_codegen = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.treat_err_as_bug = Some(1);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.report_delayed_bugs = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.continue_parse_after_error = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.extra_plugins = vec![String::from(\"plugin1\"), String::from(\"plugin2\")];\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.force_overflow_checks = Some(true);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.show_span = Some(String::from(\"abc\"));\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.mir_opt_level = 3;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.relro_level = Some(RelroLevel::Full);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.merge_functions = Some(MergeFunctions::Disabled);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.allow_features = Some(vec![String::from(\"lang_items\")]);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.symbol_mangling_version = SymbolManglingVersion::V0;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-    }\n-\n-    #[test]\n-    fn test_edition_parsing() {\n-        // test default edition\n-        let options = Options::default();\n-        assert!(options.edition == DEFAULT_EDITION);\n-\n-        let matches = optgroups()\n-            .parse(&[\"--edition=2018\".to_string()])\n-            .unwrap();\n-        let (sessopts, _) = build_session_options_and_crate_config(&matches);\n-        assert!(sessopts.edition == Edition::Edition2018)\n-    }\n-}\n+mod tests;"}, {"sha": "b8477f8dd178956ed298452c12fc3d8d44757fbc", "filename": "src/librustc/session/config/tests.rs", "status": "added", "additions": 706, "deletions": 0, "changes": 706, "blob_url": "https://github.com/rust-lang/rust/blob/638f63b6e40c38441aa191c91e8532bcc40c7b69/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/638f63b6e40c38441aa191c91e8532bcc40c7b69/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs?ref=638f63b6e40c38441aa191c91e8532bcc40c7b69", "patch": "@@ -0,0 +1,706 @@\n+use getopts;\n+use crate::lint;\n+use crate::middle::cstore;\n+use crate::session::config::{\n+    build_configuration,\n+    build_session_options_and_crate_config,\n+    to_crate_config\n+};\n+use crate::session::config::{LtoCli, LinkerPluginLto, SwitchWithOptPath, ExternEntry};\n+use crate::session::build_session;\n+use crate::session::search_paths::SearchPath;\n+use std::collections::{BTreeMap, BTreeSet};\n+use std::iter::FromIterator;\n+use std::path::PathBuf;\n+use super::{Externs, OutputType, OutputTypes, SymbolManglingVersion};\n+use rustc_target::spec::{MergeFunctions, PanicStrategy, RelroLevel};\n+use syntax::symbol::sym;\n+use syntax::edition::{Edition, DEFAULT_EDITION};\n+use syntax;\n+use super::Options;\n+\n+impl ExternEntry {\n+    fn new_public<S: Into<String>,\n+                  I: IntoIterator<Item = Option<S>>>(locations: I) -> ExternEntry {\n+        let locations: BTreeSet<_> = locations.into_iter().map(|o| o.map(|s| s.into()))\n+            .collect();\n+\n+        ExternEntry {\n+            locations,\n+            is_private_dep: false\n+        }\n+    }\n+}\n+\n+fn optgroups() -> getopts::Options {\n+    let mut opts = getopts::Options::new();\n+    for group in super::rustc_optgroups() {\n+        (group.apply)(&mut opts);\n+    }\n+    return opts;\n+}\n+\n+fn mk_map<K: Ord, V>(entries: Vec<(K, V)>) -> BTreeMap<K, V> {\n+    BTreeMap::from_iter(entries.into_iter())\n+}\n+\n+// When the user supplies --test we should implicitly supply --cfg test\n+#[test]\n+fn test_switch_implies_cfg_test() {\n+    syntax::with_default_globals(|| {\n+        let matches = &match optgroups().parse(&[\"--test\".to_string()]) {\n+            Ok(m) => m,\n+            Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f),\n+        };\n+        let registry = errors::registry::Registry::new(&[]);\n+        let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n+        let sess = build_session(sessopts, None, registry);\n+        let cfg = build_configuration(&sess, to_crate_config(cfg));\n+        assert!(cfg.contains(&(sym::test, None)));\n+    });\n+}\n+\n+// When the user supplies --test and --cfg test, don't implicitly add\n+// another --cfg test\n+#[test]\n+fn test_switch_implies_cfg_test_unless_cfg_test() {\n+    syntax::with_default_globals(|| {\n+        let matches = &match optgroups().parse(&[\"--test\".to_string(),\n+                                                 \"--cfg=test\".to_string()]) {\n+            Ok(m) => m,\n+            Err(f) => panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f),\n+        };\n+        let registry = errors::registry::Registry::new(&[]);\n+        let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n+        let sess = build_session(sessopts, None, registry);\n+        let cfg = build_configuration(&sess, to_crate_config(cfg));\n+        let mut test_items = cfg.iter().filter(|&&(name, _)| name == sym::test);\n+        assert!(test_items.next().is_some());\n+        assert!(test_items.next().is_none());\n+    });\n+}\n+\n+#[test]\n+fn test_can_print_warnings() {\n+    syntax::with_default_globals(|| {\n+        let matches = optgroups().parse(&[\"-Awarnings\".to_string()]).unwrap();\n+        let registry = errors::registry::Registry::new(&[]);\n+        let (sessopts, _) = build_session_options_and_crate_config(&matches);\n+        let sess = build_session(sessopts, None, registry);\n+        assert!(!sess.diagnostic().flags.can_emit_warnings);\n+    });\n+\n+    syntax::with_default_globals(|| {\n+        let matches = optgroups()\n+            .parse(&[\"-Awarnings\".to_string(), \"-Dwarnings\".to_string()])\n+            .unwrap();\n+        let registry = errors::registry::Registry::new(&[]);\n+        let (sessopts, _) = build_session_options_and_crate_config(&matches);\n+        let sess = build_session(sessopts, None, registry);\n+        assert!(sess.diagnostic().flags.can_emit_warnings);\n+    });\n+\n+    syntax::with_default_globals(|| {\n+        let matches = optgroups().parse(&[\"-Adead_code\".to_string()]).unwrap();\n+        let registry = errors::registry::Registry::new(&[]);\n+        let (sessopts, _) = build_session_options_and_crate_config(&matches);\n+        let sess = build_session(sessopts, None, registry);\n+        assert!(sess.diagnostic().flags.can_emit_warnings);\n+    });\n+}\n+\n+#[test]\n+fn test_output_types_tracking_hash_different_paths() {\n+    let mut v1 = Options::default();\n+    let mut v2 = Options::default();\n+    let mut v3 = Options::default();\n+\n+    v1.output_types =\n+        OutputTypes::new(&[(OutputType::Exe, Some(PathBuf::from(\"./some/thing\")))]);\n+    v2.output_types =\n+        OutputTypes::new(&[(OutputType::Exe, Some(PathBuf::from(\"/some/thing\")))]);\n+    v3.output_types = OutputTypes::new(&[(OutputType::Exe, None)]);\n+\n+    assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n+    assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n+    assert!(v2.dep_tracking_hash() != v3.dep_tracking_hash());\n+\n+    // Check clone\n+    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+}\n+\n+#[test]\n+fn test_output_types_tracking_hash_different_construction_order() {\n+    let mut v1 = Options::default();\n+    let mut v2 = Options::default();\n+\n+    v1.output_types = OutputTypes::new(&[\n+        (OutputType::Exe, Some(PathBuf::from(\"./some/thing\"))),\n+        (OutputType::Bitcode, Some(PathBuf::from(\"./some/thing.bc\"))),\n+    ]);\n+\n+    v2.output_types = OutputTypes::new(&[\n+        (OutputType::Bitcode, Some(PathBuf::from(\"./some/thing.bc\"))),\n+        (OutputType::Exe, Some(PathBuf::from(\"./some/thing\"))),\n+    ]);\n+\n+    assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n+\n+    // Check clone\n+    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+}\n+\n+#[test]\n+fn test_externs_tracking_hash_different_construction_order() {\n+    let mut v1 = Options::default();\n+    let mut v2 = Options::default();\n+    let mut v3 = Options::default();\n+\n+    v1.externs = Externs::new(mk_map(vec![\n+        (\n+            String::from(\"a\"),\n+            ExternEntry::new_public(vec![Some(\"b\"), Some(\"c\")])\n+        ),\n+        (\n+            String::from(\"d\"),\n+            ExternEntry::new_public(vec![Some(\"e\"), Some(\"f\")])\n+        ),\n+    ]));\n+\n+    v2.externs = Externs::new(mk_map(vec![\n+        (\n+            String::from(\"d\"),\n+            ExternEntry::new_public(vec![Some(\"e\"), Some(\"f\")])\n+        ),\n+        (\n+            String::from(\"a\"),\n+            ExternEntry::new_public(vec![Some(\"b\"), Some(\"c\")])\n+        ),\n+    ]));\n+\n+    v3.externs = Externs::new(mk_map(vec![\n+        (\n+            String::from(\"a\"),\n+            ExternEntry::new_public(vec![Some(\"b\"), Some(\"c\")])\n+        ),\n+        (\n+            String::from(\"d\"),\n+            ExternEntry::new_public(vec![Some(\"f\"), Some(\"e\")])\n+        ),\n+    ]));\n+\n+    assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n+    assert_eq!(v1.dep_tracking_hash(), v3.dep_tracking_hash());\n+    assert_eq!(v2.dep_tracking_hash(), v3.dep_tracking_hash());\n+\n+    // Check clone\n+    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+}\n+\n+#[test]\n+fn test_lints_tracking_hash_different_values() {\n+    let mut v1 = Options::default();\n+    let mut v2 = Options::default();\n+    let mut v3 = Options::default();\n+\n+    v1.lint_opts = vec![\n+        (String::from(\"a\"), lint::Allow),\n+        (String::from(\"b\"), lint::Warn),\n+        (String::from(\"c\"), lint::Deny),\n+        (String::from(\"d\"), lint::Forbid),\n+    ];\n+\n+    v2.lint_opts = vec![\n+        (String::from(\"a\"), lint::Allow),\n+        (String::from(\"b\"), lint::Warn),\n+        (String::from(\"X\"), lint::Deny),\n+        (String::from(\"d\"), lint::Forbid),\n+    ];\n+\n+    v3.lint_opts = vec![\n+        (String::from(\"a\"), lint::Allow),\n+        (String::from(\"b\"), lint::Warn),\n+        (String::from(\"c\"), lint::Forbid),\n+        (String::from(\"d\"), lint::Deny),\n+    ];\n+\n+    assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n+    assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n+    assert!(v2.dep_tracking_hash() != v3.dep_tracking_hash());\n+\n+    // Check clone\n+    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+}\n+\n+#[test]\n+fn test_lints_tracking_hash_different_construction_order() {\n+    let mut v1 = Options::default();\n+    let mut v2 = Options::default();\n+\n+    v1.lint_opts = vec![\n+        (String::from(\"a\"), lint::Allow),\n+        (String::from(\"b\"), lint::Warn),\n+        (String::from(\"c\"), lint::Deny),\n+        (String::from(\"d\"), lint::Forbid),\n+    ];\n+\n+    v2.lint_opts = vec![\n+        (String::from(\"a\"), lint::Allow),\n+        (String::from(\"c\"), lint::Deny),\n+        (String::from(\"b\"), lint::Warn),\n+        (String::from(\"d\"), lint::Forbid),\n+    ];\n+\n+    assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n+\n+    // Check clone\n+    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+}\n+\n+#[test]\n+fn test_search_paths_tracking_hash_different_order() {\n+    let mut v1 = Options::default();\n+    let mut v2 = Options::default();\n+    let mut v3 = Options::default();\n+    let mut v4 = Options::default();\n+\n+    const JSON: super::ErrorOutputType = super::ErrorOutputType::Json {\n+        pretty: false,\n+        json_rendered: super::HumanReadableErrorType::Default(super::ColorConfig::Never),\n+    };\n+\n+    // Reference\n+    v1.search_paths\n+        .push(SearchPath::from_cli_opt(\"native=abc\", JSON));\n+    v1.search_paths\n+        .push(SearchPath::from_cli_opt(\"crate=def\", JSON));\n+    v1.search_paths\n+        .push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n+    v1.search_paths\n+        .push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n+    v1.search_paths\n+        .push(SearchPath::from_cli_opt(\"all=mno\", JSON));\n+\n+    v2.search_paths\n+        .push(SearchPath::from_cli_opt(\"native=abc\", JSON));\n+    v2.search_paths\n+        .push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n+    v2.search_paths\n+        .push(SearchPath::from_cli_opt(\"crate=def\", JSON));\n+    v2.search_paths\n+        .push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n+    v2.search_paths\n+        .push(SearchPath::from_cli_opt(\"all=mno\", JSON));\n+\n+    v3.search_paths\n+        .push(SearchPath::from_cli_opt(\"crate=def\", JSON));\n+    v3.search_paths\n+        .push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n+    v3.search_paths\n+        .push(SearchPath::from_cli_opt(\"native=abc\", JSON));\n+    v3.search_paths\n+        .push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n+    v3.search_paths\n+        .push(SearchPath::from_cli_opt(\"all=mno\", JSON));\n+\n+    v4.search_paths\n+        .push(SearchPath::from_cli_opt(\"all=mno\", JSON));\n+    v4.search_paths\n+        .push(SearchPath::from_cli_opt(\"native=abc\", JSON));\n+    v4.search_paths\n+        .push(SearchPath::from_cli_opt(\"crate=def\", JSON));\n+    v4.search_paths\n+        .push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n+    v4.search_paths\n+        .push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n+\n+    assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n+    assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n+    assert!(v1.dep_tracking_hash() == v4.dep_tracking_hash());\n+\n+    // Check clone\n+    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    assert_eq!(v4.dep_tracking_hash(), v4.clone().dep_tracking_hash());\n+}\n+\n+#[test]\n+fn test_native_libs_tracking_hash_different_values() {\n+    let mut v1 = Options::default();\n+    let mut v2 = Options::default();\n+    let mut v3 = Options::default();\n+    let mut v4 = Options::default();\n+\n+    // Reference\n+    v1.libs = vec![\n+        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+        (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n+        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+    ];\n+\n+    // Change label\n+    v2.libs = vec![\n+        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+        (String::from(\"X\"), None, Some(cstore::NativeFramework)),\n+        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+    ];\n+\n+    // Change kind\n+    v3.libs = vec![\n+        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+        (String::from(\"b\"), None, Some(cstore::NativeStatic)),\n+        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+    ];\n+\n+    // Change new-name\n+    v4.libs = vec![\n+        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+        (\n+            String::from(\"b\"),\n+            Some(String::from(\"X\")),\n+            Some(cstore::NativeFramework),\n+        ),\n+        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+    ];\n+\n+    assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n+    assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n+    assert!(v1.dep_tracking_hash() != v4.dep_tracking_hash());\n+\n+    // Check clone\n+    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    assert_eq!(v4.dep_tracking_hash(), v4.clone().dep_tracking_hash());\n+}\n+\n+#[test]\n+fn test_native_libs_tracking_hash_different_order() {\n+    let mut v1 = Options::default();\n+    let mut v2 = Options::default();\n+    let mut v3 = Options::default();\n+\n+    // Reference\n+    v1.libs = vec![\n+        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+        (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n+        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+    ];\n+\n+    v2.libs = vec![\n+        (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n+        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+    ];\n+\n+    v3.libs = vec![\n+        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+        (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n+    ];\n+\n+    assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n+    assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n+    assert!(v2.dep_tracking_hash() == v3.dep_tracking_hash());\n+\n+    // Check clone\n+    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+}\n+\n+#[test]\n+fn test_codegen_options_tracking_hash() {\n+    let reference = Options::default();\n+    let mut opts = Options::default();\n+\n+    // Make sure the changing an [UNTRACKED] option leaves the hash unchanged\n+    opts.cg.ar = Some(String::from(\"abc\"));\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts.cg.linker = Some(PathBuf::from(\"linker\"));\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts.cg.link_args = Some(vec![String::from(\"abc\"), String::from(\"def\")]);\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts.cg.link_dead_code = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts.cg.rpath = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts.cg.extra_filename = String::from(\"extra-filename\");\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts.cg.codegen_units = Some(42);\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts.cg.remark = super::Passes::Some(vec![String::from(\"pass1\"), String::from(\"pass2\")]);\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts.cg.save_temps = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts.cg.incremental = Some(String::from(\"abc\"));\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    // Make sure changing a [TRACKED] option changes the hash\n+    opts = reference.clone();\n+    opts.cg.lto = LtoCli::Fat;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.target_cpu = Some(String::from(\"abc\"));\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.target_feature = String::from(\"all the features, all of them\");\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.passes = vec![String::from(\"1\"), String::from(\"2\")];\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.llvm_args = vec![String::from(\"1\"), String::from(\"2\")];\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.overflow_checks = Some(true);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.no_prepopulate_passes = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.no_vectorize_loops = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.no_vectorize_slp = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.soft_float = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.prefer_dynamic = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.no_integrated_as = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.no_redzone = Some(true);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.relocation_model = Some(String::from(\"relocation model\"));\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.code_model = Some(String::from(\"code model\"));\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.tls_model = Some(String::from(\"tls model\"));\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.pgo_gen = SwitchWithOptPath::Enabled(None);\n+    assert_ne!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.pgo_use = Some(PathBuf::from(\"abc\"));\n+    assert_ne!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.metadata = vec![String::from(\"A\"), String::from(\"B\")];\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.debuginfo = Some(0xdeadbeef);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.debuginfo = Some(0xba5eba11);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.force_frame_pointers = Some(false);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.debug_assertions = Some(true);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.inline_threshold = Some(0xf007ba11);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.panic = Some(PanicStrategy::Abort);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.linker_plugin_lto = LinkerPluginLto::LinkerPluginAuto;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+}\n+\n+#[test]\n+fn test_debugging_options_tracking_hash() {\n+    let reference = Options::default();\n+    let mut opts = Options::default();\n+\n+    // Make sure the changing an [UNTRACKED] option leaves the hash unchanged\n+    opts.debugging_opts.verbose = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.time_passes = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.time_llvm_passes = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.input_stats = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.borrowck_stats = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.meta_stats = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.print_link_args = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.print_llvm_passes = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.ast_json = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.ast_json_noexpand = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.ls = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.save_analysis = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.flowgraph_print_loans = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.flowgraph_print_moves = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.flowgraph_print_assigns = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.flowgraph_print_all = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.print_region_graph = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.parse_only = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.incremental = Some(String::from(\"abc\"));\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.dump_dep_graph = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.query_dep_graph = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.no_analysis = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.unstable_options = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.trace_macros = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.keep_hygiene_data = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.keep_ast = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.print_mono_items = Some(String::from(\"abc\"));\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.dump_mir = Some(String::from(\"abc\"));\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.dump_mir_dir = String::from(\"abc\");\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.dump_mir_graphviz = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    // Make sure changing a [TRACKED] option changes the hash\n+    opts = reference.clone();\n+    opts.debugging_opts.asm_comments = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.verify_llvm_ir = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.no_landing_pads = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.fewer_names = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.no_codegen = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.treat_err_as_bug = Some(1);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.report_delayed_bugs = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.continue_parse_after_error = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.extra_plugins = vec![String::from(\"plugin1\"), String::from(\"plugin2\")];\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.force_overflow_checks = Some(true);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.show_span = Some(String::from(\"abc\"));\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.mir_opt_level = 3;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.relro_level = Some(RelroLevel::Full);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.merge_functions = Some(MergeFunctions::Disabled);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.allow_features = Some(vec![String::from(\"lang_items\")]);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.symbol_mangling_version = SymbolManglingVersion::V0;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+}\n+\n+#[test]\n+fn test_edition_parsing() {\n+    // test default edition\n+    let options = Options::default();\n+    assert!(options.edition == DEFAULT_EDITION);\n+\n+    let matches = optgroups()\n+        .parse(&[\"--edition=2018\".to_string()])\n+        .unwrap();\n+    let (sessopts, _) = build_session_options_and_crate_config(&matches);\n+    assert!(sessopts.edition == Edition::Edition2018)\n+}"}]}