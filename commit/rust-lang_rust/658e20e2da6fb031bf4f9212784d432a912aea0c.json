{"sha": "658e20e2da6fb031bf4f9212784d432a912aea0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1OGUyMGUyZGE2ZmIwMzFiZjRmOTIxMjc4NGQ0MzJhOTEyYWVhMGM=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-11-08T14:18:52Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-11-09T05:58:27Z"}, "message": "std: os: Document MemoryMap", "tree": {"sha": "c2d28084f5a5a1eab4b81f44028911cbb15eb2a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2d28084f5a5a1eab4b81f44028911cbb15eb2a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/658e20e2da6fb031bf4f9212784d432a912aea0c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/658e20e2da6fb031bf4f9212784d432a912aea0c", "html_url": "https://github.com/rust-lang/rust/commit/658e20e2da6fb031bf4f9212784d432a912aea0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/658e20e2da6fb031bf4f9212784d432a912aea0c/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acbcb9ed2e24137040a4c0a4f87034e943036ecb", "url": "https://api.github.com/repos/rust-lang/rust/commits/acbcb9ed2e24137040a4c0a4f87034e943036ecb", "html_url": "https://github.com/rust-lang/rust/commit/acbcb9ed2e24137040a4c0a4f87034e943036ecb"}], "stats": {"total": 52, "additions": 49, "deletions": 3}, "files": [{"sha": "a5858092f2149990787986417423408710c80195", "filename": "src/libstd/os.rs", "status": "modified", "additions": 49, "deletions": 3, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/658e20e2da6fb031bf4f9212784d432a912aea0c/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658e20e2da6fb031bf4f9212784d432a912aea0c/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=658e20e2da6fb031bf4f9212784d432a912aea0c", "patch": "@@ -913,41 +913,81 @@ pub fn page_size() -> uint {\n     }\n }\n \n+/// A memory mapped file or chunk of memory. This is a very system-specific interface to the OS's\n+/// memory mapping facilities (`mmap` on POSIX, `VirtualAlloc`/`CreateFileMapping` on win32). It\n+/// makes no attempt at abstracting platform differences, besides in error values returned. Consider\n+/// yourself warned.\n+///\n+/// The memory map is released (unmapped) when the destructor is run, so don't let it leave scope by\n+/// accident if you want it to stick around.\n pub struct MemoryMap {\n+    /// Pointer to the memory created or modified by this map.\n     data: *mut u8,\n+    /// Number of bytes this map applies to\n     len: size_t,\n+    /// Type of mapping\n     kind: MemoryMapKind\n }\n \n+/// Type of memory map\n pub enum MemoryMapKind {\n+    /// Memory-mapped file. On Windows, the inner pointer is a handle to the mapping, and\n+    /// corresponds to `CreateFileMapping`. Elsewhere, it is null.\n     MapFile(*c_void),\n+    /// Virtual memory map. Usually used to change the permissions of a given chunk of memory.\n+    /// Corresponds to `VirtualAlloc` on Windows.\n     MapVirtual\n }\n \n+/// Options the memory map is created with\n pub enum MapOption {\n+    /// The memory should be readable\n     MapReadable,\n+    /// The memory should be writable\n     MapWritable,\n+    /// The memory should be executable\n     MapExecutable,\n+    /// Create a map for a specific address range. Corresponds to `MAP_FIXED` on POSIX.\n     MapAddr(*c_void),\n+    /// Create a memory mapping for a file with a given fd.\n     MapFd(c_int),\n+    /// When using `MapFd`, the start of the map is `uint` bytes from the start of the file.\n     MapOffset(uint)\n }\n \n+/// Possible errors when creating a map.\n pub enum MapError {\n-    // Linux-specific errors\n+    /// ## The following are POSIX-specific\n+    ///\n+    /// fd was not open for reading or, if using `MapWritable`, was not open for writing.\n     ErrFdNotAvail,\n+    /// fd was not valid\n     ErrInvalidFd,\n+    /// Either the address given by `MapAddr` or offset given by `MapOffset` was not a multiple of\n+    /// `MemoryMap::granularity` (unaligned to page size).\n     ErrUnaligned,\n+    /// With `MapFd`, the fd does not support mapping.\n     ErrNoMapSupport,\n+    /// If using `MapAddr`, the address + `min_len` was outside of the process's address space. If\n+    /// using `MapFd`, the target of the fd didn't have enough resources to fulfill the request.\n     ErrNoMem,\n+    /// Unrecognized error. The inner value is the unrecognized errno.\n     ErrUnknown(libc::c_int),\n-\n-    // Windows-specific errors\n+    /// ## The following are win32-specific\n+    ///\n+    /// Unsupported combination of protection flags (`MapReadable`/`MapWritable`/`MapExecutable`).\n     ErrUnsupProt,\n+    /// When using `MapFd`, `MapOffset` was given (Windows does not support this at all)\n     ErrUnsupOffset,\n+    /// When using `MapFd`, there was already a mapping to the file.\n     ErrAlreadyExists,\n+    /// Unrecognized error from `VirtualAlloc`. The inner value is the return value of GetLastError.\n     ErrVirtualAlloc(uint),\n+    /// Unrecognized error from `CreateFileMapping`. The inner value is the return value of\n+    /// `GetLastError`.\n     ErrCreateFileMappingW(uint),\n+    /// Unrecognized error from `MapViewOfFile`. The inner value is the return value of\n+    /// `GetLastError`.\n     ErrMapViewOfFile(uint)\n }\n \n@@ -973,6 +1013,7 @@ impl to_str::ToStr for MapError {\n \n #[cfg(unix)]\n impl MemoryMap {\n+    /// Create a new mapping with the given `options`, at least `min_len` bytes long.\n     pub fn new(min_len: uint, options: &[MapOption]) -> Result<MemoryMap, MapError> {\n         #[fixed_stack_segment]; #[inline(never)];\n \n@@ -1028,13 +1069,15 @@ impl MemoryMap {\n         }\n     }\n \n+    /// Granularity that the offset or address must be for `MapOffset` and `MapAddr` respectively.\n     pub fn granularity() -> uint {\n         page_size()\n     }\n }\n \n #[cfg(unix)]\n impl Drop for MemoryMap {\n+    /// Unmap the mapping. Fails the task if `munmap` fails.\n     fn drop(&mut self) {\n         #[fixed_stack_segment]; #[inline(never)];\n \n@@ -1053,6 +1096,7 @@ impl Drop for MemoryMap {\n \n #[cfg(windows)]\n impl MemoryMap {\n+    /// Create a new mapping with the given `options`, at least `min_len` bytes long.\n     pub fn new(min_len: uint, options: &[MapOption]) -> Result<MemoryMap, MapError> {\n         #[fixed_stack_segment]; #[inline(never)];\n \n@@ -1161,6 +1205,8 @@ impl MemoryMap {\n \n #[cfg(windows)]\n impl Drop for MemoryMap {\n+    /// Unmap the mapping. Fails the task if any of `VirtualFree`, `UnmapViewOfFile`, or\n+    /// `CloseHandle` fail.\n     fn drop(&mut self) {\n         #[fixed_stack_segment]; #[inline(never)];\n "}]}