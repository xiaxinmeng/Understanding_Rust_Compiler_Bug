{"sha": "2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "node_id": "C_kwDOAAsO6NoAKDI1ODViY2VhMGJjMmE5YzQyYTRiZTJjMWViYTVjNjExMzdmMmIxNjc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-28T20:53:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-28T20:53:42Z"}, "message": "Auto merge of #105017 - matthiaskrgr:rollup-j0x550l, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #104804 (Rename `ast::Lit` as `ast::MetaItemLit`.)\n - #104891 (Add documentation for `has_escaping_bound_vars`)\n - #104933 (interpret: remove PartialOrd from a bunch of types that do not have or need a sensible order)\n - #104936 (Ignore bivariant parameters in test_type_match.)\n - #104954 (make simple check of prinf function)\n - #104956 (Avoid ICE if the Clone trait is not found while building error suggestions)\n - #104982 (interpret: get rid of run() function)\n - #104998 (Update my mailmap)\n - #105006 (stricter alignment enforcement for ScalarPair)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "0f33b88b1a3842bed80689bb9fd4b74506071d52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f33b88b1a3842bed80689bb9fd4b74506071d52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "html_url": "https://github.com/rust-lang/rust/commit/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a09420ac48658cad726e0a6997687ceac4151e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a09420ac48658cad726e0a6997687ceac4151e3", "html_url": "https://github.com/rust-lang/rust/commit/8a09420ac48658cad726e0a6997687ceac4151e3"}, {"sha": "3dfb6ca8e26f6bb9232a4c6a7afef90f4abf54dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dfb6ca8e26f6bb9232a4c6a7afef90f4abf54dd", "html_url": "https://github.com/rust-lang/rust/commit/3dfb6ca8e26f6bb9232a4c6a7afef90f4abf54dd"}], "stats": {"total": 982, "additions": 567, "deletions": 415}, "files": [{"sha": "4ef723e51468a9cd2871f3b28cd4868f360f788f", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -229,7 +229,7 @@ Jacob <jacob.macritchie@gmail.com>\n Jacob Greenfield <xales@naveria.com>\n Jacob Pratt <jacob@jhpratt.dev> <the.z.cuber@gmail.com>\n Jake Vossen <jake@vossen.dev>\n-Jakob Degen <jakob@degen.com>\n+Jakob Degen <jakob.e.degen@gmail.com> <jakob@degen.com>\n Jakob Lautrup Nysom <jako3047@gmail.com>\n Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com>\n Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakub.bukaj@yahoo.com>"}, {"sha": "d0bb05c36549b09a5b2db238644895fca7aca18c", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -13,7 +13,7 @@\n //! - [`FnDecl`], [`FnHeader`] and [`Param`]: Metadata associated with a function declaration.\n //! - [`Generics`], [`GenericParam`], [`WhereClause`]: Metadata associated with generic parameters.\n //! - [`EnumDef`] and [`Variant`]: Enum declaration.\n-//! - [`Lit`] and [`LitKind`]: Literal expressions.\n+//! - [`MetaItemLit`] and [`LitKind`]: Literal expressions.\n //! - [`MacroDef`], [`MacStmtStyle`], [`MacCall`], [`MacDelimiter`]: Macro definition and invocation.\n //! - [`Attribute`]: Metadata associated with item.\n //! - [`UnOp`], [`BinOp`], and [`BinOpKind`]: Unary and binary operators.\n@@ -489,7 +489,7 @@ pub enum NestedMetaItem {\n     /// A literal.\n     ///\n     /// E.g., `\"foo\"`, `64`, `true`.\n-    Literal(Lit),\n+    Lit(MetaItemLit),\n }\n \n /// A spanned compile-time attribute item.\n@@ -518,7 +518,7 @@ pub enum MetaItemKind {\n     /// Name value meta item.\n     ///\n     /// E.g., `feature = \"foo\"` as in `#[feature = \"foo\"]`.\n-    NameValue(Lit),\n+    NameValue(MetaItemLit),\n }\n \n /// A block (`{ .. }`).\n@@ -1599,12 +1599,12 @@ pub enum AttrArgs {\n }\n \n // The RHS of an `AttrArgs::Eq` starts out as an expression. Once macro\n-// expansion is completed, all cases end up either as a literal, which is the\n-// form used after lowering to HIR, or as an error.\n+// expansion is completed, all cases end up either as a meta item literal,\n+// which is the form used after lowering to HIR, or as an error.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum AttrArgsEq {\n     Ast(P<Expr>),\n-    Hir(Lit),\n+    Hir(MetaItemLit),\n }\n \n impl AttrArgs {\n@@ -1726,19 +1726,18 @@ pub enum StrStyle {\n     Raw(u8),\n }\n \n-/// An AST literal.\n+/// A literal in a meta item.\n #[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n-pub struct Lit {\n+pub struct MetaItemLit {\n     /// The original literal token as written in source code.\n     pub token_lit: token::Lit,\n     /// The \"semantic\" representation of the literal lowered from the original tokens.\n     /// Strings are unescaped, hexadecimal forms are eliminated, etc.\n-    /// FIXME: Remove this and only create the semantic representation during lowering to HIR.\n     pub kind: LitKind,\n     pub span: Span,\n }\n \n-/// Same as `Lit`, but restricted to string literals.\n+/// Similar to `MetaItemLit`, but restricted to string literals.\n #[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub struct StrLit {\n     /// The original literal token as written in source code.\n@@ -1747,7 +1746,6 @@ pub struct StrLit {\n     pub suffix: Option<Symbol>,\n     pub span: Span,\n     /// The unescaped \"semantic\" representation of the literal lowered from the original token.\n-    /// FIXME: Remove this and only create the semantic representation during lowering to HIR.\n     pub symbol_unescaped: Symbol,\n }\n \n@@ -1783,6 +1781,8 @@ pub enum LitFloatType {\n     Unsuffixed,\n }\n \n+/// This type is used within both `ast::MetaItemLit` and `hir::Lit`.\n+///\n /// Note that the entire literal (including the suffix) is considered when\n /// deciding the `LitKind`. This means that float literals like `1f32` are\n /// classified by this type as `Float`. This is different to `token::LitKind`\n@@ -3096,9 +3096,9 @@ mod size_asserts {\n     static_assert_size!(Impl, 184);\n     static_assert_size!(Item, 184);\n     static_assert_size!(ItemKind, 112);\n-    static_assert_size!(Lit, 48);\n     static_assert_size!(LitKind, 24);\n     static_assert_size!(Local, 72);\n+    static_assert_size!(MetaItemLit, 48);\n     static_assert_size!(Param, 40);\n     static_assert_size!(Pat, 88);\n     static_assert_size!(Path, 24);"}, {"sha": "7a86b471ba298a988f7f61b89ecbf8d6b56c3e29", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -2,7 +2,7 @@\n \n use crate::ast;\n use crate::ast::{AttrArgs, AttrArgsEq, AttrId, AttrItem, AttrKind, AttrStyle, Attribute};\n-use crate::ast::{DelimArgs, Lit, LitKind};\n+use crate::ast::{DelimArgs, LitKind, MetaItemLit};\n use crate::ast::{MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Path, PathSegment};\n use crate::ptr::P;\n@@ -50,10 +50,10 @@ impl NestedMetaItem {\n         }\n     }\n \n-    /// Returns the `Lit` if `self` is a `NestedMetaItem::Literal`s.\n-    pub fn literal(&self) -> Option<&Lit> {\n+    /// Returns the `MetaItemLit` if `self` is a `NestedMetaItem::Literal`s.\n+    pub fn lit(&self) -> Option<&MetaItemLit> {\n         match self {\n-            NestedMetaItem::Literal(lit) => Some(lit),\n+            NestedMetaItem::Lit(lit) => Some(lit),\n             _ => None,\n         }\n     }\n@@ -78,12 +78,12 @@ impl NestedMetaItem {\n     }\n \n     /// Returns a name and single literal value tuple of the `MetaItem`.\n-    pub fn name_value_literal(&self) -> Option<(Symbol, &Lit)> {\n+    pub fn name_value_literal(&self) -> Option<(Symbol, &MetaItemLit)> {\n         self.meta_item().and_then(|meta_item| {\n             meta_item.meta_item_list().and_then(|meta_item_list| {\n                 if meta_item_list.len() == 1\n                     && let Some(ident) = meta_item.ident()\n-                    && let Some(lit) = meta_item_list[0].literal()\n+                    && let Some(lit) = meta_item_list[0].lit()\n                 {\n                     return Some((ident.name, lit));\n                 }\n@@ -179,7 +179,7 @@ impl MetaItem {\n     ///     #[attribute(name = \"value\")]\n     ///                 ^^^^^^^^^^^^^^\n     /// ```\n-    pub fn name_value_literal(&self) -> Option<&Lit> {\n+    pub fn name_value_literal(&self) -> Option<&MetaItemLit> {\n         match &self.kind {\n             MetaItemKind::NameValue(v) => Some(v),\n             _ => None,\n@@ -334,7 +334,7 @@ pub fn mk_name_value_item_str(ident: Ident, str: Symbol, str_span: Span) -> Meta\n }\n \n pub fn mk_name_value_item(ident: Ident, lit_kind: LitKind, lit_span: Span) -> MetaItem {\n-    let lit = Lit::from_lit_kind(lit_kind, lit_span);\n+    let lit = MetaItemLit::from_lit_kind(lit_kind, lit_span);\n     let span = ident.span.to(lit_span);\n     MetaItem { path: Path::from_ident(ident), span, kind: MetaItemKind::NameValue(lit) }\n }\n@@ -604,7 +604,7 @@ impl MetaItemKind {\n                 MetaItemKind::name_value_from_tokens(&mut inner_tokens.into_trees())\n             }\n             Some(TokenTree::Token(token, _)) => {\n-                Lit::from_token(&token).map(MetaItemKind::NameValue)\n+                MetaItemLit::from_token(&token).map(MetaItemKind::NameValue)\n             }\n             _ => None,\n         }\n@@ -622,7 +622,7 @@ impl MetaItemKind {\n             AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => match expr.kind {\n                 ast::ExprKind::Lit(token_lit) => {\n                     // Turn failures to `None`, we'll get parse errors elsewhere.\n-                    Lit::from_token_lit(token_lit, expr.span)\n+                    MetaItemLit::from_token_lit(token_lit, expr.span)\n                         .ok()\n                         .map(|lit| MetaItemKind::NameValue(lit))\n                 }\n@@ -655,14 +655,14 @@ impl NestedMetaItem {\n     pub fn span(&self) -> Span {\n         match self {\n             NestedMetaItem::MetaItem(item) => item.span,\n-            NestedMetaItem::Literal(lit) => lit.span,\n+            NestedMetaItem::Lit(lit) => lit.span,\n         }\n     }\n \n     fn token_trees(&self) -> Vec<TokenTree> {\n         match self {\n             NestedMetaItem::MetaItem(item) => item.token_trees(),\n-            NestedMetaItem::Literal(lit) => {\n+            NestedMetaItem::Lit(lit) => {\n                 vec![TokenTree::Token(lit.to_token(), Spacing::Alone)]\n             }\n         }\n@@ -674,10 +674,10 @@ impl NestedMetaItem {\n     {\n         match tokens.peek() {\n             Some(TokenTree::Token(token, _))\n-                if let Some(lit) = Lit::from_token(token) =>\n+                if let Some(lit) = MetaItemLit::from_token(token) =>\n             {\n                 tokens.next();\n-                return Some(NestedMetaItem::Literal(lit));\n+                return Some(NestedMetaItem::Lit(lit));\n             }\n             Some(TokenTree::Delimited(_, Delimiter::Invisible, inner_tokens)) => {\n                 let inner_tokens = inner_tokens.clone();"}, {"sha": "cb3c54fa03ce56dd4395d543179bdd1842d4fcb7", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -628,7 +628,7 @@ pub fn noop_visit_macro_def<T: MutVisitor>(macro_def: &mut MacroDef, vis: &mut T\n pub fn noop_visit_meta_list_item<T: MutVisitor>(li: &mut NestedMetaItem, vis: &mut T) {\n     match li {\n         NestedMetaItem::MetaItem(mi) => vis.visit_meta_item(mi),\n-        NestedMetaItem::Literal(_lit) => {}\n+        NestedMetaItem::Lit(_lit) => {}\n     }\n }\n "}, {"sha": "42cba07fcef8d41c6044d15f8e4571b97aeb00c7", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -1,8 +1,7 @@\n //! Code related to parsing literals.\n \n-use crate::ast::{self, Lit, LitKind};\n+use crate::ast::{self, LitKind, MetaItemLit};\n use crate::token::{self, Token};\n-use rustc_data_structures::sync::Lrc;\n use rustc_lexer::unescape::{byte_from_char, unescape_byte, unescape_char, unescape_literal, Mode};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n@@ -196,33 +195,26 @@ impl LitKind {\n     }\n }\n \n-impl Lit {\n-    /// Converts literal token into an AST literal.\n-    pub fn from_token_lit(token_lit: token::Lit, span: Span) -> Result<Lit, LitError> {\n-        Ok(Lit { token_lit, kind: LitKind::from_token_lit(token_lit)?, span })\n+impl MetaItemLit {\n+    /// Converts token literal into a meta item literal.\n+    pub fn from_token_lit(token_lit: token::Lit, span: Span) -> Result<MetaItemLit, LitError> {\n+        Ok(MetaItemLit { token_lit, kind: LitKind::from_token_lit(token_lit)?, span })\n     }\n \n-    /// Converts an arbitrary token into an AST literal.\n-    pub fn from_token(token: &Token) -> Option<Lit> {\n+    /// Converts an arbitrary token into meta item literal.\n+    pub fn from_token(token: &Token) -> Option<MetaItemLit> {\n         token::Lit::from_token(token)\n-            .and_then(|token_lit| Lit::from_token_lit(token_lit, token.span).ok())\n+            .and_then(|token_lit| MetaItemLit::from_token_lit(token_lit, token.span).ok())\n     }\n \n-    /// Attempts to recover an AST literal from semantic literal.\n+    /// Attempts to create a meta item literal from a `LitKind`.\n     /// This function is used when the original token doesn't exist (e.g. the literal is created\n     /// by an AST-based macro) or unavailable (e.g. from HIR pretty-printing).\n-    pub fn from_lit_kind(kind: LitKind, span: Span) -> Lit {\n-        Lit { token_lit: kind.to_token_lit(), kind, span }\n+    pub fn from_lit_kind(kind: LitKind, span: Span) -> MetaItemLit {\n+        MetaItemLit { token_lit: kind.to_token_lit(), kind, span }\n     }\n \n-    /// Recovers an AST literal from a string of bytes produced by `include_bytes!`.\n-    /// This requires ASCII-escaping the string, which can result in poor performance\n-    /// for very large strings of bytes.\n-    pub fn from_included_bytes(bytes: &Lrc<[u8]>, span: Span) -> Lit {\n-        Self::from_lit_kind(LitKind::ByteStr(bytes.clone()), span)\n-    }\n-\n-    /// Losslessly convert an AST literal into a token.\n+    /// Losslessly convert a meta item literal into a token.\n     pub fn to_token(&self) -> Token {\n         let kind = match self.token_lit.kind {\n             token::Bool => token::Ident(self.token_lit.symbol, false),"}, {"sha": "ad6e72d015695efd1f2934881bf795f8074434d0", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -948,17 +948,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             AttrArgs::Eq(eq_span, AttrArgsEq::Ast(expr)) => {\n                 // In valid code the value always ends up as a single literal. Otherwise, a dummy\n                 // literal suffices because the error is handled elsewhere.\n-                let lit = if let ExprKind::Lit(token_lit) = expr.kind {\n-                    match Lit::from_token_lit(token_lit, expr.span) {\n-                        Ok(lit) => lit,\n-                        Err(_err) => Lit {\n-                            token_lit: token::Lit::new(token::LitKind::Err, kw::Empty, None),\n-                            kind: LitKind::Err,\n-                            span: DUMMY_SP,\n-                        },\n-                    }\n+                let lit = if let ExprKind::Lit(token_lit) = expr.kind\n+                    && let Ok(lit) = MetaItemLit::from_token_lit(token_lit, expr.span)\n+                {\n+                    lit\n                 } else {\n-                    Lit {\n+                    MetaItemLit {\n                         token_lit: token::Lit::new(token::LitKind::Err, kw::Empty, None),\n                         kind: LitKind::Err,\n                         span: DUMMY_SP,"}, {"sha": "7a9243c511b921c068edc1d1491ae8f2da0740ee", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -371,7 +371,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         }\n     }\n \n-    fn print_literal(&mut self, lit: &ast::Lit) {\n+    fn print_meta_item_lit(&mut self, lit: &ast::MetaItemLit) {\n         self.print_token_literal(lit.token_lit, lit.span)\n     }\n \n@@ -488,7 +488,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 self.print_path(&item.path, false, 0);\n                 self.space();\n                 self.word_space(\"=\");\n-                let token_str = self.literal_to_string(lit);\n+                let token_str = self.meta_item_lit_to_string(lit);\n                 self.word(token_str);\n             }\n         }\n@@ -498,7 +498,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     fn print_meta_list_item(&mut self, item: &ast::NestedMetaItem) {\n         match item {\n             ast::NestedMetaItem::MetaItem(ref mi) => self.print_meta_item(mi),\n-            ast::NestedMetaItem::Literal(ref lit) => self.print_literal(lit),\n+            ast::NestedMetaItem::Lit(ref lit) => self.print_meta_item_lit(lit),\n         }\n     }\n \n@@ -510,7 +510,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 self.print_path(&item.path, false, 0);\n                 self.space();\n                 self.word_space(\"=\");\n-                self.print_literal(value);\n+                self.print_meta_item_lit(value);\n             }\n             ast::MetaItemKind::List(ref items) => {\n                 self.print_path(&item.path, false, 0);\n@@ -825,8 +825,8 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         Self::to_string(|s| s.print_expr(e))\n     }\n \n-    fn literal_to_string(&self, lit: &ast::Lit) -> String {\n-        Self::to_string(|s| s.print_literal(lit))\n+    fn meta_item_lit_to_string(&self, lit: &ast::MetaItemLit) -> String {\n+        Self::to_string(|s| s.print_meta_item_lit(lit))\n     }\n \n     fn tt_to_string(&self, tt: &TokenTree) -> String {"}, {"sha": "f4d77549eff4cc77a3a374cd9267b5678b741ef9", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -328,8 +328,8 @@ impl<'a> State<'a> {\n                 self.print_token_literal(token_lit, expr.span);\n             }\n             ast::ExprKind::IncludedBytes(ref bytes) => {\n-                let lit = ast::Lit::from_included_bytes(bytes, expr.span);\n-                self.print_literal(&lit)\n+                let lit = ast::LitKind::ByteStr(bytes.clone()).to_token_lit();\n+                self.print_token_literal(lit, expr.span)\n             }\n             ast::ExprKind::Cast(ref expr, ref ty) => {\n                 let prec = AssocOp::As.precedence() as i8;"}, {"sha": "13b48d8f89ab4a6eea6f60a986d88369be7235d4", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -1,7 +1,7 @@\n //! Parsing and validation of builtin attributes\n \n use rustc_ast as ast;\n-use rustc_ast::{Attribute, Lit, LitKind, MetaItem, MetaItemKind, NestedMetaItem, NodeId};\n+use rustc_ast::{Attribute, LitKind, MetaItem, MetaItemKind, MetaItemLit, NestedMetaItem, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_feature::{find_gated_cfg, is_builtin_attr_name, Features, GatedCfg};\n use rustc_macros::HashStable_Generic;\n@@ -486,7 +486,7 @@ where\n                                     continue 'outer;\n                                 }\n                             },\n-                            NestedMetaItem::Literal(lit) => {\n+                            NestedMetaItem::Lit(lit) => {\n                                 handle_errors(\n                                     &sess.parse_sess,\n                                     lit.span,\n@@ -658,11 +658,11 @@ pub fn eval_condition(\n         ast::MetaItemKind::List(ref mis) if cfg.name_or_empty() == sym::version => {\n             try_gate_cfg(sym::version, cfg.span, sess, features);\n             let (min_version, span) = match &mis[..] {\n-                [NestedMetaItem::Literal(Lit { kind: LitKind::Str(sym, ..), span, .. })] => {\n+                [NestedMetaItem::Lit(MetaItemLit { kind: LitKind::Str(sym, ..), span, .. })] => {\n                     (sym, span)\n                 }\n                 [\n-                    NestedMetaItem::Literal(Lit { span, .. })\n+                    NestedMetaItem::Lit(MetaItemLit { span, .. })\n                     | NestedMetaItem::MetaItem(MetaItem { span, .. }),\n                 ] => {\n                     sess.emit_err(session_diagnostics::ExpectedVersionLiteral { span: *span });\n@@ -899,7 +899,7 @@ where\n                                 continue 'outer;\n                             }\n                         },\n-                        NestedMetaItem::Literal(lit) => {\n+                        NestedMetaItem::Lit(lit) => {\n                             handle_errors(\n                                 &sess.parse_sess,\n                                 lit.span,"}, {"sha": "d221da5c17ed0bd31d20d107933e548b89df2744", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -732,13 +732,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let tcx = self.infcx.tcx;\n         // Try to find predicates on *generic params* that would allow copying `ty`\n         let infcx = tcx.infer_ctxt().build();\n-        if infcx\n-            .type_implements_trait(\n-                tcx.lang_items().clone_trait().unwrap(),\n-                [tcx.erase_regions(ty)],\n-                self.param_env,\n-            )\n-            .must_apply_modulo_regions()\n+\n+        if let Some(clone_trait_def) = tcx.lang_items().clone_trait()\n+            && infcx\n+                .type_implements_trait(\n+                    clone_trait_def,\n+                    [tcx.erase_regions(ty)],\n+                    self.param_env,\n+                )\n+                .must_apply_modulo_regions()\n         {\n             err.span_suggestion_verbose(\n                 span.shrink_to_hi(),"}, {"sha": "c8a2fca00e800efacb597aea3744e2275f2d6e48", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -48,9 +48,9 @@ impl MultiItemModifier for Expander {\n                     .into_iter()\n                     .filter_map(|nested_meta| match nested_meta {\n                         NestedMetaItem::MetaItem(meta) => Some(meta),\n-                        NestedMetaItem::Literal(lit) => {\n+                        NestedMetaItem::Lit(lit) => {\n                             // Reject `#[derive(\"Debug\")]`.\n-                            report_unexpected_literal(sess, &lit);\n+                            report_unexpected_meta_item_lit(sess, &lit);\n                             None\n                         }\n                     })\n@@ -127,7 +127,7 @@ fn report_bad_target(sess: &Session, item: &Annotatable, span: Span) -> bool {\n     bad_target\n }\n \n-fn report_unexpected_literal(sess: &Session, lit: &ast::Lit) {\n+fn report_unexpected_meta_item_lit(sess: &Session, lit: &ast::MetaItemLit) {\n     let help_msg = match lit.token_lit.kind {\n         token::Str if rustc_lexer::is_ident(lit.token_lit.symbol.as_str()) => {\n             format!(\"try using `#[derive({})]`\", lit.token_lit.symbol)"}, {"sha": "c27790d8887a377a67a59da57daa99ca84f5f9b3", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -66,7 +66,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     )?;\n \n     // The main interpreter loop.\n-    ecx.run()?;\n+    while ecx.step()? {}\n \n     // Intern the result\n     let intern_kind = if cid.promoted.is_some() {"}, {"sha": "60578246eedcccb01cf885385d53caa5839602f7", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -32,11 +32,6 @@ fn binop_right_homogeneous(op: mir::BinOp) -> bool {\n }\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    pub fn run(&mut self) -> InterpResult<'tcx> {\n-        while self.step()? {}\n-        Ok(())\n-    }\n-\n     /// Returns `true` as long as there are more things to do.\n     ///\n     /// This is used by [priroda](https://github.com/oli-obk/priroda)"}, {"sha": "7616579611711984161c740745240ab4a9bac203", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -526,11 +526,8 @@ impl server::TokenStream for Rustc<'_, '_> {\n                 Ok(tokenstream::TokenStream::token_alone(token::Literal(*token_lit), expr.span))\n             }\n             ast::ExprKind::IncludedBytes(bytes) => {\n-                let lit = ast::Lit::from_included_bytes(bytes, expr.span);\n-                Ok(tokenstream::TokenStream::token_alone(\n-                    token::TokenKind::Literal(lit.token_lit),\n-                    expr.span,\n-                ))\n+                let lit = ast::LitKind::ByteStr(bytes.clone()).to_token_lit();\n+                Ok(tokenstream::TokenStream::token_alone(token::TokenKind::Literal(lit), expr.span))\n             }\n             ast::ExprKind::Unary(ast::UnOp::Neg, e) => match &e.kind {\n                 ast::ExprKind::Lit(token_lit) => match token_lit {"}, {"sha": "638dd6d756b58177ec5225df67a1668599406f44", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -2145,7 +2145,7 @@ fn should_inherit_track_caller(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n }\n \n fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n-    use rustc_ast::{Lit, LitIntType, LitKind};\n+    use rustc_ast::{LitIntType, LitKind, MetaItemLit};\n     if !tcx.features().raw_dylib && tcx.sess.target.arch == \"x86\" {\n         feature_err(\n             &tcx.sess.parse_sess,\n@@ -2158,7 +2158,7 @@ fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n     let meta_item_list = attr.meta_item_list();\n     let meta_item_list = meta_item_list.as_deref();\n     let sole_meta_list = match meta_item_list {\n-        Some([item]) => item.literal(),\n+        Some([item]) => item.lit(),\n         Some(_) => {\n             tcx.sess\n                 .struct_span_err(attr.span, \"incorrect number of arguments to `#[link_ordinal]`\")\n@@ -2168,7 +2168,9 @@ fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n         }\n         _ => None,\n     };\n-    if let Some(Lit { kind: LitKind::Int(ordinal, LitIntType::Unsuffixed), .. }) = sole_meta_list {\n+    if let Some(MetaItemLit { kind: LitKind::Int(ordinal, LitIntType::Unsuffixed), .. }) =\n+        sole_meta_list\n+    {\n         // According to the table at https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#import-header,\n         // the ordinal must fit into 16 bits.  Similarly, the Ordinal field in COFFShortExport (defined\n         // in llvm/include/llvm/Object/COFFImportFile.h), which we use to communicate import information"}, {"sha": "10b474efd5aebdc9337b0a3d863fa04d0badc674", "filename": "compiler/rustc_infer/src/infer/outlives/test_type_match.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -155,14 +155,17 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n         bug!()\n     }\n \n+    #[instrument(level = \"trace\", skip(self))]\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n-        _: ty::Variance,\n+        variance: ty::Variance,\n         _: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {\n-        self.relate(a, b)\n+        // Opaque types substs have lifetime parameters.\n+        // We must not check them to be equal, as we never insert anything to make them so.\n+        if variance != ty::Bivariant { self.relate(a, b) } else { Ok(a) }\n     }\n \n     #[instrument(skip(self), level = \"debug\")]"}, {"sha": "4c22ab68a5681f227aa4a644c64a346be1689311", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -194,7 +194,7 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n \n                                         for val in values {\n                                             if let Some(LitKind::Str(s, _)) =\n-                                                val.literal().map(|lit| &lit.kind)\n+                                                val.lit().map(|lit| &lit.kind)\n                                             {\n                                                 ident_values.insert(s.to_string());\n                                             } else {"}, {"sha": "a6c7e819482c25c992f4f125a4d6f6ae530875f7", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -462,8 +462,8 @@ impl LateLintPass<'_> for BadOptAccess {\n                 let Some(attr) = cx.tcx.get_attr(field.did, sym::rustc_lint_opt_deny_field_access) &&\n                 let Some(items) = attr.meta_item_list()  &&\n                 let Some(item) = items.first()  &&\n-                let Some(literal) = item.literal()  &&\n-                let ast::LitKind::Str(val, _) = literal.kind\n+                let Some(lit) = item.lit()  &&\n+                let ast::LitKind::Str(val, _) = lit.kind\n             {\n                 cx.struct_span_lint(BAD_OPT_ACCESS, expr.span, val.as_str(), |lint|\n                     lint"}, {"sha": "5f911d5884a3353019f39ee10521beaab33bdcd1", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -36,7 +36,7 @@ pub use init_mask::{InitChunk, InitChunkIter};\n /// module provides higher-level access.\n // Note: for performance reasons when interning, some of the `Allocation` fields can be partially\n // hashed. (see the `Hash` impl below for more details), so the impl is not derived.\n-#[derive(Clone, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n+#[derive(Clone, Eq, PartialEq, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub struct Allocation<Prov: Provenance = AllocId, Extra = ()> {\n     /// The actual bytes of the allocation.\n@@ -108,7 +108,7 @@ impl hash::Hash for Allocation {\n /// Here things are different because only const allocations are interned. This\n /// means that both the inner type (`Allocation`) and the outer type\n /// (`ConstAllocation`) are used quite a bit.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, HashStable)]\n #[rustc_pass_by_value]\n pub struct ConstAllocation<'tcx>(pub Interned<'tcx, Allocation>);\n "}, {"sha": "82e9a961a2bfb73a3b703917b29231d4588e6911", "filename": "compiler/rustc_middle/src/mir/interpret/allocation/init_mask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -12,7 +12,7 @@ type Block = u64;\n /// is initialized. If it is `false` the byte is uninitialized.\n // Note: for performance reasons when interning, some of the `InitMask` fields can be partially\n // hashed. (see the `Hash` impl below for more details), so the impl is not derived.\n-#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n+#[derive(Clone, Debug, Eq, PartialEq, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub struct InitMask {\n     blocks: Vec<Block>,"}, {"sha": "ddd3f394358a311d059dae14a971f204308b71a6", "filename": "compiler/rustc_middle/src/mir/interpret/allocation/provenance_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Fprovenance_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Fprovenance_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Fprovenance_map.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -10,7 +10,7 @@ use super::{alloc_range, AllocError, AllocId, AllocRange, AllocResult, Provenanc\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n \n /// Stores the provenance information of pointers stored in memory.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n #[derive(HashStable)]\n pub struct ProvenanceMap<Prov = AllocId> {\n     /// Provenance in this map applies from the given offset for an entire pointer-size worth of"}, {"sha": "9c270ba1ec179939e18834ca0f773c9efbea4836", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -173,7 +173,7 @@ impl Provenance for AllocId {\n /// Represents a pointer in the Miri engine.\n ///\n /// Pointers are \"tagged\" with provenance information; typically the `AllocId` they belong to.\n-#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, TyEncodable, TyDecodable, Hash)]\n+#[derive(Copy, Clone, Eq, PartialEq, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n pub struct Pointer<Prov = AllocId> {\n     pub(super) offset: Size, // kept private to avoid accidental misinterpretation (meaning depends on `Prov` type)"}, {"sha": "e6636e50e6e7ab0a1acf50e90cf57ed963c70c6a", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -28,7 +28,7 @@ pub struct ConstAlloc<'tcx> {\n \n /// Represents a constant value in Rust. `Scalar` and `Slice` are optimizations for\n /// array length computations, enum discriminants and the pattern matching logic.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable, Hash)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable, Lift)]\n pub enum ConstValue<'tcx> {\n     /// Used only for types with `layout::abi::Scalar` ABI.\n@@ -110,7 +110,7 @@ impl<'tcx> ConstValue<'tcx> {\n ///\n /// These variants would be private if there was a convenient way to achieve that in Rust.\n /// Do *not* match on a `Scalar`! Use the various `to_*` methods instead.\n-#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, TyEncodable, TyDecodable, Hash)]\n+#[derive(Clone, Copy, Eq, PartialEq, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n pub enum Scalar<Prov = AllocId> {\n     /// The raw bytes of a simple value."}, {"sha": "297433d37c4f369b19dff3f1eab83694a4fb5426", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -1191,8 +1191,9 @@ impl<'tcx> TyCtxt<'tcx> {\n             debug!(\"layout_scalar_valid_range: attr={:?}\", attr);\n             if let Some(\n                 &[\n-                    ast::NestedMetaItem::Literal(ast::Lit {\n-                        kind: ast::LitKind::Int(a, _), ..\n+                    ast::NestedMetaItem::Lit(ast::MetaItemLit {\n+                        kind: ast::LitKind::Int(a, _),\n+                        ..\n                     }),\n                 ],\n             ) = attr.meta_item_list().as_deref()"}, {"sha": "4cdfd9e594042ba3550aa038094c7c707ad836b2", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -72,12 +72,18 @@ pub trait TypeVisitable<'tcx>: fmt::Debug + Clone {\n         self.visit_with(&mut HasEscapingVarsVisitor { outer_index: binder }).is_break()\n     }\n \n-    /// Returns `true` if this `self` has any regions that escape `binder` (and\n+    /// Returns `true` if this type has any regions that escape `binder` (and\n     /// hence are not bound by it).\n     fn has_vars_bound_above(&self, binder: ty::DebruijnIndex) -> bool {\n         self.has_vars_bound_at_or_above(binder.shifted_in(1))\n     }\n \n+    /// Return `true` if this type has regions that are not a part of the type.\n+    /// For example, `for<'a> fn(&'a i32)` return `false`, while `fn(&'a i32)`\n+    /// would return `true`. The latter can occur when traversing through the\n+    /// former.\n+    ///\n+    /// See [`HasEscapingVarsVisitor`] for more information.\n     fn has_escaping_bound_vars(&self) -> bool {\n         self.has_vars_bound_at_or_above(ty::INNERMOST)\n     }"}, {"sha": "c7d239b647f35b2bc273fdc0185a5cf224f13ac9", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -315,8 +315,9 @@ impl<'a> Parser<'a> {\n         Ok(attrs)\n     }\n \n-    pub(crate) fn parse_unsuffixed_lit(&mut self) -> PResult<'a, ast::Lit> {\n-        let lit = self.parse_ast_lit()?;\n+    // Note: must be unsuffixed.\n+    pub(crate) fn parse_unsuffixed_meta_item_lit(&mut self) -> PResult<'a, ast::MetaItemLit> {\n+        let lit = self.parse_meta_item_lit()?;\n         debug!(\"checking if {:?} is unsuffixed\", lit);\n \n         if !lit.kind.is_unsuffixed() {\n@@ -391,7 +392,7 @@ impl<'a> Parser<'a> {\n \n     pub(crate) fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {\n         Ok(if self.eat(&token::Eq) {\n-            ast::MetaItemKind::NameValue(self.parse_unsuffixed_lit()?)\n+            ast::MetaItemKind::NameValue(self.parse_unsuffixed_meta_item_lit()?)\n         } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n             // Matches `meta_seq = ( COMMASEP(meta_item_inner) )`.\n             let (list, _) = self.parse_paren_comma_seq(|p| p.parse_meta_item_inner())?;\n@@ -403,8 +404,8 @@ impl<'a> Parser<'a> {\n \n     /// Matches `meta_item_inner : (meta_item | UNSUFFIXED_LIT) ;`.\n     fn parse_meta_item_inner(&mut self) -> PResult<'a, ast::NestedMetaItem> {\n-        match self.parse_unsuffixed_lit() {\n-            Ok(lit) => return Ok(ast::NestedMetaItem::Literal(lit)),\n+        match self.parse_unsuffixed_meta_item_lit() {\n+            Ok(lit) => return Ok(ast::NestedMetaItem::Lit(lit)),\n             Err(err) => err.cancel(),\n         }\n "}, {"sha": "e0443a697b50415fc950376706034f3aacdb9085", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -33,10 +33,10 @@ use rustc_ast::util::case::Case;\n use rustc_ast::util::classify;\n use rustc_ast::util::parser::{prec_let_scrutinee_needs_par, AssocOp, Fixity};\n use rustc_ast::visit::Visitor;\n-use rustc_ast::{self as ast, AttrStyle, AttrVec, CaptureBy, ExprField, Lit, UnOp, DUMMY_NODE_ID};\n+use rustc_ast::{self as ast, AttrStyle, AttrVec, CaptureBy, ExprField, UnOp, DUMMY_NODE_ID};\n use rustc_ast::{AnonConst, BinOp, BinOpKind, FnDecl, FnRetTy, MacCall, Param, Ty, TyKind};\n use rustc_ast::{Arm, Async, BlockCheckMode, Expr, ExprKind, Label, Movability, RangeLimits};\n-use rustc_ast::{ClosureBinder, StmtKind};\n+use rustc_ast::{ClosureBinder, MetaItemLit, StmtKind};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{\n     Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, PResult,\n@@ -1631,7 +1631,7 @@ impl<'a> Parser<'a> {\n         &self,\n         lifetime: Ident,\n         err: impl FnOnce(&Self) -> DiagnosticBuilder<'a, ErrorGuaranteed>,\n-    ) -> ast::Lit {\n+    ) -> ast::MetaItemLit {\n         if let Some(mut diag) =\n             self.sess.span_diagnostic.steal_diagnostic(lifetime.span, StashKey::LifetimeIsChar)\n         {\n@@ -1653,7 +1653,7 @@ impl<'a> Parser<'a> {\n                 .emit();\n         }\n         let name = lifetime.without_first_quote().name;\n-        ast::Lit {\n+        ast::MetaItemLit {\n             token_lit: token::Lit::new(token::LitKind::Char, name, None),\n             kind: ast::LitKind::Char(name.as_str().chars().next().unwrap_or('_')),\n             span: lifetime.span,\n@@ -1768,8 +1768,8 @@ impl<'a> Parser<'a> {\n     /// Returns a string literal if the next token is a string literal.\n     /// In case of error returns `Some(lit)` if the next token is a literal with a wrong kind,\n     /// and returns `None` if the next token is not literal at all.\n-    pub fn parse_str_lit(&mut self) -> Result<ast::StrLit, Option<Lit>> {\n-        match self.parse_opt_ast_lit() {\n+    pub fn parse_str_lit(&mut self) -> Result<ast::StrLit, Option<MetaItemLit>> {\n+        match self.parse_opt_meta_item_lit() {\n             Some(lit) => match lit.kind {\n                 ast::LitKind::Str(symbol_unescaped, style) => Ok(ast::StrLit {\n                     style,\n@@ -1784,7 +1784,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn handle_missing_lit(&mut self) -> PResult<'a, Lit> {\n+    fn handle_missing_lit(&mut self) -> PResult<'a, MetaItemLit> {\n         if let token::Interpolated(inner) = &self.token.kind {\n             let expr = match inner.as_ref() {\n                 token::NtExpr(expr) => Some(expr),\n@@ -1820,8 +1820,8 @@ impl<'a> Parser<'a> {\n             .or_else(|()| self.handle_missing_lit().map(|lit| (lit.token_lit, lit.span)))\n     }\n \n-    pub(super) fn parse_ast_lit(&mut self) -> PResult<'a, Lit> {\n-        self.parse_opt_ast_lit().ok_or(()).or_else(|()| self.handle_missing_lit())\n+    pub(super) fn parse_meta_item_lit(&mut self) -> PResult<'a, MetaItemLit> {\n+        self.parse_opt_meta_item_lit().ok_or(()).or_else(|()| self.handle_missing_lit())\n     }\n \n     fn recover_after_dot(&mut self) -> Option<Token> {\n@@ -1867,12 +1867,12 @@ impl<'a> Parser<'a> {\n \n     /// Matches `lit = true | false | token_lit`.\n     /// Returns `None` if the next token is not a literal.\n-    pub(super) fn parse_opt_ast_lit(&mut self) -> Option<Lit> {\n+    pub(super) fn parse_opt_meta_item_lit(&mut self) -> Option<MetaItemLit> {\n         let recovered = self.recover_after_dot();\n         let token = recovered.as_ref().unwrap_or(&self.token);\n         match token::Lit::from_token(token) {\n             Some(token_lit) => {\n-                match Lit::from_token_lit(token_lit, token.span) {\n+                match MetaItemLit::from_token_lit(token_lit, token.span) {\n                     Ok(lit) => {\n                         self.bump();\n                         Some(lit)\n@@ -1889,7 +1889,10 @@ impl<'a> Parser<'a> {\n                         let suffixless_lit = token::Lit::new(lit.kind, lit.symbol, None);\n                         let symbol = Symbol::intern(&suffixless_lit.to_string());\n                         let lit = token::Lit::new(token::Err, symbol, lit.suffix);\n-                        Some(Lit::from_token_lit(lit, span).unwrap_or_else(|_| unreachable!()))\n+                        Some(\n+                            MetaItemLit::from_token_lit(lit, span)\n+                                .unwrap_or_else(|_| unreachable!()),\n+                        )\n                     }\n                 }\n             }"}, {"sha": "ff1ddfd97dfc62dc52e183f64fb1280433d44ce7", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -358,7 +358,7 @@ impl<'a> Parser<'a> {\n     /// report error for `let 1x = 123`\n     pub fn report_invalid_identifier_error(&mut self) -> PResult<'a, ()> {\n         if let token::Literal(lit) = self.token.uninterpolate().kind &&\n-            rustc_ast::Lit::from_token(&self.token).is_none() &&\n+            rustc_ast::MetaItemLit::from_token(&self.token).is_none() &&\n             (lit.kind == token::LitKind::Integer || lit.kind == token::LitKind::Float) &&\n             self.look_ahead(1, |t| matches!(t.kind, token::Eq) || matches!(t.kind, token::Colon ) ) {\n                 return Err(self.sess.create_err(InvalidIdentiferStartsWithNumber { span: self.token.span }));"}, {"sha": "59e564114e5cf0e390ed38585e5f83c0c2026425", "filename": "compiler/rustc_parse/src/validate_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -51,7 +51,7 @@ pub fn parse_meta<'a>(sess: &'a ParseSess, attr: &Attribute) -> PResult<'a, Meta\n             }\n             AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => {\n                 if let ast::ExprKind::Lit(token_lit) = expr.kind\n-                    && let Ok(lit) = ast::Lit::from_token_lit(token_lit, expr.span)\n+                    && let Ok(lit) = ast::MetaItemLit::from_token_lit(token_lit, expr.span)\n                 {\n                     if token_lit.suffix.is_some() {\n                         let mut err = sess.span_diagnostic.struct_span_err("}, {"sha": "2e2874dbccb9e4fb3749f901398f9310e9212f4b", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -8,7 +8,7 @@ use crate::errors::{\n     self, AttrApplication, DebugVisualizerUnreadable, InvalidAttrAtCrateLevel, ObjectLifetimeErr,\n     OnlyHasEffectOn, TransparentIncompatible, UnrecognizedReprHint,\n };\n-use rustc_ast::{ast, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n+use rustc_ast::{ast, AttrStyle, Attribute, LitKind, MetaItemKind, MetaItemLit, NestedMetaItem};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{fluent, Applicability, MultiSpan};\n use rustc_expand::base::resolve_path;\n@@ -715,7 +715,7 @@ impl CheckAttrVisitor<'_> {\n         if let Some(values) = meta.meta_item_list() {\n             let mut errors = 0;\n             for v in values {\n-                match v.literal() {\n+                match v.lit() {\n                     Some(l) => match l.kind {\n                         LitKind::Str(s, _) => {\n                             if !self.check_doc_alias_value(v, s, hir_id, target, true, aliases) {\n@@ -1355,7 +1355,7 @@ impl CheckAttrVisitor<'_> {\n             return false;\n         };\n \n-        if matches!(&list[..], &[NestedMetaItem::Literal(Lit { kind: LitKind::Int(..), .. })]) {\n+        if matches!(&list[..], &[NestedMetaItem::Lit(MetaItemLit { kind: LitKind::Int(..), .. })]) {\n             true\n         } else {\n             self.tcx.sess.emit_err(errors::RustcLayoutScalarValidRangeArg { attr_span: attr.span });\n@@ -1418,7 +1418,7 @@ impl CheckAttrVisitor<'_> {\n         let arg_count = decl.inputs.len() as u128 + generics.params.len() as u128;\n         let mut invalid_args = vec![];\n         for meta in list {\n-            if let Some(LitKind::Int(val, _)) = meta.literal().map(|lit| &lit.kind) {\n+            if let Some(LitKind::Int(val, _)) = meta.lit().map(|lit| &lit.kind) {\n                 if *val >= arg_count {\n                     let span = meta.span();\n                     self.tcx.sess.emit_err(errors::RustcLegacyConstGenericsIndexExceed {"}, {"sha": "5b9513ebc0da4ae9ced55de9fce5e9d9ca19cb2c", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -282,6 +282,14 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                             \"you may want to use a bool value instead\",\n                             format!(\"{}\", item_typo),\n                         ))\n+                    // FIXME(vicnenzopalazzo): make the check smarter,\n+                    // and maybe expand with levenshtein distance checks\n+                    } else if item_str.as_str() == \"printf\" {\n+                        Some((\n+                            item_span,\n+                            \"you may have meant to use the `print` macro\",\n+                            \"print!\".to_owned(),\n+                        ))\n                     } else {\n                         suggestion\n                     };"}, {"sha": "4ef89cfb2554fdbc13f0dde06cbb2582a81eeb30", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -1989,7 +1989,7 @@ impl<'a> Resolver<'a> {\n                     .find(|a| a.has_name(sym::rustc_legacy_const_generics))?;\n                 let mut ret = Vec::new();\n                 for meta in attr.meta_item_list()? {\n-                    match meta.literal()?.kind {\n+                    match meta.lit()?.kind {\n                         LitKind::Int(a, _) => ret.push(a as usize),\n                         _ => panic!(\"invalid arg index\"),\n                     }"}, {"sha": "a5311dbd1b77025b32d282d9cf689d70c5e53fcd", "filename": "compiler/rustc_ty_utils/src/layout_sanity_check.rs", "status": "modified", "additions": 272, "deletions": 262, "changes": 534, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout_sanity_check.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -20,283 +20,293 @@ pub(super) fn sanity_check_layout<'tcx>(\n         bug!(\"size is not a multiple of align, in the following layout:\\n{layout:#?}\");\n     }\n \n-    if cfg!(debug_assertions) {\n-        /// Yields non-ZST fields of the type\n-        fn non_zst_fields<'tcx, 'a>(\n-            cx: &'a LayoutCx<'tcx, TyCtxt<'tcx>>,\n-            layout: &'a TyAndLayout<'tcx>,\n-        ) -> impl Iterator<Item = (Size, TyAndLayout<'tcx>)> + 'a {\n-            (0..layout.layout.fields().count()).filter_map(|i| {\n-                let field = layout.field(cx, i);\n-                // Also checking `align == 1` here leads to test failures in\n-                // `layout/zero-sized-array-union.rs`, where a type has a zero-size field with\n-                // alignment 4 that still gets ignored during layout computation (which is okay\n-                // since other fields already force alignment 4).\n-                let zst = field.is_zst();\n-                (!zst).then(|| (layout.fields.offset(i), field))\n-            })\n-        }\n+    if !cfg!(debug_assertions) {\n+        // Stop here, the rest is kind of expensive.\n+        return;\n+    }\n \n-        fn skip_newtypes<'tcx>(\n-            cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n-            layout: &TyAndLayout<'tcx>,\n-        ) -> TyAndLayout<'tcx> {\n-            if matches!(layout.layout.variants(), Variants::Multiple { .. }) {\n-                // Definitely not a newtype of anything.\n-                return *layout;\n-            }\n-            let mut fields = non_zst_fields(cx, layout);\n-            let Some(first) = fields.next() else {\n-                // No fields here, so this could be a primitive or enum -- either way it's not a newtype around a thing\n-                return *layout\n-            };\n-            if fields.next().is_none() {\n-                let (offset, first) = first;\n-                if offset == Size::ZERO && first.layout.size() == layout.size {\n-                    // This is a newtype, so keep recursing.\n-                    // FIXME(RalfJung): I don't think it would be correct to do any checks for\n-                    // alignment here, so we don't. Is that correct?\n-                    return skip_newtypes(cx, &first);\n-                }\n+    /// Yields non-ZST fields of the type\n+    fn non_zst_fields<'tcx, 'a>(\n+        cx: &'a LayoutCx<'tcx, TyCtxt<'tcx>>,\n+        layout: &'a TyAndLayout<'tcx>,\n+    ) -> impl Iterator<Item = (Size, TyAndLayout<'tcx>)> + 'a {\n+        (0..layout.layout.fields().count()).filter_map(|i| {\n+            let field = layout.field(cx, i);\n+            // Also checking `align == 1` here leads to test failures in\n+            // `layout/zero-sized-array-union.rs`, where a type has a zero-size field with\n+            // alignment 4 that still gets ignored during layout computation (which is okay\n+            // since other fields already force alignment 4).\n+            let zst = field.is_zst();\n+            (!zst).then(|| (layout.fields.offset(i), field))\n+        })\n+    }\n+\n+    fn skip_newtypes<'tcx>(\n+        cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+        layout: &TyAndLayout<'tcx>,\n+    ) -> TyAndLayout<'tcx> {\n+        if matches!(layout.layout.variants(), Variants::Multiple { .. }) {\n+            // Definitely not a newtype of anything.\n+            return *layout;\n+        }\n+        let mut fields = non_zst_fields(cx, layout);\n+        let Some(first) = fields.next() else {\n+            // No fields here, so this could be a primitive or enum -- either way it's not a newtype around a thing\n+            return *layout\n+        };\n+        if fields.next().is_none() {\n+            let (offset, first) = first;\n+            if offset == Size::ZERO && first.layout.size() == layout.size {\n+                // This is a newtype, so keep recursing.\n+                // FIXME(RalfJung): I don't think it would be correct to do any checks for\n+                // alignment here, so we don't. Is that correct?\n+                return skip_newtypes(cx, &first);\n             }\n-            // No more newtypes here.\n-            *layout\n         }\n+        // No more newtypes here.\n+        *layout\n+    }\n \n-        fn check_layout_abi<'tcx>(cx: &LayoutCx<'tcx, TyCtxt<'tcx>>, layout: &TyAndLayout<'tcx>) {\n-            match layout.layout.abi() {\n-                Abi::Scalar(scalar) => {\n-                    // No padding in scalars.\n-                    let size = scalar.size(cx);\n-                    let align = scalar.align(cx).abi;\n-                    assert_eq!(\n-                        layout.layout.size(),\n-                        size,\n-                        \"size mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                    assert_eq!(\n-                        layout.layout.align().abi,\n-                        align,\n-                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                    // Check that this matches the underlying field.\n-                    let inner = skip_newtypes(cx, layout);\n-                    assert!(\n-                        matches!(inner.layout.abi(), Abi::Scalar(_)),\n-                        \"`Scalar` type {} is newtype around non-`Scalar` type {}\",\n-                        layout.ty,\n-                        inner.ty\n-                    );\n-                    match inner.layout.fields() {\n-                        FieldsShape::Primitive => {\n-                            // Fine.\n-                        }\n-                        FieldsShape::Union(..) => {\n-                            // FIXME: I guess we could also check something here? Like, look at all fields?\n-                            return;\n-                        }\n-                        FieldsShape::Arbitrary { .. } => {\n-                            // Should be an enum, the only field is the discriminant.\n-                            assert!(\n-                                inner.ty.is_enum(),\n-                                \"`Scalar` layout for non-primitive non-enum type {}\",\n-                                inner.ty\n-                            );\n-                            assert_eq!(\n-                                inner.layout.fields().count(),\n-                                1,\n-                                \"`Scalar` layout for multiple-field type in {inner:#?}\",\n-                            );\n-                            let offset = inner.layout.fields().offset(0);\n-                            let field = inner.field(cx, 0);\n-                            // The field should be at the right offset, and match the `scalar` layout.\n-                            assert_eq!(\n-                                offset,\n-                                Size::ZERO,\n-                                \"`Scalar` field at non-0 offset in {inner:#?}\",\n-                            );\n-                            assert_eq!(\n-                                field.size, size,\n-                                \"`Scalar` field with bad size in {inner:#?}\",\n-                            );\n-                            assert_eq!(\n-                                field.align.abi, align,\n-                                \"`Scalar` field with bad align in {inner:#?}\",\n-                            );\n-                            assert!(\n-                                matches!(field.abi, Abi::Scalar(_)),\n-                                \"`Scalar` field with bad ABI in {inner:#?}\",\n-                            );\n-                        }\n-                        _ => {\n-                            panic!(\"`Scalar` layout for non-primitive non-enum type {}\", inner.ty);\n-                        }\n+    fn check_layout_abi<'tcx>(cx: &LayoutCx<'tcx, TyCtxt<'tcx>>, layout: &TyAndLayout<'tcx>) {\n+        match layout.layout.abi() {\n+            Abi::Scalar(scalar) => {\n+                // No padding in scalars.\n+                let size = scalar.size(cx);\n+                let align = scalar.align(cx).abi;\n+                assert_eq!(\n+                    layout.layout.size(),\n+                    size,\n+                    \"size mismatch between ABI and layout in {layout:#?}\"\n+                );\n+                assert_eq!(\n+                    layout.layout.align().abi,\n+                    align,\n+                    \"alignment mismatch between ABI and layout in {layout:#?}\"\n+                );\n+                // Check that this matches the underlying field.\n+                let inner = skip_newtypes(cx, layout);\n+                assert!(\n+                    matches!(inner.layout.abi(), Abi::Scalar(_)),\n+                    \"`Scalar` type {} is newtype around non-`Scalar` type {}\",\n+                    layout.ty,\n+                    inner.ty\n+                );\n+                match inner.layout.fields() {\n+                    FieldsShape::Primitive => {\n+                        // Fine.\n                     }\n-                }\n-                Abi::ScalarPair(scalar1, scalar2) => {\n-                    // Sanity-check scalar pairs. These are a bit more flexible and support\n-                    // padding, but we can at least ensure both fields actually fit into the layout\n-                    // and the alignment requirement has not been weakened.\n-                    let size1 = scalar1.size(cx);\n-                    let align1 = scalar1.align(cx).abi;\n-                    let size2 = scalar2.size(cx);\n-                    let align2 = scalar2.align(cx).abi;\n-                    assert!(\n-                        layout.layout.align().abi >= cmp::max(align1, align2),\n-                        \"alignment mismatch between ABI and layout in {layout:#?}\",\n-                    );\n-                    let field2_offset = size1.align_to(align2);\n-                    assert!(\n-                        layout.layout.size() >= field2_offset + size2,\n-                        \"size mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                    // Check that the underlying pair of fields matches.\n-                    let inner = skip_newtypes(cx, layout);\n-                    assert!(\n-                        matches!(inner.layout.abi(), Abi::ScalarPair(..)),\n-                        \"`ScalarPair` type {} is newtype around non-`ScalarPair` type {}\",\n-                        layout.ty,\n-                        inner.ty\n-                    );\n-                    if matches!(inner.layout.variants(), Variants::Multiple { .. }) {\n-                        // FIXME: ScalarPair for enums is enormously complicated and it is very hard\n-                        // to check anything about them.\n+                    FieldsShape::Union(..) => {\n+                        // FIXME: I guess we could also check something here? Like, look at all fields?\n                         return;\n                     }\n-                    match inner.layout.fields() {\n-                        FieldsShape::Arbitrary { .. } => {\n-                            // Checked below.\n-                        }\n-                        FieldsShape::Union(..) => {\n-                            // FIXME: I guess we could also check something here? Like, look at all fields?\n-                            return;\n-                        }\n-                        _ => {\n-                            panic!(\"`ScalarPair` layout with unexpected field shape in {inner:#?}\");\n-                        }\n+                    FieldsShape::Arbitrary { .. } => {\n+                        // Should be an enum, the only field is the discriminant.\n+                        assert!(\n+                            inner.ty.is_enum(),\n+                            \"`Scalar` layout for non-primitive non-enum type {}\",\n+                            inner.ty\n+                        );\n+                        assert_eq!(\n+                            inner.layout.fields().count(),\n+                            1,\n+                            \"`Scalar` layout for multiple-field type in {inner:#?}\",\n+                        );\n+                        let offset = inner.layout.fields().offset(0);\n+                        let field = inner.field(cx, 0);\n+                        // The field should be at the right offset, and match the `scalar` layout.\n+                        assert_eq!(\n+                            offset,\n+                            Size::ZERO,\n+                            \"`Scalar` field at non-0 offset in {inner:#?}\",\n+                        );\n+                        assert_eq!(field.size, size, \"`Scalar` field with bad size in {inner:#?}\",);\n+                        assert_eq!(\n+                            field.align.abi, align,\n+                            \"`Scalar` field with bad align in {inner:#?}\",\n+                        );\n+                        assert!(\n+                            matches!(field.abi, Abi::Scalar(_)),\n+                            \"`Scalar` field with bad ABI in {inner:#?}\",\n+                        );\n+                    }\n+                    _ => {\n+                        panic!(\"`Scalar` layout for non-primitive non-enum type {}\", inner.ty);\n                     }\n-                    let mut fields = non_zst_fields(cx, &inner);\n-                    let (offset1, field1) = fields.next().unwrap_or_else(|| {\n-                        panic!(\"`ScalarPair` layout for type with not even one non-ZST field: {inner:#?}\")\n-                    });\n-                    let (offset2, field2) = fields.next().unwrap_or_else(|| {\n-                        panic!(\"`ScalarPair` layout for type with less than two non-ZST fields: {inner:#?}\")\n-                    });\n-                    assert!(\n-                        fields.next().is_none(),\n-                        \"`ScalarPair` layout for type with at least three non-ZST fields: {inner:#?}\"\n-                    );\n-                    // The fields might be in opposite order.\n-                    let (offset1, field1, offset2, field2) = if offset1 <= offset2 {\n-                        (offset1, field1, offset2, field2)\n-                    } else {\n-                        (offset2, field2, offset1, field1)\n-                    };\n-                    // The fields should be at the right offset, and match the `scalar` layout.\n-                    assert_eq!(\n-                        offset1,\n-                        Size::ZERO,\n-                        \"`ScalarPair` first field at non-0 offset in {inner:#?}\",\n-                    );\n-                    assert_eq!(\n-                        field1.size, size1,\n-                        \"`ScalarPair` first field with bad size in {inner:#?}\",\n-                    );\n-                    assert_eq!(\n-                        field1.align.abi, align1,\n-                        \"`ScalarPair` first field with bad align in {inner:#?}\",\n-                    );\n-                    assert!(\n-                        matches!(field1.abi, Abi::Scalar(_)),\n-                        \"`ScalarPair` first field with bad ABI in {inner:#?}\",\n-                    );\n-                    assert_eq!(\n-                        offset2, field2_offset,\n-                        \"`ScalarPair` second field at bad offset in {inner:#?}\",\n-                    );\n-                    assert_eq!(\n-                        field2.size, size2,\n-                        \"`ScalarPair` second field with bad size in {inner:#?}\",\n-                    );\n-                    assert_eq!(\n-                        field2.align.abi, align2,\n-                        \"`ScalarPair` second field with bad align in {inner:#?}\",\n-                    );\n-                    assert!(\n-                        matches!(field2.abi, Abi::Scalar(_)),\n-                        \"`ScalarPair` second field with bad ABI in {inner:#?}\",\n-                    );\n                 }\n-                Abi::Vector { count, element } => {\n-                    // No padding in vectors. Alignment can be strengthened, though.\n-                    assert!(\n-                        layout.layout.align().abi >= element.align(cx).abi,\n-                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                    let size = element.size(cx) * count;\n-                    assert_eq!(\n-                        layout.layout.size(),\n-                        size.align_to(cx.data_layout().vector_align(size).abi),\n-                        \"size mismatch between ABI and layout in {layout:#?}\"\n-                    );\n+            }\n+            Abi::ScalarPair(scalar1, scalar2) => {\n+                // Sanity-check scalar pairs. Computing the expected size and alignment is a bit of work.\n+                let size1 = scalar1.size(cx);\n+                let align1 = scalar1.align(cx).abi;\n+                let size2 = scalar2.size(cx);\n+                let align2 = scalar2.align(cx).abi;\n+                let align = cmp::max(align1, align2);\n+                let field2_offset = size1.align_to(align2);\n+                let size = (field2_offset + size2).align_to(align);\n+                assert_eq!(\n+                    layout.layout.size(),\n+                    size,\n+                    \"size mismatch between ABI and layout in {layout:#?}\"\n+                );\n+                assert_eq!(\n+                    layout.layout.align().abi,\n+                    align,\n+                    \"alignment mismatch between ABI and layout in {layout:#?}\",\n+                );\n+                // Check that the underlying pair of fields matches.\n+                let inner = skip_newtypes(cx, layout);\n+                assert!(\n+                    matches!(inner.layout.abi(), Abi::ScalarPair(..)),\n+                    \"`ScalarPair` type {} is newtype around non-`ScalarPair` type {}\",\n+                    layout.ty,\n+                    inner.ty\n+                );\n+                if matches!(inner.layout.variants(), Variants::Multiple { .. }) {\n+                    // FIXME: ScalarPair for enums is enormously complicated and it is very hard\n+                    // to check anything about them.\n+                    return;\n+                }\n+                match inner.layout.fields() {\n+                    FieldsShape::Arbitrary { .. } => {\n+                        // Checked below.\n+                    }\n+                    FieldsShape::Union(..) => {\n+                        // FIXME: I guess we could also check something here? Like, look at all fields?\n+                        return;\n+                    }\n+                    _ => {\n+                        panic!(\"`ScalarPair` layout with unexpected field shape in {inner:#?}\");\n+                    }\n                 }\n-                Abi::Uninhabited | Abi::Aggregate { .. } => {} // Nothing to check.\n+                let mut fields = non_zst_fields(cx, &inner);\n+                let (offset1, field1) = fields.next().unwrap_or_else(|| {\n+                    panic!(\n+                        \"`ScalarPair` layout for type with not even one non-ZST field: {inner:#?}\"\n+                    )\n+                });\n+                let (offset2, field2) = fields.next().unwrap_or_else(|| {\n+                    panic!(\n+                        \"`ScalarPair` layout for type with less than two non-ZST fields: {inner:#?}\"\n+                    )\n+                });\n+                assert!(\n+                    fields.next().is_none(),\n+                    \"`ScalarPair` layout for type with at least three non-ZST fields: {inner:#?}\"\n+                );\n+                // The fields might be in opposite order.\n+                let (offset1, field1, offset2, field2) = if offset1 <= offset2 {\n+                    (offset1, field1, offset2, field2)\n+                } else {\n+                    (offset2, field2, offset1, field1)\n+                };\n+                // The fields should be at the right offset, and match the `scalar` layout.\n+                assert_eq!(\n+                    offset1,\n+                    Size::ZERO,\n+                    \"`ScalarPair` first field at non-0 offset in {inner:#?}\",\n+                );\n+                assert_eq!(\n+                    field1.size, size1,\n+                    \"`ScalarPair` first field with bad size in {inner:#?}\",\n+                );\n+                assert_eq!(\n+                    field1.align.abi, align1,\n+                    \"`ScalarPair` first field with bad align in {inner:#?}\",\n+                );\n+                assert!(\n+                    matches!(field1.abi, Abi::Scalar(_)),\n+                    \"`ScalarPair` first field with bad ABI in {inner:#?}\",\n+                );\n+                assert_eq!(\n+                    offset2, field2_offset,\n+                    \"`ScalarPair` second field at bad offset in {inner:#?}\",\n+                );\n+                assert_eq!(\n+                    field2.size, size2,\n+                    \"`ScalarPair` second field with bad size in {inner:#?}\",\n+                );\n+                assert_eq!(\n+                    field2.align.abi, align2,\n+                    \"`ScalarPair` second field with bad align in {inner:#?}\",\n+                );\n+                assert!(\n+                    matches!(field2.abi, Abi::Scalar(_)),\n+                    \"`ScalarPair` second field with bad ABI in {inner:#?}\",\n+                );\n             }\n+            Abi::Vector { count, element } => {\n+                // No padding in vectors, except possibly for trailing padding to make the size a multiple of align.\n+                let size = element.size(cx) * count;\n+                let align = cx.data_layout().vector_align(size).abi;\n+                let size = size.align_to(align); // needed e.g. for vectors of size 3\n+                assert!(align >= element.align(cx).abi); // just sanity-checking `vector_align`.\n+                assert_eq!(\n+                    layout.layout.size(),\n+                    size,\n+                    \"size mismatch between ABI and layout in {layout:#?}\"\n+                );\n+                assert_eq!(\n+                    layout.layout.align().abi,\n+                    align,\n+                    \"alignment mismatch between ABI and layout in {layout:#?}\"\n+                );\n+                // FIXME: Do some kind of check of the inner type, like for Scalar and ScalarPair.\n+            }\n+            Abi::Uninhabited | Abi::Aggregate { .. } => {} // Nothing to check.\n         }\n+    }\n \n-        check_layout_abi(cx, layout);\n+    check_layout_abi(cx, layout);\n \n-        if let Variants::Multiple { variants, .. } = &layout.variants {\n-            for variant in variants.iter() {\n-                // No nested \"multiple\".\n-                assert!(matches!(variant.variants, Variants::Single { .. }));\n-                // Variants should have the same or a smaller size as the full thing,\n-                // and same for alignment.\n-                if variant.size > layout.size {\n-                    bug!(\n-                        \"Type with size {} bytes has variant with size {} bytes: {layout:#?}\",\n-                        layout.size.bytes(),\n-                        variant.size.bytes(),\n-                    )\n-                }\n-                if variant.align.abi > layout.align.abi {\n-                    bug!(\n-                        \"Type with alignment {} bytes has variant with alignment {} bytes: {layout:#?}\",\n-                        layout.align.abi.bytes(),\n-                        variant.align.abi.bytes(),\n-                    )\n-                }\n-                // Skip empty variants.\n-                if variant.size == Size::ZERO\n-                    || variant.fields.count() == 0\n-                    || variant.abi.is_uninhabited()\n-                {\n-                    // These are never actually accessed anyway, so we can skip the coherence check\n-                    // for them. They also fail that check, since they have\n-                    // `Aggregate`/`Uninhbaited` ABI even when the main type is\n-                    // `Scalar`/`ScalarPair`. (Note that sometimes, variants with fields have size\n-                    // 0, and sometimes, variants without fields have non-0 size.)\n-                    continue;\n-                }\n-                // The top-level ABI and the ABI of the variants should be coherent.\n-                let scalar_coherent = |s1: Scalar, s2: Scalar| {\n-                    s1.size(cx) == s2.size(cx) && s1.align(cx) == s2.align(cx)\n-                };\n-                let abi_coherent = match (layout.abi, variant.abi) {\n-                    (Abi::Scalar(s1), Abi::Scalar(s2)) => scalar_coherent(s1, s2),\n-                    (Abi::ScalarPair(a1, b1), Abi::ScalarPair(a2, b2)) => {\n-                        scalar_coherent(a1, a2) && scalar_coherent(b1, b2)\n-                    }\n-                    (Abi::Uninhabited, _) => true,\n-                    (Abi::Aggregate { .. }, _) => true,\n-                    _ => false,\n-                };\n-                if !abi_coherent {\n-                    bug!(\n-                        \"Variant ABI is incompatible with top-level ABI:\\nvariant={:#?}\\nTop-level: {layout:#?}\",\n-                        variant\n-                    );\n+    if let Variants::Multiple { variants, .. } = &layout.variants {\n+        for variant in variants.iter() {\n+            // No nested \"multiple\".\n+            assert!(matches!(variant.variants, Variants::Single { .. }));\n+            // Variants should have the same or a smaller size as the full thing,\n+            // and same for alignment.\n+            if variant.size > layout.size {\n+                bug!(\n+                    \"Type with size {} bytes has variant with size {} bytes: {layout:#?}\",\n+                    layout.size.bytes(),\n+                    variant.size.bytes(),\n+                )\n+            }\n+            if variant.align.abi > layout.align.abi {\n+                bug!(\n+                    \"Type with alignment {} bytes has variant with alignment {} bytes: {layout:#?}\",\n+                    layout.align.abi.bytes(),\n+                    variant.align.abi.bytes(),\n+                )\n+            }\n+            // Skip empty variants.\n+            if variant.size == Size::ZERO\n+                || variant.fields.count() == 0\n+                || variant.abi.is_uninhabited()\n+            {\n+                // These are never actually accessed anyway, so we can skip the coherence check\n+                // for them. They also fail that check, since they have\n+                // `Aggregate`/`Uninhbaited` ABI even when the main type is\n+                // `Scalar`/`ScalarPair`. (Note that sometimes, variants with fields have size\n+                // 0, and sometimes, variants without fields have non-0 size.)\n+                continue;\n+            }\n+            // The top-level ABI and the ABI of the variants should be coherent.\n+            let scalar_coherent =\n+                |s1: Scalar, s2: Scalar| s1.size(cx) == s2.size(cx) && s1.align(cx) == s2.align(cx);\n+            let abi_coherent = match (layout.abi, variant.abi) {\n+                (Abi::Scalar(s1), Abi::Scalar(s2)) => scalar_coherent(s1, s2),\n+                (Abi::ScalarPair(a1, b1), Abi::ScalarPair(a2, b2)) => {\n+                    scalar_coherent(a1, a2) && scalar_coherent(b1, b2)\n                 }\n+                (Abi::Uninhabited, _) => true,\n+                (Abi::Aggregate { .. }, _) => true,\n+                _ => false,\n+            };\n+            if !abi_coherent {\n+                bug!(\n+                    \"Variant ABI is incompatible with top-level ABI:\\nvariant={:#?}\\nTop-level: {layout:#?}\",\n+                    variant\n+                );\n             }\n         }\n     }"}, {"sha": "1843a21205cfa65ef3de0f27c2b2391ac0b191b1", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -50,7 +50,7 @@ impl Cfg {\n     ) -> Result<Option<Cfg>, InvalidCfgError> {\n         match nested_cfg {\n             NestedMetaItem::MetaItem(ref cfg) => Cfg::parse_without(cfg, exclude),\n-            NestedMetaItem::Literal(ref lit) => {\n+            NestedMetaItem::Lit(ref lit) => {\n                 Err(InvalidCfgError { msg: \"unexpected literal\", span: lit.span })\n             }\n         }"}, {"sha": "42328222fd3820a0b8023c8bb11681d0fd93b16b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -893,7 +893,7 @@ fn clean_fn_decl_legacy_const_generics(func: &mut Function, attrs: &[ast::Attrib\n         .filter(|a| a.has_name(sym::rustc_legacy_const_generics))\n         .filter_map(|a| a.meta_item_list())\n     {\n-        for (pos, literal) in meta_item_list.iter().filter_map(|meta| meta.literal()).enumerate() {\n+        for (pos, literal) in meta_item_list.iter().filter_map(|meta| meta.lit()).enumerate() {\n             match literal.kind {\n                 ast::LitKind::Int(a, _) => {\n                     let gen = func.generics.params.remove(0);"}, {"sha": "ed4e9508f430999e603fb7417a1243d0fb88e6ce", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -1305,7 +1305,7 @@ impl Attributes {\n         for attr in self.other_attrs.lists(sym::doc).filter(|a| a.has_name(sym::alias)) {\n             if let Some(values) = attr.meta_item_list() {\n                 for l in values {\n-                    match l.literal().unwrap().kind {\n+                    match l.lit().unwrap().kind {\n                         ast::LitKind::Str(s, _) => {\n                             aliases.insert(s);\n                         }"}, {"sha": "7a9826a8dff9142a23652a162fa0bde8945b1df3", "filename": "src/test/ui/impl-trait/issues/issue-104815.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-104815.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-104815.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-104815.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -0,0 +1,66 @@\n+// check-pass\n+\n+struct It;\n+\n+struct Data {\n+    items: Vec<It>,\n+}\n+\n+impl Data {\n+    fn new() -> Self {\n+        Self {\n+            items: vec![It, It],\n+        }\n+    }\n+\n+    fn content(&self) -> impl Iterator<Item = &It> {\n+        self.items.iter()\n+    }\n+}\n+\n+struct Container<'a> {\n+    name: String,\n+    resolver: Box<dyn Resolver + 'a>,\n+}\n+\n+impl<'a> Container<'a> {\n+    fn new<R: Resolver + 'a>(name: &str, resolver: R) -> Self {\n+        Self {\n+            name: name.to_owned(),\n+            resolver: Box::new(resolver),\n+        }\n+    }\n+}\n+\n+trait Resolver {}\n+\n+impl<R: Resolver> Resolver for &R {}\n+\n+impl Resolver for It {}\n+\n+fn get<'a>(mut items: impl Iterator<Item = &'a It>) -> impl Resolver + 'a {\n+    items.next().unwrap()\n+}\n+\n+fn get2<'a, 'b: 'b>(mut items: impl Iterator<Item = &'a It>) -> impl Resolver + 'a {\n+    items.next().unwrap()\n+}\n+\n+fn main() {\n+    let data = Data::new();\n+    let resolver = get(data.content());\n+\n+    let _ = [\"a\", \"b\"]\n+        .iter()\n+        .map(|&n| Container::new(n, &resolver))\n+        .map(|c| c.name)\n+        .collect::<Vec<_>>();\n+\n+    let resolver = get2(data.content());\n+\n+    let _ = [\"a\", \"b\"]\n+        .iter()\n+        .map(|&n| Container::new(n, &resolver))\n+        .map(|c| c.name)\n+        .collect::<Vec<_>>();\n+}"}, {"sha": "e8290c0098afd80781bae68a67fa906dbaabc0d9", "filename": "src/test/ui/lang-items/missing-clone-for-suggestion.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftest%2Fui%2Flang-items%2Fmissing-clone-for-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftest%2Fui%2Flang-items%2Fmissing-clone-for-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Fmissing-clone-for-suggestion.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -0,0 +1,20 @@\n+// Avoid panicking if the Clone trait is not found while building error suggestions\n+// See #104870\n+\n+#![feature(no_core, lang_items)]\n+#![no_core]\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+fn g<T>(x: T) {}\n+\n+fn f(x: *mut u8) {\n+    g(x);\n+    g(x); //~ ERROR use of moved value: `x`\n+}\n+\n+fn main() {}"}, {"sha": "35783a1be78ade83d3cb65d2104cc5e032cf0861", "filename": "src/test/ui/lang-items/missing-clone-for-suggestion.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftest%2Fui%2Flang-items%2Fmissing-clone-for-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftest%2Fui%2Flang-items%2Fmissing-clone-for-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Fmissing-clone-for-suggestion.stderr?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -0,0 +1,21 @@\n+error[E0382]: use of moved value: `x`\n+  --> $DIR/missing-clone-for-suggestion.rs:17:7\n+   |\n+LL | fn f(x: *mut u8) {\n+   |      - move occurs because `x` has type `*mut u8`, which does not implement the `Copy` trait\n+LL |     g(x);\n+   |       - value moved here\n+LL |     g(x);\n+   |       ^ value used here after move\n+   |\n+note: consider changing this parameter type in function `g` to borrow instead if owning the value isn't necessary\n+  --> $DIR/missing-clone-for-suggestion.rs:13:12\n+   |\n+LL | fn g<T>(x: T) {}\n+   |    -       ^ this parameter takes ownership of the value\n+   |    |\n+   |    in this function\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "25566cd7f2aeb8440b4d521ea852230b1dfb1f98", "filename": "src/test/ui/suggestions/seggest_print_over_printf.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftest%2Fui%2Fsuggestions%2Fseggest_print_over_printf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftest%2Fui%2Fsuggestions%2Fseggest_print_over_printf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fseggest_print_over_printf.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -0,0 +1,9 @@\n+// Suggest to a user to use the print macros\n+// instead to use the printf.\n+\n+fn main() {\n+    let x = 4;\n+    printf(\"%d\", x);\n+    //~^ ERROR cannot find function `printf` in this scope\n+    //~| HELP you may have meant to use the `print` macro\n+}"}, {"sha": "7b1ce047a92747901cb76c0ca5b299e96f856934", "filename": "src/test/ui/suggestions/seggest_print_over_printf.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftest%2Fui%2Fsuggestions%2Fseggest_print_over_printf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftest%2Fui%2Fsuggestions%2Fseggest_print_over_printf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fseggest_print_over_printf.stderr?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -0,0 +1,14 @@\n+error[E0425]: cannot find function `printf` in this scope\n+  --> $DIR/seggest_print_over_printf.rs:6:5\n+   |\n+LL |     printf(\"%d\", x);\n+   |     ^^^^^^ not found in this scope\n+   |\n+help: you may have meant to use the `print` macro\n+   |\n+LL |     print!(\"%d\", x);\n+   |     ~~~~~~\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "018f10f258867872816e22b5f9604ee0cbc57a0f", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -6,7 +6,7 @@ use clippy_utils::msrvs;\n use clippy_utils::source::{first_line_of_span, is_present_in_source, snippet_opt, without_block_comments};\n use clippy_utils::{extract_msrv_attr, meets_msrv};\n use if_chain::if_chain;\n-use rustc_ast::{AttrKind, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n+use rustc_ast::{AttrKind, AttrStyle, Attribute, LitKind, MetaItemKind, MetaItemLit, NestedMetaItem};\n use rustc_errors::Applicability;\n use rustc_hir::{\n     Block, Expr, ExprKind, ImplItem, ImplItemKind, Item, ItemKind, StmtKind, TraitFn, TraitItem, TraitItemKind,\n@@ -576,7 +576,7 @@ fn check_attrs(cx: &LateContext<'_>, span: Span, name: Symbol, attrs: &[Attribut\n     }\n }\n \n-fn check_semver(cx: &LateContext<'_>, span: Span, lit: &Lit) {\n+fn check_semver(cx: &LateContext<'_>, span: Span, lit: &MetaItemLit) {\n     if let LitKind::Str(is, _) = lit.kind {\n         if Version::parse(is.as_str()).is_ok() {\n             return;"}, {"sha": "cfbeb347cabb6ddd1a85af6899475869f7c190c2", "filename": "src/tools/miri/src/concurrency/data_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -158,7 +158,7 @@ impl ThreadClockSet {\n \n /// Error returned by finding a data race\n /// should be elaborated upon.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct DataRace;\n \n /// Externally stored memory cell clocks"}, {"sha": "2ac703b957b86456b1784119dfae6d31324af1c4", "filename": "src/tools/rustfmt/src/attr.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -260,9 +260,7 @@ impl Rewrite for ast::NestedMetaItem {\n     fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         match self {\n             ast::NestedMetaItem::MetaItem(ref meta_item) => meta_item.rewrite(context, shape),\n-            ast::NestedMetaItem::Literal(ref l) => {\n-                rewrite_literal(context, l.token_lit, l.span, shape)\n-            }\n+            ast::NestedMetaItem::Lit(ref l) => rewrite_literal(context, l.token_lit, l.span, shape),\n         }\n     }\n }\n@@ -527,14 +525,19 @@ pub(crate) trait MetaVisitor<'ast> {\n \n     fn visit_meta_word(&mut self, _meta_item: &'ast ast::MetaItem) {}\n \n-    fn visit_meta_name_value(&mut self, _meta_item: &'ast ast::MetaItem, _lit: &'ast ast::Lit) {}\n+    fn visit_meta_name_value(\n+        &mut self,\n+        _meta_item: &'ast ast::MetaItem,\n+        _lit: &'ast ast::MetaItemLit,\n+    ) {\n+    }\n \n     fn visit_nested_meta_item(&mut self, nm: &'ast ast::NestedMetaItem) {\n         match nm {\n             ast::NestedMetaItem::MetaItem(ref meta_item) => self.visit_meta_item(meta_item),\n-            ast::NestedMetaItem::Literal(ref lit) => self.visit_literal(lit),\n+            ast::NestedMetaItem::Lit(ref lit) => self.visit_meta_item_lit(lit),\n         }\n     }\n \n-    fn visit_literal(&mut self, _lit: &'ast ast::Lit) {}\n+    fn visit_meta_item_lit(&mut self, _lit: &'ast ast::MetaItemLit) {}\n }"}, {"sha": "48431693332a619211a269c29da2669ed3d78ae3", "filename": "src/tools/rustfmt/src/modules/visitor.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules%2Fvisitor.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -84,23 +84,27 @@ impl PathVisitor {\n }\n \n impl<'ast> MetaVisitor<'ast> for PathVisitor {\n-    fn visit_meta_name_value(&mut self, meta_item: &'ast ast::MetaItem, lit: &'ast ast::Lit) {\n+    fn visit_meta_name_value(\n+        &mut self,\n+        meta_item: &'ast ast::MetaItem,\n+        lit: &'ast ast::MetaItemLit,\n+    ) {\n         if meta_item.has_name(Symbol::intern(\"path\")) && lit.kind.is_str() {\n-            self.paths.push(lit_to_str(lit));\n+            self.paths.push(meta_item_lit_to_str(lit));\n         }\n     }\n }\n \n #[cfg(not(windows))]\n-fn lit_to_str(lit: &ast::Lit) -> String {\n+fn meta_item_lit_to_str(lit: &ast::MetaItemLit) -> String {\n     match lit.kind {\n         ast::LitKind::Str(symbol, ..) => symbol.to_string(),\n         _ => unreachable!(),\n     }\n }\n \n #[cfg(windows)]\n-fn lit_to_str(lit: &ast::Lit) -> String {\n+fn meta_item_lit_to_str(lit: &ast::MetaItemLit) -> String {\n     match lit.kind {\n         ast::LitKind::Str(symbol, ..) => symbol.as_str().replace(\"/\", \"\\\\\"),\n         _ => unreachable!(),"}, {"sha": "af0b95430a1979c9098d3facf79987cf453121ad", "filename": "src/tools/rustfmt/src/overflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftools%2Frustfmt%2Fsrc%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftools%2Frustfmt%2Fsrc%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Foverflow.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -125,7 +125,7 @@ impl<'a> OverflowableItem<'a> {\n             OverflowableItem::MacroArg(MacroArg::Keyword(..)) => true,\n             OverflowableItem::MacroArg(MacroArg::Expr(expr)) => is_simple_expr(expr),\n             OverflowableItem::NestedMetaItem(nested_meta_item) => match nested_meta_item {\n-                ast::NestedMetaItem::Literal(..) => true,\n+                ast::NestedMetaItem::Lit(..) => true,\n                 ast::NestedMetaItem::MetaItem(ref meta_item) => {\n                     matches!(meta_item.kind, ast::MetaItemKind::Word)\n                 }\n@@ -169,7 +169,7 @@ impl<'a> OverflowableItem<'a> {\n             },\n             OverflowableItem::NestedMetaItem(nested_meta_item) if len == 1 => {\n                 match nested_meta_item {\n-                    ast::NestedMetaItem::Literal(..) => false,\n+                    ast::NestedMetaItem::Lit(..) => false,\n                     ast::NestedMetaItem::MetaItem(..) => true,\n                 }\n             }"}, {"sha": "3e884419f1a32c84406947b74ae678979577bfef", "filename": "src/tools/rustfmt/src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftools%2Frustfmt%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2585bcea0bc2a9c42a4be2c1eba5c61137f2b167/src%2Ftools%2Frustfmt%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Futils.rs?ref=2585bcea0bc2a9c42a4be2c1eba5c61137f2b167", "patch": "@@ -263,7 +263,7 @@ fn is_skip(meta_item: &MetaItem) -> bool {\n fn is_skip_nested(meta_item: &NestedMetaItem) -> bool {\n     match meta_item {\n         NestedMetaItem::MetaItem(ref mi) => is_skip(mi),\n-        NestedMetaItem::Literal(_) => false,\n+        NestedMetaItem::Lit(_) => false,\n     }\n }\n "}]}