{"sha": "251fdc877c0b2e3fdff61cbe083d1ba513f8e11b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1MWZkYzg3N2MwYjJlM2ZkZmY2MWNiZTA4M2QxYmE1MTNmOGUxMWI=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-11-02T09:00:34Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-11-03T13:20:37Z"}, "message": "Remove unnecessary features from strconv", "tree": {"sha": "5a21588fd2928d77faf44fb65a9e818d5609b923", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a21588fd2928d77faf44fb65a9e818d5609b923"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/251fdc877c0b2e3fdff61cbe083d1ba513f8e11b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/251fdc877c0b2e3fdff61cbe083d1ba513f8e11b", "html_url": "https://github.com/rust-lang/rust/commit/251fdc877c0b2e3fdff61cbe083d1ba513f8e11b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/251fdc877c0b2e3fdff61cbe083d1ba513f8e11b/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "138b76b83a067284f25e1f8971600aaf49206816", "url": "https://api.github.com/repos/rust-lang/rust/commits/138b76b83a067284f25e1f8971600aaf49206816", "html_url": "https://github.com/rust-lang/rust/commit/138b76b83a067284f25e1f8971600aaf49206816"}], "stats": {"total": 154, "additions": 33, "deletions": 121}, "files": [{"sha": "448cb2d01fe2c7efb1c72c3f2829b82f4ff85490", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/251fdc877c0b2e3fdff61cbe083d1ba513f8e11b/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251fdc877c0b2e3fdff61cbe083d1ba513f8e11b/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=251fdc877c0b2e3fdff61cbe083d1ba513f8e11b", "patch": "@@ -360,8 +360,7 @@ pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n /// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n #[inline]\n pub fn from_str_hex(num: &str) -> Option<f32> {\n-    strconv::from_str_common(num, 16u, true, true, true,\n-                             strconv::ExpBin, false)\n+    strconv::from_str_float(num, 16u, true, strconv::ExpBin)\n }\n \n impl FromStr for f32 {\n@@ -392,8 +391,7 @@ impl FromStr for f32 {\n     /// `Some(n)` where `n` is the floating-point number represented by `num`.\n     #[inline]\n     fn from_str(val: &str) -> Option<f32> {\n-        strconv::from_str_common(val, 10u, true, true, true,\n-                                 strconv::ExpDec, false)\n+        strconv::from_str_float(val, 10u, true, strconv::ExpDec)\n     }\n }\n \n@@ -417,8 +415,7 @@ impl num::FromStrRadix for f32 {\n     /// `Some(n)` where `n` is the floating-point number represented by `num`.\n     #[inline]\n     fn from_str_radix(val: &str, rdx: uint) -> Option<f32> {\n-        strconv::from_str_common(val, rdx, true, true, false,\n-                                 strconv::ExpNone, false)\n+        strconv::from_str_float(val, rdx, false, strconv::ExpNone)\n     }\n }\n "}, {"sha": "f49e14cb04bab3a6becc3863b782ed13115ad9f1", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/251fdc877c0b2e3fdff61cbe083d1ba513f8e11b/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251fdc877c0b2e3fdff61cbe083d1ba513f8e11b/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=251fdc877c0b2e3fdff61cbe083d1ba513f8e11b", "patch": "@@ -368,8 +368,7 @@ pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n /// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n #[inline]\n pub fn from_str_hex(num: &str) -> Option<f64> {\n-    strconv::from_str_common(num, 16u, true, true, true,\n-                             strconv::ExpBin, false)\n+    strconv::from_str_float(num, 16u, true, strconv::ExpBin)\n }\n \n impl FromStr for f64 {\n@@ -400,8 +399,7 @@ impl FromStr for f64 {\n     /// `Some(n)` where `n` is the floating-point number represented by `num`.\n     #[inline]\n     fn from_str(val: &str) -> Option<f64> {\n-        strconv::from_str_common(val, 10u, true, true, true,\n-                                 strconv::ExpDec, false)\n+        strconv::from_str_float(val, 10u, true, strconv::ExpDec)\n     }\n }\n \n@@ -425,8 +423,7 @@ impl num::FromStrRadix for f64 {\n     /// `Some(n)` where `n` is the floating-point number represented by `num`.\n     #[inline]\n     fn from_str_radix(val: &str, rdx: uint) -> Option<f64> {\n-        strconv::from_str_common(val, rdx, true, true, false,\n-                                 strconv::ExpNone, false)\n+        strconv::from_str_float(val, rdx, false, strconv::ExpNone)\n     }\n }\n "}, {"sha": "07468c3702632e0693eefb1daa7b986fb79b2f87", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 27, "deletions": 109, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/251fdc877c0b2e3fdff61cbe083d1ba513f8e11b/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251fdc877c0b2e3fdff61cbe083d1ba513f8e11b/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=251fdc877c0b2e3fdff61cbe083d1ba513f8e11b", "patch": "@@ -17,13 +17,11 @@ use char::Char;\n use clone::Clone;\n use from_str::from_str;\n use iter::Iterator;\n-use num::{NumCast, Zero, One, cast, Int, Bounded};\n-use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n use num;\n-use ops::{Add, Sub, Mul, Div, Rem, Neg};\n+use num::{Zero, One, cast, Int, Bounded};\n+use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n use option::{None, Option, Some};\n use slice::{ImmutableSlice, MutableSlice, CloneableVector};\n-use std::cmp::{PartialOrd, PartialEq};\n use str::{Str, StrSlice};\n use string::String;\n use vec::Vec;\n@@ -70,51 +68,6 @@ pub enum SignFormat {\n     SignAll,\n }\n \n-/// Encompasses functions used by the string converter.\n-pub trait NumStrConv {\n-    /// Returns the NaN value.\n-    fn nan()      -> Option<Self>;\n-\n-    /// Returns the infinite value.\n-    fn inf()      -> Option<Self>;\n-\n-    /// Returns the negative infinite value.\n-    fn neg_inf()  -> Option<Self>;\n-\n-    /// Returns -0.0.\n-    fn neg_zero() -> Option<Self>;\n-\n-    /// Rounds the number toward zero.\n-    fn round_to_zero(&self)   -> Self;\n-\n-    /// Returns the fractional part of the number.\n-    fn fractional_part(&self) -> Self;\n-}\n-\n-macro_rules! impl_NumStrConv_Floating (($t:ty) => (\n-    impl NumStrConv for $t {\n-        #[inline]\n-        fn nan()      -> Option<$t> { Some( 0.0 / 0.0) }\n-        #[inline]\n-        fn inf()      -> Option<$t> { Some( 1.0 / 0.0) }\n-        #[inline]\n-        fn neg_inf()  -> Option<$t> { Some(-1.0 / 0.0) }\n-        #[inline]\n-        fn neg_zero() -> Option<$t> { Some(-0.0      ) }\n-\n-        #[inline]\n-        fn round_to_zero(&self) -> $t { self.trunc() }\n-        #[inline]\n-        fn fractional_part(&self) -> $t { self.fract() }\n-    }\n-))\n-\n-// FIXME: #4955\n-// Replace by two generic impls for traits 'Integral' and 'Floating'\n-impl_NumStrConv_Floating!(f32)\n-impl_NumStrConv_Floating!(f64)\n-\n-\n // Special value strings as [u8] consts.\n static INF_BUF:     [u8, ..3] = [b'i', b'n', b'f'];\n static POS_INF_BUF: [u8, ..4] = [b'+', b'i', b'n', b'f'];\n@@ -234,8 +187,7 @@ fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8\n  * - Fails if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n  *   between digit and exponent sign `'p'`.\n  */\n-pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n-                                  Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n+pub fn float_to_str_bytes_common<T: Float>(\n         num: T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_upper: bool\n         ) -> (Vec<u8>, bool) {\n@@ -467,8 +419,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n  * `to_str_bytes_common()`, for details see there.\n  */\n #[inline]\n-pub fn float_to_str_common<T:NumCast+Zero+One+PartialEq+PartialOrd+NumStrConv+Float+\n-                             Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n+pub fn float_to_str_common<T: Float>(\n         num: T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_capital: bool\n         ) -> (String, bool) {\n@@ -484,15 +435,13 @@ static DIGIT_I_RADIX: uint = ('i' as uint) - ('a' as uint) + 11u;\n static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n \n /**\n- * Parses a byte slice as a number. This is meant to\n+ * Parses a string as a number. This is meant to\n  * be a common base implementation for all numeric string conversion\n  * functions like `from_str()` or `from_str_radix()`.\n  *\n  * # Arguments\n- * - `buf`        - The byte slice to parse.\n+ * - `src`        - The string to parse.\n  * - `radix`      - Which base to parse the number as. Accepts 2-36.\n- * - `negative`   - Whether to accept negative numbers.\n- * - `fractional` - Whether to accept numbers with fractional parts.\n  * - `special`    - Whether to accept special values like `inf`\n  *                  and `NaN`. Can conflict with `radix`, see Failure.\n  * - `exponent`   - Which exponent format to accept. Options are:\n@@ -504,7 +453,6 @@ static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n  *     - `ExpBin`:  Accepts numbers with a binary exponent like `42P-8` or\n  *                  `FFp128`. The exponent string itself is always base 10.\n  *                  Can conflict with `radix`, see Failure.\n- * - `empty_zero` - Whether to accept an empty `buf` as a 0 or not.\n  *\n  * # Return value\n  * Returns `Some(n)` if `buf` parses to a number n without overflowing, and\n@@ -520,11 +468,8 @@ static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n  * - Fails if `radix` > 18 and `special == true` due to conflict\n  *   between digit and lowest first character in `inf` and `NaN`, the `'i'`.\n  */\n-pub fn from_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+\n-                                    Mul<T,T>+Sub<T,T>+Neg<T>+Add<T,T>+\n-                                    NumStrConv+Clone>(\n-        buf: &[u8], radix: uint, negative: bool, fractional: bool,\n-        special: bool, exponent: ExponentFormat, empty_zero: bool,\n+pub fn from_str_float<T: Float>(\n+        src: &str, radix: uint, special: bool, exponent: ExponentFormat,\n         ) -> Option<T> {\n     match exponent {\n         ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n@@ -548,33 +493,25 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+\n     let _0: T = Zero::zero();\n     let _1: T = One::one();\n     let radix_gen: T = cast(radix as int).unwrap();\n+    let buf = src.as_bytes();\n \n     let len = buf.len();\n \n     if len == 0 {\n-        if empty_zero {\n-            return Some(_0);\n-        } else {\n-            return None;\n-        }\n+        return None;\n     }\n \n     if special {\n         if buf == INF_BUF || buf == POS_INF_BUF {\n-            return NumStrConv::inf();\n+            return Some(Float::infinity());\n         } else if buf == NEG_INF_BUF {\n-            if negative {\n-                return NumStrConv::neg_inf();\n-            } else {\n-                return None;\n-            }\n+            return Some(Float::neg_infinity());\n         } else if buf == NAN_BUF {\n-            return NumStrConv::nan();\n+            return Some(Float::nan());\n         }\n     }\n \n     let (start, accum_positive) = match buf[0] as char {\n-      '-' if !negative => return None,\n       '-' => (1u, false),\n       '+' => (1u, true),\n        _  => (0u, true)\n@@ -606,17 +543,17 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+\n                 // Detect overflow by comparing to last value, except\n                 // if we've not seen any non-zero digits.\n                 if last_accum != _0 {\n-                    if accum_positive && accum <= last_accum { return NumStrConv::inf(); }\n-                    if !accum_positive && accum >= last_accum { return NumStrConv::neg_inf(); }\n+                    if accum_positive && accum <= last_accum { return Some(Float::infinity()); }\n+                    if !accum_positive && accum >= last_accum { return Some(Float::neg_infinity()); }\n \n                     // Detect overflow by reversing the shift-and-add process\n                     if accum_positive &&\n                         (last_accum != ((accum - cast(digit as int).unwrap())/radix_gen.clone())) {\n-                        return NumStrConv::inf();\n+                        return Some(Float::infinity());\n                     }\n                     if !accum_positive &&\n                         (last_accum != ((accum + cast(digit as int).unwrap())/radix_gen.clone())) {\n-                        return NumStrConv::neg_inf();\n+                        return Some(Float::neg_infinity());\n                     }\n                 }\n                 last_accum = accum.clone();\n@@ -626,7 +563,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+\n                     exp_found = true;\n                     break;                       // start of exponent\n                 }\n-                '.' if fractional => {\n+                '.' => {\n                     i += 1u;                     // skip the '.'\n                     break;                       // start of fractional part\n                 }\n@@ -660,8 +597,8 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+\n                     }\n \n                     // Detect overflow by comparing to last value\n-                    if accum_positive && accum < last_accum { return NumStrConv::inf(); }\n-                    if !accum_positive && accum > last_accum { return NumStrConv::neg_inf(); }\n+                    if accum_positive && accum < last_accum { return Some(Float::infinity()); }\n+                    if !accum_positive && accum > last_accum { return Some(Float::neg_infinity()); }\n                     last_accum = accum.clone();\n                 }\n                 None => match c {\n@@ -680,11 +617,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+\n     // Special case: buf not empty, but does not contain any digit in front\n     // of the exponent sign -> number is empty string\n     if i == start {\n-        if empty_zero {\n-            return Some(_0);\n-        } else {\n-            return None;\n-        }\n+        return None;\n     }\n \n     let mut multiplier = _1.clone();\n@@ -717,20 +650,6 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+\n     Some(accum * multiplier)\n }\n \n-/**\n- * Parses a string as a number. This is a wrapper for\n- * `from_str_bytes_common()`, for details see there.\n- */\n-#[inline]\n-pub fn from_str_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+Mul<T,T>+\n-                              Sub<T,T>+Neg<T>+Add<T,T>+NumStrConv+Clone>(\n-        buf: &str, radix: uint, negative: bool, fractional: bool,\n-        special: bool, exponent: ExponentFormat, empty_zero: bool,\n-        ) -> Option<T> {\n-    from_str_bytes_common(buf.as_bytes(), radix, negative,\n-                          fractional, special, exponent, empty_zero)\n-}\n-\n pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n     fn cast<T: Int>(x: uint) -> T {\n         num::cast(x).unwrap()\n@@ -791,20 +710,19 @@ pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n mod test {\n     use super::*;\n     use option::*;\n+    use num::Float;\n \n     #[test]\n     fn from_str_issue7588() {\n         let u : Option<u8> = from_str_radix_int(\"1000\", 10);\n         assert_eq!(u, None);\n         let s : Option<i16> = from_str_radix_int(\"80000\", 10);\n         assert_eq!(s, None);\n-        let f : Option<f32> = from_str_common(\n-            \"10000000000000000000000000000000000000000\", 10, false, false, false,\n-            ExpNone, false);\n-        assert_eq!(f, NumStrConv::inf())\n-        let fe : Option<f32> = from_str_common(\"1e40\", 10, false, false, false,\n-                                            ExpDec, false);\n-        assert_eq!(fe, NumStrConv::inf())\n+        let f : Option<f32> = from_str_float(\n+            \"10000000000000000000000000000000000000000\", 10, false, ExpNone);\n+        assert_eq!(f, Some(Float::infinity()))\n+        let fe : Option<f32> = from_str_float(\"1e40\", 10, false, ExpDec);\n+        assert_eq!(fe, Some(Float::infinity()))\n     }\n }\n "}]}