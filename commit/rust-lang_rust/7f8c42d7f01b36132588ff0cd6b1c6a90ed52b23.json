{"sha": "7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmOGM0MmQ3ZjAxYjM2MTMyNTg4ZmYwY2Q2YjFjNmE5MGVkNTJiMjM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-19T19:58:47Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-26T13:38:26Z"}, "message": "refactor away `AnyRegions` and `AllRegions`\n\nIt's a bit cleaner to just have `AnyBound` and `AllBound`, after all.", "tree": {"sha": "3f97d0f195b095ca86eb54bc2c7738aad38a861f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f97d0f195b095ca86eb54bc2c7738aad38a861f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23", "html_url": "https://github.com/rust-lang/rust/commit/7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18b86e94065ff3e493406a7fb811115a85dc57ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/18b86e94065ff3e493406a7fb811115a85dc57ce", "html_url": "https://github.com/rust-lang/rust/commit/18b86e94065ff3e493406a7fb811115a85dc57ce"}], "stats": {"total": 130, "additions": 61, "deletions": 69}, "files": [{"sha": "a8fbfc3b64dfd1e1d63ec40bc02b415bc3bdf882", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23", "patch": "@@ -723,13 +723,11 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n                     && self.bound_is_met(b, var_values, generic_ty, min)\n             }\n \n-            VerifyBound::AnyRegion(rs) => rs.iter()\n-                .map(|&r| var_values.normalize(self.tcx(), r))\n-                .any(|r| self.region_rels.is_subregion_of(min, r)),\n-\n-            VerifyBound::AllRegions(rs) => rs.iter()\n-                .map(|&r| var_values.normalize(self.tcx(), r))\n-                .all(|r| self.region_rels.is_subregion_of(min, r)),\n+            VerifyBound::OutlivedBy(r) =>\n+                self.region_rels.is_subregion_of(\n+                    min,\n+                    var_values.normalize(self.tcx(), r),\n+                ),\n \n             VerifyBound::AnyBound(bs) => bs.iter()\n                 .any(|b| self.bound_is_met(b, var_values, generic_ty, min)),"}, {"sha": "79fc2df7db9d066bd9ce8c3a1f51fbbee205da70", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23", "patch": "@@ -63,13 +63,23 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n     fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound<'tcx> {\n         debug!(\"param_bound(param_ty={:?})\", param_ty);\n \n-        let mut param_bounds = self.declared_generic_bounds_from_env(GenericKind::Param(param_ty));\n+        // Start with anything like `T: 'a` we can scrape from the\n+        // environment\n+        let param_bounds =\n+            self.declared_generic_bounds_from_env(GenericKind::Param(param_ty))\n+            .into_iter();\n \n         // Add in the default bound of fn body that applies to all in\n         // scope type parameters:\n-        param_bounds.extend(self.implicit_region_bound);\n+        let param_bounds =\n+            param_bounds\n+            .chain(self.implicit_region_bound);\n \n-        VerifyBound::AnyRegion(param_bounds)\n+        VerifyBound::AnyBound(\n+            param_bounds\n+                .map(|r| VerifyBound::OutlivedBy(r))\n+                .collect()\n+        )\n     }\n \n     /// Given a projection like `T::Item`, searches the environment\n@@ -115,20 +125,23 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n         debug!(\"projection_bound(projection_ty={:?})\", projection_ty);\n \n         // Search the env for where clauses like `P: 'a`.\n-        let mut declared_bounds =\n-            self.declared_generic_bounds_from_env(GenericKind::Projection(projection_ty));\n+        let env_bounds =\n+            self.declared_generic_bounds_from_env(GenericKind::Projection(projection_ty))\n+            .into_iter();\n \n         // Extend with bounds that we can find from the trait.\n-        declared_bounds.extend(self.projection_declared_bounds_from_trait(projection_ty));\n-\n-        debug!(\"projection_bound: declared_bounds = {:?}\", declared_bounds);\n+        let trait_bounds =\n+            self.projection_declared_bounds_from_trait(projection_ty)\n+            .into_iter();\n \n         // see the extensive comment in projection_must_outlive\n         let ty = self.tcx\n             .mk_projection(projection_ty.item_def_id, projection_ty.substs);\n         let recursive_bound = self.recursive_type_bound(ty);\n \n-        VerifyBound::AnyRegion(declared_bounds).or(recursive_bound)\n+        VerifyBound::AnyBound(\n+            env_bounds.chain(trait_bounds).map(|r| VerifyBound::OutlivedBy(r)).collect()\n+        ).or(recursive_bound)\n     }\n \n     fn recursive_type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n@@ -138,7 +151,11 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n \n         let mut regions = ty.regions();\n         regions.retain(|r| !r.is_late_bound()); // ignore late-bound regions\n-        bounds.push(VerifyBound::AllRegions(regions));\n+        bounds.push(\n+            VerifyBound::AllBounds(\n+                regions.into_iter().map(|r| VerifyBound::OutlivedBy(r)).collect()\n+            )\n+        );\n \n         // remove bounds that must hold, since they are not interesting\n         bounds.retain(|b| !b.must_hold());"}, {"sha": "bc9027a08258c944d91223de0111f96238ae8a66", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23", "patch": "@@ -213,40 +213,36 @@ pub enum VerifyBound<'tcx> {\n     /// (after inference), and `'a: min`, then `G: min`.\n     IfEq(Ty<'tcx>, Box<VerifyBound<'tcx>>),\n \n-    /// Given a set of regions `R`, expands to the function:\n+    /// Given a region `R`, expands to the function:\n     ///\n     ///     fn(min) -> bool {\n-    ///       exists (r in R) { r: min }\n+    ///       R: min\n     ///     }\n     ///\n-    /// In other words, if some r in R outlives min, then G outlives\n-    /// min.  This is used when G is known to outlive all the regions\n-    /// in R.\n-    AnyRegion(Vec<Region<'tcx>>),\n-\n-    /// Given a set of regions `R`, expands to the function:\n-    ///\n-    ///     fn(min) -> bool {\n-    ///       forall (r in R) { r: min }\n-    ///     }\n-    ///\n-    /// In other words, if all r in R outlives min, then G outlives\n-    /// min. This is used when G is known to outlive some region in\n-    /// R, but we don't know which.\n-    AllRegions(Vec<Region<'tcx>>),\n+    /// This is used when we can establish that `G: R` -- therefore,\n+    /// if `R: min`, then by transitivity `G: min`.\n+    OutlivedBy(Region<'tcx>),\n \n     /// Given a set of bounds `B`, expands to the function:\n     ///\n     ///     fn(min) -> bool {\n     ///       exists (b in B) { b(min) }\n     ///     }\n+    ///\n+    /// In other words, if we meet some bound in `B`, that suffices.\n+    /// This is used when all the bounds in `B` are known to apply to\n+    /// G.\n     AnyBound(Vec<VerifyBound<'tcx>>),\n \n     /// Given a set of bounds `B`, expands to the function:\n     ///\n     ///     fn(min) -> bool {\n     ///       forall (b in B) { b(min) }\n     ///     }\n+    ///\n+    /// In other words, if we meet *all* bounds in `B`, that suffices.\n+    /// This is used when *some* bound in `B` is known to suffice, but\n+    /// we don't know which.\n     AllBounds(Vec<VerifyBound<'tcx>>),\n }\n \n@@ -954,8 +950,8 @@ impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n     pub fn must_hold(&self) -> bool {\n         match self {\n             VerifyBound::IfEq(..) => false,\n-            VerifyBound::AnyRegion(bs) => bs.contains(&&ty::ReStatic),\n-            VerifyBound::AllRegions(bs) => bs.is_empty(),\n+            VerifyBound::OutlivedBy(ty::ReStatic) => true,\n+            VerifyBound::OutlivedBy(_) => false,\n             VerifyBound::AnyBound(bs) => bs.iter().any(|b| b.must_hold()),\n             VerifyBound::AllBounds(bs) => bs.iter().all(|b| b.must_hold()),\n         }\n@@ -964,8 +960,8 @@ impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n     pub fn cannot_hold(&self) -> bool {\n         match self {\n             VerifyBound::IfEq(_, b) => b.cannot_hold(),\n-            VerifyBound::AnyRegion(bs) => bs.is_empty(),\n-            VerifyBound::AllRegions(bs) => bs.contains(&&ty::ReEmpty),\n+            VerifyBound::OutlivedBy(ty::ReEmpty) => true,\n+            VerifyBound::OutlivedBy(_) => false,\n             VerifyBound::AnyBound(bs) => bs.iter().all(|b| b.cannot_hold()),\n             VerifyBound::AllBounds(bs) => bs.iter().any(|b| b.cannot_hold()),\n         }"}, {"sha": "250db14bc95c619f03cc33d41bec77b07ce649a7", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 9, "deletions": 24, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23", "patch": "@@ -172,28 +172,19 @@ pub struct TypeTest<'tcx> {\n /// conveniently include disjuction (\"a or b must be true\").\n #[derive(Clone, Debug)]\n pub enum RegionTest {\n-    /// The subject region `'x` must by outlived by *some* region in\n-    /// the given set of regions.\n+    /// The subject region `'x` must by outlived by the given region.\n+    ///\n+    /// This test comes from e.g. a where clause like `T: 'a`, which\n+    /// implies that we know that `T: 'a`. Therefore, if we are trying\n+    /// to prove that `T: 'x`, we can do so by showing that `'a: 'x`.\n+    IsOutlivedBy(RegionVid),\n+\n+    /// Any of the given tests are true.\n     ///\n     /// This test comes from e.g. a where clause like `T: 'a + 'b`,\n     /// which implies that we know that `T: 'a` and that `T:\n     /// 'b`. Therefore, if we are trying to prove that `T: 'x`, we can\n     /// do so by showing that `'a: 'x` *or* `'b: 'x`.\n-    IsOutlivedByAnyRegionIn(Vec<RegionVid>),\n-\n-    /// The subject region `'x` must by outlived by *all* regions in\n-    /// the given set of regions.\n-    ///\n-    /// This test comes from e.g. a projection type like `T = <u32 as\n-    /// Trait<'a, 'b>>::Foo`, which must outlive `'a` or `'b`, and\n-    /// maybe both. Therefore we can prove that `T: 'x` if we know\n-    /// that `'a: 'x` *and* `'b: 'x`.\n-    IsOutlivedByAllRegionsIn(Vec<RegionVid>),\n-\n-    /// Any of the given tests are true.\n-    ///\n-    /// This arises from projections, for which there are multiple\n-    /// ways to prove an outlives relationship.\n     Any(Vec<RegionTest>),\n \n     /// All of the given tests are true.\n@@ -895,13 +886,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n \n         match test {\n-            RegionTest::IsOutlivedByAllRegionsIn(regions) => regions\n-                .iter()\n-                .all(|&r| self.eval_outlives(mir, r, lower_bound)),\n-\n-            RegionTest::IsOutlivedByAnyRegionIn(regions) => regions\n-                .iter()\n-                .any(|&r| self.eval_outlives(mir, r, lower_bound)),\n+            RegionTest::IsOutlivedBy(r) => self.eval_outlives(mir, *r, lower_bound),\n \n             RegionTest::Any(tests) => tests\n                 .iter()"}, {"sha": "f50516d014aa9916716aa918333dc8d35ca5e93e", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23", "patch": "@@ -158,15 +158,11 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n         match verify_bound {\n             VerifyBound::IfEq(..) => {\n                 // FIXME: always false right now\n-                RegionTest::IsOutlivedByAnyRegionIn(vec![])\n+                RegionTest::Any(vec![])\n             }\n \n-            VerifyBound::AnyRegion(regions) => RegionTest::IsOutlivedByAnyRegionIn(\n-                regions.iter().map(|r| self.to_region_vid(r)).collect(),\n-            ),\n-\n-            VerifyBound::AllRegions(regions) => RegionTest::IsOutlivedByAllRegionsIn(\n-                regions.iter().map(|r| self.to_region_vid(r)).collect(),\n+            VerifyBound::OutlivedBy(r) => RegionTest::IsOutlivedBy(\n+                self.to_region_vid(r)\n             ),\n \n             VerifyBound::AnyBound(bounds) => RegionTest::Any("}]}