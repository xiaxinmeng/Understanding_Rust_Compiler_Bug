{"sha": "35040275b3f39618c3cec4a9f702b6e057309604", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1MDQwMjc1YjNmMzk2MThjM2NlYzRhOWY3MDJiNmUwNTczMDk2MDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-12T18:53:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-12T18:53:18Z"}, "message": "auto merge of #8400 : blake2-ppc/rust/seq-ord, r=cmr\n\nUse Eq + Ord for lexicographical ordering of sequences.\r\n\r\nFor each of <, <=, >= or > as R, use::\r\n\r\n    [x, ..xs] R [y, ..ys]  =  if x != y { x R y } else { xs R ys }\r\n\r\nPrevious code using `a < b` and then `!(b < a)` for short-circuiting\r\nfails on cases such as  [1.0, 2.0] < [0.0/0.0, 3.0], where the first\r\nelement was effectively considered equal.\r\n\r\nContainers like &[T] did also implement only one comparison operator `<`,\r\nand derived the comparison results from this. This isn't correct either for\r\nOrd.\r\n\r\nImplement functions in `std::iterator::order::{lt,le,gt,ge,equal,cmp}` that all\r\niterable containers can use for lexical order.\r\n\r\nWe also visit tuple ordering, having the same problem and same solution\r\n(but differing implementation).", "tree": {"sha": "18153f0a059cbadb4672f6cff56227eccae18271", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18153f0a059cbadb4672f6cff56227eccae18271"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35040275b3f39618c3cec4a9f702b6e057309604", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35040275b3f39618c3cec4a9f702b6e057309604", "html_url": "https://github.com/rust-lang/rust/commit/35040275b3f39618c3cec4a9f702b6e057309604", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35040275b3f39618c3cec4a9f702b6e057309604/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59434a1b8c83b3c243556038578736ebde02a3e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/59434a1b8c83b3c243556038578736ebde02a3e8", "html_url": "https://github.com/rust-lang/rust/commit/59434a1b8c83b3c243556038578736ebde02a3e8"}, {"sha": "854e219d0aff3eff1f0b3762efc2d1a05ebb426b", "url": "https://api.github.com/repos/rust-lang/rust/commits/854e219d0aff3eff1f0b3762efc2d1a05ebb426b", "html_url": "https://github.com/rust-lang/rust/commit/854e219d0aff3eff1f0b3762efc2d1a05ebb426b"}], "stats": {"total": 381, "additions": 308, "deletions": 73}, "files": [{"sha": "788ed726d0fc0329187e434cac8ffe90189dce19", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 61, "deletions": 3, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/35040275b3f39618c3cec4a9f702b6e057309604/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35040275b3f39618c3cec4a9f702b6e057309604/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=35040275b3f39618c3cec4a9f702b6e057309604", "patch": "@@ -26,6 +26,7 @@ use std::cast;\n use std::ptr;\n use std::util;\n use std::iterator::{FromIterator, Extendable, Invert};\n+use std::iterator;\n \n use container::Deque;\n \n@@ -589,12 +590,27 @@ impl<A, T: Iterator<A>> Extendable<A, T> for DList<A> {\n impl<A: Eq> Eq for DList<A> {\n     fn eq(&self, other: &DList<A>) -> bool {\n         self.len() == other.len() &&\n-            self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n+            iterator::order::eq(self.iter(), other.iter())\n     }\n \n-    #[inline]\n     fn ne(&self, other: &DList<A>) -> bool {\n-        !self.eq(other)\n+        self.len() != other.len() &&\n+            iterator::order::ne(self.iter(), other.iter())\n+    }\n+}\n+\n+impl<A: Eq + Ord> Ord for DList<A> {\n+    fn lt(&self, other: &DList<A>) -> bool {\n+        iterator::order::lt(self.iter(), other.iter())\n+    }\n+    fn le(&self, other: &DList<A>) -> bool {\n+        iterator::order::le(self.iter(), other.iter())\n+    }\n+    fn gt(&self, other: &DList<A>) -> bool {\n+        iterator::order::gt(self.iter(), other.iter())\n+    }\n+    fn ge(&self, other: &DList<A>) -> bool {\n+        iterator::order::ge(self.iter(), other.iter())\n     }\n }\n \n@@ -964,6 +980,48 @@ mod tests {\n         assert_eq!(&n, &m);\n     }\n \n+    #[test]\n+    fn test_ord() {\n+        let n: DList<int> = list_from([]);\n+        let m = list_from([1,2,3]);\n+        assert!(n < m);\n+        assert!(m > n);\n+        assert!(n <= n);\n+        assert!(n >= n);\n+    }\n+\n+    #[test]\n+    fn test_ord_nan() {\n+        let nan = 0.0/0.0;\n+        let n = list_from([nan]);\n+        let m = list_from([nan]);\n+        assert!(!(n < m));\n+        assert!(!(n > m));\n+        assert!(!(n <= m));\n+        assert!(!(n >= m));\n+\n+        let n = list_from([nan]);\n+        let one = list_from([1.0]);\n+        assert!(!(n < one));\n+        assert!(!(n > one));\n+        assert!(!(n <= one));\n+        assert!(!(n >= one));\n+\n+        let u = list_from([1.0,2.0,nan]);\n+        let v = list_from([1.0,2.0,3.0]);\n+        assert!(!(u < v));\n+        assert!(!(u > v));\n+        assert!(!(u <= v));\n+        assert!(!(u >= v));\n+\n+        let s = list_from([1.0,2.0,4.0,2.0]);\n+        let t = list_from([1.0,2.0,3.0,2.0]);\n+        assert!(!(s < t));\n+        assert!(s > one);\n+        assert!(!(s <= one));\n+        assert!(s >= one);\n+    }\n+\n     #[test]\n     fn test_fuzz() {\n         do 25.times {"}, {"sha": "bd89c271a36b0a08d48ea12c4e6511c004e7ec6b", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/35040275b3f39618c3cec4a9f702b6e057309604/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35040275b3f39618c3cec4a9f702b6e057309604/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=35040275b3f39618c3cec4a9f702b6e057309604", "patch": "@@ -1568,6 +1568,163 @@ impl<A: Clone> RandomAccessIterator<A> for Repeat<A> {\n     fn idx(&self, _: uint) -> Option<A> { Some(self.element.clone()) }\n }\n \n+/// Functions for lexicographical ordering of sequences.\n+///\n+/// Lexicographical ordering through `<`, `<=`, `>=`, `>` requires\n+/// that the elements implement both `Eq` and `Ord`.\n+///\n+/// If two sequences are equal up until the point where one ends,\n+/// the shorter sequence compares less.\n+pub mod order {\n+    use cmp;\n+    use cmp::{TotalEq, TotalOrd, Ord, Eq};\n+    use option::{Some, None};\n+    use super::Iterator;\n+\n+    /// Compare `a` and `b` for equality using `TotalOrd`\n+    pub fn equals<A: TotalEq, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+        loop {\n+            match (a.next(), b.next()) {\n+                (None, None) => return true,\n+                (None, _) | (_, None) => return false,\n+                (Some(x), Some(y)) => if !x.equals(&y) { return false },\n+            }\n+        }\n+    }\n+\n+    /// Order `a` and `b` lexicographically using `TotalOrd`\n+    pub fn cmp<A: TotalOrd, T: Iterator<A>>(mut a: T, mut b: T) -> cmp::Ordering {\n+        loop {\n+            match (a.next(), b.next()) {\n+                (None, None) => return cmp::Equal,\n+                (None, _   ) => return cmp::Less,\n+                (_   , None) => return cmp::Greater,\n+                (Some(x), Some(y)) => match x.cmp(&y) {\n+                    cmp::Equal => (),\n+                    non_eq => return non_eq,\n+                },\n+            }\n+        }\n+    }\n+\n+    /// Compare `a` and `b` for equality (Using partial equality, `Eq`)\n+    pub fn eq<A: Eq, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+        loop {\n+            match (a.next(), b.next()) {\n+                (None, None) => return true,\n+                (None, _) | (_, None) => return false,\n+                (Some(x), Some(y)) => if !x.eq(&y) { return false },\n+            }\n+        }\n+    }\n+\n+    /// Compare `a` and `b` for nonequality (Using partial equality, `Eq`)\n+    pub fn ne<A: Eq, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+        loop {\n+            match (a.next(), b.next()) {\n+                (None, None) => return false,\n+                (None, _) | (_, None) => return true,\n+                (Some(x), Some(y)) => if x.ne(&y) { return true },\n+            }\n+        }\n+    }\n+\n+    /// Return `a` < `b` lexicographically (Using partial order, `Ord`)\n+    pub fn lt<A: Eq + Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+        loop {\n+            match (a.next(), b.next()) {\n+                (None, None) => return false,\n+                (None, _   ) => return true,\n+                (_   , None) => return false,\n+                (Some(x), Some(y)) => if x.ne(&y) { return x.lt(&y) },\n+            }\n+        }\n+    }\n+\n+    /// Return `a` <= `b` lexicographically (Using partial order, `Ord`)\n+    pub fn le<A: Eq + Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+        loop {\n+            match (a.next(), b.next()) {\n+                (None, None) => return true,\n+                (None, _   ) => return true,\n+                (_   , None) => return false,\n+                (Some(x), Some(y)) => if x.ne(&y) { return x.le(&y) },\n+            }\n+        }\n+    }\n+\n+    /// Return `a` > `b` lexicographically (Using partial order, `Ord`)\n+    pub fn gt<A: Eq + Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+        loop {\n+            match (a.next(), b.next()) {\n+                (None, None) => return false,\n+                (None, _   ) => return false,\n+                (_   , None) => return true,\n+                (Some(x), Some(y)) => if x.ne(&y) { return x.gt(&y) },\n+            }\n+        }\n+    }\n+\n+    /// Return `a` >= `b` lexicographically (Using partial order, `Ord`)\n+    pub fn ge<A: Eq + Ord, T: Iterator<A>>(mut a: T, mut b: T) -> bool {\n+        loop {\n+            match (a.next(), b.next()) {\n+                (None, None) => return true,\n+                (None, _   ) => return false,\n+                (_   , None) => return true,\n+                (Some(x), Some(y)) => if x.ne(&y) { return x.ge(&y) },\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_lt() {\n+        use vec::ImmutableVector;\n+\n+        let empty: [int, ..0] = [];\n+        let xs = [1,2,3];\n+        let ys = [1,2,0];\n+\n+        assert!(!lt(xs.iter(), ys.iter()));\n+        assert!(!le(xs.iter(), ys.iter()));\n+        assert!( gt(xs.iter(), ys.iter()));\n+        assert!( ge(xs.iter(), ys.iter()));\n+\n+        assert!( lt(ys.iter(), xs.iter()));\n+        assert!( le(ys.iter(), xs.iter()));\n+        assert!(!gt(ys.iter(), xs.iter()));\n+        assert!(!ge(ys.iter(), xs.iter()));\n+\n+        assert!( lt(empty.iter(), xs.iter()));\n+        assert!( le(empty.iter(), xs.iter()));\n+        assert!(!gt(empty.iter(), xs.iter()));\n+        assert!(!ge(empty.iter(), xs.iter()));\n+\n+        // Sequence with NaN\n+        let u = [1.0, 2.0];\n+        let v = [0.0/0.0, 3.0];\n+\n+        assert!(!lt(u.iter(), v.iter()));\n+        assert!(!le(u.iter(), v.iter()));\n+        assert!(!gt(u.iter(), v.iter()));\n+        assert!(!ge(u.iter(), v.iter()));\n+\n+        let a = [0.0/0.0];\n+        let b = [1.0];\n+        let c = [2.0];\n+\n+        assert!(lt(a.iter(), b.iter()) == (a[0] <  b[0]));\n+        assert!(le(a.iter(), b.iter()) == (a[0] <= b[0]));\n+        assert!(gt(a.iter(), b.iter()) == (a[0] >  b[0]));\n+        assert!(ge(a.iter(), b.iter()) == (a[0] >= b[0]));\n+\n+        assert!(lt(c.iter(), b.iter()) == (c[0] <  b[0]));\n+        assert!(le(c.iter(), b.iter()) == (c[0] <= b[0]));\n+        assert!(gt(c.iter(), b.iter()) == (c[0] >  b[0]));\n+        assert!(ge(c.iter(), b.iter()) == (c[0] >= b[0]));\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "04e839cf691dcefbd9c085f546d2559f68aa0ae3", "filename": "src/libstd/option.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/35040275b3f39618c3cec4a9f702b6e057309604/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35040275b3f39618c3cec4a9f702b6e057309604/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=35040275b3f39618c3cec4a9f702b6e057309604", "patch": "@@ -47,6 +47,7 @@ use ops::Add;\n use util;\n use num::Zero;\n use iterator::Iterator;\n+use iterator;\n use str::{StrSlice, OwnedStr};\n use to_str::ToStr;\n use clone::DeepClone;\n@@ -58,31 +59,21 @@ pub enum Option<T> {\n     Some(T),\n }\n \n-impl<T:Ord> Ord for Option<T> {\n+impl<T: Eq + Ord> Ord for Option<T> {\n     fn lt(&self, other: &Option<T>) -> bool {\n-        match (self, other) {\n-            (&None, &None) => false,\n-            (&None, &Some(_)) => true,\n-            (&Some(_), &None) => false,\n-            (&Some(ref a), &Some(ref b)) => *a < *b\n-        }\n+        iterator::order::lt(self.iter(), other.iter())\n     }\n \n     fn le(&self, other: &Option<T>) -> bool {\n-        match (self, other) {\n-            (&None, &None) => true,\n-            (&None, &Some(_)) => true,\n-            (&Some(_), &None) => false,\n-            (&Some(ref a), &Some(ref b)) => *a <= *b\n-        }\n+        iterator::order::le(self.iter(), other.iter())\n     }\n \n     fn ge(&self, other: &Option<T>) -> bool {\n-        !(self < other)\n+        iterator::order::ge(self.iter(), other.iter())\n     }\n \n     fn gt(&self, other: &Option<T>) -> bool {\n-        !(self <= other)\n+        iterator::order::gt(self.iter(), other.iter())\n     }\n }\n \n@@ -553,6 +544,18 @@ mod tests {\n         assert!(it.next().is_none());\n     }\n \n+    #[test]\n+    fn test_ord() {\n+        let small = Some(1.0);\n+        let big = Some(5.0);\n+        let nan = Some(0.0/0.0);\n+        assert!(!(nan < big));\n+        assert!(!(nan > big));\n+        assert!(small < big);\n+        assert!(None < big);\n+        assert!(big > None);\n+    }\n+\n     #[test]\n     fn test_mutate() {\n         let mut x = Some(3i);"}, {"sha": "deee49bc47235af321a648a502fc1b23035d8725", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35040275b3f39618c3cec4a9f702b6e057309604/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35040275b3f39618c3cec4a9f702b6e057309604/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=35040275b3f39618c3cec4a9f702b6e057309604", "patch": "@@ -70,6 +70,7 @@ pub use from_str::FromStr;\n pub use to_bytes::IterBytes;\n pub use to_str::{ToStr, ToStrConsume};\n pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};\n+pub use tuple::{CloneableTuple1, ImmutableTuple1};\n pub use tuple::{CloneableTuple2, CloneableTuple3, CloneableTuple4, CloneableTuple5};\n pub use tuple::{CloneableTuple6, CloneableTuple7, CloneableTuple8, CloneableTuple9};\n pub use tuple::{CloneableTuple10, CloneableTuple11, CloneableTuple12};"}, {"sha": "8a3c024ede50d253a323c9b02c9f0148503dc9d6", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 49, "deletions": 31, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/35040275b3f39618c3cec4a9f702b6e057309604/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35040275b3f39618c3cec4a9f702b6e057309604/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=35040275b3f39618c3cec4a9f702b6e057309604", "patch": "@@ -148,7 +148,7 @@ macro_rules! tuple_impls {\n                     $(fn $get_fn(&self) -> $T;)+\n                 }\n \n-                impl<$($T:Clone),+> $cloneable_trait<$($T),+> for ($($T),+) {\n+                impl<$($T:Clone),+> $cloneable_trait<$($T),+> for ($($T,)+) {\n                     $(\n                         #[inline]\n                         fn $get_fn(&self) -> $T {\n@@ -161,7 +161,7 @@ macro_rules! tuple_impls {\n                     $(fn $get_ref_fn<'a>(&'a self) -> &'a $T;)+\n                 }\n \n-                impl<$($T),+> $immutable_trait<$($T),+> for ($($T),+) {\n+                impl<$($T),+> $immutable_trait<$($T),+> for ($($T,)+) {\n                     $(\n                         #[inline]\n                         fn $get_ref_fn<'a>(&'a self) -> &'a $T {\n@@ -170,59 +170,65 @@ macro_rules! tuple_impls {\n                     )+\n                 }\n \n-                impl<$($T:Clone),+> Clone for ($($T),+) {\n-                    fn clone(&self) -> ($($T),+) {\n-                        ($(self.$get_ref_fn().clone()),+)\n+                impl<$($T:Clone),+> Clone for ($($T,)+) {\n+                    fn clone(&self) -> ($($T,)+) {\n+                        ($(self.$get_ref_fn().clone(),)+)\n                     }\n                 }\n \n                 #[cfg(not(test))]\n-                impl<$($T:Eq),+> Eq for ($($T),+) {\n+                impl<$($T:Eq),+> Eq for ($($T,)+) {\n                     #[inline]\n-                    fn eq(&self, other: &($($T),+)) -> bool {\n+                    fn eq(&self, other: &($($T,)+)) -> bool {\n                         $(*self.$get_ref_fn() == *other.$get_ref_fn())&&+\n                     }\n                     #[inline]\n-                    fn ne(&self, other: &($($T),+)) -> bool {\n-                        !(*self == *other)\n+                    fn ne(&self, other: &($($T,)+)) -> bool {\n+                        $(*self.$get_ref_fn() != *other.$get_ref_fn())||+\n                     }\n                 }\n \n                 #[cfg(not(test))]\n-                impl<$($T:TotalEq),+> TotalEq for ($($T),+) {\n+                impl<$($T:TotalEq),+> TotalEq for ($($T,)+) {\n                     #[inline]\n-                    fn equals(&self, other: &($($T),+)) -> bool {\n+                    fn equals(&self, other: &($($T,)+)) -> bool {\n                         $(self.$get_ref_fn().equals(other.$get_ref_fn()))&&+\n                     }\n                 }\n \n                 #[cfg(not(test))]\n-                impl<$($T:Ord),+> Ord for ($($T),+) {\n+                impl<$($T:Ord + Eq),+> Ord for ($($T,)+) {\n                     #[inline]\n-                    fn lt(&self, other: &($($T),+)) -> bool {\n-                        lexical_lt!($(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                    fn lt(&self, other: &($($T,)+)) -> bool {\n+                        lexical_ord!(lt, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n                     }\n                     #[inline]\n-                    fn le(&self, other: &($($T),+)) -> bool { !(*other).lt(&(*self)) }\n+                    fn le(&self, other: &($($T,)+)) -> bool {\n+                        lexical_ord!(le, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                    }\n                     #[inline]\n-                    fn ge(&self, other: &($($T),+)) -> bool { !(*self).lt(other) }\n+                    fn ge(&self, other: &($($T,)+)) -> bool {\n+                        lexical_ord!(ge, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                    }\n                     #[inline]\n-                    fn gt(&self, other: &($($T),+)) -> bool { (*other).lt(&(*self)) }\n+                    fn gt(&self, other: &($($T,)+)) -> bool {\n+                        lexical_ord!(gt, $(self.$get_ref_fn(), other.$get_ref_fn()),+)\n+                    }\n                 }\n \n                 #[cfg(not(test))]\n-                impl<$($T:TotalOrd),+> TotalOrd for ($($T),+) {\n+                impl<$($T:TotalOrd),+> TotalOrd for ($($T,)+) {\n                     #[inline]\n-                    fn cmp(&self, other: &($($T),+)) -> Ordering {\n+                    fn cmp(&self, other: &($($T,)+)) -> Ordering {\n                         lexical_cmp!($(self.$get_ref_fn(), other.$get_ref_fn()),+)\n                     }\n                 }\n \n                 #[cfg(not(test))]\n-                impl<$($T:Zero),+> Zero for ($($T),+) {\n+                impl<$($T:Zero),+> Zero for ($($T,)+) {\n                     #[inline]\n-                    fn zero() -> ($($T),+) {\n-                        ($(Zero::zero::<$T>()),+)\n+                    fn zero() -> ($($T,)+) {\n+                        ($(Zero::zero::<$T>(),)+)\n                     }\n                     #[inline]\n                     fn is_zero(&self) -> bool {\n@@ -234,17 +240,16 @@ macro_rules! tuple_impls {\n     }\n }\n \n-// Constructs an expression that performs a lexical less-than\n-// ordering.  The values are interleaved, so the macro invocation for\n-// `(a1, a2, a3) < (b1, b2, b3)` would be `lexical_lt!(a1, b1, a2, b2,\n+// Constructs an expression that performs a lexical ordering using method $rel.\n+// The values are interleaved, so the macro invocation for\n+// `(a1, a2, a3) < (b1, b2, b3)` would be `lexical_ord!(lt, a1, b1, a2, b2,\n // a3, b3)` (and similarly for `lexical_cmp`)\n-macro_rules! lexical_lt {\n-    ($a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n-        if *$a < *$b { true }\n-        else if !(*$b < *$a) { lexical_lt!($($rest_a, $rest_b),+) }\n-        else { false }\n+macro_rules! lexical_ord {\n+    ($rel: ident, $a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n+        if *$a != *$b { lexical_ord!($rel, $a, $b) }\n+        else { lexical_ord!($rel, $($rest_a, $rest_b),+) }\n     };\n-    ($a:expr, $b:expr) => { *$a < *$b };\n+    ($rel: ident, $a:expr, $b:expr) => { (*$a) . $rel ($b) };\n }\n \n macro_rules! lexical_cmp {\n@@ -259,6 +264,10 @@ macro_rules! lexical_cmp {\n \n \n tuple_impls! {\n+    (CloneableTuple1, ImmutableTuple1) {\n+        (n0, n0_ref) -> A { (ref a,) => a }\n+    }\n+\n     (CloneableTuple2, ImmutableTuple2) {\n         (n0, n0_ref) -> A { (ref a,_) => a }\n         (n1, n1_ref) -> B { (_,ref b) => b }\n@@ -432,6 +441,8 @@ mod tests {\n     fn test_tuple_cmp() {\n         let (small, big) = ((1u, 2u, 3u), (3u, 2u, 1u));\n \n+        let nan = 0.0/0.0;\n+\n         // Eq\n         assert_eq!(small, small);\n         assert_eq!(big, big);\n@@ -452,6 +463,13 @@ mod tests {\n         assert!(big >= small);\n         assert!(big >= big);\n \n+        assert!(!((1.0, 2.0) < (nan, 3.0)));\n+        assert!(!((1.0, 2.0) <= (nan, 3.0)));\n+        assert!(!((1.0, 2.0) > (nan, 3.0)));\n+        assert!(!((1.0, 2.0) >= (nan, 3.0)));\n+        assert!(((1.0, 2.0) < (2.0, nan)));\n+        assert!(!((2.0, 2.0) < (2.0, nan)));\n+\n         // TotalEq\n         assert!(small.equals(&small));\n         assert!(big.equals(&big));"}, {"sha": "2228922d9e4d951b9dcec6660649183eb711b3f8", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/35040275b3f39618c3cec4a9f702b6e057309604/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35040275b3f39618c3cec4a9f702b6e057309604/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=35040275b3f39618c3cec4a9f702b6e057309604", "patch": "@@ -564,17 +564,19 @@ pub mod traits {\n     use super::*;\n \n     use clone::Clone;\n-    use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Equal, Equiv};\n+    use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Equiv};\n+    use iterator::order;\n     use ops::Add;\n-    use option::{Some, None};\n \n     impl<'self,T:Eq> Eq for &'self [T] {\n         fn eq(&self, other: & &'self [T]) -> bool {\n             self.len() == other.len() &&\n-                self.iter().zip(other.iter()).all(|(s,o)| *s == *o)\n+                order::eq(self.iter(), other.iter())\n+        }\n+        fn ne(&self, other: & &'self [T]) -> bool {\n+            self.len() != other.len() ||\n+                order::ne(self.iter(), other.iter())\n         }\n-        #[inline]\n-        fn ne(&self, other: & &'self [T]) -> bool { !self.eq(other) }\n     }\n \n     impl<T:Eq> Eq for ~[T] {\n@@ -594,7 +596,7 @@ pub mod traits {\n     impl<'self,T:TotalEq> TotalEq for &'self [T] {\n         fn equals(&self, other: & &'self [T]) -> bool {\n             self.len() == other.len() &&\n-                self.iter().zip(other.iter()).all(|(s,o)| s.equals(o))\n+                order::equals(self.iter(), other.iter())\n         }\n     }\n \n@@ -625,13 +627,7 @@ pub mod traits {\n \n     impl<'self,T:TotalOrd> TotalOrd for &'self [T] {\n         fn cmp(&self, other: & &'self [T]) -> Ordering {\n-            for (s,o) in self.iter().zip(other.iter()) {\n-                match s.cmp(o) {\n-                    Equal => {},\n-                    non_eq => { return non_eq; }\n-                }\n-            }\n-            self.len().cmp(&other.len())\n+            order::cmp(self.iter(), other.iter())\n         }\n     }\n \n@@ -645,23 +641,25 @@ pub mod traits {\n         fn cmp(&self, other: &@[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n     }\n \n-    impl<'self,T:Ord> Ord for &'self [T] {\n+    impl<'self, T: Eq + Ord> Ord for &'self [T] {\n         fn lt(&self, other: & &'self [T]) -> bool {\n-            for (s,o) in self.iter().zip(other.iter()) {\n-                if *s < *o { return true; }\n-                if *s > *o { return false; }\n-            }\n-            self.len() < other.len()\n+            order::lt(self.iter(), other.iter())\n         }\n         #[inline]\n-        fn le(&self, other: & &'self [T]) -> bool { !(*other < *self) }\n+        fn le(&self, other: & &'self [T]) -> bool {\n+            order::le(self.iter(), other.iter())\n+        }\n         #[inline]\n-        fn ge(&self, other: & &'self [T]) -> bool { !(*self < *other) }\n+        fn ge(&self, other: & &'self [T]) -> bool {\n+            order::ge(self.iter(), other.iter())\n+        }\n         #[inline]\n-        fn gt(&self, other: & &'self [T]) -> bool { *other < *self }\n+        fn gt(&self, other: & &'self [T]) -> bool {\n+            order::gt(self.iter(), other.iter())\n+        }\n     }\n \n-    impl<T:Ord> Ord for ~[T] {\n+    impl<T: Eq + Ord> Ord for ~[T] {\n         #[inline]\n         fn lt(&self, other: &~[T]) -> bool { self.as_slice() < other.as_slice() }\n         #[inline]\n@@ -672,7 +670,7 @@ pub mod traits {\n         fn gt(&self, other: &~[T]) -> bool { self.as_slice() > other.as_slice() }\n     }\n \n-    impl<T:Ord> Ord for @[T] {\n+    impl<T: Eq + Ord> Ord for @[T] {\n         #[inline]\n         fn lt(&self, other: &@[T]) -> bool { self.as_slice() < other.as_slice() }\n         #[inline]"}]}