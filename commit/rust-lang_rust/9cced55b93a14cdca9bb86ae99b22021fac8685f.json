{"sha": "9cced55b93a14cdca9bb86ae99b22021fac8685f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljY2VkNTViOTNhMTRjZGNhOWJiODZhZTk5YjIyMDIxZmFjODY4NWY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-12-12T18:44:01Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-12-12T23:02:47Z"}, "message": "syntax: remove all remaining uses of #ast, and #ast / qquote itself.", "tree": {"sha": "0cfce9ba8403c8c29d7c7e1284fc01a99341c4d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cfce9ba8403c8c29d7c7e1284fc01a99341c4d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cced55b93a14cdca9bb86ae99b22021fac8685f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cced55b93a14cdca9bb86ae99b22021fac8685f", "html_url": "https://github.com/rust-lang/rust/commit/9cced55b93a14cdca9bb86ae99b22021fac8685f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cced55b93a14cdca9bb86ae99b22021fac8685f/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80d6bc899b2c44fc795e9a3db61083520bda8355", "url": "https://api.github.com/repos/rust-lang/rust/commits/80d6bc899b2c44fc795e9a3db61083520bda8355", "html_url": "https://github.com/rust-lang/rust/commit/80d6bc899b2c44fc795e9a3db61083520bda8355"}], "stats": {"total": 561, "additions": 95, "deletions": 466}, "files": [{"sha": "781ac7809e70cf5904fbe6e05e44fa7bee4d9d34", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=9cced55b93a14cdca9bb86ae99b22021fac8685f", "patch": "@@ -1033,6 +1033,8 @@ fn decode_item_ast(par_doc: ebml::Doc) -> @ast::item {\n trait fake_ext_ctxt {\n     fn cfg() -> ast::crate_cfg;\n     fn parse_sess() -> parse::parse_sess;\n+    fn call_site() -> span;\n+    fn ident_of(st: ~str) -> ast::ident;\n }\n \n #[cfg(test)]\n@@ -1042,6 +1044,16 @@ type fake_session = parse::parse_sess;\n impl fake_session: fake_ext_ctxt {\n     fn cfg() -> ast::crate_cfg { ~[] }\n     fn parse_sess() -> parse::parse_sess { self }\n+    fn call_site() -> span {\n+        codemap::span {\n+            lo: codemap::BytePos(0),\n+            hi: codemap::BytePos(0),\n+            expn_info: None\n+        }\n+    }\n+    fn ident_of(st: ~str) -> ast::ident {\n+        self.interner.intern(@st)\n+    }\n }\n \n #[cfg(test)]\n@@ -1050,7 +1062,8 @@ fn mk_ctxt() -> fake_ext_ctxt {\n }\n \n #[cfg(test)]\n-fn roundtrip(in_item: @ast::item) {\n+fn roundtrip(in_item: Option<@ast::item>) {\n+    let in_item = in_item.get();\n     let bytes = do io::with_bytes_writer |wr| {\n         let ebml_w = writer::Serializer(wr);\n         encode_item_ast(ebml_w, in_item);\n@@ -1074,45 +1087,45 @@ fn roundtrip(in_item: @ast::item) {\n #[test]\n fn test_basic() {\n     let ext_cx = mk_ctxt();\n-    roundtrip(#ast[item]{\n+    roundtrip(quote_item!(\n         fn foo() {}\n-    });\n+    ));\n }\n \n #[test]\n fn test_smalltalk() {\n     let ext_cx = mk_ctxt();\n-    roundtrip(#ast[item]{\n+    roundtrip(quote_item!(\n         fn foo() -> int { 3 + 4 } // first smalltalk program ever executed.\n-    });\n+    ));\n }\n \n #[test]\n fn test_more() {\n     let ext_cx = mk_ctxt();\n-    roundtrip(#ast[item]{\n+    roundtrip(quote_item!(\n         fn foo(x: uint, y: uint) -> uint {\n             let z = x + y;\n             return z;\n         }\n-    });\n+    ));\n }\n \n #[test]\n fn test_simplification() {\n     let ext_cx = mk_ctxt();\n-    let item_in = ast::ii_item(#ast[item] {\n+    let item_in = ast::ii_item(quote_item!(\n         fn new_int_alist<B: Copy>() -> alist<int, B> {\n             fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n             return {eq_fn: eq_int, mut data: ~[]};\n         }\n-    });\n+    ).get());\n     let item_out = simplify_ast(item_in);\n-    let item_exp = ast::ii_item(#ast[item] {\n+    let item_exp = ast::ii_item(quote_item!(\n         fn new_int_alist<B: Copy>() -> alist<int, B> {\n             return {eq_fn: eq_int, mut data: ~[]};\n         }\n-    });\n+    ).get());\n     match (item_out, item_exp) {\n       (ast::ii_item(item_out), ast::ii_item(item_exp)) => {\n         assert pprust::item_to_str(item_out, ext_cx.parse_sess().interner)"}, {"sha": "9830a5b1434fbf512e385926f6107eb67d5e364e", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=9cced55b93a14cdca9bb86ae99b22021fac8685f", "patch": "@@ -309,7 +309,7 @@ priv impl ext_ctxt {\n     fn lambda(blk: ast::blk) -> @ast::expr {\n         let ext_cx = self;\n         let blk_e = self.expr(blk.span, ast::expr_block(blk));\n-        #ast{ || $(blk_e) }\n+        quote_expr!( || $blk_e )\n     }\n \n     fn blk(span: span, stmts: ~[@ast::stmt]) -> ast::blk {"}, {"sha": "10e42a6facfa55c7f5b38cc137f4b12efea5926a", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=9cced55b93a14cdca9bb86ae99b22021fac8685f", "patch": "@@ -109,8 +109,6 @@ fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n     syntax_expanders.insert(~\"log_syntax\",\n                             builtin_normal_tt(\n                                 ext::log_syntax::expand_syntax_ext));\n-    syntax_expanders.insert(~\"ast\",\n-                            builtin(ext::qquote::expand_ast));\n     syntax_expanders.insert(~\"deriving_eq\",\n                             item_decorator(\n                                 ext::deriving::expand_deriving_eq));"}, {"sha": "489a1cb3c22056fa294e3909ea0b710fe32d7e5b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9cced55b93a14cdca9bb86ae99b22021fac8685f", "patch": "@@ -14,7 +14,6 @@ use ast::{crate, expr_, expr_mac, mac_invoc, mac_invoc_tt,\n           tt_delim, tt_tok, item_mac, stmt_, stmt_mac, stmt_expr, stmt_semi};\n use fold::*;\n use ext::base::*;\n-use ext::qquote::{qq_helper};\n use parse::{parser, parse_expr_from_source_str, new_parser_from_tts};\n \n \n@@ -169,7 +168,12 @@ fn expand_mod_items(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n               None | Some(normal(_)) | Some(macro_defining(_))\n               | Some(normal_tt(_)) | Some(item_tt(*)) => items,\n               Some(item_decorator(dec_fn)) => {\n-                dec_fn(cx, attr.span, attr.node.value, items)\n+                  cx.bt_push(ExpandedFrom({call_site: attr.span,\n+                                           callie: {name: copy mname,\n+                                                    span: None}}));\n+                  let r = dec_fn(cx, attr.span, attr.node.value, items);\n+                  cx.bt_pop();\n+                  r\n               }\n             }\n         }"}, {"sha": "e13dfe750b790484dcf5b38282b42e81ef3dd37a", "filename": "src/libsyntax/ext/qquote.rs", "status": "removed", "additions": 0, "deletions": 370, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/80d6bc899b2c44fc795e9a3db61083520bda8355/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80d6bc899b2c44fc795e9a3db61083520bda8355/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=80d6bc899b2c44fc795e9a3db61083520bda8355", "patch": "@@ -1,370 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use ast::{crate, expr_, mac_invoc,\n-                     mac_aq, mac_var};\n-use parse::parser;\n-use parse::parser::{Parser, parse_from_source_str};\n-use dvec::DVec;\n-use parse::token::ident_interner;\n-use codemap::{CharPos, BytePos};\n-\n-use fold::*;\n-use visit::*;\n-use ext::base::*;\n-use ext::build::*;\n-use print::*;\n-use io::*;\n-\n-use codemap::span;\n-\n-struct gather_item {\n-    lo: BytePos,\n-    hi: BytePos,\n-    e: @ast::expr,\n-    constr: ~str\n-}\n-\n-type aq_ctxt = @{lo: BytePos, gather: DVec<gather_item>};\n-enum fragment {\n-    from_expr(@ast::expr),\n-    from_ty(@ast::Ty)\n-}\n-\n-fn ids_ext(cx: ext_ctxt, strs: ~[~str]) -> ~[ast::ident] {\n-    strs.map(|str| cx.parse_sess().interner.intern(@*str))\n-}\n-fn id_ext(cx: ext_ctxt, str: ~str) -> ast::ident {\n-    cx.parse_sess().interner.intern(@str)\n-}\n-\n-\n-trait qq_helper {\n-    fn span() -> span;\n-    fn visit(aq_ctxt, vt<aq_ctxt>);\n-    fn extract_mac() -> Option<ast::mac_>;\n-    fn mk_parse_fn(ext_ctxt,span) -> @ast::expr;\n-    fn get_fold_fn() -> ~str;\n-}\n-\n-impl @ast::crate: qq_helper {\n-    fn span() -> span {self.span}\n-    fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_crate(*self, cx, v);}\n-    fn extract_mac() -> Option<ast::mac_> {fail}\n-    fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp,\n-                ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\", ~\"parse_crate\"]))\n-    }\n-    fn get_fold_fn() -> ~str {~\"fold_crate\"}\n-}\n-impl @ast::expr: qq_helper {\n-    fn span() -> span {self.span}\n-    fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_expr(self, cx, v);}\n-    fn extract_mac() -> Option<ast::mac_> {\n-        match (self.node) {\n-          ast::expr_mac({node: ref mac, _}) => Some((*mac)),\n-          _ => None\n-        }\n-    }\n-    fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp,\n-                ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\", ~\"parse_expr\"]))\n-    }\n-    fn get_fold_fn() -> ~str {~\"fold_expr\"}\n-}\n-impl @ast::Ty: qq_helper {\n-    fn span() -> span {self.span}\n-    fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_ty(self, cx, v);}\n-    fn extract_mac() -> Option<ast::mac_> {\n-        match (self.node) {\n-          ast::ty_mac({node: ref mac, _}) => Some((*mac)),\n-          _ => None\n-        }\n-    }\n-    fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp,\n-                ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\", ~\"parse_ty\"]))\n-    }\n-    fn get_fold_fn() -> ~str {~\"fold_ty\"}\n-}\n-impl @ast::item: qq_helper {\n-    fn span() -> span {self.span}\n-    fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_item(self, cx, v);}\n-    fn extract_mac() -> Option<ast::mac_> {fail}\n-    fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp,\n-                ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\", ~\"parse_item\"]))\n-    }\n-    fn get_fold_fn() -> ~str {~\"fold_item\"}\n-}\n-impl @ast::stmt: qq_helper {\n-    fn span() -> span {self.span}\n-    fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_stmt(self, cx, v);}\n-    fn extract_mac() -> Option<ast::mac_> {fail}\n-    fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp,\n-                ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\", ~\"parse_stmt\"]))\n-    }\n-    fn get_fold_fn() -> ~str {~\"fold_stmt\"}\n-}\n-impl @ast::pat: qq_helper {\n-    fn span() -> span {self.span}\n-    fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_pat(self, cx, v);}\n-    fn extract_mac() -> Option<ast::mac_> {fail}\n-    fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\",\n-                                      ~\"parse_pat\"]))\n-    }\n-    fn get_fold_fn() -> ~str {~\"fold_pat\"}\n-}\n-\n-fn gather_anti_quotes<N: qq_helper>(lo: BytePos, node: N) -> aq_ctxt\n-{\n-    let v = @{visit_expr: |node, &&cx, v| visit_aq(node, ~\"from_expr\", cx, v),\n-              visit_ty: |node, &&cx, v| visit_aq(node, ~\"from_ty\", cx, v),\n-              .. *default_visitor()};\n-    let cx = @{lo:lo, gather: DVec()};\n-    node.visit(cx, mk_vt(v));\n-    // FIXME (#2250): Maybe this is an overkill (merge_sort), it might\n-    // be better to just keep the gather array in sorted order.\n-    do cx.gather.swap |v| {\n-        pure fn by_lo(a: &gather_item, b: &gather_item) -> bool {\n-            a.lo < b.lo\n-        }\n-        std::sort::merge_sort(v, by_lo)\n-    };\n-    return cx;\n-}\n-\n-fn visit_aq<T:qq_helper>(node: T, constr: ~str, &&cx: aq_ctxt, v: vt<aq_ctxt>)\n-{\n-    match (node.extract_mac()) {\n-      Some(mac_aq(sp, e)) => {\n-        cx.gather.push(gather_item {\n-            lo: sp.lo - cx.lo,\n-            hi: sp.hi - cx.lo,\n-            e: e,\n-            constr: constr});\n-      }\n-      _ => node.visit(cx, v)\n-    }\n-}\n-\n-fn is_space(c: char) -> bool {\n-    parse::lexer::is_whitespace(c)\n-}\n-\n-fn expand_ast(ecx: ext_ctxt, _sp: span,\n-              arg: ast::mac_arg, body: ast::mac_body)\n-    -> @ast::expr\n-{\n-    let mut what = ~\"expr\";\n-    do arg.iter |arg| {\n-        let args: ~[@ast::expr] =\n-            match arg.node {\n-              ast::expr_vec(elts, _) => elts,\n-              _ => {\n-                ecx.span_fatal\n-                    (_sp, ~\"#ast requires arguments of the form `~[...]`.\")\n-              }\n-            };\n-        if vec::len::<@ast::expr>(args) != 1u {\n-            ecx.span_fatal(_sp, ~\"#ast requires exactly one arg\");\n-        }\n-        match (args[0].node) {\n-          ast::expr_path(@{idents: id, _}) if vec::len(id) == 1u\n-            => what = *ecx.parse_sess().interner.get(id[0]),\n-          _ => ecx.span_fatal(args[0].span, ~\"expected an identifier\")\n-        }\n-    }\n-    let body = get_mac_body(ecx,_sp,body);\n-\n-    return match what {\n-      ~\"crate\" => finish(ecx, body, parse_crate),\n-      ~\"expr\" => finish(ecx, body, parse_expr),\n-      ~\"ty\" => finish(ecx, body, parse_ty),\n-      ~\"item\" => finish(ecx, body, parse_item),\n-      ~\"stmt\" => finish(ecx, body, parse_stmt),\n-      ~\"pat\" => finish(ecx, body, parse_pat),\n-      _ => ecx.span_fatal(_sp, ~\"unsupported ast type\")\n-    };\n-}\n-\n-fn parse_crate(p: Parser) -> @ast::crate { p.parse_crate_mod(~[]) }\n-fn parse_ty(p: Parser) -> @ast::Ty { p.parse_ty(false) }\n-fn parse_stmt(p: Parser) -> @ast::stmt { p.parse_stmt(~[]) }\n-fn parse_expr(p: Parser) -> @ast::expr { p.parse_expr() }\n-fn parse_pat(p: Parser) -> @ast::pat { p.parse_pat(true) }\n-\n-fn parse_item(p: Parser) -> @ast::item {\n-    match p.parse_item(~[]) {\n-      Some(item) => item,\n-      None       => fail ~\"parse_item: parsing an item failed\"\n-    }\n-}\n-\n-fn finish<T: qq_helper>\n-    (ecx: ext_ctxt, body: ast::mac_body_, f: fn (p: Parser) -> T)\n-    -> @ast::expr\n-{\n-    let cm = ecx.codemap();\n-    let str = @cm.span_to_snippet(body.span);\n-    debug!(\"qquote--str==%?\", str);\n-    let fname = cm.mk_substr_filename(body.span);\n-    let node = parse_from_source_str\n-        (f, fname, codemap::FssInternal(body.span), str,\n-         ecx.cfg(), ecx.parse_sess());\n-    let loc = cm.lookup_char_pos(body.span.lo);\n-\n-    let sp = node.span();\n-    let qcx = gather_anti_quotes(sp.lo, node);\n-    let cx = qcx;\n-\n-    for uint::range(1u, cx.gather.len()) |i| {\n-        assert cx.gather[i-1u].lo < cx.gather[i].lo;\n-        // ^^ check that the vector is sorted\n-        assert cx.gather[i-1u].hi <= cx.gather[i].lo;\n-        // ^^ check that the spans are non-overlapping\n-    }\n-\n-    let mut str2 = ~\"\";\n-    enum state {active, skip(uint), blank};\n-    let mut state = active;\n-    let mut i = BytePos(0u);\n-    let mut j = 0u;\n-    let g_len = cx.gather.len();\n-    for str::chars_each(*str) |ch| {\n-        if (j < g_len && i == cx.gather[j].lo) {\n-            assert ch == '$';\n-            let repl = fmt!(\"$%u \", j);\n-            state = skip(str::char_len(repl));\n-            str2 += repl;\n-        }\n-        match copy state {\n-          active => str::push_char(&mut str2, ch),\n-          skip(1u) => state = blank,\n-          skip(sk) => state = skip (sk-1u),\n-          blank if is_space(ch) => str::push_char(&mut str2, ch),\n-          blank => str::push_char(&mut str2, ' ')\n-        }\n-        i += BytePos(1u);\n-        if (j < g_len && i == cx.gather[j].hi) {\n-            assert ch == ')';\n-            state = active;\n-            j += 1u;\n-        }\n-    }\n-\n-    let cx = ecx;\n-\n-    let cfg_call = || mk_call_(\n-        cx, sp, mk_access(cx, sp, ids_ext(cx, ~[~\"ext_cx\"]),\n-                          id_ext(cx, ~\"cfg\")), ~[]);\n-\n-    let parse_sess_call = || mk_call_(\n-        cx, sp, mk_access(cx, sp, ids_ext(cx, ~[~\"ext_cx\"]),\n-                          id_ext(cx, ~\"parse_sess\")), ~[]);\n-\n-    let pcall = mk_call(cx,sp,\n-                       ids_ext(cx, ~[~\"syntax\", ~\"parse\", ~\"parser\",\n-                        ~\"parse_from_source_str\"]),\n-                       ~[node.mk_parse_fn(cx,sp),\n-                        mk_uniq_str(cx,sp, fname),\n-                        mk_call(cx,sp,\n-                                ids_ext(cx, ~[~\"syntax\",~\"ext\",\n-                                 ~\"qquote\", ~\"mk_file_substr\"]),\n-                                ~[mk_uniq_str(cx,sp, loc.file.name),\n-                                 mk_uint(cx,sp, loc.line),\n-                                 mk_uint(cx,sp, loc.col.to_uint())]),\n-                        mk_unary(cx,sp, ast::box(ast::m_imm),\n-                                 mk_uniq_str(cx,sp, str2)),\n-                        cfg_call(),\n-                        parse_sess_call()]\n-                      );\n-    let mut rcall = pcall;\n-    if (g_len > 0u) {\n-        rcall = mk_call(cx,sp,\n-                        ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\",\n-                                      ~\"replace\"]),\n-                        ~[pcall,\n-                          mk_uniq_vec_e(cx,sp, qcx.gather.map_to_vec(|g| {\n-                             mk_call(cx,sp,\n-                                     ids_ext(cx, ~[~\"syntax\", ~\"ext\",\n-                                                   ~\"qquote\", g.constr]),\n-                                     ~[g.e])})),\n-                         mk_path(cx,sp,\n-                                 ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\",\n-                                               node.get_fold_fn()]))]);\n-    }\n-    return rcall;\n-}\n-\n-fn replace<T>(node: T, repls: ~[fragment], ff: fn (ast_fold, T) -> T)\n-    -> T\n-{\n-    let aft = default_ast_fold();\n-    let f_pre = @{fold_expr: |a,b,c|replace_expr(repls, a, b, c,\n-                                                  aft.fold_expr),\n-                  fold_ty: |a,b,c|replace_ty(repls, a, b, c,\n-                                              aft.fold_ty),\n-                  .. *aft};\n-    return ff(make_fold(f_pre), node);\n-}\n-fn fold_crate(f: ast_fold, &&n: @ast::crate) -> @ast::crate {\n-    @f.fold_crate(*n)\n-}\n-fn fold_expr(f: ast_fold, &&n: @ast::expr) -> @ast::expr {f.fold_expr(n)}\n-fn fold_ty(f: ast_fold, &&n: @ast::Ty) -> @ast::Ty {f.fold_ty(n)}\n-fn fold_item(f: ast_fold, &&n: @ast::item) -> @ast::item {\n-    f.fold_item(n).get() //HACK: we know we don't drop items\n-}\n-fn fold_stmt(f: ast_fold, &&n: @ast::stmt) -> @ast::stmt {f.fold_stmt(n)}\n-fn fold_pat(f: ast_fold, &&n: @ast::pat) -> @ast::pat {f.fold_pat(n)}\n-\n-fn replace_expr(repls: ~[fragment],\n-                e: ast::expr_, s: span, fld: ast_fold,\n-                orig: fn@(ast::expr_, span, ast_fold)->(ast::expr_, span))\n-    -> (ast::expr_, span)\n-{\n-    match e {\n-      ast::expr_mac({node: mac_var(i), _}) => match (repls[i]) {\n-        from_expr(r) => (r.node, r.span),\n-        _ => fail /* fixme error message */\n-      },\n-      _ => orig(e,s,fld)\n-    }\n-}\n-\n-fn replace_ty(repls: ~[fragment],\n-                e: ast::ty_, s: span, fld: ast_fold,\n-                orig: fn@(ast::ty_, span, ast_fold)->(ast::ty_, span))\n-    -> (ast::ty_, span)\n-{\n-    match e {\n-      ast::ty_mac({node: mac_var(i), _}) => match (repls[i]) {\n-        from_ty(r) => (r.node, r.span),\n-        _ => fail /* fixme error message */\n-      },\n-      _ => orig(e,s,fld)\n-    }\n-}\n-\n-fn mk_file_substr(fname: ~str, line: uint, col: uint) ->\n-    codemap::FileSubstr {\n-    codemap::FssExternal({filename: fname, line: line, col: CharPos(col)})\n-}\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "ead0de78f6e7faf1b73d8a14bdd6094521644bff", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9cced55b93a14cdca9bb86ae99b22021fac8685f", "patch": "@@ -81,13 +81,6 @@ use ast::{_mod, add, arg, arm, attribute,\n \n export Parser;\n \n-// FIXME (#3726): #ast expects to find this here but it's actually\n-// defined in `parse` Fixing this will be easier when we have export\n-// decls on individual items -- then parse can export this publicly, and\n-// everything else crate-visibly.\n-use parse::parse_from_source_str;\n-export parse_from_source_str;\n-\n export item_or_view_item, iovi_none, iovi_view_item, iovi_item;\n \n enum restriction {"}, {"sha": "c85b033be84e4b584835c8f477b1c7466f1976a0", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=9cced55b93a14cdca9bb86ae99b22021fac8685f", "patch": "@@ -75,9 +75,6 @@ mod ext {\n     #[legacy_exports]\n     #[path = \"ext/expand.rs\"]\n     mod expand;\n-    #[legacy_exports]\n-    #[path = \"ext/qquote.rs\"]\n-    mod qquote;\n \n     #[path = \"ext/quote.rs\"]\n     mod quote;"}, {"sha": "a343158337d09570d88958bdad27a607fb7f436b", "filename": "src/test/compile-fail/qquote-1.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs?ref=9cced55b93a14cdca9bb86ae99b22021fac8685f", "patch": "@@ -21,36 +21,44 @@ use syntax::codemap;\n use syntax::parse;\n use syntax::print::*;\n \n-fn new_parse_sess() -> parse::parse_sess {\n-  fail;\n-}\n \n trait fake_ext_ctxt {\n-    fn session() -> fake_session;\n+    fn cfg() -> ast::crate_cfg;\n+    fn parse_sess() -> parse::parse_sess;\n+    fn call_site() -> span;\n+    fn ident_of(st: ~str) -> ast::ident;\n }\n \n-type fake_options = {cfg: ast::crate_cfg};\n-\n-type fake_session = {opts: @fake_options,\n-                     parse_sess: parse::parse_sess};\n+type fake_session = parse::parse_sess;\n \n impl fake_session: fake_ext_ctxt {\n-    fn session() -> fake_session {self}\n+    fn cfg() -> ast::crate_cfg { ~[] }\n+    fn parse_sess() -> parse::parse_sess { self }\n+    fn call_site() -> span {\n+        codemap::span {\n+            lo: codemap::BytePos(0),\n+            hi: codemap::BytePos(0),\n+            expn_info: None\n+        }\n+    }\n+    fn ident_of(st: ~str) -> ast::ident {\n+        self.interner.intern(@st)\n+    }\n }\n \n fn mk_ctxt() -> fake_ext_ctxt {\n-    let opts : fake_options = {cfg: ~[]};\n-    {opts: @opts, parse_sess: new_parse_sess()} as fake_ext_ctxt\n+    parse::new_parse_sess(None) as fake_ext_ctxt\n }\n \n \n+\n fn main() {\n     let ext_cx = mk_ctxt();\n \n-    let abc = #ast{23};\n+    let abc = quote_expr!(23);\n     check_pp(abc,  pprust::print_expr, \"23\");\n \n-    let expr3 = #ast{2 - $(abcd) + 7}; //~ ERROR unresolved name: abcd\n+    let expr3 = quote_expr!(2 - $abcd + 7); //~ ERROR unresolved name: abcd\n     check_pp(expr3,  pprust::print_expr, \"2 - 23 + 7\");\n }\n "}, {"sha": "b7e33f99e3b487c06fee59dae97cb38af1e15445", "filename": "src/test/compile-fail/qquote-2.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs?ref=9cced55b93a14cdca9bb86ae99b22021fac8685f", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test Can't use syntax crate here\n \n extern mod std;\n-use syntax;\n+extern mod syntax;\n \n use std::io::*;\n \n@@ -20,33 +21,39 @@ use syntax::codemap;\n use syntax::parse::parser;\n use syntax::print::*;\n \n-fn new_parse_sess() -> parser::parse_sess {\n-  fail;\n-}\n-\n trait fake_ext_ctxt {\n-    fn session() -> fake_session;\n+    fn cfg() -> ast::crate_cfg;\n+    fn parse_sess() -> parse::parse_sess;\n+    fn call_site() -> span;\n+    fn ident_of(st: ~str) -> ast::ident;\n }\n \n-type fake_options = {cfg: ast::crate_cfg};\n-\n-type fake_session = {opts: @fake_options,\n-                     parse_sess: parser::parse_sess};\n+type fake_session = parse::parse_sess;\n \n impl fake_session: fake_ext_ctxt {\n-    fn session() -> fake_session {self}\n+    fn cfg() -> ast::crate_cfg { ~[] }\n+    fn parse_sess() -> parse::parse_sess { self }\n+    fn call_site() -> span {\n+        codemap::span {\n+            lo: codemap::BytePos(0),\n+            hi: codemap::BytePos(0),\n+            expn_info: None\n+        }\n+    }\n+    fn ident_of(st: ~str) -> ast::ident {\n+        self.interner.intern(@st)\n+    }\n }\n \n fn mk_ctxt() -> fake_ext_ctxt {\n-    let opts : fake_options = {cfg: ~[]};\n-    {opts: @opts, parse_sess: new_parse_sess()} as fake_ext_ctxt\n+    parse::new_parse_sess(None) as fake_ext_ctxt\n }\n \n \n fn main() {\n     let ext_cx = mk_ctxt();\n \n-    let stmt = #ast[stmt]{let x int = 20;}; //~ ERROR expected end-of-string\n+    let stmt = quote_stmt!(let x int = 20;); //~ ERROR expected end-of-string\n     check_pp(*stmt,  pprust::print_stmt, \"\");\n }\n "}, {"sha": "7d52f13b0750ad6000245f2644548ad2b7f382ad", "filename": "src/test/run-pass-fulldeps/issue-1926.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs?ref=9cced55b93a14cdca9bb86ae99b22021fac8685f", "patch": "@@ -55,8 +55,8 @@ fn mk_ctxt() -> fake_ext_ctxt {\n \n fn main() {\n     let ext_cx = mk_ctxt();\n-    let s = #ast[expr]{__s};\n-    let e = #ast[expr]{__e};\n-    let f = #ast[expr]{$(s).foo {|__e| $(e)}};\n+    let s = quote_expr!(__s);\n+    let e = quote_expr!(__e);\n+    let f = quote_expr!($s.foo {|__e| $e});\n     log(error, pprust::expr_to_str(f));\n }"}, {"sha": "3345dcaaad02a611d618b751b604e333495c802e", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 19, "deletions": 40, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cced55b93a14cdca9bb86ae99b22021fac8685f/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=9cced55b93a14cdca9bb86ae99b22021fac8685f", "patch": "@@ -20,79 +20,58 @@ use io::*;\n use syntax::diagnostic;\n use syntax::ast;\n use syntax::codemap;\n+use syntax::codemap::span;\n use syntax::parse;\n use syntax::print::*;\n \n+\n trait fake_ext_ctxt {\n     fn cfg() -> ast::crate_cfg;\n     fn parse_sess() -> parse::parse_sess;\n+    fn call_site() -> span;\n+    fn ident_of(st: ~str) -> ast::ident;\n }\n \n type fake_session = parse::parse_sess;\n \n impl fake_session: fake_ext_ctxt {\n     fn cfg() -> ast::crate_cfg { ~[] }\n     fn parse_sess() -> parse::parse_sess { self }\n+    fn call_site() -> span {\n+        codemap::span {\n+            lo: codemap::BytePos(0),\n+            hi: codemap::BytePos(0),\n+            expn_info: None\n+        }\n+    }\n+    fn ident_of(st: ~str) -> ast::ident {\n+        self.interner.intern(@copy st)\n+    }\n }\n \n fn mk_ctxt() -> fake_ext_ctxt {\n     parse::new_parse_sess(None) as fake_ext_ctxt\n }\n \n-\n fn main() {\n     let ext_cx = mk_ctxt();\n \n-    let abc = #ast{23};\n+    let abc = quote_expr!(23);\n     check_pp(ext_cx, abc,  pprust::print_expr, ~\"23\");\n \n-    let expr3 = #ast{2 - $(abc) + 7};\n-    check_pp(ext_cx, expr3,  pprust::print_expr, ~\"2 - 23 + 7\");\n-\n-    let expr4 = #ast{2 - $(#ast{3}) + 9};\n-    check_pp(ext_cx, expr4,  pprust::print_expr, ~\"2 - 3 + 9\");\n \n-    let ty = #ast[ty]{int};\n+    let ty = quote_ty!(int);\n     check_pp(ext_cx, ty, pprust::print_type, ~\"int\");\n \n-    let ty2 = #ast[ty]{option<$(ty)>};\n-    check_pp(ext_cx, ty2, pprust::print_type, ~\"option<int>\");\n-\n-    let item = #ast[item]{const x : int = 10;};\n+    let item = quote_item!(const x : int = 10;).get();\n     check_pp(ext_cx, item, pprust::print_item, ~\"const x: int = 10;\");\n \n-    let item2: @ast::item = #ast[item]{const x : int = $(abc);};\n-    check_pp(ext_cx, item2, pprust::print_item, ~\"const x: int = 23;\");\n-\n-    let stmt = #ast[stmt]{let x = 20;};\n+    let stmt = quote_stmt!(let x = 20;);\n     check_pp(ext_cx, *stmt, pprust::print_stmt, ~\"let x = 20;\");\n \n-    let stmt2 = #ast[stmt]{let x : $(ty) = $(abc);};\n-    check_pp(ext_cx, *stmt2, pprust::print_stmt, ~\"let x: int = 23;\");\n-\n-    let pat = #ast[pat]{some(_)};\n+    let pat = quote_pat!(some(_));\n     check_pp(ext_cx, pat, pprust::print_refutable_pat, ~\"some(_)\");\n \n-    // issue #1785\n-    let x = #ast{1};\n-    let test1 = #ast{1+$(x)};\n-    check_pp(ext_cx, test1, pprust::print_expr, ~\"1 + 1\");\n-\n-    let test2 = #ast{$(x)+1};\n-    check_pp(ext_cx, test2, pprust::print_expr, ~\"1 + 1\");\n-\n-    let y = #ast{2};\n-    let test3 = #ast{$(x) + $(y)};\n-    check_pp(ext_cx, test3, pprust::print_expr, ~\"1 + 2\");\n-\n-    let crate = #ast[crate] { fn a() { } };\n-    check_pp(ext_cx, crate, pprust::print_crate_, ~\"fn a() { }\\n\");\n-\n-    // issue #1926\n-    let s = #ast[expr]{__s};\n-    let e = #ast[expr]{__e};\n-    let call = #ast[expr]{$(s).foo(|__e| $(e) )};\n-    check_pp(ext_cx, call, pprust::print_expr, ~\"__s.foo(|__e| __e)\")\n }\n \n fn check_pp<T>(cx: fake_ext_ctxt,"}]}