{"sha": "c1a99fdd90df92d5cb9a1b5b5f6ee66aad627766", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxYTk5ZmRkOTBkZjkyZDVjYjlhMWI1YjVmNmVlNjZhYWQ2Mjc3NjY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-04T04:43:56Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-04T06:36:37Z"}, "message": "Fix dogfood failures by refactoring open_options", "tree": {"sha": "e81ce506e2a6c70e8e2c15e26b3ef2cd76192843", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e81ce506e2a6c70e8e2c15e26b3ef2cd76192843"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1a99fdd90df92d5cb9a1b5b5f6ee66aad627766", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1a99fdd90df92d5cb9a1b5b5f6ee66aad627766", "html_url": "https://github.com/rust-lang/rust/commit/c1a99fdd90df92d5cb9a1b5b5f6ee66aad627766", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1a99fdd90df92d5cb9a1b5b5f6ee66aad627766/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9342d01213ca1663d2cdf23289bae024823ae6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9342d01213ca1663d2cdf23289bae024823ae6a", "html_url": "https://github.com/rust-lang/rust/commit/c9342d01213ca1663d2cdf23289bae024823ae6a"}], "stats": {"total": 195, "additions": 74, "deletions": 121}, "files": [{"sha": "8227be92543b3f211aaeb3119a2fb1cb72f566fb", "filename": "src/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c1a99fdd90df92d5cb9a1b5b5f6ee66aad627766/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1a99fdd90df92d5cb9a1b5b5f6ee66aad627766/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c1a99fdd90df92d5cb9a1b5b5f6ee66aad627766", "patch": "@@ -1,6 +1,7 @@\n #![feature(plugin_registrar, box_syntax)]\n #![feature(rustc_private, collections)]\n #![feature(num_bits_bytes, iter_arith)]\n+#![feature(custom_attribute)]\n #![allow(unknown_lints)]\n \n // this only exists to allow the \"dogfood\" integration test to work\n@@ -77,6 +78,7 @@ mod reexport {\n }\n \n #[plugin_registrar]\n+#[rustfmt_skip]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box types::TypePass);\n     reg.register_late_lint_pass(box misc::TopLevelRefPass);\n@@ -130,8 +132,8 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box array_indexing::ArrayIndexing);\n     reg.register_late_lint_pass(box panic::PanicPass);\n \n-    reg.register_lint_group(\"clippy_pedantic\",\n-                            vec![\n+\n+    reg.register_lint_group(\"clippy_pedantic\", vec![\n         methods::OPTION_UNWRAP_USED,\n         methods::RESULT_UNWRAP_USED,\n         methods::WRONG_PUB_SELF_CONVENTION,\n@@ -150,8 +152,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         unicode::UNICODE_NOT_NFC,\n     ]);\n \n-    reg.register_lint_group(\"clippy\",\n-                            vec![\n+    reg.register_lint_group(\"clippy\", vec![\n         approx_const::APPROX_CONSTANT,\n         array_indexing::OUT_OF_BOUNDS_INDEXING,\n         attrs::INLINE_ALWAYS,"}, {"sha": "541ed2444f484110ff4b3954d0ff1c43be4cc892", "filename": "src/open_options.rs", "status": "modified", "additions": 69, "deletions": 117, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/c1a99fdd90df92d5cb9a1b5b5f6ee66aad627766/src%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1a99fdd90df92d5cb9a1b5b5f6ee66aad627766/src%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fopen_options.rs?ref=c1a99fdd90df92d5cb9a1b5b5f6ee66aad627766", "patch": "@@ -40,7 +40,7 @@ impl LateLintPass for NonSensicalOpenOptions {\n     }\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n enum Argument {\n     True,\n     False,\n@@ -104,130 +104,82 @@ fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOp\n     }\n }\n \n-fn check_for_duplicates(cx: &LateContext, options: &[(OpenOption, Argument)], span: Span) {\n+fn check_open_options(cx: &LateContext, options: &[(OpenOption, Argument)], span: Span) {\n+    let (mut create, mut append, mut truncate, mut read, mut write) = (false, false, false, false, false);\n+    let (mut create_arg, mut append_arg, mut truncate_arg, mut read_arg, mut write_arg) = (false,\n+                                                                                           false,\n+                                                                                           false,\n+                                                                                           false,\n+                                                                                           false);\n     // This code is almost duplicated (oh, the irony), but I haven't found a way to unify it.\n-    if options.iter()\n-              .filter(|o| {\n-                  if let (OpenOption::Create, _) = **o {\n-                      true\n-                  } else {\n-                      false\n-                  }\n-              })\n-              .count() > 1 {\n-        span_lint(cx,\n-                  NONSENSICAL_OPEN_OPTIONS,\n-                  span,\n-                  \"The method \\\"create\\\" is called more than once\");\n-    }\n-    if options.iter()\n-              .filter(|o| {\n-                  if let (OpenOption::Append, _) = **o {\n-                      true\n-                  } else {\n-                      false\n-                  }\n-              })\n-              .count() > 1 {\n-        span_lint(cx,\n-                  NONSENSICAL_OPEN_OPTIONS,\n-                  span,\n-                  \"The method \\\"append\\\" is called more than once\");\n-    }\n-    if options.iter()\n-              .filter(|o| {\n-                  if let (OpenOption::Truncate, _) = **o {\n-                      true\n-                  } else {\n-                      false\n-                  }\n-              })\n-              .count() > 1 {\n-        span_lint(cx,\n-                  NONSENSICAL_OPEN_OPTIONS,\n-                  span,\n-                  \"The method \\\"truncate\\\" is called more than once\");\n-    }\n-    if options.iter()\n-              .filter(|o| {\n-                  if let (OpenOption::Read, _) = **o {\n-                      true\n-                  } else {\n-                      false\n-                  }\n-              })\n-              .count() > 1 {\n-        span_lint(cx,\n-                  NONSENSICAL_OPEN_OPTIONS,\n-                  span,\n-                  \"The method \\\"read\\\" is called more than once\");\n-    }\n-    if options.iter()\n-              .filter(|o| {\n-                  if let (OpenOption::Write, _) = **o {\n-                      true\n-                  } else {\n-                      false\n-                  }\n-              })\n-              .count() > 1 {\n-        span_lint(cx,\n-                  NONSENSICAL_OPEN_OPTIONS,\n-                  span,\n-                  \"The method \\\"write\\\" is called more than once\");\n+\n+    for option in options {\n+        match *option {\n+            (OpenOption::Create, arg) => {\n+                if create {\n+                    span_lint(cx,\n+                              NONSENSICAL_OPEN_OPTIONS,\n+                              span,\n+                              \"The method \\\"create\\\" is called more than once\");\n+                } else {\n+                    create = true\n+                }\n+                create_arg = create_arg || (arg == Argument::True);;\n+            }\n+            (OpenOption::Append, arg) => {\n+                if append {\n+                    span_lint(cx,\n+                              NONSENSICAL_OPEN_OPTIONS,\n+                              span,\n+                              \"The method \\\"append\\\" is called more than once\");\n+                } else {\n+                    append = true\n+                }\n+                append_arg = append_arg || (arg == Argument::True);;\n+            }\n+            (OpenOption::Truncate, arg) => {\n+                if truncate {\n+                    span_lint(cx,\n+                              NONSENSICAL_OPEN_OPTIONS,\n+                              span,\n+                              \"The method \\\"truncate\\\" is called more than once\");\n+                } else {\n+                    truncate = true\n+                }\n+                truncate_arg = truncate_arg || (arg == Argument::True);\n+            }\n+            (OpenOption::Read, arg) => {\n+                if read {\n+                    span_lint(cx,\n+                              NONSENSICAL_OPEN_OPTIONS,\n+                              span,\n+                              \"The method \\\"read\\\" is called more than once\");\n+                } else {\n+                    read = true\n+                }\n+                read_arg = read_arg || (arg == Argument::True);;\n+            }\n+            (OpenOption::Write, arg) => {\n+                if write {\n+                    span_lint(cx,\n+                              NONSENSICAL_OPEN_OPTIONS,\n+                              span,\n+                              \"The method \\\"write\\\" is called more than once\");\n+                } else {\n+                    write = true\n+                }\n+                write_arg = write_arg || (arg == Argument::True);;\n+            }\n+        }\n     }\n-}\n \n-fn check_for_inconsistencies(cx: &LateContext, options: &[(OpenOption, Argument)], span: Span) {\n-    // Truncate + read makes no sense.\n-    if options.iter()\n-              .filter(|o| {\n-                  if let (OpenOption::Read, Argument::True) = **o {\n-                      true\n-                  } else {\n-                      false\n-                  }\n-              })\n-              .count() > 0 &&\n-       options.iter()\n-              .filter(|o| {\n-                  if let (OpenOption::Truncate, Argument::True) = **o {\n-                      true\n-                  } else {\n-                      false\n-                  }\n-              })\n-              .count() > 0 {\n+    if read && truncate && read_arg && truncate_arg {\n         span_lint(cx, NONSENSICAL_OPEN_OPTIONS, span, \"File opened with \\\"truncate\\\" and \\\"read\\\"\");\n     }\n-\n-    // Append + truncate makes no sense.\n-    if options.iter()\n-              .filter(|o| {\n-                  if let (OpenOption::Append, Argument::True) = **o {\n-                      true\n-                  } else {\n-                      false\n-                  }\n-              })\n-              .count() > 0 &&\n-       options.iter()\n-              .filter(|o| {\n-                  if let (OpenOption::Truncate, Argument::True) = **o {\n-                      true\n-                  } else {\n-                      false\n-                  }\n-              })\n-              .count() > 0 {\n+    if append && truncate && append_arg && truncate_arg {\n         span_lint(cx,\n                   NONSENSICAL_OPEN_OPTIONS,\n                   span,\n                   \"File opened with \\\"append\\\" and \\\"truncate\\\"\");\n     }\n }\n-\n-fn check_open_options(cx: &LateContext, options: &[(OpenOption, Argument)], span: Span) {\n-    check_for_duplicates(cx, options, span);\n-    check_for_inconsistencies(cx, options, span);\n-}"}]}