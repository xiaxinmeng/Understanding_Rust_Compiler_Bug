{"sha": "c0592faa67a1fe8fb7425f24899c5538dec23ee1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwNTkyZmFhNjdhMWZlOGZiNzQyNWYyNDg5OWM1NTM4ZGVjMjNlZTE=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2019-10-10T03:22:58Z"}, "committer": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2019-12-02T13:30:30Z"}, "message": "Move predecessor cache outside of Body, use wrapper types to manage Cache and Body (WIP, amend this commit)", "tree": {"sha": "a6f06c8b1249dfcb93d5ee87e3c7ca59208823f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6f06c8b1249dfcb93d5ee87e3c7ca59208823f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0592faa67a1fe8fb7425f24899c5538dec23ee1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0592faa67a1fe8fb7425f24899c5538dec23ee1", "html_url": "https://github.com/rust-lang/rust/commit/c0592faa67a1fe8fb7425f24899c5538dec23ee1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0592faa67a1fe8fb7425f24899c5538dec23ee1/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b335ce1a64048dbdf930deef9ca1851b7412e86", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b335ce1a64048dbdf930deef9ca1851b7412e86", "html_url": "https://github.com/rust-lang/rust/commit/9b335ce1a64048dbdf930deef9ca1851b7412e86"}], "stats": {"total": 461, "additions": 300, "deletions": 161}, "files": [{"sha": "4300a5acba4f81f87f11128d24fd0384a6429cd6", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 233, "deletions": 25, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/c0592faa67a1fe8fb7425f24899c5538dec23ee1/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0592faa67a1fe8fb7425f24899c5538dec23ee1/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=c0592faa67a1fe8fb7425f24899c5538dec23ee1", "patch": "@@ -1,47 +1,255 @@\n use rustc_index::vec::IndexVec;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n-use crate::ich::StableHashingContext;\n-use crate::mir::BasicBlock;\n+//use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+//use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n+//use crate::ich::StableHashingContext;\n+use crate::mir::{BasicBlock, BasicBlockData, Body, LocalDecls, Location, Successors};\n+use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n+use rustc_data_structures::graph::dominators::{dominators, Dominators};\n+use std::iter;\n+use std::ops::{Index, IndexMut};\n+use std::vec::IntoIter;\n \n #[derive(Clone, Debug)]\n-pub(in crate::mir) struct Cache {\n-    pub(in crate::mir) predecessors: Option<IndexVec<BasicBlock, Vec<BasicBlock>>>\n+pub struct Cache {\n+    predecessors: Option<IndexVec<BasicBlock, Vec<BasicBlock>>>,\n }\n \n \n-impl rustc_serialize::Encodable for Cache {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        Encodable::encode(&(), s)\n+//impl<'tcx, T> rustc_serialize::Encodable for Cache<'tcx, T> {\n+//    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+//        Encodable::encode(&(), s)\n+//    }\n+//}\n+//\n+//impl<'tcx, T> rustc_serialize::Decodable for Cache<'tcx, T> {\n+//    fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+//        Decodable::decode(d).map(|_v: ()| Self::new())\n+//    }\n+//}\n+//\n+//impl<'a, 'tcx, T> HashStable<StableHashingContext<'a>> for Cache<'tcx, T> {\n+//    fn hash_stable(&self, _: &mut StableHashingContext<'a>, _: &mut StableHasher) {\n+//        // Do nothing.\n+//    }\n+//}\n+\n+impl Cache {\n+    pub fn new() -> Self {\n+        Self {\n+            predecessors: None,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn invalidate_predecessors(&mut self) {\n+        // FIXME: consider being more fine-grained\n+        self.predecessors = None;\n+    }\n+\n+    #[inline]\n+    /// This will recompute the predecessors cache if it is not available\n+    pub fn predecessors(&mut self, body: &Body<'_>) -> &IndexVec<BasicBlock, Vec<BasicBlock>> {\n+        if self.predecessors.is_none() {\n+            let mut result = IndexVec::from_elem(vec![], body.basic_blocks());\n+            for (bb, data) in body.basic_blocks().iter_enumerated() {\n+                if let Some(ref term) = data.terminator {\n+                    for &tgt in term.successors() {\n+                        result[tgt].push(bb);\n+                    }\n+                }\n+            }\n+\n+            self.predecessors = Some(result)\n+        }\n+\n+        self.predecessors.as_ref().unwrap()\n+    }\n+\n+    #[inline]\n+    pub fn predecessors_for(&mut self, bb: BasicBlock, body: &Body<'_>) -> &[BasicBlock] {\n+        &self.predecessors(body)[bb]\n+    }\n+\n+    #[inline]\n+    pub fn predecessor_locations<'a>(&'a mut self, loc: Location, body: &'a Body<'a>) -> impl Iterator<Item = Location> + 'a {\n+        let if_zero_locations = if loc.statement_index == 0 {\n+            let predecessor_blocks = self.predecessors_for(loc.block, body);\n+            let num_predecessor_blocks = predecessor_blocks.len();\n+            Some(\n+                (0..num_predecessor_blocks)\n+                    .map(move |i| predecessor_blocks[i])\n+                    .map(move |bb| body.terminator_loc(bb)),\n+            )\n+        } else {\n+            None\n+        };\n+\n+        let if_not_zero_locations = if loc.statement_index == 0 {\n+            None\n+        } else {\n+            Some(Location { block: loc.block, statement_index: loc.statement_index - 1 })\n+        };\n+\n+        if_zero_locations.into_iter().flatten().chain(if_not_zero_locations)\n+    }\n+\n+    #[inline]\n+    pub fn basic_blocks_mut<'a, 'tcx>(&mut self, body: &'a mut Body<'tcx>) -> &'a mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        debug!(\"bbm: Clearing predecessors cache for body at: {:?}\", body.span.data());\n+        self.invalidate_predecessors();\n+        &mut body.basic_blocks\n+    }\n+\n+    #[inline]\n+    pub fn basic_blocks_and_local_decls_mut<'a, 'tcx>(\n+        &mut self,\n+        body: &'a mut Body<'tcx>\n+    ) -> (&'a mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &'a mut LocalDecls<'tcx>) {\n+        debug!(\"bbaldm: Clearing predecessors cache for body at: {:?}\", body.span.data());\n+        self.invalidate_predecessors();\n+        (&mut body.basic_blocks, &mut body.local_decls)\n+    }\n+}\n+\n+pub struct OwningCache<'tcx> {\n+    cache: Cache,\n+    body: Body<'tcx>,\n+}\n+\n+impl<'tcx> OwningCache<'tcx> {\n+    pub fn borrow(&mut self) -> BorrowedCache<'_, 'tcx> {\n+        BorrowedCache {\n+            cache: &mut self.cache,\n+            body: &self.body,\n+        }\n+    }\n+\n+    pub fn borrow_mut(&mut self) -> MutCache<'_, 'tcx> {\n+        MutCache {\n+            cache: &mut self.cache,\n+            body: &mut self.body,\n+        }\n+    }\n+}\n+\n+pub struct BorrowedCache<'a, 'tcx> {\n+    cache: &'a mut Cache,\n+    body: &'a Body<'tcx>\n+}\n+\n+impl<'a, 'tcx> BorrowedCache<'a, 'tcx> {\n+    #[inline]\n+    pub fn predecessors_for(&mut self, bb: BasicBlock) -> &[BasicBlock] {\n+        self.cache.predecessors_for(bb, self.body)\n+    }\n+\n+    #[inline]\n+    pub fn body(&self) -> &Body<'tcx> {\n+        self.body\n+    }\n+\n+    #[inline]\n+    pub fn basic_blocks(&self) -> &IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        &self.body.basic_blocks\n+    }\n+\n+    #[inline]\n+    pub fn dominators(&mut self) -> Dominators<BasicBlock> {\n+        dominators(self)\n     }\n }\n \n-impl rustc_serialize::Decodable for Cache {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n-        Decodable::decode(d).map(|_v: ()| Self::new())\n+impl<'a, 'tcx> Index<BasicBlock> for BorrowedCache<'a, 'tcx> {\n+    type Output = BasicBlockData<'tcx>;\n+\n+    #[inline]\n+    fn index(&self, index: BasicBlock) -> &BasicBlockData<'tcx> {\n+        &self.body[index]\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for Cache {\n-    fn hash_stable(&self, _: &mut StableHashingContext<'a>, _: &mut StableHasher) {\n-        // Do nothing.\n+impl<'a, 'tcx> graph::DirectedGraph for BorrowedCache<'a, 'tcx> {\n+    type Node = BasicBlock;\n+}\n+\n+impl<'a, 'graph, 'tcx> graph::GraphPredecessors<'graph> for BorrowedCache<'a, 'tcx> {\n+    type Item = BasicBlock;\n+    type Iter = IntoIter<BasicBlock>;\n+}\n+\n+impl<'a, 'tcx> graph::WithPredecessors for BorrowedCache<'a, 'tcx> {\n+    fn predecessors(\n+        &mut self,\n+        node: Self::Node,\n+    ) -> <Self as GraphPredecessors<'_>>::Iter {\n+        self.predecessors_for(node).to_vec().into_iter()\n     }\n }\n \n-impl Cache {\n-    pub fn new() -> Self {\n-        Cache {\n-            predecessors: None\n-        }\n+impl<'a, 'tcx> graph::WithNumNodes for BorrowedCache<'a, 'tcx> {\n+    fn num_nodes(&self) -> usize {\n+        self.body.num_nodes()\n     }\n+}\n \n+impl<'a, 'tcx> graph::WithStartNode for BorrowedCache<'a, 'tcx> {\n+    fn start_node(&self) -> Self::Node {\n+        self.body.start_node()\n+    }\n+}\n+\n+impl<'a, 'tcx> graph::WithSuccessors for BorrowedCache<'a, 'tcx> {\n+    fn successors(\n+        &self,\n+        node: Self::Node,\n+    ) -> <Self as GraphSuccessors<'_>>::Iter {\n+        self.body.successors(node)\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> graph::GraphSuccessors<'b> for BorrowedCache<'a, 'tcx> {\n+    type Item = BasicBlock;\n+    type Iter = iter::Cloned<Successors<'b>>;\n+}\n+\n+pub struct MutCache<'a, 'tcx> {\n+    cache: &'a mut Cache,\n+    body: &'a mut Body<'tcx>,\n+}\n+\n+impl<'a, 'tcx> MutCache<'a, 'tcx> {\n     #[inline]\n-    pub fn invalidate_predecessors(&mut self) {\n-        // FIXME: consider being more fine-grained\n-        self.predecessors = None;\n+    pub fn body(&mut self) -> &mut Body<'tcx> {\n+        self.body\n+    }\n+\n+    #[inline]\n+    pub fn basic_blocks(&self) -> &IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        &self.body.basic_blocks\n+    }\n+\n+    #[inline]\n+    pub fn basic_blocks_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+        self.cache.basic_blocks_mut(&mut self.body)\n     }\n }\n \n-CloneTypeFoldableAndLiftImpls! {\n-    Cache,\n+impl<'a, 'tcx> Index<BasicBlock> for MutCache<'a, 'tcx> {\n+    type Output = BasicBlockData<'tcx>;\n+\n+    #[inline]\n+    fn index(&self, index: BasicBlock) -> &BasicBlockData<'tcx> {\n+        &self.body[index]\n+    }\n }\n+\n+impl<'a, 'tcx> IndexMut<BasicBlock> for MutCache<'a, 'tcx> {\n+    fn index_mut(&mut self, index: BasicBlock) -> &mut Self::Output {\n+        self.cache.invalidate_predecessors();\n+        &mut self.body.basic_blocks[index]\n+    }\n+}\n+\n+//CloneTypeFoldableAndLiftImpls! {\n+//    Cache,\n+//}"}, {"sha": "fa435b9a51b8ab57092849882208334681c58150", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 116, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/c0592faa67a1fe8fb7425f24899c5538dec23ee1/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0592faa67a1fe8fb7425f24899c5538dec23ee1/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=c0592faa67a1fe8fb7425f24899c5538dec23ee1", "patch": "@@ -21,26 +21,25 @@ use crate::ty::{\n use polonius_engine::Atom;\n use rustc_index::bit_set::BitMatrix;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::graph::dominators::{dominators, Dominators};\n-use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n+use rustc_data_structures::graph::dominators::Dominators;\n+use rustc_data_structures::graph::{self, GraphSuccessors};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_data_structures::sync::Lrc;\n use rustc_macros::HashStable;\n use rustc_serialize::{Encodable, Decodable};\n use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n-use std::ops::{Index, IndexMut};\n+use std::ops::Index;\n use std::slice;\n-use std::vec::IntoIter;\n use std::{iter, mem, option, u32};\n use syntax::ast::Name;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n \n pub use crate::mir::interpret::AssertMessage;\n \n-mod cache;\n+pub mod cache;\n pub mod interpret;\n pub mod mono;\n pub mod tcx;\n@@ -153,9 +152,6 @@ pub struct Body<'tcx> {\n \n     /// A span representing this MIR, for error reporting.\n     pub span: Span,\n-\n-    /// A cache for various calculations.\n-    cache: cache::Cache,\n }\n \n impl<'tcx> Body<'tcx> {\n@@ -192,7 +188,6 @@ impl<'tcx> Body<'tcx> {\n             spread_arg: None,\n             var_debug_info,\n             span,\n-            cache: cache::Cache::new(),\n             control_flow_destroyed,\n         }\n     }\n@@ -202,88 +197,6 @@ impl<'tcx> Body<'tcx> {\n         &self.basic_blocks\n     }\n \n-    #[inline]\n-    pub fn basic_blocks_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n-        debug!(\"bbm: Clearing predecessors cache for body at: {:?}\", self.span.data());\n-        self.cache.invalidate_predecessors();\n-        &mut self.basic_blocks\n-    }\n-\n-    #[inline]\n-    pub fn basic_blocks_and_local_decls_mut(\n-        &mut self,\n-    ) -> (&mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &mut LocalDecls<'tcx>) {\n-        debug!(\"bbaldm: Clearing predecessors cache for body at: {:?}\", self.span.data());\n-        self.cache.invalidate_predecessors();\n-        (&mut self.basic_blocks, &mut self.local_decls)\n-    }\n-\n-    #[inline]\n-    pub fn unwrap_predecessors(&self) -> &IndexVec<BasicBlock, Vec<BasicBlock>> {\n-        assert!(\n-            self.cache.predecessors.is_some(),\n-            \"Expected cache.predecessors to be `Some(...)` for block at: {:?}\",\n-            self.span.data()\n-        );\n-        self.cache.predecessors.as_ref().unwrap()\n-    }\n-\n-    #[inline]\n-    pub fn ensure_predecessors(&mut self) {\n-        if self.cache.predecessors.is_none() {\n-            let mut result = IndexVec::from_elem(vec![], self.basic_blocks());\n-            for (bb, data) in self.basic_blocks().iter_enumerated() {\n-                if let Some(ref term) = data.terminator {\n-                    for &tgt in term.successors() {\n-                        result[tgt].push(bb);\n-                    }\n-                }\n-            }\n-\n-            self.cache.predecessors = Some(result)\n-        }\n-    }\n-\n-    #[inline]\n-    /// This will recompute the predecessors cache if it is not available\n-    pub fn predecessors(&mut self) -> &IndexVec<BasicBlock, Vec<BasicBlock>> {\n-        self.ensure_predecessors();\n-        self.cache.predecessors.as_ref().unwrap()\n-    }\n-\n-    #[inline]\n-    pub fn predecessors_for(&self, bb: BasicBlock) -> &[BasicBlock] {\n-        &self.unwrap_predecessors()[bb]\n-    }\n-\n-    #[inline]\n-    pub fn predecessor_locations(&self, loc: Location) -> impl Iterator<Item = Location> + '_ {\n-        let if_zero_locations = if loc.statement_index == 0 {\n-            let predecessor_blocks = self.predecessors_for(loc.block);\n-            let num_predecessor_blocks = predecessor_blocks.len();\n-            Some(\n-                (0..num_predecessor_blocks)\n-                    .map(move |i| predecessor_blocks[i])\n-                    .map(move |bb| self.terminator_loc(bb)),\n-            )\n-        } else {\n-            None\n-        };\n-\n-        let if_not_zero_locations = if loc.statement_index == 0 {\n-            None\n-        } else {\n-            Some(Location { block: loc.block, statement_index: loc.statement_index - 1 })\n-        };\n-\n-        if_zero_locations.into_iter().flatten().chain(if_not_zero_locations)\n-    }\n-\n-    #[inline]\n-    pub fn dominators(&self) -> Dominators<BasicBlock> {\n-        dominators(self)\n-    }\n-\n     /// Returns `true` if a cycle exists in the control-flow graph that is reachable from the\n     /// `START_BLOCK`.\n     pub fn is_cfg_cyclic(&self) -> bool {\n@@ -384,7 +297,7 @@ impl<'tcx> Body<'tcx> {\n     /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n     /// invalidating statement indices in `Location`s.\n     pub fn make_statement_nop(&mut self, location: Location) {\n-        let block = &mut self[location.block];\n+        let block = &mut self.basic_blocks[location.block];\n         debug_assert!(location.statement_index < block.statements.len());\n         block.statements[location.statement_index].make_nop()\n     }\n@@ -444,13 +357,6 @@ impl<'tcx> Index<BasicBlock> for Body<'tcx> {\n     }\n }\n \n-impl<'tcx> IndexMut<BasicBlock> for Body<'tcx> {\n-    #[inline]\n-    fn index_mut(&mut self, index: BasicBlock) -> &mut BasicBlockData<'tcx> {\n-        &mut self.basic_blocks_mut()[index]\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, HashStable, TypeFoldable)]\n pub enum ClearCrossCrate<T> {\n     Clear,\n@@ -2647,15 +2553,6 @@ impl<'tcx> graph::WithStartNode for Body<'tcx> {\n     }\n }\n \n-impl<'tcx> graph::WithPredecessors for Body<'tcx> {\n-    fn predecessors(\n-        &self,\n-        node: Self::Node,\n-    ) -> <Self as GraphPredecessors<'_>>::Iter {\n-        self.predecessors_for(node).to_vec().into_iter()\n-    }\n-}\n-\n impl<'tcx> graph::WithSuccessors for Body<'tcx> {\n     fn successors(\n         &self,\n@@ -2665,11 +2562,6 @@ impl<'tcx> graph::WithSuccessors for Body<'tcx> {\n     }\n }\n \n-impl<'a, 'b> graph::GraphPredecessors<'b> for Body<'a> {\n-    type Item = BasicBlock;\n-    type Iter = IntoIter<BasicBlock>;\n-}\n-\n impl<'a, 'b> graph::GraphSuccessors<'b> for Body<'a> {\n     type Item = BasicBlock;\n     type Iter = iter::Cloned<Successors<'b>>;\n@@ -2704,21 +2596,21 @@ impl Location {\n     }\n \n     /// Returns `true` if `other` is earlier in the control flow graph than `self`.\n-    pub fn is_predecessor_of<'tcx>(&self, other: Location, body: &Body<'tcx>) -> bool {\n+    pub fn is_predecessor_of<'tcx>(&self, other: Location, mut body_cache: cache::BorrowedCache<'_, 'tcx>) -> bool {\n         // If we are in the same block as the other location and are an earlier statement\n         // then we are a predecessor of `other`.\n         if self.block == other.block && self.statement_index < other.statement_index {\n             return true;\n         }\n \n         // If we're in another block, then we want to check that block is a predecessor of `other`.\n-        let mut queue: Vec<BasicBlock> = body.predecessors_for(other.block).to_vec();\n+        let mut queue: Vec<BasicBlock> = body_cache.predecessors_for(other.block).to_vec();\n         let mut visited = FxHashSet::default();\n \n         while let Some(block) = queue.pop() {\n             // If we haven't visited this block before, then make sure we visit it's predecessors.\n             if visited.insert(block) {\n-                queue.extend(body.predecessors_for(block).iter().cloned());\n+                queue.extend(body_cache.predecessors_for(block).iter().cloned());\n             } else {\n                 continue;\n             }"}, {"sha": "fbcfe10483958db4cc8815271aefd94db22a9450", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c0592faa67a1fe8fb7425f24899c5538dec23ee1/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0592faa67a1fe8fb7425f24899c5538dec23ee1/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=c0592faa67a1fe8fb7425f24899c5538dec23ee1", "patch": "@@ -1,6 +1,7 @@\n use crate::ty::subst::SubstsRef;\n use crate::ty::{CanonicalUserTypeAnnotation, Ty};\n use crate::mir::*;\n+use crate::mir::cache::*;\n use syntax_pos::Span;\n \n // # The MIR Visitor\n@@ -71,8 +72,8 @@ macro_rules! make_mir_visitor {\n             // Override these, and call `self.super_xxx` to revert back to the\n             // default behavior.\n \n-            fn visit_body(&mut self, body: & $($mutability)? Body<'tcx>) {\n-                self.super_body(body);\n+            fn visit_body(&mut self, body_cache: & $($mutability)? cache_type!('tcx $($mutability)?)) {\n+                self.super_body(body_cache);\n             }\n \n             fn visit_basic_block_data(&mut self,\n@@ -241,10 +242,11 @@ macro_rules! make_mir_visitor {\n             // not meant to be overridden.\n \n             fn super_body(&mut self,\n-                         body: & $($mutability)? Body<'tcx>) {\n-                if let Some(yield_ty) = &$($mutability)? body.yield_ty {\n+                         body_cache: & $($mutability)? cache_type!('tcx $($mutability)?)) {\n+                let span = body_cache.body().span;\n+                if let Some(yield_ty) = &$($mutability)? body_cache.body().yield_ty {\n                     self.visit_ty(yield_ty, TyContext::YieldTy(SourceInfo {\n-                        span: body.span,\n+                        span,\n                         scope: OUTERMOST_SOURCE_SCOPE,\n                     }));\n                 }\n@@ -253,13 +255,14 @@ macro_rules! make_mir_visitor {\n                 // than a for-loop, to avoid calling `body::Body::invalidate` for\n                 // each basic block.\n                 macro_rules! basic_blocks {\n-                    (mut) => (body.basic_blocks_mut().iter_enumerated_mut());\n-                    () => (body.basic_blocks().iter_enumerated());\n+                    (mut) => (body_cache.basic_blocks_mut().iter_enumerated_mut());\n+                    () => (body_cache.basic_blocks().iter_enumerated());\n                 };\n                 for (bb, data) in basic_blocks!($($mutability)?) {\n                     self.visit_basic_block_data(bb, data);\n                 }\n \n+                let body = body_cache.body();\n                 for scope in &$($mutability)? body.source_scopes {\n                     self.visit_source_scope_data(scope);\n                 }\n@@ -790,8 +793,8 @@ macro_rules! make_mir_visitor {\n \n             // Convenience methods\n \n-            fn visit_location(&mut self, body: & $($mutability)? Body<'tcx>, location: Location) {\n-                let basic_block = & $($mutability)? body[location.block];\n+            fn visit_location(&mut self, body_cache: & $($mutability)? cache_type!('tcx $($mutability)?), location: Location) {\n+                let basic_block = & $($mutability)? body_cache[location.block];\n                 if basic_block.statements.len() == location.statement_index {\n                     if let Some(ref $($mutability)? terminator) = basic_block.terminator {\n                         self.visit_terminator(terminator, location)\n@@ -806,6 +809,11 @@ macro_rules! make_mir_visitor {\n     }\n }\n \n+macro_rules! cache_type {\n+    ($tcx:lifetime mut) => {MutCache<'_, $tcx>};\n+    ($tcx:lifetime) => {BorrowedCache<'_, $tcx>};\n+}\n+\n macro_rules! visit_place_fns {\n     (mut) => (\n         fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;"}, {"sha": "5fb58eea3819d84ffaa720043e17d9125a5944ce", "filename": "src/librustc_data_structures/graph/dominators/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c0592faa67a1fe8fb7425f24899c5538dec23ee1/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0592faa67a1fe8fb7425f24899c5538dec23ee1/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs?ref=c0592faa67a1fe8fb7425f24899c5538dec23ee1", "patch": "@@ -7,32 +7,33 @@\n use rustc_index::vec::{Idx, IndexVec};\n use super::iterate::reverse_post_order;\n use super::ControlFlowGraph;\n+use std::borrow::BorrowMut;\n \n #[cfg(test)]\n mod tests;\n \n-pub fn dominators<G: ControlFlowGraph>(graph: &G) -> Dominators<G::Node> {\n+pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n     let start_node = graph.start_node();\n-    let rpo = reverse_post_order(graph, start_node);\n+    let rpo = reverse_post_order(&graph, start_node);\n     dominators_given_rpo(graph, &rpo)\n }\n \n-fn dominators_given_rpo<G: ControlFlowGraph>(\n-    graph: &G,\n+fn dominators_given_rpo<G: ControlFlowGraph + BorrowMut<G>>(\n+    mut graph: G,\n     rpo: &[G::Node],\n ) -> Dominators<G::Node> {\n-    let start_node = graph.start_node();\n+    let start_node = graph.borrow().start_node();\n     assert_eq!(rpo[0], start_node);\n \n     // compute the post order index (rank) for each node\n     let mut post_order_rank: IndexVec<G::Node, usize> =\n-        (0..graph.num_nodes()).map(|_| 0).collect();\n+        (0..graph.borrow().num_nodes()).map(|_| 0).collect();\n     for (index, node) in rpo.iter().rev().cloned().enumerate() {\n         post_order_rank[node] = index;\n     }\n \n     let mut immediate_dominators: IndexVec<G::Node, Option<G::Node>> =\n-        (0..graph.num_nodes()).map(|_| None).collect();\n+        (0..graph.borrow().num_nodes()).map(|_| None).collect();\n     immediate_dominators[start_node] = Some(start_node);\n \n     let mut changed = true;\n@@ -41,7 +42,7 @@ fn dominators_given_rpo<G: ControlFlowGraph>(\n \n         for &node in &rpo[1..] {\n             let mut new_idom = None;\n-            for pred in graph.predecessors(node) {\n+            for pred in graph.borrow_mut().predecessors(node) {\n                 if immediate_dominators[pred].is_some() {\n                     // (*) dominators for `pred` have been calculated\n                     new_idom = Some(if let Some(new_idom) = new_idom {"}, {"sha": "9ce60d207ad0e55ec93a28ea4507734685b72e09", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0592faa67a1fe8fb7425f24899c5538dec23ee1/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0592faa67a1fe8fb7425f24899c5538dec23ee1/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=c0592faa67a1fe8fb7425f24899c5538dec23ee1", "patch": "@@ -50,7 +50,7 @@ where\n     Self: for<'graph> GraphPredecessors<'graph, Item = <Self as DirectedGraph>::Node>,\n {\n     fn predecessors(\n-        &self,\n+        &mut self,\n         node: Self::Node,\n     ) -> <Self as GraphPredecessors<'_>>::Iter;\n }"}, {"sha": "bc4458334d57f45cf19703f0fe0614de0f715691", "filename": "src/librustc_data_structures/graph/reference.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c0592faa67a1fe8fb7425f24899c5538dec23ee1/src%2Flibrustc_data_structures%2Fgraph%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0592faa67a1fe8fb7425f24899c5538dec23ee1/src%2Flibrustc_data_structures%2Fgraph%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Freference.rs?ref=c0592faa67a1fe8fb7425f24899c5538dec23ee1", "patch": "@@ -4,26 +4,46 @@ impl<'graph, G: DirectedGraph> DirectedGraph for &'graph G {\n     type Node = G::Node;\n }\n \n+impl<'graph, G: DirectedGraph> DirectedGraph for &'graph mut G {\n+    type Node = G::Node;\n+}\n+\n impl<'graph, G: WithNumNodes> WithNumNodes for &'graph G {\n     fn num_nodes(&self) -> usize {\n         (**self).num_nodes()\n     }\n }\n+impl<'graph, G: WithNumNodes> WithNumNodes for &'graph mut G {\n+    fn num_nodes(&self) -> usize {\n+        (**self).num_nodes()\n+    }\n+}\n \n impl<'graph, G: WithStartNode> WithStartNode for &'graph G {\n     fn start_node(&self) -> Self::Node {\n         (**self).start_node()\n     }\n }\n \n+impl<'graph, G: WithStartNode> WithStartNode for &'graph mut G {\n+    fn start_node(&self) -> Self::Node {\n+        (**self).start_node()\n+    }\n+}\n+\n impl<'graph, G: WithSuccessors> WithSuccessors for &'graph G {\n     fn successors(&self, node: Self::Node) -> <Self as GraphSuccessors<'_>>::Iter {\n         (**self).successors(node)\n     }\n }\n+impl<'graph, G: WithSuccessors> WithSuccessors for &'graph mut G {\n+    fn successors(&self, node: Self::Node) -> <Self as GraphSuccessors<'_>>::Iter {\n+        (**self).successors(node)\n+    }\n+}\n \n-impl<'graph, G: WithPredecessors> WithPredecessors for &'graph G {\n-    fn predecessors(&self,\n+impl<'graph, G: WithPredecessors> WithPredecessors for &'graph mut G {\n+    fn predecessors(&mut self,\n                     node: Self::Node)\n                     -> <Self as GraphPredecessors<'_>>::Iter {\n         (**self).predecessors(node)\n@@ -35,7 +55,17 @@ impl<'iter, 'graph, G: WithPredecessors> GraphPredecessors<'iter> for &'graph G\n     type Iter = <G as GraphPredecessors<'iter>>::Iter;\n }\n \n+impl<'iter, 'graph, G: WithPredecessors> GraphPredecessors<'iter> for &'graph mut G {\n+    type Item = G::Node;\n+    type Iter = <G as GraphPredecessors<'iter>>::Iter;\n+}\n+\n impl<'iter, 'graph, G: WithSuccessors> GraphSuccessors<'iter> for &'graph G {\n     type Item = G::Node;\n     type Iter = <G as GraphSuccessors<'iter>>::Iter;\n }\n+\n+impl<'iter, 'graph, G: WithSuccessors> GraphSuccessors<'iter> for &'graph mut G {\n+    type Item = G::Node;\n+    type Iter = <G as GraphSuccessors<'iter>>::Iter;\n+}"}]}