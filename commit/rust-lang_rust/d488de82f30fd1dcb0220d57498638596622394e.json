{"sha": "d488de82f30fd1dcb0220d57498638596622394e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ODhkZTgyZjMwZmQxZGNiMDIyMGQ1NzQ5ODYzODU5NjYyMjM5NGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-11T05:14:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-11T05:14:45Z"}, "message": "Auto merge of #87587 - oli-obk:lazy_tait, r=spastorino\n\nVarious refactorings of the TAIT infrastructure\n\nBefore this PR we used to store the opaque type knowledge outside the `InferCtxt`, so it got recomputed on every opaque type instantiation.\n\nI also removed a feature gate check that makes no sense in the planned lazy TAIT resolution scheme\n\nEach commit passes all tests, so this PR is best reviewed commit by commit.\n\nr? `@spastorino`", "tree": {"sha": "06c86ec1acc9802aad71c437f3bbb48945727bd6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06c86ec1acc9802aad71c437f3bbb48945727bd6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d488de82f30fd1dcb0220d57498638596622394e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d488de82f30fd1dcb0220d57498638596622394e", "html_url": "https://github.com/rust-lang/rust/commit/d488de82f30fd1dcb0220d57498638596622394e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d488de82f30fd1dcb0220d57498638596622394e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47b41b7788a6f85c749049062f1e4eed497cd894", "url": "https://api.github.com/repos/rust-lang/rust/commits/47b41b7788a6f85c749049062f1e4eed497cd894", "html_url": "https://github.com/rust-lang/rust/commit/47b41b7788a6f85c749049062f1e4eed497cd894"}, {"sha": "93c4aa80b805bd2f0685e3438cb851ff8775415c", "url": "https://api.github.com/repos/rust-lang/rust/commits/93c4aa80b805bd2f0685e3438cb851ff8775415c", "html_url": "https://github.com/rust-lang/rust/commit/93c4aa80b805bd2f0685e3438cb851ff8775415c"}], "stats": {"total": 821, "additions": 339, "deletions": 482}, "files": [{"sha": "10217a5f5749809d6615794d19f942a039c788d6", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -4,10 +4,12 @@ pub use self::RegionVariableOrigin::*;\n pub use self::SubregionOrigin::*;\n pub use self::ValuePairs::*;\n \n+use self::opaque_types::OpaqueTypeMap;\n pub(crate) use self::undo_log::{InferCtxtUndoLogs, Snapshot, UndoLog};\n \n use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n \n+use hir::def_id::CRATE_DEF_ID;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::undo_log::Rollback;\n@@ -59,6 +61,7 @@ pub mod lattice;\n mod lexical_region_resolve;\n mod lub;\n pub mod nll_relate;\n+pub mod opaque_types;\n pub mod outlives;\n pub mod region_constraints;\n pub mod resolve;\n@@ -191,6 +194,19 @@ pub struct InferCtxtInner<'tcx> {\n     region_obligations: Vec<(hir::HirId, RegionObligation<'tcx>)>,\n \n     undo_log: InferCtxtUndoLogs<'tcx>,\n+\n+    // Opaque types found in explicit return types and their\n+    // associated fresh inference variable. Writeback resolves these\n+    // variables to get the concrete type, which can be used to\n+    // 'de-opaque' OpaqueTypeDecl, after typeck is done with all functions.\n+    pub opaque_types: OpaqueTypeMap<'tcx>,\n+\n+    /// A map from inference variables created from opaque\n+    /// type instantiations (`ty::Infer`) to the actual opaque\n+    /// type (`ty::Opaque`). Used during fallback to map unconstrained\n+    /// opaque type inference variables to their corresponding\n+    /// opaque type.\n+    pub opaque_types_vars: FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n }\n \n impl<'tcx> InferCtxtInner<'tcx> {\n@@ -204,6 +220,8 @@ impl<'tcx> InferCtxtInner<'tcx> {\n             float_unification_storage: ut::UnificationTableStorage::new(),\n             region_constraint_storage: Some(RegionConstraintStorage::new()),\n             region_obligations: vec![],\n+            opaque_types: Default::default(),\n+            opaque_types_vars: Default::default(),\n         }\n     }\n \n@@ -273,6 +291,10 @@ impl<'tcx> InferCtxtInner<'tcx> {\n pub struct InferCtxt<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n \n+    /// The `DefId` of the item in whose context we are performing inference or typeck.\n+    /// It is used to check whether an opaque type use is a defining use.\n+    pub defining_use_anchor: LocalDefId,\n+\n     /// During type-checking/inference of a body, `in_progress_typeck_results`\n     /// contains a reference to the typeck results being built up, which are\n     /// used for reading closure kinds/signatures as they are inferred,\n@@ -531,6 +553,7 @@ impl<'tcx> fmt::Display for FixupError<'tcx> {\n pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     fresh_typeck_results: Option<RefCell<ty::TypeckResults<'tcx>>>,\n+    defining_use_anchor: LocalDefId,\n }\n \n pub trait TyCtxtInferExt<'tcx> {\n@@ -539,15 +562,31 @@ pub trait TyCtxtInferExt<'tcx> {\n \n impl TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n     fn infer_ctxt(self) -> InferCtxtBuilder<'tcx> {\n-        InferCtxtBuilder { tcx: self, fresh_typeck_results: None }\n+        InferCtxtBuilder {\n+            tcx: self,\n+            defining_use_anchor: CRATE_DEF_ID,\n+            fresh_typeck_results: None,\n+        }\n     }\n }\n \n impl<'tcx> InferCtxtBuilder<'tcx> {\n     /// Used only by `rustc_typeck` during body type-checking/inference,\n     /// will initialize `in_progress_typeck_results` with fresh `TypeckResults`.\n+    /// Will also change the scope for opaque type defining use checks to the given owner.\n     pub fn with_fresh_in_progress_typeck_results(mut self, table_owner: LocalDefId) -> Self {\n         self.fresh_typeck_results = Some(RefCell::new(ty::TypeckResults::new(table_owner)));\n+        self.with_opaque_type_inference(table_owner)\n+    }\n+\n+    /// Whenever the `InferCtxt` should be able to handle defining uses of opaque types,\n+    /// you need to call this function. Otherwise the opaque type will be treated opaquely.\n+    ///\n+    /// It is only meant to be called in two places, for typeck\n+    /// (via `with_fresh_in_progress_typeck_results`) and for the inference context used\n+    /// in mir borrowck.\n+    pub fn with_opaque_type_inference(mut self, defining_use_anchor: LocalDefId) -> Self {\n+        self.defining_use_anchor = defining_use_anchor;\n         self\n     }\n \n@@ -575,10 +614,11 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     }\n \n     pub fn enter<R>(&mut self, f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>) -> R) -> R {\n-        let InferCtxtBuilder { tcx, ref fresh_typeck_results } = *self;\n+        let InferCtxtBuilder { tcx, defining_use_anchor, ref fresh_typeck_results } = *self;\n         let in_progress_typeck_results = fresh_typeck_results.as_ref();\n         f(InferCtxt {\n             tcx,\n+            defining_use_anchor,\n             in_progress_typeck_results,\n             inner: RefCell::new(InferCtxtInner::new()),\n             lexical_region_resolutions: RefCell::new(None),"}, {"sha": "d0883f23a4e6bb9237a7c8b83aa17f0dca6beb2c", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -0,0 +1,47 @@\n+use rustc_data_structures::vec_map::VecMap;\n+use rustc_hir as hir;\n+use rustc_middle::ty::{OpaqueTypeKey, Ty};\n+use rustc_span::Span;\n+\n+pub type OpaqueTypeMap<'tcx> = VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n+\n+/// Information about the opaque types whose values we\n+/// are inferring in this function (these are the `impl Trait` that\n+/// appear in the return type).\n+#[derive(Copy, Clone, Debug)]\n+pub struct OpaqueTypeDecl<'tcx> {\n+    /// The opaque type (`ty::Opaque`) for this declaration.\n+    pub opaque_type: Ty<'tcx>,\n+\n+    /// The span of this particular definition of the opaque type. So\n+    /// for example:\n+    ///\n+    /// ```ignore (incomplete snippet)\n+    /// type Foo = impl Baz;\n+    /// fn bar() -> Foo {\n+    /// //          ^^^ This is the span we are looking for!\n+    /// }\n+    /// ```\n+    ///\n+    /// In cases where the fn returns `(impl Trait, impl Trait)` or\n+    /// other such combinations, the result is currently\n+    /// over-approximated, but better than nothing.\n+    pub definition_span: Span,\n+\n+    /// The type variable that represents the value of the opaque type\n+    /// that we require. In other words, after we compile this function,\n+    /// we will be created a constraint like:\n+    ///\n+    ///     Foo<'a, T> = ?C\n+    ///\n+    /// where `?C` is the value of this type variable. =) It may\n+    /// naturally refer to the type and lifetime parameters in scope\n+    /// in this function, though ultimately it should only reference\n+    /// those that are arguments to `Foo` in the constraint above. (In\n+    /// other words, `?C` should not include `'b`, even though it's a\n+    /// lifetime parameter on `foo`.)\n+    pub concrete_ty: Ty<'tcx>,\n+\n+    /// The origin of the opaque type.\n+    pub origin: hir::OpaqueTyOrigin,\n+}"}, {"sha": "2bfa51f27bbb610ad932d222da084a989cc5ac7f", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -105,7 +105,7 @@ fn mir_borrowck<'tcx>(\n     let (input_body, promoted) = tcx.mir_promoted(def);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def.did.to_def_id()));\n \n-    let opt_closure_req = tcx.infer_ctxt().enter(|infcx| {\n+    let opt_closure_req = tcx.infer_ctxt().with_opaque_type_inference(def.did).enter(|infcx| {\n         let input_body: &Body<'_> = &input_body.borrow();\n         let promoted: &IndexVec<_, _> = &promoted.borrow();\n         do_mir_borrowck(&infcx, input_body, promoted)"}, {"sha": "f69d08a6d594231163296fac607a42bd41da390d", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 74, "deletions": 90, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -179,54 +179,55 @@ pub(crate) fn type_check<'mir, 'tcx>(\n             liveness::generate(&mut cx, body, elements, flow_inits, move_data, location_table);\n \n             translate_outlives_facts(&mut cx);\n-            let mut opaque_type_values = cx.opaque_type_values;\n-\n-            for (_, revealed_ty) in &mut opaque_type_values {\n-                *revealed_ty = infcx.resolve_vars_if_possible(*revealed_ty);\n-                if revealed_ty.has_infer_types_or_consts() {\n-                    infcx.tcx.sess.delay_span_bug(\n-                        body.span,\n-                        &format!(\"could not resolve {:#?}\", revealed_ty.kind()),\n-                    );\n-                    *revealed_ty = infcx.tcx.ty_error();\n-                }\n-            }\n-\n-            opaque_type_values.retain(|(opaque_type_key, resolved_ty)| {\n-                let concrete_is_opaque = if let ty::Opaque(def_id, _) = resolved_ty.kind() {\n-                    *def_id == opaque_type_key.def_id\n-                } else {\n-                    false\n-                };\n+            let opaque_type_values = mem::take(&mut infcx.inner.borrow_mut().opaque_types);\n \n-                if concrete_is_opaque {\n-                    // We're using an opaque `impl Trait` type without\n-                    // 'revealing' it. For example, code like this:\n-                    //\n-                    // type Foo = impl Debug;\n-                    // fn foo1() -> Foo { ... }\n-                    // fn foo2() -> Foo { foo1() }\n-                    //\n-                    // In `foo2`, we're not revealing the type of `Foo` - we're\n-                    // just treating it as the opaque type.\n-                    //\n-                    // When this occurs, we do *not* want to try to equate\n-                    // the concrete type with the underlying defining type\n-                    // of the opaque type - this will always fail, since\n-                    // the defining type of an opaque type is always\n-                    // some other type (e.g. not itself)\n-                    // Essentially, none of the normal obligations apply here -\n-                    // we're just passing around some unknown opaque type,\n-                    // without actually looking at the underlying type it\n-                    // gets 'revealed' into\n-                    debug!(\n-                        \"eq_opaque_type_and_type: non-defining use of {:?}\",\n-                        opaque_type_key.def_id,\n-                    );\n-                }\n-                !concrete_is_opaque\n-            });\n             opaque_type_values\n+                .into_iter()\n+                .filter_map(|(opaque_type_key, decl)| {\n+                    let mut revealed_ty = infcx.resolve_vars_if_possible(decl.concrete_ty);\n+                    if revealed_ty.has_infer_types_or_consts() {\n+                        infcx.tcx.sess.delay_span_bug(\n+                            body.span,\n+                            &format!(\"could not resolve {:#?}\", revealed_ty.kind()),\n+                        );\n+                        revealed_ty = infcx.tcx.ty_error();\n+                    }\n+                    let concrete_is_opaque = if let ty::Opaque(def_id, _) = revealed_ty.kind() {\n+                        *def_id == opaque_type_key.def_id\n+                    } else {\n+                        false\n+                    };\n+\n+                    if concrete_is_opaque {\n+                        // We're using an opaque `impl Trait` type without\n+                        // 'revealing' it. For example, code like this:\n+                        //\n+                        // type Foo = impl Debug;\n+                        // fn foo1() -> Foo { ... }\n+                        // fn foo2() -> Foo { foo1() }\n+                        //\n+                        // In `foo2`, we're not revealing the type of `Foo` - we're\n+                        // just treating it as the opaque type.\n+                        //\n+                        // When this occurs, we do *not* want to try to equate\n+                        // the concrete type with the underlying defining type\n+                        // of the opaque type - this will always fail, since\n+                        // the defining type of an opaque type is always\n+                        // some other type (e.g. not itself)\n+                        // Essentially, none of the normal obligations apply here -\n+                        // we're just passing around some unknown opaque type,\n+                        // without actually looking at the underlying type it\n+                        // gets 'revealed' into\n+                        debug!(\n+                            \"eq_opaque_type_and_type: non-defining use of {:?}\",\n+                            opaque_type_key.def_id,\n+                        );\n+                        None\n+                    } else {\n+                        Some((opaque_type_key, revealed_ty))\n+                    }\n+                })\n+                .collect()\n         },\n     );\n \n@@ -865,7 +866,6 @@ struct TypeChecker<'a, 'tcx> {\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n     universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n-    opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n }\n \n struct BorrowCheckContext<'a, 'tcx> {\n@@ -1025,7 +1025,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             borrowck_context,\n             reported_errors: Default::default(),\n             universal_region_relations,\n-            opaque_type_values: VecMap::default(),\n         };\n         checker.check_user_type_annotations();\n         checker\n@@ -1289,10 +1288,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let body = self.body;\n         let mir_def_id = body.source.def_id().expect_local();\n \n-        let mut opaque_type_values = VecMap::new();\n-\n         debug!(\"eq_opaque_type_and_type: mir_def_id={:?}\", mir_def_id);\n-        let opaque_type_map = self.fully_perform_op(\n+        self.fully_perform_op(\n             locations,\n             category,\n             CustomTypeOp::new(\n@@ -1307,20 +1304,17 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     // to `Box<?T>`, returning an `opaque_type_map` mapping `{Foo<T> -> ?T}`.\n                     // (Note that the key of the map is both the def-id of `Foo` along with\n                     // any generic parameters.)\n-                    let (output_ty, opaque_type_map) =\n-                        obligations.add(infcx.instantiate_opaque_types(\n-                            mir_def_id,\n-                            dummy_body_id,\n-                            param_env,\n-                            anon_ty,\n-                            locations.span(body),\n-                        ));\n+                    let output_ty = obligations.add(infcx.instantiate_opaque_types(\n+                        dummy_body_id,\n+                        param_env,\n+                        anon_ty,\n+                        locations.span(body),\n+                    ));\n                     debug!(\n                         \"eq_opaque_type_and_type: \\\n                          instantiated output_ty={:?} \\\n-                         opaque_type_map={:#?} \\\n                          revealed_ty={:?}\",\n-                        output_ty, opaque_type_map, revealed_ty\n+                        output_ty, revealed_ty\n                     );\n \n                     // Make sure that the inferred types are well-formed. I'm\n@@ -1338,48 +1332,38 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             .eq(output_ty, revealed_ty)?,\n                     );\n \n-                    for &(opaque_type_key, opaque_decl) in &opaque_type_map {\n-                        opaque_type_values.insert(opaque_type_key, opaque_decl.concrete_ty);\n-                    }\n-\n                     debug!(\"eq_opaque_type_and_type: equated\");\n \n-                    Ok(InferOk {\n-                        value: Some(opaque_type_map),\n-                        obligations: obligations.into_vec(),\n-                    })\n+                    Ok(InferOk { value: (), obligations: obligations.into_vec() })\n                 },\n                 || \"input_output\".to_string(),\n             ),\n         )?;\n \n-        self.opaque_type_values.extend(opaque_type_values);\n-\n         let universal_region_relations = self.universal_region_relations;\n \n         // Finally, if we instantiated the anon types successfully, we\n         // have to solve any bounds (e.g., `-> impl Iterator` needs to\n         // prove that `T: Iterator` where `T` is the type we\n         // instantiated it with).\n-        if let Some(opaque_type_map) = opaque_type_map {\n-            for (opaque_type_key, opaque_decl) in opaque_type_map {\n-                self.fully_perform_op(\n-                    locations,\n-                    ConstraintCategory::OpaqueType,\n-                    CustomTypeOp::new(\n-                        |infcx| {\n-                            infcx.constrain_opaque_type(\n-                                opaque_type_key,\n-                                &opaque_decl,\n-                                GenerateMemberConstraints::IfNoStaticBound,\n-                                universal_region_relations,\n-                            );\n-                            Ok(InferOk { value: (), obligations: vec![] })\n-                        },\n-                        || \"opaque_type_map\".to_string(),\n-                    ),\n-                )?;\n-            }\n+        let opaque_type_map = self.infcx.inner.borrow().opaque_types.clone();\n+        for (opaque_type_key, opaque_decl) in opaque_type_map {\n+            self.fully_perform_op(\n+                locations,\n+                ConstraintCategory::OpaqueType,\n+                CustomTypeOp::new(\n+                    |infcx| {\n+                        infcx.constrain_opaque_type(\n+                            opaque_type_key,\n+                            &opaque_decl,\n+                            GenerateMemberConstraints::IfNoStaticBound,\n+                            universal_region_relations,\n+                        );\n+                        Ok(InferOk { value: (), obligations: vec![] })\n+                    },\n+                    || \"opaque_type_map\".to_string(),\n+                ),\n+            )?;\n         }\n         Ok(())\n     }"}, {"sha": "1a195ce18ec64d3708f30bfc83616341d472ed13", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 85, "deletions": 149, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -2,11 +2,11 @@ use crate::infer::InferCtxtExt as _;\n use crate::traits::{self, ObligationCause, PredicateObligation};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n-use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n use rustc_infer::infer::free_regions::FreeRegionRelations;\n+use rustc_infer::infer::opaque_types::OpaqueTypeDecl;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{self, InferCtxt, InferOk};\n use rustc_middle::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n@@ -16,72 +16,6 @@ use rustc_span::Span;\n \n use std::ops::ControlFlow;\n \n-pub type OpaqueTypeMap<'tcx> = VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n-\n-/// Information about the opaque types whose values we\n-/// are inferring in this function (these are the `impl Trait` that\n-/// appear in the return type).\n-#[derive(Copy, Clone, Debug)]\n-pub struct OpaqueTypeDecl<'tcx> {\n-    /// The opaque type (`ty::Opaque`) for this declaration.\n-    pub opaque_type: Ty<'tcx>,\n-\n-    /// The span of this particular definition of the opaque type. So\n-    /// for example:\n-    ///\n-    /// ```ignore (incomplete snippet)\n-    /// type Foo = impl Baz;\n-    /// fn bar() -> Foo {\n-    /// //          ^^^ This is the span we are looking for!\n-    /// }\n-    /// ```\n-    ///\n-    /// In cases where the fn returns `(impl Trait, impl Trait)` or\n-    /// other such combinations, the result is currently\n-    /// over-approximated, but better than nothing.\n-    pub definition_span: Span,\n-\n-    /// The type variable that represents the value of the opaque type\n-    /// that we require. In other words, after we compile this function,\n-    /// we will be created a constraint like:\n-    ///\n-    ///     Foo<'a, T> = ?C\n-    ///\n-    /// where `?C` is the value of this type variable. =) It may\n-    /// naturally refer to the type and lifetime parameters in scope\n-    /// in this function, though ultimately it should only reference\n-    /// those that are arguments to `Foo` in the constraint above. (In\n-    /// other words, `?C` should not include `'b`, even though it's a\n-    /// lifetime parameter on `foo`.)\n-    pub concrete_ty: Ty<'tcx>,\n-\n-    /// Returns `true` if the `impl Trait` bounds include region bounds.\n-    /// For example, this would be true for:\n-    ///\n-    ///     fn foo<'a, 'b, 'c>() -> impl Trait<'c> + 'a + 'b\n-    ///\n-    /// but false for:\n-    ///\n-    ///     fn foo<'c>() -> impl Trait<'c>\n-    ///\n-    /// unless `Trait` was declared like:\n-    ///\n-    ///     trait Trait<'c>: 'c\n-    ///\n-    /// in which case it would be true.\n-    ///\n-    /// This is used during regionck to decide whether we need to\n-    /// impose any additional constraints to ensure that region\n-    /// variables in `concrete_ty` wind up being constrained to\n-    /// something from `substs` (or, at minimum, things that outlive\n-    /// the fn body). (Ultimately, writeback is responsible for this\n-    /// check.)\n-    pub has_required_region_bounds: bool,\n-\n-    /// The origin of the opaque type.\n-    pub origin: hir::OpaqueTyOrigin,\n-}\n-\n /// Whether member constraints should be generated for all opaque types\n #[derive(Debug)]\n pub enum GenerateMemberConstraints {\n@@ -98,18 +32,13 @@ pub enum GenerateMemberConstraints {\n pub trait InferCtxtExt<'tcx> {\n     fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n         &self,\n-        parent_def_id: LocalDefId,\n         body_id: hir::HirId,\n         param_env: ty::ParamEnv<'tcx>,\n         value: T,\n         value_span: Span,\n-    ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)>;\n+    ) -> InferOk<'tcx, T>;\n \n-    fn constrain_opaque_types<FRR: FreeRegionRelations<'tcx>>(\n-        &self,\n-        opaque_types: &OpaqueTypeMap<'tcx>,\n-        free_region_relations: &FRR,\n-    );\n+    fn constrain_opaque_types<FRR: FreeRegionRelations<'tcx>>(&self, free_region_relations: &FRR);\n \n     fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n         &self,\n@@ -164,28 +93,20 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// - `value_span` -- the span where the value came from, used in error reporting\n     fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n         &self,\n-        parent_def_id: LocalDefId,\n         body_id: hir::HirId,\n         param_env: ty::ParamEnv<'tcx>,\n         value: T,\n         value_span: Span,\n-    ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)> {\n+    ) -> InferOk<'tcx, T> {\n         debug!(\n-            \"instantiate_opaque_types(value={:?}, parent_def_id={:?}, body_id={:?}, \\\n+            \"instantiate_opaque_types(value={:?}, body_id={:?}, \\\n              param_env={:?}, value_span={:?})\",\n-            value, parent_def_id, body_id, param_env, value_span,\n+            value, body_id, param_env, value_span,\n         );\n-        let mut instantiator = Instantiator {\n-            infcx: self,\n-            parent_def_id,\n-            body_id,\n-            param_env,\n-            value_span,\n-            opaque_types: Default::default(),\n-            obligations: vec![],\n-        };\n+        let mut instantiator =\n+            Instantiator { infcx: self, body_id, param_env, value_span, obligations: vec![] };\n         let value = instantiator.instantiate_opaque_types_in_map(value);\n-        InferOk { value: (value, instantiator.opaque_types), obligations: instantiator.obligations }\n+        InferOk { value, obligations: instantiator.obligations }\n     }\n \n     /// Given the map `opaque_types` containing the opaque\n@@ -350,12 +271,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// - `opaque_types` -- the map produced by `instantiate_opaque_types`\n     /// - `free_region_relations` -- something that can be used to relate\n     ///   the free regions (`'a`) that appear in the impl trait.\n-    fn constrain_opaque_types<FRR: FreeRegionRelations<'tcx>>(\n-        &self,\n-        opaque_types: &OpaqueTypeMap<'tcx>,\n-        free_region_relations: &FRR,\n-    ) {\n-        for &(opaque_type_key, opaque_defn) in opaque_types {\n+    fn constrain_opaque_types<FRR: FreeRegionRelations<'tcx>>(&self, free_region_relations: &FRR) {\n+        let opaque_types = self.inner.borrow().opaque_types.clone();\n+        for (opaque_type_key, opaque_defn) in opaque_types {\n             self.constrain_opaque_type(\n                 opaque_type_key,\n                 &opaque_defn,\n@@ -403,19 +321,35 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         let span = tcx.def_span(def_id);\n \n-        // If there are required region bounds, we can use them.\n-        if opaque_defn.has_required_region_bounds {\n-            let bounds = tcx.explicit_item_bounds(def_id);\n-            debug!(\"{:#?}\", bounds);\n-            let bounds: Vec<_> =\n-                bounds.iter().map(|(bound, _)| bound.subst(tcx, opaque_type_key.substs)).collect();\n-            debug!(\"{:#?}\", bounds);\n-            let opaque_type = tcx.mk_opaque(def_id, opaque_type_key.substs);\n-\n-            let required_region_bounds =\n-                required_region_bounds(tcx, opaque_type, bounds.into_iter());\n-            debug_assert!(!required_region_bounds.is_empty());\n-\n+        // Check if the `impl Trait` bounds include region bounds.\n+        // For example, this would be true for:\n+        //\n+        //     fn foo<'a, 'b, 'c>() -> impl Trait<'c> + 'a + 'b\n+        //\n+        // but false for:\n+        //\n+        //     fn foo<'c>() -> impl Trait<'c>\n+        //\n+        // unless `Trait` was declared like:\n+        //\n+        //     trait Trait<'c>: 'c\n+        //\n+        // in which case it would be true.\n+        //\n+        // This is used during regionck to decide whether we need to\n+        // impose any additional constraints to ensure that region\n+        // variables in `concrete_ty` wind up being constrained to\n+        // something from `substs` (or, at minimum, things that outlive\n+        // the fn body). (Ultimately, writeback is responsible for this\n+        // check.)\n+        let bounds = tcx.explicit_item_bounds(def_id);\n+        debug!(\"{:#?}\", bounds);\n+        let bounds = bounds.iter().map(|(bound, _)| bound.subst(tcx, opaque_type_key.substs));\n+        debug!(\"{:#?}\", bounds);\n+        let opaque_type = tcx.mk_opaque(def_id, opaque_type_key.substs);\n+\n+        let required_region_bounds = required_region_bounds(tcx, opaque_type, bounds);\n+        if !required_region_bounds.is_empty() {\n             for required_region in required_region_bounds {\n                 concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n                     op: |r| self.sub_regions(infer::CallReturn(span), required_region, r),\n@@ -914,11 +848,9 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n \n struct Instantiator<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n-    parent_def_id: LocalDefId,\n     body_id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n     value_span: Span,\n-    opaque_types: OpaqueTypeMap<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n }\n \n@@ -968,7 +900,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                     // ```\n                     if let Some(def_id) = def_id.as_local() {\n                         let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-                        let parent_def_id = self.parent_def_id;\n+                        let parent_def_id = self.infcx.defining_use_anchor;\n                         let def_scope_default = || {\n                             let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n                             parent_def_id == tcx.hir().local_def_id(opaque_parent_hir_id)\n@@ -980,14 +912,14 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                                     impl_trait_fn: Some(parent),\n                                     origin,\n                                     ..\n-                                }) => (parent == self.parent_def_id.to_def_id(), origin),\n+                                }) => (parent == parent_def_id.to_def_id(), origin),\n                                 // Named `type Foo = impl Bar;`\n                                 hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                                     impl_trait_fn: None,\n                                     origin,\n                                     ..\n                                 }) => (\n-                                    may_define_opaque_type(tcx, self.parent_def_id, opaque_hir_id),\n+                                    may_define_opaque_type(tcx, parent_def_id, opaque_hir_id),\n                                     origin,\n                                 ),\n                                 _ => (def_scope_default(), hir::OpaqueTyOrigin::TyAlias),\n@@ -1028,32 +960,14 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n \n         // Use the same type variable if the exact same opaque type appears more\n         // than once in the return type (e.g., if it's passed to a type alias).\n-        if let Some(opaque_defn) = self.opaque_types.get(&opaque_type_key) {\n+        if let Some(opaque_defn) = infcx.inner.borrow().opaque_types.get(&opaque_type_key) {\n             debug!(\"instantiate_opaque_types: returning concrete ty {:?}\", opaque_defn.concrete_ty);\n             return opaque_defn.concrete_ty;\n         }\n-        let span = tcx.def_span(def_id);\n-        debug!(\"fold_opaque_ty {:?} {:?}\", self.value_span, span);\n-        let ty_var = infcx\n-            .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n-\n-        let item_bounds = tcx.explicit_item_bounds(def_id);\n-        debug!(\"instantiate_opaque_types: bounds={:#?}\", item_bounds);\n-        let bounds: Vec<_> =\n-            item_bounds.iter().map(|(bound, _)| bound.subst(tcx, substs)).collect();\n-\n-        let param_env = tcx.param_env(def_id);\n-        let InferOk { value: bounds, obligations } = infcx.partially_normalize_associated_types_in(\n-            ObligationCause::misc(span, self.body_id),\n-            param_env,\n-            bounds,\n-        );\n-        self.obligations.extend(obligations);\n-\n-        debug!(\"instantiate_opaque_types: bounds={:?}\", bounds);\n-\n-        let required_region_bounds = required_region_bounds(tcx, ty, bounds.iter().copied());\n-        debug!(\"instantiate_opaque_types: required_region_bounds={:?}\", required_region_bounds);\n+        let ty_var = infcx.next_ty_var(TypeVariableOrigin {\n+            kind: TypeVariableOriginKind::TypeInference,\n+            span: self.value_span,\n+        });\n \n         // Make sure that we are in fact defining the *entire* type\n         // (e.g., `type Foo<T: Bound> = impl Bar;` needs to be\n@@ -1068,23 +982,46 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         // Foo, impl Bar)`.\n         let definition_span = self.value_span;\n \n-        self.opaque_types.insert(\n-            OpaqueTypeKey { def_id, substs },\n-            OpaqueTypeDecl {\n-                opaque_type: ty,\n-                definition_span,\n-                concrete_ty: ty_var,\n-                has_required_region_bounds: !required_region_bounds.is_empty(),\n-                origin,\n-            },\n-        );\n+        {\n+            let mut infcx = self.infcx.inner.borrow_mut();\n+            infcx.opaque_types.insert(\n+                OpaqueTypeKey { def_id, substs },\n+                OpaqueTypeDecl { opaque_type: ty, definition_span, concrete_ty: ty_var, origin },\n+            );\n+            infcx.opaque_types_vars.insert(ty_var, ty);\n+        }\n+\n         debug!(\"instantiate_opaque_types: ty_var={:?}\", ty_var);\n+        self.compute_opaque_type_obligations(opaque_type_key);\n+\n+        ty_var\n+    }\n+\n+    fn compute_opaque_type_obligations(&mut self, opaque_type_key: OpaqueTypeKey<'tcx>) {\n+        let infcx = self.infcx;\n+        let tcx = infcx.tcx;\n+        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n+\n+        let item_bounds = tcx.explicit_item_bounds(def_id);\n+        debug!(\"instantiate_opaque_types: bounds={:#?}\", item_bounds);\n+        let bounds: Vec<_> =\n+            item_bounds.iter().map(|(bound, _)| bound.subst(tcx, substs)).collect();\n+\n+        let param_env = tcx.param_env(def_id);\n+        let InferOk { value: bounds, obligations } = infcx.partially_normalize_associated_types_in(\n+            ObligationCause::misc(self.value_span, self.body_id),\n+            param_env,\n+            bounds,\n+        );\n+        self.obligations.extend(obligations);\n+\n+        debug!(\"instantiate_opaque_types: bounds={:?}\", bounds);\n \n         for predicate in &bounds {\n             if let ty::PredicateKind::Projection(projection) = predicate.kind().skip_binder() {\n                 if projection.ty.references_error() {\n                     // No point on adding these obligations since there's a type error involved.\n-                    return ty_var;\n+                    return;\n                 }\n             }\n         }\n@@ -1096,14 +1033,13 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n             // This also instantiates nested instances of `impl Trait`.\n             let predicate = self.instantiate_opaque_types_in_map(predicate);\n \n-            let cause = traits::ObligationCause::new(span, self.body_id, traits::OpaqueType);\n+            let cause =\n+                traits::ObligationCause::new(self.value_span, self.body_id, traits::OpaqueType);\n \n             // Require that the predicate holds for the concrete type.\n             debug!(\"instantiate_opaque_types: predicate={:?}\", predicate);\n             self.obligations.push(traits::Obligation::new(cause, self.param_env, predicate));\n         }\n-\n-        ty_var\n     }\n }\n "}, {"sha": "10c3a97e73a5af46123d9446b320a1532007fdbc", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -593,13 +593,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         orig_expected: Expectation<'tcx>,\n     ) -> Option<Span> {\n         match (orig_expected, self.ret_coercion_impl_trait.map(|ty| (self.body_id.owner, ty))) {\n-            (Expectation::ExpectHasType(expected), Some((id, ty)))\n+            (Expectation::ExpectHasType(expected), Some((_id, ty)))\n                 if self.in_tail_expr && self.can_coerce(outer_ty, expected) =>\n             {\n                 let impl_trait_ret_ty =\n-                    self.infcx.instantiate_opaque_types(id, self.body_id, self.param_env, ty, span);\n-                let mut suggest_box = !impl_trait_ret_ty.obligations.is_empty();\n-                for o in impl_trait_ret_ty.obligations {\n+                    self.infcx.instantiate_opaque_types(self.body_id, self.param_env, ty, span);\n+                assert!(\n+                    impl_trait_ret_ty.obligations.is_empty(),\n+                    \"we should never get new obligations here\"\n+                );\n+                let obligations = self.fulfillment_cx.borrow().pending_obligations();\n+                let mut suggest_box = !obligations.is_empty();\n+                for o in obligations {\n                     match o.predicate.kind().skip_binder() {\n                         ty::PredicateKind::Trait(t, constness) => {\n                             let pred = ty::PredicateKind::Trait("}, {"sha": "8b5b7e3e52c80d0d9cd72a8c029ab4308e3ef4c3", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 5, "deletions": 65, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -94,69 +94,8 @@ pub(super) fn check_fn<'a, 'tcx>(\n \n     let declared_ret_ty = fn_sig.output();\n \n-    let feature = match tcx.hir().get(fn_id) {\n-        // TAIT usage in function return position.\n-        // Example:\n-        //\n-        // ```rust\n-        // type Foo = impl Debug;\n-        // fn bar() -> Foo { 42 }\n-        // ```\n-        Node::Item(hir::Item { kind: ItemKind::Fn(..), .. }) |\n-        // TAIT usage in associated function return position.\n-        //\n-        // Example with a free type alias:\n-        //\n-        // ```rust\n-        // type Foo = impl Debug;\n-        // impl SomeTrait for SomeType {\n-        //     fn bar() -> Foo { 42 }\n-        // }\n-        // ```\n-        //\n-        // Example with an associated TAIT:\n-        //\n-        // ```rust\n-        // impl SomeTrait for SomeType {\n-        //     type Foo = impl Debug;\n-        //     fn bar() -> Self::Foo { 42 }\n-        // }\n-        // ```\n-        Node::ImplItem(hir::ImplItem {\n-            kind: hir::ImplItemKind::Fn(..), ..\n-        }) => None,\n-        // Forbid TAIT in trait declarations for now.\n-        // Examples:\n-        //\n-        // ```rust\n-        // type Foo = impl Debug;\n-        // trait Bar {\n-        //     fn bar() -> Foo;\n-        // }\n-        // trait Bop {\n-        //     type Bop: PartialEq<Foo>;\n-        // }\n-        // ```\n-        Node::TraitItem(hir::TraitItem {\n-            kind: hir::TraitItemKind::Fn(..),\n-            ..\n-        }) |\n-        // Forbid TAIT in closure return position for now.\n-        // Example:\n-        //\n-        // ```rust\n-        // type Foo = impl Debug;\n-        // let x = |y| -> Foo { 42 + y };\n-        // ```\n-        Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(..), .. }) => Some(sym::type_alias_impl_trait),\n-        node => bug!(\"Item being checked wasn't a function/closure: {:?}\", node),\n-    };\n-    let revealed_ret_ty = fcx.instantiate_opaque_types_from_value(\n-        fn_id,\n-        declared_ret_ty,\n-        decl.output.span(),\n-        feature,\n-    );\n+    let revealed_ret_ty =\n+        fcx.instantiate_opaque_types_from_value(declared_ret_ty, decl.output.span());\n     debug!(\"check_fn: declared_ret_ty: {}, revealed_ret_ty: {}\", declared_ret_ty, revealed_ret_ty);\n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(revealed_ret_ty)));\n     fcx.ret_type_span = Some(decl.output.span());\n@@ -711,10 +650,11 @@ fn check_opaque_meets_bounds<'tcx>(\n \n         let misc_cause = traits::ObligationCause::misc(span, hir_id);\n \n-        let (_, opaque_type_map) = inh.register_infer_ok_obligations(\n-            infcx.instantiate_opaque_types(def_id, hir_id, param_env, opaque_ty, span),\n+        let _ = inh.register_infer_ok_obligations(\n+            infcx.instantiate_opaque_types(hir_id, param_env, opaque_ty, span),\n         );\n \n+        let opaque_type_map = infcx.inner.borrow().opaque_types.clone();\n         for (OpaqueTypeKey { def_id, substs }, opaque_defn) in opaque_type_map {\n             match infcx\n                 .at(&misc_cause, param_env)"}, {"sha": "b84a79b768c9a32223fa1c739685d54c372c83e8", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 9, "deletions": 42, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -29,12 +29,11 @@ use rustc_middle::ty::{\n };\n use rustc_session::lint;\n use rustc_session::lint::builtin::BARE_TRAIT_OBJECTS;\n-use rustc_session::parse::feature_err;\n use rustc_span::edition::Edition;\n+use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{original_sp, DUMMY_SP};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{self, BytePos, MultiSpan, Span};\n-use rustc_span::{hygiene::DesugaringKind, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n@@ -363,50 +362,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Replaces the opaque types from the given value with type variables,\n     /// and records the `OpaqueTypeMap` for later use during writeback. See\n     /// `InferCtxt::instantiate_opaque_types` for more details.\n+    #[instrument(skip(self, value_span), level = \"debug\")]\n     pub(in super::super) fn instantiate_opaque_types_from_value<T: TypeFoldable<'tcx>>(\n         &self,\n-        parent_id: hir::HirId,\n         value: T,\n         value_span: Span,\n-        feature: Option<Symbol>,\n     ) -> T {\n-        let parent_def_id = self.tcx.hir().local_def_id(parent_id);\n-        debug!(\n-            \"instantiate_opaque_types_from_value(parent_def_id={:?}, value={:?})\",\n-            parent_def_id, value\n-        );\n-\n-        let (value, opaque_type_map) =\n-            self.register_infer_ok_obligations(self.instantiate_opaque_types(\n-                parent_def_id,\n-                self.body_id,\n-                self.param_env,\n-                value,\n-                value_span,\n-            ));\n-\n-        let mut opaque_types = self.opaque_types.borrow_mut();\n-        let mut opaque_types_vars = self.opaque_types_vars.borrow_mut();\n-\n-        for (ty, decl) in opaque_type_map {\n-            if let Some(feature) = feature {\n-                if let hir::OpaqueTyOrigin::TyAlias = decl.origin {\n-                    if !self.tcx.features().enabled(feature) {\n-                        feature_err(\n-                            &self.tcx.sess.parse_sess,\n-                            feature,\n-                            value_span,\n-                            \"type alias impl trait is not permitted here\",\n-                        )\n-                        .emit();\n-                    }\n-                }\n-            }\n-            let _ = opaque_types.insert(ty, decl);\n-            let _ = opaque_types_vars.insert(decl.concrete_ty, decl.opaque_type);\n-        }\n-\n-        value\n+        self.register_infer_ok_obligations(self.instantiate_opaque_types(\n+            self.body_id,\n+            self.param_env,\n+            value,\n+            value_span,\n+        ))\n     }\n \n     /// Convenience method which tracks extra diagnostic information for normalization\n@@ -726,7 +693,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // We treat this as a non-defining use by making the inference\n                 // variable fall back to the opaque type itself.\n                 if let FallbackMode::All = mode {\n-                    if let Some(opaque_ty) = self.opaque_types_vars.borrow().get(ty) {\n+                    if let Some(opaque_ty) = self.infcx.inner.borrow().opaque_types_vars.get(ty) {\n                         debug!(\n                             \"fallback_if_possible: falling back opaque type var {:?} to {:?}\",\n                             ty, opaque_ty"}, {"sha": "fb7beae70ba1ea4075a7f83cba657ea4fadc1eb6", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -1,18 +1,15 @@\n use super::callee::DeferredCallResolution;\n use super::MaybeInProgressTables;\n \n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefIdMap, LocalDefId};\n use rustc_hir::HirIdMap;\n use rustc_infer::infer;\n use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_middle::ty::fold::TypeFoldable;\n-use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::{self, Span};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n-use rustc_trait_selection::opaque_types::OpaqueTypeDecl;\n use rustc_trait_selection::traits::{self, ObligationCause, TraitEngine, TraitEngineExt};\n \n use std::cell::RefCell;\n@@ -55,19 +52,6 @@ pub struct Inherited<'a, 'tcx> {\n     pub(super) deferred_generator_interiors:\n         RefCell<Vec<(hir::BodyId, Ty<'tcx>, hir::GeneratorKind)>>,\n \n-    // Opaque types found in explicit return types and their\n-    // associated fresh inference variable. Writeback resolves these\n-    // variables to get the concrete type, which can be used to\n-    // 'de-opaque' OpaqueTypeDecl, after typeck is done with all functions.\n-    pub(super) opaque_types: RefCell<VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>>,\n-\n-    /// A map from inference variables created from opaque\n-    /// type instantiations (`ty::Infer`) to the actual opaque\n-    /// type (`ty::Opaque`). Used during fallback to map unconstrained\n-    /// opaque type inference variables to their corresponding\n-    /// opaque type.\n-    pub(super) opaque_types_vars: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n-\n     pub(super) body_id: Option<hir::BodyId>,\n }\n \n@@ -124,8 +108,6 @@ impl Inherited<'a, 'tcx> {\n             deferred_call_resolutions: RefCell::new(Default::default()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n             deferred_generator_interiors: RefCell::new(Vec::new()),\n-            opaque_types: RefCell::new(Default::default()),\n-            opaque_types_vars: RefCell::new(Default::default()),\n             body_id,\n         }\n     }"}, {"sha": "ca6828cfdf68de599fee44ff104038bbb081a59c", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -291,10 +291,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.hir_id);\n \n-        self.constrain_opaque_types(\n-            &self.fcx.opaque_types.borrow(),\n-            self.outlives_environment.free_region_map(),\n-        );\n+        self.constrain_opaque_types(self.outlives_environment.free_region_map());\n     }\n \n     fn visit_region_obligations(&mut self, hir_id: hir::HirId) {"}, {"sha": "959ab69a679eb1d6075b02f1f42a2daf021679e1", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -498,7 +498,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     }\n \n     fn visit_opaque_types(&mut self, span: Span) {\n-        for &(opaque_type_key, opaque_defn) in self.fcx.opaque_types.borrow().iter() {\n+        let opaque_types = self.fcx.infcx.inner.borrow().opaque_types.clone();\n+        for (opaque_type_key, opaque_defn) in opaque_types {\n             let hir_id =\n                 self.tcx().hir().local_def_id_to_hir_id(opaque_type_key.def_id.expect_local());\n             let instantiated_ty = self.resolve(opaque_defn.concrete_ty, &hir_id);"}, {"sha": "4c36289f47b857ac0e5c50ae4fa9df26d9dc7863", "filename": "src/test/ui/associated-type-bounds/assoc-type-eq-with-dyn-atb-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -28,9 +28,9 @@ impl Bar for AssocNoCopy {\n \n impl Thing for AssocNoCopy {\n     type Out = Box<dyn Bar<Assoc: Copy>>;\n-    //~^ ERROR the trait bound `String: Copy` is not satisfied\n \n     fn func() -> Self::Out {\n+        //~^ ERROR the trait bound `String: Copy` is not satisfied\n         Box::new(AssocNoCopy)\n     }\n }"}, {"sha": "a32ab453152a0b4663c06788b189aaba8cd23431", "filename": "src/test/ui/associated-type-bounds/assoc-type-eq-with-dyn-atb-fail.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `String: Copy` is not satisfied\n-  --> $DIR/assoc-type-eq-with-dyn-atb-fail.rs:30:28\n+  --> $DIR/assoc-type-eq-with-dyn-atb-fail.rs:32:18\n    |\n-LL |     type Out = Box<dyn Bar<Assoc: Copy>>;\n-   |                            ^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n+LL |     fn func() -> Self::Out {\n+   |                  ^^^^^^^^^ the trait `Copy` is not implemented for `String`\n \n error: aborting due to previous error\n "}, {"sha": "46188636475db0362549d659208bef75878f060a", "filename": "src/test/ui/impl-trait/issue-55872-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -8,12 +8,12 @@ pub trait Bar {\n \n impl<S: Default> Bar for S {\n     type E = impl Copy;\n-    //~^ ERROR the trait bound `S: Copy` is not satisfied in `(S, T)` [E0277]\n-    //~^^ ERROR the trait bound `T: Copy` is not satisfied in `(S, T)` [E0277]\n \n     fn foo<T: Default>() -> Self::E {\n         //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n         //~| ERROR impl has stricter requirements than trait\n+        //~| ERROR the trait bound `S: Copy` is not satisfied in `(S, T)` [E0277]\n+        //~| ERROR the trait bound `T: Copy` is not satisfied in `(S, T)` [E0277]\n         (S::default(), T::default())\n     }\n }"}, {"sha": "56f5bff939fb7211e6bb511d8bf9defddf64ddfd", "filename": "src/test/ui/impl-trait/issue-55872-1.stderr", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -1,5 +1,5 @@\n error[E0276]: impl has stricter requirements than trait\n-  --> $DIR/issue-55872-1.rs:14:5\n+  --> $DIR/issue-55872-1.rs:12:5\n    |\n LL |     fn foo<T>() -> Self::E;\n    |     ----------------------- definition of `foo` from trait\n@@ -8,10 +8,10 @@ LL |     fn foo<T: Default>() -> Self::E {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `T: Default`\n \n error[E0277]: the trait bound `S: Copy` is not satisfied in `(S, T)`\n-  --> $DIR/issue-55872-1.rs:10:14\n+  --> $DIR/issue-55872-1.rs:12:29\n    |\n-LL |     type E = impl Copy;\n-   |              ^^^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `S`\n+LL |     fn foo<T: Default>() -> Self::E {\n+   |                             ^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `S`\n    |\n    = note: required because it appears within the type `(S, T)`\n help: consider further restricting this bound\n@@ -20,10 +20,10 @@ LL | impl<S: Default + std::marker::Copy> Bar for S {\n    |                 ^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `T: Copy` is not satisfied in `(S, T)`\n-  --> $DIR/issue-55872-1.rs:10:14\n+  --> $DIR/issue-55872-1.rs:12:29\n    |\n-LL |     type E = impl Copy;\n-   |              ^^^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `T`\n+LL |     fn foo<T: Default>() -> Self::E {\n+   |                             ^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `T`\n    |\n    = note: required because it appears within the type `(S, T)`\n help: consider further restricting this bound\n@@ -32,12 +32,14 @@ LL |     fn foo<T: Default + std::marker::Copy>() -> Self::E {\n    |                       ^^^^^^^^^^^^^^^^^^^\n \n error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-55872-1.rs:14:37\n+  --> $DIR/issue-55872-1.rs:12:37\n    |\n LL |       fn foo<T: Default>() -> Self::E {\n    |  _____________________________________^\n LL | |\n LL | |\n+LL | |\n+LL | |\n LL | |         (S::default(), T::default())\n LL | |     }\n    | |_____^"}, {"sha": "9546d01ac5c6895ea2c0560ab2bf255f94dff540", "filename": "src/test/ui/impl-trait/issue-55872-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -11,9 +11,9 @@ pub trait Bar {\n \n impl<S> Bar for S {\n     type E = impl std::marker::Copy;\n-    //~^ ERROR the trait bound `impl Future: Copy` is not satisfied [E0277]\n     fn foo<T>() -> Self::E {\n         //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n+        //~| ERROR the trait bound `impl Future: Copy` is not satisfied [E0277]\n         async {}\n     }\n }"}, {"sha": "31b8fbd299c51ea9087e988a24a02940feb05aa1", "filename": "src/test/ui/impl-trait/issue-55872-2.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -1,15 +1,16 @@\n error[E0277]: the trait bound `impl Future: Copy` is not satisfied\n-  --> $DIR/issue-55872-2.rs:13:14\n+  --> $DIR/issue-55872-2.rs:14:20\n    |\n-LL |     type E = impl std::marker::Copy;\n-   |              ^^^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `impl Future`\n+LL |     fn foo<T>() -> Self::E {\n+   |                    ^^^^^^^ the trait `Copy` is not implemented for `impl Future`\n \n error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-55872-2.rs:15:28\n+  --> $DIR/issue-55872-2.rs:14:28\n    |\n LL |       fn foo<T>() -> Self::E {\n    |  ____________________________^\n LL | |\n+LL | |\n LL | |         async {}\n LL | |     }\n    | |_____^"}, {"sha": "f4e1de8e50f688399b52757f244d6c5200f17405", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -19,7 +19,7 @@ LL | type WrongGeneric<T> = impl 'static;\n            found opaque type `impl Sized`\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:13:30\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:12:30\n    |\n LL | fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n    |                              ^^^^^^^^^^^^^^^"}, {"sha": "78d25e30e0382eba41de11a042664471784ca8a2", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -7,9 +7,9 @@ fn main() {\n }\n \n type WrongGeneric<T> = impl 'static;\n-//~^ ERROR the parameter type `T` may not live long enough\n-//~| ERROR: at least one trait must be specified\n+//~^ ERROR: at least one trait must be specified\n \n fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n+    //~^ ERROR the parameter type `T` may not live long enough\n     t\n }"}, {"sha": "568784372e5191db73218523175ccec67dafc72c", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -19,13 +19,12 @@ LL | type WrongGeneric<T> = impl 'static;\n            found opaque type `impl Sized`\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:9:24\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:12:30\n    |\n-LL | type WrongGeneric<T> = impl 'static;\n-   |                        ^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n-...\n LL | fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n-   |                  - help: consider adding an explicit lifetime bound...: `T: 'static`\n+   |                  -           ^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |                  |\n+   |                  help: consider adding an explicit lifetime bound...: `T: 'static`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "8c9cb742fac91f12814c64af1ed4806180b25a04", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.nll.stderr", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -10,29 +10,5 @@ error: higher-ranked subtype error\n LL |         |x| x\n    |         ^^^^^\n \n-error[E0308]: mismatched types\n-  --> $DIR/issue-57611-trait-alias.rs:17:16\n-   |\n-LL |     type Bar = impl Baz<Self, Self>;\n-   |                ^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n-   |\n-   = note: expected type `for<'r> Fn<(&'r X,)>`\n-              found type `Fn<(&'static X,)>`\n-note: this closure does not fulfill the lifetime requirements\n-  --> $DIR/issue-57611-trait-alias.rs:21:9\n-   |\n-LL |         |x| x\n-   |         ^^^^^\n-\n-error: implementation of `FnOnce` is not general enough\n-  --> $DIR/issue-57611-trait-alias.rs:17:16\n-   |\n-LL |     type Bar = impl Baz<Self, Self>;\n-   |                ^^^^^^^^^^^^^^^^^^^^ implementation of `FnOnce` is not general enough\n-   |\n-   = note: closure with signature `fn(&'static X) -> &'static X` must implement `FnOnce<(&'0 X,)>`, for any lifetime `'0`...\n-   = note: ...but it actually implements `FnOnce<(&'static X,)>`\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "625e46b6bc0122b4ed5e1d74367e150e5e2595dc", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -15,9 +15,9 @@ struct X;\n \n impl Foo for X {\n     type Bar = impl Baz<Self, Self>;\n-    //~^ ERROR implementation of `FnOnce` is not general enough\n \n     fn bar(&self) -> Self::Bar {\n+        //~^ ERROR implementation of `FnOnce` is not general enough\n         |x| x\n     }\n }"}, {"sha": "54d237159d80b56fd0edb903825ec19682ab342e", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -1,8 +1,8 @@\n error: implementation of `FnOnce` is not general enough\n-  --> $DIR/issue-57611-trait-alias.rs:17:16\n+  --> $DIR/issue-57611-trait-alias.rs:19:22\n    |\n-LL |     type Bar = impl Baz<Self, Self>;\n-   |                ^^^^^^^^^^^^^^^^^^^^ implementation of `FnOnce` is not general enough\n+LL |     fn bar(&self) -> Self::Bar {\n+   |                      ^^^^^^^^^ implementation of `FnOnce` is not general enough\n    |\n    = note: closure with signature `fn(&'2 X) -> &X` must implement `FnOnce<(&'1 X,)>`, for any lifetime `'1`...\n    = note: ...but it actually implements `FnOnce<(&'2 X,)>`, for some specific lifetime `'2`"}, {"sha": "37a2f28ce074fed466fbb7dcb3f4b95ef7a0a7cd", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -8,10 +8,9 @@ trait Bug {\n \n impl Bug for &() {\n     type Item = impl Bug; //~ ERROR `impl Trait` in type aliases is unstable\n-    //~^ ERROR the trait bound `(): Bug` is not satisfied\n \n     const FUN: fn() -> Self::Item = || ();\n-    //~^ ERROR type alias impl trait is not permitted here\n+    //~^ ERROR the trait bound `(): Bug` is not satisfied\n }\n \n fn main() {}"}, {"sha": "1710e07644d647e3b698b4fe60fbf10997c44952", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.stderr", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -7,25 +7,16 @@ LL |     type Item = impl Bug;\n    = note: see issue #63063 <https://github.com/rust-lang/rust/issues/63063> for more information\n    = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n-error[E0658]: type alias impl trait is not permitted here\n-  --> $DIR/issue-60371.rs:13:40\n-   |\n-LL |     const FUN: fn() -> Self::Item = || ();\n-   |                                        ^\n-   |\n-   = note: see issue #63063 <https://github.com/rust-lang/rust/issues/63063> for more information\n-   = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n-\n error[E0277]: the trait bound `(): Bug` is not satisfied\n-  --> $DIR/issue-60371.rs:10:17\n+  --> $DIR/issue-60371.rs:12:40\n    |\n-LL |     type Item = impl Bug;\n-   |                 ^^^^^^^^ the trait `Bug` is not implemented for `()`\n+LL |     const FUN: fn() -> Self::Item = || ();\n+   |                                        ^ the trait `Bug` is not implemented for `()`\n    |\n    = help: the following implementations were found:\n              <&() as Bug>\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0277, E0658.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "875cce4df2390b0d9ad38d7c9d2bab320a5a6986", "filename": "src/test/ui/type-alias-impl-trait/issue-63279.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -2,10 +2,10 @@\n \n #![feature(type_alias_impl_trait)]\n \n-type Closure = impl FnOnce(); //~ ERROR: type mismatch resolving\n+type Closure = impl FnOnce();\n \n fn c() -> Closure {\n-    || -> Closure { || () }\n+    || -> Closure { || () } //~ ERROR: mismatched types\n }\n \n fn main() {}"}, {"sha": "5fde8c2ef1e1138e896cfa4d3b37d998a9cf3d24", "filename": "src/test/ui/type-alias-impl-trait/issue-63279.stderr", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -1,12 +1,17 @@\n-error[E0271]: type mismatch resolving `<[closure@$DIR/issue-63279.rs:8:5: 8:28] as FnOnce<()>>::Output == ()`\n-  --> $DIR/issue-63279.rs:5:16\n+error[E0308]: mismatched types\n+  --> $DIR/issue-63279.rs:8:5\n    |\n LL | type Closure = impl FnOnce();\n-   |                ^^^^^^^^^^^^^ expected `()`, found opaque type\n+   |                ------------- the found opaque type\n+...\n+LL |     || -> Closure { || () }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ expected closure, found a different closure\n    |\n-   = note: expected unit type `()`\n-            found opaque type `impl FnOnce<()>`\n+   = note: expected type `[closure@$DIR/issue-63279.rs:8:21: 8:26]`\n+           found closure `[closure@$DIR/issue-63279.rs:8:5: 8:28]`\n+   = note: no two closures, even if identical, have the same type\n+   = help: consider boxing your closure and/or using it as a trait object\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0271`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "72c22827f624bc039e2ca161767b7d7734f1daa0", "filename": "src/test/ui/type-alias-impl-trait/issue-65679-inst-opaque-ty-from-val-twice.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65679-inst-opaque-ty-from-val-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65679-inst-opaque-ty-from-val-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65679-inst-opaque-ty-from-val-twice.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -1,4 +1,5 @@\n // compile-flags: -Zsave-analysis\n+// check-pass\n \n #![feature(type_alias_impl_trait, rustc_attrs)]\n \n@@ -11,9 +12,7 @@ type T = impl Sized;\n \n fn take(_: fn() -> T) {}\n \n-#[rustc_error]\n fn main() {\n-    //~^ ERROR fatal error triggered by #[rustc_error]\n     take(|| {});\n     take(|| {});\n }"}, {"sha": "f3683f2bf96075822fe70b9e42ac9cd542fb994f", "filename": "src/test/ui/type-alias-impl-trait/issue-65679-inst-opaque-ty-from-val-twice.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/47b41b7788a6f85c749049062f1e4eed497cd894/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65679-inst-opaque-ty-from-val-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/47b41b7788a6f85c749049062f1e4eed497cd894/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65679-inst-opaque-ty-from-val-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65679-inst-opaque-ty-from-val-twice.stderr?ref=47b41b7788a6f85c749049062f1e4eed497cd894", "patch": "@@ -1,8 +0,0 @@\n-error: fatal error triggered by #[rustc_error]\n-  --> $DIR/issue-65679-inst-opaque-ty-from-val-twice.rs:15:1\n-   |\n-LL | fn main() {\n-   | ^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "ad641eaa00d38afa4721054eba06d8b81a1e86a2", "filename": "src/test/ui/type-alias-impl-trait/issue-74280.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -6,8 +6,7 @@ type Test = impl Copy;\n \n fn test() -> Test {\n     let y = || -> Test { () };\n-    //~^ ERROR: concrete type differs from previous defining opaque type use\n-    7\n+    7 //~ ERROR mismatched types\n }\n \n fn main() {}"}, {"sha": "f6b369dd8d51827d0ec572e925405673d318779a", "filename": "src/test/ui/type-alias-impl-trait/issue-74280.stderr", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.stderr?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -1,14 +1,9 @@\n-error: concrete type differs from previous defining opaque type use\n-  --> $DIR/issue-74280.rs:8:13\n+error[E0308]: mismatched types\n+  --> $DIR/issue-74280.rs:9:5\n    |\n-LL |     let y = || -> Test { () };\n-   |             ^^^^^^^^^^^^^^^^^ expected `i32`, got `()`\n-   |\n-note: previous use here\n-  --> $DIR/issue-74280.rs:7:1\n-   |\n-LL | fn test() -> Test {\n-   | ^^^^^^^^^^^^^^^^^\n+LL |     7\n+   |     ^ expected `()`, found integer\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "da845e86147b7ffb620f880936aae59069a2095f", "filename": "src/test/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -5,9 +5,9 @@\n #![feature(type_alias_impl_trait)]\n \n type X<A, B> = impl Into<&'static A>;\n-//~^ ERROR the trait bound `&'static B: From<&A>` is not satisfied\n \n fn f<A, B: 'static>(a: &'static A, b: B) -> (X<A, B>, X<B, A>) {\n+    //~^ ERROR the trait bound `&'static B: From<&A>` is not satisfied\n     (a, a)\n }\n "}, {"sha": "734f15a9283de9052516ccac0206f0992fb3076b", "filename": "src/test/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d488de82f30fd1dcb0220d57498638596622394e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr?ref=d488de82f30fd1dcb0220d57498638596622394e", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `&'static B: From<&A>` is not satisfied\n-  --> $DIR/multiple-def-uses-in-one-fn.rs:7:16\n+  --> $DIR/multiple-def-uses-in-one-fn.rs:9:45\n    |\n-LL | type X<A, B> = impl Into<&'static A>;\n-   |                ^^^^^^^^^^^^^^^^^^^^^ the trait `From<&A>` is not implemented for `&'static B`\n+LL | fn f<A, B: 'static>(a: &'static A, b: B) -> (X<A, B>, X<B, A>) {\n+   |                                             ^^^^^^^^^^^^^^^^^^ the trait `From<&A>` is not implemented for `&'static B`\n    |\n    = note: required because of the requirements on the impl of `Into<&'static B>` for `&A`\n help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement"}]}