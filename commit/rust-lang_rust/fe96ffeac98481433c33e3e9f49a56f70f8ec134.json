{"sha": "fe96ffeac98481433c33e3e9f49a56f70f8ec134", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlOTZmZmVhYzk4NDgxNDMzYzMzZTNlOWY0OWE1NmY3MGY4ZWMxMzQ=", "commit": {"author": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2019-03-05T16:50:33Z"}, "committer": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2019-03-05T23:45:08Z"}, "message": "move lint documentation into macro invocations", "tree": {"sha": "d8a1beb253175c96b4c4a7d38ae1603731546142", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8a1beb253175c96b4c4a7d38ae1603731546142"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe96ffeac98481433c33e3e9f49a56f70f8ec134", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQFKBAABCAA0FiEELriChyEaiMu0yCg7viIhAz7bw3QFAlx/CgQWHGFydXNzZWxs\nMTIzQGdtYWlsLmNvbQAKCRC+IiEDPtvDdOHkCACj+vVwtWstzF+CAOzbQovqnU5Y\nqh4n30yHUCLZcKqmTId1t13jbP7BZn3afrvbu7Ok9Cg8diaFv/Zmkp1QUQQIN2mj\nCD7kPZvpqRutjk5SDdd/rkrHwGLhkk4jyhHIJf1yFohbHQIED0L0IIM2G/S2oLkF\nVJvz/Iw74eKLSLcOqZUadjMxVJOTLs3QZ2GyM+mYgfQ/qpOu3PzIA1Ac266kwLkc\nVUOXmQSWrYWGqFYlI8BhqJWkm3vikQ7BosetPsQQZR8sa+HDjIoRjUoZALPjRcIE\nylT+6hmH7skpEFOc9H7lq4M4Y/r/Xq9X9Gu0sTE8eSuhsJahHpxVkiI6dqkE\n=FxA8\n-----END PGP SIGNATURE-----", "payload": "tree d8a1beb253175c96b4c4a7d38ae1603731546142\nparent a8f61e70a8c1c438658d0c30080fc3ce3be6c2df\nauthor Andy Russell <arussell123@gmail.com> 1551804633 -0500\ncommitter Andy Russell <arussell123@gmail.com> 1551829508 -0500\n\nmove lint documentation into macro invocations\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe96ffeac98481433c33e3e9f49a56f70f8ec134", "html_url": "https://github.com/rust-lang/rust/commit/fe96ffeac98481433c33e3e9f49a56f70f8ec134", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe96ffeac98481433c33e3e9f49a56f70f8ec134/comments", "author": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "committer": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8f61e70a8c1c438658d0c30080fc3ce3be6c2df", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8f61e70a8c1c438658d0c30080fc3ce3be6c2df", "html_url": "https://github.com/rust-lang/rust/commit/a8f61e70a8c1c438658d0c30080fc3ce3be6c2df"}], "stats": {"total": 10799, "additions": 5407, "deletions": 5392}, "files": [{"sha": "3efee458cdc07baa2a5f0b94e1669ebca8a65717", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -12,8 +12,9 @@ use walkdir::WalkDir;\n lazy_static! {\n     static ref DEC_CLIPPY_LINT_RE: Regex = Regex::new(\n         r#\"(?x)\n-        declare_clippy_lint!\\s*[\\{(]\\s*\n-        pub\\s+(?P<name>[A-Z_][A-Z_0-9]*)\\s*,\\s*\n+        declare_clippy_lint!\\s*[\\{(]\n+        (?:\\s+///.*)*\n+        \\s+pub\\s+(?P<name>[A-Z_][A-Z_0-9]*)\\s*,\\s*\n         (?P<cat>[a-z_]+)\\s*,\\s*\n         \"(?P<desc>(?:[^\"\\\\]+|\\\\(?s).(?-s))*)\"\\s*[})]\n     \"#\n@@ -22,7 +23,8 @@ lazy_static! {\n     static ref DEC_DEPRECATED_LINT_RE: Regex = Regex::new(\n         r#\"(?x)\n         declare_deprecated_lint!\\s*[{(]\\s*\n-        pub\\s+(?P<name>[A-Z_][A-Z_0-9]*)\\s*,\\s*\n+        (?:\\s+///.*)*\n+        \\s+pub\\s+(?P<name>[A-Z_][A-Z_0-9]*)\\s*,\\s*\n         \"(?P<desc>(?:[^\"\\\\]+|\\\\(?s).(?-s))*)\"\\s*[})]\n     \"#\n     )"}, {"sha": "28c536df0c54bb8037ce5ed44d990126c0d2009c", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -6,28 +6,28 @@ use std::f64::consts as f64;\n use syntax::ast::{FloatTy, Lit, LitKind};\n use syntax::symbol;\n \n-/// **What it does:** Checks for floating point literals that approximate\n-/// constants which are defined in\n-/// [`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants)\n-/// or\n-/// [`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants),\n-/// respectively, suggesting to use the predefined constant.\n-///\n-/// **Why is this bad?** Usually, the definition in the standard library is more\n-/// precise than what people come up with. If you find that your definition is\n-/// actually more precise, please [file a Rust\n-/// issue](https://github.com/rust-lang/rust/issues).\n-///\n-/// **Known problems:** If you happen to have a value that is within 1/8192 of a\n-/// known constant, but is not *and should not* be the same, this lint will\n-/// report your value anyway. We have not yet noticed any false positives in\n-/// code we tested clippy with (this includes servo), but YMMV.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = 3.14;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for floating point literals that approximate\n+    /// constants which are defined in\n+    /// [`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants)\n+    /// or\n+    /// [`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants),\n+    /// respectively, suggesting to use the predefined constant.\n+    ///\n+    /// **Why is this bad?** Usually, the definition in the standard library is more\n+    /// precise than what people come up with. If you find that your definition is\n+    /// actually more precise, please [file a Rust\n+    /// issue](https://github.com/rust-lang/rust/issues).\n+    ///\n+    /// **Known problems:** If you happen to have a value that is within 1/8192 of a\n+    /// known constant, but is not *and should not* be the same, this lint will\n+    /// report your value anyway. We have not yet noticed any false positives in\n+    /// code we tested clippy with (this includes servo), but YMMV.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = 3.14;\n+    /// ```\n     pub APPROX_CONSTANT,\n     correctness,\n     \"the approximate of a known float constant (in `std::fXX::consts`)\""}, {"sha": "416ec656e12a44bb5d1729f15e2c413c46ddb176", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,36 +5,36 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for plain integer arithmetic.\n-///\n-/// **Why is this bad?** This is only checked against overflow in debug builds.\n-/// In some applications one wants explicitly checked, wrapping or saturating\n-/// arithmetic.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// a + 1\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for plain integer arithmetic.\n+    ///\n+    /// **Why is this bad?** This is only checked against overflow in debug builds.\n+    /// In some applications one wants explicitly checked, wrapping or saturating\n+    /// arithmetic.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// a + 1\n+    /// ```\n     pub INTEGER_ARITHMETIC,\n     restriction,\n     \"any integer arithmetic statement\"\n }\n \n-/// **What it does:** Checks for float arithmetic.\n-///\n-/// **Why is this bad?** For some embedded systems or kernel development, it\n-/// can be useful to rule out floating-point numbers.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// a + 1.0\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for float arithmetic.\n+    ///\n+    /// **Why is this bad?** For some embedded systems or kernel development, it\n+    /// can be useful to rule out floating-point numbers.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// a + 1.0\n+    /// ```\n     pub FLOAT_ARITHMETIC,\n     restriction,\n     \"any floating-point arithmetic statement\""}, {"sha": "54ef63160db0d2403df0543ec1a7384c5baae704", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -6,23 +6,23 @@ use crate::syntax::ast::LitKind;\n use crate::utils::{in_macro, is_direct_expn_of, span_help_and_lint};\n use if_chain::if_chain;\n \n-/// **What it does:** Check to call assert!(true/false)\n-///\n-/// **Why is this bad?** Will be optimized out by the compiler or should probably be replaced by a\n-/// panic!() or unreachable!()\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// assert!(false)\n-/// // or\n-/// assert!(true)\n-/// // or\n-/// const B: bool = false;\n-/// assert!(B)\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Check to call assert!(true/false)\n+    ///\n+    /// **Why is this bad?** Will be optimized out by the compiler or should probably be replaced by a\n+    /// panic!() or unreachable!()\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// assert!(false)\n+    /// // or\n+    /// assert!(true)\n+    /// // or\n+    /// const B: bool = false;\n+    /// assert!(B)\n+    /// ```\n     pub ASSERTIONS_ON_CONSTANTS,\n     style,\n     \"assert!(true/false) will be optimized out by the compiler/should probably be replaced by a panic!() or unreachable!()\""}, {"sha": "bfa35d4381ae10c39808fecfeab2c76e1962e130", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -7,43 +7,43 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for `a = a op b` or `a = b commutative_op a`\n-/// patterns.\n-///\n-/// **Why is this bad?** These can be written as the shorter `a op= b`.\n-///\n-/// **Known problems:** While forbidden by the spec, `OpAssign` traits may have\n-/// implementations that differ from the regular `Op` impl.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let mut a = 5;\n-/// ...\n-/// a = a + b;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `a = a op b` or `a = b commutative_op a`\n+    /// patterns.\n+    ///\n+    /// **Why is this bad?** These can be written as the shorter `a op= b`.\n+    ///\n+    /// **Known problems:** While forbidden by the spec, `OpAssign` traits may have\n+    /// implementations that differ from the regular `Op` impl.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut a = 5;\n+    /// ...\n+    /// a = a + b;\n+    /// ```\n     pub ASSIGN_OP_PATTERN,\n     style,\n     \"assigning the result of an operation on a variable to that same variable\"\n }\n \n-/// **What it does:** Checks for `a op= a op b` or `a op= b op a` patterns.\n-///\n-/// **Why is this bad?** Most likely these are bugs where one meant to write `a\n-/// op= b`.\n-///\n-/// **Known problems:** Clippy cannot know for sure if `a op= a op b` should have\n-/// been `a = a op a op b` or `a = a op b`/`a op= b`. Therefore it suggests both.\n-/// If `a op= a op b` is really the correct behaviour it should be\n-/// written as `a = a op a op b` as it's less confusing.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let mut a = 5;\n-/// ...\n-/// a += a + b;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `a op= a op b` or `a op= b op a` patterns.\n+    ///\n+    /// **Why is this bad?** Most likely these are bugs where one meant to write `a\n+    /// op= b`.\n+    ///\n+    /// **Known problems:** Clippy cannot know for sure if `a op= a op b` should have\n+    /// been `a = a op a op b` or `a = a op b`/`a op= b`. Therefore it suggests both.\n+    /// If `a op= a op b` is really the correct behaviour it should be\n+    /// written as `a = a op a op b` as it's less confusing.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut a = 5;\n+    /// ...\n+    /// a += a + b;\n+    /// ```\n     pub MISREFACTORED_ASSIGN_OP,\n     complexity,\n     \"having a variable on both sides of an assign op\""}, {"sha": "205b11b3b91a82c586947ea820415d491469343d", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 133, "deletions": 133, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -17,170 +17,170 @@ use semver::Version;\n use syntax::ast::{AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for items annotated with `#[inline(always)]`,\n-/// unless the annotated function is empty or simply panics.\n-///\n-/// **Why is this bad?** While there are valid uses of this annotation (and once\n-/// you know when to use it, by all means `allow` this lint), it's a common\n-/// newbie-mistake to pepper one's code with it.\n-///\n-/// As a rule of thumb, before slapping `#[inline(always)]` on a function,\n-/// measure if that additional function call really affects your runtime profile\n-/// sufficiently to make up for the increase in compile time.\n-///\n-/// **Known problems:** False positives, big time. This lint is meant to be\n-/// deactivated by everyone doing serious performance work. This means having\n-/// done the measurement.\n-///\n-/// **Example:**\n-/// ```rust\n-/// #[inline(always)]\n-/// fn not_quite_hot_code(..) { ... }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for items annotated with `#[inline(always)]`,\n+    /// unless the annotated function is empty or simply panics.\n+    ///\n+    /// **Why is this bad?** While there are valid uses of this annotation (and once\n+    /// you know when to use it, by all means `allow` this lint), it's a common\n+    /// newbie-mistake to pepper one's code with it.\n+    ///\n+    /// As a rule of thumb, before slapping `#[inline(always)]` on a function,\n+    /// measure if that additional function call really affects your runtime profile\n+    /// sufficiently to make up for the increase in compile time.\n+    ///\n+    /// **Known problems:** False positives, big time. This lint is meant to be\n+    /// deactivated by everyone doing serious performance work. This means having\n+    /// done the measurement.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// #[inline(always)]\n+    /// fn not_quite_hot_code(..) { ... }\n+    /// ```\n     pub INLINE_ALWAYS,\n     pedantic,\n     \"use of `#[inline(always)]`\"\n }\n \n-/// **What it does:** Checks for `extern crate` and `use` items annotated with\n-/// lint attributes.\n-///\n-/// This lint whitelists `#[allow(unused_imports)]` and `#[allow(deprecated)]` on\n-/// `use` items and `#[allow(unused_imports)]` on `extern crate` items with a\n-/// `#[macro_use]` attribute.\n-///\n-/// **Why is this bad?** Lint attributes have no effect on crate imports. Most\n-/// likely a `!` was forgotten.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// // Bad\n-/// #[deny(dead_code)]\n-/// extern crate foo;\n-/// #[forbid(dead_code)]\n-/// use foo::bar;\n-///\n-/// // Ok\n-/// #[allow(unused_imports)]\n-/// use foo::baz;\n-/// #[allow(unused_imports)]\n-/// #[macro_use]\n-/// extern crate baz;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `extern crate` and `use` items annotated with\n+    /// lint attributes.\n+    ///\n+    /// This lint whitelists `#[allow(unused_imports)]` and `#[allow(deprecated)]` on\n+    /// `use` items and `#[allow(unused_imports)]` on `extern crate` items with a\n+    /// `#[macro_use]` attribute.\n+    ///\n+    /// **Why is this bad?** Lint attributes have no effect on crate imports. Most\n+    /// likely a `!` was forgotten.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // Bad\n+    /// #[deny(dead_code)]\n+    /// extern crate foo;\n+    /// #[forbid(dead_code)]\n+    /// use foo::bar;\n+    ///\n+    /// // Ok\n+    /// #[allow(unused_imports)]\n+    /// use foo::baz;\n+    /// #[allow(unused_imports)]\n+    /// #[macro_use]\n+    /// extern crate baz;\n+    /// ```\n     pub USELESS_ATTRIBUTE,\n     correctness,\n     \"use of lint attributes on `extern crate` items\"\n }\n \n-/// **What it does:** Checks for `#[deprecated]` annotations with a `since`\n-/// field that is not a valid semantic version.\n-///\n-/// **Why is this bad?** For checking the version of the deprecation, it must be\n-/// a valid semver. Failing that, the contained information is useless.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// #[deprecated(since = \"forever\")]\n-/// fn something_else(..) { ... }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `#[deprecated]` annotations with a `since`\n+    /// field that is not a valid semantic version.\n+    ///\n+    /// **Why is this bad?** For checking the version of the deprecation, it must be\n+    /// a valid semver. Failing that, the contained information is useless.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// #[deprecated(since = \"forever\")]\n+    /// fn something_else(..) { ... }\n+    /// ```\n     pub DEPRECATED_SEMVER,\n     correctness,\n     \"use of `#[deprecated(since = \\\"x\\\")]` where x is not semver\"\n }\n \n-/// **What it does:** Checks for empty lines after outer attributes\n-///\n-/// **Why is this bad?**\n-/// Most likely the attribute was meant to be an inner attribute using a '!'.\n-/// If it was meant to be an outer attribute, then the following item\n-/// should not be separated by empty lines.\n-///\n-/// **Known problems:** Can cause false positives.\n-///\n-/// From the clippy side it's difficult to detect empty lines between an attributes and the\n-/// following item because empty lines and comments are not part of the AST. The parsing\n-/// currently works for basic cases but is not perfect.\n-///\n-/// **Example:**\n-/// ```rust\n-/// // Bad\n-/// #[inline(always)]\n-///\n-/// fn not_quite_good_code(..) { ... }\n-///\n-/// // Good (as inner attribute)\n-/// #![inline(always)]\n-///\n-/// fn this_is_fine(..) { ... }\n-///\n-/// // Good (as outer attribute)\n-/// #[inline(always)]\n-/// fn this_is_fine_too(..) { ... }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for empty lines after outer attributes\n+    ///\n+    /// **Why is this bad?**\n+    /// Most likely the attribute was meant to be an inner attribute using a '!'.\n+    /// If it was meant to be an outer attribute, then the following item\n+    /// should not be separated by empty lines.\n+    ///\n+    /// **Known problems:** Can cause false positives.\n+    ///\n+    /// From the clippy side it's difficult to detect empty lines between an attributes and the\n+    /// following item because empty lines and comments are not part of the AST. The parsing\n+    /// currently works for basic cases but is not perfect.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // Bad\n+    /// #[inline(always)]\n+    ///\n+    /// fn not_quite_good_code(..) { ... }\n+    ///\n+    /// // Good (as inner attribute)\n+    /// #![inline(always)]\n+    ///\n+    /// fn this_is_fine(..) { ... }\n+    ///\n+    /// // Good (as outer attribute)\n+    /// #[inline(always)]\n+    /// fn this_is_fine_too(..) { ... }\n+    /// ```\n     pub EMPTY_LINE_AFTER_OUTER_ATTR,\n     nursery,\n     \"empty line after outer attribute\"\n }\n \n-/// **What it does:** Checks for `allow`/`warn`/`deny`/`forbid` attributes with scoped clippy\n-/// lints and if those lints exist in clippy. If there is a uppercase letter in the lint name\n-/// (not the tool name) and a lowercase version of this lint exists, it will suggest to lowercase\n-/// the lint name.\n-///\n-/// **Why is this bad?** A lint attribute with a mistyped lint name won't have an effect.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// Bad:\n-/// ```rust\n-/// #![warn(if_not_els)]\n-/// #![deny(clippy::All)]\n-/// ```\n-///\n-/// Good:\n-/// ```rust\n-/// #![warn(if_not_else)]\n-/// #![deny(clippy::all)]\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `allow`/`warn`/`deny`/`forbid` attributes with scoped clippy\n+    /// lints and if those lints exist in clippy. If there is a uppercase letter in the lint name\n+    /// (not the tool name) and a lowercase version of this lint exists, it will suggest to lowercase\n+    /// the lint name.\n+    ///\n+    /// **Why is this bad?** A lint attribute with a mistyped lint name won't have an effect.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// Bad:\n+    /// ```rust\n+    /// #![warn(if_not_els)]\n+    /// #![deny(clippy::All)]\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust\n+    /// #![warn(if_not_else)]\n+    /// #![deny(clippy::all)]\n+    /// ```\n     pub UNKNOWN_CLIPPY_LINTS,\n     style,\n     \"unknown_lints for scoped Clippy lints\"\n }\n \n-/// **What it does:** Checks for `#[cfg_attr(rustfmt, rustfmt_skip)]` and suggests to replace it\n-/// with `#[rustfmt::skip]`.\n-///\n-/// **Why is this bad?** Since tool_attributes ([rust-lang/rust#44690](https://github.com/rust-lang/rust/issues/44690))\n-/// are stable now, they should be used instead of the old `cfg_attr(rustfmt)` attributes.\n-///\n-/// **Known problems:** This lint doesn't detect crate level inner attributes, because they get\n-/// processed before the PreExpansionPass lints get executed. See\n-/// [#3123](https://github.com/rust-lang/rust-clippy/pull/3123#issuecomment-422321765)\n-///\n-/// **Example:**\n-///\n-/// Bad:\n-/// ```rust\n-/// #[cfg_attr(rustfmt, rustfmt_skip)]\n-/// fn main() { }\n-/// ```\n-///\n-/// Good:\n-/// ```rust\n-/// #[rustfmt::skip]\n-/// fn main() { }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `#[cfg_attr(rustfmt, rustfmt_skip)]` and suggests to replace it\n+    /// with `#[rustfmt::skip]`.\n+    ///\n+    /// **Why is this bad?** Since tool_attributes ([rust-lang/rust#44690](https://github.com/rust-lang/rust/issues/44690))\n+    /// are stable now, they should be used instead of the old `cfg_attr(rustfmt)` attributes.\n+    ///\n+    /// **Known problems:** This lint doesn't detect crate level inner attributes, because they get\n+    /// processed before the PreExpansionPass lints get executed. See\n+    /// [#3123](https://github.com/rust-lang/rust-clippy/pull/3123#issuecomment-422321765)\n+    ///\n+    /// **Example:**\n+    ///\n+    /// Bad:\n+    /// ```rust\n+    /// #[cfg_attr(rustfmt, rustfmt_skip)]\n+    /// fn main() { }\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust\n+    /// #[rustfmt::skip]\n+    /// fn main() { }\n+    /// ```\n     pub DEPRECATED_CFG_ATTR,\n     complexity,\n     \"usage of `cfg_attr(rustfmt)` instead of `tool_attributes`\""}, {"sha": "7c5d2495952eb4be90dfc5bf7d30ee026919c0b3", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -9,83 +9,83 @@ use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for incompatible bit masks in comparisons.\n-///\n-/// The formula for detecting if an expression of the type `_ <bit_op> m\n-/// <cmp_op> c` (where `<bit_op>` is one of {`&`, `|`} and `<cmp_op>` is one of\n-/// {`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following\n-/// table:\n-///\n-/// |Comparison  |Bit Op|Example     |is always|Formula               |\n-/// |------------|------|------------|---------|----------------------|\n-/// |`==` or `!=`| `&`  |`x & 2 == 3`|`false`  |`c & m != c`          |\n-/// |`<`  or `>=`| `&`  |`x & 2 < 3` |`true`   |`m < c`               |\n-/// |`>`  or `<=`| `&`  |`x & 1 > 1` |`false`  |`m <= c`              |\n-/// |`==` or `!=`| `|`  |`x | 1 == 0`|`false`  |`c | m != c`          |\n-/// |`<`  or `>=`| `|`  |`x | 1 < 1` |`false`  |`m >= c`              |\n-/// |`<=` or `>` | `|`  |`x | 1 > 0` |`true`   |`m > c`               |\n-///\n-/// **Why is this bad?** If the bits that the comparison cares about are always\n-/// set to zero or one by the bit mask, the comparison is constant `true` or\n-/// `false` (depending on mask, compared value, and operators).\n-///\n-/// So the code is actively misleading, and the only reason someone would write\n-/// this intentionally is to win an underhanded Rust contest or create a\n-/// test-case for this lint.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if (x & 1 == 2) { \u2026 }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for incompatible bit masks in comparisons.\n+    ///\n+    /// The formula for detecting if an expression of the type `_ <bit_op> m\n+    /// <cmp_op> c` (where `<bit_op>` is one of {`&`, `|`} and `<cmp_op>` is one of\n+    /// {`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following\n+    /// table:\n+    ///\n+    /// |Comparison  |Bit Op|Example     |is always|Formula               |\n+    /// |------------|------|------------|---------|----------------------|\n+    /// |`==` or `!=`| `&`  |`x & 2 == 3`|`false`  |`c & m != c`          |\n+    /// |`<`  or `>=`| `&`  |`x & 2 < 3` |`true`   |`m < c`               |\n+    /// |`>`  or `<=`| `&`  |`x & 1 > 1` |`false`  |`m <= c`              |\n+    /// |`==` or `!=`| `|`  |`x | 1 == 0`|`false`  |`c | m != c`          |\n+    /// |`<`  or `>=`| `|`  |`x | 1 < 1` |`false`  |`m >= c`              |\n+    /// |`<=` or `>` | `|`  |`x | 1 > 0` |`true`   |`m > c`               |\n+    ///\n+    /// **Why is this bad?** If the bits that the comparison cares about are always\n+    /// set to zero or one by the bit mask, the comparison is constant `true` or\n+    /// `false` (depending on mask, compared value, and operators).\n+    ///\n+    /// So the code is actively misleading, and the only reason someone would write\n+    /// this intentionally is to win an underhanded Rust contest or create a\n+    /// test-case for this lint.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if (x & 1 == 2) { \u2026 }\n+    /// ```\n     pub BAD_BIT_MASK,\n     correctness,\n     \"expressions of the form `_ & mask == select` that will only ever return `true` or `false`\"\n }\n \n-/// **What it does:** Checks for bit masks in comparisons which can be removed\n-/// without changing the outcome. The basic structure can be seen in the\n-/// following table:\n-///\n-/// |Comparison| Bit Op  |Example    |equals |\n-/// |----------|---------|-----------|-------|\n-/// |`>` / `<=`|`|` / `^`|`x | 2 > 3`|`x > 3`|\n-/// |`<` / `>=`|`|` / `^`|`x ^ 1 < 4`|`x < 4`|\n-///\n-/// **Why is this bad?** Not equally evil as [`bad_bit_mask`](#bad_bit_mask),\n-/// but still a bit misleading, because the bit mask is ineffective.\n-///\n-/// **Known problems:** False negatives: This lint will only match instances\n-/// where we have figured out the math (which is for a power-of-two compared\n-/// value). This means things like `x | 1 >= 7` (which would be better written\n-/// as `x >= 6`) will not be reported (but bit masks like this are fairly\n-/// uncommon).\n-///\n-/// **Example:**\n-/// ```rust\n-/// if (x | 1 > 3) { \u2026 }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for bit masks in comparisons which can be removed\n+    /// without changing the outcome. The basic structure can be seen in the\n+    /// following table:\n+    ///\n+    /// |Comparison| Bit Op  |Example    |equals |\n+    /// |----------|---------|-----------|-------|\n+    /// |`>` / `<=`|`|` / `^`|`x | 2 > 3`|`x > 3`|\n+    /// |`<` / `>=`|`|` / `^`|`x ^ 1 < 4`|`x < 4`|\n+    ///\n+    /// **Why is this bad?** Not equally evil as [`bad_bit_mask`](#bad_bit_mask),\n+    /// but still a bit misleading, because the bit mask is ineffective.\n+    ///\n+    /// **Known problems:** False negatives: This lint will only match instances\n+    /// where we have figured out the math (which is for a power-of-two compared\n+    /// value). This means things like `x | 1 >= 7` (which would be better written\n+    /// as `x >= 6`) will not be reported (but bit masks like this are fairly\n+    /// uncommon).\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if (x | 1 > 3) { \u2026 }\n+    /// ```\n     pub INEFFECTIVE_BIT_MASK,\n     correctness,\n     \"expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\"\n }\n \n-/// **What it does:** Checks for bit masks that can be replaced by a call\n-/// to `trailing_zeros`\n-///\n-/// **Why is this bad?** `x.trailing_zeros() > 4` is much clearer than `x & 15\n-/// == 0`\n-///\n-/// **Known problems:** llvm generates better code for `x & 15 == 0` on x86\n-///\n-/// **Example:**\n-/// ```rust\n-/// x & 0x1111 == 0\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for bit masks that can be replaced by a call\n+    /// to `trailing_zeros`\n+    ///\n+    /// **Why is this bad?** `x.trailing_zeros() > 4` is much clearer than `x & 15\n+    /// == 0`\n+    ///\n+    /// **Known problems:** llvm generates better code for `x & 15 == 0` on x86\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x & 0x1111 == 0\n+    /// ```\n     pub VERBOSE_BIT_MASK,\n     style,\n     \"expressions where a bit mask is less readable than the corresponding method call\""}, {"sha": "c1ee4d528854609648067f967a03892e511ab06d", "filename": "clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -4,19 +4,19 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_data_structures::fx::FxHashSet;\n \n-/// **What it does:** Checks for usage of blacklisted names for variables, such\n-/// as `foo`.\n-///\n-/// **Why is this bad?** These names are usually placeholder names and should be\n-/// avoided.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let foo = 3.14;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of blacklisted names for variables, such\n+    /// as `foo`.\n+    ///\n+    /// **Why is this bad?** These names are usually placeholder names and should be\n+    /// avoided.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let foo = 3.14;\n+    /// ```\n     pub BLACKLISTED_NAME,\n     style,\n     \"usage of a blacklisted/placeholder name\""}, {"sha": "7c664866f59e91b521aaa4cec2d08cc993b99dc6", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,38 +5,38 @@ use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for `if` conditions that use blocks to contain an\n-/// expression.\n-///\n-/// **Why is this bad?** It isn't really Rust style, same as using parentheses\n-/// to contain expressions.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if { true } ..\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `if` conditions that use blocks to contain an\n+    /// expression.\n+    ///\n+    /// **Why is this bad?** It isn't really Rust style, same as using parentheses\n+    /// to contain expressions.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if { true } ..\n+    /// ```\n     pub BLOCK_IN_IF_CONDITION_EXPR,\n     style,\n     \"braces that can be eliminated in conditions, e.g. `if { true } ...`\"\n }\n \n-/// **What it does:** Checks for `if` conditions that use blocks containing\n-/// statements, or conditions that use closures with blocks.\n-///\n-/// **Why is this bad?** Using blocks in the condition makes it hard to read.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if { let x = somefunc(); x } ..\n-/// // or\n-/// if somefunc(|x| { x == 47 }) ..\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `if` conditions that use blocks containing\n+    /// statements, or conditions that use closures with blocks.\n+    ///\n+    /// **Why is this bad?** Using blocks in the condition makes it hard to read.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if { let x = somefunc(); x } ..\n+    /// // or\n+    /// if somefunc(|x| { x == 47 }) ..\n+    /// ```\n     pub BLOCK_IN_IF_CONDITION_STMT,\n     style,\n     \"complex blocks in conditions, e.g. `if { let x = true; x } ...`\""}, {"sha": "5d05caf3aa84b582f5779b5bc4abcc4fd1ff8f39", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -10,39 +10,39 @@ use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n use syntax::source_map::{dummy_spanned, Span, DUMMY_SP};\n \n-/// **What it does:** Checks for boolean expressions that can be written more\n-/// concisely.\n-///\n-/// **Why is this bad?** Readability of boolean expressions suffers from\n-/// unnecessary duplication.\n-///\n-/// **Known problems:** Ignores short circuiting behavior of `||` and\n-/// `&&`. Ignores `|`, `&` and `^`.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if a && true  // should be: if a\n-/// if !(a == b)  // should be: if a != b\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for boolean expressions that can be written more\n+    /// concisely.\n+    ///\n+    /// **Why is this bad?** Readability of boolean expressions suffers from\n+    /// unnecessary duplication.\n+    ///\n+    /// **Known problems:** Ignores short circuiting behavior of `||` and\n+    /// `&&`. Ignores `|`, `&` and `^`.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if a && true  // should be: if a\n+    /// if !(a == b)  // should be: if a != b\n+    /// ```\n     pub NONMINIMAL_BOOL,\n     complexity,\n     \"boolean expressions that can be written more concisely\"\n }\n \n-/// **What it does:** Checks for boolean expressions that contain terminals that\n-/// can be eliminated.\n-///\n-/// **Why is this bad?** This is most likely a logic bug.\n-///\n-/// **Known problems:** Ignores short circuiting behavior.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if a && b || a { ... }\n-/// ```\n-/// The `b` is unnecessary, the expression is equivalent to `if a`.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for boolean expressions that contain terminals that\n+    /// can be eliminated.\n+    ///\n+    /// **Why is this bad?** This is most likely a logic bug.\n+    ///\n+    /// **Known problems:** Ignores short circuiting behavior.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if a && b || a { ... }\n+    /// ```\n+    /// The `b` is unnecessary, the expression is equivalent to `if a`.\n     pub LOGIC_BUG,\n     correctness,\n     \"boolean expressions that contain terminals which can be eliminated\""}, {"sha": "9fd82ae5946b7af0dc37f00c9b28cb5ea9e1c4d1", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -10,22 +10,22 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::ast::{Name, UintTy};\n \n-/// **What it does:** Checks for naive byte counts\n-///\n-/// **Why is this bad?** The [`bytecount`](https://crates.io/crates/bytecount)\n-/// crate has methods to count your bytes faster, especially for large slices.\n-///\n-/// **Known problems:** If you have predominantly small slices, the\n-/// `bytecount::count(..)` method may actually be slower. However, if you can\n-/// ensure that less than 2\u00b3\u00b2-1 matches arise, the `naive_count_32(..)` can be\n-/// faster in those cases.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// &my_data.filter(|&x| x == 0u8).count() // use bytecount::count instead\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for naive byte counts\n+    ///\n+    /// **Why is this bad?** The [`bytecount`](https://crates.io/crates/bytecount)\n+    /// crate has methods to count your bytes faster, especially for large slices.\n+    ///\n+    /// **Known problems:** If you have predominantly small slices, the\n+    /// `bytecount::count(..)` method may actually be slower. However, if you can\n+    /// ensure that less than 2\u00b3\u00b2-1 matches arise, the `naive_count_32(..)` can be\n+    /// faster in those cases.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// &my_data.filter(|&x| x == 0u8).count() // use bytecount::count instead\n+    /// ```\n     pub NAIVE_BYTECOUNT,\n     perf,\n     \"use of naive `<slice>.filter(|&x| x == y).count()` to count byte values\""}, {"sha": "57bdce4cf3a9a2b0624c7c65cbc1b01a5fca05ce", "filename": "clippy_lints/src/cargo_common_metadata.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -7,28 +7,28 @@ use syntax::{ast::*, source_map::DUMMY_SP};\n \n use cargo_metadata;\n \n-/// **What it does:** Checks to see if all common metadata is defined in\n-/// `Cargo.toml`. See: https://rust-lang-nursery.github.io/api-guidelines/documentation.html#cargotoml-includes-all-common-metadata-c-metadata\n-///\n-/// **Why is this bad?** It will be more difficult for users to discover the\n-/// purpose of the crate, and key information related to it.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```toml\n-/// # This `Cargo.toml` is missing an authors field:\n-/// [package]\n-/// name = \"clippy\"\n-/// version = \"0.0.212\"\n-/// description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n-/// repository = \"https://github.com/rust-lang/rust-clippy\"\n-/// readme = \"README.md\"\n-/// license = \"MIT/Apache-2.0\"\n-/// keywords = [\"clippy\", \"lint\", \"plugin\"]\n-/// categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks to see if all common metadata is defined in\n+    /// `Cargo.toml`. See: https://rust-lang-nursery.github.io/api-guidelines/documentation.html#cargotoml-includes-all-common-metadata-c-metadata\n+    ///\n+    /// **Why is this bad?** It will be more difficult for users to discover the\n+    /// purpose of the crate, and key information related to it.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```toml\n+    /// # This `Cargo.toml` is missing an authors field:\n+    /// [package]\n+    /// name = \"clippy\"\n+    /// version = \"0.0.212\"\n+    /// description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n+    /// repository = \"https://github.com/rust-lang/rust-clippy\"\n+    /// readme = \"README.md\"\n+    /// license = \"MIT/Apache-2.0\"\n+    /// keywords = [\"clippy\", \"lint\", \"plugin\"]\n+    /// categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n+    /// ```\n     pub CARGO_COMMON_METADATA,\n     cargo,\n     \"common metadata is defined in `Cargo.toml`\""}, {"sha": "dd4934f909011d87ce45bcd53eb597bf785feb51", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -21,51 +21,51 @@ use crate::utils::sugg::Sugg;\n use crate::utils::{in_macro, snippet_block, snippet_block_with_applicability, span_lint_and_sugg, span_lint_and_then};\n use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for nested `if` statements which can be collapsed\n-/// by `&&`-combining their conditions and for `else { if ... }` expressions\n-/// that\n-/// can be collapsed to `else if ...`.\n-///\n-/// **Why is this bad?** Each `if`-statement adds one level of nesting, which\n-/// makes code look more complex than it really is.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// if x {\n-///     if y {\n-///         \u2026\n-///     }\n-/// }\n-///\n-/// // or\n-///\n-/// if x {\n-///     \u2026\n-/// } else {\n-///     if y {\n-///         \u2026\n-///     }\n-/// }\n-/// ```\n-///\n-/// Should be written:\n-///\n-/// ```rust.ignore\n-/// if x && y {\n-///     \u2026\n-/// }\n-///\n-/// // or\n-///\n-/// if x {\n-///     \u2026\n-/// } else if y {\n-///     \u2026\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for nested `if` statements which can be collapsed\n+    /// by `&&`-combining their conditions and for `else { if ... }` expressions\n+    /// that\n+    /// can be collapsed to `else if ...`.\n+    ///\n+    /// **Why is this bad?** Each `if`-statement adds one level of nesting, which\n+    /// makes code look more complex than it really is.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// if x {\n+    ///     if y {\n+    ///         \u2026\n+    ///     }\n+    /// }\n+    ///\n+    /// // or\n+    ///\n+    /// if x {\n+    ///     \u2026\n+    /// } else {\n+    ///     if y {\n+    ///         \u2026\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Should be written:\n+    ///\n+    /// ```rust.ignore\n+    /// if x && y {\n+    ///     \u2026\n+    /// }\n+    ///\n+    /// // or\n+    ///\n+    /// if x {\n+    ///     \u2026\n+    /// } else if y {\n+    ///     \u2026\n+    /// }\n+    /// ```\n     pub COLLAPSIBLE_IF,\n     style,\n     \"`if`s that can be collapsed (e.g. `if x { if y { ... } }` and `else { if x { ... } }`)\""}, {"sha": "e160008fa5588fd70ba1f1e23576f01f0d3f0aed", "filename": "clippy_lints/src/const_static_lifetime.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -4,23 +4,23 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::ast::*;\n \n-/// **What it does:** Checks for constants with an explicit `'static` lifetime.\n-///\n-/// **Why is this bad?** Adding `'static` to every reference can create very\n-/// complicated types.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// const FOO: &'static [(&'static str, &'static str, fn(&Bar) -> bool)] =\n-/// &[...]\n-/// ```\n-/// This code can be rewritten as\n-/// ```rust\n-///  const FOO: &[(&str, &str, fn(&Bar) -> bool)] = &[...]\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for constants with an explicit `'static` lifetime.\n+    ///\n+    /// **Why is this bad?** Adding `'static` to every reference can create very\n+    /// complicated types.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// const FOO: &'static [(&'static str, &'static str, fn(&Bar) -> bool)] =\n+    /// &[...]\n+    /// ```\n+    /// This code can be rewritten as\n+    /// ```rust\n+    ///  const FOO: &[(&str, &str, fn(&Bar) -> bool)] = &[...]\n+    /// ```\n     pub CONST_STATIC_LIFETIME,\n     style,\n     \"Using explicit `'static` lifetime for constants when elision rules would allow omitting them.\""}, {"sha": "60319045830832acff956829143209fbd8a6a385", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 75, "deletions": 75, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -10,94 +10,94 @@ use std::collections::hash_map::Entry;\n use std::hash::BuildHasherDefault;\n use syntax::symbol::LocalInternedString;\n \n-/// **What it does:** Checks for consecutive `if`s with the same condition.\n-///\n-/// **Why is this bad?** This is probably a copy & paste error.\n-///\n-/// **Known problems:** Hopefully none.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if a == b {\n-///     \u2026\n-/// } else if a == b {\n-///     \u2026\n-/// }\n-/// ```\n-///\n-/// Note that this lint ignores all conditions with a function call as it could\n-/// have side effects:\n-///\n-/// ```rust\n-/// if foo() {\n-///     \u2026\n-/// } else if foo() { // not linted\n-///     \u2026\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for consecutive `if`s with the same condition.\n+    ///\n+    /// **Why is this bad?** This is probably a copy & paste error.\n+    ///\n+    /// **Known problems:** Hopefully none.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if a == b {\n+    ///     \u2026\n+    /// } else if a == b {\n+    ///     \u2026\n+    /// }\n+    /// ```\n+    ///\n+    /// Note that this lint ignores all conditions with a function call as it could\n+    /// have side effects:\n+    ///\n+    /// ```rust\n+    /// if foo() {\n+    ///     \u2026\n+    /// } else if foo() { // not linted\n+    ///     \u2026\n+    /// }\n+    /// ```\n     pub IFS_SAME_COND,\n     correctness,\n     \"consecutive `ifs` with the same condition\"\n }\n \n-/// **What it does:** Checks for `if/else` with the same body as the *then* part\n-/// and the *else* part.\n-///\n-/// **Why is this bad?** This is probably a copy & paste error.\n-///\n-/// **Known problems:** Hopefully none.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let foo = if \u2026 {\n-///     42\n-/// } else {\n-///     42\n-/// };\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `if/else` with the same body as the *then* part\n+    /// and the *else* part.\n+    ///\n+    /// **Why is this bad?** This is probably a copy & paste error.\n+    ///\n+    /// **Known problems:** Hopefully none.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let foo = if \u2026 {\n+    ///     42\n+    /// } else {\n+    ///     42\n+    /// };\n+    /// ```\n     pub IF_SAME_THEN_ELSE,\n     correctness,\n     \"if with the same *then* and *else* blocks\"\n }\n \n-/// **What it does:** Checks for `match` with identical arm bodies.\n-///\n-/// **Why is this bad?** This is probably a copy & paste error. If arm bodies\n-/// are the same on purpose, you can factor them\n-/// [using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).\n-///\n-/// **Known problems:** False positive possible with order dependent `match`\n-/// (see issue\n-/// [#860](https://github.com/rust-lang/rust-clippy/issues/860)).\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// match foo {\n-///     Bar => bar(),\n-///     Quz => quz(),\n-///     Baz => bar(), // <= oops\n-/// }\n-/// ```\n-///\n-/// This should probably be\n-/// ```rust,ignore\n-/// match foo {\n-///     Bar => bar(),\n-///     Quz => quz(),\n-///     Baz => baz(), // <= fixed\n-/// }\n-/// ```\n-///\n-/// or if the original code was not a typo:\n-/// ```rust,ignore\n-/// match foo {\n-///     Bar | Baz => bar(), // <= shows the intent better\n-///     Quz => quz(),\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `match` with identical arm bodies.\n+    ///\n+    /// **Why is this bad?** This is probably a copy & paste error. If arm bodies\n+    /// are the same on purpose, you can factor them\n+    /// [using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).\n+    ///\n+    /// **Known problems:** False positive possible with order dependent `match`\n+    /// (see issue\n+    /// [#860](https://github.com/rust-lang/rust-clippy/issues/860)).\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar => bar(),\n+    ///     Quz => quz(),\n+    ///     Baz => bar(), // <= oops\n+    /// }\n+    /// ```\n+    ///\n+    /// This should probably be\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar => bar(),\n+    ///     Quz => quz(),\n+    ///     Baz => baz(), // <= fixed\n+    /// }\n+    /// ```\n+    ///\n+    /// or if the original code was not a typo:\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar | Baz => bar(), // <= shows the intent better\n+    ///     Quz => quz(),\n+    /// }\n+    /// ```\n     pub MATCH_SAME_ARMS,\n     pedantic,\n     \"`match` with identical arm bodies\""}, {"sha": "5c8d6def210fcdf9e7c7f749d4ae47598924b432", "filename": "clippy_lints/src/copy_iterator.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopy_iterator.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -3,27 +3,27 @@ use rustc::hir::{Item, ItemKind};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for types that implement `Copy` as well as\n-/// `Iterator`.\n-///\n-/// **Why is this bad?** Implicit copies can be confusing when working with\n-/// iterator combinators.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// #[derive(Copy, Clone)]\n-/// struct Countdown(u8);\n-///\n-/// impl Iterator for Countdown {\n-///     // ...\n-/// }\n-///\n-/// let a: Vec<_> = my_iterator.take(1).collect();\n-/// let b: Vec<_> = my_iterator.collect();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for types that implement `Copy` as well as\n+    /// `Iterator`.\n+    ///\n+    /// **Why is this bad?** Implicit copies can be confusing when working with\n+    /// iterator combinators.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// #[derive(Copy, Clone)]\n+    /// struct Countdown(u8);\n+    ///\n+    /// impl Iterator for Countdown {\n+    ///     // ...\n+    /// }\n+    ///\n+    /// let a: Vec<_> = my_iterator.take(1).collect();\n+    /// let b: Vec<_> = my_iterator.collect();\n+    /// ```\n     pub COPY_ITERATOR,\n     pedantic,\n     \"implementing `Iterator` on a `Copy` type\""}, {"sha": "fa046d8bb7b49a7fd21ce94f6ef121ab414997c6", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -11,16 +11,16 @@ use syntax::source_map::Span;\n \n use crate::utils::{in_macro, is_allowed, match_type, paths, span_help_and_lint, LimitStack};\n \n-/// **What it does:** Checks for methods with high cyclomatic complexity.\n-///\n-/// **Why is this bad?** Methods of high cyclomatic complexity tend to be badly\n-/// readable. Also LLVM will usually optimize small methods better.\n-///\n-/// **Known problems:** Sometimes it's hard to find a way to reduce the\n-/// complexity.\n-///\n-/// **Example:** No. You'll see it when you get the warning.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for methods with high cyclomatic complexity.\n+    ///\n+    /// **Why is this bad?** Methods of high cyclomatic complexity tend to be badly\n+    /// readable. Also LLVM will usually optimize small methods better.\n+    ///\n+    /// **Known problems:** Sometimes it's hard to find a way to reduce the\n+    /// complexity.\n+    ///\n+    /// **Example:** No. You'll see it when you get the warning.\n     pub CYCLOMATIC_COMPLEXITY,\n     complexity,\n     \"functions that should be split up into multiple functions\""}, {"sha": "8b71123ca55b767afee979b644ef503b21ac110f", "filename": "clippy_lints/src/dbg_macro.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fdbg_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fdbg_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdbg_macro.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -6,22 +6,22 @@ use syntax::ast;\n use syntax::source_map::Span;\n use syntax::tokenstream::TokenStream;\n \n-/// **What it does:** Checks for usage of dbg!() macro.\n-///\n-/// **Why is this bad?** `dbg!` macro is intended as a debugging tool. It\n-/// should not be in version control.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// // Bad\n-/// dbg!(true)\n-///\n-/// // Good\n-/// true\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of dbg!() macro.\n+    ///\n+    /// **Why is this bad?** `dbg!` macro is intended as a debugging tool. It\n+    /// should not be in version control.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// // Bad\n+    /// dbg!(true)\n+    ///\n+    /// // Good\n+    /// true\n+    /// ```\n     pub DBG_MACRO,\n     restriction,\n     \"`dbg!` macro is intended as a debugging tool\""}, {"sha": "3ced814adc31461666938cb49aae130df7207b95", "filename": "clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -7,22 +7,22 @@ use rustc_errors::Applicability;\n \n use crate::utils::{any_parent_is_automatically_derived, match_def_path, opt_def_id, paths, span_lint_and_sugg};\n \n-/// **What it does:** Checks for literal calls to `Default::default()`.\n-///\n-/// **Why is this bad?** It's more clear to the reader to use the name of the type whose default is\n-/// being gotten than the generic `Default`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// // Bad\n-/// let s: String = Default::default();\n-///\n-/// // Good\n-/// let s = String::default();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for literal calls to `Default::default()`.\n+    ///\n+    /// **Why is this bad?** It's more clear to the reader to use the name of the type whose default is\n+    /// being gotten than the generic `Default`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // Bad\n+    /// let s: String = Default::default();\n+    ///\n+    /// // Good\n+    /// let s = String::default();\n+    /// ```\n     pub DEFAULT_TRAIT_ACCESS,\n     pedantic,\n     \"checks for literal calls to Default::default()\""}, {"sha": "a00f7cfe2631c8ac0d7884d7e526b77dc0f909cc", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -7,56 +7,56 @@ use rustc::ty::{self, Ty};\n use rustc::{declare_tool_lint, lint_array};\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for deriving `Hash` but implementing `PartialEq`\n-/// explicitly or vice versa.\n-///\n-/// **Why is this bad?** The implementation of these traits must agree (for\n-/// example for use with `HashMap`) so it\u2019s probably a bad idea to use a\n-/// default-generated `Hash` implementation with an explicitly defined\n-/// `PartialEq`. In particular, the following must hold for any type:\n-///\n-/// ```rust\n-/// k1 == k2 \u21d2 hash(k1) == hash(k2)\n-/// ```\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// #[derive(Hash)]\n-/// struct Foo;\n-///\n-/// impl PartialEq for Foo {\n-///     ...\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for deriving `Hash` but implementing `PartialEq`\n+    /// explicitly or vice versa.\n+    ///\n+    /// **Why is this bad?** The implementation of these traits must agree (for\n+    /// example for use with `HashMap`) so it\u2019s probably a bad idea to use a\n+    /// default-generated `Hash` implementation with an explicitly defined\n+    /// `PartialEq`. In particular, the following must hold for any type:\n+    ///\n+    /// ```rust\n+    /// k1 == k2 \u21d2 hash(k1) == hash(k2)\n+    /// ```\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// #[derive(Hash)]\n+    /// struct Foo;\n+    ///\n+    /// impl PartialEq for Foo {\n+    ///     ...\n+    /// }\n+    /// ```\n     pub DERIVE_HASH_XOR_EQ,\n     correctness,\n     \"deriving `Hash` but implementing `PartialEq` explicitly\"\n }\n \n-/// **What it does:** Checks for explicit `Clone` implementations for `Copy`\n-/// types.\n-///\n-/// **Why is this bad?** To avoid surprising behaviour, these traits should\n-/// agree and the behaviour of `Copy` cannot be overridden. In almost all\n-/// situations a `Copy` type should have a `Clone` implementation that does\n-/// nothing more than copy the object, which is what `#[derive(Copy, Clone)]`\n-/// gets you.\n-///\n-/// **Known problems:** Bounds of generic types are sometimes wrong: https://github.com/rust-lang/rust/issues/26925\n-///\n-/// **Example:**\n-/// ```rust\n-/// #[derive(Copy)]\n-/// struct Foo;\n-///\n-/// impl Clone for Foo {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for explicit `Clone` implementations for `Copy`\n+    /// types.\n+    ///\n+    /// **Why is this bad?** To avoid surprising behaviour, these traits should\n+    /// agree and the behaviour of `Copy` cannot be overridden. In almost all\n+    /// situations a `Copy` type should have a `Clone` implementation that does\n+    /// nothing more than copy the object, which is what `#[derive(Copy, Clone)]`\n+    /// gets you.\n+    ///\n+    /// **Known problems:** Bounds of generic types are sometimes wrong: https://github.com/rust-lang/rust/issues/26925\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// #[derive(Copy)]\n+    /// struct Foo;\n+    ///\n+    /// impl Clone for Foo {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub EXPL_IMPL_CLONE_ON_COPY,\n     pedantic,\n     \"implementing `Clone` explicitly on `Copy` types\""}, {"sha": "dda4ab7c3b0bb77dde071f2732f194d348fd50ab", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -9,25 +9,25 @@ use syntax::source_map::{BytePos, Span};\n use syntax_pos::Pos;\n use url::Url;\n \n-/// **What it does:** Checks for the presence of `_`, `::` or camel-case words\n-/// outside ticks in documentation.\n-///\n-/// **Why is this bad?** *Rustdoc* supports markdown formatting, `_`, `::` and\n-/// camel-case probably indicates some code which should be included between\n-/// ticks. `_` can also be used for emphasis in markdown, this lint tries to\n-/// consider that.\n-///\n-/// **Known problems:** Lots of bad docs won\u2019t be fixed, what the lint checks\n-/// for is limited, and there are still false positives.\n-///\n-/// **Examples:**\n-/// ```rust\n-/// /// Do something with the foo_bar parameter. See also\n-/// /// that::other::module::foo.\n-/// // ^ `foo_bar` and `that::other::module::foo` should be ticked.\n-/// fn doit(foo_bar) { .. }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for the presence of `_`, `::` or camel-case words\n+    /// outside ticks in documentation.\n+    ///\n+    /// **Why is this bad?** *Rustdoc* supports markdown formatting, `_`, `::` and\n+    /// camel-case probably indicates some code which should be included between\n+    /// ticks. `_` can also be used for emphasis in markdown, this lint tries to\n+    /// consider that.\n+    ///\n+    /// **Known problems:** Lots of bad docs won\u2019t be fixed, what the lint checks\n+    /// for is limited, and there are still false positives.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// /// Do something with the foo_bar parameter. See also\n+    /// /// that::other::module::foo.\n+    /// // ^ `foo_bar` and `that::other::module::foo` should be ticked.\n+    /// fn doit(foo_bar) { .. }\n+    /// ```\n     pub DOC_MARKDOWN,\n     pedantic,\n     \"presence of `_`, `::` or camel-case outside backticks in documentation\""}, {"sha": "be6124e45536fe714127210a23895a8d9834245c", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -8,24 +8,24 @@ use syntax::source_map::Span;\n \n use crate::utils::{snippet_with_applicability, span_lint_and_sugg, SpanlessEq};\n \n-/// **What it does:** Checks for double comparions that could be simplified to a single expression.\n-///\n-///\n-/// **Why is this bad?** Readability.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x == y || x < y\n-/// ```\n-///\n-/// Could be written as:\n-///\n-/// ```rust\n-/// x <= y\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for double comparions that could be simplified to a single expression.\n+    ///\n+    ///\n+    /// **Why is this bad?** Readability.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x == y || x < y\n+    /// ```\n+    ///\n+    /// Could be written as:\n+    ///\n+    /// ```rust\n+    /// x <= y\n+    /// ```\n     pub DOUBLE_COMPARISONS,\n     complexity,\n     \"unnecessary double comparisons that can be simplified\""}, {"sha": "5b5639371a188627ceeb6dc34fdc1ac7ef420636", "filename": "clippy_lints/src/double_parens.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_parens.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -3,20 +3,20 @@ use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use syntax::ast::*;\n \n-/// **What it does:** Checks for unnecessary double parentheses.\n-///\n-/// **Why is this bad?** This makes code harder to read and might indicate a\n-/// mistake.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// ((0))\n-/// foo((0))\n-/// ((1, 2))\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for unnecessary double parentheses.\n+    ///\n+    /// **Why is this bad?** This makes code harder to read and might indicate a\n+    /// mistake.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// ((0))\n+    /// foo((0))\n+    /// ((1, 2))\n+    /// ```\n     pub DOUBLE_PARENS,\n     complexity,\n     \"Warn on unnecessary double parentheses\""}, {"sha": "702f7eced717944c2c11bc2cf2bb6b68a11d7818", "filename": "clippy_lints/src/drop_bounds.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fdrop_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fdrop_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_bounds.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -4,29 +4,29 @@ use rustc::hir::*;\n use rustc::lint::{LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for generics with `std::ops::Drop` as bounds.\n-///\n-/// **Why is this bad?** `Drop` bounds do not really accomplish anything.\n-/// A type may have compiler-generated drop glue without implementing the\n-/// `Drop` trait itself. The `Drop` trait also only has one method,\n-/// `Drop::drop`, and that function is by fiat not callable in user code.\n-/// So there is really no use case for using `Drop` in trait bounds.\n-///\n-/// The most likely use case of a drop bound is to distinguish between types\n-/// that have destructors and types that don't. Combined with specialization,\n-/// a naive coder would write an implementation that assumed a type could be\n-/// trivially dropped, then write a specialization for `T: Drop` that actually\n-/// calls the destructor. Except that doing so is not correct; String, for\n-/// example, doesn't actually implement Drop, but because String contains a\n-/// Vec, assuming it can be trivially dropped will leak memory.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo<T: Drop>() {}\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for generics with `std::ops::Drop` as bounds.\n+    ///\n+    /// **Why is this bad?** `Drop` bounds do not really accomplish anything.\n+    /// A type may have compiler-generated drop glue without implementing the\n+    /// `Drop` trait itself. The `Drop` trait also only has one method,\n+    /// `Drop::drop`, and that function is by fiat not callable in user code.\n+    /// So there is really no use case for using `Drop` in trait bounds.\n+    ///\n+    /// The most likely use case of a drop bound is to distinguish between types\n+    /// that have destructors and types that don't. Combined with specialization,\n+    /// a naive coder would write an implementation that assumed a type could be\n+    /// trivially dropped, then write a specialization for `T: Drop` that actually\n+    /// calls the destructor. Except that doing so is not correct; String, for\n+    /// example, doesn't actually implement Drop, but because String contains a\n+    /// Vec, assuming it can be trivially dropped will leak memory.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo<T: Drop>() {}\n+    /// ```\n     pub DROP_BOUNDS,\n     correctness,\n     \"Bounds of the form `T: Drop` are useless\""}, {"sha": "08c523b038ced7c3376a315cd042dc4121aecec0", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,93 +5,93 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for calls to `std::mem::drop` with a reference\n-/// instead of an owned value.\n-///\n-/// **Why is this bad?** Calling `drop` on a reference will only drop the\n-/// reference itself, which is a no-op. It will not call the `drop` method (from\n-/// the `Drop` trait implementation) on the underlying referenced value, which\n-/// is likely what was intended.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let mut lock_guard = mutex.lock();\n-/// std::mem::drop(&lock_guard) // Should have been drop(lock_guard), mutex\n-/// // still locked\n-/// operation_that_requires_mutex_to_be_unlocked();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `std::mem::drop` with a reference\n+    /// instead of an owned value.\n+    ///\n+    /// **Why is this bad?** Calling `drop` on a reference will only drop the\n+    /// reference itself, which is a no-op. It will not call the `drop` method (from\n+    /// the `Drop` trait implementation) on the underlying referenced value, which\n+    /// is likely what was intended.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut lock_guard = mutex.lock();\n+    /// std::mem::drop(&lock_guard) // Should have been drop(lock_guard), mutex\n+    /// // still locked\n+    /// operation_that_requires_mutex_to_be_unlocked();\n+    /// ```\n     pub DROP_REF,\n     correctness,\n     \"calls to `std::mem::drop` with a reference instead of an owned value\"\n }\n \n-/// **What it does:** Checks for calls to `std::mem::forget` with a reference\n-/// instead of an owned value.\n-///\n-/// **Why is this bad?** Calling `forget` on a reference will only forget the\n-/// reference itself, which is a no-op. It will not forget the underlying\n-/// referenced\n-/// value, which is likely what was intended.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = Box::new(1);\n-/// std::mem::forget(&x) // Should have been forget(x), x will still be dropped\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `std::mem::forget` with a reference\n+    /// instead of an owned value.\n+    ///\n+    /// **Why is this bad?** Calling `forget` on a reference will only forget the\n+    /// reference itself, which is a no-op. It will not forget the underlying\n+    /// referenced\n+    /// value, which is likely what was intended.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = Box::new(1);\n+    /// std::mem::forget(&x) // Should have been forget(x), x will still be dropped\n+    /// ```\n     pub FORGET_REF,\n     correctness,\n     \"calls to `std::mem::forget` with a reference instead of an owned value\"\n }\n \n-/// **What it does:** Checks for calls to `std::mem::drop` with a value\n-/// that derives the Copy trait\n-///\n-/// **Why is this bad?** Calling `std::mem::drop` [does nothing for types that\n-/// implement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html), since the\n-/// value will be copied and moved into the function on invocation.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x: i32 = 42; // i32 implements Copy\n-/// std::mem::drop(x) // A copy of x is passed to the function, leaving the\n-///                   // original unaffected\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `std::mem::drop` with a value\n+    /// that derives the Copy trait\n+    ///\n+    /// **Why is this bad?** Calling `std::mem::drop` [does nothing for types that\n+    /// implement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html), since the\n+    /// value will be copied and moved into the function on invocation.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x: i32 = 42; // i32 implements Copy\n+    /// std::mem::drop(x) // A copy of x is passed to the function, leaving the\n+    ///                   // original unaffected\n+    /// ```\n     pub DROP_COPY,\n     correctness,\n     \"calls to `std::mem::drop` with a value that implements Copy\"\n }\n \n-/// **What it does:** Checks for calls to `std::mem::forget` with a value that\n-/// derives the Copy trait\n-///\n-/// **Why is this bad?** Calling `std::mem::forget` [does nothing for types that\n-/// implement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html) since the\n-/// value will be copied and moved into the function on invocation.\n-///\n-/// An alternative, but also valid, explanation is that Copy types do not\n-/// implement\n-/// the Drop trait, which means they have no destructors. Without a destructor,\n-/// there\n-/// is nothing for `std::mem::forget` to ignore.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x: i32 = 42; // i32 implements Copy\n-/// std::mem::forget(x) // A copy of x is passed to the function, leaving the\n-///                     // original unaffected\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `std::mem::forget` with a value that\n+    /// derives the Copy trait\n+    ///\n+    /// **Why is this bad?** Calling `std::mem::forget` [does nothing for types that\n+    /// implement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html) since the\n+    /// value will be copied and moved into the function on invocation.\n+    ///\n+    /// An alternative, but also valid, explanation is that Copy types do not\n+    /// implement\n+    /// the Drop trait, which means they have no destructors. Without a destructor,\n+    /// there\n+    /// is nothing for `std::mem::forget` to ignore.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x: i32 = 42; // i32 implements Copy\n+    /// std::mem::forget(x) // A copy of x is passed to the function, leaving the\n+    ///                     // original unaffected\n+    /// ```\n     pub FORGET_COPY,\n     correctness,\n     \"calls to `std::mem::forget` with a value that implements Copy\""}, {"sha": "df0ea31470c60a3721209f26ad7ea23b9e0123f0", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -9,21 +9,21 @@ use crate::consts::{constant, Constant};\n use crate::utils::paths;\n use crate::utils::{match_type, snippet_with_applicability, span_lint_and_sugg, walk_ptrs_ty};\n \n-/// **What it does:** Checks for calculation of subsecond microseconds or milliseconds\n-/// from other `Duration` methods.\n-///\n-/// **Why is this bad?** It's more concise to call `Duration::subsec_micros()` or\n-/// `Duration::subsec_millis()` than to calculate them.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let dur = Duration::new(5, 0);\n-/// let _micros = dur.subsec_nanos() / 1_000;\n-/// let _millis = dur.subsec_nanos() / 1_000_000;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calculation of subsecond microseconds or milliseconds\n+    /// from other `Duration` methods.\n+    ///\n+    /// **Why is this bad?** It's more concise to call `Duration::subsec_micros()` or\n+    /// `Duration::subsec_millis()` than to calculate them.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let dur = Duration::new(5, 0);\n+    /// let _micros = dur.subsec_nanos() / 1_000;\n+    /// let _millis = dur.subsec_nanos() / 1_000_000;\n+    /// ```\n     pub DURATION_SUBSEC,\n     complexity,\n     \"checks for calculation of subsecond microseconds or milliseconds\""}, {"sha": "a306cff6eba5f5924b942ec1e2b348e54163211e", "filename": "clippy_lints/src/else_if_without_else.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Felse_if_without_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Felse_if_without_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Felse_if_without_else.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -6,34 +6,34 @@ use syntax::ast::*;\n \n use crate::utils::span_help_and_lint;\n \n-/// **What it does:** Checks for usage of if expressions with an `else if` branch,\n-/// but without a final `else` branch.\n-///\n-/// **Why is this bad?** Some coding guidelines require this (e.g. MISRA-C:2004 Rule 14.10).\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if x.is_positive() {\n-///     a();\n-/// } else if x.is_negative() {\n-///     b();\n-/// }\n-/// ```\n-///\n-/// Could be written:\n-///\n-/// ```rust\n-/// if x.is_positive() {\n-///     a();\n-/// } else if x.is_negative() {\n-///     b();\n-/// } else {\n-///     // we don't care about zero\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of if expressions with an `else if` branch,\n+    /// but without a final `else` branch.\n+    ///\n+    /// **Why is this bad?** Some coding guidelines require this (e.g. MISRA-C:2004 Rule 14.10).\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if x.is_positive() {\n+    ///     a();\n+    /// } else if x.is_negative() {\n+    ///     b();\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// if x.is_positive() {\n+    ///     a();\n+    /// } else if x.is_negative() {\n+    ///     b();\n+    /// } else {\n+    ///     // we don't care about zero\n+    /// }\n+    /// ```\n     pub ELSE_IF_WITHOUT_ELSE,\n     restriction,\n     \"if expression with an `else if`, but without a final `else` branch\""}, {"sha": "9075cdc10c8b1b254efbdcd98fef923e374bdefb", "filename": "clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_enum.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,19 +5,19 @@ use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for `enum`s with no variants.\n-///\n-/// **Why is this bad?** Enum's with no variants should be replaced with `!`,\n-/// the uninhabited type,\n-/// or a wrapper around it.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// enum Test {}\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `enum`s with no variants.\n+    ///\n+    /// **Why is this bad?** Enum's with no variants should be replaced with `!`,\n+    /// the uninhabited type,\n+    /// or a wrapper around it.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// enum Test {}\n+    /// ```\n     pub EMPTY_ENUM,\n     pedantic,\n     \"enum with no variants\""}, {"sha": "0dc970fcafe261e14e97a2ad481915b4fa0bc3b9", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -8,30 +8,30 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for uses of `contains_key` + `insert` on `HashMap`\n-/// or `BTreeMap`.\n-///\n-/// **Why is this bad?** Using `entry` is more efficient.\n-///\n-/// **Known problems:** Some false negatives, eg.:\n-/// ```rust\n-/// let k = &key;\n-/// if !m.contains_key(k) {\n-///     m.insert(k.clone(), v);\n-/// }\n-/// ```\n-///\n-/// **Example:**\n-/// ```rust\n-/// if !m.contains_key(&k) {\n-///     m.insert(k, v)\n-/// }\n-/// ```\n-/// can be rewritten as:\n-/// ```rust\n-/// m.entry(k).or_insert(v);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for uses of `contains_key` + `insert` on `HashMap`\n+    /// or `BTreeMap`.\n+    ///\n+    /// **Why is this bad?** Using `entry` is more efficient.\n+    ///\n+    /// **Known problems:** Some false negatives, eg.:\n+    /// ```rust\n+    /// let k = &key;\n+    /// if !m.contains_key(k) {\n+    ///     m.insert(k.clone(), v);\n+    /// }\n+    /// ```\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if !m.contains_key(&k) {\n+    ///     m.insert(k, v)\n+    /// }\n+    /// ```\n+    /// can be rewritten as:\n+    /// ```rust\n+    /// m.entry(k).or_insert(v);\n+    /// ```\n     pub MAP_ENTRY,\n     perf,\n     \"use of `contains_key` followed by `insert` on a `HashMap` or `BTreeMap`\""}, {"sha": "8e844f9c3988199e322a87f90114dffb7f2d03f1", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -12,23 +12,23 @@ use rustc::ty::util::IntTypeExt;\n use rustc::{declare_tool_lint, lint_array};\n use syntax::ast::{IntTy, UintTy};\n \n-/// **What it does:** Checks for C-like enumerations that are\n-/// `repr(isize/usize)` and have values that don't fit into an `i32`.\n-///\n-/// **Why is this bad?** This will truncate the variant value on 32 bit\n-/// architectures, but works fine on 64 bit.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// #[repr(usize)]\n-/// enum NonPortable {\n-///     X = 0x1_0000_0000,\n-///     Y = 0,\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for C-like enumerations that are\n+    /// `repr(isize/usize)` and have values that don't fit into an `i32`.\n+    ///\n+    /// **Why is this bad?** This will truncate the variant value on 32 bit\n+    /// architectures, but works fine on 64 bit.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// #[repr(usize)]\n+    /// enum NonPortable {\n+    ///     X = 0x1_0000_0000,\n+    ///     Y = 0,\n+    /// }\n+    /// ```\n     pub ENUM_CLIKE_UNPORTABLE_VARIANT,\n     correctness,\n     \"C-like enums that are `repr(isize/usize)` and have values that don't fit into an `i32`\""}, {"sha": "37575f10f19574d926d0452332feeadc2d3115c3", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -7,19 +7,19 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for `use Enum::*`.\n-///\n-/// **Why is this bad?** It is usually better style to use the prefixed name of\n-/// an enumeration variant, rather than importing variants.\n-///\n-/// **Known problems:** Old-style enumerations that prefix the variants are\n-/// still around.\n-///\n-/// **Example:**\n-/// ```rust\n-/// use std::cmp::Ordering::*;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `use Enum::*`.\n+    ///\n+    /// **Why is this bad?** It is usually better style to use the prefixed name of\n+    /// an enumeration variant, rather than importing variants.\n+    ///\n+    /// **Known problems:** Old-style enumerations that prefix the variants are\n+    /// still around.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// use std::cmp::Ordering::*;\n+    /// ```\n     pub ENUM_GLOB_USE,\n     pedantic,\n     \"use items that import all variants of an enum\""}, {"sha": "192668028f1b3a6fe12d62361669d305b3c3d946", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -8,94 +8,94 @@ use syntax::ast::*;\n use syntax::source_map::Span;\n use syntax::symbol::{InternedString, LocalInternedString};\n \n-/// **What it does:** Detects enumeration variants that are prefixed or suffixed\n-/// by the same characters.\n-///\n-/// **Why is this bad?** Enumeration variant names should specify their variant,\n-/// not repeat the enumeration name.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// enum Cake {\n-///     BlackForestCake,\n-///     HummingbirdCake,\n-///     BattenbergCake,\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Detects enumeration variants that are prefixed or suffixed\n+    /// by the same characters.\n+    ///\n+    /// **Why is this bad?** Enumeration variant names should specify their variant,\n+    /// not repeat the enumeration name.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// enum Cake {\n+    ///     BlackForestCake,\n+    ///     HummingbirdCake,\n+    ///     BattenbergCake,\n+    /// }\n+    /// ```\n     pub ENUM_VARIANT_NAMES,\n     style,\n     \"enums where all variants share a prefix/postfix\"\n }\n \n-/// **What it does:** Detects enumeration variants that are prefixed or suffixed\n-/// by the same characters.\n-///\n-/// **Why is this bad?** Enumeration variant names should specify their variant,\n-/// not repeat the enumeration name.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// enum Cake {\n-///     BlackForestCake,\n-///     HummingbirdCake,\n-///     BattenbergCake,\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Detects enumeration variants that are prefixed or suffixed\n+    /// by the same characters.\n+    ///\n+    /// **Why is this bad?** Enumeration variant names should specify their variant,\n+    /// not repeat the enumeration name.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// enum Cake {\n+    ///     BlackForestCake,\n+    ///     HummingbirdCake,\n+    ///     BattenbergCake,\n+    /// }\n+    /// ```\n     pub PUB_ENUM_VARIANT_NAMES,\n     pedantic,\n     \"enums where all variants share a prefix/postfix\"\n }\n \n-/// **What it does:** Detects type names that are prefixed or suffixed by the\n-/// containing module's name.\n-///\n-/// **Why is this bad?** It requires the user to type the module name twice.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// mod cake {\n-///     struct BlackForestCake;\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Detects type names that are prefixed or suffixed by the\n+    /// containing module's name.\n+    ///\n+    /// **Why is this bad?** It requires the user to type the module name twice.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// mod cake {\n+    ///     struct BlackForestCake;\n+    /// }\n+    /// ```\n     pub MODULE_NAME_REPETITIONS,\n     pedantic,\n     \"type names prefixed/postfixed with their containing module's name\"\n }\n \n-/// **What it does:** Checks for modules that have the same name as their\n-/// parent module\n-///\n-/// **Why is this bad?** A typical beginner mistake is to have `mod foo;` and\n-/// again `mod foo { ..\n-/// }` in `foo.rs`.\n-/// The expectation is that items inside the inner `mod foo { .. }` are then\n-/// available\n-/// through `foo::x`, but they are only available through\n-/// `foo::foo::x`.\n-/// If this is done on purpose, it would be better to choose a more\n-/// representative module name.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// // lib.rs\n-/// mod foo;\n-/// // foo.rs\n-/// mod foo {\n-///     ...\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for modules that have the same name as their\n+    /// parent module\n+    ///\n+    /// **Why is this bad?** A typical beginner mistake is to have `mod foo;` and\n+    /// again `mod foo { ..\n+    /// }` in `foo.rs`.\n+    /// The expectation is that items inside the inner `mod foo { .. }` are then\n+    /// available\n+    /// through `foo::x`, but they are only available through\n+    /// `foo::foo::x`.\n+    /// If this is done on purpose, it would be better to choose a more\n+    /// representative module name.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // lib.rs\n+    /// mod foo;\n+    /// // foo.rs\n+    /// mod foo {\n+    ///     ...\n+    /// }\n+    /// ```\n     pub MODULE_INCEPTION,\n     style,\n     \"modules that have the same name as their parent module\""}, {"sha": "24b6371142fb00e9cfcedb61aa21a5a3bfc9cd45", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -6,40 +6,40 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for equal operands to comparison, logical and\n-/// bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n-/// `||`, `&`, `|`, `^`, `-` and `/`).\n-///\n-/// **Why is this bad?** This is usually just a typo or a copy and paste error.\n-///\n-/// **Known problems:** False negatives: We had some false positives regarding\n-/// calls (notably [racer](https://github.com/phildawes/racer) had one instance\n-/// of `x.pop() && x.pop()`), so we removed matching any function or method\n-/// calls. We may introduce a whitelist of known pure functions in the future.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x + 1 == x + 1\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for equal operands to comparison, logical and\n+    /// bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n+    /// `||`, `&`, `|`, `^`, `-` and `/`).\n+    ///\n+    /// **Why is this bad?** This is usually just a typo or a copy and paste error.\n+    ///\n+    /// **Known problems:** False negatives: We had some false positives regarding\n+    /// calls (notably [racer](https://github.com/phildawes/racer) had one instance\n+    /// of `x.pop() && x.pop()`), so we removed matching any function or method\n+    /// calls. We may introduce a whitelist of known pure functions in the future.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x + 1 == x + 1\n+    /// ```\n     pub EQ_OP,\n     correctness,\n     \"equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\"\n }\n \n-/// **What it does:** Checks for arguments to `==` which have their address\n-/// taken to satisfy a bound\n-/// and suggests to dereference the other argument instead\n-///\n-/// **Why is this bad?** It is more idiomatic to dereference the other argument.\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// &x == y\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for arguments to `==` which have their address\n+    /// taken to satisfy a bound\n+    /// and suggests to dereference the other argument instead\n+    ///\n+    /// **Why is this bad?** It is more idiomatic to dereference the other argument.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// &x == y\n+    /// ```\n     pub OP_REF,\n     style,\n     \"taking a reference to satisfy the type constraints on `==`\""}, {"sha": "748673c96b12f5a6e9748ac5edc9132f9fae5a64", "filename": "clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ferasing_op.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,21 +5,21 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for erasing operations, e.g. `x * 0`.\n-///\n-/// **Why is this bad?** The whole expression can be replaced by zero.\n-/// This is most likely not the intended outcome and should probably be\n-/// corrected\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// 0 / x;\n-/// 0 * x;\n-/// x & 0\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for erasing operations, e.g. `x * 0`.\n+    ///\n+    /// **Why is this bad?** The whole expression can be replaced by zero.\n+    /// This is most likely not the intended outcome and should probably be\n+    /// corrected\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// 0 / x;\n+    /// 0 * x;\n+    /// x & 0\n+    /// ```\n     pub ERASING_OP,\n     correctness,\n     \"using erasing operations, e.g. `x * 0` or `y & 0`\""}, {"sha": "c84552d60c1c2ed145acc03bb727c9ede73abe08", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -14,24 +14,24 @@ pub struct Pass {\n     pub too_large_for_stack: u64,\n }\n \n-/// **What it does:** Checks for usage of `Box<T>` where an unboxed `T` would\n-/// work fine.\n-///\n-/// **Why is this bad?** This is an unnecessary allocation, and bad for\n-/// performance. It is only necessary to allocate if you wish to move the box\n-/// into something.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn main() {\n-///     let x = Box::new(1);\n-///     foo(*x);\n-///     println!(\"{}\", *x);\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `Box<T>` where an unboxed `T` would\n+    /// work fine.\n+    ///\n+    /// **Why is this bad?** This is an unnecessary allocation, and bad for\n+    /// performance. It is only necessary to allocate if you wish to move the box\n+    /// into something.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn main() {\n+    ///     let x = Box::new(1);\n+    ///     foo(*x);\n+    ///     println!(\"{}\", *x);\n+    /// }\n+    /// ```\n     pub BOXED_LOCAL,\n     perf,\n     \"using `Box<T>` where unnecessary\""}, {"sha": "cd3146cf1be3aae513af4d9082779eb5b9d7240b", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -8,26 +8,26 @@ use rustc_errors::Applicability;\n \n pub struct EtaPass;\n \n-/// **What it does:** Checks for closures which just call another function where\n-/// the function can be called directly. `unsafe` functions or calls where types\n-/// get adjusted are ignored.\n-///\n-/// **Why is this bad?** Needlessly creating a closure adds code for no benefit\n-/// and gives the optimizer more work.\n-///\n-/// **Known problems:** If creating the closure inside the closure has a side-\n-/// effect then moving the closure creation out will change when that side-\n-/// effect runs.\n-/// See https://github.com/rust-lang/rust-clippy/issues/1439 for more\n-/// details.\n-///\n-/// **Example:**\n-/// ```rust\n-/// xs.map(|x| foo(x))\n-/// ```\n-/// where `foo(_)` is a plain function that takes the exact argument type of\n-/// `x`.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for closures which just call another function where\n+    /// the function can be called directly. `unsafe` functions or calls where types\n+    /// get adjusted are ignored.\n+    ///\n+    /// **Why is this bad?** Needlessly creating a closure adds code for no benefit\n+    /// and gives the optimizer more work.\n+    ///\n+    /// **Known problems:** If creating the closure inside the closure has a side-\n+    /// effect then moving the closure creation out will change when that side-\n+    /// effect runs.\n+    /// See https://github.com/rust-lang/rust-clippy/issues/1439 for more\n+    /// details.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// xs.map(|x| foo(x))\n+    /// ```\n+    /// where `foo(_)` is a plain function that takes the exact argument type of\n+    /// `x`.\n     pub REDUNDANT_CLOSURE,\n     style,\n     \"redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\""}, {"sha": "6bba31b15c1d9935130f24149339fd8d0afea2ad", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -7,48 +7,48 @@ use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use syntax::ast;\n \n-/// **What it does:** Checks for a read and a write to the same variable where\n-/// whether the read occurs before or after the write depends on the evaluation\n-/// order of sub-expressions.\n-///\n-/// **Why is this bad?** It is often confusing to read. In addition, the\n-/// sub-expression evaluation order for Rust is not well documented.\n-///\n-/// **Known problems:** Code which intentionally depends on the evaluation\n-/// order, or which is correct for any evaluation order.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let mut x = 0;\n-/// let a = {\n-///     x = 1;\n-///     1\n-/// } + x;\n-/// // Unclear whether a is 1 or 2.\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for a read and a write to the same variable where\n+    /// whether the read occurs before or after the write depends on the evaluation\n+    /// order of sub-expressions.\n+    ///\n+    /// **Why is this bad?** It is often confusing to read. In addition, the\n+    /// sub-expression evaluation order for Rust is not well documented.\n+    ///\n+    /// **Known problems:** Code which intentionally depends on the evaluation\n+    /// order, or which is correct for any evaluation order.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut x = 0;\n+    /// let a = {\n+    ///     x = 1;\n+    ///     1\n+    /// } + x;\n+    /// // Unclear whether a is 1 or 2.\n+    /// ```\n     pub EVAL_ORDER_DEPENDENCE,\n     complexity,\n     \"whether a variable read occurs before a write depends on sub-expression evaluation order\"\n }\n \n-/// **What it does:** Checks for diverging calls that are not match arms or\n-/// statements.\n-///\n-/// **Why is this bad?** It is often confusing to read. In addition, the\n-/// sub-expression evaluation order for Rust is not well documented.\n-///\n-/// **Known problems:** Someone might want to use `some_bool || panic!()` as a\n-/// shorthand.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let a = b() || panic!() || c();\n-/// // `c()` is dead, `panic!()` is only called if `b()` returns `false`\n-/// let x = (a, b, c, panic!());\n-/// // can simply be replaced by `panic!()`\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for diverging calls that are not match arms or\n+    /// statements.\n+    ///\n+    /// **Why is this bad?** It is often confusing to read. In addition, the\n+    /// sub-expression evaluation order for Rust is not well documented.\n+    ///\n+    /// **Known problems:** Someone might want to use `some_bool || panic!()` as a\n+    /// shorthand.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let a = b() || panic!() || c();\n+    /// // `c()` is dead, `panic!()` is only called if `b()` returns `false`\n+    /// let x = (a, b, c, panic!());\n+    /// // can simply be replaced by `panic!()`\n+    /// ```\n     pub DIVERGING_SUB_EXPRESSION,\n     complexity,\n     \"whether an expression contains a diverging sub expression\""}, {"sha": "ff28866e3a7bff70f56fb55dd12f6d01bafcbad7", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -11,25 +11,25 @@ use std::fmt;\n use syntax::ast::*;\n use syntax_pos::symbol::Symbol;\n \n-/// **What it does:** Checks for float literals with a precision greater\n-/// than that supported by the underlying type\n-///\n-/// **Why is this bad?** Rust will truncate the literal silently.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// // Bad\n-/// let v: f32 = 0.123_456_789_9;\n-/// println!(\"{}\", v); //  0.123_456_789\n-///\n-/// // Good\n-/// let v: f64 = 0.123_456_789_9;\n-/// println!(\"{}\", v); //  0.123_456_789_9\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for float literals with a precision greater\n+    /// than that supported by the underlying type\n+    ///\n+    /// **Why is this bad?** Rust will truncate the literal silently.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// let v: f32 = 0.123_456_789_9;\n+    /// println!(\"{}\", v); //  0.123_456_789\n+    ///\n+    /// // Good\n+    /// let v: f64 = 0.123_456_789_9;\n+    /// println!(\"{}\", v); //  0.123_456_789_9\n+    /// ```\n     pub EXCESSIVE_PRECISION,\n     style,\n     \"excessive precision for float literal\""}, {"sha": "5c75f8888a4e1ad87b9fda56ccfa504d36e13a35", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -6,19 +6,19 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n \n-/// **What it does:** Checks for usage of `write!()` / `writeln()!` which can be\n-/// replaced with `(e)print!()` / `(e)println!()`\n-///\n-/// **Why is this bad?** Using `(e)println! is clearer and more concise\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// // this would be clearer as `eprintln!(\"foo: {:?}\", bar);`\n-/// writeln!(&mut io::stderr(), \"foo: {:?}\", bar).unwrap();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `write!()` / `writeln()!` which can be\n+    /// replaced with `(e)print!()` / `(e)println!()`\n+    ///\n+    /// **Why is this bad?** Using `(e)println! is clearer and more concise\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // this would be clearer as `eprintln!(\"foo: {:?}\", bar);`\n+    /// writeln!(&mut io::stderr(), \"foo: {:?}\", bar).unwrap();\n+    /// ```\n     pub EXPLICIT_WRITE,\n     complexity,\n     \"using the `write!()` family of functions instead of the `print!()` family of functions, when using the latter would work\""}, {"sha": "2a1f3661c78fbb88ba588feded7d051c75d123ec", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -7,22 +7,22 @@ use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use syntax_pos::Span;\n \n-/// **What it does:** Checks for impls of `From<..>` that contain `panic!()` or `unwrap()`\n-///\n-/// **Why is this bad?** `TryFrom` should be used if there's a possibility of failure.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// struct Foo(i32);\n-/// impl From<String> for Foo {\n-///     fn from(s: String) -> Self {\n-///         Foo(s.parse().unwrap())\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for impls of `From<..>` that contain `panic!()` or `unwrap()`\n+    ///\n+    /// **Why is this bad?** `TryFrom` should be used if there's a possibility of failure.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// struct Foo(i32);\n+    /// impl From<String> for Foo {\n+    ///     fn from(s: String) -> Self {\n+    ///         Foo(s.parse().unwrap())\n+    ///     }\n+    /// }\n+    /// ```\n     pub FALLIBLE_IMPL_FROM,\n     nursery,\n     \"Warn on impls of `From<..>` that contain `panic!()` or `unwrap()`\""}, {"sha": "205df2ab43ba7cd47dd5915bd7da3a3aed983c6b", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -12,23 +12,23 @@ use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for the use of `format!(\"string literal with no\n-/// argument\")` and `format!(\"{}\", foo)` where `foo` is a string.\n-///\n-/// **Why is this bad?** There is no point of doing that. `format!(\"foo\")` can\n-/// be replaced by `\"foo\".to_owned()` if you really need a `String`. The even\n-/// worse `&format!(\"foo\")` is often encountered in the wild. `format!(\"{}\",\n-/// foo)` can be replaced by `foo.clone()` if `foo: String` or `foo.to_owned()`\n-/// if `foo: &str`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Examples:**\n-/// ```rust\n-/// format!(\"foo\")\n-/// format!(\"{}\", foo)\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for the use of `format!(\"string literal with no\n+    /// argument\")` and `format!(\"{}\", foo)` where `foo` is a string.\n+    ///\n+    /// **Why is this bad?** There is no point of doing that. `format!(\"foo\")` can\n+    /// be replaced by `\"foo\".to_owned()` if you really need a `String`. The even\n+    /// worse `&format!(\"foo\")` is often encountered in the wild. `format!(\"{}\",\n+    /// foo)` can be replaced by `foo.clone()` if `foo: String` or `foo.to_owned()`\n+    /// if `foo: &str`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// format!(\"foo\")\n+    /// format!(\"{}\", foo)\n+    /// ```\n     pub USELESS_FORMAT,\n     complexity,\n     \"useless use of `format!`\""}, {"sha": "4788f57d070a486b8d68a9df07e837099a55ce86", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -4,75 +4,75 @@ use rustc::{declare_tool_lint, lint_array};\n use syntax::ast;\n use syntax::ptr::P;\n \n-/// **What it does:** Checks for use of the non-existent `=*`, `=!` and `=-`\n-/// operators.\n-///\n-/// **Why is this bad?** This is either a typo of `*=`, `!=` or `-=` or\n-/// confusing.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// a =- 42; // confusing, should it be `a -= 42` or `a = -42`?\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for use of the non-existent `=*`, `=!` and `=-`\n+    /// operators.\n+    ///\n+    /// **Why is this bad?** This is either a typo of `*=`, `!=` or `-=` or\n+    /// confusing.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// a =- 42; // confusing, should it be `a -= 42` or `a = -42`?\n+    /// ```\n     pub SUSPICIOUS_ASSIGNMENT_FORMATTING,\n     style,\n     \"suspicious formatting of `*=`, `-=` or `!=`\"\n }\n \n-/// **What it does:** Checks for formatting of `else`. It lints if the `else`\n-/// is followed immediately by a newline or the `else` seems to be missing.\n-///\n-/// **Why is this bad?** This is probably some refactoring remnant, even if the\n-/// code is correct, it might look confusing.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// if foo {\n-/// } { // looks like an `else` is missing here\n-/// }\n-///\n-/// if foo {\n-/// } if bar { // looks like an `else` is missing here\n-/// }\n-///\n-/// if foo {\n-/// } else\n-///\n-/// { // this is the `else` block of the previous `if`, but should it be?\n-/// }\n-///\n-/// if foo {\n-/// } else\n-///\n-/// if bar { // this is the `else` block of the previous `if`, but should it be?\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for formatting of `else`. It lints if the `else`\n+    /// is followed immediately by a newline or the `else` seems to be missing.\n+    ///\n+    /// **Why is this bad?** This is probably some refactoring remnant, even if the\n+    /// code is correct, it might look confusing.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// if foo {\n+    /// } { // looks like an `else` is missing here\n+    /// }\n+    ///\n+    /// if foo {\n+    /// } if bar { // looks like an `else` is missing here\n+    /// }\n+    ///\n+    /// if foo {\n+    /// } else\n+    ///\n+    /// { // this is the `else` block of the previous `if`, but should it be?\n+    /// }\n+    ///\n+    /// if foo {\n+    /// } else\n+    ///\n+    /// if bar { // this is the `else` block of the previous `if`, but should it be?\n+    /// }\n+    /// ```\n     pub SUSPICIOUS_ELSE_FORMATTING,\n     style,\n     \"suspicious formatting of `else`\"\n }\n \n-/// **What it does:** Checks for possible missing comma in an array. It lints if\n-/// an array element is a binary operator expression and it lies on two lines.\n-///\n-/// **Why is this bad?** This could lead to unexpected results.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// let a = &[\n-///     -1, -2, -3 // <= no comma here\n-///     -4, -5, -6\n-/// ];\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for possible missing comma in an array. It lints if\n+    /// an array element is a binary operator expression and it lies on two lines.\n+    ///\n+    /// **Why is this bad?** This could lead to unexpected results.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// let a = &[\n+    ///     -1, -2, -3 // <= no comma here\n+    ///     -4, -5, -6\n+    /// ];\n+    /// ```\n     pub POSSIBLE_MISSING_COMMA,\n     correctness,\n     \"possible missing comma in array\""}, {"sha": "ef3debe17a7082cf7a318a2de5c8697589c74a91", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -11,72 +11,72 @@ use rustc_target::spec::abi::Abi;\n use syntax::ast;\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for functions with too many parameters.\n-///\n-/// **Why is this bad?** Functions with lots of parameters are considered bad\n-/// style and reduce readability (\u201cwhat does the 5th parameter mean?\u201d). Consider\n-/// grouping some parameters into a new type.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b: f32) {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for functions with too many parameters.\n+    ///\n+    /// **Why is this bad?** Functions with lots of parameters are considered bad\n+    /// style and reduce readability (\u201cwhat does the 5th parameter mean?\u201d). Consider\n+    /// grouping some parameters into a new type.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b: f32) {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub TOO_MANY_ARGUMENTS,\n     complexity,\n     \"functions with too many arguments\"\n }\n \n-/// **What it does:** Checks for functions with a large amount of lines.\n-///\n-/// **Why is this bad?** Functions with a lot of lines are harder to understand\n-/// due to having to look at a larger amount of code to understand what the\n-/// function is doing. Consider splitting the body of the function into\n-/// multiple functions.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ``` rust\n-/// fn im_too_long() {\n-/// println!(\"\");\n-/// // ... 100 more LoC\n-/// println!(\"\");\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for functions with a large amount of lines.\n+    ///\n+    /// **Why is this bad?** Functions with a lot of lines are harder to understand\n+    /// due to having to look at a larger amount of code to understand what the\n+    /// function is doing. Consider splitting the body of the function into\n+    /// multiple functions.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ``` rust\n+    /// fn im_too_long() {\n+    /// println!(\"\");\n+    /// // ... 100 more LoC\n+    /// println!(\"\");\n+    /// }\n+    /// ```\n     pub TOO_MANY_LINES,\n     pedantic,\n     \"functions with too many lines\"\n }\n \n-/// **What it does:** Checks for public functions that dereferences raw pointer\n-/// arguments but are not marked unsafe.\n-///\n-/// **Why is this bad?** The function should probably be marked `unsafe`, since\n-/// for an arbitrary raw pointer, there is no way of telling for sure if it is\n-/// valid.\n-///\n-/// **Known problems:**\n-///\n-/// * It does not check functions recursively so if the pointer is passed to a\n-/// private non-`unsafe` function which does the dereferencing, the lint won't\n-/// trigger.\n-/// * It only checks for arguments whose type are raw pointers, not raw pointers\n-/// got from an argument in some other way (`fn foo(bar: &[*const u8])` or\n-/// `some_argument.get_raw_ptr()`).\n-///\n-/// **Example:**\n-/// ```rust\n-/// pub fn foo(x: *const u8) {\n-///     println!(\"{}\", unsafe { *x });\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for public functions that dereferences raw pointer\n+    /// arguments but are not marked unsafe.\n+    ///\n+    /// **Why is this bad?** The function should probably be marked `unsafe`, since\n+    /// for an arbitrary raw pointer, there is no way of telling for sure if it is\n+    /// valid.\n+    ///\n+    /// **Known problems:**\n+    ///\n+    /// * It does not check functions recursively so if the pointer is passed to a\n+    /// private non-`unsafe` function which does the dereferencing, the lint won't\n+    /// trigger.\n+    /// * It only checks for arguments whose type are raw pointers, not raw pointers\n+    /// got from an argument in some other way (`fn foo(bar: &[*const u8])` or\n+    /// `some_argument.get_raw_ptr()`).\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// pub fn foo(x: *const u8) {\n+    ///     println!(\"{}\", unsafe { *x });\n+    /// }\n+    /// ```\n     pub NOT_UNSAFE_PTR_ARG_DEREF,\n     correctness,\n     \"public functions dereferencing raw pointer arguments but not marked `unsafe`\""}, {"sha": "4d3c5273f0b0319005e27370ae1bc8810d51ab9e", "filename": "clippy_lints/src/identity_conversion.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_conversion.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -7,18 +7,18 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for always-identical `Into`/`From`/`IntoIter` conversions.\n-///\n-/// **Why is this bad?** Redundant code.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// // format!() returns a `String`\n-/// let s: String = format!(\"hello\").into();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for always-identical `Into`/`From`/`IntoIter` conversions.\n+    ///\n+    /// **Why is this bad?** Redundant code.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // format!() returns a `String`\n+    /// let s: String = format!(\"hello\").into();\n+    /// ```\n     pub IDENTITY_CONVERSION,\n     complexity,\n     \"using always-identical `Into`/`From`/`IntoIter` conversions\""}, {"sha": "06546be817b8fe809c0b0dac5b66d2927df1369d", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -6,18 +6,18 @@ use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for identity operations, e.g. `x + 0`.\n-///\n-/// **Why is this bad?** This code can be removed without changing the\n-/// meaning. So it just obscures what's going on. Delete it mercilessly.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x / 1 + 0 * 1 - 0 | 0\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for identity operations, e.g. `x + 0`.\n+    ///\n+    /// **Why is this bad?** This code can be removed without changing the\n+    /// meaning. So it just obscures what's going on. Delete it mercilessly.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x / 1 + 0 * 1 - 0 | 0\n+    /// ```\n     pub IDENTITY_OP,\n     complexity,\n     \"using identity operations, e.g. `x + 0` or `y / 1`\""}, {"sha": "5ce29597cab77c5c978a507782f314a43c87aa94", "filename": "clippy_lints/src/if_not_else.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fif_not_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fif_not_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_not_else.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -7,32 +7,32 @@ use syntax::ast::*;\n \n use crate::utils::span_help_and_lint;\n \n-/// **What it does:** Checks for usage of `!` or `!=` in an if condition with an\n-/// else branch.\n-///\n-/// **Why is this bad?** Negations reduce the readability of statements.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if !v.is_empty() {\n-///     a()\n-/// } else {\n-///     b()\n-/// }\n-/// ```\n-///\n-/// Could be written:\n-///\n-/// ```rust\n-/// if v.is_empty() {\n-///     b()\n-/// } else {\n-///     a()\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `!` or `!=` in an if condition with an\n+    /// else branch.\n+    ///\n+    /// **Why is this bad?** Negations reduce the readability of statements.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if !v.is_empty() {\n+    ///     a()\n+    /// } else {\n+    ///     b()\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// if v.is_empty() {\n+    ///     b()\n+    /// } else {\n+    ///     a()\n+    /// }\n+    /// ```\n     pub IF_NOT_ELSE,\n     pedantic,\n     \"`if` branches that could be swapped so no negation operation is necessary on the condition\""}, {"sha": "a82a57fe6ff316d0cf28acda865d1ed1fe504532", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,29 +5,29 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for missing return statements at the end of a block.\n-///\n-/// **Why is this bad?** Actually omitting the return keyword is idiomatic Rust code. Programmers\n-/// coming from other languages might prefer the expressiveness of `return`. It's possible to miss\n-/// the last returning statement because the only difference is a missing `;`. Especially in bigger\n-/// code with multiple return paths having a `return` keyword makes it easier to find the\n-/// corresponding statements.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo(x: usize) {\n-///     x\n-/// }\n-/// ```\n-/// add return\n-/// ```rust\n-/// fn foo(x: usize) {\n-///     return x;\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for missing return statements at the end of a block.\n+    ///\n+    /// **Why is this bad?** Actually omitting the return keyword is idiomatic Rust code. Programmers\n+    /// coming from other languages might prefer the expressiveness of `return`. It's possible to miss\n+    /// the last returning statement because the only difference is a missing `;`. Especially in bigger\n+    /// code with multiple return paths having a `return` keyword makes it easier to find the\n+    /// corresponding statements.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo(x: usize) {\n+    ///     x\n+    /// }\n+    /// ```\n+    /// add return\n+    /// ```rust\n+    /// fn foo(x: usize) {\n+    ///     return x;\n+    /// }\n+    /// ```\n     pub IMPLICIT_RETURN,\n     restriction,\n     \"use a return statement like `return expr` instead of an expression\""}, {"sha": "90129d794ac12b8f7e689e8cf6fc9f0b397b3814", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -10,75 +10,75 @@ use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use syntax::ast::RangeLimits;\n \n-/// **What it does:** Checks for out of bounds array indexing with a constant\n-/// index.\n-///\n-/// **Why is this bad?** This will always panic at runtime.\n-///\n-/// **Known problems:** Hopefully none.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = [1, 2, 3, 4];\n-///\n-/// // Bad\n-/// x[9];\n-/// &x[2..9];\n-///\n-/// // Good\n-/// x[0];\n-/// x[3];\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for out of bounds array indexing with a constant\n+    /// index.\n+    ///\n+    /// **Why is this bad?** This will always panic at runtime.\n+    ///\n+    /// **Known problems:** Hopefully none.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = [1, 2, 3, 4];\n+    ///\n+    /// // Bad\n+    /// x[9];\n+    /// &x[2..9];\n+    ///\n+    /// // Good\n+    /// x[0];\n+    /// x[3];\n+    /// ```\n     pub OUT_OF_BOUNDS_INDEXING,\n     correctness,\n     \"out of bounds constant indexing\"\n }\n \n-/// **What it does:** Checks for usage of indexing or slicing. Arrays are special cased, this lint\n-/// does report on arrays if we can tell that slicing operations are in bounds and does not\n-/// lint on constant `usize` indexing on arrays because that is handled by rustc's `const_err` lint.\n-///\n-/// **Why is this bad?** Indexing and slicing can panic at runtime and there are\n-/// safe alternatives.\n-///\n-/// **Known problems:** Hopefully none.\n-///\n-/// **Example:**\n-/// ```rust\n-/// // Vector\n-/// let x = vec![0; 5];\n-///\n-/// // Bad\n-/// x[2];\n-/// &x[2..100];\n-/// &x[2..];\n-/// &x[..100];\n-///\n-/// // Good\n-/// x.get(2);\n-/// x.get(2..100);\n-/// x.get(2..);\n-/// x.get(..100);\n-///\n-/// // Array\n-/// let y = [0, 1, 2, 3];\n-///\n-/// // Bad\n-/// &y[10..100];\n-/// &y[10..];\n-/// &y[..100];\n-///\n-/// // Good\n-/// &y[2..];\n-/// &y[..2];\n-/// &y[0..3];\n-/// y.get(10);\n-/// y.get(10..100);\n-/// y.get(10..);\n-/// y.get(..100);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of indexing or slicing. Arrays are special cased, this lint\n+    /// does report on arrays if we can tell that slicing operations are in bounds and does not\n+    /// lint on constant `usize` indexing on arrays because that is handled by rustc's `const_err` lint.\n+    ///\n+    /// **Why is this bad?** Indexing and slicing can panic at runtime and there are\n+    /// safe alternatives.\n+    ///\n+    /// **Known problems:** Hopefully none.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // Vector\n+    /// let x = vec![0; 5];\n+    ///\n+    /// // Bad\n+    /// x[2];\n+    /// &x[2..100];\n+    /// &x[2..];\n+    /// &x[..100];\n+    ///\n+    /// // Good\n+    /// x.get(2);\n+    /// x.get(2..100);\n+    /// x.get(2..);\n+    /// x.get(..100);\n+    ///\n+    /// // Array\n+    /// let y = [0, 1, 2, 3];\n+    ///\n+    /// // Bad\n+    /// &y[10..100];\n+    /// &y[10..];\n+    /// &y[..100];\n+    ///\n+    /// // Good\n+    /// &y[2..];\n+    /// &y[..2];\n+    /// &y[0..3];\n+    /// y.get(10);\n+    /// y.get(10..100);\n+    /// y.get(10..);\n+    /// y.get(..100);\n+    /// ```\n     pub INDEXING_SLICING,\n     restriction,\n     \"indexing/slicing usage\""}, {"sha": "762d3b17c926665b3ee4690aaaf726b7f50e11b7", "filename": "clippy_lints/src/infallible_destructuring_match.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,36 +5,36 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for matches being used to destructure a single-variant enum\n-/// or tuple struct where a `let` will suffice.\n-///\n-/// **Why is this bad?** Just readability \u2013 `let` doesn't nest, whereas a `match` does.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// enum Wrapper {\n-///     Data(i32),\n-/// }\n-///\n-/// let wrapper = Wrapper::Data(42);\n-///\n-/// let data = match wrapper {\n-///     Wrapper::Data(i) => i,\n-/// };\n-/// ```\n-///\n-/// The correct use would be:\n-/// ```rust\n-/// enum Wrapper {\n-///     Data(i32),\n-/// }\n-///\n-/// let wrapper = Wrapper::Data(42);\n-/// let Wrapper::Data(data) = wrapper;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for matches being used to destructure a single-variant enum\n+    /// or tuple struct where a `let` will suffice.\n+    ///\n+    /// **Why is this bad?** Just readability \u2013 `let` doesn't nest, whereas a `match` does.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// enum Wrapper {\n+    ///     Data(i32),\n+    /// }\n+    ///\n+    /// let wrapper = Wrapper::Data(42);\n+    ///\n+    /// let data = match wrapper {\n+    ///     Wrapper::Data(i) => i,\n+    /// };\n+    /// ```\n+    ///\n+    /// The correct use would be:\n+    /// ```rust\n+    /// enum Wrapper {\n+    ///     Data(i32),\n+    /// }\n+    ///\n+    /// let wrapper = Wrapper::Data(42);\n+    /// let Wrapper::Data(data) = wrapper;\n+    /// ```\n     pub INFALLIBLE_DESTRUCTURING_MATCH,\n     style,\n     \"a match statement with a single infallible arm instead of a `let`\""}, {"sha": "bee28a4b741dcdde5316d5f0bf30ef40329c6ad2", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -3,36 +3,36 @@ use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for iteration that is guaranteed to be infinite.\n-///\n-/// **Why is this bad?** While there may be places where this is acceptable\n-/// (e.g. in event streams), in most cases this is simply an error.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// repeat(1_u8).iter().collect::<Vec<_>>()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for iteration that is guaranteed to be infinite.\n+    ///\n+    /// **Why is this bad?** While there may be places where this is acceptable\n+    /// (e.g. in event streams), in most cases this is simply an error.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// repeat(1_u8).iter().collect::<Vec<_>>()\n+    /// ```\n     pub INFINITE_ITER,\n     correctness,\n     \"infinite iteration\"\n }\n \n-/// **What it does:** Checks for iteration that may be infinite.\n-///\n-/// **Why is this bad?** While there may be places where this is acceptable\n-/// (e.g. in event streams), in most cases this is simply an error.\n-///\n-/// **Known problems:** The code may have a condition to stop iteration, but\n-/// this lint is not clever enough to analyze it.\n-///\n-/// **Example:**\n-/// ```rust\n-/// [0..].iter().zip(infinite_iter.take_while(|x| x > 5))\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for iteration that may be infinite.\n+    ///\n+    /// **Why is this bad?** While there may be places where this is acceptable\n+    /// (e.g. in event streams), in most cases this is simply an error.\n+    ///\n+    /// **Known problems:** The code may have a condition to stop iteration, but\n+    /// this lint is not clever enough to analyze it.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// [0..].iter().zip(infinite_iter.take_while(|x| x > 5))\n+    /// ```\n     pub MAYBE_INFINITE_ITER,\n     pedantic,\n     \"possible infinite iteration\""}, {"sha": "51d6c310cf628f0ec87c5971f0d7dd7874241e70", "filename": "clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_impl.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -8,33 +8,33 @@ use rustc_data_structures::fx::FxHashMap;\n use std::default::Default;\n use syntax_pos::Span;\n \n-/// **What it does:** Checks for multiple inherent implementations of a struct\n-///\n-/// **Why is this bad?** Splitting the implementation of a type makes the code harder to navigate.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// struct X;\n-/// impl X {\n-///     fn one() {}\n-/// }\n-/// impl X {\n-///     fn other() {}\n-/// }\n-/// ```\n-///\n-/// Could be written:\n-///\n-/// ```rust\n-/// struct X;\n-/// impl X {\n-///     fn one() {}\n-///     fn other() {}\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for multiple inherent implementations of a struct\n+    ///\n+    /// **Why is this bad?** Splitting the implementation of a type makes the code harder to navigate.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// struct X;\n+    /// impl X {\n+    ///     fn one() {}\n+    /// }\n+    /// impl X {\n+    ///     fn other() {}\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// struct X;\n+    /// impl X {\n+    ///     fn one() {}\n+    ///     fn other() {}\n+    /// }\n+    /// ```\n     pub MULTIPLE_INHERENT_IMPL,\n     restriction,\n     \"Multiple inherent impl that could be grouped\""}, {"sha": "cced334f43a8c517c2279adaf8508d62ece4aeed", "filename": "clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -8,21 +8,21 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::ast::{Attribute, Name};\n \n-/// **What it does:** Checks for `#[inline]` on trait methods without bodies\n-///\n-/// **Why is this bad?** Only implementations of trait methods may be inlined.\n-/// The inline attribute is ignored for trait methods without bodies.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// trait Animal {\n-///     #[inline]\n-///     fn name(&self) -> &'static str;\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `#[inline]` on trait methods without bodies\n+    ///\n+    /// **Why is this bad?** Only implementations of trait methods may be inlined.\n+    /// The inline attribute is ignored for trait methods without bodies.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// trait Animal {\n+    ///     #[inline]\n+    ///     fn name(&self) -> &'static str;\n+    /// }\n+    /// ```\n     pub INLINE_FN_WITHOUT_BODY,\n     correctness,\n     \"use of `#[inline]` on trait methods without bodies\""}, {"sha": "bab7374916dab9991708a46a8410491b91d21365", "filename": "clippy_lints/src/int_plus_one.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fint_plus_one.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -7,24 +7,24 @@ use syntax::ast::*;\n \n use crate::utils::{snippet_opt, span_lint_and_then};\n \n-/// **What it does:** Checks for usage of `x >= y + 1` or `x - 1 >= y` (and `<=`) in a block\n-///\n-///\n-/// **Why is this bad?** Readability -- better to use `> y` instead of `>= y + 1`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x >= y + 1\n-/// ```\n-///\n-/// Could be written:\n-///\n-/// ```rust\n-/// x > y\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `x >= y + 1` or `x - 1 >= y` (and `<=`) in a block\n+    ///\n+    ///\n+    /// **Why is this bad?** Readability -- better to use `> y` instead of `>= y + 1`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x >= y + 1\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// x > y\n+    /// ```\n     pub INT_PLUS_ONE,\n     complexity,\n     \"instead of using x >= y + 1, use x > y\""}, {"sha": "63011726b4f718ba87a594602153d7193a76a5e1", "filename": "clippy_lints/src/invalid_ref.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Finvalid_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Finvalid_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finvalid_ref.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,17 +5,17 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for creation of references to zeroed or uninitialized memory.\n-///\n-/// **Why is this bad?** Creation of null references is undefined behavior.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let bad_ref: &usize = std::mem::zeroed();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for creation of references to zeroed or uninitialized memory.\n+    ///\n+    /// **Why is this bad?** Creation of null references is undefined behavior.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let bad_ref: &usize = std::mem::zeroed();\n+    /// ```\n     pub INVALID_REF,\n     correctness,\n     \"creation of invalid reference\""}, {"sha": "f93f515d0239d7d9dc80624aac0c4d6d1fecfd1f", "filename": "clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -6,29 +6,29 @@ use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use syntax::ast::*;\n \n-/// **What it does:** Checks for items declared after some statement in a block.\n-///\n-/// **Why is this bad?** Items live for the entire scope they are declared\n-/// in. But statements are processed in order. This might cause confusion as\n-/// it's hard to figure out which item is meant in a statement.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo() {\n-///     println!(\"cake\");\n-/// }\n-///\n-/// fn main() {\n-///     foo(); // prints \"foo\"\n-///     fn foo() {\n-///         println!(\"foo\");\n-///     }\n-///     foo(); // prints \"foo\"\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for items declared after some statement in a block.\n+    ///\n+    /// **Why is this bad?** Items live for the entire scope they are declared\n+    /// in. But statements are processed in order. This might cause confusion as\n+    /// it's hard to figure out which item is meant in a statement.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo() {\n+    ///     println!(\"cake\");\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     foo(); // prints \"foo\"\n+    ///     fn foo() {\n+    ///         println!(\"foo\");\n+    ///     }\n+    ///     foo(); // prints \"foo\"\n+    /// }\n+    /// ```\n     pub ITEMS_AFTER_STATEMENTS,\n     pedantic,\n     \"blocks where an item comes after a statement\""}, {"sha": "2e38fcf03672bc4cdc976de7db2a928aa852eab7", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -7,23 +7,23 @@ use rustc::ty::layout::LayoutOf;\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for large size differences between variants on\n-/// `enum`s.\n-///\n-/// **Why is this bad?** Enum size is bounded by the largest variant. Having a\n-/// large variant\n-/// can penalize the memory layout of that enum.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// enum Test {\n-///     A(i32),\n-///     B([i32; 8000]),\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for large size differences between variants on\n+    /// `enum`s.\n+    ///\n+    /// **Why is this bad?** Enum size is bounded by the largest variant. Having a\n+    /// large variant\n+    /// can penalize the memory layout of that enum.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// enum Test {\n+    ///     A(i32),\n+    ///     B([i32; 8000]),\n+    /// }\n+    /// ```\n     pub LARGE_ENUM_VARIANT,\n     perf,\n     \"large size difference between variants on an enum\""}, {"sha": "c802b267df2f86d39f61cc2336f2a614ac2caac0", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 51, "deletions": 52, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -9,62 +9,61 @@ use rustc_errors::Applicability;\n use syntax::ast::{Lit, LitKind, Name};\n use syntax::source_map::{Span, Spanned};\n \n-/// **What it does:** Checks for getting the length of something via `.len()`\n-/// just to compare to zero, and suggests using `.is_empty()` where applicable.\n-///\n-/// **Why is this bad?** Some structures can answer `.is_empty()` much faster\n-/// than calculating their length. Notably, for slices, getting the length\n-/// requires a subtraction whereas `.is_empty()` is just a comparison. So it is\n-/// good to get into the habit of using `.is_empty()`, and having it is cheap.\n-/// Besides, it makes the intent clearer than a manual comparison.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if x.len() == 0 {\n-///     ..\n-/// }\n-/// if y.len() != 0 {\n-///     ..\n-/// }\n-/// ```\n-/// instead use\n-/// ```rust\n-/// if x.is_empty() {\n-///     ..\n-/// }\n-/// if !y.is_empty() {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n-pub LEN_ZERO,\n-style,\n-\"checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` \\\n- could be used instead\"\n+    /// **What it does:** Checks for getting the length of something via `.len()`\n+    /// just to compare to zero, and suggests using `.is_empty()` where applicable.\n+    ///\n+    /// **Why is this bad?** Some structures can answer `.is_empty()` much faster\n+    /// than calculating their length. Notably, for slices, getting the length\n+    /// requires a subtraction whereas `.is_empty()` is just a comparison. So it is\n+    /// good to get into the habit of using `.is_empty()`, and having it is cheap.\n+    /// Besides, it makes the intent clearer than a manual comparison.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if x.len() == 0 {\n+    ///     ..\n+    /// }\n+    /// if y.len() != 0 {\n+    ///     ..\n+    /// }\n+    /// ```\n+    /// instead use\n+    /// ```rust\n+    /// if x.is_empty() {\n+    ///     ..\n+    /// }\n+    /// if !y.is_empty() {\n+    ///     ..\n+    /// }\n+    /// ```\n+    pub LEN_ZERO,\n+    style,\n+    \"checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead\"\n }\n \n-/// **What it does:** Checks for items that implement `.len()` but not\n-/// `.is_empty()`.\n-///\n-/// **Why is this bad?** It is good custom to have both methods, because for\n-/// some data structures, asking about the length will be a costly operation,\n-/// whereas `.is_empty()` can usually answer in constant time. Also it used to\n-/// lead to false positives on the [`len_zero`](#len_zero) lint \u2013 currently that\n-/// lint will ignore such entities.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// impl X {\n-///     pub fn len(&self) -> usize {\n-///         ..\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for items that implement `.len()` but not\n+    /// `.is_empty()`.\n+    ///\n+    /// **Why is this bad?** It is good custom to have both methods, because for\n+    /// some data structures, asking about the length will be a costly operation,\n+    /// whereas `.is_empty()` can usually answer in constant time. Also it used to\n+    /// lead to false positives on the [`len_zero`](#len_zero) lint \u2013 currently that\n+    /// lint will ignore such entities.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// impl X {\n+    ///     pub fn len(&self) -> usize {\n+    ///         ..\n+    ///     }\n+    /// }\n+    /// ```\n     pub LEN_WITHOUT_IS_EMPTY,\n     style,\n     \"traits or impls with a public `len` method but no corresponding `is_empty` method\""}, {"sha": "e3533ed6d02166dcd233e6198d0881e950d00824", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -8,46 +8,46 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::ast;\n \n-/// **What it does:** Checks for variable declarations immediately followed by a\n-/// conditional affectation.\n-///\n-/// **Why is this bad?** This is not idiomatic Rust.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// let foo;\n-///\n-/// if bar() {\n-///     foo = 42;\n-/// } else {\n-///     foo = 0;\n-/// }\n-///\n-/// let mut baz = None;\n-///\n-/// if bar() {\n-///     baz = Some(42);\n-/// }\n-/// ```\n-///\n-/// should be written\n-///\n-/// ```rust,ignore\n-/// let foo = if bar() {\n-///     42\n-/// } else {\n-///     0\n-/// };\n-///\n-/// let baz = if bar() {\n-///     Some(42)\n-/// } else {\n-///     None\n-/// };\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for variable declarations immediately followed by a\n+    /// conditional affectation.\n+    ///\n+    /// **Why is this bad?** This is not idiomatic Rust.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// let foo;\n+    ///\n+    /// if bar() {\n+    ///     foo = 42;\n+    /// } else {\n+    ///     foo = 0;\n+    /// }\n+    ///\n+    /// let mut baz = None;\n+    ///\n+    /// if bar() {\n+    ///     baz = Some(42);\n+    /// }\n+    /// ```\n+    ///\n+    /// should be written\n+    ///\n+    /// ```rust,ignore\n+    /// let foo = if bar() {\n+    ///     42\n+    /// } else {\n+    ///     0\n+    /// };\n+    ///\n+    /// let baz = if bar() {\n+    ///     Some(42)\n+    /// } else {\n+    ///     None\n+    /// };\n+    /// ```\n     pub USELESS_LET_IF_SEQ,\n     style,\n     \"unidiomatic `let mut` declaration followed by initialization in `if`\""}, {"sha": "ae24ef54c27c1ae4a5e7b9e7551f9e34a23132a9", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 56, "deletions": 36, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -39,7 +39,7 @@ use toml;\n ///\n /// Every lint declaration consists of 4 parts:\n ///\n-/// 1. The documentation above the lint, which is used for the website\n+/// 1. The documentation, which is used for the website\n /// 2. The `LINT_NAME`. See [lint naming][lint_naming] on lint naming conventions.\n /// 3. The `lint_level`, which is a mapping from *one* of our lint groups to `Allow`, `Warn` or\n ///    `Deny`. The lint level here has nothing to do with what lint groups the lint is a part of.\n@@ -60,22 +60,22 @@ use toml;\n /// # use clippy_lints::declare_clippy_lint;\n /// use rustc::declare_tool_lint;\n ///\n-/// /// **What it does:** Checks for ... (describe what the lint matches).\n-/// ///\n-/// /// **Why is this bad?** Supply the reason for linting the code.\n-/// ///\n-/// /// **Known problems:** None. (Or describe where it could go wrong.)\n-/// ///\n-/// /// **Example:**\n-/// ///\n-/// /// ```rust\n-/// /// // Bad\n-/// /// Insert a short example of code that triggers the lint\n-/// ///\n-/// /// // Good\n-/// /// Insert a short example of improved code that doesn't trigger the lint\n-/// /// ```\n /// declare_clippy_lint! {\n+///     /// **What it does:** Checks for ... (describe what the lint matches).\n+///     ///\n+///     /// **Why is this bad?** Supply the reason for linting the code.\n+///     ///\n+///     /// **Known problems:** None. (Or describe where it could go wrong.)\n+///     ///\n+///     /// **Example:**\n+///     ///\n+///     /// ```rust\n+///     /// // Bad\n+///     /// Insert a short example of code that triggers the lint\n+///     ///\n+///     /// // Good\n+///     /// Insert a short example of improved code that doesn't trigger the lint\n+///     /// ```\n ///     pub LINT_NAME,\n ///     pedantic,\n ///     \"description\"\n@@ -84,35 +84,55 @@ use toml;\n /// [lint_naming]: https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints\n #[macro_export]\n macro_rules! declare_clippy_lint {\n-    { pub $name:tt, style, $description:tt } => {\n-        declare_tool_lint! { pub clippy::$name, Warn, $description, report_in_external_macro: true }\n+    { $(#[$attr:meta])* pub $name:tt, style, $description:tt } => {\n+        declare_tool_lint! {\n+            $(#[$attr])* pub clippy::$name, Warn, $description, report_in_external_macro: true\n+        }\n     };\n-    { pub $name:tt, correctness, $description:tt } => {\n-        declare_tool_lint! { pub clippy::$name, Deny, $description, report_in_external_macro: true }\n+    { $(#[$attr:meta])* pub $name:tt, correctness, $description:tt } => {\n+        declare_tool_lint! {\n+            $(#[$attr])* pub clippy::$name, Deny, $description, report_in_external_macro: true\n+        }\n     };\n-    { pub $name:tt, complexity, $description:tt } => {\n-        declare_tool_lint! { pub clippy::$name, Warn, $description, report_in_external_macro: true }\n+    { $(#[$attr:meta])* pub $name:tt, complexity, $description:tt } => {\n+        declare_tool_lint! {\n+            pub clippy::$name, Warn, $description, report_in_external_macro: true\n+        }\n     };\n-    { pub $name:tt, perf, $description:tt } => {\n-        declare_tool_lint! { pub clippy::$name, Warn, $description, report_in_external_macro: true }\n+    { $(#[$attr:meta])* pub $name:tt, perf, $description:tt } => {\n+        declare_tool_lint! {\n+            pub clippy::$name, Warn, $description, report_in_external_macro: true\n+        }\n     };\n-    { pub $name:tt, pedantic, $description:tt } => {\n-        declare_tool_lint! { pub clippy::$name, Allow, $description, report_in_external_macro: true }\n+    { $(#[$attr:meta])* pub $name:tt, pedantic, $description:tt } => {\n+        declare_tool_lint! {\n+            pub clippy::$name, Allow, $description, report_in_external_macro: true\n+        }\n     };\n-    { pub $name:tt, restriction, $description:tt } => {\n-        declare_tool_lint! { pub clippy::$name, Allow, $description, report_in_external_macro: true }\n+    { $(#[$attr:meta])* pub $name:tt, restriction, $description:tt } => {\n+        declare_tool_lint! {\n+            pub clippy::$name, Allow, $description, report_in_external_macro: true\n+        }\n     };\n-    { pub $name:tt, cargo, $description:tt } => {\n-        declare_tool_lint! { pub clippy::$name, Allow, $description, report_in_external_macro: true }\n+    { $(#[$attr:meta])* pub $name:tt, cargo, $description:tt } => {\n+        declare_tool_lint! {\n+            pub clippy::$name, Allow, $description, report_in_external_macro: true\n+        }\n     };\n-    { pub $name:tt, nursery, $description:tt } => {\n-        declare_tool_lint! { pub clippy::$name, Allow, $description, report_in_external_macro: true }\n+    { $(#[$attr:meta])* pub $name:tt, nursery, $description:tt } => {\n+        declare_tool_lint! {\n+            pub clippy::$name, Allow, $description, report_in_external_macro: true\n+        }\n     };\n-    { pub $name:tt, internal, $description:tt } => {\n-        declare_tool_lint! { pub clippy::$name, Allow, $description, report_in_external_macro: true }\n+    { $(#[$attr:meta])* pub $name:tt, internal, $description:tt } => {\n+        declare_tool_lint! {\n+            pub clippy::$name, Allow, $description, report_in_external_macro: true\n+        }\n     };\n-    { pub $name:tt, internal_warn, $description:tt } => {\n-        declare_tool_lint! { pub clippy::$name, Warn, $description, report_in_external_macro: true }\n+    { $(#[$attr:meta])* pub $name:tt, internal_warn, $description:tt } => {\n+        declare_tool_lint! {\n+            pub clippy::$name, Warn, $description, report_in_external_macro: true\n+        }\n     };\n }\n "}, {"sha": "0d417fb8b6b0100e65b91683e2b411539da43e8a", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -10,45 +10,45 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use syntax::source_map::Span;\n use syntax::symbol::keywords;\n \n-/// **What it does:** Checks for lifetime annotations which can be removed by\n-/// relying on lifetime elision.\n-///\n-/// **Why is this bad?** The additional lifetimes make the code look more\n-/// complicated, while there is nothing out of the ordinary going on. Removing\n-/// them leads to more readable code.\n-///\n-/// **Known problems:** Potential false negatives: we bail out if the function\n-/// has a `where` clause where lifetimes are mentioned.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn in_and_out<'a>(x: &'a u8, y: u8) -> &'a u8 {\n-///     x\n-/// }\n-/// ```\n declare_clippy_lint! {\n-pub NEEDLESS_LIFETIMES,\n-complexity,\n-\"using explicit lifetimes for references in function arguments when elision rules \\\n- would allow omitting them\"\n+    /// **What it does:** Checks for lifetime annotations which can be removed by\n+    /// relying on lifetime elision.\n+    ///\n+    /// **Why is this bad?** The additional lifetimes make the code look more\n+    /// complicated, while there is nothing out of the ordinary going on. Removing\n+    /// them leads to more readable code.\n+    ///\n+    /// **Known problems:** Potential false negatives: we bail out if the function\n+    /// has a `where` clause where lifetimes are mentioned.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn in_and_out<'a>(x: &'a u8, y: u8) -> &'a u8 {\n+    ///     x\n+    /// }\n+    /// ```\n+    pub NEEDLESS_LIFETIMES,\n+    complexity,\n+    \"using explicit lifetimes for references in function arguments when elision rules \\\n+     would allow omitting them\"\n }\n \n-/// **What it does:** Checks for lifetimes in generics that are never used\n-/// anywhere else.\n-///\n-/// **Why is this bad?** The additional lifetimes make the code look more\n-/// complicated, while there is nothing out of the ordinary going on. Removing\n-/// them leads to more readable code.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn unused_lifetime<'a>(x: u8) {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for lifetimes in generics that are never used\n+    /// anywhere else.\n+    ///\n+    /// **Why is this bad?** The additional lifetimes make the code look more\n+    /// complicated, while there is nothing out of the ordinary going on. Removing\n+    /// them leads to more readable code.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn unused_lifetime<'a>(x: u8) {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub EXTRA_UNUSED_LIFETIMES,\n     complexity,\n     \"unused lifetimes in function definitions\""}, {"sha": "92cc288abb67ec56043d2b12431bbad020040808", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -9,95 +9,95 @@ use rustc_errors::Applicability;\n use syntax::ast::*;\n use syntax_pos;\n \n-/// **What it does:** Warns if a long integral or floating-point constant does\n-/// not contain underscores.\n-///\n-/// **Why is this bad?** Reading long numbers is difficult without separators.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// 61864918973511\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Warns if a long integral or floating-point constant does\n+    /// not contain underscores.\n+    ///\n+    /// **Why is this bad?** Reading long numbers is difficult without separators.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// 61864918973511\n+    /// ```\n     pub UNREADABLE_LITERAL,\n     style,\n     \"long integer literal without underscores\"\n }\n \n-/// **What it does:** Warns for mistyped suffix in literals\n-///\n-/// **Why is this bad?** This is most probably a typo\n-///\n-/// **Known problems:**\n-/// \t\t- Recommends a signed suffix, even though the number might be too big and an unsigned\n-///\t\tsuffix is required\n-/// \t\t- Does not match on `_128` since that is a valid grouping for decimal and octal numbers\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// 2_32\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Warns for mistyped suffix in literals\n+    ///\n+    /// **Why is this bad?** This is most probably a typo\n+    ///\n+    /// **Known problems:**\n+    /// \t\t- Recommends a signed suffix, even though the number might be too big and an unsigned\n+    ///\t\tsuffix is required\n+    /// \t\t- Does not match on `_128` since that is a valid grouping for decimal and octal numbers\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// 2_32\n+    /// ```\n     pub MISTYPED_LITERAL_SUFFIXES,\n     correctness,\n     \"mistyped literal suffix\"\n }\n \n-/// **What it does:** Warns if an integral or floating-point constant is\n-/// grouped inconsistently with underscores.\n-///\n-/// **Why is this bad?** Readers may incorrectly interpret inconsistently\n-/// grouped digits.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// 618_64_9189_73_511\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Warns if an integral or floating-point constant is\n+    /// grouped inconsistently with underscores.\n+    ///\n+    /// **Why is this bad?** Readers may incorrectly interpret inconsistently\n+    /// grouped digits.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// 618_64_9189_73_511\n+    /// ```\n     pub INCONSISTENT_DIGIT_GROUPING,\n     style,\n     \"integer literals with digits grouped inconsistently\"\n }\n \n-/// **What it does:** Warns if the digits of an integral or floating-point\n-/// constant are grouped into groups that\n-/// are too large.\n-///\n-/// **Why is this bad?** Negatively impacts readability.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// 6186491_8973511\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Warns if the digits of an integral or floating-point\n+    /// constant are grouped into groups that\n+    /// are too large.\n+    ///\n+    /// **Why is this bad?** Negatively impacts readability.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// 6186491_8973511\n+    /// ```\n     pub LARGE_DIGIT_GROUPS,\n     pedantic,\n     \"grouping digits into groups that are too large\"\n }\n \n-/// **What it does:** Warns if there is a better representation for a numeric literal.\n-///\n-/// **Why is this bad?** Especially for big powers of 2 a hexadecimal representation is more\n-/// readable than a decimal representation.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// `255` => `0xFF`\n-/// `65_535` => `0xFFFF`\n-/// `4_042_322_160` => `0xF0F0_F0F0`\n declare_clippy_lint! {\n+    /// **What it does:** Warns if there is a better representation for a numeric literal.\n+    ///\n+    /// **Why is this bad?** Especially for big powers of 2 a hexadecimal representation is more\n+    /// readable than a decimal representation.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// `255` => `0xFF`\n+    /// `65_535` => `0xFFFF`\n+    /// `4_042_322_160` => `0xF0F0_F0F0`\n     pub DECIMAL_LITERAL_REPRESENTATION,\n     restriction,\n     \"using decimal representation when hexadecimal would be better\""}, {"sha": "35d9bf38797a66f5f4a99470bac12b52c229b014", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 299, "deletions": 299, "changes": 598, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -32,408 +32,408 @@ use crate::utils::{\n     span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, SpanlessEq,\n };\n \n-/// **What it does:** Checks for for-loops that manually copy items between\n-/// slices that could be optimized by having a memcpy.\n-///\n-/// **Why is this bad?** It is not as fast as a memcpy.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for i in 0..src.len() {\n-///     dst[i + 64] = src[i];\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for for-loops that manually copy items between\n+    /// slices that could be optimized by having a memcpy.\n+    ///\n+    /// **Why is this bad?** It is not as fast as a memcpy.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// for i in 0..src.len() {\n+    ///     dst[i + 64] = src[i];\n+    /// }\n+    /// ```\n     pub MANUAL_MEMCPY,\n     perf,\n     \"manually copying items between slices\"\n }\n \n-/// **What it does:** Checks for looping over the range of `0..len` of some\n-/// collection just to get the values by index.\n-///\n-/// **Why is this bad?** Just iterating the collection itself makes the intent\n-/// more clear and is probably faster.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for i in 0..vec.len() {\n-///     println!(\"{}\", vec[i]);\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for looping over the range of `0..len` of some\n+    /// collection just to get the values by index.\n+    ///\n+    /// **Why is this bad?** Just iterating the collection itself makes the intent\n+    /// more clear and is probably faster.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// for i in 0..vec.len() {\n+    ///     println!(\"{}\", vec[i]);\n+    /// }\n+    /// ```\n     pub NEEDLESS_RANGE_LOOP,\n     style,\n     \"for-looping over a range of indices where an iterator over items would do\"\n }\n \n-/// **What it does:** Checks for loops on `x.iter()` where `&x` will do, and\n-/// suggests the latter.\n-///\n-/// **Why is this bad?** Readability.\n-///\n-/// **Known problems:** False negatives. We currently only warn on some known\n-/// types.\n-///\n-/// **Example:**\n-/// ```rust\n-/// // with `y` a `Vec` or slice:\n-/// for x in y.iter() {\n-///     ..\n-/// }\n-/// ```\n-/// can be rewritten to\n-/// ```rust\n-/// for x in &y {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for loops on `x.iter()` where `&x` will do, and\n+    /// suggests the latter.\n+    ///\n+    /// **Why is this bad?** Readability.\n+    ///\n+    /// **Known problems:** False negatives. We currently only warn on some known\n+    /// types.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // with `y` a `Vec` or slice:\n+    /// for x in y.iter() {\n+    ///     ..\n+    /// }\n+    /// ```\n+    /// can be rewritten to\n+    /// ```rust\n+    /// for x in &y {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub EXPLICIT_ITER_LOOP,\n     pedantic,\n     \"for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\"\n }\n \n-/// **What it does:** Checks for loops on `y.into_iter()` where `y` will do, and\n-/// suggests the latter.\n-///\n-/// **Why is this bad?** Readability.\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// // with `y` a `Vec` or slice:\n-/// for x in y.into_iter() {\n-///     ..\n-/// }\n-/// ```\n-/// can be rewritten to\n-/// ```rust\n-/// for x in y {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for loops on `y.into_iter()` where `y` will do, and\n+    /// suggests the latter.\n+    ///\n+    /// **Why is this bad?** Readability.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // with `y` a `Vec` or slice:\n+    /// for x in y.into_iter() {\n+    ///     ..\n+    /// }\n+    /// ```\n+    /// can be rewritten to\n+    /// ```rust\n+    /// for x in y {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub EXPLICIT_INTO_ITER_LOOP,\n     pedantic,\n     \"for-looping over `_.into_iter()` when `_` would do\"\n }\n \n-/// **What it does:** Checks for loops on `x.next()`.\n-///\n-/// **Why is this bad?** `next()` returns either `Some(value)` if there was a\n-/// value, or `None` otherwise. The insidious thing is that `Option<_>`\n-/// implements `IntoIterator`, so that possibly one value will be iterated,\n-/// leading to some hard to find bugs. No one will want to write such code\n-/// [except to win an Underhanded Rust\n-/// Contest](https://www.reddit.com/r/rust/comments/3hb0wm/underhanded_rust_contest/cu5yuhr).\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for x in y.next() {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for loops on `x.next()`.\n+    ///\n+    /// **Why is this bad?** `next()` returns either `Some(value)` if there was a\n+    /// value, or `None` otherwise. The insidious thing is that `Option<_>`\n+    /// implements `IntoIterator`, so that possibly one value will be iterated,\n+    /// leading to some hard to find bugs. No one will want to write such code\n+    /// [except to win an Underhanded Rust\n+    /// Contest](https://www.reddit.com/r/rust/comments/3hb0wm/underhanded_rust_contest/cu5yuhr).\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// for x in y.next() {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub ITER_NEXT_LOOP,\n     correctness,\n     \"for-looping over `_.next()` which is probably not intended\"\n }\n \n-/// **What it does:** Checks for `for` loops over `Option` values.\n-///\n-/// **Why is this bad?** Readability. This is more clearly expressed as an `if\n-/// let`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for x in option {\n-///     ..\n-/// }\n-/// ```\n-///\n-/// This should be\n-/// ```rust\n-/// if let Some(x) = option {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `for` loops over `Option` values.\n+    ///\n+    /// **Why is this bad?** Readability. This is more clearly expressed as an `if\n+    /// let`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// for x in option {\n+    ///     ..\n+    /// }\n+    /// ```\n+    ///\n+    /// This should be\n+    /// ```rust\n+    /// if let Some(x) = option {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub FOR_LOOP_OVER_OPTION,\n     correctness,\n     \"for-looping over an `Option`, which is more clearly expressed as an `if let`\"\n }\n \n-/// **What it does:** Checks for `for` loops over `Result` values.\n-///\n-/// **Why is this bad?** Readability. This is more clearly expressed as an `if\n-/// let`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for x in result {\n-///     ..\n-/// }\n-/// ```\n-///\n-/// This should be\n-/// ```rust\n-/// if let Ok(x) = result {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `for` loops over `Result` values.\n+    ///\n+    /// **Why is this bad?** Readability. This is more clearly expressed as an `if\n+    /// let`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// for x in result {\n+    ///     ..\n+    /// }\n+    /// ```\n+    ///\n+    /// This should be\n+    /// ```rust\n+    /// if let Ok(x) = result {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub FOR_LOOP_OVER_RESULT,\n     correctness,\n     \"for-looping over a `Result`, which is more clearly expressed as an `if let`\"\n }\n \n-/// **What it does:** Detects `loop + match` combinations that are easier\n-/// written as a `while let` loop.\n-///\n-/// **Why is this bad?** The `while let` loop is usually shorter and more\n-/// readable.\n-///\n-/// **Known problems:** Sometimes the wrong binding is displayed (#383).\n-///\n-/// **Example:**\n-/// ```rust\n-/// loop {\n-///     let x = match y {\n-///         Some(x) => x,\n-///         None => break,\n-///     }\n-///     // .. do something with x\n-/// }\n-/// // is easier written as\n-/// while let Some(x) = y {\n-///     // .. do something with x\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Detects `loop + match` combinations that are easier\n+    /// written as a `while let` loop.\n+    ///\n+    /// **Why is this bad?** The `while let` loop is usually shorter and more\n+    /// readable.\n+    ///\n+    /// **Known problems:** Sometimes the wrong binding is displayed (#383).\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// loop {\n+    ///     let x = match y {\n+    ///         Some(x) => x,\n+    ///         None => break,\n+    ///     }\n+    ///     // .. do something with x\n+    /// }\n+    /// // is easier written as\n+    /// while let Some(x) = y {\n+    ///     // .. do something with x\n+    /// }\n+    /// ```\n     pub WHILE_LET_LOOP,\n     complexity,\n     \"`loop { if let { ... } else break }`, which can be written as a `while let` loop\"\n }\n \n-/// **What it does:** Checks for using `collect()` on an iterator without using\n-/// the result.\n-///\n-/// **Why is this bad?** It is more idiomatic to use a `for` loop over the\n-/// iterator instead.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// vec.iter().map(|x| /* some operation returning () */).collect::<Vec<_>>();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for using `collect()` on an iterator without using\n+    /// the result.\n+    ///\n+    /// **Why is this bad?** It is more idiomatic to use a `for` loop over the\n+    /// iterator instead.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// vec.iter().map(|x| /* some operation returning () */).collect::<Vec<_>>();\n+    /// ```\n     pub UNUSED_COLLECT,\n     perf,\n     \"`collect()`ing an iterator without using the result; this is usually better written as a for loop\"\n }\n \n-/// **What it does:** Checks for functions collecting an iterator when collect\n-/// is not needed.\n-///\n-/// **Why is this bad?** `collect` causes the allocation of a new data structure,\n-/// when this allocation may not be needed.\n-///\n-/// **Known problems:**\n-/// None\n-///\n-/// **Example:**\n-/// ```rust\n-/// let len = iterator.collect::<Vec<_>>().len();\n-/// // should be\n-/// let len = iterator.count();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for functions collecting an iterator when collect\n+    /// is not needed.\n+    ///\n+    /// **Why is this bad?** `collect` causes the allocation of a new data structure,\n+    /// when this allocation may not be needed.\n+    ///\n+    /// **Known problems:**\n+    /// None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let len = iterator.collect::<Vec<_>>().len();\n+    /// // should be\n+    /// let len = iterator.count();\n+    /// ```\n     pub NEEDLESS_COLLECT,\n     perf,\n     \"collecting an iterator when collect is not needed\"\n }\n \n-/// **What it does:** Checks for loops over ranges `x..y` where both `x` and `y`\n-/// are constant and `x` is greater or equal to `y`, unless the range is\n-/// reversed or has a negative `.step_by(_)`.\n-///\n-/// **Why is it bad?** Such loops will either be skipped or loop until\n-/// wrap-around (in debug code, this may `panic!()`). Both options are probably\n-/// not intended.\n-///\n-/// **Known problems:** The lint cannot catch loops over dynamically defined\n-/// ranges. Doing this would require simulating all possible inputs and code\n-/// paths through the program, which would be complex and error-prone.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for x in 5..10 - 5 {\n-///     ..\n-/// } // oops, stray `-`\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for loops over ranges `x..y` where both `x` and `y`\n+    /// are constant and `x` is greater or equal to `y`, unless the range is\n+    /// reversed or has a negative `.step_by(_)`.\n+    ///\n+    /// **Why is it bad?** Such loops will either be skipped or loop until\n+    /// wrap-around (in debug code, this may `panic!()`). Both options are probably\n+    /// not intended.\n+    ///\n+    /// **Known problems:** The lint cannot catch loops over dynamically defined\n+    /// ranges. Doing this would require simulating all possible inputs and code\n+    /// paths through the program, which would be complex and error-prone.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// for x in 5..10 - 5 {\n+    ///     ..\n+    /// } // oops, stray `-`\n+    /// ```\n     pub REVERSE_RANGE_LOOP,\n     correctness,\n     \"iteration over an empty range, such as `10..0` or `5..5`\"\n }\n \n-/// **What it does:** Checks `for` loops over slices with an explicit counter\n-/// and suggests the use of `.enumerate()`.\n-///\n-/// **Why is it bad?** Not only is the version using `.enumerate()` more\n-/// readable, the compiler is able to remove bounds checks which can lead to\n-/// faster code in some instances.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for i in 0..v.len() { foo(v[i]);\n-/// for i in 0..v.len() { bar(i, v[i]); }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks `for` loops over slices with an explicit counter\n+    /// and suggests the use of `.enumerate()`.\n+    ///\n+    /// **Why is it bad?** Not only is the version using `.enumerate()` more\n+    /// readable, the compiler is able to remove bounds checks which can lead to\n+    /// faster code in some instances.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// for i in 0..v.len() { foo(v[i]);\n+    /// for i in 0..v.len() { bar(i, v[i]); }\n+    /// ```\n     pub EXPLICIT_COUNTER_LOOP,\n     complexity,\n     \"for-looping with an explicit counter when `_.enumerate()` would do\"\n }\n \n-/// **What it does:** Checks for empty `loop` expressions.\n-///\n-/// **Why is this bad?** Those busy loops burn CPU cycles without doing\n-/// anything. Think of the environment and either block on something or at least\n-/// make the thread sleep for some microseconds.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// loop {}\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for empty `loop` expressions.\n+    ///\n+    /// **Why is this bad?** Those busy loops burn CPU cycles without doing\n+    /// anything. Think of the environment and either block on something or at least\n+    /// make the thread sleep for some microseconds.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// loop {}\n+    /// ```\n     pub EMPTY_LOOP,\n     style,\n     \"empty `loop {}`, which should block or sleep\"\n }\n \n-/// **What it does:** Checks for `while let` expressions on iterators.\n-///\n-/// **Why is this bad?** Readability. A simple `for` loop is shorter and conveys\n-/// the intent better.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// while let Some(val) = iter() {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `while let` expressions on iterators.\n+    ///\n+    /// **Why is this bad?** Readability. A simple `for` loop is shorter and conveys\n+    /// the intent better.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// while let Some(val) = iter() {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub WHILE_LET_ON_ITERATOR,\n     style,\n     \"using a while-let loop instead of a for loop on an iterator\"\n }\n \n-/// **What it does:** Checks for iterating a map (`HashMap` or `BTreeMap`) and\n-/// ignoring either the keys or values.\n-///\n-/// **Why is this bad?** Readability. There are `keys` and `values` methods that\n-/// can be used to express that don't need the values or keys.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for (k, _) in &map {\n-///     ..\n-/// }\n-/// ```\n-///\n-/// could be replaced by\n-///\n-/// ```rust\n-/// for k in map.keys() {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for iterating a map (`HashMap` or `BTreeMap`) and\n+    /// ignoring either the keys or values.\n+    ///\n+    /// **Why is this bad?** Readability. There are `keys` and `values` methods that\n+    /// can be used to express that don't need the values or keys.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// for (k, _) in &map {\n+    ///     ..\n+    /// }\n+    /// ```\n+    ///\n+    /// could be replaced by\n+    ///\n+    /// ```rust\n+    /// for k in map.keys() {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub FOR_KV_MAP,\n     style,\n     \"looping on a map using `iter` when `keys` or `values` would do\"\n }\n \n-/// **What it does:** Checks for loops that will always `break`, `return` or\n-/// `continue` an outer loop.\n-///\n-/// **Why is this bad?** This loop never loops, all it does is obfuscating the\n-/// code.\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// loop {\n-///     ..;\n-///     break;\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for loops that will always `break`, `return` or\n+    /// `continue` an outer loop.\n+    ///\n+    /// **Why is this bad?** This loop never loops, all it does is obfuscating the\n+    /// code.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// loop {\n+    ///     ..;\n+    ///     break;\n+    /// }\n+    /// ```\n     pub NEVER_LOOP,\n     correctness,\n     \"any loop that will always `break` or `return`\"\n }\n \n-/// **What it does:** Checks for loops which have a range bound that is a mutable variable\n-///\n-/// **Why is this bad?** One might think that modifying the mutable variable changes the loop bounds\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// let mut foo = 42;\n-/// for i in 0..foo {\n-///     foo -= 1;\n-///     println!(\"{}\", i); // prints numbers from 0 to 42, not 0 to 21\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for loops which have a range bound that is a mutable variable\n+    ///\n+    /// **Why is this bad?** One might think that modifying the mutable variable changes the loop bounds\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut foo = 42;\n+    /// for i in 0..foo {\n+    ///     foo -= 1;\n+    ///     println!(\"{}\", i); // prints numbers from 0 to 42, not 0 to 21\n+    /// }\n+    /// ```\n     pub MUT_RANGE_BOUND,\n     complexity,\n     \"for loop over a range where one of the bounds is a mutable variable\"\n }\n \n-/// **What it does:** Checks whether variables used within while loop condition\n-/// can be (and are) mutated in the body.\n-///\n-/// **Why is this bad?** If the condition is unchanged, entering the body of the loop\n-/// will lead to an infinite loop.\n-///\n-/// **Known problems:** If the `while`-loop is in a closure, the check for mutation of the\n-/// condition variables in the body can cause false negatives. For example when only `Upvar` `a` is\n-/// in the condition and only `Upvar` `b` gets mutated in the body, the lint will not trigger.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let i = 0;\n-/// while i > 10 {\n-///     println!(\"let me loop forever!\");\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks whether variables used within while loop condition\n+    /// can be (and are) mutated in the body.\n+    ///\n+    /// **Why is this bad?** If the condition is unchanged, entering the body of the loop\n+    /// will lead to an infinite loop.\n+    ///\n+    /// **Known problems:** If the `while`-loop is in a closure, the check for mutation of the\n+    /// condition variables in the body can cause false negatives. For example when only `Upvar` `a` is\n+    /// in the condition and only `Upvar` `b` gets mutated in the body, the lint will not trigger.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let i = 0;\n+    /// while i > 10 {\n+    ///     println!(\"let me loop forever!\");\n+    /// }\n+    /// ```\n     pub WHILE_IMMUTABLE_CONDITION,\n     correctness,\n     \"variables used within while expression are not mutated in the body\""}, {"sha": "4a3092640962fc7de8e788af62a856dfa212bf12", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -14,29 +14,29 @@ use syntax::source_map::Span;\n #[derive(Clone)]\n pub struct Pass;\n \n-/// **What it does:** Checks for usage of `iterator.map(|x| x.clone())` and suggests\n-/// `iterator.cloned()` instead\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// let x = vec![42, 43];\n-/// let y = x.iter();\n-/// let z = y.map(|i| *i);\n-/// ```\n-///\n-/// The correct use would be:\n-///\n-/// ```rust\n-/// let x = vec![42, 43];\n-/// let y = x.iter();\n-/// let z = y.cloned();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `iterator.map(|x| x.clone())` and suggests\n+    /// `iterator.cloned()` instead\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let x = vec![42, 43];\n+    /// let y = x.iter();\n+    /// let z = y.map(|i| *i);\n+    /// ```\n+    ///\n+    /// The correct use would be:\n+    ///\n+    /// ```rust\n+    /// let x = vec![42, 43];\n+    /// let y = x.iter();\n+    /// let z = y.cloned();\n+    /// ```\n     pub MAP_CLONE,\n     style,\n     \"using `iterator.map(|x| x.clone())`, or dereferencing closures for `Copy` types\""}, {"sha": "f96418201da751d5fc5a2e9e5975d32f232b2476", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -11,67 +11,67 @@ use syntax::source_map::Span;\n #[derive(Clone)]\n pub struct Pass;\n \n-/// **What it does:** Checks for usage of `option.map(f)` where f is a function\n-/// or closure that returns the unit type.\n-///\n-/// **Why is this bad?** Readability, this can be written more clearly with\n-/// an if let statement\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// let x: Option<&str> = do_stuff();\n-/// x.map(log_err_msg);\n-/// x.map(|msg| log_err_msg(format_msg(msg)))\n-/// ```\n-///\n-/// The correct use would be:\n-///\n-/// ```rust\n-/// let x: Option<&str> = do_stuff();\n-/// if let Some(msg) = x {\n-///     log_err_msg(msg)\n-/// }\n-/// if let Some(msg) = x {\n-///     log_err_msg(format_msg(msg))\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `option.map(f)` where f is a function\n+    /// or closure that returns the unit type.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more clearly with\n+    /// an if let statement\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let x: Option<&str> = do_stuff();\n+    /// x.map(log_err_msg);\n+    /// x.map(|msg| log_err_msg(format_msg(msg)))\n+    /// ```\n+    ///\n+    /// The correct use would be:\n+    ///\n+    /// ```rust\n+    /// let x: Option<&str> = do_stuff();\n+    /// if let Some(msg) = x {\n+    ///     log_err_msg(msg)\n+    /// }\n+    /// if let Some(msg) = x {\n+    ///     log_err_msg(format_msg(msg))\n+    /// }\n+    /// ```\n     pub OPTION_MAP_UNIT_FN,\n     complexity,\n     \"using `option.map(f)`, where f is a function or closure that returns ()\"\n }\n \n-/// **What it does:** Checks for usage of `result.map(f)` where f is a function\n-/// or closure that returns the unit type.\n-///\n-/// **Why is this bad?** Readability, this can be written more clearly with\n-/// an if let statement\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// let x: Result<&str, &str> = do_stuff();\n-/// x.map(log_err_msg);\n-/// x.map(|msg| log_err_msg(format_msg(msg)))\n-/// ```\n-///\n-/// The correct use would be:\n-///\n-/// ```rust\n-/// let x: Result<&str, &str> = do_stuff();\n-/// if let Ok(msg) = x {\n-///     log_err_msg(msg)\n-/// }\n-/// if let Ok(msg) = x {\n-///     log_err_msg(format_msg(msg))\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `result.map(f)` where f is a function\n+    /// or closure that returns the unit type.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more clearly with\n+    /// an if let statement\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let x: Result<&str, &str> = do_stuff();\n+    /// x.map(log_err_msg);\n+    /// x.map(|msg| log_err_msg(format_msg(msg)))\n+    /// ```\n+    ///\n+    /// The correct use would be:\n+    ///\n+    /// ```rust\n+    /// let x: Result<&str, &str> = do_stuff();\n+    /// if let Ok(msg) = x {\n+    ///     log_err_msg(msg)\n+    /// }\n+    /// if let Ok(msg) = x {\n+    ///     log_err_msg(format_msg(msg))\n+    /// }\n+    /// ```\n     pub RESULT_MAP_UNIT_FN,\n     complexity,\n     \"using `result.map(f)`, where f is a function or closure that returns ()\""}, {"sha": "101a31e308608cdbf7c601291bddebc6e8638482", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 143, "deletions": 143, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -18,192 +18,192 @@ use std::ops::Deref;\n use syntax::ast::LitKind;\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for matches with a single arm where an `if let`\n-/// will usually suffice.\n-///\n-/// **Why is this bad?** Just readability \u2013 `if let` nests less than a `match`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// match x {\n-///     Some(ref foo) => bar(foo),\n-///     _ => (),\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for matches with a single arm where an `if let`\n+    /// will usually suffice.\n+    ///\n+    /// **Why is this bad?** Just readability \u2013 `if let` nests less than a `match`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// match x {\n+    ///     Some(ref foo) => bar(foo),\n+    ///     _ => (),\n+    /// }\n+    /// ```\n     pub SINGLE_MATCH,\n     style,\n     \"a match statement with a single nontrivial arm (i.e. where the other arm is `_ => {}`) instead of `if let`\"\n }\n \n-/// **What it does:** Checks for matches with a two arms where an `if let else` will\n-/// usually suffice.\n-///\n-/// **Why is this bad?** Just readability \u2013 `if let` nests less than a `match`.\n-///\n-/// **Known problems:** Personal style preferences may differ.\n-///\n-/// **Example:**\n-///\n-/// Using `match`:\n-///\n-/// ```rust\n-/// match x {\n-///     Some(ref foo) => bar(foo),\n-///     _ => bar(other_ref),\n-/// }\n-/// ```\n-///\n-/// Using `if let` with `else`:\n-///\n-/// ```rust\n-/// if let Some(ref foo) = x {\n-///     bar(foo);\n-/// } else {\n-///     bar(other_ref);\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for matches with a two arms where an `if let else` will\n+    /// usually suffice.\n+    ///\n+    /// **Why is this bad?** Just readability \u2013 `if let` nests less than a `match`.\n+    ///\n+    /// **Known problems:** Personal style preferences may differ.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// Using `match`:\n+    ///\n+    /// ```rust\n+    /// match x {\n+    ///     Some(ref foo) => bar(foo),\n+    ///     _ => bar(other_ref),\n+    /// }\n+    /// ```\n+    ///\n+    /// Using `if let` with `else`:\n+    ///\n+    /// ```rust\n+    /// if let Some(ref foo) = x {\n+    ///     bar(foo);\n+    /// } else {\n+    ///     bar(other_ref);\n+    /// }\n+    /// ```\n     pub SINGLE_MATCH_ELSE,\n     pedantic,\n     \"a match statement with a two arms where the second arm's pattern is a placeholder instead of a specific match pattern\"\n }\n \n-/// **What it does:** Checks for matches where all arms match a reference,\n-/// suggesting to remove the reference and deref the matched expression\n-/// instead. It also checks for `if let &foo = bar` blocks.\n-///\n-/// **Why is this bad?** It just makes the code less readable. That reference\n-/// destructuring adds nothing to the code.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// match x {\n-///     &A(ref y) => foo(y),\n-///     &B => bar(),\n-///     _ => frob(&x),\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for matches where all arms match a reference,\n+    /// suggesting to remove the reference and deref the matched expression\n+    /// instead. It also checks for `if let &foo = bar` blocks.\n+    ///\n+    /// **Why is this bad?** It just makes the code less readable. That reference\n+    /// destructuring adds nothing to the code.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// match x {\n+    ///     &A(ref y) => foo(y),\n+    ///     &B => bar(),\n+    ///     _ => frob(&x),\n+    /// }\n+    /// ```\n     pub MATCH_REF_PATS,\n     style,\n     \"a match or `if let` with all arms prefixed with `&` instead of deref-ing the match expression\"\n }\n \n-/// **What it does:** Checks for matches where match expression is a `bool`. It\n-/// suggests to replace the expression with an `if...else` block.\n-///\n-/// **Why is this bad?** It makes the code less readable.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let condition: bool = true;\n-/// match condition {\n-///     true => foo(),\n-///     false => bar(),\n-/// }\n-/// ```\n-/// Use if/else instead:\n-/// ```rust\n-/// let condition: bool = true;\n-/// if condition {\n-///     foo();\n-/// } else {\n-///     bar();\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for matches where match expression is a `bool`. It\n+    /// suggests to replace the expression with an `if...else` block.\n+    ///\n+    /// **Why is this bad?** It makes the code less readable.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let condition: bool = true;\n+    /// match condition {\n+    ///     true => foo(),\n+    ///     false => bar(),\n+    /// }\n+    /// ```\n+    /// Use if/else instead:\n+    /// ```rust\n+    /// let condition: bool = true;\n+    /// if condition {\n+    ///     foo();\n+    /// } else {\n+    ///     bar();\n+    /// }\n+    /// ```\n     pub MATCH_BOOL,\n     style,\n     \"a match on a boolean expression instead of an `if..else` block\"\n }\n \n-/// **What it does:** Checks for overlapping match arms.\n-///\n-/// **Why is this bad?** It is likely to be an error and if not, makes the code\n-/// less obvious.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = 5;\n-/// match x {\n-///     1...10 => println!(\"1 ... 10\"),\n-///     5...15 => println!(\"5 ... 15\"),\n-///     _ => (),\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for overlapping match arms.\n+    ///\n+    /// **Why is this bad?** It is likely to be an error and if not, makes the code\n+    /// less obvious.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = 5;\n+    /// match x {\n+    ///     1...10 => println!(\"1 ... 10\"),\n+    ///     5...15 => println!(\"5 ... 15\"),\n+    ///     _ => (),\n+    /// }\n+    /// ```\n     pub MATCH_OVERLAPPING_ARM,\n     style,\n     \"a match with overlapping arms\"\n }\n \n-/// **What it does:** Checks for arm which matches all errors with `Err(_)`\n-/// and take drastic actions like `panic!`.\n-///\n-/// **Why is this bad?** It is generally a bad practice, just like\n-/// catching all exceptions in java with `catch(Exception)`\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x: Result(i32, &str) = Ok(3);\n-/// match x {\n-///     Ok(_) => println!(\"ok\"),\n-///     Err(_) => panic!(\"err\"),\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for arm which matches all errors with `Err(_)`\n+    /// and take drastic actions like `panic!`.\n+    ///\n+    /// **Why is this bad?** It is generally a bad practice, just like\n+    /// catching all exceptions in java with `catch(Exception)`\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x: Result(i32, &str) = Ok(3);\n+    /// match x {\n+    ///     Ok(_) => println!(\"ok\"),\n+    ///     Err(_) => panic!(\"err\"),\n+    /// }\n+    /// ```\n     pub MATCH_WILD_ERR_ARM,\n     style,\n     \"a match with `Err(_)` arm and take drastic actions\"\n }\n \n-/// **What it does:** Checks for match which is used to add a reference to an\n-/// `Option` value.\n-///\n-/// **Why is this bad?** Using `as_ref()` or `as_mut()` instead is shorter.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x: Option<()> = None;\n-/// let r: Option<&()> = match x {\n-///     None => None,\n-///     Some(ref v) => Some(v),\n-/// };\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for match which is used to add a reference to an\n+    /// `Option` value.\n+    ///\n+    /// **Why is this bad?** Using `as_ref()` or `as_mut()` instead is shorter.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x: Option<()> = None;\n+    /// let r: Option<&()> = match x {\n+    ///     None => None,\n+    ///     Some(ref v) => Some(v),\n+    /// };\n+    /// ```\n     pub MATCH_AS_REF,\n     complexity,\n     \"a match on an Option value instead of using `as_ref()` or `as_mut`\"\n }\n \n-/// **What it does:** Checks for wildcard enum matches using `_`.\n-///\n-/// **Why is this bad?** New enum variants added by library updates can be missed.\n-///\n-/// **Known problems:** Suggested replacements may be incorrect if guards exhaustively cover some\n-/// variants, and also may not use correct path to enum if it's not present in the current scope.\n-///\n-/// **Example:**\n-/// ```rust\n-/// match x {\n-///     A => {},\n-///     _ => {},\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for wildcard enum matches using `_`.\n+    ///\n+    /// **Why is this bad?** New enum variants added by library updates can be missed.\n+    ///\n+    /// **Known problems:** Suggested replacements may be incorrect if guards exhaustively cover some\n+    /// variants, and also may not use correct path to enum if it's not present in the current scope.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// match x {\n+    ///     A => {},\n+    ///     _ => {},\n+    /// }\n+    /// ```\n     pub WILDCARD_ENUM_MATCH_ARM,\n     restriction,\n     \"a wildcard enum match arm using `_`\""}, {"sha": "17a9131640b4470b67d9ab3efd5c279a6b57156b", "filename": "clippy_lints/src/mem_discriminant.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_discriminant.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -7,19 +7,19 @@ use rustc_errors::Applicability;\n \n use std::iter;\n \n-/// **What it does:** Checks for calls of `mem::discriminant()` on a non-enum type.\n-///\n-/// **Why is this bad?** The value of `mem::discriminant()` on non-enum types\n-/// is unspecified.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// mem::discriminant(&\"hello\");\n-/// mem::discriminant(&&Some(2));\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calls of `mem::discriminant()` on a non-enum type.\n+    ///\n+    /// **Why is this bad?** The value of `mem::discriminant()` on non-enum types\n+    /// is unspecified.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// mem::discriminant(&\"hello\");\n+    /// mem::discriminant(&&Some(2));\n+    /// ```\n     pub MEM_DISCRIMINANT_NON_ENUM,\n     correctness,\n     \"calling mem::descriminant on non-enum type\""}, {"sha": "aaaef49cfc41a7b2e563b79493e9a933d77690e0", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -3,19 +3,19 @@ use rustc::hir::{Expr, ExprKind};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for usage of `std::mem::forget(t)` where `t` is\n-/// `Drop`.\n-///\n-/// **Why is this bad?** `std::mem::forget(t)` prevents `t` from running its\n-/// destructor, possibly causing leaks.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// mem::forget(Rc::new(55))\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `std::mem::forget(t)` where `t` is\n+    /// `Drop`.\n+    ///\n+    /// **Why is this bad?** `std::mem::forget(t)` prevents `t` from running its\n+    /// destructor, possibly causing leaks.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// mem::forget(Rc::new(55))\n+    /// ```\n     pub MEM_FORGET,\n     restriction,\n     \"`mem::forget` usage on `Drop` types, likely to cause memory leaks\""}, {"sha": "4d0fae2ac1c50506269fbe0c571dc2b5ec2c3eb2", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,26 +5,26 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for `mem::replace()` on an `Option` with\n-/// `None`.\n-///\n-/// **Why is this bad?** `Option` already has the method `take()` for\n-/// taking its current value (Some(..) or None) and replacing it with\n-/// `None`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let mut an_option = Some(0);\n-/// let replaced = mem::replace(&mut an_option, None);\n-/// ```\n-/// Is better expressed with:\n-/// ```rust\n-/// let mut an_option = Some(0);\n-/// let taken = an_option.take();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `mem::replace()` on an `Option` with\n+    /// `None`.\n+    ///\n+    /// **Why is this bad?** `Option` already has the method `take()` for\n+    /// taking its current value (Some(..) or None) and replacing it with\n+    /// `None`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut an_option = Some(0);\n+    /// let replaced = mem::replace(&mut an_option, None);\n+    /// ```\n+    /// Is better expressed with:\n+    /// ```rust\n+    /// let mut an_option = Some(0);\n+    /// let taken = an_option.take();\n+    /// ```\n     pub MEM_REPLACE_OPTION_WITH_NONE,\n     style,\n     \"replacing an `Option` with `None` instead of `take()`\""}, {"sha": "75865f9123bd0b9eedf8dc6bdd2ec50a603323ce", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 548, "deletions": 549, "changes": 1097, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -28,749 +28,748 @@ mod unnecessary_filter_map;\n #[derive(Clone)]\n pub struct Pass;\n \n-/// **What it does:** Checks for `.unwrap()` calls on `Option`s.\n-///\n-/// **Why is this bad?** Usually it is better to handle the `None` case, or to\n-/// at least call `.expect(_)` with a more helpful message. Still, for a lot of\n-/// quick-and-dirty code, `unwrap` is a good choice, which is why this lint is\n-/// `Allow` by default.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.unwrap()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `.unwrap()` calls on `Option`s.\n+    ///\n+    /// **Why is this bad?** Usually it is better to handle the `None` case, or to\n+    /// at least call `.expect(_)` with a more helpful message. Still, for a lot of\n+    /// quick-and-dirty code, `unwrap` is a good choice, which is why this lint is\n+    /// `Allow` by default.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x.unwrap()\n+    /// ```\n     pub OPTION_UNWRAP_USED,\n     restriction,\n     \"using `Option.unwrap()`, which should at least get a better message using `expect()`\"\n }\n \n-/// **What it does:** Checks for `.unwrap()` calls on `Result`s.\n-///\n-/// **Why is this bad?** `result.unwrap()` will let the thread panic on `Err`\n-/// values. Normally, you want to implement more sophisticated error handling,\n-/// and propagate errors upwards with `try!`.\n-///\n-/// Even if you want to panic on errors, not all `Error`s implement good\n-/// messages on display.  Therefore it may be beneficial to look at the places\n-/// where they may get displayed. Activate this lint to do just that.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.unwrap()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `.unwrap()` calls on `Result`s.\n+    ///\n+    /// **Why is this bad?** `result.unwrap()` will let the thread panic on `Err`\n+    /// values. Normally, you want to implement more sophisticated error handling,\n+    /// and propagate errors upwards with `try!`.\n+    ///\n+    /// Even if you want to panic on errors, not all `Error`s implement good\n+    /// messages on display.  Therefore it may be beneficial to look at the places\n+    /// where they may get displayed. Activate this lint to do just that.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x.unwrap()\n+    /// ```\n     pub RESULT_UNWRAP_USED,\n     restriction,\n     \"using `Result.unwrap()`, which might be better handled\"\n }\n \n-/// **What it does:** Checks for methods that should live in a trait\n-/// implementation of a `std` trait (see [llogiq's blog\n-/// post](http://llogiq.github.io/2015/07/30/traits.html) for further\n-/// information) instead of an inherent implementation.\n-///\n-/// **Why is this bad?** Implementing the traits improve ergonomics for users of\n-/// the code, often with very little cost. Also people seeing a `mul(...)`\n-/// method\n-/// may expect `*` to work equally, so you should have good reason to disappoint\n-/// them.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// struct X;\n-/// impl X {\n-///     fn add(&self, other: &X) -> X {\n-///         ..\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for methods that should live in a trait\n+    /// implementation of a `std` trait (see [llogiq's blog\n+    /// post](http://llogiq.github.io/2015/07/30/traits.html) for further\n+    /// information) instead of an inherent implementation.\n+    ///\n+    /// **Why is this bad?** Implementing the traits improve ergonomics for users of\n+    /// the code, often with very little cost. Also people seeing a `mul(...)`\n+    /// method\n+    /// may expect `*` to work equally, so you should have good reason to disappoint\n+    /// them.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// struct X;\n+    /// impl X {\n+    ///     fn add(&self, other: &X) -> X {\n+    ///         ..\n+    ///     }\n+    /// }\n+    /// ```\n     pub SHOULD_IMPLEMENT_TRAIT,\n     style,\n     \"defining a method that should be implementing a std trait\"\n }\n \n-/// **What it does:** Checks for methods with certain name prefixes and which\n-/// doesn't match how self is taken. The actual rules are:\n-///\n-/// |Prefix |`self` taken          |\n-/// |-------|----------------------|\n-/// |`as_`  |`&self` or `&mut self`|\n-/// |`from_`| none                 |\n-/// |`into_`|`self`                |\n-/// |`is_`  |`&self` or none       |\n-/// |`to_`  |`&self`               |\n-///\n-/// **Why is this bad?** Consistency breeds readability. If you follow the\n-/// conventions, your users won't be surprised that they, e.g., need to supply a\n-/// mutable reference to a `as_..` function.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// impl X {\n-///     fn as_str(self) -> &str {\n-///         ..\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for methods with certain name prefixes and which\n+    /// doesn't match how self is taken. The actual rules are:\n+    ///\n+    /// |Prefix |`self` taken          |\n+    /// |-------|----------------------|\n+    /// |`as_`  |`&self` or `&mut self`|\n+    /// |`from_`| none                 |\n+    /// |`into_`|`self`                |\n+    /// |`is_`  |`&self` or none       |\n+    /// |`to_`  |`&self`               |\n+    ///\n+    /// **Why is this bad?** Consistency breeds readability. If you follow the\n+    /// conventions, your users won't be surprised that they, e.g., need to supply a\n+    /// mutable reference to a `as_..` function.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// impl X {\n+    ///     fn as_str(self) -> &str {\n+    ///         ..\n+    ///     }\n+    /// }\n+    /// ```\n     pub WRONG_SELF_CONVENTION,\n     style,\n     \"defining a method named with an established prefix (like \\\"into_\\\") that takes `self` with the wrong convention\"\n }\n \n-/// **What it does:** This is the same as\n-/// [`wrong_self_convention`](#wrong_self_convention), but for public items.\n-///\n-/// **Why is this bad?** See [`wrong_self_convention`](#wrong_self_convention).\n-///\n-/// **Known problems:** Actually *renaming* the function may break clients if\n-/// the function is part of the public interface. In that case, be mindful of\n-/// the stability guarantees you've given your users.\n-///\n-/// **Example:**\n-/// ```rust\n-/// impl X {\n-///     pub fn as_str(self) -> &str {\n-///         ..\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** This is the same as\n+    /// [`wrong_self_convention`](#wrong_self_convention), but for public items.\n+    ///\n+    /// **Why is this bad?** See [`wrong_self_convention`](#wrong_self_convention).\n+    ///\n+    /// **Known problems:** Actually *renaming* the function may break clients if\n+    /// the function is part of the public interface. In that case, be mindful of\n+    /// the stability guarantees you've given your users.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// impl X {\n+    ///     pub fn as_str(self) -> &str {\n+    ///         ..\n+    ///     }\n+    /// }\n+    /// ```\n     pub WRONG_PUB_SELF_CONVENTION,\n     restriction,\n     \"defining a public method named with an established prefix (like \\\"into_\\\") that takes `self` with the wrong convention\"\n }\n \n-/// **What it does:** Checks for usage of `ok().expect(..)`.\n-///\n-/// **Why is this bad?** Because you usually call `expect()` on the `Result`\n-/// directly to get a better error message.\n-///\n-/// **Known problems:** The error type needs to implement `Debug`\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.ok().expect(\"why did I do this again?\")\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `ok().expect(..)`.\n+    ///\n+    /// **Why is this bad?** Because you usually call `expect()` on the `Result`\n+    /// directly to get a better error message.\n+    ///\n+    /// **Known problems:** The error type needs to implement `Debug`\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x.ok().expect(\"why did I do this again?\")\n+    /// ```\n     pub OK_EXPECT,\n     style,\n     \"using `ok().expect()`, which gives worse error messages than calling `expect` directly on the Result\"\n }\n \n-/// **What it does:** Checks for usage of `_.map(_).unwrap_or(_)`.\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely as\n-/// `_.map_or(_, _)`.\n-///\n-/// **Known problems:** The order of the arguments is not in execution order\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.map(|a| a + 1).unwrap_or(0)\n-/// ```\n declare_clippy_lint! {\n-pub OPTION_MAP_UNWRAP_OR,\n-pedantic,\n-\"using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as \\\n- `map_or(a, f)`\"\n-}\n-\n-/// **What it does:** Checks for usage of `_.map(_).unwrap_or_else(_)`.\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely as\n-/// `_.map_or_else(_, _)`.\n-///\n-/// **Known problems:** The order of the arguments is not in execution order.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.map(|a| a + 1).unwrap_or_else(some_function)\n-/// ```\n+    /// **What it does:** Checks for usage of `_.map(_).unwrap_or(_)`.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely as\n+    /// `_.map_or(_, _)`.\n+    ///\n+    /// **Known problems:** The order of the arguments is not in execution order\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x.map(|a| a + 1).unwrap_or(0)\n+    /// ```\n+    pub OPTION_MAP_UNWRAP_OR,\n+    pedantic,\n+    \"using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as `map_or(a, f)`\"\n+}\n+\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `_.map(_).unwrap_or_else(_)`.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely as\n+    /// `_.map_or_else(_, _)`.\n+    ///\n+    /// **Known problems:** The order of the arguments is not in execution order.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x.map(|a| a + 1).unwrap_or_else(some_function)\n+    /// ```\n     pub OPTION_MAP_UNWRAP_OR_ELSE,\n     pedantic,\n     \"using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `map_or_else(g, f)`\"\n }\n \n-/// **What it does:** Checks for usage of `result.map(_).unwrap_or_else(_)`.\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely as\n-/// `result.ok().map_or_else(_, _)`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.map(|a| a + 1).unwrap_or_else(some_function)\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `result.map(_).unwrap_or_else(_)`.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely as\n+    /// `result.ok().map_or_else(_, _)`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x.map(|a| a + 1).unwrap_or_else(some_function)\n+    /// ```\n     pub RESULT_MAP_UNWRAP_OR_ELSE,\n     pedantic,\n     \"using `Result.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `.ok().map_or_else(g, f)`\"\n }\n \n-/// **What it does:** Checks for usage of `_.map_or(None, _)`.\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely as\n-/// `_.and_then(_)`.\n-///\n-/// **Known problems:** The order of the arguments is not in execution order.\n-///\n-/// **Example:**\n-/// ```rust\n-/// opt.map_or(None, |a| a + 1)\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `_.map_or(None, _)`.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely as\n+    /// `_.and_then(_)`.\n+    ///\n+    /// **Known problems:** The order of the arguments is not in execution order.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// opt.map_or(None, |a| a + 1)\n+    /// ```\n     pub OPTION_MAP_OR_NONE,\n     style,\n     \"using `Option.map_or(None, f)`, which is more succinctly expressed as `and_then(f)`\"\n }\n \n-/// **What it does:** Checks for usage of `_.filter(_).next()`.\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely as\n-/// `_.find(_)`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// iter.filter(|x| x == 0).next()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `_.filter(_).next()`.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely as\n+    /// `_.find(_)`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// iter.filter(|x| x == 0).next()\n+    /// ```\n     pub FILTER_NEXT,\n     complexity,\n     \"using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\"\n }\n \n-/// **What it does:** Checks for usage of `_.map(_).flatten(_)`,\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely as a\n-/// single method call.\n-///\n-/// **Known problems:**\n-///\n-/// **Example:**\n-/// ```rust\n-/// iter.map(|x| x.iter()).flatten()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `_.map(_).flatten(_)`,\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely as a\n+    /// single method call.\n+    ///\n+    /// **Known problems:**\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// iter.map(|x| x.iter()).flatten()\n+    /// ```\n     pub MAP_FLATTEN,\n     pedantic,\n     \"using combinations of `flatten` and `map` which can usually be written as a single method call\"\n }\n \n-/// **What it does:** Checks for usage of `_.filter(_).map(_)`,\n-/// `_.filter(_).flat_map(_)`, `_.filter_map(_).flat_map(_)` and similar.\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely as a\n-/// single method call.\n-///\n-/// **Known problems:** Often requires a condition + Option/Iterator creation\n-/// inside the closure.\n-///\n-/// **Example:**\n-/// ```rust\n-/// iter.filter(|x| x == 0).map(|x| x * 2)\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `_.filter(_).map(_)`,\n+    /// `_.filter(_).flat_map(_)`, `_.filter_map(_).flat_map(_)` and similar.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely as a\n+    /// single method call.\n+    ///\n+    /// **Known problems:** Often requires a condition + Option/Iterator creation\n+    /// inside the closure.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// iter.filter(|x| x == 0).map(|x| x * 2)\n+    /// ```\n     pub FILTER_MAP,\n     pedantic,\n     \"using combinations of `filter`, `map`, `filter_map` and `flat_map` which can usually be written as a single method call\"\n }\n \n-/// **What it does:** Checks for an iterator search (such as `find()`,\n-/// `position()`, or `rposition()`) followed by a call to `is_some()`.\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely as\n-/// `_.any(_)`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// iter.find(|x| x == 0).is_some()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for an iterator search (such as `find()`,\n+    /// `position()`, or `rposition()`) followed by a call to `is_some()`.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely as\n+    /// `_.any(_)`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// iter.find(|x| x == 0).is_some()\n+    /// ```\n     pub SEARCH_IS_SOME,\n     complexity,\n     \"using an iterator search followed by `is_some()`, which is more succinctly expressed as a call to `any()`\"\n }\n \n-/// **What it does:** Checks for usage of `.chars().next()` on a `str` to check\n-/// if it starts with a given char.\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely as\n-/// `_.starts_with(_)`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// name.chars().next() == Some('_')\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `.chars().next()` on a `str` to check\n+    /// if it starts with a given char.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely as\n+    /// `_.starts_with(_)`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// name.chars().next() == Some('_')\n+    /// ```\n     pub CHARS_NEXT_CMP,\n     complexity,\n     \"using `.chars().next()` to check if a string starts with a char\"\n }\n \n-/// **What it does:** Checks for calls to `.or(foo(..))`, `.unwrap_or(foo(..))`,\n-/// etc., and suggests to use `or_else`, `unwrap_or_else`, etc., or\n-/// `unwrap_or_default` instead.\n-///\n-/// **Why is this bad?** The function will always be called and potentially\n-/// allocate an object acting as the default.\n-///\n-/// **Known problems:** If the function has side-effects, not calling it will\n-/// change the semantic of the program, but you shouldn't rely on that anyway.\n-///\n-/// **Example:**\n-/// ```rust\n-/// foo.unwrap_or(String::new())\n-/// ```\n-/// this can instead be written:\n-/// ```rust\n-/// foo.unwrap_or_else(String::new)\n-/// ```\n-/// or\n-/// ```rust\n-/// foo.unwrap_or_default()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `.or(foo(..))`, `.unwrap_or(foo(..))`,\n+    /// etc., and suggests to use `or_else`, `unwrap_or_else`, etc., or\n+    /// `unwrap_or_default` instead.\n+    ///\n+    /// **Why is this bad?** The function will always be called and potentially\n+    /// allocate an object acting as the default.\n+    ///\n+    /// **Known problems:** If the function has side-effects, not calling it will\n+    /// change the semantic of the program, but you shouldn't rely on that anyway.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// foo.unwrap_or(String::new())\n+    /// ```\n+    /// this can instead be written:\n+    /// ```rust\n+    /// foo.unwrap_or_else(String::new)\n+    /// ```\n+    /// or\n+    /// ```rust\n+    /// foo.unwrap_or_default()\n+    /// ```\n     pub OR_FUN_CALL,\n     perf,\n     \"using any `*or` method with a function call, which suggests `*or_else`\"\n }\n \n-/// **What it does:** Checks for calls to `.expect(&format!(...))`, `.expect(foo(..))`,\n-/// etc., and suggests to use `unwrap_or_else` instead\n-///\n-/// **Why is this bad?** The function will always be called.\n-///\n-/// **Known problems:** If the function has side-effects, not calling it will\n-/// change the semantic of the program, but you shouldn't rely on that anyway.\n-///\n-/// **Example:**\n-/// ```rust\n-/// foo.expect(&format!(\"Err {}: {}\", err_code, err_msg))\n-/// ```\n-/// or\n-/// ```rust\n-/// foo.expect(format!(\"Err {}: {}\", err_code, err_msg).as_str())\n-/// ```\n-/// this can instead be written:\n-/// ```rust\n-/// foo.unwrap_or_else(|_| panic!(\"Err {}: {}\", err_code, err_msg))\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `.expect(&format!(...))`, `.expect(foo(..))`,\n+    /// etc., and suggests to use `unwrap_or_else` instead\n+    ///\n+    /// **Why is this bad?** The function will always be called.\n+    ///\n+    /// **Known problems:** If the function has side-effects, not calling it will\n+    /// change the semantic of the program, but you shouldn't rely on that anyway.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// foo.expect(&format!(\"Err {}: {}\", err_code, err_msg))\n+    /// ```\n+    /// or\n+    /// ```rust\n+    /// foo.expect(format!(\"Err {}: {}\", err_code, err_msg).as_str())\n+    /// ```\n+    /// this can instead be written:\n+    /// ```rust\n+    /// foo.unwrap_or_else(|_| panic!(\"Err {}: {}\", err_code, err_msg))\n+    /// ```\n     pub EXPECT_FUN_CALL,\n     perf,\n     \"using any `expect` method with a function call\"\n }\n \n-/// **What it does:** Checks for usage of `.clone()` on a `Copy` type.\n-///\n-/// **Why is this bad?** The only reason `Copy` types implement `Clone` is for\n-/// generics, not for using the `clone` method on a concrete type.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// 42u64.clone()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `.clone()` on a `Copy` type.\n+    ///\n+    /// **Why is this bad?** The only reason `Copy` types implement `Clone` is for\n+    /// generics, not for using the `clone` method on a concrete type.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// 42u64.clone()\n+    /// ```\n     pub CLONE_ON_COPY,\n     complexity,\n     \"using `clone` on a `Copy` type\"\n }\n \n-/// **What it does:** Checks for usage of `.clone()` on a ref-counted pointer,\n-/// (`Rc`, `Arc`, `rc::Weak`, or `sync::Weak`), and suggests calling Clone via unified\n-/// function syntax instead (e.g. `Rc::clone(foo)`).\n-///\n-/// **Why is this bad?** Calling '.clone()' on an Rc, Arc, or Weak\n-/// can obscure the fact that only the pointer is being cloned, not the underlying\n-/// data.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.clone()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `.clone()` on a ref-counted pointer,\n+    /// (`Rc`, `Arc`, `rc::Weak`, or `sync::Weak`), and suggests calling Clone via unified\n+    /// function syntax instead (e.g. `Rc::clone(foo)`).\n+    ///\n+    /// **Why is this bad?** Calling '.clone()' on an Rc, Arc, or Weak\n+    /// can obscure the fact that only the pointer is being cloned, not the underlying\n+    /// data.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x.clone()\n+    /// ```\n     pub CLONE_ON_REF_PTR,\n     restriction,\n     \"using 'clone' on a ref-counted pointer\"\n }\n \n-/// **What it does:** Checks for usage of `.clone()` on an `&&T`.\n-///\n-/// **Why is this bad?** Cloning an `&&T` copies the inner `&T`, instead of\n-/// cloning the underlying `T`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn main() {\n-///     let x = vec![1];\n-///     let y = &&x;\n-///     let z = y.clone();\n-///     println!(\"{:p} {:p}\", *y, z); // prints out the same pointer\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `.clone()` on an `&&T`.\n+    ///\n+    /// **Why is this bad?** Cloning an `&&T` copies the inner `&T`, instead of\n+    /// cloning the underlying `T`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn main() {\n+    ///     let x = vec![1];\n+    ///     let y = &&x;\n+    ///     let z = y.clone();\n+    ///     println!(\"{:p} {:p}\", *y, z); // prints out the same pointer\n+    /// }\n+    /// ```\n     pub CLONE_DOUBLE_REF,\n     correctness,\n     \"using `clone` on `&&T`\"\n }\n \n-/// **What it does:** Checks for `new` not returning `Self`.\n-///\n-/// **Why is this bad?** As a convention, `new` methods are used to make a new\n-/// instance of a type.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// impl Foo {\n-///     fn new(..) -> NotAFoo {\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `new` not returning `Self`.\n+    ///\n+    /// **Why is this bad?** As a convention, `new` methods are used to make a new\n+    /// instance of a type.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// impl Foo {\n+    ///     fn new(..) -> NotAFoo {\n+    ///     }\n+    /// }\n+    /// ```\n     pub NEW_RET_NO_SELF,\n     style,\n     \"not returning `Self` in a `new` method\"\n }\n \n-/// **What it does:** Checks for string methods that receive a single-character\n-/// `str` as an argument, e.g. `_.split(\"x\")`.\n-///\n-/// **Why is this bad?** Performing these methods using a `char` is faster than\n-/// using a `str`.\n-///\n-/// **Known problems:** Does not catch multi-byte unicode characters.\n-///\n-/// **Example:**\n-/// `_.split(\"x\")` could be `_.split('x')`\n declare_clippy_lint! {\n+    /// **What it does:** Checks for string methods that receive a single-character\n+    /// `str` as an argument, e.g. `_.split(\"x\")`.\n+    ///\n+    /// **Why is this bad?** Performing these methods using a `char` is faster than\n+    /// using a `str`.\n+    ///\n+    /// **Known problems:** Does not catch multi-byte unicode characters.\n+    ///\n+    /// **Example:**\n+    /// `_.split(\"x\")` could be `_.split('x')`\n     pub SINGLE_CHAR_PATTERN,\n     perf,\n     \"using a single-character str where a char could be used, e.g. `_.split(\\\"x\\\")`\"\n }\n \n-/// **What it does:** Checks for getting the inner pointer of a temporary\n-/// `CString`.\n-///\n-/// **Why is this bad?** The inner pointer of a `CString` is only valid as long\n-/// as the `CString` is alive.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// let c_str = CString::new(\"foo\").unwrap().as_ptr();\n-/// unsafe {\n-///     call_some_ffi_func(c_str);\n-/// }\n-/// ```\n-/// Here `c_str` point to a freed address. The correct use would be:\n-/// ```rust,ignore\n-/// let c_str = CString::new(\"foo\").unwrap();\n-/// unsafe {\n-///     call_some_ffi_func(c_str.as_ptr());\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for getting the inner pointer of a temporary\n+    /// `CString`.\n+    ///\n+    /// **Why is this bad?** The inner pointer of a `CString` is only valid as long\n+    /// as the `CString` is alive.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// let c_str = CString::new(\"foo\").unwrap().as_ptr();\n+    /// unsafe {\n+    ///     call_some_ffi_func(c_str);\n+    /// }\n+    /// ```\n+    /// Here `c_str` point to a freed address. The correct use would be:\n+    /// ```rust,ignore\n+    /// let c_str = CString::new(\"foo\").unwrap();\n+    /// unsafe {\n+    ///     call_some_ffi_func(c_str.as_ptr());\n+    /// }\n+    /// ```\n     pub TEMPORARY_CSTRING_AS_PTR,\n     correctness,\n     \"getting the inner pointer of a temporary `CString`\"\n }\n \n-/// **What it does:** Checks for use of `.iter().nth()` (and the related\n-/// `.iter_mut().nth()`) on standard library types with O(1) element access.\n-///\n-/// **Why is this bad?** `.get()` and `.get_mut()` are more efficient and more\n-/// readable.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let some_vec = vec![0, 1, 2, 3];\n-/// let bad_vec = some_vec.iter().nth(3);\n-/// let bad_slice = &some_vec[..].iter().nth(3);\n-/// ```\n-/// The correct use would be:\n-/// ```rust\n-/// let some_vec = vec![0, 1, 2, 3];\n-/// let bad_vec = some_vec.get(3);\n-/// let bad_slice = &some_vec[..].get(3);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for use of `.iter().nth()` (and the related\n+    /// `.iter_mut().nth()`) on standard library types with O(1) element access.\n+    ///\n+    /// **Why is this bad?** `.get()` and `.get_mut()` are more efficient and more\n+    /// readable.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let some_vec = vec![0, 1, 2, 3];\n+    /// let bad_vec = some_vec.iter().nth(3);\n+    /// let bad_slice = &some_vec[..].iter().nth(3);\n+    /// ```\n+    /// The correct use would be:\n+    /// ```rust\n+    /// let some_vec = vec![0, 1, 2, 3];\n+    /// let bad_vec = some_vec.get(3);\n+    /// let bad_slice = &some_vec[..].get(3);\n+    /// ```\n     pub ITER_NTH,\n     perf,\n     \"using `.iter().nth()` on a standard library type with O(1) element access\"\n }\n \n-/// **What it does:** Checks for use of `.skip(x).next()` on iterators.\n-///\n-/// **Why is this bad?** `.nth(x)` is cleaner\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let some_vec = vec![0, 1, 2, 3];\n-/// let bad_vec = some_vec.iter().skip(3).next();\n-/// let bad_slice = &some_vec[..].iter().skip(3).next();\n-/// ```\n-/// The correct use would be:\n-/// ```rust\n-/// let some_vec = vec![0, 1, 2, 3];\n-/// let bad_vec = some_vec.iter().nth(3);\n-/// let bad_slice = &some_vec[..].iter().nth(3);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for use of `.skip(x).next()` on iterators.\n+    ///\n+    /// **Why is this bad?** `.nth(x)` is cleaner\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let some_vec = vec![0, 1, 2, 3];\n+    /// let bad_vec = some_vec.iter().skip(3).next();\n+    /// let bad_slice = &some_vec[..].iter().skip(3).next();\n+    /// ```\n+    /// The correct use would be:\n+    /// ```rust\n+    /// let some_vec = vec![0, 1, 2, 3];\n+    /// let bad_vec = some_vec.iter().nth(3);\n+    /// let bad_slice = &some_vec[..].iter().nth(3);\n+    /// ```\n     pub ITER_SKIP_NEXT,\n     style,\n     \"using `.skip(x).next()` on an iterator\"\n }\n \n-/// **What it does:** Checks for use of `.get().unwrap()` (or\n-/// `.get_mut().unwrap`) on a standard library type which implements `Index`\n-///\n-/// **Why is this bad?** Using the Index trait (`[]`) is more clear and more\n-/// concise.\n-///\n-/// **Known problems:** Not a replacement for error handling: Using either\n-/// `.unwrap()` or the Index trait (`[]`) carries the risk of causing a `panic`\n-/// if the value being accessed is `None`. If the use of `.get().unwrap()` is a\n-/// temporary placeholder for dealing with the `Option` type, then this does\n-/// not mitigate the need for error handling. If there is a chance that `.get()`\n-/// will be `None` in your program, then it is advisable that the `None` case\n-/// is handled in a future refactor instead of using `.unwrap()` or the Index\n-/// trait.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let some_vec = vec![0, 1, 2, 3];\n-/// let last = some_vec.get(3).unwrap();\n-/// *some_vec.get_mut(0).unwrap() = 1;\n-/// ```\n-/// The correct use would be:\n-/// ```rust\n-/// let some_vec = vec![0, 1, 2, 3];\n-/// let last = some_vec[3];\n-/// some_vec[0] = 1;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for use of `.get().unwrap()` (or\n+    /// `.get_mut().unwrap`) on a standard library type which implements `Index`\n+    ///\n+    /// **Why is this bad?** Using the Index trait (`[]`) is more clear and more\n+    /// concise.\n+    ///\n+    /// **Known problems:** Not a replacement for error handling: Using either\n+    /// `.unwrap()` or the Index trait (`[]`) carries the risk of causing a `panic`\n+    /// if the value being accessed is `None`. If the use of `.get().unwrap()` is a\n+    /// temporary placeholder for dealing with the `Option` type, then this does\n+    /// not mitigate the need for error handling. If there is a chance that `.get()`\n+    /// will be `None` in your program, then it is advisable that the `None` case\n+    /// is handled in a future refactor instead of using `.unwrap()` or the Index\n+    /// trait.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let some_vec = vec![0, 1, 2, 3];\n+    /// let last = some_vec.get(3).unwrap();\n+    /// *some_vec.get_mut(0).unwrap() = 1;\n+    /// ```\n+    /// The correct use would be:\n+    /// ```rust\n+    /// let some_vec = vec![0, 1, 2, 3];\n+    /// let last = some_vec[3];\n+    /// some_vec[0] = 1;\n+    /// ```\n     pub GET_UNWRAP,\n     style,\n     \"using `.get().unwrap()` or `.get_mut().unwrap()` when using `[]` would work instead\"\n }\n \n-/// **What it does:** Checks for the use of `.extend(s.chars())` where s is a\n-/// `&str` or `String`.\n-///\n-/// **Why is this bad?** `.push_str(s)` is clearer\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let abc = \"abc\";\n-/// let def = String::from(\"def\");\n-/// let mut s = String::new();\n-/// s.extend(abc.chars());\n-/// s.extend(def.chars());\n-/// ```\n-/// The correct use would be:\n-/// ```rust\n-/// let abc = \"abc\";\n-/// let def = String::from(\"def\");\n-/// let mut s = String::new();\n-/// s.push_str(abc);\n-/// s.push_str(&def));\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for the use of `.extend(s.chars())` where s is a\n+    /// `&str` or `String`.\n+    ///\n+    /// **Why is this bad?** `.push_str(s)` is clearer\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let abc = \"abc\";\n+    /// let def = String::from(\"def\");\n+    /// let mut s = String::new();\n+    /// s.extend(abc.chars());\n+    /// s.extend(def.chars());\n+    /// ```\n+    /// The correct use would be:\n+    /// ```rust\n+    /// let abc = \"abc\";\n+    /// let def = String::from(\"def\");\n+    /// let mut s = String::new();\n+    /// s.push_str(abc);\n+    /// s.push_str(&def));\n+    /// ```\n     pub STRING_EXTEND_CHARS,\n     style,\n     \"using `x.extend(s.chars())` where s is a `&str` or `String`\"\n }\n \n-/// **What it does:** Checks for the use of `.cloned().collect()` on slice to\n-/// create a `Vec`.\n-///\n-/// **Why is this bad?** `.to_vec()` is clearer\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let s = [1, 2, 3, 4, 5];\n-/// let s2: Vec<isize> = s[..].iter().cloned().collect();\n-/// ```\n-/// The better use would be:\n-/// ```rust\n-/// let s = [1, 2, 3, 4, 5];\n-/// let s2: Vec<isize> = s.to_vec();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for the use of `.cloned().collect()` on slice to\n+    /// create a `Vec`.\n+    ///\n+    /// **Why is this bad?** `.to_vec()` is clearer\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let s = [1, 2, 3, 4, 5];\n+    /// let s2: Vec<isize> = s[..].iter().cloned().collect();\n+    /// ```\n+    /// The better use would be:\n+    /// ```rust\n+    /// let s = [1, 2, 3, 4, 5];\n+    /// let s2: Vec<isize> = s.to_vec();\n+    /// ```\n     pub ITER_CLONED_COLLECT,\n     style,\n     \"using `.cloned().collect()` on slice to create a `Vec`\"\n }\n \n-/// **What it does:** Checks for usage of `.chars().last()` or\n-/// `.chars().next_back()` on a `str` to check if it ends with a given char.\n-///\n-/// **Why is this bad?** Readability, this can be written more concisely as\n-/// `_.ends_with(_)`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// name.chars().last() == Some('_') || name.chars().next_back() == Some('-')\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `.chars().last()` or\n+    /// `.chars().next_back()` on a `str` to check if it ends with a given char.\n+    ///\n+    /// **Why is this bad?** Readability, this can be written more concisely as\n+    /// `_.ends_with(_)`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// name.chars().last() == Some('_') || name.chars().next_back() == Some('-')\n+    /// ```\n     pub CHARS_LAST_CMP,\n     style,\n     \"using `.chars().last()` or `.chars().next_back()` to check if a string ends with a char\"\n }\n \n-/// **What it does:** Checks for usage of `.as_ref()` or `.as_mut()` where the\n-/// types before and after the call are the same.\n-///\n-/// **Why is this bad?** The call is unnecessary.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x: &[i32] = &[1, 2, 3, 4, 5];\n-/// do_stuff(x.as_ref());\n-/// ```\n-/// The correct use would be:\n-/// ```rust\n-/// let x: &[i32] = &[1, 2, 3, 4, 5];\n-/// do_stuff(x);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `.as_ref()` or `.as_mut()` where the\n+    /// types before and after the call are the same.\n+    ///\n+    /// **Why is this bad?** The call is unnecessary.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x: &[i32] = &[1, 2, 3, 4, 5];\n+    /// do_stuff(x.as_ref());\n+    /// ```\n+    /// The correct use would be:\n+    /// ```rust\n+    /// let x: &[i32] = &[1, 2, 3, 4, 5];\n+    /// do_stuff(x);\n+    /// ```\n     pub USELESS_ASREF,\n     complexity,\n     \"using `as_ref` where the types before and after the call are the same\"\n }\n \n-/// **What it does:** Checks for using `fold` when a more succinct alternative exists.\n-/// Specifically, this checks for `fold`s which could be replaced by `any`, `all`,\n-/// `sum` or `product`.\n-///\n-/// **Why is this bad?** Readability.\n-///\n-/// **Known problems:** False positive in pattern guards. Will be resolved once\n-/// non-lexical lifetimes are stable.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _ = (0..3).fold(false, |acc, x| acc || x > 2);\n-/// ```\n-/// This could be written as:\n-/// ```rust\n-/// let _ = (0..3).any(|x| x > 2);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for using `fold` when a more succinct alternative exists.\n+    /// Specifically, this checks for `fold`s which could be replaced by `any`, `all`,\n+    /// `sum` or `product`.\n+    ///\n+    /// **Why is this bad?** Readability.\n+    ///\n+    /// **Known problems:** False positive in pattern guards. Will be resolved once\n+    /// non-lexical lifetimes are stable.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _ = (0..3).fold(false, |acc, x| acc || x > 2);\n+    /// ```\n+    /// This could be written as:\n+    /// ```rust\n+    /// let _ = (0..3).any(|x| x > 2);\n+    /// ```\n     pub UNNECESSARY_FOLD,\n     style,\n     \"using `fold` when a more succinct alternative exists\"\n }\n \n-/// **What it does:** Checks for `filter_map` calls which could be replaced by `filter` or `map`.\n-/// More specifically it checks if the closure provided is only performing one of the\n-/// filter or map operations and suggests the appropriate option.\n-///\n-/// **Why is this bad?** Complexity. The intent is also clearer if only a single\n-/// operation is being performed.\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _ = (0..3).filter_map(|x| if x > 2 { Some(x) } else { None });\n-/// ```\n-/// As there is no transformation of the argument this could be written as:\n-/// ```rust\n-/// let _ = (0..3).filter(|&x| x > 2);\n-/// ```\n-///\n-/// ```rust\n-/// let _ = (0..4).filter_map(i32::checked_abs);\n-/// ```\n-/// As there is no conditional check on the argument this could be written as:\n-/// ```rust\n-/// let _ = (0..4).map(i32::checked_abs);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `filter_map` calls which could be replaced by `filter` or `map`.\n+    /// More specifically it checks if the closure provided is only performing one of the\n+    /// filter or map operations and suggests the appropriate option.\n+    ///\n+    /// **Why is this bad?** Complexity. The intent is also clearer if only a single\n+    /// operation is being performed.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _ = (0..3).filter_map(|x| if x > 2 { Some(x) } else { None });\n+    /// ```\n+    /// As there is no transformation of the argument this could be written as:\n+    /// ```rust\n+    /// let _ = (0..3).filter(|&x| x > 2);\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// let _ = (0..4).filter_map(i32::checked_abs);\n+    /// ```\n+    /// As there is no conditional check on the argument this could be written as:\n+    /// ```rust\n+    /// let _ = (0..4).map(i32::checked_abs);\n+    /// ```\n     pub UNNECESSARY_FILTER_MAP,\n     complexity,\n     \"using `filter_map` when a more succinct alternative exists\"\n }\n \n-/// **What it does:** Checks for `into_iter` calls on types which should be replaced by `iter` or\n-/// `iter_mut`.\n-///\n-/// **Why is this bad?** Arrays and `PathBuf` do not yet have an `into_iter` method which move out\n-/// their content into an iterator. Auto-referencing resolves the `into_iter` call to its reference\n-/// instead, like `<&[T; N] as IntoIterator>::into_iter`, which just iterates over item references\n-/// like calling `iter` would. Furthermore, when the standard library actually\n-/// [implements the `into_iter` method][25725] which moves the content out of the array, the\n-/// original use of `into_iter` got inferred with the wrong type and the code will be broken.\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// let _ = [1, 2, 3].into_iter().map(|x| *x).collect::<Vec<u32>>();\n-/// ```\n-///\n-/// [25725]: https://github.com/rust-lang/rust/issues/25725\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `into_iter` calls on types which should be replaced by `iter` or\n+    /// `iter_mut`.\n+    ///\n+    /// **Why is this bad?** Arrays and `PathBuf` do not yet have an `into_iter` method which move out\n+    /// their content into an iterator. Auto-referencing resolves the `into_iter` call to its reference\n+    /// instead, like `<&[T; N] as IntoIterator>::into_iter`, which just iterates over item references\n+    /// like calling `iter` would. Furthermore, when the standard library actually\n+    /// [implements the `into_iter` method][25725] which moves the content out of the array, the\n+    /// original use of `into_iter` got inferred with the wrong type and the code will be broken.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let _ = [1, 2, 3].into_iter().map(|x| *x).collect::<Vec<u32>>();\n+    /// ```\n+    ///\n+    /// [25725]: https://github.com/rust-lang/rust/issues/25725\n     pub INTO_ITER_ON_ARRAY,\n     correctness,\n     \"using `.into_iter()` on an array\"\n }\n \n-/// **What it does:** Checks for `into_iter` calls on references which should be replaced by `iter`\n-/// or `iter_mut`.\n-///\n-/// **Why is this bad?** Readability. Calling `into_iter` on a reference will not move out its\n-/// content into the resulting iterator, which is confusing. It is better just call `iter` or\n-/// `iter_mut` directly.\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// let _ = (&vec![3, 4, 5]).into_iter();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `into_iter` calls on references which should be replaced by `iter`\n+    /// or `iter_mut`.\n+    ///\n+    /// **Why is this bad?** Readability. Calling `into_iter` on a reference will not move out its\n+    /// content into the resulting iterator, which is confusing. It is better just call `iter` or\n+    /// `iter_mut` directly.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let _ = (&vec![3, 4, 5]).into_iter();\n+    /// ```\n     pub INTO_ITER_ON_REF,\n     style,\n     \"using `.into_iter()` on a reference\""}, {"sha": "22bc25094bea2d9127f85faef637a56c92a94c0d", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,21 +5,21 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use std::cmp::Ordering;\n \n-/// **What it does:** Checks for expressions where `std::cmp::min` and `max` are\n-/// used to clamp values, but switched so that the result is constant.\n-///\n-/// **Why is this bad?** This is in all probability not the intended outcome. At\n-/// the least it hurts readability of the code.\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// min(0, max(100, x))\n-/// ```\n-/// It will always be equal to `0`. Probably the author meant to clamp the value\n-/// between 0 and 100, but has erroneously swapped `min` and `max`.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for expressions where `std::cmp::min` and `max` are\n+    /// used to clamp values, but switched so that the result is constant.\n+    ///\n+    /// **Why is this bad?** This is in all probability not the intended outcome. At\n+    /// the least it hurts readability of the code.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// min(0, max(100, x))\n+    /// ```\n+    /// It will always be equal to `0`. Probably the author meant to clamp the value\n+    /// between 0 and 100, but has erroneously swapped `min` and `max`.\n     pub MIN_MAX,\n     correctness,\n     \"`min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\""}, {"sha": "34e276dcc4bcec1c381dd1feb68461f1f35e66a9", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 147, "deletions": 147, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -16,208 +16,208 @@ use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n use syntax::source_map::{ExpnFormat, Span};\n \n-/// **What it does:** Checks for function arguments and let bindings denoted as\n-/// `ref`.\n-///\n-/// **Why is this bad?** The `ref` declaration makes the function take an owned\n-/// value, but turns the argument into a reference (which means that the value\n-/// is destroyed when exiting the function). This adds not much value: either\n-/// take a reference type, or take an owned value and create references in the\n-/// body.\n-///\n-/// For let bindings, `let x = &foo;` is preferred over `let ref x = foo`. The\n-/// type of `x` is more obvious with the former.\n-///\n-/// **Known problems:** If the argument is dereferenced within the function,\n-/// removing the `ref` will lead to errors. This can be fixed by removing the\n-/// dereferences, e.g. changing `*x` to `x` within the function.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo(ref x: u8) -> bool {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for function arguments and let bindings denoted as\n+    /// `ref`.\n+    ///\n+    /// **Why is this bad?** The `ref` declaration makes the function take an owned\n+    /// value, but turns the argument into a reference (which means that the value\n+    /// is destroyed when exiting the function). This adds not much value: either\n+    /// take a reference type, or take an owned value and create references in the\n+    /// body.\n+    ///\n+    /// For let bindings, `let x = &foo;` is preferred over `let ref x = foo`. The\n+    /// type of `x` is more obvious with the former.\n+    ///\n+    /// **Known problems:** If the argument is dereferenced within the function,\n+    /// removing the `ref` will lead to errors. This can be fixed by removing the\n+    /// dereferences, e.g. changing `*x` to `x` within the function.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo(ref x: u8) -> bool {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub TOPLEVEL_REF_ARG,\n     style,\n     \"an entire binding declared as `ref`, in a function argument or a `let` statement\"\n }\n \n-/// **What it does:** Checks for comparisons to NaN.\n-///\n-/// **Why is this bad?** NaN does not compare meaningfully to anything \u2013 not\n-/// even itself \u2013 so those comparisons are simply wrong.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x == NAN\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for comparisons to NaN.\n+    ///\n+    /// **Why is this bad?** NaN does not compare meaningfully to anything \u2013 not\n+    /// even itself \u2013 so those comparisons are simply wrong.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x == NAN\n+    /// ```\n     pub CMP_NAN,\n     correctness,\n     \"comparisons to NAN, which will always return false, probably not intended\"\n }\n \n-/// **What it does:** Checks for (in-)equality comparisons on floating-point\n-/// values (apart from zero), except in functions called `*eq*` (which probably\n-/// implement equality for a type involving floats).\n-///\n-/// **Why is this bad?** Floating point calculations are usually imprecise, so\n-/// asking if two values are *exactly* equal is asking for trouble. For a good\n-/// guide on what to do, see [the floating point\n-/// guide](http://www.floating-point-gui.de/errors/comparison).\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// y == 1.23f64\n-/// y != x  // where both are floats\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for (in-)equality comparisons on floating-point\n+    /// values (apart from zero), except in functions called `*eq*` (which probably\n+    /// implement equality for a type involving floats).\n+    ///\n+    /// **Why is this bad?** Floating point calculations are usually imprecise, so\n+    /// asking if two values are *exactly* equal is asking for trouble. For a good\n+    /// guide on what to do, see [the floating point\n+    /// guide](http://www.floating-point-gui.de/errors/comparison).\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// y == 1.23f64\n+    /// y != x  // where both are floats\n+    /// ```\n     pub FLOAT_CMP,\n     correctness,\n     \"using `==` or `!=` on float values instead of comparing difference with an epsilon\"\n }\n \n-/// **What it does:** Checks for conversions to owned values just for the sake\n-/// of a comparison.\n-///\n-/// **Why is this bad?** The comparison can operate on a reference, so creating\n-/// an owned value effectively throws it away directly afterwards, which is\n-/// needlessly consuming code and heap space.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.to_owned() == y\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for conversions to owned values just for the sake\n+    /// of a comparison.\n+    ///\n+    /// **Why is this bad?** The comparison can operate on a reference, so creating\n+    /// an owned value effectively throws it away directly afterwards, which is\n+    /// needlessly consuming code and heap space.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x.to_owned() == y\n+    /// ```\n     pub CMP_OWNED,\n     perf,\n     \"creating owned instances for comparing with others, e.g. `x == \\\"foo\\\".to_string()`\"\n }\n \n-/// **What it does:** Checks for getting the remainder of a division by one.\n-///\n-/// **Why is this bad?** The result can only ever be zero. No one will write\n-/// such code deliberately, unless trying to win an Underhanded Rust\n-/// Contest. Even for that contest, it's probably a bad idea. Use something more\n-/// underhanded.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x % 1\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for getting the remainder of a division by one.\n+    ///\n+    /// **Why is this bad?** The result can only ever be zero. No one will write\n+    /// such code deliberately, unless trying to win an Underhanded Rust\n+    /// Contest. Even for that contest, it's probably a bad idea. Use something more\n+    /// underhanded.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x % 1\n+    /// ```\n     pub MODULO_ONE,\n     correctness,\n     \"taking a number modulo 1, which always returns 0\"\n }\n \n-/// **What it does:** Checks for patterns in the form `name @ _`.\n-///\n-/// **Why is this bad?** It's almost always more readable to just use direct\n-/// bindings.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// match v {\n-///     Some(x) => (),\n-///     y @ _ => (), // easier written as `y`,\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for patterns in the form `name @ _`.\n+    ///\n+    /// **Why is this bad?** It's almost always more readable to just use direct\n+    /// bindings.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// match v {\n+    ///     Some(x) => (),\n+    ///     y @ _ => (), // easier written as `y`,\n+    /// }\n+    /// ```\n     pub REDUNDANT_PATTERN,\n     style,\n     \"using `name @ _` in a pattern\"\n }\n \n-/// **What it does:** Checks for the use of bindings with a single leading\n-/// underscore.\n-///\n-/// **Why is this bad?** A single leading underscore is usually used to indicate\n-/// that a binding will not be used. Using such a binding breaks this\n-/// expectation.\n-///\n-/// **Known problems:** The lint does not work properly with desugaring and\n-/// macro, it has been allowed in the mean time.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _x = 0;\n-/// let y = _x + 1; // Here we are using `_x`, even though it has a leading\n-///                 // underscore. We should rename `_x` to `x`\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for the use of bindings with a single leading\n+    /// underscore.\n+    ///\n+    /// **Why is this bad?** A single leading underscore is usually used to indicate\n+    /// that a binding will not be used. Using such a binding breaks this\n+    /// expectation.\n+    ///\n+    /// **Known problems:** The lint does not work properly with desugaring and\n+    /// macro, it has been allowed in the mean time.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _x = 0;\n+    /// let y = _x + 1; // Here we are using `_x`, even though it has a leading\n+    ///                 // underscore. We should rename `_x` to `x`\n+    /// ```\n     pub USED_UNDERSCORE_BINDING,\n     pedantic,\n     \"using a binding which is prefixed with an underscore\"\n }\n \n-/// **What it does:** Checks for the use of short circuit boolean conditions as\n-/// a\n-/// statement.\n-///\n-/// **Why is this bad?** Using a short circuit boolean condition as a statement\n-/// may hide the fact that the second part is executed or not depending on the\n-/// outcome of the first part.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// f() && g(); // We should write `if f() { g(); }`.\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for the use of short circuit boolean conditions as\n+    /// a\n+    /// statement.\n+    ///\n+    /// **Why is this bad?** Using a short circuit boolean condition as a statement\n+    /// may hide the fact that the second part is executed or not depending on the\n+    /// outcome of the first part.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// f() && g(); // We should write `if f() { g(); }`.\n+    /// ```\n     pub SHORT_CIRCUIT_STATEMENT,\n     complexity,\n     \"using a short circuit boolean condition as a statement\"\n }\n \n-/// **What it does:** Catch casts from `0` to some pointer type\n-///\n-/// **Why is this bad?** This generally means `null` and is better expressed as\n-/// {`std`, `core`}`::ptr::`{`null`, `null_mut`}.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// 0 as *const u32\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Catch casts from `0` to some pointer type\n+    ///\n+    /// **Why is this bad?** This generally means `null` and is better expressed as\n+    /// {`std`, `core`}`::ptr::`{`null`, `null_mut`}.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// 0 as *const u32\n+    /// ```\n     pub ZERO_PTR,\n     style,\n     \"using 0 as *{const, mut} T\"\n }\n \n-/// **What it does:** Checks for (in-)equality comparisons on floating-point\n-/// value and constant, except in functions called `*eq*` (which probably\n-/// implement equality for a type involving floats).\n-///\n-/// **Why is this bad?** Floating point calculations are usually imprecise, so\n-/// asking if two values are *exactly* equal is asking for trouble. For a good\n-/// guide on what to do, see [the floating point\n-/// guide](http://www.floating-point-gui.de/errors/comparison).\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// const ONE = 1.00f64;\n-/// x == ONE  // where both are floats\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for (in-)equality comparisons on floating-point\n+    /// value and constant, except in functions called `*eq*` (which probably\n+    /// implement equality for a type involving floats).\n+    ///\n+    /// **Why is this bad?** Floating point calculations are usually imprecise, so\n+    /// asking if two values are *exactly* equal is asking for trouble. For a good\n+    /// guide on what to do, see [the floating point\n+    /// guide](http://www.floating-point-gui.de/errors/comparison).\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// const ONE = 1.00f64;\n+    /// x == ONE  // where both are floats\n+    /// ```\n     pub FLOAT_CMP_CONST,\n     restriction,\n     \"using `==` or `!=` on float constants instead of comparing difference with an epsilon\""}, {"sha": "e522326066c376138fd06b3cc4fe8047957a2f8c", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 114, "deletions": 114, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -9,163 +9,163 @@ use syntax::ast::*;\n use syntax::source_map::Span;\n use syntax::visit::{walk_expr, FnKind, Visitor};\n \n-/// **What it does:** Checks for structure field patterns bound to wildcards.\n-///\n-/// **Why is this bad?** Using `..` instead is shorter and leaves the focus on\n-/// the fields that are actually bound.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let { a: _, b: ref b, c: _ } = ..\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for structure field patterns bound to wildcards.\n+    ///\n+    /// **Why is this bad?** Using `..` instead is shorter and leaves the focus on\n+    /// the fields that are actually bound.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let { a: _, b: ref b, c: _ } = ..\n+    /// ```\n     pub UNNEEDED_FIELD_PATTERN,\n     style,\n     \"struct fields bound to a wildcard instead of using `..`\"\n }\n \n-/// **What it does:** Checks for function arguments having the similar names\n-/// differing by an underscore.\n-///\n-/// **Why is this bad?** It affects code readability.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo(a: i32, _a: i32) {}\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for function arguments having the similar names\n+    /// differing by an underscore.\n+    ///\n+    /// **Why is this bad?** It affects code readability.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo(a: i32, _a: i32) {}\n+    /// ```\n     pub DUPLICATE_UNDERSCORE_ARGUMENT,\n     style,\n     \"function arguments having names which only differ by an underscore\"\n }\n \n-/// **What it does:** Detects closures called in the same expression where they\n-/// are defined.\n-///\n-/// **Why is this bad?** It is unnecessarily adding to the expression's\n-/// complexity.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// (|| 42)()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Detects closures called in the same expression where they\n+    /// are defined.\n+    ///\n+    /// **Why is this bad?** It is unnecessarily adding to the expression's\n+    /// complexity.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// (|| 42)()\n+    /// ```\n     pub REDUNDANT_CLOSURE_CALL,\n     complexity,\n     \"throwaway closures called in the expression they are defined\"\n }\n \n-/// **What it does:** Detects expressions of the form `--x`.\n-///\n-/// **Why is this bad?** It can mislead C/C++ programmers to think `x` was\n-/// decremented.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// --x;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Detects expressions of the form `--x`.\n+    ///\n+    /// **Why is this bad?** It can mislead C/C++ programmers to think `x` was\n+    /// decremented.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// --x;\n+    /// ```\n     pub DOUBLE_NEG,\n     style,\n     \"`--x`, which is a double negation of `x` and not a pre-decrement as in C/C++\"\n }\n \n-/// **What it does:** Warns on hexadecimal literals with mixed-case letter\n-/// digits.\n-///\n-/// **Why is this bad?** It looks confusing.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let y = 0x1a9BAcD;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Warns on hexadecimal literals with mixed-case letter\n+    /// digits.\n+    ///\n+    /// **Why is this bad?** It looks confusing.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let y = 0x1a9BAcD;\n+    /// ```\n     pub MIXED_CASE_HEX_LITERALS,\n     style,\n     \"hex literals whose letter digits are not consistently upper- or lowercased\"\n }\n \n-/// **What it does:** Warns if literal suffixes are not separated by an\n-/// underscore.\n-///\n-/// **Why is this bad?** It is much less readable.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let y = 123832i32;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Warns if literal suffixes are not separated by an\n+    /// underscore.\n+    ///\n+    /// **Why is this bad?** It is much less readable.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let y = 123832i32;\n+    /// ```\n     pub UNSEPARATED_LITERAL_SUFFIX,\n     pedantic,\n     \"literals whose suffix is not separated by an underscore\"\n }\n \n-/// **What it does:** Warns if an integral constant literal starts with `0`.\n-///\n-/// **Why is this bad?** In some languages (including the infamous C language\n-/// and most of its\n-/// family), this marks an octal constant. In Rust however, this is a decimal\n-/// constant. This could\n-/// be confusing for both the writer and a reader of the constant.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// In Rust:\n-/// ```rust\n-/// fn main() {\n-///     let a = 0123;\n-///     println!(\"{}\", a);\n-/// }\n-/// ```\n-///\n-/// prints `123`, while in C:\n-///\n-/// ```c\n-/// #include <stdio.h>\n-///\n-/// int main() {\n-///     int a = 0123;\n-///     printf(\"%d\\n\", a);\n-/// }\n-/// ```\n-///\n-/// prints `83` (as `83 == 0o123` while `123 == 0o173`).\n declare_clippy_lint! {\n+    /// **What it does:** Warns if an integral constant literal starts with `0`.\n+    ///\n+    /// **Why is this bad?** In some languages (including the infamous C language\n+    /// and most of its\n+    /// family), this marks an octal constant. In Rust however, this is a decimal\n+    /// constant. This could\n+    /// be confusing for both the writer and a reader of the constant.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// In Rust:\n+    /// ```rust\n+    /// fn main() {\n+    ///     let a = 0123;\n+    ///     println!(\"{}\", a);\n+    /// }\n+    /// ```\n+    ///\n+    /// prints `123`, while in C:\n+    ///\n+    /// ```c\n+    /// #include <stdio.h>\n+    ///\n+    /// int main() {\n+    ///     int a = 0123;\n+    ///     printf(\"%d\\n\", a);\n+    /// }\n+    /// ```\n+    ///\n+    /// prints `83` (as `83 == 0o123` while `123 == 0o173`).\n     pub ZERO_PREFIXED_LITERAL,\n     complexity,\n     \"integer literals starting with `0`\"\n }\n \n-/// **What it does:** Warns if a generic shadows a built-in type.\n-///\n-/// **Why is this bad?** This gives surprising type errors.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// impl<u32> Foo<u32> {\n-///     fn impl_func(&self) -> u32 {\n-///         42\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Warns if a generic shadows a built-in type.\n+    ///\n+    /// **Why is this bad?** This gives surprising type errors.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// impl<u32> Foo<u32> {\n+    ///     fn impl_func(&self) -> u32 {\n+    ///         42\n+    ///     }\n+    /// }\n+    /// ```\n     pub BUILTIN_TYPE_SHADOW,\n     style,\n     \"shadowing a builtin type\""}, {"sha": "19757f32e6b49534e64b3f3c8ba5d3163019c279", "filename": "clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -8,51 +8,51 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_mir::transform::qualify_min_const_fn::is_min_const_fn;\n use syntax_pos::Span;\n \n-/// **What it does:**\n-///\n-/// Suggests the use of `const` in functions and methods where possible.\n-///\n-/// **Why is this bad?**\n-///\n-/// Not having the function const prevents callers of the function from being const as well.\n-///\n-/// **Known problems:**\n-///\n-/// Const functions are currently still being worked on, with some features only being available\n-/// on nightly. This lint does not consider all edge cases currently and the suggestions may be\n-/// incorrect if you are using this lint on stable.\n-///\n-/// Also, the lint only runs one pass over the code. Consider these two non-const functions:\n-///\n-/// ```rust\n-/// fn a() -> i32 {\n-///     0\n-/// }\n-/// fn b() -> i32 {\n-///     a()\n-/// }\n-/// ```\n-///\n-/// When running Clippy, the lint will only suggest to make `a` const, because `b` at this time\n-/// can't be const as it calls a non-const function. Making `a` const and running Clippy again,\n-/// will suggest to make `b` const, too.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// fn new() -> Self {\n-///     Self { random_number: 42 }\n-/// }\n-/// ```\n-///\n-/// Could be a const fn:\n-///\n-/// ```rust\n-/// const fn new() -> Self {\n-///     Self { random_number: 42 }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:**\n+    ///\n+    /// Suggests the use of `const` in functions and methods where possible.\n+    ///\n+    /// **Why is this bad?**\n+    ///\n+    /// Not having the function const prevents callers of the function from being const as well.\n+    ///\n+    /// **Known problems:**\n+    ///\n+    /// Const functions are currently still being worked on, with some features only being available\n+    /// on nightly. This lint does not consider all edge cases currently and the suggestions may be\n+    /// incorrect if you are using this lint on stable.\n+    ///\n+    /// Also, the lint only runs one pass over the code. Consider these two non-const functions:\n+    ///\n+    /// ```rust\n+    /// fn a() -> i32 {\n+    ///     0\n+    /// }\n+    /// fn b() -> i32 {\n+    ///     a()\n+    /// }\n+    /// ```\n+    ///\n+    /// When running Clippy, the lint will only suggest to make `a` const, because `b` at this time\n+    /// can't be const as it calls a non-const function. Making `a` const and running Clippy again,\n+    /// will suggest to make `b` const, too.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// fn new() -> Self {\n+    ///     Self { random_number: 42 }\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be a const fn:\n+    ///\n+    /// ```rust\n+    /// const fn new() -> Self {\n+    ///     Self { random_number: 42 }\n+    /// }\n+    /// ```\n     pub MISSING_CONST_FOR_FN,\n     nursery,\n     \"Lint functions definitions that could be made `const fn`\""}, {"sha": "d7e4dd221232600ccb0611b67bdb604a4eb6eab6", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -14,16 +14,16 @@ use syntax::ast;\n use syntax::attr;\n use syntax::source_map::Span;\n \n-/// **What it does:** Warns if there is missing doc for any documentable item\n-/// (public or private).\n-///\n-/// **Why is this bad?** Doc is good. *rustc* has a `MISSING_DOCS`\n-/// allowed-by-default lint for\n-/// public members, but has no way to enforce documentation of private items.\n-/// This lint fixes that.\n-///\n-/// **Known problems:** None.\n declare_clippy_lint! {\n+    /// **What it does:** Warns if there is missing doc for any documentable item\n+    /// (public or private).\n+    ///\n+    /// **Why is this bad?** Doc is good. *rustc* has a `MISSING_DOCS`\n+    /// allowed-by-default lint for\n+    /// public members, but has no way to enforce documentation of private items.\n+    /// This lint fixes that.\n+    ///\n+    /// **Known problems:** None.\n     pub MISSING_DOCS_IN_PRIVATE_ITEMS,\n     restriction,\n     \"detects missing documentation for public and private members\""}, {"sha": "82c5b62145b6419665377a59f199d0bc628754fe", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,52 +5,52 @@ use rustc::{declare_tool_lint, lint_array};\n use syntax::ast;\n use syntax::source_map::Span;\n \n-/// **What it does:** it lints if an exported function, method, trait method with default impl,\n-/// or trait method impl is not `#[inline]`.\n-///\n-/// **Why is this bad?** In general, it is not. Functions can be inlined across\n-/// crates when that's profitable as long as any form of LTO is used. When LTO is disabled,\n-/// functions that are not `#[inline]` cannot be inlined across crates. Certain types of crates\n-/// might intend for most of the methods in their public API to be able to be inlined across\n-/// crates even when LTO is disabled. For these types of crates, enabling this lint might make\n-/// sense. It allows the crate to require all exported methods to be `#[inline]` by default, and\n-/// then opt out for specific methods where this might not make sense.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// pub fn foo() {} // missing #[inline]\n-/// fn ok() {} // ok\n-/// #[inline] pub fn bar() {} // ok\n-/// #[inline(always)] pub fn baz() {} // ok\n-///\n-/// pub trait Bar {\n-///   fn bar(); // ok\n-///   fn def_bar() {} // missing #[inline]\n-/// }\n-///\n-/// struct Baz;\n-/// impl Baz {\n-///    fn priv() {} // ok\n-/// }\n-///\n-/// impl Bar for Baz {\n-///   fn bar() {} // ok - Baz is not exported\n-/// }\n-///\n-/// pub struct PubBaz;\n-/// impl PubBaz {\n-///    fn priv() {} // ok\n-///    pub not_ptriv() {} // missing #[inline]\n-/// }\n-///\n-/// impl Bar for PubBaz {\n-///    fn bar() {} // missing #[inline]\n-///    fn def_bar() {} // missing #[inline]\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** it lints if an exported function, method, trait method with default impl,\n+    /// or trait method impl is not `#[inline]`.\n+    ///\n+    /// **Why is this bad?** In general, it is not. Functions can be inlined across\n+    /// crates when that's profitable as long as any form of LTO is used. When LTO is disabled,\n+    /// functions that are not `#[inline]` cannot be inlined across crates. Certain types of crates\n+    /// might intend for most of the methods in their public API to be able to be inlined across\n+    /// crates even when LTO is disabled. For these types of crates, enabling this lint might make\n+    /// sense. It allows the crate to require all exported methods to be `#[inline]` by default, and\n+    /// then opt out for specific methods where this might not make sense.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// pub fn foo() {} // missing #[inline]\n+    /// fn ok() {} // ok\n+    /// #[inline] pub fn bar() {} // ok\n+    /// #[inline(always)] pub fn baz() {} // ok\n+    ///\n+    /// pub trait Bar {\n+    ///   fn bar(); // ok\n+    ///   fn def_bar() {} // missing #[inline]\n+    /// }\n+    ///\n+    /// struct Baz;\n+    /// impl Baz {\n+    ///    fn priv() {} // ok\n+    /// }\n+    ///\n+    /// impl Bar for Baz {\n+    ///   fn bar() {} // ok - Baz is not exported\n+    /// }\n+    ///\n+    /// pub struct PubBaz;\n+    /// impl PubBaz {\n+    ///    fn priv() {} // ok\n+    ///    pub not_ptriv() {} // missing #[inline]\n+    /// }\n+    ///\n+    /// impl Bar for PubBaz {\n+    ///    fn bar() {} // missing #[inline]\n+    ///    fn def_bar() {} // missing #[inline]\n+    /// }\n+    /// ```\n     pub MISSING_INLINE_IN_PUBLIC_ITEMS,\n     restriction,\n     \"detects missing #[inline] attribute for public callables (functions, trait methods, methods...)\""}, {"sha": "68293f58cadd5bd451af95188e830a0e64382722", "filename": "clippy_lints/src/multiple_crate_versions.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -8,24 +8,24 @@ use syntax::{ast::*, source_map::DUMMY_SP};\n use cargo_metadata;\n use itertools::Itertools;\n \n-/// **What it does:** Checks to see if multiple versions of a crate are being\n-/// used.\n-///\n-/// **Why is this bad?** This bloats the size of targets, and can lead to\n-/// confusing error messages when structs or traits are used interchangeably\n-/// between different versions of a crate.\n-///\n-/// **Known problems:** Because this can be caused purely by the dependencies\n-/// themselves, it's not always possible to fix this issue.\n-///\n-/// **Example:**\n-/// ```toml\n-/// # This will pull in both winapi v0.3.4 and v0.2.8, triggering a warning.\n-/// [dependencies]\n-/// ctrlc = \"3.1.0\"\n-/// ansi_term = \"0.11.0\"\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks to see if multiple versions of a crate are being\n+    /// used.\n+    ///\n+    /// **Why is this bad?** This bloats the size of targets, and can lead to\n+    /// confusing error messages when structs or traits are used interchangeably\n+    /// between different versions of a crate.\n+    ///\n+    /// **Known problems:** Because this can be caused purely by the dependencies\n+    /// themselves, it's not always possible to fix this issue.\n+    ///\n+    /// **Example:**\n+    /// ```toml\n+    /// # This will pull in both winapi v0.3.4 and v0.2.8, triggering a warning.\n+    /// [dependencies]\n+    /// ctrlc = \"3.1.0\"\n+    /// ansi_term = \"0.11.0\"\n+    /// ```\n     pub MULTIPLE_CRATE_VERSIONS,\n     cargo,\n     \"multiple versions of the same crate being used\""}, {"sha": "41b5f6f383315e2fef2c1afe692ab7bcce297b62", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,19 +5,19 @@ use rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintC\n use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for instances of `mut mut` references.\n-///\n-/// **Why is this bad?** Multiple `mut`s don't add anything meaningful to the\n-/// source. This is either a copy'n'paste error, or it shows a fundamental\n-/// misunderstanding of references.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = &mut &mut y;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for instances of `mut mut` references.\n+    ///\n+    /// **Why is this bad?** Multiple `mut`s don't add anything meaningful to the\n+    /// source. This is either a copy'n'paste error, or it shows a fundamental\n+    /// misunderstanding of references.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = &mut &mut y;\n+    /// ```\n     pub MUT_MUT,\n     pedantic,\n     \"usage of double-mut refs, e.g. `&mut &mut ...`\""}, {"sha": "69f41e23508db8c0dfa8170c0e1a4dea19f54b51", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,19 +5,19 @@ use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Detects giving a mutable reference to a function that only\n-/// requires an immutable reference.\n-///\n-/// **Why is this bad?** The immutable reference rules out all other references\n-/// to the value. Also the code misleads about the intent of the call site.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// my_vec.push(&mut value)\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Detects giving a mutable reference to a function that only\n+    /// requires an immutable reference.\n+    ///\n+    /// **Why is this bad?** The immutable reference rules out all other references\n+    /// to the value. Also the code misleads about the intent of the call site.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// my_vec.push(&mut value)\n+    /// ```\n     pub UNNECESSARY_MUT_PASSED,\n     style,\n     \"an argument passed as a mutable reference although the callee only demands an immutable reference\""}, {"sha": "6800e4295f5702b9449e50ab20aa97dd79454129", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -9,41 +9,41 @@ use rustc::ty::{self, Ty};\n use rustc::{declare_tool_lint, lint_array};\n use syntax::ast;\n \n-/// **What it does:** Checks for usages of `Mutex<X>` where an atomic will do.\n-///\n-/// **Why is this bad?** Using a mutex just to make access to a plain bool or\n-/// reference sequential is shooting flies with cannons.\n-/// `std::sync::atomic::AtomicBool` and `std::sync::atomic::AtomicPtr` are leaner and\n-/// faster.\n-///\n-/// **Known problems:** This lint cannot detect if the mutex is actually used\n-/// for waiting before a critical section.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = Mutex::new(&y);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usages of `Mutex<X>` where an atomic will do.\n+    ///\n+    /// **Why is this bad?** Using a mutex just to make access to a plain bool or\n+    /// reference sequential is shooting flies with cannons.\n+    /// `std::sync::atomic::AtomicBool` and `std::sync::atomic::AtomicPtr` are leaner and\n+    /// faster.\n+    ///\n+    /// **Known problems:** This lint cannot detect if the mutex is actually used\n+    /// for waiting before a critical section.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = Mutex::new(&y);\n+    /// ```\n     pub MUTEX_ATOMIC,\n     perf,\n     \"using a mutex where an atomic value could be used instead\"\n }\n \n-/// **What it does:** Checks for usages of `Mutex<X>` where `X` is an integral\n-/// type.\n-///\n-/// **Why is this bad?** Using a mutex just to make access to a plain integer\n-/// sequential is\n-/// shooting flies with cannons. `std::sync::atomic::AtomicUsize` is leaner and faster.\n-///\n-/// **Known problems:** This lint cannot detect if the mutex is actually used\n-/// for waiting before a critical section.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = Mutex::new(0usize);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usages of `Mutex<X>` where `X` is an integral\n+    /// type.\n+    ///\n+    /// **Why is this bad?** Using a mutex just to make access to a plain integer\n+    /// sequential is\n+    /// shooting flies with cannons. `std::sync::atomic::AtomicUsize` is leaner and faster.\n+    ///\n+    /// **Known problems:** This lint cannot detect if the mutex is actually used\n+    /// for waiting before a critical section.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = Mutex::new(0usize);\n+    /// ```\n     pub MUTEX_INTEGER,\n     nursery,\n     \"using a mutex for an integer type\""}, {"sha": "2a4f2bb1450feeb0e0d8546566b042dc1e39a296", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -11,44 +11,44 @@ use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n use syntax::source_map::Spanned;\n \n-/// **What it does:** Checks for expressions of the form `if c { true } else {\n-/// false }`\n-/// (or vice versa) and suggest using the condition directly.\n-///\n-/// **Why is this bad?** Redundant code.\n-///\n-/// **Known problems:** Maybe false positives: Sometimes, the two branches are\n-/// painstakingly documented (which we of course do not detect), so they *may*\n-/// have some value. Even then, the documentation can be rewritten to match the\n-/// shorter code.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if x {\n-///     false\n-/// } else {\n-///     true\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for expressions of the form `if c { true } else {\n+    /// false }`\n+    /// (or vice versa) and suggest using the condition directly.\n+    ///\n+    /// **Why is this bad?** Redundant code.\n+    ///\n+    /// **Known problems:** Maybe false positives: Sometimes, the two branches are\n+    /// painstakingly documented (which we of course do not detect), so they *may*\n+    /// have some value. Even then, the documentation can be rewritten to match the\n+    /// shorter code.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if x {\n+    ///     false\n+    /// } else {\n+    ///     true\n+    /// }\n+    /// ```\n     pub NEEDLESS_BOOL,\n     complexity,\n     \"if-statements with plain booleans in the then- and else-clause, e.g. `if p { true } else { false }`\"\n }\n \n-/// **What it does:** Checks for expressions of the form `x == true`,\n-/// `x != true` and order comparisons such as `x < true` (or vice versa) and\n-/// suggest using the variable directly.\n-///\n-/// **Why is this bad?** Unnecessary code.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if x == true {} // could be `if x { }`\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for expressions of the form `x == true`,\n+    /// `x != true` and order comparisons such as `x < true` (or vice versa) and\n+    /// suggest using the variable directly.\n+    ///\n+    /// **Why is this bad?** Unnecessary code.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if x == true {} // could be `if x { }`\n+    /// ```\n     pub BOOL_COMPARISON,\n     complexity,\n     \"comparing a variable to a boolean, e.g. `if x == true` or `if x != true`\""}, {"sha": "59b4095f61ec5b59d5a186c50d0a87a449ade654", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -11,19 +11,19 @@ use rustc::ty::adjustment::{Adjust, Adjustment};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for address of operations (`&`) that are going to\n-/// be dereferenced immediately by the compiler.\n-///\n-/// **Why is this bad?** Suggests that the receiver of the expression borrows\n-/// the expression.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x: &i32 = &&&&&&5;\n-/// ```\n-///\n-/// **Known problems:** None.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for address of operations (`&`) that are going to\n+    /// be dereferenced immediately by the compiler.\n+    ///\n+    /// **Why is this bad?** Suggests that the receiver of the expression borrows\n+    /// the expression.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x: &i32 = &&&&&&5;\n+    /// ```\n+    ///\n+    /// **Known problems:** None.\n     pub NEEDLESS_BORROW,\n     nursery,\n     \"taking a reference that is going to be automatically dereferenced\""}, {"sha": "2c1f87c53e35596d44f3440dab069fe278ca83fe", "filename": "clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -9,43 +9,43 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for useless borrowed references.\n-///\n-/// **Why is this bad?** It is mostly useless and make the code look more\n-/// complex than it\n-/// actually is.\n-///\n-/// **Known problems:** It seems that the `&ref` pattern is sometimes useful.\n-/// For instance in the following snippet:\n-/// ```rust\n-/// enum Animal {\n-///     Cat(u64),\n-///     Dog(u64),\n-/// }\n-///\n-/// fn foo(a: &Animal, b: &Animal) {\n-///     match (a, b) {\n-/// (&Animal::Cat(v), k) | (k, &Animal::Cat(v)) => (), // lifetime\n-/// mismatch error\n-///         (&Animal::Dog(ref c), &Animal::Dog(_)) => ()\n-///     }\n-/// }\n-/// ```\n-/// There is a lifetime mismatch error for `k` (indeed a and b have distinct\n-/// lifetime).\n-/// This can be fixed by using the `&ref` pattern.\n-/// However, the code can also be fixed by much cleaner ways\n-///\n-/// **Example:**\n-/// ```rust\n-/// let mut v = Vec::<String>::new();\n-/// let _ = v.iter_mut().filter(|&ref a| a.is_empty());\n-/// ```\n-/// This closure takes a reference on something that has been matched as a\n-/// reference and\n-/// de-referenced.\n-/// As such, it could just be |a| a.is_empty()\n declare_clippy_lint! {\n+    /// **What it does:** Checks for useless borrowed references.\n+    ///\n+    /// **Why is this bad?** It is mostly useless and make the code look more\n+    /// complex than it\n+    /// actually is.\n+    ///\n+    /// **Known problems:** It seems that the `&ref` pattern is sometimes useful.\n+    /// For instance in the following snippet:\n+    /// ```rust\n+    /// enum Animal {\n+    ///     Cat(u64),\n+    ///     Dog(u64),\n+    /// }\n+    ///\n+    /// fn foo(a: &Animal, b: &Animal) {\n+    ///     match (a, b) {\n+    /// (&Animal::Cat(v), k) | (k, &Animal::Cat(v)) => (), // lifetime\n+    /// mismatch error\n+    ///         (&Animal::Dog(ref c), &Animal::Dog(_)) => ()\n+    ///     }\n+    /// }\n+    /// ```\n+    /// There is a lifetime mismatch error for `k` (indeed a and b have distinct\n+    /// lifetime).\n+    /// This can be fixed by using the `&ref` pattern.\n+    /// However, the code can also be fixed by much cleaner ways\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut v = Vec::<String>::new();\n+    /// let _ = v.iter_mut().filter(|&ref a| a.is_empty());\n+    /// ```\n+    /// This closure takes a reference on something that has been matched as a\n+    /// reference and\n+    /// de-referenced.\n+    /// As such, it could just be |a| a.is_empty()\n     pub NEEDLESS_BORROWED_REFERENCE,\n     complexity,\n     \"taking a needless borrowed reference\""}, {"sha": "00394a9e1e2ba1e271704582e0ed79b702c36506", "filename": "clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_continue.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -35,66 +35,66 @@ use syntax::source_map::{original_sp, DUMMY_SP};\n \n use crate::utils::{in_macro, snippet, snippet_block, span_help_and_lint, trim_multiline};\n \n-/// **What it does:** The lint checks for `if`-statements appearing in loops\n-/// that contain a `continue` statement in either their main blocks or their\n-/// `else`-blocks, when omitting the `else`-block possibly with some\n-/// rearrangement of code can make the code easier to understand.\n-///\n-/// **Why is this bad?** Having explicit `else` blocks for `if` statements\n-/// containing `continue` in their THEN branch adds unnecessary branching and\n-/// nesting to the code. Having an else block containing just `continue` can\n-/// also be better written by grouping the statements following the whole `if`\n-/// statement within the THEN block and omitting the else block completely.\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// while condition() {\n-///     update_condition();\n-///     if x {\n-///         // ...\n-///     } else {\n-///         continue;\n-///     }\n-///     println!(\"Hello, world\");\n-/// }\n-/// ```\n-///\n-/// Could be rewritten as\n-///\n-/// ```rust\n-/// while condition() {\n-///     update_condition();\n-///     if x {\n-///         // ...\n-///         println!(\"Hello, world\");\n-///     }\n-/// }\n-/// ```\n-///\n-/// As another example, the following code\n-///\n-/// ```rust\n-/// loop {\n-///     if waiting() {\n-///         continue;\n-///     } else {\n-///         // Do something useful\n-///     }\n-/// }\n-/// ```\n-/// Could be rewritten as\n-///\n-/// ```rust\n-/// loop {\n-///     if waiting() {\n-///         continue;\n-///     }\n-///     // Do something useful\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** The lint checks for `if`-statements appearing in loops\n+    /// that contain a `continue` statement in either their main blocks or their\n+    /// `else`-blocks, when omitting the `else`-block possibly with some\n+    /// rearrangement of code can make the code easier to understand.\n+    ///\n+    /// **Why is this bad?** Having explicit `else` blocks for `if` statements\n+    /// containing `continue` in their THEN branch adds unnecessary branching and\n+    /// nesting to the code. Having an else block containing just `continue` can\n+    /// also be better written by grouping the statements following the whole `if`\n+    /// statement within the THEN block and omitting the else block completely.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// while condition() {\n+    ///     update_condition();\n+    ///     if x {\n+    ///         // ...\n+    ///     } else {\n+    ///         continue;\n+    ///     }\n+    ///     println!(\"Hello, world\");\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be rewritten as\n+    ///\n+    /// ```rust\n+    /// while condition() {\n+    ///     update_condition();\n+    ///     if x {\n+    ///         // ...\n+    ///         println!(\"Hello, world\");\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// As another example, the following code\n+    ///\n+    /// ```rust\n+    /// loop {\n+    ///     if waiting() {\n+    ///         continue;\n+    ///     } else {\n+    ///         // Do something useful\n+    ///     }\n+    /// }\n+    /// ```\n+    /// Could be rewritten as\n+    ///\n+    /// ```rust\n+    /// loop {\n+    ///     if waiting() {\n+    ///         continue;\n+    ///     }\n+    ///     // Do something useful\n+    /// }\n+    /// ```\n     pub NEEDLESS_CONTINUE,\n     pedantic,\n     \"`continue` statements that can be replaced by a rearrangement of code\""}, {"sha": "5dfc36d3e0e8b9872997608b5b5af8a972bc7ae0", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -20,30 +20,30 @@ use std::borrow::Cow;\n use syntax::errors::DiagnosticBuilder;\n use syntax_pos::Span;\n \n-/// **What it does:** Checks for functions taking arguments by value, but not\n-/// consuming them in its\n-/// body.\n-///\n-/// **Why is this bad?** Taking arguments by reference is more flexible and can\n-/// sometimes avoid\n-/// unnecessary allocations.\n-///\n-/// **Known problems:**\n-/// * This lint suggests taking an argument by reference,\n-/// however sometimes it is better to let users decide the argument type\n-/// (by using `Borrow` trait, for example), depending on how the function is used.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo(v: Vec<i32>) {\n-///     assert_eq!(v.len(), 42);\n-/// }\n-/// // should be\n-/// fn foo(v: &[i32]) {\n-///     assert_eq!(v.len(), 42);\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for functions taking arguments by value, but not\n+    /// consuming them in its\n+    /// body.\n+    ///\n+    /// **Why is this bad?** Taking arguments by reference is more flexible and can\n+    /// sometimes avoid\n+    /// unnecessary allocations.\n+    ///\n+    /// **Known problems:**\n+    /// * This lint suggests taking an argument by reference,\n+    /// however sometimes it is better to let users decide the argument type\n+    /// (by using `Borrow` trait, for example), depending on how the function is used.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo(v: Vec<i32>) {\n+    ///     assert_eq!(v.len(), 42);\n+    /// }\n+    /// // should be\n+    /// fn foo(v: &[i32]) {\n+    ///     assert_eq!(v.len(), 42);\n+    /// }\n+    /// ```\n     pub NEEDLESS_PASS_BY_VALUE,\n     pedantic,\n     \"functions taking arguments by value, but not consuming them in its body\""}, {"sha": "2ce9bf78aa6c40248a3774afcf5bfdbc6e76ed6d", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -4,23 +4,23 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for needlessly including a base struct on update\n-/// when all fields are changed anyway.\n-///\n-/// **Why is this bad?** This will cost resources (because the base has to be\n-/// somewhere), and make the code less readable.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// Point {\n-///     x: 1,\n-///     y: 0,\n-///     ..zero_point\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for needlessly including a base struct on update\n+    /// when all fields are changed anyway.\n+    ///\n+    /// **Why is this bad?** This will cost resources (because the base has to be\n+    /// somewhere), and make the code less readable.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// Point {\n+    ///     x: 1,\n+    ///     y: 0,\n+    ///     ..zero_point\n+    /// }\n+    /// ```\n     pub NEEDLESS_UPDATE,\n     complexity,\n     \"using `Foo { ..base }` when there are no missing fields\""}, {"sha": "eb8a19f2bbb17ccc950c40715e0d6cab80a90403", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,38 +5,38 @@ use rustc::{declare_tool_lint, lint_array};\n \n use crate::utils::{self, paths, span_lint};\n \n-/// **What it does:**\n-/// Checks for the usage of negated comparison operators on types which only implement\n-/// `PartialOrd` (e.g. `f64`).\n-///\n-/// **Why is this bad?**\n-/// These operators make it easy to forget that the underlying types actually allow not only three\n-/// potential Orderings (Less, Equal, Greater) but also a fourth one (Uncomparable). This is\n-/// especially easy to miss if the operator based comparison result is negated.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// use std::cmp::Ordering;\n-///\n-/// // Bad\n-/// let a = 1.0;\n-/// let b = std::f64::NAN;\n-///\n-/// let _not_less_or_equal = !(a <= b);\n-///\n-/// // Good\n-/// let a = 1.0;\n-/// let b = std::f64::NAN;\n-///\n-/// let _not_less_or_equal = match a.partial_cmp(&b) {\n-///     None | Some(Ordering::Greater) => true,\n-///     _ => false,\n-/// };\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Checks for the usage of negated comparison operators on types which only implement\n+    /// `PartialOrd` (e.g. `f64`).\n+    ///\n+    /// **Why is this bad?**\n+    /// These operators make it easy to forget that the underlying types actually allow not only three\n+    /// potential Orderings (Less, Equal, Greater) but also a fourth one (Uncomparable). This is\n+    /// especially easy to miss if the operator based comparison result is negated.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// // Bad\n+    /// let a = 1.0;\n+    /// let b = std::f64::NAN;\n+    ///\n+    /// let _not_less_or_equal = !(a <= b);\n+    ///\n+    /// // Good\n+    /// let a = 1.0;\n+    /// let b = std::f64::NAN;\n+    ///\n+    /// let _not_less_or_equal = match a.partial_cmp(&b) {\n+    ///     None | Some(Ordering::Greater) => true,\n+    ///     _ => false,\n+    /// };\n+    /// ```\n     pub NEG_CMP_OP_ON_PARTIAL_ORD,\n     complexity,\n     \"The use of negated comparison operators on partially ordered types may produce confusing code.\""}, {"sha": "dde998a9a5c2567888f75f97b17b4f9b81039fe4", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -7,17 +7,17 @@ use syntax::source_map::{Span, Spanned};\n use crate::consts::{self, Constant};\n use crate::utils::span_lint;\n \n-/// **What it does:** Checks for multiplication by -1 as a form of negation.\n-///\n-/// **Why is this bad?** It's more readable to just negate.\n-///\n-/// **Known problems:** This only catches integers (for now).\n-///\n-/// **Example:**\n-/// ```rust\n-/// x * -1\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for multiplication by -1 as a form of negation.\n+    ///\n+    /// **Why is this bad?** It's more readable to just negate.\n+    ///\n+    /// **Known problems:** This only catches integers (for now).\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x * -1\n+    /// ```\n     pub NEG_MULTIPLY,\n     style,\n     \"multiplying integers with -1\""}, {"sha": "127438da917049b998e06ea2baef636445d61c77", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -11,74 +11,74 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for types with a `fn new() -> Self` method and no\n-/// implementation of\n-/// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html).\n-///\n-/// It detects both the case when a manual\n-/// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html)\n-/// implementation is required and also when it can be created with\n-/// `#[derive(Default)]`\n-///\n-/// **Why is this bad?** The user might expect to be able to use\n-/// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) as the\n-/// type can be constructed without arguments.\n-///\n-/// **Known problems:** Hopefully none.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// struct Foo(Bar);\n-///\n-/// impl Foo {\n-///     fn new() -> Self {\n-///         Foo(Bar::new())\n-///     }\n-/// }\n-/// ```\n-///\n-/// Instead, use:\n-///\n-/// ```rust\n-/// struct Foo(Bar);\n-///\n-/// impl Default for Foo {\n-///     fn default() -> Self {\n-///         Foo(Bar::new())\n-///     }\n-/// }\n-/// ```\n-///\n-/// Or, if\n-/// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html)\n-/// can be derived by `#[derive(Default)]`:\n-///\n-/// ```rust\n-/// struct Foo;\n-///\n-/// impl Foo {\n-///     fn new() -> Self {\n-///         Foo\n-///     }\n-/// }\n-/// ```\n-///\n-/// Instead, use:\n-///\n-/// ```rust\n-/// #[derive(Default)]\n-/// struct Foo;\n-///\n-/// impl Foo {\n-///     fn new() -> Self {\n-///         Foo\n-///     }\n-/// }\n-/// ```\n-///\n-/// You can also have `new()` call `Default::default()`.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for types with a `fn new() -> Self` method and no\n+    /// implementation of\n+    /// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html).\n+    ///\n+    /// It detects both the case when a manual\n+    /// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html)\n+    /// implementation is required and also when it can be created with\n+    /// `#[derive(Default)]`\n+    ///\n+    /// **Why is this bad?** The user might expect to be able to use\n+    /// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) as the\n+    /// type can be constructed without arguments.\n+    ///\n+    /// **Known problems:** Hopefully none.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// struct Foo(Bar);\n+    ///\n+    /// impl Foo {\n+    ///     fn new() -> Self {\n+    ///         Foo(Bar::new())\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Instead, use:\n+    ///\n+    /// ```rust\n+    /// struct Foo(Bar);\n+    ///\n+    /// impl Default for Foo {\n+    ///     fn default() -> Self {\n+    ///         Foo(Bar::new())\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Or, if\n+    /// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html)\n+    /// can be derived by `#[derive(Default)]`:\n+    ///\n+    /// ```rust\n+    /// struct Foo;\n+    ///\n+    /// impl Foo {\n+    ///     fn new() -> Self {\n+    ///         Foo\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Instead, use:\n+    ///\n+    /// ```rust\n+    /// #[derive(Default)]\n+    /// struct Foo;\n+    ///\n+    /// impl Foo {\n+    ///     fn new() -> Self {\n+    ///         Foo\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// You can also have `new()` call `Default::default()`.\n     pub NEW_WITHOUT_DEFAULT,\n     style,\n     \"`fn new() -> Self` method without `Default` implementation\""}, {"sha": "dae59bc84b9525e38fbba9f8bd8094fa754ddca3", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -6,37 +6,37 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use std::ops::Deref;\n \n-/// **What it does:** Checks for statements which have no effect.\n-///\n-/// **Why is this bad?** Similar to dead code, these statements are actually\n-/// executed. However, as they have no effect, all they do is make the code less\n-/// readable.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// 0;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for statements which have no effect.\n+    ///\n+    /// **Why is this bad?** Similar to dead code, these statements are actually\n+    /// executed. However, as they have no effect, all they do is make the code less\n+    /// readable.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// 0;\n+    /// ```\n     pub NO_EFFECT,\n     complexity,\n     \"statements with no effect\"\n }\n \n-/// **What it does:** Checks for expression statements that can be reduced to a\n-/// sub-expression.\n-///\n-/// **Why is this bad?** Expressions by themselves often have no side-effects.\n-/// Having such expressions reduces readability.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// compute_array()[0];\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for expression statements that can be reduced to a\n+    /// sub-expression.\n+    ///\n+    /// **Why is this bad?** Expressions by themselves often have no side-effects.\n+    /// Having such expressions reduces readability.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// compute_array()[0];\n+    /// ```\n     pub UNNECESSARY_OPERATION,\n     complexity,\n     \"outer expressions with no effect\""}, {"sha": "21130e36e4650b89c73c9ee95d67070fca1693ed", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -14,69 +14,69 @@ use rustc_typeck::hir_ty_to_ty;\n use std::ptr;\n use syntax_pos::{Span, DUMMY_SP};\n \n-/// **What it does:** Checks for declaration of `const` items which is interior\n-/// mutable (e.g. contains a `Cell`, `Mutex`, `AtomicXxxx` etc).\n-///\n-/// **Why is this bad?** Consts are copied everywhere they are referenced, i.e.\n-/// every time you refer to the const a fresh instance of the `Cell` or `Mutex`\n-/// or `AtomicXxxx` will be created, which defeats the whole purpose of using\n-/// these types in the first place.\n-///\n-/// The `const` should better be replaced by a `static` item if a global\n-/// variable is wanted, or replaced by a `const fn` if a constructor is wanted.\n-///\n-/// **Known problems:** A \"non-constant\" const item is a legacy way to supply an\n-/// initialized value to downstream `static` items (e.g. the\n-/// `std::sync::ONCE_INIT` constant). In this case the use of `const` is legit,\n-/// and this lint should be suppressed.\n-///\n-/// **Example:**\n-/// ```rust\n-/// use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n-///\n-/// // Bad.\n-/// const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n-/// CONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\n-/// assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n-///\n-/// // Good.\n-/// static STATIC_ATOM: AtomicUsize = AtomicUsize::new(15);\n-/// STATIC_ATOM.store(9, SeqCst);\n-/// assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for declaration of `const` items which is interior\n+    /// mutable (e.g. contains a `Cell`, `Mutex`, `AtomicXxxx` etc).\n+    ///\n+    /// **Why is this bad?** Consts are copied everywhere they are referenced, i.e.\n+    /// every time you refer to the const a fresh instance of the `Cell` or `Mutex`\n+    /// or `AtomicXxxx` will be created, which defeats the whole purpose of using\n+    /// these types in the first place.\n+    ///\n+    /// The `const` should better be replaced by a `static` item if a global\n+    /// variable is wanted, or replaced by a `const fn` if a constructor is wanted.\n+    ///\n+    /// **Known problems:** A \"non-constant\" const item is a legacy way to supply an\n+    /// initialized value to downstream `static` items (e.g. the\n+    /// `std::sync::ONCE_INIT` constant). In this case the use of `const` is legit,\n+    /// and this lint should be suppressed.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+    ///\n+    /// // Bad.\n+    /// const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n+    /// CONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\n+    /// assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n+    ///\n+    /// // Good.\n+    /// static STATIC_ATOM: AtomicUsize = AtomicUsize::new(15);\n+    /// STATIC_ATOM.store(9, SeqCst);\n+    /// assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n+    /// ```\n     pub DECLARE_INTERIOR_MUTABLE_CONST,\n     correctness,\n     \"declaring const with interior mutability\"\n }\n \n-/// **What it does:** Checks if `const` items which is interior mutable (e.g.\n-/// contains a `Cell`, `Mutex`, `AtomicXxxx` etc) has been borrowed directly.\n-///\n-/// **Why is this bad?** Consts are copied everywhere they are referenced, i.e.\n-/// every time you refer to the const a fresh instance of the `Cell` or `Mutex`\n-/// or `AtomicXxxx` will be created, which defeats the whole purpose of using\n-/// these types in the first place.\n-///\n-/// The `const` value should be stored inside a `static` item.\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n-/// const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n-///\n-/// // Bad.\n-/// CONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\n-/// assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n-///\n-/// // Good.\n-/// static STATIC_ATOM: AtomicUsize = CONST_ATOM;\n-/// STATIC_ATOM.store(9, SeqCst);\n-/// assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks if `const` items which is interior mutable (e.g.\n+    /// contains a `Cell`, `Mutex`, `AtomicXxxx` etc) has been borrowed directly.\n+    ///\n+    /// **Why is this bad?** Consts are copied everywhere they are referenced, i.e.\n+    /// every time you refer to the const a fresh instance of the `Cell` or `Mutex`\n+    /// or `AtomicXxxx` will be created, which defeats the whole purpose of using\n+    /// these types in the first place.\n+    ///\n+    /// The `const` value should be stored inside a `static` item.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+    /// const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n+    ///\n+    /// // Bad.\n+    /// CONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\n+    /// assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n+    ///\n+    /// // Good.\n+    /// static STATIC_ATOM: AtomicUsize = CONST_ATOM;\n+    /// STATIC_ATOM.store(9, SeqCst);\n+    /// assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n+    /// ```\n     pub BORROW_INTERIOR_MUTABLE_CONST,\n     correctness,\n     \"referencing const with interior mutability\""}, {"sha": "9bb3a1d3d6b17277f5fd69c0ae2e960a0970cfa7", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -7,57 +7,57 @@ use syntax::source_map::Span;\n use syntax::symbol::LocalInternedString;\n use syntax::visit::{walk_block, walk_expr, walk_pat, Visitor};\n \n-/// **What it does:** Checks for names that are very similar and thus confusing.\n-///\n-/// **Why is this bad?** It's hard to distinguish between names that differ only\n-/// by a single character.\n-///\n-/// **Known problems:** None?\n-///\n-/// **Example:**\n-/// ```rust\n-/// let checked_exp = something;\n-/// let checked_expr = something_else;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for names that are very similar and thus confusing.\n+    ///\n+    /// **Why is this bad?** It's hard to distinguish between names that differ only\n+    /// by a single character.\n+    ///\n+    /// **Known problems:** None?\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let checked_exp = something;\n+    /// let checked_expr = something_else;\n+    /// ```\n     pub SIMILAR_NAMES,\n     pedantic,\n     \"similarly named items and bindings\"\n }\n \n-/// **What it does:** Checks for too many variables whose name consists of a\n-/// single character.\n-///\n-/// **Why is this bad?** It's hard to memorize what a variable means without a\n-/// descriptive name.\n-///\n-/// **Known problems:** None?\n-///\n-/// **Example:**\n-/// ```rust\n-/// let (a, b, c, d, e, f, g) = (...);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for too many variables whose name consists of a\n+    /// single character.\n+    ///\n+    /// **Why is this bad?** It's hard to memorize what a variable means without a\n+    /// descriptive name.\n+    ///\n+    /// **Known problems:** None?\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let (a, b, c, d, e, f, g) = (...);\n+    /// ```\n     pub MANY_SINGLE_CHAR_NAMES,\n     style,\n     \"too many single character bindings\"\n }\n \n-/// **What it does:** Checks if you have variables whose name consists of just\n-/// underscores and digits.\n-///\n-/// **Why is this bad?** It's hard to memorize what a variable means without a\n-/// descriptive name.\n-///\n-/// **Known problems:** None?\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _1 = 1;\n-/// let ___1 = 1;\n-/// let __1___2 = 11;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks if you have variables whose name consists of just\n+    /// underscores and digits.\n+    ///\n+    /// **Why is this bad?** It's hard to memorize what a variable means without a\n+    /// descriptive name.\n+    ///\n+    /// **Known problems:** None?\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _1 = 1;\n+    /// let ___1 = 1;\n+    /// let __1___2 = 11;\n+    /// ```\n     pub JUST_UNDERSCORES_AND_DIGITS,\n     style,\n     \"unclear name\""}, {"sha": "b82d0372b81180a6f41025c107d35e543e3c1ced", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -4,31 +4,31 @@ use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:*** Checks for unnecessary `ok()` in if let.\n-///\n-/// **Why is this bad?** Calling `ok()` in if let is unnecessary, instead match\n-/// on `Ok(pat)`\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for result in iter {\n-///     if let Some(bench) = try!(result).parse().ok() {\n-///         vec.push(bench)\n-///     }\n-/// }\n-/// ```\n-/// Could be written:\n-///\n-/// ```rust\n-/// for result in iter {\n-///     if let Ok(bench) = try!(result).parse() {\n-///         vec.push(bench)\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:*** Checks for unnecessary `ok()` in if let.\n+    ///\n+    /// **Why is this bad?** Calling `ok()` in if let is unnecessary, instead match\n+    /// on `Ok(pat)`\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// for result in iter {\n+    ///     if let Some(bench) = try!(result).parse().ok() {\n+    ///         vec.push(bench)\n+    ///     }\n+    /// }\n+    /// ```\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// for result in iter {\n+    ///     if let Ok(bench) = try!(result).parse() {\n+    ///         vec.push(bench)\n+    ///     }\n+    /// }\n+    /// ```\n     pub IF_LET_SOME_RESULT,\n     style,\n     \"usage of `ok()` in `if let Some(pat)` statements is unnecessary, match on `Ok(pat)` instead\""}, {"sha": "65257973bead0970b45645fbd6e685f30156e5bd", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,19 +5,19 @@ use rustc::{declare_tool_lint, lint_array};\n use syntax::ast::LitKind;\n use syntax::source_map::{Span, Spanned};\n \n-/// **What it does:** Checks for duplicate open options as well as combinations\n-/// that make no sense.\n-///\n-/// **Why is this bad?** In the best case, the code will be harder to read than\n-/// necessary. I don't know the worst case.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// OpenOptions::new().read(true).truncate(true)\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for duplicate open options as well as combinations\n+    /// that make no sense.\n+    ///\n+    /// **Why is this bad?** In the best case, the code will be harder to read than\n+    /// necessary. I don't know the worst case.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// OpenOptions::new().read(true).truncate(true)\n+    /// ```\n     pub NONSENSICAL_OPEN_OPTIONS,\n     correctness,\n     \"nonsensical combination of options for opening a file\""}, {"sha": "c041f3a959a021a6d8a5f479c2b3b323e767d193", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -4,18 +4,18 @@ use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Detects classic underflow/overflow checks.\n-///\n-/// **Why is this bad?** Most classic C underflow/overflow checks will fail in\n-/// Rust. Users can use functions like `overflowing_*` and `wrapping_*` instead.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// a + b < a\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Detects classic underflow/overflow checks.\n+    ///\n+    /// **Why is this bad?** Most classic C underflow/overflow checks will fail in\n+    /// Rust. Users can use functions like `overflowing_*` and `wrapping_*` instead.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// a + b < a\n+    /// ```\n     pub OVERFLOW_CHECK_CONDITIONAL,\n     complexity,\n     \"overflow checks inspired by C which are likely to panic\""}, {"sha": "bd73f5a05724bec9b100d61316896d37aaf55902", "filename": "clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -7,36 +7,36 @@ use syntax::ast::LitKind;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n-/// **What it does:** Checks for missing parameters in `panic!`.\n-///\n-/// **Why is this bad?** Contrary to the `format!` family of macros, there are\n-/// two forms of `panic!`: if there are no parameters given, the first argument\n-/// is not a format string and used literally. So while `format!(\"{}\")` will\n-/// fail to compile, `panic!(\"{}\")` will not.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// panic!(\"This `panic!` is probably missing a parameter there: {}\");\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for missing parameters in `panic!`.\n+    ///\n+    /// **Why is this bad?** Contrary to the `format!` family of macros, there are\n+    /// two forms of `panic!`: if there are no parameters given, the first argument\n+    /// is not a format string and used literally. So while `format!(\"{}\")` will\n+    /// fail to compile, `panic!(\"{}\")` will not.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// panic!(\"This `panic!` is probably missing a parameter there: {}\");\n+    /// ```\n     pub PANIC_PARAMS,\n     style,\n     \"missing parameters in `panic!` calls\"\n }\n \n-/// **What it does:** Checks for usage of `unimplemented!`.\n-///\n-/// **Why is this bad?** This macro should not be present in production code\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// unimplemented!();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `unimplemented!`.\n+    ///\n+    /// **Why is this bad?** This macro should not be present in production code\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// unimplemented!();\n+    /// ```\n     pub UNIMPLEMENTED,\n     restriction,\n     \"`unimplemented!` should not be present in production code\""}, {"sha": "47495fde24a3d657e568c0a422222c2061cb6ff6", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -4,25 +4,25 @@ use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for manual re-implementations of `PartialEq::ne`.\n-///\n-/// **Why is this bad?** `PartialEq::ne` is required to always return the\n-/// negated result of `PartialEq::eq`, which is exactly what the default\n-/// implementation does. Therefore, there should never be any need to\n-/// re-implement it.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// struct Foo;\n-///\n-/// impl PartialEq for Foo {\n-///    fn eq(&self, other: &Foo) -> bool { ... }\n-///    fn ne(&self, other: &Foo) -> bool { !(self == other) }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for manual re-implementations of `PartialEq::ne`.\n+    ///\n+    /// **Why is this bad?** `PartialEq::ne` is required to always return the\n+    /// negated result of `PartialEq::eq`, which is exactly what the default\n+    /// implementation does. Therefore, there should never be any need to\n+    /// re-implement it.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// struct Foo;\n+    ///\n+    /// impl PartialEq for Foo {\n+    ///    fn eq(&self, other: &Foo) -> bool { ... }\n+    ///    fn ne(&self, other: &Foo) -> bool { !(self == other) }\n+    /// }\n+    /// ```\n     pub PARTIALEQ_NE_IMPL,\n     complexity,\n     \"re-implementing `PartialEq::ne`\""}, {"sha": "6819ac74474434e7b899677f38f07d2bcd113944", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,24 +5,24 @@ use rustc_errors::Applicability;\n use syntax::ast::*;\n use syntax::source_map::Spanned;\n \n-/// **What it does:** Checks for operations where precedence may be unclear\n-/// and suggests to add parentheses. Currently it catches the following:\n-/// * mixed usage of arithmetic and bit shifting/combining operators without\n-/// parentheses\n-/// * a \"negative\" numeric literal (which is really a unary `-` followed by a\n-/// numeric literal)\n-///   followed by a method call\n-///\n-/// **Why is this bad?** Not everyone knows the precedence of those operators by\n-/// heart, so expressions like these may trip others trying to reason about the\n-/// code.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// * `1 << 2 + 3` equals 32, while `(1 << 2) + 3` equals 7\n-/// * `-1i32.abs()` equals -1, while `(-1i32).abs()` equals 1\n declare_clippy_lint! {\n+    /// **What it does:** Checks for operations where precedence may be unclear\n+    /// and suggests to add parentheses. Currently it catches the following:\n+    /// * mixed usage of arithmetic and bit shifting/combining operators without\n+    /// parentheses\n+    /// * a \"negative\" numeric literal (which is really a unary `-` followed by a\n+    /// numeric literal)\n+    ///   followed by a method call\n+    ///\n+    /// **Why is this bad?** Not everyone knows the precedence of those operators by\n+    /// heart, so expressions like these may trip others trying to reason about the\n+    /// code.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// * `1 << 2 + 3` equals 32, while `(1 << 2) + 3` equals 7\n+    /// * `-1i32.abs()` equals -1, while `(-1i32).abs()` equals 1\n     pub PRECEDENCE,\n     complexity,\n     \"operations where precedence may be unclear\""}, {"sha": "68fb5b0b20f1346f711001971a569e6b98f5776e", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -13,82 +13,82 @@ use std::borrow::Cow;\n use syntax::source_map::Span;\n use syntax_pos::MultiSpan;\n \n-/// **What it does:** This lint checks for function arguments of type `&String`\n-/// or `&Vec` unless the references are mutable. It will also suggest you\n-/// replace `.clone()` calls with the appropriate `.to_owned()`/`to_string()`\n-/// calls.\n-///\n-/// **Why is this bad?** Requiring the argument to be of the specific size\n-/// makes the function less useful for no benefit; slices in the form of `&[T]`\n-/// or `&str` usually suffice and can be obtained from other types, too.\n-///\n-/// **Known problems:** The lint does not follow data. So if you have an\n-/// argument `x` and write `let y = x; y.clone()` the lint will not suggest\n-/// changing that `.clone()` to `.to_owned()`.\n-///\n-/// Other functions called from this function taking a `&String` or `&Vec`\n-/// argument may also fail to compile if you change the argument. Applying\n-/// this lint on them will fix the problem, but they may be in other crates.\n-///\n-/// Also there may be `fn(&Vec)`-typed references pointing to your function.\n-/// If you have them, you will get a compiler error after applying this lint's\n-/// suggestions. You then have the choice to undo your changes or change the\n-/// type of the reference.\n-///\n-/// Note that if the function is part of your public interface, there may be\n-/// other crates referencing it you may not be aware. Carefully deprecate the\n-/// function before applying the lint suggestions in this case.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo(&Vec<u32>) { .. }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** This lint checks for function arguments of type `&String`\n+    /// or `&Vec` unless the references are mutable. It will also suggest you\n+    /// replace `.clone()` calls with the appropriate `.to_owned()`/`to_string()`\n+    /// calls.\n+    ///\n+    /// **Why is this bad?** Requiring the argument to be of the specific size\n+    /// makes the function less useful for no benefit; slices in the form of `&[T]`\n+    /// or `&str` usually suffice and can be obtained from other types, too.\n+    ///\n+    /// **Known problems:** The lint does not follow data. So if you have an\n+    /// argument `x` and write `let y = x; y.clone()` the lint will not suggest\n+    /// changing that `.clone()` to `.to_owned()`.\n+    ///\n+    /// Other functions called from this function taking a `&String` or `&Vec`\n+    /// argument may also fail to compile if you change the argument. Applying\n+    /// this lint on them will fix the problem, but they may be in other crates.\n+    ///\n+    /// Also there may be `fn(&Vec)`-typed references pointing to your function.\n+    /// If you have them, you will get a compiler error after applying this lint's\n+    /// suggestions. You then have the choice to undo your changes or change the\n+    /// type of the reference.\n+    ///\n+    /// Note that if the function is part of your public interface, there may be\n+    /// other crates referencing it you may not be aware. Carefully deprecate the\n+    /// function before applying the lint suggestions in this case.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo(&Vec<u32>) { .. }\n+    /// ```\n     pub PTR_ARG,\n     style,\n     \"fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively\"\n }\n \n-/// **What it does:** This lint checks for equality comparisons with `ptr::null`\n-///\n-/// **Why is this bad?** It's easier and more readable to use the inherent\n-/// `.is_null()`\n-/// method instead\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if x == ptr::null {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** This lint checks for equality comparisons with `ptr::null`\n+    ///\n+    /// **Why is this bad?** It's easier and more readable to use the inherent\n+    /// `.is_null()`\n+    /// method instead\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if x == ptr::null {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub CMP_NULL,\n     style,\n     \"comparing a pointer to a null pointer, suggesting to use `.is_null()` instead.\"\n }\n \n-/// **What it does:** This lint checks for functions that take immutable\n-/// references and return\n-/// mutable ones.\n-///\n-/// **Why is this bad?** This is trivially unsound, as one can create two\n-/// mutable references\n-/// from the same (immutable!) source. This\n-/// [error](https://github.com/rust-lang/rust/issues/39465)\n-/// actually lead to an interim Rust release 1.15.1.\n-///\n-/// **Known problems:** To be on the conservative side, if there's at least one\n-/// mutable reference\n-/// with the output lifetime, this lint will not trigger. In practice, this\n-/// case is unlikely anyway.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo(&Foo) -> &mut Bar { .. }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** This lint checks for functions that take immutable\n+    /// references and return\n+    /// mutable ones.\n+    ///\n+    /// **Why is this bad?** This is trivially unsound, as one can create two\n+    /// mutable references\n+    /// from the same (immutable!) source. This\n+    /// [error](https://github.com/rust-lang/rust/issues/39465)\n+    /// actually lead to an interim Rust release 1.15.1.\n+    ///\n+    /// **Known problems:** To be on the conservative side, if there's at least one\n+    /// mutable reference\n+    /// with the output lifetime, this lint will not trigger. In practice, this\n+    /// case is unlikely anyway.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo(&Foo) -> &mut Bar { .. }\n+    /// ```\n     pub MUT_FROM_REF,\n     correctness,\n     \"fns that create mutable refs from immutable ref args\""}, {"sha": "21c7e721338292b0684a92081edf175b608f1810", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -3,37 +3,37 @@ use rustc::{declare_tool_lint, hir, lint, lint_array};\n use rustc_errors::Applicability;\n use std::fmt;\n \n-/// **What it does:** Checks for usage of the `offset` pointer method with a `usize` casted to an\n-/// `isize`.\n-///\n-/// **Why is this bad?** If we\u2019re always increasing the pointer address, we can avoid the numeric\n-/// cast by using the `add` method instead.\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// let vec = vec![b'a', b'b', b'c'];\n-/// let ptr = vec.as_ptr();\n-/// let offset = 1_usize;\n-///\n-/// unsafe {\n-///     ptr.offset(offset as isize);\n-/// }\n-/// ```\n-///\n-/// Could be written:\n-///\n-/// ```rust\n-/// let vec = vec![b'a', b'b', b'c'];\n-/// let ptr = vec.as_ptr();\n-/// let offset = 1_usize;\n-///\n-/// unsafe {\n-///     ptr.add(offset);\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of the `offset` pointer method with a `usize` casted to an\n+    /// `isize`.\n+    ///\n+    /// **Why is this bad?** If we\u2019re always increasing the pointer address, we can avoid the numeric\n+    /// cast by using the `add` method instead.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let vec = vec![b'a', b'b', b'c'];\n+    /// let ptr = vec.as_ptr();\n+    /// let offset = 1_usize;\n+    ///\n+    /// unsafe {\n+    ///     ptr.offset(offset as isize);\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// let vec = vec![b'a', b'b', b'c'];\n+    /// let ptr = vec.as_ptr();\n+    /// let offset = 1_usize;\n+    ///\n+    /// unsafe {\n+    ///     ptr.add(offset);\n+    /// }\n+    /// ```\n     pub PTR_OFFSET_WITH_CAST,\n     complexity,\n     \"unneeded pointer offset cast\""}, {"sha": "13ae2c29b55f507c94d1653f9913e832807152f2", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -10,25 +10,25 @@ use crate::utils::paths::*;\n use crate::utils::{match_def_path, match_type, span_lint_and_then, SpanlessEq};\n use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for expressions that could be replaced by the question mark operator\n-///\n-/// **Why is this bad?** Question mark usage is more idiomatic\n-///\n-/// **Known problems:** None\n-///\n-/// **Example:**\n-/// ```rust\n-/// if option.is_none() {\n-///     return None;\n-/// }\n-/// ```\n-///\n-/// Could be written:\n-///\n-/// ```rust\n-/// option?;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for expressions that could be replaced by the question mark operator\n+    ///\n+    /// **Why is this bad?** Question mark usage is more idiomatic\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if option.is_none() {\n+    ///     return None;\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// option?;\n+    /// ```\n     pub QUESTION_MARK,\n     style,\n     \"checks for expressions that could be replaced by the question mark operator\""}, {"sha": "353b1700b45adf17909cce9e36f12411b060ff83", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -9,77 +9,77 @@ use rustc_errors::Applicability;\n use syntax::ast::RangeLimits;\n use syntax::source_map::Spanned;\n \n-/// **What it does:** Checks for calling `.step_by(0)` on iterators,\n-/// which never terminates.\n-///\n-/// **Why is this bad?** This very much looks like an oversight, since with\n-/// `loop { .. }` there is an obvious better way to endlessly loop.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for x in (5..5).step_by(0) {\n-///     ..\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calling `.step_by(0)` on iterators,\n+    /// which never terminates.\n+    ///\n+    /// **Why is this bad?** This very much looks like an oversight, since with\n+    /// `loop { .. }` there is an obvious better way to endlessly loop.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// for x in (5..5).step_by(0) {\n+    ///     ..\n+    /// }\n+    /// ```\n     pub ITERATOR_STEP_BY_ZERO,\n     correctness,\n     \"using `Iterator::step_by(0)`, which produces an infinite iterator\"\n }\n \n-/// **What it does:** Checks for zipping a collection with the range of\n-/// `0.._.len()`.\n-///\n-/// **Why is this bad?** The code is better expressed with `.enumerate()`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.iter().zip(0..x.len())\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for zipping a collection with the range of\n+    /// `0.._.len()`.\n+    ///\n+    /// **Why is this bad?** The code is better expressed with `.enumerate()`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// x.iter().zip(0..x.len())\n+    /// ```\n     pub RANGE_ZIP_WITH_LEN,\n     complexity,\n     \"zipping iterator with a range when `enumerate()` would do\"\n }\n \n-/// **What it does:** Checks for exclusive ranges where 1 is added to the\n-/// upper bound, e.g. `x..(y+1)`.\n-///\n-/// **Why is this bad?** The code is more readable with an inclusive range\n-/// like `x..=y`.\n-///\n-/// **Known problems:** Will add unnecessary pair of parentheses when the\n-/// expression is not wrapped in a pair but starts with a opening parenthesis\n-/// and ends with a closing one.\n-/// I.e: `let _ = (f()+1)..(f()+1)` results in `let _ = ((f()+1)..=f())`.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for x..(y+1) { .. }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for exclusive ranges where 1 is added to the\n+    /// upper bound, e.g. `x..(y+1)`.\n+    ///\n+    /// **Why is this bad?** The code is more readable with an inclusive range\n+    /// like `x..=y`.\n+    ///\n+    /// **Known problems:** Will add unnecessary pair of parentheses when the\n+    /// expression is not wrapped in a pair but starts with a opening parenthesis\n+    /// and ends with a closing one.\n+    /// I.e: `let _ = (f()+1)..(f()+1)` results in `let _ = ((f()+1)..=f())`.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// for x..(y+1) { .. }\n+    /// ```\n     pub RANGE_PLUS_ONE,\n     complexity,\n     \"`x..(y+1)` reads better as `x..=y`\"\n }\n \n-/// **What it does:** Checks for inclusive ranges where 1 is subtracted from\n-/// the upper bound, e.g. `x..=(y-1)`.\n-///\n-/// **Why is this bad?** The code is more readable with an exclusive range\n-/// like `x..y`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// for x..=(y-1) { .. }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for inclusive ranges where 1 is subtracted from\n+    /// the upper bound, e.g. `x..=(y-1)`.\n+    ///\n+    /// **Why is this bad?** The code is more readable with an exclusive range\n+    /// like `x..y`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// for x..=(y-1) { .. }\n+    /// ```\n     pub RANGE_MINUS_ONE,\n     complexity,\n     \"`x..=(y-1)` reads better as `x..y`\""}, {"sha": "3b74de5159f7ca0ffc93fd168de5646bc76eabd2", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -27,38 +27,38 @@ macro_rules! unwrap_or_continue {\n     };\n }\n \n-/// **What it does:** Checks for a redudant `clone()` (and its relatives) which clones an owned\n-/// value that is going to be dropped without further use.\n-///\n-/// **Why is this bad?** It is not always possible for the compiler to eliminate useless\n-/// allocations and deallocations generated by redundant `clone()`s.\n-///\n-/// **Known problems:**\n-///\n-/// * Suggestions made by this lint could require NLL to be enabled.\n-/// * False-positive if there is a borrow preventing the value from moving out.\n-///\n-/// ```rust\n-/// let x = String::new();\n-///\n-/// let y = &x;\n-///\n-/// foo(x.clone()); // This lint suggests to remove this `clone()`\n-/// ```\n-///\n-/// **Example:**\n-/// ```rust\n-/// {\n-///     let x = Foo::new();\n-///     call(x.clone());\n-///     call(x.clone()); // this can just pass `x`\n-/// }\n-///\n-/// [\"lorem\", \"ipsum\"].join(\" \").to_string()\n-///\n-/// Path::new(\"/a/b\").join(\"c\").to_path_buf()\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for a redudant `clone()` (and its relatives) which clones an owned\n+    /// value that is going to be dropped without further use.\n+    ///\n+    /// **Why is this bad?** It is not always possible for the compiler to eliminate useless\n+    /// allocations and deallocations generated by redundant `clone()`s.\n+    ///\n+    /// **Known problems:**\n+    ///\n+    /// * Suggestions made by this lint could require NLL to be enabled.\n+    /// * False-positive if there is a borrow preventing the value from moving out.\n+    ///\n+    /// ```rust\n+    /// let x = String::new();\n+    ///\n+    /// let y = &x;\n+    ///\n+    /// foo(x.clone()); // This lint suggests to remove this `clone()`\n+    /// ```\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// {\n+    ///     let x = Foo::new();\n+    ///     call(x.clone());\n+    ///     call(x.clone()); // this can just pass `x`\n+    /// }\n+    ///\n+    /// [\"lorem\", \"ipsum\"].join(\" \").to_string()\n+    ///\n+    /// Path::new(\"/a/b\").join(\"c\").to_path_buf()\n+    /// ```\n     pub REDUNDANT_CLONE,\n     nursery,\n     \"`clone()` of an owned value that is going to be dropped immediately\""}, {"sha": "d05560653ef8c157bc170273d5a9e2a8e1463236", "filename": "clippy_lints/src/redundant_field_names.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_field_names.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -4,29 +4,29 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::ast::*;\n \n-/// **What it does:** Checks for fields in struct literals where shorthands\n-/// could be used.\n-///\n-/// **Why is this bad?** If the field and variable names are the same,\n-/// the field name is redundant.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let bar: u8 = 123;\n-///\n-/// struct Foo {\n-///     bar: u8,\n-/// }\n-///\n-/// let foo = Foo{ bar: bar }\n-/// ```\n-/// the last line can be simplified to\n-/// ```rust\n-/// let foo = Foo{ bar }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for fields in struct literals where shorthands\n+    /// could be used.\n+    ///\n+    /// **Why is this bad?** If the field and variable names are the same,\n+    /// the field name is redundant.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let bar: u8 = 123;\n+    ///\n+    /// struct Foo {\n+    ///     bar: u8,\n+    /// }\n+    ///\n+    /// let foo = Foo{ bar: bar }\n+    /// ```\n+    /// the last line can be simplified to\n+    /// ```rust\n+    /// let foo = Foo{ bar }\n+    /// ```\n     pub REDUNDANT_FIELD_NAMES,\n     style,\n     \"checks for fields in struct literals where shorthands could be used\""}, {"sha": "ebc5e240a954e5bfd85e5f0d87dc2b7398b76701", "filename": "clippy_lints/src/redundant_pattern_matching.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -6,37 +6,37 @@ use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n use syntax::ptr::P;\n \n-/// **What it does:** Lint for redundant pattern matching over `Result` or\n-/// `Option`\n-///\n-/// **Why is this bad?** It's more concise and clear to just use the proper\n-/// utility function\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// if let Ok(_) = Ok::<i32, i32>(42) {}\n-/// if let Err(_) = Err::<i32, i32>(42) {}\n-/// if let None = None::<()> {}\n-/// if let Some(_) = Some(42) {}\n-/// match Ok::<i32, i32>(42) {\n-///     Ok(_) => true,\n-///     Err(_) => false,\n-/// };\n-/// ```\n-///\n-/// The more idiomatic use would be:\n-///\n-/// ```rust\n-/// if Ok::<i32, i32>(42).is_ok() {}\n-/// if Err::<i32, i32>(42).is_err() {}\n-/// if None::<()>.is_none() {}\n-/// if Some(42).is_some() {}\n-/// Ok::<i32, i32>(42).is_ok();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Lint for redundant pattern matching over `Result` or\n+    /// `Option`\n+    ///\n+    /// **Why is this bad?** It's more concise and clear to just use the proper\n+    /// utility function\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// if let Ok(_) = Ok::<i32, i32>(42) {}\n+    /// if let Err(_) = Err::<i32, i32>(42) {}\n+    /// if let None = None::<()> {}\n+    /// if let Some(_) = Some(42) {}\n+    /// match Ok::<i32, i32>(42) {\n+    ///     Ok(_) => true,\n+    ///     Err(_) => false,\n+    /// };\n+    /// ```\n+    ///\n+    /// The more idiomatic use would be:\n+    ///\n+    /// ```rust\n+    /// if Ok::<i32, i32>(42).is_ok() {}\n+    /// if Err::<i32, i32>(42).is_err() {}\n+    /// if None::<()>.is_none() {}\n+    /// if Some(42).is_some() {}\n+    /// Ok::<i32, i32>(42).is_ok();\n+    /// ```\n     pub REDUNDANT_PATTERN_MATCHING,\n     style,\n     \"use the proper utility function avoiding an `if let`\""}, {"sha": "d5447027acbabed71fc4190b23c5bc2698277e4d", "filename": "clippy_lints/src/reference.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freference.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,20 +5,20 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::ast::{Expr, ExprKind, UnOp};\n \n-/// **What it does:** Checks for usage of `*&` and `*&mut` in expressions.\n-///\n-/// **Why is this bad?** Immediately dereferencing a reference is no-op and\n-/// makes the code less clear.\n-///\n-/// **Known problems:** Multiple dereference/addrof pairs are not handled so\n-/// the suggested fix for `x = **&&y` is `x = *&y`, which is still incorrect.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let a = f(*&mut b);\n-/// let c = *&d;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `*&` and `*&mut` in expressions.\n+    ///\n+    /// **Why is this bad?** Immediately dereferencing a reference is no-op and\n+    /// makes the code less clear.\n+    ///\n+    /// **Known problems:** Multiple dereference/addrof pairs are not handled so\n+    /// the suggested fix for `x = **&&y` is `x = *&y`, which is still incorrect.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let a = f(*&mut b);\n+    /// let c = *&d;\n+    /// ```\n     pub DEREF_ADDROF,\n     complexity,\n     \"use of `*&` or `*&mut` in an expression\"\n@@ -64,19 +64,19 @@ impl EarlyLintPass for Pass {\n     }\n }\n \n-/// **What it does:** Checks for references in expressions that use\n-/// auto dereference.\n-///\n-/// **Why is this bad?** The reference is a no-op and is automatically\n-/// dereferenced by the compiler and makes the code less clear.\n-///\n-/// **Example:**\n-/// ```rust\n-/// struct Point(u32, u32);\n-/// let point = Foo(30, 20);\n-/// let x = (&point).x;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for references in expressions that use\n+    /// auto dereference.\n+    ///\n+    /// **Why is this bad?** The reference is a no-op and is automatically\n+    /// dereferenced by the compiler and makes the code less clear.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// struct Point(u32, u32);\n+    /// let point = Foo(30, 20);\n+    /// let x = (&point).x;\n+    /// ```\n     pub REF_IN_DEREF,\n     complexity,\n     \"Use of reference in auto dereference expression.\""}, {"sha": "a875256870d1b3381de7b56ab1896fe6d4a9eed3", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -10,57 +10,57 @@ use std::convert::TryFrom;\n use syntax::ast::{LitKind, StrStyle};\n use syntax::source_map::{BytePos, Span};\n \n-/// **What it does:** Checks [regex](https://crates.io/crates/regex) creation\n-/// (with `Regex::new`,`RegexBuilder::new` or `RegexSet::new`) for correct\n-/// regex syntax.\n-///\n-/// **Why is this bad?** This will lead to a runtime panic.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// Regex::new(\"|\")\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks [regex](https://crates.io/crates/regex) creation\n+    /// (with `Regex::new`,`RegexBuilder::new` or `RegexSet::new`) for correct\n+    /// regex syntax.\n+    ///\n+    /// **Why is this bad?** This will lead to a runtime panic.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// Regex::new(\"|\")\n+    /// ```\n     pub INVALID_REGEX,\n     correctness,\n     \"invalid regular expressions\"\n }\n \n-/// **What it does:** Checks for trivial [regex](https://crates.io/crates/regex)\n-/// creation (with `Regex::new`, `RegexBuilder::new` or `RegexSet::new`).\n-///\n-/// **Why is this bad?** Matching the regex can likely be replaced by `==` or\n-/// `str::starts_with`, `str::ends_with` or `std::contains` or other `str`\n-/// methods.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// Regex::new(\"^foobar\")\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for trivial [regex](https://crates.io/crates/regex)\n+    /// creation (with `Regex::new`, `RegexBuilder::new` or `RegexSet::new`).\n+    ///\n+    /// **Why is this bad?** Matching the regex can likely be replaced by `==` or\n+    /// `str::starts_with`, `str::ends_with` or `std::contains` or other `str`\n+    /// methods.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// Regex::new(\"^foobar\")\n+    /// ```\n     pub TRIVIAL_REGEX,\n     style,\n     \"trivial regular expressions\"\n }\n \n-/// **What it does:** Checks for usage of `regex!(_)` which (as of now) is\n-/// usually slower than `Regex::new(_)` unless called in a loop (which is a bad\n-/// idea anyway).\n-///\n-/// **Why is this bad?** Performance, at least for now. The macro version is\n-/// likely to catch up long-term, but for now the dynamic version is faster.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// regex!(\"foo|bar\")\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `regex!(_)` which (as of now) is\n+    /// usually slower than `Regex::new(_)` unless called in a loop (which is a bad\n+    /// idea anyway).\n+    ///\n+    /// **Why is this bad?** Performance, at least for now. The macro version is\n+    /// likely to catch up long-term, but for now the dynamic version is faster.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// regex!(\"foo|bar\")\n+    /// ```\n     pub REGEX_MACRO,\n     style,\n     \"use of `regex!(_)` instead of `Regex::new(_)`\""}, {"sha": "10e339eeb023cd8cbcb0396103147bedfab8d776", "filename": "clippy_lints/src/replace_consts.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Freplace_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Freplace_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freplace_consts.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -6,24 +6,24 @@ use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for usage of `ATOMIC_X_INIT`, `ONCE_INIT`, and\n-/// `uX/iX::MIN/MAX`.\n-///\n-/// **Why is this bad?** `const fn`s exist\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// static FOO: AtomicIsize = ATOMIC_ISIZE_INIT;\n-/// ```\n-///\n-/// Could be written:\n-///\n-/// ```rust\n-/// static FOO: AtomicIsize = AtomicIsize::new(0);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `ATOMIC_X_INIT`, `ONCE_INIT`, and\n+    /// `uX/iX::MIN/MAX`.\n+    ///\n+    /// **Why is this bad?** `const fn`s exist\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// static FOO: AtomicIsize = ATOMIC_ISIZE_INIT;\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// static FOO: AtomicIsize = AtomicIsize::new(0);\n+    /// ```\n     pub REPLACE_CONSTS,\n     pedantic,\n     \"Lint usages of standard library `const`s that could be replaced by `const fn`s\""}, {"sha": "2ea4b8daf8c980bf60b2e047535ffc9d93e833d6", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -8,75 +8,75 @@ use syntax::source_map::Span;\n use syntax::visit::FnKind;\n use syntax_pos::BytePos;\n \n-/// **What it does:** Checks for return statements at the end of a block.\n-///\n-/// **Why is this bad?** Removing the `return` and semicolon will make the code\n-/// more rusty.\n-///\n-/// **Known problems:** If the computation returning the value borrows a local\n-/// variable, removing the `return` may run afoul of the borrow checker.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo(x: usize) {\n-///     return x;\n-/// }\n-/// ```\n-/// simplify to\n-/// ```rust\n-/// fn foo(x: usize) {\n-///     x\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for return statements at the end of a block.\n+    ///\n+    /// **Why is this bad?** Removing the `return` and semicolon will make the code\n+    /// more rusty.\n+    ///\n+    /// **Known problems:** If the computation returning the value borrows a local\n+    /// variable, removing the `return` may run afoul of the borrow checker.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo(x: usize) {\n+    ///     return x;\n+    /// }\n+    /// ```\n+    /// simplify to\n+    /// ```rust\n+    /// fn foo(x: usize) {\n+    ///     x\n+    /// }\n+    /// ```\n     pub NEEDLESS_RETURN,\n     style,\n     \"using a return statement like `return expr;` where an expression would suffice\"\n }\n \n-/// **What it does:** Checks for `let`-bindings, which are subsequently\n-/// returned.\n-///\n-/// **Why is this bad?** It is just extraneous code. Remove it to make your code\n-/// more rusty.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo() -> String {\n-///     let x = String::new();\n-///     x\n-/// }\n-/// ```\n-/// instead, use\n-/// ```\n-/// fn foo() -> String {\n-///     String::new()\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `let`-bindings, which are subsequently\n+    /// returned.\n+    ///\n+    /// **Why is this bad?** It is just extraneous code. Remove it to make your code\n+    /// more rusty.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo() -> String {\n+    ///     let x = String::new();\n+    ///     x\n+    /// }\n+    /// ```\n+    /// instead, use\n+    /// ```\n+    /// fn foo() -> String {\n+    ///     String::new()\n+    /// }\n+    /// ```\n     pub LET_AND_RETURN,\n     style,\n     \"creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\"\n }\n \n-/// **What it does:** Checks for unit (`()`) expressions that can be removed.\n-///\n-/// **Why is this bad?** Such expressions add no value, but can make the code\n-/// less readable. Depending on formatting they can make a `break` or `return`\n-/// statement look like a function call.\n-///\n-/// **Known problems:** The lint currently misses unit return types in types,\n-/// e.g. the `F` in `fn generic_unit<F: Fn() -> ()>(f: F) { .. }`.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn return_unit() -> () {\n-///     ()\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for unit (`()`) expressions that can be removed.\n+    ///\n+    /// **Why is this bad?** Such expressions add no value, but can make the code\n+    /// less readable. Depending on formatting they can make a `break` or `return`\n+    /// statement look like a function call.\n+    ///\n+    /// **Known problems:** The lint currently misses unit return types in types,\n+    /// e.g. the `F` in `fn generic_unit<F: Fn() -> ()>(f: F) { .. }`.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn return_unit() -> () {\n+    ///     ()\n+    /// }\n+    /// ```\n     pub UNUSED_UNIT,\n     style,\n     \"needless unit expression\""}, {"sha": "e9479af541909a31d3c24aaae1f314fba72931fd", "filename": "clippy_lints/src/serde_api.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fserde_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fserde_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde_api.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -3,16 +3,16 @@ use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for mis-uses of the serde API.\n-///\n-/// **Why is this bad?** Serde is very finnicky about how its API should be\n-/// used, but the type system can't be used to enforce it (yet?).\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:** Implementing `Visitor::visit_string` but not\n-/// `Visitor::visit_str`.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for mis-uses of the serde API.\n+    ///\n+    /// **Why is this bad?** Serde is very finnicky about how its API should be\n+    /// used, but the type system can't be used to enforce it (yet?).\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:** Implementing `Visitor::visit_string` but not\n+    /// `Visitor::visit_str`.\n     pub SERDE_API_MISUSE,\n     correctness,\n     \"various things that will negatively affect your serde experience\""}, {"sha": "9572dc7acb5aac6a43096f3d9cdf780226849e46", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -7,69 +7,69 @@ use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for bindings that shadow other bindings already in\n-/// scope, while just changing reference level or mutability.\n-///\n-/// **Why is this bad?** Not much, in fact it's a very common pattern in Rust\n-/// code. Still, some may opt to avoid it in their code base, they can set this\n-/// lint to `Warn`.\n-///\n-/// **Known problems:** This lint, as the other shadowing related lints,\n-/// currently only catches very simple patterns.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = &x;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for bindings that shadow other bindings already in\n+    /// scope, while just changing reference level or mutability.\n+    ///\n+    /// **Why is this bad?** Not much, in fact it's a very common pattern in Rust\n+    /// code. Still, some may opt to avoid it in their code base, they can set this\n+    /// lint to `Warn`.\n+    ///\n+    /// **Known problems:** This lint, as the other shadowing related lints,\n+    /// currently only catches very simple patterns.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = &x;\n+    /// ```\n     pub SHADOW_SAME,\n     restriction,\n     \"rebinding a name to itself, e.g. `let mut x = &mut x`\"\n }\n \n-/// **What it does:** Checks for bindings that shadow other bindings already in\n-/// scope, while reusing the original value.\n-///\n-/// **Why is this bad?** Not too much, in fact it's a common pattern in Rust\n-/// code. Still, some argue that name shadowing like this hurts readability,\n-/// because a value may be bound to different things depending on position in\n-/// the code.\n-///\n-/// **Known problems:** This lint, as the other shadowing related lints,\n-/// currently only catches very simple patterns.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = x + 1;\n-/// ```\n-/// use different variable name:\n-/// ```rust\n-/// let y = x + 1;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for bindings that shadow other bindings already in\n+    /// scope, while reusing the original value.\n+    ///\n+    /// **Why is this bad?** Not too much, in fact it's a common pattern in Rust\n+    /// code. Still, some argue that name shadowing like this hurts readability,\n+    /// because a value may be bound to different things depending on position in\n+    /// the code.\n+    ///\n+    /// **Known problems:** This lint, as the other shadowing related lints,\n+    /// currently only catches very simple patterns.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = x + 1;\n+    /// ```\n+    /// use different variable name:\n+    /// ```rust\n+    /// let y = x + 1;\n+    /// ```\n     pub SHADOW_REUSE,\n     restriction,\n     \"rebinding a name to an expression that re-uses the original value, e.g. `let x = x + 1`\"\n }\n \n-/// **What it does:** Checks for bindings that shadow other bindings already in\n-/// scope, either without a initialization or with one that does not even use\n-/// the original value.\n-///\n-/// **Why is this bad?** Name shadowing can hurt readability, especially in\n-/// large code bases, because it is easy to lose track of the active binding at\n-/// any place in the code. This can be alleviated by either giving more specific\n-/// names to bindings or introducing more scopes to contain the bindings.\n-///\n-/// **Known problems:** This lint, as the other shadowing related lints,\n-/// currently only catches very simple patterns.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = y;\n-/// let x = z; // shadows the earlier binding\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for bindings that shadow other bindings already in\n+    /// scope, either without a initialization or with one that does not even use\n+    /// the original value.\n+    ///\n+    /// **Why is this bad?** Name shadowing can hurt readability, especially in\n+    /// large code bases, because it is easy to lose track of the active binding at\n+    /// any place in the code. This can be alleviated by either giving more specific\n+    /// names to bindings or introducing more scopes to contain the bindings.\n+    ///\n+    /// **Known problems:** This lint, as the other shadowing related lints,\n+    /// currently only catches very simple patterns.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = y;\n+    /// let x = z; // shadows the earlier binding\n+    /// ```\n     pub SHADOW_UNRELATED,\n     pedantic,\n     \"rebinding a name without even using the original value\""}, {"sha": "7b4fd7732129618c78a03ff28cbfd961003d8f6f", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -9,22 +9,22 @@ use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n use syntax_pos::symbol::Symbol;\n \n-/// **What it does:** Checks slow zero-filled vector initialization\n-///\n-/// **Why is this bad?** These structures are non-idiomatic and less efficient than simply using\n-/// `vec![0; len]`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let mut vec1 = Vec::with_capacity(len);\n-/// vec1.resize(len, 0);\n-///\n-/// let mut vec2 = Vec::with_capacity(len);\n-/// vec2.extend(repeat(0).take(len))\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks slow zero-filled vector initialization\n+    ///\n+    /// **Why is this bad?** These structures are non-idiomatic and less efficient than simply using\n+    /// `vec![0; len]`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut vec1 = Vec::with_capacity(len);\n+    /// vec1.resize(len, 0);\n+    ///\n+    /// let mut vec2 = Vec::with_capacity(len);\n+    /// vec2.extend(repeat(0).take(len))\n+    /// ```\n     pub SLOW_VECTOR_INITIALIZATION,\n     perf,\n     \"slow vector initialization\""}, {"sha": "0f6603f9d280ebcf3b862e89b1f8bfe0fb35e6c8", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -6,67 +6,67 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::source_map::Spanned;\n \n-/// **What it does:** Checks for string appends of the form `x = x + y` (without\n-/// `let`!).\n-///\n-/// **Why is this bad?** It's not really bad, but some people think that the\n-/// `.push_str(_)` method is more readable.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// let mut x = \"Hello\".to_owned();\n-/// x = x + \", World\";\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for string appends of the form `x = x + y` (without\n+    /// `let`!).\n+    ///\n+    /// **Why is this bad?** It's not really bad, but some people think that the\n+    /// `.push_str(_)` method is more readable.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let mut x = \"Hello\".to_owned();\n+    /// x = x + \", World\";\n+    /// ```\n     pub STRING_ADD_ASSIGN,\n     pedantic,\n     \"using `x = x + ..` where x is a `String` instead of `push_str()`\"\n }\n \n-/// **What it does:** Checks for all instances of `x + _` where `x` is of type\n-/// `String`, but only if [`string_add_assign`](#string_add_assign) does *not*\n-/// match.\n-///\n-/// **Why is this bad?** It's not bad in and of itself. However, this particular\n-/// `Add` implementation is asymmetric (the other operand need not be `String`,\n-/// but `x` does), while addition as mathematically defined is symmetric, also\n-/// the `String::push_str(_)` function is a perfectly good replacement.\n-/// Therefore some dislike it and wish not to have it in their code.\n-///\n-/// That said, other people think that string addition, having a long tradition\n-/// in other languages is actually fine, which is why we decided to make this\n-/// particular lint `allow` by default.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// let x = \"Hello\".to_owned();\n-/// x + \", World\"\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for all instances of `x + _` where `x` is of type\n+    /// `String`, but only if [`string_add_assign`](#string_add_assign) does *not*\n+    /// match.\n+    ///\n+    /// **Why is this bad?** It's not bad in and of itself. However, this particular\n+    /// `Add` implementation is asymmetric (the other operand need not be `String`,\n+    /// but `x` does), while addition as mathematically defined is symmetric, also\n+    /// the `String::push_str(_)` function is a perfectly good replacement.\n+    /// Therefore some dislike it and wish not to have it in their code.\n+    ///\n+    /// That said, other people think that string addition, having a long tradition\n+    /// in other languages is actually fine, which is why we decided to make this\n+    /// particular lint `allow` by default.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let x = \"Hello\".to_owned();\n+    /// x + \", World\"\n+    /// ```\n     pub STRING_ADD,\n     restriction,\n     \"using `x + ..` where x is a `String` instead of `push_str()`\"\n }\n \n-/// **What it does:** Checks for the `as_bytes` method called on string literals\n-/// that contain only ASCII characters.\n-///\n-/// **Why is this bad?** Byte string literals (e.g. `b\"foo\"`) can be used\n-/// instead. They are shorter but less discoverable than `as_bytes()`.\n-///\n-/// **Known Problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let bs = \"a byte string\".as_bytes();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for the `as_bytes` method called on string literals\n+    /// that contain only ASCII characters.\n+    ///\n+    /// **Why is this bad?** Byte string literals (e.g. `b\"foo\"`) can be used\n+    /// instead. They are shorter but less discoverable than `as_bytes()`.\n+    ///\n+    /// **Known Problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let bs = \"a byte string\".as_bytes();\n+    /// ```\n     pub STRING_LIT_AS_BYTES,\n     style,\n     \"calling `as_bytes` on a string literal instead of using a byte string literal\""}, {"sha": "cb7fc0fee80fc86500771e95de391e9b90bfb63d", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,45 +5,45 @@ use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Lints for suspicious operations in impls of arithmetic operators, e.g.\n-/// subtracting elements in an Add impl.\n-///\n-/// **Why this is bad?** This is probably a typo or copy-and-paste error and not intended.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// impl Add for Foo {\n-///     type Output = Foo;\n-///\n-///     fn add(self, other: Foo) -> Foo {\n-///         Foo(self.0 - other.0)\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Lints for suspicious operations in impls of arithmetic operators, e.g.\n+    /// subtracting elements in an Add impl.\n+    ///\n+    /// **Why this is bad?** This is probably a typo or copy-and-paste error and not intended.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// impl Add for Foo {\n+    ///     type Output = Foo;\n+    ///\n+    ///     fn add(self, other: Foo) -> Foo {\n+    ///         Foo(self.0 - other.0)\n+    ///     }\n+    /// }\n+    /// ```\n     pub SUSPICIOUS_ARITHMETIC_IMPL,\n     correctness,\n     \"suspicious use of operators in impl of arithmetic trait\"\n }\n \n-/// **What it does:** Lints for suspicious operations in impls of OpAssign, e.g.\n-/// subtracting elements in an AddAssign impl.\n-///\n-/// **Why this is bad?** This is probably a typo or copy-and-paste error and not intended.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// impl AddAssign for Foo {\n-///     fn add_assign(&mut self, other: Foo) {\n-///         *self = *self - other;\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Lints for suspicious operations in impls of OpAssign, e.g.\n+    /// subtracting elements in an AddAssign impl.\n+    ///\n+    /// **Why this is bad?** This is probably a typo or copy-and-paste error and not intended.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// impl AddAssign for Foo {\n+    ///     fn add_assign(&mut self, other: Foo) {\n+    ///         *self = *self - other;\n+    ///     }\n+    /// }\n+    /// ```\n     pub SUSPICIOUS_OP_ASSIGN_IMPL,\n     correctness,\n     \"suspicious use of operators in impl of OpAssign trait\""}, {"sha": "c7003cfb9f032c6fd0152de3ada29dcaf81ee110", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -10,41 +10,41 @@ use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n-/// **What it does:** Checks for manual swapping.\n-///\n-/// **Why is this bad?** The `std::mem::swap` function exposes the intent better\n-/// without deinitializing or copying either variable.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// let t = b;\n-/// b = a;\n-/// a = t;\n-/// ```\n-/// Use std::mem::swap():\n-/// ```rust\n-/// std::mem::swap(&mut a, &mut b);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for manual swapping.\n+    ///\n+    /// **Why is this bad?** The `std::mem::swap` function exposes the intent better\n+    /// without deinitializing or copying either variable.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// let t = b;\n+    /// b = a;\n+    /// a = t;\n+    /// ```\n+    /// Use std::mem::swap():\n+    /// ```rust\n+    /// std::mem::swap(&mut a, &mut b);\n+    /// ```\n     pub MANUAL_SWAP,\n     complexity,\n     \"manual swap of two variables\"\n }\n \n-/// **What it does:** Checks for `foo = bar; bar = foo` sequences.\n-///\n-/// **Why is this bad?** This looks like a failed attempt to swap.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// a = b;\n-/// b = a;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `foo = bar; bar = foo` sequences.\n+    ///\n+    /// **Why is this bad?** This looks like a failed attempt to swap.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// a = b;\n+    /// b = a;\n+    /// ```\n     pub ALMOST_SWAPPED,\n     correctness,\n     \"`foo = bar; bar = foo` sequence\""}, {"sha": "a6126f37282872afc0af76a808751e49131dda80", "filename": "clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,19 +5,19 @@ use rustc::hir::{Expr, ExprKind};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for construction of a structure or tuple just to\n-/// assign a value in it.\n-///\n-/// **Why is this bad?** Readability. If the structure is only created to be\n-/// updated, why not write the structure you want in the first place?\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// (0, 0).0 = 1\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for construction of a structure or tuple just to\n+    /// assign a value in it.\n+    ///\n+    /// **Why is this bad?** Readability. If the structure is only created to be\n+    /// updated, why not write the structure you want in the first place?\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// (0, 0).0 = 1\n+    /// ```\n     pub TEMPORARY_ASSIGNMENT,\n     complexity,\n     \"assignments to temporaries\""}, {"sha": "aa4f808ee3f1ef59408dde68abf22966b53d952b", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 141, "deletions": 141, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -9,196 +9,196 @@ use rustc_errors::Applicability;\n use std::borrow::Cow;\n use syntax::ast;\n \n-/// **What it does:** Checks for transmutes that can't ever be correct on any\n-/// architecture.\n-///\n-/// **Why is this bad?** It's basically guaranteed to be undefined behaviour.\n-///\n-/// **Known problems:** When accessing C, users might want to store pointer\n-/// sized objects in `extradata` arguments to save an allocation.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let ptr: *const T = core::intrinsics::transmute('x')\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes that can't ever be correct on any\n+    /// architecture.\n+    ///\n+    /// **Why is this bad?** It's basically guaranteed to be undefined behaviour.\n+    ///\n+    /// **Known problems:** When accessing C, users might want to store pointer\n+    /// sized objects in `extradata` arguments to save an allocation.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let ptr: *const T = core::intrinsics::transmute('x')\n+    /// ```\n     pub WRONG_TRANSMUTE,\n     correctness,\n     \"transmutes that are confusing at best, undefined behaviour at worst and always useless\"\n }\n \n-/// **What it does:** Checks for transmutes to the original type of the object\n-/// and transmutes that could be a cast.\n-///\n-/// **Why is this bad?** Readability. The code tricks people into thinking that\n-/// something complex is going on.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// core::intrinsics::transmute(t) // where the result type is the same as `t`'s\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes to the original type of the object\n+    /// and transmutes that could be a cast.\n+    ///\n+    /// **Why is this bad?** Readability. The code tricks people into thinking that\n+    /// something complex is going on.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// core::intrinsics::transmute(t) // where the result type is the same as `t`'s\n+    /// ```\n     pub USELESS_TRANSMUTE,\n     complexity,\n     \"transmutes that have the same to and from types or could be a cast/coercion\"\n }\n \n-/// **What it does:** Checks for transmutes between a type `T` and `*T`.\n-///\n-/// **Why is this bad?** It's easy to mistakenly transmute between a type and a\n-/// pointer to that type.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// core::intrinsics::transmute(t) // where the result type is the same as\n-///                                // `*t` or `&t`'s\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes between a type `T` and `*T`.\n+    ///\n+    /// **Why is this bad?** It's easy to mistakenly transmute between a type and a\n+    /// pointer to that type.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// core::intrinsics::transmute(t) // where the result type is the same as\n+    ///                                // `*t` or `&t`'s\n+    /// ```\n     pub CROSSPOINTER_TRANSMUTE,\n     complexity,\n     \"transmutes that have to or from types that are a pointer to the other\"\n }\n \n-/// **What it does:** Checks for transmutes from a pointer to a reference.\n-///\n-/// **Why is this bad?** This can always be rewritten with `&` and `*`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _: &T = std::mem::transmute(p); // where p: *const T\n-///\n-/// // can be written:\n-/// let _: &T = &*p;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from a pointer to a reference.\n+    ///\n+    /// **Why is this bad?** This can always be rewritten with `&` and `*`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _: &T = std::mem::transmute(p); // where p: *const T\n+    ///\n+    /// // can be written:\n+    /// let _: &T = &*p;\n+    /// ```\n     pub TRANSMUTE_PTR_TO_REF,\n     complexity,\n     \"transmutes from a pointer to a reference type\"\n }\n \n-/// **What it does:** Checks for transmutes from an integer to a `char`.\n-///\n-/// **Why is this bad?** Not every integer is a Unicode scalar value.\n-///\n-/// **Known problems:**\n-/// - [`from_u32`] which this lint suggests using is slower than `transmute`\n-/// as it needs to validate the input.\n-/// If you are certain that the input is always a valid Unicode scalar value,\n-/// use [`from_u32_unchecked`] which is as fast as `transmute`\n-/// but has a semantically meaningful name.\n-/// - You might want to handle `None` returned from [`from_u32`] instead of calling `unwrap`.\n-///\n-/// [`from_u32`]: https://doc.rust-lang.org/std/char/fn.from_u32.html\n-/// [`from_u32_unchecked`]: https://doc.rust-lang.org/std/char/fn.from_u32_unchecked.html\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _: char = std::mem::transmute(x); // where x: u32\n-///\n-/// // should be:\n-/// let _ = std::char::from_u32(x).unwrap();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from an integer to a `char`.\n+    ///\n+    /// **Why is this bad?** Not every integer is a Unicode scalar value.\n+    ///\n+    /// **Known problems:**\n+    /// - [`from_u32`] which this lint suggests using is slower than `transmute`\n+    /// as it needs to validate the input.\n+    /// If you are certain that the input is always a valid Unicode scalar value,\n+    /// use [`from_u32_unchecked`] which is as fast as `transmute`\n+    /// but has a semantically meaningful name.\n+    /// - You might want to handle `None` returned from [`from_u32`] instead of calling `unwrap`.\n+    ///\n+    /// [`from_u32`]: https://doc.rust-lang.org/std/char/fn.from_u32.html\n+    /// [`from_u32_unchecked`]: https://doc.rust-lang.org/std/char/fn.from_u32_unchecked.html\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _: char = std::mem::transmute(x); // where x: u32\n+    ///\n+    /// // should be:\n+    /// let _ = std::char::from_u32(x).unwrap();\n+    /// ```\n     pub TRANSMUTE_INT_TO_CHAR,\n     complexity,\n     \"transmutes from an integer to a `char`\"\n }\n \n-/// **What it does:** Checks for transmutes from a `&[u8]` to a `&str`.\n-///\n-/// **Why is this bad?** Not every byte slice is a valid UTF-8 string.\n-///\n-/// **Known problems:**\n-/// - [`from_utf8`] which this lint suggests using is slower than `transmute`\n-/// as it needs to validate the input.\n-/// If you are certain that the input is always a valid UTF-8,\n-/// use [`from_utf8_unchecked`] which is as fast as `transmute`\n-/// but has a semantically meaningful name.\n-/// - You might want to handle errors returned from [`from_utf8`] instead of calling `unwrap`.\n-///\n-/// [`from_utf8`]: https://doc.rust-lang.org/std/str/fn.from_utf8.html\n-/// [`from_utf8_unchecked`]: https://doc.rust-lang.org/std/str/fn.from_utf8_unchecked.html\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _: &str = std::mem::transmute(b); // where b: &[u8]\n-///\n-/// // should be:\n-/// let _ = std::str::from_utf8(b).unwrap();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from a `&[u8]` to a `&str`.\n+    ///\n+    /// **Why is this bad?** Not every byte slice is a valid UTF-8 string.\n+    ///\n+    /// **Known problems:**\n+    /// - [`from_utf8`] which this lint suggests using is slower than `transmute`\n+    /// as it needs to validate the input.\n+    /// If you are certain that the input is always a valid UTF-8,\n+    /// use [`from_utf8_unchecked`] which is as fast as `transmute`\n+    /// but has a semantically meaningful name.\n+    /// - You might want to handle errors returned from [`from_utf8`] instead of calling `unwrap`.\n+    ///\n+    /// [`from_utf8`]: https://doc.rust-lang.org/std/str/fn.from_utf8.html\n+    /// [`from_utf8_unchecked`]: https://doc.rust-lang.org/std/str/fn.from_utf8_unchecked.html\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _: &str = std::mem::transmute(b); // where b: &[u8]\n+    ///\n+    /// // should be:\n+    /// let _ = std::str::from_utf8(b).unwrap();\n+    /// ```\n     pub TRANSMUTE_BYTES_TO_STR,\n     complexity,\n     \"transmutes from a `&[u8]` to a `&str`\"\n }\n \n-/// **What it does:** Checks for transmutes from an integer to a `bool`.\n-///\n-/// **Why is this bad?** This might result in an invalid in-memory representation of a `bool`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _: bool = std::mem::transmute(x); // where x: u8\n-///\n-/// // should be:\n-/// let _: bool = x != 0;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from an integer to a `bool`.\n+    ///\n+    /// **Why is this bad?** This might result in an invalid in-memory representation of a `bool`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _: bool = std::mem::transmute(x); // where x: u8\n+    ///\n+    /// // should be:\n+    /// let _: bool = x != 0;\n+    /// ```\n     pub TRANSMUTE_INT_TO_BOOL,\n     complexity,\n     \"transmutes from an integer to a `bool`\"\n }\n \n-/// **What it does:** Checks for transmutes from an integer to a float.\n-///\n-/// **Why is this bad?** Transmutes are dangerous and error-prone, whereas `from_bits` is intuitive\n-/// and safe.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _: f32 = std::mem::transmute(x); // where x: u32\n-///\n-/// // should be:\n-/// let _: f32 = f32::from_bits(x);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from an integer to a float.\n+    ///\n+    /// **Why is this bad?** Transmutes are dangerous and error-prone, whereas `from_bits` is intuitive\n+    /// and safe.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _: f32 = std::mem::transmute(x); // where x: u32\n+    ///\n+    /// // should be:\n+    /// let _: f32 = f32::from_bits(x);\n+    /// ```\n     pub TRANSMUTE_INT_TO_FLOAT,\n     complexity,\n     \"transmutes from an integer to a float\"\n }\n \n-/// **What it does:** Checks for transmutes from a pointer to a pointer, or\n-/// from a reference to a reference.\n-///\n-/// **Why is this bad?** Transmutes are dangerous, and these can instead be\n-/// written as casts.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let ptr = &1u32 as *const u32;\n-/// unsafe {\n-///     // pointer-to-pointer transmute\n-///     let _: *const f32 = std::mem::transmute(ptr);\n-///     // ref-ref transmute\n-///     let _: &f32 = std::mem::transmute(&1u32);\n-/// }\n-/// // These can be respectively written:\n-/// let _ = ptr as *const f32\n-/// let _ = unsafe{ &*(&1u32 as *const u32 as *const f32) };\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from a pointer to a pointer, or\n+    /// from a reference to a reference.\n+    ///\n+    /// **Why is this bad?** Transmutes are dangerous, and these can instead be\n+    /// written as casts.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let ptr = &1u32 as *const u32;\n+    /// unsafe {\n+    ///     // pointer-to-pointer transmute\n+    ///     let _: *const f32 = std::mem::transmute(ptr);\n+    ///     // ref-ref transmute\n+    ///     let _: &f32 = std::mem::transmute(&1u32);\n+    /// }\n+    /// // These can be respectively written:\n+    /// let _ = ptr as *const f32\n+    /// let _ = unsafe{ &*(&1u32 as *const u32 as *const f32) };\n+    /// ```\n     pub TRANSMUTE_PTR_TO_PTR,\n     complexity,\n     \"transmutes from a pointer to a pointer / a reference to a reference\""}, {"sha": "d246a7911662299494c8b3c152f5e604cd7b5557", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -15,39 +15,39 @@ use rustc_target::abi::LayoutOf;\n use rustc_target::spec::abi::Abi;\n use syntax_pos::Span;\n \n-/// **What it does:** Checks for functions taking arguments by reference, where\n-/// the argument type is `Copy` and small enough to be more efficient to always\n-/// pass by value.\n-///\n-/// **Why is this bad?** In many calling conventions instances of structs will\n-/// be passed through registers if they fit into two or less general purpose\n-/// registers.\n-///\n-/// **Known problems:** This lint is target register size dependent, it is\n-/// limited to 32-bit to try and reduce portability problems between 32 and\n-/// 64-bit, but if you are compiling for 8 or 16-bit targets then the limit\n-/// will be different.\n-///\n-/// The configuration option `trivial_copy_size_limit` can be set to override\n-/// this limit for a project.\n-///\n-/// This lint attempts to allow passing arguments by reference if a reference\n-/// to that argument is returned. This is implemented by comparing the lifetime\n-/// of the argument and return value for equality. However, this can cause\n-/// false positives in cases involving multiple lifetimes that are bounded by\n-/// each other.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo(v: &u32) {\n-///     assert_eq!(v, 42);\n-/// }\n-/// // should be\n-/// fn foo(v: u32) {\n-///     assert_eq!(v, 42);\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for functions taking arguments by reference, where\n+    /// the argument type is `Copy` and small enough to be more efficient to always\n+    /// pass by value.\n+    ///\n+    /// **Why is this bad?** In many calling conventions instances of structs will\n+    /// be passed through registers if they fit into two or less general purpose\n+    /// registers.\n+    ///\n+    /// **Known problems:** This lint is target register size dependent, it is\n+    /// limited to 32-bit to try and reduce portability problems between 32 and\n+    /// 64-bit, but if you are compiling for 8 or 16-bit targets then the limit\n+    /// will be different.\n+    ///\n+    /// The configuration option `trivial_copy_size_limit` can be set to override\n+    /// this limit for a project.\n+    ///\n+    /// This lint attempts to allow passing arguments by reference if a reference\n+    /// to that argument is returned. This is implemented by comparing the lifetime\n+    /// of the argument and return value for equality. However, this can cause\n+    /// false positives in cases involving multiple lifetimes that are bounded by\n+    /// each other.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo(v: &u32) {\n+    ///     assert_eq!(v, 42);\n+    /// }\n+    /// // should be\n+    /// fn foo(v: u32) {\n+    ///     assert_eq!(v, 42);\n+    /// }\n+    /// ```\n     pub TRIVIALLY_COPY_PASS_BY_REF,\n     perf,\n     \"functions taking small copyable arguments by reference\""}, {"sha": "3b057081c73c74d95ed662edb30950caf51a8980", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 432, "deletions": 432, "changes": 864, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -29,135 +29,135 @@ use syntax::source_map::Span;\n /// Handles all the linting of funky types\n pub struct TypePass;\n \n-/// **What it does:** Checks for use of `Box<Vec<_>>` anywhere in the code.\n-///\n-/// **Why is this bad?** `Vec` already keeps its contents in a separate area on\n-/// the heap. So if you `Box` it, you just add another level of indirection\n-/// without any benefit whatsoever.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// struct X {\n-///     values: Box<Vec<Foo>>,\n-/// }\n-/// ```\n-///\n-/// Better:\n-///\n-/// ```rust\n-/// struct X {\n-///     values: Vec<Foo>,\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for use of `Box<Vec<_>>` anywhere in the code.\n+    ///\n+    /// **Why is this bad?** `Vec` already keeps its contents in a separate area on\n+    /// the heap. So if you `Box` it, you just add another level of indirection\n+    /// without any benefit whatsoever.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// struct X {\n+    ///     values: Box<Vec<Foo>>,\n+    /// }\n+    /// ```\n+    ///\n+    /// Better:\n+    ///\n+    /// ```rust\n+    /// struct X {\n+    ///     values: Vec<Foo>,\n+    /// }\n+    /// ```\n     pub BOX_VEC,\n     perf,\n     \"usage of `Box<Vec<T>>`, vector elements are already on the heap\"\n }\n \n-/// **What it does:** Checks for use of `Vec<Box<T>>` where T: Sized anywhere in the code.\n-///\n-/// **Why is this bad?** `Vec` already keeps its contents in a separate area on\n-/// the heap. So if you `Box` its contents, you just add another level of indirection.\n-///\n-/// **Known problems:** Vec<Box<T: Sized>> makes sense if T is a large type (see #3530,\n-/// 1st comment).\n-///\n-/// **Example:**\n-/// ```rust\n-/// struct X {\n-///     values: Vec<Box<i32>>,\n-/// }\n-/// ```\n-///\n-/// Better:\n-///\n-/// ```rust\n-/// struct X {\n-///     values: Vec<i32>,\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for use of `Vec<Box<T>>` where T: Sized anywhere in the code.\n+    ///\n+    /// **Why is this bad?** `Vec` already keeps its contents in a separate area on\n+    /// the heap. So if you `Box` its contents, you just add another level of indirection.\n+    ///\n+    /// **Known problems:** Vec<Box<T: Sized>> makes sense if T is a large type (see #3530,\n+    /// 1st comment).\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// struct X {\n+    ///     values: Vec<Box<i32>>,\n+    /// }\n+    /// ```\n+    ///\n+    /// Better:\n+    ///\n+    /// ```rust\n+    /// struct X {\n+    ///     values: Vec<i32>,\n+    /// }\n+    /// ```\n     pub VEC_BOX,\n     complexity,\n     \"usage of `Vec<Box<T>>` where T: Sized, vector elements are already on the heap\"\n }\n \n-/// **What it does:** Checks for use of `Option<Option<_>>` in function signatures and type\n-/// definitions\n-///\n-/// **Why is this bad?** `Option<_>` represents an optional value. `Option<Option<_>>`\n-/// represents an optional optional value which is logically the same thing as an optional\n-/// value but has an unneeded extra level of wrapping.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example**\n-/// ```rust\n-/// fn x() -> Option<Option<u32>> {\n-///     None\n-/// }\n declare_clippy_lint! {\n+    /// **What it does:** Checks for use of `Option<Option<_>>` in function signatures and type\n+    /// definitions\n+    ///\n+    /// **Why is this bad?** `Option<_>` represents an optional value. `Option<Option<_>>`\n+    /// represents an optional optional value which is logically the same thing as an optional\n+    /// value but has an unneeded extra level of wrapping.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example**\n+    /// ```rust\n+    /// fn x() -> Option<Option<u32>> {\n+    ///     None\n+    /// }\n     pub OPTION_OPTION,\n     complexity,\n     \"usage of `Option<Option<T>>`\"\n }\n \n-/// **What it does:** Checks for usage of any `LinkedList`, suggesting to use a\n-/// `Vec` or a `VecDeque` (formerly called `RingBuf`).\n-///\n-/// **Why is this bad?** Gankro says:\n-///\n-/// > The TL;DR of `LinkedList` is that it's built on a massive amount of\n-/// pointers and indirection.\n-/// > It wastes memory, it has terrible cache locality, and is all-around slow.\n-/// `RingBuf`, while\n-/// > \"only\" amortized for push/pop, should be faster in the general case for\n-/// almost every possible\n-/// > workload, and isn't even amortized at all if you can predict the capacity\n-/// you need.\n-/// >\n-/// > `LinkedList`s are only really good if you're doing a lot of merging or\n-/// splitting of lists.\n-/// > This is because they can just mangle some pointers instead of actually\n-/// copying the data. Even\n-/// > if you're doing a lot of insertion in the middle of the list, `RingBuf`\n-/// can still be better\n-/// > because of how expensive it is to seek to the middle of a `LinkedList`.\n-///\n-/// **Known problems:** False positives \u2013 the instances where using a\n-/// `LinkedList` makes sense are few and far between, but they can still happen.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = LinkedList::new();\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of any `LinkedList`, suggesting to use a\n+    /// `Vec` or a `VecDeque` (formerly called `RingBuf`).\n+    ///\n+    /// **Why is this bad?** Gankro says:\n+    ///\n+    /// > The TL;DR of `LinkedList` is that it's built on a massive amount of\n+    /// pointers and indirection.\n+    /// > It wastes memory, it has terrible cache locality, and is all-around slow.\n+    /// `RingBuf`, while\n+    /// > \"only\" amortized for push/pop, should be faster in the general case for\n+    /// almost every possible\n+    /// > workload, and isn't even amortized at all if you can predict the capacity\n+    /// you need.\n+    /// >\n+    /// > `LinkedList`s are only really good if you're doing a lot of merging or\n+    /// splitting of lists.\n+    /// > This is because they can just mangle some pointers instead of actually\n+    /// copying the data. Even\n+    /// > if you're doing a lot of insertion in the middle of the list, `RingBuf`\n+    /// can still be better\n+    /// > because of how expensive it is to seek to the middle of a `LinkedList`.\n+    ///\n+    /// **Known problems:** False positives \u2013 the instances where using a\n+    /// `LinkedList` makes sense are few and far between, but they can still happen.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = LinkedList::new();\n+    /// ```\n     pub LINKEDLIST,\n     pedantic,\n     \"usage of LinkedList, usually a vector is faster, or a more specialized data structure like a VecDeque\"\n }\n \n-/// **What it does:** Checks for use of `&Box<T>` anywhere in the code.\n-///\n-/// **Why is this bad?** Any `&Box<T>` can also be a `&T`, which is more\n-/// general.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn foo(bar: &Box<T>) { ... }\n-/// ```\n-///\n-/// Better:\n-///\n-/// ```rust\n-/// fn foo(bar: &T) { ... }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for use of `&Box<T>` anywhere in the code.\n+    ///\n+    /// **Why is this bad?** Any `&Box<T>` can also be a `&T`, which is more\n+    /// general.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo(bar: &Box<T>) { ... }\n+    /// ```\n+    ///\n+    /// Better:\n+    ///\n+    /// ```rust\n+    /// fn foo(bar: &T) { ... }\n+    /// ```\n     pub BORROWED_BOX,\n     complexity,\n     \"a borrow of a boxed type\"\n@@ -446,20 +446,20 @@ fn is_any_trait(t: &hir::Ty) -> bool {\n \n pub struct LetPass;\n \n-/// **What it does:** Checks for binding a unit value.\n-///\n-/// **Why is this bad?** A unit value cannot usefully be used anywhere. So\n-/// binding one is kind of pointless.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = {\n-///     1;\n-/// };\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for binding a unit value.\n+    ///\n+    /// **Why is this bad?** A unit value cannot usefully be used anywhere. So\n+    /// binding one is kind of pointless.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = {\n+    ///     1;\n+    /// };\n+    /// ```\n     pub LET_UNIT_VALUE,\n     style,\n     \"creating a let binding to a value of unit type, which usually can't be used afterwards\"\n@@ -499,33 +499,33 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetPass {\n     }\n }\n \n-/// **What it does:** Checks for comparisons to unit.\n-///\n-/// **Why is this bad?** Unit is always equal to itself, and thus is just a\n-/// clumsily written constant. Mostly this happens when someone accidentally\n-/// adds semicolons at the end of the operands.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if {\n-///     foo();\n-/// } == {\n-///     bar();\n-/// } {\n-///     baz();\n-/// }\n-/// ```\n-/// is equal to\n-/// ```rust\n-/// {\n-///     foo();\n-///     bar();\n-///     baz();\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for comparisons to unit.\n+    ///\n+    /// **Why is this bad?** Unit is always equal to itself, and thus is just a\n+    /// clumsily written constant. Mostly this happens when someone accidentally\n+    /// adds semicolons at the end of the operands.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if {\n+    ///     foo();\n+    /// } == {\n+    ///     bar();\n+    /// } {\n+    ///     baz();\n+    /// }\n+    /// ```\n+    /// is equal to\n+    /// ```rust\n+    /// {\n+    ///     foo();\n+    ///     bar();\n+    ///     baz();\n+    /// }\n+    /// ```\n     pub UNIT_CMP,\n     correctness,\n     \"comparing unit values\"\n@@ -570,21 +570,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n     }\n }\n \n-/// **What it does:** Checks for passing a unit value as an argument to a function without using a\n-/// unit literal (`()`).\n-///\n-/// **Why is this bad?** This is likely the result of an accidental semicolon.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// foo({\n-///     let a = bar();\n-///     baz(a);\n-/// })\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for passing a unit value as an argument to a function without using a\n+    /// unit literal (`()`).\n+    ///\n+    /// **Why is this bad?** This is likely the result of an accidental semicolon.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// foo({\n+    ///     let a = bar();\n+    ///     baz(a);\n+    /// })\n+    /// ```\n     pub UNIT_ARG,\n     complexity,\n     \"passing unit to a function\"\n@@ -677,216 +677,216 @@ fn is_unit_literal(expr: &Expr) -> bool {\n \n pub struct CastPass;\n \n-/// **What it does:** Checks for casts from any numerical to a float type where\n-/// the receiving type cannot store all values from the original type without\n-/// rounding errors. This possible rounding is to be expected, so this lint is\n-/// `Allow` by default.\n-///\n-/// Basically, this warns on casting any integer with 32 or more bits to `f32`\n-/// or any 64-bit integer to `f64`.\n-///\n-/// **Why is this bad?** It's not bad at all. But in some applications it can be\n-/// helpful to know where precision loss can take place. This lint can help find\n-/// those places in the code.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = u64::MAX;\n-/// x as f64\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for casts from any numerical to a float type where\n+    /// the receiving type cannot store all values from the original type without\n+    /// rounding errors. This possible rounding is to be expected, so this lint is\n+    /// `Allow` by default.\n+    ///\n+    /// Basically, this warns on casting any integer with 32 or more bits to `f32`\n+    /// or any 64-bit integer to `f64`.\n+    ///\n+    /// **Why is this bad?** It's not bad at all. But in some applications it can be\n+    /// helpful to know where precision loss can take place. This lint can help find\n+    /// those places in the code.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = u64::MAX;\n+    /// x as f64\n+    /// ```\n     pub CAST_PRECISION_LOSS,\n     pedantic,\n     \"casts that cause loss of precision, e.g. `x as f32` where `x: u64`\"\n }\n \n-/// **What it does:** Checks for casts from a signed to an unsigned numerical\n-/// type. In this case, negative values wrap around to large positive values,\n-/// which can be quite surprising in practice. However, as the cast works as\n-/// defined, this lint is `Allow` by default.\n-///\n-/// **Why is this bad?** Possibly surprising results. You can activate this lint\n-/// as a one-time check to see where numerical wrapping can arise.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let y: i8 = -1;\n-/// y as u128 // will return 18446744073709551615\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for casts from a signed to an unsigned numerical\n+    /// type. In this case, negative values wrap around to large positive values,\n+    /// which can be quite surprising in practice. However, as the cast works as\n+    /// defined, this lint is `Allow` by default.\n+    ///\n+    /// **Why is this bad?** Possibly surprising results. You can activate this lint\n+    /// as a one-time check to see where numerical wrapping can arise.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let y: i8 = -1;\n+    /// y as u128 // will return 18446744073709551615\n+    /// ```\n     pub CAST_SIGN_LOSS,\n     pedantic,\n     \"casts from signed types to unsigned types, e.g. `x as u32` where `x: i32`\"\n }\n \n-/// **What it does:** Checks for on casts between numerical types that may\n-/// truncate large values. This is expected behavior, so the cast is `Allow` by\n-/// default.\n-///\n-/// **Why is this bad?** In some problem domains, it is good practice to avoid\n-/// truncation. This lint can be activated to help assess where additional\n-/// checks could be beneficial.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn as_u8(x: u64) -> u8 {\n-///     x as u8\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for on casts between numerical types that may\n+    /// truncate large values. This is expected behavior, so the cast is `Allow` by\n+    /// default.\n+    ///\n+    /// **Why is this bad?** In some problem domains, it is good practice to avoid\n+    /// truncation. This lint can be activated to help assess where additional\n+    /// checks could be beneficial.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn as_u8(x: u64) -> u8 {\n+    ///     x as u8\n+    /// }\n+    /// ```\n     pub CAST_POSSIBLE_TRUNCATION,\n     pedantic,\n     \"casts that may cause truncation of the value, e.g. `x as u8` where `x: u32`, or `x as i32` where `x: f32`\"\n }\n \n-/// **What it does:** Checks for casts from an unsigned type to a signed type of\n-/// the same size. Performing such a cast is a 'no-op' for the compiler,\n-/// i.e. nothing is changed at the bit level, and the binary representation of\n-/// the value is reinterpreted. This can cause wrapping if the value is too big\n-/// for the target signed type. However, the cast works as defined, so this lint\n-/// is `Allow` by default.\n-///\n-/// **Why is this bad?** While such a cast is not bad in itself, the results can\n-/// be surprising when this is not the intended behavior, as demonstrated by the\n-/// example below.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// u32::MAX as i32 // will yield a value of `-1`\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for casts from an unsigned type to a signed type of\n+    /// the same size. Performing such a cast is a 'no-op' for the compiler,\n+    /// i.e. nothing is changed at the bit level, and the binary representation of\n+    /// the value is reinterpreted. This can cause wrapping if the value is too big\n+    /// for the target signed type. However, the cast works as defined, so this lint\n+    /// is `Allow` by default.\n+    ///\n+    /// **Why is this bad?** While such a cast is not bad in itself, the results can\n+    /// be surprising when this is not the intended behavior, as demonstrated by the\n+    /// example below.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// u32::MAX as i32 // will yield a value of `-1`\n+    /// ```\n     pub CAST_POSSIBLE_WRAP,\n     pedantic,\n     \"casts that may cause wrapping around the value, e.g. `x as i32` where `x: u32` and `x > i32::MAX`\"\n }\n \n-/// **What it does:** Checks for on casts between numerical types that may\n-/// be replaced by safe conversion functions.\n-///\n-/// **Why is this bad?** Rust's `as` keyword will perform many kinds of\n-/// conversions, including silently lossy conversions. Conversion functions such\n-/// as `i32::from` will only perform lossless conversions. Using the conversion\n-/// functions prevents conversions from turning into silent lossy conversions if\n-/// the types of the input expressions ever change, and make it easier for\n-/// people reading the code to know that the conversion is lossless.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn as_u64(x: u8) -> u64 {\n-///     x as u64\n-/// }\n-/// ```\n-///\n-/// Using `::from` would look like this:\n-///\n-/// ```rust\n-/// fn as_u64(x: u8) -> u64 {\n-///     u64::from(x)\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for on casts between numerical types that may\n+    /// be replaced by safe conversion functions.\n+    ///\n+    /// **Why is this bad?** Rust's `as` keyword will perform many kinds of\n+    /// conversions, including silently lossy conversions. Conversion functions such\n+    /// as `i32::from` will only perform lossless conversions. Using the conversion\n+    /// functions prevents conversions from turning into silent lossy conversions if\n+    /// the types of the input expressions ever change, and make it easier for\n+    /// people reading the code to know that the conversion is lossless.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn as_u64(x: u8) -> u64 {\n+    ///     x as u64\n+    /// }\n+    /// ```\n+    ///\n+    /// Using `::from` would look like this:\n+    ///\n+    /// ```rust\n+    /// fn as_u64(x: u8) -> u64 {\n+    ///     u64::from(x)\n+    /// }\n+    /// ```\n     pub CAST_LOSSLESS,\n     complexity,\n     \"casts using `as` that are known to be lossless, e.g. `x as u64` where `x: u8`\"\n }\n \n-/// **What it does:** Checks for casts to the same type.\n-///\n-/// **Why is this bad?** It's just unnecessary.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _ = 2i32 as i32\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for casts to the same type.\n+    ///\n+    /// **Why is this bad?** It's just unnecessary.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _ = 2i32 as i32\n+    /// ```\n     pub UNNECESSARY_CAST,\n     complexity,\n     \"cast to the same type, e.g. `x as i32` where `x: i32`\"\n }\n \n-/// **What it does:** Checks for casts from a less-strictly-aligned pointer to a\n-/// more-strictly-aligned pointer\n-///\n-/// **Why is this bad?** Dereferencing the resulting pointer may be undefined\n-/// behavior.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _ = (&1u8 as *const u8) as *const u16;\n-/// let _ = (&mut 1u8 as *mut u8) as *mut u16;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for casts from a less-strictly-aligned pointer to a\n+    /// more-strictly-aligned pointer\n+    ///\n+    /// **Why is this bad?** Dereferencing the resulting pointer may be undefined\n+    /// behavior.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _ = (&1u8 as *const u8) as *const u16;\n+    /// let _ = (&mut 1u8 as *mut u8) as *mut u16;\n+    /// ```\n     pub CAST_PTR_ALIGNMENT,\n     correctness,\n     \"cast from a pointer to a more-strictly-aligned pointer\"\n }\n \n-/// **What it does:** Checks for casts of function pointers to something other than usize\n-///\n-/// **Why is this bad?**\n-/// Casting a function pointer to anything other than usize/isize is not portable across\n-/// architectures, because you end up losing bits if the target type is too small or end up with a\n-/// bunch of extra bits that waste space and add more instructions to the final binary than\n-/// strictly necessary for the problem\n-///\n-/// Casting to isize also doesn't make sense since there are no signed addresses.\n-///\n-/// **Example**\n-///\n-/// ```rust\n-/// // Bad\n-/// fn fun() -> i32 {}\n-/// let a = fun as i64;\n-///\n-/// // Good\n-/// fn fun2() -> i32 {}\n-/// let a = fun2 as usize;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for casts of function pointers to something other than usize\n+    ///\n+    /// **Why is this bad?**\n+    /// Casting a function pointer to anything other than usize/isize is not portable across\n+    /// architectures, because you end up losing bits if the target type is too small or end up with a\n+    /// bunch of extra bits that waste space and add more instructions to the final binary than\n+    /// strictly necessary for the problem\n+    ///\n+    /// Casting to isize also doesn't make sense since there are no signed addresses.\n+    ///\n+    /// **Example**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// fn fun() -> i32 {}\n+    /// let a = fun as i64;\n+    ///\n+    /// // Good\n+    /// fn fun2() -> i32 {}\n+    /// let a = fun2 as usize;\n+    /// ```\n     pub FN_TO_NUMERIC_CAST,\n     style,\n     \"casting a function pointer to a numeric type other than usize\"\n }\n \n-/// **What it does:** Checks for casts of a function pointer to a numeric type not wide enough to\n-/// store address.\n-///\n-/// **Why is this bad?**\n-/// Such a cast discards some bits of the function's address. If this is intended, it would be more\n-/// clearly expressed by casting to usize first, then casting the usize to the intended type (with\n-/// a comment) to perform the truncation.\n-///\n-/// **Example**\n-///\n-/// ```rust\n-/// // Bad\n-/// fn fn1() -> i16 {\n-///     1\n-/// };\n-/// let _ = fn1 as i32;\n-///\n-/// // Better: Cast to usize first, then comment with the reason for the truncation\n-/// fn fn2() -> i16 {\n-///     1\n-/// };\n-/// let fn_ptr = fn2 as usize;\n-/// let fn_ptr_truncated = fn_ptr as i32;\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for casts of a function pointer to a numeric type not wide enough to\n+    /// store address.\n+    ///\n+    /// **Why is this bad?**\n+    /// Such a cast discards some bits of the function's address. If this is intended, it would be more\n+    /// clearly expressed by casting to usize first, then casting the usize to the intended type (with\n+    /// a comment) to perform the truncation.\n+    ///\n+    /// **Example**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// fn fn1() -> i16 {\n+    ///     1\n+    /// };\n+    /// let _ = fn1 as i32;\n+    ///\n+    /// // Better: Cast to usize first, then comment with the reason for the truncation\n+    /// fn fn2() -> i16 {\n+    ///     1\n+    /// };\n+    /// let fn_ptr = fn2 as usize;\n+    /// let fn_ptr_truncated = fn_ptr as i32;\n+    /// ```\n     pub FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n     style,\n     \"casting a function pointer to a numeric type not wide enough to store the address\"\n@@ -1287,21 +1287,21 @@ fn lint_fn_to_numeric_cast(\n     }\n }\n \n-/// **What it does:** Checks for types used in structs, parameters and `let`\n-/// declarations above a certain complexity threshold.\n-///\n-/// **Why is this bad?** Too complex types make the code less readable. Consider\n-/// using a `type` definition to simplify them.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// struct Foo {\n-///     inner: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>,\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for types used in structs, parameters and `let`\n+    /// declarations above a certain complexity threshold.\n+    ///\n+    /// **Why is this bad?** Too complex types make the code less readable. Consider\n+    /// using a `type` definition to simplify them.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// struct Foo {\n+    ///     inner: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>,\n+    /// }\n+    /// ```\n     pub TYPE_COMPLEXITY,\n     complexity,\n     \"usage of very complex types that might be better factored into `type` definitions\"\n@@ -1456,28 +1456,28 @@ impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n     }\n }\n \n-/// **What it does:** Checks for expressions where a character literal is cast\n-/// to `u8` and suggests using a byte literal instead.\n-///\n-/// **Why is this bad?** In general, casting values to smaller types is\n-/// error-prone and should be avoided where possible. In the particular case of\n-/// converting a character literal to u8, it is easy to avoid by just using a\n-/// byte literal instead. As an added bonus, `b'a'` is even slightly shorter\n-/// than `'a' as u8`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// 'x' as u8\n-/// ```\n-///\n-/// A better version, using the byte literal:\n-///\n-/// ```rust\n-/// b'x'\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for expressions where a character literal is cast\n+    /// to `u8` and suggests using a byte literal instead.\n+    ///\n+    /// **Why is this bad?** In general, casting values to smaller types is\n+    /// error-prone and should be avoided where possible. In the particular case of\n+    /// converting a character literal to u8, it is easy to avoid by just using a\n+    /// byte literal instead. As an added bonus, `b'a'` is even slightly shorter\n+    /// than `'a' as u8`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// 'x' as u8\n+    /// ```\n+    ///\n+    /// A better version, using the byte literal:\n+    ///\n+    /// ```rust\n+    /// b'x'\n+    /// ```\n     pub CHAR_LIT_AS_U8,\n     complexity,\n     \"casting a character literal to u8\"\n@@ -1518,28 +1518,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CharLitAsU8 {\n     }\n }\n \n-/// **What it does:** Checks for comparisons where one side of the relation is\n-/// either the minimum or maximum value for its type and warns if it involves a\n-/// case that is always true or always false. Only integer and boolean types are\n-/// checked.\n-///\n-/// **Why is this bad?** An expression like `min <= x` may misleadingly imply\n-/// that is is possible for `x` to be less than the minimum. Expressions like\n-/// `max < x` are probably mistakes.\n-///\n-/// **Known problems:** For `usize` the size of the current compile target will\n-/// be assumed (e.g. 64 bits on 64 bit systems). This means code that uses such\n-/// a comparison to detect target pointer width will trigger this lint. One can\n-/// use `mem::sizeof` and compare its value or conditional compilation\n-/// attributes\n-/// like `#[cfg(target_pointer_width = \"64\")] ..` instead.\n-///\n-/// **Example:**\n-/// ```rust\n-/// vec.len() <= 0\n-/// 100 > std::i32::MAX\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for comparisons where one side of the relation is\n+    /// either the minimum or maximum value for its type and warns if it involves a\n+    /// case that is always true or always false. Only integer and boolean types are\n+    /// checked.\n+    ///\n+    /// **Why is this bad?** An expression like `min <= x` may misleadingly imply\n+    /// that is is possible for `x` to be less than the minimum. Expressions like\n+    /// `max < x` are probably mistakes.\n+    ///\n+    /// **Known problems:** For `usize` the size of the current compile target will\n+    /// be assumed (e.g. 64 bits on 64 bit systems). This means code that uses such\n+    /// a comparison to detect target pointer width will trigger this lint. One can\n+    /// use `mem::sizeof` and compare its value or conditional compilation\n+    /// attributes\n+    /// like `#[cfg(target_pointer_width = \"64\")] ..` instead.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// vec.len() <= 0\n+    /// 100 > std::i32::MAX\n+    /// ```\n     pub ABSURD_EXTREME_COMPARISONS,\n     correctness,\n     \"a comparison with a maximum or minimum value that is always true or false\"\n@@ -1703,22 +1703,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AbsurdExtremeComparisons {\n     }\n }\n \n-/// **What it does:** Checks for comparisons where the relation is always either\n-/// true or false, but where one side has been upcast so that the comparison is\n-/// necessary. Only integer types are checked.\n-///\n-/// **Why is this bad?** An expression like `let x : u8 = ...; (x as u32) > 300`\n-/// will mistakenly imply that it is possible for `x` to be outside the range of\n-/// `u8`.\n-///\n-/// **Known problems:**\n-/// https://github.com/rust-lang/rust-clippy/issues/886\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x : u8 = ...; (x as u32) > 300\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for comparisons where the relation is always either\n+    /// true or false, but where one side has been upcast so that the comparison is\n+    /// necessary. Only integer types are checked.\n+    ///\n+    /// **Why is this bad?** An expression like `let x : u8 = ...; (x as u32) > 300`\n+    /// will mistakenly imply that it is possible for `x` to be outside the range of\n+    /// `u8`.\n+    ///\n+    /// **Known problems:**\n+    /// https://github.com/rust-lang/rust-clippy/issues/886\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x : u8 = ...; (x as u32) > 300\n+    /// ```\n     pub INVALID_UPCAST_COMPARISONS,\n     pedantic,\n     \"a comparison involving an upcast which is always true or false\"\n@@ -1948,24 +1948,24 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidUpcastComparisons {\n     }\n }\n \n-/// **What it does:** Checks for public `impl` or `fn` missing generalization\n-/// over different hashers and implicitly defaulting to the default hashing\n-/// algorithm (SipHash).\n-///\n-/// **Why is this bad?** `HashMap` or `HashSet` with custom hashers cannot be\n-/// used with them.\n-///\n-/// **Known problems:** Suggestions for replacing constructors can contain\n-/// false-positives. Also applying suggestions can require modification of other\n-/// pieces of code, possibly including external crates.\n-///\n-/// **Example:**\n-/// ```rust\n-/// impl<K: Hash + Eq, V> Serialize for HashMap<K, V> { ... }\n-///\n-/// pub foo(map: &mut HashMap<i32, i32>) { .. }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for public `impl` or `fn` missing generalization\n+    /// over different hashers and implicitly defaulting to the default hashing\n+    /// algorithm (SipHash).\n+    ///\n+    /// **Why is this bad?** `HashMap` or `HashSet` with custom hashers cannot be\n+    /// used with them.\n+    ///\n+    /// **Known problems:** Suggestions for replacing constructors can contain\n+    /// false-positives. Also applying suggestions can require modification of other\n+    /// pieces of code, possibly including external crates.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// impl<K: Hash + Eq, V> Serialize for HashMap<K, V> { ... }\n+    ///\n+    /// pub foo(map: &mut HashMap<i32, i32>) { .. }\n+    /// ```\n     pub IMPLICIT_HASHER,\n     style,\n     \"missing generalization over different hashers\"\n@@ -2292,33 +2292,33 @@ impl<'a, 'b, 'tcx: 'a + 'b> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'\n     }\n }\n \n-/// **What it does:** Checks for casts of `&T` to `&mut T` anywhere in the code.\n-///\n-/// **Why is this bad?** It\u2019s basically guaranteed to be undefined behaviour.\n-/// `UnsafeCell` is the only way to obtain aliasable data that is considered\n-/// mutable.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// fn x(r: &i32) {\n-///     unsafe {\n-///         *(r as *const _ as *mut _) += 1;\n-///     }\n-/// }\n-/// ```\n-///\n-/// Instead consider using interior mutability types.\n-///\n-/// ```rust\n-/// fn x(r: &UnsafeCell<i32>) {\n-///     unsafe {\n-///         *r.get() += 1;\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for casts of `&T` to `&mut T` anywhere in the code.\n+    ///\n+    /// **Why is this bad?** It\u2019s basically guaranteed to be undefined behaviour.\n+    /// `UnsafeCell` is the only way to obtain aliasable data that is considered\n+    /// mutable.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn x(r: &i32) {\n+    ///     unsafe {\n+    ///         *(r as *const _ as *mut _) += 1;\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Instead consider using interior mutability types.\n+    ///\n+    /// ```rust\n+    /// fn x(r: &UnsafeCell<i32>) {\n+    ///     unsafe {\n+    ///         *r.get() += 1;\n+    ///     }\n+    /// }\n+    /// ```\n     pub CAST_REF_TO_MUT,\n     correctness,\n     \"a cast of reference to a mutable pointer\""}, {"sha": "4d9e2f18650ea3ca5dc9a8276cbe4a8b5d9b4101", "filename": "clippy_lints/src/unicode.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funicode.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -6,53 +6,53 @@ use syntax::ast::LitKind;\n use syntax::source_map::Span;\n use unicode_normalization::UnicodeNormalization;\n \n-/// **What it does:** Checks for the Unicode zero-width space in the code.\n-///\n-/// **Why is this bad?** Having an invisible character in the code makes for all\n-/// sorts of April fools, but otherwise is very much frowned upon.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:** You don't see it, but there may be a zero-width space\n-/// somewhere in this text.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for the Unicode zero-width space in the code.\n+    ///\n+    /// **Why is this bad?** Having an invisible character in the code makes for all\n+    /// sorts of April fools, but otherwise is very much frowned upon.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:** You don't see it, but there may be a zero-width space\n+    /// somewhere in this text.\n     pub ZERO_WIDTH_SPACE,\n     correctness,\n     \"using a zero-width space in a string literal, which is confusing\"\n }\n \n-/// **What it does:** Checks for non-ASCII characters in string literals.\n-///\n-/// **Why is this bad?** Yeah, we know, the 90's called and wanted their charset\n-/// back. Even so, there still are editors and other programs out there that\n-/// don't work well with Unicode. So if the code is meant to be used\n-/// internationally, on multiple operating systems, or has other portability\n-/// requirements, activating this lint could be useful.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let x = \"H\u00e4?\"\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for non-ASCII characters in string literals.\n+    ///\n+    /// **Why is this bad?** Yeah, we know, the 90's called and wanted their charset\n+    /// back. Even so, there still are editors and other programs out there that\n+    /// don't work well with Unicode. So if the code is meant to be used\n+    /// internationally, on multiple operating systems, or has other portability\n+    /// requirements, activating this lint could be useful.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = \"H\u00e4?\"\n+    /// ```\n     pub NON_ASCII_LITERAL,\n     pedantic,\n     \"using any literal non-ASCII chars in a string literal instead of using the `\\\\u` escape\"\n }\n \n-/// **What it does:** Checks for string literals that contain Unicode in a form\n-/// that is not equal to its\n-/// [NFC-recomposition](http://www.unicode.org/reports/tr15/#Norm_Forms).\n-///\n-/// **Why is this bad?** If such a string is compared to another, the results\n-/// may be surprising.\n-///\n-/// **Known problems** None.\n-///\n-/// **Example:** You may not see it, but \u201ca\u0300\u201d and \u201c\u00e0\u201d aren't the same string. The\n-/// former when escaped is actually `\"a\\u{300}\"` while the latter is `\"\\u{e0}\"`.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for string literals that contain Unicode in a form\n+    /// that is not equal to its\n+    /// [NFC-recomposition](http://www.unicode.org/reports/tr15/#Norm_Forms).\n+    ///\n+    /// **Why is this bad?** If such a string is compared to another, the results\n+    /// may be surprising.\n+    ///\n+    /// **Known problems** None.\n+    ///\n+    /// **Example:** You may not see it, but \u201ca\u0300\u201d and \u201c\u00e0\u201d aren't the same string. The\n+    /// former when escaped is actually `\"a\\u{300}\"` while the latter is `\"\\u{e0}\"`.\n     pub UNICODE_NOT_NFC,\n     pedantic,\n     \"using a unicode literal not in NFC normal form (see [unicode tr15](http://www.unicode.org/reports/tr15/) for further information)\""}, {"sha": "68ceaaac8a31432416cb38c6540494c13357221b", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,22 +5,22 @@ use syntax::ast::*;\n use syntax::source_map::Span;\n use syntax::symbol::LocalInternedString;\n \n-/// **What it does:** Checks for imports that remove \"unsafe\" from an item's\n-/// name.\n-///\n-/// **Why is this bad?** Renaming makes it less clear which traits and\n-/// structures are unsafe.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// use std::cell::{UnsafeCell as TotallySafeCell};\n-///\n-/// extern crate crossbeam;\n-/// use crossbeam::{spawn_unsafe as spawn};\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for imports that remove \"unsafe\" from an item's\n+    /// name.\n+    ///\n+    /// **Why is this bad?** Renaming makes it less clear which traits and\n+    /// structures are unsafe.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// use std::cell::{UnsafeCell as TotallySafeCell};\n+    ///\n+    /// extern crate crossbeam;\n+    /// use crossbeam::{spawn_unsafe as spawn};\n+    /// ```\n     pub UNSAFE_REMOVED_FROM_NAME,\n     style,\n     \"`unsafe` removed from API names on import\""}, {"sha": "89f6873565a5d94283fe2f7a34e8ba1570a8fe52", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -3,28 +3,28 @@ use rustc::hir;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for unused written/read amount.\n-///\n-/// **Why is this bad?** `io::Write::write` and `io::Read::read` are not\n-/// guaranteed to\n-/// process the entire buffer. They return how many bytes were processed, which\n-/// might be smaller\n-/// than a given buffer's length. If you don't need to deal with\n-/// partial-write/read, use\n-/// `write_all`/`read_exact` instead.\n-///\n-/// **Known problems:** Detects only common patterns.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// use std::io;\n-/// fn foo<W: io::Write>(w: &mut W) -> io::Result<()> {\n-///     // must be `w.write_all(b\"foo\")?;`\n-///     w.write(b\"foo\")?;\n-///     Ok(())\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for unused written/read amount.\n+    ///\n+    /// **Why is this bad?** `io::Write::write` and `io::Read::read` are not\n+    /// guaranteed to\n+    /// process the entire buffer. They return how many bytes were processed, which\n+    /// might be smaller\n+    /// than a given buffer's length. If you don't need to deal with\n+    /// partial-write/read, use\n+    /// `write_all`/`read_exact` instead.\n+    ///\n+    /// **Known problems:** Detects only common patterns.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// use std::io;\n+    /// fn foo<W: io::Write>(w: &mut W) -> io::Result<()> {\n+    ///     // must be `w.write_all(b\"foo\")?;`\n+    ///     w.write(b\"foo\")?;\n+    ///     Ok(())\n+    /// }\n+    /// ```\n     pub UNUSED_IO_AMOUNT,\n     correctness,\n     \"unused written/read amount\""}, {"sha": "d92511d999fb392b9171a11f36e3fefc8f8f9a3b", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -7,21 +7,21 @@ use rustc_data_structures::fx::FxHashMap;\n use syntax::source_map::Span;\n use syntax::symbol::LocalInternedString;\n \n-/// **What it does:** Checks for unused labels.\n-///\n-/// **Why is this bad?** Maybe the label should be used in which case there is\n-/// an error in the code or it should be removed.\n-///\n-/// **Known problems:** Hopefully none.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// fn unused_label() {\n-///     'label: for i in 1..2 {\n-///         if i > 4 { continue }\n-///     }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for unused labels.\n+    ///\n+    /// **Why is this bad?** Maybe the label should be used in which case there is\n+    /// an error in the code or it should be removed.\n+    ///\n+    /// **Known problems:** Hopefully none.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// fn unused_label() {\n+    ///     'label: for i in 1..2 {\n+    ///         if i > 4 { continue }\n+    ///     }\n+    /// ```\n     pub UNUSED_LABEL,\n     complexity,\n     \"unused labels\""}, {"sha": "6b77e0f16faa0981a99bb3312c8693179451cbef", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -7,48 +7,48 @@ use rustc::hir::intravisit::*;\n use rustc::hir::*;\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for calls of `unwrap[_err]()` that cannot fail.\n-///\n-/// **Why is this bad?** Using `if let` or `match` is more idiomatic.\n-///\n-/// **Known problems:** Limitations of the borrow checker might make unwrap() necessary sometimes?\n-///\n-/// **Example:**\n-/// ```rust\n-/// if option.is_some() {\n-///     do_something_with(option.unwrap())\n-/// }\n-/// ```\n-///\n-/// Could be written:\n-///\n-/// ```rust\n-/// if let Some(value) = option {\n-///     do_something_with(value)\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calls of `unwrap[_err]()` that cannot fail.\n+    ///\n+    /// **Why is this bad?** Using `if let` or `match` is more idiomatic.\n+    ///\n+    /// **Known problems:** Limitations of the borrow checker might make unwrap() necessary sometimes?\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if option.is_some() {\n+    ///     do_something_with(option.unwrap())\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// if let Some(value) = option {\n+    ///     do_something_with(value)\n+    /// }\n+    /// ```\n     pub UNNECESSARY_UNWRAP,\n     nursery,\n     \"checks for calls of unwrap[_err]() that cannot fail\"\n }\n \n-/// **What it does:** Checks for calls of `unwrap[_err]()` that will always fail.\n-///\n-/// **Why is this bad?** If panicking is desired, an explicit `panic!()` should be used.\n-///\n-/// **Known problems:** This lint only checks `if` conditions not assignments.\n-/// So something like `let x: Option<()> = None; x.unwrap();` will not be recognized.\n-///\n-/// **Example:**\n-/// ```rust\n-/// if option.is_none() {\n-///     do_something_with(option.unwrap())\n-/// }\n-/// ```\n-///\n-/// This code will always panic. The if condition should probably be inverted.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calls of `unwrap[_err]()` that will always fail.\n+    ///\n+    /// **Why is this bad?** If panicking is desired, an explicit `panic!()` should be used.\n+    ///\n+    /// **Known problems:** This lint only checks `if` conditions not assignments.\n+    /// So something like `let x: Option<()> = None; x.unwrap();` will not be recognized.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// if option.is_none() {\n+    ///     do_something_with(option.unwrap())\n+    /// }\n+    /// ```\n+    ///\n+    /// This code will always panic. The if condition should probably be inverted.\n     pub PANICKING_UNWRAP,\n     nursery,\n     \"checks for calls of unwrap[_err]() that will always fail\""}, {"sha": "5144e8076abb9aee4b94ba6ca84071f262d9ca82", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -9,36 +9,36 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax_pos::symbol::keywords::SelfUpper;\n \n-/// **What it does:** Checks for unnecessary repetition of structure name when a\n-/// replacement with `Self` is applicable.\n-///\n-/// **Why is this bad?** Unnecessary repetition. Mixed use of `Self` and struct\n-/// name\n-/// feels inconsistent.\n-///\n-/// **Known problems:**\n-/// - False positive when using associated types (#2843)\n-/// - False positives in some situations when using generics (#3410)\n-///\n-/// **Example:**\n-/// ```rust\n-/// struct Foo {}\n-/// impl Foo {\n-///     fn new() -> Foo {\n-///         Foo {}\n-///     }\n-/// }\n-/// ```\n-/// could be\n-/// ```rust\n-/// struct Foo {}\n-/// impl Foo {\n-///     fn new() -> Self {\n-///         Self {}\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for unnecessary repetition of structure name when a\n+    /// replacement with `Self` is applicable.\n+    ///\n+    /// **Why is this bad?** Unnecessary repetition. Mixed use of `Self` and struct\n+    /// name\n+    /// feels inconsistent.\n+    ///\n+    /// **Known problems:**\n+    /// - False positive when using associated types (#2843)\n+    /// - False positives in some situations when using generics (#3410)\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// struct Foo {}\n+    /// impl Foo {\n+    ///     fn new() -> Foo {\n+    ///         Foo {}\n+    ///     }\n+    /// }\n+    /// ```\n+    /// could be\n+    /// ```rust\n+    /// struct Foo {}\n+    /// impl Foo {\n+    ///     fn new() -> Self {\n+    ///         Self {}\n+    ///     }\n+    /// }\n+    /// ```\n     pub USE_SELF,\n     pedantic,\n     \"Unnecessary structure name repetition whereas `Self` is applicable\""}, {"sha": "f1ab545ad3e4f4f8e12c13f226da88eb56517081", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -11,38 +11,38 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast::{Attribute, LitKind};\n \n-/// **What it does:** Generates clippy code that detects the offending pattern\n-///\n-/// **Example:**\n-/// ```rust\n-/// // ./tests/ui/my_lint.rs\n-/// fn foo() {\n-///     // detect the following pattern\n-///     #[clippy::author]\n-///     if x == 42 {\n-///         // but ignore everything from here on\n-///         #![clippy::author = \"ignore\"]\n-///     }\n-/// }\n-/// ```\n-///\n-/// Running `TESTNAME=ui/my_lint cargo uitest` will produce\n-/// a `./tests/ui/new_lint.stdout` file with the generated code:\n-///\n-/// ```rust\n-/// // ./tests/ui/new_lint.stdout\n-/// if_chain! {\n-///     if let ExprKind::If(ref cond, ref then, None) = item.node,\n-///     if let ExprKind::Binary(BinOp::Eq, ref left, ref right) = cond.node,\n-///     if let ExprKind::Path(ref path) = left.node,\n-///     if let ExprKind::Lit(ref lit) = right.node,\n-///     if let LitKind::Int(42, _) = lit.node,\n-///     then {\n-///         // report your lint here\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Generates clippy code that detects the offending pattern\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // ./tests/ui/my_lint.rs\n+    /// fn foo() {\n+    ///     // detect the following pattern\n+    ///     #[clippy::author]\n+    ///     if x == 42 {\n+    ///         // but ignore everything from here on\n+    ///         #![clippy::author = \"ignore\"]\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Running `TESTNAME=ui/my_lint cargo uitest` will produce\n+    /// a `./tests/ui/new_lint.stdout` file with the generated code:\n+    ///\n+    /// ```rust\n+    /// // ./tests/ui/new_lint.stdout\n+    /// if_chain! {\n+    ///     if let ExprKind::If(ref cond, ref then, None) = item.node,\n+    ///     if let ExprKind::Binary(BinOp::Eq, ref left, ref right) = cond.node,\n+    ///     if let ExprKind::Path(ref path) = left.node,\n+    ///     if let ExprKind::Lit(ref lit) = right.node,\n+    ///     if let LitKind::Int(42, _) = lit.node,\n+    ///     then {\n+    ///         // report your lint here\n+    ///     }\n+    /// }\n+    /// ```\n     pub LINT_AUTHOR,\n     internal_warn,\n     \"helper for writing lints\""}, {"sha": "2195039227013535c8b3dfd08de2aaa79692ded2", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -8,23 +8,23 @@ use rustc::session::Session;\n use rustc::{declare_tool_lint, lint_array};\n use syntax::ast::Attribute;\n \n-/// **What it does:** Dumps every ast/hir node which has the `#[clippy::dump]`\n-/// attribute\n-///\n-/// **Example:**\n-/// ```rust\n-/// #[clippy::dump]\n-/// extern crate foo;\n-/// ```\n-///\n-/// prints\n-///\n-/// ```\n-/// item `foo`\n-/// visibility inherited from outer item\n-/// extern crate dylib source: \"/path/to/foo.so\"\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Dumps every ast/hir node which has the `#[clippy::dump]`\n+    /// attribute\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// #[clippy::dump]\n+    /// extern crate foo;\n+    /// ```\n+    ///\n+    /// prints\n+    ///\n+    /// ```\n+    /// item `foo`\n+    /// visibility inherited from outer item\n+    /// extern crate dylib source: \"/path/to/foo.so\"\n+    /// ```\n     pub DEEP_CODE_INSPECTION,\n     internal_warn,\n     \"helper to dump info about code\""}, {"sha": "877f431e6413bdcf2b8ef9dd3691cc292f329029", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -14,78 +14,78 @@ use syntax::ast::{Crate as AstCrate, Ident, ItemKind, Name};\n use syntax::source_map::Span;\n use syntax::symbol::LocalInternedString;\n \n-/// **What it does:** Checks for various things we like to keep tidy in clippy.\n-///\n-/// **Why is this bad?** We like to pretend we're an example of tidy code.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:** Wrong ordering of the util::paths constants.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for various things we like to keep tidy in clippy.\n+    ///\n+    /// **Why is this bad?** We like to pretend we're an example of tidy code.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:** Wrong ordering of the util::paths constants.\n     pub CLIPPY_LINTS_INTERNAL,\n     internal,\n     \"various things that will negatively affect your clippy experience\"\n }\n \n-/// **What it does:** Ensures every lint is associated to a `LintPass`.\n-///\n-/// **Why is this bad?** The compiler only knows lints via a `LintPass`. Without\n-/// putting a lint to a `LintPass::get_lints()`'s return, the compiler will not\n-/// know the name of the lint.\n-///\n-/// **Known problems:** Only checks for lints associated using the `lint_array!`\n-/// macro.\n-///\n-/// **Example:**\n-/// ```rust\n-/// declare_lint! { pub LINT_1, ... }\n-/// declare_lint! { pub LINT_2, ... }\n-/// declare_lint! { pub FORGOTTEN_LINT, ... }\n-/// // ...\n-/// pub struct Pass;\n-/// impl LintPass for Pass {\n-///     fn get_lints(&self) -> LintArray {\n-///         lint_array![LINT_1, LINT_2]\n-///         // missing FORGOTTEN_LINT\n-///     }\n-/// }\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Ensures every lint is associated to a `LintPass`.\n+    ///\n+    /// **Why is this bad?** The compiler only knows lints via a `LintPass`. Without\n+    /// putting a lint to a `LintPass::get_lints()`'s return, the compiler will not\n+    /// know the name of the lint.\n+    ///\n+    /// **Known problems:** Only checks for lints associated using the `lint_array!`\n+    /// macro.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// declare_lint! { pub LINT_1, ... }\n+    /// declare_lint! { pub LINT_2, ... }\n+    /// declare_lint! { pub FORGOTTEN_LINT, ... }\n+    /// // ...\n+    /// pub struct Pass;\n+    /// impl LintPass for Pass {\n+    ///     fn get_lints(&self) -> LintArray {\n+    ///         lint_array![LINT_1, LINT_2]\n+    ///         // missing FORGOTTEN_LINT\n+    ///     }\n+    /// }\n+    /// ```\n     pub LINT_WITHOUT_LINT_PASS,\n     internal,\n     \"declaring a lint without associating it in a LintPass\"\n }\n \n-/// **What it does:** Checks for the presence of the default hash types \"HashMap\" or \"HashSet\"\n-/// and recommends the FxHash* variants.\n-///\n-/// **Why is this bad?** The FxHash variants have better performance\n-/// and we don't need any collision prevention in clippy.\n declare_clippy_lint! {\n+    /// **What it does:** Checks for the presence of the default hash types \"HashMap\" or \"HashSet\"\n+    /// and recommends the FxHash* variants.\n+    ///\n+    /// **Why is this bad?** The FxHash variants have better performance\n+    /// and we don't need any collision prevention in clippy.\n     pub DEFAULT_HASH_TYPES,\n     internal,\n     \"forbid HashMap and HashSet and suggest the FxHash* variants\"\n }\n \n-/// **What it does:** Checks for calls to `cx.span_lint*` and suggests to use the `utils::*`\n-/// variant of the function.\n-///\n-/// **Why is this bad?** The `utils::*` variants also add a link to the Clippy documentation to the\n-/// warning/error messages.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// Bad:\n-/// ```rust\n-/// cx.span_lint(LINT_NAME, \"message\");\n-/// ```\n-///\n-/// Good:\n-/// ```rust\n-/// utils::span_lint(cx, LINT_NAME, \"message\");\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `cx.span_lint*` and suggests to use the `utils::*`\n+    /// variant of the function.\n+    ///\n+    /// **Why is this bad?** The `utils::*` variants also add a link to the Clippy documentation to the\n+    /// warning/error messages.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// Bad:\n+    /// ```rust\n+    /// cx.span_lint(LINT_NAME, \"message\");\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust\n+    /// utils::span_lint(cx, LINT_NAME, \"message\");\n+    /// ```\n     pub COMPILER_LINT_FUNCTIONS,\n     internal,\n     \"usage of the lint functions of the compiler instead of the utils::* variant\""}, {"sha": "cd53029e83478b81ef5793a1a8b78e0b77a5f7f2", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -8,18 +8,18 @@ use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::source_map::Span;\n \n-/// **What it does:** Checks for usage of `&vec![..]` when using `&[..]` would\n-/// be possible.\n-///\n-/// **Why is this bad?** This is less efficient.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust,ignore\n-/// foo(&vec![1, 2])\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `&vec![..]` when using `&[..]` would\n+    /// be possible.\n+    ///\n+    /// **Why is this bad?** This is less efficient.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// foo(&vec![1, 2])\n+    /// ```\n     pub USELESS_VEC,\n     perf,\n     \"useless `vec!`\""}, {"sha": "30bd2177ca91de9752f77bf2a09f5c7668e8bf3b", "filename": "clippy_lints/src/wildcard_dependencies.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fwildcard_dependencies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fwildcard_dependencies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwildcard_dependencies.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -7,21 +7,21 @@ use cargo_metadata;\n use if_chain::if_chain;\n use semver;\n \n-/// **What it does:** Checks for wildcard dependencies in the `Cargo.toml`.\n-///\n-/// **Why is this bad?** [As the edition guide says](https://rust-lang-nursery.github.io/edition-guide/rust-2018/cargo-and-crates-io/crates-io-disallows-wildcard-dependencies.html),\n-/// it is highly unlikely that you work with any possible version of your dependency,\n-/// and wildcard dependencies would cause unnecessary breakage in the ecosystem.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```toml\n-/// [dependencies]\n-/// regex = \"*\"\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for wildcard dependencies in the `Cargo.toml`.\n+    ///\n+    /// **Why is this bad?** [As the edition guide says](https://rust-lang-nursery.github.io/edition-guide/rust-2018/cargo-and-crates-io/crates-io-disallows-wildcard-dependencies.html),\n+    /// it is highly unlikely that you work with any possible version of your dependency,\n+    /// and wildcard dependencies would cause unnecessary breakage in the ecosystem.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```toml\n+    /// [dependencies]\n+    /// regex = \"*\"\n+    /// ```\n     pub WILDCARD_DEPENDENCIES,\n     cargo,\n     \"wildcard dependencies being used\""}, {"sha": "e433bd69cb0185edb9ea86af43fb75e9a0254fcd", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 104, "deletions": 104, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -7,153 +7,153 @@ use syntax::ast::*;\n use syntax::parse::{parser, token};\n use syntax::tokenstream::{TokenStream, TokenTree};\n \n-/// **What it does:** This lint warns when you use `println!(\"\")` to\n-/// print a newline.\n-///\n-/// **Why is this bad?** You should use `println!()`, which is simpler.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// println!(\"\");\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** This lint warns when you use `println!(\"\")` to\n+    /// print a newline.\n+    ///\n+    /// **Why is this bad?** You should use `println!()`, which is simpler.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// println!(\"\");\n+    /// ```\n     pub PRINTLN_EMPTY_STRING,\n     style,\n     \"using `println!(\\\"\\\")` with an empty string\"\n }\n \n-/// **What it does:** This lint warns when you use `print!()` with a format\n-/// string that\n-/// ends in a newline.\n-///\n-/// **Why is this bad?** You should use `println!()` instead, which appends the\n-/// newline.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// print!(\"Hello {}!\\n\", name);\n-/// ```\n-/// use println!() instead\n-/// ```rust\n-/// println!(\"Hello {}!\", name);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** This lint warns when you use `print!()` with a format\n+    /// string that\n+    /// ends in a newline.\n+    ///\n+    /// **Why is this bad?** You should use `println!()` instead, which appends the\n+    /// newline.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// print!(\"Hello {}!\\n\", name);\n+    /// ```\n+    /// use println!() instead\n+    /// ```rust\n+    /// println!(\"Hello {}!\", name);\n+    /// ```\n     pub PRINT_WITH_NEWLINE,\n     style,\n     \"using `print!()` with a format string that ends in a single newline\"\n }\n \n-/// **What it does:** Checks for printing on *stdout*. The purpose of this lint\n-/// is to catch debugging remnants.\n-///\n-/// **Why is this bad?** People often print on *stdout* while debugging an\n-/// application and might forget to remove those prints afterward.\n-///\n-/// **Known problems:** Only catches `print!` and `println!` calls.\n-///\n-/// **Example:**\n-/// ```rust\n-/// println!(\"Hello world!\");\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for printing on *stdout*. The purpose of this lint\n+    /// is to catch debugging remnants.\n+    ///\n+    /// **Why is this bad?** People often print on *stdout* while debugging an\n+    /// application and might forget to remove those prints afterward.\n+    ///\n+    /// **Known problems:** Only catches `print!` and `println!` calls.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// println!(\"Hello world!\");\n+    /// ```\n     pub PRINT_STDOUT,\n     restriction,\n     \"printing on stdout\"\n }\n \n-/// **What it does:** Checks for use of `Debug` formatting. The purpose of this\n-/// lint is to catch debugging remnants.\n-///\n-/// **Why is this bad?** The purpose of the `Debug` trait is to facilitate\n-/// debugging Rust code. It should not be used in in user-facing output.\n-///\n-/// **Example:**\n-/// ```rust\n-/// println!(\"{:?}\", foo);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for use of `Debug` formatting. The purpose of this\n+    /// lint is to catch debugging remnants.\n+    ///\n+    /// **Why is this bad?** The purpose of the `Debug` trait is to facilitate\n+    /// debugging Rust code. It should not be used in in user-facing output.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// println!(\"{:?}\", foo);\n+    /// ```\n     pub USE_DEBUG,\n     restriction,\n     \"use of `Debug`-based formatting\"\n }\n \n-/// **What it does:** This lint warns about the use of literals as `print!`/`println!` args.\n-///\n-/// **Why is this bad?** Using literals as `println!` args is inefficient\n-/// (c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n-/// (i.e., just put the literal in the format string)\n-///\n-/// **Known problems:** Will also warn with macro calls as arguments that expand to literals\n-/// -- e.g., `println!(\"{}\", env!(\"FOO\"))`.\n-///\n-/// **Example:**\n-/// ```rust\n-/// println!(\"{}\", \"foo\");\n-/// ```\n-/// use the literal without formatting:\n-/// ```rust\n-/// println!(\"foo\");\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** This lint warns about the use of literals as `print!`/`println!` args.\n+    ///\n+    /// **Why is this bad?** Using literals as `println!` args is inefficient\n+    /// (c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n+    /// (i.e., just put the literal in the format string)\n+    ///\n+    /// **Known problems:** Will also warn with macro calls as arguments that expand to literals\n+    /// -- e.g., `println!(\"{}\", env!(\"FOO\"))`.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// println!(\"{}\", \"foo\");\n+    /// ```\n+    /// use the literal without formatting:\n+    /// ```rust\n+    /// println!(\"foo\");\n+    /// ```\n     pub PRINT_LITERAL,\n     style,\n     \"printing a literal with a format string\"\n }\n \n-/// **What it does:** This lint warns when you use `writeln!(buf, \"\")` to\n-/// print a newline.\n-///\n-/// **Why is this bad?** You should use `writeln!(buf)`, which is simpler.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// writeln!(\"\");\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** This lint warns when you use `writeln!(buf, \"\")` to\n+    /// print a newline.\n+    ///\n+    /// **Why is this bad?** You should use `writeln!(buf)`, which is simpler.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// writeln!(\"\");\n+    /// ```\n     pub WRITELN_EMPTY_STRING,\n     style,\n     \"using `writeln!(\\\"\\\")` with an empty string\"\n }\n \n-/// **What it does:** This lint warns when you use `write!()` with a format\n-/// string that\n-/// ends in a newline.\n-///\n-/// **Why is this bad?** You should use `writeln!()` instead, which appends the\n-/// newline.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// write!(buf, \"Hello {}!\\n\", name);\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** This lint warns when you use `write!()` with a format\n+    /// string that\n+    /// ends in a newline.\n+    ///\n+    /// **Why is this bad?** You should use `writeln!()` instead, which appends the\n+    /// newline.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// write!(buf, \"Hello {}!\\n\", name);\n+    /// ```\n     pub WRITE_WITH_NEWLINE,\n     style,\n     \"using `write!()` with a format string that ends in a single newline\"\n }\n \n-/// **What it does:** This lint warns about the use of literals as `write!`/`writeln!` args.\n-///\n-/// **Why is this bad?** Using literals as `writeln!` args is inefficient\n-/// (c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n-/// (i.e., just put the literal in the format string)\n-///\n-/// **Known problems:** Will also warn with macro calls as arguments that expand to literals\n-/// -- e.g., `writeln!(buf, \"{}\", env!(\"FOO\"))`.\n-///\n-/// **Example:**\n-/// ```rust\n-/// writeln!(buf, \"{}\", \"foo\");\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** This lint warns about the use of literals as `write!`/`writeln!` args.\n+    ///\n+    /// **Why is this bad?** Using literals as `writeln!` args is inefficient\n+    /// (c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n+    /// (i.e., just put the literal in the format string)\n+    ///\n+    /// **Known problems:** Will also warn with macro calls as arguments that expand to literals\n+    /// -- e.g., `writeln!(buf, \"{}\", env!(\"FOO\"))`.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// writeln!(buf, \"{}\", \"foo\");\n+    /// ```\n     pub WRITE_LITERAL,\n     style,\n     \"writing a literal with a format string\""}, {"sha": "de13816f66fdc4858d3f364dd232ca733d8a2d25", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -5,18 +5,18 @@ use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n \n-/// **What it does:** Checks for `0.0 / 0.0`.\n-///\n-/// **Why is this bad?** It's less readable than `std::f32::NAN` or\n-/// `std::f64::NAN`.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// 0.0f32 / 0.0\n-/// ```\n declare_clippy_lint! {\n+    /// **What it does:** Checks for `0.0 / 0.0`.\n+    ///\n+    /// **Why is this bad?** It's less readable than `std::f32::NAN` or\n+    /// `std::f64::NAN`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// 0.0f32 / 0.0\n+    /// ```\n     pub ZERO_DIVIDED_BY_ZERO,\n     complexity,\n     \"usage of `0.0 / 0.0` to obtain NaN instead of std::f32::NaN or std::f64::NaN\""}, {"sha": "a260e00cde460ad200a08dcd3470ba745e2f0ae4", "filename": "util/lintlib.py", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/fe96ffeac98481433c33e3e9f49a56f70f8ec134/util%2Flintlib.py", "raw_url": "https://github.com/rust-lang/rust/raw/fe96ffeac98481433c33e3e9f49a56f70f8ec134/util%2Flintlib.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Flintlib.py?ref=fe96ffeac98481433c33e3e9f49a56f70f8ec134", "patch": "@@ -15,6 +15,7 @@\n conf_re = re.compile(r'''define_Conf! {\\n([^}]*)\\n}''', re.MULTILINE)\n confvar_re = re.compile(\n     r'''/// Lint: (\\w+). (.*).*\\n\\s*\\([^,]+,\\s+\"([^\"]+)\",\\s+([^=\\)]+)=>\\s+(.*)\\),''', re.MULTILINE)\n+comment_re = re.compile(r'''\\s*/// ?(.*)''')\n \n lint_levels = {\n     \"correctness\": 'Deny',\n@@ -29,37 +30,15 @@\n \n \n def parse_lints(lints, filepath):\n-    last_comment = []\n-    comment = True\n+    comment = []\n     clippy = False\n     deprecated = False\n     name = \"\"\n \n     with open(filepath) as fp:\n         for line in fp:\n-            if comment:\n-                if line.startswith(\"/// \"):\n-                    last_comment.append(line[4:])\n-                elif line.startswith(\"///\"):\n-                    last_comment.append(line[3:])\n-                elif line.startswith(\"declare_lint!\"):\n-                    import sys\n-                    print(\"don't use `declare_lint!` in Clippy, use `declare_clippy_lint!` instead\")\n-                    sys.exit(42)\n-                elif line.startswith(\"declare_clippy_lint!\"):\n-                    comment = False\n-                    deprecated = False\n-                    clippy = True\n-                    name = \"\"\n-                elif line.startswith(\"declare_deprecated_lint!\"):\n-                    comment = False\n-                    deprecated = True\n-                    clippy = False\n-                else:\n-                    last_comment = []\n-            if not comment:\n+            if clippy or deprecated:\n                 m = lintname_re.search(line)\n-\n                 if m:\n                     name = m.group(1).lower()\n                     line = next(fp)\n@@ -81,13 +60,29 @@ def parse_lints(lints, filepath):\n \n                     log.info(\"found %s with level %s in %s\",\n                              name, level, filepath)\n-                    lints.append(Lint(name, level, last_comment, filepath, group))\n-                    last_comment = []\n-                    comment = True\n+                    lints.append(Lint(name, level, comment, filepath, group))\n+                    comment = []\n \n-                    if \"}\" in line:\n-                        log.warn(\"Warning: missing Lint-Name in %s\", filepath)\n-                        comment = True\n+                    clippy = False\n+                    deprecated = False\n+                    name = \"\"\n+                else:\n+                    m = comment_re.search(line)\n+                    if m:\n+                        comment.append(m.group(1))\n+            elif line.startswith(\"declare_clippy_lint!\"):\n+                clippy = True\n+                deprecated = False\n+            elif line.startswith(\"declare_deprecated_lint!\"):\n+                clippy = False\n+                deprecated = True\n+            elif line.startswith(\"declare_lint!\"):\n+                import sys\n+                print(\n+                    \"don't use `declare_lint!` in Clippy, \"\n+                    \"use `declare_clippy_lint!` instead\"\n+                )\n+                sys.exit(42)\n \n \n def parse_configs(path):"}]}