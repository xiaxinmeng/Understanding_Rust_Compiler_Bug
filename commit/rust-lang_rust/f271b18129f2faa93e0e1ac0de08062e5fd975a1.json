{"sha": "f271b18129f2faa93e0e1ac0de08062e5fd975a1", "node_id": "C_kwDOAAsO6NoAKGYyNzFiMTgxMjlmMmZhYTkzZTBlMWFjMGRlMDgwNjJlNWZkOTc1YTE", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-18T09:19:36Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-18T09:19:36Z"}, "message": "Consider walking up macro expansions when searching for surrounding entities in completion analysis", "tree": {"sha": "76196855da6275b132e9cbd89539d84ccdc2a753", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76196855da6275b132e9cbd89539d84ccdc2a753"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f271b18129f2faa93e0e1ac0de08062e5fd975a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f271b18129f2faa93e0e1ac0de08062e5fd975a1", "html_url": "https://github.com/rust-lang/rust/commit/f271b18129f2faa93e0e1ac0de08062e5fd975a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f271b18129f2faa93e0e1ac0de08062e5fd975a1/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1446a27437c415e262f8a2850f27f9615f84c14", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1446a27437c415e262f8a2850f27f9615f84c14", "html_url": "https://github.com/rust-lang/rust/commit/c1446a27437c415e262f8a2850f27f9615f84c14"}], "stats": {"total": 85, "additions": 45, "deletions": 40}, "files": [{"sha": "9ceb60f90f1666329c2a3ec6f3edc487b3db1f2e", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 45, "deletions": 40, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/f271b18129f2faa93e0e1ac0de08062e5fd975a1/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f271b18129f2faa93e0e1ac0de08062e5fd975a1/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=f271b18129f2faa93e0e1ac0de08062e5fd975a1", "patch": "@@ -456,7 +456,7 @@ impl<'a> CompletionContext<'a> {\n                 ast::IdentPat(bind_pat) => {\n                     let mut pat_ctx = pattern_context_for(sema, original_file, bind_pat.into());\n                     if let Some(record_field) = ast::RecordPatField::for_field_name(&name) {\n-                        pat_ctx.record_pat = find_node_in_file_compensated(original_file, &record_field.parent_record_pat());\n+                        pat_ctx.record_pat = find_node_in_file_compensated(sema, original_file, &record_field.parent_record_pat());\n                     }\n \n                     NameKind::IdentPat(pat_ctx)\n@@ -493,9 +493,13 @@ impl<'a> CompletionContext<'a> {\n             |kind| (NameRefContext { nameref: nameref.clone(), kind }, Default::default());\n \n         if let Some(record_field) = ast::RecordExprField::for_field_name(&name_ref) {\n-            return find_node_in_file_compensated(original_file, &record_field.parent_record_lit())\n-                .map(NameRefKind::RecordExpr)\n-                .map(make_res);\n+            return find_node_in_file_compensated(\n+                sema,\n+                original_file,\n+                &record_field.parent_record_lit(),\n+            )\n+            .map(NameRefKind::RecordExpr)\n+            .map(make_res);\n         }\n         if let Some(record_field) = ast::RecordPatField::for_field_name_ref(&name_ref) {\n             let kind = NameRefKind::Pattern(PatternContext {\n@@ -504,6 +508,7 @@ impl<'a> CompletionContext<'a> {\n                 ref_token: None,\n                 mut_token: None,\n                 record_pat: find_node_in_file_compensated(\n+                    sema,\n                     original_file,\n                     &record_field.parent_record_pat(),\n                 ),\n@@ -568,7 +573,7 @@ impl<'a> CompletionContext<'a> {\n         };\n         let func_update_record = |syn: &SyntaxNode| {\n             if let Some(record_expr) = syn.ancestors().nth(2).and_then(ast::RecordExpr::cast) {\n-                find_node_in_file_compensated(original_file, &record_expr)\n+                find_node_in_file_compensated(sema, original_file, &record_expr)\n             } else {\n                 None\n             }\n@@ -670,9 +675,9 @@ impl<'a> CompletionContext<'a> {\n                     ast::TypeBound(_) => TypeLocation::TypeBound,\n                     // is this case needed?\n                     ast::TypeBoundList(_) => TypeLocation::TypeBound,\n-                    ast::GenericArg(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(original_file, it.syntax().parent().and_then(ast::GenericArgList::cast))),\n+                    ast::GenericArg(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(sema, original_file, it.syntax().parent().and_then(ast::GenericArgList::cast))),\n                     // is this case needed?\n-                    ast::GenericArgList(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(original_file, Some(it))),\n+                    ast::GenericArgList(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(sema, original_file, Some(it))),\n                     ast::TupleField(_) => TypeLocation::TupleField,\n                     _ => return None,\n                 }\n@@ -734,7 +739,7 @@ impl<'a> CompletionContext<'a> {\n                     _ => Some(None),\n                 };\n \n-                match dbg!(find_node_in_file_compensated(original_file, &expr)) {\n+                match find_node_in_file_compensated(sema, original_file, &expr) {\n                     Some(it) => {\n                         let innermost_ret_ty = sema\n                             .ancestors_with_macros(it.syntax().clone())\n@@ -757,7 +762,7 @@ impl<'a> CompletionContext<'a> {\n                 .parent()\n                 .and_then(ast::LetStmt::cast)\n                 .map_or(false, |it| it.semicolon_token().is_none());\n-            let impl_ = fetch_immediate_impl(sema, original_file, &expr);\n+            let impl_ = fetch_immediate_impl(sema, original_file, expr.syntax());\n \n             PathKind::Expr {\n                 in_block_expr,\n@@ -826,7 +831,7 @@ impl<'a> CompletionContext<'a> {\n                                         match it {\n                                             ast::Trait(_) => ItemListKind::Trait,\n                                             ast::Impl(it) => if it.trait_().is_some() {\n-                                                ItemListKind::TraitImpl(find_node_in_file_compensated(original_file, &it))\n+                                                ItemListKind::TraitImpl(find_node_in_file_compensated(sema, original_file, &it))\n                                             } else {\n                                                 ItemListKind::Impl\n                                             },\n@@ -983,7 +988,7 @@ fn pattern_context_for(\n                         let has_type_ascription = param.ty().is_some();\n                         is_param = (|| {\n                             let fake_param_list = param.syntax().parent().and_then(ast::ParamList::cast)?;\n-                            let param_list = find_node_in_file_compensated(original_file, &fake_param_list)?;\n+                            let param_list = find_node_in_file_compensated(sema, original_file, &fake_param_list)?;\n                             let param_list_owner = param_list.syntax().parent()?;\n                             let kind = match_ast! {\n                                 match param_list_owner {\n@@ -1017,42 +1022,25 @@ fn pattern_context_for(\n         mut_token,\n         ref_token,\n         record_pat: None,\n-        impl_: fetch_immediate_impl(sema, original_file, &pat),\n+        impl_: fetch_immediate_impl(sema, original_file, pat.syntax()),\n     }\n }\n \n fn fetch_immediate_impl(\n     sema: &Semantics<RootDatabase>,\n     original_file: &SyntaxNode,\n-    node: &impl AstNode,\n+    node: &SyntaxNode,\n ) -> Option<ast::Impl> {\n-    // FIXME: The fallback here could be done better\n-    let (f, s) = match find_node_in_file_compensated(original_file, node) {\n-        Some(node) => {\n-            let mut items = sema\n-                .ancestors_with_macros(node.syntax().clone())\n-                .filter_map(ast::Item::cast)\n-                .filter(|it| !matches!(it, ast::Item::MacroCall(_)))\n-                .take(2);\n-            (items.next(), items.next())\n-        }\n-        None => {\n-            let mut items = node\n-                .syntax()\n-                .ancestors()\n-                .filter_map(ast::Item::cast)\n-                .filter(|it| !matches!(it, ast::Item::MacroCall(_)))\n-                .take(2);\n-            (items.next(), items.next())\n-        }\n-    };\n+    let mut ancestors = ancestors_in_file_compensated(sema, original_file, node)?\n+        .filter_map(ast::Item::cast)\n+        .filter(|it| !matches!(it, ast::Item::MacroCall(_)));\n \n-    match f? {\n+    match ancestors.next()? {\n         ast::Item::Const(_) | ast::Item::Fn(_) | ast::Item::TypeAlias(_) => (),\n         ast::Item::Impl(it) => return Some(it),\n         _ => return None,\n     }\n-    match s? {\n+    match ancestors.next()? {\n         ast::Item::Impl(it) => Some(it),\n         _ => None,\n     }\n@@ -1076,27 +1064,44 @@ fn find_node_in_file<N: AstNode>(syntax: &SyntaxNode, node: &N) -> Option<N> {\n /// Attempts to find `node` inside `syntax` via `node`'s text range while compensating\n /// for the offset introduced by the fake ident.\n /// This is wrong if `node` comes before the insertion point! Use `find_node_in_file` instead.\n-fn find_node_in_file_compensated<N: AstNode>(syntax: &SyntaxNode, node: &N) -> Option<N> {\n-    let syntax_range = syntax.text_range();\n-    let range = node.syntax().text_range();\n+fn find_node_in_file_compensated<N: AstNode>(\n+    sema: &Semantics<RootDatabase>,\n+    in_file: &SyntaxNode,\n+    node: &N,\n+) -> Option<N> {\n+    ancestors_in_file_compensated(sema, in_file, node.syntax())?.find_map(N::cast)\n+}\n+\n+fn ancestors_in_file_compensated<'sema>(\n+    sema: &'sema Semantics<RootDatabase>,\n+    in_file: &SyntaxNode,\n+    node: &SyntaxNode,\n+) -> Option<impl Iterator<Item = SyntaxNode> + 'sema> {\n+    let syntax_range = in_file.text_range();\n+    let range = node.text_range();\n     let end = range.end().checked_sub(TextSize::try_from(COMPLETION_MARKER.len()).ok()?)?;\n     if end < range.start() {\n         return None;\n     }\n     let range = TextRange::new(range.start(), end);\n     // our inserted ident could cause `range` to go outside of the original syntax, so cap it\n     let intersection = range.intersect(syntax_range)?;\n-    syntax.covering_element(intersection).ancestors().find_map(N::cast)\n+    let node = match in_file.covering_element(intersection) {\n+        NodeOrToken::Node(node) => node,\n+        NodeOrToken::Token(tok) => tok.parent()?,\n+    };\n+    Some(sema.ancestors_with_macros(node))\n }\n \n /// Attempts to find `node` inside `syntax` via `node`'s text range while compensating\n /// for the offset introduced by the fake ident..\n /// This is wrong if `node` comes before the insertion point! Use `find_node_in_file` instead.\n fn find_opt_node_in_file_compensated<N: AstNode>(\n+    sema: &Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n     node: Option<N>,\n ) -> Option<N> {\n-    find_node_in_file_compensated(syntax, &node?)\n+    find_node_in_file_compensated(sema, syntax, &node?)\n }\n \n fn path_or_use_tree_qualifier(path: &ast::Path) -> Option<(ast::Path, bool)> {"}]}