{"sha": "a7aecc46a517c4cac0a63ffcdb2e87ebff77e281", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3YWVjYzQ2YTUxN2M0Y2FjMGE2M2ZmY2RiMmU4N2ViZmY3N2UyODE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-20T02:05:50Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-20T19:58:19Z"}, "message": "rustc: Implement \"deriving\" for monomorphic structs via a syntax extension. r=brson", "tree": {"sha": "01bd00f0a6269e76464fe85a59784b13de802a92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01bd00f0a6269e76464fe85a59784b13de802a92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7aecc46a517c4cac0a63ffcdb2e87ebff77e281", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7aecc46a517c4cac0a63ffcdb2e87ebff77e281", "html_url": "https://github.com/rust-lang/rust/commit/a7aecc46a517c4cac0a63ffcdb2e87ebff77e281", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7aecc46a517c4cac0a63ffcdb2e87ebff77e281/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f22582e9f05c1ba36b25ad468ac75f8793f5011", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f22582e9f05c1ba36b25ad468ac75f8793f5011", "html_url": "https://github.com/rust-lang/rust/commit/8f22582e9f05c1ba36b25ad468ac75f8793f5011"}], "stats": {"total": 450, "additions": 450, "deletions": 0}, "files": [{"sha": "ba5d34bfdb411d1e5719849aa847f9cbb818c893", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a7aecc46a517c4cac0a63ffcdb2e87ebff77e281/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7aecc46a517c4cac0a63ffcdb2e87ebff77e281/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=a7aecc46a517c4cac0a63ffcdb2e87ebff77e281", "patch": "@@ -97,6 +97,9 @@ fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n                                 ext::log_syntax::expand_syntax_ext));\n     syntax_expanders.insert(~\"ast\",\n                             builtin(ext::qquote::expand_ast));\n+    syntax_expanders.insert(~\"deriving_eq\",\n+                            item_decorator(\n+                                ext::deriving::expand_deriving_eq));\n \n     // Quasi-quoting expanders\n     syntax_expanders.insert(~\"quote_tokens\","}, {"sha": "856cc0884ac14301703d4d3b510a11afa608f54d", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a7aecc46a517c4cac0a63ffcdb2e87ebff77e281/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7aecc46a517c4cac0a63ffcdb2e87ebff77e281/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=a7aecc46a517c4cac0a63ffcdb2e87ebff77e281", "patch": "@@ -136,9 +136,29 @@ fn mk_block(cx: ext_ctxt, sp: span,\n                span: sp };\n     mk_expr(cx, sp, ast::expr_block(blk))\n }\n+fn mk_simple_block(cx: ext_ctxt, span: span, expr: @ast::expr) -> ast::blk {\n+    let block = {\n+        view_items: ~[],\n+        stmts: ~[],\n+        expr: Some(expr),\n+        id: cx.next_id(),\n+        rules: ast::default_blk\n+    };\n+    { node: move block, span: span }\n+}\n fn mk_copy(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_copy(e))\n }\n fn mk_managed(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_unary(ast::box(ast::m_imm), e))\n }\n+fn mk_pat_ident(cx: ext_ctxt, span: span, ident: ast::ident) -> @ast::pat {\n+    let path = build::mk_raw_path(span, ~[ ident ]);\n+    let pat = ast::pat_ident(ast::bind_by_value, path, None);\n+    @{ id: cx.next_id(), node: move pat, span: span }\n+}\n+fn mk_bool(cx: ext_ctxt, span: span, value: bool) -> @ast::expr {\n+    let lit_expr = ast::expr_lit(@{ node: ast::lit_bool(value), span: span });\n+    build::mk_expr(cx, span, move lit_expr)\n+}\n+"}, {"sha": "ab0361e88ba1980d152de0414c2dc0a2dceaeb98", "filename": "src/libsyntax/ext/deriving.rs", "status": "added", "additions": 394, "deletions": 0, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/a7aecc46a517c4cac0a63ffcdb2e87ebff77e281/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7aecc46a517c4cac0a63ffcdb2e87ebff77e281/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=a7aecc46a517c4cac0a63ffcdb2e87ebff77e281", "patch": "@@ -0,0 +1,394 @@\n+/// The compiler code necessary to implement the #[deriving_eq] and\n+/// #[deriving_ord] extensions.\n+\n+use ast::{and, bind_by_value, binop, blk, default_blk, deref, enum_def, expr};\n+use ast::{expr_, expr_addr_of, expr_binary, expr_call, expr_field, expr_lit};\n+use ast::{expr_match, expr_path, expr_unary, ident, infer, item, item_};\n+use ast::{item_class, item_enum, item_impl, lit_bool, m_imm, meta_item};\n+use ast::{method, named_field, or, pat, pat_ident, pat_wild, path, public};\n+use ast::{pure_fn, re_anon, return_val, struct_def, sty_region, ty_path};\n+use ast::{ty_rptr, unnamed_field};\n+use base::ext_ctxt;\n+use codemap::span;\n+use parse::token::special_idents::clownshoes_extensions;\n+\n+enum Junction {\n+    Conjunction,\n+    Disjunction,\n+}\n+\n+impl Junction {\n+    fn to_binop(self) -> binop {\n+        match self {\n+            Conjunction => and,\n+            Disjunction => or,\n+        }\n+    }\n+}\n+\n+pub fn expand_deriving_eq(cx: ext_ctxt,\n+                          span: span,\n+                          _mitem: meta_item,\n+                          in_items: ~[@item])\n+                       -> ~[@item] {\n+    let result = dvec::DVec();\n+    for in_items.each |item| {\n+        result.push(copy *item);\n+        match item.node {\n+            item_class(struct_def, _) => {\n+                result.push(expand_deriving_struct_def(cx,\n+                                                       span,\n+                                                       struct_def,\n+                                                       item.ident));\n+            }\n+            item_enum(ref enum_definition, _) => {\n+                result.push(expand_deriving_enum_def(cx,\n+                                                     span,\n+                                                     enum_definition,\n+                                                     item.ident));\n+            }\n+            _ => result.push(copy *item)    // XXX: Don't copy.\n+        }\n+    }\n+    dvec::unwrap(move result)\n+}\n+\n+fn create_impl_item(cx: ext_ctxt, span: span, +item: item_) -> @item {\n+    @{\n+        ident: clownshoes_extensions,\n+        attrs: ~[],\n+        id: cx.next_id(),\n+        node: move item,\n+        vis: ast::public,\n+        span: span,\n+    }\n+}\n+\n+/// Creates a method from the given expression, the signature of which\n+/// conforms to the `eq` or `ne` method.\n+fn create_method(cx: ext_ctxt,\n+                 span: span,\n+                 method_ident: ident,\n+                 type_ident: ident,\n+                 body: @expr)\n+              -> @method {\n+    // Create the type of the `other` parameter.\n+    let arg_path_type = build::mk_raw_path(span, ~[ type_ident ]);\n+    let arg_path_type = ty_path(arg_path_type, cx.next_id());\n+    let arg_path_type = @{\n+        id: cx.next_id(),\n+        node: move arg_path_type,\n+        span: span\n+    };\n+    let arg_region = @{ id: cx.next_id(), node: re_anon };\n+    let arg_type = ty_rptr(arg_region, { ty: arg_path_type, mutbl: m_imm });\n+    let arg_type = @{ id: cx.next_id(), node: move arg_type, span: span };\n+\n+    // Create the `other` parameter.\n+    let other_ident = cx.ident_of(~\"__other\");\n+    let arg_pat = build::mk_pat_ident(cx, span, other_ident);\n+    let arg = {\n+        mode: infer(cx.next_id()),\n+        ty: arg_type,\n+        pat: arg_pat,\n+        id: cx.next_id()\n+    };\n+\n+    // Create the type of the return value.\n+    let bool_ident = cx.ident_of(~\"bool\");\n+    let output_type = build::mk_raw_path(span, ~[ bool_ident ]);\n+    let output_type = ty_path(output_type, cx.next_id());\n+    let output_type = @{\n+        id: cx.next_id(),\n+        node: move output_type,\n+        span: span\n+    };\n+\n+    // Create the function declaration.\n+    let fn_decl = {\n+        inputs: ~[ move arg ],\n+        output: output_type,\n+        cf: return_val\n+    };\n+\n+    // Create the body block.\n+    let body_block = build::mk_simple_block(cx, span, body);\n+\n+    // Create the method.\n+    let self_ty = { node: sty_region(m_imm), span: span };\n+    return @{\n+        ident: method_ident,\n+        attrs: ~[],\n+        tps: ~[],\n+        self_ty: self_ty,\n+        purity: pure_fn,\n+        decl: move fn_decl,\n+        body: move body_block,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: public\n+    };\n+}\n+\n+fn create_derived_impl(cx: ext_ctxt,\n+                       span: span,\n+                       type_ident: ident,\n+                       eq_method: @method,\n+                       ne_method: @method)\n+                    -> @item {\n+    // Create the reference to the `core::cmp::Eq` trait.\n+    let core_ident = cx.ident_of(~\"core\");\n+    let cmp_ident = cx.ident_of(~\"cmp\");\n+    let eq_ident = cx.ident_of(~\"Eq\");\n+    let core_cmp_eq_idents = ~[\n+        move core_ident,\n+        move cmp_ident,\n+        move eq_ident\n+    ];\n+    let core_cmp_eq_path = {\n+        span: span,\n+        global: false,\n+        idents: move core_cmp_eq_idents,\n+        rp: None,\n+        types: ~[]\n+    };\n+    let core_cmp_eq_path = @move core_cmp_eq_path;\n+    let trait_ref = {\n+        path: core_cmp_eq_path,\n+        ref_id: cx.next_id(),\n+        impl_id: cx.next_id(),\n+    };\n+    let trait_ref = @move trait_ref;\n+\n+    // Create the type of `self`.\n+    let self_type = build::mk_raw_path(span, ~[ type_ident ]);\n+    let self_type = ty_path(self_type, cx.next_id());\n+    let self_type = @{ id: cx.next_id(), node: move self_type, span: span };\n+\n+    // Create the impl item.\n+    let impl_item = item_impl(~[],\n+                              Some(trait_ref),\n+                              self_type,\n+                              ~[ eq_method, ne_method ]);\n+    return create_impl_item(cx, span, move impl_item);\n+}\n+\n+fn expand_deriving_struct_def(cx: ext_ctxt,\n+                              span: span,\n+                              struct_def: &struct_def,\n+                              type_ident: ident)\n+                           -> @item {\n+    // Create the methods.\n+    let eq_ident = cx.ident_of(~\"eq\");\n+    let ne_ident = cx.ident_of(~\"ne\");\n+    let eq_method = expand_deriving_struct_method(cx,\n+                                                  span,\n+                                                  struct_def,\n+                                                  eq_ident,\n+                                                  type_ident,\n+                                                  Conjunction);\n+    let ne_method = expand_deriving_struct_method(cx,\n+                                                  span,\n+                                                  struct_def,\n+                                                  ne_ident,\n+                                                  type_ident,\n+                                                  Disjunction);\n+\n+    // Create the implementation.\n+    return create_derived_impl(cx, span, type_ident, eq_method, ne_method);    \n+}\n+\n+fn expand_deriving_struct_method(cx: ext_ctxt,\n+                                 span: span,\n+                                 struct_def: &struct_def,\n+                                 method_ident: ident,\n+                                 type_ident: ident,\n+                                 junction: Junction)\n+                              -> @method {\n+    let self_ident = cx.ident_of(~\"self\");\n+    let other_ident = cx.ident_of(~\"__other\");\n+\n+    let binop = junction.to_binop();\n+\n+    // Create the body of the method.\n+    let mut outer_expr = None;\n+    for struct_def.fields.each |struct_field| {\n+        match struct_field.node.kind {\n+            named_field(ident, _, _) => {\n+                // Create the accessor for the other field.\n+                let other_field = build::mk_access(cx,\n+                                                   span,\n+                                                   ~[ other_ident ],\n+                                                   ident);\n+                let other_field_ref = build::mk_addr_of(cx,\n+                                                        span,\n+                                                        other_field);\n+\n+                // Create the accessor for this field.\n+                let self_field = build::mk_access(cx,\n+                                                  span,\n+                                                  ~[ self_ident ],\n+                                                  ident);\n+\n+                // Call the substructure method.\n+                let self_method = build::mk_access_(cx,\n+                                                    span,\n+                                                    self_field,\n+                                                    method_ident);\n+                let self_call = build::mk_call_(cx,\n+                                                span,\n+                                                self_method,\n+                                                ~[ other_field_ref ]);\n+\n+                // Connect to the outer expression if necessary.\n+                outer_expr = match outer_expr {\n+                    None => Some(self_call),\n+                    Some(old_outer_expr) => {\n+                        let chain_expr = build::mk_binary(cx,\n+                                                          span,\n+                                                          binop,\n+                                                          old_outer_expr,\n+                                                          self_call);\n+                        Some(chain_expr)\n+                    }\n+                };\n+            }\n+            unnamed_field => {\n+                cx.span_unimpl(span, ~\"unnamed fields with `deriving_eq`\");\n+            }\n+        }\n+    }\n+\n+    // Create the method itself.\n+    let body;\n+    match outer_expr {\n+        None => cx.span_unimpl(span, ~\"empty structs with `deriving_eq`\"),\n+        Some(outer_expr) => body = outer_expr,\n+    }\n+\n+    return create_method(cx, span, method_ident, type_ident, body);\n+}\n+\n+fn expand_deriving_enum_def(cx: ext_ctxt,\n+                            span: span,\n+                            enum_definition: &enum_def,\n+                            type_ident: ident)\n+                         -> @item {\n+    // Create the methods.\n+    let eq_ident = cx.ident_of(~\"eq\");\n+    let ne_ident = cx.ident_of(~\"ne\");\n+    let eq_method = expand_deriving_enum_method(cx,\n+                                                span,\n+                                                enum_definition,\n+                                                eq_ident,\n+                                                type_ident,\n+                                                Conjunction);\n+    let ne_method = expand_deriving_enum_method(cx,\n+                                                span,\n+                                                enum_definition,\n+                                                ne_ident,\n+                                                type_ident,\n+                                                Disjunction);\n+\n+    // Create the implementation.\n+    return create_derived_impl(cx, span, type_ident, eq_method, ne_method);\n+}\n+\n+fn expand_deriving_enum_method(cx: ext_ctxt,\n+                               span: span,\n+                               enum_definition: &enum_def,\n+                               method_ident: ident,\n+                               type_ident: ident,\n+                               junction: Junction)\n+                            -> @method {\n+    let self_ident = cx.ident_of(~\"self\");\n+    let other_ident = cx.ident_of(~\"__other\");\n+\n+    let _binop = junction.to_binop();\n+\n+    let is_eq;\n+    match junction {\n+        Conjunction => is_eq = true,\n+        Disjunction => is_eq = false,\n+    }\n+\n+    // Create the arms of the self match in the method body.\n+    let self_arms = dvec::DVec();\n+    for enum_definition.variants.each |self_variant| {\n+        let other_arms = dvec::DVec();\n+        let self_variant_ident = self_variant.node.name;\n+\n+        // Create the matching pattern.\n+        let matching_pat = build::mk_pat_ident(cx, span, self_variant_ident);\n+\n+        // Create the matching pattern body.\n+        let matching_body_expr = build::mk_bool(cx, span, is_eq);\n+        let matching_body_block = build::mk_simple_block(cx,\n+                                                         span,\n+                                                         matching_body_expr);\n+\n+        // Create the matching arm.\n+        let matching_arm = {\n+            pats: ~[ matching_pat ],\n+            guard: None,\n+            body: move matching_body_block\n+        };\n+        other_arms.push(move matching_arm);\n+\n+        // Create the nonmatching pattern.\n+        let nonmatching_pat = @{\n+            id: cx.next_id(),\n+            node: pat_wild,\n+            span: span\n+        };\n+\n+        // Create the nonmatching pattern body.\n+        let nonmatching_expr = build::mk_bool(cx, span, !is_eq);\n+        let nonmatching_body_block = build::mk_simple_block(cx,\n+                                                            span,\n+                                                            nonmatching_expr);\n+\n+        // Create the nonmatching arm.\n+        let nonmatching_arm = {\n+            pats: ~[ nonmatching_pat ],\n+            guard: None,\n+            body: move nonmatching_body_block\n+        };\n+        other_arms.push(move nonmatching_arm);\n+\n+        // Create the self pattern.\n+        let self_pat = build::mk_pat_ident(cx, span, self_variant_ident);\n+\n+        // Create the self pattern body.\n+        let other_expr = build::mk_path(cx, span, ~[ other_ident ]);\n+        let other_expr = build::mk_unary(cx, span, deref, other_expr);\n+        let other_arms = dvec::unwrap(move other_arms);\n+        let other_match_expr = expr_match(other_expr, move other_arms);\n+        let other_match_expr = build::mk_expr(cx,\n+                                              span,\n+                                              move other_match_expr);\n+        let other_match_body_block = build::mk_simple_block(cx,\n+                                                            span,\n+                                                            other_match_expr);\n+\n+        // Create the self arm.\n+        let self_arm = {\n+            pats: ~[ self_pat ],\n+            guard: None,\n+            body: move other_match_body_block\n+        };\n+        self_arms.push(move self_arm);\n+    }\n+\n+    // Create the method body.\n+    let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n+    let self_expr = build::mk_unary(cx, span, deref, self_expr);\n+    let self_arms = dvec::unwrap(move self_arms);\n+    let self_match_expr = expr_match(self_expr, move self_arms);\n+    let self_match_expr = build::mk_expr(cx, span, move self_match_expr);\n+\n+    // Create the method.\n+    return create_method(cx, span, method_ident, type_ident, self_match_expr);\n+}\n+"}, {"sha": "2837e8fc64ff3f68b6b65c19ca335048c6828b96", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7aecc46a517c4cac0a63ffcdb2e87ebff77e281/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a7aecc46a517c4cac0a63ffcdb2e87ebff77e281/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=a7aecc46a517c4cac0a63ffcdb2e87ebff77e281", "patch": "@@ -103,6 +103,7 @@ mod ext {\n     mod qquote;\n \n     mod quote;\n+    mod deriving;\n \n     #[legacy_exports]\n     mod build;"}, {"sha": "54df7d847984330a394efbe0cc107b0b5b25f0c8", "filename": "src/test/run-pass/deriving-via-extension-c-enum.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a7aecc46a517c4cac0a63ffcdb2e87ebff77e281/src%2Ftest%2Frun-pass%2Fderiving-via-extension-c-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7aecc46a517c4cac0a63ffcdb2e87ebff77e281/src%2Ftest%2Frun-pass%2Fderiving-via-extension-c-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-c-enum.rs?ref=a7aecc46a517c4cac0a63ffcdb2e87ebff77e281", "patch": "@@ -0,0 +1,16 @@\n+#[deriving_eq]\n+enum Foo {\n+    Bar,\n+    Baz,\n+    Boo\n+}\n+\n+fn main() {\n+    let a = Bar;\n+    let b = Bar;\n+    assert a == b;\n+    assert !(a != b);\n+    assert a.eq(&b);\n+    assert !a.ne(&b);\n+}\n+"}, {"sha": "169fad63376efaf3f710964200f8eedb8fe27952", "filename": "src/test/run-pass/deriving-via-extension-struct.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a7aecc46a517c4cac0a63ffcdb2e87ebff77e281/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7aecc46a517c4cac0a63ffcdb2e87ebff77e281/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct.rs?ref=a7aecc46a517c4cac0a63ffcdb2e87ebff77e281", "patch": "@@ -0,0 +1,16 @@\n+#[deriving_eq]\n+struct Foo {\n+    x: int,\n+    y: int,\n+    z: int,\n+}\n+\n+fn main() {\n+    let a = Foo { x: 1, y: 2, z: 3 };\n+    let b = Foo { x: 1, y: 2, z: 3 };\n+    assert a == b;\n+    assert !(a != b);\n+    assert a.eq(&b);\n+    assert !a.ne(&b);\n+}\n+"}]}