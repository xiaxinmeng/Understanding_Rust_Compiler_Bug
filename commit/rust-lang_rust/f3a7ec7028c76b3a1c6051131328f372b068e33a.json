{"sha": "f3a7ec7028c76b3a1c6051131328f372b068e33a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzYTdlYzcwMjhjNzZiM2ExYzYwNTExMzEzMjhmMzcyYjA2OGUzM2E=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-29T23:03:01Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-02T06:02:59Z"}, "message": "std: Second pass stabilization of sync\n\nThis pass performs a second pass of stabilization through the `std::sync`\nmodule, avoiding modules/types that are being handled in other PRs (e.g.\nmutexes, rwlocks, condvars, and channels).\n\nThe following items are now stable\n\n* `sync::atomic`\n* `sync::atomic::ATOMIC_BOOL_INIT` (was `INIT_ATOMIC_BOOL`)\n* `sync::atomic::ATOMIC_INT_INIT` (was `INIT_ATOMIC_INT`)\n* `sync::atomic::ATOMIC_UINT_INIT` (was `INIT_ATOMIC_UINT`)\n* `sync::Once`\n* `sync::ONCE_INIT`\n* `sync::Once::call_once` (was `doit`)\n  * C == `pthread_once(..)`\n  * Boost == `call_once(..)`\n  * Windows == `InitOnceExecuteOnce`\n* `sync::Barrier`\n* `sync::Barrier::new`\n* `sync::Barrier::wait` (now returns a `bool`)\n* `sync::Semaphore::new`\n* `sync::Semaphore::acquire`\n* `sync::Semaphore::release`\n\nThe following items remain unstable\n\n* `sync::SemaphoreGuard`\n* `sync::Semaphore::access` - it's unclear how this relates to the poisoning\n                              story of mutexes.\n* `sync::TaskPool` - the semantics of a failing task and whether a thread is\n                     re-attached to a thread pool are somewhat unclear, and the\n                     utility of this type in `sync` is question with respect to\n                     the jobs of other primitives. This type will likely become\n                     stable or move out of the standard library over time.\n* `sync::Future` - futures as-is have yet to be deeply re-evaluated with the\n                   recent core changes to Rust's synchronization story, and will\n                   likely become stable in the future but are unstable until\n                   that time comes.\n\n[breaking-change]", "tree": {"sha": "dce13e4152a6d9d988042c4be77720d14dcc62c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dce13e4152a6d9d988042c4be77720d14dcc62c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3a7ec7028c76b3a1c6051131328f372b068e33a", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3a7ec7028c76b3a1c6051131328f372b068e33a", "html_url": "https://github.com/rust-lang/rust/commit/f3a7ec7028c76b3a1c6051131328f372b068e33a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3a7ec7028c76b3a1c6051131328f372b068e33a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd614164e692cca3a1460737f581fcb6d4630baf", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd614164e692cca3a1460737f581fcb6d4630baf", "html_url": "https://github.com/rust-lang/rust/commit/cd614164e692cca3a1460737f581fcb6d4630baf"}], "stats": {"total": 405, "additions": 168, "deletions": 237}, "files": [{"sha": "8eb13187e5841b8d1595ca846b0d9606be8c2ef8", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -206,6 +206,7 @@ getting the result later.\n The basic example below illustrates this.\n \n ```{rust,ignore}\n+# #![allow(deprecated)]\n use std::sync::Future;\n \n # fn main() {\n@@ -233,6 +234,7 @@ Here is another example showing how futures allow you to background\n computations. The workload will be distributed on the available cores.\n \n ```{rust,ignore}\n+# #![allow(deprecated)]\n # use std::num::Float;\n # use std::sync::Future;\n fn partial_sum(start: uint) -> f64 {"}, {"sha": "552ac31d0380887935b2f1afa845e394432b6c55", "filename": "src/doc/guide.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -5312,6 +5312,7 @@ example, if you wish to compute some value in the background, `Future` is\n a useful thing to use:\n \n ```{rust}\n+# #![allow(deprecated)]\n use std::sync::Future;\n \n let mut delayed_value = Future::spawn(move || {"}, {"sha": "0ce7c30d197aa3cbaac93a8b2dbc06a67978f731", "filename": "src/doc/reference.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -1480,9 +1480,9 @@ data are being stored, or single-address and mutability properties are required.\n ```\n use std::sync::atomic;\n \n-// Note that INIT_ATOMIC_UINT is a *const*, but it may be used to initialize a\n+// Note that ATOMIC_UINT_INIT is a *const*, but it may be used to initialize a\n // static. This static can be modified, so it is not placed in read-only memory.\n-static COUNTER: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+static COUNTER: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n \n // This table is a candidate to be placed in read-only memory.\n static TABLE: &'static [uint] = &[1, 2, 3, /* ... */];"}, {"sha": "02a627c42ac6f774c798d4e9970583984a60253b", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -2263,7 +2263,7 @@ mod tests {\n             }\n         }\n         const NUM_ELEMENTS: uint = 2;\n-        static DROP_COUNTER: AtomicUint = atomic::INIT_ATOMIC_UINT;\n+        static DROP_COUNTER: AtomicUint = atomic::ATOMIC_UINT_INIT;\n \n         let v = Vec::from_elem(NUM_ELEMENTS, Nothing);\n "}, {"sha": "f653998c9bf5d471db0b65a7856614ee9634da7a", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -89,17 +89,27 @@ pub enum Ordering {\n \n /// An `AtomicBool` initialized to `false`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n-pub const INIT_ATOMIC_BOOL: AtomicBool =\n+pub const ATOMIC_BOOL_INIT: AtomicBool =\n         AtomicBool { v: UnsafeCell { value: 0 } };\n /// An `AtomicInt` initialized to `0`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n-pub const INIT_ATOMIC_INT: AtomicInt =\n+pub const ATOMIC_INT_INIT: AtomicInt =\n         AtomicInt { v: UnsafeCell { value: 0 } };\n /// An `AtomicUint` initialized to `0`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n-pub const INIT_ATOMIC_UINT: AtomicUint =\n+pub const ATOMIC_UINT_INIT: AtomicUint =\n         AtomicUint { v: UnsafeCell { value: 0, } };\n \n+/// Deprecated\n+#[deprecated = \"renamed to ATOMIC_BOOL_INIT\"]\n+pub const INIT_ATOMIC_BOOL: AtomicBool = ATOMIC_BOOL_INIT;\n+/// Deprecated\n+#[deprecated = \"renamed to ATOMIC_INT_INIT\"]\n+pub const INIT_ATOMIC_INT: AtomicInt = ATOMIC_INT_INIT;\n+/// Deprecated\n+#[deprecated = \"renamed to ATOMIC_UINT_INIT\"]\n+pub const INIT_ATOMIC_UINT: AtomicUint = ATOMIC_UINT_INIT;\n+\n // NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n const UINT_TRUE: uint = -1;\n "}, {"sha": "94e9441abc8b658ba33a76c38699a1fb1e944c7e", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -155,6 +155,8 @@\n // FIXME: Can't be shared between threads. Dynamic borrows\n // FIXME: Relationship to Atomic types and RWLock\n \n+#![stable]\n+\n use clone::Clone;\n use cmp::PartialEq;\n use default::Default;"}, {"sha": "f8e943ec9f651a9bef01e5e5c2388dc6b24beabb", "filename": "src/libcoretest/atomic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibcoretest%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibcoretest%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fatomic.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -70,9 +70,9 @@ fn int_xor() {\n     assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n }\n \n-static S_BOOL : AtomicBool = INIT_ATOMIC_BOOL;\n-static S_INT  : AtomicInt  = INIT_ATOMIC_INT;\n-static S_UINT : AtomicUint = INIT_ATOMIC_UINT;\n+static S_BOOL : AtomicBool = ATOMIC_BOOL_INIT;\n+static S_INT  : AtomicInt  = ATOMIC_INT_INIT;\n+static S_UINT : AtomicUint = ATOMIC_UINT_INIT;\n \n #[test]\n fn static_init() {"}, {"sha": "4ee5b2d5e834991db0dcde74e74ceef76a1d92f2", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -352,7 +352,7 @@ pub struct LogLocation {\n #[doc(hidden)]\n pub fn mod_enabled(level: u32, module: &str) -> bool {\n     static INIT: Once = ONCE_INIT;\n-    INIT.doit(init);\n+    INIT.call_once(init);\n \n     // It's possible for many threads are in this function, only one of them\n     // will perform the global initialization, but all of them will need to check"}, {"sha": "b6020fe5ce38bf3d142ff2b826ac408914e6235c", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -73,7 +73,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n     let output_path = {\n         let output_template = match requested_output {\n             Some(ref s) if s.as_slice() == \"help\" => {\n-                static PRINTED_YET : atomic::AtomicBool = atomic::INIT_ATOMIC_BOOL;\n+                static PRINTED_YET : atomic::AtomicBool = atomic::ATOMIC_BOOL_INIT;\n                 if !PRINTED_YET.load(atomic::SeqCst) {\n                     print_help_message();\n                     PRINTED_YET.store(true, atomic::SeqCst);"}, {"sha": "f2242b72aae321a098d919210d51b6fcfee7415e", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -1009,7 +1009,7 @@ unsafe fn configure_llvm(sess: &Session) {\n         }\n     }\n \n-    INIT.doit(|| {\n+    INIT.call_once(|| {\n         llvm::LLVMInitializePasses();\n \n         // Only initialize the platforms supported by Rust here, because"}, {"sha": "18a3ce2ab729c9163d22e8caed851729547db607", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -3097,7 +3097,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n         use std::sync::{Once, ONCE_INIT};\n         static INIT: Once = ONCE_INIT;\n         static mut POISONED: bool = false;\n-        INIT.doit(|| {\n+        INIT.call_once(|| {\n             if llvm::LLVMStartMultithreaded() != 1 {\n                 // use an extra bool to make sure that all future usage of LLVM\n                 // cannot proceed despite the Once not running more than once."}, {"sha": "a529901272358604752c43e9d73e86fe907d5142", "filename": "src/libstd/comm/blocking.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fcomm%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fcomm%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fblocking.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -11,7 +11,7 @@\n //! Generic support for building blocking abstractions.\n \n use thread::Thread;\n-use sync::atomic::{AtomicBool, INIT_ATOMIC_BOOL, Ordering};\n+use sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT, Ordering};\n use sync::Arc;\n use kinds::{Sync, Send};\n use kinds::marker::{NoSend, NoSync};\n@@ -40,7 +40,7 @@ pub struct WaitToken {\n pub fn tokens() -> (WaitToken, SignalToken) {\n     let inner = Arc::new(Inner {\n         thread: Thread::current(),\n-        woken: INIT_ATOMIC_BOOL,\n+        woken: ATOMIC_BOOL_INIT,\n     });\n     let wait_token = WaitToken {\n         inner: inner.clone(),"}, {"sha": "aa05c65ce76cbb367c05f8be632f3782a34e7717", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -22,7 +22,6 @@ use result::Result::{Ok, Err};\n use slice::{SliceExt};\n use slice;\n use vec::Vec;\n-use kinds::{Send,Sync};\n \n /// Wraps a Reader and buffers input from it\n ///\n@@ -52,11 +51,6 @@ pub struct BufferedReader<R> {\n     cap: uint,\n }\n \n-\n-unsafe impl<R: Send> Send for BufferedReader<R> {}\n-unsafe impl<R: Send+Sync> Sync for BufferedReader<R> {}\n-\n-\n impl<R: Reader> BufferedReader<R> {\n     /// Creates a new `BufferedReader` with the specified buffer capacity\n     pub fn with_capacity(cap: uint, inner: R) -> BufferedReader<R> {"}, {"sha": "c76d68a01bedc410e1b67bae91cc7e6bd8c2939d", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -218,7 +218,7 @@ pub fn stdin() -> StdinReader {\n     static ONCE: Once = ONCE_INIT;\n \n     unsafe {\n-        ONCE.doit(|| {\n+        ONCE.call_once(|| {\n             // The default buffer capacity is 64k, but apparently windows doesn't like\n             // 64k reads on stdin. See #13304 for details, but the idea is that on\n             // windows we use a slightly smaller buffer that's been seen to be"}, {"sha": "5cf8667665162ebf34b84e81cd75eaba3b919bab", "filename": "src/libstd/io/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fio%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fio%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftempfile.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -90,7 +90,7 @@ impl TempDir {\n             return TempDir::new_in(&abs_tmpdir, suffix);\n         }\n \n-        static CNT: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+        static CNT: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n \n         let mut attempts = 0u;\n         loop {"}, {"sha": "3055359538bac82f4bfdb1ad4ec21ad7fa2ecc0d", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -16,17 +16,17 @@ use libc;\n use os;\n use prelude::*;\n use std::io::net::ip::*;\n-use sync::atomic::{AtomicUint, INIT_ATOMIC_UINT, Relaxed};\n+use sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Relaxed};\n \n /// Get a port number, starting at 9600, for use in tests\n pub fn next_test_port() -> u16 {\n-    static NEXT_OFFSET: AtomicUint = INIT_ATOMIC_UINT;\n+    static NEXT_OFFSET: AtomicUint = ATOMIC_UINT_INIT;\n     base_port() + NEXT_OFFSET.fetch_add(1, Relaxed) as u16\n }\n \n /// Get a temporary path which could be the location of a unix socket\n pub fn next_test_unix() -> Path {\n-    static COUNT: AtomicUint = INIT_ATOMIC_UINT;\n+    static COUNT: AtomicUint = ATOMIC_UINT_INIT;\n     // base port and pid are an attempt to be unique between multiple\n     // test-runners of different configurations running on one\n     // buildbot, the count is to be unique within this executable."}, {"sha": "e470ee3cb4b0c3d310a4871e1e32584f61754eaf", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -55,7 +55,7 @@ use slice::{AsSlice, SliceExt};\n use slice::CloneSliceExt;\n use str::{Str, StrExt};\n use string::{String, ToString};\n-use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n+use sync::atomic::{AtomicInt, ATOMIC_INT_INIT, SeqCst};\n use vec::Vec;\n \n #[cfg(unix)] use c_str::ToCStr;\n@@ -596,7 +596,7 @@ pub fn last_os_error() -> String {\n     error_string(errno() as uint)\n }\n \n-static EXIT_STATUS: AtomicInt = INIT_ATOMIC_INT;\n+static EXIT_STATUS: AtomicInt = ATOMIC_INT_INIT;\n \n /// Sets the process exit code\n ///"}, {"sha": "46b9fe9657cea22c7a20a59084f4b7abd1c686f7", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -84,10 +84,10 @@ mod imp {\n     #[cfg(all(target_os = \"linux\",\n               any(target_arch = \"x86_64\", target_arch = \"x86\", target_arch = \"arm\")))]\n     fn is_getrandom_available() -> bool {\n-        use sync::atomic::{AtomicBool, INIT_ATOMIC_BOOL, Relaxed};\n+        use sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT, Relaxed};\n \n-        static GETRANDOM_CHECKED: AtomicBool = INIT_ATOMIC_BOOL;\n-        static GETRANDOM_AVAILABLE: AtomicBool = INIT_ATOMIC_BOOL;\n+        static GETRANDOM_CHECKED: AtomicBool = ATOMIC_BOOL_INIT;\n+        static GETRANDOM_AVAILABLE: AtomicBool = ATOMIC_BOOL_INIT;\n \n         if !GETRANDOM_CHECKED.load(Relaxed) {\n             let mut buf: [u8; 0] = [];"}, {"sha": "0b69486129aa69a7e3e3f61c4cd5e0f9d3b3cfb8", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -22,7 +22,7 @@ pub use sys::backtrace::write;\n // For now logging is turned off by default, and this function checks to see\n // whether the magical environment variable is present to see if it's turned on.\n pub fn log_enabled() -> bool {\n-    static ENABLED: atomic::AtomicInt = atomic::INIT_ATOMIC_INT;\n+    static ENABLED: atomic::AtomicInt = atomic::ATOMIC_INT_INIT;\n     match ENABLED.load(atomic::SeqCst) {\n         1 => return false,\n         2 => return true,"}, {"sha": "88bdb29caecadc94b7e386cd02979ed039fee701", "filename": "src/libstd/rt/exclusive.rs", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/cd614164e692cca3a1460737f581fcb6d4630baf/src%2Flibstd%2Frt%2Fexclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd614164e692cca3a1460737f581fcb6d4630baf/src%2Flibstd%2Frt%2Fexclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fexclusive.rs?ref=cd614164e692cca3a1460737f581fcb6d4630baf", "patch": "@@ -1,119 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use core::prelude::*;\n-\n-use cell::UnsafeCell;\n-use rt::mutex;\n-\n-/// An OS mutex over some data.\n-///\n-/// This is not a safe primitive to use, it is unaware of the libgreen\n-/// scheduler, as well as being easily susceptible to misuse due to the usage of\n-/// the inner NativeMutex.\n-///\n-/// > **Note**: This type is not recommended for general use. The mutex provided\n-/// >           as part of `libsync` should almost always be favored.\n-pub struct Exclusive<T> {\n-    lock: mutex::NativeMutex,\n-    data: UnsafeCell<T>,\n-}\n-\n-unsafe impl<T:Send> Send for Exclusive<T> { }\n-\n-unsafe impl<T:Send> Sync for Exclusive<T> { }\n-\n-/// An RAII guard returned via `lock`\n-pub struct ExclusiveGuard<'a, T:'a> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _data: &'a mut T,\n-    _guard: mutex::LockGuard<'a>,\n-}\n-\n-impl<T: Send> Exclusive<T> {\n-    /// Creates a new `Exclusive` which will protect the data provided.\n-    pub fn new(user_data: T) -> Exclusive<T> {\n-        Exclusive {\n-            lock: unsafe { mutex::NativeMutex::new() },\n-            data: UnsafeCell::new(user_data),\n-        }\n-    }\n-\n-    /// Acquires this lock, returning a guard which the data is accessed through\n-    /// and from which that lock will be unlocked.\n-    ///\n-    /// This method is unsafe due to many of the same reasons that the\n-    /// NativeMutex itself is unsafe.\n-    pub unsafe fn lock<'a>(&'a self) -> ExclusiveGuard<'a, T> {\n-        let guard = self.lock.lock();\n-        let data = &mut *self.data.get();\n-\n-        ExclusiveGuard {\n-            _data: data,\n-            _guard: guard,\n-        }\n-    }\n-}\n-\n-impl<'a, T: Send> ExclusiveGuard<'a, T> {\n-    // The unsafety here should be ok because our loan guarantees that the lock\n-    // itself is not moving\n-    pub fn signal(&self) {\n-        unsafe { self._guard.signal() }\n-    }\n-    pub fn wait(&self) {\n-        unsafe { self._guard.wait() }\n-    }\n-}\n-\n-impl<'a, T: Send> Deref<T> for ExclusiveGuard<'a, T> {\n-    fn deref(&self) -> &T { &*self._data }\n-}\n-impl<'a, T: Send> DerefMut<T> for ExclusiveGuard<'a, T> {\n-    fn deref_mut(&mut self) -> &mut T { &mut *self._data }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use sync::Arc;\n-    use super::Exclusive;\n-    use task;\n-\n-    #[test]\n-    fn exclusive_new_arc() {\n-        unsafe {\n-            let mut futures = Vec::new();\n-\n-            let num_tasks = 10;\n-            let count = 10;\n-\n-            let total = Arc::new(Exclusive::new(box 0));\n-\n-            for _ in range(0u, num_tasks) {\n-                let total = total.clone();\n-                let (tx, rx) = channel();\n-                futures.push(rx);\n-\n-                task::spawn(move || {\n-                    for _ in range(0u, count) {\n-                        **total.lock() += 1;\n-                    }\n-                    tx.send(());\n-                });\n-            };\n-\n-            for f in futures.iter_mut() { f.recv() }\n-\n-            assert_eq!(**total.lock(), num_tasks * count);\n-        }\n-    }\n-}"}, {"sha": "a6063d0b609b70d09f3f89fe88253ceb07724bd0", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -84,15 +84,15 @@ pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: uint);\n // For more information, see below.\n const MAX_CALLBACKS: uint = 16;\n static CALLBACKS: [atomic::AtomicUint; MAX_CALLBACKS] =\n-        [atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT,\n-         atomic::INIT_ATOMIC_UINT, atomic::INIT_ATOMIC_UINT];\n-static CALLBACK_CNT: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+        [atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT,\n+         atomic::ATOMIC_UINT_INIT, atomic::ATOMIC_UINT_INIT];\n+static CALLBACK_CNT: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n \n thread_local! { static PANICKING: Cell<bool> = Cell::new(false) }\n \n@@ -544,7 +544,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n     // Make sure the default failure handler is registered before we look at the\n     // callbacks.\n     static INIT: Once = ONCE_INIT;\n-    INIT.doit(|| unsafe { register(failure::on_fail); });\n+    INIT.call_once(|| unsafe { register(failure::on_fail); });\n \n     // First, invoke call the user-defined callbacks triggered on thread panic.\n     //"}, {"sha": "d66d8d52be9fad3fdc00ebd19e19c462647778b8", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -47,7 +47,7 @@ pub fn limit_thread_creation_due_to_osx_and_valgrind() -> bool {\n }\n \n pub fn min_stack() -> uint {\n-    static MIN: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+    static MIN: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n     match MIN.load(atomic::SeqCst) {\n         0 => {}\n         n => return n - 1,"}, {"sha": "71eae8ac8afa2533e286f0d2d0c2d85bf0b0cd8b", "filename": "src/libstd/sync/atomic.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomic.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -86,22 +86,23 @@\n //! Keep a global count of live tasks:\n //!\n //! ```\n-//! use std::sync::atomic::{AtomicUint, SeqCst, INIT_ATOMIC_UINT};\n+//! use std::sync::atomic::{AtomicUint, SeqCst, ATOMIC_UINT_INIT};\n //!\n-//! static GLOBAL_TASK_COUNT: AtomicUint = INIT_ATOMIC_UINT;\n+//! static GLOBAL_TASK_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n //!\n //! let old_task_count = GLOBAL_TASK_COUNT.fetch_add(1, SeqCst);\n //! println!(\"live tasks: {}\", old_task_count + 1);\n //! ```\n \n-#![allow(deprecated)]\n+#![stable]\n \n use alloc::boxed::Box;\n use core::mem;\n use core::prelude::{Send, Drop, None, Option, Some};\n \n pub use core::atomic::{AtomicBool, AtomicInt, AtomicUint, AtomicPtr};\n pub use core::atomic::{INIT_ATOMIC_BOOL, INIT_ATOMIC_INT, INIT_ATOMIC_UINT};\n+pub use core::atomic::{ATOMIC_BOOL_INIT, ATOMIC_INT_INIT, ATOMIC_UINT_INIT};\n pub use core::atomic::fence;\n pub use core::atomic::Ordering::{mod, Relaxed, Release, Acquire, AcqRel, SeqCst};\n \n@@ -116,6 +117,7 @@ pub struct AtomicOption<T> {\n     p: AtomicUint,\n }\n \n+#[allow(deprecated)]\n impl<T: Send> AtomicOption<T> {\n     /// Create a new `AtomicOption`\n     pub fn new(p: Box<T>) -> AtomicOption<T> {"}, {"sha": "6dc37cdadbe1a14f4328ed68af1a9aaf7e3201a9", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use kinds::{Send, Sync};\n use sync::{Mutex, Condvar};\n \n /// A barrier enables multiple tasks to synchronize the beginning\n@@ -30,29 +29,32 @@ use sync::{Mutex, Condvar};\n ///     }).detach();\n /// }\n /// ```\n+#[stable]\n pub struct Barrier {\n     lock: Mutex<BarrierState>,\n     cvar: Condvar,\n     num_threads: uint,\n }\n \n-unsafe impl Send for Barrier {}\n-unsafe impl Sync for Barrier {}\n-\n // The inner state of a double barrier\n struct BarrierState {\n     count: uint,\n     generation_id: uint,\n }\n \n-unsafe impl Send for BarrierState {}\n-unsafe impl Sync for BarrierState {}\n+/// A result returned from wait.\n+///\n+/// Currently this opaque structure only has one method, `.is_leader()`. Only\n+/// one thread will receive a result that will return `true` from this function.\n+#[allow(missing_copy_implementations)]\n+pub struct BarrierWaitResult(bool);\n \n impl Barrier {\n     /// Create a new barrier that can block a given number of threads.\n     ///\n     /// A barrier will block `n`-1 threads which call `wait` and then wake up\n     /// all threads at once when the `n`th thread calls `wait`.\n+    #[stable]\n     pub fn new(n: uint) -> Barrier {\n         Barrier {\n             lock: Mutex::new(BarrierState {\n@@ -68,7 +70,13 @@ impl Barrier {\n     ///\n     /// Barriers are re-usable after all threads have rendezvoused once, and can\n     /// be used continuously.\n-    pub fn wait(&self) {\n+    ///\n+    /// A single (arbitrary) thread will receive a `BarrierWaitResult` that\n+    /// returns `true` from `is_leader` when returning from this function, and\n+    /// all other threads will receive a result that will return `false` from\n+    /// `is_leader`\n+    #[stable]\n+    pub fn wait(&self) -> BarrierWaitResult {\n         let mut lock = self.lock.lock().unwrap();\n         let local_gen = lock.generation_id;\n         lock.count += 1;\n@@ -79,32 +87,44 @@ impl Barrier {\n                   lock.count < self.num_threads {\n                 lock = self.cvar.wait(lock).unwrap();\n             }\n+            BarrierWaitResult(false)\n         } else {\n             lock.count = 0;\n             lock.generation_id += 1;\n             self.cvar.notify_all();\n+            BarrierWaitResult(true)\n         }\n     }\n }\n \n+impl BarrierWaitResult {\n+    /// Return whether this thread from `wait` is the \"leader thread\".\n+    ///\n+    /// Only one thread will have `true` returned from their result, all other\n+    /// threads will have `false` returned.\n+    #[stable]\n+    pub fn is_leader(&self) -> bool { self.0 }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n \n-    use sync::{Arc, Barrier};\n     use comm::Empty;\n+    use sync::{Arc, Barrier};\n \n     #[test]\n     fn test_barrier() {\n-        let barrier = Arc::new(Barrier::new(10));\n+        const N: uint = 10;\n+\n+        let barrier = Arc::new(Barrier::new(N));\n         let (tx, rx) = channel();\n \n-        for _ in range(0u, 9) {\n+        for _ in range(0u, N - 1) {\n             let c = barrier.clone();\n             let tx = tx.clone();\n             spawn(move|| {\n-                c.wait();\n-                tx.send(true);\n+                tx.send(c.wait().is_leader());\n             });\n         }\n \n@@ -115,10 +135,15 @@ mod tests {\n             _ => false,\n         });\n \n-        barrier.wait();\n+        let mut leader_found = barrier.wait().is_leader();\n+\n         // Now, the barrier is cleared and we should get data.\n-        for _ in range(0u, 9) {\n-            rx.recv();\n+        for _ in range(0u, N - 1) {\n+            if rx.recv() {\n+                assert!(!leader_found);\n+                leader_found = true;\n+            }\n         }\n+        assert!(leader_found);\n     }\n }"}, {"sha": "79a7af7454d6a256f0efc3efd6a041278235d56e", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -88,7 +88,7 @@ unsafe impl Sync for StaticCondvar {}\n #[unstable = \"may be merged with Condvar in the future\"]\n pub const CONDVAR_INIT: StaticCondvar = StaticCondvar {\n     inner: sys::CONDVAR_INIT,\n-    mutex: atomic::INIT_ATOMIC_UINT,\n+    mutex: atomic::ATOMIC_UINT_INIT,\n };\n \n impl Condvar {"}, {"sha": "c952d13ef043da1bb0ea210e92fd7fa7c0a2e778", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A type representing values that may be computed concurrently and operations for working with\n-//! them.\n+//! A type representing values that may be computed concurrently and operations\n+//! for working with them.\n //!\n //! # Example\n //!\n@@ -23,6 +23,9 @@\n //! ```\n \n #![allow(missing_docs)]\n+#![unstable = \"futures as-is have yet to be deeply reevaluated with recent \\\n+               core changes to Rust's synchronization story, and will likely \\\n+               become stable in the future but are unstable until that time\"]\n \n use core::prelude::*;\n use core::mem::replace;"}, {"sha": "de455d8a6c6f5b0fe7bddd2baa7ac53c430a0198", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -26,7 +26,7 @@ pub use self::rwlock::{RWLockReadGuard, RWLockWriteGuard};\n pub use self::condvar::{Condvar, StaticCondvar, CONDVAR_INIT};\n pub use self::once::{Once, ONCE_INIT};\n pub use self::semaphore::{Semaphore, SemaphoreGuard};\n-pub use self::barrier::Barrier;\n+pub use self::barrier::{Barrier, BarrierWaitResult};\n pub use self::poison::{PoisonError, TryLockError, TryLockResult, LockResult};\n \n pub use self::future::Future;"}, {"sha": "e9e3e79812abc4c08dd62f4754ea3840479660e6", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -32,10 +32,11 @@ use sync::{StaticMutex, MUTEX_INIT};\n ///\n /// static START: Once = ONCE_INIT;\n ///\n-/// START.doit(|| {\n+/// START.call_once(|| {\n ///     // run initialization here\n /// });\n /// ```\n+#[stable]\n pub struct Once {\n     mutex: StaticMutex,\n     cnt: atomic::AtomicInt,\n@@ -45,23 +46,25 @@ pub struct Once {\n unsafe impl Sync for Once {}\n \n /// Initialization value for static `Once` values.\n+#[stable]\n pub const ONCE_INIT: Once = Once {\n     mutex: MUTEX_INIT,\n-    cnt: atomic::INIT_ATOMIC_INT,\n-    lock_cnt: atomic::INIT_ATOMIC_INT,\n+    cnt: atomic::ATOMIC_INT_INIT,\n+    lock_cnt: atomic::ATOMIC_INT_INIT,\n };\n \n impl Once {\n     /// Perform an initialization routine once and only once. The given closure\n-    /// will be executed if this is the first time `doit` has been called, and\n-    /// otherwise the routine will *not* be invoked.\n+    /// will be executed if this is the first time `call_once` has been called,\n+    /// and otherwise the routine will *not* be invoked.\n     ///\n     /// This method will block the calling task if another initialization\n     /// routine is currently running.\n     ///\n     /// When this function returns, it is guaranteed that some initialization\n     /// has run and completed (it may not be the closure specified).\n-    pub fn doit<F>(&'static self, f: F) where F: FnOnce() {\n+    #[stable]\n+    pub fn call_once<F>(&'static self, f: F) where F: FnOnce() {\n         // Optimize common path: load is much cheaper than fetch_add.\n         if self.cnt.load(atomic::SeqCst) < 0 {\n             return\n@@ -91,13 +94,13 @@ impl Once {\n         //\n         // It is crucial that the negative value is swapped in *after* the\n         // initialization routine has completed because otherwise new threads\n-        // calling `doit` will return immediately before the initialization has\n-        // completed.\n+        // calling `call_once` will return immediately before the initialization\n+        // has completed.\n \n         let prev = self.cnt.fetch_add(1, atomic::SeqCst);\n         if prev < 0 {\n             // Make sure we never overflow, we'll never have int::MIN\n-            // simultaneous calls to `doit` to make this value go back to 0\n+            // simultaneous calls to `call_once` to make this value go back to 0\n             self.cnt.store(int::MIN, atomic::SeqCst);\n             return\n         }\n@@ -118,6 +121,10 @@ impl Once {\n             unsafe { self.mutex.destroy() }\n         }\n     }\n+\n+    /// Deprecated\n+    #[deprecated = \"renamed to `call_once`\"]\n+    pub fn doit<F>(&'static self, f: F) where F: FnOnce() { self.call_once(f) }\n }\n \n #[cfg(test)]\n@@ -131,9 +138,9 @@ mod test {\n     fn smoke_once() {\n         static O: Once = ONCE_INIT;\n         let mut a = 0i;\n-        O.doit(|| a += 1);\n+        O.call_once(|| a += 1);\n         assert_eq!(a, 1);\n-        O.doit(|| a += 1);\n+        O.call_once(|| a += 1);\n         assert_eq!(a, 1);\n     }\n \n@@ -148,7 +155,7 @@ mod test {\n             spawn(move|| {\n                 for _ in range(0u, 4) { Thread::yield_now() }\n                 unsafe {\n-                    O.doit(|| {\n+                    O.call_once(|| {\n                         assert!(!run);\n                         run = true;\n                     });\n@@ -159,7 +166,7 @@ mod test {\n         }\n \n         unsafe {\n-            O.doit(|| {\n+            O.call_once(|| {\n                 assert!(!run);\n                 run = true;\n             });"}, {"sha": "bd86e5d0ed25dbe1b9a40ca611b5a21de34be1bc", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![unstable = \"the interaction between semaphores and the acquisition/release \\\n+               of resources is currently unclear\"]\n+\n use ops::Drop;\n use sync::{Mutex, Condvar};\n "}, {"sha": "632ad49e952078f6d85f8e357564b8e8c7e91b34", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -10,6 +10,11 @@\n \n //! Abstraction of a thread pool for basic parallelism.\n \n+#![unstable = \"the semantics of a failing task and whether a thread is \\\n+               re-attached to a thread pool are somewhat unclear, and the \\\n+               utility of this type in `std::sync` is questionable with \\\n+               respect to the jobs of other primitives\"]\n+\n use core::prelude::*;\n \n use thread::Thread;"}, {"sha": "597790af83c9600efef1d3e6c1777dfba9b11a55", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -137,7 +137,7 @@ pub const INIT: StaticKey = StaticKey {\n ///\n /// This value allows specific configuration of the destructor for a TLS key.\n pub const INIT_INNER: StaticKeyInner = StaticKeyInner {\n-    key: atomic::INIT_ATOMIC_UINT,\n+    key: atomic::ATOMIC_UINT_INIT,\n };\n \n static INIT_KEYS: Once = ONCE_INIT;"}, {"sha": "0ccf130af6ea7064e763fd6bca1a462034365868", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -18,7 +18,7 @@ use io::{IoError, IoResult};\n use libc::{mod, c_int, c_char, c_void};\n use path::BytesContainer;\n use ptr;\n-use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n+use sync::atomic::{AtomicInt, SeqCst};\n use sys::fs::FileDesc;\n use os;\n "}, {"sha": "1e1b95ee96c480c41743d07f77cb262a3f3f3b1c", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -8,13 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::*;\n+\n use alloc::arc::Arc;\n use libc;\n use c_str::CString;\n use mem;\n use sync::{atomic, Mutex};\n use io::{mod, IoResult, IoError};\n-use prelude::*;\n \n use sys::{mod, timer, retry, c, set_nonblocking, wouldblock};\n use sys::fs::{fd_t, FileDesc};\n@@ -117,9 +118,6 @@ pub struct UnixStream {\n     write_deadline: u64,\n }\n \n-unsafe impl Send for UnixStream {}\n-unsafe impl Sync for UnixStream {}\n-\n impl UnixStream {\n     pub fn connect(addr: &CString,\n                    timeout: Option<u64>) -> IoResult<UnixStream> {\n@@ -218,6 +216,7 @@ pub struct UnixListener {\n     path: CString,\n }\n \n+// we currently own the CString, so these impls should be safe\n unsafe impl Send for UnixListener {}\n unsafe impl Sync for UnixListener {}\n \n@@ -265,9 +264,6 @@ struct AcceptorInner {\n     closed: atomic::AtomicBool,\n }\n \n-unsafe impl Send for AcceptorInner {}\n-unsafe impl Sync for AcceptorInner {}\n-\n impl UnixAcceptor {\n     pub fn fd(&self) -> fd_t { self.inner.listener.fd() }\n "}, {"sha": "25216c35b6580dffd62e7189c8e7166dc5199abb", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -211,7 +211,7 @@ impl Timer {\n         // instead of ()\n         HELPER.boot(|| {}, helper);\n \n-        static ID: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+        static ID: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n         let id = ID.fetch_add(1, atomic::Relaxed);\n         Ok(Timer {\n             id: id,"}, {"sha": "88313d661737fe974f4ee7b775a1a34d53711e98", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -171,7 +171,7 @@ pub fn init_net() {\n     unsafe {\n         static START: Once = ONCE_INIT;\n \n-        START.doit(|| {\n+        START.call_once(|| {\n             let mut data: c::WSADATA = mem::zeroed();\n             let ret = c::WSAStartup(0x202, // version 2.2\n                                     &mut data);"}, {"sha": "5f65b429d869e628e7db90874aa9451f032f5078", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -20,7 +20,7 @@ const SPIN_COUNT: DWORD = 4000;\n \n pub struct Mutex { inner: atomic::AtomicUint }\n \n-pub const MUTEX_INIT: Mutex = Mutex { inner: atomic::INIT_ATOMIC_UINT };\n+pub const MUTEX_INIT: Mutex = Mutex { inner: atomic::ATOMIC_UINT_INIT };\n \n unsafe impl Sync for Mutex {}\n "}, {"sha": "d6c94f27a8baf9462dea4a451861ad329956d37b", "filename": "src/libstd/time/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Ftime%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibstd%2Ftime%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fmod.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -45,7 +45,7 @@ fn precise_time_ns() -> u64 {\n                                                                                    denom: 0 };\n         static ONCE: sync::Once = sync::ONCE_INIT;\n         unsafe {\n-            ONCE.doit(|| {\n+            ONCE.call_once(|| {\n                 imp::mach_timebase_info(&mut TIMEBASE);\n             });\n             let time = imp::mach_absolute_time();"}, {"sha": "2cf4c15606916d2c4a9a66f28bb9bc787062c452", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -198,7 +198,7 @@ pub fn precise_time_ns() -> u64 {\n                                                                                    denom: 0 };\n         static ONCE: std::sync::Once = std::sync::ONCE_INIT;\n         unsafe {\n-            ONCE.doit(|| {\n+            ONCE.call_once(|| {\n                 imp::mach_timebase_info(&mut TIMEBASE);\n             });\n             let time = imp::mach_absolute_time();"}, {"sha": "689610d799ec065d979858c998df04ce60a473d5", "filename": "src/test/auxiliary/issue-17718.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Ftest%2Fauxiliary%2Fissue-17718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Ftest%2Fauxiliary%2Fissue-17718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-17718.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -11,12 +11,12 @@\n use std::sync::atomic;\n \n pub const C1: uint = 1;\n-pub const C2: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+pub const C2: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n pub const C3: fn() = foo;\n pub const C4: uint = C1 * C1 + C1 / C1;\n pub const C5: &'static uint = &C4;\n \n pub static S1: uint = 3;\n-pub static S2: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+pub static S2: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n \n fn foo() {}"}, {"sha": "236e1cbb217352385246cecd807bdc73b65368b5", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -41,7 +41,7 @@\n extern crate arena;\n \n use std::iter::range_step;\n-use std::sync::Future;\n+use std::thread::Thread;\n use arena::TypedArena;\n \n enum Tree<'a> {\n@@ -95,7 +95,7 @@ fn main() {\n     let mut messages = range_step(min_depth, max_depth + 1, 2).map(|depth| {\n             use std::num::Int;\n             let iterations = 2i.pow((max_depth - depth + min_depth) as uint);\n-            Future::spawn(move|| {\n+            Thread::spawn(move|| {\n                 let mut chk = 0;\n                 for i in range(1, iterations + 1) {\n                     let arena = TypedArena::new();\n@@ -106,10 +106,10 @@ fn main() {\n                 format!(\"{}\\t trees of depth {}\\t check: {}\",\n                         iterations * 2, depth, chk)\n             })\n-        }).collect::<Vec<Future<String>>>();\n+        }).collect::<Vec<_>>();\n \n-    for message in messages.iter_mut() {\n-        println!(\"{}\", *message.get_ref());\n+    for message in messages.into_iter() {\n+        println!(\"{}\", message.join().ok().unwrap());\n     }\n \n     println!(\"long lived tree of depth {}\\t check: {}\","}, {"sha": "8e594b861803f57be4811fd10c9353577598231e", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -41,7 +41,7 @@\n #![feature(slicing_syntax)]\n \n use std::{cmp, iter, mem};\n-use std::sync::Future;\n+use std::thread::Thread;\n \n fn rotate(x: &mut [i32]) {\n     let mut prev = x[0];\n@@ -168,15 +168,15 @@ fn fannkuch(n: i32) -> (i32, i32) {\n     for (i, j) in range(0, N).zip(iter::count(0, k)) {\n         let max = cmp::min(j+k, perm.max());\n \n-        futures.push(Future::spawn(move|| {\n+        futures.push(Thread::spawn(move|| {\n             work(perm, j as uint, max as uint)\n         }))\n     }\n \n     let mut checksum = 0;\n     let mut maxflips = 0;\n-    for fut in futures.iter_mut() {\n-        let (cs, mf) = fut.get();\n+    for fut in futures.into_iter() {\n+        let (cs, mf) = fut.join().ok().unwrap();\n         checksum += cs;\n         maxflips = cmp::max(maxflips, mf);\n     }"}, {"sha": "501187ca9e5435257bb62a0ee9ba426146d68b9f", "filename": "src/test/compile-fail/std-uncopyable-atomics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -16,11 +16,11 @@ use std::sync::atomic::*;\n use std::ptr;\n \n fn main() {\n-    let x = INIT_ATOMIC_BOOL;\n+    let x = ATOMIC_BOOL_INIT;\n     let x = *&x; //~ ERROR: cannot move out of dereference\n-    let x = INIT_ATOMIC_INT;\n+    let x = ATOMIC_INT_INIT;\n     let x = *&x; //~ ERROR: cannot move out of dereference\n-    let x = INIT_ATOMIC_UINT;\n+    let x = ATOMIC_UINT_INIT;\n     let x = *&x; //~ ERROR: cannot move out of dereference\n     let x: AtomicPtr<uint> = AtomicPtr::new(ptr::null_mut());\n     let x = *&x; //~ ERROR: cannot move out of dereference"}, {"sha": "10ad0f620e9f3076442ba870abae2fb60a0ac573", "filename": "src/test/run-pass/issue-17718.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Ftest%2Frun-pass%2Fissue-17718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Ftest%2Frun-pass%2Fissue-17718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17718.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -15,7 +15,7 @@ extern crate \"issue-17718\" as other;\n use std::sync::atomic;\n \n const C1: uint = 1;\n-const C2: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+const C2: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n const C3: fn() = foo;\n const C4: uint = C1 * C1 + C1 / C1;\n const C5: &'static uint = &C4;\n@@ -25,7 +25,7 @@ const C6: uint = {\n };\n \n static S1: uint = 3;\n-static S2: atomic::AtomicUint = atomic::INIT_ATOMIC_UINT;\n+static S2: atomic::AtomicUint = atomic::ATOMIC_UINT_INIT;\n \n mod test {\n     static A: uint = 4;"}, {"sha": "c5f5cd2c3aab58dde727d58fc8157b5642235e53", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a7ec7028c76b3a1c6051131328f372b068e33a/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=f3a7ec7028c76b3a1c6051131328f372b068e33a", "patch": "@@ -9,26 +9,26 @@\n // except according to those terms.\n \n use std::task;\n-use std::sync::atomic::{AtomicUint, INIT_ATOMIC_UINT, Relaxed};\n+use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Relaxed};\n use std::rand::{thread_rng, Rng, Rand};\n \n const REPEATS: uint = 5;\n const MAX_LEN: uint = 32;\n static drop_counts: [AtomicUint;  MAX_LEN] =\n     // FIXME #5244: AtomicUint is not Copy.\n     [\n-        INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT,\n-        INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT,\n-        INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT,\n-        INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT,\n+        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n+        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n+        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n+        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n \n-        INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT,\n-        INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT,\n-        INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT,\n-        INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT, INIT_ATOMIC_UINT,\n+        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n+        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n+        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n+        ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT, ATOMIC_UINT_INIT,\n      ];\n \n-static creation_count: AtomicUint = INIT_ATOMIC_UINT;\n+static creation_count: AtomicUint = ATOMIC_UINT_INIT;\n \n #[deriving(Clone, PartialEq, PartialOrd, Eq, Ord)]\n struct DropCounter { x: uint, creation_id: uint }"}]}