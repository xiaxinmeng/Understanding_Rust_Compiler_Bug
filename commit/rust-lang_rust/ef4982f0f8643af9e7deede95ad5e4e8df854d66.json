{"sha": "ef4982f0f8643af9e7deede95ad5e4e8df854d66", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNDk4MmYwZjg2NDNhZjllN2RlZWRlOTVhZDVlNGU4ZGY4NTRkNjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-09T14:02:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-09T14:02:45Z"}, "message": "auto merge of #19466 : nikomatsakis/rust/recursion-limit, r=eddyb\n\nThis is particularly important for deeply nested types, which generate deeply nested impls. This is a fix for #19318. It's possible we could also improve this particular case not to increment the recursion count, but it's worth being able to adjust the recursion limit anyhow.\r\n\r\ncc @jdm \r\nr? @pcwalton", "tree": {"sha": "ed63942aeef2d2e9e2b8378751695b19f7e9f25e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed63942aeef2d2e9e2b8378751695b19f7e9f25e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef4982f0f8643af9e7deede95ad5e4e8df854d66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef4982f0f8643af9e7deede95ad5e4e8df854d66", "html_url": "https://github.com/rust-lang/rust/commit/ef4982f0f8643af9e7deede95ad5e4e8df854d66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef4982f0f8643af9e7deede95ad5e4e8df854d66/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cafe2966770ff377aad6dd9fd808e68055587c58", "url": "https://api.github.com/repos/rust-lang/rust/commits/cafe2966770ff377aad6dd9fd808e68055587c58", "html_url": "https://github.com/rust-lang/rust/commit/cafe2966770ff377aad6dd9fd808e68055587c58"}, {"sha": "34812b891db7a699cebddb584e6c6ae44f82ed2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/34812b891db7a699cebddb584e6c6ae44f82ed2e", "html_url": "https://github.com/rust-lang/rust/commit/34812b891db7a699cebddb584e6c6ae44f82ed2e"}], "stats": {"total": 420, "additions": 126, "deletions": 294}, "files": [{"sha": "2af6a4876299b69ba043106133179764f06d39ad", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef4982f0f8643af9e7deede95ad5e4e8df854d66/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4982f0f8643af9e7deede95ad5e4e8df854d66/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=ef4982f0f8643af9e7deede95ad5e4e8df854d66", "patch": "@@ -88,6 +88,7 @@ pub mod middle {\n     pub mod privacy;\n     pub mod reachable;\n     pub mod region;\n+    pub mod recursion_limit;\n     pub mod resolve;\n     pub mod resolve_lifetime;\n     pub mod stability;"}, {"sha": "a6a6703353cd1ca12911f72ea3b6fb101eab43c8", "filename": "src/librustc/middle/recursion_limit.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ef4982f0f8643af9e7deede95ad5e4e8df854d66/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4982f0f8643af9e7deede95ad5e4e8df854d66/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=ef4982f0f8643af9e7deede95ad5e4e8df854d66", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Recursion limit.\n+//\n+// There are various parts of the compiler that must impose arbitrary limits\n+// on how deeply they recurse to prevent stack overflow. Users can override\n+// this via an attribute on the crate like `#![recursion_limit(22)]`. This pass\n+// just peeks and looks for that attribute.\n+\n+use session::Session;\n+use syntax::ast;\n+use syntax::attr::AttrMetaMethods;\n+use std::str::FromStr;\n+\n+pub fn update_recursion_limit(sess: &Session, krate: &ast::Crate) {\n+    for attr in krate.attrs.iter() {\n+        if !attr.check_name(\"recursion_limit\") {\n+            continue;\n+        }\n+\n+        if let Some(s) = attr.value_str() {\n+            if let Some(n) = FromStr::from_str(s.get()) {\n+                sess.recursion_limit.set(n);\n+                return;\n+            }\n+        }\n+\n+        sess.span_err(attr.span, \"malformed recursion limit attribute, \\\n+                                  expected #![recursion_limit(\\\"N\\\")]\");\n+    }\n+}"}, {"sha": "06f8cbf1a6a60e88b02770b4c24d879580b0541c", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 20, "deletions": 292, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/ef4982f0f8643af9e7deede95ad5e4e8df854d66/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4982f0f8643af9e7deede95ad5e4e8df854d66/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=ef4982f0f8643af9e7deede95ad5e4e8df854d66", "patch": "@@ -158,10 +158,10 @@ enum BuiltinBoundConditions<'tcx> {\n }\n \n #[deriving(Show)]\n-enum EvaluationResult {\n+enum EvaluationResult<'tcx> {\n     EvaluatedToOk,\n-    EvaluatedToErr,\n     EvaluatedToAmbig,\n+    EvaluatedToErr(SelectionError<'tcx>),\n }\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n@@ -275,7 +275,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                               bound: ty::BuiltinBound,\n                                               previous_stack: &ObligationStack<'o, 'tcx>,\n                                               ty: Ty<'tcx>)\n-                                              -> EvaluationResult\n+                                              -> EvaluationResult<'tcx>\n     {\n         let obligation =\n             util::obligation_for_builtin_bound(\n@@ -298,7 +298,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn evaluate_obligation_recursively<'o>(&mut self,\n                                            previous_stack: Option<&ObligationStack<'o, 'tcx>>,\n                                            obligation: &Obligation<'tcx>)\n-                                           -> EvaluationResult\n+                                           -> EvaluationResult<'tcx>\n     {\n         debug!(\"evaluate_obligation_recursively({})\",\n                obligation.repr(self.tcx()));\n@@ -313,7 +313,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn evaluate_stack<'o>(&mut self,\n                           stack: &ObligationStack<'o, 'tcx>)\n-                          -> EvaluationResult\n+                          -> EvaluationResult<'tcx>\n     {\n         // In intercrate mode, whenever any of the types are unbound,\n         // there can always be an impl. Even if there are no impls in\n@@ -384,7 +384,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.candidate_from_obligation(stack) {\n             Ok(Some(c)) => self.winnow_candidate(stack, &c),\n             Ok(None) => EvaluatedToAmbig,\n-            Err(_) => EvaluatedToErr,\n+            Err(e) => EvaluatedToErr(e),\n         }\n     }\n \n@@ -415,285 +415,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         })\n     }\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    // METHOD MATCHING\n-    //\n-    // Method matching is a variation on the normal select/evaluation\n-    // situation.  In this scenario, rather than having a full trait\n-    // reference to select from, we start with an expression like\n-    // `receiver.method(...)`. This means that we have `rcvr_ty`, the\n-    // type of the receiver, and we have a possible trait that\n-    // supplies `method`. We must determine whether the receiver is\n-    // applicable, taking into account the transformed self type\n-    // declared on `method`. We also must consider the possibility\n-    // that `receiver` can be *coerced* into a suitable type (for\n-    // example, a receiver type like `&(Any+Send)` might be coerced\n-    // into a receiver like `&Any` to allow for method dispatch).  See\n-    // the body of `evaluate_method_obligation()` for more details on\n-    // the algorithm.\n-\n-    /// Determine whether a trait-method is applicable to a receiver of\n-    /// type `rcvr_ty`. *Does not affect the inference state.*\n-    ///\n-    /// - `rcvr_ty` -- type of the receiver\n-    /// - `xform_self_ty` -- transformed self type declared on the method, with `Self`\n-    ///   to a fresh type variable\n-    /// - `obligation` -- a reference to the trait where the method is declared, with\n-    ///   the input types on the trait replaced with fresh type variables\n-    pub fn evaluate_method_obligation(&mut self,\n-                                      rcvr_ty: Ty<'tcx>,\n-                                      xform_self_ty: Ty<'tcx>,\n-                                      obligation: &Obligation<'tcx>)\n-                                      -> MethodMatchResult\n-    {\n-        // Here is the situation. We have a trait method declared (say) like so:\n-        //\n-        //     trait TheTrait {\n-        //         fn the_method(self: Rc<Self>, ...) { ... }\n-        //     }\n-        //\n-        // And then we have a call looking (say) like this:\n-        //\n-        //     let x: Rc<Foo> = ...;\n-        //     x.the_method()\n-        //\n-        // Now we want to decide if `TheTrait` is applicable. As a\n-        // human, we can see that `TheTrait` is applicable if there is\n-        // an impl for the type `Foo`. But how does the compiler know\n-        // what impl to look for, given that our receiver has type\n-        // `Rc<Foo>`? We need to take the method's self type into\n-        // account.\n-        //\n-        // On entry to this function, we have the following inputs:\n-        //\n-        // - `rcvr_ty = Rc<Foo>`\n-        // - `xform_self_ty = Rc<$0>`\n-        // - `obligation = $0 as TheTrait`\n-        //\n-        // We do the match in two phases. The first is a *precise\n-        // match*, which means that no coercion is required. This is\n-        // the preferred way to match. It works by first making\n-        // `rcvr_ty` a subtype of `xform_self_ty`. This unifies `$0`\n-        // and `Foo`. We can then evaluate (roughly as normal) the\n-        // trait reference `Foo as TheTrait`.\n-        //\n-        // If this fails, we fallback to a coercive match, described below.\n-\n-        match self.infcx.probe(|| self.match_method_precise(rcvr_ty, xform_self_ty, obligation)) {\n-            Ok(()) => { return MethodMatched(PreciseMethodMatch); }\n-            Err(_) => { }\n-        }\n-\n-        // Coercive matches work slightly differently and cannot\n-        // completely reuse the normal trait matching machinery\n-        // (though they employ many of the same bits and pieces). To\n-        // see how it works, let's continue with our previous example,\n-        // but with the following declarations:\n-        //\n-        // ```\n-        // trait Foo : Bar { .. }\n-        // trait Bar : Baz { ... }\n-        // trait Baz { ... }\n-        // impl TheTrait for Bar {\n-        //     fn the_method(self: Rc<Bar>, ...) { ... }\n-        // }\n-        // ```\n-        //\n-        // Now we see that the receiver type `Rc<Foo>` is actually an\n-        // object type. And in fact the impl we want is an impl on the\n-        // supertrait `Rc<Bar>`.  The precise matching procedure won't\n-        // find it, however, because `Rc<Foo>` is not a subtype of\n-        // `Rc<Bar>` -- it is *coercible* to `Rc<Bar>` (actually, such\n-        // coercions are not yet implemented, but let's leave that\n-        // aside for now).\n-        //\n-        // To handle this case, we employ a different procedure. Recall\n-        // that our initial state is as follows:\n-        //\n-        // - `rcvr_ty = Rc<Foo>`\n-        // - `xform_self_ty = Rc<$0>`\n-        // - `obligation = $0 as TheTrait`\n-        //\n-        // We now go through each impl and instantiate all of its type\n-        // variables, yielding the trait reference that the impl\n-        // provides. In our example, the impl would provide `Bar as\n-        // TheTrait`.  Next we (try to) unify the trait reference that\n-        // the impl provides with the input obligation. This would\n-        // unify `$0` and `Bar`. Now we can see whether the receiver\n-        // type (`Rc<Foo>`) is *coercible to* the transformed self\n-        // type (`Rc<$0> == Rc<Bar>`). In this case, the answer is\n-        // yes, so the impl is considered a candidate.\n-        //\n-        // Note that there is the possibility of ambiguity here, even\n-        // when all types are known. In our example, this might occur\n-        // if there was *also* an impl of `TheTrait` for `Baz`. In\n-        // this case, `Rc<Foo>` would be coercible to both `Rc<Bar>`\n-        // and `Rc<Baz>`. (Note that it is not a *coherence violation*\n-        // to have impls for both `Bar` and `Baz`, despite this\n-        // ambiguity).  In this case, we report an error, listing all\n-        // the applicable impls.  The user can explicitly \"up-coerce\"\n-        // to the type they want.\n-        //\n-        // Note that this coercion step only considers actual impls\n-        // found in the source. This is because all the\n-        // compiler-provided impls (such as those for unboxed\n-        // closures) do not have relevant coercions. This simplifies\n-        // life immensely.\n-\n-        let mut impls =\n-            self.assemble_method_candidates_from_impls(rcvr_ty, xform_self_ty, obligation);\n-\n-        if impls.len() > 1 {\n-            impls.retain(|&c| self.winnow_method_impl(c, rcvr_ty, xform_self_ty, obligation));\n-        }\n-\n-        if impls.len() > 1 {\n-            return MethodAmbiguous(impls);\n-        }\n-\n-        match impls.pop() {\n-            Some(def_id) => MethodMatched(CoerciveMethodMatch(def_id)),\n-            None => MethodDidNotMatch\n-        }\n-    }\n-\n-    /// Given the successful result of a method match, this function \"confirms\" the result, which\n-    /// basically repeats the various matching operations, but outside of any snapshot so that\n-    /// their effects are committed into the inference state.\n-    pub fn confirm_method_match(&mut self,\n-                                rcvr_ty: Ty<'tcx>,\n-                                xform_self_ty: Ty<'tcx>,\n-                                obligation: &Obligation<'tcx>,\n-                                data: MethodMatchedData)\n-    {\n-        let is_ok = match data {\n-            PreciseMethodMatch => {\n-                self.match_method_precise(rcvr_ty, xform_self_ty, obligation).is_ok()\n-            }\n-\n-            CoerciveMethodMatch(impl_def_id) => {\n-                self.match_method_coerce(impl_def_id, rcvr_ty, xform_self_ty, obligation).is_ok()\n-            }\n-        };\n-\n-        if !is_ok {\n-            self.tcx().sess.span_bug(\n-                obligation.cause.span,\n-                format!(\"match not repeatable: {}, {}, {}, {}\",\n-                        rcvr_ty.repr(self.tcx()),\n-                        xform_self_ty.repr(self.tcx()),\n-                        obligation.repr(self.tcx()),\n-                        data)[]);\n-        }\n-    }\n-\n-    /// Implements the *precise method match* procedure described in\n-    /// `evaluate_method_obligation()`.\n-    fn match_method_precise(&mut self,\n-                            rcvr_ty: Ty<'tcx>,\n-                            xform_self_ty: Ty<'tcx>,\n-                            obligation: &Obligation<'tcx>)\n-                            -> Result<(),()>\n-    {\n-        self.infcx.commit_if_ok(|| {\n-            match self.infcx.sub_types(false, infer::RelateSelfType(obligation.cause.span),\n-                                       rcvr_ty, xform_self_ty) {\n-                Ok(()) => { }\n-                Err(_) => { return Err(()); }\n-            }\n-\n-            if self.evaluate_obligation(obligation) {\n-                Ok(())\n-            } else {\n-                Err(())\n-            }\n-        })\n-    }\n-\n-    /// Assembles a list of potentially applicable impls using the *coercive match* procedure\n-    /// described in `evaluate_method_obligation()`.\n-    fn assemble_method_candidates_from_impls(&mut self,\n-                                             rcvr_ty: Ty<'tcx>,\n-                                             xform_self_ty: Ty<'tcx>,\n-                                             obligation: &Obligation<'tcx>)\n-                                             -> Vec<ast::DefId>\n-    {\n-        let mut candidates = Vec::new();\n-\n-        let all_impls = self.all_impls(obligation.trait_ref.def_id);\n-        for &impl_def_id in all_impls.iter() {\n-            self.infcx.probe(|| {\n-                match self.match_method_coerce(impl_def_id, rcvr_ty, xform_self_ty, obligation) {\n-                    Ok(_) => { candidates.push(impl_def_id); }\n-                    Err(_) => { }\n-                }\n-            });\n-        }\n-\n-        candidates\n-    }\n-\n-    /// Applies the *coercive match* procedure described in `evaluate_method_obligation()` to a\n-    /// particular impl.\n-    fn match_method_coerce(&mut self,\n-                           impl_def_id: ast::DefId,\n-                           rcvr_ty: Ty<'tcx>,\n-                           xform_self_ty: Ty<'tcx>,\n-                           obligation: &Obligation<'tcx>)\n-                           -> Result<Substs<'tcx>, ()>\n-    {\n-        // This is almost always expected to succeed. It\n-        // causes the impl's self-type etc to be unified with\n-        // the type variable that is shared between\n-        // obligation/xform_self_ty. In our example, after\n-        // this is done, the type of `xform_self_ty` would\n-        // change from `Rc<$0>` to `Rc<Foo>` (because $0 is\n-        // unified with `Foo`).\n-        let substs = try!(self.match_impl(impl_def_id, obligation));\n-\n-        // Next, check whether we can coerce. For now we require\n-        // that the coercion be a no-op.\n-        let origin = infer::Misc(obligation.cause.span);\n-        match infer::mk_coercety(self.infcx, true, origin,\n-                                 rcvr_ty, xform_self_ty) {\n-            Ok(None) => { /* Fallthrough */ }\n-            Ok(Some(_)) | Err(_) => { return Err(()); }\n-        }\n-\n-        Ok(substs)\n-    }\n-\n-    /// A version of `winnow_impl` applicable to coerice method matching.  This is basically the\n-    /// same as `winnow_impl` but it uses the method matching procedure and is specific to impls.\n-    fn winnow_method_impl(&mut self,\n-                          impl_def_id: ast::DefId,\n-                          rcvr_ty: Ty<'tcx>,\n-                          xform_self_ty: Ty<'tcx>,\n-                          obligation: &Obligation<'tcx>)\n-                          -> bool\n-    {\n-        debug!(\"winnow_method_impl: impl_def_id={} rcvr_ty={} xform_self_ty={} obligation={}\",\n-               impl_def_id.repr(self.tcx()),\n-               rcvr_ty.repr(self.tcx()),\n-               xform_self_ty.repr(self.tcx()),\n-               obligation.repr(self.tcx()));\n-\n-        self.infcx.probe(|| {\n-            match self.match_method_coerce(impl_def_id, rcvr_ty, xform_self_ty, obligation) {\n-                Ok(substs) => {\n-                    let vtable_impl = self.vtable_impl(impl_def_id,\n-                                                       substs,\n-                                                       obligation.cause,\n-                                                       obligation.recursion_depth + 1);\n-                    self.winnow_selection(None, VtableImpl(vtable_impl)).may_apply()\n-                }\n-                Err(()) => {\n-                    false\n-                }\n-            }\n-        })\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // CANDIDATE ASSEMBLY\n     //\n@@ -1112,27 +833,27 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn winnow_candidate<'o>(&mut self,\n                             stack: &ObligationStack<'o, 'tcx>,\n                             candidate: &Candidate<'tcx>)\n-                            -> EvaluationResult\n+                            -> EvaluationResult<'tcx>\n     {\n         debug!(\"winnow_candidate: candidate={}\", candidate.repr(self.tcx()));\n         self.infcx.probe(|| {\n             let candidate = (*candidate).clone();\n             match self.confirm_candidate(stack.obligation, candidate) {\n                 Ok(selection) => self.winnow_selection(Some(stack), selection),\n-                Err(_) => EvaluatedToErr,\n+                Err(error) => EvaluatedToErr(error),\n             }\n         })\n     }\n \n     fn winnow_selection<'o>(&mut self,\n                             stack: Option<&ObligationStack<'o, 'tcx>>,\n                             selection: Selection<'tcx>)\n-                            -> EvaluationResult\n+                            -> EvaluationResult<'tcx>\n     {\n         let mut result = EvaluatedToOk;\n         for obligation in selection.iter_nested() {\n             match self.evaluate_obligation_recursively(stack, obligation) {\n-                EvaluatedToErr => { return EvaluatedToErr; }\n+                EvaluatedToErr(e) => { return EvaluatedToErr(e); }\n                 EvaluatedToAmbig => { result = EvaluatedToAmbig; }\n                 EvaluatedToOk => { }\n             }\n@@ -2146,11 +1867,18 @@ impl<'o, 'tcx> Repr<'tcx> for ObligationStack<'o, 'tcx> {\n     }\n }\n \n-impl EvaluationResult {\n+impl<'tcx> EvaluationResult<'tcx> {\n     fn may_apply(&self) -> bool {\n         match *self {\n-            EvaluatedToOk | EvaluatedToAmbig => true,\n-            EvaluatedToErr => false,\n+            EvaluatedToOk |\n+            EvaluatedToAmbig |\n+            EvaluatedToErr(Overflow) |\n+            EvaluatedToErr(OutputTypeParameterMismatch(..)) => {\n+                true\n+            }\n+            EvaluatedToErr(Unimplemented) => {\n+                false\n+            }\n         }\n     }\n }"}, {"sha": "749bed15e38e05cc05a4c293d35f667327f1fed3", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef4982f0f8643af9e7deede95ad5e4e8df854d66/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4982f0f8643af9e7deede95ad5e4e8df854d66/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=ef4982f0f8643af9e7deede95ad5e4e8df854d66", "patch": "@@ -180,6 +180,10 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         *sess.features.borrow_mut() = features;\n     });\n \n+    time(time_passes, \"recursion limit\", (), |_| {\n+        middle::recursion_limit::update_recursion_limit(sess, &krate);\n+    });\n+\n     // strip before expansion to allow macros to depend on\n     // configuration variables e.g/ in\n     //"}, {"sha": "80363055a4bf0ea6206dc7bde15a49063dbc9bdb", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef4982f0f8643af9e7deede95ad5e4e8df854d66/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4982f0f8643af9e7deede95ad5e4e8df854d66/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=ef4982f0f8643af9e7deede95ad5e4e8df854d66", "patch": "@@ -366,6 +366,15 @@ pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     \"overflow evaluating the trait `{}` for the type `{}`\",\n                     trait_ref.user_string(fcx.tcx()),\n                     self_ty.user_string(fcx.tcx())).as_slice());\n+\n+            let current_limit = fcx.tcx().sess.recursion_limit.get();\n+            let suggested_limit = current_limit * 2;\n+            fcx.tcx().sess.span_note(\n+                obligation.cause.span,\n+                format!(\n+                    \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n+                    suggested_limit)[]);\n+\n             note_obligation_cause(fcx, obligation);\n         }\n         Unimplemented => {"}, {"sha": "17afb168a9839a284ba75e4c3e908f5733bcf9e7", "filename": "src/test/compile-fail/recursion_limit.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ef4982f0f8643af9e7deede95ad5e4e8df854d66/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4982f0f8643af9e7deede95ad5e4e8df854d66/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs?ref=ef4982f0f8643af9e7deede95ad5e4e8df854d66", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the recursion limit can be changed. In this case, we have\n+// deeply nested types that will fail the `Send` check by overflow\n+// when the recursion limit is set very low.\n+\n+#![feature(macro_rules)]\n+#![allow(dead_code)]\n+#![recursion_limit=\"10\"]\n+\n+macro_rules! link {\n+    ($id:ident, $t:ty) => {\n+        enum $id { $id($t) }\n+    }\n+}\n+\n+link!(A,B)\n+link!(B,C)\n+link!(C,D)\n+link!(D,E)\n+link!(E,F)\n+link!(F,G)\n+link!(G,H)\n+link!(H,I)\n+link!(I,J)\n+link!(J,K)\n+link!(K,L)\n+link!(L,M)\n+link!(M,N)\n+\n+enum N { N(uint) }\n+\n+fn is_send<T:Send>() { }\n+\n+fn main() {\n+    is_send::<A>();\n+    //~^ ERROR overflow evaluating\n+    //~^^ NOTE consider adding a `#![recursion_limit=\"20\"]` attribute to your crate\n+    //~^^^ NOTE must be implemented\n+    //~^^^^ ERROR overflow evaluating\n+    //~^^^^^ NOTE consider adding a `#![recursion_limit=\"20\"]` attribute to your crate\n+    //~^^^^^^ NOTE must be implemented\n+}"}, {"sha": "b3528f7abe71927f0c8284dae48340f0d1347bb6", "filename": "src/test/compile-fail/unboxed-closures-type-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef4982f0f8643af9e7deede95ad5e4e8df854d66/src%2Ftest%2Fcompile-fail%2Funboxed-closures-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4982f0f8643af9e7deede95ad5e4e8df854d66/src%2Ftest%2Fcompile-fail%2Funboxed-closures-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-type-mismatch.rs?ref=ef4982f0f8643af9e7deede95ad5e4e8df854d66", "patch": "@@ -14,6 +14,6 @@ use std::ops::FnMut;\n \n pub fn main() {\n     let mut f = |&mut: x: int, y: int| -> int { x + y };\n-    let z = f.call_mut((1u, 2));    //~ ERROR not implemented\n+    let z = f.call_mut((1u, 2));    //~ ERROR type mismatch\n     println!(\"{}\", z);\n }"}, {"sha": "a96bde7cca4cdcb06ce12c1140709b7b9aa22e32", "filename": "src/test/compile-fail/unboxed-closures-vtable-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef4982f0f8643af9e7deede95ad5e4e8df854d66/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4982f0f8643af9e7deede95ad5e4e8df854d66/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs?ref=ef4982f0f8643af9e7deede95ad5e4e8df854d66", "patch": "@@ -18,7 +18,7 @@ fn call_it<F:FnMut<(int,int),int>>(y: int, mut f: F) -> int {\n \n pub fn main() {\n     let f = |&mut: x: uint, y: int| -> int { (x as int) + y };\n-    let z = call_it(3, f);  //~ ERROR not implemented\n+    let z = call_it(3, f);  //~ ERROR type mismatch\n     println!(\"{}\", z);\n }\n "}]}