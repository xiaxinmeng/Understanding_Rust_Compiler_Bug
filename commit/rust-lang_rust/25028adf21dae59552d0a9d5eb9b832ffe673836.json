{"sha": "25028adf21dae59552d0a9d5eb9b832ffe673836", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1MDI4YWRmMjFkYWU1OTU1MmQwYTlkNWViOWI4MzJmZmU2NzM4MzY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-21T11:12:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-21T11:12:13Z"}, "message": "Rollup merge of #71854 - eduardosm:assoc-char-funcs-and-consts, r=Amanieu\n\nMake `std::char` functions and constants associated to `char`.\n\nFirst step to fix https://github.com/rust-lang/rust/issues/71763.", "tree": {"sha": "e0511c828dde73178d3f6f7cf0f0e7f172bd9601", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0511c828dde73178d3f6f7cf0f0e7f172bd9601"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25028adf21dae59552d0a9d5eb9b832ffe673836", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJexmINCRBK7hj4Ov3rIwAAdHIIAEHVhLnPT0jCAS/YP5cS077R\n0cwcvMXurVMJQTK/+hl/iilKxWuSB46zF/lk5OQIskSgnMzfa3kuecVRLyah6tfs\n4EudPZtZWmohylW3ErRrqWNqkYU2dhnyMg3Z2K85ja+xFfociRoHWuav3H6pavPw\nPRWz+OwYvxUC+JX8un3jjb8x9eYjIsct+yTtgEBHCHBlTKYhULaKmpR9/0w5lLIf\nwkHmSfG5g5tTTPKYFv9LvwZAi1m0Ogpp2ir6GfiKrgrf4ss8E5EtPDnhwdBtYaMM\n6uayz3BEdt9fztd8B9OmqFkVHUZ2sM7KGqYCFmwivwwy4oc6gx8XZe57vPgAfPs=\n=LTlH\n-----END PGP SIGNATURE-----\n", "payload": "tree e0511c828dde73178d3f6f7cf0f0e7f172bd9601\nparent 7f79e98c0356642db62e5113327e436c951e843d\nparent 0e12a9d9ac6f69ddd72f2c028f668c0b55ac2eda\nauthor Ralf Jung <post@ralfj.de> 1590059533 +0200\ncommitter GitHub <noreply@github.com> 1590059533 +0200\n\nRollup merge of #71854 - eduardosm:assoc-char-funcs-and-consts, r=Amanieu\n\nMake `std::char` functions and constants associated to `char`.\n\nFirst step to fix https://github.com/rust-lang/rust/issues/71763.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25028adf21dae59552d0a9d5eb9b832ffe673836", "html_url": "https://github.com/rust-lang/rust/commit/25028adf21dae59552d0a9d5eb9b832ffe673836", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25028adf21dae59552d0a9d5eb9b832ffe673836/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f79e98c0356642db62e5113327e436c951e843d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f79e98c0356642db62e5113327e436c951e843d", "html_url": "https://github.com/rust-lang/rust/commit/7f79e98c0356642db62e5113327e436c951e843d"}, {"sha": "0e12a9d9ac6f69ddd72f2c028f668c0b55ac2eda", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e12a9d9ac6f69ddd72f2c028f668c0b55ac2eda", "html_url": "https://github.com/rust-lang/rust/commit/0e12a9d9ac6f69ddd72f2c028f668c0b55ac2eda"}], "stats": {"total": 241, "additions": 239, "deletions": 2}, "files": [{"sha": "35fae778437fa4289e7f672e62832441057efc50", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/25028adf21dae59552d0a9d5eb9b832ffe673836/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25028adf21dae59552d0a9d5eb9b832ffe673836/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=25028adf21dae59552d0a9d5eb9b832ffe673836", "patch": "@@ -9,6 +9,243 @@ use super::*;\n \n #[lang = \"char\"]\n impl char {\n+    /// The highest valid code point a `char` can have.\n+    ///\n+    /// A `char` is a [Unicode Scalar Value], which means that it is a [Code\n+    /// Point], but only ones within a certain range. `MAX` is the highest valid\n+    /// code point that's a valid [Unicode Scalar Value].\n+    ///\n+    /// [Unicode Scalar Value]: http://www.unicode.org/glossary/#unicode_scalar_value\n+    /// [Code Point]: http://www.unicode.org/glossary/#code_point\n+    #[unstable(feature = \"assoc_char_consts\", reason = \"recently added\", issue = \"71763\")]\n+    pub const MAX: char = '\\u{10ffff}';\n+\n+    /// `U+FFFD REPLACEMENT CHARACTER` (\ufffd) is used in Unicode to represent a\n+    /// decoding error.\n+    ///\n+    /// It can occur, for example, when giving ill-formed UTF-8 bytes to\n+    /// [`String::from_utf8_lossy`](string/struct.String.html#method.from_utf8_lossy).\n+    #[unstable(feature = \"assoc_char_consts\", reason = \"recently added\", issue = \"71763\")]\n+    pub const REPLACEMENT_CHARACTER: char = '\\u{FFFD}';\n+\n+    /// The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n+    /// `char` and `str` methods are based on.\n+    ///\n+    /// New versions of Unicode are released regularly and subsequently all methods\n+    /// in the standard library depending on Unicode are updated. Therefore the\n+    /// behavior of some `char` and `str` methods and the value of this constant\n+    /// changes over time. This is *not* considered to be a breaking change.\n+    ///\n+    /// The version numbering scheme is explained in\n+    /// [Unicode 11.0 or later, Section 3.1 Versions of the Unicode Standard](https://www.unicode.org/versions/Unicode11.0.0/ch03.pdf#page=4).\n+    #[unstable(feature = \"assoc_char_consts\", reason = \"recently added\", issue = \"71763\")]\n+    pub const UNICODE_VERSION: (u8, u8, u8) = crate::unicode::UNICODE_VERSION;\n+\n+    /// Creates an iterator over the UTF-16 encoded code points in `iter`,\n+    /// returning unpaired surrogates as `Err`s.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::char::decode_utf16;\n+    ///\n+    /// // \ud834\udd1emus<invalid>ic<invalid>\n+    /// let v = [\n+    ///     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n+    /// ];\n+    ///\n+    /// assert_eq!(\n+    ///     decode_utf16(v.iter().cloned())\n+    ///         .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n+    ///         .collect::<Vec<_>>(),\n+    ///     vec![\n+    ///         Ok('\ud834\udd1e'),\n+    ///         Ok('m'), Ok('u'), Ok('s'),\n+    ///         Err(0xDD1E),\n+    ///         Ok('i'), Ok('c'),\n+    ///         Err(0xD834)\n+    ///     ]\n+    /// );\n+    /// ```\n+    ///\n+    /// A lossy decoder can be obtained by replacing `Err` results with the replacement character:\n+    ///\n+    /// ```\n+    /// use std::char::{decode_utf16, REPLACEMENT_CHARACTER};\n+    ///\n+    /// // \ud834\udd1emus<invalid>ic<invalid>\n+    /// let v = [\n+    ///     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n+    /// ];\n+    ///\n+    /// assert_eq!(\n+    ///     decode_utf16(v.iter().cloned())\n+    ///        .map(|r| r.unwrap_or(REPLACEMENT_CHARACTER))\n+    ///        .collect::<String>(),\n+    ///     \"\ud834\udd1emus\ufffdic\ufffd\"\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"assoc_char_funcs\", reason = \"recently added\", issue = \"71763\")]\n+    #[inline]\n+    pub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::IntoIter> {\n+        super::decode::decode_utf16(iter)\n+    }\n+\n+    /// Converts a `u32` to a `char`.\n+    ///\n+    /// Note that all `char`s are valid [`u32`]s, and can be cast to one with\n+    /// `as`:\n+    ///\n+    /// ```\n+    /// let c = '\ud83d\udcaf';\n+    /// let i = c as u32;\n+    ///\n+    /// assert_eq!(128175, i);\n+    /// ```\n+    ///\n+    /// However, the reverse is not true: not all valid [`u32`]s are valid\n+    /// `char`s. `from_u32()` will return `None` if the input is not a valid value\n+    /// for a `char`.\n+    ///\n+    /// [`u32`]: primitive.u32.html\n+    ///\n+    /// For an unsafe version of this function which ignores these checks, see\n+    /// [`from_u32_unchecked`].\n+    ///\n+    /// [`from_u32_unchecked`]: #method.from_u32_unchecked\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::char;\n+    ///\n+    /// let c = char::from_u32(0x2764);\n+    ///\n+    /// assert_eq!(Some('\u2764'), c);\n+    /// ```\n+    ///\n+    /// Returning `None` when the input is not a valid `char`:\n+    ///\n+    /// ```\n+    /// use std::char;\n+    ///\n+    /// let c = char::from_u32(0x110000);\n+    ///\n+    /// assert_eq!(None, c);\n+    /// ```\n+    #[unstable(feature = \"assoc_char_funcs\", reason = \"recently added\", issue = \"71763\")]\n+    #[inline]\n+    pub fn from_u32(i: u32) -> Option<char> {\n+        super::convert::from_u32(i)\n+    }\n+\n+    /// Converts a `u32` to a `char`, ignoring validity.\n+    ///\n+    /// Note that all `char`s are valid [`u32`]s, and can be cast to one with\n+    /// `as`:\n+    ///\n+    /// ```\n+    /// let c = '\ud83d\udcaf';\n+    /// let i = c as u32;\n+    ///\n+    /// assert_eq!(128175, i);\n+    /// ```\n+    ///\n+    /// However, the reverse is not true: not all valid [`u32`]s are valid\n+    /// `char`s. `from_u32_unchecked()` will ignore this, and blindly cast to\n+    /// `char`, possibly creating an invalid one.\n+    ///\n+    /// [`u32`]: primitive.u32.html\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe, as it may construct invalid `char` values.\n+    ///\n+    /// For a safe version of this function, see the [`from_u32`] function.\n+    ///\n+    /// [`from_u32`]: #method.from_u32\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::char;\n+    ///\n+    /// let c = unsafe { char::from_u32_unchecked(0x2764) };\n+    ///\n+    /// assert_eq!('\u2764', c);\n+    /// ```\n+    #[unstable(feature = \"assoc_char_funcs\", reason = \"recently added\", issue = \"71763\")]\n+    #[inline]\n+    pub unsafe fn from_u32_unchecked(i: u32) -> char {\n+        super::convert::from_u32_unchecked(i)\n+    }\n+\n+    /// Converts a digit in the given radix to a `char`.\n+    ///\n+    /// A 'radix' here is sometimes also called a 'base'. A radix of two\n+    /// indicates a binary number, a radix of ten, decimal, and a radix of\n+    /// sixteen, hexadecimal, to give some common values. Arbitrary\n+    /// radices are supported.\n+    ///\n+    /// `from_digit()` will return `None` if the input is not a digit in\n+    /// the given radix.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if given a radix larger than 36.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::char;\n+    ///\n+    /// let c = char::from_digit(4, 10);\n+    ///\n+    /// assert_eq!(Some('4'), c);\n+    ///\n+    /// // Decimal 11 is a single digit in base 16\n+    /// let c = char::from_digit(11, 16);\n+    ///\n+    /// assert_eq!(Some('b'), c);\n+    /// ```\n+    ///\n+    /// Returning `None` when the input is not a digit:\n+    ///\n+    /// ```\n+    /// use std::char;\n+    ///\n+    /// let c = char::from_digit(20, 10);\n+    ///\n+    /// assert_eq!(None, c);\n+    /// ```\n+    ///\n+    /// Passing a large radix, causing a panic:\n+    ///\n+    /// ```\n+    /// use std::thread;\n+    /// use std::char;\n+    ///\n+    /// let result = thread::spawn(|| {\n+    ///     // this panics\n+    ///     let c = char::from_digit(1, 37);\n+    /// }).join();\n+    ///\n+    /// assert!(result.is_err());\n+    /// ```\n+    #[unstable(feature = \"assoc_char_funcs\", reason = \"recently added\", issue = \"71763\")]\n+    #[inline]\n+    pub fn from_digit(num: u32, radix: u32) -> Option<char> {\n+        super::convert::from_digit(num, radix)\n+    }\n+\n     /// Checks if a `char` is a digit in the given radix.\n     ///\n     /// A 'radix' here is sometimes also called a 'base'. A radix of two"}, {"sha": "bf65c31e135975826e856cbbe6a41f02783fd403", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25028adf21dae59552d0a9d5eb9b832ffe673836/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25028adf21dae59552d0a9d5eb9b832ffe673836/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=25028adf21dae59552d0a9d5eb9b832ffe673836", "patch": "@@ -92,15 +92,15 @@ const MAX_THREE_B: u32 = 0x10000;\n /// [Unicode Scalar Value]: http://www.unicode.org/glossary/#unicode_scalar_value\n /// [Code Point]: http://www.unicode.org/glossary/#code_point\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MAX: char = '\\u{10ffff}';\n+pub const MAX: char = char::MAX;\n \n /// `U+FFFD REPLACEMENT CHARACTER` (\ufffd) is used in Unicode to represent a\n /// decoding error.\n ///\n /// It can occur, for example, when giving ill-formed UTF-8 bytes to\n /// [`String::from_utf8_lossy`](../../std/string/struct.String.html#method.from_utf8_lossy).\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n-pub const REPLACEMENT_CHARACTER: char = '\\u{FFFD}';\n+pub const REPLACEMENT_CHARACTER: char = char::REPLACEMENT_CHARACTER;\n \n /// Returns an iterator that yields the hexadecimal Unicode escape of a\n /// character, as `char`s."}]}