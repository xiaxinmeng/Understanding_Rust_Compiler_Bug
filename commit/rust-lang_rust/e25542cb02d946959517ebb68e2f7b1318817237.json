{"sha": "e25542cb02d946959517ebb68e2f7b1318817237", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyNTU0MmNiMDJkOTQ2OTU5NTE3ZWJiNjhlMmY3YjEzMTg4MTcyMzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-16T07:12:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-16T07:12:12Z"}, "message": "Auto merge of #35162 - canndrew:bang_type_coerced, r=nikomatsakis\n\nImplement the `!` type\n\nThis implements the never type (`!`) and hides it behind the feature gate `#[feature(never_type)]`. With the feature gate off, things should build as normal (although some error messages may be different). With the gate on, `!` is usable as a type and diverging type variables (ie. types that are unconstrained by anything in the code) will default to `!` instead of `()`.", "tree": {"sha": "64775f55741e98f44e5e2ee854e6707e2f4b4da9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64775f55741e98f44e5e2ee854e6707e2f4b4da9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e25542cb02d946959517ebb68e2f7b1318817237", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e25542cb02d946959517ebb68e2f7b1318817237", "html_url": "https://github.com/rust-lang/rust/commit/e25542cb02d946959517ebb68e2f7b1318817237", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e25542cb02d946959517ebb68e2f7b1318817237/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "197be89f367d1240d5f9cd9c4efd77812775354e", "url": "https://api.github.com/repos/rust-lang/rust/commits/197be89f367d1240d5f9cd9c4efd77812775354e", "html_url": "https://github.com/rust-lang/rust/commit/197be89f367d1240d5f9cd9c4efd77812775354e"}, {"sha": "f59f1f0914de50ffa70e3000c317a14f6d1b8605", "url": "https://api.github.com/repos/rust-lang/rust/commits/f59f1f0914de50ffa70e3000c317a14f6d1b8605", "html_url": "https://github.com/rust-lang/rust/commit/f59f1f0914de50ffa70e3000c317a14f6d1b8605"}], "stats": {"total": 1604, "additions": 899, "deletions": 705}, "files": [{"sha": "bb7c971111853e2b612158d4a772835f5cbc7b8a", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -699,6 +699,39 @@ mod impls {\n \n     ord_impl! { char usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n+    // Note: This macro is a temporary hack that can be remove once we are building with a compiler\n+    // that supports `!`\n+    macro_rules! not_stage0 {\n+        () => {\n+            #[unstable(feature = \"never_type\", issue = \"35121\")]\n+            impl PartialEq for ! {\n+                fn eq(&self, _: &!) -> bool {\n+                    *self\n+                }\n+            }\n+\n+            #[unstable(feature = \"never_type\", issue = \"35121\")]\n+            impl Eq for ! {}\n+\n+            #[unstable(feature = \"never_type\", issue = \"35121\")]\n+            impl PartialOrd for ! {\n+                fn partial_cmp(&self, _: &!) -> Option<Ordering> {\n+                    *self\n+                }\n+            }\n+\n+            #[unstable(feature = \"never_type\", issue = \"35121\")]\n+            impl Ord for ! {\n+                fn cmp(&self, _: &!) -> Ordering {\n+                    *self\n+                }\n+            }\n+        }\n+    }\n+\n+    #[cfg(not(stage0))]\n+    not_stage0!();\n+\n     // & pointers\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "dbd715c722e13ebd4111aeb53ef2af8d70b2276a", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -1363,6 +1363,29 @@ macro_rules! fmt_refs {\n \n fmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }\n \n+// Note: This macro is a temporary hack that can be remove once we are building with a compiler\n+// that supports `!`\n+macro_rules! not_stage0 {\n+    () => {\n+        #[unstable(feature = \"never_type\", issue = \"35121\")]\n+        impl Debug for ! {\n+            fn fmt(&self, _: &mut Formatter) -> Result {\n+                *self\n+            }\n+        }\n+\n+        #[unstable(feature = \"never_type\", issue = \"35121\")]\n+        impl Display for ! {\n+            fn fmt(&self, _: &mut Formatter) -> Result {\n+                *self\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+not_stage0!();\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Debug for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {"}, {"sha": "7831464756b940d91cee040e4e0f400b1ca035ce", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -88,6 +88,9 @@\n #![feature(unboxed_closures)]\n #![feature(question_mark)]\n \n+// NOTE: remove the cfg_attr next snapshot\n+#![cfg_attr(not(stage0), feature(never_type))]\n+\n #[macro_use]\n mod macros;\n "}, {"sha": "232db76a6d175ac34394a9dcd118ccd2d92627b8", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -379,7 +379,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n-        if fn_ty.fn_ret().diverges() {\n+        // FIXME(canndrew): This is_never should probably be an is_uninhabited.\n+        if fn_ty.fn_ret().0.is_never() {\n             self.add_unreachable_node()\n         } else {\n             ret"}, {"sha": "0edfd16bdfd1b7ca07d9e3af5d222e5a44e796d0", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -353,6 +353,7 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n                         }\n                     }))\n                 }\n+                TyNever => node,\n                 TyTup(tys) => TyTup(tys.move_map(|ty| fld.fold_ty(ty))),\n                 TyPath(qself, path) => {\n                     let qself = qself.map(|QSelf { ty, position }| {\n@@ -515,7 +516,6 @@ pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> {\n             output: match output {\n                 Return(ty) => Return(fld.fold_ty(ty)),\n                 DefaultReturn(span) => DefaultReturn(span),\n-                NoReturn(span) => NoReturn(span),\n             },\n             variadic: variadic,\n         }"}, {"sha": "92b956788860ee1058d4c7fb9b773f72b2d70e19", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -403,6 +403,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             walk_list!(visitor, visit_lifetime, opt_lifetime);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n+        TyNever => {},\n         TyTup(ref tuple_element_types) => {\n             walk_list!(visitor, visit_ty, tuple_element_types);\n         }"}, {"sha": "c2b211238b2f1d1262ac1c812fa8a3667b6eac83", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -270,6 +270,7 @@ impl<'a> LoweringContext<'a> {\n                         decl: self.lower_fn_decl(&f.decl),\n                     }))\n                 }\n+                Never => hir::TyNever,\n                 Tup(ref tys) => hir::TyTup(tys.iter().map(|ty| self.lower_ty(ty)).collect()),\n                 Paren(ref ty) => {\n                     return self.lower_ty(ty);\n@@ -402,7 +403,6 @@ impl<'a> LoweringContext<'a> {\n             output: match decl.output {\n                 FunctionRetTy::Ty(ref ty) => hir::Return(self.lower_ty(ty)),\n                 FunctionRetTy::Default(span) => hir::DefaultReturn(span),\n-                FunctionRetTy::None(span) => hir::NoReturn(span),\n             },\n             variadic: decl.variadic,\n         })"}, {"sha": "d41cdfabdf4c04a55b841385bb6dccadd131cd39", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -1112,6 +1112,7 @@ pub struct BareFnTy {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n /// The different kinds of types recognized by the compiler\n pub enum Ty_ {\n+    /// A variable length array (`[T]`)\n     TyVec(P<Ty>),\n     /// A fixed length array (`[T; n]`)\n     TyFixedLengthVec(P<Ty>, P<Expr>),\n@@ -1121,6 +1122,8 @@ pub enum Ty_ {\n     TyRptr(Option<Lifetime>, MutTy),\n     /// A bare function (e.g. `fn(usize) -> bool`)\n     TyBareFn(P<BareFnTy>),\n+    /// The never type (`!`)\n+    TyNever,\n     /// A tuple (`(A, B, C, D,...)`)\n     TyTup(HirVec<P<Ty>>),\n     /// A path (`module::module::...::Type`), optionally\n@@ -1283,9 +1286,6 @@ impl fmt::Debug for ImplPolarity {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum FunctionRetTy {\n-    /// Functions with return type `!`that always\n-    /// raise an error or exit (i.e. never return to the caller)\n-    NoReturn(Span),\n     /// Return type is not specified.\n     ///\n     /// Functions default to `()` and\n@@ -1299,7 +1299,6 @@ pub enum FunctionRetTy {\n impl FunctionRetTy {\n     pub fn span(&self) -> Span {\n         match *self {\n-            NoReturn(span) => span,\n             DefaultReturn(span) => span,\n             Return(ref ty) => ty.span,\n         }"}, {"sha": "66c1bc7642c56b682ce9da0b33d4844483f4fedc", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -504,6 +504,9 @@ impl<'a> State<'a> {\n                 self.print_opt_lifetime(lifetime)?;\n                 self.print_mt(mt)?;\n             }\n+            hir::TyNever => {\n+                word(&mut self.s, \"!\")?;\n+            },\n             hir::TyTup(ref elts) => {\n                 self.popen()?;\n                 self.commasep(Inconsistent, &elts[..], |s, ty| s.print_type(&ty))?;\n@@ -1959,10 +1962,6 @@ impl<'a> State<'a> {\n                 self.maybe_print_comment(ty.span.lo)\n             }\n             hir::DefaultReturn(..) => unreachable!(),\n-            hir::NoReturn(span) => {\n-                self.word_nbsp(\"!\")?;\n-                self.maybe_print_comment(span.lo)\n-            }\n         }\n     }\n \n@@ -2195,7 +2194,6 @@ impl<'a> State<'a> {\n         self.ibox(indent_unit)?;\n         self.word_space(\"->\")?;\n         match decl.output {\n-            hir::NoReturn(_) => self.word_nbsp(\"!\")?,\n             hir::DefaultReturn(..) => unreachable!(),\n             hir::Return(ref ty) => self.print_type(&ty)?,\n         }"}, {"sha": "b0dec3277a9967686ddaf937e825947a26267000", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -1326,7 +1326,6 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                 self.rebuild_arg_ty_or_output(&ret_ty, lifetime, anon_nums, region_names)\n             ),\n             hir::DefaultReturn(span) => hir::DefaultReturn(span),\n-            hir::NoReturn(span) => hir::NoReturn(span)\n         }\n     }\n "}, {"sha": "ecd9759c721b2f11062386e08b259c9249737f4c", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -168,6 +168,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyTrait(..) |\n             ty::TyStruct(..) |\n             ty::TyClosure(..) |\n+            ty::TyNever |\n             ty::TyTuple(..) |\n             ty::TyProjection(..) |\n             ty::TyParam(..) |"}, {"sha": "24fadc549fafc221e748cdaff099c9781863b5d4", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -607,7 +607,6 @@ impl_trans_normalize!('gcx,\n     Ty<'gcx>,\n     &'gcx Substs<'gcx>,\n     ty::FnSig<'gcx>,\n-    ty::FnOutput<'gcx>,\n     &'gcx ty::BareFnTy<'gcx>,\n     ty::ClosureSubsts<'gcx>,\n     ty::PolyTraitRef<'gcx>"}, {"sha": "87463055a276a76748f939b8d59e2aaa51c6f50f", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -717,6 +717,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         let adj = infcx.adjustments().get(&expr.id).map(|x| x.clone());\n         if let Some(adjustment) = adj {\n             match adjustment {\n+                adjustment::AdjustNeverToAny(..) |\n                 adjustment::AdjustReifyFnPointer |\n                 adjustment::AdjustUnsafeFnPointer |\n                 adjustment::AdjustMutToConstPointer => {"}, {"sha": "a1a4f15b9f78edde483daf7e1dc857a613e66b09", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -161,10 +161,9 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'gcx, 'tcx> {\n                     let typ = self.infcx.tcx.node_id_to_type(expr.id);\n                     match typ.sty {\n                         ty::TyFnDef(_, _, ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n-                            if let ty::FnConverging(to) = bare_fn_ty.sig.0.output {\n-                                let from = bare_fn_ty.sig.0.inputs[0];\n-                                self.check_transmute(expr.span, from, to, expr.id);\n-                            }\n+                            let from = bare_fn_ty.sig.0.inputs[0];\n+                            let to = bare_fn_ty.sig.0.output;\n+                            self.check_transmute(expr.span, from, to, expr.id);\n                         }\n                         _ => {\n                             span_bug!(expr.span, \"transmute wasn't a bare fn?!\");"}, {"sha": "74d29b273ff2b40c9d619275a163aadbddfd4978", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 40, "deletions": 49, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -112,7 +112,7 @@ use self::VarKind::*;\n use dep_graph::DepNode;\n use hir::def::*;\n use hir::pat_util;\n-use ty::{self, TyCtxt, ParameterEnvironment};\n+use ty::{self, Ty, TyCtxt, ParameterEnvironment};\n use traits::{self, Reveal};\n use ty::subst::Subst;\n use lint;\n@@ -1111,8 +1111,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           hir::ExprCall(ref f, ref args) => {\n+            // FIXME(canndrew): This is_never should really be an is_uninhabited\n             let diverges = !self.ir.tcx.is_method_call(expr.id) &&\n-                self.ir.tcx.expr_ty_adjusted(&f).fn_ret().diverges();\n+                self.ir.tcx.expr_ty_adjusted(&f).fn_ret().0.is_never();\n             let succ = if diverges {\n                 self.s.exit_ln\n             } else {\n@@ -1125,7 +1126,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           hir::ExprMethodCall(_, _, ref args) => {\n             let method_call = ty::MethodCall::expr(expr.id);\n             let method_ty = self.ir.tcx.tables.borrow().method_map[&method_call].ty;\n-            let succ = if method_ty.fn_ret().diverges() {\n+            // FIXME(canndrew): This is_never should really be an is_uninhabited\n+            let succ = if method_ty.fn_ret().0.is_never() {\n                 self.s.exit_ln\n             } else {\n                 succ\n@@ -1454,7 +1456,7 @@ fn check_fn(_v: &Liveness,\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn fn_ret(&self, id: NodeId) -> ty::PolyFnOutput<'tcx> {\n+    fn fn_ret(&self, id: NodeId) -> ty::Binder<Ty<'tcx>> {\n         let fn_ty = self.ir.tcx.node_id_to_type(id);\n         match fn_ty.sty {\n             ty::TyClosure(closure_def_id, substs) =>\n@@ -1477,55 +1479,44 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 self.ir.tcx.region_maps.call_site_extent(id, body.id),\n                 &self.fn_ret(id));\n \n-        match fn_ret {\n-            ty::FnConverging(t_ret)\n-                    if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() => {\n-\n-                let param_env = ParameterEnvironment::for_item(self.ir.tcx, id);\n-                let t_ret_subst = t_ret.subst(self.ir.tcx, &param_env.free_substs);\n-                let is_nil = self.ir.tcx.infer_ctxt(None, Some(param_env),\n-                                                    Reveal::All).enter(|infcx| {\n-                    let cause = traits::ObligationCause::dummy();\n-                    traits::fully_normalize(&infcx, cause, &t_ret_subst).unwrap().is_nil()\n-                });\n-\n-                // for nil return types, it is ok to not return a value expl.\n-                if !is_nil {\n-                    let ends_with_stmt = match body.expr {\n-                        None if !body.stmts.is_empty() =>\n-                            match body.stmts.last().unwrap().node {\n-                                hir::StmtSemi(ref e, _) => {\n-                                    self.ir.tcx.expr_ty(&e) == t_ret\n-                                },\n-                                _ => false\n+        if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n+            let param_env = ParameterEnvironment::for_item(self.ir.tcx, id);\n+            let t_ret_subst = fn_ret.subst(self.ir.tcx, &param_env.free_substs);\n+            let is_nil = self.ir.tcx.infer_ctxt(None, Some(param_env),\n+                                                Reveal::All).enter(|infcx| {\n+                let cause = traits::ObligationCause::dummy();\n+                traits::fully_normalize(&infcx, cause, &t_ret_subst).unwrap().is_nil()\n+            });\n+\n+            // for nil return types, it is ok to not return a value expl.\n+            if !is_nil {\n+                let ends_with_stmt = match body.expr {\n+                    None if !body.stmts.is_empty() =>\n+                        match body.stmts.last().unwrap().node {\n+                            hir::StmtSemi(ref e, _) => {\n+                                self.ir.tcx.expr_ty(&e) == fn_ret\n                             },\n-                        _ => false\n+                            _ => false\n+                        },\n+                    _ => false\n+                };\n+                let mut err = struct_span_err!(self.ir.tcx.sess,\n+                                               sp,\n+                                               E0269,\n+                                               \"not all control paths return a value\");\n+                if ends_with_stmt {\n+                    let last_stmt = body.stmts.last().unwrap();\n+                    let original_span = original_sp(self.ir.tcx.sess.codemap(),\n+                                                    last_stmt.span, sp);\n+                    let span_semicolon = Span {\n+                        lo: original_span.hi - BytePos(1),\n+                        hi: original_span.hi,\n+                        expn_id: original_span.expn_id\n                     };\n-                    let mut err = struct_span_err!(self.ir.tcx.sess,\n-                                                   sp,\n-                                                   E0269,\n-                                                   \"not all control paths return a value\");\n-                    if ends_with_stmt {\n-                        let last_stmt = body.stmts.last().unwrap();\n-                        let original_span = original_sp(self.ir.tcx.sess.codemap(),\n-                                                        last_stmt.span, sp);\n-                        let span_semicolon = Span {\n-                            lo: original_span.hi - BytePos(1),\n-                            hi: original_span.hi,\n-                            expn_id: original_span.expn_id\n-                        };\n-                        err.span_help(span_semicolon, \"consider removing this semicolon:\");\n-                    }\n-                    err.emit();\n+                    err.span_help(span_semicolon, \"consider removing this semicolon:\");\n                 }\n+                err.emit();\n             }\n-            ty::FnDiverging\n-                if self.live_on_entry(entry_ln, self.s.clean_exit_var).is_some() => {\n-                    span_err!(self.ir.tcx.sess, sp, E0270,\n-                        \"computation may converge in a function marked as diverging\");\n-                }\n-\n-            _ => {}\n         }\n     }\n "}, {"sha": "676e456dcea94e2ecaf96fe984b50d1dec27dd47", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -451,6 +451,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                         self.cat_expr_autoderefd(expr, autoderefs)\n                     }\n \n+                    adjustment::AdjustNeverToAny(..) |\n                     adjustment::AdjustReifyFnPointer |\n                     adjustment::AdjustUnsafeFnPointer |\n                     adjustment::AdjustMutToConstPointer |\n@@ -922,7 +923,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let base_cmt = match method_ty {\n             Some(method_ty) => {\n                 let ref_ty =\n-                    self.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap().unwrap();\n+                    self.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n                 self.cat_rvalue_node(node.id(), node.span(), ref_ty)\n             }\n             None => base_cmt\n@@ -1244,7 +1245,6 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // to skip past the binder.\n         self.tcx().no_late_bound_regions(&method_ty.fn_ret())\n            .unwrap()\n-           .unwrap() // overloaded ops do not diverge, either\n     }\n }\n "}, {"sha": "2bde3d6554feef4400767c15037e19aa4e2955b6", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -17,7 +17,7 @@ use rustc_data_structures::control_flow_graph::{GraphPredecessors, GraphSuccesso\n use rustc_data_structures::control_flow_graph::ControlFlowGraph;\n use hir::def_id::DefId;\n use ty::subst::Substs;\n-use ty::{self, AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n+use ty::{self, AdtDef, ClosureSubsts, Region, Ty};\n use util::ppaux;\n use rustc_back::slice;\n use hir::InlineAsm;\n@@ -74,7 +74,7 @@ pub struct Mir<'tcx> {\n     pub promoted: IndexVec<Promoted, Mir<'tcx>>,\n \n     /// Return type of the function.\n-    pub return_ty: FnOutput<'tcx>,\n+    pub return_ty: Ty<'tcx>,\n \n     /// Variables: these are stack slots corresponding to user variables. They may be\n     /// assigned many times.\n@@ -107,7 +107,7 @@ impl<'tcx> Mir<'tcx> {\n     pub fn new(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n                visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n                promoted: IndexVec<Promoted, Mir<'tcx>>,\n-               return_ty: FnOutput<'tcx>,\n+               return_ty: Ty<'tcx>,\n                var_decls: IndexVec<Var, VarDecl<'tcx>>,\n                arg_decls: IndexVec<Arg, ArgDecl<'tcx>>,\n                temp_decls: IndexVec<Temp, TempDecl<'tcx>>,"}, {"sha": "cf91229f1c713afa07c4baf714e51d161baa4df7", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -125,7 +125,7 @@ impl<'tcx> Lvalue<'tcx> {\n             &Lvalue::Static(def_id) =>\n                 LvalueTy::Ty { ty: tcx.lookup_item_type(def_id).ty },\n             &Lvalue::ReturnPointer =>\n-                LvalueTy::Ty { ty: mir.return_ty.unwrap() },\n+                LvalueTy::Ty { ty: mir.return_ty },\n             &Lvalue::Projection(ref proj) =>\n                 proj.base.ty(mir, tcx).projection_ty(tcx, &proj.elem),\n         }"}, {"sha": "ead8de86dbae4094f555d09068fde43057d6a0cf", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -11,7 +11,7 @@\n use middle::const_val::ConstVal;\n use hir::def_id::DefId;\n use ty::subst::Substs;\n-use ty::{ClosureSubsts, FnOutput, Region, Ty};\n+use ty::{ClosureSubsts, Region, Ty};\n use mir::repr::*;\n use rustc_const_math::ConstUsize;\n use rustc_data_structures::tuple_slice::TupleSlice;\n@@ -38,9 +38,7 @@ use syntax_pos::Span;\n //\n // For the most part, we do not destructure things external to the\n // MIR, e.g. types, spans, etc, but simply visit them and stop. This\n-// avoids duplication with other visitors like `TypeFoldable`. But\n-// there is one exception: we do destructure the `FnOutput` to reach\n-// the type within. Just because.\n+// avoids duplication with other visitors like `TypeFoldable`.\n //\n // ## Updating\n //\n@@ -192,11 +190,6 @@ macro_rules! make_mir_visitor {\n                 self.super_source_info(source_info);\n             }\n \n-            fn visit_fn_output(&mut self,\n-                               fn_output: & $($mutability)* FnOutput<'tcx>) {\n-                self.super_fn_output(fn_output);\n-            }\n-\n             fn visit_ty(&mut self,\n                         ty: & $($mutability)* Ty<'tcx>) {\n                 self.super_ty(ty);\n@@ -261,7 +254,7 @@ macro_rules! make_mir_visitor {\n                     self.visit_visibility_scope_data(scope);\n                 }\n \n-                self.visit_fn_output(&$($mutability)* mir.return_ty);\n+                self.visit_ty(&$($mutability)* mir.return_ty);\n \n                 for var_decl in &$($mutability)* mir.var_decls {\n                     self.visit_var_decl(var_decl);\n@@ -708,16 +701,6 @@ macro_rules! make_mir_visitor {\n                 self.visit_visibility_scope(scope);\n             }\n \n-            fn super_fn_output(&mut self, fn_output: & $($mutability)* FnOutput<'tcx>) {\n-                match *fn_output {\n-                    FnOutput::FnConverging(ref $($mutability)* ty) => {\n-                        self.visit_ty(ty);\n-                    }\n-                    FnOutput::FnDiverging => {\n-                    }\n-                }\n-            }\n-\n             fn super_ty(&mut self, _ty: & $($mutability)* Ty<'tcx>) {\n             }\n "}, {"sha": "b38f5f96de4484c385f18c22b6ef4b4e420fc290", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -253,6 +253,7 @@ fn ty_is_local_constructor(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal)->\n         ty::TySlice(..) |\n         ty::TyRawPtr(..) |\n         ty::TyRef(..) |\n+        ty::TyNever |\n         ty::TyTuple(..) |\n         ty::TyParam(..) |\n         ty::TyProjection(..) => {"}, {"sha": "cf004767b2aaca0e11fc6d68664561c46ed3a8e4", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -212,6 +212,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ty::TyProjection(..) => Some(13),\n                 ty::TyParam(..) => Some(14),\n                 ty::TyAnon(..) => Some(15),\n+                ty::TyNever => Some(16),\n                 ty::TyInfer(..) | ty::TyError => None\n             }\n         }"}, {"sha": "4889895860129144dc323c6ce52ebde00b364c89", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -269,10 +269,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 return Some(MethodViolationCode::ReferencesSelf);\n             }\n         }\n-        if let ty::FnConverging(result_type) = sig.0.output {\n-            if self.contains_illegal_self_type_reference(trait_def_id, result_type) {\n-                return Some(MethodViolationCode::ReferencesSelf);\n-            }\n+        if self.contains_illegal_self_type_reference(trait_def_id, sig.0.output) {\n+            return Some(MethodViolationCode::ReferencesSelf);\n         }\n \n         // We can't monomorphize things like `fn foo<A>(...)`."}, {"sha": "b61cb0d3eee7217c17243564bee61a911ae706d9", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -1388,7 +1388,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 abi: Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: _,\n-                    output: ty::FnConverging(_),\n+                    output: _,\n                     variadic: false\n                 })\n             }) |\n@@ -1397,7 +1397,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 abi: Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: _,\n-                    output: ty::FnConverging(_),\n+                    output: _,\n                     variadic: false\n                 })\n             }) => {\n@@ -1772,7 +1772,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n             ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyRawPtr(..) |\n             ty::TyChar | ty::TyBox(_) | ty::TyRef(..) |\n-            ty::TyArray(..) | ty::TyClosure(..) |\n+            ty::TyArray(..) | ty::TyClosure(..) | ty::TyNever |\n             ty::TyError => {\n                 // safe for everything\n                 Where(ty::Binder(Vec::new()))\n@@ -1820,7 +1820,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n             ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n             ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar |\n-            ty::TyRawPtr(..) | ty::TyError |\n+            ty::TyRawPtr(..) | ty::TyError | ty::TyNever |\n             ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n                 Where(ty::Binder(Vec::new()))\n             }\n@@ -1886,6 +1886,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyError |\n             ty::TyInfer(ty::IntVar(_)) |\n             ty::TyInfer(ty::FloatVar(_)) |\n+            ty::TyNever |\n             ty::TyChar => {\n                 Vec::new()\n             }"}, {"sha": "818eb4eb2fb1e3cf1d30ce81d91d8f98852d67d5", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -515,7 +515,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             def_id: fn_trait_def_id,\n             substs: self.mk_substs(trait_substs),\n         };\n-        ty::Binder((trait_ref, sig.0.output.unwrap_or(self.mk_nil())))\n+        ty::Binder((trait_ref, sig.0.output))\n     }\n }\n "}, {"sha": "ae9fd5ab5bc87f79bef77f744f2f11632ce2ab59", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -21,9 +21,10 @@ use hir;\n \n #[derive(Copy, Clone)]\n pub enum AutoAdjustment<'tcx> {\n-    AdjustReifyFnPointer,    // go from a fn-item type to a fn-pointer type\n-    AdjustUnsafeFnPointer,   // go from a safe fn pointer to an unsafe fn pointer\n-    AdjustMutToConstPointer, // go from a mut raw pointer to a const raw pointer\n+    AdjustNeverToAny(Ty<'tcx>), // go from ! to any type\n+    AdjustReifyFnPointer,       // go from a fn-item type to a fn-pointer type\n+    AdjustUnsafeFnPointer,      // go from a safe fn pointer to an unsafe fn pointer\n+    AdjustMutToConstPointer,    // go from a mut raw pointer to a const raw pointer\n     AdjustDerefRef(AutoDerefRef<'tcx>),\n }\n \n@@ -106,6 +107,7 @@ pub struct AutoDerefRef<'tcx> {\n impl<'tcx> AutoAdjustment<'tcx> {\n     pub fn is_identity(&self) -> bool {\n         match *self {\n+            AdjustNeverToAny(ty) => ty.is_never(),\n             AdjustReifyFnPointer |\n             AdjustUnsafeFnPointer |\n             AdjustMutToConstPointer => false,\n@@ -154,6 +156,8 @@ impl<'a, 'gcx, 'tcx> ty::TyS<'tcx> {\n         return match adjustment {\n             Some(adjustment) => {\n                 match *adjustment {\n+                    AdjustNeverToAny(ref ty) => ty,\n+\n                     AdjustReifyFnPointer => {\n                         match self.sty {\n                             ty::TyFnDef(_, _, f) => tcx.mk_fn_ptr(f),\n@@ -227,8 +231,7 @@ impl<'a, 'gcx, 'tcx> ty::TyS<'tcx> {\n         if let Some(method_ty) = method_type(method_call) {\n             // Method calls always have all late-bound regions\n             // fully instantiated.\n-            let fn_ret = tcx.no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n-            adjusted_ty = fn_ret.unwrap();\n+            adjusted_ty = tcx.no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n         }\n         match adjusted_ty.builtin_deref(true, NoPreference) {\n             Some(mt) => mt.ty,"}, {"sha": "53bf046d6b597ed74acdb37792d5afd7c79f1492", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -185,7 +185,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n                 // Scalar and unique types are sendable, and durable\n                 ty::TyInfer(ty::FreshIntTy(_)) | ty::TyInfer(ty::FreshFloatTy(_)) |\n-                ty::TyBool | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) |\n+                ty::TyBool | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) | ty::TyNever |\n                 ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar => {\n                     TC::None\n                 }"}, {"sha": "4056fb01aa2c26fe73c4061f0d7b0b4fa18bd6c9", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -190,6 +190,7 @@ pub struct CommonTypes<'tcx> {\n     pub u64: Ty<'tcx>,\n     pub f32: Ty<'tcx>,\n     pub f64: Ty<'tcx>,\n+    pub never: Ty<'tcx>,\n     pub err: Ty<'tcx>,\n }\n \n@@ -256,6 +257,7 @@ impl<'tcx> CommonTypes<'tcx> {\n         CommonTypes {\n             bool: mk(TyBool),\n             char: mk(TyChar),\n+            never: mk(TyNever),\n             err: mk(TyError),\n             isize: mk(TyInt(ast::IntTy::Is)),\n             i8: mk(TyInt(ast::IntTy::I8)),\n@@ -975,7 +977,7 @@ macro_rules! sty_debug_print {\n                 for &Interned(t) in tcx.interners.type_.borrow().iter() {\n                     let variant = match t.sty {\n                         ty::TyBool | ty::TyChar | ty::TyInt(..) | ty::TyUint(..) |\n-                            ty::TyFloat(..) | ty::TyStr => continue,\n+                            ty::TyFloat(..) | ty::TyStr | ty::TyNever => continue,\n                         ty::TyError => /* unimportant */ continue,\n                         $(ty::$variant(..) => &mut $variant,)*\n                     };\n@@ -1264,6 +1266,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_tup(Vec::new())\n     }\n \n+    pub fn mk_diverging_default(self) -> Ty<'tcx> {\n+        if self.sess.features.borrow().never_type {\n+            self.types.never\n+        } else {\n+            self.mk_nil()\n+        }\n+    }\n+\n     pub fn mk_bool(self) -> Ty<'tcx> {\n         self.mk_ty(TyBool)\n     }"}, {"sha": "42d5788568f1c246ac72ae746c74452ffe0d1f2d", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -214,7 +214,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n     fn sort_string(&self, tcx: TyCtxt<'a, 'gcx, 'lcx>) -> String {\n         match self.sty {\n             ty::TyBool | ty::TyChar | ty::TyInt(_) |\n-            ty::TyUint(_) | ty::TyFloat(_) | ty::TyStr => self.to_string(),\n+            ty::TyUint(_) | ty::TyFloat(_) | ty::TyStr | ty::TyNever => self.to_string(),\n             ty::TyTuple(ref tys) if tys.is_empty() => self.to_string(),\n \n             ty::TyEnum(def, _) => format!(\"enum `{}`\", tcx.item_path_str(def.did)),"}, {"sha": "9bf2daeb5f49bfa38be179145515d2193c08e92d", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -26,6 +26,7 @@ pub enum SimplifiedType {\n     StrSimplifiedType,\n     VecSimplifiedType,\n     PtrSimplifiedType,\n+    NeverSimplifiedType,\n     TupleSimplifiedType(usize),\n     TraitSimplifiedType(DefId),\n     StructSimplifiedType(DefId),\n@@ -81,6 +82,7 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyClosure(def_id, _) => {\n             Some(ClosureSimplifiedType(def_id))\n         }\n+        ty::TyNever => Some(NeverSimplifiedType),\n         ty::TyTuple(ref tys) => {\n             Some(TupleSimplifiedType(tys.len()))\n         }"}, {"sha": "0997d6c1a7562e6b2055847f3c767e2e1ba35216", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -60,6 +60,7 @@ impl FlagComputation {\n             &ty::TyInt(_) |\n             &ty::TyFloat(_) |\n             &ty::TyUint(_) |\n+            &ty::TyNever |\n             &ty::TyStr => {\n             }\n \n@@ -171,10 +172,7 @@ impl FlagComputation {\n         let mut computation = FlagComputation::new();\n \n         computation.add_tys(&fn_sig.0.inputs);\n-\n-        if let ty::FnConverging(output) = fn_sig.0.output {\n-            computation.add_ty(output);\n-        }\n+        computation.add_ty(fn_sig.0.output);\n \n         self.add_bound_computation(&computation);\n     }"}, {"sha": "3eeff6ee5792fe716d07d61691d10e750a2692ee", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -160,12 +160,6 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n         sig.super_fold_with(self)\n     }\n \n-    fn fold_output(&mut self,\n-                      output: &ty::FnOutput<'tcx>)\n-                      -> ty::FnOutput<'tcx> {\n-        output.super_fold_with(self)\n-    }\n-\n     fn fold_bare_fn_ty(&mut self,\n                        fty: &'tcx ty::BareFnTy<'tcx>)\n                        -> &'tcx ty::BareFnTy<'tcx>"}, {"sha": "8ddd8bef36a6f7f006b9e3f95e5008f3348a439f", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -349,6 +349,7 @@ pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n         ty::TyAnon(..) |\n         ty::TyInfer(_) |\n         ty::TyError |\n+        ty::TyNever |\n         ty::TyFloat(_) => None,\n     }\n }"}, {"sha": "195cece6bc4e008eb125087a9bc94d063cad0844", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -795,6 +795,9 @@ impl<'a, 'gcx, 'tcx> Layout {\n             ty::TyFloat(FloatTy::F64) => Scalar { value: F64, non_zero: false },\n             ty::TyFnPtr(_) => Scalar { value: Pointer, non_zero: true },\n \n+            // The never type.\n+            ty::TyNever => Univariant { variant: Struct::new(dl, false), non_zero: false },\n+\n             // Potentially-fat pointers.\n             ty::TyBox(pointee) |\n             ty::TyRef(_, ty::TypeAndMut { ty: pointee, .. }) |"}, {"sha": "cfc2e89f9d5a126e10e22681c00076fb29710007", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -55,15 +55,14 @@ use hir::intravisit::Visitor;\n \n pub use self::sty::{Binder, DebruijnIndex};\n pub use self::sty::{BuiltinBound, BuiltinBounds, ExistentialBounds};\n-pub use self::sty::{BareFnTy, FnSig, PolyFnSig, FnOutput, PolyFnOutput};\n+pub use self::sty::{BareFnTy, FnSig, PolyFnSig};\n pub use self::sty::{ClosureTy, InferTy, ParamTy, ProjectionTy, TraitTy};\n pub use self::sty::{ClosureSubsts, TypeAndMut};\n pub use self::sty::{TraitRef, TypeVariants, PolyTraitRef};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::Issue32330;\n pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid, SkolemizedRegionVid};\n pub use self::sty::BoundRegion::*;\n-pub use self::sty::FnOutput::*;\n pub use self::sty::InferTy::*;\n pub use self::sty::Region::*;\n pub use self::sty::TypeVariants::*;\n@@ -1854,7 +1853,7 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n         let result = match ty.sty {\n             TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n             TyBox(..) | TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n-            TyArray(..) | TyClosure(..) => {\n+            TyArray(..) | TyClosure(..) | TyNever => {\n                 vec![]\n             }\n "}, {"sha": "ee431681ad100488cb8c49f63d5f9c89766ce529", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -171,6 +171,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ty::TyInt(..) |         // OutlivesScalar\n             ty::TyUint(..) |        // OutlivesScalar\n             ty::TyFloat(..) |       // OutlivesScalar\n+            ty::TyNever |           // ...\n             ty::TyEnum(..) |        // OutlivesNominalType\n             ty::TyStruct(..) |      // OutlivesNominalType\n             ty::TyBox(..) |         // OutlivesNominalType (ish)"}, {"sha": "05a9b8111570dd5830287269b8f957b914493379", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -256,20 +256,11 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n         let inputs = relate_arg_vecs(relation,\n                                      &a.inputs,\n                                      &b.inputs)?;\n+        let output = relation.relate(&a.output, &b.output)?;\n \n-        let output = match (a.output, b.output) {\n-            (ty::FnConverging(a_ty), ty::FnConverging(b_ty)) =>\n-                Ok(ty::FnConverging(relation.relate(&a_ty, &b_ty)?)),\n-            (ty::FnDiverging, ty::FnDiverging) =>\n-                Ok(ty::FnDiverging),\n-            (a, b) =>\n-                Err(TypeError::ConvergenceMismatch(\n-                    expected_found(relation, &(a != ty::FnDiverging), &(b != ty::FnDiverging)))),\n-        }?;\n-\n-        return Ok(ty::FnSig {inputs: inputs,\n-                             output: output,\n-                             variadic: a.variadic});\n+        Ok(ty::FnSig {inputs: inputs,\n+                      output: output,\n+                      variadic: a.variadic})\n     }\n }\n \n@@ -462,6 +453,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.types.err)\n         }\n \n+        (&ty::TyNever, _) |\n         (&ty::TyChar, _) |\n         (&ty::TyBool, _) |\n         (&ty::TyInt(_), _) |"}, {"sha": "83413d16ffb3ff448b02c8ec138ac04ec6b06524", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -220,18 +220,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoRef<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for ty::FnOutput<'a> {\n-    type Lifted = ty::FnOutput<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            ty::FnConverging(ty) => {\n-                tcx.lift(&ty).map(ty::FnConverging)\n-            }\n-            ty::FnDiverging => Some(ty::FnDiverging)\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n     type Lifted = ty::FnSig<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -498,7 +486,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyAnon(did, substs) => ty::TyAnon(did, substs.fold_with(folder)),\n             ty::TyBool | ty::TyChar | ty::TyStr | ty::TyInt(_) |\n             ty::TyUint(_) | ty::TyFloat(_) | ty::TyError | ty::TyInfer(_) |\n-            ty::TyParam(..) => self.sty.clone(),\n+            ty::TyParam(..) | ty::TyNever => self.sty.clone(),\n         };\n         folder.tcx().mk_ty(sty)\n     }\n@@ -527,7 +515,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyAnon(_, ref substs) => substs.visit_with(visitor),\n             ty::TyBool | ty::TyChar | ty::TyStr | ty::TyInt(_) |\n             ty::TyUint(_) | ty::TyFloat(_) | ty::TyError | ty::TyInfer(_) |\n-            ty::TyParam(..) => false,\n+            ty::TyParam(..) | ty::TyNever => false,\n         }\n     }\n \n@@ -587,26 +575,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::FnOutput<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            ty::FnConverging(ref ty) => ty::FnConverging(ty.fold_with(folder)),\n-            ty::FnDiverging => ty::FnDiverging\n-        }\n-    }\n-\n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_output(self)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            ty::FnConverging(ref ty) => ty.visit_with(visitor),\n-            ty::FnDiverging => false,\n-        }\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::FnSig { inputs: self.inputs.fold_with(folder),"}, {"sha": "9680632ec4dcc59cb901cc3822e025f511660940", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 26, "deletions": 48, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -29,7 +29,6 @@ use serialize::{Decodable, Decoder, Encodable, Encoder};\n \n use hir;\n \n-use self::FnOutput::*;\n use self::InferTy::*;\n use self::TypeVariants::*;\n \n@@ -159,6 +158,9 @@ pub enum TypeVariants<'tcx> {\n     /// `|a| a`.\n     TyClosure(DefId, ClosureSubsts<'tcx>),\n \n+    /// The never type `!`\n+    TyNever,\n+\n     /// A tuple type.  For example, `(i32, bool)`.\n     TyTuple(&'tcx [Ty<'tcx>]),\n \n@@ -474,47 +476,6 @@ pub struct ClosureTy<'tcx> {\n     pub sig: PolyFnSig<'tcx>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub enum FnOutput<'tcx> {\n-    FnConverging(Ty<'tcx>),\n-    FnDiverging\n-}\n-\n-impl<'tcx> FnOutput<'tcx> {\n-    pub fn diverges(&self) -> bool {\n-        *self == FnDiverging\n-    }\n-\n-    pub fn unwrap(self) -> Ty<'tcx> {\n-        match self {\n-            ty::FnConverging(t) => t,\n-            ty::FnDiverging => bug!()\n-        }\n-    }\n-\n-    pub fn unwrap_or(self, def: Ty<'tcx>) -> Ty<'tcx> {\n-        match self {\n-            ty::FnConverging(t) => t,\n-            ty::FnDiverging => def\n-        }\n-    }\n-\n-    pub fn maybe_converging(self) -> Option<Ty<'tcx>> {\n-        match self {\n-            ty::FnConverging(t) => Some(t),\n-            ty::FnDiverging => None\n-        }\n-    }\n-}\n-\n-pub type PolyFnOutput<'tcx> = Binder<FnOutput<'tcx>>;\n-\n-impl<'tcx> PolyFnOutput<'tcx> {\n-    pub fn diverges(&self) -> bool {\n-        self.0.diverges()\n-    }\n-}\n-\n /// Signature of a function type, which I have arbitrarily\n /// decided to use to refer to the input/output types.\n ///\n@@ -524,7 +485,7 @@ impl<'tcx> PolyFnOutput<'tcx> {\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct FnSig<'tcx> {\n     pub inputs: Vec<Ty<'tcx>>,\n-    pub output: FnOutput<'tcx>,\n+    pub output: Ty<'tcx>,\n     pub variadic: bool\n }\n \n@@ -537,7 +498,7 @@ impl<'tcx> PolyFnSig<'tcx> {\n     pub fn input(&self, index: usize) -> ty::Binder<Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.inputs[index])\n     }\n-    pub fn output(&self) -> ty::Binder<FnOutput<'tcx>> {\n+    pub fn output(&self) -> ty::Binder<Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.output.clone())\n     }\n     pub fn variadic(&self) -> bool {\n@@ -933,11 +894,27 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn is_empty(&self, _cx: TyCtxt) -> bool {\n-        // FIXME(#24885): be smarter here\n+    pub fn is_never(&self) -> bool {\n+        match self.sty {\n+            TyNever => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_uninhabited(&self, _cx: TyCtxt) -> bool {\n+        // FIXME(#24885): be smarter here, the AdtDefData::is_empty method could easily be made\n+        // more complete.\n         match self.sty {\n             TyEnum(def, _) | TyStruct(def, _) => def.is_empty(),\n-            _ => false\n+\n+            // FIXME(canndrew): There's no reason why these can't be uncommented, they're tested\n+            // and they don't break anything. But I'm keeping my changes small for now.\n+            //TyNever => true,\n+            //TyTuple(ref tys) => tys.iter().any(|ty| ty.is_uninhabited(cx)),\n+\n+            // FIXME(canndrew): this line breaks core::fmt\n+            //TyRef(_, ref tm) => tm.ty.is_uninhabited(cx),\n+            _ => false,\n         }\n     }\n \n@@ -1195,7 +1172,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         self.fn_sig().inputs()\n     }\n \n-    pub fn fn_ret(&self) -> Binder<FnOutput<'tcx>> {\n+    pub fn fn_ret(&self) -> Binder<Ty<'tcx>> {\n         self.fn_sig().output()\n     }\n \n@@ -1260,6 +1237,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             TyArray(_, _) |\n             TySlice(_) |\n             TyRawPtr(_) |\n+            TyNever |\n             TyTuple(_) |\n             TyParam(_) |\n             TyInfer(_) |"}, {"sha": "d7bb8ff2995aa17e359a97d15bc2879d7e795140", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -485,6 +485,7 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx> {\n                 self.def_id(data.trait_ref.def_id);\n                 self.hash(data.item_name.as_str());\n             }\n+            TyNever |\n             TyBool |\n             TyChar |\n             TyStr |\n@@ -550,7 +551,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n         // Fast-path for primitive types\n         let result = match self.sty {\n-            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n+            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) | TyNever |\n             TyRawPtr(..) | TyFnDef(..) | TyFnPtr(_) | TyRef(_, TypeAndMut {\n                 mutbl: hir::MutImmutable, ..\n             }) => Some(false),\n@@ -596,7 +597,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         let result = match self.sty {\n             TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n             TyBox(..) | TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n-            TyArray(..) | TyTuple(..) | TyClosure(..) => Some(true),\n+            TyArray(..) | TyTuple(..) | TyClosure(..) | TyNever => Some(true),\n \n             TyStr | TyTrait(..) | TySlice(_) => Some(false),\n "}, {"sha": "9c1f9d9537a4f2e7e8e2e3715312b0b36df08818", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -70,7 +70,7 @@ pub fn walk_shallow<'tcx>(ty: Ty<'tcx>) -> IntoIter<Ty<'tcx>> {\n fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n     match parent_ty.sty {\n         ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) |\n-        ty::TyStr | ty::TyInfer(_) | ty::TyParam(_) | ty::TyError => {\n+        ty::TyStr | ty::TyInfer(_) | ty::TyParam(_) | ty::TyNever | ty::TyError => {\n         }\n         ty::TyBox(ty) | ty::TyArray(ty, _) | ty::TySlice(ty) => {\n             stack.push(ty);\n@@ -110,10 +110,7 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n }\n \n fn push_sig_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, sig: &ty::PolyFnSig<'tcx>) {\n-    match sig.0.output {\n-        ty::FnConverging(output) => { stack.push(output); }\n-        ty::FnDiverging => { }\n-    }\n+    stack.push(sig.0.output);\n     push_reversed(stack, &sig.0.inputs);\n }\n "}, {"sha": "bfc2e11d9fbcef7a56c49859ff3494f6be64fea8", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -321,6 +321,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                 ty::TyFloat(..) |\n                 ty::TyError |\n                 ty::TyStr |\n+                ty::TyNever |\n                 ty::TyParam(_) => {\n                     // WfScalar, WfParameter, etc\n                 }"}, {"sha": "896ef49de6f05240d1bc2749effa35e262ddd9d9", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -14,7 +14,7 @@ use ty::subst::{self, Subst};\n use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n use ty::{TyBool, TyChar, TyStruct, TyEnum};\n use ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyFnDef, TyFnPtr};\n-use ty::{TyParam, TyRawPtr, TyRef, TyTuple};\n+use ty::{TyParam, TyRawPtr, TyRef, TyNever, TyTuple};\n use ty::TyClosure;\n use ty::{TyBox, TyTrait, TyInt, TyUint, TyInfer};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -34,7 +34,7 @@ pub fn verbose() -> bool {\n fn fn_sig(f: &mut fmt::Formatter,\n           inputs: &[Ty],\n           variadic: bool,\n-          output: ty::FnOutput)\n+          output: Ty)\n           -> fmt::Result {\n     write!(f, \"(\")?;\n     let mut inputs = inputs.iter();\n@@ -48,18 +48,11 @@ fn fn_sig(f: &mut fmt::Formatter,\n         }\n     }\n     write!(f, \")\")?;\n-\n-    match output {\n-        ty::FnConverging(ty) => {\n-            if !ty.is_nil() {\n-                write!(f, \" -> {}\", ty)?;\n-            }\n-            Ok(())\n-        }\n-        ty::FnDiverging => {\n-            write!(f, \" -> !\")\n-        }\n+    if !output.is_nil() {\n+        write!(f, \" -> {}\", output)?;\n     }\n+\n+    Ok(())\n }\n \n /// Namespace of the path given to parameterized to print.\n@@ -135,7 +128,7 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n     if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n         let projection_ty = projections[0].ty;\n         if let TyTuple(ref args) = substs.types.get_slice(subst::TypeSpace)[0].sty {\n-            return fn_sig(f, args, false, ty::FnConverging(projection_ty));\n+            return fn_sig(f, args, false, projection_ty);\n         }\n     }\n \n@@ -429,6 +422,9 @@ impl<'tcx, 'container> fmt::Debug for ty::AdtDefData<'tcx, 'container> {\n impl<'tcx> fmt::Debug for ty::adjustment::AutoAdjustment<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n+            ty::adjustment::AdjustNeverToAny(ref target) => {\n+                write!(f, \"AdjustNeverToAny({:?})\", target)\n+            }\n             ty::adjustment::AdjustReifyFnPointer => {\n                 write!(f, \"AdjustReifyFnPointer\")\n             }\n@@ -847,6 +843,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 }\n                 write!(f, \"{}\", tm)\n             }\n+            TyNever => write!(f, \"!\"),\n             TyTuple(ref tys) => {\n                 write!(f, \"(\")?;\n                 let mut tys = tys.iter();"}, {"sha": "8ae40e71bee58a6eac20fc76e55c66938aceab60", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use rustc::ty::{FnOutput, TyCtxt};\n+use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n use rustc::util::nodemap::FnvHashMap;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n@@ -231,8 +231,7 @@ impl<'tcx> Index<MovePathIndex> for MovePathData<'tcx> {\n     }\n }\n \n-struct MovePathDataBuilder<'a, 'tcx: 'a> {\n-    mir: &'a Mir<'tcx>,\n+struct MovePathDataBuilder<'tcx> {\n     pre_move_paths: Vec<PreMovePath<'tcx>>,\n     rev_lookup: MovePathLookup<'tcx>,\n }\n@@ -412,7 +411,7 @@ impl<'tcx> MovePathLookup<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n+impl<'tcx> MovePathDataBuilder<'tcx> {\n     fn lookup(&mut self, lval: &Lvalue<'tcx>) -> Lookup<MovePathIndex> {\n         let proj = match *lval {\n             Lvalue::Var(var_idx) =>\n@@ -528,7 +527,6 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n     // BlockContexts constructed on each iteration. (Moving is more\n     // straight-forward than mutable borrows in this instance.)\n     let mut builder = MovePathDataBuilder {\n-        mir: mir,\n         pre_move_paths: Vec::new(),\n         rev_lookup: MovePathLookup::new(mir),\n     };\n@@ -634,13 +632,8 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n             TerminatorKind::Return => {\n                 let source = Location { block: bb,\n                                         index: bb_data.statements.len() };\n-                if let FnOutput::FnConverging(_) = bb_ctxt.builder.mir.return_ty {\n-                    debug!(\"gather_moves Return on_move_out_lval return {:?}\", source);\n-                    bb_ctxt.on_move_out_lval(SK::Return, &Lvalue::ReturnPointer, source);\n-                } else {\n-                    debug!(\"gather_moves Return on_move_out_lval \\\n-                            assuming unreachable return {:?}\", source);\n-                }\n+                debug!(\"gather_moves Return on_move_out_lval return {:?}\", source);\n+                bb_ctxt.on_move_out_lval(SK::Return, &Lvalue::ReturnPointer, source);\n             }\n \n             TerminatorKind::If { ref cond, targets: _ } => {\n@@ -751,15 +744,15 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n     }\n }\n \n-struct BlockContext<'b, 'a: 'b, 'tcx: 'a> {\n+struct BlockContext<'b, 'tcx: 'b> {\n     _tcx: TyCtxt<'b, 'tcx, 'tcx>,\n     moves: &'b mut Vec<MoveOut>,\n-    builder: MovePathDataBuilder<'a, 'tcx>,\n+    builder: MovePathDataBuilder<'tcx>,\n     path_map: &'b mut Vec<Vec<MoveOutIndex>>,\n     loc_map_bb: &'b mut Vec<Vec<MoveOutIndex>>,\n }\n \n-impl<'b, 'a: 'b, 'tcx: 'a> BlockContext<'b, 'a, 'tcx> {\n+impl<'b, 'tcx: 'b> BlockContext<'b, 'tcx> {\n     fn on_move_out_lval(&mut self,\n                         stmt_kind: StmtKind,\n                         lval: &Lvalue<'tcx>,"}, {"sha": "bf6ebcb5efefb6e02bc4fb86281082299b4b11fd", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -215,7 +215,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n             // Check for empty enum, because is_useful only works on inhabited types.\n             let pat_ty = cx.tcx.node_id_to_type(scrut.id);\n             if inlined_arms.is_empty() {\n-                if !pat_ty.is_empty(cx.tcx) {\n+                if !pat_ty.is_uninhabited(cx.tcx) {\n                     // We know the type is inhabited, so this must be wrong\n                     let mut err = struct_span_err!(cx.tcx.sess, ex.span, E0002,\n                                                    \"non-exhaustive patterns: type {} is non-empty\",\n@@ -225,7 +225,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n                          possibly adding wildcards or more match arms.\");\n                     err.emit();\n                 }\n-                // If the type *is* empty, it's vacuously exhaustive\n+                // If the type *is* uninhabited, it's vacuously exhaustive\n                 return;\n             }\n "}, {"sha": "7711091685d3848d4cd43ed0d3c8dd94951c5cf7", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -262,7 +262,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n             abi: Abi::Rust,\n             sig: ty::Binder(ty::FnSig {\n                 inputs: input_args,\n-                output: ty::FnConverging(output_ty),\n+                output: output_ty,\n                 variadic: false,\n             }),\n         }))"}, {"sha": "ed17f3533d49f785750ff73ea7bac3b9aa63f098", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -1110,10 +1110,9 @@ impl LateLintPass for MutableTransmutes {\n                 let typ = cx.tcx.node_id_to_type(expr.id);\n                 match typ.sty {\n                     ty::TyFnDef(_, _, ref bare_fn) if bare_fn.abi == RustIntrinsic => {\n-                        if let ty::FnConverging(to) = bare_fn.sig.0.output {\n-                            let from = bare_fn.sig.0.inputs[0];\n-                            return Some((&from.sty, &to.sty));\n-                        }\n+                        let from = bare_fn.sig.0.inputs[0];\n+                        let to = bare_fn.sig.0.output;\n+                        return Some((&from.sty, &to.sty));\n                     },\n                     _ => ()\n                 }"}, {"sha": "99df5c6e5f95e591b7592d807862781e3f9a2974", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -523,7 +523,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             // Primitive types with a stable representation.\n             ty::TyBool | ty::TyInt(..) | ty::TyUint(..) |\n-            ty::TyFloat(..) => FfiSafe,\n+            ty::TyFloat(..) | ty::TyNever => FfiSafe,\n \n             ty::TyBox(..) => {\n                 FfiUnsafe(\"found Rust type Box<_> in foreign module, \\\n@@ -573,16 +573,11 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 }\n \n                 let sig = cx.erase_late_bound_regions(&bare_fn.sig);\n-                match sig.output {\n-                    ty::FnDiverging => {}\n-                    ty::FnConverging(output) => {\n-                        if !output.is_nil() {\n-                            let r = self.check_type_for_ffi(cache, output);\n-                            match r {\n-                                FfiSafe => {}\n-                                _ => { return r; }\n-                            }\n-                        }\n+                if !sig.output.is_nil() {\n+                    let r = self.check_type_for_ffi(cache, sig.output);\n+                    match r {\n+                        FfiSafe => {}\n+                        _ => { return r; }\n                     }\n                 }\n                 for arg in sig.inputs {\n@@ -641,7 +636,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n \n         if let hir::Return(ref ret_hir) = decl.output {\n-            let ret_ty = sig.output.unwrap();\n+            let ret_ty = sig.output;\n             if !ret_ty.is_nil() {\n                 self.check_type_for_ffi_and_report_errors(ret_hir.span, ret_ty);\n             }"}, {"sha": "57705301aab4e55b27a5edb884c7ad1d9d2e0f5e", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -133,6 +133,7 @@ impl LateLintPass for UnusedResults {\n         let t = cx.tcx.expr_ty(&expr);\n         let warned = match t.sty {\n             ty::TyTuple(ref tys) if tys.is_empty() => return,\n+            ty::TyNever => return,\n             ty::TyBool => return,\n             ty::TyStruct(def, _) |\n             ty::TyEnum(def, _) => {"}, {"sha": "b8e66530ea1533c0e6299bc9b551a731efe30e0e", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -644,6 +644,12 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                             |this| Ok(this.emit_auto_deref_ref(ecx, auto_deref_ref)))\n                     })\n                 }\n+\n+                adjustment::AdjustNeverToAny(ref ty) => {\n+                    this.emit_enum_variant(\"AdjustNeverToAny\", 5, 1, |this| {\n+                        this.emit_enum_variant_arg(0, |this| Ok(this.emit_ty(ecx, ty)))\n+                    })\n+                }\n             }\n         });\n     }\n@@ -1017,7 +1023,8 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                     -> adjustment::AutoAdjustment<'tcx> {\n         self.read_enum(\"AutoAdjustment\", |this| {\n             let variants = [\"AdjustReifyFnPointer\", \"AdjustUnsafeFnPointer\",\n-                            \"AdjustMutToConstPointer\", \"AdjustDerefRef\"];\n+                            \"AdjustMutToConstPointer\", \"AdjustDerefRef\",\n+                            \"AdjustNeverToAny\"];\n             this.read_enum_variant(&variants, |this, i| {\n                 Ok(match i {\n                     1 => adjustment::AdjustReifyFnPointer,\n@@ -1030,6 +1037,13 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n \n                         adjustment::AdjustDerefRef(auto_deref_ref)\n                     }\n+                    5 => {\n+                        let ty: Ty<'tcx> = this.read_enum_variant_arg(0, |this| {\n+                            Ok(this.read_ty(dcx))\n+                        }).unwrap();\n+\n+                        adjustment::AdjustNeverToAny(ty)\n+                    }\n                     _ => bug!(\"bad enum variant for adjustment::AutoAdjustment\")\n                 })\n             })"}, {"sha": "7b4919bb4773be39e41447b8a37b47e299e8a0d4", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -311,6 +311,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         let tcx = self.tcx;\n         match self.next() {\n             'b' => return tcx.types.bool,\n+            '!' => return tcx.types.never,\n             'i' => { /* eat the s of is */ self.next(); return tcx.types.isize },\n             'u' => { /* eat the s of us */ self.next(); return tcx.types.usize },\n             'M' => {\n@@ -539,13 +540,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             'N' => false,\n             r => bug!(\"bad variadic: {}\", r),\n         };\n-        let output = match self.peek() {\n-            'z' => {\n-                self.pos += 1;\n-                ty::FnDiverging\n-            }\n-            _ => ty::FnConverging(self.parse_ty())\n-        };\n+        let output = self.parse_ty();\n         ty::Binder(ty::FnSig {inputs: inputs,\n                               output: output,\n                               variadic: variadic})"}, {"sha": "15bafcdd3c99e9e5d61378be03509da0d264a640", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -74,6 +74,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n     match t.sty {\n         ty::TyBool => { write!(w, \"b\"); }\n         ty::TyChar => { write!(w, \"c\"); }\n+        ty::TyNever => { write!(w, \"!\"); }\n         ty::TyInt(t) => {\n             match t {\n                 ast::IntTy::Is => write!(w, \"is\"),\n@@ -382,14 +383,7 @@ fn enc_fn_sig<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n     } else {\n         write!(w, \"N\");\n     }\n-    match fsig.0.output {\n-        ty::FnConverging(result_type) => {\n-            enc_ty(w, cx, result_type);\n-        }\n-        ty::FnDiverging => {\n-            write!(w, \"z\");\n-        }\n-    }\n+    enc_ty(w, cx, fsig.0.output);\n }\n \n pub fn enc_builtin_bounds(w: &mut Cursor<Vec<u8>>, _cx: &ctxt, bs: &ty::BuiltinBounds) {"}, {"sha": "ae5ccbfd820996f8c1b582e66a501032f538797f", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -96,6 +96,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::LogicalOp { .. } |\n             ExprKind::Box { .. } |\n             ExprKind::Cast { .. } |\n+            ExprKind::NeverToAny { .. } |\n             ExprKind::ReifyFnPointer { .. } |\n             ExprKind::UnsafeFnPointer { .. } |\n             ExprKind::Unsize { .. } |"}, {"sha": "dafc53d3c154208e518295b293d0a51d42a3105f", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -219,6 +219,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Block { .. } |\n             ExprKind::Match { .. } |\n             ExprKind::If { .. } |\n+            ExprKind::NeverToAny { .. } |\n             ExprKind::Loop { .. } |\n             ExprKind::LogicalOp { .. } |\n             ExprKind::Call { .. } |"}, {"sha": "c19ea0f445ac0ce8b60b7fb83dcc2f2297f59d9f", "filename": "src/librustc_mir/build/expr/category.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -56,6 +56,7 @@ impl Category {\n             ExprKind::LogicalOp { .. } |\n             ExprKind::If { .. } |\n             ExprKind::Match { .. } |\n+            ExprKind::NeverToAny { .. } |\n             ExprKind::Call { .. } =>\n                 Some(Category::Rvalue(RvalueFunc::Into)),\n "}, {"sha": "e5930f5a62df6da0c240e2459d2ef1e37bdb9576", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -45,6 +45,25 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Match { discriminant, arms } => {\n                 this.match_expr(destination, expr_span, block, discriminant, arms)\n             }\n+            ExprKind::NeverToAny { source } => {\n+                let source = this.hir.mirror(source);\n+                let is_call = match source.kind {\n+                    ExprKind::Call { .. } => true,\n+                    _ => false,\n+                };\n+\n+                unpack!(block = this.as_rvalue(block, source));\n+\n+                // This is an optimization. If the expression was a call then we already have an\n+                // unreachable block. Don't bother to terminate it and create a new one.\n+                if is_call {\n+                    block.unit()\n+                } else {\n+                    this.cfg.terminate(block, source_info, TerminatorKind::Unreachable);\n+                    let end_block = this.cfg.start_new_block();\n+                    end_block.unit()\n+                }\n+            }\n             ExprKind::If { condition: cond_expr, then: then_expr, otherwise: else_expr } => {\n                 let operand = unpack!(block = this.as_operand(block, cond_expr));\n \n@@ -190,7 +209,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Call { ty, fun, args } => {\n                 let diverges = match ty.sty {\n                     ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => {\n-                        f.sig.0.output.diverges()\n+                        // FIXME(canndrew): This is_never should probably be an is_uninhabited\n+                        f.sig.0.output.is_never()\n                     }\n                     _ => false\n                 };"}, {"sha": "26eb782a73b0031c656e5353801828d421726502", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -162,7 +162,7 @@ macro_rules! unpack {\n pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        fn_id: ast::NodeId,\n                                        arguments: A,\n-                                       return_ty: ty::FnOutput<'gcx>,\n+                                       return_ty: Ty<'gcx>,\n                                        ast_block: &'gcx hir::Block)\n                                        -> (Mir<'tcx>, ScopeAuxiliaryVec)\n     where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n@@ -256,7 +256,7 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     });\n \n     let ty = tcx.expr_ty_adjusted(ast_expr);\n-    builder.finish(vec![], IndexVec::new(), ty::FnConverging(ty))\n+    builder.finish(vec![], IndexVec::new(), ty)\n }\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n@@ -288,7 +288,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn finish(self,\n               upvar_decls: Vec<UpvarDecl>,\n               arg_decls: IndexVec<Arg, ArgDecl<'tcx>>,\n-              return_ty: ty::FnOutput<'tcx>)\n+              return_ty: Ty<'tcx>)\n               -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n         for (index, block) in self.cfg.basic_blocks.iter().enumerate() {\n             if block.terminator.is_none() {\n@@ -310,7 +310,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn args_and_body<A>(&mut self,\n                         mut block: BasicBlock,\n-                        return_ty: ty::FnOutput<'tcx>,\n+                        return_ty: Ty<'tcx>,\n                         arguments: A,\n                         argument_extent: CodeExtent,\n                         ast_block: &'gcx hir::Block)\n@@ -351,11 +351,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n \n         // FIXME(#32959): temporary hack for the issue at hand\n-        let return_is_unit = if let ty::FnConverging(t) = return_ty {\n-            t.is_nil()\n-        } else {\n-            false\n-        };\n+        let return_is_unit = return_ty.is_nil();\n         // start the first basic block and translate the body\n         unpack!(block = self.ast_block(&Lvalue::ReturnPointer, return_is_unit, block, ast_block));\n "}, {"sha": "72b6d7f0e5aa514605252addab0cc268760c4650", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -12,7 +12,7 @@ use dot;\n use rustc::hir::def_id::DefId;\n use rustc::mir::repr::*;\n use rustc::mir::mir_map::MirMap;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::TyCtxt;\n use std::fmt::Debug;\n use std::io::{self, Write};\n use syntax::ast::NodeId;\n@@ -143,14 +143,7 @@ fn write_graph_label<'a, 'tcx, W: Write>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         write!(w, \"{:?}: {}\", Lvalue::Arg(Arg::new(i)), escape(&arg.ty))?;\n     }\n \n-    write!(w, \") -&gt; \")?;\n-\n-    // fn return type.\n-    match mir.return_ty {\n-        ty::FnOutput::FnConverging(ty) => write!(w, \"{}\", escape(ty))?,\n-        ty::FnOutput::FnDiverging => write!(w, \"!\")?,\n-    }\n-\n+    write!(w, \") -&gt; {}\", escape(mir.return_ty))?;\n     write!(w, r#\"<br align=\"left\"/>\"#)?;\n \n     // User variable types (including the user's name in a comment)."}, {"sha": "a61fdb79df822588fb61ca54dbd456f686ea4ff0", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -60,6 +60,14 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     kind: ExprKind::UnsafeFnPointer { source: expr.to_ref() },\n                 };\n             }\n+            Some(&ty::adjustment::AdjustNeverToAny(adjusted_ty)) => {\n+                expr = Expr {\n+                    temp_lifetime: temp_lifetime,\n+                    ty: adjusted_ty,\n+                    span: self.span,\n+                    kind: ExprKind::NeverToAny { source: expr.to_ref() },\n+                };\n+            }\n             Some(&ty::adjustment::AdjustMutToConstPointer) => {\n                 let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n                 expr = Expr {\n@@ -88,9 +96,9 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n \n                         let ref_ty = cx.tcx.no_late_bound_regions(&meth_ty.fn_ret());\n                         let (region, mutbl) = match ref_ty {\n-                            Some(ty::FnConverging(&ty::TyS {\n+                            Some(&ty::TyS {\n                                 sty: ty::TyRef(region, mt), ..\n-                            })) => (region, mt.mutbl),\n+                            }) => (region, mt.mutbl),\n                             _ => span_bug!(expr.span, \"autoderef returned bad type\")\n                         };\n \n@@ -946,10 +954,8 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     let tables = cx.tcx.tables.borrow();\n     let callee = &tables.method_map[&method_call];\n     let ref_ty = callee.ty.fn_ret();\n-    let ref_ty = cx.tcx.no_late_bound_regions(&ref_ty).unwrap().unwrap();\n-    //                                              1~~~~~   2~~~~~\n-    // (1) callees always have all late-bound regions fully instantiated,\n-    // (2) overloaded methods don't return `!`\n+    let ref_ty = cx.tcx.no_late_bound_regions(&ref_ty).unwrap();\n+    // callees always have all late-bound regions fully instantiated,\n \n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type"}, {"sha": "2a5b7d0fb29024950cc727c92a407532a4810324", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -139,6 +139,9 @@ pub enum ExprKind<'tcx> {\n     Cast {\n         source: ExprRef<'tcx>,\n     },\n+    NeverToAny {\n+        source: ExprRef<'tcx>,\n+    },\n     ReifyFnPointer {\n         source: ExprRef<'tcx>,\n     },"}, {"sha": "c58491096b94f0d3957442e3738f9c14c19e3b80", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -14,7 +14,7 @@ use rustc::hir::def_id::DefId;\n use rustc::mir::repr::*;\n use rustc::mir::mir_map::MirMap;\n use rustc::mir::transform::MirSource;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_data_structures::indexed_vec::{Idx};\n use std::fmt::Display;\n@@ -320,16 +320,10 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n             write!(w, \"{:?}: {}\", Lvalue::Arg(i), arg.ty)?;\n         }\n \n-        write!(w, \") -> \")?;\n-\n-        // fn return type.\n-        match mir.return_ty {\n-            ty::FnOutput::FnConverging(ty) => write!(w, \"{}\", ty),\n-            ty::FnOutput::FnDiverging => write!(w, \"!\"),\n-        }\n+        write!(w, \") -> {}\", mir.return_ty)\n     } else {\n         assert!(mir.arg_decls.is_empty());\n-        write!(w, \": {} =\", mir.return_ty.unwrap())\n+        write!(w, \": {} =\", mir.return_ty)\n     }\n }\n "}, {"sha": "21b406c3bf5c99ba1e26d2822d62a3d356c1760e", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -25,7 +25,7 @@\n use rustc::mir::repr::*;\n use rustc::mir::visit::{LvalueContext, MutVisitor, Visitor};\n use rustc::mir::traversal::ReversePostorder;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::TyCtxt;\n use syntax_pos::Span;\n \n use build::Location;\n@@ -303,7 +303,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         let span = self.promoted.span;\n         let new_operand = Operand::Constant(Constant {\n             span: span,\n-            ty: self.promoted.return_ty.unwrap(),\n+            ty: self.promoted.return_ty,\n             literal: Literal::Promoted {\n                 index: Promoted::new(self.source.promoted.len())\n             }\n@@ -391,7 +391,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                     parent_scope: None\n                 }).into_iter().collect(),\n                 IndexVec::new(),\n-                ty::FnConverging(ty),\n+                ty,\n                 IndexVec::new(),\n                 IndexVec::new(),\n                 IndexVec::new(),"}, {"sha": "103a15dadb61cfcc9481049a9eb28d804445bbb3", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -416,7 +416,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             }\n         }\n \n-        let return_ty = mir.return_ty.unwrap();\n+        let return_ty = mir.return_ty;\n         self.qualif = self.return_qualif.unwrap_or(Qualif::NOT_CONST);\n \n         match self.mode {\n@@ -1001,7 +1001,7 @@ impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n \n             // Statics must be Sync.\n             if mode == Mode::Static {\n-                let ty = mir.return_ty.unwrap();\n+                let ty = mir.return_ty;\n                 tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n                     let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n                     let mut fulfillment_cx = traits::FulfillmentContext::new();"}, {"sha": "bbd2a93659b0aff480d70a5ba03d7113c597083c", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -85,9 +85,7 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     }\n \n     fn visit_mir(&mut self, mir: &Mir<'tcx>) {\n-        if let ty::FnConverging(t) = mir.return_ty {\n-            self.sanitize_type(&\"return type\", t);\n-        }\n+        self.sanitize_type(&\"return type\", mir.return_ty);\n         for var_decl in &mir.var_decls {\n             self.sanitize_type(var_decl, var_decl.ty);\n         }\n@@ -135,14 +133,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             Lvalue::Static(def_id) =>\n                 LvalueTy::Ty { ty: self.tcx().lookup_item_type(def_id).ty },\n             Lvalue::ReturnPointer => {\n-                if let ty::FnConverging(return_ty) = self.mir.return_ty {\n-                    LvalueTy::Ty { ty: return_ty }\n-                } else {\n-                    LvalueTy::Ty {\n-                        ty: span_mirbug_and_err!(\n-                            self, lvalue, \"return in diverging function\")\n-                    }\n-                }\n+                LvalueTy::Ty { ty: self.mir.return_ty }\n             }\n             Lvalue::Projection(ref proj) => {\n                 let base_ty = self.sanitize_lvalue(&proj.base);\n@@ -500,22 +491,21 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                        sig: &ty::FnSig<'tcx>,\n                        destination: &Option<(Lvalue<'tcx>, BasicBlock)>) {\n         let tcx = self.tcx();\n-        match (destination, sig.output) {\n-            (&Some(..), ty::FnDiverging) => {\n-                span_mirbug!(self, term, \"call to diverging function {:?} with dest\", sig);\n-            }\n-            (&Some((ref dest, _)), ty::FnConverging(ty)) => {\n+        match *destination {\n+            Some((ref dest, _)) => {\n                 let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n-                if let Err(terr) = self.sub_types(self.last_span, ty, dest_ty) {\n+                if let Err(terr) = self.sub_types(self.last_span, sig.output, dest_ty) {\n                     span_mirbug!(self, term,\n                                  \"call dest mismatch ({:?} <- {:?}): {:?}\",\n-                                 dest_ty, ty, terr);\n+                                 dest_ty, sig.output, terr);\n                 }\n-            }\n-            (&None, ty::FnDiverging) => {}\n-            (&None, ty::FnConverging(..)) => {\n-                span_mirbug!(self, term, \"call to converging function {:?} w/o dest\", sig);\n-             }\n+            },\n+            None => {\n+                // FIXME(canndrew): This is_never should probably be an is_uninhabited\n+                if !sig.output.is_never() {\n+                    span_mirbug!(self, term, \"call to converging function {:?} w/o dest\", sig);\n+                }\n+            },\n         }\n     }\n "}, {"sha": "0c54f20fe76676bfd19c71405c3799a1752e0595", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -632,6 +632,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr) {\n     match v.tcx.tables.borrow().adjustments.get(&e.id) {\n         None |\n+        Some(&ty::adjustment::AdjustNeverToAny(..)) |\n         Some(&ty::adjustment::AdjustReifyFnPointer) |\n         Some(&ty::adjustment::AdjustUnsafeFnPointer) |\n         Some(&ty::adjustment::AdjustMutToConstPointer) => {}"}, {"sha": "de9ddcd934216e4cbcecf16de4c0cbdffc8a6d05", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -440,7 +440,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                     let expr_ty = self.tcx.expr_ty(expr);\n                     let def = match expr_ty.sty {\n                         ty::TyFnDef(_, _, &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n-                            output: ty::FnConverging(ty), ..\n+                            output: ty, ..\n                         }), ..}) => ty,\n                         _ => expr_ty\n                     }.ty_adt_def().unwrap();"}, {"sha": "16cd9186ce9bb43e251b29c5c66d61c799256457", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -671,7 +671,6 @@ fn make_signature(decl: &ast::FnDecl, generics: &ast::Generics) -> String {\n     sig.push_str(&decl.inputs.iter().map(arg_to_string).collect::<Vec<_>>().join(\", \"));\n     sig.push(')');\n     match decl.output {\n-        ast::FunctionRetTy::None(_) => sig.push_str(\" -> !\"),\n         ast::FunctionRetTy::Default(_) => {}\n         ast::FunctionRetTy::Ty(ref t) => sig.push_str(&format!(\" -> {}\", ty_to_string(t))),\n     }"}, {"sha": "27a8c1f1df47686e3b0d6f66a127ab80685c831d", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -1593,7 +1593,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     }\n \n     let t = node_id_type(bcx, discr_expr.id);\n-    let chk = if t.is_empty(tcx) {\n+    let chk = if t.is_uninhabited(tcx) {\n         Unreachable\n     } else {\n         Infallible"}, {"sha": "3a7fde6a36bad02e6629ef9c27ea297b148b2d0e", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -326,10 +326,7 @@ impl FnType {\n             }\n         };\n \n-        let ret_ty = match sig.output {\n-            ty::FnConverging(ret_ty) => ret_ty,\n-            ty::FnDiverging => ccx.tcx().mk_nil()\n-        };\n+        let ret_ty = sig.output;\n         let mut ret = arg_of(ret_ty, true);\n \n         if !type_is_fat_ptr(ccx.tcx(), ret_ty) {\n@@ -470,7 +467,7 @@ impl FnType {\n             };\n             // Fat pointers are returned by-value.\n             if !self.ret.is_ignore() {\n-                if !type_is_fat_ptr(ccx.tcx(), sig.output.unwrap()) {\n+                if !type_is_fat_ptr(ccx.tcx(), sig.output) {\n                     fixup(&mut self.ret);\n                 }\n             }"}, {"sha": "c78cda75e820e548d5a585c1b5e2d1736745f3d0", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -1972,7 +1972,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     let sig = ccx.tcx().erase_late_bound_regions(&ctor_ty.fn_sig());\n     let sig = ccx.tcx().normalize_associated_type(&sig);\n-    let result_ty = sig.output.unwrap();\n+    let result_ty = sig.output;\n \n     // Get location to store the result. If the user does not care about\n     // the result, just make a stack slot\n@@ -2054,7 +2054,7 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     if !fcx.fn_ty.ret.is_ignore() {\n         let dest = fcx.get_ret_slot(bcx, \"eret_slot\");\n         let dest_val = adt::MaybeSizedValue::sized(dest); // Can return unsized value\n-        let repr = adt::represent_type(ccx, sig.output.unwrap());\n+        let repr = adt::represent_type(ccx, sig.output);\n         let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n         let mut arg_idx = 0;\n         for (i, arg_ty) in sig.inputs.into_iter().enumerate() {"}, {"sha": "aaec2a47025a2e2a7d788e57ac96c817f8a4596b", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -641,10 +641,7 @@ fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let opt_llretslot = dest.and_then(|dest| match dest {\n         expr::SaveIn(dst) => Some(dst),\n         expr::Ignore => {\n-            let needs_drop = || match output {\n-                ty::FnConverging(ret_ty) => bcx.fcx.type_needs_drop(ret_ty),\n-                ty::FnDiverging => false\n-            };\n+            let needs_drop = || bcx.fcx.type_needs_drop(output);\n             if fn_ty.ret.is_indirect() || fn_ty.ret.cast.is_some() || needs_drop() {\n                 // Push the out-pointer if we use an out-pointer for this\n                 // return type, otherwise push \"undef\".\n@@ -706,16 +703,17 @@ fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     // If the caller doesn't care about the result of this fn call,\n     // drop the temporary slot we made.\n-    match (dest, opt_llretslot, output) {\n-        (Some(expr::Ignore), Some(llretslot), ty::FnConverging(ret_ty)) => {\n+    match (dest, opt_llretslot) {\n+        (Some(expr::Ignore), Some(llretslot)) => {\n             // drop the value if it is not being saved.\n-            bcx = glue::drop_ty(bcx, llretslot, ret_ty, debug_loc);\n+            bcx = glue::drop_ty(bcx, llretslot, output, debug_loc);\n             call_lifetime_end(bcx, llretslot);\n         }\n         _ => {}\n     }\n \n-    if output == ty::FnDiverging {\n+    // FIXME(canndrew): This is_never should really be an is_uninhabited\n+    if output.is_never() {\n         Unreachable(bcx);\n     }\n "}, {"sha": "77b2c43167cfd280b20122f7c4bc233740141c4d", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -201,7 +201,11 @@ pub fn trans_closure_body_via_mir<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     trans_closure_expr(Dest::Ignore(ccx),\n                        &hir::FnDecl {\n                            inputs: P::new(),\n-                           output: hir::NoReturn(DUMMY_SP),\n+                           output: hir::Return(P(hir::Ty {\n+                               id: DUMMY_NODE_ID,\n+                               span: DUMMY_SP,\n+                               node: hir::Ty_::TyNever,\n+                           })),\n                            variadic: false\n                        },\n                        &hir::Block {"}, {"sha": "acc302430aee68383513650f15f2db85cf1b3aa2", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -791,6 +791,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         ty::TyRef(..)   |\n         ty::TyFnDef(..) |\n         ty::TyFnPtr(_)  |\n+        ty::TyNever     |\n         ty::TyTrait(_)  => {\n             /* nothing to do */\n         }"}, {"sha": "79cf77cd9d35d534c8434dc1dac8b5dd4d444d3a", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -558,7 +558,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n             abi: Abi::C,\n             sig: ty::Binder(ty::FnSig {\n                 inputs: vec![tcx.mk_mut_ptr(tcx.types.u8)],\n-                output: ty::FnDiverging,\n+                output: tcx.types.never,\n                 variadic: false\n             }),\n         }));\n@@ -1240,8 +1240,8 @@ pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            inlined_vid);\n     let adt_def = match ctor_ty.sty {\n         ty::TyFnDef(_, _, &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n-            output: ty::FnConverging(ty), ..\n-        }), ..}) => ty,\n+            output, ..\n+        }), ..}) => output,\n         _ => ctor_ty\n     }.ty_adt_def().unwrap();\n     let variant_def_id = if ccx.tcx().map.is_inlined_node_id(inlined_vid) {"}, {"sha": "3ecba3691d279d22dd994b002a66de89e556db4b", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -34,7 +34,7 @@ use type_of;\n use value::Value;\n use Disr;\n use rustc::ty::subst::Substs;\n-use rustc::ty::adjustment::{AdjustDerefRef, AdjustReifyFnPointer};\n+use rustc::ty::adjustment::{AdjustNeverToAny, AdjustDerefRef, AdjustReifyFnPointer};\n use rustc::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::cast::{CastTy,IntTy};\n@@ -348,6 +348,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                             &cx.tcx().expr_ty_adjusted(e));\n     let opt_adj = cx.tcx().tables.borrow().adjustments.get(&e.id).cloned();\n     match opt_adj {\n+        Some(AdjustNeverToAny(..)) => span_bug!(e.span, \"const expression of type ! encountered\"),\n         Some(AdjustReifyFnPointer) => {\n             match ety.sty {\n                 ty::TyFnDef(def_id, substs, _) => {"}, {"sha": "3fe8b2b66791a8c65b3db77cca77596c7b167a9d", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 9, "deletions": 27, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -171,6 +171,7 @@ impl<'tcx> TypeMap<'tcx> {\n         unique_type_id.push('{');\n \n         match type_.sty {\n+            ty::TyNever    |\n             ty::TyBool     |\n             ty::TyChar     |\n             ty::TyStr      |\n@@ -278,16 +279,9 @@ impl<'tcx> TypeMap<'tcx> {\n                 }\n \n                 unique_type_id.push_str(\")->\");\n-                match sig.output {\n-                    ty::FnConverging(ret_ty) => {\n-                        let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n-                        let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                        unique_type_id.push_str(&return_type_id[..]);\n-                    }\n-                    ty::FnDiverging => {\n-                        unique_type_id.push_str(\"!\");\n-                    }\n-                }\n+                let return_type_id = self.get_unique_type_id_of_type(cx, sig.output);\n+                let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n+                unique_type_id.push_str(&return_type_id[..]);\n             },\n             ty::TyClosure(_, substs) if substs.upvar_tys.is_empty() => {\n                 push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n@@ -595,12 +589,9 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs.len() + 1);\n \n     // return type\n-    signature_metadata.push(match signature.output {\n-        ty::FnConverging(ret_ty) => match ret_ty.sty {\n-            ty::TyTuple(ref tys) if tys.is_empty() => ptr::null_mut(),\n-            _ => type_metadata(cx, ret_ty, span)\n-        },\n-        ty::FnDiverging => diverging_type_metadata(cx)\n+    signature_metadata.push(match signature.output.sty {\n+        ty::TyTuple(ref tys) if tys.is_empty() => ptr::null_mut(),\n+        _ => type_metadata(cx, signature.output, span)\n     });\n \n     // regular arguments\n@@ -704,6 +695,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let sty = &t.sty;\n     let MetadataCreationResult { metadata, already_stored_in_typemap } = match *sty {\n+        ty::TyNever    |\n         ty::TyBool     |\n         ty::TyChar     |\n         ty::TyInt(_)   |\n@@ -914,23 +906,13 @@ pub fn scope_metadata(fcx: &FunctionContext,\n     }\n }\n \n-pub fn diverging_type_metadata(cx: &CrateContext) -> DIType {\n-    unsafe {\n-        llvm::LLVMRustDIBuilderCreateBasicType(\n-            DIB(cx),\n-            \"!\\0\".as_ptr() as *const _,\n-            bytes_to_bits(0),\n-            bytes_to_bits(0),\n-            DW_ATE_unsigned)\n-    }\n-}\n-\n fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                  t: Ty<'tcx>) -> DIType {\n \n     debug!(\"basic_type_metadata: {:?}\", t);\n \n     let (name, encoding) = match t.sty {\n+        ty::TyNever => (\"!\", DW_ATE_unsigned),\n         ty::TyTuple(ref elements) if elements.is_empty() =>\n             (\"()\", DW_ATE_unsigned),\n         ty::TyBool => (\"bool\", DW_ATE_boolean),"}, {"sha": "d6a4ce3c43a4ecc9b9ec67e0c1522daf93ed5889", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -17,8 +17,7 @@ use self::VariableKind::*;\n use self::utils::{DIB, span_start, create_DIArray, is_node_local_to_unit};\n use self::namespace::mangled_name_of_item;\n use self::type_names::compute_debuginfo_type_name;\n-use self::metadata::{type_metadata, diverging_type_metadata};\n-use self::metadata::{file_metadata, TypeMap};\n+use self::metadata::{type_metadata, file_metadata, TypeMap};\n use self::source_loc::InternalDebugLocation::{self, UnknownLocation};\n \n use llvm;\n@@ -325,12 +324,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         let mut signature = Vec::with_capacity(sig.inputs.len() + 1);\n \n         // Return type -- llvm::DIBuilder wants this at index 0\n-        signature.push(match sig.output {\n-            ty::FnConverging(ret_ty) => match ret_ty.sty {\n-                ty::TyTuple(ref tys) if tys.is_empty() => ptr::null_mut(),\n-                _ => type_metadata(cx, ret_ty, syntax_pos::DUMMY_SP)\n-            },\n-            ty::FnDiverging => diverging_type_metadata(cx)\n+        signature.push(match sig.output.sty {\n+            ty::TyTuple(ref tys) if tys.is_empty() => ptr::null_mut(),\n+            _ => type_metadata(cx, sig.output, syntax_pos::DUMMY_SP)\n         });\n \n         let inputs = if abi == Abi::RustCall {"}, {"sha": "73b1c828663e1b660751578045a2dce73b28e956", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -40,6 +40,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyBool => output.push_str(\"bool\"),\n         ty::TyChar => output.push_str(\"char\"),\n         ty::TyStr => output.push_str(\"str\"),\n+        ty::TyNever => output.push_str(\"!\"),\n         ty::TyInt(int_ty) => output.push_str(int_ty.ty_to_string()),\n         ty::TyUint(uint_ty) => output.push_str(uint_ty.ty_to_string()),\n         ty::TyFloat(float_ty) => output.push_str(float_ty.ty_to_string()),\n@@ -133,15 +134,9 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push(')');\n \n-            match sig.output {\n-                ty::FnConverging(result_type) if result_type.is_nil() => {}\n-                ty::FnConverging(result_type) => {\n-                    output.push_str(\" -> \");\n-                    push_debuginfo_type_name(cx, result_type, true, output);\n-                }\n-                ty::FnDiverging => {\n-                    output.push_str(\" -> !\");\n-                }\n+            if !sig.output.is_nil() {\n+                output.push_str(\" -> \");\n+                push_debuginfo_type_name(cx, sig.output, true, output);\n             }\n         },\n         ty::TyClosure(..) => {"}, {"sha": "4d9ee187ac50c36ddad54d98548175e874b4c26f", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -111,7 +111,8 @@ pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n     let fty = FnType::new(ccx, abi, &sig, &[]);\n     let llfn = declare_raw_fn(ccx, name, fty.cconv, fty.llvm_type(ccx));\n \n-    if sig.output == ty::FnDiverging {\n+    // FIXME(canndrew): This is_never should really be an is_uninhabited\n+    if sig.output.is_never() {\n         llvm::Attribute::NoReturn.apply_llfn(Function, llfn);\n     }\n "}, {"sha": "6c894ddad1a94981559d56da9aef60ad564f84e7", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -69,7 +69,7 @@ use tvec;\n use type_of;\n use value::Value;\n use Disr;\n-use rustc::ty::adjustment::{AdjustDerefRef, AdjustReifyFnPointer};\n+use rustc::ty::adjustment::{AdjustNeverToAny, AdjustDerefRef, AdjustReifyFnPointer};\n use rustc::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -348,6 +348,7 @@ fn adjustment_required<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     match adjustment {\n+        AdjustNeverToAny(..) => true,\n         AdjustReifyFnPointer => true,\n         AdjustUnsafeFnPointer | AdjustMutToConstPointer => {\n             // purely a type-level thing\n@@ -380,6 +381,12 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     debug!(\"unadjusted datum for expr {:?}: {:?} adjustment={:?}\",\n            expr, datum, adjustment);\n     match adjustment {\n+        AdjustNeverToAny(ref target) => {\n+            let mono_target = bcx.monomorphize(target);\n+            let llty = type_of::type_of(bcx.ccx(), mono_target);\n+            let dummy = C_undef(llty.ptr_to());\n+            datum = Datum::new(dummy, mono_target, Lvalue::new(\"never\")).to_expr_datum();\n+        }\n         AdjustReifyFnPointer => {\n             match datum.ty.sty {\n                 ty::TyFnDef(def_id, substs, _) => {\n@@ -796,7 +803,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let ix_datum = unpack_datum!(bcx, trans(bcx, idx));\n \n             let ref_ty = // invoked methods have LB regions instantiated:\n-                bcx.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap().unwrap();\n+                bcx.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n             let elt_ty = match ref_ty.builtin_deref(true, ty::NoPreference) {\n                 None => {\n                     span_bug!(index_expr.span,\n@@ -2053,7 +2060,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n \n             let ref_ty = // invoked methods have their LB regions instantiated\n-                ccx.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap().unwrap();\n+                ccx.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n             let scratch = rvalue_scratch_datum(bcx, ref_ty, \"overloaded_deref\");\n \n             bcx = Callee::method(bcx, method)"}, {"sha": "7be173d17b487ded0132b7408c214a96becb84e5", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -132,7 +132,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     // For `transmute` we can just trans the input expr directly into dest\n     if name == \"transmute\" {\n-        let llret_ty = type_of::type_of(ccx, ret_ty.unwrap());\n+        let llret_ty = type_of::type_of(ccx, ret_ty);\n         match args {\n             callee::ArgExprs(arg_exprs) => {\n                 assert_eq!(arg_exprs.len(), 1);\n@@ -315,11 +315,6 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         return Result::new(bcx, C_nil(ccx));\n     }\n \n-    let ret_ty = match ret_ty {\n-        ty::FnConverging(ret_ty) => ret_ty,\n-        ty::FnDiverging => bug!()\n-    };\n-\n     let llret_ty = type_of::type_of(ccx, ret_ty);\n \n     // Get location to store the result. If the user does\n@@ -1226,7 +1221,7 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n                     name: &str,\n                     inputs: Vec<Ty<'tcx>>,\n-                    output: ty::FnOutput<'tcx>,\n+                    output: Ty<'tcx>,\n                     trans: &mut for<'b> FnMut(Block<'b, 'tcx>))\n                     -> ValueRef {\n     let ccx = fcx.ccx;\n@@ -1272,11 +1267,11 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         abi: Abi::Rust,\n         sig: ty::Binder(ty::FnSig {\n             inputs: vec![i8p],\n-            output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n+            output: tcx.mk_nil(),\n             variadic: false,\n         }),\n     }));\n-    let output = ty::FnOutput::FnConverging(tcx.types.i32);\n+    let output = tcx.types.i32;\n     let rust_try = gen_fn(fcx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, trans);\n     ccx.rust_try_fn().set(Some(rust_try));\n     return rust_try"}, {"sha": "e0d959f4774a64e3a2952f85bb6dcf081f931025", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -19,6 +19,7 @@ use rustc::mir::visit::{Visitor, LvalueContext};\n use rustc::mir::traversal;\n use common::{self, Block, BlockAndBuilder};\n use glue;\n+use std::iter;\n use super::rvalue;\n \n pub fn lvalue_locals<'bcx, 'tcx>(bcx: Block<'bcx,'tcx>,\n@@ -31,7 +32,7 @@ pub fn lvalue_locals<'bcx, 'tcx>(bcx: Block<'bcx,'tcx>,\n     let local_types = mir.arg_decls.iter().map(|a| a.ty)\n                .chain(mir.var_decls.iter().map(|v| v.ty))\n                .chain(mir.temp_decls.iter().map(|t| t.ty))\n-               .chain(mir.return_ty.maybe_converging());\n+               .chain(iter::once(mir.return_ty));\n     for (index, ty) in local_types.enumerate() {\n         let ty = bcx.monomorphize(&ty);\n         debug!(\"local {} has type {:?}\", index, ty);"}, {"sha": "56d02fa1fac4fbc02bdfe337ff48f77607b2e7dd", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -525,7 +525,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             // Make a fake operand for store_return\n                             let op = OperandRef {\n                                 val: Ref(dst),\n-                                ty: sig.output.unwrap()\n+                                ty: sig.output,\n                             };\n                             self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n                         }\n@@ -563,7 +563,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             debug_loc.apply_to_bcx(ret_bcx);\n                             let op = OperandRef {\n                                 val: Immediate(invokeret),\n-                                ty: sig.output.unwrap()\n+                                ty: sig.output,\n                             };\n                             self.store_return(&ret_bcx, ret_dest, fn_ty.ret, op);\n                         });\n@@ -574,7 +574,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     if let Some((_, target)) = *destination {\n                         let op = OperandRef {\n                             val: Immediate(llret),\n-                            ty: sig.output.unwrap()\n+                            ty: sig.output,\n                         };\n                         self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n                         funclet_br(self, bcx, target);"}, {"sha": "727b680541dd7cf81579f2ce97e17982009beb0f", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -26,6 +26,7 @@ use syntax::parse::token::keywords;\n \n use std::ops::Deref;\n use std::rc::Rc;\n+use std::iter;\n \n use basic_block::BasicBlock;\n \n@@ -183,7 +184,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n \n         let locals = mir.temp_decls.iter().enumerate().map(|(i, decl)| {\n             (mir::Lvalue::Temp(mir::Temp::new(i)), decl.ty)\n-        }).chain(mir.return_ty.maybe_converging().map(|ty| (mir::Lvalue::ReturnPointer, ty)));\n+        }).chain(iter::once((mir::Lvalue::ReturnPointer, mir.return_ty)));\n \n         args.into_iter().chain(vars).chain(locals.map(|(lvalue, ty)| {\n             let ty = bcx.monomorphize(&ty);"}, {"sha": "90058f0b8329a30afdc3f0d694c9438599fffd7a", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -233,7 +233,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n         let sig = ty::FnSig {\n             inputs: vec![tcx.mk_mut_ptr(tcx.types.i8)],\n-            output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n+            output: tcx.mk_nil(),\n             variadic: false,\n         };\n \n@@ -412,6 +412,7 @@ pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ty::TyBool              => output.push_str(\"bool\"),\n         ty::TyChar              => output.push_str(\"char\"),\n         ty::TyStr               => output.push_str(\"str\"),\n+        ty::TyNever             => output.push_str(\"!\"),\n         ty::TyInt(ast::IntTy::Is)    => output.push_str(\"isize\"),\n         ty::TyInt(ast::IntTy::I8)    => output.push_str(\"i8\"),\n         ty::TyInt(ast::IntTy::I16)   => output.push_str(\"i16\"),\n@@ -515,15 +516,9 @@ pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             output.push(')');\n \n-            match sig.output {\n-                ty::FnConverging(result_type) if result_type.is_nil() => {}\n-                ty::FnConverging(result_type) => {\n-                    output.push_str(\" -> \");\n-                    push_unique_type_name(tcx, result_type, output);\n-                }\n-                ty::FnDiverging => {\n-                    output.push_str(\" -> !\");\n-                }\n+            if !sig.output.is_nil() {\n+                output.push_str(\" -> \");\n+                push_unique_type_name(tcx, sig.output, output);\n             }\n         },\n         ty::TyClosure(def_id, ref closure_substs) => {"}, {"sha": "e6794149fcb3b5b7088dc476b7aa6b1977d6abcd", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -64,6 +64,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         ty::TyInt(t) => Type::int_from_ty(cx, t),\n         ty::TyUint(t) => Type::uint_from_ty(cx, t),\n         ty::TyFloat(t) => Type::float_from_ty(cx, t),\n+        ty::TyNever => Type::nil(cx),\n \n         ty::TyBox(ty) |\n         ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n@@ -249,6 +250,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       ty::TyInt(t) => Type::int_from_ty(cx, t),\n       ty::TyUint(t) => Type::uint_from_ty(cx, t),\n       ty::TyFloat(t) => Type::float_from_ty(cx, t),\n+      ty::TyNever => Type::nil(cx),\n       ty::TyEnum(def, ref substs) => {\n           // Only create the named struct, but don't fill it in. We\n           // fill it in *after* placing it into the type cache. This"}, {"sha": "ed67c9fbe30bee94e3f7ebeb94dc8a0831e28bfe", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -1700,6 +1700,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 let t = self.ast_ty_to_ty(rscope1, &mt.ty);\n                 tcx.mk_ref(tcx.mk_region(r), ty::TypeAndMut {ty: t, mutbl: mt.mutbl})\n             }\n+            hir::TyNever => {\n+                tcx.types.never\n+            },\n             hir::TyTup(ref fields) => {\n                 let flds = fields.iter()\n                                  .map(|t| self.ast_ty_to_ty(rscope, &t))\n@@ -1920,11 +1923,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let output_ty = match decl.output {\n             hir::Return(ref output) =>\n-                ty::FnConverging(self.convert_ty_with_lifetime_elision(implied_output_region,\n-                                                                       &output,\n-                                                                       ret_anon_scope)),\n-            hir::DefaultReturn(..) => ty::FnConverging(self.tcx().mk_nil()),\n-            hir::NoReturn(..) => ty::FnDiverging\n+                self.convert_ty_with_lifetime_elision(implied_output_region,\n+                                                      &output,\n+                                                      ret_anon_scope),\n+            hir::DefaultReturn(..) => self.tcx().mk_nil(),\n         };\n \n         (self.tcx().mk_bare_fn(ty::BareFnTy {\n@@ -2067,11 +2069,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             _ if is_infer && expected_ret_ty.is_some() =>\n                 expected_ret_ty.unwrap(),\n             _ if is_infer =>\n-                ty::FnConverging(self.ty_infer(None, None, None, decl.output.span())),\n+                self.ty_infer(None, None, None, decl.output.span()),\n             hir::Return(ref output) =>\n-                ty::FnConverging(self.ast_ty_to_ty(&rb, &output)),\n+                self.ast_ty_to_ty(&rb, &output),\n             hir::DefaultReturn(..) => bug!(),\n-            hir::NoReturn(..) => ty::FnDiverging\n         };\n \n         debug!(\"ty_of_closure: input_tys={:?}\", input_tys);"}, {"sha": "04f22b195110f59b6bb7306695bc77808b98c8ab", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -610,7 +610,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let scheme = tcx.lookup_item_type(def.def_id());\n         let scheme = if scheme.ty.is_fn() {\n             // Replace constructor type with constructed type for tuple struct patterns.\n-            let fn_ret = tcx.no_late_bound_regions(&scheme.ty.fn_ret()).unwrap().unwrap();\n+            let fn_ret = tcx.no_late_bound_regions(&scheme.ty.fn_ret()).unwrap();\n             ty::TypeScheme { ty: fn_ret, generics: scheme.generics }\n         } else {\n             // Leave the type as is for unit structs (backward compatibility)."}, {"sha": "985c3be149617dc388a08a2e932b92f41f1eeef9", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -213,7 +213,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // set up all the node type bindings.\n                 error_fn_sig = ty::Binder(ty::FnSig {\n                     inputs: self.err_args(arg_exprs.len()),\n-                    output: ty::FnConverging(self.tcx.types.err),\n+                    output: self.tcx.types.err,\n                     variadic: false\n                 });\n \n@@ -345,10 +345,9 @@ impl<'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> for CallResolution<'gcx, 'tc\n                     fcx.demand_eqtype(self.call_expr.span, self_arg_ty, method_arg_ty);\n                 }\n \n-                let nilty = fcx.tcx.mk_nil();\n                 fcx.demand_eqtype(self.call_expr.span,\n-                                  method_sig.output.unwrap_or(nilty),\n-                                  self.fn_sig.output.unwrap_or(nilty));\n+                                  method_sig.output,\n+                                  self.fn_sig.output);\n \n                 fcx.write_overloaded_call_method_map(self.call_expr, method_callee);\n             }"}, {"sha": "3acb8017eec509acaadd09ef48ed36c343095c2d", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -221,7 +221,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let fn_sig = ty::FnSig {\n             inputs: input_tys,\n-            output: ty::FnConverging(ret_param_ty),\n+            output: ret_param_ty,\n             variadic: false\n         };\n         debug!(\"deduce_sig_from_projection: fn_sig {:?}\", fn_sig);"}, {"sha": "4a0d529812891f48049e128824b5cec7cf8b1ece", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -68,6 +68,7 @@ use rustc::traits::{self, ObligationCause};\n use rustc::ty::adjustment::{AutoAdjustment, AutoDerefRef, AdjustDerefRef};\n use rustc::ty::adjustment::{AutoPtr, AutoUnsafe, AdjustReifyFnPointer};\n use rustc::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n+use rustc::ty::adjustment::AdjustNeverToAny;\n use rustc::ty::{self, LvaluePreference, TypeAndMut, Ty};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n@@ -167,6 +168,10 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             return self.identity(b);\n         }\n \n+        if a.is_never() {\n+            return Ok((b, AdjustNeverToAny(b)));\n+        }\n+\n         // Consider coercing the subtype to a DST\n         let unsize = self.coerce_unsized(a, b);\n         if unsize.is_ok() {\n@@ -637,7 +642,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 apply(&mut coerce, &|| Some(expr), source, target)?;\n             if !adjustment.is_identity() {\n                 debug!(\"Success, coerced with {:?}\", adjustment);\n-                assert!(!self.tables.borrow().adjustments.contains_key(&expr.id));\n+                match self.tables.borrow().adjustments.get(&expr.id) {\n+                    None | Some(&AdjustNeverToAny(..)) => (),\n+                    _ => bug!(\"expr already has an adjustment on it!\"),\n+                };\n                 self.write_adjustment(expr.id, adjustment);\n             }\n             Ok(ty)\n@@ -741,6 +749,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     _ => false\n                 },\n+                Some(&AdjustNeverToAny(_)) => true,\n                 Some(_) => false,\n                 None => true\n             };\n@@ -776,7 +785,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Ok((ty, adjustment)) => {\n                 if !adjustment.is_identity() {\n                     for expr in exprs() {\n-                        self.write_adjustment(expr.id, adjustment);\n+                        let previous = self.tables.borrow().adjustments.get(&expr.id).cloned();\n+                        if let Some(AdjustNeverToAny(_)) = previous {\n+                            self.write_adjustment(expr.id, AdjustNeverToAny(ty));\n+                        } else {\n+                            self.write_adjustment(expr.id, adjustment);\n+                        }\n                     }\n                 }\n                 Ok(ty)"}, {"sha": "f3a01ef7409fa48fa7a86b600b963d7f9a59e4da", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -433,7 +433,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n     // We still need to ensure all referenced data is safe.\n     match ty.sty {\n         ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) |\n-        ty::TyFloat(_) | ty::TyStr => {\n+        ty::TyFloat(_) | ty::TyStr | ty::TyNever => {\n             // primitive - definitely safe\n             Ok(())\n         }"}, {"sha": "4334f043772e361962a409b94e1ec0e7c6a82a0c", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -30,8 +30,8 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    it: &hir::ForeignItem,\n                                    n_tps: usize,\n                                    abi: Abi,\n-                                   inputs: Vec<ty::Ty<'tcx>>,\n-                                   output: ty::FnOutput<'tcx>) {\n+                                   inputs: Vec<Ty<'tcx>>,\n+                                   output: Ty<'tcx>) {\n     let tcx = ccx.tcx;\n     let def_id = tcx.map.local_def_id(it.id);\n     let i_ty = tcx.lookup_item_type(def_id);\n@@ -106,9 +106,9 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n                 return;\n             }\n         };\n-        (n_tps, inputs, ty::FnConverging(output))\n+        (n_tps, inputs, output)\n     } else if &name[..] == \"abort\" || &name[..] == \"unreachable\" {\n-        (0, Vec::new(), ty::FnDiverging)\n+        (0, Vec::new(), tcx.types.never)\n     } else {\n         let (n_tps, inputs, output) = match &name[..] {\n             \"breakpoint\" => (0, Vec::new(), tcx.mk_nil()),\n@@ -293,7 +293,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n                     abi: Abi::Rust,\n                     sig: ty::Binder(FnSig {\n                         inputs: vec![mut_u8],\n-                        output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n+                        output: tcx.mk_nil(),\n                         variadic: false,\n                     }),\n                 });\n@@ -306,7 +306,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n                 return;\n             }\n         };\n-        (n_tps, inputs, ty::FnConverging(output))\n+        (n_tps, inputs, output)\n     };\n     equate_intrinsic_type(ccx, it, n_tps, Abi::RustIntrinsic, inputs, output)\n }\n@@ -379,7 +379,7 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n                     }\n                     match_intrinsic_type_to_type(ccx, \"return value\", it.span,\n                                                  &mut structural_to_nomimal,\n-                                                 &intr.output, sig.output.unwrap());\n+                                                 &intr.output, sig.output);\n                     return\n                 }\n                 None => {\n@@ -392,7 +392,7 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n     };\n \n     equate_intrinsic_type(ccx, it, n_tps, Abi::PlatformIntrinsic,\n-                          inputs, ty::FnConverging(output))\n+                          inputs, output)\n }\n \n // walk the expected type and the actual type in lock step, checking they're"}, {"sha": "d985d3ccbea89751909d018202a7cc999f6086df", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 85, "deletions": 86, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -372,7 +372,7 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // expects the types within the function to be consistent.\n     err_count_on_creation: usize,\n \n-    ret_ty: ty::FnOutput<'tcx>,\n+    ret_ty: Ty<'tcx>,\n \n     ps: RefCell<UnsafetyState>,\n \n@@ -676,14 +676,9 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     let mut fcx = FnCtxt::new(inherited, fn_sig.output, body.id);\n     *fcx.ps.borrow_mut() = UnsafetyState::function(unsafety, unsafety_id);\n \n-    fn_sig.output = match fcx.ret_ty {\n-        ty::FnConverging(orig_ret_ty) => {\n-            fcx.require_type_is_sized(orig_ret_ty, decl.output.span(), traits::ReturnType);\n-            ty::FnConverging(fcx.instantiate_anon_types(&orig_ret_ty))\n-        }\n-        ty::FnDiverging => ty::FnDiverging\n-    };\n-    fcx.ret_ty = fn_sig.output;\n+    fcx.require_type_is_sized(fcx.ret_ty, decl.output.span(), traits::ReturnType);\n+    fcx.ret_ty = fcx.instantiate_anon_types(&fcx.ret_ty);\n+    fn_sig.output = fcx.ret_ty;\n \n     {\n         let mut visit = GatherLocalsVisitor { fcx: &fcx, };\n@@ -714,10 +709,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     inherited.tables.borrow_mut().liberated_fn_sigs.insert(fn_id, fn_sig);\n \n-    fcx.check_block_with_expected(body, match fcx.ret_ty {\n-        ty::FnConverging(result_type) => ExpectHasType(result_type),\n-        ty::FnDiverging => NoExpectation\n-    });\n+    fcx.check_block_with_expected(body, ExpectHasType(fcx.ret_ty));\n \n     fcx\n }\n@@ -1168,7 +1160,7 @@ fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                                    expected_type: Ty<'tcx>,\n                                    id: ast::NodeId) {\n     ccx.inherited(id).enter(|inh| {\n-        let fcx = FnCtxt::new(&inh, ty::FnConverging(expected_type), expr.id);\n+        let fcx = FnCtxt::new(&inh, expected_type, expr.id);\n         fcx.require_type_is_sized(expected_type, expr.span, traits::ConstSized);\n \n         // Gather locals in statics (because of block expressions).\n@@ -1465,7 +1457,7 @@ enum TupleArgumentsFlag {\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn new(inh: &'a Inherited<'a, 'gcx, 'tcx>,\n-               rty: ty::FnOutput<'tcx>,\n+               rty: Ty<'tcx>,\n                body_id: ast::NodeId)\n                -> FnCtxt<'a, 'gcx, 'tcx> {\n         FnCtxt {\n@@ -1559,6 +1551,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"write_ty({}, {:?}) in fcx {}\",\n                node_id, ty, self.tag());\n         self.tables.borrow_mut().node_types.insert(node_id, ty);\n+\n+        // Add adjustments to !-expressions\n+        if ty.is_never() {\n+            if let Some(hir::map::NodeExpr(_)) = self.tcx.map.find(node_id) {\n+                let adj = adjustment::AdjustNeverToAny(self.next_diverging_ty_var());\n+                self.write_adjustment(node_id, adj);\n+            }\n+        }\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n@@ -1704,7 +1704,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut type_scheme = self.tcx.lookup_item_type(did);\n         if type_scheme.ty.is_fn() {\n             // Tuple variants have fn type even in type namespace, extract true variant type from it\n-            let fn_ret = self.tcx.no_late_bound_regions(&type_scheme.ty.fn_ret()).unwrap().unwrap();\n+            let fn_ret = self.tcx.no_late_bound_regions(&type_scheme.ty.fn_ret()).unwrap();\n             type_scheme = ty::TypeScheme { ty: fn_ret, generics: type_scheme.generics }\n         }\n         let type_predicates = self.tcx.lookup_predicates(did);\n@@ -1731,6 +1731,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn write_nil(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, self.tcx.mk_nil());\n     }\n+\n+    pub fn write_never(&self, node_id: ast::NodeId) {\n+        self.write_ty(node_id, self.tcx.types.never);\n+    }\n+\n     pub fn write_error(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, self.tcx.types.err);\n     }\n@@ -1788,6 +1793,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn expr_ty(&self, ex: &hir::Expr) -> Ty<'tcx> {\n+        if let Some(&adjustment::AdjustNeverToAny(ref t))\n+                = self.tables.borrow().adjustments.get(&ex.id) {\n+            return t;\n+        }\n         match self.tables.borrow().node_types.get(&ex.id) {\n             Some(&t) => t,\n             None => {\n@@ -1966,9 +1975,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         for ty in &self.unsolved_variables() {\n             let resolved = self.resolve_type_vars_if_possible(ty);\n             if self.type_var_diverges(resolved) {\n-                debug!(\"default_type_parameters: defaulting `{:?}` to `()` because it diverges\",\n+                debug!(\"default_type_parameters: defaulting `{:?}` to `!` because it diverges\",\n                        resolved);\n-                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.mk_nil());\n+                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty,\n+                                   self.tcx.mk_diverging_default());\n             } else {\n                 match self.type_is_unconstrained_numeric(resolved) {\n                     UnconstrainedInt => {\n@@ -2042,7 +2052,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             for ty in &unsolved_variables {\n                 let resolved = self.resolve_type_vars_if_possible(ty);\n                 if self.type_var_diverges(resolved) {\n-                    self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.mk_nil());\n+                    self.demand_eqtype(syntax_pos::DUMMY_SP, *ty,\n+                                       self.tcx.mk_diverging_default());\n                 } else {\n                     match self.type_is_unconstrained_numeric(resolved) {\n                         UnconstrainedInt | UnconstrainedFloat => {\n@@ -2100,7 +2111,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let _ = self.commit_if_ok(|_: &infer::CombinedSnapshot| {\n                 for ty in &unbound_tyvars {\n                     if self.type_var_diverges(ty) {\n-                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.mk_nil());\n+                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty,\n+                                           self.tcx.mk_diverging_default());\n                     } else {\n                         match self.type_is_unconstrained_numeric(ty) {\n                             UnconstrainedInt => {\n@@ -2196,7 +2208,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // reporting for more then one conflict.\n         for ty in &unbound_tyvars {\n             if self.type_var_diverges(ty) {\n-                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.mk_nil());\n+                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty,\n+                                   self.tcx.mk_diverging_default());\n             } else {\n                 match self.type_is_unconstrained_numeric(ty) {\n                     UnconstrainedInt => {\n@@ -2271,7 +2284,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // extract method return type, which will be &T;\n         // all LB regions should have been instantiated during method lookup\n         let ret_ty = method.ty.fn_ret();\n-        let ret_ty = self.tcx.no_late_bound_regions(&ret_ty).unwrap().unwrap();\n+        let ret_ty = self.tcx.no_late_bound_regions(&ret_ty).unwrap();\n \n         // method returns &T, but the type as visible to user is T, so deref\n         ret_ty.builtin_deref(true, NoPreference).unwrap()\n@@ -2400,7 +2413,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                    args_no_rcvr: &'gcx [P<hir::Expr>],\n                                    tuple_arguments: TupleArgumentsFlag,\n                                    expected: Expectation<'tcx>)\n-                                   -> ty::FnOutput<'tcx> {\n+                                   -> Ty<'tcx> {\n         if method_fn_ty.references_error() {\n             let err_inputs = self.err_args(args_no_rcvr.len());\n \n@@ -2411,7 +2424,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             self.check_argument_types(sp, &err_inputs[..], &[], args_no_rcvr,\n                                       false, tuple_arguments);\n-            ty::FnConverging(self.tcx.types.err)\n+            self.tcx.types.err\n         } else {\n             match method_fn_ty.sty {\n                 ty::TyFnDef(_, _, ref fty) => {\n@@ -2601,7 +2614,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 if let Some(&arg_ty) = self.tables.borrow().node_types.get(&arg.id) {\n-                    any_diverges = any_diverges || self.type_var_diverges(arg_ty);\n+                    // FIXME(canndrew): This is_never should probably be an is_uninhabited\n+                    any_diverges = any_diverges ||\n+                                   self.type_var_diverges(arg_ty) ||\n+                                   arg_ty.is_never();\n                 }\n             }\n             if any_diverges && !warned {\n@@ -2669,11 +2685,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn write_call(&self,\n                   call_expr: &hir::Expr,\n-                  output: ty::FnOutput<'tcx>) {\n-        self.write_ty(call_expr.id, match output {\n-            ty::FnConverging(output_ty) => output_ty,\n-            ty::FnDiverging => self.next_diverging_ty_var()\n-        });\n+                  output: Ty<'tcx>) {\n+        self.write_ty(call_expr.id, output);\n     }\n \n     // AST fragment checking\n@@ -2796,35 +2809,31 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn expected_types_for_fn_args(&self,\n                                   call_span: Span,\n                                   expected_ret: Expectation<'tcx>,\n-                                  formal_ret: ty::FnOutput<'tcx>,\n+                                  formal_ret: Ty<'tcx>,\n                                   formal_args: &[Ty<'tcx>])\n                                   -> Vec<Ty<'tcx>> {\n         let expected_args = expected_ret.only_has_type(self).and_then(|ret_ty| {\n-            if let ty::FnConverging(formal_ret_ty) = formal_ret {\n-                self.commit_regions_if_ok(|| {\n-                    // Attempt to apply a subtyping relationship between the formal\n-                    // return type (likely containing type variables if the function\n-                    // is polymorphic) and the expected return type.\n-                    // No argument expectations are produced if unification fails.\n-                    let origin = TypeOrigin::Misc(call_span);\n-                    let ures = self.sub_types(false, origin, formal_ret_ty, ret_ty);\n-                    // FIXME(#15760) can't use try! here, FromError doesn't default\n-                    // to identity so the resulting type is not constrained.\n-                    match ures {\n-                        // FIXME(#32730) propagate obligations\n-                        Ok(InferOk { obligations, .. }) => assert!(obligations.is_empty()),\n-                        Err(e) => return Err(e),\n-                    }\n+            self.commit_regions_if_ok(|| {\n+                // Attempt to apply a subtyping relationship between the formal\n+                // return type (likely containing type variables if the function\n+                // is polymorphic) and the expected return type.\n+                // No argument expectations are produced if unification fails.\n+                let origin = TypeOrigin::Misc(call_span);\n+                let ures = self.sub_types(false, origin, formal_ret, ret_ty);\n+                // FIXME(#15760) can't use try! here, FromError doesn't default\n+                // to identity so the resulting type is not constrained.\n+                match ures {\n+                    // FIXME(#32730) propagate obligations\n+                    Ok(InferOk { obligations, .. }) => assert!(obligations.is_empty()),\n+                    Err(e) => return Err(e),\n+                }\n \n-                    // Record all the argument types, with the substitutions\n-                    // produced from the above subtyping unification.\n-                    Ok(formal_args.iter().map(|ty| {\n-                        self.resolve_type_vars_if_possible(ty)\n-                    }).collect())\n-                }).ok()\n-            } else {\n-                None\n-            }\n+                // Record all the argument types, with the substitutions\n+                // produced from the above subtyping unification.\n+                Ok(formal_args.iter().map(|ty| {\n+                    self.resolve_type_vars_if_possible(ty)\n+                }).collect())\n+            }).ok()\n         }).unwrap_or(vec![]);\n         debug!(\"expected_types_for_fn_args(formal={:?} -> {:?}, expected={:?} -> {:?})\",\n                formal_args, formal_ret,\n@@ -3481,39 +3490,26 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               }\n               self.write_nil(id);\n           }\n-          hir::ExprBreak(_) => { self.write_ty(id, self.next_diverging_ty_var()); }\n-          hir::ExprAgain(_) => { self.write_ty(id, self.next_diverging_ty_var()); }\n+          hir::ExprBreak(_) => { self.write_never(id); }\n+          hir::ExprAgain(_) => { self.write_never(id); }\n           hir::ExprRet(ref expr_opt) => {\n-            match self.ret_ty {\n-                ty::FnConverging(result_type) => {\n-                    if let Some(ref e) = *expr_opt {\n-                        self.check_expr_coercable_to_type(&e, result_type);\n-                    } else {\n-                        let eq_result = self.eq_types(false,\n-                                                      TypeOrigin::Misc(expr.span),\n-                                                      result_type,\n-                                                      tcx.mk_nil())\n-                            // FIXME(#32730) propagate obligations\n-                            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()));\n-                        if eq_result.is_err() {\n-                            struct_span_err!(tcx.sess, expr.span, E0069,\n-                                     \"`return;` in a function whose return type is not `()`\")\n-                                .span_label(expr.span, &format!(\"return type is not ()\"))\n-                                .emit();\n-                        }\n-                    }\n-                }\n-                ty::FnDiverging => {\n-                    if let Some(ref e) = *expr_opt {\n-                        self.check_expr(&e);\n-                    }\n-                    struct_span_err!(tcx.sess, expr.span, E0166,\n-                        \"`return` in a function declared as diverging\")\n-                        .span_label(expr.span, &format!(\"diverging function cannot return\"))\n+            if let Some(ref e) = *expr_opt {\n+                self.check_expr_coercable_to_type(&e, self.ret_ty);\n+            } else {\n+                let eq_result = self.eq_types(false,\n+                                              TypeOrigin::Misc(expr.span),\n+                                              self.ret_ty,\n+                                              tcx.mk_nil())\n+                    // FIXME(#32730) propagate obligations\n+                    .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()));\n+                if eq_result.is_err() {\n+                    struct_span_err!(tcx.sess, expr.span, E0069,\n+                             \"`return;` in a function whose return type is not `()`\")\n+                        .span_label(expr.span, &format!(\"return type is not ()\"))\n                         .emit();\n                 }\n             }\n-            self.write_ty(id, self.next_diverging_ty_var());\n+            self.write_never(id);\n           }\n           hir::ExprAssign(ref lhs, ref rhs) => {\n             self.check_expr_with_lvalue_pref(&lhs, PreferMutLvalue);\n@@ -3560,7 +3556,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprLoop(ref body, _) => {\n             self.check_block_no_value(&body);\n             if !may_break(tcx, expr.id, &body) {\n-                self.write_ty(id, self.next_diverging_ty_var());\n+                self.write_never(id);\n             } else {\n                 self.write_nil(id);\n             }\n@@ -4016,7 +4012,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               \"unreachable statement\".to_string());\n                 warned = true;\n             }\n-            any_diverges = any_diverges || self.type_var_diverges(s_ty);\n+            // FIXME(canndrew): This is_never should probably be an is_uninhabited\n+            any_diverges = any_diverges ||\n+                           self.type_var_diverges(s_ty) ||\n+                           s_ty.is_never();\n             any_err = any_err || s_ty.references_error();\n         }\n         match blk.expr {"}, {"sha": "a8b1683f6d354e1dce9bd28185f0bd6e7e4224c8", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -349,7 +349,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // extract return type for method; all late bound regions\n                 // should have been instantiated by now\n                 let ret_ty = method_ty.fn_ret();\n-                Ok(self.tcx.no_late_bound_regions(&ret_ty).unwrap().unwrap())\n+                Ok(self.tcx.no_late_bound_regions(&ret_ty).unwrap())\n             }\n             None => {\n                 Err(())"}, {"sha": "22ffcfbaae111df894576ee75b2fdce6675fb10e", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -311,7 +311,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         let fn_sig_tys: Vec<_> =\n             fn_sig.inputs.iter()\n                          .cloned()\n-                         .chain(Some(fn_sig.output.unwrap_or(self.tcx.types.bool)))\n+                         .chain(Some(fn_sig.output))\n                          .collect();\n \n         let old_body_id = self.set_body_id(body.id);\n@@ -708,7 +708,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n                                             None::<hir::Expr>.iter(), true);\n                         // late-bound regions in overloaded method calls are instantiated\n                         let fn_ret = self.tcx.no_late_bound_regions(&method.ty.fn_ret());\n-                        fn_ret.unwrap().unwrap()\n+                        fn_ret.unwrap()\n                     }\n                     None => self.resolve_node_type(base.id)\n                 };\n@@ -980,14 +980,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     // Specialized version of constrain_call.\n                     self.type_must_outlive(infer::CallRcvr(deref_expr.span),\n                                            self_ty, r_deref_expr);\n-                    match fn_sig.output {\n-                        ty::FnConverging(return_type) => {\n-                            self.type_must_outlive(infer::CallReturn(deref_expr.span),\n-                                                   return_type, r_deref_expr);\n-                            return_type\n-                        }\n-                        ty::FnDiverging => bug!()\n-                    }\n+                    self.type_must_outlive(infer::CallReturn(deref_expr.span),\n+                                           fn_sig.output, r_deref_expr);\n+                    fn_sig.output\n                 }\n                 None => derefd_ty\n             };"}, {"sha": "4bb9f4fd332f2e3c183d75d79a5790622b8cfe13", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -51,7 +51,7 @@ impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n         let id = self.id;\n         let span = self.span;\n         self.inherited.enter(|inh| {\n-            let fcx = FnCtxt::new(&inh, ty::FnDiverging, id);\n+            let fcx = FnCtxt::new(&inh, inh.ccx.tcx.types.never, id);\n             let wf_tys = f(&fcx, &mut CheckTypeWellFormedVisitor {\n                 ccx: fcx.ccx,\n                 code: code\n@@ -394,15 +394,10 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         }\n         implied_bounds.extend(sig.inputs);\n \n-        match sig.output {\n-            ty::FnConverging(output) => {\n-                fcx.register_wf_obligation(output, span, self.code.clone());\n+        fcx.register_wf_obligation(sig.output, span, self.code.clone());\n \n-                // FIXME(#25759) return types should not be implied bounds\n-                implied_bounds.push(output);\n-            }\n-            ty::FnDiverging => { }\n-        }\n+        // FIXME(#25759) return types should not be implied bounds\n+        implied_bounds.push(sig.output);\n \n         self.check_where_clauses(fcx, span, predicates);\n     }"}, {"sha": "5f8861f309948d1dfdff5a65d1b18a2f931bc14c", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -378,6 +378,10 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n             Some(adjustment) => {\n                 let resolved_adjustment = match adjustment {\n+                    adjustment::AdjustNeverToAny(ty) => {\n+                        adjustment::AdjustNeverToAny(self.resolve(&ty, reason))\n+                    }\n+\n                     adjustment::AdjustReifyFnPointer => {\n                         adjustment::AdjustReifyFnPointer\n                     }"}, {"sha": "9b26e95f7fa55b3255c9514cfe6d21331827ced6", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -24,7 +24,7 @@ use rustc::ty::{ImplOrTraitItemId, ConstTraitItemId};\n use rustc::ty::{MethodTraitItemId, TypeTraitItemId, ParameterEnvironment};\n use rustc::ty::{Ty, TyBool, TyChar, TyEnum, TyError};\n use rustc::ty::{TyParam, TyRawPtr};\n-use rustc::ty::{TyRef, TyStruct, TyTrait, TyTuple};\n+use rustc::ty::{TyRef, TyStruct, TyTrait, TyNever, TyTuple};\n use rustc::ty::{TyStr, TyArray, TySlice, TyFloat, TyInfer, TyInt};\n use rustc::ty::{TyUint, TyClosure, TyBox, TyFnDef, TyFnPtr};\n use rustc::ty::{TyProjection, TyAnon};\n@@ -84,7 +84,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n \n             TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n             TyStr | TyArray(..) | TySlice(..) | TyFnDef(..) | TyFnPtr(_) |\n-            TyTuple(..) | TyParam(..) | TyError |\n+            TyTuple(..) | TyParam(..) | TyError | TyNever |\n             TyRawPtr(_) | TyRef(_, _) | TyProjection(..) => {\n                 None\n             }"}, {"sha": "d38065f4f1238912f3624ef2dbff74702f5c0c5e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -971,7 +971,7 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 abi: abi::Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: inputs,\n-                    output: ty::FnConverging(scheme.ty),\n+                    output: scheme.ty,\n                     variadic: false\n                 })\n             }))\n@@ -2155,11 +2155,9 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n \n     let output = match decl.output {\n         hir::Return(ref ty) =>\n-            ty::FnConverging(AstConv::ast_ty_to_ty(&ccx.icx(ast_generics), &rb, &ty)),\n+            AstConv::ast_ty_to_ty(&ccx.icx(ast_generics), &rb, &ty),\n         hir::DefaultReturn(..) =>\n-            ty::FnConverging(ccx.tcx.mk_nil()),\n-        hir::NoReturn(..) =>\n-            ty::FnDiverging\n+            ccx.tcx.mk_nil(),\n     };\n \n     // feature gate SIMD types in FFI, since I (huonw) am not sure the\n@@ -2180,7 +2178,7 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n             check(&input.ty, ty)\n         }\n         if let hir::Return(ref ty) = decl.output {\n-            check(&ty, output.unwrap())\n+            check(&ty, output)\n         }\n     }\n "}, {"sha": "337b87ce994ad93e50b21f740d0fe1eea2de75dc", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -1866,20 +1866,6 @@ fn bar(foo: Foo) -> u32 {\n ```\n \"##,\n \n-E0166: r##\"\n-This error means that the compiler found a return expression in a function\n-marked as diverging. A function diverges if it has `!` in the place of the\n-return type in its signature. For example:\n-\n-```compile_fail,E0166\n-fn foo() -> ! { return; } // error\n-```\n-\n-For a function that diverges, every control path in the function must never\n-return, for example with a `loop` that never breaks or a call to another\n-diverging function (such as `panic!()`).\n-\"##,\n-\n E0172: r##\"\n This error means that an attempt was made to specify the type of a variable with\n a combination of a concrete type and a trait. Consider the following example:"}, {"sha": "11743ade2d469260008a5b01688be69e48a938d5", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -238,7 +238,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 abi: Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: Vec::new(),\n-                    output: ty::FnConverging(tcx.mk_nil()),\n+                    output: tcx.mk_nil(),\n                     variadic: false\n                 })\n             }));\n@@ -294,7 +294,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                         tcx.types.isize,\n                         tcx.mk_imm_ptr(tcx.mk_imm_ptr(tcx.types.u8))\n                     ),\n-                    output: ty::FnConverging(tcx.types.isize),\n+                    output: tcx.types.isize,\n                     variadic: false,\n                 }),\n             }));"}, {"sha": "a4faee8f633ed71a423c5bce34392a1daae94365", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -322,7 +322,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         match ty.sty {\n             ty::TyBool |\n             ty::TyChar | ty::TyInt(_) | ty::TyUint(_) |\n-            ty::TyFloat(_) | ty::TyStr => {\n+            ty::TyFloat(_) | ty::TyStr | ty::TyNever => {\n                 /* leaf type -- noop */\n             }\n \n@@ -490,9 +490,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         for &input in &sig.0.inputs {\n             self.add_constraints_from_ty(generics, input, contra);\n         }\n-        if let ty::FnConverging(result_type) = sig.0.output {\n-            self.add_constraints_from_ty(generics, result_type, variance);\n-        }\n+        self.add_constraints_from_ty(generics, sig.0.output, variance);\n     }\n \n     /// Adds constraints appropriate for a region appearing in a"}, {"sha": "99d2732c4bb06c300bad012c7589c08770d94626", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -1176,15 +1176,6 @@ impl Clean<FnDecl> for hir::FnDecl {\n     }\n }\n \n-impl<'tcx> Clean<Type> for ty::FnOutput<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> Type {\n-        match *self {\n-            ty::FnConverging(ty) => ty.clean(cx),\n-            ty::FnDiverging => Bottom\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n     fn clean(&self, cx: &DocContext) -> FnDecl {\n         let (did, sig) = *self;\n@@ -1254,15 +1245,13 @@ impl Clean<Argument> for hir::Arg {\n pub enum FunctionRetTy {\n     Return(Type),\n     DefaultReturn,\n-    NoReturn\n }\n \n impl Clean<FunctionRetTy> for hir::FunctionRetTy {\n     fn clean(&self, cx: &DocContext) -> FunctionRetTy {\n         match *self {\n             hir::Return(ref typ) => Return(typ.clean(cx)),\n             hir::DefaultReturn(..) => DefaultReturn,\n-            hir::NoReturn(..) => NoReturn\n         }\n     }\n }\n@@ -1470,8 +1459,7 @@ pub enum Type {\n     Tuple(Vec<Type>),\n     Vector(Box<Type>),\n     FixedVector(Box<Type>, String),\n-    /// aka TyBot\n-    Bottom,\n+    Never,\n     Unique(Box<Type>),\n     RawPointer(Mutability, Box<Type>),\n     BorrowedRef {\n@@ -1682,6 +1670,7 @@ impl Clean<Type> for hir::Ty {\n     fn clean(&self, cx: &DocContext) -> Type {\n         use rustc::hir::*;\n         match self.node {\n+            TyNever => Never,\n             TyPtr(ref m) => RawPointer(m.mutbl.clean(cx), box m.ty.clean(cx)),\n             TyRptr(ref l, ref m) =>\n                 BorrowedRef {lifetime: l.clean(cx), mutability: m.mutbl.clean(cx),\n@@ -1790,6 +1779,7 @@ impl Clean<Type> for hir::Ty {\n impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Type {\n         match self.sty {\n+            ty::TyNever => Never,\n             ty::TyBool => Primitive(Bool),\n             ty::TyChar => Primitive(Char),\n             ty::TyInt(ast::IntTy::Is) => Primitive(Isize),"}, {"sha": "2f03b235e9f672f397664bdbe874a4dc82734139", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -492,7 +492,7 @@ impl fmt::Display for clean::Type {\n                 primitive_link(f, clean::PrimitiveType::Array,\n                                &format!(\"; {}]\", Escape(s)))\n             }\n-            clean::Bottom => f.write_str(\"!\"),\n+            clean::Never => f.write_str(\"!\"),\n             clean::RawPointer(m, ref t) => {\n                 match **t {\n                     clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n@@ -634,7 +634,6 @@ impl fmt::Display for clean::FunctionRetTy {\n             clean::Return(clean::Tuple(ref tys)) if tys.is_empty() => Ok(()),\n             clean::Return(ref ty) => write!(f, \" -&gt; {}\", ty),\n             clean::DefaultReturn => Ok(()),\n-            clean::NoReturn => write!(f, \" -&gt; !\")\n         }\n     }\n }"}, {"sha": "f8a5cb0b04a8e8bcab9f759e780b0fd9dab19d80", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -1348,6 +1348,7 @@ pub struct BareFnTy {\n /// The different kinds of types recognized by the compiler\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum TyKind {\n+    /// A variable-length array (`[T]`)\n     Vec(P<Ty>),\n     /// A fixed length array (`[T; n]`)\n     FixedLengthVec(P<Ty>, P<Expr>),\n@@ -1357,6 +1358,8 @@ pub enum TyKind {\n     Rptr(Option<Lifetime>, MutTy),\n     /// A bare function (e.g. `fn(usize) -> bool`)\n     BareFn(P<BareFnTy>),\n+    /// The never type (`!`)\n+    Never,\n     /// A tuple (`(A, B, C, D,...)`)\n     Tup(Vec<P<Ty>> ),\n     /// A path (`module::module::...::Type`), optionally\n@@ -1564,9 +1567,6 @@ impl fmt::Debug for ImplPolarity {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum FunctionRetTy {\n-    /// Functions with return type `!`that always\n-    /// raise an error or exit (i.e. never return to the caller)\n-    None(Span),\n     /// Return type is not specified.\n     ///\n     /// Functions default to `()` and\n@@ -1580,7 +1580,6 @@ pub enum FunctionRetTy {\n impl FunctionRetTy {\n     pub fn span(&self) -> Span {\n         match *self {\n-            FunctionRetTy::None(span) => span,\n             FunctionRetTy::Default(span) => span,\n             FunctionRetTy::Ty(ref ty) => ty.span,\n         }"}, {"sha": "d94bfe7dcbdac2df758c55f87ec3256c1b9ee523", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -284,7 +284,10 @@ declare_features! (\n \n     // Allows tuple structs and variants in more contexts,\n     // Permits numeric fields in struct expressions and patterns.\n-    (active, relaxed_adts, \"1.12.0\", Some(35626))\n+    (active, relaxed_adts, \"1.12.0\", Some(35626)),\n+\n+    // The `!` type\n+    (active, never_type, \"1.13.0\", Some(35121))\n );\n \n declare_features! (\n@@ -963,11 +966,25 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, conservative_impl_trait, ty.span,\n                                    \"`impl Trait` is experimental\");\n             }\n+            ast::TyKind::Never => {\n+                gate_feature_post!(&self, never_type, ty.span,\n+                                   \"The `!` type is experimental\");\n+            },\n             _ => {}\n         }\n         visit::walk_ty(self, ty)\n     }\n \n+    fn visit_fn_ret_ty(&mut self, ret_ty: &ast::FunctionRetTy) {\n+        if let ast::FunctionRetTy::Ty(ref output_ty) = *ret_ty {\n+            match output_ty.node {\n+                ast::TyKind::Never => return,\n+                _ => (),\n+            };\n+            self.visit_ty(output_ty)\n+        }\n+    }\n+\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n             ast::ExprKind::Box(_) => {"}, {"sha": "b257ab98987dc24701760d1ec76301380d39aa1e", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -373,6 +373,7 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n                     decl: fld.fold_fn_decl(decl)\n                 }))\n             }\n+            TyKind::Never => node,\n             TyKind::Tup(tys) => TyKind::Tup(tys.move_map(|ty| fld.fold_ty(ty))),\n             TyKind::Paren(ty) => TyKind::Paren(fld.fold_ty(ty)),\n             TyKind::Path(qself, path) => {\n@@ -637,7 +638,6 @@ pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> {\n         output: match output {\n             FunctionRetTy::Ty(ty) => FunctionRetTy::Ty(fld.fold_ty(ty)),\n             FunctionRetTy::Default(span) => FunctionRetTy::Default(span),\n-            FunctionRetTy::None(span) => FunctionRetTy::None(span),\n         },\n         variadic: variadic\n     })"}, {"sha": "126e8816d055924d3faf250ed32a4c840efdc68f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -1332,11 +1332,7 @@ impl<'a> Parser<'a> {\n     /// Parse optional return type [ -> TY ] in function decl\n     pub fn parse_ret_ty(&mut self) -> PResult<'a, FunctionRetTy> {\n         if self.eat(&token::RArrow) {\n-            if self.eat(&token::Not) {\n-                Ok(FunctionRetTy::None(self.last_span))\n-            } else {\n-                Ok(FunctionRetTy::Ty(self.parse_ty()?))\n-            }\n+            Ok(FunctionRetTy::Ty(self.parse_ty()?))\n         } else {\n             let pos = self.span.lo;\n             Ok(FunctionRetTy::Default(mk_sp(pos, pos)))\n@@ -1399,6 +1395,8 @@ impl<'a> Parser<'a> {\n             } else {\n                 TyKind::Tup(ts)\n             }\n+        } else if self.eat(&token::Not) {\n+            TyKind::Never\n         } else if self.check(&token::BinOp(token::Star)) {\n             // STAR POINTER (bare pointer?)\n             self.bump();"}, {"sha": "a77c678248b565642a31fc5b60851c62ff1a9299", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -976,6 +976,9 @@ impl<'a> State<'a> {\n                 try!(self.print_opt_lifetime(lifetime));\n                 try!(self.print_mt(mt));\n             }\n+            ast::TyKind::Never => {\n+                try!(word(&mut self.s, \"!\"));\n+            },\n             ast::TyKind::Tup(ref elts) => {\n                 try!(self.popen());\n                 try!(self.commasep(Inconsistent, &elts[..],\n@@ -2693,10 +2696,6 @@ impl<'a> State<'a> {\n                 self.maybe_print_comment(ty.span.lo)\n             }\n             ast::FunctionRetTy::Default(..) => unreachable!(),\n-            ast::FunctionRetTy::None(span) => {\n-                try!(self.word_nbsp(\"!\"));\n-                self.maybe_print_comment(span.lo)\n-            }\n         }\n     }\n \n@@ -2952,8 +2951,6 @@ impl<'a> State<'a> {\n         try!(self.ibox(INDENT_UNIT));\n         try!(self.word_space(\"->\"));\n         match decl.output {\n-            ast::FunctionRetTy::None(_) =>\n-                try!(self.word_nbsp(\"!\")),\n             ast::FunctionRetTy::Default(..) => unreachable!(),\n             ast::FunctionRetTy::Ty(ref ty) =>\n                 try!(self.print_type(&ty))"}, {"sha": "582412119caa875923f6d41e6ad34c40829547e1", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -128,6 +128,9 @@ pub trait Visitor: Sized {\n     fn visit_vis(&mut self, vis: &Visibility) {\n         walk_vis(self, vis)\n     }\n+    fn visit_fn_ret_ty(&mut self, ret_ty: &FunctionRetTy) {\n+        walk_fn_ret_ty(self, ret_ty)\n+    }\n }\n \n #[macro_export]\n@@ -319,6 +322,7 @@ pub fn walk_ty<V: Visitor>(visitor: &mut V, typ: &Ty) {\n             walk_list!(visitor, visit_lifetime, opt_lifetime);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n+        TyKind::Never => {},\n         TyKind::Tup(ref tuple_element_types) => {\n             walk_list!(visitor, visit_ty, tuple_element_types);\n         }\n@@ -509,7 +513,7 @@ pub fn walk_fn_decl<V: Visitor>(visitor: &mut V, function_declaration: &FnDecl)\n         visitor.visit_pat(&argument.pat);\n         visitor.visit_ty(&argument.ty)\n     }\n-    walk_fn_ret_ty(visitor, &function_declaration.output)\n+    visitor.visit_fn_ret_ty(&function_declaration.output)\n }\n \n pub fn walk_fn_kind<V: Visitor>(visitor: &mut V, function_kind: FnKind) {"}, {"sha": "583befed1e8287bf8d82f23f38a71f3e24a4a71b", "filename": "src/test/compile-fail/call-fn-never-arg-wrong-type.rs", "status": "renamed", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Fcompile-fail%2Fcall-fn-never-arg-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Fcompile-fail%2Fcall-fn-never-arg-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcall-fn-never-arg-wrong-type.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -8,10 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f<F, R>(_: F) where F: Fn() -> R {\n+// Test that we can't pass other types for !\n+\n+#![feature(never_type)]\n+\n+fn foo(x: !) -> ! {\n+    x\n }\n \n fn main() {\n-    f(|| -> ! { () });\n-//~^ ERROR: computation may converge in a function marked as diverging [E0270]\n+    foo(\"wow\"); //~ ERROR mismatched types\n }\n+", "previous_filename": "src/test/compile-fail/issue-20105.rs"}, {"sha": "b9cfbd695b0473049a1963b7c321c43051f41e84", "filename": "src/test/compile-fail/issue-897.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/197be89f367d1240d5f9cd9c4efd77812775354e/src%2Ftest%2Fcompile-fail%2Fissue-897.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197be89f367d1240d5f9cd9c4efd77812775354e/src%2Ftest%2Fcompile-fail%2Fissue-897.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-897.rs?ref=197be89f367d1240d5f9cd9c4efd77812775354e", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![deny(unreachable_code)]\n-\n-fn f() -> ! {\n-    return panic!(); //~ ERROR `return` in a function declared as diverging\n-    panic!(); // the unreachable statement error is in <std macro>, at this line, there\n-             // only is a note\n-}\n-\n-fn main() { f() }"}, {"sha": "57e0bca6a6d770a36b7b43e09671e1bdbcff8b7a", "filename": "src/test/compile-fail/never-assign-dead-code.rs", "status": "renamed", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Fcompile-fail%2Fnever-assign-dead-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Fcompile-fail%2Fnever-assign-dead-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnever-assign-dead-code.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,9 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo() -> ! { return; }\n-    //~^ ERROR E0166\n-    //~| NOTE diverging function cannot return\n+// Test that an assignment of type ! makes the rest of the block dead code.\n+\n+#![feature(never_type)]\n+#![deny(unused, unreachable_code)]\n \n fn main() {\n+    let x: ! = panic!(\"aah\"); //~ ERROR unused\n+    drop(x); //~ ERROR unreachable\n }\n+", "previous_filename": "src/test/compile-fail/E0166.rs"}, {"sha": "53d96aaf4fe89ad95c8e7350eac5362e0599e7fe", "filename": "src/test/compile-fail/never-assign-wrong-type.rs", "status": "renamed", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Fcompile-fail%2Fnever-assign-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Fcompile-fail%2Fnever-assign-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnever-assign-wrong-type.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -8,8 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn forever2() -> ! { //~ ERROR computation may converge in a function marked as diverging\n-  loop { break }\n+// Test that we can't use another type in place of !\n+\n+#![feature(never_type)]\n+\n+fn main() {\n+    let x: ! = \"hello\"; //~ ERROR mismatched types\n }\n \n-fn main() {}\n+", "previous_filename": "src/test/compile-fail/loop-properly-diverging.rs"}, {"sha": "11b9f412957eb52c2ef5c5da3241c942a13733bd", "filename": "src/test/compile-fail/never-disabled.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Fcompile-fail%2Fnever-disabled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Fcompile-fail%2Fnever-disabled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnever-disabled.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that ! errors when used in illegal positions with feature(never_type) disabled\n+\n+trait Foo {\n+    type Wub;\n+}\n+\n+type Ma = (u32, !, i32); //~ ERROR type is experimental\n+type Meeshka = Vec<!>; //~ ERROR type is experimental\n+type Mow = &fn(!) -> !; //~ ERROR type is experimental\n+type Skwoz = &mut !; //~ ERROR type is experimental\n+\n+impl Foo for Meeshka {\n+    type Wub = !; //~ ERROR type is experimental\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "a43b1a45fe939fdc88adbb71593c24d797cccecb", "filename": "src/test/compile-fail/never-fallback.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Fcompile-fail%2Fnever-fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Fcompile-fail%2Fnever-fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnever-fallback.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that diverging types default to ! when feature(never_type) is enabled. This test is the\n+// same as run-pass/unit-fallback.rs except that ! is enabled.\n+\n+#![feature(never_type)]\n+\n+trait Balls: Sized {\n+    fn smeg() -> Result<Self, ()>;\n+}\n+\n+impl Balls for () {\n+    fn smeg() -> Result<(), ()> { Ok(()) }\n+}\n+\n+struct Flah;\n+\n+impl Flah {\n+    fn flah<T: Balls>(&self) -> Result<T, ()> {\n+        T::smeg()\n+    }\n+}\n+\n+fn doit() -> Result<(), ()> {\n+    // The type of _ is unconstrained here and should default to !\n+    let _ = try!(Flah.flah()); //~ ERROR the trait bound\n+    Ok(())\n+}\n+\n+fn main() {\n+    let _ = doit();\n+}\n+"}, {"sha": "cec59faa918bc6a9146846ec440088388f3755af", "filename": "src/test/compile-fail/return-from-diverging.rs", "status": "renamed", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Fcompile-fail%2Freturn-from-diverging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Fcompile-fail%2Freturn-from-diverging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freturn-from-diverging.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -8,9 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n+// Test that return another type in place of ! raises a type mismatch.\n \n-enum v {}\n-pub fn main() {\n-    let y: v = unsafe { ::std::mem::uninitialized() };\n+fn fail() -> ! {\n+    return \"wow\"; //~ ERROR mismatched types\n }\n+\n+fn main() {\n+}\n+", "previous_filename": "src/test/run-pass/issue-10714.rs"}, {"sha": "ae2a325b24a9236d5fede3ea2d6a9ce2f1218437", "filename": "src/test/compile-fail/return-unit-from-diverging.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Fcompile-fail%2Freturn-unit-from-diverging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Fcompile-fail%2Freturn-unit-from-diverging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freturn-unit-from-diverging.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we get the usual error that we'd get for any other return type and not something about\n+// diverging functions not being able to return.\n+\n+fn fail() -> ! {\n+    return; //~ ERROR in a function whose return type is not\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "ccdb1ca15bba019f10811f2591326986990d1c00", "filename": "src/test/run-fail/adjust_never.rs", "status": "renamed", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Frun-fail%2Fadjust_never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Frun-fail%2Fadjust_never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fadjust_never.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -8,7 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f() -> ! { //~ ERROR computation may converge in a function marked as diverging\n-    3\n+// Test that a variable of type ! can coerce to another type.\n+\n+#![feature(never_type)]\n+\n+// error-pattern:explicit\n+fn main() {\n+    let x: ! = panic!();\n+    let y: u32 = x;\n }\n-fn main() { }", "previous_filename": "src/test/compile-fail/bang-tailexpr.rs"}, {"sha": "95101e70db95192aae510e6593b4a6175cbfa902", "filename": "src/test/run-fail/call-fn-never-arg.rs", "status": "renamed", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Frun-fail%2Fcall-fn-never-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Frun-fail%2Fcall-fn-never-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fcall-fn-never-arg.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -8,14 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/* Make sure a loop{} with a break in it can't be\n-   the tailexpr in the body of a diverging function */\n-fn forever() -> ! {\n-  loop {\n-    break;\n-  }\n-  return 42; //~ ERROR `return` in a function declared as diverging\n+// Test that we can use a ! for an argument of type !\n+\n+// error-pattern:wowzers!\n+\n+#![feature(never_type)]\n+#![allow(unreachable_code)]\n+\n+fn foo(x: !) -> ! {\n+    x\n }\n \n fn main() {\n+    foo(panic!(\"wowzers!\"))\n }\n+", "previous_filename": "src/test/compile-fail/loop-does-not-diverge.rs"}, {"sha": "acd002494f4eea001af3e740ecf2660c2e78420e", "filename": "src/test/run-fail/cast-never.rs", "status": "renamed", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Frun-fail%2Fcast-never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Frun-fail%2Fcast-never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fcast-never.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -8,10 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Tests that a function with a ! annotation always actually fails\n+// Test that we can explicitly cast ! to another type\n \n-fn bad_bang(i: usize) -> ! { //~ ERROR computation may converge in a function marked as diverging\n-    println!(\"{}\", 3);\n+#![feature(never_type)]\n+\n+// error-pattern:explicit\n+fn main() {\n+    let x: ! = panic!();\n+    let y: u32 = x as u32;\n }\n \n-fn main() { bad_bang(5); }", "previous_filename": "src/test/compile-fail/liveness-bad-bang-2.rs"}, {"sha": "345674f3f522ad0c2f914a8c4c7c2c5e0bf732ab", "filename": "src/test/run-fail/never-associated-type.rs", "status": "renamed", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Frun-fail%2Fnever-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Frun-fail%2Fnever-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fnever-associated-type.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -8,10 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Tests that a function with a ! annotation always actually fails\n+// Test that we can use ! as an associated type.\n \n-fn bad_bang(i: usize) -> ! { //~ ERROR computation may converge in a function marked as diverging\n-    if i < 0 { } else { panic!(); }\n+#![feature(never_type)]\n+\n+// error-pattern:kapow!\n+\n+trait Foo {\n+    type Wow;\n+\n+    fn smeg(&self) -> Self::Wow;\n+}\n+\n+struct Blah;\n+impl Foo for Blah {\n+    type Wow = !;\n+    fn smeg(&self) -> ! {\n+        panic!(\"kapow!\");\n+    }\n+}\n+\n+fn main() {\n+    Blah.smeg();\n }\n \n-fn main() { bad_bang(5); }", "previous_filename": "src/test/compile-fail/bad-bang-ann.rs"}, {"sha": "826ca3a08c0e1dc5e67c30aa80b2c30fef3c33ac", "filename": "src/test/run-fail/never-type-arg.rs", "status": "renamed", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Frun-fail%2Fnever-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Frun-fail%2Fnever-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fnever-type-arg.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -8,12 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Tests that a function with a ! annotation always actually fails\n+// Test that we can use ! as an argument to a trait impl.\n \n-fn bad_bang(i: usize) -> ! {\n-    return 7;\n-    //~^ ERROR `return` in a function declared as diverging [E0166]\n-    //~| NOTE diverging function cannot return\n+// error-pattern:oh no!\n+\n+#![feature(never_type)]\n+\n+struct Wub;\n+\n+impl PartialEq<!> for Wub {\n+    fn eq(&self, other: &!) -> bool {\n+        *other\n+    }\n+}\n+\n+fn main() {\n+    let _ = Wub == panic!(\"oh no!\");\n }\n \n-fn main() { bad_bang(5); }", "previous_filename": "src/test/compile-fail/bad-bang-ann-3.rs"}, {"sha": "4cd93ac7e1a5d23fd9e45cd12ef757a5c7f0013c", "filename": "src/test/run-fail/return-never-coerce.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Frun-fail%2Freturn-never-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Frun-fail%2Freturn-never-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Freturn-never-coerce.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that ! coerces to other types.\n+\n+// error-pattern:aah!\n+\n+fn call_another_fn<T, F: FnOnce() -> T>(f: F) -> T {\n+    f()\n+}\n+\n+fn wub() -> ! {\n+    panic!(\"aah!\");\n+}\n+\n+fn main() {\n+    let x: i32 = call_another_fn(wub);\n+    let y: u32 = wub();\n+}\n+\n+"}, {"sha": "794f5969bff507fbc04b2821e399522a5de85966", "filename": "src/test/run-pass/impl-for-never.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Frun-pass%2Fimpl-for-never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Frun-pass%2Fimpl-for-never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-for-never.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can call static methods on ! both directly and when it appears in a generic\n+\n+#![feature(never_type)]\n+\n+trait StringifyType {\n+    fn stringify_type() -> &'static str;\n+}\n+\n+impl StringifyType for ! {\n+    fn stringify_type() -> &'static str {\n+        \"!\"\n+    }\n+}\n+\n+fn maybe_stringify<T: StringifyType>(opt: Option<T>) -> &'static str {\n+    match opt {\n+        Some(_) => T::stringify_type(),\n+        None => \"none\",\n+    }\n+}\n+\n+fn main() {\n+    println!(\"! is {}\", <!>::stringify_type());\n+    println!(\"None is {}\", maybe_stringify(None::<!>));\n+}\n+"}, {"sha": "5c0af392f44df27c659d6cebedccf666c1c4dee7", "filename": "src/test/run-pass/never-result.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Frun-pass%2Fnever-result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Frun-pass%2Fnever-result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnever-result.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can extract a ! through pattern matching then use it as several different types.\n+\n+#![feature(never_type)]\n+\n+fn main() {\n+    let x: Result<u32, !> = Ok(123);\n+    match x {\n+        Ok(z) => (),\n+        Err(y) => {\n+            let q: u32 = y;\n+            let w: i32 = y;\n+            let e: String = y;\n+            y\n+        },\n+    }\n+}\n+"}, {"sha": "dfba5d2c3da0a754b7d1ac92113402f5d8778886", "filename": "src/test/run-pass/never_coercions.rs", "status": "renamed", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Frun-pass%2Fnever_coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Frun-pass%2Fnever_coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnever_coercions.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -8,16 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny(unreachable_code)]\n+// Test that having something of type ! doesn't screw up type-checking and that it coerces to the\n+// LUB type of the other match arms.\n \n-fn g() -> ! { panic!(); }\n-fn f() -> ! {\n-    return g(); //~ ERROR `return` in a function declared as diverging\n-    g();\n-}\n-fn h() -> ! {\n-    loop {}\n-    g();\n+fn main() {\n+    let v: Vec<u32> = Vec::new();\n+    match 0u32 {\n+        0 => &v,\n+        1 => return,\n+        _ => &v[..],\n+    };\n }\n \n-fn main() { f() }", "previous_filename": "src/test/compile-fail/issue-897-2.rs"}, {"sha": "2babc6348e1078ccfc6a406a265b7b9644565587", "filename": "src/test/run-pass/unit-fallback.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Frun-pass%2Funit-fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25542cb02d946959517ebb68e2f7b1318817237/src%2Ftest%2Frun-pass%2Funit-fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funit-fallback.rs?ref=e25542cb02d946959517ebb68e2f7b1318817237", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that diverging types default to () (with feature(never_type) disabled).\n+\n+trait Balls: Sized {\n+    fn smeg() -> Result<Self, ()>;\n+}\n+\n+impl Balls for () {\n+    fn smeg() -> Result<(), ()> { Ok(()) }\n+}\n+\n+struct Flah;\n+\n+impl Flah {\n+    fn flah<T: Balls>(&self) -> Result<T, ()> {\n+        T::smeg()\n+    }\n+}\n+\n+fn doit() -> Result<(), ()> {\n+    // The type of _ is unconstrained here and should default to ()\n+    let _ = try!(Flah.flah());\n+    Ok(())\n+}\n+\n+fn main() {\n+    let _ = doit();\n+}\n+"}]}