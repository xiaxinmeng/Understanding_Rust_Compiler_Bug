{"sha": "d232acdb398c5837f2c95ffe6c38970059451445", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyMzJhY2RiMzk4YzU4MzdmMmM5NWZmZTZjMzg5NzAwNTk0NTE0NDU=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2020-01-20T23:59:17Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2020-02-22T00:27:44Z"}, "message": "Report all errors in `check_generic_arg_count`", "tree": {"sha": "c530e536a0326468fe01203ff44ea985742fd4e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c530e536a0326468fe01203ff44ea985742fd4e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d232acdb398c5837f2c95ffe6c38970059451445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d232acdb398c5837f2c95ffe6c38970059451445", "html_url": "https://github.com/rust-lang/rust/commit/d232acdb398c5837f2c95ffe6c38970059451445", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d232acdb398c5837f2c95ffe6c38970059451445/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a504878c3d1f80581e6b202490e10fe199914da", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a504878c3d1f80581e6b202490e10fe199914da", "html_url": "https://github.com/rust-lang/rust/commit/2a504878c3d1f80581e6b202490e10fe199914da"}], "stats": {"total": 166, "additions": 81, "deletions": 85}, "files": [{"sha": "5c9178ff66d155e9cfdaed25d78841a4bdce1473", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 77, "deletions": 70, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/d232acdb398c5837f2c95ffe6c38970059451445/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d232acdb398c5837f2c95ffe6c38970059451445/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d232acdb398c5837f2c95ffe6c38970059451445", "patch": "@@ -287,7 +287,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         position: GenericArgPosition,\n         has_self: bool,\n         infer_args: bool,\n-    ) -> (bool, Option<Vec<Span>>) {\n+    ) -> (bool, Vec<Span>) {\n         // At this stage we are guaranteed that the generic arguments are in the correct order, e.g.\n         // that lifetimes will proceed types. So it suffices to check the number of each generic\n         // arguments in order to validate them with respect to the generic parameters.\n@@ -341,104 +341,110 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n         }\n \n-        let check_kind_count = |kind, required, permitted, provided, offset| {\n-            debug!(\n-                \"check_kind_count: kind: {} required: {} permitted: {} provided: {} offset: {}\",\n-                kind, required, permitted, provided, offset\n-            );\n-            // We enforce the following: `required` <= `provided` <= `permitted`.\n-            // For kinds without defaults (e.g.., lifetimes), `required == permitted`.\n-            // For other kinds (i.e., types), `permitted` may be greater than `required`.\n-            if required <= provided && provided <= permitted {\n-                return (reported_late_bound_region_err.unwrap_or(false), None);\n-            }\n-\n-            // Unfortunately lifetime and type parameter mismatches are typically styled\n-            // differently in diagnostics, which means we have a few cases to consider here.\n-            let (bound, quantifier) = if required != permitted {\n-                if provided < required {\n-                    (required, \"at least \")\n-                } else {\n-                    // provided > permitted\n-                    (permitted, \"at most \")\n+        let check_kind_count =\n+            |kind, required, permitted, provided, offset, unexpected_spans: &mut Vec<Span>| {\n+                debug!(\n+                    \"check_kind_count: kind: {} required: {} permitted: {} provided: {} offset: {}\",\n+                    kind, required, permitted, provided, offset\n+                );\n+                // We enforce the following: `required` <= `provided` <= `permitted`.\n+                // For kinds without defaults (e.g.., lifetimes), `required == permitted`.\n+                // For other kinds (i.e., types), `permitted` may be greater than `required`.\n+                if required <= provided && provided <= permitted {\n+                    return false;\n                 }\n-            } else {\n-                (required, \"\")\n-            };\n \n-            let mut potential_assoc_types: Option<Vec<Span>> = None;\n-            let (spans, label) = if required == permitted && provided > permitted {\n-                // In the case when the user has provided too many arguments,\n-                // we want to point to the unexpected arguments.\n-                let spans: Vec<Span> = args.args[offset + permitted..offset + provided]\n-                    .iter()\n-                    .map(|arg| arg.span())\n-                    .collect();\n-                potential_assoc_types = Some(spans.clone());\n-                (spans, format!(\"unexpected {} argument\", kind))\n-            } else {\n-                (\n-                    vec![span],\n-                    format!(\n-                        \"expected {}{} {} argument{}\",\n-                        quantifier,\n-                        bound,\n-                        kind,\n-                        pluralize!(bound),\n+                // Unfortunately lifetime and type parameter mismatches are typically styled\n+                // differently in diagnostics, which means we have a few cases to consider here.\n+                let (bound, quantifier) = if required != permitted {\n+                    if provided < required {\n+                        (required, \"at least \")\n+                    } else {\n+                        // provided > permitted\n+                        (permitted, \"at most \")\n+                    }\n+                } else {\n+                    (required, \"\")\n+                };\n+\n+                let (spans, label) = if required == permitted && provided > permitted {\n+                    // In the case when the user has provided too many arguments,\n+                    // we want to point to the unexpected arguments.\n+                    let spans: Vec<Span> = args.args[offset + permitted..offset + provided]\n+                        .iter()\n+                        .map(|arg| arg.span())\n+                        .collect();\n+                    unexpected_spans.extend(spans.clone());\n+                    (spans, format!(\"unexpected {} argument\", kind))\n+                } else {\n+                    (\n+                        vec![span],\n+                        format!(\n+                            \"expected {}{} {} argument{}\",\n+                            quantifier,\n+                            bound,\n+                            kind,\n+                            pluralize!(bound),\n+                        ),\n+                    )\n+                };\n+\n+                let mut err = tcx.sess.struct_span_err_with_code(\n+                    spans.clone(),\n+                    &format!(\n+                        \"wrong number of {} arguments: expected {}{}, found {}\",\n+                        kind, quantifier, bound, provided,\n                     ),\n-                )\n-            };\n+                    DiagnosticId::Error(\"E0107\".into()),\n+                );\n+                for span in spans {\n+                    err.span_label(span, label.as_str());\n+                }\n+                err.emit();\n \n-            let mut err = tcx.sess.struct_span_err_with_code(\n-                spans.clone(),\n-                &format!(\n-                    \"wrong number of {} arguments: expected {}{}, found {}\",\n-                    kind, quantifier, bound, provided,\n-                ),\n-                DiagnosticId::Error(\"E0107\".into()),\n-            );\n-            for span in spans {\n-                err.span_label(span, label.as_str());\n-            }\n-            err.emit();\n+                true\n+            };\n \n-            (true, potential_assoc_types)\n-        };\n+        let mut arg_count_mismatch = reported_late_bound_region_err.unwrap_or(false);\n+        let mut unexpected_spans = vec![];\n \n         if reported_late_bound_region_err.is_none()\n             && (!infer_lifetimes || arg_counts.lifetimes > param_counts.lifetimes)\n         {\n-            check_kind_count(\n+            arg_count_mismatch |= check_kind_count(\n                 \"lifetime\",\n                 param_counts.lifetimes,\n                 param_counts.lifetimes,\n                 arg_counts.lifetimes,\n                 0,\n+                &mut unexpected_spans,\n             );\n         }\n         // FIXME(const_generics:defaults)\n         if !infer_args || arg_counts.consts > param_counts.consts {\n-            check_kind_count(\n+            arg_count_mismatch |= check_kind_count(\n                 \"const\",\n                 param_counts.consts,\n                 param_counts.consts,\n                 arg_counts.consts,\n                 arg_counts.lifetimes + arg_counts.types,\n+                &mut unexpected_spans,\n             );\n         }\n         // Note that type errors are currently be emitted *after* const errors.\n         if !infer_args || arg_counts.types > param_counts.types - defaults.types - has_self as usize\n         {\n-            check_kind_count(\n+            arg_count_mismatch |= check_kind_count(\n                 \"type\",\n                 param_counts.types - defaults.types - has_self as usize,\n                 param_counts.types - has_self as usize,\n                 arg_counts.types,\n                 arg_counts.lifetimes,\n-            )\n-        } else {\n-            (reported_late_bound_region_err.unwrap_or(false), None)\n+                &mut unexpected_spans,\n+            );\n         }\n+\n+        (arg_count_mismatch, unexpected_spans)\n     }\n \n     /// Creates the relevant generic argument substitutions\n@@ -627,7 +633,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         generic_args: &'a hir::GenericArgs<'_>,\n         infer_args: bool,\n         self_ty: Option<Ty<'tcx>>,\n-    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Option<Vec<Span>>) {\n+    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Vec<Span>) {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n@@ -922,7 +928,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Ty<'tcx>,\n         bounds: &mut Bounds<'tcx>,\n         speculative: bool,\n-    ) -> Option<Vec<Span>> {\n+    ) -> Vec<Span> {\n         let trait_def_id = trait_ref.trait_def_id();\n \n         debug!(\"instantiate_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n@@ -968,6 +974,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             \"instantiate_poly_trait_ref({:?}, bounds={:?}) -> {:?}\",\n             trait_ref, bounds, poly_trait_ref\n         );\n+\n         potential_assoc_types\n     }\n \n@@ -996,7 +1003,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         constness: Constness,\n         self_ty: Ty<'tcx>,\n         bounds: &mut Bounds<'tcx>,\n-    ) -> Option<Vec<Span>> {\n+    ) -> Vec<Span> {\n         self.instantiate_poly_trait_ref_inner(\n             &poly_trait_ref.trait_ref,\n             poly_trait_ref.span,\n@@ -1085,7 +1092,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         trait_segment: &'a hir::PathSegment<'a>,\n-    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Option<Vec<Span>>) {\n+    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Vec<Span>) {\n         debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\", trait_segment);\n \n         self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment);\n@@ -1436,7 +1443,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 dummy_self,\n                 &mut bounds,\n             );\n-            potential_assoc_types.extend(cur_potential_assoc_types.into_iter().flatten());\n+            potential_assoc_types.extend(cur_potential_assoc_types.into_iter());\n         }\n \n         // Expand trait aliases recursively and check that only one regular (non-auto) trait"}, {"sha": "3e5e2e601f5c46a72df440926644177dd906ffbd", "filename": "src/test/ui/generic/generic-arg-mismatch-recover.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d232acdb398c5837f2c95ffe6c38970059451445/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-arg-mismatch-recover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d232acdb398c5837f2c95ffe6c38970059451445/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-arg-mismatch-recover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-arg-mismatch-recover.rs?ref=d232acdb398c5837f2c95ffe6c38970059451445", "patch": "@@ -4,7 +4,6 @@ struct Bar<'a>(&'a ());\n \n fn main() {\n     Foo::<'static, 'static, ()>(&0); //~ ERROR wrong number of lifetime arguments\n-    //~^ ERROR mismatched types\n \n     Bar::<'static, 'static, ()>(&()); //~ ERROR wrong number of lifetime arguments\n     //~^ ERROR wrong number of type arguments"}, {"sha": "99adb3526852710af8efae52b2af5e006124f406", "filename": "src/test/ui/generic/generic-arg-mismatch-recover.stderr", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d232acdb398c5837f2c95ffe6c38970059451445/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-arg-mismatch-recover.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d232acdb398c5837f2c95ffe6c38970059451445/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-arg-mismatch-recover.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric%2Fgeneric-arg-mismatch-recover.stderr?ref=d232acdb398c5837f2c95ffe6c38970059451445", "patch": "@@ -4,28 +4,18 @@ error[E0107]: wrong number of lifetime arguments: expected 1, found 2\n LL |     Foo::<'static, 'static, ()>(&0);\n    |                    ^^^^^^^ unexpected lifetime argument\n \n-error[E0308]: mismatched types\n-  --> $DIR/generic-arg-mismatch-recover.rs:6:33\n-   |\n-LL |     Foo::<'static, 'static, ()>(&0);\n-   |                                 ^^ expected `()`, found integer\n-   |\n-   = note: expected reference `&'static ()`\n-              found reference `&{integer}`\n-\n error[E0107]: wrong number of lifetime arguments: expected 1, found 2\n-  --> $DIR/generic-arg-mismatch-recover.rs:9:20\n+  --> $DIR/generic-arg-mismatch-recover.rs:8:20\n    |\n LL |     Bar::<'static, 'static, ()>(&());\n    |                    ^^^^^^^ unexpected lifetime argument\n \n error[E0107]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/generic-arg-mismatch-recover.rs:9:29\n+  --> $DIR/generic-arg-mismatch-recover.rs:8:29\n    |\n LL |     Bar::<'static, 'static, ()>(&());\n    |                             ^^ unexpected type argument\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0107, E0308.\n-For more information about an error, try `rustc --explain E0107`.\n+For more information about this error, try `rustc --explain E0107`."}]}