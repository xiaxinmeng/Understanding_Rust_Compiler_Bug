{"sha": "1b0799157450a2ef6c50b4ffb9c0c40ee105fe8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiMDc5OTE1NzQ1MGEyZWY2YzUwYjRmZmI5YzBjNDBlZTEwNWZlOGY=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-06-28T16:36:41Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-10-06T10:19:30Z"}, "message": "Check associated type bounds for object safety violations", "tree": {"sha": "9e2a97170999ad1d3d6c3a28cf32d618704ad7b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e2a97170999ad1d3d6c3a28cf32d618704ad7b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b0799157450a2ef6c50b4ffb9c0c40ee105fe8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b0799157450a2ef6c50b4ffb9c0c40ee105fe8f", "html_url": "https://github.com/rust-lang/rust/commit/1b0799157450a2ef6c50b4ffb9c0c40ee105fe8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b0799157450a2ef6c50b4ffb9c0c40ee105fe8f/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b279c801635c2762c013c1d13a9bead3bcd9df4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b279c801635c2762c013c1d13a9bead3bcd9df4", "html_url": "https://github.com/rust-lang/rust/commit/5b279c801635c2762c013c1d13a9bead3bcd9df4"}], "stats": {"total": 127, "additions": 88, "deletions": 39}, "files": [{"sha": "0e43f1655ddb2f0c23a1d532344f3254f1230174", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 62, "deletions": 39, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/1b0799157450a2ef6c50b4ffb9c0c40ee105fe8f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b0799157450a2ef6c50b4ffb9c0c40ee105fe8f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=1b0799157450a2ef6c50b4ffb9c0c40ee105fe8f", "patch": "@@ -160,6 +160,10 @@ fn object_safety_violations_for_trait(\n     if !spans.is_empty() {\n         violations.push(ObjectSafetyViolation::SupertraitSelf(spans));\n     }\n+    let spans = bounds_reference_self(tcx, trait_def_id);\n+    if !spans.is_empty() {\n+        violations.push(ObjectSafetyViolation::SupertraitSelf(spans));\n+    }\n \n     violations.extend(\n         tcx.associated_items(trait_def_id)\n@@ -239,51 +243,70 @@ fn predicates_reference_self(\n     } else {\n         tcx.predicates_of(trait_def_id)\n     };\n-    let self_ty = tcx.types.self_param;\n-    let has_self_ty = |arg: &GenericArg<'_>| arg.walk().any(|arg| arg == self_ty.into());\n     predicates\n         .predicates\n         .iter()\n-        .map(|(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), sp))\n-        .filter_map(|(predicate, &sp)| {\n-            match predicate.skip_binders() {\n-                ty::PredicateAtom::Trait(ref data, _) => {\n-                    // In the case of a trait predicate, we can skip the \"self\" type.\n-                    if data.trait_ref.substs[1..].iter().any(has_self_ty) { Some(sp) } else { None }\n-                }\n-                ty::PredicateAtom::Projection(ref data) => {\n-                    // And similarly for projections. This should be redundant with\n-                    // the previous check because any projection should have a\n-                    // matching `Trait` predicate with the same inputs, but we do\n-                    // the check to be safe.\n-                    //\n-                    // Note that we *do* allow projection *outputs* to contain\n-                    // `self` (i.e., `trait Foo: Bar<Output=Self::Result> { type Result; }`),\n-                    // we just require the user to specify *both* outputs\n-                    // in the object type (i.e., `dyn Foo<Output=(), Result=()>`).\n-                    //\n-                    // This is ALT2 in issue #56288, see that for discussion of the\n-                    // possible alternatives.\n-                    if data.projection_ty.trait_ref(tcx).substs[1..].iter().any(has_self_ty) {\n-                        Some(sp)\n-                    } else {\n-                        None\n-                    }\n-                }\n-                ty::PredicateAtom::WellFormed(..)\n-                | ty::PredicateAtom::ObjectSafe(..)\n-                | ty::PredicateAtom::TypeOutlives(..)\n-                | ty::PredicateAtom::RegionOutlives(..)\n-                | ty::PredicateAtom::ClosureKind(..)\n-                | ty::PredicateAtom::Subtype(..)\n-                | ty::PredicateAtom::ConstEvaluatable(..)\n-                | ty::PredicateAtom::ConstEquate(..)\n-                | ty::PredicateAtom::TypeWellFormedFromEnv(..) => None,\n-            }\n-        })\n+        .map(|(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), *sp))\n+        .filter_map(|predicate| predicate_references_self(tcx, predicate))\n+        .collect()\n+}\n+\n+fn bounds_reference_self(tcx: TyCtxt<'_>, trait_def_id: DefId) -> SmallVec<[Span; 1]> {\n+    let trait_ref = ty::Binder::dummy(ty::TraitRef::identity(tcx, trait_def_id));\n+    tcx.associated_items(trait_def_id)\n+        .in_definition_order()\n+        .filter(|item| item.kind == ty::AssocKind::Type)\n+        .flat_map(|item| tcx.explicit_item_bounds(item.def_id))\n+        .map(|(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), *sp))\n+        .filter_map(|predicate| predicate_references_self(tcx, predicate))\n         .collect()\n }\n \n+fn predicate_references_self(\n+    tcx: TyCtxt<'tcx>,\n+    (predicate, sp): (ty::Predicate<'tcx>, Span),\n+) -> Option<Span> {\n+    let self_ty = tcx.types.self_param;\n+    let has_self_ty = |arg: &GenericArg<'_>| arg.walk().any(|arg| arg == self_ty.into());\n+    match predicate.skip_binders() {\n+        ty::PredicateAtom::Trait(ref data, _) => {\n+            // In the case of a trait predicate, we can skip the \"self\" type.\n+            if data.trait_ref.substs[1..].iter().any(has_self_ty) { Some(sp) } else { None }\n+        }\n+        ty::PredicateAtom::Projection(ref data) => {\n+            // And similarly for projections. This should be redundant with\n+            // the previous check because any projection should have a\n+            // matching `Trait` predicate with the same inputs, but we do\n+            // the check to be safe.\n+            //\n+            // It's also won't be redundant if we allow type-generic associated\n+            // types for trait objects.\n+            //\n+            // Note that we *do* allow projection *outputs* to contain\n+            // `self` (i.e., `trait Foo: Bar<Output=Self::Result> { type Result; }`),\n+            // we just require the user to specify *both* outputs\n+            // in the object type (i.e., `dyn Foo<Output=(), Result=()>`).\n+            //\n+            // This is ALT2 in issue #56288, see that for discussion of the\n+            // possible alternatives.\n+            if data.projection_ty.trait_ref(tcx).substs[1..].iter().any(has_self_ty) {\n+                Some(sp)\n+            } else {\n+                None\n+            }\n+        }\n+        ty::PredicateAtom::WellFormed(..)\n+        | ty::PredicateAtom::ObjectSafe(..)\n+        | ty::PredicateAtom::TypeOutlives(..)\n+        | ty::PredicateAtom::RegionOutlives(..)\n+        | ty::PredicateAtom::ClosureKind(..)\n+        | ty::PredicateAtom::Subtype(..)\n+        | ty::PredicateAtom::ConstEvaluatable(..)\n+        | ty::PredicateAtom::ConstEquate(..)\n+        | ty::PredicateAtom::TypeWellFormedFromEnv(..) => None,\n+    }\n+}\n+\n fn trait_has_sized_self(tcx: TyCtxt<'_>, trait_def_id: DefId) -> bool {\n     generics_require_sized_self(tcx, trait_def_id)\n }"}, {"sha": "44bd369324a4b640345dc8c769f2d7034c28a927", "filename": "src/test/ui/object-safety/object-safety-bounds.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b0799157450a2ef6c50b4ffb9c0c40ee105fe8f/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b0799157450a2ef6c50b4ffb9c0c40ee105fe8f/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-bounds.rs?ref=1b0799157450a2ef6c50b4ffb9c0c40ee105fe8f", "patch": "@@ -0,0 +1,12 @@\n+// Traits with bounds mentioning `Self` are not object safe\n+\n+trait X {\n+    type U: PartialEq<Self>;\n+}\n+\n+fn f() -> Box<dyn X<U = u32>> {\n+    //~^ ERROR the trait `X` cannot be made into an object\n+    loop {}\n+}\n+\n+fn main() {}"}, {"sha": "af4548308631e2304a7873584fcc016a3a9340fc", "filename": "src/test/ui/object-safety/object-safety-bounds.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1b0799157450a2ef6c50b4ffb9c0c40ee105fe8f/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b0799157450a2ef6c50b4ffb9c0c40ee105fe8f/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-bounds.stderr?ref=1b0799157450a2ef6c50b4ffb9c0c40ee105fe8f", "patch": "@@ -0,0 +1,14 @@\n+error[E0038]: the trait `X` cannot be made into an object\n+  --> $DIR/object-safety-bounds.rs:7:11\n+   |\n+LL | trait X {\n+   |       - this trait cannot be made into an object...\n+LL |     type U: PartialEq<Self>;\n+   |             --------------- ...because it uses `Self` as a type parameter in this\n+...\n+LL | fn f() -> Box<dyn X<U = u32>> {\n+   |           ^^^^^^^^^^^^^^^^^^^ the trait `X` cannot be made into an object\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0038`."}]}