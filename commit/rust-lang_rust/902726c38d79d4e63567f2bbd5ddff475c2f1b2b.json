{"sha": "902726c38d79d4e63567f2bbd5ddff475c2f1b2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwMjcyNmMzOGQ3OWQ0ZTYzNTY3ZjJiYmQ1ZGRmZjQ3NWMyZjFiMmI=", "commit": {"author": {"name": "Vincent Dal Maso", "email": "vincent.dalmaso.ext@delair-tech.com", "date": "2019-05-16T09:27:45Z"}, "committer": {"name": "Vincent Dal Maso", "email": "vincent.dalmaso.ext@delair-tech.com", "date": "2019-05-16T09:27:45Z"}, "message": "Fix match_same_arms to fail late\n\nChanges:\n- Add a function search_same_list which return a list of matched expressions\n- Change the match_same_arms implementation behaviour. It will lint each same arms found.", "tree": {"sha": "e0388c76de767568efe342dc7486e0526f439fd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0388c76de767568efe342dc7486e0526f439fd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/902726c38d79d4e63567f2bbd5ddff475c2f1b2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/902726c38d79d4e63567f2bbd5ddff475c2f1b2b", "html_url": "https://github.com/rust-lang/rust/commit/902726c38d79d4e63567f2bbd5ddff475c2f1b2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/902726c38d79d4e63567f2bbd5ddff475c2f1b2b/comments", "author": null, "committer": null, "parents": [{"sha": "f49d878ce5aede7e99d284a97cfdca321314ccc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f49d878ce5aede7e99d284a97cfdca321314ccc2", "html_url": "https://github.com/rust-lang/rust/commit/f49d878ce5aede7e99d284a97cfdca321314ccc2"}], "stats": {"total": 111, "additions": 74, "deletions": 37}, "files": [{"sha": "a28af2371edf543a03445b51f9b343c52f83cdb3", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 74, "deletions": 37, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/902726c38d79d4e63567f2bbd5ddff475c2f1b2b/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/902726c38d79d4e63567f2bbd5ddff475c2f1b2b/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=902726c38d79d4e63567f2bbd5ddff475c2f1b2b", "patch": "@@ -185,44 +185,48 @@ fn lint_match_arms(cx: &LateContext<'_, '_>, expr: &Expr) {\n         };\n \n         let indexed_arms: Vec<(usize, &Arm)> = arms.iter().enumerate().collect();\n-        if let Some((&(_, i), &(_, j))) = search_same(&indexed_arms, hash, eq) {\n-            span_lint_and_then(\n-                cx,\n-                MATCH_SAME_ARMS,\n-                j.body.span,\n-                \"this `match` has identical arm bodies\",\n-                |db| {\n-                    db.span_note(i.body.span, \"same as this\");\n-\n-                    // Note: this does not use `span_suggestion` on purpose:\n-                    // there is no clean way\n-                    // to remove the other arm. Building a span and suggest to replace it to \"\"\n-                    // makes an even more confusing error message. Also in order not to make up a\n-                    // span for the whole pattern, the suggestion is only shown when there is only\n-                    // one pattern. The user should know about `|` if they are already using it\u2026\n-\n-                    if i.pats.len() == 1 && j.pats.len() == 1 {\n-                        let lhs = snippet(cx, i.pats[0].span, \"<pat1>\");\n-                        let rhs = snippet(cx, j.pats[0].span, \"<pat2>\");\n-\n-                        if let PatKind::Wild = j.pats[0].node {\n-                            // if the last arm is _, then i could be integrated into _\n-                            // note that i.pats[0] cannot be _, because that would mean that we're\n-                            // hiding all the subsequent arms, and rust won't compile\n-                            db.span_note(\n-                                i.body.span,\n-                                &format!(\n-                                    \"`{}` has the same arm body as the `_` wildcard, consider removing it`\",\n-                                    lhs\n-                                ),\n-                            );\n-                        } else {\n-                            db.span_note(i.body.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs));\n+        search_same_list(&indexed_arms, hash, eq).map(|item| {\n+            for match_expr in item {\n+                let (&(_, i), &(_, j)) = match_expr;\n+\n+                span_lint_and_then(\n+                    cx,\n+                    MATCH_SAME_ARMS,\n+                    j.body.span,\n+                    \"this `match` has identical arm bodies\",\n+                    |db| {\n+                        db.span_note(i.body.span, \"same as this\");\n+\n+                        // Note: this does not use `span_suggestion` on purpose:\n+                        // there is no clean way\n+                        // to remove the other arm. Building a span and suggest to replace it to \"\"\n+                        // makes an even more confusing error message. Also in order not to make up a\n+                        // span for the whole pattern, the suggestion is only shown when there is only\n+                        // one pattern. The user should know about `|` if they are already using it\u2026\n+\n+                        if i.pats.len() == 1 && j.pats.len() == 1 {\n+                            let lhs = snippet(cx, i.pats[0].span, \"<pat1>\");\n+                            let rhs = snippet(cx, j.pats[0].span, \"<pat2>\");\n+\n+                            if let PatKind::Wild = j.pats[0].node {\n+                                // if the last arm is _, then i could be integrated into _\n+                                // note that i.pats[0] cannot be _, because that would mean that we're\n+                                // hiding all the subsequent arms, and rust won't compile\n+                                db.span_note(\n+                                    i.body.span,\n+                                    &format!(\n+                                        \"`{}` has the same arm body as the `_` wildcard, consider removing it`\",\n+                                        lhs\n+                                    ),\n+                                );\n+                            } else {\n+                                db.span_note(i.body.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs));\n+                            }\n                         }\n-                    }\n-                },\n-            );\n-        }\n+                    },\n+                );\n+            }\n+        });\n     }\n }\n \n@@ -360,3 +364,36 @@ where\n \n     None\n }\n+\n+fn search_same_list<T, Hash, Eq>(exprs: &[T], hash: Hash, eq: Eq) -> Option<Vec<(&T, &T)>>\n+where\n+    Hash: Fn(&T) -> u64,\n+    Eq: Fn(&T, &T) -> bool,\n+{\n+    let mut match_expr_list: Vec<(&T, &T)> = Vec::new();\n+\n+    let mut map: FxHashMap<_, Vec<&_>> =\n+        FxHashMap::with_capacity_and_hasher(exprs.len(), BuildHasherDefault::default());\n+\n+    for expr in exprs {\n+        match map.entry(hash(expr)) {\n+            Entry::Occupied(mut o) => {\n+                for o in o.get() {\n+                    if eq(o, expr) {\n+                        match_expr_list.push((o, expr));\n+                    }\n+                }\n+                o.get_mut().push(expr);\n+            },\n+            Entry::Vacant(v) => {\n+                v.insert(vec![expr]);\n+            },\n+        }\n+    }\n+\n+    if match_expr_list.is_empty() {\n+        None\n+    } else {\n+        Some(match_expr_list)\n+    }\n+}"}]}