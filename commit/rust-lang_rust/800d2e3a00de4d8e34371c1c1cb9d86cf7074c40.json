{"sha": "800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwMGQyZTNhMDBkZTRkOGUzNDM3MWMxYzFjYjlkODZjZjcwNzRjNDA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-28T05:30:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-28T05:30:03Z"}, "message": "Rollup merge of #73796 - lcnr:LocalDefId, r=matthewjasper\n\nreplace more `DefId`s with `LocalDefId`\n\npart of https://github.com/rust-lang/rust/issues/70853", "tree": {"sha": "9d68559e82750c1a8b8273a0f1b23970cb8a718f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d68559e82750c1a8b8273a0f1b23970cb8a718f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe+CrbCRBK7hj4Ov3rIwAAdHIIAIIRv9Zwm0Uuv6JjYtPzE5fB\nmv0PdJ5bCBGhXb4BmA24tAq7yMpza4T7+mu7CRwLbNPI5aF2D2Z0K3tXF1wIYuO3\noRO6W1Nh0xFNI/aFEfxcJYOMfwIvzGKljw/TfmcPy8M17s9yJlL3eA2+nmciAekO\nxl+tfIh+skVC5fmcdCcAYa40JS8NJqapKfpu2voukbAImr4v2oGUdF9l4Qq1IzKP\nmUUnBo1ughv3DttZinzayAJkZOCX8jONhlu+Ri3cZ9VXBb7/dw90KeyyYPYj6X4Z\n+iuHnS5Gr7KW+2k/8OmupgGGxu5CBGVwFaviHAwPAPdwVWZy3WUarKFZyfOO8U0=\n=YEjv\n-----END PGP SIGNATURE-----\n", "payload": "tree 9d68559e82750c1a8b8273a0f1b23970cb8a718f\nparent 596af5ae5d3f0cb3ee7168d605c24f7b55628db8\nparent 2d280a55a9820ab18b25b8080d30e6d0a864ec17\nauthor Manish Goregaokar <manishsmail@gmail.com> 1593322203 -0700\ncommitter GitHub <noreply@github.com> 1593322203 -0700\n\nRollup merge of #73796 - lcnr:LocalDefId, r=matthewjasper\n\nreplace more `DefId`s with `LocalDefId`\n\npart of https://github.com/rust-lang/rust/issues/70853\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "html_url": "https://github.com/rust-lang/rust/commit/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "596af5ae5d3f0cb3ee7168d605c24f7b55628db8", "url": "https://api.github.com/repos/rust-lang/rust/commits/596af5ae5d3f0cb3ee7168d605c24f7b55628db8", "html_url": "https://github.com/rust-lang/rust/commit/596af5ae5d3f0cb3ee7168d605c24f7b55628db8"}, {"sha": "2d280a55a9820ab18b25b8080d30e6d0a864ec17", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d280a55a9820ab18b25b8080d30e6d0a864ec17", "html_url": "https://github.com/rust-lang/rust/commit/2d280a55a9820ab18b25b8080d30e6d0a864ec17"}], "stats": {"total": 605, "additions": 304, "deletions": 301}, "files": [{"sha": "20617bb8bd8fc2aa84cfffef9be05b2960e0c3d3", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "patch": "@@ -28,30 +28,27 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         br: &ty::BoundRegion,\n     ) -> Option<(&hir::Ty<'tcx>, &hir::FnDecl<'tcx>)> {\n         if let Some(anon_reg) = self.tcx().is_suitable_region(region) {\n-            let def_id = anon_reg.def_id;\n-            if let Some(def_id) = def_id.as_local() {\n-                let hir_id = self.tcx().hir().as_local_hir_id(def_id);\n-                let fndecl = match self.tcx().hir().get(hir_id) {\n-                    Node::Item(&hir::Item { kind: hir::ItemKind::Fn(ref m, ..), .. })\n-                    | Node::TraitItem(&hir::TraitItem {\n-                        kind: hir::TraitItemKind::Fn(ref m, ..),\n-                        ..\n-                    })\n-                    | Node::ImplItem(&hir::ImplItem {\n-                        kind: hir::ImplItemKind::Fn(ref m, ..),\n-                        ..\n-                    }) => &m.decl,\n-                    _ => return None,\n-                };\n+            let hir_id = self.tcx().hir().as_local_hir_id(anon_reg.def_id);\n+            let fndecl = match self.tcx().hir().get(hir_id) {\n+                Node::Item(&hir::Item { kind: hir::ItemKind::Fn(ref m, ..), .. })\n+                | Node::TraitItem(&hir::TraitItem {\n+                    kind: hir::TraitItemKind::Fn(ref m, ..),\n+                    ..\n+                })\n+                | Node::ImplItem(&hir::ImplItem {\n+                    kind: hir::ImplItemKind::Fn(ref m, ..), ..\n+                }) => &m.decl,\n+                _ => return None,\n+            };\n \n-                return fndecl\n-                    .inputs\n-                    .iter()\n-                    .find_map(|arg| self.find_component_for_bound_region(arg, br))\n-                    .map(|ty| (ty, &**fndecl));\n-            }\n+            fndecl\n+                .inputs\n+                .iter()\n+                .find_map(|arg| self.find_component_for_bound_region(arg, br))\n+                .map(|ty| (ty, &**fndecl))\n+        } else {\n+            None\n         }\n-        None\n     }\n \n     // This method creates a FindNestedTypeVisitor which returns the type corresponding"}, {"sha": "72deba990b0b5e5dc5dc6a629cfcede63cce94ab", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "patch": "@@ -75,8 +75,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         }\n \n         if let Some((_, fndecl)) = self.find_anon_type(anon, &br) {\n-            let is_self_anon = self.is_self_anon(is_first, scope_def_id);\n-            if is_self_anon {\n+            if self.is_self_anon(is_first, scope_def_id) {\n                 return None;\n             }\n "}, {"sha": "b6e971feb0e5fdc4043f45411baa2264ea13cc19", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 196, "deletions": 198, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "patch": "@@ -10,219 +10,217 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when the return type is a static impl Trait.\n     pub(super) fn try_report_static_impl_trait(&self) -> Option<ErrorReported> {\n         debug!(\"try_report_static_impl_trait(error={:?})\", self.error);\n-        if let Some(ref error) = self.error {\n-            if let RegionResolutionError::SubSupConflict(\n-                _,\n-                var_origin,\n-                sub_origin,\n-                sub_r,\n-                sup_origin,\n-                sup_r,\n-            ) = error\n-            {\n-                debug!(\n-                    \"try_report_static_impl_trait(var={:?}, sub={:?} {:?} sup={:?} {:?})\",\n-                    var_origin, sub_origin, sub_r, sup_origin, sup_r\n+        if let Some(RegionResolutionError::SubSupConflict(\n+            _,\n+            var_origin,\n+            ref sub_origin,\n+            sub_r,\n+            ref sup_origin,\n+            sup_r,\n+        )) = self.error\n+        {\n+            debug!(\n+                \"try_report_static_impl_trait(var={:?}, sub={:?} {:?} sup={:?} {:?})\",\n+                var_origin, sub_origin, sub_r, sup_origin, sup_r\n+            );\n+            let anon_reg_sup = self.tcx().is_suitable_region(sup_r)?;\n+            debug!(\"try_report_static_impl_trait: anon_reg_sup={:?}\", anon_reg_sup);\n+            let fn_returns = self.tcx().return_type_impl_or_dyn_traits(anon_reg_sup.def_id);\n+            if fn_returns.is_empty() {\n+                return None;\n+            }\n+            debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_returns);\n+            if *sub_r == RegionKind::ReStatic {\n+                let sp = var_origin.span();\n+                let return_sp = sub_origin.span();\n+                let param_info = self.find_param_with_region(sup_r, sub_r)?;\n+                let (lifetime_name, lifetime) = if sup_r.has_name() {\n+                    (sup_r.to_string(), format!(\"lifetime `{}`\", sup_r))\n+                } else {\n+                    (\"'_\".to_owned(), \"an anonymous lifetime `'_`\".to_string())\n+                };\n+                let mut err = struct_span_err!(\n+                    self.tcx().sess,\n+                    sp,\n+                    E0759,\n+                    \"cannot infer an appropriate lifetime\"\n                 );\n-                let anon_reg_sup = self.tcx().is_suitable_region(sup_r)?;\n-                debug!(\"try_report_static_impl_trait: anon_reg_sup={:?}\", anon_reg_sup);\n-                let fn_returns = self.tcx().return_type_impl_or_dyn_traits(anon_reg_sup.def_id);\n-                if fn_returns.is_empty() {\n-                    return None;\n-                }\n-                debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_returns);\n-                if **sub_r == RegionKind::ReStatic {\n-                    let sp = var_origin.span();\n-                    let return_sp = sub_origin.span();\n-                    let param_info = self.find_param_with_region(sup_r, sub_r)?;\n-                    let (lifetime_name, lifetime) = if sup_r.has_name() {\n-                        (sup_r.to_string(), format!(\"lifetime `{}`\", sup_r))\n+                err.span_label(\n+                    param_info.param_ty_span,\n+                    &format!(\"this data with {}...\", lifetime),\n+                );\n+                debug!(\"try_report_static_impl_trait: param_info={:?}\", param_info);\n+\n+                // We try to make the output have fewer overlapping spans if possible.\n+                if (sp == sup_origin.span() || !return_sp.overlaps(sup_origin.span()))\n+                    && sup_origin.span() != return_sp\n+                {\n+                    // FIXME: account for `async fn` like in `async-await/issues/issue-62097.rs`\n+\n+                    // Customize the spans and labels depending on their relative order so\n+                    // that split sentences flow correctly.\n+                    if sup_origin.span().overlaps(return_sp) && sp == sup_origin.span() {\n+                        // Avoid the following:\n+                        //\n+                        // error: cannot infer an appropriate lifetime\n+                        //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n+                        //    |\n+                        // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n+                        //    |           ----                      ---------^-\n+                        //\n+                        // and instead show:\n+                        //\n+                        // error: cannot infer an appropriate lifetime\n+                        //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n+                        //    |\n+                        // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n+                        //    |           ----                               ^\n+                        err.span_label(\n+                            sup_origin.span(),\n+                            \"...is captured here, requiring it to live as long as `'static`\",\n+                        );\n                     } else {\n-                        (\"'_\".to_owned(), \"an anonymous lifetime `'_`\".to_string())\n-                    };\n-                    let mut err = struct_span_err!(\n-                        self.tcx().sess,\n-                        sp,\n-                        E0759,\n-                        \"cannot infer an appropriate lifetime\"\n-                    );\n+                        err.span_label(sup_origin.span(), \"...is captured here...\");\n+                        if return_sp < sup_origin.span() {\n+                            err.span_note(\n+                                return_sp,\n+                                \"...and is required to live as long as `'static` here\",\n+                            );\n+                        } else {\n+                            err.span_label(\n+                                return_sp,\n+                                \"...and is required to live as long as `'static` here\",\n+                            );\n+                        }\n+                    }\n+                } else {\n                     err.span_label(\n-                        param_info.param_ty_span,\n-                        &format!(\"this data with {}...\", lifetime),\n+                        return_sp,\n+                        \"...is captured and required to live as long as `'static` here\",\n                     );\n-                    debug!(\"try_report_static_impl_trait: param_info={:?}\", param_info);\n+                }\n \n-                    // We try to make the output have fewer overlapping spans if possible.\n-                    if (sp == sup_origin.span() || !return_sp.overlaps(sup_origin.span()))\n-                        && sup_origin.span() != return_sp\n-                    {\n-                        // FIXME: account for `async fn` like in `async-await/issues/issue-62097.rs`\n+                // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n+                let consider = \"consider changing the\";\n+                let declare = \"to declare that the\";\n+                let arg = match param_info.param.pat.simple_ident() {\n+                    Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n+                    None => \"the argument\".to_string(),\n+                };\n+                let explicit =\n+                    format!(\"you can add an explicit `{}` lifetime bound\", lifetime_name);\n+                let explicit_static =\n+                    format!(\"explicit `'static` bound to the lifetime of {}\", arg);\n+                let captures = format!(\"captures data from {}\", arg);\n+                let add_static_bound =\n+                    \"alternatively, add an explicit `'static` bound to this reference\";\n+                let plus_lt = format!(\" + {}\", lifetime_name);\n+                for fn_return in fn_returns {\n+                    if fn_return.span.desugaring_kind().is_some() {\n+                        // Skip `async` desugaring `impl Future`.\n+                        continue;\n+                    }\n+                    match fn_return.kind {\n+                        TyKind::OpaqueDef(item_id, _) => {\n+                            let item = self.tcx().hir().item(item_id.id);\n+                            let opaque = if let ItemKind::OpaqueTy(opaque) = &item.kind {\n+                                opaque\n+                            } else {\n+                                err.emit();\n+                                return Some(ErrorReported);\n+                            };\n \n-                        // Customize the spans and labels depending on their relative order so\n-                        // that split sentences flow correctly.\n-                        if sup_origin.span().overlaps(return_sp) && sp == sup_origin.span() {\n-                            // Avoid the following:\n-                            //\n-                            // error: cannot infer an appropriate lifetime\n-                            //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n-                            //    |\n-                            // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n-                            //    |           ----                      ---------^-\n-                            //\n-                            // and instead show:\n-                            //\n-                            // error: cannot infer an appropriate lifetime\n-                            //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n-                            //    |\n-                            // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n-                            //    |           ----                               ^\n-                            err.span_label(\n-                                sup_origin.span(),\n-                                \"...is captured here, requiring it to live as long as `'static`\",\n-                            );\n-                        } else {\n-                            err.span_label(sup_origin.span(), \"...is captured here...\");\n-                            if return_sp < sup_origin.span() {\n-                                err.span_note(\n-                                    return_sp,\n-                                    \"...and is required to live as long as `'static` here\",\n+                            if let Some(span) = opaque\n+                                .bounds\n+                                .iter()\n+                                .filter_map(|arg| match arg {\n+                                    GenericBound::Outlives(Lifetime {\n+                                        name: LifetimeName::Static,\n+                                        span,\n+                                        ..\n+                                    }) => Some(*span),\n+                                    _ => None,\n+                                })\n+                                .next()\n+                            {\n+                                err.span_suggestion_verbose(\n+                                    span,\n+                                    &format!(\"{} `impl Trait`'s {}\", consider, explicit_static),\n+                                    lifetime_name.clone(),\n+                                    Applicability::MaybeIncorrect,\n                                 );\n+                                err.span_suggestion_verbose(\n+                                    param_info.param_ty_span,\n+                                    add_static_bound,\n+                                    param_info.param_ty.to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            } else if let Some(_) = opaque\n+                                .bounds\n+                                .iter()\n+                                .filter_map(|arg| match arg {\n+                                    GenericBound::Outlives(Lifetime { name, span, .. })\n+                                        if name.ident().to_string() == lifetime_name =>\n+                                    {\n+                                        Some(*span)\n+                                    }\n+                                    _ => None,\n+                                })\n+                                .next()\n+                            {\n                             } else {\n-                                err.span_label(\n-                                    return_sp,\n-                                    \"...and is required to live as long as `'static` here\",\n+                                err.span_suggestion_verbose(\n+                                    fn_return.span.shrink_to_hi(),\n+                                    &format!(\n+                                        \"{declare} `impl Trait` {captures}, {explicit}\",\n+                                        declare = declare,\n+                                        captures = captures,\n+                                        explicit = explicit,\n+                                    ),\n+                                    plus_lt.clone(),\n+                                    Applicability::MaybeIncorrect,\n                                 );\n                             }\n                         }\n-                    } else {\n-                        err.span_label(\n-                            return_sp,\n-                            \"...is captured and required to live as long as `'static` here\",\n-                        );\n-                    }\n-\n-                    // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n-                    let consider = \"consider changing the\";\n-                    let declare = \"to declare that the\";\n-                    let arg = match param_info.param.pat.simple_ident() {\n-                        Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n-                        None => \"the argument\".to_string(),\n-                    };\n-                    let explicit =\n-                        format!(\"you can add an explicit `{}` lifetime bound\", lifetime_name);\n-                    let explicit_static =\n-                        format!(\"explicit `'static` bound to the lifetime of {}\", arg);\n-                    let captures = format!(\"captures data from {}\", arg);\n-                    let add_static_bound =\n-                        \"alternatively, add an explicit `'static` bound to this reference\";\n-                    let plus_lt = format!(\" + {}\", lifetime_name);\n-                    for fn_return in fn_returns {\n-                        if fn_return.span.desugaring_kind().is_some() {\n-                            // Skip `async` desugaring `impl Future`.\n-                            continue;\n-                        }\n-                        match fn_return.kind {\n-                            TyKind::OpaqueDef(item_id, _) => {\n-                                let item = self.tcx().hir().item(item_id.id);\n-                                let opaque = if let ItemKind::OpaqueTy(opaque) = &item.kind {\n-                                    opaque\n-                                } else {\n-                                    err.emit();\n-                                    return Some(ErrorReported);\n-                                };\n-\n-                                if let Some(span) = opaque\n-                                    .bounds\n-                                    .iter()\n-                                    .filter_map(|arg| match arg {\n-                                        GenericBound::Outlives(Lifetime {\n-                                            name: LifetimeName::Static,\n-                                            span,\n-                                            ..\n-                                        }) => Some(*span),\n-                                        _ => None,\n-                                    })\n-                                    .next()\n-                                {\n-                                    err.span_suggestion_verbose(\n-                                        span,\n-                                        &format!(\"{} `impl Trait`'s {}\", consider, explicit_static),\n-                                        lifetime_name.clone(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                    err.span_suggestion_verbose(\n-                                        param_info.param_ty_span,\n-                                        add_static_bound,\n-                                        param_info.param_ty.to_string(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                } else if let Some(_) = opaque\n-                                    .bounds\n-                                    .iter()\n-                                    .filter_map(|arg| match arg {\n-                                        GenericBound::Outlives(Lifetime { name, span, .. })\n-                                            if name.ident().to_string() == lifetime_name =>\n-                                        {\n-                                            Some(*span)\n-                                        }\n-                                        _ => None,\n-                                    })\n-                                    .next()\n-                                {\n-                                } else {\n-                                    err.span_suggestion_verbose(\n-                                        fn_return.span.shrink_to_hi(),\n-                                        &format!(\n-                                            \"{declare} `impl Trait` {captures}, {explicit}\",\n-                                            declare = declare,\n-                                            captures = captures,\n-                                            explicit = explicit,\n-                                        ),\n-                                        plus_lt.clone(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n+                        TyKind::TraitObject(_, lt) => match lt.name {\n+                            LifetimeName::ImplicitObjectLifetimeDefault => {\n+                                err.span_suggestion_verbose(\n+                                    fn_return.span.shrink_to_hi(),\n+                                    &format!(\n+                                        \"{declare} trait object {captures}, {explicit}\",\n+                                        declare = declare,\n+                                        captures = captures,\n+                                        explicit = explicit,\n+                                    ),\n+                                    plus_lt.clone(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                            name if name.ident().to_string() != lifetime_name => {\n+                                // With this check we avoid suggesting redundant bounds. This\n+                                // would happen if there are nested impl/dyn traits and only\n+                                // one of them has the bound we'd suggest already there, like\n+                                // in `impl Foo<X = dyn Bar> + '_`.\n+                                err.span_suggestion_verbose(\n+                                    lt.span,\n+                                    &format!(\"{} trait object's {}\", consider, explicit_static),\n+                                    lifetime_name.clone(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                                err.span_suggestion_verbose(\n+                                    param_info.param_ty_span,\n+                                    add_static_bound,\n+                                    param_info.param_ty.to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n                             }\n-                            TyKind::TraitObject(_, lt) => match lt.name {\n-                                LifetimeName::ImplicitObjectLifetimeDefault => {\n-                                    err.span_suggestion_verbose(\n-                                        fn_return.span.shrink_to_hi(),\n-                                        &format!(\n-                                            \"{declare} trait object {captures}, {explicit}\",\n-                                            declare = declare,\n-                                            captures = captures,\n-                                            explicit = explicit,\n-                                        ),\n-                                        plus_lt.clone(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n-                                name if name.ident().to_string() != lifetime_name => {\n-                                    // With this check we avoid suggesting redundant bounds. This\n-                                    // would happen if there are nested impl/dyn traits and only\n-                                    // one of them has the bound we'd suggest already there, like\n-                                    // in `impl Foo<X = dyn Bar> + '_`.\n-                                    err.span_suggestion_verbose(\n-                                        lt.span,\n-                                        &format!(\"{} trait object's {}\", consider, explicit_static),\n-                                        lifetime_name.clone(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                    err.span_suggestion_verbose(\n-                                        param_info.param_ty_span,\n-                                        add_static_bound,\n-                                        param_info.param_ty.to_string(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n-                                _ => {}\n-                            },\n                             _ => {}\n-                        }\n+                        },\n+                        _ => {}\n                     }\n-                    err.emit();\n-                    return Some(ErrorReported);\n                 }\n+                err.emit();\n+                return Some(ErrorReported);\n             }\n         }\n         None"}, {"sha": "fa999abb1a86c46b672c88b81b49d1efc36f5fea", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "patch": "@@ -3,7 +3,7 @@\n \n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::{self, DefIdTree, Region, Ty};\n use rustc_span::Span;\n \n@@ -92,7 +92,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     // FIXME(#42703) - Need to handle certain cases here.\n     pub(super) fn is_return_type_anon(\n         &self,\n-        scope_def_id: DefId,\n+        scope_def_id: LocalDefId,\n         br: ty::BoundRegion,\n         decl: &hir::FnDecl<'_>,\n     ) -> Option<Span> {\n@@ -112,9 +112,12 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     // corresponds to self and if yes, we display E0312.\n     // FIXME(#42700) - Need to format self properly to\n     // enable E0621 for it.\n-    pub(super) fn is_self_anon(&self, is_first: bool, scope_def_id: DefId) -> bool {\n+    pub(super) fn is_self_anon(&self, is_first: bool, scope_def_id: LocalDefId) -> bool {\n         is_first\n-            && self.tcx().opt_associated_item(scope_def_id).map(|i| i.fn_has_self_parameter)\n+            && self\n+                .tcx()\n+                .opt_associated_item(scope_def_id.to_def_id())\n+                .map(|i| i.fn_has_self_parameter)\n                 == Some(true)\n     }\n }"}, {"sha": "75c10de9bbe5ef29e38e4f707464ad3075c6f332", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "patch": "@@ -458,11 +458,11 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn visit_item_likes_in_module<V>(&self, module: DefId, visitor: &mut V)\n+    pub fn visit_item_likes_in_module<V>(&self, module: LocalDefId, visitor: &mut V)\n     where\n         V: ItemLikeVisitor<'hir>,\n     {\n-        let module = self.tcx.hir_module_items(module.expect_local());\n+        let module = self.tcx.hir_module_items(module);\n \n         for id in &module.items {\n             visitor.visit_item(self.expect_item(*id));"}, {"sha": "ba5a8c3ec2052a22dc2fdaa2a68ef7e0d66acbe4", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "patch": "@@ -15,11 +15,11 @@ use rustc_query_system::query::QueryDescription;\n use rustc_span::symbol::Symbol;\n use std::borrow::Cow;\n \n-fn describe_as_module(def_id: DefId, tcx: TyCtxt<'_>) -> String {\n+fn describe_as_module(def_id: LocalDefId, tcx: TyCtxt<'_>) -> String {\n     if def_id.is_top_level_module() {\n         \"top-level module\".to_string()\n     } else {\n-        format!(\"module `{}`\", tcx.def_path_str(def_id))\n+        format!(\"module `{}`\", tcx.def_path_str(def_id.to_def_id()))\n     }\n }\n \n@@ -473,49 +473,49 @@ rustc_queries! {\n \n     Other {\n         query lint_mod(key: LocalDefId) -> () {\n-            desc { |tcx| \"linting {}\", describe_as_module(key.to_def_id(), tcx) }\n+            desc { |tcx| \"linting {}\", describe_as_module(key, tcx) }\n         }\n \n         /// Checks the attributes in the module.\n-        query check_mod_attrs(key: DefId) -> () {\n+        query check_mod_attrs(key: LocalDefId) -> () {\n             desc { |tcx| \"checking attributes in {}\", describe_as_module(key, tcx) }\n         }\n \n-        query check_mod_unstable_api_usage(key: DefId) -> () {\n+        query check_mod_unstable_api_usage(key: LocalDefId) -> () {\n             desc { |tcx| \"checking for unstable API usage in {}\", describe_as_module(key, tcx) }\n         }\n \n         /// Checks the const bodies in the module for illegal operations (e.g. `if` or `loop`).\n-        query check_mod_const_bodies(key: DefId) -> () {\n+        query check_mod_const_bodies(key: LocalDefId) -> () {\n             desc { |tcx| \"checking consts in {}\", describe_as_module(key, tcx) }\n         }\n \n         /// Checks the loops in the module.\n-        query check_mod_loops(key: DefId) -> () {\n+        query check_mod_loops(key: LocalDefId) -> () {\n             desc { |tcx| \"checking loops in {}\", describe_as_module(key, tcx) }\n         }\n \n-        query check_mod_item_types(key: DefId) -> () {\n+        query check_mod_item_types(key: LocalDefId) -> () {\n             desc { |tcx| \"checking item types in {}\", describe_as_module(key, tcx) }\n         }\n \n         query check_mod_privacy(key: LocalDefId) -> () {\n-            desc { |tcx| \"checking privacy in {}\", describe_as_module(key.to_def_id(), tcx) }\n+            desc { |tcx| \"checking privacy in {}\", describe_as_module(key, tcx) }\n         }\n \n-        query check_mod_intrinsics(key: DefId) -> () {\n+        query check_mod_intrinsics(key: LocalDefId) -> () {\n             desc { |tcx| \"checking intrinsics in {}\", describe_as_module(key, tcx) }\n         }\n \n-        query check_mod_liveness(key: DefId) -> () {\n+        query check_mod_liveness(key: LocalDefId) -> () {\n             desc { |tcx| \"checking liveness of variables in {}\", describe_as_module(key, tcx) }\n         }\n \n-        query check_mod_impl_wf(key: DefId) -> () {\n+        query check_mod_impl_wf(key: LocalDefId) -> () {\n             desc { |tcx| \"checking that impls are well-formed in {}\", describe_as_module(key, tcx) }\n         }\n \n-        query collect_mod_item_types(key: DefId) -> () {\n+        query collect_mod_item_types(key: LocalDefId) -> () {\n             desc { |tcx| \"collecting item types in {}\", describe_as_module(key, tcx) }\n         }\n "}, {"sha": "44c8c1f6fdba44ecaf1cf9af4197d86ebb2ae242", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "patch": "@@ -873,8 +873,8 @@ impl<'tcx> CommonConsts<'tcx> {\n // conflict.\n #[derive(Debug)]\n pub struct FreeRegionInfo {\n-    // def id corresponding to FreeRegion\n-    pub def_id: DefId,\n+    // `LocalDefId` corresponding to FreeRegion\n+    pub def_id: LocalDefId,\n     // the bound region corresponding to FreeRegion\n     pub boundregion: ty::BoundRegion,\n     // checks if bound region is in Impl Item\n@@ -1412,14 +1412,17 @@ impl<'tcx> TyCtxt<'tcx> {\n     // Returns the `DefId` and the `BoundRegion` corresponding to the given region.\n     pub fn is_suitable_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n         let (suitable_region_binding_scope, bound_region) = match *region {\n-            ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n-            ty::ReEarlyBound(ref ebr) => {\n-                (self.parent(ebr.def_id).unwrap(), ty::BoundRegion::BrNamed(ebr.def_id, ebr.name))\n+            ty::ReFree(ref free_region) => {\n+                (free_region.scope.expect_local(), free_region.bound_region)\n             }\n+            ty::ReEarlyBound(ref ebr) => (\n+                self.parent(ebr.def_id).unwrap().expect_local(),\n+                ty::BoundRegion::BrNamed(ebr.def_id, ebr.name),\n+            ),\n             _ => return None, // not a free region\n         };\n \n-        let hir_id = self.hir().as_local_hir_id(suitable_region_binding_scope.expect_local());\n+        let hir_id = self.hir().as_local_hir_id(suitable_region_binding_scope);\n         let is_impl_item = match self.hir().find(hir_id) {\n             Some(Node::Item(..) | Node::TraitItem(..)) => false,\n             Some(Node::ImplItem(..)) => {\n@@ -1436,8 +1439,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Given a `DefId` for an `fn`, return all the `dyn` and `impl` traits in its return type.\n-    pub fn return_type_impl_or_dyn_traits(&self, scope_def_id: DefId) -> Vec<&'tcx hir::Ty<'tcx>> {\n-        let hir_id = self.hir().as_local_hir_id(scope_def_id.expect_local());\n+    pub fn return_type_impl_or_dyn_traits(\n+        &self,\n+        scope_def_id: LocalDefId,\n+    ) -> Vec<&'tcx hir::Ty<'tcx>> {\n+        let hir_id = self.hir().as_local_hir_id(scope_def_id);\n         let hir_output = match self.hir().get(hir_id) {\n             Node::Item(hir::Item {\n                 kind:\n@@ -1480,9 +1486,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         v.0\n     }\n \n-    pub fn return_type_impl_trait(&self, scope_def_id: DefId) -> Option<(Ty<'tcx>, Span)> {\n+    pub fn return_type_impl_trait(&self, scope_def_id: LocalDefId) -> Option<(Ty<'tcx>, Span)> {\n         // HACK: `type_of_def_id()` will fail on these (#55796), so return `None`.\n-        let hir_id = self.hir().as_local_hir_id(scope_def_id.expect_local());\n+        let hir_id = self.hir().as_local_hir_id(scope_def_id);\n         match self.hir().get(hir_id) {\n             Node::Item(item) => {\n                 match item.kind {\n@@ -1512,8 +1518,9 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     // Checks if the bound region is in Impl Item.\n-    pub fn is_bound_region_in_impl_item(&self, suitable_region_binding_scope: DefId) -> bool {\n-        let container_id = self.associated_item(suitable_region_binding_scope).container.id();\n+    pub fn is_bound_region_in_impl_item(&self, suitable_region_binding_scope: LocalDefId) -> bool {\n+        let container_id =\n+            self.associated_item(suitable_region_binding_scope.to_def_id()).container.id();\n         if self.impl_trait_ref(container_id).is_some() {\n             // For now, we do not try to target impls of traits. This is\n             // because this message is going to suggest that the user"}, {"sha": "99b9788c20b053b549c6b5eb918e2fc60ab27076", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "patch": "@@ -579,7 +579,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         if let (Some(f), Some(ty::RegionKind::ReStatic)) =\n             (self.to_error_region(fr), self.to_error_region(outlived_fr))\n         {\n-            if let Some((ty::TyS { kind: ty::Opaque(did, substs), .. }, _)) = self\n+            if let Some((&ty::TyS { kind: ty::Opaque(did, substs), .. }, _)) = self\n                 .infcx\n                 .tcx\n                 .is_suitable_region(f)\n@@ -592,7 +592,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 //\n                 // eg. check for `impl Trait + 'static` instead of `impl Trait`.\n                 let has_static_predicate = {\n-                    let predicates_of = self.infcx.tcx.predicates_of(*did);\n+                    let predicates_of = self.infcx.tcx.predicates_of(did);\n                     let bounds = predicates_of.instantiate(self.infcx.tcx, substs);\n \n                     let mut found = false;\n@@ -625,7 +625,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     diag.help(&format!(\"consider replacing `{}` with `{}`\", fr_name, static_str));\n                 } else {\n                     // Otherwise, we should suggest adding a constraint on the return type.\n-                    let span = self.infcx.tcx.def_span(*did);\n+                    let span = self.infcx.tcx.def_span(did);\n                     if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n                         let suggestable_fr_name = if fr_name.was_named() {\n                             fr_name.to_string()"}, {"sha": "7b292ee71f99d22f49dbef2ad6e5f4256b0473e2", "filename": "src/librustc_mir/borrow_check/universal_regions.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs?ref=800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "patch": "@@ -232,8 +232,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     ) -> Self {\n         let tcx = infcx.tcx;\n         let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id);\n-        UniversalRegionsBuilder { infcx, mir_def_id: mir_def_id.to_def_id(), mir_hir_id, param_env }\n-            .build()\n+        UniversalRegionsBuilder { infcx, mir_def_id, mir_hir_id, param_env }.build()\n     }\n \n     /// Given a reference to a closure type, extracts all the values\n@@ -389,7 +388,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n \n struct UniversalRegionsBuilder<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n-    mir_def_id: DefId,\n+    mir_def_id: LocalDefId,\n     mir_hir_id: HirId,\n     param_env: ty::ParamEnv<'tcx>,\n }\n@@ -418,15 +417,15 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let mut indices = self.compute_indices(fr_static, defining_ty);\n         debug!(\"build: indices={:?}\", indices);\n \n-        let closure_base_def_id = self.infcx.tcx.closure_base_def_id(self.mir_def_id);\n+        let closure_base_def_id = self.infcx.tcx.closure_base_def_id(self.mir_def_id.to_def_id());\n \n         // If this is a closure or generator, then the late-bound regions from the enclosing\n         // function are actually external regions to us. For example, here, 'a is not local\n         // to the closure c (although it is local to the fn foo):\n         // fn foo<'a>() {\n         //     let c = || { let x: &'a u32 = ...; }\n         // }\n-        if self.mir_def_id != closure_base_def_id {\n+        if self.mir_def_id.to_def_id() != closure_base_def_id {\n             self.infcx.replace_late_bound_regions_with_nll_infer_vars(self.mir_def_id, &mut indices)\n         }\n \n@@ -443,7 +442,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         );\n         // Converse of above, if this is a function then the late-bound regions declared on its\n         // signature are local to the fn.\n-        if self.mir_def_id == closure_base_def_id {\n+        if self.mir_def_id.to_def_id() == closure_base_def_id {\n             self.infcx\n                 .replace_late_bound_regions_with_nll_infer_vars(self.mir_def_id, &mut indices);\n         }\n@@ -508,14 +507,14 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n     /// see `DefiningTy` for details.\n     fn defining_ty(&self) -> DefiningTy<'tcx> {\n         let tcx = self.infcx.tcx;\n-        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n+        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id.to_def_id());\n \n         match tcx.hir().body_owner_kind(self.mir_hir_id) {\n             BodyOwnerKind::Closure | BodyOwnerKind::Fn => {\n-                let defining_ty = if self.mir_def_id == closure_base_def_id {\n+                let defining_ty = if self.mir_def_id.to_def_id() == closure_base_def_id {\n                     tcx.type_of(closure_base_def_id)\n                 } else {\n-                    let tables = tcx.typeck_tables_of(self.mir_def_id.expect_local());\n+                    let tables = tcx.typeck_tables_of(self.mir_def_id);\n                     tables.node_type(self.mir_hir_id)\n                 };\n \n@@ -540,11 +539,11 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             }\n \n             BodyOwnerKind::Const | BodyOwnerKind::Static(..) => {\n-                assert_eq!(closure_base_def_id, self.mir_def_id);\n+                assert_eq!(self.mir_def_id.to_def_id(), closure_base_def_id);\n                 let identity_substs = InternalSubsts::identity_for_item(tcx, closure_base_def_id);\n                 let substs =\n                     self.infcx.replace_free_regions_with_nll_infer_vars(FR, &identity_substs);\n-                DefiningTy::Const(self.mir_def_id, substs)\n+                DefiningTy::Const(self.mir_def_id.to_def_id(), substs)\n             }\n         }\n     }\n@@ -559,7 +558,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         defining_ty: DefiningTy<'tcx>,\n     ) -> UniversalRegionIndices<'tcx> {\n         let tcx = self.infcx.tcx;\n-        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n+        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id.to_def_id());\n         let identity_substs = InternalSubsts::identity_for_item(tcx, closure_base_def_id);\n         let fr_substs = match defining_ty {\n             DefiningTy::Closure(_, ref substs) | DefiningTy::Generator(_, ref substs, _) => {\n@@ -593,7 +592,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let tcx = self.infcx.tcx;\n         match defining_ty {\n             DefiningTy::Closure(def_id, substs) => {\n-                assert_eq!(self.mir_def_id, def_id);\n+                assert_eq!(self.mir_def_id.to_def_id(), def_id);\n                 let closure_sig = substs.as_closure().sig();\n                 let inputs_and_output = closure_sig.inputs_and_output();\n                 let closure_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n@@ -617,7 +616,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             }\n \n             DefiningTy::Generator(def_id, substs, movability) => {\n-                assert_eq!(self.mir_def_id, def_id);\n+                assert_eq!(self.mir_def_id.to_def_id(), def_id);\n                 let resume_ty = substs.as_generator().resume_ty();\n                 let output = substs.as_generator().return_ty();\n                 let generator_ty = tcx.mk_generator(def_id, substs, movability);\n@@ -635,7 +634,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             DefiningTy::Const(def_id, _) => {\n                 // For a constant body, there are no inputs, and one\n                 // \"output\" (the type of the constant).\n-                assert_eq!(self.mir_def_id, def_id);\n+                assert_eq!(self.mir_def_id.to_def_id(), def_id);\n                 let ty = tcx.type_of(def_id);\n                 let ty = indices.fold_to_region_vids(tcx, &ty);\n                 ty::Binder::dummy(tcx.intern_type_list(&[ty]))\n@@ -656,7 +655,7 @@ trait InferCtxtExt<'tcx> {\n     fn replace_bound_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NLLRegionVariableOrigin,\n-        all_outlive_scope: DefId,\n+        all_outlive_scope: LocalDefId,\n         value: &ty::Binder<T>,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) -> T\n@@ -665,7 +664,7 @@ trait InferCtxtExt<'tcx> {\n \n     fn replace_late_bound_regions_with_nll_infer_vars(\n         &self,\n-        mir_def_id: DefId,\n+        mir_def_id: LocalDefId,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     );\n }\n@@ -685,7 +684,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     fn replace_bound_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NLLRegionVariableOrigin,\n-        all_outlive_scope: DefId,\n+        all_outlive_scope: LocalDefId,\n         value: &ty::Binder<T>,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) -> T\n@@ -699,7 +698,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n         let (value, _map) = self.tcx.replace_late_bound_regions(value, |br| {\n             debug!(\"replace_bound_regions_with_nll_infer_vars: br={:?}\", br);\n             let liberated_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                scope: all_outlive_scope,\n+                scope: all_outlive_scope.to_def_id(),\n                 bound_region: br,\n             }));\n             let region_vid = self.next_nll_region_var(origin);\n@@ -724,11 +723,11 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     /// inputs vector.\n     fn replace_late_bound_regions_with_nll_infer_vars(\n         &self,\n-        mir_def_id: DefId,\n+        mir_def_id: LocalDefId,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) {\n         debug!(\"replace_late_bound_regions_with_nll_infer_vars(mir_def_id={:?})\", mir_def_id);\n-        let closure_base_def_id = self.tcx.closure_base_def_id(mir_def_id);\n+        let closure_base_def_id = self.tcx.closure_base_def_id(mir_def_id.to_def_id());\n         for_each_late_bound_region_defined_on(self.tcx, closure_base_def_id, |r| {\n             debug!(\"replace_late_bound_regions_with_nll_infer_vars: r={:?}\", r);\n             if !indices.indices.contains_key(&r) {"}, {"sha": "ef84f251390e6045efcf82bfa15ec9935feca066", "filename": "src/librustc_passes/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_passes%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_passes%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_attr.rs?ref=800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "patch": "@@ -12,7 +12,7 @@ use rustc_ast::ast::{Attribute, NestedMetaItem};\n use rustc_ast::attr;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{self, HirId, Item, ItemKind, TraitItem};\n use rustc_hir::{MethodKind, Target};\n@@ -464,7 +464,7 @@ fn is_c_like_enum(item: &Item<'_>) -> bool {\n     }\n }\n \n-fn check_mod_attrs(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+fn check_mod_attrs(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     tcx.hir()\n         .visit_item_likes_in_module(module_def_id, &mut CheckAttrVisitor { tcx }.as_deep_visitor());\n }"}, {"sha": "90a076eeded7ed520be0afa2a4a410262c88169b", "filename": "src/librustc_passes/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_passes%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_passes%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_const.rs?ref=800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "patch": "@@ -9,7 +9,7 @@\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::query::Providers;\n@@ -62,7 +62,7 @@ impl NonConstExpr {\n     }\n }\n \n-fn check_mod_const_bodies(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+fn check_mod_const_bodies(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     let mut vis = CheckConstVisitor::new(tcx);\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut vis.as_deep_visitor());\n }"}, {"sha": "2edbc29b7efb6fcb92936d694547a39ece519ca0", "filename": "src/librustc_passes/hir_id_validator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_passes%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_passes%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_id_validator.rs?ref=800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "patch": "@@ -17,7 +17,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n     par_iter(&hir_map.krate().modules).for_each(|(module_id, _)| {\n         let local_def_id = hir_map.local_def_id(*module_id);\n         hir_map.visit_item_likes_in_module(\n-            local_def_id.to_def_id(),\n+            local_def_id,\n             &mut OuterVisitor { hir_map, errors: &errors },\n         );\n     });"}, {"sha": "683039df15ac6d0de0f47898f577befc37df68ea", "filename": "src/librustc_passes/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_passes%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_passes%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fintrinsicck.rs?ref=800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "patch": "@@ -2,7 +2,7 @@ use rustc_ast::ast::{FloatTy, InlineAsmTemplatePiece, IntTy, UintTy};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_index::vec::Idx;\n use rustc_middle::ty::layout::{LayoutError, SizeSkeleton};\n@@ -14,7 +14,7 @@ use rustc_target::abi::{Pointer, VariantIdx};\n use rustc_target::asm::{InlineAsmRegOrRegClass, InlineAsmType};\n use rustc_target::spec::abi::Abi::RustIntrinsic;\n \n-fn check_mod_intrinsics(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+fn check_mod_intrinsics(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut ItemVisitor { tcx }.as_deep_visitor());\n }\n "}, {"sha": "798c6b8925bbf6d03c992507d955c3633a8d9a06", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "patch": "@@ -89,7 +89,7 @@ use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::*;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{Expr, HirId, HirIdMap, HirIdSet, Node};\n use rustc_middle::hir::map::Map;\n@@ -172,7 +172,7 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n     }\n }\n \n-fn check_mod_liveness(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+fn check_mod_liveness(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut IrMaps::new(tcx, module_def_id).as_deep_visitor(),\n@@ -248,7 +248,7 @@ enum VarKind {\n \n struct IrMaps<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    body_owner: DefId,\n+    body_owner: LocalDefId,\n     num_live_nodes: usize,\n     num_vars: usize,\n     live_node_map: HirIdMap<LiveNode>,\n@@ -259,7 +259,7 @@ struct IrMaps<'tcx> {\n }\n \n impl IrMaps<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>, body_owner: DefId) -> IrMaps<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>, body_owner: LocalDefId) -> IrMaps<'tcx> {\n         IrMaps {\n             tcx,\n             body_owner,\n@@ -349,7 +349,7 @@ fn visit_fn<'tcx>(\n \n     // swap in a new set of IR maps for this function body:\n     let def_id = ir.tcx.hir().local_def_id(id);\n-    let mut fn_maps = IrMaps::new(ir.tcx, def_id.to_def_id());\n+    let mut fn_maps = IrMaps::new(ir.tcx, def_id);\n \n     // Don't run unused pass for #[derive()]\n     if let FnKind::Method(..) = fk {\n@@ -484,7 +484,7 @@ fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr<'tcx>) {\n             }\n             ir.set_captures(expr.hir_id, call_caps);\n             let old_body_owner = ir.body_owner;\n-            ir.body_owner = closure_def_id.to_def_id();\n+            ir.body_owner = closure_def_id;\n             intravisit::walk_expr(ir, expr);\n             ir.body_owner = old_body_owner;\n         }\n@@ -937,7 +937,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             for (&var_hir_id, upvar) in upvars.iter().rev() {\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                    closure_expr_id: self.ir.body_owner.expect_local(),\n+                    closure_expr_id: self.ir.body_owner,\n                 };\n                 match self.tables.upvar_capture(upvar_id) {\n                     ty::UpvarCapture::ByRef(_) => {\n@@ -1614,7 +1614,7 @@ impl<'tcx> Liveness<'_, 'tcx> {\n             let var = self.variable(var_hir_id, upvar.span);\n             let upvar_id = ty::UpvarId {\n                 var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                closure_expr_id: self.ir.body_owner.expect_local(),\n+                closure_expr_id: self.ir.body_owner,\n             };\n             match self.tables.upvar_capture(upvar_id) {\n                 ty::UpvarCapture::ByValue => {}"}, {"sha": "d7012d4d711df89de5d8e08cd4fc7a96ddd78636", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "patch": "@@ -2,7 +2,7 @@ use Context::*;\n \n use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{Destination, Movability, Node};\n use rustc_middle::hir::map::Map;\n@@ -29,7 +29,7 @@ struct CheckLoopVisitor<'a, 'hir> {\n     cx: Context,\n }\n \n-fn check_mod_loops(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+fn check_mod_loops(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut CheckLoopVisitor { sess: &tcx.sess, hir_map: tcx.hir(), cx: Normal }.as_deep_visitor(),"}, {"sha": "ad512c63352f1a062c8bf0daeee2cb5a216754f2", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "patch": "@@ -7,7 +7,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{Generics, HirId, Item, StructField, Variant};\n use rustc_middle::hir::map::Map;\n@@ -472,7 +472,7 @@ fn new_index(tcx: TyCtxt<'tcx>) -> Index<'tcx> {\n \n /// Cross-references the feature names of unstable APIs with enabled\n /// features and possibly prints errors.\n-fn check_mod_unstable_api_usage(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+fn check_mod_unstable_api_usage(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut Checker { tcx }.as_deep_visitor());\n }\n "}, {"sha": "7c4048ab223023f3b56bd3671a3043a1bca01131", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "patch": "@@ -737,7 +737,7 @@ pub fn check_wf_new(tcx: TyCtxt<'_>) {\n     tcx.hir().krate().par_visit_all_item_likes(&visit);\n }\n \n-fn check_mod_item_types(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+fn check_mod_item_types(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut CheckItemTypesVisitor { tcx });\n }\n "}, {"sha": "b486e3d3536c99f4e0f1e69d62be93f56deb8fff", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "patch": "@@ -55,7 +55,7 @@ struct OnlySelfBounds(bool);\n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n \n-fn collect_mod_item_types(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+fn collect_mod_item_types(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut CollectItemTypesVisitor { tcx }.as_deep_visitor(),"}, {"sha": "77cd1b3de0106723004e428c9aab4773e1efd4be", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800d2e3a00de4d8e34371c1c1cb9d86cf7074c40/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=800d2e3a00de4d8e34371c1c1cb9d86cf7074c40", "patch": "@@ -14,7 +14,7 @@ use min_specialization::check_min_specialization;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n@@ -59,11 +59,11 @@ pub fn impl_wf_check(tcx: TyCtxt<'_>) {\n     // but it's one that we must perform earlier than the rest of\n     // WfCheck.\n     for &module in tcx.hir().krate().modules.keys() {\n-        tcx.ensure().check_mod_impl_wf(tcx.hir().local_def_id(module).to_def_id());\n+        tcx.ensure().check_mod_impl_wf(tcx.hir().local_def_id(module));\n     }\n }\n \n-fn check_mod_impl_wf(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+fn check_mod_impl_wf(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     let min_specialization = tcx.features().min_specialization;\n     tcx.hir()\n         .visit_item_likes_in_module(module_def_id, &mut ImplWfCheck { tcx, min_specialization });"}]}