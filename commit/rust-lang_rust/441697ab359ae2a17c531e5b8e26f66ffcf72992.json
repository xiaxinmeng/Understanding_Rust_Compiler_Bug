{"sha": "441697ab359ae2a17c531e5b8e26f66ffcf72992", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0MTY5N2FiMzU5YWUyYTE3YzUzMWU1YjhlMjZmNjZmZmNmNzI5OTI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-03-10T15:02:53Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-14T21:57:13Z"}, "message": "Extend stream functionality\n\nWriter and reader streams now come with methods to write and read\nlittle-endian numbers. Whether that is the right place for such\nmethods is debatable, but for now, that's where they live.", "tree": {"sha": "b094368c6bedb50bf52acb2e4fe775e47aef7741", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b094368c6bedb50bf52acb2e4fe775e47aef7741"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/441697ab359ae2a17c531e5b8e26f66ffcf72992", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/441697ab359ae2a17c531e5b8e26f66ffcf72992", "html_url": "https://github.com/rust-lang/rust/commit/441697ab359ae2a17c531e5b8e26f66ffcf72992", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/441697ab359ae2a17c531e5b8e26f66ffcf72992/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c731d625fe5f7626b41c7241893350b8b27b1dbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/c731d625fe5f7626b41c7241893350b8b27b1dbe", "html_url": "https://github.com/rust-lang/rust/commit/c731d625fe5f7626b41c7241893350b8b27b1dbe"}], "stats": {"total": 229, "additions": 140, "deletions": 89}, "files": [{"sha": "ed61b34019083cc98b5fad069eeae6a237d93486", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/441697ab359ae2a17c531e5b8e26f66ffcf72992/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441697ab359ae2a17c531e5b8e26f66ffcf72992/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=441697ab359ae2a17c531e5b8e26f66ffcf72992", "patch": "@@ -68,7 +68,7 @@ impure fn pretty_print_input(session.session sess,\n     auto def = tup(0, 0);\n     auto p = front.parser.new_parser(sess, env, def, input);\n     auto crate = front.parser.parse_crate_from_source_file(p);\n-    pretty.pprust.print_ast(crate.node.module, std.io.stdout_writer());\n+    pretty.pprust.print_ast(crate.node.module, std.io.stdout());\n }\n \n fn warn_wrong_compiler() {"}, {"sha": "95fd32c7b499234fcf796a4c69e59ba76a277e27", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/441697ab359ae2a17c531e5b8e26f66ffcf72992/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441697ab359ae2a17c531e5b8e26f66ffcf72992/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=441697ab359ae2a17c531e5b8e26f66ffcf72992", "patch": "@@ -1,4 +1,4 @@\n-import std.io.stdio_reader;\n+import std.io;\n import std._str;\n import std.map;\n import std.map.hashmap;\n@@ -18,9 +18,9 @@ state type reader = state obj {\n                           fn get_reserved() -> hashmap[str,()];\n };\n \n-fn new_reader(stdio_reader rdr, str filename) -> reader\n+impure fn new_reader(io.reader rdr, str filename) -> reader\n {\n-    state obj reader(stdio_reader rdr,\n+    state obj reader(io.reader rdr,\n                      str filename,\n                      mutable char c,\n                      mutable char n,\n@@ -72,7 +72,7 @@ fn new_reader(stdio_reader rdr, str filename) -> reader\n                     col += 1u;\n                 }\n \n-                n = rdr.getc() as char;\n+                n = rdr.read_char() as char;\n             }\n \n             fn mark() {\n@@ -200,8 +200,8 @@ fn new_reader(stdio_reader rdr, str filename) -> reader\n     reserved.insert(\"m128\", ()); // IEEE 754-2008 'decimal128'\n     reserved.insert(\"dec\", ());  // One of m32, m64, m128\n \n-    ret reader(rdr, filename, rdr.getc() as char, rdr.getc() as char,\n-               1u, 0u, 1u, 0u, keywords, reserved);\n+    ret reader(rdr, filename, rdr.read_char() as char,\n+               rdr.read_char() as char, 1u, 0u, 1u, 0u, keywords, reserved);\n }\n \n "}, {"sha": "832afe205d5057e5d279ebca2b43f5e9105f600d", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/441697ab359ae2a17c531e5b8e26f66ffcf72992/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441697ab359ae2a17c531e5b8e26f66ffcf72992/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=441697ab359ae2a17c531e5b8e26f66ffcf72992", "patch": "@@ -115,7 +115,7 @@ impure fn new_parser(session.session sess,\n     if (_str.ends_with(path, \".rc\")) {\n         ftype = CRATE_FILE;\n     }\n-    auto srdr = io.new_stdio_reader(path);\n+    auto srdr = io.file_reader(path);\n     auto rdr = lexer.new_reader(srdr, path);\n     auto npos = rdr.get_curr_pos();\n     ret stdio_parser(sess, env, ftype, lexer.next_token(rdr),"}, {"sha": "45bdb4a0d4a44c13062f5b4579de89fe57613a29", "filename": "src/lib/io.rs", "status": "modified", "additions": 123, "deletions": 81, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/441697ab359ae2a17c531e5b8e26f66ffcf72992/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441697ab359ae2a17c531e5b8e26f66ffcf72992/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=441697ab359ae2a17c531e5b8e26f66ffcf72992", "patch": "@@ -1,94 +1,114 @@\n import os.libc;\n \n-type stdio_reader = state obj {\n-                          fn getc() -> int;\n-                          fn ungetc(int i);\n-};\n-\n-fn new_stdio_reader(str path) -> stdio_reader {\n-    state obj stdio_FILE_reader(os.libc.FILE f) {\n-        fn getc() -> int {\n-            ret os.libc.fgetc(f);\n-        }\n-        fn ungetc(int i) {\n-            os.libc.ungetc(i, f);\n-        }\n-        drop {\n-            os.libc.fclose(f);\n-        }\n-    }\n-    auto FILE = os.libc.fopen(_str.buf(path), _str.buf(\"r\"));\n-    check (FILE as uint != 0u);\n-    ret stdio_FILE_reader(FILE);\n+native \"rust\" mod rustrt {\n+  fn rust_get_stdin() -> os.libc.FILE;\n+  fn rust_get_stdout() -> os.libc.FILE;\n }\n \n+// Reading\n \n-type buf_reader = state obj {\n-                        fn read() -> vec[u8];\n-};\n-\n-type buf_writer = state obj {\n-                        fn write(vec[u8] v);\n-};\n-\n-fn default_bufsz() -> uint {\n-    ret 4096u;\n-}\n-\n-fn new_buf() -> vec[u8] {\n-    ret _vec.alloc[u8](default_bufsz());\n-}\n-\n-fn new_buf_reader(str path) -> buf_reader {\n+// TODO This is all buffered. We might need an unbuffered variant as well\n \n-    state obj fd_buf_reader(int fd, mutable vec[u8] buf) {\n+tag seek_style {seek_set; seek_end; seek_cur;}\n \n-        fn read() -> vec[u8] {\n-\n-            // Ensure our buf is singly-referenced.\n-            if (_vec.rustrt.refcount[u8](buf) != 1u) {\n-                buf = new_buf();\n-            }\n-\n-            auto len = default_bufsz();\n-            auto vbuf = _vec.buf[u8](buf);\n-            auto count = os.libc.read(fd, vbuf, len);\n-\n-            if (count < 0) {\n-                log \"error filling buffer\";\n-                log sys.rustrt.last_os_error();\n-                fail;\n-            }\n+type reader =\n+    state obj {\n+          impure fn read_byte() -> u8;\n+          impure fn read_bytes(uint len) -> vec[u8];\n+          impure fn read_char() -> int;\n+          impure fn unread_char(int i);\n+          impure fn read_c_str() -> str;\n+          impure fn read_le_uint(uint size) -> uint;\n+          impure fn read_le_int(uint size) -> int;\n+\n+          impure fn seek(int offset, seek_style whence);\n+    };\n \n-            _vec.len_set[u8](buf, count as uint);\n-            ret buf;\n+state obj FILE_reader(os.libc.FILE f, bool must_close) {\n+    impure fn read_byte() -> u8 {\n+        ret os.libc.fgetc(f) as u8;\n+    }\n+    impure fn read_bytes(uint len) -> vec[u8] {\n+        auto buf = _vec.alloc[u8](len);\n+        auto read = os.libc.fread(_vec.buf[u8](buf), 1u, len, f);\n+        check(read == len);\n+        ret buf;\n+    }\n+    impure fn read_char() -> int {\n+        ret os.libc.fgetc(f);\n+    }\n+    impure fn unread_char(int ch) {\n+        os.libc.ungetc(ch, f);\n+    }\n+    impure fn read_c_str() -> str {\n+        auto buf = \"\";\n+        while (true) {\n+            auto ch = os.libc.fgetc(f);\n+            if (ch < 1) {break;}\n+            buf += _str.unsafe_from_bytes(vec(ch as u8));\n         }\n-\n-        drop {\n-            os.libc.close(fd);\n+        ret buf;\n+    }\n+    // TODO deal with eof?\n+    impure fn read_le_uint(uint size) -> uint {\n+        auto val = 0u;\n+        auto pos = 0u;\n+        while (size > 0u) {\n+            val += (os.libc.fgetc(f) as uint) << pos;\n+            pos += 8u;\n+            size -= 1u;\n+        }\n+        ret val;\n+    }\n+    impure fn read_le_int(uint size) -> int {\n+        auto val = 0u;\n+        auto pos = 0u;\n+        while (size > 0u) {\n+            val += (os.libc.fgetc(f) as uint) << pos;\n+            pos += 8u;\n+            size -= 1u;\n         }\n+        ret val as int; // TODO does that work?\n+    }\n+    impure fn seek(int offset, seek_style whence) {\n+        auto wh;\n+        alt (whence) {\n+            case (seek_set) {wh = 0;}\n+            case (seek_cur) {wh = 1;}\n+            case (seek_end) {wh = 2;}\n+        }\n+        check(os.libc.fseek(f, offset, wh) == 0);\n+    }\n+    drop {\n+        if (must_close) {os.libc.fclose(f);}\n     }\n+}\n \n-    auto fd = os.libc.open(_str.buf(path),\n-                           os.libc_constants.O_RDONLY() |\n-                           os.libc_constants.O_BINARY(),\n-                           0u);\n+fn stdin() -> reader {\n+    ret FILE_reader(rustrt.rust_get_stdin(), false);\n+}\n \n-    if (fd < 0) {\n-        log \"error opening file for reading\";\n-        log sys.rustrt.last_os_error();\n-        fail;\n-    }\n-    ret fd_buf_reader(fd, new_buf());\n+fn file_reader(str path) -> reader {\n+    auto f = os.libc.fopen(_str.buf(path), _str.buf(\"r\"));\n+    check (f as uint != 0u);\n+    ret FILE_reader(f, true);\n }\n \n+// Writing\n+\n+// TODO This is all unbuffered. We might need a buffered variant as well\n+\n tag fileflag {\n     append;\n     create;\n     truncate;\n     none;\n }\n \n+type buf_writer = state obj {\n+  fn write(vec[u8] v);\n+};\n+\n state obj fd_buf_writer(int fd, bool must_close) {\n     fn write(vec[u8] v) {\n         auto len = _vec.len[u8](v);\n@@ -143,8 +163,21 @@ type writer =\n           impure fn write_str(str s);\n           impure fn write_int(int n);\n           impure fn write_uint(uint n);\n+          impure fn write_bytes(vec[u8] bytes);\n+          impure fn write_le_uint(uint n, uint size);\n+          impure fn write_le_int(int n, uint size);\n     };\n \n+fn uint_to_le_bytes(uint n, uint size) -> vec[u8] {\n+    let vec[u8] bytes = vec();\n+    while (size > 0u) {\n+        bytes += vec((n & 255u) as u8);\n+        n >>= 8u;\n+        size -= 1u;\n+    }\n+    ret bytes;\n+}\n+\n state obj new_writer(buf_writer out) {\n     impure fn write_str(str s) {\n         out.write(_str.bytes(s));\n@@ -155,14 +188,23 @@ state obj new_writer(buf_writer out) {\n     impure fn write_uint(uint n) {\n         out.write(_str.bytes(_uint.to_str(n, 10u)));\n     }\n+    impure fn write_bytes(vec[u8] bytes) {\n+        out.write(bytes);\n+    }\n+    impure fn write_le_uint(uint n, uint size) {\n+        out.write(uint_to_le_bytes(n, size));\n+    }\n+    impure fn write_le_int(int n, uint size) {\n+        out.write(uint_to_le_bytes(n as uint, size));\n+    }\n }\n \n fn file_writer(str path, vec[fileflag] flags) -> writer {\n     ret new_writer(file_buf_writer(path, flags));\n }\n \n-// FIXME it would be great if this could be a const named stdout\n-fn stdout_writer() -> writer {\n+// FIXME it would be great if this could be a const\n+fn stdout() -> writer {\n     ret new_writer(fd_buf_writer(1, false));\n }\n \n@@ -172,21 +214,21 @@ type str_writer =\n           fn get_str() -> str;\n     };\n \n-type str_buf = @rec(mutable str buf);\n+type byte_buf = @rec(mutable vec[u8] buf);\n+\n+state obj byte_buf_writer(byte_buf buf) {\n+    fn write(vec[u8] v) {buf.buf += v;}\n+}\n \n // TODO awkward! it's not possible to implement a writer with an extra method\n fn string_writer() -> str_writer {\n-    auto buf = @rec(mutable buf = \"\");\n-    state obj str_writer_writer(str_buf buf) {\n-        impure fn write_str(str s)   { buf.buf += s; }\n-        impure fn write_int(int n)   { buf.buf += _int.to_str(n, 10u); }\n-        impure fn write_uint(uint n) { buf.buf += _uint.to_str(n, 10u); }\n-    }\n-    state obj str_writer_wrap(writer wr, str_buf buf) {\n+    let vec[u8] b = vec();\n+    let byte_buf buf = @rec(mutable buf = b);\n+    state obj str_writer_wrap(writer wr, byte_buf buf) {\n         fn get_writer() -> writer {ret wr;}\n-        fn get_str() -> str {ret buf.buf;}\n+        fn get_str() -> str {ret _str.unsafe_from_bytes(buf.buf);}\n     }\n-    ret str_writer_wrap(str_writer_writer(buf), buf);\n+    ret str_writer_wrap(new_writer(byte_buf_writer(buf)), buf);\n }\n \n //"}, {"sha": "bed8fdbc09d4016885f4d4e33785813fbca1630f", "filename": "src/lib/linux_os.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/441697ab359ae2a17c531e5b8e26f66ffcf72992/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441697ab359ae2a17c531e5b8e26f66ffcf72992/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=441697ab359ae2a17c531e5b8e26f66ffcf72992", "patch": "@@ -13,6 +13,8 @@ native mod libc = \"libc.so.6\" {\n     fn fclose(FILE f);\n     fn fgetc(FILE f) -> int;\n     fn ungetc(int c, FILE f);\n+    fn fread(vbuf buf, uint size, uint n, FILE f) -> uint;\n+    fn fseek(FILE f, int offset, int whence) -> int;\n \n     type dir;\n     fn opendir(sbuf d) -> dir;"}, {"sha": "bacf2d8ab04b12c682ceb1edc384786a04221439", "filename": "src/lib/macos_os.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/441697ab359ae2a17c531e5b8e26f66ffcf72992/src%2Flib%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441697ab359ae2a17c531e5b8e26f66ffcf72992/src%2Flib%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_os.rs?ref=441697ab359ae2a17c531e5b8e26f66ffcf72992", "patch": "@@ -12,6 +12,8 @@ native mod libc = \"libc.dylib\" {\n     fn fclose(FILE f);\n     fn fgetc(FILE f) -> int;\n     fn ungetc(int c, FILE f);\n+    fn fread(vbuf buf, uint size, uint n, FILE f) -> uint;\n+    fn fseek(FILE f, int offset, int whence) -> int;\n \n     type dir;\n     fn opendir(sbuf d) -> dir;"}, {"sha": "1c037c77cb373aef694e6df487f44dab9f26e00f", "filename": "src/lib/win32_os.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/441697ab359ae2a17c531e5b8e26f66ffcf72992/src%2Flib%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441697ab359ae2a17c531e5b8e26f66ffcf72992/src%2Flib%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_os.rs?ref=441697ab359ae2a17c531e5b8e26f66ffcf72992", "patch": "@@ -12,6 +12,8 @@ native mod libc = \"msvcrt.dll\" {\n     fn fclose(FILE f);\n     fn fgetc(FILE f) -> int;\n     fn ungetc(int c, FILE f);\n+    fn fread(vbuf buf, uint size, uint n, FILE f) -> uint;\n+    fn fseek(FILE f, int offset, int whence) -> int;\n }\n \n mod libc_constants {"}, {"sha": "4097621402132a735f87295195de1ac2350533d8", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/441697ab359ae2a17c531e5b8e26f66ffcf72992/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/441697ab359ae2a17c531e5b8e26f66ffcf72992/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=441697ab359ae2a17c531e5b8e26f66ffcf72992", "patch": "@@ -408,6 +408,9 @@ rust_file_is_dir(rust_task *task, rust_str *path) {\n     return S_ISDIR(buf.st_mode);\n }\n \n+extern \"C\" CDECL FILE* rust_get_stdin() {return stdin;}\n+extern \"C\" CDECL FILE* rust_get_stdout() {return stdout;}\n+\n //\n // Local Variables:\n // mode: C++"}]}