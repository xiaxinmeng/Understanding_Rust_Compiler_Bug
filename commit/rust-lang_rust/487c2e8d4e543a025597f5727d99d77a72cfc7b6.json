{"sha": "487c2e8d4e543a025597f5727d99d77a72cfc7b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4N2MyZThkNGU1NDNhMDI1NTk3ZjU3MjdkOTlkNzdhNzJjZmM3YjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-31T18:30:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-31T18:30:32Z"}, "message": "Auto merge of #6913 - camsteffen:method-chain, r=flip1995\n\nDestructure args in `methods`\n\nchangelog: none\n\nThis changes the main pattern in `methods` to match and destructure the method call args at the same time as the method name, and pass individual arg `Expr`s to the lint impls.\n\n```rust\n// before\n[\"expect\", ..] => expect::check(cx, expr, arg_lists[0]);\n// after\n(\"expect\", [arg]) => expect::check(cx, expr, recv, arg);\n```\n\nThis makes the code safer since there is no risk of out of bounds `args[n]` everywhere. There will be no more collecting `method_names`, `arg_lists`, `method_spans` as a separate step - everything comes out of the `match`es. Chained methods are parsed in a nested `match`. This makes the code more verbose in some ways, but IMO it is much easier to follow.\n\n~Definitely should wait for #6896. Just putting out the idea.~", "tree": {"sha": "5fca0ecdaf7382b1cdc39701d39e2eb6d620652c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fca0ecdaf7382b1cdc39701d39e2eb6d620652c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/487c2e8d4e543a025597f5727d99d77a72cfc7b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/487c2e8d4e543a025597f5727d99d77a72cfc7b6", "html_url": "https://github.com/rust-lang/rust/commit/487c2e8d4e543a025597f5727d99d77a72cfc7b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/487c2e8d4e543a025597f5727d99d77a72cfc7b6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "775ef473d7770f375c571004a8ca1ae42983937b", "url": "https://api.github.com/repos/rust-lang/rust/commits/775ef473d7770f375c571004a8ca1ae42983937b", "html_url": "https://github.com/rust-lang/rust/commit/775ef473d7770f375c571004a8ca1ae42983937b"}, {"sha": "21083875d211c29fcfa4a21fcd66d4601d2b618b", "url": "https://api.github.com/repos/rust-lang/rust/commits/21083875d211c29fcfa4a21fcd66d4601d2b618b", "html_url": "https://github.com/rust-lang/rust/commit/21083875d211c29fcfa4a21fcd66d4601d2b618b"}], "stats": {"total": 787, "additions": 412, "deletions": 375}, "files": [{"sha": "8ccb8f4268ce9d103f3a0b53787b898c95eb7080", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -80,7 +80,7 @@ pub(crate) trait BindInsteadOfMap {\n     fn lint_closure_autofixable(\n         cx: &LateContext<'_>,\n         expr: &hir::Expr<'_>,\n-        args: &[hir::Expr<'_>],\n+        recv: &hir::Expr<'_>,\n         closure_expr: &hir::Expr<'_>,\n         closure_args_span: Span,\n     ) -> bool {\n@@ -103,7 +103,7 @@ pub(crate) trait BindInsteadOfMap {\n                 };\n \n                 let closure_args_snip = snippet(cx, closure_args_span, \"..\");\n-                let option_snip = snippet(cx, args[0].span, \"..\");\n+                let option_snip = snippet(cx, recv.span, \"..\");\n                 let note = format!(\"{}.{}({} {})\", option_snip, Self::GOOD_METHOD_NAME, closure_args_snip, some_inner_snip);\n                 span_lint_and_sugg(\n                     cx,\n@@ -158,17 +158,17 @@ pub(crate) trait BindInsteadOfMap {\n     }\n \n     /// Lint use of `_.and_then(|x| Some(y))` for `Option`s\n-    fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) -> bool {\n-        if !match_type(cx, cx.typeck_results().expr_ty(&args[0]), Self::TYPE_QPATH) {\n+    fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, arg: &hir::Expr<'_>) -> bool {\n+        if !match_type(cx, cx.typeck_results().expr_ty(recv), Self::TYPE_QPATH) {\n             return false;\n         }\n \n-        match args[1].kind {\n+        match arg.kind {\n             hir::ExprKind::Closure(_, _, body_id, closure_args_span, _) => {\n                 let closure_body = cx.tcx.hir().body(body_id);\n                 let closure_expr = remove_blocks(&closure_body.value);\n \n-                if Self::lint_closure_autofixable(cx, expr, args, closure_expr, closure_args_span) {\n+                if Self::lint_closure_autofixable(cx, expr, recv, closure_expr, closure_args_span) {\n                     true\n                 } else {\n                     Self::lint_closure(cx, expr, closure_expr)\n@@ -182,7 +182,7 @@ pub(crate) trait BindInsteadOfMap {\n                     expr.span,\n                     Self::no_op_msg().as_ref(),\n                     \"use the expression directly\",\n-                    snippet(cx, args[0].span, \"..\").into(),\n+                    snippet(cx, recv.span, \"..\").into(),\n                     Applicability::MachineApplicable,\n                 );\n                 true"}, {"sha": "77f140510b619afa1c54c400856da3956ce0d112", "filename": "clippy_lints/src/methods/bytes_nth.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -3,16 +3,15 @@ use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind};\n+use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_span::sym;\n \n use super::BYTES_NTH;\n \n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, iter_args: &'tcx [Expr<'tcx>]) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, recv: &'tcx Expr<'tcx>, n_arg: &'tcx Expr<'tcx>) {\n     if_chain! {\n-        if let ExprKind::MethodCall(_, _, ref args, _) = expr.kind;\n-        let ty = cx.typeck_results().expr_ty(&iter_args[0]).peel_refs();\n+        let ty = cx.typeck_results().expr_ty(recv).peel_refs();\n         let caller_type = if is_type_diagnostic_item(cx, ty, sym::string_type) {\n             Some(\"String\")\n         } else if ty.is_str() {\n@@ -31,8 +30,8 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, iter_args: &'\n                 \"try\",\n                 format!(\n                     \"{}.as_bytes().get({})\",\n-                    snippet_with_applicability(cx, iter_args[0].span, \"..\", &mut applicability),\n-                    snippet_with_applicability(cx, args[1].span, \"..\", &mut applicability)\n+                    snippet_with_applicability(cx, recv.span, \"..\", &mut applicability),\n+                    snippet_with_applicability(cx, n_arg.span, \"..\", &mut applicability)\n                 ),\n                 applicability,\n             );"}, {"sha": "63a834fdce0cb8e525e771bbf07a48c9d9c4b776", "filename": "clippy_lints/src/methods/expect_used.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -7,8 +7,8 @@ use rustc_span::sym;\n use super::EXPECT_USED;\n \n /// lint use of `expect()` for `Option`s and `Result`s\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, expect_args: &[hir::Expr<'_>]) {\n-    let obj_ty = cx.typeck_results().expr_ty(&expect_args[0]).peel_refs();\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n+    let obj_ty = cx.typeck_results().expr_ty(recv).peel_refs();\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym::option_type) {\n         Some((EXPECT_USED, \"an Option\", \"None\"))"}, {"sha": "7b2967feb0fe988e18bfeb683616b39e09023dff", "filename": "clippy_lints/src/methods/filetype_is_file.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -8,8 +8,8 @@ use rustc_span::source_map::Span;\n \n use super::FILETYPE_IS_FILE;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n-    let ty = cx.typeck_results().expr_ty(&args[0]);\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n+    let ty = cx.typeck_results().expr_ty(recv);\n \n     if !match_type(cx, ty, &paths::FILE_TYPE) {\n         return;"}, {"sha": "45d1ed953b4e8e4f0c368571e6d979c9d5590aaa", "filename": "clippy_lints/src/methods/filter_map.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -46,21 +46,17 @@ fn is_method<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Sy\n     }\n }\n \n-fn is_option_filter_map<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    filter_arg: &'tcx hir::Expr<'_>,\n-    map_arg: &'tcx hir::Expr<'_>,\n-) -> bool {\n+fn is_option_filter_map<'tcx>(cx: &LateContext<'tcx>, filter_arg: &hir::Expr<'_>, map_arg: &hir::Expr<'_>) -> bool {\n     is_method(cx, map_arg, sym::unwrap) && is_method(cx, filter_arg, sym!(is_some))\n }\n \n /// lint use of `filter().map()` for `Iterators`\n-fn lint_filter_some_map_unwrap<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx hir::Expr<'_>,\n-    filter_recv: &'tcx hir::Expr<'_>,\n-    filter_arg: &'tcx hir::Expr<'_>,\n-    map_arg: &'tcx hir::Expr<'_>,\n+fn lint_filter_some_map_unwrap(\n+    cx: &LateContext<'_>,\n+    expr: &hir::Expr<'_>,\n+    filter_recv: &hir::Expr<'_>,\n+    filter_arg: &hir::Expr<'_>,\n+    map_arg: &hir::Expr<'_>,\n     target_span: Span,\n     methods_span: Span,\n ) {\n@@ -86,14 +82,28 @@ fn lint_filter_some_map_unwrap<'tcx>(\n }\n \n /// lint use of `filter().map()` or `find().map()` for `Iterators`\n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, is_find: bool, target_span: Span) {\n+#[allow(clippy::too_many_arguments)]\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &hir::Expr<'_>,\n+    filter_recv: &hir::Expr<'_>,\n+    filter_arg: &hir::Expr<'_>,\n+    filter_span: Span,\n+    map_recv: &hir::Expr<'_>,\n+    map_arg: &hir::Expr<'_>,\n+    map_span: Span,\n+    is_find: bool,\n+) {\n+    lint_filter_some_map_unwrap(\n+        cx,\n+        expr,\n+        filter_recv,\n+        filter_arg,\n+        map_arg,\n+        map_span,\n+        filter_span.with_hi(expr.span.hi()),\n+    );\n     if_chain! {\n-            if let ExprKind::MethodCall(_, _, [map_recv, map_arg], map_span) = expr.kind;\n-            if let ExprKind::MethodCall(_, _, [filter_recv, filter_arg], filter_span) = map_recv.kind;\n-            then {\n-              lint_filter_some_map_unwrap(cx, expr, filter_recv, filter_arg,\n-                map_arg, target_span, filter_span.to(map_span));\n-              if_chain! {\n             if is_trait_method(cx, map_recv, sym::Iterator);\n \n             // filter(|x| ...is_some())...\n@@ -148,7 +158,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, is_\n             };\n             if SpanlessEq::new(cx).expr_fallback(eq_fallback).eq_expr(filter_arg, map_arg);\n             then {\n-                let span = filter_span.to(map_span);\n+                let span = filter_span.with_hi(expr.span.hi());\n                 let (filter_name, lint) = if is_find {\n                     (\"find\", MANUAL_FIND_MAP)\n                 } else {\n@@ -160,7 +170,5 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, is_\n                     snippet(cx, map_arg.span, \"..\"), to_opt);\n                 span_lint_and_sugg(cx, lint, span, &msg, \"try\", sugg, Applicability::MachineApplicable);\n             }\n-        }\n-        }\n     }\n }"}, {"sha": "3a61f4ccad78930ccc5aca26b70de78a1727e1a1", "filename": "clippy_lints/src/methods/filter_map_identity.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_identity.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -8,15 +8,8 @@ use rustc_span::{source_map::Span, sym};\n \n use super::FILTER_MAP_IDENTITY;\n \n-pub(super) fn check(\n-    cx: &LateContext<'_>,\n-    expr: &hir::Expr<'_>,\n-    filter_map_args: &[hir::Expr<'_>],\n-    filter_map_span: Span,\n-) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, filter_map_arg: &hir::Expr<'_>, filter_map_span: Span) {\n     if is_trait_method(cx, expr, sym::Iterator) {\n-        let arg_node = &filter_map_args[1].kind;\n-\n         let apply_lint = |message: &str| {\n             span_lint_and_sugg(\n                 cx,\n@@ -30,8 +23,8 @@ pub(super) fn check(\n         };\n \n         if_chain! {\n-            if let hir::ExprKind::Closure(_, _, body_id, _, _) = arg_node;\n-            let body = cx.tcx.hir().body(*body_id);\n+            if let hir::ExprKind::Closure(_, _, body_id, _, _) = filter_map_arg.kind;\n+            let body = cx.tcx.hir().body(body_id);\n \n             if let hir::PatKind::Binding(_, binding_id, ..) = body.params[0].pat.kind;\n             if path_to_local_id(&body.value, binding_id);\n@@ -41,7 +34,7 @@ pub(super) fn check(\n         }\n \n         if_chain! {\n-            if let hir::ExprKind::Path(ref qpath) = arg_node;\n+            if let hir::ExprKind::Path(ref qpath) = filter_map_arg.kind;\n \n             if match_qpath(qpath, &paths::STD_CONVERT_IDENTITY);\n "}, {"sha": "2b19e4ee8c055b16c9b962465dbc43769ebbce98", "filename": "clippy_lints/src/methods/filter_map_next.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_next.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -14,7 +14,8 @@ const FILTER_MAP_NEXT_MSRV: RustcVersion = RustcVersion::new(1, 30, 0);\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n-    filter_args: &'tcx [hir::Expr<'_>],\n+    recv: &'tcx hir::Expr<'_>,\n+    arg: &'tcx hir::Expr<'_>,\n     msrv: Option<&RustcVersion>,\n ) {\n     if is_trait_method(cx, expr, sym::Iterator) {\n@@ -24,9 +25,9 @@ pub(super) fn check<'tcx>(\n \n         let msg = \"called `filter_map(..).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n                    `.find_map(..)` instead\";\n-        let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n+        let filter_snippet = snippet(cx, arg.span, \"..\");\n         if filter_snippet.lines().count() <= 1 {\n-            let iter_snippet = snippet(cx, filter_args[0].span, \"..\");\n+            let iter_snippet = snippet(cx, recv.span, \"..\");\n             span_lint_and_sugg(\n                 cx,\n                 FILTER_MAP_NEXT,"}, {"sha": "172714f6b01c61d97b31eac24d6a7d3bbc8f013b", "filename": "clippy_lints/src/methods/filter_next.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -9,14 +9,19 @@ use rustc_span::sym;\n use super::FILTER_NEXT;\n \n /// lint use of `filter().next()` for `Iterators`\n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, filter_args: &'tcx [hir::Expr<'_>]) {\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    recv: &'tcx hir::Expr<'_>,\n+    filter_arg: &'tcx hir::Expr<'_>,\n+) {\n     // lint if caller of `.filter().next()` is an Iterator\n     if is_trait_method(cx, expr, sym::Iterator) {\n         let msg = \"called `filter(..).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n                    `.find(..)` instead\";\n-        let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n+        let filter_snippet = snippet(cx, filter_arg.span, \"..\");\n         if filter_snippet.lines().count() <= 1 {\n-            let iter_snippet = snippet(cx, filter_args[0].span, \"..\");\n+            let iter_snippet = snippet(cx, recv.span, \"..\");\n             // add note if not multi-line\n             span_lint_and_sugg(\n                 cx,"}, {"sha": "664885a2f0e73cfe2af7bad95597966b3ad85833", "filename": "clippy_lints/src/methods/flat_map_identity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -12,11 +12,11 @@ use super::FLAT_MAP_IDENTITY;\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n-    flat_map_args: &'tcx [hir::Expr<'_>],\n+    flat_map_arg: &'tcx hir::Expr<'_>,\n     flat_map_span: Span,\n ) {\n     if is_trait_method(cx, expr, sym::Iterator) {\n-        let arg_node = &flat_map_args[1].kind;\n+        let arg_node = &flat_map_arg.kind;\n \n         let apply_lint = |message: &str| {\n             span_lint_and_sugg("}, {"sha": "54f280643841368df11c504b4c0aad291cb41321", "filename": "clippy_lints/src/methods/get_unwrap.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -11,18 +11,20 @@ use rustc_span::sym;\n \n use super::GET_UNWRAP;\n \n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, get_args: &'tcx [hir::Expr<'_>], is_mut: bool) {\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &hir::Expr<'_>,\n+    recv: &'tcx hir::Expr<'tcx>,\n+    get_arg: &'tcx hir::Expr<'_>,\n+    is_mut: bool,\n+) {\n     // Note: we don't want to lint `get_mut().unwrap` for `HashMap` or `BTreeMap`,\n     // because they do not implement `IndexMut`\n     let mut applicability = Applicability::MachineApplicable;\n-    let expr_ty = cx.typeck_results().expr_ty(&get_args[0]);\n-    let get_args_str = if get_args.len() > 1 {\n-        snippet_with_applicability(cx, get_args[1].span, \"..\", &mut applicability)\n-    } else {\n-        return; // not linting on a .get().unwrap() chain or variant\n-    };\n+    let expr_ty = cx.typeck_results().expr_ty(recv);\n+    let get_args_str = snippet_with_applicability(cx, get_arg.span, \"..\", &mut applicability);\n     let mut needs_ref;\n-    let caller_type = if derefs_to_slice(cx, &get_args[0], expr_ty).is_some() {\n+    let caller_type = if derefs_to_slice(cx, recv, expr_ty).is_some() {\n         needs_ref = get_args_str.parse::<usize>().is_ok();\n         \"slice\"\n     } else if is_type_diagnostic_item(cx, expr_ty, sym::vec_type) {\n@@ -77,7 +79,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, get_args\n         format!(\n             \"{}{}[{}]\",\n             borrow_str,\n-            snippet_with_applicability(cx, get_args[0].span, \"..\", &mut applicability),\n+            snippet_with_applicability(cx, recv.span, \"..\", &mut applicability),\n             get_args_str\n         ),\n         applicability,"}, {"sha": "739f313716e99db6a75378660ebfe52dbef71061", "filename": "clippy_lints/src/methods/iter_cloned_collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -9,10 +9,10 @@ use rustc_span::sym;\n \n use super::ITER_CLONED_COLLECT;\n \n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, iter_args: &'tcx [hir::Expr<'_>]) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, recv: &'tcx hir::Expr<'_>) {\n     if_chain! {\n         if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::vec_type);\n-        if let Some(slice) = derefs_to_slice(cx, &iter_args[0], cx.typeck_results().expr_ty(&iter_args[0]));\n+        if let Some(slice) = derefs_to_slice(cx, recv, cx.typeck_results().expr_ty(recv));\n         if let Some(to_replace) = expr.span.trim_start(slice.span.source_callsite());\n \n         then {"}, {"sha": "c6b7c7cd1795dc15398f62194c71fa6876f5188c", "filename": "clippy_lints/src/methods/iter_count.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fiter_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fiter_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_count.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -10,9 +10,9 @@ use rustc_span::sym;\n \n use super::ITER_COUNT;\n \n-pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, iter_args: &'tcx [Expr<'tcx>], iter_method: &str) {\n-    let ty = cx.typeck_results().expr_ty(&iter_args[0]);\n-    let caller_type = if derefs_to_slice(cx, &iter_args[0], ty).is_some() {\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, recv: &'tcx Expr<'tcx>, iter_method: &str) {\n+    let ty = cx.typeck_results().expr_ty(recv);\n+    let caller_type = if derefs_to_slice(cx, recv, ty).is_some() {\n         \"slice\"\n     } else if is_type_diagnostic_item(cx, ty, sym::vec_type) {\n         \"Vec\"\n@@ -42,7 +42,7 @@ pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, iter_args: &'\n         \"try\",\n         format!(\n             \"{}.len()\",\n-            snippet_with_applicability(cx, iter_args[0].span, \"..\", &mut applicability),\n+            snippet_with_applicability(cx, recv.span, \"..\", &mut applicability),\n         ),\n         applicability,\n     );"}, {"sha": "dab0a43a0968d419152da0307db4fa31d2f0eb04", "filename": "clippy_lints/src/methods/iter_next_slice.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -13,9 +13,7 @@ use rustc_span::symbol::sym;\n \n use super::ITER_NEXT_SLICE;\n \n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_args: &'tcx [hir::Expr<'_>]) {\n-    let caller_expr = &iter_args[0];\n-\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, caller_expr: &'tcx hir::Expr<'_>) {\n     // Skip lint if the `iter().next()` expression is a for loop argument,\n     // since it is already covered by `&loops::ITER_NEXT_LOOP`\n     let mut parent_expr_opt = get_parent_expr(cx, expr);"}, {"sha": "c2232239fe43f7ef20af03e9c2dbd9a05789989f", "filename": "clippy_lints/src/methods/iter_nth.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -11,20 +11,20 @@ use super::ITER_NTH;\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &hir::Expr<'_>,\n-    nth_and_iter_args: &[&'tcx [hir::Expr<'tcx>]],\n+    iter_recv: &'tcx hir::Expr<'tcx>,\n+    nth_recv: &hir::Expr<'_>,\n+    nth_arg: &hir::Expr<'_>,\n     is_mut: bool,\n ) {\n-    let iter_args = nth_and_iter_args[1];\n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n-    let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.typeck_results().expr_ty(&iter_args[0])).is_some() {\n+    let caller_type = if derefs_to_slice(cx, iter_recv, cx.typeck_results().expr_ty(iter_recv)).is_some() {\n         \"slice\"\n-    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym::vec_type) {\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(iter_recv), sym::vec_type) {\n         \"Vec\"\n-    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym::vecdeque_type) {\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(iter_recv), sym::vecdeque_type) {\n         \"VecDeque\"\n     } else {\n-        let nth_args = nth_and_iter_args[0];\n-        iter_nth_zero::check(cx, expr, &nth_args);\n+        iter_nth_zero::check(cx, expr, nth_recv, nth_arg);\n         return; // caller is not a type that we want to lint\n     };\n "}, {"sha": "52d7c15332e809c593b4d4e7cbebec2cd717390b", "filename": "clippy_lints/src/methods/iter_nth_zero.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -10,10 +10,10 @@ use rustc_span::sym;\n \n use super::ITER_NTH_ZERO;\n \n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, nth_args: &'tcx [hir::Expr<'_>]) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n     if_chain! {\n         if is_trait_method(cx, expr, sym::Iterator);\n-        if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), &nth_args[1]);\n+        if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), arg);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n@@ -22,7 +22,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, nth_args\n                 expr.span,\n                 \"called `.nth(0)` on a `std::iter::Iterator`, when `.next()` is equivalent\",\n                 \"try calling `.next()` instead of `.nth(0)`\",\n-                format!(\"{}.next()\", snippet_with_applicability(cx, nth_args[0].span, \"..\", &mut applicability)),\n+                format!(\"{}.next()\", snippet_with_applicability(cx, recv.span, \"..\", &mut applicability)),\n                 applicability,\n             );\n         }"}, {"sha": "e32594757d0caa929da4a608e335baad4b527d42", "filename": "clippy_lints/src/methods/iter_skip_next.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -8,19 +8,17 @@ use rustc_span::sym;\n \n use super::ITER_SKIP_NEXT;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, skip_args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n     // lint if caller of skip is an Iterator\n     if is_trait_method(cx, expr, sym::Iterator) {\n-        if let [caller, n] = skip_args {\n-            span_lint_and_sugg(\n-                cx,\n-                ITER_SKIP_NEXT,\n-                expr.span.trim_start(caller.span).unwrap(),\n-                \"called `skip(..).next()` on an iterator\",\n-                \"use `nth` instead\",\n-                format!(\".nth({})\", snippet(cx, n.span, \"..\")),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n+        span_lint_and_sugg(\n+            cx,\n+            ITER_SKIP_NEXT,\n+            expr.span.trim_start(recv.span).unwrap(),\n+            \"called `skip(..).next()` on an iterator\",\n+            \"use `nth` instead\",\n+            format!(\".nth({})\", snippet(cx, arg.span, \"..\")),\n+            Applicability::MachineApplicable,\n+        );\n     }\n }"}, {"sha": "06b12998b1aae958fe22a34e16189fd1711161de", "filename": "clippy_lints/src/methods/iterator_step_by_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -7,9 +7,9 @@ use rustc_span::sym;\n \n use super::ITERATOR_STEP_BY_ZERO;\n \n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, args: &'tcx [hir::Expr<'_>]) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, arg: &'tcx hir::Expr<'_>) {\n     if is_trait_method(cx, expr, sym::Iterator) {\n-        if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), &args[1]) {\n+        if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), arg) {\n             span_lint(\n                 cx,\n                 ITERATOR_STEP_BY_ZERO,"}, {"sha": "6c5a842a9128ebfed5f02130f69218506dedb8d2", "filename": "clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -8,11 +8,14 @@ use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_target::abi::LayoutOf;\n \n-pub fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[&[hir::Expr<'_>]], arith: &str) {\n-    let unwrap_arg = &args[0][1];\n-    let arith_lhs = &args[1][0];\n-    let arith_rhs = &args[1][1];\n-\n+pub fn check(\n+    cx: &LateContext<'_>,\n+    expr: &hir::Expr<'_>,\n+    arith_lhs: &hir::Expr<'_>,\n+    arith_rhs: &hir::Expr<'_>,\n+    unwrap_arg: &hir::Expr<'_>,\n+    arith: &str,\n+) {\n     let ty = cx.typeck_results().expr_ty(arith_lhs);\n     if !ty.is_integral() {\n         return;"}, {"sha": "82063ad70b5358f33e54a3fa30befee48619dbe8", "filename": "clippy_lints/src/methods/map_collect_result_unit.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fmap_collect_result_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fmap_collect_result_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_collect_result_unit.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -14,21 +14,20 @@ use super::MAP_COLLECT_RESULT_UNIT;\n pub(super) fn check(\n     cx: &LateContext<'_>,\n     expr: &hir::Expr<'_>,\n-    map_args: &[hir::Expr<'_>],\n-    collect_args: &[hir::Expr<'_>],\n+    iter: &hir::Expr<'_>,\n+    map_fn: &hir::Expr<'_>,\n+    collect_recv: &hir::Expr<'_>,\n ) {\n     if_chain! {\n         // called on Iterator\n-        if let [map_expr] = collect_args;\n-        if is_trait_method(cx, map_expr, sym::Iterator);\n+        if is_trait_method(cx, collect_recv, sym::Iterator);\n         // return of collect `Result<(),_>`\n         let collect_ret_ty = cx.typeck_results().expr_ty(expr);\n         if is_type_diagnostic_item(cx, collect_ret_ty, sym::result_type);\n         if let ty::Adt(_, substs) = collect_ret_ty.kind();\n         if let Some(result_t) = substs.types().next();\n         if result_t.is_unit();\n         // get parts for snippet\n-        if let [iter, map_fn] = map_args;\n         then {\n             span_lint_and_sugg(\n                 cx,"}, {"sha": "e8ad16bc0def91b6676b11792eaedfb218ee0f2e", "filename": "clippy_lints/src/methods/map_flatten.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -11,10 +11,15 @@ use rustc_span::symbol::sym;\n use super::MAP_FLATTEN;\n \n /// lint use of `map().flatten()` for `Iterators` and 'Options'\n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map_args: &'tcx [hir::Expr<'_>]) {\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    recv: &'tcx hir::Expr<'_>,\n+    map_arg: &'tcx hir::Expr<'_>,\n+) {\n     // lint if caller of `.map().flatten()` is an Iterator\n     if is_trait_method(cx, expr, sym::Iterator) {\n-        let map_closure_ty = cx.typeck_results().expr_ty(&map_args[1]);\n+        let map_closure_ty = cx.typeck_results().expr_ty(map_arg);\n         let is_map_to_option = match map_closure_ty.kind() {\n             ty::Closure(_, _) | ty::FnDef(_, _) | ty::FnPtr(_) => {\n                 let map_closure_sig = match map_closure_ty.kind() {\n@@ -34,12 +39,12 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n             // `(...).map(...)` has type `impl Iterator<Item=impl Iterator<...>>\n             \"flat_map\"\n         };\n-        let func_snippet = snippet(cx, map_args[1].span, \"..\");\n+        let func_snippet = snippet(cx, map_arg.span, \"..\");\n         let hint = format!(\".{0}({1})\", method_to_use, func_snippet);\n         span_lint_and_sugg(\n             cx,\n             MAP_FLATTEN,\n-            expr.span.with_lo(map_args[0].span.hi()),\n+            expr.span.with_lo(recv.span.hi()),\n             \"called `map(..).flatten()` on an `Iterator`\",\n             &format!(\"try using `{}` instead\", method_to_use),\n             hint,\n@@ -48,13 +53,13 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n     }\n \n     // lint if caller of `.map().flatten()` is an Option\n-    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type) {\n-        let func_snippet = snippet(cx, map_args[1].span, \"..\");\n+    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::option_type) {\n+        let func_snippet = snippet(cx, map_arg.span, \"..\");\n         let hint = format!(\".and_then({})\", func_snippet);\n         span_lint_and_sugg(\n             cx,\n             MAP_FLATTEN,\n-            expr.span.with_lo(map_args[0].span.hi()),\n+            expr.span.with_lo(recv.span.hi()),\n             \"called `map(..).flatten()` on an `Option`\",\n             \"try using `and_then` instead\",\n             hint,"}, {"sha": "4330fea727b3aad373ace7e667c9d61f568b9e10", "filename": "clippy_lints/src/methods/map_unwrap_or.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -18,22 +18,23 @@ const MAP_UNWRAP_OR_MSRV: RustcVersion = RustcVersion::new(1, 41, 0);\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n-    map_args: &'tcx [hir::Expr<'_>],\n-    unwrap_args: &'tcx [hir::Expr<'_>],\n+    recv: &'tcx hir::Expr<'_>,\n+    map_arg: &'tcx hir::Expr<'_>,\n+    unwrap_arg: &'tcx hir::Expr<'_>,\n     msrv: Option<&RustcVersion>,\n ) -> bool {\n     if !meets_msrv(msrv, &MAP_UNWRAP_OR_MSRV) {\n         return false;\n     }\n     // lint if the caller of `map()` is an `Option`\n-    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type);\n-    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::result_type);\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::option_type);\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::result_type);\n \n     if is_option || is_result {\n         // Don't make a suggestion that may fail to compile due to mutably borrowing\n         // the same variable twice.\n-        let map_mutated_vars = mutated_variables(&map_args[0], cx);\n-        let unwrap_mutated_vars = mutated_variables(&unwrap_args[1], cx);\n+        let map_mutated_vars = mutated_variables(recv, cx);\n+        let unwrap_mutated_vars = mutated_variables(unwrap_arg, cx);\n         if let (Some(map_mutated_vars), Some(unwrap_mutated_vars)) = (map_mutated_vars, unwrap_mutated_vars) {\n             if map_mutated_vars.intersection(&unwrap_mutated_vars).next().is_some() {\n                 return false;\n@@ -51,14 +52,14 @@ pub(super) fn check<'tcx>(\n             `.map_or_else(<g>, <f>)` instead\"\n         };\n         // get snippets for args to map() and unwrap_or_else()\n-        let map_snippet = snippet(cx, map_args[1].span, \"..\");\n-        let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n+        let map_snippet = snippet(cx, map_arg.span, \"..\");\n+        let unwrap_snippet = snippet(cx, unwrap_arg.span, \"..\");\n         // lint, with note if neither arg is > 1 line and both map() and\n         // unwrap_or_else() have the same span\n         let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n-        let same_span = map_args[1].span.ctxt() == unwrap_args[1].span.ctxt();\n+        let same_span = map_arg.span.ctxt() == unwrap_arg.span.ctxt();\n         if same_span && !multiline {\n-            let var_snippet = snippet(cx, map_args[0].span, \"..\");\n+            let var_snippet = snippet(cx, recv.span, \"..\");\n             span_lint_and_sugg(\n                 cx,\n                 MAP_UNWRAP_OR,"}, {"sha": "9a95354db7a7ae6ba2efff69a1f340924bbaaaba", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 158, "deletions": 125, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -62,17 +62,18 @@ mod zst_offset;\n use bind_instead_of_map::BindInsteadOfMap;\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::ty::{contains_adt_constructor, contains_ty, implements_trait, is_copy, is_type_diagnostic_item};\n-use clippy_utils::{contains_return, get_trait_def_id, in_macro, iter_input_pats, method_calls, paths, return_ty};\n+use clippy_utils::{contains_return, get_trait_def_id, in_macro, iter_input_pats, paths, return_ty};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n-use rustc_hir::{PrimTy, QPath, TraitItem, TraitItemKind};\n+use rustc_hir::{Expr, ExprKind, PrimTy, QPath, TraitItem, TraitItemKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, TraitRef, Ty, TyS};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::{sym, SymbolStr};\n+use rustc_span::symbol::SymbolStr;\n+use rustc_span::{sym, Span};\n use rustc_typeck::hir_ty_to_ty;\n \n declare_clippy_lint! {\n@@ -1704,134 +1705,32 @@ impl_lint_pass!(Methods => [\n     IMPLICIT_CLONE\n ]);\n \n+/// Extracts a method call name, args, and `Span` of the method name.\n+fn method_call<'tcx>(recv: &'tcx hir::Expr<'tcx>) -> Option<(SymbolStr, &'tcx [hir::Expr<'tcx>], Span)> {\n+    if let ExprKind::MethodCall(path, span, args, _) = recv.kind {\n+        if !args.iter().any(|e| e.span.from_expansion()) {\n+            return Some((path.ident.name.as_str(), args, span));\n+        }\n+    }\n+    None\n+}\n+\n+/// Same as `method_call` but the `SymbolStr` is dereferenced into a temporary `&str`\n+macro_rules! method_call {\n+    ($expr:expr) => {\n+        method_call($expr)\n+            .as_ref()\n+            .map(|&(ref name, args, span)| (&**name, args, span))\n+    };\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for Methods {\n-    #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if in_macro(expr.span) {\n             return;\n         }\n \n-        let (method_names, arg_lists, method_spans) = method_calls(expr, 2);\n-        let method_names: Vec<SymbolStr> = method_names.iter().map(|s| s.as_str()).collect();\n-        let method_names: Vec<&str> = method_names.iter().map(|s| &**s).collect();\n-\n-        match method_names.as_slice() {\n-            [\"unwrap\", \"get\"] => get_unwrap::check(cx, expr, arg_lists[1], false),\n-            [\"unwrap\", \"get_mut\"] => get_unwrap::check(cx, expr, arg_lists[1], true),\n-            [\"unwrap\", ..] => unwrap_used::check(cx, expr, arg_lists[0]),\n-            [\"expect\", \"ok\"] => ok_expect::check(cx, expr, arg_lists[1]),\n-            [\"expect\", ..] => expect_used::check(cx, expr, arg_lists[0]),\n-            [\"unwrap_or\", \"map\"] => option_map_unwrap_or::check(cx, expr, arg_lists[1], arg_lists[0], method_spans[1]),\n-            [\"unwrap_or_else\", \"map\"] => {\n-                if !map_unwrap_or::check(cx, expr, arg_lists[1], arg_lists[0], self.msrv.as_ref()) {\n-                    unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"unwrap_or\");\n-                }\n-            },\n-            [\"map_or\", ..] => option_map_or_none::check(cx, expr, arg_lists[0]),\n-            [\"and_then\", ..] => {\n-                let biom_option_linted = bind_instead_of_map::OptionAndThenSome::check(cx, expr, arg_lists[0]);\n-                let biom_result_linted = bind_instead_of_map::ResultAndThenOk::check(cx, expr, arg_lists[0]);\n-                if !biom_option_linted && !biom_result_linted {\n-                    unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"and\");\n-                }\n-            },\n-            [\"or_else\", ..] => {\n-                if !bind_instead_of_map::ResultOrElseErrInfo::check(cx, expr, arg_lists[0]) {\n-                    unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"or\");\n-                }\n-            },\n-            [\"next\", \"filter\"] => filter_next::check(cx, expr, arg_lists[1]),\n-            [\"next\", \"skip_while\"] => skip_while_next::check(cx, expr, arg_lists[1]),\n-            [\"next\", \"iter\"] => iter_next_slice::check(cx, expr, arg_lists[1]),\n-            [\"map\", \"filter\"] => filter_map::check(cx, expr, false, method_spans[0]),\n-            [\"map\", \"filter_map\"] => filter_map_map::check(cx, expr),\n-            [\"next\", \"filter_map\"] => filter_map_next::check(cx, expr, arg_lists[1], self.msrv.as_ref()),\n-            [\"map\", \"find\"] => filter_map::check(cx, expr, true, method_spans[0]),\n-            [\"flat_map\", \"filter\"] => filter_flat_map::check(cx, expr),\n-            [\"flat_map\", \"filter_map\"] => filter_map_flat_map::check(cx, expr),\n-            [\"flat_map\", ..] => flat_map_identity::check(cx, expr, arg_lists[0], method_spans[0]),\n-            [\"flatten\", \"map\"] => map_flatten::check(cx, expr, arg_lists[1]),\n-            [option_check_method, \"find\"] if \"is_some\" == *option_check_method || \"is_none\" == *option_check_method => {\n-                search_is_some::check(\n-                    cx,\n-                    expr,\n-                    \"find\",\n-                    option_check_method,\n-                    arg_lists[1],\n-                    arg_lists[0],\n-                    method_spans[1],\n-                )\n-            },\n-            [option_check_method, \"position\"]\n-                if \"is_some\" == *option_check_method || \"is_none\" == *option_check_method =>\n-            {\n-                search_is_some::check(\n-                    cx,\n-                    expr,\n-                    \"position\",\n-                    option_check_method,\n-                    arg_lists[1],\n-                    arg_lists[0],\n-                    method_spans[1],\n-                )\n-            },\n-            [option_check_method, \"rposition\"]\n-                if \"is_some\" == *option_check_method || \"is_none\" == *option_check_method =>\n-            {\n-                search_is_some::check(\n-                    cx,\n-                    expr,\n-                    \"rposition\",\n-                    option_check_method,\n-                    arg_lists[1],\n-                    arg_lists[0],\n-                    method_spans[1],\n-                )\n-            },\n-            [\"extend\", ..] => string_extend_chars::check(cx, expr, arg_lists[0]),\n-            [\"count\", \"into_iter\"] => iter_count::check(cx, expr, &arg_lists[1], \"into_iter\"),\n-            [\"count\", \"iter\"] => iter_count::check(cx, expr, &arg_lists[1], \"iter\"),\n-            [\"count\", \"iter_mut\"] => iter_count::check(cx, expr, &arg_lists[1], \"iter_mut\"),\n-            [\"nth\", \"iter\"] => iter_nth::check(cx, expr, &arg_lists, false),\n-            [\"nth\", \"iter_mut\"] => iter_nth::check(cx, expr, &arg_lists, true),\n-            [\"nth\", \"bytes\"] => bytes_nth::check(cx, expr, &arg_lists[1]),\n-            [\"nth\", ..] => iter_nth_zero::check(cx, expr, arg_lists[0]),\n-            [\"step_by\", ..] => iterator_step_by_zero::check(cx, expr, arg_lists[0]),\n-            [\"next\", \"skip\"] => iter_skip_next::check(cx, expr, arg_lists[1]),\n-            [\"collect\", \"cloned\"] => iter_cloned_collect::check(cx, expr, arg_lists[1]),\n-            [\"as_ref\"] => useless_asref::check(cx, expr, \"as_ref\", arg_lists[0]),\n-            [\"as_mut\"] => useless_asref::check(cx, expr, \"as_mut\", arg_lists[0]),\n-            [\"fold\", ..] => unnecessary_fold::check(cx, expr, arg_lists[0], method_spans[0]),\n-            [\"filter_map\", ..] => {\n-                unnecessary_filter_map::check(cx, expr, arg_lists[0]);\n-                filter_map_identity::check(cx, expr, arg_lists[0], method_spans[0]);\n-            },\n-            [\"count\", \"map\"] => suspicious_map::check(cx, expr, arg_lists[1], arg_lists[0]),\n-            [\"assume_init\"] => uninit_assumed_init::check(cx, &arg_lists[0][0], expr),\n-            [\"unwrap_or\", arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\")] => {\n-                manual_saturating_arithmetic::check(cx, expr, &arg_lists, &arith[\"checked_\".len()..])\n-            },\n-            [\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\"] => {\n-                zst_offset::check(cx, expr, arg_lists[0])\n-            },\n-            [\"is_file\", ..] => filetype_is_file::check(cx, expr, arg_lists[0]),\n-            [\"map\", \"as_ref\"] => {\n-                option_as_ref_deref::check(cx, expr, arg_lists[1], arg_lists[0], false, self.msrv.as_ref())\n-            },\n-            [\"map\", \"as_mut\"] => {\n-                option_as_ref_deref::check(cx, expr, arg_lists[1], arg_lists[0], true, self.msrv.as_ref())\n-            },\n-            [\"unwrap_or_else\", ..] => unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"unwrap_or\"),\n-            [\"get_or_insert_with\", ..] => unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"get_or_insert\"),\n-            [\"ok_or_else\", ..] => unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"ok_or\"),\n-            [\"collect\", \"map\"] => map_collect_result_unit::check(cx, expr, arg_lists[1], arg_lists[0]),\n-            [\"for_each\", \"inspect\"] => inspect_for_each::check(cx, expr, method_spans[1]),\n-            [\"to_owned\", ..] => implicit_clone::check(cx, expr, sym::ToOwned),\n-            [\"to_os_string\", ..] => implicit_clone::check(cx, expr, sym::OsStr),\n-            [\"to_path_buf\", ..] => implicit_clone::check(cx, expr, sym::Path),\n-            [\"to_vec\", ..] => implicit_clone::check(cx, expr, sym::slice),\n-            _ => {},\n-        }\n+        check_methods(cx, expr, self.msrv.as_ref());\n \n         match expr.kind {\n             hir::ExprKind::Call(ref func, ref args) => {\n@@ -2020,6 +1919,140 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n     extract_msrv_attr!(LateContext);\n }\n+\n+#[allow(clippy::too_many_lines)]\n+fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Option<&RustcVersion>) {\n+    if let Some((name, [recv, args @ ..], span)) = method_call!(expr) {\n+        match (name, args) {\n+            (\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\", [recv, _]) => {\n+                zst_offset::check(cx, expr, recv)\n+            },\n+            (\"and_then\", [arg]) => {\n+                let biom_option_linted = bind_instead_of_map::OptionAndThenSome::check(cx, expr, recv, arg);\n+                let biom_result_linted = bind_instead_of_map::ResultAndThenOk::check(cx, expr, recv, arg);\n+                if !biom_option_linted && !biom_result_linted {\n+                    unnecessary_lazy_eval::check(cx, expr, recv, arg, \"and\");\n+                }\n+            },\n+            (\"as_mut\", []) => useless_asref::check(cx, expr, \"as_mut\", recv),\n+            (\"as_ref\", []) => useless_asref::check(cx, expr, \"as_ref\", recv),\n+            (\"assume_init\", []) => uninit_assumed_init::check(cx, expr, recv),\n+            (\"collect\", []) => match method_call!(recv) {\n+                Some((\"cloned\", [recv2], _)) => iter_cloned_collect::check(cx, expr, recv2),\n+                Some((\"map\", [m_recv, m_arg], _)) => {\n+                    map_collect_result_unit::check(cx, expr, m_recv, m_arg, recv);\n+                },\n+                _ => {},\n+            },\n+            (\"count\", []) => match method_call!(recv) {\n+                Some((name @ (\"into_iter\" | \"iter\" | \"iter_mut\"), [recv2], _)) => {\n+                    iter_count::check(cx, expr, recv2, name);\n+                },\n+                Some((\"map\", [_, arg], _)) => suspicious_map::check(cx, expr, recv, arg),\n+                _ => {},\n+            },\n+            (\"expect\", [_]) => match method_call!(recv) {\n+                Some((\"ok\", [recv], _)) => ok_expect::check(cx, expr, recv),\n+                _ => expect_used::check(cx, expr, recv),\n+            },\n+            (\"extend\", [arg]) => string_extend_chars::check(cx, expr, recv, arg),\n+            (\"filter_map\", [arg]) => {\n+                unnecessary_filter_map::check(cx, expr, arg);\n+                filter_map_identity::check(cx, expr, arg, span);\n+            },\n+            (\"flat_map\", [flm_arg]) => match method_call!(recv) {\n+                Some((\"filter\", [_, _], _)) => filter_flat_map::check(cx, expr),\n+                Some((\"filter_map\", [_, _], _)) => filter_map_flat_map::check(cx, expr),\n+                _ => flat_map_identity::check(cx, expr, flm_arg, span),\n+            },\n+            (\"flatten\", []) => {\n+                if let Some((\"map\", [recv, map_arg], _)) = method_call!(recv) {\n+                    map_flatten::check(cx, expr, recv, map_arg);\n+                }\n+            },\n+            (\"fold\", [init, acc]) => unnecessary_fold::check(cx, expr, init, acc, span),\n+            (\"for_each\", [_]) => {\n+                if let Some((\"inspect\", [_, _], span2)) = method_call!(recv) {\n+                    inspect_for_each::check(cx, expr, span2);\n+                }\n+            },\n+            (\"get_or_insert_with\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"get_or_insert\"),\n+            (\"is_file\", []) => filetype_is_file::check(cx, expr, recv),\n+            (\"is_none\", []) => check_is_some_is_none(cx, expr, recv, false),\n+            (\"is_some\", []) => check_is_some_is_none(cx, expr, recv, true),\n+            (\"map\", [m_arg]) => {\n+                if let Some((name, [recv2, args @ ..], span2)) = method_call!(recv) {\n+                    match (name, args) {\n+                        (\"as_mut\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, true, msrv),\n+                        (\"as_ref\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, false, msrv),\n+                        (\"filter\", [f_arg]) => {\n+                            filter_map::check(cx, expr, recv2, f_arg, span2, recv, m_arg, span, false)\n+                        },\n+                        (\"filter_map\", [_]) => filter_map_map::check(cx, expr),\n+                        (\"find\", [f_arg]) => filter_map::check(cx, expr, recv2, f_arg, span2, recv, m_arg, span, true),\n+                        _ => {},\n+                    }\n+                }\n+            },\n+            (\"map_or\", [def, map]) => option_map_or_none::check(cx, expr, recv, def, map),\n+            (\"next\", []) => {\n+                if let Some((name, [recv, args @ ..], _)) = method_call!(recv) {\n+                    match (name, args) {\n+                        (\"filter\", [arg]) => filter_next::check(cx, expr, recv, arg),\n+                        (\"filter_map\", [arg]) => filter_map_next::check(cx, expr, recv, arg, msrv),\n+                        (\"iter\", []) => iter_next_slice::check(cx, expr, recv),\n+                        (\"skip\", [arg]) => iter_skip_next::check(cx, expr, recv, arg),\n+                        (\"skip_while\", [_]) => skip_while_next::check(cx, expr),\n+                        _ => {},\n+                    }\n+                }\n+            },\n+            (\"nth\", [n_arg]) => match method_call!(recv) {\n+                Some((\"bytes\", [recv2], _)) => bytes_nth::check(cx, expr, recv2, n_arg),\n+                Some((\"iter\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, false),\n+                Some((\"iter_mut\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, true),\n+                _ => iter_nth_zero::check(cx, expr, recv, n_arg),\n+            },\n+            (\"ok_or_else\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"ok_or\"),\n+            (\"or_else\", [arg]) => {\n+                if !bind_instead_of_map::ResultOrElseErrInfo::check(cx, expr, recv, arg) {\n+                    unnecessary_lazy_eval::check(cx, expr, recv, arg, \"or\");\n+                }\n+            },\n+            (\"step_by\", [arg]) => iterator_step_by_zero::check(cx, expr, arg),\n+            (\"to_os_string\", []) => implicit_clone::check(cx, expr, sym::OsStr),\n+            (\"to_owned\", []) => implicit_clone::check(cx, expr, sym::ToOwned),\n+            (\"to_path_buf\", []) => implicit_clone::check(cx, expr, sym::Path),\n+            (\"to_vec\", []) => implicit_clone::check(cx, expr, sym::slice),\n+            (\"unwrap\", []) => match method_call!(recv) {\n+                Some((\"get\", [recv, get_arg], _)) => get_unwrap::check(cx, expr, recv, get_arg, false),\n+                Some((\"get_mut\", [recv, get_arg], _)) => get_unwrap::check(cx, expr, recv, get_arg, true),\n+                _ => unwrap_used::check(cx, expr, recv),\n+            },\n+            (\"unwrap_or\", [u_arg]) => match method_call!(recv) {\n+                Some((arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\"), [lhs, rhs], _)) => {\n+                    manual_saturating_arithmetic::check(cx, expr, lhs, rhs, u_arg, &arith[\"checked_\".len()..]);\n+                },\n+                Some((\"map\", [m_recv, m_arg], span)) => {\n+                    option_map_unwrap_or::check(cx, expr, m_recv, m_arg, recv, u_arg, span)\n+                },\n+                _ => {},\n+            },\n+            (\"unwrap_or_else\", [u_arg]) => match method_call!(recv) {\n+                Some((\"map\", [recv, map_arg], _)) if map_unwrap_or::check(cx, expr, recv, map_arg, u_arg, msrv) => {},\n+                _ => unnecessary_lazy_eval::check(cx, expr, recv, u_arg, \"unwrap_or\"),\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+fn check_is_some_is_none(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, is_some: bool) {\n+    if let Some((name @ (\"find\" | \"position\" | \"rposition\"), [f_recv, arg], span)) = method_call!(recv) {\n+        search_is_some::check(cx, expr, name, is_some, f_recv, arg, recv, span)\n+    }\n+}\n+\n /// Used for `lint_binary_expr_with_method_call`.\n #[derive(Copy, Clone)]\n struct BinaryExprInfo<'a> {"}, {"sha": "d0b1b4b84be507f0bba45e2ab0f8a38467656d46", "filename": "clippy_lints/src/methods/ok_expect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fok_expect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fok_expect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fok_expect.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -9,11 +9,11 @@ use rustc_span::sym;\n use super::OK_EXPECT;\n \n /// lint use of `ok().expect()` for `Result`s\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ok_args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n     if_chain! {\n         // lint if the caller of `ok()` is a `Result`\n-        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&ok_args[0]), sym::result_type);\n-        let result_type = cx.typeck_results().expr_ty(&ok_args[0]);\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::result_type);\n+        let result_type = cx.typeck_results().expr_ty(recv);\n         if let Some(error_type) = get_error_type(cx, result_type);\n         if has_debug_impl(error_type, cx);\n "}, {"sha": "1367a0c21d8ebb79dcdaba40d0224ef477307303", "filename": "clippy_lints/src/methods/option_as_ref_deref.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -18,8 +18,8 @@ const OPTION_AS_REF_DEREF_MSRV: RustcVersion = RustcVersion::new(1, 40, 0);\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &hir::Expr<'_>,\n-    as_ref_args: &[hir::Expr<'_>],\n-    map_args: &[hir::Expr<'_>],\n+    as_ref_recv: &hir::Expr<'_>,\n+    map_arg: &hir::Expr<'_>,\n     is_mut: bool,\n     msrv: Option<&RustcVersion>,\n ) {\n@@ -29,7 +29,7 @@ pub(super) fn check<'tcx>(\n \n     let same_mutability = |m| (is_mut && m == &hir::Mutability::Mut) || (!is_mut && m == &hir::Mutability::Not);\n \n-    let option_ty = cx.typeck_results().expr_ty(&as_ref_args[0]);\n+    let option_ty = cx.typeck_results().expr_ty(as_ref_recv);\n     if !is_type_diagnostic_item(cx, option_ty, sym::option_type) {\n         return;\n     }\n@@ -46,9 +46,9 @@ pub(super) fn check<'tcx>(\n         &paths::VEC_AS_MUT_SLICE,\n     ];\n \n-    let is_deref = match map_args[1].kind {\n+    let is_deref = match map_arg.kind {\n         hir::ExprKind::Path(ref expr_qpath) => cx\n-            .qpath_res(expr_qpath, map_args[1].hir_id)\n+            .qpath_res(expr_qpath, map_arg.hir_id)\n             .opt_def_id()\n             .map_or(false, |fun_def_id| {\n                 deref_aliases.iter().any(|path| match_def_path(cx, fun_def_id, path))\n@@ -96,12 +96,12 @@ pub(super) fn check<'tcx>(\n \n     if is_deref {\n         let current_method = if is_mut {\n-            format!(\".as_mut().map({})\", snippet(cx, map_args[1].span, \"..\"))\n+            format!(\".as_mut().map({})\", snippet(cx, map_arg.span, \"..\"))\n         } else {\n-            format!(\".as_ref().map({})\", snippet(cx, map_args[1].span, \"..\"))\n+            format!(\".as_ref().map({})\", snippet(cx, map_arg.span, \"..\"))\n         };\n         let method_hint = if is_mut { \"as_deref_mut\" } else { \"as_deref\" };\n-        let hint = format!(\"{}.{}()\", snippet(cx, as_ref_args[0].span, \"..\"), method_hint);\n+        let hint = format!(\"{}.{}()\", snippet(cx, as_ref_recv.span, \"..\"), method_hint);\n         let suggestion = format!(\"try using {} instead\", method_hint);\n \n         let msg = format!("}, {"sha": "013a6f90ac97b06bdfd443938f50e64ec7c22649", "filename": "clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -11,9 +11,15 @@ use super::OPTION_MAP_OR_NONE;\n use super::RESULT_MAP_OR_INTO_OPTION;\n \n /// lint use of `_.map_or(None, _)` for `Option`s and `Result`s\n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map_or_args: &'tcx [hir::Expr<'_>]) {\n-    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_or_args[0]), sym::option_type);\n-    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_or_args[0]), sym::result_type);\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    recv: &'tcx hir::Expr<'_>,\n+    def_arg: &'tcx hir::Expr<'_>,\n+    map_arg: &'tcx hir::Expr<'_>,\n+) {\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::option_type);\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::result_type);\n \n     // There are two variants of this `map_or` lint:\n     // (1) using `map_or` as an adapter from `Result<T,E>` to `Option<T>`\n@@ -25,7 +31,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n     }\n \n     let (lint_name, msg, instead, hint) = {\n-        let default_arg_is_none = if let hir::ExprKind::Path(ref qpath) = map_or_args[1].kind {\n+        let default_arg_is_none = if let hir::ExprKind::Path(ref qpath) = def_arg.kind {\n             match_qpath(qpath, &paths::OPTION_NONE)\n         } else {\n             return;\n@@ -36,15 +42,15 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n             return;\n         }\n \n-        let f_arg_is_some = if let hir::ExprKind::Path(ref qpath) = map_or_args[2].kind {\n+        let f_arg_is_some = if let hir::ExprKind::Path(ref qpath) = map_arg.kind {\n             match_qpath(qpath, &paths::OPTION_SOME)\n         } else {\n             false\n         };\n \n         if is_option {\n-            let self_snippet = snippet(cx, map_or_args[0].span, \"..\");\n-            let func_snippet = snippet(cx, map_or_args[2].span, \"..\");\n+            let self_snippet = snippet(cx, recv.span, \"..\");\n+            let func_snippet = snippet(cx, map_arg.span, \"..\");\n             let msg = \"called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling \\\n                        `and_then(..)` instead\";\n             (\n@@ -56,7 +62,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n         } else if f_arg_is_some {\n             let msg = \"called `map_or(None, Some)` on a `Result` value. This can be done more directly by calling \\\n                        `ok()` instead\";\n-            let self_snippet = snippet(cx, map_or_args[0].span, \"..\");\n+            let self_snippet = snippet(cx, recv.span, \"..\");\n             (\n                 RESULT_MAP_OR_INTO_OPTION,\n                 msg,"}, {"sha": "5bca49dec241408e5587e52db2ead38d67d67705", "filename": "clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -18,41 +18,43 @@ use super::MAP_UNWRAP_OR;\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &rustc_hir::Expr<'_>,\n-    map_args: &'tcx [rustc_hir::Expr<'_>],\n-    unwrap_args: &'tcx [rustc_hir::Expr<'_>],\n+    recv: &rustc_hir::Expr<'_>,\n+    map_arg: &'tcx rustc_hir::Expr<'_>,\n+    unwrap_recv: &rustc_hir::Expr<'_>,\n+    unwrap_arg: &'tcx rustc_hir::Expr<'_>,\n     map_span: Span,\n ) {\n     // lint if the caller of `map()` is an `Option`\n-    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type) {\n-        if !is_copy(cx, cx.typeck_results().expr_ty(&unwrap_args[1])) {\n+    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::option_type) {\n+        if !is_copy(cx, cx.typeck_results().expr_ty(unwrap_arg)) {\n             // Do not lint if the `map` argument uses identifiers in the `map`\n             // argument that are also used in the `unwrap_or` argument\n \n             let mut unwrap_visitor = UnwrapVisitor {\n                 cx,\n                 identifiers: FxHashSet::default(),\n             };\n-            unwrap_visitor.visit_expr(&unwrap_args[1]);\n+            unwrap_visitor.visit_expr(unwrap_arg);\n \n             let mut map_expr_visitor = MapExprVisitor {\n                 cx,\n                 identifiers: unwrap_visitor.identifiers,\n                 found_identifier: false,\n             };\n-            map_expr_visitor.visit_expr(&map_args[1]);\n+            map_expr_visitor.visit_expr(map_arg);\n \n             if map_expr_visitor.found_identifier {\n                 return;\n             }\n         }\n \n-        if differing_macro_contexts(unwrap_args[1].span, map_span) {\n+        if differing_macro_contexts(unwrap_arg.span, map_span) {\n             return;\n         }\n \n         let mut applicability = Applicability::MachineApplicable;\n         // get snippet for unwrap_or()\n-        let unwrap_snippet = snippet_with_applicability(cx, unwrap_args[1].span, \"..\", &mut applicability);\n+        let unwrap_snippet = snippet_with_applicability(cx, unwrap_arg.span, \"..\", &mut applicability);\n         // lint message\n         // comparing the snippet from source to raw text (\"None\") below is safe\n         // because we already have checked the type.\n@@ -70,14 +72,14 @@ pub(super) fn check<'tcx>(\n         );\n \n         span_lint_and_then(cx, MAP_UNWRAP_OR, expr.span, msg, |diag| {\n-            let map_arg_span = map_args[1].span;\n+            let map_arg_span = map_arg.span;\n \n             let mut suggestion = vec![\n                 (\n                     map_span,\n                     String::from(if unwrap_snippet_none { \"and_then\" } else { \"map_or\" }),\n                 ),\n-                (expr.span.with_lo(unwrap_args[0].span.hi()), String::from(\"\")),\n+                (expr.span.with_lo(unwrap_recv.span.hi()), String::from(\"\")),\n             ];\n \n             if !unwrap_snippet_none {"}, {"sha": "8a94d7f415583b978774c09372d0593a1d9ccba7", "filename": "clippy_lints/src/methods/search_is_some.rs", "status": "modified", "additions": 43, "deletions": 45, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -15,29 +15,31 @@ use super::SEARCH_IS_SOME;\n \n /// lint searching an Iterator followed by `is_some()`\n /// or calling `find()` on a string followed by `is_some()` or `is_none()`\n-#[allow(clippy::too_many_lines)]\n+#[allow(clippy::too_many_arguments, clippy::too_many_lines)]\n pub(super) fn check<'tcx>(\n-    cx: &LateContext<'tcx>,\n+    cx: &LateContext<'_>,\n     expr: &'tcx hir::Expr<'_>,\n     search_method: &str,\n-    option_check_method: &str,\n-    search_args: &'tcx [hir::Expr<'_>],\n-    is_some_args: &'tcx [hir::Expr<'_>],\n+    is_some: bool,\n+    search_recv: &hir::Expr<'_>,\n+    search_arg: &'tcx hir::Expr<'_>,\n+    is_some_recv: &hir::Expr<'_>,\n     method_span: Span,\n ) {\n+    let option_check_method = if is_some { \"is_some\" } else { \"is_none\" };\n     // lint if caller of search is an Iterator\n-    if is_trait_method(cx, &is_some_args[0], sym::Iterator) {\n+    if is_trait_method(cx, is_some_recv, sym::Iterator) {\n         let msg = format!(\n             \"called `{}()` after searching an `Iterator` with `{}`\",\n             option_check_method, search_method\n         );\n-        let search_snippet = snippet(cx, search_args[1].span, \"..\");\n+        let search_snippet = snippet(cx, search_arg.span, \"..\");\n         if search_snippet.lines().count() <= 1 {\n             // suggest `any(|x| ..)` instead of `any(|&x| ..)` for `find(|&x| ..).is_some()`\n             // suggest `any(|..| *..)` instead of `any(|..| **..)` for `find(|..| **..).is_some()`\n             let any_search_snippet = if_chain! {\n                 if search_method == \"find\";\n-                if let hir::ExprKind::Closure(_, _, body_id, ..) = search_args[1].kind;\n+                if let hir::ExprKind::Closure(_, _, body_id, ..) = search_arg.kind;\n                 let closure_body = cx.tcx.hir().body(body_id);\n                 if let Some(closure_arg) = closure_body.params.get(0);\n                 then {\n@@ -54,38 +56,34 @@ pub(super) fn check<'tcx>(\n                 }\n             };\n             // add note if not multi-line\n-            match option_check_method {\n-                \"is_some\" => {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        SEARCH_IS_SOME,\n-                        method_span.with_hi(expr.span.hi()),\n-                        &msg,\n-                        \"use `any()` instead\",\n-                        format!(\n-                            \"any({})\",\n-                            any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n-                        ),\n-                        Applicability::MachineApplicable,\n-                    );\n-                },\n-                \"is_none\" => {\n-                    let iter = snippet(cx, search_args[0].span, \"..\");\n-                    span_lint_and_sugg(\n-                        cx,\n-                        SEARCH_IS_SOME,\n-                        expr.span,\n-                        &msg,\n-                        \"use `!_.any()` instead\",\n-                        format!(\n-                            \"!{}.any({})\",\n-                            iter,\n-                            any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n-                        ),\n-                        Applicability::MachineApplicable,\n-                    );\n-                },\n-                _ => (),\n+            if is_some {\n+                span_lint_and_sugg(\n+                    cx,\n+                    SEARCH_IS_SOME,\n+                    method_span.with_hi(expr.span.hi()),\n+                    &msg,\n+                    \"use `any()` instead\",\n+                    format!(\n+                        \"any({})\",\n+                        any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n+                    ),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                let iter = snippet(cx, search_recv.span, \"..\");\n+                span_lint_and_sugg(\n+                    cx,\n+                    SEARCH_IS_SOME,\n+                    expr.span,\n+                    &msg,\n+                    \"use `!_.any()` instead\",\n+                    format!(\n+                        \"!{}.any({})\",\n+                        iter,\n+                        any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n+                    ),\n+                    Applicability::MachineApplicable,\n+                );\n             }\n         } else {\n             let hint = format!(\n@@ -110,14 +108,14 @@ pub(super) fn check<'tcx>(\n             }\n         };\n         if_chain! {\n-            if is_string_or_str_slice(&search_args[0]);\n-            if is_string_or_str_slice(&search_args[1]);\n+            if is_string_or_str_slice(&search_recv);\n+            if is_string_or_str_slice(&search_arg);\n             then {\n                 let msg = format!(\"called `{}()` after calling `find()` on a string\", option_check_method);\n                 match option_check_method {\n                     \"is_some\" => {\n                         let mut applicability = Applicability::MachineApplicable;\n-                        let find_arg = snippet_with_applicability(cx, search_args[1].span, \"..\", &mut applicability);\n+                        let find_arg = snippet_with_applicability(cx, search_arg.span, \"..\", &mut applicability);\n                         span_lint_and_sugg(\n                             cx,\n                             SEARCH_IS_SOME,\n@@ -129,9 +127,9 @@ pub(super) fn check<'tcx>(\n                         );\n                     },\n                     \"is_none\" => {\n-                        let string = snippet(cx, search_args[0].span, \"..\");\n+                        let string = snippet(cx, search_recv.span, \"..\");\n                         let mut applicability = Applicability::MachineApplicable;\n-                        let find_arg = snippet_with_applicability(cx, search_args[1].span, \"..\", &mut applicability);\n+                        let find_arg = snippet_with_applicability(cx, search_arg.span, \"..\", &mut applicability);\n                         span_lint_and_sugg(\n                             cx,\n                             SEARCH_IS_SOME,"}, {"sha": "9f0b6c34ea2efb715d1c1362cf4a503d193534d3", "filename": "clippy_lints/src/methods/skip_while_next.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fskip_while_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fskip_while_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fskip_while_next.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -7,7 +7,7 @@ use rustc_span::sym;\n use super::SKIP_WHILE_NEXT;\n \n /// lint use of `skip_while().next()` for `Iterators`\n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, _skip_while_args: &'tcx [hir::Expr<'_>]) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n     // lint if caller of `.skip_while().next()` is an Iterator\n     if is_trait_method(cx, expr, sym::Iterator) {\n         span_lint_and_help("}, {"sha": "6e7890a3080e60a0b99838e13c83a1fe70af04dc", "filename": "clippy_lints/src/methods/string_extend_chars.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -10,12 +10,11 @@ use rustc_span::symbol::sym;\n \n use super::STRING_EXTEND_CHARS;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n-    let obj_ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n+    let obj_ty = cx.typeck_results().expr_ty(recv).peel_refs();\n     if !is_type_diagnostic_item(cx, obj_ty, sym::string_type) {\n         return;\n     }\n-    let arg = &args[1];\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n         let target = &arglists[0][0];\n         let self_ty = cx.typeck_results().expr_ty(target).peel_refs();\n@@ -36,7 +35,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Exp\n             \"try this\",\n             format!(\n                 \"{}.push_str({}{})\",\n-                snippet_with_applicability(cx, args[0].span, \"..\", &mut applicability),\n+                snippet_with_applicability(cx, recv.span, \"..\", &mut applicability),\n                 ref_str,\n                 snippet_with_applicability(cx, target.span, \"..\", &mut applicability)\n             ),"}, {"sha": "0fd0668c734022b4e4834781c1bdba1128a3b78e", "filename": "clippy_lints/src/methods/suspicious_map.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -8,15 +8,8 @@ use rustc_span::sym;\n \n use super::SUSPICIOUS_MAP;\n \n-pub fn check<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &hir::Expr<'_>,\n-    map_args: &[hir::Expr<'_>],\n-    count_args: &[hir::Expr<'_>],\n-) {\n+pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, count_recv: &hir::Expr<'_>, map_arg: &hir::Expr<'_>) {\n     if_chain! {\n-        if let [count_recv] = count_args;\n-        if let [_, map_arg] = map_args;\n         if is_trait_method(cx, count_recv, sym::Iterator);\n         let closure = expr_or_init(cx, map_arg);\n         if let Some(body_id) = cx.tcx.hir().maybe_body_owned_by(closure.hir_id);"}, {"sha": "3cc1912b15aefb794ba0b3da8531b1b4d44e193f", "filename": "clippy_lints/src/methods/uninit_assumed_init.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -8,18 +8,18 @@ use rustc_middle::ty::{self, Ty};\n use super::UNINIT_ASSUMED_INIT;\n \n /// lint for `MaybeUninit::uninit().assume_init()` (we already have the latter)\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, outer: &hir::Expr<'_>) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n     if_chain! {\n-        if let hir::ExprKind::Call(ref callee, ref args) = expr.kind;\n+        if let hir::ExprKind::Call(ref callee, ref args) = recv.kind;\n         if args.is_empty();\n         if let hir::ExprKind::Path(ref path) = callee.kind;\n         if match_qpath(path, &paths::MEM_MAYBEUNINIT_UNINIT);\n-        if !is_maybe_uninit_ty_valid(cx, cx.typeck_results().expr_ty_adjusted(outer));\n+        if !is_maybe_uninit_ty_valid(cx, cx.typeck_results().expr_ty_adjusted(expr));\n         then {\n             span_lint(\n                 cx,\n                 UNINIT_ASSUMED_INIT,\n-                outer.span,\n+                expr.span,\n                 \"this call for this type may be undefined behavior\"\n             );\n         }"}, {"sha": "dac7e039e37f1898c0c2e7fe3adbd20f506af488", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -10,12 +10,12 @@ use rustc_span::sym;\n \n use super::UNNECESSARY_FILTER_MAP;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n     if !is_trait_method(cx, expr, sym::Iterator) {\n         return;\n     }\n \n-    if let hir::ExprKind::Closure(_, _, body_id, ..) = args[1].kind {\n+    if let hir::ExprKind::Closure(_, _, body_id, ..) = arg.kind {\n         let body = cx.tcx.hir().body(body_id);\n         let arg_id = body.params[0].pat.hir_id;\n         let mutates_arg ="}, {"sha": "7c16470348fde6c6f4064d7642988680b6ccd075", "filename": "clippy_lints/src/methods/unnecessary_fold.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -11,19 +11,25 @@ use rustc_span::{source_map::Span, sym};\n \n use super::UNNECESSARY_FOLD;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, fold_args: &[hir::Expr<'_>], fold_span: Span) {\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &hir::Expr<'_>,\n+    init: &hir::Expr<'_>,\n+    acc: &hir::Expr<'_>,\n+    fold_span: Span,\n+) {\n     fn check_fold_with_op(\n         cx: &LateContext<'_>,\n         expr: &hir::Expr<'_>,\n-        fold_args: &[hir::Expr<'_>],\n+        acc: &hir::Expr<'_>,\n         fold_span: Span,\n         op: hir::BinOpKind,\n         replacement_method_name: &str,\n         replacement_has_args: bool,\n     ) {\n         if_chain! {\n             // Extract the body of the closure passed to fold\n-            if let hir::ExprKind::Closure(_, _, body_id, _, _) = fold_args[2].kind;\n+            if let hir::ExprKind::Closure(_, _, body_id, _, _) = acc.kind;\n             let closure_body = cx.tcx.hir().body(body_id);\n             let closure_expr = remove_blocks(&closure_body.value);\n \n@@ -74,25 +80,14 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, fold_args: &[hir\n         return;\n     }\n \n-    assert!(\n-        fold_args.len() == 3,\n-        \"Expected fold_args to have three entries - the receiver, the initial value and the closure\"\n-    );\n-\n     // Check if the first argument to .fold is a suitable literal\n-    if let hir::ExprKind::Lit(ref lit) = fold_args[1].kind {\n+    if let hir::ExprKind::Lit(ref lit) = init.kind {\n         match lit.node {\n-            ast::LitKind::Bool(false) => {\n-                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::Or, \"any\", true)\n-            },\n-            ast::LitKind::Bool(true) => {\n-                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::And, \"all\", true)\n-            },\n-            ast::LitKind::Int(0, _) => {\n-                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::Add, \"sum\", false)\n-            },\n+            ast::LitKind::Bool(false) => check_fold_with_op(cx, expr, acc, fold_span, hir::BinOpKind::Or, \"any\", true),\n+            ast::LitKind::Bool(true) => check_fold_with_op(cx, expr, acc, fold_span, hir::BinOpKind::And, \"all\", true),\n+            ast::LitKind::Int(0, _) => check_fold_with_op(cx, expr, acc, fold_span, hir::BinOpKind::Add, \"sum\", false),\n             ast::LitKind::Int(1, _) => {\n-                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::Mul, \"product\", false)\n+                check_fold_with_op(cx, expr, acc, fold_span, hir::BinOpKind::Mul, \"product\", false)\n             },\n             _ => (),\n         }"}, {"sha": "b7380883a5eecad1574296e8d1b222d590a866fa", "filename": "clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -14,14 +14,15 @@ use super::UNNECESSARY_LAZY_EVALUATIONS;\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n-    args: &'tcx [hir::Expr<'_>],\n+    recv: &'tcx hir::Expr<'_>,\n+    arg: &'tcx hir::Expr<'_>,\n     simplify_using: &str,\n ) {\n-    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym::option_type);\n-    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym::result_type);\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::option_type);\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::result_type);\n \n     if is_option || is_result {\n-        if let hir::ExprKind::Closure(_, _, eid, _, _) = args[1].kind {\n+        if let hir::ExprKind::Closure(_, _, eid, _, _) = arg.kind {\n             let body = cx.tcx.hir().body(eid);\n             let body_expr = &body.value;\n \n@@ -55,7 +56,7 @@ pub(super) fn check<'tcx>(\n                     &format!(\"use `{}` instead\", simplify_using),\n                     format!(\n                         \"{0}.{1}({2})\",\n-                        snippet(cx, args[0].span, \"..\"),\n+                        snippet(cx, recv.span, \"..\"),\n                         simplify_using,\n                         snippet(cx, body_expr.span, \"..\"),\n                     ),"}, {"sha": "7fd1948594d707904de39347a38671d6ecb0b2e9", "filename": "clippy_lints/src/methods/unwrap_used.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -7,8 +7,8 @@ use rustc_span::sym;\n use super::UNWRAP_USED;\n \n /// lint use of `unwrap()` for `Option`s and `Result`s\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::Expr<'_>]) {\n-    let obj_ty = cx.typeck_results().expr_ty(&unwrap_args[0]).peel_refs();\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n+    let obj_ty = cx.typeck_results().expr_ty(recv).peel_refs();\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym::option_type) {\n         Some((UNWRAP_USED, \"an Option\", \"None\"))"}, {"sha": "e0b1de68b37d359b85c8e7d41eed620338b0c54f", "filename": "clippy_lints/src/methods/useless_asref.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -10,12 +10,11 @@ use rustc_lint::LateContext;\n use super::USELESS_ASREF;\n \n /// Checks for the `USELESS_ASREF` lint.\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, as_ref_args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, recvr: &hir::Expr<'_>) {\n     // when we get here, we've already checked that the call name is \"as_ref\" or \"as_mut\"\n     // check if the call is to the actual `AsRef` or `AsMut` trait\n     if match_trait_method(cx, expr, &paths::ASREF_TRAIT) || match_trait_method(cx, expr, &paths::ASMUT_TRAIT) {\n         // check if the type after `as_ref` or `as_mut` is the same as before\n-        let recvr = &as_ref_args[0];\n         let rcv_ty = cx.typeck_results().expr_ty(recvr);\n         let res_ty = cx.typeck_results().expr_ty(expr);\n         let (base_res_ty, res_depth) = walk_ptrs_ty_depth(res_ty);"}, {"sha": "0489d0f6fcfcede21405a95e766859e4f39a95ad", "filename": "clippy_lints/src/methods/zst_offset.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487c2e8d4e543a025597f5727d99d77a72cfc7b6/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs?ref=487c2e8d4e543a025597f5727d99d77a72cfc7b6", "patch": "@@ -6,10 +6,9 @@ use rustc_middle::ty;\n \n use super::ZST_OFFSET;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n     if_chain! {\n-        if args.len() == 2;\n-        if let ty::RawPtr(ty::TypeAndMut { ref ty, .. }) = cx.typeck_results().expr_ty(&args[0]).kind();\n+        if let ty::RawPtr(ty::TypeAndMut { ref ty, .. }) = cx.typeck_results().expr_ty(recv).kind();\n         if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty));\n         if layout.is_zst();\n         then {"}]}