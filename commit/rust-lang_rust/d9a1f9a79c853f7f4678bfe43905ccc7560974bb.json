{"sha": "d9a1f9a79c853f7f4678bfe43905ccc7560974bb", "node_id": "C_kwDOAAsO6NoAKGQ5YTFmOWE3OWM4NTNmN2Y0Njc4YmZlNDM5MDVjY2M3NTYwOTc0YmI", "commit": {"author": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2021-10-30T11:20:50Z"}, "committer": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2021-10-31T16:32:34Z"}, "message": " Windows: Resolve Command program without using the current directory", "tree": {"sha": "efe2efa8a0070135265de748c6b81ca7f08334a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efe2efa8a0070135265de748c6b81ca7f08334a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9a1f9a79c853f7f4678bfe43905ccc7560974bb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+p/jD6jrzmnSIWJLcTRy8vRWJ94FAmF+xSIACgkQcTRy8vRW\nJ94JFA//dBtDlQ0hhIvUgblIFVMWMxAAcOEEJWTiUDkTpCX9iUS1wofAPTGq4BLm\nxZ1O84Z3G+RPxhoYQRWRvp/K8fEzHG1PLGUzOpEnDJ1geBhD0ezi6VgiHWB4+dsb\n+UvxIhGIMkegzSvnp2W9YkMdIdY7upIn9K4mPGpIAH0rNcwkC8g3U2RyJDC9RpYq\nEWZsb+drpZXlGGcGxyg9kxCTadb5GRiIbwTFxLpI0T9Uqr1V5n5btSleEpfepMXd\n//WFwaC5OJhNvpWZjzBkRuJdjE/Vfcwei2t3ps9O+E/wpsUwoyJEJv2F4z0wXCsW\nq8WYDQVj5dPKoQt2bXcLvKjE0JEzF6S1w6sAN+ghzS/Edj9IIKVDVUDXu0Yvm2Ha\nJmGfN0ItBp18C3hNwQkfD641jf9xVEqGTjpWKvSDaSeAZjXkkGinRMK8hGetfyCy\nO5fSkltUgfbaMqppaUOKv8vcX5s8EuEt13u4r6OLH2/8Takbvl3UwYobxJOfeOLG\nKCPlzZ1VFMTW90vGVHaqWVG/Y2EoXaqVgzD0TBXkHJE6s1JE4eSYEjXeRjQn1bID\nIfNmBNmTCRvtgwzOvZFP+IQUq5OEBCFwSpcU+AB6BH7Syue3uk2UiMzPbbRPAwwh\n4HaXzk681vwNnq5MH5H4/pUcwD04VQQI/7HUh9gwhAN6EcX4RAI=\n=Dngb\n-----END PGP SIGNATURE-----", "payload": "tree efe2efa8a0070135265de748c6b81ca7f08334a2\nparent 07f54d94e608fc29e8aad386831dacee397e2282\nauthor Chris Denton <christophersdenton@gmail.com> 1635592850 +0100\ncommitter Chris Denton <christophersdenton@gmail.com> 1635697954 +0000\n\n Windows: Resolve Command program without using the current directory\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9a1f9a79c853f7f4678bfe43905ccc7560974bb", "html_url": "https://github.com/rust-lang/rust/commit/d9a1f9a79c853f7f4678bfe43905ccc7560974bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9a1f9a79c853f7f4678bfe43905ccc7560974bb/comments", "author": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07f54d94e608fc29e8aad386831dacee397e2282", "url": "https://api.github.com/repos/rust-lang/rust/commits/07f54d94e608fc29e8aad386831dacee397e2282", "html_url": "https://github.com/rust-lang/rust/commit/07f54d94e608fc29e8aad386831dacee397e2282"}], "stats": {"total": 245, "additions": 216, "deletions": 29}, "files": [{"sha": "50c4547de85f69e46f7ff43276367d153e0128f1", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9a1f9a79c853f7f4678bfe43905ccc7560974bb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9a1f9a79c853f7f4678bfe43905ccc7560974bb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=d9a1f9a79c853f7f4678bfe43905ccc7560974bb", "patch": "@@ -734,6 +734,7 @@ if #[cfg(not(target_vendor = \"uwp\"))] {\n             lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n         ) -> BOOL;\n         pub fn SetThreadStackGuarantee(_size: *mut c_ulong) -> BOOL;\n+        pub fn GetWindowsDirectoryW(lpBuffer: LPWSTR, uSize: UINT) -> UINT;\n     }\n }\n }\n@@ -773,6 +774,7 @@ extern \"system\" {\n     pub fn LeaveCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n     pub fn DeleteCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n \n+    pub fn GetSystemDirectoryW(lpBuffer: LPWSTR, uSize: UINT) -> UINT;\n     pub fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n     pub fn SetFileAttributesW(lpFileName: LPCWSTR, dwFileAttributes: DWORD) -> BOOL;\n     pub fn SetLastError(dwErrCode: DWORD);"}, {"sha": "8a5a5f56aa8fa693e41de5861c4f47c57172dc19", "filename": "library/std/src/sys/windows/path.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d9a1f9a79c853f7f4678bfe43905ccc7560974bb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9a1f9a79c853f7f4678bfe43905ccc7560974bb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs?ref=d9a1f9a79c853f7f4678bfe43905ccc7560974bb", "patch": "@@ -1,9 +1,8 @@\n use super::{c, fill_utf16_buf, to_u16s};\n-use crate::ffi::OsStr;\n+use crate::ffi::{OsStr, OsString};\n use crate::io;\n use crate::mem;\n-use crate::path::Path;\n-use crate::path::Prefix;\n+use crate::path::{Path, PathBuf, Prefix};\n use crate::ptr;\n \n #[cfg(test)]\n@@ -32,6 +31,25 @@ pub fn is_verbatim_sep(b: u8) -> bool {\n     b == b'\\\\'\n }\n \n+/// Returns true if `path` looks like a lone filename.\n+pub(crate) fn is_file_name(path: &OsStr) -> bool {\n+    !path.bytes().iter().copied().any(is_sep_byte)\n+}\n+pub(crate) fn has_trailing_slash(path: &OsStr) -> bool {\n+    let is_verbatim = path.bytes().starts_with(br\"\\\\?\\\");\n+    let is_separator = if is_verbatim { is_verbatim_sep } else { is_sep_byte };\n+    if let Some(&c) = path.bytes().last() { is_separator(c) } else { false }\n+}\n+\n+/// Appends a suffix to a path.\n+///\n+/// Can be used to append an extension without removing an existing extension.\n+pub(crate) fn append_suffix(path: PathBuf, suffix: &OsStr) -> PathBuf {\n+    let mut path = OsString::from(path);\n+    path.push(suffix);\n+    path.into()\n+}\n+\n pub fn parse_prefix(path: &OsStr) -> Option<Prefix<'_>> {\n     use Prefix::{DeviceNS, Disk, Verbatim, VerbatimDisk, VerbatimUNC, UNC};\n "}, {"sha": "66b210ce1bfb3ebcfadc052330fd05cfe2fe8c3c", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 141, "deletions": 26, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/d9a1f9a79c853f7f4678bfe43905ccc7560974bb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9a1f9a79c853f7f4678bfe43905ccc7560974bb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=d9a1f9a79c853f7f4678bfe43905ccc7560974bb", "patch": "@@ -7,24 +7,24 @@ use crate::cmp;\n use crate::collections::BTreeMap;\n use crate::convert::{TryFrom, TryInto};\n use crate::env;\n-use crate::env::split_paths;\n+use crate::env::consts::{EXE_EXTENSION, EXE_SUFFIX};\n use crate::ffi::{OsStr, OsString};\n use crate::fmt;\n-use crate::fs;\n use crate::io::{self, Error, ErrorKind};\n use crate::mem;\n use crate::num::NonZeroI32;\n-use crate::os::windows::ffi::OsStrExt;\n+use crate::os::windows::ffi::{OsStrExt, OsStringExt};\n use crate::os::windows::io::{AsRawHandle, FromRawHandle, IntoRawHandle};\n-use crate::path::Path;\n+use crate::path::{Path, PathBuf};\n use crate::ptr;\n use crate::sys::c;\n use crate::sys::c::NonZeroDWORD;\n-use crate::sys::cvt;\n use crate::sys::fs::{File, OpenOptions};\n use crate::sys::handle::Handle;\n+use crate::sys::path;\n use crate::sys::pipe::{self, AnonPipe};\n use crate::sys::stdio;\n+use crate::sys::{cvt, to_u16s};\n use crate::sys_common::mutex::StaticMutex;\n use crate::sys_common::process::{CommandEnv, CommandEnvs};\n use crate::sys_common::{AsInner, IntoInner};\n@@ -258,31 +258,19 @@ impl Command {\n         needs_stdin: bool,\n     ) -> io::Result<(Process, StdioPipes)> {\n         let maybe_env = self.env.capture_if_changed();\n-        // To have the spawning semantics of unix/windows stay the same, we need\n-        // to read the *child's* PATH if one is provided. See #15149 for more\n-        // details.\n-        let program = maybe_env.as_ref().and_then(|env| {\n-            if let Some(v) = env.get(&EnvKey::new(\"PATH\")) {\n-                // Split the value and test each path to see if the\n-                // program exists.\n-                for path in split_paths(&v) {\n-                    let path = path\n-                        .join(self.program.to_str().unwrap())\n-                        .with_extension(env::consts::EXE_EXTENSION);\n-                    if fs::metadata(&path).is_ok() {\n-                        return Some(path.into_os_string());\n-                    }\n-                }\n-            }\n-            None\n-        });\n \n         let mut si = zeroed_startupinfo();\n         si.cb = mem::size_of::<c::STARTUPINFO>() as c::DWORD;\n         si.dwFlags = c::STARTF_USESTDHANDLES;\n \n-        let program = program.as_ref().unwrap_or(&self.program);\n-        let mut cmd_str = make_command_line(program, &self.args, self.force_quotes_enabled)?;\n+        let child_paths = if let Some(env) = maybe_env.as_ref() {\n+            env.get(&EnvKey::new(\"PATH\")).map(|s| s.as_os_str())\n+        } else {\n+            None\n+        };\n+        let program = resolve_exe(&self.program, child_paths)?;\n+        let mut cmd_str =\n+            make_command_line(program.as_os_str(), &self.args, self.force_quotes_enabled)?;\n         cmd_str.push(0); // add null terminator\n \n         // stolen from the libuv code.\n@@ -321,9 +309,10 @@ impl Command {\n         si.hStdOutput = stdout.as_raw_handle();\n         si.hStdError = stderr.as_raw_handle();\n \n+        let program = to_u16s(&program)?;\n         unsafe {\n             cvt(c::CreateProcessW(\n-                ptr::null(),\n+                program.as_ptr(),\n                 cmd_str.as_mut_ptr(),\n                 ptr::null_mut(),\n                 ptr::null_mut(),\n@@ -361,6 +350,132 @@ impl fmt::Debug for Command {\n     }\n }\n \n+// Resolve `exe_path` to the executable name.\n+//\n+// * If the path is simply a file name then use the paths given by `search_paths` to find the executable.\n+// * Otherwise use the `exe_path` as given.\n+//\n+// This function may also append `.exe` to the name. The rationale for doing so is as follows:\n+//\n+// It is a very strong convention that Windows executables have the `exe` extension.\n+// In Rust, it is common to omit this extension.\n+// Therefore this functions first assumes `.exe` was intended.\n+// It falls back to the plain file name if a full path is given and the extension is omitted\n+// or if only a file name is given and it already contains an extension.\n+fn resolve_exe<'a>(exe_path: &'a OsStr, child_paths: Option<&OsStr>) -> io::Result<PathBuf> {\n+    // Early return if there is no filename.\n+    if exe_path.is_empty() || path::has_trailing_slash(exe_path) {\n+        return Err(io::Error::new_const(\n+            io::ErrorKind::InvalidInput,\n+            &\"program path has no file name\",\n+        ));\n+    }\n+    // Test if the file name has the `exe` extension.\n+    // This does a case-insensitive `ends_with`.\n+    let has_exe_suffix = if exe_path.len() >= EXE_SUFFIX.len() {\n+        exe_path.bytes()[exe_path.len() - EXE_SUFFIX.len()..]\n+            .eq_ignore_ascii_case(EXE_SUFFIX.as_bytes())\n+    } else {\n+        false\n+    };\n+\n+    // If `exe_path` is an absolute path or a sub-path then don't search `PATH` for it.\n+    if !path::is_file_name(exe_path) {\n+        if has_exe_suffix {\n+            // The application name is a path to a `.exe` file.\n+            // Let `CreateProcessW` figure out if it exists or not.\n+            return Ok(exe_path.into());\n+        }\n+        let mut path = PathBuf::from(exe_path);\n+\n+        // Append `.exe` if not already there.\n+        path = path::append_suffix(path, EXE_SUFFIX.as_ref());\n+        if path.try_exists().unwrap_or(false) {\n+            return Ok(path);\n+        } else {\n+            // It's ok to use `set_extension` here because the intent is to\n+            // remove the extension that was just added.\n+            path.set_extension(\"\");\n+            return Ok(path);\n+        }\n+    } else {\n+        ensure_no_nuls(exe_path)?;\n+        // From the `CreateProcessW` docs:\n+        // > If the file name does not contain an extension, .exe is appended.\n+        // Note that this rule only applies when searching paths.\n+        let has_extension = exe_path.bytes().contains(&b'.');\n+\n+        // Search the directories given by `search_paths`.\n+        let result = search_paths(child_paths, |mut path| {\n+            path.push(&exe_path);\n+            if !has_extension {\n+                path.set_extension(EXE_EXTENSION);\n+            }\n+            if let Ok(true) = path.try_exists() { Some(path) } else { None }\n+        });\n+        if let Some(path) = result {\n+            return Ok(path);\n+        }\n+    }\n+    // If we get here then the executable cannot be found.\n+    Err(io::Error::new_const(io::ErrorKind::NotFound, &\"program not found\"))\n+}\n+\n+// Calls `f` for every path that should be used to find an executable.\n+// Returns once `f` returns the path to an executable or all paths have been searched.\n+fn search_paths<F>(child_paths: Option<&OsStr>, mut f: F) -> Option<PathBuf>\n+where\n+    F: FnMut(PathBuf) -> Option<PathBuf>,\n+{\n+    // 1. Child paths\n+    // This is for consistency with Rust's historic behaviour.\n+    if let Some(paths) = child_paths {\n+        for path in env::split_paths(paths).filter(|p| !p.as_os_str().is_empty()) {\n+            if let Some(path) = f(path) {\n+                return Some(path);\n+            }\n+        }\n+    }\n+\n+    // 2. Application path\n+    if let Ok(mut app_path) = env::current_exe() {\n+        app_path.pop();\n+        if let Some(path) = f(app_path) {\n+            return Some(path);\n+        }\n+    }\n+\n+    // 3 & 4. System paths\n+    // SAFETY: This uses `fill_utf16_buf` to safely call the OS functions.\n+    unsafe {\n+        if let Ok(Some(path)) = super::fill_utf16_buf(\n+            |buf, size| c::GetSystemDirectoryW(buf, size),\n+            |buf| f(PathBuf::from(OsString::from_wide(buf))),\n+        ) {\n+            return Some(path);\n+        }\n+        #[cfg(not(target_vendor = \"uwp\"))]\n+        {\n+            if let Ok(Some(path)) = super::fill_utf16_buf(\n+                |buf, size| c::GetWindowsDirectoryW(buf, size),\n+                |buf| f(PathBuf::from(OsString::from_wide(buf))),\n+            ) {\n+                return Some(path);\n+            }\n+        }\n+    }\n+\n+    // 5. Parent paths\n+    if let Some(parent_paths) = env::var_os(\"PATH\") {\n+        for path in env::split_paths(&parent_paths).filter(|p| !p.as_os_str().is_empty()) {\n+            if let Some(path) = f(path) {\n+                return Some(path);\n+            }\n+        }\n+    }\n+    None\n+}\n+\n impl Stdio {\n     fn to_handle(&self, stdio_id: c::DWORD, pipe: &mut Option<AnonPipe>) -> io::Result<Handle> {\n         match *self {"}, {"sha": "6c862edc2370ace2a74a21780a7e6e61f51e99ec", "filename": "library/std/src/sys/windows/process/tests.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d9a1f9a79c853f7f4678bfe43905ccc7560974bb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9a1f9a79c853f7f4678bfe43905ccc7560974bb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs?ref=d9a1f9a79c853f7f4678bfe43905ccc7560974bb", "patch": "@@ -128,3 +128,55 @@ fn windows_env_unicode_case() {\n         }\n     }\n }\n+\n+// UWP applications run in a restricted environment which means this test may not work.\n+#[cfg(not(target_vendor = \"uwp\"))]\n+#[test]\n+fn windows_exe_resolver() {\n+    use super::resolve_exe;\n+    use crate::io;\n+\n+    // Test a full path, with and without the `exe` extension.\n+    let mut current_exe = env::current_exe().unwrap();\n+    assert!(resolve_exe(current_exe.as_ref(), None).is_ok());\n+    current_exe.set_extension(\"\");\n+    assert!(resolve_exe(current_exe.as_ref(), None).is_ok());\n+\n+    // Test lone file names.\n+    assert!(resolve_exe(OsStr::new(\"cmd\"), None).is_ok());\n+    assert!(resolve_exe(OsStr::new(\"cmd.exe\"), None).is_ok());\n+    assert!(resolve_exe(OsStr::new(\"cmd.EXE\"), None).is_ok());\n+    assert!(resolve_exe(OsStr::new(\"fc\"), None).is_ok());\n+\n+    // Invalid file names should return InvalidInput.\n+    assert_eq!(resolve_exe(OsStr::new(\"\"), None).unwrap_err().kind(), io::ErrorKind::InvalidInput);\n+    assert_eq!(\n+        resolve_exe(OsStr::new(\"\\0\"), None).unwrap_err().kind(),\n+        io::ErrorKind::InvalidInput\n+    );\n+    // Trailing slash, therefore there's no file name component.\n+    assert_eq!(\n+        resolve_exe(OsStr::new(r\"C:\\Path\\to\\\"), None).unwrap_err().kind(),\n+        io::ErrorKind::InvalidInput\n+    );\n+\n+    /*\n+    Some of the following tests may need to be changed if you are deliberately\n+    changing the behaviour of `resolve_exe`.\n+    */\n+\n+    let paths = env::var_os(\"PATH\").unwrap();\n+    env::set_var(\"PATH\", \"\");\n+\n+    assert_eq!(resolve_exe(OsStr::new(\"rustc\"), None).unwrap_err().kind(), io::ErrorKind::NotFound);\n+\n+    let child_paths = Some(paths.as_os_str());\n+    assert!(resolve_exe(OsStr::new(\"rustc\"), child_paths).is_ok());\n+\n+    // The resolver looks in system directories even when `PATH` is empty.\n+    assert!(resolve_exe(OsStr::new(\"cmd.exe\"), None).is_ok());\n+\n+    // The application's directory is also searched.\n+    let current_exe = env::current_exe().unwrap();\n+    assert!(resolve_exe(current_exe.file_name().unwrap().as_ref(), None).is_ok());\n+}"}]}