{"sha": "8f6894e177cecf3cd35833e2063256a69841415a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNjg5NGUxNzdjZWNmM2NkMzU4MzNlMjA2MzI1NmE2OTg0MTQxNWE=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-24T13:50:42Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-31T13:15:09Z"}, "message": "async-llvm(6): Make the LLVM work coordinator get its work package through a channel instead of upfront.", "tree": {"sha": "aa19daea1d81814f17608c4c5050e72a7770325d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa19daea1d81814f17608c4c5050e72a7770325d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f6894e177cecf3cd35833e2063256a69841415a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f6894e177cecf3cd35833e2063256a69841415a", "html_url": "https://github.com/rust-lang/rust/commit/8f6894e177cecf3cd35833e2063256a69841415a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f6894e177cecf3cd35833e2063256a69841415a/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b18a61a15ba5c267f7b25edebf3ff4aa7c3896f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b18a61a15ba5c267f7b25edebf3ff4aa7c3896f6", "html_url": "https://github.com/rust-lang/rust/commit/b18a61a15ba5c267f7b25edebf3ff4aa7c3896f6"}], "stats": {"total": 81, "additions": 53, "deletions": 28}, "files": [{"sha": "ee3c9ace7dc14e061945cc656f581bbaf36ed987", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 53, "deletions": 28, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8f6894e177cecf3cd35833e2063256a69841415a/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6894e177cecf3cd35833e2063256a69841415a/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=8f6894e177cecf3cd35833e2063256a69841415a", "patch": "@@ -780,19 +780,31 @@ pub fn run_passes(sess: &Session,\n \n     let (shared_emitter, shared_emitter_main) = SharedEmitter::new();\n     let (trans_worker_send, trans_worker_receive) = channel();\n+    let (coordinator_send, coordinator_receive) = channel();\n \n     let coordinator_thread = start_executing_work(sess,\n-                                                  work_items,\n+                                                  work_items.len(),\n                                                   shared_emitter,\n                                                   trans_worker_send,\n+                                                  coordinator_send.clone(),\n+                                                  coordinator_receive,\n                                                   client,\n                                                   trans.exported_symbols.clone());\n+    for work_item in work_items {\n+        coordinator_send.send(Message::WorkItem(work_item)).unwrap();\n+    }\n+\n     loop {\n         shared_emitter_main.check(sess);\n \n         match trans_worker_receive.recv() {\n-            Ok(Message::AllWorkDone) |\n-            Err(_) => break,\n+            Err(_) => {\n+                // An `Err` here means that all senders for this channel have\n+                // been closed. This could happen because all work has\n+                // completed successfully or there has been some error.\n+                // At this point we don't care which it is.\n+                break\n+            }\n \n             Ok(Message::CheckErrorMessages) => continue,\n             Ok(msg) => {\n@@ -801,9 +813,15 @@ pub fn run_passes(sess: &Session,\n         }\n     }\n \n-    coordinator_thread.join().unwrap();\n+    match coordinator_thread.join() {\n+        Ok(()) => {},\n+        Err(err) => {\n+            panic!(\"error: {:?}\", err);\n+        }\n+    }\n \n     // Just in case, check this on the way out.\n+    shared_emitter_main.check(sess);\n     sess.diagnostic().abort_if_errors();\n \n     // If in incr. comp. mode, preserve the `.o` files for potential re-use\n@@ -1080,7 +1098,6 @@ pub enum Message {\n     Done { success: bool },\n     WorkItem(WorkItem),\n     CheckErrorMessages,\n-    AllWorkDone,\n }\n \n \n@@ -1091,15 +1108,14 @@ pub struct Diagnostic {\n }\n \n fn start_executing_work(sess: &Session,\n-                        mut work_items: Vec<WorkItem>,\n+                        total_work_item_count: usize,\n                         shared_emitter: SharedEmitter,\n                         trans_worker_send: Sender<Message>,\n+                        coordinator_send: Sender<Message>,\n+                        coordinator_receive: Receiver<Message>,\n                         jobserver: Client,\n                         exported_symbols: Arc<ExportedSymbols>)\n-                -> thread::JoinHandle<()> {\n-    let (tx, rx) = channel();\n-    let tx2 = tx.clone();\n-\n+                        -> thread::JoinHandle<()> {\n     // First up, convert our jobserver into a helper thread so we can use normal\n     // mpsc channels to manage our messages and such. Once we've got the helper\n     // thread then request `n-1` tokens because all of our work items are ready\n@@ -1110,10 +1126,11 @@ fn start_executing_work(sess: &Session,\n     //\n     // After we've requested all these tokens then we'll, when we can, get\n     // tokens on `rx` above which will get managed in the main loop below.\n+    let coordinator_send2 = coordinator_send.clone();\n     let helper = jobserver.into_helper_thread(move |token| {\n-        drop(tx2.send(Message::Token(token)));\n+        drop(coordinator_send2.send(Message::Token(token)));\n     }).expect(\"failed to spawn helper thread\");\n-    for _ in 0..work_items.len() - 1 {\n+    for _ in 0..total_work_item_count - 1 {\n         helper.request_token();\n     }\n \n@@ -1137,7 +1154,7 @@ fn start_executing_work(sess: &Session,\n         remark: sess.opts.cg.remark.clone(),\n         worker: 0,\n         incr_comp_session_dir: sess.incr_comp_session_dir_opt().map(|r| r.clone()),\n-        coordinator_send: tx.clone(),\n+        coordinator_send: coordinator_send,\n         diag_emitter: shared_emitter.clone(),\n     };\n \n@@ -1198,36 +1215,46 @@ fn start_executing_work(sess: &Session,\n     // the jobserver.\n \n     thread::spawn(move || {\n+        let mut work_items_left = total_work_item_count;\n+        let mut work_items = Vec::with_capacity(total_work_item_count);\n         let mut tokens = Vec::new();\n         let mut running = 0;\n-        while work_items.len() > 0 || running > 0 {\n+        while work_items_left > 0 || running > 0 {\n \n             // Spin up what work we can, only doing this while we've got available\n             // parallelism slots and work left to spawn.\n-            while work_items.len() > 0 && running < tokens.len() + 1 {\n-                let item = work_items.pop().unwrap();\n-                let worker_index = work_items.len();\n-\n-                let cgcx = CodegenContext {\n-                    worker: worker_index,\n-                    .. cgcx.clone()\n-                };\n-\n-                spawn_work(cgcx, item);\n-                running += 1;\n+            while work_items_left > 0 && running < tokens.len() + 1 {\n+                if let Some(item) = work_items.pop() {\n+                    work_items_left -= 1;\n+                    let worker_index = work_items_left;\n+\n+                    let cgcx = CodegenContext {\n+                        worker: worker_index,\n+                        .. cgcx.clone()\n+                    };\n+\n+                    spawn_work(cgcx, item);\n+                    running += 1;\n+                } else {\n+                    break\n+                }\n             }\n \n             // Relinquish accidentally acquired extra tokens\n             tokens.truncate(running.saturating_sub(1));\n \n-            match rx.recv().unwrap() {\n+            match coordinator_receive.recv().unwrap() {\n                 // Save the token locally and the next turn of the loop will use\n                 // this to spawn a new unit of work, or it may get dropped\n                 // immediately if we have no more work to spawn.\n                 Message::Token(token) => {\n                     tokens.push(token.expect(\"failed to acquire jobserver token\"));\n                 }\n \n+                Message::WorkItem(work_item) => {\n+                    work_items.push(work_item);\n+                }\n+\n                 // If a thread exits successfully then we drop a token associated\n                 // with that worker and update our `running` count. We may later\n                 // re-acquire a token to continue running more work. We may also not\n@@ -1245,8 +1272,6 @@ fn start_executing_work(sess: &Session,\n                     shared_emitter.fatal(\"aborting due to worker thread panic\".to_string());\n                     trans_worker_send.send(Message::CheckErrorMessages).unwrap();\n                 }\n-                msg @ Message::WorkItem(_) |\n-                msg @ Message::AllWorkDone |\n                 msg @ Message::CheckErrorMessages => {\n                     bug!(\"unexpected message: {:?}\", msg);\n                 }"}]}