{"sha": "e7d96934c16c915d18be391836fbf0ebca6c558b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3ZDk2OTM0YzE2YzkxNWQxOGJlMzkxODM2ZmJmMGViY2E2YzU1OGI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-03T16:11:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-03T16:29:24Z"}, "message": "Correct mismatch between the way that pattern ids and expression ids map to types (pattern ids map to the input type, expression ids map to the output type)", "tree": {"sha": "6ce6cc6cd3054effceb51c343e080970d31dd919", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ce6cc6cd3054effceb51c343e080970d31dd919"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7d96934c16c915d18be391836fbf0ebca6c558b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7d96934c16c915d18be391836fbf0ebca6c558b", "html_url": "https://github.com/rust-lang/rust/commit/e7d96934c16c915d18be391836fbf0ebca6c558b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7d96934c16c915d18be391836fbf0ebca6c558b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34024353e86e22e459a1981f563e3d4f43906432", "url": "https://api.github.com/repos/rust-lang/rust/commits/34024353e86e22e459a1981f563e3d4f43906432", "html_url": "https://github.com/rust-lang/rust/commit/34024353e86e22e459a1981f563e3d4f43906432"}], "stats": {"total": 246, "additions": 131, "deletions": 115}, "files": [{"sha": "c2dc2fb22ab5b0684e1a20a69193def6a6f036b9", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7d96934c16c915d18be391836fbf0ebca6c558b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7d96934c16c915d18be391836fbf0ebca6c558b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=e7d96934c16c915d18be391836fbf0ebca6c558b", "patch": "@@ -378,7 +378,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n                     // Dynamically check writes to `@mut`\n \n                     let key = root_map_key {\n-                        id: base.id,\n+                        id: guarantor.id,\n                         derefs: deref_count\n                     };\n                     debug!(\"Inserting write guard at %?\", key);"}, {"sha": "43fff110a7a7e6394a6962de0015bdba43e80902", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7d96934c16c915d18be391836fbf0ebca6c558b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7d96934c16c915d18be391836fbf0ebca6c558b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=e7d96934c16c915d18be391836fbf0ebca6c558b", "patch": "@@ -97,7 +97,7 @@ impl GuaranteeLifetimeContext {\n                 );\n \n                 if !omit_root {\n-                    self.check_root(base, derefs, ptr_mutbl, discr_scope);\n+                    self.check_root(cmt, base, derefs, ptr_mutbl, discr_scope);\n                 } else {\n                     debug!(\"omitting root, base=%s, base_scope=%?\",\n                            base.repr(self.tcx()), base_scope);\n@@ -168,12 +168,14 @@ impl GuaranteeLifetimeContext {\n     }\n \n     fn check_root(&self,\n+                  cmt_deref: mc::cmt,\n                   cmt_base: mc::cmt,\n                   derefs: uint,\n                   ptr_mutbl: ast::mutability,\n                   discr_scope: Option<ast::node_id>) {\n-        debug!(\"check_root(cmt_base=%s, derefs=%? ptr_mutbl=%?, \\\n+        debug!(\"check_root(cmt_deref=%s, cmt_base=%s, derefs=%?, ptr_mutbl=%?, \\\n                 discr_scope=%?)\",\n+               cmt_deref.repr(self.tcx()),\n                cmt_base.repr(self.tcx()),\n                derefs,\n                ptr_mutbl,\n@@ -234,7 +236,7 @@ impl GuaranteeLifetimeContext {\n         };\n \n         // Add a record of what is required\n-        let rm_key = root_map_key {id: cmt_base.id, derefs: derefs};\n+        let rm_key = root_map_key {id: cmt_deref.id, derefs: derefs};\n         let root_info = RootInfo {scope: root_scope, freeze: opt_dyna};\n         self.bccx.root_map.insert(rm_key, root_info);\n "}, {"sha": "a44f743c9ead0f9b96723bdd0e0769515e2e68c9", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e7d96934c16c915d18be391836fbf0ebca6c558b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7d96934c16c915d18be391836fbf0ebca6c558b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=e7d96934c16c915d18be391836fbf0ebca6c558b", "patch": "@@ -172,11 +172,19 @@ pub struct BorrowStats {\n \n pub type LoanMap = @mut HashMap<ast::node_id, @Loan>;\n \n-// the keys to the root map combine the `id` of the expression with\n-// the number of types that it is autodereferenced. So, for example,\n-// if you have an expression `x.f` and x has type ~@T, we could add an\n-// entry {id:x, derefs:0} to refer to `x` itself, `{id:x, derefs:1}`\n-// to refer to the deref of the unique pointer, and so on.\n+// The keys to the root map combine the `id` of the deref expression\n+// with the number of types that it is *autodereferenced*. So, for\n+// example, imagine I have a variable `x: @@@T` and an expression\n+// `(*x).f`.  This will have 3 derefs, one explicit and then two\n+// autoderefs. These are the relevant `root_map_key` values that could\n+// appear:\n+//\n+//    {id:*x, derefs:0} --> roots `x` (type: @@@T, due to explicit deref)\n+//    {id:*x, derefs:1} --> roots `*x` (type: @@T, due to autoderef #1)\n+//    {id:*x, derefs:2} --> roots `**x` (type: @T, due to autoderef #2)\n+//\n+// Note that there is no entry with derefs:3---the type of that expression\n+// is T, which is not a box.\n #[deriving(Eq, IterBytes)]\n pub struct root_map_key {\n     id: ast::node_id,"}, {"sha": "f1c337125d70416d79f9af1c8bbd88d07f261088", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 93, "deletions": 102, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/e7d96934c16c915d18be391836fbf0ebca6c558b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7d96934c16c915d18be391836fbf0ebca6c558b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e7d96934c16c915d18be391836fbf0ebca6c558b", "patch": "@@ -92,12 +92,12 @@ pub enum ptr_kind {\n pub enum interior_kind {\n     interior_tuple,                  // elt in a tuple\n     interior_anon_field,             // anonymous field (in e.g.\n-                                 // struct Foo(int, int);\n+                                     // struct Foo(int, int);\n     interior_variant(ast::def_id),   // internals to a variant of given enum\n     interior_field(ast::ident,       // name of field\n-               ast::mutability), // declared mutability of field\n+                   ast::mutability), // declared mutability of field\n     interior_index(ty::t,            // type of vec/str/etc being deref'd\n-               ast::mutability)  // mutability of vec content\n+                   ast::mutability)  // mutability of vec content\n }\n \n #[deriving(Eq)]\n@@ -108,18 +108,27 @@ pub enum MutabilityCategory {\n     McInherited  // Inherited from the fact that owner is mutable.\n }\n \n+// `cmt`: \"Category, Mutability, and Type\".\n+//\n // a complete categorization of a value indicating where it originated\n // and how it is located, as well as the mutability of the memory in\n // which the value is stored.\n //\n-// note: cmt stands for \"categorized mutable type\".\n+// *WARNING* The field `cmt.type` is NOT necessarily the same as the\n+// result of `node_id_to_type(cmt.id)`. This is because the `id` is\n+// always the `id` of the node producing the type; in an expression\n+// like `*x`, the type of this deref node is the deref'd type (`T`),\n+// but in a pattern like `@x`, the `@x` pattern is again a\n+// dereference, but its type is the type *before* the dereference\n+// (`@T`). So use `cmt.type` to find the type of the value in a consistent\n+// fashion. For more details, see the method `cat_pattern`\n #[deriving(Eq)]\n pub struct cmt_ {\n     id: ast::node_id,          // id of expr/pat producing this value\n     span: span,                // span of same expr/pat\n     cat: categorization,       // categorization of expr\n     mutbl: MutabilityCategory, // mutability of expr as lvalue\n-    ty: ty::t                  // type of the expr\n+    ty: ty::t                  // type of the expr (*see WARNING above*)\n }\n \n pub type cmt = @cmt_;\n@@ -245,19 +254,6 @@ pub fn cat_def(\n     return mcx.cat_def(expr_id, expr_span, expr_ty, def);\n }\n \n-pub fn cat_variant<N:ast_node>(\n-    tcx: ty::ctxt,\n-    method_map: typeck::method_map,\n-    arg: N,\n-    enum_did: ast::def_id,\n-    cmt: cmt) -> cmt {\n-\n-    let mcx = &mem_categorization_ctxt {\n-        tcx: tcx, method_map: method_map\n-    };\n-    return mcx.cat_variant(arg, enum_did, cmt);\n-}\n-\n pub trait ast_node {\n     fn id(&self) -> ast::node_id;\n     fn span(&self) -> span;\n@@ -273,16 +269,6 @@ impl ast_node for @ast::pat {\n     fn span(&self) -> span { self.span }\n }\n \n-pub trait get_type_for_node {\n-    fn ty<N:ast_node>(&self, node: N) -> ty::t;\n-}\n-\n-impl get_type_for_node for ty::ctxt {\n-    fn ty<N:ast_node>(&self, node: N) -> ty::t {\n-        ty::node_id_to_type(*self, node.id())\n-    }\n-}\n-\n pub struct mem_categorization_ctxt {\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n@@ -336,6 +322,14 @@ pub impl MutabilityCategory {\n }\n \n pub impl mem_categorization_ctxt {\n+    fn expr_ty(&self, expr: @ast::expr) -> ty::t {\n+        ty::expr_ty(self.tcx, expr)\n+    }\n+\n+    fn pat_ty(&self, pat: @ast::pat) -> ty::t {\n+        ty::node_id_to_type(self.tcx, pat.id)\n+    }\n+\n     fn cat_expr(&self, expr: @ast::expr) -> cmt {\n         match self.tcx.adjustments.find(&expr.id) {\n             None => {\n@@ -385,7 +379,7 @@ pub impl mem_categorization_ctxt {\n                expr.id, pprust::expr_to_str(expr, self.tcx.sess.intr()));\n \n         let tcx = self.tcx;\n-        let expr_ty = tcx.ty(expr);\n+        let expr_ty = self.expr_ty(expr);\n         match expr.node {\n           ast::expr_unary(ast::deref, e_base) => {\n             if self.method_map.contains_key(&expr.id) {\n@@ -402,7 +396,8 @@ pub impl mem_categorization_ctxt {\n             assert!(!self.method_map.contains_key(&expr.id));\n \n             let base_cmt = self.cat_expr(base);\n-            self.cat_field(expr, base_cmt, f_name, expr.id)\n+            self.cat_field(expr, base_cmt, f_name,\n+                           self.expr_ty(expr), expr.id)\n           }\n \n           ast::expr_index(base, _) => {\n@@ -554,19 +549,6 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_variant<N:ast_node>(&self,\n-                                arg: N,\n-                                enum_did: ast::def_id,\n-                                cmt: cmt) -> cmt {\n-        @cmt_ {\n-            id: arg.id(),\n-            span: arg.span(),\n-            cat: cat_interior(cmt, interior_variant(enum_did)),\n-            mutbl: cmt.mutbl.inherit(),\n-            ty: self.tcx.ty(arg)\n-        }\n-    }\n-\n     fn cat_rvalue<N:ast_node>(&self, elt: N, expr_ty: ty::t) -> cmt {\n         @cmt_ {\n             id:elt.id(),\n@@ -598,6 +580,7 @@ pub impl mem_categorization_ctxt {\n                              node: N,\n                              base_cmt: cmt,\n                              f_name: ast::ident,\n+                             f_ty: ty::t,\n                              field_id: ast::node_id) -> cmt {\n         let f_mutbl = match field_mutbl(self.tcx, base_cmt.ty,\n                                         f_name, field_id) {\n@@ -617,7 +600,7 @@ pub impl mem_categorization_ctxt {\n             span: node.span(),\n             cat: cat_interior(base_cmt, f_interior),\n             mutbl: m,\n-            ty: self.tcx.ty(node)\n+            ty: f_ty\n         }\n     }\n \n@@ -697,8 +680,8 @@ pub impl mem_categorization_ctxt {\n     }\n \n     fn cat_index<N:ast_node>(&self,\n-                              elt: N,\n-                              base_cmt: cmt) -> cmt {\n+                             elt: N,\n+                             base_cmt: cmt) -> cmt {\n         let mt = match ty::index(base_cmt.ty) {\n           Some(mt) => mt,\n           None => {\n@@ -756,27 +739,17 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_tuple_elt<N:ast_node>(&self,\n-                                  elt: N,\n-                                  cmt: cmt) -> cmt {\n-        @cmt_ {\n-            id: elt.id(),\n-            span: elt.span(),\n-            cat: cat_interior(cmt, interior_tuple),\n-            mutbl: cmt.mutbl.inherit(),\n-            ty: self.tcx.ty(elt)\n-        }\n-    }\n-\n-    fn cat_anon_struct_field<N:ast_node>(&self,\n-                                          elt: N,\n-                                          cmt: cmt) -> cmt {\n+    fn cat_imm_interior<N:ast_node>(&self,\n+                                    node: N,\n+                                    base_cmt: cmt,\n+                                    interior_ty: ty::t,\n+                                    interior: interior_kind) -> cmt {\n         @cmt_ {\n-            id: elt.id(),\n-            span: elt.span(),\n-            cat: cat_interior(cmt, interior_anon_field),\n-            mutbl: cmt.mutbl.inherit(),\n-            ty: self.tcx.ty(elt)\n+            id: node.id(),\n+            span: node.span(),\n+            cat: cat_interior(base_cmt, interior),\n+            mutbl: base_cmt.mutbl.inherit(),\n+            ty: interior_ty\n         }\n     }\n \n@@ -797,27 +770,37 @@ pub impl mem_categorization_ctxt {\n         // we can be sure that the binding will remain valid for the\n         // duration of the arm.\n         //\n-        // The correspondence between the id in the cmt and which\n-        // pattern is being referred to is somewhat...subtle.  In\n-        // general, the id of the cmt is the id of the node that\n-        // produces the value.  For patterns, that's actually the\n-        // *subpattern*, generally speaking.\n+        // (*) There is subtlety concerning the correspondence between\n+        // pattern ids and types as compared to *expression* ids and\n+        // types. This is explained briefly. on the definition of the\n+        // type `cmt`, so go off and read what it says there, then\n+        // come back and I'll dive into a bit more detail here. :) OK,\n+        // back?\n         //\n-        // To see what I mean about ids etc, consider:\n+        // In general, the id of the cmt should be the node that\n+        // \"produces\" the value---patterns aren't executable code\n+        // exactly, but I consider them to \"execute\" when they match a\n+        // value. So if you have something like:\n         //\n         //     let x = @@3;\n         //     match x {\n         //       @@y { ... }\n         //     }\n         //\n-        // Here the cmt for `y` would be something like\n+        // In this case, the cmt and the relevant ids would be:\n+        //\n+        //     CMT             Id                  Type of Id Type of cmt\n         //\n         //     local(x)->@->@\n+        //     ^~~~~~~^        `x` from discr      @@int      @@int\n+        //     ^~~~~~~~~~^     `@@y` pattern node  @@int      @int\n+        //     ^~~~~~~~~~~~~^  `@y` pattern node   @int       int\n         //\n-        // where the id of `local(x)` is the id of the `x` that appears\n-        // in the match, the id of `local(x)->@` is the `@y` pattern,\n-        // and the id of `local(x)->@->@` is the id of the `y` pattern.\n-\n+        // You can see that the types of the id and the cmt are in\n+        // sync in the first line, because that id is actually the id\n+        // of an expression. But once we get to pattern ids, the types\n+        // step out of sync again. So you'll see below that we always\n+        // get the type of the *subpattern* and use that.\n \n         let tcx = self.tcx;\n         debug!(\"cat_pattern: id=%d pat=%s cmt=%s\",\n@@ -839,22 +822,27 @@ pub impl mem_categorization_ctxt {\n             match self.tcx.def_map.find(&pat.id) {\n                 Some(&ast::def_variant(enum_did, _)) => {\n                     // variant(x, y, z)\n-                    for subpats.each |subpat| {\n-                        let subcmt = self.cat_variant(*subpat, enum_did, cmt);\n-                        self.cat_pattern(subcmt, *subpat, op);\n+                    for subpats.each |&subpat| {\n+                        let subpat_ty = self.pat_ty(subpat); // see (*)\n+                        let subcmt =\n+                            self.cat_imm_interior(pat, cmt, subpat_ty,\n+                                                  interior_variant(enum_did));\n+                        self.cat_pattern(subcmt, subpat, op);\n                     }\n                 }\n                 Some(&ast::def_fn(*)) |\n                 Some(&ast::def_struct(*)) => {\n-                    for subpats.each |subpat| {\n-                        let cmt_field = self.cat_anon_struct_field(*subpat,\n-                                                                   cmt);\n-                        self.cat_pattern(cmt_field, *subpat, op);\n+                    for subpats.each |&subpat| {\n+                        let subpat_ty = self.pat_ty(subpat); // see (*)\n+                        let cmt_field =\n+                            self.cat_imm_interior(pat, cmt, subpat_ty,\n+                                                  interior_anon_field);\n+                        self.cat_pattern(cmt_field, subpat, op);\n                     }\n                 }\n                 Some(&ast::def_const(*)) => {\n-                    for subpats.each |subpat| {\n-                        self.cat_pattern(cmt, *subpat, op);\n+                    for subpats.each |&subpat| {\n+                        self.cat_pattern(cmt, subpat, op);\n                     }\n                 }\n                 _ => {\n@@ -876,39 +864,43 @@ pub impl mem_categorization_ctxt {\n           ast::pat_struct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for field_pats.each |fp| {\n-                let cmt_field = self.cat_field(fp.pat, cmt, fp.ident, pat.id);\n+                let field_ty = self.pat_ty(fp.pat); // see (*)\n+                let cmt_field = self.cat_field(pat, cmt, fp.ident,\n+                                               field_ty, pat.id);\n                 self.cat_pattern(cmt_field, fp.pat, op);\n             }\n           }\n \n           ast::pat_tup(ref subpats) => {\n             // (p1, ..., pN)\n-            for subpats.each |subpat| {\n-                let subcmt = self.cat_tuple_elt(*subpat, cmt);\n-                self.cat_pattern(subcmt, *subpat, op);\n+            for subpats.each |&subpat| {\n+                let subpat_ty = self.pat_ty(subpat); // see (*)\n+                let subcmt = self.cat_imm_interior(pat, cmt, subpat_ty,\n+                                                   interior_tuple);\n+                self.cat_pattern(subcmt, subpat, op);\n             }\n           }\n \n           ast::pat_box(subpat) | ast::pat_uniq(subpat) |\n           ast::pat_region(subpat) => {\n             // @p1, ~p1\n-            let subcmt = self.cat_deref(subpat, cmt, 0);\n+            let subcmt = self.cat_deref(pat, cmt, 0);\n             self.cat_pattern(subcmt, subpat, op);\n           }\n \n           ast::pat_vec(ref before, slice, ref after) => {\n-              for before.each |pat| {\n-                  let elt_cmt = self.cat_index(*pat, cmt);\n-                  self.cat_pattern(elt_cmt, *pat, op);\n+              for before.each |&before_pat| {\n+                  let elt_cmt = self.cat_index(pat, cmt);\n+                  self.cat_pattern(elt_cmt, before_pat, op);\n               }\n-              for slice.each |slice_pat| {\n-                  let slice_ty = self.tcx.ty(*slice_pat);\n-                  let slice_cmt = self.cat_rvalue(*slice_pat, slice_ty);\n-                  self.cat_pattern(slice_cmt, *slice_pat, op);\n+              for slice.each |&slice_pat| {\n+                  let slice_ty = self.pat_ty(slice_pat);\n+                  let slice_cmt = self.cat_rvalue(pat, slice_ty);\n+                  self.cat_pattern(slice_cmt, slice_pat, op);\n               }\n-              for after.each |pat| {\n-                  let elt_cmt = self.cat_index(*pat, cmt);\n-                  self.cat_pattern(elt_cmt, *pat, op);\n+              for after.each |&after_pat| {\n+                  let elt_cmt = self.cat_index(pat, cmt);\n+                  self.cat_pattern(elt_cmt, after_pat, op);\n               }\n           }\n \n@@ -1145,4 +1137,3 @@ impl Repr for interior_kind {\n         }\n     }\n }\n-"}, {"sha": "80e34ca4814262a8c8a2e29994d7045469576608", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e7d96934c16c915d18be391836fbf0ebca6c558b/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7d96934c16c915d18be391836fbf0ebca6c558b/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=e7d96934c16c915d18be391836fbf0ebca6c558b", "patch": "@@ -947,6 +947,17 @@ pub fn collect_record_or_struct_fields(bcx: block,\n     }\n }\n \n+pub fn pats_require_rooting(bcx: block,\n+                            m: &[@Match],\n+                            col: uint)\n+                         -> bool {\n+    vec::any(m, |br| {\n+        let pat_id = br.pats[col].id;\n+        let key = root_map_key {id: pat_id, derefs: 0u };\n+        bcx.ccx().maps.root_map.contains_key(&key)\n+    })\n+}\n+\n pub fn root_pats_as_necessary(bcx: block,\n                               m: &[@Match],\n                               col: uint,\n@@ -1303,7 +1314,10 @@ pub fn compile_submatch(bcx: block,\n         if pat_id == 0 { pat_id = br.pats[col].id; }\n     }\n \n-    bcx = root_pats_as_necessary(bcx, m, col, val);\n+    // If we are not matching against an `@T`, we should not be\n+    // required to root any values.\n+    assert!(any_box_pat(m, col) || !pats_require_rooting(bcx, m, col));\n+\n     let rec_fields = collect_record_or_struct_fields(bcx, m, col);\n     if rec_fields.len() > 0 {\n         let pat_ty = node_id_type(bcx, pat_id);\n@@ -1364,6 +1378,7 @@ pub fn compile_submatch(bcx: block,\n \n     // Unbox in case of a box field\n     if any_box_pat(m, col) {\n+        bcx = root_pats_as_necessary(bcx, m, col, val);\n         let llbox = Load(bcx, val);\n         let box_no_addrspace = non_gc_box_cast(bcx, llbox);\n         let unboxed ="}, {"sha": "095798ae21272da88654c136f6e4391baa5b0148", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7d96934c16c915d18be391836fbf0ebca6c558b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7d96934c16c915d18be391836fbf0ebca6c558b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=e7d96934c16c915d18be391836fbf0ebca6c558b", "patch": "@@ -675,7 +675,7 @@ pub impl Datum {\n     fn try_deref(&self,\n         bcx: block,            // block wherein to generate insn's\n         span: span,            // location where deref occurs\n-        expr_id: ast::node_id, // id of expr being deref'd\n+        expr_id: ast::node_id, // id of deref expr\n         derefs: uint,          // number of times deref'd already\n         is_auto: bool)         // if true, only deref if auto-derefable\n         -> (Option<Datum>, block)\n@@ -810,7 +810,7 @@ pub impl Datum {\n     }\n \n     fn deref(&self, bcx: block,\n-             expr: @ast::expr,  // the expression whose value is being deref'd\n+             expr: @ast::expr,  // the deref expression\n              derefs: uint)\n           -> DatumBlock {\n         match self.try_deref(bcx, expr.span, expr.id, derefs, false) {"}, {"sha": "1a9824dcfe8a1e496f186eda2ad8d54abe4410cf", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7d96934c16c915d18be391836fbf0ebca6c558b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7d96934c16c915d18be391836fbf0ebca6c558b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=e7d96934c16c915d18be391836fbf0ebca6c558b", "patch": "@@ -835,7 +835,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         }\n         ast::expr_unary(ast::deref, base) => {\n             let basedatum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n-            basedatum.deref(bcx, base, 0)\n+            basedatum.deref(bcx, expr, 0)\n         }\n         _ => {\n             bcx.tcx().sess.span_bug("}]}