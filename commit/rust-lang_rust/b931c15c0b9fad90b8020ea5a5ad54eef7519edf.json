{"sha": "b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MzFjMTVjMGI5ZmFkOTBiODAyMGVhNWE1YWQ1NGVlZjc1MTllZGY=", "commit": {"author": {"name": "Ashley Mannix", "email": "kodraus@hey.com", "date": "2021-01-19T07:41:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-19T07:41:38Z"}, "message": "Merge pull request #49 from rust-lang/feature/const-generics\n\nFeature/const generics", "tree": {"sha": "b1b048f07c80a3998f9fdfb2180a3c4cc5fb3c13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1b048f07c80a3998f9fdfb2180a3c4cc5fb3c13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgBo0yCRBK7hj4Ov3rIwAAdHIIADkHJvC6iEY4Lh0BtoHszkxT\nopvyX4LX/eKZGg9t5xvVSeT+RjVk+RBc6EfogKh4X9XXRWUOZa+ubeq60NOQexBZ\ncg2i1V4akNrTDR/RbN8ZR5tsZk8NzESvdTuTg0TV2yJlsYPvYepLguhTYovbN8On\nzjvFUVyY9eOLemWTPZGUN4ZW1l+9941MGO+0/rqvM4VT/m7jtn+em/R77Srdb/Y8\nLKP3eD+ZNNBtSMFFCh6X3yFZnFiAhYJpEc+s8uzs23+8XoPRaNvTNaW0pXBCcomc\neEfl3wWxUMhd8AB8sZ49I3CurG9kk5fA6A8D/IU8pcZ5LaLA6vJYY5MTIhAXCYY=\n=TQBw\n-----END PGP SIGNATURE-----\n", "payload": "tree b1b048f07c80a3998f9fdfb2180a3c4cc5fb3c13\nparent d72927c85b1ae34e1115a19897d93b8dcf59e44d\nparent 59947717c5644a110caea924114b8f64fcb8234c\nauthor Ashley Mannix <kodraus@hey.com> 1611042098 +1000\ncommitter GitHub <noreply@github.com> 1611042098 +1000\n\nMerge pull request #49 from rust-lang/feature/const-generics\n\nFeature/const generics"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "html_url": "https://github.com/rust-lang/rust/commit/b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/comments", "author": {"login": "KodrAus", "id": 6721458, "node_id": "MDQ6VXNlcjY3MjE0NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6721458?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KodrAus", "html_url": "https://github.com/KodrAus", "followers_url": "https://api.github.com/users/KodrAus/followers", "following_url": "https://api.github.com/users/KodrAus/following{/other_user}", "gists_url": "https://api.github.com/users/KodrAus/gists{/gist_id}", "starred_url": "https://api.github.com/users/KodrAus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KodrAus/subscriptions", "organizations_url": "https://api.github.com/users/KodrAus/orgs", "repos_url": "https://api.github.com/users/KodrAus/repos", "events_url": "https://api.github.com/users/KodrAus/events{/privacy}", "received_events_url": "https://api.github.com/users/KodrAus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d72927c85b1ae34e1115a19897d93b8dcf59e44d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d72927c85b1ae34e1115a19897d93b8dcf59e44d", "html_url": "https://github.com/rust-lang/rust/commit/d72927c85b1ae34e1115a19897d93b8dcf59e44d"}, {"sha": "59947717c5644a110caea924114b8f64fcb8234c", "url": "https://api.github.com/repos/rust-lang/rust/commits/59947717c5644a110caea924114b8f64fcb8234c", "html_url": "https://github.com/rust-lang/rust/commit/59947717c5644a110caea924114b8f64fcb8234c"}], "stats": {"total": 2203, "additions": 1135, "deletions": 1068}, "files": [{"sha": "16b8f3b95d9ab1e2440bbb819ea07c95f46d01c2", "filename": "crates/core_simd/src/fmt.rs", "status": "modified", "additions": 9, "deletions": 29, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Ffmt.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -30,18 +30,18 @@ debug_wrapper! {\n }\n \n macro_rules! impl_fmt_trait {\n-    { $($type:ty => $(($trait:ident, $format:ident)),*;)* } => {\n+    { $($type:ident => $(($trait:ident, $format:ident)),*;)* } => {\n         $( // repeat type\n             $( // repeat trait\n-                impl core::fmt::$trait for $type {\n+                impl<const LANES: usize> core::fmt::$trait for crate::$type<LANES> {\n                     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                         $format(self.as_ref(), f)\n                     }\n                 }\n             )*\n         )*\n     };\n-    { integers: $($type:ty,)* } => {\n+    { integers: $($type:ident,)* } => {\n         impl_fmt_trait! {\n             $($type =>\n               (Debug, format),\n@@ -54,7 +54,7 @@ macro_rules! impl_fmt_trait {\n             )*\n         }\n     };\n-    { floats: $($type:ty,)* } => {\n+    { floats: $($type:ident,)* } => {\n         impl_fmt_trait! {\n             $($type =>\n               (Debug, format),\n@@ -63,7 +63,7 @@ macro_rules! impl_fmt_trait {\n             )*\n         }\n     };\n-    { masks: $($type:ty,)* } => {\n+    { masks: $($type:ident,)* } => {\n         impl_fmt_trait! {\n             $($type =>\n               (Debug, format);\n@@ -74,32 +74,12 @@ macro_rules! impl_fmt_trait {\n \n impl_fmt_trait! {\n     integers:\n-        crate::u8x8,    crate::u8x16,    crate::u8x32,    crate::u8x64,\n-        crate::i8x8,    crate::i8x16,    crate::i8x32,    crate::i8x64,\n-        crate::u16x4,   crate::u16x8,   crate::u16x16,   crate::u16x32,\n-        crate::i16x4,   crate::i16x8,   crate::i16x16,   crate::i16x32,\n-        crate::u32x2,   crate::u32x4,   crate::u32x8,   crate::u32x16,\n-        crate::i32x2,   crate::i32x4,   crate::i32x8,   crate::i32x16,\n-        crate::u64x2,   crate::u64x4,   crate::u64x8,\n-        crate::i64x2,   crate::i64x4,   crate::i64x8,\n-        crate::u128x2,  crate::u128x4,\n-        crate::i128x2,  crate::i128x4,\n-        crate::usizex2, crate::usizex4, crate::usizex8,\n-        crate::isizex2, crate::isizex4, crate::isizex8,\n+        SimdU8, SimdU16, SimdU32, SimdU64, SimdU128,\n+        SimdI8, SimdI16, SimdI32, SimdI64, SimdI128,\n+        SimdUsize, SimdIsize,\n }\n \n impl_fmt_trait! {\n     floats:\n-        crate::f32x2, crate::f32x4, crate::f32x8, crate::f32x16,\n-        crate::f64x2, crate::f64x4, crate::f64x8,\n-}\n-\n-impl_fmt_trait! {\n-    masks:\n-        crate::mask8x8,    crate::mask8x16,    crate::mask8x32,    crate::mask8x64,\n-        crate::mask16x4,   crate::mask16x8,   crate::mask16x16,   crate::mask16x32,\n-        crate::mask32x2,   crate::mask32x4,   crate::mask32x8,   crate::mask32x16,\n-        crate::mask64x2,   crate::mask64x4,   crate::mask64x8,\n-        crate::mask128x2,  crate::mask128x4,\n-        crate::masksizex2, crate::masksizex4, crate::masksizex8,\n+        SimdF32, SimdF64,\n }"}, {"sha": "51689cd97bea480fb370dea37b316ea7f0837fab", "filename": "crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,7 +1,7 @@\n //! This module contains the LLVM intrinsics bindings that provide the functionality for this\n //! crate.\n //!\n-//! The LLVM assembly language is documented here: https://llvm.org/docs/LangRef.html\n+//! The LLVM assembly language is documented here: <https://llvm.org/docs/LangRef.html>\n \n /// These intrinsics aren't linked directly from LLVM and are mostly undocumented, however they are\n /// simply lowered to the matching LLVM instructions by the compiler.  The associated instruction\n@@ -45,4 +45,11 @@ extern \"platform-intrinsic\" {\n \n     // ceil\n     pub(crate) fn simd_ceil<T>(x: T) -> T;\n+\n+    pub(crate) fn simd_eq<T, U>(x: T, y: T) -> U;\n+    pub(crate) fn simd_ne<T, U>(x: T, y: T) -> U;\n+    pub(crate) fn simd_lt<T, U>(x: T, y: T) -> U;\n+    pub(crate) fn simd_le<T, U>(x: T, y: T) -> U;\n+    pub(crate) fn simd_gt<T, U>(x: T, y: T) -> U;\n+    pub(crate) fn simd_ge<T, U>(x: T, y: T) -> U;\n }"}, {"sha": "3a3346975c15e070a593ea0d019d468420d5b778", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,5 +1,5 @@\n #![no_std]\n-#![feature(repr_simd, platform_intrinsics, link_llvm_intrinsics, simd_ffi)]\n+#![feature(repr_simd, platform_intrinsics, link_llvm_intrinsics, simd_ffi, min_const_generics)]\n #![warn(missing_docs)]\n //! Portable SIMD module.\n \n@@ -9,6 +9,7 @@ mod macros;\n mod fmt;\n mod intrinsics;\n mod ops;\n+mod round;\n \n mod masks;\n pub use masks::*;\n@@ -43,18 +44,3 @@ mod vectors_f32;\n pub use vectors_f32::*;\n mod vectors_f64;\n pub use vectors_f64::*;\n-\n-mod vectors_mask8;\n-pub use vectors_mask8::*;\n-mod vectors_mask16;\n-pub use vectors_mask16::*;\n-mod vectors_mask32;\n-pub use vectors_mask32::*;\n-mod vectors_mask64;\n-pub use vectors_mask64::*;\n-mod vectors_mask128;\n-pub use vectors_mask128::*;\n-mod vectors_masksize;\n-pub use vectors_masksize::*;\n-\n-mod round;"}, {"sha": "7e4d851424908c1b0a3583aa913ee6270fb98e90", "filename": "crates/core_simd/src/macros.rs", "status": "modified", "additions": 89, "deletions": 240, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmacros.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -26,183 +26,123 @@ macro_rules! from_transmute_x86 {\n     }\n }\n \n-/// Calls a the macro `$mac` with the provided `$args` followed by `$repeat` repeated the specified\n-/// number of times.\n-macro_rules! call_repeat {\n-    { 1 => $mac:path [$($repeat:tt)*] $($args:tt)* } => {\n-        $mac! {\n-            $($args)*\n-            $($repeat)*\n-        }\n-    };\n-    { 2 => $mac:path [$($repeat:tt)*] $($args:tt)* } => {\n-        $mac! {\n-            $($args)*\n-            $($repeat)* $($repeat)*\n-        }\n-    };\n-    { 4 => $mac:path [$($repeat:tt)*] $($args:tt)* } => {\n-        $mac! {\n-            $($args)*\n-            $($repeat)* $($repeat)* $($repeat)* $($repeat)*\n-        }\n-    };\n-    { 8 => $mac:path [$($repeat:tt)*] $($args:tt)* } => {\n-        $mac! {\n-            $($args)*\n-            $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)*\n-        }\n-    };\n-    { 16 => $mac:path [$($repeat:tt)*] $($args:tt)* } => {\n-        $mac! {\n-            $($args)*\n-            $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)*\n-            $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)*\n-        }\n-    };\n-    { 32 => $mac:path [$($repeat:tt)*] $($args:tt)* } => {\n-        $mac! {\n-            $($args)*\n-            $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)*\n-            $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)*\n-            $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)*\n-            $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)*\n-        }\n-    };\n-    { 64 => $mac:path [$($repeat:tt)*] $($args:tt)* } => {\n-        $mac! {\n-            $($args)*\n-            $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)*\n-            $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)*\n-            $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)*\n-            $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)*\n-            $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)*\n-            $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)*\n-            $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)*\n-            $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)* $($repeat)*\n-        }\n-    };\n-}\n+/// Implements common traits on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n+macro_rules! impl_vector {\n+    { $name:ident, $type:ty } => {\n+        impl<const LANES: usize> $name<LANES> {\n+            /// Construct a SIMD vector by setting all lanes to the given value.\n+            pub const fn splat(value: $type) -> Self {\n+                Self([value; LANES])\n+            }\n \n-/// Calls the macro `$mac` with the specified `$args` followed by the specified number of unique\n-/// identifiers.\n-macro_rules! call_counting_args {\n-    { 1 => $mac:path => $($args:tt)* } => {\n-        $mac! {\n-            $($args)*\n-            value\n-        }\n-    };\n-    { 2 => $mac:path => $($args:tt)* } => {\n-        $mac! {\n-            $($args)*\n-            v0 v1\n-        }\n-    };\n-    { 4 => $mac:path => $($args:tt)* } => {\n-        $mac! {\n-            $($args)*\n-            v0 v1 v2 v3\n-        }\n-    };\n-    { 8 => $mac:path => $($args:tt)* } => {\n-        $mac! {\n-            $($args)*\n-            v0 v1 v2 v3 v4 v5 v6 v7\n-        }\n-    };\n-    { 16 => $mac:path => $($args:tt)* } => {\n-        $mac! {\n-            $($args)*\n-            v0 v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 v14 v15\n-        }\n-    };\n-    { 32 => $mac:path => $($args:tt)* } => {\n-        $mac! {\n-            $($args)*\n-            v0  v1  v2  v3  v4  v5  v6  v7  v8  v9  v10 v11 v12 v13 v14 v15\n-            v16 v17 v18 v19 v20 v21 v22 v23 v24 v25 v26 v27 v28 v29 v30 v31\n-        }\n-    };\n-    { 64 => $mac:path => $($args:tt)* } => {\n-        $mac! {\n-            $($args)*\n-            v0  v1  v2  v3  v4  v5  v6  v7  v8  v9  v10 v11 v12 v13 v14 v15\n-            v16 v17 v18 v19 v20 v21 v22 v23 v24 v25 v26 v27 v28 v29 v30 v31\n-            v32 v33 v34 v35 v36 v37 v38 v39 v40 v41 v42 v43 v44 v45 v46 v47\n-            v48 v49 v50 v51 v52 v53 v54 v55 v56 v57 v58 v59 v60 v61 v62 v63\n+            /// Returns a slice containing the entire SIMD vector.\n+            pub const fn as_slice(&self) -> &[$type] {\n+                &self.0\n+            }\n+\n+            /// Returns a mutable slice containing the entire SIMD vector.\n+            pub fn as_mut_slice(&mut self) -> &mut [$type] {\n+                &mut self.0\n+            }\n+\n+            /// Converts an array to a SIMD vector.\n+            pub const fn from_array(array: [$type; LANES]) -> Self {\n+                Self(array)\n+            }\n+\n+            /// Converts a SIMD vector to an array.\n+            pub const fn to_array(self) -> [$type; LANES] {\n+                // workaround for rust-lang/rust#80108\n+                // TODO fix this\n+                #[cfg(target_arch = \"wasm32\")]\n+                {\n+                    let mut arr = [self.0[0]; LANES];\n+                    let mut i = 0;\n+                    while i < LANES {\n+                        arr[i] = self.0[i];\n+                        i += 1;\n+                    }\n+                    arr\n+                }\n+\n+                #[cfg(not(target_arch = \"wasm32\"))]\n+                {\n+                    self.0\n+                }\n+            }\n         }\n-    };\n-}\n \n-/// Implements common traits on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n-macro_rules! base_vector_traits {\n-    { $name:path => [$type:ty; $lanes:literal] } => {\n-        impl Copy for $name {}\n+        impl<const LANES: usize> Copy for $name<LANES> {}\n \n-        impl Clone for $name {\n+        impl<const LANES: usize> Clone for $name<LANES> {\n             #[inline]\n             fn clone(&self) -> Self {\n                 *self\n             }\n         }\n \n-        impl Default for $name {\n+        impl<const LANES: usize> Default for $name<LANES> {\n             #[inline]\n             fn default() -> Self {\n                 Self::splat(<$type>::default())\n             }\n         }\n \n-        impl PartialEq for $name {\n+        impl<const LANES: usize> PartialEq for $name<LANES> {\n             #[inline]\n             fn eq(&self, other: &Self) -> bool {\n-                AsRef::<[$type]>::as_ref(self) == AsRef::<[$type]>::as_ref(other)\n+                // TODO use SIMD equality\n+                self.to_array() == other.to_array()\n             }\n         }\n \n-        impl PartialOrd for $name {\n+        impl<const LANES: usize> PartialOrd for $name<LANES> {\n             #[inline]\n             fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n-                AsRef::<[$type]>::as_ref(self).partial_cmp(AsRef::<[$type]>::as_ref(other))\n+                // TODO use SIMD equalitya\n+                self.to_array().partial_cmp(other.as_ref())\n             }\n         }\n \n         // array references\n-        impl AsRef<[$type; $lanes]> for $name {\n+        impl<const LANES: usize> AsRef<[$type; LANES]> for $name<LANES> {\n             #[inline]\n-            fn as_ref(&self) -> &[$type; $lanes] {\n-                unsafe { &*(self as *const _ as *const _) }\n+            fn as_ref(&self) -> &[$type; LANES] {\n+                &self.0\n             }\n         }\n \n-        impl AsMut<[$type; $lanes]> for $name {\n+        impl<const LANES: usize> AsMut<[$type; LANES]> for $name<LANES> {\n             #[inline]\n-            fn as_mut(&mut self) -> &mut [$type; $lanes] {\n-                unsafe { &mut *(self as *mut _ as *mut _) }\n+            fn as_mut(&mut self) -> &mut [$type; LANES] {\n+                &mut self.0\n             }\n         }\n \n         // slice references\n-        impl AsRef<[$type]> for $name {\n+        impl<const LANES: usize> AsRef<[$type]> for $name<LANES> {\n             #[inline]\n             fn as_ref(&self) -> &[$type] {\n-                AsRef::<[$type; $lanes]>::as_ref(self)\n+                &self.0\n             }\n         }\n \n-        impl AsMut<[$type]> for $name {\n+        impl<const LANES: usize> AsMut<[$type]> for $name<LANES> {\n             #[inline]\n             fn as_mut(&mut self) -> &mut [$type] {\n-                AsMut::<[$type; $lanes]>::as_mut(self)\n+                &mut self.0\n             }\n         }\n \n         // vector/array conversion\n-        from_transmute! { unsafe $name => [$type; $lanes] }\n+        impl<const LANES: usize> From<[$type; LANES]> for $name<LANES> {\n+            fn from(array: [$type; LANES]) -> Self {\n+                Self(array)\n+            }\n+        }\n \n         // splat\n-        impl From<$type> for $name {\n+        impl<const LANES: usize> From<$type> for $name<LANES> {\n             #[inline]\n             fn from(value: $type) -> Self {\n                 Self::splat(value)\n@@ -212,154 +152,63 @@ macro_rules! base_vector_traits {\n }\n \n /// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n-macro_rules! integer_vector_traits {\n-    { $name:path => [$type:ty; $lanes:literal] } => {\n-        impl Eq for $name {}\n+macro_rules! impl_integer_vector {\n+    { $name:ident, $type:ty } => {\n+        impl_vector! { $name, $type }\n \n-        impl Ord for $name {\n+        impl<const LANES: usize> Eq for $name<LANES> {}\n+\n+        impl<const LANES: usize> Ord for $name<LANES> {\n             #[inline]\n             fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n-                AsRef::<[$type]>::as_ref(self).cmp(AsRef::<[$type]>::as_ref(other))\n+                // TODO use SIMD cmp\n+                self.to_array().cmp(other.as_ref())\n             }\n         }\n \n-        impl core::hash::Hash for $name {\n+        impl<const LANES: usize> core::hash::Hash for $name<LANES> {\n             #[inline]\n             fn hash<H>(&self, state: &mut H)\n             where\n                 H: core::hash::Hasher\n             {\n-                AsRef::<[$type]>::as_ref(self).hash(state)\n+                self.as_slice().hash(state)\n             }\n         }\n     }\n }\n \n-/// Defines a vector `$name` containing multiple `$lanes` of `$type`.\n-macro_rules! define_vector {\n-    { $(#[$attr:meta])* struct $name:ident([$type:ty; $lanes:tt]); } => {\n-        call_repeat! { $lanes => define_vector [$type] def $(#[$attr])* | $name | }\n-\n-        impl $name {\n-            call_repeat! { $lanes => define_vector [$type] splat $type | }\n-            call_counting_args! { $lanes => define_vector => new $type | }\n-        }\n-\n-        base_vector_traits! { $name => [$type; $lanes] }\n-    };\n-    { def $(#[$attr:meta])* | $name:ident | $($itype:ty)* } => {\n-        $(#[$attr])*\n-        #[allow(non_camel_case_types)]\n-        #[repr(simd)]\n-        pub struct $name($($itype),*);\n-    };\n-    { splat $type:ty | $($itype:ty)* } => {\n-        /// Construct a vector by setting all lanes to the given value.\n-        #[inline]\n-        pub const fn splat(value: $type) -> Self {\n-            Self($(value as $itype),*)\n-        }\n-    };\n-    { new $type:ty | $($var:ident)* } => {\n-        /// Construct a vector by setting each lane to the given values.\n-        #[allow(clippy::too_many_arguments)]\n-        #[inline]\n-        pub const fn new($($var: $type),*) -> Self {\n-            Self($($var),*)\n-        }\n-    }\n-}\n-\n /// Implements inherent methods for a float vector `$name` containing multiple\n /// `$lanes` of float `$type`, which uses `$bits_ty` as its binary\n /// representation. Called from `define_float_vector!`.\n macro_rules! impl_float_vector {\n-    { $name:path => [$type:ty; $lanes:literal]; bits $bits_ty:ty; } => {\n-        impl $name {\n+    { $name:ident, $type:ty, $bits_ty:ident } => {\n+        impl_vector! { $name, $type }\n+\n+        impl<const LANES: usize> $name<LANES> {\n             /// Raw transmutation to an unsigned integer vector type with the\n             /// same size and number of lanes.\n             #[inline]\n-            pub fn to_bits(self) -> $bits_ty {\n-                unsafe { core::mem::transmute(self) }\n+            pub fn to_bits(self) -> crate::$bits_ty<LANES> {\n+                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<crate::$bits_ty<LANES>>());\n+                unsafe { core::mem::transmute_copy(&self) }\n             }\n \n             /// Raw transmutation from an unsigned integer vector type with the\n             /// same size and number of lanes.\n             #[inline]\n-            pub fn from_bits(bits: $bits_ty) -> Self {\n-                unsafe { core::mem::transmute(bits) }\n+            pub fn from_bits(bits: crate::$bits_ty<LANES>) -> Self {\n+                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<crate::$bits_ty<LANES>>());\n+                unsafe { core::mem::transmute_copy(&bits) }\n             }\n \n             /// Produces a vector where every lane has the absolute value of the\n             /// equivalently-indexed lane in `self`.\n             #[inline]\n             pub fn abs(self) -> Self {\n-                let no_sign = <$bits_ty>::splat(!0 >> 1);\n+                let no_sign = crate::$bits_ty::splat(!0 >> 1);\n                 Self::from_bits(self.to_bits() & no_sign)\n             }\n         }\n     };\n }\n-\n-/// Defines a float vector `$name` containing multiple `$lanes` of float\n-/// `$type`, which uses `$bits_ty` as its binary representation.\n-macro_rules! define_float_vector {\n-    { $(#[$attr:meta])* struct $name:ident([$type:ty; $lanes:tt]); bits $bits_ty:ty; } => {\n-        define_vector! {\n-            $(#[$attr])*\n-            struct $name([$type; $lanes]);\n-        }\n-\n-        impl_float_vector! { $name => [$type; $lanes]; bits $bits_ty; }\n-    }\n-}\n-\n-\n-/// Defines an integer vector `$name` containing multiple `$lanes` of integer `$type`.\n-macro_rules! define_integer_vector {\n-    { $(#[$attr:meta])* struct $name:ident([$type:ty; $lanes:tt]); } => {\n-        define_vector! {\n-            $(#[$attr])*\n-            struct $name([$type; $lanes]);\n-        }\n-\n-        integer_vector_traits! { $name => [$type; $lanes] }\n-    }\n-}\n-\n-/// Defines a mask vector `$name` containing multiple `$lanes` of `$type`, represented by the\n-/// underlying type `$impl_type`.\n-macro_rules! define_mask_vector {\n-    { $(#[$attr:meta])* struct $name:ident([$impl_type:ty as $type:ty; $lanes:tt]); } => {\n-        call_repeat! { $lanes => define_mask_vector [$impl_type] def $(#[$attr])* | $name | }\n-\n-        impl $name {\n-            call_repeat! { $lanes => define_mask_vector [$impl_type] splat $type | }\n-            call_counting_args! { $lanes => define_mask_vector => new $type | }\n-        }\n-\n-        base_vector_traits! { $name => [$type; $lanes] }\n-        integer_vector_traits! { $name => [$type; $lanes] }\n-    };\n-    { def $(#[$attr:meta])* | $name:ident | $($itype:ty)* } => {\n-        $(#[$attr])*\n-        #[allow(non_camel_case_types)]\n-        #[repr(simd)]\n-        pub struct $name($($itype),*);\n-    };\n-    { splat $type:ty | $($itype:ty)* } => {\n-        /// Construct a vector by setting all lanes to the given value.\n-        #[inline]\n-        pub const fn splat(value: $type) -> Self {\n-            Self($(value.0 as $itype),*)\n-        }\n-    };\n-    { new $type:ty | $($var:ident)* } => {\n-        /// Construct a vector by setting each lane to the given values.\n-        #[allow(clippy::too_many_arguments)]\n-        #[inline]\n-        pub const fn new($($var: $type),*) -> Self {\n-            Self($($var.0),*)\n-        }\n-    }\n-}"}, {"sha": "cba76b6a2a35d73e04b8d78b973a763cb237a12d", "filename": "crates/core_simd/src/masks.rs", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/d72927c85b1ae34e1115a19897d93b8dcf59e44d/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d72927c85b1ae34e1115a19897d93b8dcf59e44d/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=d72927c85b1ae34e1115a19897d93b8dcf59e44d", "patch": "@@ -1,124 +0,0 @@\n-/// The error type returned when converting an integer to a mask fails.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub struct TryFromMaskError(());\n-\n-impl core::fmt::Display for TryFromMaskError {\n-    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-        write!(f, \"mask must have all bits set or unset\")\n-    }\n-}\n-\n-macro_rules! define_mask {\n-    { $(#[$attr:meta])* struct $name:ident($type:ty); } => {\n-        $(#[$attr])*\n-        #[allow(non_camel_case_types)]\n-        #[derive(Copy, Clone, Default, PartialEq, PartialOrd, Eq, Ord, Hash)]\n-        #[repr(transparent)]\n-        pub struct $name(pub(crate) $type);\n-\n-        impl $name {\n-            /// Construct a mask from the given value.\n-            pub const fn new(value: bool) -> Self {\n-                if value {\n-                    Self(!0)\n-                } else {\n-                    Self(0)\n-                }\n-            }\n-\n-            /// Test if the mask is set.\n-            pub const fn test(&self) -> bool {\n-                self.0 != 0\n-            }\n-        }\n-\n-        impl core::convert::From<bool> for $name {\n-            fn from(value: bool) -> Self {\n-                Self::new(value)\n-            }\n-        }\n-\n-        impl core::convert::From<$name> for bool {\n-            fn from(mask: $name) -> Self {\n-                mask.test()\n-            }\n-        }\n-\n-        impl core::convert::TryFrom<$type> for $name {\n-            type Error = TryFromMaskError;\n-            fn try_from(value: $type) -> Result<Self, Self::Error> {\n-                if value == 0 || !value == 0 {\n-                    Ok(Self(value))\n-                } else {\n-                    Err(TryFromMaskError(()))\n-                }\n-            }\n-        }\n-\n-        impl core::convert::From<$name> for $type {\n-            fn from(value: $name) -> Self {\n-                value.0\n-            }\n-        }\n-\n-        impl core::fmt::Debug for $name {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                self.test().fmt(f)\n-            }\n-        }\n-\n-        impl core::fmt::Binary for $name {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                <$type as core::fmt::Binary>::fmt(&self.0, f)\n-            }\n-        }\n-\n-        impl core::fmt::Octal for $name {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                <$type as core::fmt::Octal>::fmt(&self.0, f)\n-            }\n-        }\n-\n-        impl core::fmt::LowerHex for $name {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                <$type as core::fmt::LowerHex>::fmt(&self.0, f)\n-            }\n-        }\n-\n-        impl core::fmt::UpperHex for $name {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                <$type as core::fmt::UpperHex>::fmt(&self.0, f)\n-            }\n-        }\n-    }\n-}\n-\n-define_mask! {\n-    /// 8-bit mask\n-    struct mask8(i8);\n-}\n-\n-define_mask! {\n-    /// 16-bit mask\n-    struct mask16(i16);\n-}\n-\n-define_mask! {\n-    /// 32-bit mask\n-    struct mask32(i32);\n-}\n-\n-define_mask! {\n-    /// 64-bit mask\n-    struct mask64(i64);\n-}\n-\n-define_mask! {\n-    /// 128-bit mask\n-    struct mask128(i128);\n-}\n-\n-define_mask! {\n-    /// `isize`-wide mask\n-    struct masksize(isize);\n-}"}, {"sha": "eac5178512e52f894075ffed57011319e4599088", "filename": "crates/core_simd/src/masks/full_masks/mod.rs", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fmod.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -0,0 +1,205 @@\n+//! Masks that take up full SIMD vector registers.\n+\n+/// The error type returned when converting an integer to a mask fails.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub struct TryFromMaskError(());\n+\n+impl core::fmt::Display for TryFromMaskError {\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        write!(f, \"mask vector must have all bits set or unset in each lane\")\n+    }\n+}\n+\n+macro_rules! define_mask {\n+    { $(#[$attr:meta])* struct $name:ident<const $lanes:ident: usize>($type:ty); } => {\n+        $(#[$attr])*\n+        #[derive(Copy, Clone, Default, PartialEq, PartialOrd, Eq, Ord, Hash)]\n+        #[repr(transparent)]\n+        pub struct $name<const $lanes: usize>($type);\n+\n+        delegate_ops_to_inner! { $name }\n+\n+        impl<const $lanes: usize> $name<$lanes> {\n+            /// Construct a mask by setting all lanes to the given value.\n+            pub fn splat(value: bool) -> Self {\n+                Self(<$type>::splat(\n+                    if value {\n+                        -1\n+                    } else {\n+                        0\n+                    }\n+                ))\n+            }\n+\n+            /// Tests the value of the specified lane.\n+            ///\n+            /// # Panics\n+            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+            #[inline]\n+            pub fn test(&self, lane: usize) -> bool {\n+                self.0[lane] == -1\n+            }\n+\n+            /// Sets the value of the specified lane.\n+            ///\n+            /// # Panics\n+            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+            #[inline]\n+            pub fn set(&mut self, lane: usize, value: bool) {\n+                self.0[lane] = if value {\n+                    -1\n+                } else {\n+                    0\n+                }\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::convert::From<bool> for $name<$lanes> {\n+            fn from(value: bool) -> Self {\n+                Self::splat(value)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::convert::TryFrom<$type> for $name<$lanes> {\n+            type Error = TryFromMaskError;\n+            fn try_from(value: $type) -> Result<Self, Self::Error> {\n+                if value.as_slice().iter().all(|x| *x == 0 || *x == -1) {\n+                    Ok(Self(value))\n+                } else {\n+                    Err(TryFromMaskError(()))\n+                }\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::convert::From<$name<$lanes>> for $type {\n+            fn from(value: $name<$lanes>) -> Self {\n+                value.0\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::Debug for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                f.debug_list()\n+                    .entries((0..LANES).map(|lane| self.test(lane)))\n+                    .finish()\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::Binary for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                core::fmt::Binary::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::Octal for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                core::fmt::Octal::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::LowerHex for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                core::fmt::LowerHex::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::UpperHex for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                core::fmt::UpperHex::fmt(&self.0, f)\n+            }\n+        }\n+    }\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdI8](crate::SimdI8), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdI8Mask<const LANES: usize>(crate::SimdI8<LANES>);\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdI16](crate::SimdI16), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdI16Mask<const LANES: usize>(crate::SimdI16<LANES>);\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdI32](crate::SimdI32), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdI32Mask<const LANES: usize>(crate::SimdI32<LANES>);\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdI64](crate::SimdI64), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdI64Mask<const LANES: usize>(crate::SimdI64<LANES>);\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdI128](crate::SimdI128), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdI128Mask<const LANES: usize>(crate::SimdI64<LANES>);\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdIsize](crate::SimdIsize), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdIsizeMask<const LANES: usize>(crate::SimdI64<LANES>);\n+}\n+\n+macro_rules! implement_mask_ext {\n+    { $($vector:ident => $mask:ident,)* } => {\n+        $(\n+            impl<const LANES: usize> crate::masks::MaskExt<$mask<LANES>> for crate::$vector<LANES> {\n+                #[inline]\n+                fn lanes_eq(&self, other: &Self) -> $mask<LANES> {\n+                    unsafe { crate::intrinsics::simd_eq(self, other) }\n+                }\n+\n+                #[inline]\n+                fn lanes_ne(&self, other: &Self) -> $mask<LANES> {\n+                    unsafe { crate::intrinsics::simd_ne(self, other) }\n+                }\n+\n+                #[inline]\n+                fn lanes_lt(&self, other: &Self) -> $mask<LANES> {\n+                    unsafe { crate::intrinsics::simd_lt(self, other) }\n+                }\n+\n+                #[inline]\n+                fn lanes_gt(&self, other: &Self) -> $mask<LANES> {\n+                    unsafe { crate::intrinsics::simd_gt(self, other) }\n+                }\n+\n+                #[inline]\n+                fn lanes_le(&self, other: &Self) -> $mask<LANES> {\n+                    unsafe { crate::intrinsics::simd_le(self, other) }\n+                }\n+\n+                #[inline]\n+                fn lanes_ge(&self, other: &Self) -> $mask<LANES> {\n+                    unsafe { crate::intrinsics::simd_ge(self, other) }\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+implement_mask_ext! {\n+    SimdI8 => SimdI8Mask,\n+    SimdI16 => SimdI16Mask,\n+    SimdI32 => SimdI32Mask,\n+    SimdI64 => SimdI64Mask,\n+    SimdI128 => SimdI128Mask,\n+    SimdIsize => SimdIsizeMask,\n+\n+    SimdU8 => SimdI8Mask,\n+    SimdU16 => SimdI16Mask,\n+    SimdU32 => SimdI32Mask,\n+    SimdU64 => SimdI64Mask,\n+    SimdU128 => SimdI128Mask,\n+    SimdUsize => SimdIsizeMask,\n+\n+    SimdF32 => SimdI32Mask,\n+    SimdF64 => SimdI64Mask,\n+}"}, {"sha": "a075040affe72b45297b2bdb6f104543811be1c3", "filename": "crates/core_simd/src/masks/mod.rs", "status": "added", "additions": 391, "deletions": 0, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -0,0 +1,391 @@\n+//! Types and traits associated with masking lanes of vectors.\n+#![allow(non_camel_case_types)]\n+\n+/// Implements bitwise ops on mask types by delegating the operators to the inner type.\n+macro_rules! delegate_ops_to_inner {\n+    { $name:ident } => {\n+        impl<const LANES: usize> core::ops::BitAnd for $name<LANES> {\n+            type Output = Self;\n+            #[inline]\n+            fn bitand(self, rhs: Self) -> Self {\n+                Self(self.0 & rhs.0)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES> {\n+            type Output = Self;\n+            #[inline]\n+            fn bitand(self, rhs: bool) -> Self {\n+                self & Self::splat(rhs)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool {\n+            type Output = $name<LANES>;\n+            #[inline]\n+            fn bitand(self, rhs: $name<LANES>) -> $name<LANES> {\n+                $name::<LANES>::splat(self) & rhs\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitOr for $name<LANES> {\n+            type Output = Self;\n+            #[inline]\n+            fn bitor(self, rhs: Self) -> Self {\n+                Self(self.0 | rhs.0)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES> {\n+            type Output = Self;\n+            #[inline]\n+            fn bitor(self, rhs: bool) -> Self {\n+                self | Self::splat(rhs)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool {\n+            type Output = $name<LANES>;\n+            #[inline]\n+            fn bitor(self, rhs: $name<LANES>) -> $name<LANES> {\n+                $name::<LANES>::splat(self) | rhs\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitXor for $name<LANES> {\n+            type Output = Self;\n+            #[inline]\n+            fn bitxor(self, rhs: Self) -> Self::Output {\n+                Self(self.0 ^ rhs.0)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES> {\n+            type Output = Self;\n+            #[inline]\n+            fn bitxor(self, rhs: bool) -> Self::Output {\n+                self ^ Self::splat(rhs)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool {\n+            type Output = $name<LANES>;\n+            #[inline]\n+            fn bitxor(self, rhs: $name<LANES>) -> Self::Output {\n+                $name::<LANES>::splat(self) ^ rhs\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::Not for $name<LANES> {\n+            type Output = $name<LANES>;\n+            #[inline]\n+            fn not(self) -> Self::Output {\n+                Self(!self.0)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES> {\n+            #[inline]\n+            fn bitand_assign(&mut self, rhs: Self) {\n+                self.0 &= rhs.0;\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES> {\n+            #[inline]\n+            fn bitand_assign(&mut self, rhs: bool) {\n+                *self &= Self::splat(rhs);\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES> {\n+            #[inline]\n+            fn bitor_assign(&mut self, rhs: Self) {\n+                self.0 |= rhs.0;\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES> {\n+            #[inline]\n+            fn bitor_assign(&mut self, rhs: bool) {\n+                *self |= Self::splat(rhs);\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES> {\n+            #[inline]\n+            fn bitxor_assign(&mut self, rhs: Self) {\n+                self.0 ^= rhs.0;\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES> {\n+            #[inline]\n+            fn bitxor_assign(&mut self, rhs: bool) {\n+                *self ^= Self::splat(rhs);\n+            }\n+        }\n+    }\n+}\n+\n+pub mod full_masks;\n+\n+macro_rules! define_opaque_mask {\n+    {\n+        $(#[$attr:meta])*\n+        struct $name:ident<const $lanes:ident: usize>($inner_ty:ty);\n+    } => {\n+        $(#[$attr])*\n+        #[allow(non_camel_case_types)]\n+        pub struct $name<const $lanes: usize>($inner_ty);\n+\n+        delegate_ops_to_inner! { $name }\n+\n+        impl<const $lanes: usize> $name<$lanes> {\n+            /// Construct a mask by setting all lanes to the given value.\n+            pub fn splat(value: bool) -> Self {\n+                Self(<$inner_ty>::splat(value))\n+            }\n+\n+            /// Tests the value of the specified lane.\n+            ///\n+            /// # Panics\n+            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+            #[inline]\n+            pub fn test(&self, lane: usize) -> bool {\n+                self.0.test(lane)\n+            }\n+\n+            /// Sets the value of the specified lane.\n+            ///\n+            /// # Panics\n+            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+            #[inline]\n+            pub fn set(&mut self, lane: usize, value: bool) {\n+                self.0.set(lane, value);\n+            }\n+        }\n+\n+        impl<const $lanes: usize> Copy for $name<$lanes> {}\n+\n+        impl<const $lanes: usize> Clone for $name<$lanes> {\n+            #[inline]\n+            fn clone(&self) -> Self {\n+                *self\n+            }\n+        }\n+\n+        impl<const $lanes: usize> Default for $name<$lanes> {\n+            #[inline]\n+            fn default() -> Self {\n+                Self::splat(false)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> PartialEq for $name<$lanes> {\n+            #[inline]\n+            fn eq(&self, other: &Self) -> bool {\n+                self.0 == other.0\n+            }\n+        }\n+\n+        impl<const $lanes: usize> PartialOrd for $name<$lanes> {\n+            #[inline]\n+            fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+                self.0.partial_cmp(&other.0)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::Debug for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                core::fmt::Debug::fmt(&self.0, f)\n+            }\n+        }\n+    };\n+}\n+\n+define_opaque_mask! {\n+    /// Mask for vectors with `LANES` 8-bit elements.\n+    ///\n+    /// The layout of this type is unspecified.\n+    struct Mask8<const LANES: usize>(full_masks::SimdI8Mask<LANES>);\n+}\n+\n+define_opaque_mask! {\n+    /// Mask for vectors with `LANES` 16-bit elements.\n+    ///\n+    /// The layout of this type is unspecified.\n+    struct Mask16<const LANES: usize>(full_masks::SimdI16Mask<LANES>);\n+}\n+\n+define_opaque_mask! {\n+    /// Mask for vectors with `LANES` 32-bit elements.\n+    ///\n+    /// The layout of this type is unspecified.\n+    struct Mask32<const LANES: usize>(full_masks::SimdI32Mask<LANES>);\n+}\n+\n+define_opaque_mask! {\n+    /// Mask for vectors with `LANES` 64-bit elements.\n+    ///\n+    /// The layout of this type is unspecified.\n+    struct Mask64<const LANES: usize>(full_masks::SimdI64Mask<LANES>);\n+}\n+\n+define_opaque_mask! {\n+    /// Mask for vectors with `LANES` 128-bit elements.\n+    ///\n+    /// The layout of this type is unspecified.\n+    struct Mask128<const LANES: usize>(full_masks::SimdI128Mask<LANES>);\n+}\n+\n+define_opaque_mask! {\n+    /// Mask for vectors with `LANES` pointer-width elements.\n+    ///\n+    /// The layout of this type is unspecified.\n+    struct MaskSize<const LANES: usize>(full_masks::SimdIsizeMask<LANES>);\n+}\n+\n+/// Mask-related operations using a particular mask layout.\n+pub trait MaskExt<Mask> {\n+    /// Test if each lane is equal to the corresponding lane in `other`.\n+    fn lanes_eq(&self, other: &Self) -> Mask;\n+\n+    /// Test if each lane is not equal to the corresponding lane in `other`.\n+    fn lanes_ne(&self, other: &Self) -> Mask;\n+\n+    /// Test if each lane is less than the corresponding lane in `other`.\n+    fn lanes_lt(&self, other: &Self) -> Mask;\n+\n+    /// Test if each lane is greater than the corresponding lane in `other`.\n+    fn lanes_gt(&self, other: &Self) -> Mask;\n+\n+    /// Test if each lane is less than or equal to the corresponding lane in `other`.\n+    fn lanes_le(&self, other: &Self) -> Mask;\n+\n+    /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n+    fn lanes_ge(&self, other: &Self) -> Mask;\n+}\n+\n+macro_rules! implement_mask_ops {\n+    { $($vector:ident => $mask:ident,)* } => {\n+        $(\n+            impl<const LANES: usize> crate::$vector<LANES> {\n+                /// Test if each lane is equal to the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_eq(&self, other: &Self) -> $mask<LANES> {\n+                    $mask(MaskExt::lanes_eq(self, other))\n+                }\n+\n+                /// Test if each lane is not equal to the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_ne(&self, other: &Self) -> $mask<LANES> {\n+                    $mask(MaskExt::lanes_ne(self, other))\n+                }\n+\n+                /// Test if each lane is less than the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_lt(&self, other: &Self) -> $mask<LANES> {\n+                    $mask(MaskExt::lanes_lt(self, other))\n+                }\n+\n+                /// Test if each lane is greater than the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_gt(&self, other: &Self) -> $mask<LANES> {\n+                    $mask(MaskExt::lanes_gt(self, other))\n+                }\n+\n+                /// Test if each lane is less than or equal to the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_le(&self, other: &Self) -> $mask<LANES> {\n+                    $mask(MaskExt::lanes_le(self, other))\n+                }\n+\n+                /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_ge(&self, other: &Self) -> $mask<LANES> {\n+                    $mask(MaskExt::lanes_ge(self, other))\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+implement_mask_ops! {\n+    SimdI8 => Mask8,\n+    SimdI16 => Mask16,\n+    SimdI32 => Mask32,\n+    SimdI64 => Mask64,\n+    SimdI128 => Mask128,\n+    SimdIsize => MaskSize,\n+\n+    SimdU8 => Mask8,\n+    SimdU16 => Mask16,\n+    SimdU32 => Mask32,\n+    SimdU64 => Mask64,\n+    SimdU128 => Mask128,\n+    SimdUsize => MaskSize,\n+\n+    SimdF32 => Mask32,\n+    SimdF64 => Mask64,\n+}\n+\n+/// Vector of eight 8-bit masks\n+pub type mask8x8 = Mask8<8>;\n+\n+/// Vector of 16 8-bit masks\n+pub type mask8x16 = Mask8<16>;\n+\n+/// Vector of 32 8-bit masks\n+pub type mask8x32 = Mask8<32>;\n+\n+/// Vector of 16 8-bit masks\n+pub type mask8x64 = Mask8<64>;\n+\n+/// Vector of four 16-bit masks\n+pub type mask16x4 = Mask16<4>;\n+\n+/// Vector of eight 16-bit masks\n+pub type mask16x8 = Mask16<8>;\n+\n+/// Vector of 16 16-bit masks\n+pub type mask16x16 = Mask16<16>;\n+\n+/// Vector of 32 16-bit masks\n+pub type mask16x32 = Mask32<32>;\n+\n+/// Vector of two 32-bit masks\n+pub type mask32x2 = Mask32<2>;\n+\n+/// Vector of four 32-bit masks\n+pub type mask32x4 = Mask32<4>;\n+\n+/// Vector of eight 32-bit masks\n+pub type mask32x8 = Mask32<8>;\n+\n+/// Vector of 16 32-bit masks\n+pub type mask32x16 = Mask32<16>;\n+\n+/// Vector of two 64-bit masks\n+pub type mask64x2 = Mask64<2>;\n+\n+/// Vector of four 64-bit masks\n+pub type mask64x4 = Mask64<4>;\n+\n+/// Vector of eight 64-bit masks\n+pub type mask64x8 = Mask64<8>;\n+\n+/// Vector of two 128-bit masks\n+pub type mask128x2 = Mask128<2>;\n+\n+/// Vector of four 128-bit masks\n+pub type mask128x4 = Mask128<4>;\n+\n+/// Vector of two pointer-width masks\n+pub type masksizex2 = MaskSize<2>;\n+\n+/// Vector of four pointer-width masks\n+pub type masksizex4 = MaskSize<4>;\n+\n+/// Vector of eight pointer-width masks\n+pub type masksizex8 = MaskSize<8>;"}, {"sha": "a21e9ab5bf1e02362da3ef718ef19ca38ce8fafd", "filename": "crates/core_simd/src/ops.rs", "status": "modified", "additions": 98, "deletions": 190, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -12,21 +12,21 @@ where\n macro_rules! impl_ref_ops {\n     // binary op\n     {\n-        impl core::ops::$trait:ident<$rhs:ty> for $type:ty {\n+        impl<const $lanes:ident: usize> core::ops::$trait:ident<$rhs:ty> for $type:ty {\n             type Output = $output:ty;\n \n             $(#[$attrs:meta])*\n             fn $fn:ident($self_tok:ident, $rhs_arg:ident: $rhs_arg_ty:ty) -> Self::Output $body:tt\n         }\n     } => {\n-        impl core::ops::$trait<$rhs> for $type {\n+        impl<const $lanes: usize> core::ops::$trait<$rhs> for $type {\n             type Output = $output;\n \n             $(#[$attrs])*\n             fn $fn($self_tok, $rhs_arg: $rhs_arg_ty) -> Self::Output $body\n         }\n \n-        impl core::ops::$trait<&'_ $rhs> for $type {\n+        impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for $type {\n             type Output = <$type as core::ops::$trait<$rhs>>::Output;\n \n             $(#[$attrs])*\n@@ -35,7 +35,7 @@ macro_rules! impl_ref_ops {\n             }\n         }\n \n-        impl core::ops::$trait<$rhs> for &'_ $type {\n+        impl<const $lanes: usize> core::ops::$trait<$rhs> for &'_ $type {\n             type Output = <$type as core::ops::$trait<$rhs>>::Output;\n \n             $(#[$attrs])*\n@@ -44,7 +44,7 @@ macro_rules! impl_ref_ops {\n             }\n         }\n \n-        impl core::ops::$trait<&'_ $rhs> for &'_ $type {\n+        impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for &'_ $type {\n             type Output = <$type as core::ops::$trait<$rhs>>::Output;\n \n             $(#[$attrs])*\n@@ -56,17 +56,17 @@ macro_rules! impl_ref_ops {\n \n     // binary assignment op\n     {\n-        impl core::ops::$trait:ident<$rhs:ty> for $type:ty {\n+        impl<const $lanes:ident: usize> core::ops::$trait:ident<$rhs:ty> for $type:ty {\n             $(#[$attrs:meta])*\n             fn $fn:ident(&mut $self_tok:ident, $rhs_arg:ident: $rhs_arg_ty:ty) $body:tt\n         }\n     } => {\n-        impl core::ops::$trait<$rhs> for $type {\n+        impl<const $lanes: usize> core::ops::$trait<$rhs> for $type {\n             $(#[$attrs])*\n             fn $fn(&mut $self_tok, $rhs_arg: $rhs_arg_ty) $body\n         }\n \n-        impl core::ops::$trait<&'_ $rhs> for $type {\n+        impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for $type {\n             $(#[$attrs])*\n             fn $fn(&mut $self_tok, $rhs_arg: &$rhs_arg_ty) {\n                 core::ops::$trait::$fn($self_tok, *$rhs_arg)\n@@ -76,17 +76,17 @@ macro_rules! impl_ref_ops {\n \n     // unary op\n     {\n-        impl core::ops::$trait:ident for $type:ty {\n+        impl<const $lanes:ident: usize> core::ops::$trait:ident for $type:ty {\n             type Output = $output:ty;\n             fn $fn:ident($self_tok:ident) -> Self::Output $body:tt\n         }\n     } => {\n-        impl core::ops::$trait for $type {\n+        impl<const $lanes: usize> core::ops::$trait for $type {\n             type Output = $output;\n             fn $fn($self_tok) -> Self::Output $body\n         }\n \n-        impl core::ops::$trait for &'_ $type {\n+        impl<const $lanes: usize> core::ops::$trait for &'_ $type {\n             type Output = <$type as core::ops::$trait>::Output;\n             fn $fn($self_tok) -> Self::Output {\n                 core::ops::$trait::$fn(*$self_tok)\n@@ -95,144 +95,76 @@ macro_rules! impl_ref_ops {\n     }\n }\n \n-/// Implements op traits for masks\n-macro_rules! impl_mask_ops {\n-    { $($mask:ty),* } => {\n-        $(\n-            impl_ref_ops! {\n-                impl core::ops::BitAnd<$mask> for $mask {\n-                    type Output = Self;\n-                    fn bitand(self, rhs: Self) -> Self::Output {\n-                        Self(self.0 & rhs.0)\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl core::ops::BitAndAssign<$mask> for $mask {\n-                    fn bitand_assign(&mut self, rhs: Self) {\n-                        *self = *self & rhs;\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl core::ops::BitOr<$mask> for $mask {\n-                    type Output = Self;\n-                    fn bitor(self, rhs: Self) -> Self::Output {\n-                        Self(self.0 | rhs.0)\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl core::ops::BitOrAssign<$mask> for $mask {\n-                    fn bitor_assign(&mut self, rhs: Self) {\n-                        *self = *self | rhs;\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl core::ops::BitXor<$mask> for $mask {\n-                    type Output = Self;\n-                    fn bitxor(self, rhs: Self) -> Self::Output {\n-                        Self(self.0 ^ rhs.0)\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl core::ops::BitXorAssign<$mask> for $mask {\n-                    fn bitxor_assign(&mut self, rhs: Self) {\n-                        *self = *self ^ rhs;\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl core::ops::Not for $mask {\n-                    type Output = Self;\n-                    fn not(self) -> Self::Output {\n-                        Self(!self.0)\n-                    }\n-                }\n-            }\n-        )*\n-    }\n-}\n-impl_mask_ops! { crate::mask8, crate::mask16, crate::mask32, crate::mask64, crate::mask128, crate::masksize }\n-\n /// Automatically implements operators over vectors and scalars for a particular vector.\n macro_rules! impl_op {\n-    { impl Add for $type:ty, $scalar:ty } => {\n+    { impl Add for $type:ident, $scalar:ty } => {\n         impl_op! { @binary $type, $scalar, Add::add, AddAssign::add_assign, simd_add }\n     };\n-    { impl Sub for $type:ty, $scalar:ty } => {\n+    { impl Sub for $type:ident, $scalar:ty } => {\n         impl_op! { @binary $type, $scalar, Sub::sub, SubAssign::sub_assign, simd_sub }\n     };\n-    { impl Mul for $type:ty, $scalar:ty } => {\n+    { impl Mul for $type:ident, $scalar:ty } => {\n         impl_op! { @binary $type, $scalar, Mul::mul, MulAssign::mul_assign, simd_mul }\n     };\n-    { impl Div for $type:ty, $scalar:ty } => {\n+    { impl Div for $type:ident, $scalar:ty } => {\n         impl_op! { @binary $type, $scalar, Div::div, DivAssign::div_assign, simd_div }\n     };\n-    { impl Rem for $type:ty, $scalar:ty } => {\n+    { impl Rem for $type:ident, $scalar:ty } => {\n         impl_op! { @binary $type, $scalar, Rem::rem, RemAssign::rem_assign, simd_rem }\n     };\n-    { impl Shl for $type:ty, $scalar:ty } => {\n+    { impl Shl for $type:ident, $scalar:ty } => {\n         impl_op! { @binary $type, $scalar, Shl::shl, ShlAssign::shl_assign, simd_shl }\n     };\n-    { impl Shr for $type:ty, $scalar:ty } => {\n+    { impl Shr for $type:ident, $scalar:ty } => {\n         impl_op! { @binary $type, $scalar, Shr::shr, ShrAssign::shr_assign, simd_shr }\n     };\n-    { impl BitAnd for $type:ty, $scalar:ty } => {\n+    { impl BitAnd for $type:ident, $scalar:ty } => {\n         impl_op! { @binary $type, $scalar, BitAnd::bitand, BitAndAssign::bitand_assign, simd_and }\n     };\n-    { impl BitOr for $type:ty, $scalar:ty } => {\n+    { impl BitOr for $type:ident, $scalar:ty } => {\n         impl_op! { @binary $type, $scalar, BitOr::bitor, BitOrAssign::bitor_assign, simd_or }\n     };\n-    { impl BitXor for $type:ty, $scalar:ty } => {\n+    { impl BitXor for $type:ident, $scalar:ty } => {\n         impl_op! { @binary $type, $scalar, BitXor::bitxor, BitXorAssign::bitxor_assign, simd_xor }\n     };\n \n-    { impl Not for $type:ty, $scalar:ty } => {\n+    { impl Not for $type:ident, $scalar:ty } => {\n         impl_ref_ops! {\n-            impl core::ops::Not for $type {\n+            impl<const LANES: usize> core::ops::Not for crate::$type<LANES> {\n                 type Output = Self;\n                 fn not(self) -> Self::Output {\n-                    self ^ <$type>::splat(!<$scalar>::default())\n+                    self ^ Self::splat(!<$scalar>::default())\n                 }\n             }\n         }\n     };\n \n-    { impl Neg for $type:ty, $scalar:ty } => {\n+    { impl Neg for $type:ident, $scalar:ty } => {\n         impl_ref_ops! {\n-            impl core::ops::Neg for $type {\n+            impl<const LANES: usize> core::ops::Neg for crate::$type<LANES> {\n                 type Output = Self;\n                 fn neg(self) -> Self::Output {\n-                    <$type>::splat(0) - self\n+                    Self::splat(0) - self\n                 }\n             }\n         }\n     };\n \n-    { impl Neg for $type:ty, $scalar:ty, @float } => {\n+    { impl Neg for $type:ident, $scalar:ty, @float } => {\n         impl_ref_ops! {\n-            impl core::ops::Neg for $type {\n+            impl<const LANES: usize> core::ops::Neg for crate::$type<LANES> {\n                 type Output = Self;\n                 fn neg(self) -> Self::Output {\n                     // FIXME: Replace this with fneg intrinsic once available.\n                     // https://github.com/rust-lang/stdsimd/issues/32\n-                    Self::from_bits(<$type>::splat(-0.0).to_bits() ^ self.to_bits())\n+                    Self::from_bits(Self::splat(-0.0).to_bits() ^ self.to_bits())\n                 }\n             }\n         }\n     };\n \n-    { impl Index for $type:ty, $scalar:ty } => {\n-        impl<I> core::ops::Index<I> for $type\n+    { impl Index for $type:ident, $scalar:ty } => {\n+        impl<I, const LANES: usize> core::ops::Index<I> for crate::$type<LANES>\n         where\n             I: core::slice::SliceIndex<[$scalar]>,\n         {\n@@ -243,7 +175,7 @@ macro_rules! impl_op {\n             }\n         }\n \n-        impl<I> core::ops::IndexMut<I> for $type\n+        impl<I, const LANES: usize> core::ops::IndexMut<I> for crate::$type<LANES>\n         where\n             I: core::slice::SliceIndex<[$scalar]>,\n         {\n@@ -255,13 +187,13 @@ macro_rules! impl_op {\n     };\n \n     // generic binary op with assignment when output is `Self`\n-    { @binary $type:ty, $scalar:ty, $trait:ident :: $trait_fn:ident, $assign_trait:ident :: $assign_trait_fn:ident, $intrinsic:ident } => {\n+    { @binary $type:ident, $scalar:ty, $trait:ident :: $trait_fn:ident, $assign_trait:ident :: $assign_trait_fn:ident, $intrinsic:ident } => {\n         impl_ref_ops! {\n-            impl core::ops::$trait<$type> for $type {\n-                type Output = $type;\n+            impl<const LANES: usize> core::ops::$trait<Self> for crate::$type<LANES> {\n+                type Output = Self;\n \n                 #[inline]\n-                fn $trait_fn(self, rhs: $type) -> Self::Output {\n+                fn $trait_fn(self, rhs: Self) -> Self::Output {\n                     unsafe {\n                         crate::intrinsics::$intrinsic(self, rhs)\n                     }\n@@ -270,31 +202,31 @@ macro_rules! impl_op {\n         }\n \n         impl_ref_ops! {\n-            impl core::ops::$trait<$scalar> for $type {\n-                type Output = $type;\n+            impl<const LANES: usize> core::ops::$trait<$scalar> for crate::$type<LANES> {\n+                type Output = Self;\n \n                 #[inline]\n                 fn $trait_fn(self, rhs: $scalar) -> Self::Output {\n-                    core::ops::$trait::$trait_fn(self, <$type>::splat(rhs))\n+                    core::ops::$trait::$trait_fn(self, Self::splat(rhs))\n                 }\n             }\n         }\n \n         impl_ref_ops! {\n-            impl core::ops::$trait<$type> for $scalar {\n-                type Output = $type;\n+            impl<const LANES: usize> core::ops::$trait<crate::$type<LANES>> for $scalar {\n+                type Output = crate::$type<LANES>;\n \n                 #[inline]\n-                fn $trait_fn(self, rhs: $type) -> Self::Output {\n-                    core::ops::$trait::$trait_fn(<$type>::splat(self), rhs)\n+                fn $trait_fn(self, rhs: crate::$type<LANES>) -> Self::Output {\n+                    core::ops::$trait::$trait_fn(crate::$type::splat(self), rhs)\n                 }\n             }\n         }\n \n         impl_ref_ops! {\n-            impl core::ops::$assign_trait<$type> for $type {\n+            impl<const LANES: usize> core::ops::$assign_trait<Self> for crate::$type<LANES> {\n                 #[inline]\n-                fn $assign_trait_fn(&mut self, rhs: $type) {\n+                fn $assign_trait_fn(&mut self, rhs: Self) {\n                     unsafe {\n                         *self = crate::intrinsics::$intrinsic(*self, rhs);\n                     }\n@@ -303,10 +235,10 @@ macro_rules! impl_op {\n         }\n \n         impl_ref_ops! {\n-            impl core::ops::$assign_trait<$scalar> for $type {\n+            impl<const LANES: usize> core::ops::$assign_trait<$scalar> for crate::$type<LANES> {\n                 #[inline]\n                 fn $assign_trait_fn(&mut self, rhs: $scalar) {\n-                    core::ops::$assign_trait::$assign_trait_fn(self, <$type>::splat(rhs));\n+                    core::ops::$assign_trait::$assign_trait_fn(self, Self::splat(rhs));\n                 }\n             }\n         }\n@@ -315,7 +247,7 @@ macro_rules! impl_op {\n \n /// Implements floating-point operators for the provided types.\n macro_rules! impl_float_ops {\n-    { $($scalar:ty => $($vector:ty),*;)* } => {\n+    { $($scalar:ty => $($vector:ident),*;)* } => {\n         $( // scalar\n             $( // vector\n                 impl_op! { impl Add for $vector, $scalar }\n@@ -330,24 +262,9 @@ macro_rules! impl_float_ops {\n     };\n }\n \n-/// Implements mask operators for the provided types.\n-macro_rules! impl_mask_ops {\n-    { $($scalar:ty => $($vector:ty),*;)* } => {\n-        $( // scalar\n-            $( // vector\n-                impl_op! { impl BitAnd for $vector, $scalar }\n-                impl_op! { impl BitOr  for $vector, $scalar }\n-                impl_op! { impl BitXor for $vector, $scalar }\n-                impl_op! { impl Not for $vector, $scalar }\n-                impl_op! { impl Index for $vector, $scalar }\n-            )*\n-        )*\n-    };\n-}\n-\n /// Implements unsigned integer operators for the provided types.\n macro_rules! impl_unsigned_int_ops {\n-    { $($scalar:ty => $($vector:ty),*;)* } => {\n+    { $($scalar:ty => $($vector:ident),*;)* } => {\n         $( // scalar\n             $( // vector\n                 impl_op! { impl Add for $vector, $scalar }\n@@ -361,11 +278,11 @@ macro_rules! impl_unsigned_int_ops {\n \n                 // Integers panic on divide by 0\n                 impl_ref_ops! {\n-                    impl core::ops::Div<$vector> for $vector {\n+                    impl<const LANES: usize> core::ops::Div<Self> for crate::$vector<LANES> {\n                         type Output = Self;\n \n                         #[inline]\n-                        fn div(self, rhs: $vector) -> Self::Output {\n+                        fn div(self, rhs: Self) -> Self::Output {\n                             // TODO there is probably a better way of doing this\n                             if AsRef::<[$scalar]>::as_ref(&rhs)\n                                 .iter()\n@@ -379,8 +296,8 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::Div<$scalar> for $vector {\n-                        type Output = $vector;\n+                    impl<const LANES: usize> core::ops::Div<$scalar> for crate::$vector<LANES> {\n+                        type Output = Self;\n \n                         #[inline]\n                         fn div(self, rhs: $scalar) -> Self::Output {\n@@ -394,18 +311,18 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::Div<$vector> for $scalar {\n-                        type Output = $vector;\n+                    impl<const LANES: usize> core::ops::Div<crate::$vector<LANES>> for $scalar {\n+                        type Output = crate::$vector<LANES>;\n \n                         #[inline]\n-                        fn div(self, rhs: $vector) -> Self::Output {\n-                            <$vector>::splat(self) / rhs\n+                        fn div(self, rhs: crate::$vector<LANES>) -> Self::Output {\n+                            crate::$vector::splat(self) / rhs\n                         }\n                     }\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::DivAssign<$vector> for $vector {\n+                    impl<const LANES: usize> core::ops::DivAssign<Self> for crate::$vector<LANES> {\n                         #[inline]\n                         fn div_assign(&mut self, rhs: Self) {\n                             *self = *self / rhs;\n@@ -414,7 +331,7 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::DivAssign<$scalar> for $vector {\n+                    impl<const LANES: usize> core::ops::DivAssign<$scalar> for crate::$vector<LANES> {\n                         #[inline]\n                         fn div_assign(&mut self, rhs: $scalar) {\n                             *self = *self / rhs;\n@@ -424,11 +341,11 @@ macro_rules! impl_unsigned_int_ops {\n \n                 // remainder panics on zero divisor\n                 impl_ref_ops! {\n-                    impl core::ops::Rem<$vector> for $vector {\n+                    impl<const LANES: usize> core::ops::Rem<Self> for crate::$vector<LANES> {\n                         type Output = Self;\n \n                         #[inline]\n-                        fn rem(self, rhs: $vector) -> Self::Output {\n+                        fn rem(self, rhs: Self) -> Self::Output {\n                             // TODO there is probably a better way of doing this\n                             if AsRef::<[$scalar]>::as_ref(&rhs)\n                                 .iter()\n@@ -442,8 +359,8 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::Rem<$scalar> for $vector {\n-                        type Output = $vector;\n+                    impl<const LANES: usize> core::ops::Rem<$scalar> for crate::$vector<LANES> {\n+                        type Output = Self;\n \n                         #[inline]\n                         fn rem(self, rhs: $scalar) -> Self::Output {\n@@ -457,18 +374,18 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::Rem<$vector> for $scalar {\n-                        type Output = $vector;\n+                    impl<const LANES: usize> core::ops::Rem<crate::$vector<LANES>> for $scalar {\n+                        type Output = crate::$vector<LANES>;\n \n                         #[inline]\n-                        fn rem(self, rhs: $vector) -> Self::Output {\n-                            <$vector>::splat(self) % rhs\n+                        fn rem(self, rhs: crate::$vector<LANES>) -> Self::Output {\n+                            crate::$vector::splat(self) % rhs\n                         }\n                     }\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::RemAssign<$vector> for $vector {\n+                    impl<const LANES: usize> core::ops::RemAssign<Self> for crate::$vector<LANES> {\n                         #[inline]\n                         fn rem_assign(&mut self, rhs: Self) {\n                             *self = *self % rhs;\n@@ -477,7 +394,7 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::RemAssign<$scalar> for $vector {\n+                    impl<const LANES: usize> core::ops::RemAssign<$scalar> for crate::$vector<LANES> {\n                         #[inline]\n                         fn rem_assign(&mut self, rhs: $scalar) {\n                             *self = *self % rhs;\n@@ -487,11 +404,11 @@ macro_rules! impl_unsigned_int_ops {\n \n                 // shifts panic on overflow\n                 impl_ref_ops! {\n-                    impl core::ops::Shl<$vector> for $vector {\n+                    impl<const LANES: usize> core::ops::Shl<Self> for crate::$vector<LANES> {\n                         type Output = Self;\n \n                         #[inline]\n-                        fn shl(self, rhs: $vector) -> Self::Output {\n+                        fn shl(self, rhs: Self) -> Self::Output {\n                             // TODO there is probably a better way of doing this\n                             if AsRef::<[$scalar]>::as_ref(&rhs)\n                                 .iter()\n@@ -506,8 +423,8 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::Shl<$scalar> for $vector {\n-                        type Output = $vector;\n+                    impl<const LANES: usize> core::ops::Shl<$scalar> for crate::$vector<LANES> {\n+                        type Output = Self;\n \n                         #[inline]\n                         fn shl(self, rhs: $scalar) -> Self::Output {\n@@ -522,7 +439,7 @@ macro_rules! impl_unsigned_int_ops {\n \n \n                 impl_ref_ops! {\n-                    impl core::ops::ShlAssign<$vector> for $vector {\n+                    impl<const LANES: usize> core::ops::ShlAssign<Self> for crate::$vector<LANES> {\n                         #[inline]\n                         fn shl_assign(&mut self, rhs: Self) {\n                             *self = *self << rhs;\n@@ -531,7 +448,7 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::ShlAssign<$scalar> for $vector {\n+                    impl<const LANES: usize> core::ops::ShlAssign<$scalar> for crate::$vector<LANES> {\n                         #[inline]\n                         fn shl_assign(&mut self, rhs: $scalar) {\n                             *self = *self << rhs;\n@@ -540,13 +457,13 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::Shr<$vector> for $vector {\n+                    impl<const LANES: usize> core::ops::Shr<Self> for crate::$vector<LANES> {\n                         type Output = Self;\n \n                         #[inline]\n-                        fn shr(self, rhs: $vector) -> Self::Output {\n+                        fn shr(self, rhs: Self) -> Self::Output {\n                             // TODO there is probably a better way of doing this\n-                            if AsRef::<[$scalar]>::as_ref(&rhs)\n+                            if rhs.as_slice()\n                                 .iter()\n                                 .copied()\n                                 .any(invalid_shift_rhs)\n@@ -559,8 +476,8 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::Shr<$scalar> for $vector {\n-                        type Output = $vector;\n+                    impl<const LANES: usize> core::ops::Shr<$scalar> for crate::$vector<LANES> {\n+                        type Output = Self;\n \n                         #[inline]\n                         fn shr(self, rhs: $scalar) -> Self::Output {\n@@ -575,7 +492,7 @@ macro_rules! impl_unsigned_int_ops {\n \n \n                 impl_ref_ops! {\n-                    impl core::ops::ShrAssign<$vector> for $vector {\n+                    impl<const LANES: usize> core::ops::ShrAssign<Self> for crate::$vector<LANES> {\n                         #[inline]\n                         fn shr_assign(&mut self, rhs: Self) {\n                             *self = *self >> rhs;\n@@ -584,7 +501,7 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::ShrAssign<$scalar> for $vector {\n+                    impl<const LANES: usize> core::ops::ShrAssign<$scalar> for crate::$vector<LANES> {\n                         #[inline]\n                         fn shr_assign(&mut self, rhs: $scalar) {\n                             *self = *self >> rhs;\n@@ -598,7 +515,7 @@ macro_rules! impl_unsigned_int_ops {\n \n /// Implements unsigned integer operators for the provided types.\n macro_rules! impl_signed_int_ops {\n-    { $($scalar:ty => $($vector:ty),*;)* } => {\n+    { $($scalar:ty => $($vector:ident),*;)* } => {\n         impl_unsigned_int_ops! { $($scalar => $($vector),*;)* }\n         $( // scalar\n             $( // vector\n@@ -609,33 +526,24 @@ macro_rules! impl_signed_int_ops {\n }\n \n impl_unsigned_int_ops! {\n-    u8    => crate::u8x8,    crate::u8x16,   crate::u8x32,   crate::u8x64;\n-    u16   => crate::u16x4,   crate::u16x8,   crate::u16x16,  crate::u16x32;\n-    u32   => crate::u32x2,   crate::u32x4,   crate::u32x8,   crate::u32x16;\n-    u64   => crate::u64x2,   crate::u64x4,   crate::u64x8;\n-    u128  => crate::u128x2,  crate::u128x4;\n-    usize => crate::usizex2, crate::usizex4, crate::usizex8;\n+    u8 => SimdU8;\n+    u16 => SimdU16;\n+    u32 => SimdU32;\n+    u64 => SimdU64;\n+    u128 => SimdU128;\n+    usize => SimdUsize;\n }\n \n impl_signed_int_ops! {\n-    i8    => crate::i8x8,    crate::i8x16,   crate::i8x32,   crate::i8x64;\n-    i16   => crate::i16x4,   crate::i16x8,   crate::i16x16,  crate::i16x32;\n-    i32   => crate::i32x2,   crate::i32x4,   crate::i32x8,   crate::i32x16;\n-    i64   => crate::i64x2,   crate::i64x4,   crate::i64x8;\n-    i128  => crate::i128x2,  crate::i128x4;\n-    isize => crate::isizex2, crate::isizex4, crate::isizex8;\n+    i8 => SimdI8;\n+    i16 => SimdI16;\n+    i32 => SimdI32;\n+    i64 => SimdI64;\n+    i128 => SimdI128;\n+    isize => SimdIsize;\n }\n \n impl_float_ops! {\n-    f32 => crate::f32x2, crate::f32x4, crate::f32x8, crate::f32x16;\n-    f64 => crate::f64x2, crate::f64x4, crate::f64x8;\n-}\n-\n-impl_mask_ops! {\n-    crate::mask8    => crate::mask8x8,    crate::mask8x16,   crate::mask8x32,   crate::mask8x64;\n-    crate::mask16   => crate::mask16x4,   crate::mask16x8,   crate::mask16x16,  crate::mask16x32;\n-    crate::mask32   => crate::mask32x2,   crate::mask32x4,   crate::mask32x8,   crate::mask32x16;\n-    crate::mask64   => crate::mask64x2,   crate::mask64x4,   crate::mask64x8;\n-    crate::mask128  => crate::mask128x2,  crate::mask128x4;\n-    crate::masksize => crate::masksizex2, crate::masksizex4, crate::masksizex8;\n+    f32 => SimdF32;\n+    f64 => SimdF64;\n }"}, {"sha": "d77bc4e8fa7edad02eab2ec9110897ed26f9019b", "filename": "crates/core_simd/src/round.rs", "status": "modified", "additions": 34, "deletions": 77, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fround.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,88 +1,45 @@\n macro_rules! implement {\n     {\n-        impl $type:ident {\n-            int_type = $int_type:ident\n-        }\n+        $type:ident, $int_type:ident\n     } => {\n-        mod $type {\n-            impl crate::$type {\n-                /// Returns the largest integer less than or equal to each lane.\n-                #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-                #[inline]\n-                pub fn floor(self) -> Self {\n-                    unsafe { crate::intrinsics::simd_floor(self) }\n-                }\n+        impl<const LANES: usize> crate::$type<LANES> {\n+            /// Returns the largest integer less than or equal to each lane.\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+            #[inline]\n+            pub fn floor(self) -> Self {\n+                unsafe { crate::intrinsics::simd_floor(self) }\n+            }\n \n-                /// Returns the smallest integer greater than or equal to each lane.\n-                #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-                #[inline]\n-                pub fn ceil(self) -> Self {\n-                    unsafe { crate::intrinsics::simd_ceil(self) }\n-                }\n+            /// Returns the smallest integer greater than or equal to each lane.\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+            #[inline]\n+            pub fn ceil(self) -> Self {\n+                unsafe { crate::intrinsics::simd_ceil(self) }\n+            }\n \n-                /// Rounds toward zero and converts to the same-width integer type, assuming that\n-                /// the value is finite and fits in that type.\n-                ///\n-                /// # Safety\n-                /// The value must:\n-                ///\n-                /// * Not be NaN\n-                /// * Not be infinite\n-                /// * Be representable in the return type, after truncating off its fractional part\n-                #[inline]\n-                pub unsafe fn to_int_unchecked(self) -> crate::$int_type {\n-                    crate::intrinsics::simd_cast(self)\n-                }\n+            /// Rounds toward zero and converts to the same-width integer type, assuming that\n+            /// the value is finite and fits in that type.\n+            ///\n+            /// # Safety\n+            /// The value must:\n+            ///\n+            /// * Not be NaN\n+            /// * Not be infinite\n+            /// * Be representable in the return type, after truncating off its fractional part\n+            #[inline]\n+            pub unsafe fn to_int_unchecked(self) -> crate::$int_type<LANES> {\n+                crate::intrinsics::simd_cast(self)\n+            }\n \n-                /// Creates a floating-point vector from an integer vector.  Rounds values that are\n-                /// not exactly representable.\n-                #[inline]\n-                pub fn round_from_int(value: crate::$int_type) -> Self {\n-                    unsafe { crate::intrinsics::simd_cast(value) }\n-                }\n+            /// Creates a floating-point vector from an integer vector.  Rounds values that are\n+            /// not exactly representable.\n+            #[inline]\n+            pub fn round_from_int(value: crate::$int_type<LANES>) -> Self {\n+                unsafe { crate::intrinsics::simd_cast(value) }\n             }\n         }\n     }\n }\n \n-implement! {\n-    impl f32x2 {\n-        int_type = i32x2\n-    }\n-}\n-\n-implement! {\n-    impl f32x4 {\n-        int_type = i32x4\n-    }\n-}\n-\n-implement! {\n-    impl f32x8 {\n-        int_type = i32x8\n-    }\n-}\n-\n-implement! {\n-    impl f32x16 {\n-        int_type = i32x16\n-    }\n-}\n-\n-implement! {\n-    impl f64x2 {\n-        int_type = i64x2\n-    }\n-}\n-\n-implement! {\n-    impl f64x4 {\n-        int_type = i64x4\n-    }\n-}\n-\n-implement! {\n-    impl f64x8 {\n-        int_type = i64x8\n-    }\n-}\n+implement! { SimdF32, SimdI32 }\n+implement! { SimdF64, SimdI64 }"}, {"sha": "0b5d8c6ec49b40eb2f46542c9cc88177a63e4340", "filename": "crates/core_simd/src/vectors_f32.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_f32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_f32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_f32.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,29 +1,23 @@\n-define_float_vector! {\n-    /// Vector of two `f32` values\n-    struct f32x2([f32; 2]);\n-    bits crate::u32x2;\n-}\n+#![allow(non_camel_case_types)]\n \n-define_float_vector! {\n-    /// Vector of four `f32` values\n-    struct f32x4([f32; 4]);\n-    bits crate::u32x4;\n-}\n+/// A SIMD vector of containing `LANES` `f32` values.\n+#[repr(simd)]\n+pub struct SimdF32<const LANES: usize>([f32; LANES]);\n \n-define_float_vector! {\n-    /// Vector of eight `f32` values\n-    struct f32x8([f32; 8]);\n-    bits crate::u32x8;\n-}\n+impl_float_vector! { SimdF32, f32, SimdU32 }\n \n-define_float_vector! {\n-    /// Vector of 16 `f32` values\n-    struct f32x16([f32; 16]);\n-    bits crate::u32x16;\n-}\n+/// Vector of two `f32` values\n+pub type f32x2 = SimdF32<2>;\n+\n+/// Vector of four `f32` values\n+pub type f32x4 = SimdF32<4>;\n+\n+/// Vector of eight `f32` values\n+pub type f32x8 = SimdF32<8>;\n+\n+/// Vector of 16 `f32` values\n+pub type f32x16 = SimdF32<16>;\n \n from_transmute_x86! { unsafe f32x4 => __m128 }\n from_transmute_x86! { unsafe f32x8 => __m256 }\n //from_transmute_x86! { unsafe f32x16 => __m512 }\n-\n-"}, {"sha": "307f8a4acacd760c88480df8aafc885d6bb940bb", "filename": "crates/core_simd/src/vectors_f64.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_f64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_f64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_f64.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,20 +1,19 @@\n-define_float_vector! {\n-    /// Vector of two `f64` values\n-    struct f64x2([f64; 2]);\n-    bits crate::u64x2;\n-}\n+#![allow(non_camel_case_types)]\n \n-define_float_vector! {\n-    /// Vector of four `f64` values\n-    struct f64x4([f64; 4]);\n-    bits crate::u64x4;\n-}\n+/// A SIMD vector of containing `LANES` `f64` values.\n+#[repr(simd)]\n+pub struct SimdF64<const LANES: usize>([f64; LANES]);\n \n-define_float_vector! {\n-    /// Vector of eight `f64` values\n-    struct f64x8([f64; 8]);\n-    bits crate::u64x8;\n-}\n+impl_float_vector! { SimdF64, f64, SimdU64 }\n+\n+/// Vector of two `f64` values\n+pub type f64x2 = SimdF64<2>;\n+\n+/// Vector of four `f64` values\n+pub type f64x4 = SimdF64<4>;\n+\n+/// Vector of eight `f64` values\n+pub type f64x8 = SimdF64<8>;\n \n from_transmute_x86! { unsafe f64x2 => __m128d }\n from_transmute_x86! { unsafe f64x4 => __m256d }"}, {"sha": "16e6162be5523e07afe81ce92d29298da768b5ed", "filename": "crates/core_simd/src/vectors_i128.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_i128.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,12 +1,16 @@\n-define_integer_vector! {\n-    /// Vector of two `i128` values\n-    struct i128x2([i128; 2]);\n-}\n-\n-define_integer_vector! {\n-    /// Vector of four `i128` values\n-    struct i128x4([i128; 4]);\n-}\n+#![allow(non_camel_case_types)]\n+\n+/// A SIMD vector of containing `LANES` `i128` values.\n+#[repr(simd)]\n+pub struct SimdI128<const LANES: usize>([i128; LANES]);\n+\n+impl_integer_vector! { SimdI128, i128 }\n+\n+/// Vector of two `i128` values\n+pub type i128x2 = SimdI128<2>;\n+\n+/// Vector of four `i128` values\n+pub type i128x4 = SimdI128<4>;\n \n from_transmute_x86! { unsafe i128x2 => __m256i }\n //from_transmute_x86! { unsafe i128x4 => __m512i }"}, {"sha": "08cc4af2a5ea419ab2f7f0b9fb706a864aea3796", "filename": "crates/core_simd/src/vectors_i16.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_i16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_i16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_i16.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,22 +1,22 @@\n-define_integer_vector! {\n-    /// Vector of four `i16` values\n-    struct i16x4([i16; 4]);\n-}\n+#![allow(non_camel_case_types)]\n \n-define_integer_vector! {\n-    /// Vector of eight `i16` values\n-    struct i16x8([i16; 8]);\n-}\n+/// A SIMD vector of containing `LANES` `i16` values.\n+#[repr(simd)]\n+pub struct SimdI16<const LANES: usize>([i16; LANES]);\n \n-define_integer_vector! {\n-    /// Vector of 16 `i16` values\n-    struct i16x16([i16; 16]);\n-}\n+impl_integer_vector! { SimdI16, i16 }\n \n-define_integer_vector! {\n-    /// Vector of 32 `i16` values\n-    struct i16x32([i16; 32]);\n-}\n+/// Vector of four `i16` values\n+pub type i16x4 = SimdI16<4>;\n+\n+/// Vector of eight `i16` values\n+pub type i16x8 = SimdI16<8>;\n+\n+/// Vector of 16 `i16` values\n+pub type i16x16 = SimdI16<16>;\n+\n+/// Vector of 32 `i16` values\n+pub type i16x32 = SimdI16<32>;\n \n from_transmute_x86! { unsafe i16x8 => __m128i }\n from_transmute_x86! { unsafe i16x16 => __m256i }"}, {"sha": "116f2abaeeedb7d234937952269279955a236a2c", "filename": "crates/core_simd/src/vectors_i32.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_i32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_i32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_i32.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,22 +1,22 @@\n-define_integer_vector! {\n-    /// Vector of two `i32` values\n-    struct i32x2([i32; 2]);\n-}\n+#![allow(non_camel_case_types)]\n \n-define_integer_vector! {\n-    /// Vector of four `i32` values\n-    struct i32x4([i32; 4]);\n-}\n+/// A SIMD vector of containing `LANES` `i32` values.\n+#[repr(simd)]\n+pub struct SimdI32<const LANES: usize>([i32; LANES]);\n \n-define_integer_vector! {\n-    /// Vector of eight `i32` values\n-    struct i32x8([i32; 8]);\n-}\n+impl_integer_vector! { SimdI32, i32 }\n \n-define_integer_vector! {\n-    /// Vector of 16 `i32` values\n-    struct i32x16([i32; 16]);\n-}\n+/// Vector of two `i32` values\n+pub type i32x2 = SimdI32<2>;\n+\n+/// Vector of four `i32` values\n+pub type i32x4 = SimdI32<4>;\n+\n+/// Vector of eight `i32` values\n+pub type i32x8 = SimdI32<8>;\n+\n+/// Vector of 16 `i32` values\n+pub type i32x16 = SimdI32<16>;\n \n from_transmute_x86! { unsafe i32x4 => __m128i }\n from_transmute_x86! { unsafe i32x8 => __m256i }"}, {"sha": "6a1e2094179bd8d948f3bf6f5b5b586a60696a9c", "filename": "crates/core_simd/src/vectors_i64.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_i64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_i64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_i64.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,17 +1,19 @@\n-define_integer_vector! {\n-    /// Vector of two `i64` values\n-    struct i64x2([i64; 2]);\n-}\n+#![allow(non_camel_case_types)]\n \n-define_integer_vector! {\n-    /// Vector of four `i64` values\n-    struct i64x4([i64; 4]);\n-}\n+/// A SIMD vector of containing `LANES` `i64` values.\n+#[repr(simd)]\n+pub struct SimdI64<const LANES: usize>([i64; LANES]);\n \n-define_integer_vector! {\n-    /// Vector of eight `i64` values\n-    struct i64x8([i64; 8]);\n-}\n+impl_integer_vector! { SimdI64, i64 }\n+\n+/// Vector of two `i64` values\n+pub type i64x2 = SimdI64<2>;\n+\n+/// Vector of four `i64` values\n+pub type i64x4 = SimdI64<4>;\n+\n+/// Vector of eight `i64` values\n+pub type i64x8 = SimdI64<8>;\n \n from_transmute_x86! { unsafe i64x2 => __m128i }\n from_transmute_x86! { unsafe i64x4 => __m256i }"}, {"sha": "0ac5ba9efee56a7d14961f73bad636e091e521e5", "filename": "crates/core_simd/src/vectors_i8.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_i8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_i8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_i8.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,22 +1,22 @@\n-define_integer_vector! {\n-    /// Vector of eight `i8` values\n-    struct i8x8([i8; 8]);\n-}\n+#![allow(non_camel_case_types)]\n \n-define_integer_vector! {\n-    /// Vector of 16 `i8` values\n-    struct i8x16([i8; 16]);\n-}\n+/// A SIMD vector of containing `LANES` `i8` values.\n+#[repr(simd)]\n+pub struct SimdI8<const LANES: usize>([i8; LANES]);\n \n-define_integer_vector! {\n-    /// Vector of 32 `i8` values\n-    struct i8x32([i8; 32]);\n-}\n+impl_integer_vector! { SimdI8, i8 }\n \n-define_integer_vector! {\n-    /// Vector of 64 `i8` values\n-    struct i8x64([i8; 64]);\n-}\n+/// Vector of eight `i8` values\n+pub type i8x8 = SimdI8<8>;\n+\n+/// Vector of 16 `i8` values\n+pub type i8x16 = SimdI8<16>;\n+\n+/// Vector of 32 `i8` values\n+pub type i8x32 = SimdI8<32>;\n+\n+/// Vector of 64 `i8` values\n+pub type i8x64 = SimdI8<64>;\n \n from_transmute_x86! { unsafe i8x16 => __m128i }\n from_transmute_x86! { unsafe i8x32 => __m256i }"}, {"sha": "6856f305092d3e97061109cb8d33c00c8b9aa1ab", "filename": "crates/core_simd/src/vectors_isize.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_isize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_isize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_isize.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,17 +1,19 @@\n-define_integer_vector! {\n-    /// Vector of two `isize` values\n-    struct isizex2([isize; 2]);\n-}\n+#![allow(non_camel_case_types)]\n \n-define_integer_vector! {\n-    /// Vector of four `isize` values\n-    struct isizex4([isize; 4]);\n-}\n+/// A SIMD vector of containing `LANES` `isize` values.\n+#[repr(simd)]\n+pub struct SimdIsize<const LANES: usize>([isize; LANES]);\n \n-define_integer_vector! {\n-    /// Vector of eight `isize` values\n-    struct isizex8([isize; 8]);\n-}\n+impl_integer_vector! { SimdIsize, isize }\n+\n+/// Vector of two `isize` values\n+pub type isizex2 = SimdIsize<2>;\n+\n+/// Vector of four `isize` values\n+pub type isizex4 = SimdIsize<4>;\n+\n+/// Vector of eight `isize` values\n+pub type isizex8 = SimdIsize<8>;\n \n #[cfg(target_pointer_width = \"32\")]\n from_transmute_x86! { unsafe isizex4 => __m128i }"}, {"sha": "adf56a3684b3be8829e28ac9d6d0911536ef75ad", "filename": "crates/core_simd/src/vectors_mask128.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d72927c85b1ae34e1115a19897d93b8dcf59e44d/crates%2Fcore_simd%2Fsrc%2Fvectors_mask128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d72927c85b1ae34e1115a19897d93b8dcf59e44d/crates%2Fcore_simd%2Fsrc%2Fvectors_mask128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_mask128.rs?ref=d72927c85b1ae34e1115a19897d93b8dcf59e44d", "patch": "@@ -1,11 +0,0 @@\n-use crate::mask128;\n-\n-define_mask_vector! {\n-    /// Vector of two `mask128` values\n-    struct mask128x2([i128 as mask128; 2]);\n-}\n-\n-define_mask_vector! {\n-    /// Vector of four `mask128` values\n-    struct mask128x4([i128 as mask128; 4]);\n-}"}, {"sha": "406d7255a11efe3bd31407ba73b476488f467568", "filename": "crates/core_simd/src/vectors_mask16.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d72927c85b1ae34e1115a19897d93b8dcf59e44d/crates%2Fcore_simd%2Fsrc%2Fvectors_mask16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d72927c85b1ae34e1115a19897d93b8dcf59e44d/crates%2Fcore_simd%2Fsrc%2Fvectors_mask16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_mask16.rs?ref=d72927c85b1ae34e1115a19897d93b8dcf59e44d", "patch": "@@ -1,21 +0,0 @@\n-use crate::mask16;\n-\n-define_mask_vector! {\n-    /// Vector of four `mask16` values\n-    struct mask16x4([i16 as mask16; 4]);\n-}\n-\n-define_mask_vector! {\n-    /// Vector of eight `mask16` values\n-    struct mask16x8([i16 as mask16; 8]);\n-}\n-\n-define_mask_vector! {\n-    /// Vector of 16 `mask16` values\n-    struct mask16x16([i16 as mask16; 16]);\n-}\n-\n-define_mask_vector! {\n-    /// Vector of 32 `mask16` values\n-    struct mask16x32([i16 as mask16; 32]);\n-}"}, {"sha": "fad191421f3879fa97648c6fe4fc7c424f10921d", "filename": "crates/core_simd/src/vectors_mask32.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d72927c85b1ae34e1115a19897d93b8dcf59e44d/crates%2Fcore_simd%2Fsrc%2Fvectors_mask32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d72927c85b1ae34e1115a19897d93b8dcf59e44d/crates%2Fcore_simd%2Fsrc%2Fvectors_mask32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_mask32.rs?ref=d72927c85b1ae34e1115a19897d93b8dcf59e44d", "patch": "@@ -1,21 +0,0 @@\n-use crate::mask32;\n-\n-define_mask_vector! {\n-    /// Vector of two `mask32` values\n-    struct mask32x2([i32 as mask32; 2]);\n-}\n-\n-define_mask_vector! {\n-    /// Vector of four `mask32` values\n-    struct mask32x4([i32 as mask32; 4]);\n-}\n-\n-define_mask_vector! {\n-    /// Vector of eight `mask32` values\n-    struct mask32x8([i32 as mask32; 8]);\n-}\n-\n-define_mask_vector! {\n-    /// Vector of 16 `mask32` values\n-    struct mask32x16([i32 as mask32; 16]);\n-}"}, {"sha": "554e731ccf24b0d177f6ba492cdf0d6e5797c80e", "filename": "crates/core_simd/src/vectors_mask64.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d72927c85b1ae34e1115a19897d93b8dcf59e44d/crates%2Fcore_simd%2Fsrc%2Fvectors_mask64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d72927c85b1ae34e1115a19897d93b8dcf59e44d/crates%2Fcore_simd%2Fsrc%2Fvectors_mask64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_mask64.rs?ref=d72927c85b1ae34e1115a19897d93b8dcf59e44d", "patch": "@@ -1,16 +0,0 @@\n-use crate::mask64;\n-\n-define_mask_vector! {\n-    /// Vector of two `mask64` values\n-    struct mask64x2([i64 as mask64; 2]);\n-}\n-\n-define_mask_vector! {\n-    /// Vector of four `mask64` values\n-    struct mask64x4([i64 as mask64; 4]);\n-}\n-\n-define_mask_vector! {\n-    /// Vector of eight `mask64` values\n-    struct mask64x8([i64 as mask64; 8]);\n-}"}, {"sha": "d038b33610444a1d084e09021a2a57270e46bc9b", "filename": "crates/core_simd/src/vectors_mask8.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d72927c85b1ae34e1115a19897d93b8dcf59e44d/crates%2Fcore_simd%2Fsrc%2Fvectors_mask8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d72927c85b1ae34e1115a19897d93b8dcf59e44d/crates%2Fcore_simd%2Fsrc%2Fvectors_mask8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_mask8.rs?ref=d72927c85b1ae34e1115a19897d93b8dcf59e44d", "patch": "@@ -1,21 +0,0 @@\n-use crate::mask8;\n-\n-define_mask_vector! {\n-    /// Vector of eight `mask8` values\n-    struct mask8x8([i8 as mask8; 8]);\n-}\n-\n-define_mask_vector! {\n-    /// Vector of 16 `mask8` values\n-    struct mask8x16([i8 as mask8; 16]);\n-}\n-\n-define_mask_vector! {\n-    /// Vector of 32 `mask8` values\n-    struct mask8x32([i8 as mask8; 32]);\n-}\n-\n-define_mask_vector! {\n-    /// Vector of 64 `mask8` values\n-    struct mask8x64([i8 as mask8; 64]);\n-}"}, {"sha": "a838aee51985352443a3a3673f5ef88da79ade67", "filename": "crates/core_simd/src/vectors_masksize.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d72927c85b1ae34e1115a19897d93b8dcf59e44d/crates%2Fcore_simd%2Fsrc%2Fvectors_masksize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d72927c85b1ae34e1115a19897d93b8dcf59e44d/crates%2Fcore_simd%2Fsrc%2Fvectors_masksize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_masksize.rs?ref=d72927c85b1ae34e1115a19897d93b8dcf59e44d", "patch": "@@ -1,16 +0,0 @@\n-use crate::masksize;\n-\n-define_mask_vector! {\n-    /// Vector of two `masksize` values\n-    struct masksizex2([isize as masksize; 2]);\n-}\n-\n-define_mask_vector! {\n-    /// Vector of four `masksize` values\n-    struct masksizex4([isize as masksize; 4]);\n-}\n-\n-define_mask_vector! {\n-    /// Vector of eight `masksize` values\n-    struct masksizex8([isize as masksize; 8]);\n-}"}, {"sha": "522404f133e564d644294fa2d302f844c6d9d8b5", "filename": "crates/core_simd/src/vectors_u128.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_u128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_u128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_u128.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,12 +1,16 @@\n-define_integer_vector! {\n-    /// Vector of two `u128` values\n-    struct u128x2([u128; 2]);\n-}\n-\n-define_integer_vector! {\n-    /// Vector of four `u128` values\n-    struct u128x4([u128; 4]);\n-}\n+#![allow(non_camel_case_types)]\n+\n+/// A SIMD vector of containing `LANES` `u128` values.\n+#[repr(simd)]\n+pub struct SimdU128<const LANES: usize>([u128; LANES]);\n+\n+impl_integer_vector! { SimdU128, u128 }\n+\n+/// Vector of two `u128` values\n+pub type u128x2 = SimdU128<2>;\n+\n+/// Vector of four `u128` values\n+pub type u128x4 = SimdU128<4>;\n \n from_transmute_x86! { unsafe u128x2 => __m256i }\n //from_transmute_x86! { unsafe u128x4 => __m512i }"}, {"sha": "efe7dea58dc48c26adbc3aff1563b80f6ecde5da", "filename": "crates/core_simd/src/vectors_u16.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_u16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_u16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_u16.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,22 +1,22 @@\n-define_integer_vector! {\n-    /// Vector of four `u16` values\n-    struct u16x4([u16; 4]);\n-}\n+#![allow(non_camel_case_types)]\n \n-define_integer_vector! {\n-    /// Vector of eight `u16` values\n-    struct u16x8([u16; 8]);\n-}\n+/// A SIMD vector of containing `LANES` `u16` values.\n+#[repr(simd)]\n+pub struct SimdU16<const LANES: usize>([u16; LANES]);\n \n-define_integer_vector! {\n-    /// Vector of 16 `u16` values\n-    struct u16x16([u16; 16]);\n-}\n+impl_integer_vector! { SimdU16, u16 }\n \n-define_integer_vector! {\n-    /// Vector of 32 `u16` values\n-    struct u16x32([u16; 32]);\n-}\n+/// Vector of four `u16` values\n+pub type u16x4 = SimdU16<4>;\n+\n+/// Vector of eight `u16` values\n+pub type u16x8 = SimdU16<8>;\n+\n+/// Vector of 16 `u16` values\n+pub type u16x16 = SimdU16<16>;\n+\n+/// Vector of 32 `u16` values\n+pub type u16x32 = SimdU16<32>;\n \n from_transmute_x86! { unsafe u16x8 => __m128i }\n from_transmute_x86! { unsafe u16x16 => __m256i }"}, {"sha": "a6cef5baeb73f63f974ca533612decb1c0a66d79", "filename": "crates/core_simd/src/vectors_u32.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_u32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_u32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_u32.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,22 +1,22 @@\n-define_integer_vector! {\n-    /// Vector of two `u32` values\n-    struct u32x2([u32; 2]);\n-}\n+#![allow(non_camel_case_types)]\n \n-define_integer_vector! {\n-    /// Vector of four `u32` values\n-    struct u32x4([u32; 4]);\n-}\n+/// A SIMD vector of containing `LANES` `u32` values.\n+#[repr(simd)]\n+pub struct SimdU32<const LANES: usize>([u32; LANES]);\n \n-define_integer_vector! {\n-    /// Vector of eight `u32` values\n-    struct u32x8([u32; 8]);\n-}\n+impl_integer_vector! { SimdU32, u32 }\n \n-define_integer_vector! {\n-    /// Vector of 16 `u32` values\n-    struct u32x16([u32; 16]);\n-}\n+/// Vector of two `u32` values\n+pub type u32x2 = SimdU32<2>;\n+\n+/// Vector of four `u32` values\n+pub type u32x4 = SimdU32<4>;\n+\n+/// Vector of eight `u32` values\n+pub type u32x8 = SimdU32<8>;\n+\n+/// Vector of 16 `u32` values\n+pub type u32x16 = SimdU32<16>;\n \n from_transmute_x86! { unsafe u32x4 => __m128i }\n from_transmute_x86! { unsafe u32x8 => __m256i }"}, {"sha": "3982e30f57055bf1121cf0f10000fc4a3897705a", "filename": "crates/core_simd/src/vectors_u64.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_u64.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,17 +1,19 @@\n-define_integer_vector! {\n-    /// Vector of two `u64` values\n-    struct u64x2([u64; 2]);\n-}\n+#![allow(non_camel_case_types)]\n \n-define_integer_vector! {\n-    /// Vector of four `u64` values\n-    struct u64x4([u64; 4]);\n-}\n+/// A SIMD vector of containing `LANES` `u64` values.\n+#[repr(simd)]\n+pub struct SimdU64<const LANES: usize>([u64; LANES]);\n \n-define_integer_vector! {\n-    /// Vector of eight `u64` values\n-    struct u64x8([u64; 8]);\n-}\n+impl_integer_vector! { SimdU64, u64 }\n+\n+/// Vector of two `u64` values\n+pub type u64x2 = SimdU64<2>;\n+\n+/// Vector of four `u64` values\n+pub type u64x4 = SimdU64<4>;\n+\n+/// Vector of eight `u64` values\n+pub type u64x8 = SimdU64<8>;\n \n from_transmute_x86! { unsafe u64x2 => __m128i }\n from_transmute_x86! { unsafe u64x4 => __m256i }"}, {"sha": "9cc4eaca47ad454a83cd7a581af1523cd70cfa49", "filename": "crates/core_simd/src/vectors_u8.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_u8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_u8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_u8.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,22 +1,22 @@\n-define_integer_vector! {\n-    /// Vector of eight `u8` values\n-    struct u8x8([u8; 8]);\n-}\n+#![allow(non_camel_case_types)]\n \n-define_integer_vector! {\n-    /// Vector of 16 `u8` values\n-    struct u8x16([u8; 16]);\n-}\n+/// A SIMD vector of containing `LANES` `u8` values.\n+#[repr(simd)]\n+pub struct SimdU8<const LANES: usize>([u8; LANES]);\n \n-define_integer_vector! {\n-    /// Vector of 32 `u8` values\n-    struct u8x32([u8; 32]);\n-}\n+impl_integer_vector! { SimdU8, u8 }\n \n-define_integer_vector! {\n-    /// Vector of 64 `u8` values\n-    struct u8x64([u8; 64]);\n-}\n+/// Vector of eight `u8` values\n+pub type u8x8 = SimdU8<8>;\n+\n+/// Vector of 16 `u8` values\n+pub type u8x16 = SimdU8<16>;\n+\n+/// Vector of 32 `u8` values\n+pub type u8x32 = SimdU8<32>;\n+\n+/// Vector of 64 `u8` values\n+pub type u8x64 = SimdU8<64>;\n \n from_transmute_x86! { unsafe u8x16 => __m128i }\n from_transmute_x86! { unsafe u8x32 => __m256i }"}, {"sha": "c882898f9fbea8d65d208fbf431e21ca672345b6", "filename": "crates/core_simd/src/vectors_usize.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_usize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Fsrc%2Fvectors_usize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_usize.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,17 +1,19 @@\n-define_integer_vector! {\n-    /// Vector of two `usize` values\n-    struct usizex2([usize; 2]);\n-}\n+#![allow(non_camel_case_types)]\n \n-define_integer_vector! {\n-    /// Vector of four `usize` values\n-    struct usizex4([usize; 4]);\n-}\n+/// A SIMD vector of containing `LANES` `usize` values.\n+#[repr(simd)]\n+pub struct SimdUsize<const LANES: usize>([usize; LANES]);\n \n-define_integer_vector! {\n-    /// Vector of eight `usize` values\n-    struct usizex8([usize; 8]);\n-}\n+impl_integer_vector! { SimdUsize, usize }\n+\n+/// Vector of two `usize` values\n+pub type usizex2 = SimdUsize<2>;\n+\n+/// Vector of four `usize` values\n+pub type usizex4 = SimdUsize<4>;\n+\n+/// Vector of eight `usize` values\n+pub type usizex8 = SimdUsize<8>;\n \n #[cfg(target_pointer_width = \"32\")]\n from_transmute_x86! { unsafe usizex4 => __m128i }"}, {"sha": "9da2bdfce42e90b9eb3dcb38bb104c043935259c", "filename": "crates/core_simd/tests/helpers/biteq.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fbiteq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fbiteq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fbiteq.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -70,7 +70,6 @@ impl_biteq! {\n     integer impl BitEq for\n         u8, u16, u32, u64, u128, usize,\n         i8, i16, i32, i64, i128, isize,\n-        core_simd::mask8, core_simd::mask16, core_simd::mask32, core_simd::mask64, core_simd::mask128, core_simd::masksize,\n }\n \n impl_biteq! {\n@@ -93,12 +92,6 @@ impl_biteq! {\n         core_simd::isizex2, core_simd::isizex4, core_simd::isizex8,\n         core_simd::f32x2, core_simd::f32x4, core_simd::f32x8, core_simd::f32x16,\n         core_simd::f64x2, core_simd::f64x4, core_simd::f64x8,\n-        core_simd::mask8x8,    core_simd::mask8x16,   core_simd::mask8x32,   core_simd::mask8x64,\n-        core_simd::mask16x4,   core_simd::mask16x8,   core_simd::mask16x16,  core_simd::mask16x32,\n-        core_simd::mask32x2,   core_simd::mask32x4,   core_simd::mask32x8,   core_simd::mask32x16,\n-        core_simd::mask64x2,   core_simd::mask64x4,   core_simd::mask64x8,\n-        core_simd::mask128x2,  core_simd::mask128x4,\n-        core_simd::masksizex2, core_simd::masksizex4, core_simd::masksizex8,\n }\n \n pub(crate) struct BitEqWrapper<'a, T>(pub(crate) &'a T);"}, {"sha": "27ba4e2d29fe683b1cc3db9cfb03efe52c3446be", "filename": "crates/core_simd/tests/ops_impl/mask128.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask128.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,4 +1,2 @@\n-use super::helpers;\n-\n-mask_tests! { mask128x2, mask128 }\n-mask_tests! { mask128x4, mask128 }\n+mask_tests! { mask128x2, 2 }\n+mask_tests! { mask128x4, 4 }"}, {"sha": "0fe82fa680479a457a7e37852a2d5f0fed94e7bc", "filename": "crates/core_simd/tests/ops_impl/mask16.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask16.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,6 +1,4 @@\n-use super::helpers;\n-\n-mask_tests! { mask16x4, mask16 }\n-mask_tests! { mask16x8, mask16 }\n-mask_tests! { mask16x16, mask16 }\n-mask_tests! { mask16x32, mask16 }\n+mask_tests! { mask16x4, 4 }\n+mask_tests! { mask16x8, 8 }\n+mask_tests! { mask16x16, 16 }\n+mask_tests! { mask16x32, 32 }"}, {"sha": "66d987a43ce83c295a96e014c3fce7e839ee435a", "filename": "crates/core_simd/tests/ops_impl/mask32.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask32.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,6 +1,4 @@\n-use super::helpers;\n-\n-mask_tests! { mask32x2, mask32 }\n-mask_tests! { mask32x4, mask32 }\n-mask_tests! { mask32x8, mask32 }\n-mask_tests! { mask32x16, mask32 }\n+mask_tests! { mask32x2, 2 }\n+mask_tests! { mask32x4, 4 }\n+mask_tests! { mask32x8, 8 }\n+mask_tests! { mask32x16, 16 }"}, {"sha": "a1f1f67b23887641de455b53796d1e323e038c8b", "filename": "crates/core_simd/tests/ops_impl/mask64.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask64.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,5 +1,3 @@\n-use super::helpers;\n-\n-mask_tests! { mask64x2, mask64 }\n-mask_tests! { mask64x4, mask64 }\n-mask_tests! { mask64x8, mask64 }\n+mask_tests! { mask64x2, 2 }\n+mask_tests! { mask64x4, 4 }\n+mask_tests! { mask64x8, 8 }"}, {"sha": "218fa9fe895e5a9706790ab25f94290a744c82b6", "filename": "crates/core_simd/tests/ops_impl/mask8.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask8.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,6 +1,4 @@\n-use super::helpers;\n-\n-mask_tests! { mask8x8, mask8 }\n-mask_tests! { mask8x16, mask8 }\n-mask_tests! { mask8x32, mask8 }\n-mask_tests! { mask8x64, mask8 }\n+mask_tests! { mask8x8, 8 }\n+mask_tests! { mask8x16, 16 }\n+mask_tests! { mask8x32, 32 }\n+mask_tests! { mask8x64, 64 }"}, {"sha": "795f9e27c4458fa1dcefeb5e23ece1f66d4d859e", "filename": "crates/core_simd/tests/ops_impl/mask_macros.rs", "status": "modified", "additions": 71, "deletions": 47, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask_macros.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,25 +1,54 @@\n macro_rules! mask_tests {\n-    { $vector:ident, $scalar:ident } => {\n+    { $vector:ident, $lanes:literal } => {\n         #[cfg(test)]\n         mod $vector {\n-            use super::*;\n-            use helpers::lanewise::*;\n+            use core_simd::$vector as Vector;\n+            const LANES: usize = $lanes;\n \n             #[cfg(target_arch = \"wasm32\")]\n             use wasm_bindgen_test::*;\n \n             #[cfg(target_arch = \"wasm32\")]\n             wasm_bindgen_test_configure!(run_in_browser);\n \n-            fn from_slice(slice: &[bool]) -> core_simd::$vector {\n-                let mut value = core_simd::$vector::default();\n-                let value_slice: &mut [_] = value.as_mut();\n-                for (m, b) in value_slice.iter_mut().zip(slice.iter()) {\n-                    *m = (*b).into();\n+            fn from_slice(slice: &[bool]) -> Vector {\n+                let mut value = Vector::default();\n+                for (i, b) in slice.iter().take(LANES).enumerate() {\n+                    value.set(i, *b);\n                 }\n                 value\n             }\n \n+            fn apply_unary_lanewise(x: Vector, f: impl Fn(bool) -> bool) -> Vector {\n+                let mut value = Vector::default();\n+                for i in 0..LANES {\n+                    value.set(i, f(x.test(i)));\n+                }\n+                value\n+            }\n+\n+            fn apply_binary_lanewise(x: Vector, y: Vector, f: impl Fn(bool, bool) -> bool) -> Vector {\n+                let mut value = Vector::default();\n+                for i in 0..LANES {\n+                    value.set(i, f(x.test(i), y.test(i)));\n+                }\n+                value\n+            }\n+\n+            fn apply_binary_scalar_lhs_lanewise(x: bool, mut y: Vector, f: impl Fn(bool, bool) -> bool) -> Vector {\n+                for i in 0..LANES {\n+                    y.set(i, f(x, y.test(i)));\n+                }\n+                y\n+            }\n+\n+            fn apply_binary_scalar_rhs_lanewise(mut x: Vector, y: bool, f: impl Fn(bool, bool) -> bool) -> Vector {\n+                for i in 0..LANES {\n+                    x.set(i, f(x.test(i), y));\n+                }\n+                x\n+            }\n+\n             const A: [bool; 64] = [\n                 false, true, false, true, false, false, true, true,\n                 false, true, false, true, false, false, true, true,\n@@ -41,18 +70,13 @@ macro_rules! mask_tests {\n                 false, false, true, true, false, true, false, true,\n             ];\n \n-            const SET_SCALAR: core_simd::$scalar = core_simd::$scalar::new(true);\n-            const UNSET_SCALAR: core_simd::$scalar = core_simd::$scalar::new(false);\n-            const SET_VECTOR: core_simd::$vector = core_simd::$vector::splat(SET_SCALAR);\n-            const UNSET_VECTOR: core_simd::$vector = core_simd::$vector::splat(UNSET_SCALAR);\n-\n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n             fn bitand() {\n                 let a = from_slice(&A);\n                 let b = from_slice(&B);\n                 let expected = apply_binary_lanewise(a, b, core::ops::BitAnd::bitand);\n-                assert_biteq!(a & b, expected);\n+                assert_eq!(a & b, expected);\n             }\n \n             #[test]\n@@ -62,36 +86,36 @@ macro_rules! mask_tests {\n                 let b = from_slice(&B);\n                 let expected = apply_binary_lanewise(a, b, core::ops::BitAnd::bitand);\n                 a &= b;\n-                assert_biteq!(a, expected);\n+                assert_eq!(a, expected);\n             }\n \n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n             fn bitand_scalar_rhs() {\n                 let a = from_slice(&A);\n                 let expected = a;\n-                assert_biteq!(a & SET_SCALAR, expected);\n-                assert_biteq!(a & UNSET_SCALAR, UNSET_VECTOR);\n+                assert_eq!(a & true, expected);\n+                assert_eq!(a & false, Vector::splat(false));\n             }\n \n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n             fn bitand_scalar_lhs() {\n                 let a = from_slice(&A);\n                 let expected = a;\n-                assert_biteq!(SET_SCALAR & a, expected);\n-                assert_biteq!(UNSET_SCALAR & a, UNSET_VECTOR);\n+                assert_eq!(true & a, expected);\n+                assert_eq!(false & a, Vector::splat(false));\n             }\n \n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n             fn bitand_assign_scalar() {\n                 let mut a = from_slice(&A);\n                 let expected = a;\n-                a &= SET_SCALAR;\n-                assert_biteq!(a, expected);\n-                a &= UNSET_SCALAR;\n-                assert_biteq!(a, UNSET_VECTOR);\n+                a &= true;\n+                assert_eq!(a, expected);\n+                a &= false;\n+                assert_eq!(a, Vector::splat(false));\n             }\n \n             #[test]\n@@ -100,7 +124,7 @@ macro_rules! mask_tests {\n                 let a = from_slice(&A);\n                 let b = from_slice(&B);\n                 let expected = apply_binary_lanewise(a, b, core::ops::BitOr::bitor);\n-                assert_biteq!(a | b, expected);\n+                assert_eq!(a | b, expected);\n             }\n \n             #[test]\n@@ -110,34 +134,34 @@ macro_rules! mask_tests {\n                 let b = from_slice(&B);\n                 let expected = apply_binary_lanewise(a, b, core::ops::BitOr::bitor);\n                 a |= b;\n-                assert_biteq!(a, expected);\n+                assert_eq!(a, expected);\n             }\n \n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n             fn bitor_scalar_rhs() {\n                 let a = from_slice(&A);\n-                assert_biteq!(a | UNSET_SCALAR, a);\n-                assert_biteq!(a | SET_SCALAR, SET_VECTOR);\n+                assert_eq!(a | false, a);\n+                assert_eq!(a | true, Vector::splat(true));\n             }\n \n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n             fn bitor_scalar_lhs() {\n                 let a = from_slice(&A);\n-                assert_biteq!(UNSET_SCALAR | a, a);\n-                assert_biteq!(SET_SCALAR | a, SET_VECTOR);\n+                assert_eq!(false | a, a);\n+                assert_eq!(true | a, Vector::splat(true));\n             }\n \n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n             fn bitor_assign_scalar() {\n                 let mut a = from_slice(&A);\n                 let expected = a;\n-                a |= UNSET_SCALAR;\n-                assert_biteq!(a, expected);\n-                a |= SET_SCALAR;\n-                assert_biteq!(a, SET_VECTOR);\n+                a |= false;\n+                assert_eq!(a, expected);\n+                a |= true;\n+                assert_eq!(a, Vector::splat(true));\n             }\n \n             #[test]\n@@ -146,7 +170,7 @@ macro_rules! mask_tests {\n                 let a = from_slice(&A);\n                 let b = from_slice(&B);\n                 let expected = apply_binary_lanewise(a, b, core::ops::BitXor::bitxor);\n-                assert_biteq!(a ^ b, expected);\n+                assert_eq!(a ^ b, expected);\n             }\n \n             #[test]\n@@ -156,45 +180,45 @@ macro_rules! mask_tests {\n                 let b = from_slice(&B);\n                 let expected = apply_binary_lanewise(a, b, core::ops::BitXor::bitxor);\n                 a ^= b;\n-                assert_biteq!(a, expected);\n+                assert_eq!(a, expected);\n             }\n \n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n             fn bitxor_scalar_rhs() {\n                 let a = from_slice(&A);\n-                let expected = apply_binary_scalar_rhs_lanewise(a, SET_SCALAR, core::ops::BitXor::bitxor);\n-                assert_biteq!(a ^ UNSET_SCALAR, a);\n-                assert_biteq!(a ^ SET_SCALAR, expected);\n+                let expected = apply_binary_scalar_rhs_lanewise(a, true, core::ops::BitXor::bitxor);\n+                assert_eq!(a ^ false, a);\n+                assert_eq!(a ^ true, expected);\n             }\n \n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n             fn bitxor_scalar_lhs() {\n                 let a = from_slice(&A);\n-                let expected = apply_binary_scalar_lhs_lanewise(SET_SCALAR, a, core::ops::BitXor::bitxor);\n-                assert_biteq!(UNSET_SCALAR ^ a, a);\n-                assert_biteq!(SET_SCALAR ^ a, expected);\n+                let expected = apply_binary_scalar_lhs_lanewise(true, a, core::ops::BitXor::bitxor);\n+                assert_eq!(false ^ a, a);\n+                assert_eq!(true ^ a, expected);\n             }\n \n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n             fn bitxor_assign_scalar() {\n                 let mut a = from_slice(&A);\n                 let expected_unset = a;\n-                let expected_set = apply_binary_scalar_rhs_lanewise(a, SET_SCALAR, core::ops::BitXor::bitxor);\n-                a ^= UNSET_SCALAR;\n-                assert_biteq!(a, expected_unset);\n-                a ^= SET_SCALAR;\n-                assert_biteq!(a, expected_set);\n+                let expected_set = apply_binary_scalar_rhs_lanewise(a, true, core::ops::BitXor::bitxor);\n+                a ^= false;\n+                assert_eq!(a, expected_unset);\n+                a ^= true;\n+                assert_eq!(a, expected_set);\n             }\n \n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n             fn not() {\n                 let v = from_slice(&A);\n                 let expected = apply_unary_lanewise(v, core::ops::Not::not);\n-                assert_biteq!(!v, expected);\n+                assert_eq!(!v, expected);\n             }\n         }\n     }"}, {"sha": "e0a44d870ca56b9bdd2e73085e6f9e59e3ac14c1", "filename": "crates/core_simd/tests/ops_impl/masksize.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmasksize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931c15c0b9fad90b8020ea5a5ad54eef7519edf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmasksize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmasksize.rs?ref=b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "patch": "@@ -1,5 +1,3 @@\n-use super::helpers;\n-\n-mask_tests! { masksizex2, masksize }\n-mask_tests! { masksizex4, masksize }\n-mask_tests! { masksizex8, masksize }\n+mask_tests! { masksizex2, 2 }\n+mask_tests! { masksizex4, 4 }\n+mask_tests! { masksizex8, 8 }"}]}