{"sha": "19e10e3a817336bf01dc13a15fedfb88116c61d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZTEwZTNhODE3MzM2YmYwMWRjMTNhMTVmZWRmYjg4MTE2YzYxZDk=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-06-02T15:18:23Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-06-02T16:41:48Z"}, "message": "Improve code reuse in check_match::specialize()", "tree": {"sha": "745f106715aa712d68663e275976e3f7769644bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/745f106715aa712d68663e275976e3f7769644bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19e10e3a817336bf01dc13a15fedfb88116c61d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19e10e3a817336bf01dc13a15fedfb88116c61d9", "html_url": "https://github.com/rust-lang/rust/commit/19e10e3a817336bf01dc13a15fedfb88116c61d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19e10e3a817336bf01dc13a15fedfb88116c61d9/comments", "author": null, "committer": null, "parents": [{"sha": "b981add9ee56a2d6dc11aa48f01aac5d0dda9327", "url": "https://api.github.com/repos/rust-lang/rust/commits/b981add9ee56a2d6dc11aa48f01aac5d0dda9327", "html_url": "https://github.com/rust-lang/rust/commit/b981add9ee56a2d6dc11aa48f01aac5d0dda9327"}], "stats": {"total": 211, "additions": 83, "deletions": 128}, "files": [{"sha": "bcc132941973c4648c1cbb5b2bb87f20b6b2f6bf", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 83, "deletions": 128, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/19e10e3a817336bf01dc13a15fedfb88116c61d9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19e10e3a817336bf01dc13a15fedfb88116c61d9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=19e10e3a817336bf01dc13a15fedfb88116c61d9", "patch": "@@ -20,7 +20,7 @@ use util::ppaux::ty_to_str;\n use std::cmp;\n use std::iter;\n use syntax::ast::*;\n-use syntax::ast_util::{unguarded_pat, walk_pat};\n+use syntax::ast_util::{is_unguarded, walk_pat};\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token;\n use syntax::visit;\n@@ -79,26 +79,13 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n            // If the type *is* empty, it's vacuously exhaustive\n            return;\n        }\n-       match ty::get(pat_ty).sty {\n-          ty_enum(did, _) => {\n-              if (*enum_variants(cx.tcx, did)).is_empty() &&\n-                    (*arms).is_empty() {\n-\n-               return;\n-            }\n-          }\n-          _ => { /* We assume only enum types can be uninhabited */ }\n-       }\n-\n-       let pats: Vec<@Pat> = arms.iter()\n-                               .filter_map(unguarded_pat)\n-                               .flat_map(|pats| pats.move_iter())\n-                               .collect();\n-       if pats.is_empty() {\n-           cx.tcx.sess.span_err(ex.span, \"non-exhaustive patterns\");\n-       } else {\n-           check_exhaustive(cx, ex.span, pats);\n-       }\n+       let m: matrix = arms\n+          .iter()\n+          .filter(|&arm| is_unguarded(arm))\n+          .flat_map(|arm| arm.pats.iter())\n+          .map(|pat| vec!(pat.clone()))\n+          .collect();\n+       check_exhaustive(cx, ex.span, &m);\n      }\n      _ => ()\n     }\n@@ -152,9 +139,8 @@ fn raw_pat(p: @Pat) -> @Pat {\n     }\n }\n \n-fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: Vec<@Pat> ) {\n-    assert!((!pats.is_empty()));\n-    let ext = match is_useful(cx, &pats.iter().map(|p| vec!(*p)).collect(), [wild()]) {\n+fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, m: &matrix) {\n+    let ext = match is_useful(cx, m, [wild()]) {\n         not_useful => {\n             // This is good, wildcard pattern isn't reachable\n             return;\n@@ -587,23 +573,20 @@ fn specialize(cx: &MatchCheckCtxt,\n                   arity: uint,\n                   left_ty: ty::t)\n                -> Option<Vec<@Pat> > {\n-    // Sad, but I can't get rid of this easily\n-    let r0 = (*raw_pat(r[0])).clone();\n-    match r0 {\n-        Pat{id: pat_id, node: n, span: pat_span} =>\n-            match n {\n-            PatWild => {\n-                Some(Vec::from_elem(arity, wild()).append(r.tail()))\n+    let &Pat{id: ref pat_id, node: ref n, span: ref pat_span} = &(*raw_pat(r[0]));\n+    let head: Option<Vec<@Pat>> = match n {\n+            &PatWild => {\n+                Some(Vec::from_elem(arity, wild()))\n             }\n-            PatWildMulti => {\n-                Some(Vec::from_elem(arity, wild_multi()).append(r.tail()))\n+            &PatWildMulti => {\n+                Some(Vec::from_elem(arity, wild_multi()))\n             }\n-            PatIdent(_, _, _) => {\n-                let opt_def = cx.tcx.def_map.borrow().find_copy(&pat_id);\n+            &PatIdent(_, _, _) => {\n+                let opt_def = cx.tcx.def_map.borrow().find_copy(pat_id);\n                 match opt_def {\n                     Some(DefVariant(_, id, _)) => {\n                         if variant(id) == *ctor_id {\n-                            Some(Vec::from_slice(r.tail()))\n+                            Some(vec!())\n                         } else {\n                             None\n                         }\n@@ -617,7 +600,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                                 match compare_const_vals(&e_v, v) {\n                                     Some(val1) => (val1 == 0),\n                                     None => {\n-                                        cx.tcx.sess.span_err(pat_span,\n+                                        cx.tcx.sess.span_err(*pat_span,\n                                             \"mismatched types between arms\");\n                                         false\n                                     }\n@@ -631,7 +614,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                                         (val1 >= 0 && val2 <= 0)\n                                     }\n                                     _ => {\n-                                        cx.tcx.sess.span_err(pat_span,\n+                                        cx.tcx.sess.span_err(*pat_span,\n                                             \"mismatched types between ranges\");\n                                         false\n                                     }\n@@ -641,18 +624,18 @@ fn specialize(cx: &MatchCheckCtxt,\n                             _ => fail!(\"type error\")\n                         };\n                         if match_ {\n-                            Some(Vec::from_slice(r.tail()))\n+                            Some(vec!())\n                         } else {\n                             None\n                         }\n                     }\n                     _ => {\n-                        Some(Vec::from_elem(arity, wild()).append(r.tail()))\n+                        Some(Vec::from_elem(arity, wild()))\n                     }\n                 }\n             }\n-            PatEnum(_, args) => {\n-                let def = cx.tcx.def_map.borrow().get_copy(&pat_id);\n+            &PatEnum(_, ref args) => {\n+                let def = cx.tcx.def_map.borrow().get_copy(pat_id);\n                 match def {\n                     DefStatic(did, _) => {\n                         let const_expr =\n@@ -663,7 +646,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                                 match compare_const_vals(&e_v, v) {\n                                     Some(val1) => (val1 == 0),\n                                     None => {\n-                                        cx.tcx.sess.span_err(pat_span,\n+                                        cx.tcx.sess.span_err(*pat_span,\n                                             \"mismatched types between arms\");\n                                         false\n                                     }\n@@ -674,7 +657,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                                 match (m1, m2) {\n                                     (Some(val1), Some(val2)) => (val1 >= 0 && val2 <= 0),\n                                     _ => {\n-                                        cx.tcx.sess.span_err(pat_span,\n+                                        cx.tcx.sess.span_err(*pat_span,\n                                             \"mismatched types between ranges\");\n                                         false\n                                     }\n@@ -684,97 +667,72 @@ fn specialize(cx: &MatchCheckCtxt,\n                             _ => fail!(\"type error\")\n                         };\n                         if match_ {\n-                            Some(Vec::from_slice(r.tail()))\n+                            Some(vec!())\n                         } else {\n                             None\n                         }\n                     }\n-                    DefVariant(_, id, _) if variant(id) == *ctor_id => {\n-                        let args = match args {\n-                            Some(args) => args.iter().map(|x| *x).collect(),\n-                            None => Vec::from_elem(arity, wild())\n-                        };\n-                        Some(args.append(r.tail()))\n-                    }\n-                    DefVariant(_, _, _) => None,\n-\n-                    DefFn(..) |\n-                    DefStruct(..) => {\n-                        let new_args;\n-                        match args {\n-                            Some(args) => {\n-                                new_args = args.iter().map(|x| *x).collect()\n-                            }\n-                            None => new_args = Vec::from_elem(arity, wild())\n-                        }\n-                        Some(new_args.append(r.tail()))\n+                    DefVariant(_, id, _) if variant(id) != *ctor_id => None,\n+                    DefVariant(..) | DefFn(..) | DefStruct(..) => {\n+                        Some(match args {\n+                            &Some(ref args) => args.clone(),\n+                            &None => Vec::from_elem(arity, wild())\n+                        })\n                     }\n                     _ => None\n                 }\n             }\n-            PatStruct(_, ref pattern_fields, _) => {\n+            &PatStruct(_, ref pattern_fields, _) => {\n                 // Is this a struct or an enum variant?\n-                let def = cx.tcx.def_map.borrow().get_copy(&pat_id);\n-                match def {\n+                let def = cx.tcx.def_map.borrow().get_copy(pat_id);\n+                let class_id = match def {\n                     DefVariant(_, variant_id, _) => {\n-                        if variant(variant_id) == *ctor_id {\n-                            let struct_fields = ty::lookup_struct_fields(cx.tcx, variant_id);\n-                            let args = struct_fields.iter().map(|sf| {\n-                                match pattern_fields.iter().find(|f| f.ident.name == sf.name) {\n-                                    Some(f) => f.pat,\n-                                    _ => wild()\n-                                }\n-                            }).collect::<Vec<_>>();\n-                            Some(args.append(r.tail()))\n-                        } else {\n-                            None\n-                        }\n+                      if variant(variant_id) == *ctor_id {\n+                        Some(variant_id)\n+                      } else {\n+                        None\n+                      }\n                     }\n                     _ => {\n-                        // Grab the class data that we care about.\n-                        let class_fields;\n-                        let class_id;\n                         match ty::get(left_ty).sty {\n-                            ty::ty_struct(cid, _) => {\n-                                class_id = cid;\n-                                class_fields =\n-                                    ty::lookup_struct_fields(cx.tcx,\n-                                                             class_id);\n-                            }\n+                            ty::ty_struct(cid, _) => Some(cid),\n                             _ => {\n                                 cx.tcx.sess.span_bug(\n-                                    pat_span,\n+                                    *pat_span,\n                                     format!(\"struct pattern resolved to {}, \\\n                                           not a struct\",\n                                          ty_to_str(cx.tcx,\n                                                    left_ty)).as_slice());\n                             }\n                         }\n-                        let args = class_fields.iter().map(|class_field| {\n-                            match pattern_fields.iter().find(|f|\n-                                            f.ident.name == class_field.name) {\n-                                Some(f) => f.pat,\n-                                _ => wild()\n-                            }\n-                        }).collect::<Vec<_>>();\n-                        Some(args.append(r.tail()))\n                     }\n-                }\n+                };\n+                class_id.map(|variant_id| {\n+                  let struct_fields = ty::lookup_struct_fields(cx.tcx, variant_id);\n+                  let args = struct_fields.iter().map(|sf| {\n+                      match pattern_fields.iter().find(|f| f.ident.name == sf.name) {\n+                          Some(f) => f.pat,\n+                          _ => wild()\n+                      }\n+                  }).collect();\n+                  args\n+                })\n+\n             }\n-            PatTup(args) => {\n-                Some(args.iter().map(|x| *x).collect::<Vec<_>>().append(r.tail()))\n+            &PatTup(ref args) => {\n+                Some(args.iter().map(|x| *x).collect())\n             }\n-            PatBox(a) | PatRegion(a) => {\n-                Some((vec!(a)).append(r.tail()))\n+            &PatBox(ref inner) | &PatRegion(ref inner) => {\n+                Some(vec!(inner.clone()))\n             }\n-            PatLit(expr) => {\n-                let e_v = eval_const_expr(cx.tcx, expr);\n+            &PatLit(ref expr) => {\n+                let e_v = eval_const_expr(cx.tcx, *expr);\n                 let match_ = match *ctor_id {\n                     val(ref v) => {\n                         match compare_const_vals(&e_v, v) {\n                             Some(val1) => val1 == 0,\n                             None => {\n-                                cx.tcx.sess.span_err(pat_span,\n+                                cx.tcx.sess.span_err(*pat_span,\n                                     \"mismatched types between arms\");\n                                 false\n                             }\n@@ -786,7 +744,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                         match (m1, m2) {\n                             (Some(val1), Some(val2)) => (val1 >= 0 && val2 <= 0),\n                             _ => {\n-                                cx.tcx.sess.span_err(pat_span,\n+                                cx.tcx.sess.span_err(*pat_span,\n                                     \"mismatched types between ranges\");\n                                 false\n                             }\n@@ -796,52 +754,49 @@ fn specialize(cx: &MatchCheckCtxt,\n                     _ => fail!(\"type error\")\n                 };\n                 if match_ {\n-                    Some(Vec::from_slice(r.tail()))\n+                    Some(vec!())\n                 } else {\n                     None\n                 }\n             }\n-            PatRange(lo, hi) => {\n+            &PatRange(lo, hi) => {\n                 let (c_lo, c_hi) = match *ctor_id {\n-                    val(ref v) => ((*v).clone(), (*v).clone()),\n-                    range(ref lo, ref hi) => ((*lo).clone(), (*hi).clone()),\n-                    single => return Some(Vec::from_slice(r.tail())),\n+                    val(ref v) => (v, v),\n+                    range(ref lo, ref hi) => (lo, hi),\n+                    single => return Some(vec!()),\n                     _ => fail!(\"type error\")\n                 };\n                 let v_lo = eval_const_expr(cx.tcx, lo);\n                 let v_hi = eval_const_expr(cx.tcx, hi);\n \n-                let m1 = compare_const_vals(&c_lo, &v_lo);\n-                let m2 = compare_const_vals(&c_hi, &v_hi);\n+                let m1 = compare_const_vals(c_lo, &v_lo);\n+                let m2 = compare_const_vals(c_hi, &v_hi);\n                 match (m1, m2) {\n                     (Some(val1), Some(val2)) if val1 >= 0 && val2 <= 0 => {\n-                        Some(Vec::from_slice(r.tail()))\n+                        Some(vec!())\n                     },\n                     (Some(_), Some(_)) => None,\n                     _ => {\n-                        cx.tcx.sess.span_err(pat_span,\n+                        cx.tcx.sess.span_err(*pat_span,\n                             \"mismatched types between ranges\");\n                         None\n                     }\n                 }\n             }\n-            PatVec(before, slice, after) => {\n+            &PatVec(ref before, ref slice, ref after) => {\n                 match *ctor_id {\n                     vec(_) => {\n                         let num_elements = before.len() + after.len();\n                         if num_elements < arity && slice.is_some() {\n                             let mut result = Vec::new();\n-                            let wilds = Vec::from_elem(arity - num_elements, wild());\n-                            result.push_all_move(before);\n-                            result.push_all_move(wilds);\n-                            result.push_all_move(after);\n-                            result.push_all(r.tail());\n+                            result.push_all(before.as_slice());\n+                            result.grow_fn(arity - num_elements, |_| wild());\n+                            result.push_all(after.as_slice());\n                             Some(result)\n                         } else if num_elements == arity {\n                             let mut result = Vec::new();\n-                            result.push_all_move(before);\n-                            result.push_all_move(after);\n-                            result.push_all(r.tail());\n+                            result.push_all(before.as_slice());\n+                            result.push_all(after.as_slice());\n                             Some(result)\n                         } else {\n                             None\n@@ -850,12 +805,12 @@ fn specialize(cx: &MatchCheckCtxt,\n                     _ => None\n                 }\n             }\n-            PatMac(_) => {\n-                cx.tcx.sess.span_err(pat_span, \"unexpanded macro\");\n+            &PatMac(_) => {\n+                cx.tcx.sess.span_err(*pat_span, \"unexpanded macro\");\n                 None\n             }\n-        }\n-    }\n+    };\n+    head.map(|head| head.append(r.tail()))\n }\n \n fn default(cx: &MatchCheckCtxt, r: &[@Pat]) -> Option<Vec<@Pat> > {"}]}