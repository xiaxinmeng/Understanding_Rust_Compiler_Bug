{"sha": "e24730cb846f0fd1f5c28f5336e38be6e0143c5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyNDczMGNiODQ2ZjBmZDFmNWMyOGY1MzM2ZTM4YmU2ZTAxNDNjNWU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-13T15:20:14Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-13T15:20:14Z"}, "message": "Merge pull request #547 from mcarton/single_match\n\nImprove the single_match lint", "tree": {"sha": "6383779b3a95b1cde17a8f45631bcc9bb430b6f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6383779b3a95b1cde17a8f45631bcc9bb430b6f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e24730cb846f0fd1f5c28f5336e38be6e0143c5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e24730cb846f0fd1f5c28f5336e38be6e0143c5e", "html_url": "https://github.com/rust-lang/rust/commit/e24730cb846f0fd1f5c28f5336e38be6e0143c5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e24730cb846f0fd1f5c28f5336e38be6e0143c5e/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5009f8e1505ca4e6b113be3046093127477f14db", "url": "https://api.github.com/repos/rust-lang/rust/commits/5009f8e1505ca4e6b113be3046093127477f14db", "html_url": "https://github.com/rust-lang/rust/commit/5009f8e1505ca4e6b113be3046093127477f14db"}, {"sha": "44daa8bd72d29b281741a6fc11e07faa03d5fb1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/44daa8bd72d29b281741a6fc11e07faa03d5fb1e", "html_url": "https://github.com/rust-lang/rust/commit/44daa8bd72d29b281741a6fc11e07faa03d5fb1e"}], "stats": {"total": 187, "additions": 131, "deletions": 56}, "files": [{"sha": "4cb4df19bf80ba30276c39eb7ad525e4e6849482", "filename": "src/matches.rs", "status": "modified", "additions": 86, "deletions": 51, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/e24730cb846f0fd1f5c28f5336e38be6e0143c5e/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24730cb846f0fd1f5c28f5336e38be6e0143c5e/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=e24730cb846f0fd1f5c28f5336e38be6e0143c5e", "patch": "@@ -8,7 +8,8 @@ use std::cmp::Ordering;\n use syntax::ast::Lit_::LitBool;\n use syntax::codemap::Span;\n \n-use utils::{snippet, span_lint, span_note_and_lint, span_help_and_lint, in_external_macro, expr_block};\n+use utils::{COW_PATH, OPTION_PATH, RESULT_PATH};\n+use utils::{match_type, snippet, span_lint, span_note_and_lint, span_lint_and_then, in_external_macro, expr_block};\n \n /// **What it does:** This lint checks for matches with a single arm where an `if let` will usually suffice. It is `Warn` by default.\n ///\n@@ -109,25 +110,73 @@ impl LateLintPass for MatchPass {\n }\n \n fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n-    if arms.len() == 2 && arms[0].pats.len() == 1 && arms[0].guard.is_none() && arms[1].pats.len() == 1 &&\n-       arms[1].guard.is_none() && arms[1].pats[0].node == PatWild && is_unit_expr(&arms[1].body) &&\n-       (cx.tcx.expr_ty(ex).sty != ty::TyBool || cx.current_level(MATCH_BOOL) == Allow) {\n-        span_help_and_lint(cx,\n+    if arms.len() == 2 &&\n+       arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n+       arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n+       is_unit_expr(&arms[1].body) {\n+           let ty = cx.tcx.expr_ty(ex);\n+           if ty.sty != ty::TyBool || cx.current_level(MATCH_BOOL) == Allow {\n+                check_single_match_single_pattern(cx, ex, arms, expr);\n+                check_single_match_opt_like(cx, ex, arms, expr, ty);\n+           }\n+    }\n+}\n+\n+fn check_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+    if arms[1].pats[0].node == PatWild {\n+        span_lint_and_then(cx,\n                            SINGLE_MATCH,\n                            expr.span,\n-                           \"you seem to be trying to use match for destructuring a single pattern. Consider using \\\n-                            `if let`\",\n-                           &format!(\"try\\nif let {} = {} {}\",\n-                                    snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                    snippet(cx, ex.span, \"..\"),\n-                                    expr_block(cx, &arms[0].body, None, \"..\")));\n+                           \"you seem to be trying to use match for destructuring a single pattern. \\\n+                           Consider using `if let`\", |db| {\n+                db.span_suggestion(expr.span, \"try this\",\n+                                   format!(\"if let {} = {} {}\",\n+                                           snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                           snippet(cx, ex.span, \"..\"),\n+                                           expr_block(cx, &arms[0].body, None, \"..\")));\n+            });\n+    }\n+}\n+\n+fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, ty: ty::Ty) {\n+    // list of candidate Enums we know will never get any more membre\n+    let candidates = &[\n+        (&COW_PATH, \"Borrowed\"),\n+        (&COW_PATH, \"Cow::Borrowed\"),\n+        (&COW_PATH, \"Cow::Owned\"),\n+        (&COW_PATH, \"Owned\"),\n+        (&OPTION_PATH, \"None\"),\n+        (&RESULT_PATH, \"Err\"),\n+        (&RESULT_PATH, \"Ok\"),\n+    ];\n+\n+    let path = match arms[1].pats[0].node {\n+        PatEnum(ref path, _) => path.to_string(),\n+        PatIdent(BindByValue(MutImmutable), ident, None) => ident.node.to_string(),\n+        _ => return\n+    };\n+\n+    for &(ty_path, pat_path) in candidates {\n+        if &path == pat_path && match_type(cx, ty, ty_path) {\n+            span_lint_and_then(cx,\n+                               SINGLE_MATCH,\n+                               expr.span,\n+                               \"you seem to be trying to use match for destructuring a single pattern. \\\n+                               Consider using `if let`\", |db| {\n+                db.span_suggestion(expr.span, \"try this\",\n+                                   format!(\"if let {} = {} {}\",\n+                                           snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                           snippet(cx, ex.span, \"..\"),\n+                                           expr_block(cx, &arms[0].body, None, \"..\")));\n+            });\n+        }\n     }\n }\n \n fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     // type of expression == bool\n     if cx.tcx.expr_ty(ex).sty == ty::TyBool {\n-        if arms.len() == 2 && arms[0].pats.len() == 1 {\n+        let sugg = if arms.len() == 2 && arms[0].pats.len() == 1 {\n             // no guards\n             let exprs = if let PatLit(ref arm_bool) = arms[0].pats[0].node {\n                 if let ExprLit(ref lit) = arm_bool.node {\n@@ -142,56 +191,42 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n             } else {\n                 None\n             };\n+\n             if let Some((ref true_expr, ref false_expr)) = exprs {\n                 if !is_unit_expr(true_expr) {\n                     if !is_unit_expr(false_expr) {\n-                        span_help_and_lint(cx,\n-                                           MATCH_BOOL,\n-                                           expr.span,\n-                                           \"you seem to be trying to match on a boolean expression. Consider using \\\n-                                            an if..else block:\",\n-                                           &format!(\"try\\nif {} {} else {}\",\n-                                                    snippet(cx, ex.span, \"b\"),\n-                                                    expr_block(cx, true_expr, None, \"..\"),\n-                                                    expr_block(cx, false_expr, None, \"..\")));\n+                        Some(format!(\"if {} {} else {}\",\n+                                     snippet(cx, ex.span, \"b\"),\n+                                     expr_block(cx, true_expr, None, \"..\"),\n+                                     expr_block(cx, false_expr, None, \"..\")))\n                     } else {\n-                        span_help_and_lint(cx,\n-                                           MATCH_BOOL,\n-                                           expr.span,\n-                                           \"you seem to be trying to match on a boolean expression. Consider using \\\n-                                            an if..else block:\",\n-                                           &format!(\"try\\nif {} {}\",\n-                                                    snippet(cx, ex.span, \"b\"),\n-                                                    expr_block(cx, true_expr, None, \"..\")));\n+                        Some(format!(\"if {} {}\",\n+                                     snippet(cx, ex.span, \"b\"),\n+                                     expr_block(cx, true_expr, None, \"..\")))\n                     }\n                 } else if !is_unit_expr(false_expr) {\n-                    span_help_and_lint(cx,\n-                                       MATCH_BOOL,\n-                                       expr.span,\n-                                       \"you seem to be trying to match on a boolean expression. Consider using an \\\n-                                        if..else block:\",\n-                                       &format!(\"try\\nif !{} {}\",\n-                                                snippet(cx, ex.span, \"b\"),\n-                                                expr_block(cx, false_expr, None, \"..\")));\n+                    Some(format!(\"try\\nif !{} {}\",\n+                                 snippet(cx, ex.span, \"b\"),\n+                                 expr_block(cx, false_expr, None, \"..\")))\n                 } else {\n-                    span_lint(cx,\n-                              MATCH_BOOL,\n-                              expr.span,\n-                              \"you seem to be trying to match on a boolean expression. Consider using an if..else \\\n-                               block\");\n+                    None\n                 }\n             } else {\n-                span_lint(cx,\n-                          MATCH_BOOL,\n-                          expr.span,\n-                          \"you seem to be trying to match on a boolean expression. Consider using an if..else block\");\n+                None\n             }\n         } else {\n-            span_lint(cx,\n-                      MATCH_BOOL,\n-                      expr.span,\n-                      \"you seem to be trying to match on a boolean expression. Consider using an if..else block\");\n-        }\n+            None\n+        };\n+\n+        span_lint_and_then(cx,\n+                           MATCH_BOOL,\n+                           expr.span,\n+                           \"you seem to be trying to match on a boolean expression. Consider using \\\n+                           an if..else block:\", move |db| {\n+            if let Some(ref sugg) = sugg {\n+                db.span_suggestion(expr.span, \"try this\", sugg.clone());\n+            }\n+        });\n     }\n }\n "}, {"sha": "77e63fe4458a43d385c7812b678fa7d7e621f78a", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e24730cb846f0fd1f5c28f5336e38be6e0143c5e/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24730cb846f0fd1f5c28f5336e38be6e0143c5e/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=e24730cb846f0fd1f5c28f5336e38be6e0143c5e", "patch": "@@ -29,6 +29,7 @@ pub const OPEN_OPTIONS_PATH: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n pub const MUTEX_PATH: [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n pub const CLONE_PATH: [&'static str; 2] = [\"Clone\", \"clone\"];\n pub const BEGIN_UNWIND: [&'static str; 3] = [\"std\", \"rt\", \"begin_unwind\"];\n+pub const COW_PATH: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n \n /// Produce a nested chain of if-lets and ifs from the patterns:\n ///"}, {"sha": "c58e62419c6b7cd866dbf267efdd890af01db1f5", "filename": "tests/compile-fail/matches.rs", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e24730cb846f0fd1f5c28f5336e38be6e0143c5e/tests%2Fcompile-fail%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24730cb846f0fd1f5c28f5336e38be6e0143c5e/tests%2Fcompile-fail%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatches.rs?ref=e24730cb846f0fd1f5c28f5336e38be6e0143c5e", "patch": "@@ -4,20 +4,22 @@\n #![deny(clippy)]\n #![allow(unused)]\n \n+use std::borrow::Cow;\n+\n+enum Foo { Bar, Baz(u8) }\n+use Foo::*;\n+\n fn single_match(){\n     let x = Some(1u8);\n+\n     match x {  //~ ERROR you seem to be trying to use match\n                //~^ HELP try\n         Some(y) => {\n             println!(\"{:?}\", y);\n         }\n         _ => ()\n     }\n-    // Not linted\n-    match x {\n-        Some(y) => println!(\"{:?}\", y),\n-        None => ()\n-    }\n+\n     let z = (1u8,1u8);\n     match z { //~ ERROR you seem to be trying to use match\n               //~^ HELP try\n@@ -38,6 +40,43 @@ fn single_match(){\n     }\n }\n \n+fn single_match_know_enum() {\n+    let x = Some(1u8);\n+    let y : Result<_, i8> = Ok(1i8);\n+\n+    match x { //~ ERROR you seem to be trying to use match\n+              //~^ HELP try\n+        Some(y) => println!(\"{:?}\", y),\n+        None => ()\n+    }\n+\n+    match y { //~ ERROR you seem to be trying to use match\n+              //~^ HELP try\n+        Ok(y) => println!(\"{:?}\", y),\n+        Err(..) => ()\n+    }\n+\n+    let c = Cow::Borrowed(\"\");\n+\n+    match c { //~ ERROR you seem to be trying to use match\n+              //~^ HELP try\n+        Cow::Borrowed(..) => println!(\"42\"),\n+        Cow::Owned(..) => (),\n+    }\n+\n+    let z = Foo::Bar;\n+    // no warning\n+    match z {\n+        Bar => println!(\"42\"),\n+        Baz(_) => (),\n+    }\n+\n+    match z {\n+        Baz(_) => println!(\"42\"),\n+        Bar => (),\n+    }\n+}\n+\n fn match_bool() {\n     let test: bool = true;\n "}]}