{"sha": "7690fe3bc66cae219301368650317936f0d4e3a9", "node_id": "C_kwDOAAsO6NoAKDc2OTBmZTNiYzY2Y2FlMjE5MzAxMzY4NjUwMzE3OTM2ZjBkNGUzYTk", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-10T20:31:01Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-04T00:48:07Z"}, "message": "Simplify some iterator combinators", "tree": {"sha": "f0fdc029c670efe12319708106ef258f976c8bba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0fdc029c670efe12319708106ef258f976c8bba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7690fe3bc66cae219301368650317936f0d4e3a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7690fe3bc66cae219301368650317936f0d4e3a9", "html_url": "https://github.com/rust-lang/rust/commit/7690fe3bc66cae219301368650317936f0d4e3a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7690fe3bc66cae219301368650317936f0d4e3a9/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7572670a1302f5c7e245d069200e22da9df0316", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7572670a1302f5c7e245d069200e22da9df0316", "html_url": "https://github.com/rust-lang/rust/commit/c7572670a1302f5c7e245d069200e22da9df0316"}], "stats": {"total": 226, "additions": 91, "deletions": 135}, "files": [{"sha": "6d6ad199be35c2f15ceebb0dc428260d0477f86c", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=7690fe3bc66cae219301368650317936f0d4e3a9", "patch": "@@ -527,26 +527,21 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // that are *partially* initialized by assigning to a field of an uninitialized\n             // binding. We differentiate between them for more accurate wording here.\n             \"isn't fully initialized\"\n-        } else if spans\n-            .iter()\n-            .filter(|i| {\n-                // We filter these to avoid misleading wording in cases like the following,\n-                // where `x` has an `init`, but it is in the same place we're looking at:\n-                // ```\n-                // let x;\n-                // x += 1;\n-                // ```\n-                !i.contains(span)\n+        } else if !spans.iter().any(|i| {\n+            // We filter these to avoid misleading wording in cases like the following,\n+            // where `x` has an `init`, but it is in the same place we're looking at:\n+            // ```\n+            // let x;\n+            // x += 1;\n+            // ```\n+            !i.contains(span)\n                     // We filter these to avoid incorrect main message on `match-cfg-fake-edges.rs`\n                         && !visitor\n                             .errors\n                             .iter()\n                             .map(|(sp, _)| *sp)\n                             .any(|sp| span < sp && !sp.contains(span))\n-            })\n-            .count()\n-            == 0\n-        {\n+        }) {\n             show_assign_sugg = true;\n             \"isn't initialized\"\n         } else {"}, {"sha": "631e147ce8c5f8ed05f9e36ce68a21816dd0ece5", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=7690fe3bc66cae219301368650317936f0d4e3a9", "patch": "@@ -316,35 +316,29 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         // obligation comes from the `impl`. Find that `impl` so that we can point\n                         // at it in the suggestion.\n                         let trait_did = trait_did.to_def_id();\n-                        match tcx\n-                            .hir()\n-                            .trait_impls(trait_did)\n-                            .iter()\n-                            .filter_map(|&impl_did| {\n-                                match tcx.hir().get_if_local(impl_did.to_def_id()) {\n-                                    Some(Node::Item(Item {\n-                                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n-                                        ..\n-                                    })) if trait_objects.iter().all(|did| {\n-                                        // FIXME: we should check `self_ty` against the receiver\n-                                        // type in the `UnifyReceiver` context, but for now, use\n-                                        // this imperfect proxy. This will fail if there are\n-                                        // multiple `impl`s for the same trait like\n-                                        // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n-                                        // In that case, only the first one will get suggestions.\n-                                        let mut traits = vec![];\n-                                        let mut hir_v = HirTraitObjectVisitor(&mut traits, *did);\n-                                        hir_v.visit_ty(self_ty);\n-                                        !traits.is_empty()\n-                                    }) =>\n-                                    {\n-                                        Some(self_ty)\n-                                    }\n-                                    _ => None,\n+                        match tcx.hir().trait_impls(trait_did).iter().find_map(|&impl_did| {\n+                            match tcx.hir().get_if_local(impl_did.to_def_id()) {\n+                                Some(Node::Item(Item {\n+                                    kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n+                                    ..\n+                                })) if trait_objects.iter().all(|did| {\n+                                    // FIXME: we should check `self_ty` against the receiver\n+                                    // type in the `UnifyReceiver` context, but for now, use\n+                                    // this imperfect proxy. This will fail if there are\n+                                    // multiple `impl`s for the same trait like\n+                                    // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n+                                    // In that case, only the first one will get suggestions.\n+                                    let mut traits = vec![];\n+                                    let mut hir_v = HirTraitObjectVisitor(&mut traits, *did);\n+                                    hir_v.visit_ty(self_ty);\n+                                    !traits.is_empty()\n+                                }) =>\n+                                {\n+                                    Some(self_ty)\n                                 }\n-                            })\n-                            .next()\n-                        {\n+                                _ => None,\n+                            }\n+                        }) {\n                             Some(self_ty) => Some((trait_item.ident, self_ty)),\n                             _ => None,\n                         }"}, {"sha": "a92242b2615c1f66b1cfb438c61a0bbf48ad0e97", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=7690fe3bc66cae219301368650317936f0d4e3a9", "patch": "@@ -1244,7 +1244,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     ) -> RValue<'gcc> {\n         // FIXME(antoyo): remove when having a proper API.\n         let gcc_func = unsafe { std::mem::transmute(func) };\n-        let call = if self.functions.borrow().values().find(|value| **value == gcc_func).is_some() {\n+        let call = if self.functions.borrow().values().any(|value| *value == gcc_func) {\n             self.function_call(func, args, funclet)\n         }\n         else {"}, {"sha": "4424b31c0542c65777d80571ebc85cafbdd1c925", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=7690fe3bc66cae219301368650317936f0d4e3a9", "patch": "@@ -253,7 +253,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n \n     pub fn rvalue_as_function(&self, value: RValue<'gcc>) -> Function<'gcc> {\n         let function: Function<'gcc> = unsafe { std::mem::transmute(value) };\n-        debug_assert!(self.functions.borrow().values().find(|value| **value == function).is_some(),\n+        debug_assert!(self.functions.borrow().values().any(|value| *value == function),\n             \"{:?} ({:?}) is not a function\", value, value.get_type());\n         function\n     }"}, {"sha": "cecf3d3f1e0644c2656924a4e4aa10cf13f9a7bc", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=7690fe3bc66cae219301368650317936f0d4e3a9", "patch": "@@ -240,10 +240,8 @@ fn typeck_with_fallback<'tcx>(\n                         }),\n                         Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(asm), .. })\n                         | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. }) => {\n-                            let operand_ty = asm\n-                                .operands\n-                                .iter()\n-                                .filter_map(|(op, _op_sp)| match op {\n+                            let operand_ty =\n+                                asm.operands.iter().find_map(|(op, _op_sp)| match op {\n                                     hir::InlineAsmOperand::Const { anon_const }\n                                         if anon_const.hir_id == id =>\n                                     {\n@@ -259,8 +257,7 @@ fn typeck_with_fallback<'tcx>(\n                                         }))\n                                     }\n                                     _ => None,\n-                                })\n-                                .next();\n+                                });\n                             operand_ty.unwrap_or_else(fallback)\n                         }\n                         _ => fallback(),"}, {"sha": "3d6c2119bea333e568dbd49f026bd343f1bdb32c", "filename": "compiler/rustc_hir_typeck/src/method/prelude2021.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs?ref=7690fe3bc66cae219301368650317936f0d4e3a9", "patch": "@@ -341,8 +341,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Find an identifier with which this trait was imported (note that `_` doesn't count).\n         let any_id = import_items\n             .iter()\n-            .filter_map(|item| if item.ident.name != Underscore { Some(item.ident) } else { None })\n-            .next();\n+            .find_map(|item| if item.ident.name != Underscore { Some(item.ident) } else { None });\n         if let Some(any_id) = any_id {\n             if any_id.name == Empty {\n                 // Glob import, so just use its name."}, {"sha": "2daf1979ee5e69d51642a7588f38aa29d6a12272", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=7690fe3bc66cae219301368650317936f0d4e3a9", "patch": "@@ -1111,7 +1111,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 // a raw pointer\n                 !step.self_ty.references_error() && !step.from_unsafe_deref\n             })\n-            .flat_map(|step| {\n+            .find_map(|step| {\n                 let InferOk { value: self_ty, obligations: _ } = self\n                     .fcx\n                     .probe_instantiate_query_response(\n@@ -1147,7 +1147,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         })\n                     })\n             })\n-            .next()\n     }\n \n     /// For each type `T` in the step list, this attempts to find a method where"}, {"sha": "b04ef55a994ea61dbdcf7c36c98d48b55462f245", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=7690fe3bc66cae219301368650317936f0d4e3a9", "patch": "@@ -257,9 +257,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         self.tcx\n                             .inherent_impls(adt_def.did())\n                             .iter()\n-                            .filter_map(|def_id| self.associated_value(*def_id, item_name))\n-                            .count()\n-                            >= 1\n+                            .any(|def_id| self.associated_value(*def_id, item_name).is_some())\n                     } else {\n                         false\n                     }"}, {"sha": "58be91bc276a997aa129c24d838eea23f60e585e", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 36, "deletions": 55, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=7690fe3bc66cae219301368650317936f0d4e3a9", "patch": "@@ -309,19 +309,12 @@ pub fn suggest_new_region_bound(\n                 let did = item_id.owner_id.to_def_id();\n                 let ty = tcx.mk_opaque(did, ty::InternalSubsts::identity_for_item(tcx, did));\n \n-                if let Some(span) = opaque\n-                    .bounds\n-                    .iter()\n-                    .filter_map(|arg| match arg {\n-                        GenericBound::Outlives(Lifetime {\n-                            res: LifetimeName::Static,\n-                            ident,\n-                            ..\n-                        }) => Some(ident.span),\n-                        _ => None,\n-                    })\n-                    .next()\n-                {\n+                if let Some(span) = opaque.bounds.iter().find_map(|arg| match arg {\n+                    GenericBound::Outlives(Lifetime {\n+                        res: LifetimeName::Static, ident, ..\n+                    }) => Some(ident.span),\n+                    _ => None,\n+                }) {\n                     if let Some(explicit_static) = &explicit_static {\n                         err.span_suggestion_verbose(\n                             span,\n@@ -338,20 +331,14 @@ pub fn suggest_new_region_bound(\n                             Applicability::MaybeIncorrect,\n                         );\n                     }\n-                } else if opaque\n-                    .bounds\n-                    .iter()\n-                    .filter_map(|arg| match arg {\n-                        GenericBound::Outlives(Lifetime { ident, .. })\n-                            if ident.name.to_string() == lifetime_name =>\n-                        {\n-                            Some(ident.span)\n-                        }\n-                        _ => None,\n-                    })\n-                    .next()\n-                    .is_some()\n-                {\n+                } else if opaque.bounds.iter().any(|arg| match arg {\n+                    GenericBound::Outlives(Lifetime { ident, .. })\n+                        if ident.name.to_string() == lifetime_name =>\n+                    {\n+                        true\n+                    }\n+                    _ => false,\n+                }) {\n                 } else {\n                     err.span_suggestion_verbose(\n                         fn_return.span.shrink_to_hi(),\n@@ -428,35 +415,29 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                         // obligation comes from the `impl`. Find that `impl` so that we can point\n                         // at it in the suggestion.\n                         let trait_did = trait_did.to_def_id();\n-                        match tcx\n-                            .hir()\n-                            .trait_impls(trait_did)\n-                            .iter()\n-                            .filter_map(|&impl_did| {\n-                                match tcx.hir().get_if_local(impl_did.to_def_id()) {\n-                                    Some(Node::Item(Item {\n-                                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n-                                        ..\n-                                    })) if trait_objects.iter().all(|did| {\n-                                        // FIXME: we should check `self_ty` against the receiver\n-                                        // type in the `UnifyReceiver` context, but for now, use\n-                                        // this imperfect proxy. This will fail if there are\n-                                        // multiple `impl`s for the same trait like\n-                                        // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n-                                        // In that case, only the first one will get suggestions.\n-                                        let mut traits = vec![];\n-                                        let mut hir_v = HirTraitObjectVisitor(&mut traits, *did);\n-                                        hir_v.visit_ty(self_ty);\n-                                        !traits.is_empty()\n-                                    }) =>\n-                                    {\n-                                        Some(self_ty)\n-                                    }\n-                                    _ => None,\n+                        match tcx.hir().trait_impls(trait_did).iter().find_map(|&impl_did| {\n+                            match tcx.hir().get_if_local(impl_did.to_def_id()) {\n+                                Some(Node::Item(Item {\n+                                    kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n+                                    ..\n+                                })) if trait_objects.iter().all(|did| {\n+                                    // FIXME: we should check `self_ty` against the receiver\n+                                    // type in the `UnifyReceiver` context, but for now, use\n+                                    // this imperfect proxy. This will fail if there are\n+                                    // multiple `impl`s for the same trait like\n+                                    // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n+                                    // In that case, only the first one will get suggestions.\n+                                    let mut traits = vec![];\n+                                    let mut hir_v = HirTraitObjectVisitor(&mut traits, *did);\n+                                    hir_v.visit_ty(self_ty);\n+                                    !traits.is_empty()\n+                                }) =>\n+                                {\n+                                    Some(self_ty)\n                                 }\n-                            })\n-                            .next()\n-                        {\n+                                _ => None,\n+                            }\n+                        }) {\n                             Some(self_ty) => Some((trait_item.ident, self_ty)),\n                             _ => None,\n                         }"}, {"sha": "bf1f150fc3b47d3247576bdc28666330c321cc93", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=7690fe3bc66cae219301368650317936f0d4e3a9", "patch": "@@ -256,7 +256,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                         cx.tcx,\n                         cx.tcx.explicit_item_bounds(def).iter().cloned(),\n                     )\n-                    .filter_map(|obligation| {\n+                    .find_map(|obligation| {\n                         // We only look at the `DefId`, so it is safe to skip the binder here.\n                         if let ty::PredicateKind::Clause(ty::Clause::Trait(\n                             ref poly_trait_predicate,\n@@ -270,22 +270,17 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                         }\n                     })\n                     .map(|inner| MustUsePath::Opaque(Box::new(inner)))\n-                    .next()\n                 }\n-                ty::Dynamic(binders, _, _) => binders\n-                    .iter()\n-                    .filter_map(|predicate| {\n-                        if let ty::ExistentialPredicate::Trait(ref trait_ref) =\n-                            predicate.skip_binder()\n-                        {\n-                            let def_id = trait_ref.def_id;\n-                            is_def_must_use(cx, def_id, span)\n-                        } else {\n-                            None\n-                        }\n-                        .map(|inner| MustUsePath::TraitObject(Box::new(inner)))\n-                    })\n-                    .next(),\n+                ty::Dynamic(binders, _, _) => binders.iter().find_map(|predicate| {\n+                    if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder()\n+                    {\n+                        let def_id = trait_ref.def_id;\n+                        is_def_must_use(cx, def_id, span)\n+                    } else {\n+                        None\n+                    }\n+                    .map(|inner| MustUsePath::TraitObject(Box::new(inner)))\n+                }),\n                 ty::Tuple(tys) => {\n                     let elem_exprs = if let hir::ExprKind::Tup(elem_exprs) = expr.kind {\n                         debug_assert_eq!(elem_exprs.len(), tys.len());"}, {"sha": "bd0c08a53c4f20eb2ce5b6a15a561091ce83d0a6", "filename": "compiler/rustc_macros/src/symbols/tests.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs?ref=7690fe3bc66cae219301368650317936f0d4e3a9", "patch": "@@ -16,14 +16,13 @@ fn test_symbols() {\n     let m: &syn::ItemMacro = file\n         .items\n         .iter()\n-        .filter_map(|i| {\n+        .find_map(|i| {\n             if let syn::Item::Macro(m) = i {\n                 if m.mac.path == symbols_path { Some(m) } else { None }\n             } else {\n                 None\n             }\n         })\n-        .next()\n         .expect(\"did not find `symbols!` macro invocation.\");\n \n     let body_tokens = m.mac.tokens.clone();"}, {"sha": "e41fe325b811cb42cf118565782a00e1f75df0eb", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7690fe3bc66cae219301368650317936f0d4e3a9/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=7690fe3bc66cae219301368650317936f0d4e3a9", "patch": "@@ -820,13 +820,12 @@ impl<'a> Resolver<'a> {\n             // binding if it exists. What we really want here is having two separate scopes in\n             // a module - one for non-globs and one for globs, but until that's done use this\n             // hack to avoid inconsistent resolution ICEs during import validation.\n-            let binding = [resolution.binding, resolution.shadowed_glob]\n-                .into_iter()\n-                .filter_map(|binding| match (binding, ignore_binding) {\n+            let binding = [resolution.binding, resolution.shadowed_glob].into_iter().find_map(\n+                |binding| match (binding, ignore_binding) {\n                     (Some(binding), Some(ignored)) if ptr::eq(binding, ignored) => None,\n                     _ => binding,\n-                })\n-                .next();\n+                },\n+            );\n             let Some(binding) = binding else {\n                 return Err((Determined, Weak::No));\n             };"}]}