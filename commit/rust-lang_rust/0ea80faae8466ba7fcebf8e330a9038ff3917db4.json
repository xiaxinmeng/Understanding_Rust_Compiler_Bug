{"sha": "0ea80faae8466ba7fcebf8e330a9038ff3917db4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlYTgwZmFhZTg0NjZiYTdmY2ViZjhlMzMwYTkwMzhmZjM5MTdkYjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-26T16:58:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-26T16:58:07Z"}, "message": "Auto merge of #25091 - quantheory:trait_associated_const_fixes, r=nikomatsakis\n\nCloses #25046 (by rejecting the code that causes the ICE) and #24946. I haven't been able to deal with the array size or recursion issues yet for associated consts, though my hope was that the change I made for range match patterns might help with array sizes, too.\r\n\r\nThis PR is pretty much orthogonal to #25065.", "tree": {"sha": "98a7e299fc0d8a999952b94f3a9db81aef4ac58e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98a7e299fc0d8a999952b94f3a9db81aef4ac58e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ea80faae8466ba7fcebf8e330a9038ff3917db4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ea80faae8466ba7fcebf8e330a9038ff3917db4", "html_url": "https://github.com/rust-lang/rust/commit/0ea80faae8466ba7fcebf8e330a9038ff3917db4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ea80faae8466ba7fcebf8e330a9038ff3917db4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a83201ff9fbf217e8dc963a65a992e6ead3aafba", "url": "https://api.github.com/repos/rust-lang/rust/commits/a83201ff9fbf217e8dc963a65a992e6ead3aafba", "html_url": "https://github.com/rust-lang/rust/commit/a83201ff9fbf217e8dc963a65a992e6ead3aafba"}, {"sha": "8db699d18d263bf779f260ba55221a8c0ff2f5d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/8db699d18d263bf779f260ba55221a8c0ff2f5d8", "html_url": "https://github.com/rust-lang/rust/commit/8db699d18d263bf779f260ba55221a8c0ff2f5d8"}], "stats": {"total": 148, "additions": 133, "deletions": 15}, "files": [{"sha": "188bf4bf77bb826e270860deac9515d8ebc54b11", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0ea80faae8466ba7fcebf8e330a9038ff3917db4/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea80faae8466ba7fcebf8e330a9038ff3917db4/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=0ea80faae8466ba7fcebf8e330a9038ff3917db4", "patch": "@@ -128,8 +128,10 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                         Some(ref_id) => {\n                             let trait_id = ty::trait_of_item(tcx, def_id)\n                                               .unwrap();\n+                            let substs = ty::node_id_item_substs(tcx, ref_id)\n+                                            .substs;\n                             resolve_trait_associated_const(tcx, ti, trait_id,\n-                                                           ref_id)\n+                                                           substs)\n                         }\n                         // Technically, without knowing anything about the\n                         // expression that generates the obligation, we could\n@@ -174,8 +176,10 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                         // a trait-associated const if the caller gives us\n                         // the expression that refers to it.\n                         Some(ref_id) => {\n+                            let substs = ty::node_id_item_substs(tcx, ref_id)\n+                                            .substs;\n                             resolve_trait_associated_const(tcx, ti, trait_id,\n-                                                           ref_id).map(|e| e.id)\n+                                                           substs).map(|e| e.id)\n                         }\n                         None => None\n                     }\n@@ -702,9 +706,23 @@ pub_fn_checked_op!{ const_uint_checked_shr_via_int(a: u64, b: i64,.. UintTy) {\n            uint_shift_body overflowing_shr const_uint ShiftRightWithOverflow\n }}\n \n+// After type checking, `eval_const_expr_partial` should always suffice. The\n+// reason for providing `eval_const_expr_with_substs` is to allow\n+// trait-associated consts to be evaluated *during* type checking, when the\n+// substs for each expression have not been written into `tcx` yet.\n pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      e: &Expr,\n                                      ty_hint: Option<Ty<'tcx>>) -> EvalResult {\n+    eval_const_expr_with_substs(tcx, e, ty_hint, |id| {\n+        ty::node_id_item_substs(tcx, id).substs\n+    })\n+}\n+\n+pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n+                                            e: &Expr,\n+                                            ty_hint: Option<Ty<'tcx>>,\n+                                            get_substs: S) -> EvalResult\n+        where S: Fn(ast::NodeId) -> subst::Substs<'tcx> {\n     fn fromb(b: bool) -> const_val { const_int(b as i64) }\n \n     let ety = ty_hint.or_else(|| ty::expr_ty_opt(tcx, e));\n@@ -895,8 +913,11 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                           def::FromTrait(trait_id) => match tcx.map.find(def_id.node) {\n                               Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n                                   ast::ConstTraitItem(ref ty, _) => {\n-                                      (resolve_trait_associated_const(tcx, ti,\n-                                                                      trait_id, e.id),\n+                                      let substs = get_substs(e.id);\n+                                      (resolve_trait_associated_const(tcx,\n+                                                                      ti,\n+                                                                      trait_id,\n+                                                                      substs),\n                                        Some(&**ty))\n                                   }\n                                   _ => (None, None)\n@@ -995,10 +1016,9 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                                                 ti: &'tcx ast::TraitItem,\n                                                 trait_id: ast::DefId,\n-                                                ref_id: ast::NodeId)\n+                                                rcvr_substs: subst::Substs<'tcx>)\n                                                 -> Option<&'tcx Expr>\n {\n-    let rcvr_substs = ty::node_id_item_substs(tcx, ref_id).substs;\n     let subst::SeparateVecsPerParamSpace {\n         types: rcvr_type,\n         selfs: rcvr_self,\n@@ -1150,19 +1170,21 @@ pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<Ordering> {\n     })\n }\n \n-pub fn compare_lit_exprs<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                               a: &Expr,\n-                               b: &Expr,\n-                               ty_hint: Option<Ty<'tcx>>)\n-                               -> Option<Ordering> {\n-    let a = match eval_const_expr_partial(tcx, a, ty_hint) {\n+pub fn compare_lit_exprs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n+                                  a: &Expr,\n+                                  b: &Expr,\n+                                  ty_hint: Option<Ty<'tcx>>,\n+                                  get_substs: S) -> Option<Ordering>\n+        where S: Fn(ast::NodeId) -> subst::Substs<'tcx> {\n+    let a = match eval_const_expr_with_substs(tcx, a, ty_hint,\n+                                              |id| {get_substs(id)}) {\n         Ok(a) => a,\n         Err(e) => {\n             tcx.sess.span_err(a.span, &e.description());\n             return None;\n         }\n     };\n-    let b = match eval_const_expr_partial(tcx, b, ty_hint) {\n+    let b = match eval_const_expr_with_substs(tcx, b, ty_hint, get_substs) {\n         Ok(b) => b,\n         Err(e) => {\n             tcx.sess.span_err(b.span, &e.description());"}, {"sha": "b09f5a57e46927265d195eca1c1a905fede54831", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ea80faae8466ba7fcebf8e330a9038ff3917db4/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea80faae8466ba7fcebf8e330a9038ff3917db4/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=0ea80faae8466ba7fcebf8e330a9038ff3917db4", "patch": "@@ -233,7 +233,8 @@ struct ConstantExpr<'a>(&'a ast::Expr);\n \n impl<'a> ConstantExpr<'a> {\n     fn eq(self, other: ConstantExpr<'a>, tcx: &ty::ctxt) -> bool {\n-        match const_eval::compare_lit_exprs(tcx, self.0, other.0, None) {\n+        match const_eval::compare_lit_exprs(tcx, self.0, other.0, None,\n+                                            |id| {ty::node_id_item_substs(tcx, id).substs}) {\n             Some(result) => result == Ordering::Equal,\n             None => panic!(\"compare_list_exprs: type mismatch\"),\n         }"}, {"sha": "63470604084f81a912d35bc69ed03c5ea5e18e1e", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ea80faae8466ba7fcebf8e330a9038ff3917db4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea80faae8466ba7fcebf8e330a9038ff3917db4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=0ea80faae8466ba7fcebf8e330a9038ff3917db4", "patch": "@@ -98,7 +98,9 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 lhs_eq_rhs && (ty::type_is_numeric(lhs_ty) || ty::type_is_char(lhs_ty));\n \n             if numeric_or_char {\n-                match const_eval::compare_lit_exprs(tcx, &**begin, &**end, Some(lhs_ty)) {\n+                match const_eval::compare_lit_exprs(tcx, &**begin, &**end, Some(lhs_ty),\n+                                                    |id| {fcx.item_substs()[&id].substs\n+                                                             .clone()}) {\n                     Some(Ordering::Less) |\n                     Some(Ordering::Equal) => {}\n                     Some(Ordering::Greater) => {"}, {"sha": "884933adbc4496eee045163b3e475511401e4bfc", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0ea80faae8466ba7fcebf8e330a9038ff3917db4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea80faae8466ba7fcebf8e330a9038ff3917db4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0ea80faae8466ba7fcebf8e330a9038ff3917db4", "patch": "@@ -3759,8 +3759,36 @@ pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,\n                                                         &'a [ast::PathSegment],\n                                                         def::Def)>\n {\n+\n+    // Associated constants can't depend on generic types.\n+    fn have_disallowed_generic_consts<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                                def: def::Def,\n+                                                ty: Ty<'tcx>,\n+                                                span: Span,\n+                                                node_id: ast::NodeId) -> bool {\n+        match def {\n+            def::DefAssociatedConst(..) => {\n+                if ty::type_has_params(ty) || ty::type_has_self(ty) {\n+                    span_err!(fcx.sess(), span, E0329,\n+                              \"Associated consts cannot depend \\\n+                               on type parameters or Self.\");\n+                    fcx.write_error(node_id);\n+                    return true;\n+                }\n+            }\n+            _ => {}\n+        }\n+        false\n+    }\n+\n     // If fully resolved already, we don't have to do anything.\n     if path_res.depth == 0 {\n+        if let Some(ty) = opt_self_ty {\n+            if have_disallowed_generic_consts(fcx, path_res.full_def(), ty,\n+                                              span, node_id) {\n+                return None;\n+            }\n+        }\n         Some((opt_self_ty, &path.segments, path_res.base_def))\n     } else {\n         let mut def = path_res.base_def;\n@@ -3776,6 +3804,9 @@ pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,\n         let item_name = item_segment.identifier.name;\n         match method::resolve_ufcs(fcx, span, item_name, ty, node_id) {\n             Ok((def, lp)) => {\n+                if have_disallowed_generic_consts(fcx, def, ty, span, node_id) {\n+                    return None;\n+                }\n                 // Write back the new resolution.\n                 fcx.ccx.tcx.def_map.borrow_mut()\n                        .insert(node_id, def::PathResolution {"}, {"sha": "8fd302a5f1fd1e7a3edbd514f611bd6eee931c26", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ea80faae8466ba7fcebf8e330a9038ff3917db4/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea80faae8466ba7fcebf8e330a9038ff3917db4/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=0ea80faae8466ba7fcebf8e330a9038ff3917db4", "patch": "@@ -1103,6 +1103,7 @@ register_diagnostics! {\n     E0326, // associated const implemented with different type from trait\n     E0327, // referred to method instead of constant in match pattern\n     E0328, // cannot implement Unsize explicitly\n+    E0329, // associated const depends on type parameter or Self.\n     E0366, // dropck forbid specialization to concrete type or region\n     E0367, // dropck forbid specialization to predicate not in struct/enum\n     E0369, // binary operation `<op>` cannot be applied to types"}, {"sha": "e48ff59d1dc8ed442b0b40d3a7ba40e475abdd93", "filename": "src/test/compile-fail/associated-const-type-parameters.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0ea80faae8466ba7fcebf8e330a9038ff3917db4/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea80faae8466ba7fcebf8e330a9038ff3917db4/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameters.rs?ref=0ea80faae8466ba7fcebf8e330a9038ff3917db4", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+pub trait Foo {\n+    const MIN: i32;\n+\n+    fn get_min() -> i32 {\n+        Self::MIN //~ ERROR E0329\n+    }\n+}\n+\n+fn get_min<T: Foo>() -> i32 {\n+    T::MIN; //~ ERROR E0329\n+    <T as Foo>::MIN //~ ERROR E0329\n+}\n+\n+fn main() {}"}, {"sha": "d38ccca689141e3a24f13ee8d4b2ba0f1708a24c", "filename": "src/test/run-pass/associated-const-range-match-patterns.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0ea80faae8466ba7fcebf8e330a9038ff3917db4/src%2Ftest%2Frun-pass%2Fassociated-const-range-match-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ea80faae8466ba7fcebf8e330a9038ff3917db4/src%2Ftest%2Frun-pass%2Fassociated-const-range-match-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-range-match-patterns.rs?ref=0ea80faae8466ba7fcebf8e330a9038ff3917db4", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+struct Foo;\n+\n+trait HasNum {\n+    const NUM: isize;\n+}\n+impl HasNum for Foo {\n+    const NUM: isize = 1;\n+}\n+\n+fn main() {\n+    assert!(match 2 {\n+        Foo::NUM ... 3 => true,\n+        _ => false,\n+    });\n+    assert!(match 0 {\n+        -1 ... <Foo as HasNum>::NUM => true,\n+        _ => false,\n+    });\n+    assert!(match 1 {\n+        <Foo as HasNum>::NUM ... <Foo>::NUM => true,\n+        _ => false,\n+    });\n+}"}]}