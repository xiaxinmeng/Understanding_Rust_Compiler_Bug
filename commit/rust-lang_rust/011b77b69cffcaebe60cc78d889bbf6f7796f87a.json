{"sha": "011b77b69cffcaebe60cc78d889bbf6f7796f87a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMWI3N2I2OWNmZmNhZWJlNjBjYzc4ZDg4OWJiZjZmNzc5NmY4N2E=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-10T16:42:51Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-10T16:42:51Z"}, "message": "rollup merge of #22106: steveklabnik/doc_trait_objects\n\nI started to write up some docs on this, and then realized I was just repeating http://huonw.github.io/blog/2015/01/peeking-inside-trait-objects/ but worse. @huonw previously said that we can use this content if we wanted, so I made some tweaks and integrated it into the book.\n\nFixes #21707", "tree": {"sha": "344eccacf9bfec93442570c746651faa90fa7761", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/344eccacf9bfec93442570c746651faa90fa7761"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/011b77b69cffcaebe60cc78d889bbf6f7796f87a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/011b77b69cffcaebe60cc78d889bbf6f7796f87a", "html_url": "https://github.com/rust-lang/rust/commit/011b77b69cffcaebe60cc78d889bbf6f7796f87a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/011b77b69cffcaebe60cc78d889bbf6f7796f87a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d55d3ac454fd57b32016aee280560247727f219", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d55d3ac454fd57b32016aee280560247727f219", "html_url": "https://github.com/rust-lang/rust/commit/6d55d3ac454fd57b32016aee280560247727f219"}, {"sha": "dbccd70a5736fd2e898b446e6c5f3da5d17538c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbccd70a5736fd2e898b446e6c5f3da5d17538c6", "html_url": "https://github.com/rust-lang/rust/commit/dbccd70a5736fd2e898b446e6c5f3da5d17538c6"}], "stats": {"total": 334, "additions": 289, "deletions": 45}, "files": [{"sha": "bfc1247dc3bc074002fd1de4721729cf0e9c25ed", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/011b77b69cffcaebe60cc78d889bbf6f7796f87a/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/011b77b69cffcaebe60cc78d889bbf6f7796f87a/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=011b77b69cffcaebe60cc78d889bbf6f7796f87a", "patch": "@@ -27,6 +27,7 @@\n     * [Iterators](iterators.md)\n     * [Generics](generics.md)\n     * [Traits](traits.md)\n+    * [Static and Dynamic Dispatch](static-and-dynamic-dispatch.md)\n     * [Concurrency](concurrency.md)\n     * [Error Handling](error-handling.md)\n     * [Documentation](documentation.md)"}, {"sha": "9421dac7bf65d750a554e9c1f0a17de1bfe6a5c4", "filename": "src/doc/trpl/static-and-dynamic-dispatch.md", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/011b77b69cffcaebe60cc78d889bbf6f7796f87a/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/011b77b69cffcaebe60cc78d889bbf6f7796f87a/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md?ref=011b77b69cffcaebe60cc78d889bbf6f7796f87a", "patch": "@@ -0,0 +1,286 @@\n+% Static and Dynamic Dispatch\n+\n+When code involves polymorphism, there needs to be a mechanism to determine\n+which specific version is actually run. This is called 'dispatch.' There are\n+two major forms of dispatch: static dispatch and dynamic dispatch. While Rust\n+favors static dispatch, it also supports dynamic dispatch through a mechanism\n+called 'trait objects.'\n+\n+## Background\n+\n+For the rest of this chapter, we'll need a trait and some implementations.\n+Let's make a simple one, `Foo`. It has one method that is expected to return a\n+`String`.\n+\n+```rust\n+trait Foo {\n+    fn method(&self) -> String;\n+}\n+```\n+\n+We'll also implement this trait for `u8` and `String`:\n+\n+```rust\n+# trait Foo { fn method(&self) -> String; }\n+impl Foo for u8 {\n+    fn method(&self) -> String { format!(\"u8: {}\", *self) }\n+}\n+\n+impl Foo for String {\n+    fn method(&self) -> String { format!(\"string: {}\", *self) }\n+}\n+```\n+\n+\n+## Static dispatch\n+\n+We can use this trait to perform static dispatch with trait bounds:\n+\n+```rust\n+# trait Foo { fn method(&self) -> String; }\n+# impl Foo for u8 { fn method(&self) -> String { format!(\"u8: {}\", *self) } }\n+# impl Foo for String { fn method(&self) -> String { format!(\"string: {}\", *self) } }\n+fn do_something<T: Foo>(x: T) {\n+    x.method();\n+}\n+\n+fn main() {\n+    let x = 5u8;\n+    let y = \"Hello\".to_string();\n+\n+    do_something(x);\n+    do_something(y);\n+}\n+```\n+\n+Rust uses 'monomorphization' to perform static dispatch here. This means that\n+Rust will create a special version of `do_something()` for both `u8` and\n+`String`, and then replace the call sites with calls to these specialized\n+functions. In other words, Rust generates something like this:\n+\n+```rust\n+# trait Foo { fn method(&self) -> String; }\n+# impl Foo for u8 { fn method(&self) -> String { format!(\"u8: {}\", *self) } }\n+# impl Foo for String { fn method(&self) -> String { format!(\"string: {}\", *self) } }\n+fn do_something_u8(x: u8) {\n+    x.method();\n+}\n+\n+fn do_something_string(x: String) {\n+    x.method();\n+}\n+\n+fn main() {\n+    let x = 5u8;\n+    let y = \"Hello\".to_string();\n+\n+    do_something_u8(x);\n+    do_something_string(y);\n+}\n+```\n+\n+This has some upsides: static dispatching of any method calls, allowing for\n+inlining and hence usually higher performance. It also has some downsides:\n+causing code bloat due to many copies of the same function existing in the\n+binary, one for each type.\n+\n+Furthermore, compilers aren\u2019t perfect and may \u201coptimise\u201d code to become slower.\n+For example, functions inlined too eagerly will bloat the instruction cache\n+(cache rules everything around us). This is part of the reason that `#[inline]`\n+and `#[inline(always)]` should be used carefully, and one reason why using a\n+dynamic dispatch is sometimes more efficient.\n+\n+However, the common case is that it is more efficient to use static dispatch,\n+and one can always have a thin statically-dispatched wrapper function that does\n+a dynamic, but not vice versa, meaning static calls are more flexible. The\n+standard library tries to be statically dispatched where possible for this\n+reason. \n+\n+## Dynamic dispatch\n+\n+Rust provides dynamic dispatch through a feature called 'trait objects.' Trait\n+objects, like `&Foo` or `Box<Foo>`, are normal values that store a value of\n+*any* type that implements the given trait, where the precise type can only be\n+known at runtime. The methods of the trait can be called on a trait object via\n+a special record of function pointers (created and managed by the compiler).\n+\n+A function that takes a trait object is not specialised to each of the types\n+that implements `Foo`: only one copy is generated, often (but not always)\n+resulting in less code bloat. However, this comes at the cost of requiring\n+slower virtual function calls, and effectively inhibiting any chance of\n+inlining and related optimisations from occurring.\n+\n+Trait objects are both simple and complicated: their core representation and\n+layout is quite straight-forward, but there are some curly error messages and\n+surprising behaviours to discover.\n+\n+### Obtaining a trait object\n+\n+There's two similar ways to get a trait object value: casts and coercions. If\n+`T` is a type that implements a trait `Foo` (e.g. `u8` for the `Foo` above),\n+then the two ways to get a `Foo` trait object out of a pointer to `T` look\n+like:\n+\n+```{rust,ignore}\n+let ref_to_t: &T = ...;\n+\n+// `as` keyword for casting\n+let cast = ref_to_t as &Foo;\n+\n+// using a `&T` in a place that has a known type of `&Foo` will implicitly coerce:\n+let coerce: &Foo = ref_to_t;\n+\n+fn also_coerce(_unused: &Foo) {}\n+also_coerce(ref_to_t);\n+```\n+\n+These trait object coercions and casts also work for pointers like `&mut T` to\n+`&mut Foo` and `Box<T>` to `Box<Foo>`, but that's all at the moment. Coercions\n+and casts are identical.\n+\n+This operation can be seen as \"erasing\" the compiler's knowledge about the\n+specific type of the pointer, and hence trait objects are sometimes referred to\n+\"type erasure\".\n+\n+### Representation\n+\n+Let's start simple, with the runtime representation of a trait object. The\n+`std::raw` module contains structs with layouts that are the same as the\n+complicated build-in types, [including trait objects][stdraw]:\n+\n+```rust\n+# mod foo {\n+pub struct TraitObject {\n+    pub data: *mut (),\n+    pub vtable: *mut (),\n+}\n+# }\n+```\n+\n+[stdraw]: ../std/raw/struct.TraitObject.html\n+\n+That is, a trait object like `&Foo` consists of a \"data\" pointer and a \"vtable\"\n+pointer.\n+\n+The data pointer addresses the data (of some unknown type `T`) that the trait\n+object is storing, and the vtable pointer points to the vtable (\"virtual method\n+table\") corresponding to the implementation of `Foo` for `T`.\n+\n+\n+A vtable is essentially a struct of function pointers, pointing to the concrete\n+piece of machine code for each method in the implementation. A method call like\n+`trait_object.method()` will retrieve the correct pointer out of the vtable and\n+then do a dynamic call of it. For example:\n+\n+```{rust,ignore}\n+struct FooVtable {\n+    destructor: fn(*mut ()),\n+    size: usize,\n+    align: usize,\n+    method: fn(*const ()) -> String,\n+}\n+\n+// u8:\n+\n+fn call_method_on_u8(x: *const ()) -> String {\n+    // the compiler guarantees that this function is only called\n+    // with `x` pointing to a u8\n+    let byte: &u8 = unsafe { &*(x as *const u8) };\n+\n+    byte.method()\n+}\n+\n+static Foo_for_u8_vtable: FooVtable = FooVtable {\n+    destructor: /* compiler magic */,\n+    size: 1,\n+    align: 1,\n+\n+    // cast to a function pointer\n+    method: call_method_on_u8 as fn(*const ()) -> String,\n+};\n+\n+\n+// String:\n+\n+fn call_method_on_String(x: *const ()) -> String {\n+    // the compiler guarantees that this function is only called\n+    // with `x` pointing to a String\n+    let string: &String = unsafe { &*(x as *const String) };\n+\n+    string.method()\n+}\n+\n+static Foo_for_String_vtable: FooVtable = FooVtable {\n+    destructor: /* compiler magic */,\n+    // values for a 64-bit computer, halve them for 32-bit ones\n+    size: 24,\n+    align: 8,\n+\n+    method: call_method_on_String as fn(*const ()) -> String,\n+};\n+```\n+\n+The `destructor` field in each vtable points to a function that will clean up\n+any resources of the vtable's type, for `u8` it is trivial, but for `String` it\n+will free the memory. This is necessary for owning trait objects like\n+`Box<Foo>`, which need to clean-up both the `Box` allocation and as well as the\n+internal type when they go out of scope. The `size` and `align` fields store\n+the size of the erased type, and its alignment requirements; these are\n+essentially unused at the moment since the information is embedded in the\n+destructor, but will be used in future, as trait objects are progressively made\n+more flexible.\n+\n+Suppose we've got some values that implement `Foo`, the explicit form of\n+construction and use of `Foo` trait objects might look a bit like (ignoring the\n+type mismatches: they're all just pointers anyway):\n+\n+```{rust,ignore}\n+let a: String = \"foo\".to_string();\n+let x: u8 = 1;\n+\n+// let b: &Foo = &a;\n+let b = TraitObject {\n+    // store the data\n+    data: &a,\n+    // store the methods\n+    vtable: &Foo_for_String_vtable\n+};\n+\n+// let y: &Foo = x;\n+let y = TraitObject {\n+    // store the data\n+    data: &x,\n+    // store the methods\n+    vtable: &Foo_for_u8_vtable\n+};\n+\n+// b.method();\n+(b.vtable.method)(b.data);\n+\n+// y.method();\n+(y.vtable.method)(y.data);\n+```\n+\n+If `b` or `y` were owning trait objects (`Box<Foo>`), there would be a\n+`(b.vtable.destructor)(b.data)` (respectively `y`) call when they went out of\n+scope.\n+\n+### Why pointers?\n+\n+The use of language like \"fat pointer\" implies that a trait object is\n+always a pointer of some form, but why?\n+\n+Rust does not put things behind a pointer by default, unlike many managed\n+languages, so types can have different sizes. Knowing the size of the value at\n+compile time is important for things like passing it as an argument to a\n+function, moving it about on the stack and allocating (and deallocating) space\n+on the heap to store it.\n+\n+For `Foo`, we would need to have a value that could be at least either a\n+`String` (24 bytes) or a `u8` (1 byte), as well as any other type for which\n+dependent crates may implement `Foo` (any number of bytes at all). There's no\n+way to guarantee that this last point can work if the values are stored without\n+a pointer, because those other types can be arbitrarily large.\n+\n+Putting the value behind a pointer means the size of the value is not relevant\n+when we are tossing a trait object around, only the size of the pointer itself."}, {"sha": "e091878cf86ec200df19b5b1878adebf7969ef64", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 2, "deletions": 45, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/011b77b69cffcaebe60cc78d889bbf6f7796f87a/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/011b77b69cffcaebe60cc78d889bbf6f7796f87a/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=011b77b69cffcaebe60cc78d889bbf6f7796f87a", "patch": "@@ -270,51 +270,8 @@ not, because both the trait and the type aren't in our crate.\n \n One last thing about traits: generic functions with a trait bound use\n *monomorphization* (*mono*: one, *morph*: form), so they are statically\n-dispatched. What's that mean? Well, let's take a look at `print_area` again:\n-\n-```{rust,ignore}\n-fn print_area<T: HasArea>(shape: T) {\n-    println!(\"This shape has an area of {}\", shape.area());\n-}\n-\n-fn main() {\n-    let c = Circle { ... };\n-\n-    let s = Square { ... };\n-\n-    print_area(c);\n-    print_area(s);\n-}\n-```\n-\n-When we use this trait with `Circle` and `Square`, Rust ends up generating\n-two different functions with the concrete type, and replacing the call sites with\n-calls to the concrete implementations. In other words, you get something like\n-this:\n-\n-```{rust,ignore}\n-fn __print_area_circle(shape: Circle) {\n-    println!(\"This shape has an area of {}\", shape.area());\n-}\n-\n-fn __print_area_square(shape: Square) {\n-    println!(\"This shape has an area of {}\", shape.area());\n-}\n-\n-fn main() {\n-    let c = Circle { ... };\n-\n-    let s = Square { ... };\n-\n-    __print_area_circle(c);\n-    __print_area_square(s);\n-}\n-```\n-\n-The names don't actually change to this, it's just for illustration. But\n-as you can see, there's no overhead of deciding which version to call here,\n-hence *statically dispatched*. The downside is that we have two copies of\n-the same function, so our binary is a little bit larger.\n+dispatched. What's that mean? Check out the chapter on [static and dynamic\n+dispatch](static-and-dynamic-dispatch.html) for more.\n \n ## Our `inverse` Example\n "}]}