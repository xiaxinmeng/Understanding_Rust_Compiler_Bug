{"sha": "72969f6526b6a3ff9f2bbfe73e26249d977794e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyOTY5ZjY1MjZiNmEzZmY5ZjJiYmZlNzNlMjYyNDlkOTc3Nzk0ZTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-08T04:00:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-08T04:00:58Z"}, "message": "Auto merge of #88061 - jackh726:genericbound-cleanup, r=estebank\n\nRemove `hir::GenericBound::Unsized`\n\nRather than \"moving\" the `?Sized` bounds to the param bounds, just also check where clauses in `astconv`. I also did some related cleanup here, but that's not strictly neccesary. Also going to do a perf run here.\n\nr? `@estebank`", "tree": {"sha": "79047e9b18b82787886563078666119d76de5c14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79047e9b18b82787886563078666119d76de5c14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72969f6526b6a3ff9f2bbfe73e26249d977794e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72969f6526b6a3ff9f2bbfe73e26249d977794e7", "html_url": "https://github.com/rust-lang/rust/commit/72969f6526b6a3ff9f2bbfe73e26249d977794e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72969f6526b6a3ff9f2bbfe73e26249d977794e7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d0d2fe182e8980146e25cfcfff0c481892f81c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d0d2fe182e8980146e25cfcfff0c481892f81c6", "html_url": "https://github.com/rust-lang/rust/commit/0d0d2fe182e8980146e25cfcfff0c481892f81c6"}, {"sha": "22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d", "html_url": "https://github.com/rust-lang/rust/commit/22ef04e22fc78ce0dcaaf8c8faa5944c983cdc1d"}], "stats": {"total": 689, "additions": 300, "deletions": 389}, "files": [{"sha": "b7497c713f3df32d76a8f04ce0e6e98b0a4720c4", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 16, "deletions": 30, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/72969f6526b6a3ff9f2bbfe73e26249d977794e7/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72969f6526b6a3ff9f2bbfe73e26249d977794e7/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=72969f6526b6a3ff9f2bbfe73e26249d977794e7", "patch": "@@ -2,7 +2,6 @@ use super::{AnonymousLifetimeMode, LoweringContext, ParamMode};\n use super::{ImplTraitContext, ImplTraitPosition};\n use crate::Arena;\n \n-use rustc_ast::node_id::NodeMap;\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::*;\n@@ -1351,8 +1350,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         generics: &Generics,\n         itctx: ImplTraitContext<'_, 'hir>,\n     ) -> GenericsCtor<'hir> {\n-        // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n-        let mut add_bounds: NodeMap<Vec<_>> = Default::default();\n+        // Error if `?Trait` bounds in where clauses don't refer directly to type paramters.\n+        // Note: we used to clone these bounds directly onto the type parameter (and avoid lowering\n+        // these into hir when we lower thee where clauses), but this makes it quite difficult to\n+        // keep track of the Span info. Now, `add_implicitly_sized` in `AstConv` checks both param bounds and\n+        // where clauses for `?Sized`.\n         for pred in &generics.where_clause.predicates {\n             if let WherePredicate::BoundPredicate(ref bound_pred) = *pred {\n                 'next_bound: for bound in &bound_pred.bounds {\n@@ -1368,7 +1370,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             {\n                                 for param in &generics.params {\n                                     if def_id == self.resolver.local_def_id(param.id).to_def_id() {\n-                                        add_bounds.entry(param.id).or_default().push(bound.clone());\n                                         continue 'next_bound;\n                                     }\n                                 }\n@@ -1386,7 +1387,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n \n         GenericsCtor {\n-            params: self.lower_generic_params_mut(&generics.params, &add_bounds, itctx).collect(),\n+            params: self.lower_generic_params_mut(&generics.params, itctx).collect(),\n             where_clause: self.lower_where_clause(&generics.where_clause),\n             span: self.lower_span(generics.span),\n         }\n@@ -1419,32 +1420,17 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ref bounded_ty,\n                 ref bounds,\n                 span,\n-            }) => {\n-                self.with_in_scope_lifetime_defs(&bound_generic_params, |this| {\n-                    hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n-                        bound_generic_params: this.lower_generic_params(\n-                            bound_generic_params,\n-                            &NodeMap::default(),\n-                            ImplTraitContext::disallowed(),\n-                        ),\n-                        bounded_ty: this.lower_ty(bounded_ty, ImplTraitContext::disallowed()),\n-                        bounds: this.arena.alloc_from_iter(bounds.iter().map(\n-                            |bound| match bound {\n-                                // We used to ignore `?Trait` bounds, as they were copied into type\n-                                // parameters already, but we need to keep them around only for\n-                                // diagnostics when we suggest removal of `?Sized` bounds. See\n-                                // `suggest_constraining_type_param`. This will need to change if\n-                                // we ever allow something *other* than `?Sized`.\n-                                GenericBound::Trait(p, TraitBoundModifier::Maybe) => {\n-                                    hir::GenericBound::Unsized(this.lower_span(p.span))\n-                                }\n-                                _ => this.lower_param_bound(bound, ImplTraitContext::disallowed()),\n-                            },\n-                        )),\n-                        span: this.lower_span(span),\n-                    })\n+            }) => self.with_in_scope_lifetime_defs(&bound_generic_params, |this| {\n+                hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n+                    bound_generic_params: this\n+                        .lower_generic_params(bound_generic_params, ImplTraitContext::disallowed()),\n+                    bounded_ty: this.lower_ty(bounded_ty, ImplTraitContext::disallowed()),\n+                    bounds: this.arena.alloc_from_iter(bounds.iter().map(|bound| {\n+                        this.lower_param_bound(bound, ImplTraitContext::disallowed())\n+                    })),\n+                    span: this.lower_span(span),\n                 })\n-            }\n+            }),\n             WherePredicate::RegionPredicate(WhereRegionPredicate {\n                 ref lifetime,\n                 ref bounds,"}, {"sha": "fa14764c42a73f1707ac51729632769601f83de1", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/72969f6526b6a3ff9f2bbfe73e26249d977794e7/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72969f6526b6a3ff9f2bbfe73e26249d977794e7/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=72969f6526b6a3ff9f2bbfe73e26249d977794e7", "patch": "@@ -1313,7 +1313,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     hir::TyKind::BareFn(this.arena.alloc(hir::BareFnTy {\n                         generic_params: this.lower_generic_params(\n                             &f.generic_params,\n-                            &NodeMap::default(),\n                             ImplTraitContext::disallowed(),\n                         ),\n                         unsafety: this.lower_unsafety(f.unsafety),\n@@ -1998,30 +1997,25 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_generic_params_mut<'s>(\n         &'s mut self,\n         params: &'s [GenericParam],\n-        add_bounds: &'s NodeMap<Vec<GenericBound>>,\n         mut itctx: ImplTraitContext<'s, 'hir>,\n     ) -> impl Iterator<Item = hir::GenericParam<'hir>> + Captures<'a> + Captures<'s> {\n-        params\n-            .iter()\n-            .map(move |param| self.lower_generic_param(param, add_bounds, itctx.reborrow()))\n+        params.iter().map(move |param| self.lower_generic_param(param, itctx.reborrow()))\n     }\n \n     fn lower_generic_params(\n         &mut self,\n         params: &[GenericParam],\n-        add_bounds: &NodeMap<Vec<GenericBound>>,\n         itctx: ImplTraitContext<'_, 'hir>,\n     ) -> &'hir [hir::GenericParam<'hir>] {\n-        self.arena.alloc_from_iter(self.lower_generic_params_mut(params, add_bounds, itctx))\n+        self.arena.alloc_from_iter(self.lower_generic_params_mut(params, itctx))\n     }\n \n     fn lower_generic_param(\n         &mut self,\n         param: &GenericParam,\n-        add_bounds: &NodeMap<Vec<GenericBound>>,\n         mut itctx: ImplTraitContext<'_, 'hir>,\n     ) -> hir::GenericParam<'hir> {\n-        let mut bounds: Vec<_> = self\n+        let bounds: Vec<_> = self\n             .with_anonymous_lifetime_mode(AnonymousLifetimeMode::ReportError, |this| {\n                 this.lower_param_bounds_mut(&param.bounds, itctx.reborrow()).collect()\n             });\n@@ -2057,12 +2051,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 (param_name, kind)\n             }\n             GenericParamKind::Type { ref default, .. } => {\n-                let add_bounds = add_bounds.get(&param.id).map_or(&[][..], |x| &x);\n-                if !add_bounds.is_empty() {\n-                    let params = self.lower_param_bounds_mut(add_bounds, itctx.reborrow());\n-                    bounds.extend(params);\n-                }\n-\n                 let kind = hir::GenericParamKind::Type {\n                     default: default.as_ref().map(|x| {\n                         self.lower_ty(x, ImplTraitContext::Disallowed(ImplTraitPosition::Other))\n@@ -2123,11 +2111,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         p: &PolyTraitRef,\n         mut itctx: ImplTraitContext<'_, 'hir>,\n     ) -> hir::PolyTraitRef<'hir> {\n-        let bound_generic_params = self.lower_generic_params(\n-            &p.bound_generic_params,\n-            &NodeMap::default(),\n-            itctx.reborrow(),\n-        );\n+        let bound_generic_params =\n+            self.lower_generic_params(&p.bound_generic_params, itctx.reborrow());\n \n         let trait_ref = self.with_in_scope_lifetime_defs(&p.bound_generic_params, |this| {\n             // Any impl Trait types defined within this scope can capture"}, {"sha": "84bc37170c6346d1bd819d54bacb17972cd0c900", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72969f6526b6a3ff9f2bbfe73e26249d977794e7/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72969f6526b6a3ff9f2bbfe73e26249d977794e7/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=72969f6526b6a3ff9f2bbfe73e26249d977794e7", "patch": "@@ -441,10 +441,12 @@ pub enum GenericBound<'hir> {\n     Trait(PolyTraitRef<'hir>, TraitBoundModifier),\n     // FIXME(davidtwco): Introduce `PolyTraitRef::LangItem`\n     LangItemTrait(LangItem, Span, HirId, &'hir GenericArgs<'hir>),\n-    Unsized(Span),\n     Outlives(Lifetime),\n }\n \n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+rustc_data_structures::static_assert_size!(GenericBound<'_>, 48);\n+\n impl GenericBound<'_> {\n     pub fn trait_ref(&self) -> Option<&TraitRef<'_>> {\n         match self {\n@@ -458,7 +460,6 @@ impl GenericBound<'_> {\n             GenericBound::Trait(t, ..) => t.span,\n             GenericBound::LangItemTrait(_, span, ..) => *span,\n             GenericBound::Outlives(l) => l.span,\n-            GenericBound::Unsized(span) => *span,\n         }\n     }\n }"}, {"sha": "137782a6dc78dcf809b196cd9dc0b447017d7eb4", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72969f6526b6a3ff9f2bbfe73e26249d977794e7/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72969f6526b6a3ff9f2bbfe73e26249d977794e7/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=72969f6526b6a3ff9f2bbfe73e26249d977794e7", "patch": "@@ -871,7 +871,6 @@ pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericB\n             visitor.visit_generic_args(span, args);\n         }\n         GenericBound::Outlives(ref lifetime) => visitor.visit_lifetime(lifetime),\n-        GenericBound::Unsized(_) => {}\n     }\n }\n "}, {"sha": "36054c0484782016fd0bb57c1f151d383a76d610", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72969f6526b6a3ff9f2bbfe73e26249d977794e7/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72969f6526b6a3ff9f2bbfe73e26249d977794e7/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=72969f6526b6a3ff9f2bbfe73e26249d977794e7", "patch": "@@ -2232,9 +2232,6 @@ impl<'a> State<'a> {\n                 GenericBound::Outlives(lt) => {\n                     self.print_lifetime(lt);\n                 }\n-                GenericBound::Unsized(_) => {\n-                    self.s.word(\"?Sized\");\n-                }\n             }\n         }\n     }"}, {"sha": "092eae0fc5c236bbd3bb91ed99b767a7f2994a72", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/72969f6526b6a3ff9f2bbfe73e26249d977794e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72969f6526b6a3ff9f2bbfe73e26249d977794e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=72969f6526b6a3ff9f2bbfe73e26249d977794e7", "patch": "@@ -2,7 +2,6 @@\n \n use crate::ty::TyKind::*;\n use crate::ty::{InferTy, TyCtxt, TyS};\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -114,10 +113,8 @@ fn suggest_removing_unsized_bound(\n     def_id: Option<DefId>,\n ) {\n     // See if there's a `?Sized` bound that can be removed to suggest that.\n-    // First look at the `where` clause because we can have `where T: ?Sized`, but that\n-    // `?Sized` bound is *also* included in the `GenericParam` as a bound, which breaks\n-    // the spans. Hence the somewhat involved logic that follows.\n-    let mut where_unsized_bounds = FxHashSet::default();\n+    // First look at the `where` clause because we can have `where T: ?Sized`,\n+    // then look at params.\n     for (where_pos, predicate) in generics.where_clause.predicates.iter().enumerate() {\n         match predicate {\n             WherePredicate::BoundPredicate(WhereBoundPredicate {\n@@ -140,7 +137,6 @@ fn suggest_removing_unsized_bound(\n             }) if segment.ident.as_str() == param_name => {\n                 for (pos, bound) in bounds.iter().enumerate() {\n                     match bound {\n-                        hir::GenericBound::Unsized(_) => {}\n                         hir::GenericBound::Trait(poly, hir::TraitBoundModifier::Maybe)\n                             if poly.trait_ref.trait_def_id() == def_id => {}\n                         _ => continue,\n@@ -173,7 +169,6 @@ fn suggest_removing_unsized_bound(\n                         //             ^^^^^^^^^\n                         (_, pos, _, _) => bounds[pos - 1].span().shrink_to_hi().to(bound.span()),\n                     };\n-                    where_unsized_bounds.insert(bound.span());\n                     err.span_suggestion_verbose(\n                         sp,\n                         \"consider removing the `?Sized` bound to make the \\\n@@ -189,8 +184,7 @@ fn suggest_removing_unsized_bound(\n     for (pos, bound) in param.bounds.iter().enumerate() {\n         match bound {\n             hir::GenericBound::Trait(poly, hir::TraitBoundModifier::Maybe)\n-                if poly.trait_ref.trait_def_id() == def_id\n-                    && !where_unsized_bounds.contains(&bound.span()) =>\n+                if poly.trait_ref.trait_def_id() == def_id =>\n             {\n                 let sp = match (param.bounds.len(), pos) {\n                     // T: ?Sized,"}, {"sha": "3e99f4e29ef36ca8e46c2a5d61941d51a3bdbcfb", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72969f6526b6a3ff9f2bbfe73e26249d977794e7/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72969f6526b6a3ff9f2bbfe73e26249d977794e7/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=72969f6526b6a3ff9f2bbfe73e26249d977794e7", "patch": "@@ -693,7 +693,6 @@ impl<'tcx> DumpVisitor<'tcx> {\n                     (Some(self.tcx.require_lang_item(lang_item, Some(span))), span)\n                 }\n                 hir::GenericBound::Outlives(..) => continue,\n-                hir::GenericBound::Unsized(_) => continue,\n             };\n \n             if let Some(id) = def_id {"}, {"sha": "51bb09e4c54ba29bebcf1a8356bb01a9a6fc9587", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 180, "deletions": 137, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/72969f6526b6a3ff9f2bbfe73e26249d977794e7/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72969f6526b6a3ff9f2bbfe73e26249d977794e7/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=72969f6526b6a3ff9f2bbfe73e26249d977794e7", "patch": "@@ -111,11 +111,6 @@ pub trait AstConv<'tcx> {\n     fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, span: Span);\n }\n \n-pub enum SizedByDefault {\n-    Yes,\n-    No,\n-}\n-\n #[derive(Debug)]\n struct ConvertedBinding<'a, 'tcx> {\n     hir_id: hir::HirId,\n@@ -698,6 +693,61 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         )\n     }\n \n+    fn instantiate_poly_trait_ref_inner(\n+        &self,\n+        hir_id: hir::HirId,\n+        span: Span,\n+        binding_span: Option<Span>,\n+        constness: ty::BoundConstness,\n+        bounds: &mut Bounds<'tcx>,\n+        speculative: bool,\n+        trait_ref_span: Span,\n+        trait_def_id: DefId,\n+        trait_segment: &hir::PathSegment<'_>,\n+        args: &GenericArgs<'_>,\n+        infer_args: bool,\n+        self_ty: Ty<'tcx>,\n+    ) -> GenericArgCountResult {\n+        let (substs, arg_count) = self.create_substs_for_ast_path(\n+            trait_ref_span,\n+            trait_def_id,\n+            &[],\n+            trait_segment,\n+            args,\n+            infer_args,\n+            Some(self_ty),\n+        );\n+\n+        let tcx = self.tcx();\n+        let bound_vars = tcx.late_bound_vars(hir_id);\n+        debug!(?bound_vars);\n+\n+        let assoc_bindings = self.create_assoc_bindings_for_generic_args(args);\n+\n+        let poly_trait_ref =\n+            ty::Binder::bind_with_vars(ty::TraitRef::new(trait_def_id, substs), bound_vars);\n+\n+        debug!(?poly_trait_ref, ?assoc_bindings);\n+        bounds.trait_bounds.push((poly_trait_ref, span, constness));\n+\n+        let mut dup_bindings = FxHashMap::default();\n+        for binding in &assoc_bindings {\n+            // Specify type to assert that error was already reported in `Err` case.\n+            let _: Result<_, ErrorReported> = self.add_predicates_for_ast_type_binding(\n+                hir_id,\n+                poly_trait_ref,\n+                binding,\n+                bounds,\n+                speculative,\n+                &mut dup_bindings,\n+                binding_span.unwrap_or(binding.span),\n+            );\n+            // Okay to ignore `Err` because of `ErrorReported` (see above).\n+        }\n+\n+        arg_count\n+    }\n+\n     /// Given a trait bound like `Debug`, applies that trait bound the given self-type to construct\n     /// a full trait reference. The resulting trait reference is returned. This may also generate\n     /// auxiliary bounds, which are added to `bounds`.\n@@ -718,7 +768,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// `Bar<'a>`. The returned poly-trait-ref will have this binder instantiated explicitly,\n     /// however.\n     #[tracing::instrument(level = \"debug\", skip(self, span, constness, bounds, speculative))]\n-    pub fn instantiate_poly_trait_ref(\n+    pub(crate) fn instantiate_poly_trait_ref(\n         &self,\n         trait_ref: &hir::TraitRef<'_>,\n         span: Span,\n@@ -727,48 +777,34 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         bounds: &mut Bounds<'tcx>,\n         speculative: bool,\n     ) -> GenericArgCountResult {\n+        let hir_id = trait_ref.hir_ref_id;\n+        let binding_span = None;\n+        let trait_ref_span = trait_ref.path.span;\n         let trait_def_id = trait_ref.trait_def_id().unwrap_or_else(|| FatalError.raise());\n+        let trait_segment = trait_ref.path.segments.last().unwrap();\n+        let args = trait_segment.args();\n+        let infer_args = trait_segment.infer_args;\n \n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n+        self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment);\n \n-        let tcx = self.tcx();\n-        let bound_vars = tcx.late_bound_vars(trait_ref.hir_ref_id);\n-        debug!(?bound_vars);\n-\n-        let (substs, arg_count) = self.create_substs_for_ast_trait_ref(\n-            trait_ref.path.span,\n+        self.instantiate_poly_trait_ref_inner(\n+            hir_id,\n+            span,\n+            binding_span,\n+            constness,\n+            bounds,\n+            speculative,\n+            trait_ref_span,\n             trait_def_id,\n+            trait_segment,\n+            args,\n+            infer_args,\n             self_ty,\n-            trait_ref.path.segments.last().unwrap(),\n-        );\n-        let assoc_bindings = self\n-            .create_assoc_bindings_for_generic_args(trait_ref.path.segments.last().unwrap().args());\n-\n-        let poly_trait_ref =\n-            ty::Binder::bind_with_vars(ty::TraitRef::new(trait_def_id, substs), bound_vars);\n-\n-        debug!(?poly_trait_ref, ?assoc_bindings);\n-        bounds.trait_bounds.push((poly_trait_ref, span, constness));\n-\n-        let mut dup_bindings = FxHashMap::default();\n-        for binding in &assoc_bindings {\n-            // Specify type to assert that error was already reported in `Err` case.\n-            let _: Result<_, ErrorReported> = self.add_predicates_for_ast_type_binding(\n-                trait_ref.hir_ref_id,\n-                poly_trait_ref,\n-                binding,\n-                bounds,\n-                speculative,\n-                &mut dup_bindings,\n-                binding.span,\n-            );\n-            // Okay to ignore `Err` because of `ErrorReported` (see above).\n-        }\n-\n-        arg_count\n+        )\n     }\n \n-    pub fn instantiate_lang_item_trait_ref(\n+    pub(crate) fn instantiate_lang_item_trait_ref(\n         &self,\n         lang_item: hir::LangItem,\n         span: Span,\n@@ -777,36 +813,28 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Ty<'tcx>,\n         bounds: &mut Bounds<'tcx>,\n     ) {\n+        let binding_span = Some(span);\n+        let constness = ty::BoundConstness::NotConst;\n+        let speculative = false;\n+        let trait_ref_span = span;\n         let trait_def_id = self.tcx().require_lang_item(lang_item, Some(span));\n+        let trait_segment = &hir::PathSegment::invalid();\n+        let infer_args = false;\n \n-        let (substs, _) = self.create_substs_for_ast_path(\n+        self.instantiate_poly_trait_ref_inner(\n+            hir_id,\n             span,\n+            binding_span,\n+            constness,\n+            bounds,\n+            speculative,\n+            trait_ref_span,\n             trait_def_id,\n-            &[],\n-            &hir::PathSegment::invalid(),\n+            trait_segment,\n             args,\n-            false,\n-            Some(self_ty),\n+            infer_args,\n+            self_ty,\n         );\n-        let assoc_bindings = self.create_assoc_bindings_for_generic_args(args);\n-        let tcx = self.tcx();\n-        let bound_vars = tcx.late_bound_vars(hir_id);\n-        let poly_trait_ref =\n-            ty::Binder::bind_with_vars(ty::TraitRef::new(trait_def_id, substs), bound_vars);\n-        bounds.trait_bounds.push((poly_trait_ref, span, ty::BoundConstness::NotConst));\n-\n-        let mut dup_bindings = FxHashMap::default();\n-        for binding in assoc_bindings {\n-            let _: Result<_, ErrorReported> = self.add_predicates_for_ast_type_binding(\n-                hir_id,\n-                poly_trait_ref,\n-                &binding,\n-                bounds,\n-                false,\n-                &mut dup_bindings,\n-                span,\n-            );\n-        }\n     }\n \n     fn ast_path_to_mono_trait_ref(\n@@ -853,46 +881,76 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .is_some()\n     }\n \n-    // Returns `true` if a bounds list includes `?Sized`.\n-    pub fn is_unsized(&self, ast_bounds: &[hir::GenericBound<'_>], span: Span) -> bool {\n+    // Sets `implicitly_sized` to true on `Bounds` if necessary\n+    pub(crate) fn add_implicitly_sized<'hir>(\n+        &self,\n+        bounds: &mut Bounds<'hir>,\n+        ast_bounds: &'hir [hir::GenericBound<'hir>],\n+        self_ty_where_predicates: Option<(hir::HirId, &'hir [hir::WherePredicate<'hir>])>,\n+        span: Span,\n+    ) {\n         let tcx = self.tcx();\n \n         // Try to find an unbound in bounds.\n         let mut unbound = None;\n-        for ab in ast_bounds {\n-            if let hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::Maybe) = ab {\n-                if unbound.is_none() {\n-                    unbound = Some(&ptr.trait_ref);\n-                } else {\n-                    tcx.sess.emit_err(MultipleRelaxedDefaultBounds { span });\n+        let mut search_bounds = |ast_bounds: &'hir [hir::GenericBound<'hir>]| {\n+            for ab in ast_bounds {\n+                if let hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::Maybe) = ab {\n+                    if unbound.is_none() {\n+                        unbound = Some(&ptr.trait_ref);\n+                    } else {\n+                        tcx.sess.emit_err(MultipleRelaxedDefaultBounds { span });\n+                    }\n                 }\n             }\n-        }\n-\n-        let kind_id = tcx.lang_items().require(LangItem::Sized);\n-        match unbound {\n-            Some(tpb) => {\n-                // FIXME(#8559) currently requires the unbound to be built-in.\n-                if let Ok(kind_id) = kind_id {\n-                    if tpb.path.res != Res::Def(DefKind::Trait, kind_id) {\n-                        tcx.sess.span_warn(\n-                            span,\n-                            \"default bound relaxed for a type parameter, but \\\n-                             this does nothing because the given bound is not \\\n-                             a default; only `?Sized` is supported\",\n-                        );\n-                        return false;\n+        };\n+        search_bounds(ast_bounds);\n+        if let Some((self_ty, where_clause)) = self_ty_where_predicates {\n+            let self_ty_def_id = tcx.hir().local_def_id(self_ty).to_def_id();\n+            for clause in where_clause {\n+                match clause {\n+                    hir::WherePredicate::BoundPredicate(pred) => {\n+                        match pred.bounded_ty.kind {\n+                            hir::TyKind::Path(hir::QPath::Resolved(_, path)) => match path.res {\n+                                Res::Def(DefKind::TyParam, def_id) if def_id == self_ty_def_id => {}\n+                                _ => continue,\n+                            },\n+                            _ => continue,\n+                        }\n+                        search_bounds(pred.bounds);\n                     }\n+                    _ => {}\n                 }\n             }\n-            _ if kind_id.is_ok() => {\n-                return false;\n+        }\n+\n+        let sized_def_id = tcx.lang_items().require(LangItem::Sized);\n+        match (&sized_def_id, unbound) {\n+            (Ok(sized_def_id), Some(tpb))\n+                if tpb.path.res == Res::Def(DefKind::Trait, *sized_def_id) =>\n+            {\n+                // There was in fact a `?Sized` bound, return without doing anything\n+                return;\n+            }\n+            (_, Some(_)) => {\n+                // There was a `?Trait` bound, but it was not `?Sized`; warn.\n+                tcx.sess.span_warn(\n+                    span,\n+                    \"default bound relaxed for a type parameter, but \\\n+                        this does nothing because the given bound is not \\\n+                        a default; only `?Sized` is supported\",\n+                );\n+                // Otherwise, add implicitly sized if `Sized` is available.\n             }\n+            _ => {\n+                // There was no `?Sized` bound; add implicitly sized if `Sized` is available.\n+            }\n+        }\n+        if sized_def_id.is_err() {\n             // No lang item for `Sized`, so we can't add it as a bound.\n-            None => {}\n+            return;\n         }\n-\n-        true\n+        bounds.implicitly_sized = Some(span);\n     }\n \n     /// This helper takes a *converted* parameter type (`param_ty`)\n@@ -910,46 +968,43 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// **A note on binders:** there is an implied binder around\n     /// `param_ty` and `ast_bounds`. See `instantiate_poly_trait_ref`\n     /// for more details.\n-    #[tracing::instrument(level = \"debug\", skip(self, bounds))]\n-    fn add_bounds(\n+    #[tracing::instrument(level = \"debug\", skip(self, ast_bounds, bounds))]\n+    pub(crate) fn add_bounds<'hir, I: Iterator<Item = &'hir hir::GenericBound<'hir>>>(\n         &self,\n         param_ty: Ty<'tcx>,\n-        ast_bounds: &[hir::GenericBound<'_>],\n+        ast_bounds: I,\n         bounds: &mut Bounds<'tcx>,\n         bound_vars: &'tcx ty::List<ty::BoundVariableKind>,\n     ) {\n         for ast_bound in ast_bounds {\n-            match *ast_bound {\n-                hir::GenericBound::Trait(ref b, hir::TraitBoundModifier::None) => {\n-                    self.instantiate_poly_trait_ref(\n-                        &b.trait_ref,\n-                        b.span,\n-                        ty::BoundConstness::NotConst,\n+            match ast_bound {\n+                hir::GenericBound::Trait(poly_trait_ref, modifier) => {\n+                    let constness = match modifier {\n+                        hir::TraitBoundModifier::MaybeConst => ty::BoundConstness::ConstIfConst,\n+                        hir::TraitBoundModifier::None => ty::BoundConstness::NotConst,\n+                        hir::TraitBoundModifier::Maybe => continue,\n+                    };\n+\n+                    let _ = self.instantiate_poly_trait_ref(\n+                        &poly_trait_ref.trait_ref,\n+                        poly_trait_ref.span,\n+                        constness,\n                         param_ty,\n                         bounds,\n                         false,\n                     );\n                 }\n-                hir::GenericBound::Trait(ref b, hir::TraitBoundModifier::MaybeConst) => {\n-                    self.instantiate_poly_trait_ref(\n-                        &b.trait_ref,\n-                        b.span,\n-                        ty::BoundConstness::ConstIfConst,\n-                        param_ty,\n-                        bounds,\n-                        false,\n+                &hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => {\n+                    self.instantiate_lang_item_trait_ref(\n+                        lang_item, span, hir_id, args, param_ty, bounds,\n                     );\n                 }\n-                hir::GenericBound::Trait(_, hir::TraitBoundModifier::Maybe)\n-                | hir::GenericBound::Unsized(_) => {}\n-                hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => self\n-                    .instantiate_lang_item_trait_ref(\n-                        lang_item, span, hir_id, args, param_ty, bounds,\n-                    ),\n-                hir::GenericBound::Outlives(ref l) => bounds.region_bounds.push((\n-                    ty::Binder::bind_with_vars(self.ast_region_to_region(l, None), bound_vars),\n-                    l.span,\n-                )),\n+                hir::GenericBound::Outlives(lifetime) => {\n+                    let region = self.ast_region_to_region(lifetime, None);\n+                    bounds\n+                        .region_bounds\n+                        .push((ty::Binder::bind_with_vars(region, bound_vars), lifetime.span));\n+                }\n             }\n         }\n     }\n@@ -970,24 +1025,20 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// example above, but is not true in supertrait listings like `trait Foo: Bar + Baz`.\n     ///\n     /// `span` should be the declaration size of the parameter.\n-    pub fn compute_bounds(\n+    pub(crate) fn compute_bounds(\n         &self,\n         param_ty: Ty<'tcx>,\n         ast_bounds: &[hir::GenericBound<'_>],\n-        sized_by_default: SizedByDefault,\n-        span: Span,\n     ) -> Bounds<'tcx> {\n-        self.compute_bounds_inner(param_ty, &ast_bounds, sized_by_default, span)\n+        self.compute_bounds_inner(param_ty, &ast_bounds)\n     }\n \n     /// Convert the bounds in `ast_bounds` that refer to traits which define an associated type\n     /// named `assoc_name` into ty::Bounds. Ignore the rest.\n-    pub fn compute_bounds_that_match_assoc_type(\n+    pub(crate) fn compute_bounds_that_match_assoc_type(\n         &self,\n         param_ty: Ty<'tcx>,\n         ast_bounds: &[hir::GenericBound<'_>],\n-        sized_by_default: SizedByDefault,\n-        span: Span,\n         assoc_name: Ident,\n     ) -> Bounds<'tcx> {\n         let mut result = Vec::new();\n@@ -1002,25 +1053,17 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n         }\n \n-        self.compute_bounds_inner(param_ty, &result, sized_by_default, span)\n+        self.compute_bounds_inner(param_ty, &result)\n     }\n \n     fn compute_bounds_inner(\n         &self,\n         param_ty: Ty<'tcx>,\n         ast_bounds: &[hir::GenericBound<'_>],\n-        sized_by_default: SizedByDefault,\n-        span: Span,\n     ) -> Bounds<'tcx> {\n         let mut bounds = Bounds::default();\n \n-        self.add_bounds(param_ty, ast_bounds, &mut bounds, ty::List::empty());\n-\n-        bounds.implicitly_sized = if let SizedByDefault::Yes = sized_by_default {\n-            if !self.is_unsized(ast_bounds, span) { Some(span) } else { None }\n-        } else {\n-            None\n-        };\n+        self.add_bounds(param_ty, ast_bounds.iter(), &mut bounds, ty::List::empty());\n \n         bounds\n     }\n@@ -1212,7 +1255,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // Calling `skip_binder` is okay, because `add_bounds` expects the `param_ty`\n                 // parameter to have a skipped binder.\n                 let param_ty = tcx.mk_ty(ty::Projection(projection_ty.skip_binder()));\n-                self.add_bounds(param_ty, ast_bounds, bounds, candidate.bound_vars());\n+                self.add_bounds(param_ty, ast_bounds.iter(), bounds, candidate.bound_vars());\n             }\n         }\n         Ok(())"}, {"sha": "3688fa05e038eb2948da4152ded88e55e01aabd5", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 24, "deletions": 111, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/72969f6526b6a3ff9f2bbfe73e26249d977794e7/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72969f6526b6a3ff9f2bbfe73e26249d977794e7/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=72969f6526b6a3ff9f2bbfe73e26249d977794e7", "patch": "@@ -14,7 +14,7 @@\n //! At present, however, we do run collection across all items in the\n //! crate as a kind of pass. This should eventually be factored away.\n \n-use crate::astconv::{AstConv, SizedByDefault};\n+use crate::astconv::AstConv;\n use crate::bounds::Bounds;\n use crate::check::intrinsic::intrinsic_operation_unsafety;\n use crate::constrained_generic_params as cgp;\n@@ -1156,18 +1156,10 @@ fn super_predicates_that_define_assoc_type(\n                 &icx,\n                 self_param_ty,\n                 &bounds,\n-                SizedByDefault::No,\n-                item.span,\n                 assoc_name,\n             )\n         } else {\n-            <dyn AstConv<'_>>::compute_bounds(\n-                &icx,\n-                self_param_ty,\n-                &bounds,\n-                SizedByDefault::No,\n-                item.span,\n-            )\n+            <dyn AstConv<'_>>::compute_bounds(&icx, self_param_ty, &bounds)\n         };\n \n         let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n@@ -2176,12 +2168,13 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                 let param_ty = ty::ParamTy::new(index, name).to_ty(tcx);\n                 index += 1;\n \n-                let sized = SizedByDefault::Yes;\n-                let bounds = <dyn AstConv<'_>>::compute_bounds(\n+                let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, param_ty, &param.bounds);\n+                // Params are implicitly sized unless a `?Sized` bound is found\n+                <dyn AstConv<'_>>::add_implicitly_sized(\n                     &icx,\n-                    param_ty,\n+                    &mut bounds,\n                     &param.bounds,\n-                    sized,\n+                    Some((param.hir_id, ast_generics.where_clause.predicates)),\n                     param.span,\n                 );\n                 predicates.extend(bounds.predicates(tcx, param_ty));\n@@ -2227,64 +2220,15 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                     }\n                 }\n \n-                for bound in bound_pred.bounds.iter() {\n-                    match bound {\n-                        hir::GenericBound::Trait(poly_trait_ref, modifier) => {\n-                            let constness = match modifier {\n-                                hir::TraitBoundModifier::None => ty::BoundConstness::NotConst,\n-                                hir::TraitBoundModifier::MaybeConst => {\n-                                    ty::BoundConstness::ConstIfConst\n-                                }\n-                                // We ignore `where T: ?Sized`, it is already part of\n-                                // type parameter `T`.\n-                                hir::TraitBoundModifier::Maybe => continue,\n-                            };\n-\n-                            let mut bounds = Bounds::default();\n-                            let _ = <dyn AstConv<'_>>::instantiate_poly_trait_ref(\n-                                &icx,\n-                                &poly_trait_ref.trait_ref,\n-                                poly_trait_ref.span,\n-                                constness,\n-                                ty,\n-                                &mut bounds,\n-                                false,\n-                            );\n-                            predicates.extend(bounds.predicates(tcx, ty));\n-                        }\n-\n-                        &hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => {\n-                            let mut bounds = Bounds::default();\n-                            <dyn AstConv<'_>>::instantiate_lang_item_trait_ref(\n-                                &icx,\n-                                lang_item,\n-                                span,\n-                                hir_id,\n-                                args,\n-                                ty,\n-                                &mut bounds,\n-                            );\n-                            predicates.extend(bounds.predicates(tcx, ty));\n-                        }\n-\n-                        hir::GenericBound::Unsized(_) => {}\n-\n-                        hir::GenericBound::Outlives(lifetime) => {\n-                            let region =\n-                                <dyn AstConv<'_>>::ast_region_to_region(&icx, lifetime, None);\n-                            predicates.insert((\n-                                ty::Binder::bind_with_vars(\n-                                    ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n-                                        ty, region,\n-                                    )),\n-                                    bound_vars,\n-                                )\n-                                .to_predicate(tcx),\n-                                lifetime.span,\n-                            ));\n-                        }\n-                    }\n-                }\n+                let mut bounds = Bounds::default();\n+                <dyn AstConv<'_>>::add_bounds(\n+                    &icx,\n+                    ty,\n+                    bound_pred.bounds.iter(),\n+                    &mut bounds,\n+                    bound_vars,\n+                );\n+                predicates.extend(bounds.predicates(tcx, ty));\n             }\n \n             hir::WherePredicate::RegionPredicate(region_pred) => {\n@@ -2498,45 +2442,14 @@ fn predicates_from_bound<'tcx>(\n     param_ty: Ty<'tcx>,\n     bound: &'tcx hir::GenericBound<'tcx>,\n ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n-    match *bound {\n-        hir::GenericBound::Trait(ref tr, modifier) => {\n-            let constness = match modifier {\n-                hir::TraitBoundModifier::Maybe => return vec![],\n-                hir::TraitBoundModifier::MaybeConst => ty::BoundConstness::ConstIfConst,\n-                hir::TraitBoundModifier::None => ty::BoundConstness::NotConst,\n-            };\n-\n-            let mut bounds = Bounds::default();\n-            let _ = astconv.instantiate_poly_trait_ref(\n-                &tr.trait_ref,\n-                tr.span,\n-                constness,\n-                param_ty,\n-                &mut bounds,\n-                false,\n-            );\n-            bounds.predicates(astconv.tcx(), param_ty)\n-        }\n-        hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => {\n-            let mut bounds = Bounds::default();\n-            astconv.instantiate_lang_item_trait_ref(\n-                lang_item,\n-                span,\n-                hir_id,\n-                args,\n-                param_ty,\n-                &mut bounds,\n-            );\n-            bounds.predicates(astconv.tcx(), param_ty)\n-        }\n-        hir::GenericBound::Unsized(_) => vec![],\n-        hir::GenericBound::Outlives(ref lifetime) => {\n-            let region = astconv.ast_region_to_region(lifetime, None);\n-            let pred = ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(param_ty, region))\n-                .to_predicate(astconv.tcx());\n-            vec![(pred, lifetime.span)]\n-        }\n-    }\n+    let mut bounds = Bounds::default();\n+    astconv.add_bounds(\n+        param_ty,\n+        std::array::IntoIter::new([bound]),\n+        &mut bounds,\n+        ty::List::empty(),\n+    );\n+    bounds.predicates(astconv.tcx(), param_ty)\n }\n \n fn compute_sig_of_foreign_fn_decl<'tcx>("}, {"sha": "2bc048ac8a0e9395fd69b79749c586cfcc9b9ac6", "filename": "compiler/rustc_typeck/src/collect/item_bounds.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/72969f6526b6a3ff9f2bbfe73e26249d977794e7/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72969f6526b6a3ff9f2bbfe73e26249d977794e7/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=72969f6526b6a3ff9f2bbfe73e26249d977794e7", "patch": "@@ -1,5 +1,5 @@\n use super::ItemCtxt;\n-use crate::astconv::{AstConv, SizedByDefault};\n+use crate::astconv::AstConv;\n use rustc_hir as hir;\n use rustc_infer::traits::util;\n use rustc_middle::ty::subst::InternalSubsts;\n@@ -17,21 +17,18 @@ use rustc_span::Span;\n fn associated_type_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     assoc_item_def_id: DefId,\n-    bounds: &'tcx [hir::GenericBound<'tcx>],\n+    ast_bounds: &'tcx [hir::GenericBound<'tcx>],\n     span: Span,\n ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n     let item_ty = tcx.mk_projection(\n         assoc_item_def_id,\n         InternalSubsts::identity_for_item(tcx, assoc_item_def_id),\n     );\n \n-    let bounds = <dyn AstConv<'_>>::compute_bounds(\n-        &ItemCtxt::new(tcx, assoc_item_def_id),\n-        item_ty,\n-        &bounds,\n-        SizedByDefault::Yes,\n-        span,\n-    );\n+    let icx = ItemCtxt::new(tcx, assoc_item_def_id);\n+    let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, item_ty, &ast_bounds);\n+    // Associated types are implicitly sized unless a `?Sized` bound is found\n+    <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, &ast_bounds, None, span);\n \n     let trait_def_id = tcx.associated_item(assoc_item_def_id).container.id();\n     let trait_predicates = tcx.trait_explicit_predicates_and_bounds(trait_def_id.expect_local());\n@@ -59,21 +56,18 @@ fn associated_type_bounds<'tcx>(\n fn opaque_type_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     opaque_def_id: DefId,\n-    bounds: &'tcx [hir::GenericBound<'tcx>],\n+    ast_bounds: &'tcx [hir::GenericBound<'tcx>],\n     span: Span,\n ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n     ty::print::with_no_queries(|| {\n         let item_ty =\n             tcx.mk_opaque(opaque_def_id, InternalSubsts::identity_for_item(tcx, opaque_def_id));\n \n-        let bounds = <dyn AstConv<'_>>::compute_bounds(\n-            &ItemCtxt::new(tcx, opaque_def_id),\n-            item_ty,\n-            &bounds,\n-            SizedByDefault::Yes,\n-            span,\n-        )\n-        .predicates(tcx, item_ty);\n+        let icx = ItemCtxt::new(tcx, opaque_def_id);\n+        let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, item_ty, &ast_bounds);\n+        // Opaque types are implicitly sized unless a `?Sized` bound is found\n+        <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, &ast_bounds, None, span);\n+        let bounds = bounds.predicates(tcx, item_ty);\n \n         debug!(\"opaque_type_bounds({}) = {:?}\", tcx.def_path_str(opaque_def_id), bounds);\n "}, {"sha": "a95300217ab75edab1c4d3125bbf9d70dff6f95f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72969f6526b6a3ff9f2bbfe73e26249d977794e7/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72969f6526b6a3ff9f2bbfe73e26249d977794e7/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=72969f6526b6a3ff9f2bbfe73e26249d977794e7", "patch": "@@ -129,7 +129,6 @@ impl Clean<GenericBound> for hir::GenericBound<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> GenericBound {\n         match *self {\n             hir::GenericBound::Outlives(lt) => GenericBound::Outlives(lt.clean(cx)),\n-            hir::GenericBound::Unsized(_) => GenericBound::maybe_sized(cx),\n             hir::GenericBound::LangItemTrait(lang_item, span, _, generic_args) => {\n                 let def_id = cx.tcx.require_lang_item(lang_item, Some(span));\n \n@@ -557,19 +556,13 @@ impl Clean<Generics> for hir::Generics<'_> {\n                 WherePredicate::BoundPredicate {\n                     ty: Generic(ref name), ref mut bounds, ..\n                 } => {\n-                    if let [] | [GenericBound::TraitBound(_, hir::TraitBoundModifier::Maybe)] =\n-                        &bounds[..]\n-                    {\n+                    if bounds.is_empty() {\n                         for param in &mut generics.params {\n                             match param.kind {\n                                 GenericParamDefKind::Lifetime { .. } => {}\n                                 GenericParamDefKind::Type { bounds: ref mut ty_bounds, .. } => {\n                                     if &param.name == name {\n                                         mem::swap(bounds, ty_bounds);\n-                                        // We now keep track of `?Sized` obligations in the HIR.\n-                                        // If we don't clear `ty_bounds` we end up with\n-                                        // `fn foo<X: ?Sized>(_: X) where X: ?Sized`.\n-                                        ty_bounds.clear();\n                                         break;\n                                     }\n                                 }"}, {"sha": "6a1a502749a75eb1e58320688e8f369b15c60768", "filename": "src/test/ui/error-codes/e0119/complex-impl.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72969f6526b6a3ff9f2bbfe73e26249d977794e7/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fcomplex-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/72969f6526b6a3ff9f2bbfe73e26249d977794e7/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fcomplex-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fcomplex-impl.stderr?ref=72969f6526b6a3ff9f2bbfe73e26249d977794e7", "patch": "@@ -6,7 +6,7 @@ LL | impl<R> External for (Q, R) {}\n    |\n    = note: conflicting implementation in crate `complex_impl_support`:\n            - impl<'a, 'b, 'c, T, U, V, W> External for (T, M<'a, 'b, 'c, Box<U>, V, W>)\n-             where <U as FnOnce<(T,)>>::Output == V, <V as Iterator>::Item == T, 'b: 'a, T: 'a, U: FnOnce<(T,)>, U: 'static, V: Iterator, V: Clone, W: Add, <W as Add>::Output: Copy;\n+             where <U as FnOnce<(T,)>>::Output == V, <V as Iterator>::Item == T, 'b: 'a, T: 'a, U: 'static, U: FnOnce<(T,)>, V: Iterator, V: Clone, W: Add, <W as Add>::Output: Copy;\n \n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n   --> $DIR/complex-impl.rs:9:1"}, {"sha": "22da0dffbf29eb87cf51d02eafa70ea5f6766338", "filename": "src/test/ui/generics/wrong-number-of-args.stderr", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/72969f6526b6a3ff9f2bbfe73e26249d977794e7/src%2Ftest%2Fui%2Fgenerics%2Fwrong-number-of-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/72969f6526b6a3ff9f2bbfe73e26249d977794e7/src%2Ftest%2Fui%2Fgenerics%2Fwrong-number-of-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fwrong-number-of-args.stderr?ref=72969f6526b6a3ff9f2bbfe73e26249d977794e7", "patch": "@@ -440,17 +440,6 @@ note: trait defined here, with 1 lifetime parameter: `'a`\n LL |         trait GenericLifetimeAT<'a> {\n    |               ^^^^^^^^^^^^^^^^^ --\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/wrong-number-of-args.rs:169:44\n-   |\n-LL |         type C = Box<dyn GenericLifetimeAT<(), AssocTy=()>>;\n-   |                                            ^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |         type C<'a> = Box<dyn GenericLifetimeAT<'a, (), AssocTy=()>>;\n-   |               ++++                             +++\n-\n error[E0107]: this trait takes 0 generic arguments but 1 generic argument was supplied\n   --> $DIR/wrong-number-of-args.rs:169:26\n    |\n@@ -465,6 +454,17 @@ note: trait defined here, with 0 generic parameters\n LL |         trait GenericLifetimeAT<'a> {\n    |               ^^^^^^^^^^^^^^^^^\n \n+error[E0106]: missing lifetime specifier\n+  --> $DIR/wrong-number-of-args.rs:169:44\n+   |\n+LL |         type C = Box<dyn GenericLifetimeAT<(), AssocTy=()>>;\n+   |                                            ^ expected named lifetime parameter\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |         type C<'a> = Box<dyn GenericLifetimeAT<'a, (), AssocTy=()>>;\n+   |               ++++                             +++\n+\n error[E0107]: this trait takes 1 generic argument but 0 generic arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:181:26\n    |\n@@ -525,17 +525,6 @@ help: add missing generic argument\n LL |         type C = Box<dyn GenericTypeAT<'static, A, AssocTy=()>>;\n    |                                               +++\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/wrong-number-of-args.rs:201:48\n-   |\n-LL |         type A = Box<dyn GenericLifetimeTypeAT<AssocTy=()>>;\n-   |                                                ^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |         type A<'a> = Box<dyn GenericLifetimeTypeAT<'a, AssocTy=()>>;\n-   |               ++++                                 +++\n-\n error[E0107]: this trait takes 1 generic argument but 0 generic arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:201:26\n    |\n@@ -552,6 +541,17 @@ help: add missing generic argument\n LL |         type A = Box<dyn GenericLifetimeTypeAT<A, AssocTy=()>>;\n    |                                                ++\n \n+error[E0106]: missing lifetime specifier\n+  --> $DIR/wrong-number-of-args.rs:201:48\n+   |\n+LL |         type A = Box<dyn GenericLifetimeTypeAT<AssocTy=()>>;\n+   |                                                ^ expected named lifetime parameter\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |         type A<'a> = Box<dyn GenericLifetimeTypeAT<'a, AssocTy=()>>;\n+   |               ++++                                 +++\n+\n error[E0107]: this trait takes 1 generic argument but 0 generic arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:207:26\n    |\n@@ -609,17 +609,6 @@ help: consider introducing a named lifetime parameter\n LL |         type D<'a> = Box<dyn GenericLifetimeTypeAT<'a, (), AssocTy=()>>;\n    |               ++++                                 +++\n \n-error[E0106]: missing lifetime specifier\n-  --> $DIR/wrong-number-of-args.rs:221:48\n-   |\n-LL |         type E = Box<dyn GenericLifetimeTypeAT<(), (), AssocTy=()>>;\n-   |                                                ^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |         type E<'a> = Box<dyn GenericLifetimeTypeAT<'a, (), (), AssocTy=()>>;\n-   |               ++++                                 +++\n-\n error[E0107]: this trait takes 1 generic argument but 2 generic arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:221:26\n    |\n@@ -634,6 +623,17 @@ note: trait defined here, with 1 generic parameter: `A`\n LL |         trait GenericLifetimeTypeAT<'a, A> {\n    |               ^^^^^^^^^^^^^^^^^^^^^     -\n \n+error[E0106]: missing lifetime specifier\n+  --> $DIR/wrong-number-of-args.rs:221:48\n+   |\n+LL |         type E = Box<dyn GenericLifetimeTypeAT<(), (), AssocTy=()>>;\n+   |                                                ^ expected named lifetime parameter\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |         type E<'a> = Box<dyn GenericLifetimeTypeAT<'a, (), (), AssocTy=()>>;\n+   |               ++++                                 +++\n+\n error[E0107]: this trait takes 1 lifetime argument but 2 lifetime arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:227:26\n    |\n@@ -767,17 +767,6 @@ help: add missing lifetime argument\n LL |         type B = Box<dyn GenericLifetimeLifetimeAT<'static, 'b, AssocTy=()>>;\n    |                                                           ++++\n \n-error[E0106]: missing lifetime specifiers\n-  --> $DIR/wrong-number-of-args.rs:279:56\n-   |\n-LL |         type A = Box<dyn GenericLifetimeLifetimeTypeAT<AssocTy=()>>;\n-   |                                                        ^ expected 2 lifetime parameters\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL |         type A<'a> = Box<dyn GenericLifetimeLifetimeTypeAT<'a, 'a, AssocTy=()>>;\n-   |               ++++                                         +++++++\n-\n error[E0107]: this trait takes 1 generic argument but 0 generic arguments were supplied\n   --> $DIR/wrong-number-of-args.rs:279:26\n    |\n@@ -794,6 +783,17 @@ help: add missing generic argument\n LL |         type A = Box<dyn GenericLifetimeLifetimeTypeAT<A, AssocTy=()>>;\n    |                                                        ++\n \n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/wrong-number-of-args.rs:279:56\n+   |\n+LL |         type A = Box<dyn GenericLifetimeLifetimeTypeAT<AssocTy=()>>;\n+   |                                                        ^ expected 2 lifetime parameters\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |         type A<'a> = Box<dyn GenericLifetimeLifetimeTypeAT<'a, 'a, AssocTy=()>>;\n+   |               ++++                                         +++++++\n+\n error[E0107]: this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n   --> $DIR/wrong-number-of-args.rs:285:26\n    |"}, {"sha": "d7af0c4248056de175194e77fb867f7de58c2b50", "filename": "src/test/ui/maybe-bounds-where.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72969f6526b6a3ff9f2bbfe73e26249d977794e7/src%2Ftest%2Fui%2Fmaybe-bounds-where.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72969f6526b6a3ff9f2bbfe73e26249d977794e7/src%2Ftest%2Fui%2Fmaybe-bounds-where.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmaybe-bounds-where.rs?ref=72969f6526b6a3ff9f2bbfe73e26249d977794e7", "patch": "@@ -11,6 +11,7 @@ trait Trait<'a> {}\n \n struct S4<T>(T) where for<'a> T: ?Trait<'a>;\n //~^ ERROR `?Trait` bounds are only permitted at the point where a type parameter is declared\n+//~| WARN default bound relaxed for a type parameter\n \n struct S5<T>(*const T) where T: ?Trait<'static> + ?Sized;\n //~^ ERROR type parameter has more than one relaxed default bound"}, {"sha": "2aa6a8a38223df4d5401f433ce649bc558515360", "filename": "src/test/ui/maybe-bounds-where.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/72969f6526b6a3ff9f2bbfe73e26249d977794e7/src%2Ftest%2Fui%2Fmaybe-bounds-where.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/72969f6526b6a3ff9f2bbfe73e26249d977794e7/src%2Ftest%2Fui%2Fmaybe-bounds-where.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmaybe-bounds-where.stderr?ref=72969f6526b6a3ff9f2bbfe73e26249d977794e7", "patch": "@@ -23,23 +23,29 @@ LL | struct S4<T>(T) where for<'a> T: ?Trait<'a>;\n    |                               ^\n \n error: `?Trait` bounds are only permitted at the point where a type parameter is declared\n-  --> $DIR/maybe-bounds-where.rs:20:18\n+  --> $DIR/maybe-bounds-where.rs:21:18\n    |\n LL |     fn f() where T: ?Sized {}\n    |                  ^\n \n+warning: default bound relaxed for a type parameter, but this does nothing because the given bound is not a default; only `?Sized` is supported\n+  --> $DIR/maybe-bounds-where.rs:12:11\n+   |\n+LL | struct S4<T>(T) where for<'a> T: ?Trait<'a>;\n+   |           ^\n+\n error[E0203]: type parameter has more than one relaxed default bound, only one is supported\n-  --> $DIR/maybe-bounds-where.rs:15:11\n+  --> $DIR/maybe-bounds-where.rs:16:11\n    |\n LL | struct S5<T>(*const T) where T: ?Trait<'static> + ?Sized;\n    |           ^\n \n warning: default bound relaxed for a type parameter, but this does nothing because the given bound is not a default; only `?Sized` is supported\n-  --> $DIR/maybe-bounds-where.rs:15:11\n+  --> $DIR/maybe-bounds-where.rs:16:11\n    |\n LL | struct S5<T>(*const T) where T: ?Trait<'static> + ?Sized;\n    |           ^\n \n-error: aborting due to 6 previous errors; 1 warning emitted\n+error: aborting due to 6 previous errors; 2 warnings emitted\n \n For more information about this error, try `rustc --explain E0203`."}]}