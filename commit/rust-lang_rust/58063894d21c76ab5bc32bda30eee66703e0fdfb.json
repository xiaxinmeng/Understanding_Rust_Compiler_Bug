{"sha": "58063894d21c76ab5bc32bda30eee66703e0fdfb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MDYzODk0ZDIxYzc2YWI1YmMzMmJkYTMwZWVlNjY3MDNlMGZkZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-11T23:28:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-11T23:28:39Z"}, "message": "Auto merge of #53913 - petrochenkov:biattr4, r=alexcrichton\n\nresolve: Future proof resolutions for potentially built-in attributes\n\nThis is not full \"pass all attributes through name resolution\", but a more conservative solution.\nIf built-in attribute is ambiguous with any other macro in scope, then an error is reported.\n\nWhat complications arise with the full solution - https://github.com/rust-lang/rust/pull/53913#issuecomment-418204136.\n\ncc https://github.com/rust-lang/rust/pull/50911#issuecomment-411605393\ncc https://github.com/rust-lang/rust/issues/52269\nCloses https://github.com/rust-lang/rust/issues/53531", "tree": {"sha": "834f7c003db882543320e632c7754ef2016e42eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/834f7c003db882543320e632c7754ef2016e42eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58063894d21c76ab5bc32bda30eee66703e0fdfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58063894d21c76ab5bc32bda30eee66703e0fdfb", "html_url": "https://github.com/rust-lang/rust/commit/58063894d21c76ab5bc32bda30eee66703e0fdfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58063894d21c76ab5bc32bda30eee66703e0fdfb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "html_url": "https://github.com/rust-lang/rust/commit/2f1547c0aa5957b42cc768c00119c6eb7b4262d3"}, {"sha": "de153d61f5a4ef8681fc64fc55de2bcfe449c8c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/de153d61f5a4ef8681fc64fc55de2bcfe449c8c4", "html_url": "https://github.com/rust-lang/rust/commit/de153d61f5a4ef8681fc64fc55de2bcfe449c8c4"}], "stats": {"total": 424, "additions": 353, "deletions": 71}, "files": [{"sha": "d1a05964c8f6497c0993fc342a40ee201c7e1817", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=58063894d21c76ab5bc32bda30eee66703e0fdfb", "patch": "@@ -39,6 +39,7 @@ use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::base::Determinacy::Undetermined;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n+use syntax::feature_gate::is_builtin_attr;\n use syntax::parse::token::{self, Token};\n use syntax::std_inject::injected_crate_name;\n use syntax::symbol::keywords;\n@@ -1057,4 +1058,13 @@ impl<'a, 'b, 'cl> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b, 'cl> {\n             }\n         }\n     }\n+\n+    fn visit_attribute(&mut self, attr: &'a ast::Attribute) {\n+        if !attr.is_sugared_doc && is_builtin_attr(attr) {\n+            self.resolver.current_module.builtin_attrs.borrow_mut().push((\n+                attr.path.segments[0].ident, self.expansion, self.current_legacy_scope\n+            ));\n+        }\n+        visit::walk_attribute(self, attr);\n+    }\n }"}, {"sha": "8c769094f521181d3314d0180443c9c189804916", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=58063894d21c76ab5bc32bda30eee66703e0fdfb", "patch": "@@ -81,7 +81,7 @@ use std::mem::replace;\n use rustc_data_structures::sync::Lrc;\n \n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n-use macros::{InvocationData, LegacyBinding};\n+use macros::{InvocationData, LegacyBinding, LegacyScope};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n@@ -1010,8 +1010,9 @@ pub struct ModuleData<'a> {\n     normal_ancestor_id: DefId,\n \n     resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n-    legacy_macro_resolutions: RefCell<Vec<(Mark, Ident, MacroKind, Option<Def>)>>,\n+    legacy_macro_resolutions: RefCell<Vec<(Ident, MacroKind, Mark, LegacyScope<'a>, Option<Def>)>>,\n     macro_resolutions: RefCell<Vec<(Box<[Ident]>, Span)>>,\n+    builtin_attrs: RefCell<Vec<(Ident, Mark, LegacyScope<'a>)>>,\n \n     // Macro invocations that can expand into items in this module.\n     unresolved_invocations: RefCell<FxHashSet<Mark>>,\n@@ -1050,6 +1051,7 @@ impl<'a> ModuleData<'a> {\n             resolutions: RefCell::new(FxHashMap()),\n             legacy_macro_resolutions: RefCell::new(Vec::new()),\n             macro_resolutions: RefCell::new(Vec::new()),\n+            builtin_attrs: RefCell::new(Vec::new()),\n             unresolved_invocations: RefCell::new(FxHashSet()),\n             no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n@@ -1268,6 +1270,7 @@ impl<'a> NameBinding<'a> {\n     fn macro_kind(&self) -> Option<MacroKind> {\n         match self.def_ignoring_ambiguity() {\n             Def::Macro(_, kind) => Some(kind),\n+            Def::NonMacroAttr(..) => Some(MacroKind::Attr),\n             _ => None,\n         }\n     }\n@@ -1276,19 +1279,18 @@ impl<'a> NameBinding<'a> {\n         if self.is_extern_crate() { \"extern crate\" } else { self.def().kind_name() }\n     }\n \n-    // Suppose that we resolved macro invocation with `invoc_id` to binding `binding` at some\n-    // expansion round `max(invoc_id, binding)` when they both emerged from macros.\n+    // Suppose that we resolved macro invocation with `invoc_parent_expansion` to binding `binding`\n+    // at some expansion round `max(invoc, binding)` when they both emerged from macros.\n     // Then this function returns `true` if `self` may emerge from a macro *after* that\n     // in some later round and screw up our previously found resolution.\n     // See more detailed explanation in\n     // https://github.com/rust-lang/rust/pull/53778#issuecomment-419224049\n-    fn may_appear_after(&self, invoc_id: Mark, binding: &NameBinding) -> bool {\n-        // self > max(invoc_id, binding) => !(self <= invoc_id || self <= binding)\n+    fn may_appear_after(&self, invoc_parent_expansion: Mark, binding: &NameBinding) -> bool {\n+        // self > max(invoc, binding) => !(self <= invoc || self <= binding)\n         // Expansions are partially ordered, so \"may appear after\" is an inversion of\n         // \"certainly appears before or simultaneously\" and includes unordered cases.\n         let self_parent_expansion = self.expansion;\n         let other_parent_expansion = binding.expansion;\n-        let invoc_parent_expansion = invoc_id.parent();\n         let certainly_before_other_or_simultaneously =\n             other_parent_expansion.is_descendant_of(self_parent_expansion);\n         let certainly_before_invoc_or_simultaneously =\n@@ -3493,16 +3495,16 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         path_span: Span,\n         crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n-        self.resolve_path_with_invoc_id(base_module, path, opt_ns, Mark::root(),\n-                                        record_used, path_span, crate_lint)\n+        self.resolve_path_with_parent_expansion(base_module, path, opt_ns, Mark::root(),\n+                                                record_used, path_span, crate_lint)\n     }\n \n-    fn resolve_path_with_invoc_id(\n+    fn resolve_path_with_parent_expansion(\n         &mut self,\n         base_module: Option<ModuleOrUniformRoot<'a>>,\n         path: &[Ident],\n         opt_ns: Option<Namespace>, // `None` indicates a module path\n-        invoc_id: Mark,\n+        parent_expansion: Mark,\n         record_used: bool,\n         path_span: Span,\n         crate_lint: CrateLint,\n@@ -3595,8 +3597,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 self.resolve_ident_in_module(module, ident, ns, record_used, path_span)\n             } else if opt_ns == Some(MacroNS) {\n                 assert!(ns == TypeNS);\n-                self.resolve_lexical_macro_path_segment(ident, ns, invoc_id, record_used,\n-                                                        record_used, false, path_span)\n+                self.resolve_lexical_macro_path_segment(ident, ns, None, parent_expansion,\n+                                                        record_used, record_used, path_span)\n                                                         .map(|(binding, _)| binding)\n             } else {\n                 let record_used_id ="}, {"sha": "7733ce475e339529662808efc1f26bd04d521f96", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 75, "deletions": 53, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=58063894d21c76ab5bc32bda30eee66703e0fdfb", "patch": "@@ -109,6 +109,13 @@ pub struct ProcMacError {\n     warn_msg: &'static str,\n }\n \n+// For compatibility bang macros are skipped when resolving potentially built-in attributes.\n+fn macro_kind_mismatch(name: Name, requirement: Option<MacroKind>, candidate: Option<MacroKind>)\n+                       -> bool {\n+    requirement == Some(MacroKind::Attr) && candidate == Some(MacroKind::Bang) &&\n+    (name == \"test\" || name == \"bench\" || is_builtin_attr_name(name))\n+}\n+\n impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -313,7 +320,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n         None\n     }\n \n-    fn resolve_macro_invocation(&mut self, invoc: &Invocation, scope: Mark, force: bool)\n+    fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: Mark, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n         let (path, kind, derives_in_scope) = match invoc.kind {\n             InvocationKind::Attr { attr: None, .. } =>\n@@ -326,7 +333,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n                 (path, MacroKind::Derive, &[][..]),\n         };\n \n-        let (def, ext) = self.resolve_macro_to_def(path, kind, scope, derives_in_scope, force)?;\n+        let (def, ext) = self.resolve_macro_to_def(path, kind, invoc_id, derives_in_scope, force)?;\n \n         if let Def::Macro(def_id, _) = def {\n             self.macro_defs.insert(invoc.expansion_data.mark, def_id);\n@@ -341,10 +348,10 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n         Ok(Some(ext))\n     }\n \n-    fn resolve_macro_path(&mut self, path: &ast::Path, kind: MacroKind, scope: Mark,\n+    fn resolve_macro_path(&mut self, path: &ast::Path, kind: MacroKind, invoc_id: Mark,\n                           derives_in_scope: &[ast::Path], force: bool)\n                           -> Result<Lrc<SyntaxExtension>, Determinacy> {\n-        Ok(self.resolve_macro_to_def(path, kind, scope, derives_in_scope, force)?.1)\n+        Ok(self.resolve_macro_to_def(path, kind, invoc_id, derives_in_scope, force)?.1)\n     }\n \n     fn check_unused_macros(&self) {\n@@ -366,10 +373,10 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n }\n \n impl<'a, 'cl> Resolver<'a, 'cl> {\n-    fn resolve_macro_to_def(&mut self, path: &ast::Path, kind: MacroKind, scope: Mark,\n+    fn resolve_macro_to_def(&mut self, path: &ast::Path, kind: MacroKind, invoc_id: Mark,\n                             derives_in_scope: &[ast::Path], force: bool)\n                             -> Result<(Def, Lrc<SyntaxExtension>), Determinacy> {\n-        let def = self.resolve_macro_to_def_inner(path, kind, scope, derives_in_scope, force);\n+        let def = self.resolve_macro_to_def_inner(path, kind, invoc_id, derives_in_scope, force);\n \n         // Report errors and enforce feature gates for the resolved macro.\n         if def != Err(Determinacy::Undetermined) {\n@@ -439,8 +446,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let ast::Path { ref segments, span } = *path;\n         let mut path: Vec<_> = segments.iter().map(|seg| seg.ident).collect();\n         let invocation = self.invocations[&invoc_id];\n-        let module = invocation.module.get();\n-        self.current_module = if module.is_trait() { module.parent.unwrap() } else { module };\n+        let parent_expansion = invoc_id.parent();\n+        let parent_legacy_scope = invocation.parent_legacy_scope.get();\n+        self.current_module = invocation.module.get().nearest_item_scope();\n \n         // Possibly apply the macro helper hack\n         if kind == MacroKind::Bang && path.len() == 1 &&\n@@ -450,8 +458,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         if path.len() > 1 {\n-            let def = match self.resolve_path_with_invoc_id(None, &path, Some(MacroNS), invoc_id,\n-                                                            false, span, CrateLint::No) {\n+            let def = match self.resolve_path_with_parent_expansion(None, &path, Some(MacroNS),\n+                                                                    parent_expansion, false, span,\n+                                                                    CrateLint::No) {\n                 PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n                     def @ _ => {\n@@ -471,19 +480,19 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     Err(Determinacy::Determined)\n                 },\n             };\n-            self.current_module.nearest_item_scope().macro_resolutions.borrow_mut()\n+            self.current_module.macro_resolutions.borrow_mut()\n                 .push((path.into_boxed_slice(), span));\n             return def;\n         }\n \n         let legacy_resolution = self.resolve_legacy_scope(\n-            path[0], invoc_id, invocation.parent_legacy_scope.get(), false, kind == MacroKind::Attr\n+            path[0], Some(kind), parent_expansion, parent_legacy_scope, false\n         );\n         let result = if let Some(legacy_binding) = legacy_resolution {\n             Ok(legacy_binding.def())\n         } else {\n-            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, invoc_id, false, force,\n-                                                          kind == MacroKind::Attr, span) {\n+            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, Some(kind),\n+                                                          parent_expansion, false, force, span) {\n                 Ok((binding, _)) => Ok(binding.def_ignoring_ambiguity()),\n                 Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n                 Err(Determinacy::Determined) => {\n@@ -493,8 +502,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n         };\n \n-        self.current_module.nearest_item_scope().legacy_macro_resolutions.borrow_mut()\n-            .push((invoc_id, path[0], kind, result.ok()));\n+        self.current_module.legacy_macro_resolutions.borrow_mut()\n+            .push((path[0], kind, parent_expansion, parent_legacy_scope, result.ok()));\n \n         if let Ok(Def::NonMacroAttr(NonMacroAttrKind::Custom)) = result {} else {\n             return result;\n@@ -541,10 +550,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         &mut self,\n         mut ident: Ident,\n         ns: Namespace,\n-        invoc_id: Mark,\n+        kind: Option<MacroKind>,\n+        parent_expansion: Mark,\n         record_used: bool,\n         force: bool,\n-        is_attr: bool,\n         path_span: Span,\n     ) -> Result<(&'a NameBinding<'a>, FromPrelude), Determinacy> {\n         // General principles:\n@@ -620,19 +629,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 }\n                 WhereToResolve::MacroUsePrelude => {\n                     match self.macro_use_prelude.get(&ident.name).cloned() {\n-                        Some(binding) => {\n-                            let mut result = Ok((binding, FromPrelude(true)));\n-                            // FIXME: Keep some built-in macros working even if they are\n-                            // shadowed by non-attribute macros imported with `macro_use`.\n-                            // We need to come up with some more principled approach instead.\n-                            if is_attr && (ident.name == \"test\" || ident.name == \"bench\") {\n-                                if let Def::Macro(_, MacroKind::Bang) =\n-                                        binding.def_ignoring_ambiguity() {\n-                                    result = Err(Determinacy::Determined);\n-                                }\n-                            }\n-                            result\n-                        }\n+                        Some(binding) => Ok((binding, FromPrelude(true))),\n                         None => Err(Determinacy::Determined),\n                     }\n                 }\n@@ -646,7 +643,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     // FIXME: Only built-in attributes are not considered as candidates for\n                     // non-attributes to fight off regressions on stable channel (#53205).\n                     // We need to come up with some more principled approach instead.\n-                    if is_attr && is_builtin_attr_name(ident.name) {\n+                    if kind == Some(MacroKind::Attr) && is_builtin_attr_name(ident.name) {\n                         let binding = (Def::NonMacroAttr(NonMacroAttrKind::Builtin),\n                                        ty::Visibility::Public, ident.span, Mark::root())\n                                        .to_name_binding(self.arenas);\n@@ -746,6 +743,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n             match result {\n                 Ok(result) => {\n+                    if macro_kind_mismatch(ident.name, kind, result.0.macro_kind()) {\n+                        continue_search!();\n+                    }\n+\n                     if !record_used {\n                         return Ok(result);\n                     }\n@@ -754,7 +755,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         // Found another solution, if the first one was \"weak\", report an error.\n                         if result.0.def() != innermost_result.0.def() &&\n                            (innermost_result.0.is_glob_import() ||\n-                            innermost_result.0.may_appear_after(invoc_id, result.0)) {\n+                            innermost_result.0.may_appear_after(parent_expansion, result.0)) {\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 ident,\n                                 b1: innermost_result.0,\n@@ -782,9 +783,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         let determinacy = Determinacy::determined(force);\n-        if determinacy == Determinacy::Determined && is_attr {\n+        if determinacy == Determinacy::Determined && kind == Some(MacroKind::Attr) {\n             // For single-segment attributes interpret determinate \"no resolution\" as a custom\n-            // attribute. (Lexical resolution implies the first segment and is_attr should imply\n+            // attribute. (Lexical resolution implies the first segment and attr kind should imply\n             // the last segment, so we are certainly working with a single-segment attribute here.)\n             assert!(ns == MacroNS);\n             let binding = (Def::NonMacroAttr(NonMacroAttrKind::Custom),\n@@ -798,15 +799,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n     fn resolve_legacy_scope(&mut self,\n                             ident: Ident,\n-                            invoc_id: Mark,\n-                            invoc_parent_legacy_scope: LegacyScope<'a>,\n-                            record_used: bool,\n-                            is_attr: bool)\n+                            kind: Option<MacroKind>,\n+                            parent_expansion: Mark,\n+                            parent_legacy_scope: LegacyScope<'a>,\n+                            record_used: bool)\n                             -> Option<&'a NameBinding<'a>> {\n-        if is_attr && (ident.name == \"test\" || ident.name == \"bench\") {\n-            // FIXME: Keep some built-in macros working even if they are\n-            // shadowed by user-defined `macro_rules`.\n-            // We need to come up with some more principled approach instead.\n+        if macro_kind_mismatch(ident.name, kind, Some(MacroKind::Bang)) {\n             return None;\n         }\n \n@@ -826,7 +824,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let mut innermost_result: Option<&NameBinding> = None;\n \n         // Go through all the scopes and try to resolve the name.\n-        let mut where_to_resolve = invoc_parent_legacy_scope;\n+        let mut where_to_resolve = parent_legacy_scope;\n         loop {\n             let result = match where_to_resolve {\n                 LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident =>\n@@ -854,7 +852,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     if let Some(innermost_result) = innermost_result {\n                         // Found another solution, if the first one was \"weak\", report an error.\n                         if result.def() != innermost_result.def() &&\n-                           innermost_result.may_appear_after(invoc_id, result) {\n+                           innermost_result.may_appear_after(parent_expansion, result) {\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 ident,\n                                 b1: innermost_result,\n@@ -891,14 +889,14 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n         }\n \n-        for &(invoc_id, ident, kind, def) in module.legacy_macro_resolutions.borrow().iter() {\n+        for &(ident, kind, parent_expansion, parent_legacy_scope, def)\n+                in module.legacy_macro_resolutions.borrow().iter() {\n             let span = ident.span;\n-            let invocation = self.invocations[&invoc_id];\n             let legacy_resolution = self.resolve_legacy_scope(\n-                ident, invoc_id, invocation.parent_legacy_scope.get(), true, kind == MacroKind::Attr\n+                ident, Some(kind), parent_expansion, parent_legacy_scope, true\n             );\n             let resolution = self.resolve_lexical_macro_path_segment(\n-                ident, MacroNS, invoc_id, true, true, kind == MacroKind::Attr, span\n+                ident, MacroNS, Some(kind), parent_expansion, true, true, span\n             );\n \n             let check_consistency = |this: &Self, new_def: Def| {\n@@ -932,12 +930,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     err.emit();\n                 },\n                 (Some(legacy_binding), Ok((binding, FromPrelude(from_prelude))))\n-                        if !from_prelude || legacy_binding.may_appear_after(invoc_id, binding) => {\n-                    if legacy_binding.def_ignoring_ambiguity() != binding.def_ignoring_ambiguity() {\n-                        self.report_ambiguity_error(ident, legacy_binding, binding);\n-                    }\n+                        if legacy_binding.def() != binding.def_ignoring_ambiguity() &&\n+                           (!from_prelude ||\n+                            legacy_binding.may_appear_after(parent_expansion, binding)) => {\n+                    self.report_ambiguity_error(ident, legacy_binding, binding);\n                 },\n                 // OK, non-macro-expanded legacy wins over prelude even if defs are different\n+                // Also, legacy and modern can co-exist if their defs are same\n                 (Some(legacy_binding), Ok(_)) |\n                 // OK, unambiguous resolution\n                 (Some(legacy_binding), Err(_)) => {\n@@ -953,6 +952,26 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 }\n             };\n         }\n+\n+        for &(ident, parent_expansion, parent_legacy_scope)\n+                in module.builtin_attrs.borrow().iter() {\n+            let resolve_legacy = |this: &mut Self| this.resolve_legacy_scope(\n+                ident, Some(MacroKind::Attr), parent_expansion, parent_legacy_scope, true\n+            );\n+            let resolve_modern = |this: &mut Self| this.resolve_lexical_macro_path_segment(\n+                ident, MacroNS, Some(MacroKind::Attr), parent_expansion, true, true, ident.span\n+            ).map(|(binding, _)| binding).ok();\n+\n+            if let Some(binding) = resolve_legacy(self).or_else(|| resolve_modern(self)) {\n+                if binding.def_ignoring_ambiguity() !=\n+                        Def::NonMacroAttr(NonMacroAttrKind::Builtin) {\n+                    let builtin_binding = (Def::NonMacroAttr(NonMacroAttrKind::Builtin),\n+                                           ty::Visibility::Public, ident.span, Mark::root())\n+                                           .to_name_binding(self.arenas);\n+                    self.report_ambiguity_error(ident, binding, builtin_binding);\n+                }\n+            }\n+        }\n     }\n \n     fn suggest_macro_name(&mut self, name: &str, kind: MacroKind,\n@@ -1064,6 +1083,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 self.define(module, ident, MacroNS,\n                             (def, vis, item.span, expansion, IsMacroExport));\n             } else {\n+                if !attr::contains_name(&item.attrs, \"rustc_doc_only_macro\") {\n+                    self.check_reserved_macro_name(ident, MacroNS);\n+                }\n                 self.unused_macros.insert(def_id);\n             }\n         } else {"}, {"sha": "dfbea0ffe2288e370e1589f4aca0a641b72ad110", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=58063894d21c76ab5bc32bda30eee66703e0fdfb", "patch": "@@ -452,13 +452,24 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         })\n     }\n \n+    crate fn check_reserved_macro_name(&self, ident: Ident, ns: Namespace) {\n+        // Reserve some names that are not quite covered by the general check\n+        // performed on `Resolver::builtin_attrs`.\n+        if ns == MacroNS &&\n+           (ident.name == \"cfg\" || ident.name == \"cfg_attr\" || ident.name == \"derive\") {\n+            self.session.span_err(ident.span,\n+                                  &format!(\"name `{}` is reserved in macro namespace\", ident));\n+        }\n+    }\n+\n     // Define the name or return the existing binding if there is a collision.\n     pub fn try_define(&mut self,\n                       module: Module<'a>,\n                       ident: Ident,\n                       ns: Namespace,\n                       binding: &'a NameBinding<'a>)\n                       -> Result<(), &'a NameBinding<'a>> {\n+        self.check_reserved_macro_name(ident, ns);\n         self.update_resolution(module, ident, ns, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n                 if binding.is_glob_import() {"}, {"sha": "07c3e578e5b04c88ae28d08574c60b88a47998a0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=58063894d21c76ab5bc32bda30eee66703e0fdfb", "patch": "@@ -727,10 +727,9 @@ pub trait Resolver {\n     fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<Attribute>, allow_derive: bool)\n                               -> Option<Attribute>;\n \n-    fn resolve_macro_invocation(&mut self, invoc: &Invocation, scope: Mark, force: bool)\n+    fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: Mark, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Determinacy>;\n-\n-    fn resolve_macro_path(&mut self, path: &ast::Path, kind: MacroKind, scope: Mark,\n+    fn resolve_macro_path(&mut self, path: &ast::Path, kind: MacroKind, invoc_id: Mark,\n                           derives_in_scope: &[ast::Path], force: bool)\n                           -> Result<Lrc<SyntaxExtension>, Determinacy>;\n \n@@ -764,11 +763,11 @@ impl Resolver for DummyResolver {\n     fn resolve_imports(&mut self) {}\n     fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>, _allow_derive: bool)\n                               -> Option<Attribute> { None }\n-    fn resolve_macro_invocation(&mut self, _invoc: &Invocation, _scope: Mark, _force: bool)\n+    fn resolve_macro_invocation(&mut self, _invoc: &Invocation, _invoc_id: Mark, _force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n         Err(Determinacy::Determined)\n     }\n-    fn resolve_macro_path(&mut self, _path: &ast::Path, _kind: MacroKind, _scope: Mark,\n+    fn resolve_macro_path(&mut self, _path: &ast::Path, _kind: MacroKind, _invoc_id: Mark,\n                           _derives_in_scope: &[ast::Path], _force: bool)\n                           -> Result<Lrc<SyntaxExtension>, Determinacy> {\n         Err(Determinacy::Determined)"}, {"sha": "6a47e50f62dbb6bbc0872213531d539760acdf70", "filename": "src/test/ui-fulldeps/proc-macro/ambiguous-builtin-attrs-test.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs-test.rs?ref=58063894d21c76ab5bc32bda30eee66703e0fdfb", "patch": "@@ -0,0 +1,20 @@\n+// aux-build:builtin-attrs.rs\n+// compile-flags:--test\n+\n+#![feature(decl_macro, test)]\n+\n+extern crate test;\n+extern crate builtin_attrs;\n+use builtin_attrs::{test, bench};\n+\n+#[test] // OK, shadowed\n+fn test() {}\n+\n+#[bench] // OK, shadowed\n+fn bench(b: &mut test::Bencher) {}\n+\n+fn not_main() {\n+    Test;\n+    Bench;\n+    NonExistent; //~ ERROR cannot find value `NonExistent` in this scope\n+}"}, {"sha": "db07055b6a1093334f06b7d8dfb21029b46f38f7", "filename": "src/test/ui-fulldeps/proc-macro/ambiguous-builtin-attrs-test.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs-test.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs-test.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs-test.stderr?ref=58063894d21c76ab5bc32bda30eee66703e0fdfb", "patch": "@@ -0,0 +1,9 @@\n+error[E0425]: cannot find value `NonExistent` in this scope\n+  --> $DIR/ambiguous-builtin-attrs-test.rs:19:5\n+   |\n+LL |     NonExistent; //~ ERROR cannot find value `NonExistent` in this scope\n+   |     ^^^^^^^^^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "9f4f0abf32486ec3fbb1dd9943990fc2db68286b", "filename": "src/test/ui-fulldeps/proc-macro/ambiguous-builtin-attrs.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.rs?ref=58063894d21c76ab5bc32bda30eee66703e0fdfb", "patch": "@@ -0,0 +1,31 @@\n+// aux-build:builtin-attrs.rs\n+\n+#![feature(decl_macro)] //~ ERROR `feature` is ambiguous\n+\n+extern crate builtin_attrs;\n+use builtin_attrs::{test, bench};\n+use builtin_attrs::*;\n+\n+#[repr(C)] //~ ERROR `repr` is ambiguous\n+struct S;\n+#[cfg_attr(all(), repr(C))] //~ ERROR `repr` is ambiguous\n+struct SCond;\n+\n+#[test] // OK, shadowed\n+fn test() {}\n+\n+#[bench] // OK, shadowed\n+fn bench() {}\n+\n+fn non_macro_expanded_location<#[repr(C)] T>() { //~ ERROR `repr` is ambiguous\n+    match 0u8 {\n+        #[repr(C)] //~ ERROR `repr` is ambiguous\n+        _ => {}\n+    }\n+}\n+\n+fn main() {\n+    Test;\n+    Bench;\n+    NonExistent; //~ ERROR cannot find value `NonExistent` in this scope\n+}"}, {"sha": "ea867faf47bb6b7ee017076e3d93bdec466f8bb6", "filename": "src/test/ui-fulldeps/proc-macro/ambiguous-builtin-attrs.stderr", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.stderr?ref=58063894d21c76ab5bc32bda30eee66703e0fdfb", "patch": "@@ -0,0 +1,100 @@\n+error[E0659]: `repr` is ambiguous\n+  --> $DIR/ambiguous-builtin-attrs.rs:9:3\n+   |\n+LL | #[repr(C)] //~ ERROR `repr` is ambiguous\n+   |   ^^^^ ambiguous name\n+   |\n+note: `repr` could refer to the name imported here\n+  --> $DIR/ambiguous-builtin-attrs.rs:7:5\n+   |\n+LL | use builtin_attrs::*;\n+   |     ^^^^^^^^^^^^^^^^\n+note: `repr` could also refer to the name defined here\n+  --> $DIR/ambiguous-builtin-attrs.rs:9:3\n+   |\n+LL | #[repr(C)] //~ ERROR `repr` is ambiguous\n+   |   ^^^^\n+   = note: consider adding an explicit import of `repr` to disambiguate\n+\n+error[E0659]: `repr` is ambiguous\n+  --> $DIR/ambiguous-builtin-attrs.rs:11:19\n+   |\n+LL | #[cfg_attr(all(), repr(C))] //~ ERROR `repr` is ambiguous\n+   |                   ^^^^ ambiguous name\n+   |\n+note: `repr` could refer to the name imported here\n+  --> $DIR/ambiguous-builtin-attrs.rs:7:5\n+   |\n+LL | use builtin_attrs::*;\n+   |     ^^^^^^^^^^^^^^^^\n+note: `repr` could also refer to the name defined here\n+  --> $DIR/ambiguous-builtin-attrs.rs:11:19\n+   |\n+LL | #[cfg_attr(all(), repr(C))] //~ ERROR `repr` is ambiguous\n+   |                   ^^^^\n+   = note: consider adding an explicit import of `repr` to disambiguate\n+\n+error[E0659]: `repr` is ambiguous\n+  --> $DIR/ambiguous-builtin-attrs.rs:20:34\n+   |\n+LL | fn non_macro_expanded_location<#[repr(C)] T>() { //~ ERROR `repr` is ambiguous\n+   |                                  ^^^^ ambiguous name\n+   |\n+note: `repr` could refer to the name imported here\n+  --> $DIR/ambiguous-builtin-attrs.rs:7:5\n+   |\n+LL | use builtin_attrs::*;\n+   |     ^^^^^^^^^^^^^^^^\n+note: `repr` could also refer to the name defined here\n+  --> $DIR/ambiguous-builtin-attrs.rs:20:34\n+   |\n+LL | fn non_macro_expanded_location<#[repr(C)] T>() { //~ ERROR `repr` is ambiguous\n+   |                                  ^^^^\n+   = note: consider adding an explicit import of `repr` to disambiguate\n+\n+error[E0659]: `repr` is ambiguous\n+  --> $DIR/ambiguous-builtin-attrs.rs:22:11\n+   |\n+LL |         #[repr(C)] //~ ERROR `repr` is ambiguous\n+   |           ^^^^ ambiguous name\n+   |\n+note: `repr` could refer to the name imported here\n+  --> $DIR/ambiguous-builtin-attrs.rs:7:5\n+   |\n+LL | use builtin_attrs::*;\n+   |     ^^^^^^^^^^^^^^^^\n+note: `repr` could also refer to the name defined here\n+  --> $DIR/ambiguous-builtin-attrs.rs:22:11\n+   |\n+LL |         #[repr(C)] //~ ERROR `repr` is ambiguous\n+   |           ^^^^\n+   = note: consider adding an explicit import of `repr` to disambiguate\n+\n+error[E0659]: `feature` is ambiguous\n+  --> $DIR/ambiguous-builtin-attrs.rs:3:4\n+   |\n+LL | #![feature(decl_macro)] //~ ERROR `feature` is ambiguous\n+   |    ^^^^^^^ ambiguous name\n+   |\n+note: `feature` could refer to the name imported here\n+  --> $DIR/ambiguous-builtin-attrs.rs:7:5\n+   |\n+LL | use builtin_attrs::*;\n+   |     ^^^^^^^^^^^^^^^^\n+note: `feature` could also refer to the name defined here\n+  --> $DIR/ambiguous-builtin-attrs.rs:3:4\n+   |\n+LL | #![feature(decl_macro)] //~ ERROR `feature` is ambiguous\n+   |    ^^^^^^^\n+   = note: consider adding an explicit import of `feature` to disambiguate\n+\n+error[E0425]: cannot find value `NonExistent` in this scope\n+  --> $DIR/ambiguous-builtin-attrs.rs:30:5\n+   |\n+LL |     NonExistent; //~ ERROR cannot find value `NonExistent` in this scope\n+   |     ^^^^^^^^^^^ not found in this scope\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors occurred: E0425, E0659.\n+For more information about an error, try `rustc --explain E0425`."}, {"sha": "e18ca57aab1fcdf9ca223dcb7de7c59e827bbfd3", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/builtin-attrs.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fbuiltin-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fbuiltin-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fbuiltin-attrs.rs?ref=58063894d21c76ab5bc32bda30eee66703e0fdfb", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro_attribute]\n+pub fn feature(_: TokenStream, input: TokenStream) -> TokenStream {\n+    input\n+}\n+\n+#[proc_macro_attribute]\n+pub fn repr(_: TokenStream, input: TokenStream) -> TokenStream {\n+    input\n+}\n+\n+#[proc_macro_attribute]\n+pub fn test(_: TokenStream, input: TokenStream) -> TokenStream {\n+    \"struct Test;\".parse().unwrap()\n+}\n+\n+#[proc_macro_attribute]\n+pub fn bench(_: TokenStream, input: TokenStream) -> TokenStream {\n+    \"struct Bench;\".parse().unwrap()\n+}"}, {"sha": "ff5984aa67c7acdc48af3a89c7cd73ee7520bc80", "filename": "src/test/ui-fulldeps/proc-macro/reserved-macro-names.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Freserved-macro-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Freserved-macro-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Freserved-macro-names.rs?ref=58063894d21c76ab5bc32bda30eee66703e0fdfb", "patch": "@@ -0,0 +1,22 @@\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro_attribute]\n+pub fn cfg(_: TokenStream, input: TokenStream) -> TokenStream {\n+    //~^ ERROR name `cfg` is reserved in macro namespace\n+    input\n+}\n+\n+#[proc_macro_attribute]\n+pub fn cfg_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n+    //~^ ERROR name `cfg_attr` is reserved in macro namespace\n+    input\n+}\n+\n+#[proc_macro_attribute]\n+pub fn derive(_: TokenStream, input: TokenStream) -> TokenStream {\n+    //~^ ERROR name `derive` is reserved in macro namespace\n+    input\n+}"}, {"sha": "be6e80c3878e18498dfb16ee985fafe9abe5266c", "filename": "src/test/ui-fulldeps/proc-macro/reserved-macro-names.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Freserved-macro-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58063894d21c76ab5bc32bda30eee66703e0fdfb/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Freserved-macro-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Freserved-macro-names.stderr?ref=58063894d21c76ab5bc32bda30eee66703e0fdfb", "patch": "@@ -0,0 +1,20 @@\n+error: name `cfg` is reserved in macro namespace\n+  --> $DIR/reserved-macro-names.rs:7:8\n+   |\n+LL | pub fn cfg(_: TokenStream, input: TokenStream) -> TokenStream {\n+   |        ^^^\n+\n+error: name `cfg_attr` is reserved in macro namespace\n+  --> $DIR/reserved-macro-names.rs:13:8\n+   |\n+LL | pub fn cfg_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n+   |        ^^^^^^^^\n+\n+error: name `derive` is reserved in macro namespace\n+  --> $DIR/reserved-macro-names.rs:19:8\n+   |\n+LL | pub fn derive(_: TokenStream, input: TokenStream) -> TokenStream {\n+   |        ^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}]}