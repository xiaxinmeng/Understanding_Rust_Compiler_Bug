{"sha": "a13cecacb4f3ffd6faae2080046078ff53748815", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExM2NlY2FjYjRmM2ZmZDZmYWFlMjA4MDA0NjA3OGZmNTM3NDg4MTU=", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2017-01-08T02:24:40Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2017-01-12T22:53:02Z"}, "message": "Require compile-fail tests for new lang features\n\nIts non trivial to test lang feature gates, and people\nforget to add such tests. So we extend the features lint\nof the tidy tool to ensure that all new lang features\ncontain a new compile-fail test.\n\nOf course, one could drop this requirement and just\ngrep all tests in run-pass for #![feature(abc)] and\nthen run this test again, removing the mention,\nrequiring that it fails.\n\nBut this only tests for the existence of a compilation\nfailure. Manual tests ensure that also the correct lines\nspawn the error, and also test the actual error message.\n\nFor library features, it makes no sense to require such\na test, as here code is used that is generic for all\nlibrary features.", "tree": {"sha": "014d5b93c63cd4dc58ca32863c8e0bf642b439bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/014d5b93c63cd4dc58ca32863c8e0bf642b439bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a13cecacb4f3ffd6faae2080046078ff53748815", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a13cecacb4f3ffd6faae2080046078ff53748815", "html_url": "https://github.com/rust-lang/rust/commit/a13cecacb4f3ffd6faae2080046078ff53748815", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a13cecacb4f3ffd6faae2080046078ff53748815/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8b6d3cc9ebec76b63a2f4d6b54d8eae58f07c5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8b6d3cc9ebec76b63a2f4d6b54d8eae58f07c5f", "html_url": "https://github.com/rust-lang/rust/commit/e8b6d3cc9ebec76b63a2f4d6b54d8eae58f07c5f"}], "stats": {"total": 72, "additions": 71, "deletions": 1}, "files": [{"sha": "290a1d9facb302396652c4c833f1f6d873251f91", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 71, "deletions": 1, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a13cecacb4f3ffd6faae2080046078ff53748815/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a13cecacb4f3ffd6faae2080046078ff53748815/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=a13cecacb4f3ffd6faae2080046078ff53748815", "patch": "@@ -16,6 +16,7 @@\n //! * The set of library features is disjoint from the set of language features\n //! * Library features have at most one stability level\n //! * Library features have at most one `since` value\n+//! * All stability attributes have tests to ensure they are actually stable/unstable\n \n use std::collections::HashMap;\n use std::fmt;\n@@ -42,10 +43,11 @@ impl fmt::Display for Status {\n struct Feature {\n     level: Status,\n     since: String,\n+    has_gate_test: bool,\n }\n \n pub fn check(path: &Path, bad: &mut bool) {\n-    let features = collect_lang_features(&path.join(\"libsyntax/feature_gate.rs\"));\n+    let mut features = collect_lang_features(&path.join(\"libsyntax/feature_gate.rs\"));\n     assert!(!features.is_empty());\n     let mut lib_features = HashMap::<String, Feature>::new();\n \n@@ -106,10 +108,77 @@ pub fn check(path: &Path, bad: &mut bool) {\n                                 Feature {\n                                     level: level,\n                                     since: since.to_owned(),\n+                                    has_gate_test: false,\n                                 });\n         }\n     });\n \n+    super::walk(&path.join(\"test/compile-fail\"),\n+                &mut |path| super::filter_dirs(path),\n+                &mut |file| {\n+        let filename = file.file_name().unwrap().to_string_lossy();\n+        if !filename.ends_with(\".rs\") || filename == \"features.rs\" ||\n+           filename == \"diagnostic_list.rs\" {\n+            return;\n+        }\n+\n+        contents.truncate(0);\n+        t!(t!(File::open(&file), &file).read_to_string(&mut contents));\n+\n+        for (i, line) in contents.lines().enumerate() {\n+            let mut err = |msg: &str| {\n+                println!(\"{}:{}: {}\", file.display(), i + 1, msg);\n+                *bad = true;\n+            };\n+\n+            let gate_test_str = \"gate-test-\";\n+\n+            if !line.contains(gate_test_str) {\n+                continue;\n+            }\n+\n+            let feature_name = match line.find(gate_test_str) {\n+                Some(i) => {\n+                    &line[i+gate_test_str.len()..line[i+1..].find(' ').unwrap_or(line.len())]\n+                },\n+                None => continue,\n+            };\n+            let found_feature = features.get_mut(feature_name)\n+                                        .map(|v| { v.has_gate_test = true; () })\n+                                        .is_some();\n+\n+            let found_lib_feature = features.get_mut(feature_name)\n+                                            .map(|v| { v.has_gate_test = true; () })\n+                                            .is_some();\n+\n+            if !(found_feature || found_lib_feature) {\n+                err(&format!(\"gate-test test found referencing a nonexistent feature '{}'\",\n+                             feature_name));\n+            }\n+        }\n+    });\n+\n+    // Only check the number of lang features.\n+    // Obligatory testing for library features is dumb.\n+    let gate_untested = features.iter()\n+                                .filter(|&(_, f)| f.level == Status::Unstable)\n+                                .filter(|&(_, f)| !f.has_gate_test)\n+                                .count();\n+\n+    // FIXME get this number down to zero.\n+    let gate_untested_expected = 98;\n+\n+    if gate_untested != gate_untested_expected {\n+        print!(\"Expected {} gate untested features, but found {}. \",\n+                gate_untested_expected, gate_untested);\n+        if gate_untested < gate_untested_expected {\n+            println!(\"Did you forget to reduce the expected number?\");\n+        } else {\n+            println!(\"Did you forget to add a gate test for your new feature?\");\n+        }\n+        *bad = true;\n+    }\n+\n     if *bad {\n         return;\n     }\n@@ -162,6 +231,7 @@ fn collect_lang_features(path: &Path) -> HashMap<String, Feature> {\n                 Feature {\n                     level: level,\n                     since: since.to_owned(),\n+                    has_gate_test: false,\n                 }))\n         })\n         .collect()"}]}