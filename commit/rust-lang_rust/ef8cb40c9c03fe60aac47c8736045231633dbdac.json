{"sha": "ef8cb40c9c03fe60aac47c8736045231633dbdac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmOGNiNDBjOWMwM2ZlNjBhYWM0N2M4NzM2MDQ1MjMxNjMzZGJkYWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-12T15:23:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-12T15:23:28Z"}, "message": "Auto merge of #51519 - ExpHP:issue-51331-b, r=petrochenkov\n\nFix for $crate var normalization in proc macro for externally defined macros\n\nFixes #51331, a bug that has existed in at least *some* form for a year and a half.\n\nThe PR includes the addition of a `fold_qpath` method to `syntax::fold::Folder`.  Overriding this method is useful for folds that modify paths in a way that invalidates indices (insertion or removal of a component), as it provides the opportunity to update `qself.position` in `<A as B>::C` paths.  I added it because the bugfix is messy without it.\n\n(unfortunately, grepping around the codebase, I did not see anything else that could use it.)", "tree": {"sha": "372aa750a7d6b5351c8824c762ac7b68b8640825", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/372aa750a7d6b5351c8824c762ac7b68b8640825"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef8cb40c9c03fe60aac47c8736045231633dbdac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef8cb40c9c03fe60aac47c8736045231633dbdac", "html_url": "https://github.com/rust-lang/rust/commit/ef8cb40c9c03fe60aac47c8736045231633dbdac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef8cb40c9c03fe60aac47c8736045231633dbdac/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f3ba6c3cb1707eaf63640fc6681ae389253fe18", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f3ba6c3cb1707eaf63640fc6681ae389253fe18", "html_url": "https://github.com/rust-lang/rust/commit/3f3ba6c3cb1707eaf63640fc6681ae389253fe18"}, {"sha": "d13bfd294c55a47bb33e5846ce184c80cdf547dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d13bfd294c55a47bb33e5846ce184c80cdf547dd", "html_url": "https://github.com/rust-lang/rust/commit/d13bfd294c55a47bb33e5846ce184c80cdf547dd"}], "stats": {"total": 179, "additions": 147, "deletions": 32}, "files": [{"sha": "de7a3dc5ceeb273f061bab2c5338a777a300b024", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ef8cb40c9c03fe60aac47c8736045231633dbdac/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef8cb40c9c03fe60aac47c8736045231633dbdac/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=ef8cb40c9c03fe60aac47c8736045231633dbdac", "patch": "@@ -138,7 +138,23 @@ impl<'a> base::Resolver for Resolver<'a> {\n         struct EliminateCrateVar<'b, 'a: 'b>(&'b mut Resolver<'a>, Span);\n \n         impl<'a, 'b> Folder for EliminateCrateVar<'a, 'b> {\n-            fn fold_path(&mut self, mut path: ast::Path) -> ast::Path {\n+            fn fold_path(&mut self, path: ast::Path) -> ast::Path {\n+                match self.fold_qpath(None, path) {\n+                    (None, path) => path,\n+                    _ => unreachable!(),\n+                }\n+            }\n+\n+            fn fold_qpath(&mut self, mut qself: Option<ast::QSelf>, mut path: ast::Path)\n+                          -> (Option<ast::QSelf>, ast::Path) {\n+                qself = qself.map(|ast::QSelf { ty, path_span, position }| {\n+                    ast::QSelf {\n+                        ty: self.fold_ty(ty),\n+                        path_span: self.new_span(path_span),\n+                        position,\n+                    }\n+                });\n+\n                 let ident = path.segments[0].ident;\n                 if ident.name == keywords::DollarCrate.name() {\n                     path.segments[0].ident.name = keywords::CrateRoot.name();\n@@ -150,10 +166,13 @@ impl<'a> base::Resolver for Resolver<'a> {\n                                 ast::Ident::with_empty_ctxt(name).with_span_pos(span)\n                             ),\n                             _ => unreachable!(),\n-                        })\n+                        });\n+                        if let Some(qself) = &mut qself {\n+                            qself.position += 1;\n+                        }\n                     }\n                 }\n-                path\n+                (qself, path)\n             }\n \n             fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {"}, {"sha": "1056b3dad173958ff4633c13f91fb8df49eb022a", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ef8cb40c9c03fe60aac47c8736045231633dbdac/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef8cb40c9c03fe60aac47c8736045231633dbdac/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=ef8cb40c9c03fe60aac47c8736045231633dbdac", "patch": "@@ -168,6 +168,10 @@ pub trait Folder : Sized {\n         noop_fold_path(p, self)\n     }\n \n+    fn fold_qpath(&mut self, qs: Option<QSelf>, p: Path) -> (Option<QSelf>, Path) {\n+        noop_fold_qpath(qs, p, self)\n+    }\n+\n     fn fold_path_parameters(&mut self, p: PathParameters) -> PathParameters {\n         noop_fold_path_parameters(p, self)\n     }\n@@ -370,14 +374,8 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n             TyKind::Tup(tys) => TyKind::Tup(tys.move_map(|ty| fld.fold_ty(ty))),\n             TyKind::Paren(ty) => TyKind::Paren(fld.fold_ty(ty)),\n             TyKind::Path(qself, path) => {\n-                let qself = qself.map(|QSelf { ty, path_span, position }| {\n-                    QSelf {\n-                        ty: fld.fold_ty(ty),\n-                        path_span: fld.new_span(path_span),\n-                        position,\n-                    }\n-                });\n-                TyKind::Path(qself, fld.fold_path(path))\n+                let (qself, path) = fld.fold_qpath(qself, path);\n+                TyKind::Path(qself, path)\n             }\n             TyKind::Array(ty, length) => {\n                 TyKind::Array(fld.fold_ty(ty), fld.fold_anon_const(length))\n@@ -442,6 +440,19 @@ pub fn noop_fold_path<T: Folder>(Path { segments, span }: Path, fld: &mut T) ->\n     }\n }\n \n+pub fn noop_fold_qpath<T: Folder>(qself: Option<QSelf>,\n+                                  path: Path,\n+                                  fld: &mut T) -> (Option<QSelf>, Path) {\n+    let qself = qself.map(|QSelf { ty, path_span, position }| {\n+        QSelf {\n+            ty: fld.fold_ty(ty),\n+            path_span: fld.new_span(path_span),\n+            position,\n+        }\n+    });\n+    (qself, fld.fold_path(path))\n+}\n+\n pub fn noop_fold_path_parameters<T: Folder>(path_parameters: PathParameters, fld: &mut T)\n                                             -> PathParameters\n {\n@@ -1097,15 +1108,9 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                 PatKind::TupleStruct(folder.fold_path(pth),\n                         pats.move_map(|x| folder.fold_pat(x)), ddpos)\n             }\n-            PatKind::Path(opt_qself, pth) => {\n-                let opt_qself = opt_qself.map(|qself| {\n-                    QSelf {\n-                        ty: folder.fold_ty(qself.ty),\n-                        path_span: folder.new_span(qself.path_span),\n-                        position: qself.position,\n-                    }\n-                });\n-                PatKind::Path(opt_qself, folder.fold_path(pth))\n+            PatKind::Path(qself, pth) => {\n+                let (qself, pth) = folder.fold_qpath(qself, pth);\n+                PatKind::Path(qself, pth)\n             }\n             PatKind::Struct(pth, fields, etc) => {\n                 let pth = folder.fold_path(pth);\n@@ -1267,14 +1272,8 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                                 lim)\n             }\n             ExprKind::Path(qself, path) => {\n-                let qself = qself.map(|QSelf { ty, path_span, position }| {\n-                    QSelf {\n-                        ty: folder.fold_ty(ty),\n-                        path_span: folder.new_span(path_span),\n-                        position,\n-                    }\n-                });\n-                ExprKind::Path(qself, folder.fold_path(path))\n+                let (qself, path) = folder.fold_qpath(qself, path);\n+                ExprKind::Path(qself, path)\n             }\n             ExprKind::Break(opt_label, opt_expr) => {\n                 ExprKind::Break(opt_label.map(|label| folder.fold_label(label)),"}, {"sha": "a6c9817f24714ad30d066ef0f6caa0c2909e3f53", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/double.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef8cb40c9c03fe60aac47c8736045231633dbdac/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fdouble.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef8cb40c9c03fe60aac47c8736045231633dbdac/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fdouble.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fdouble.rs?ref=ef8cb40c9c03fe60aac47c8736045231633dbdac", "patch": "@@ -16,6 +16,8 @@ extern crate proc_macro;\n \n use proc_macro::TokenStream;\n \n+// Outputs another copy of the struct.  Useful for testing the tokens\n+// seen by the proc_macro.\n #[proc_macro_derive(Double)]\n pub fn derive(input: TokenStream) -> TokenStream {\n     format!(\"mod foo {{ {} }}\", input.to_string()).parse().unwrap()"}, {"sha": "030c53b3e6f320bf5ab8542192bbb0c71a067159", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/external-crate-var.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ef8cb40c9c03fe60aac47c8736045231633dbdac/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fexternal-crate-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef8cb40c9c03fe60aac47c8736045231633dbdac/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fexternal-crate-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fexternal-crate-var.rs?ref=ef8cb40c9c03fe60aac47c8736045231633dbdac", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct ExternFoo;\n+\n+pub trait ExternTrait {\n+    const CONST: u32;\n+    type Assoc;\n+}\n+\n+impl ExternTrait for ExternFoo {\n+    const CONST: u32 = 0;\n+    type Assoc = ExternFoo;\n+}\n+\n+#[macro_export]\n+macro_rules! external { () => {\n+    mod bar {\n+        #[derive(Double)]\n+        struct Bar($crate::ExternFoo);\n+    }\n+\n+    mod qself {\n+        #[derive(Double)]\n+        struct QSelf(<$crate::ExternFoo as $crate::ExternTrait>::Assoc);\n+    }\n+\n+    mod qself_recurse {\n+        #[derive(Double)]\n+        struct QSelfRecurse(<\n+            <$crate::ExternFoo as $crate::ExternTrait>::Assoc\n+            as $crate::ExternTrait>::Assoc\n+        );\n+    }\n+\n+    mod qself_in_const {\n+        #[derive(Double)]\n+        #[repr(u32)]\n+        enum QSelfInConst {\n+            Variant = <$crate::ExternFoo as $crate::ExternTrait>::CONST,\n+        }\n+    }\n+} }\n+"}, {"sha": "41c15195bc8402e5e667b734fee17806db2abc29", "filename": "src/test/run-pass-fulldeps/proc-macro/crate-var.rs", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ef8cb40c9c03fe60aac47c8736045231633dbdac/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fcrate-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef8cb40c9c03fe60aac47c8736045231633dbdac/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fcrate-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fcrate-var.rs?ref=ef8cb40c9c03fe60aac47c8736045231633dbdac", "patch": "@@ -9,19 +9,63 @@\n // except according to those terms.\n \n // aux-build:double.rs\n+// aux-build:external-crate-var.rs\n // ignore-stage1\n \n #![allow(unused)]\n \n #[macro_use]\n extern crate double;\n+#[macro_use]\n+extern crate external_crate_var;\n \n struct Foo;\n \n-macro_rules! m { () => {\n-    #[derive(Double)]\n-    struct Bar($crate::Foo);\n+trait Trait {\n+    const CONST: u32;\n+    type Assoc;\n+}\n+\n+impl Trait for Foo {\n+    const CONST: u32 = 0;\n+    type Assoc = Foo;\n+}\n+\n+macro_rules! local { () => {\n+    // derive_Double outputs secondary copies of each definition\n+    // to test what the proc_macro sees.\n+    mod bar {\n+        #[derive(Double)]\n+        struct Bar($crate::Foo);\n+    }\n+\n+    mod qself {\n+        #[derive(Double)]\n+        struct QSelf(<::Foo as $crate::Trait>::Assoc);\n+    }\n+\n+    mod qself_recurse {\n+        #[derive(Double)]\n+        struct QSelfRecurse(<<$crate::Foo as $crate::Trait>::Assoc as $crate::Trait>::Assoc);\n+    }\n+\n+    mod qself_in_const {\n+        #[derive(Double)]\n+        #[repr(u32)]\n+        enum QSelfInConst {\n+            Variant = <::Foo as $crate::Trait>::CONST,\n+        }\n+    }\n } }\n-m!();\n+\n+mod local {\n+    local!();\n+}\n+\n+// and now repeat the above tests, using a macro defined in another crate\n+\n+mod external {\n+    external!{}\n+}\n \n fn main() {}"}]}