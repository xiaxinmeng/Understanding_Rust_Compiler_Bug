{"sha": "7d68250eb49e455ce84e762f2324510da288be45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkNjgyNTBlYjQ5ZTQ1NWNlODRlNzYyZjIzMjQ1MTBkYTI4OGJlNDU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-11T20:21:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-28T10:15:24Z"}, "message": "When pretty-printing object types, include the output associated type", "tree": {"sha": "657477556ed3b3ac1ecd03a361239b280de868c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/657477556ed3b3ac1ecd03a361239b280de868c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d68250eb49e455ce84e762f2324510da288be45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d68250eb49e455ce84e762f2324510da288be45", "html_url": "https://github.com/rust-lang/rust/commit/7d68250eb49e455ce84e762f2324510da288be45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d68250eb49e455ce84e762f2324510da288be45/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "006f3eacae03adb1546e7ea04d92fe90d52fa509", "url": "https://api.github.com/repos/rust-lang/rust/commits/006f3eacae03adb1546e7ea04d92fe90d52fa509", "html_url": "https://github.com/rust-lang/rust/commit/006f3eacae03adb1546e7ea04d92fe90d52fa509"}], "stats": {"total": 142, "additions": 97, "deletions": 45}, "files": [{"sha": "1be99a8e569f3f55bb8b536b19b790c0998eee01", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 97, "deletions": 45, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/7d68250eb49e455ce84e762f2324510da288be45/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d68250eb49e455ce84e762f2324510da288be45/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=7d68250eb49e455ce84e762f2324510da288be45", "patch": "@@ -298,17 +298,9 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n \n     fn closure_to_string<'tcx>(cx: &ctxt<'tcx>, cty: &ty::ClosureTy<'tcx>) -> String {\n         let mut s = String::new();\n-\n-        match cty.unsafety {\n-            ast::Unsafety::Normal => {}\n-            ast::Unsafety::Unsafe => {\n-                s.push_str(cty.unsafety.to_string().as_slice());\n-                s.push(' ');\n-            }\n-        };\n-\n-        push_sig_to_string(cx, &mut s, '|', '|', &cty.sig);\n-\n+        s.push_str(\"[closure\");\n+        push_sig_to_string(cx, &mut s, '(', ')', &cty.sig);\n+        s.push(']');\n         s\n     }\n \n@@ -399,18 +391,10 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         ty_enum(did, substs) | ty_struct(did, substs) => {\n             let base = ty::item_path_str(cx, did);\n             let generics = ty::lookup_item_type(cx, did).generics;\n-            parameterized(cx, base.as_slice(), substs, &generics, did)\n+            parameterized(cx, base.as_slice(), substs, &generics, did, &[])\n         }\n-        ty_trait(box ty::TyTrait {\n-            ref principal, ref bounds\n-        }) => {\n-            let principal = principal.user_string(cx);\n-            let bound_str = bounds.user_string(cx);\n-            let bound_sep = if bound_str.is_empty() { \"\" } else { \" + \" };\n-            format!(\"{}{}{}\",\n-                    principal,\n-                    bound_sep,\n-                    bound_str)\n+        ty_trait(ref data) => {\n+            data.user_string(cx)\n         }\n         ty::ty_projection(ref data) => {\n             format!(\"<{} as {}>::{}\",\n@@ -420,14 +404,15 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         }\n         ty_str => \"str\".to_string(),\n         ty_closure(ref did, _, substs) => {\n-            cx.closures.borrow().get(did).map(|cl| {\n+            let closures = cx.closures.borrow();\n+            closures.get(did).map(|cl| {\n                 closure_to_string(cx, &cl.closure_type.subst(cx, substs))\n             }).unwrap_or_else(|| {\n                 if did.krate == ast::LOCAL_CRATE {\n                     let span = cx.map.span(did.node);\n-                    format!(\"closure[{}]\", span.repr(cx))\n+                    format!(\"[closure {}]\", span.repr(cx))\n                 } else {\n-                    format!(\"closure\")\n+                    format!(\"[closure]\")\n                 }\n             })\n         }\n@@ -458,7 +443,8 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n                            base: &str,\n                            substs: &subst::Substs<'tcx>,\n                            generics: &ty::Generics<'tcx>,\n-                           did: ast::DefId)\n+                           did: ast::DefId,\n+                           projections: &[ty::ProjectionPredicate<'tcx>])\n                            -> String\n {\n     if cx.sess.verbose() {\n@@ -511,16 +497,30 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n         strs.push(ty_to_string(cx, *t))\n     }\n \n-    if cx.lang_items.fn_trait_kind(did).is_some() {\n-        format!(\"{}({})\", // TODO\n+    for projection in projections.iter() {\n+        strs.push(format!(\"{}={}\",\n+                          projection.projection_ty.item_name.user_string(cx),\n+                          projection.ty.user_string(cx)));\n+    }\n+\n+    if cx.lang_items.fn_trait_kind(did).is_some() && projections.len() == 1 {\n+        let projection_ty = projections[0].ty;\n+        let tail =\n+            if ty::type_is_nil(projection_ty) {\n+                format!(\"\")\n+            } else {\n+                format!(\" -> {}\", projection_ty.user_string(cx))\n+            };\n+        format!(\"{}({}){}\",\n                 base,\n                 if strs[0].starts_with(\"(\") && strs[0].ends_with(\",)\") {\n                     &strs[0][1 .. strs[0].len() - 2] // Remove '(' and ',)'\n                 } else if strs[0].starts_with(\"(\") && strs[0].ends_with(\")\") {\n                     &strs[0][1 .. strs[0].len() - 1] // Remove '(' and ')'\n                 } else {\n                     &strs[0][]\n-                })\n+                },\n+                tail)\n     } else if strs.len() > 0 {\n         format!(\"{}<{}>\", base, strs.connect(\", \"))\n     } else {\n@@ -622,6 +622,65 @@ impl<'tcx> Repr<'tcx> for def::Def {\n     }\n }\n \n+/// This curious type is here to help pretty-print trait objects. In\n+/// a trait object, the projections are stored separately from the\n+/// main trait bound, but in fact we want to package them together\n+/// when printing out; they also have separate binders, but we want\n+/// them to share a binder when we print them out. (And the binder\n+/// pretty-printing logic is kind of clever and we don't want to\n+/// reproduce it.) So we just repackage up the structure somewhat.\n+///\n+/// Right now there is only one trait in an object that can have\n+/// projection bounds, so we just stuff them altogether. But in\n+/// reality we should eventually sort things out better.\n+type TraitAndProjections<'tcx> =\n+    (Rc<ty::TraitRef<'tcx>>, Vec<ty::ProjectionPredicate<'tcx>>);\n+\n+impl<'tcx> UserString<'tcx> for TraitAndProjections<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+        let &(ref trait_ref, ref projection_bounds) = self;\n+        let base = ty::item_path_str(tcx, trait_ref.def_id);\n+        let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id);\n+        parameterized(tcx,\n+                      base.as_slice(),\n+                      trait_ref.substs,\n+                      &trait_def.generics,\n+                      trait_ref.def_id,\n+                      &projection_bounds[])\n+    }\n+}\n+\n+impl<'tcx> UserString<'tcx> for ty::TyTrait<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+        let &ty::TyTrait { ref principal, ref bounds } = self;\n+\n+        let mut components = vec![];\n+\n+        let tap: ty::Binder<TraitAndProjections<'tcx>> =\n+            ty::Binder((principal.0.clone(),\n+                        bounds.projection_bounds.iter().map(|x| x.0.clone()).collect()));\n+\n+        // Generate the main trait ref, including associated types.\n+        components.push(tap.user_string(tcx));\n+\n+        // Builtin bounds.\n+        for bound in bounds.builtin_bounds.iter() {\n+            components.push(bound.user_string(tcx));\n+        }\n+\n+        // Region, if not obviously implied by builtin bounds.\n+        if bounds.region_bound != ty::ReStatic ||\n+            !bounds.builtin_bounds.contains(&ty::BoundSend)\n+        { // Region bound is implied by builtin bounds:\n+            components.push(bounds.region_bound.user_string(tcx));\n+        }\n+\n+        components.retain(|s| !s.is_empty());\n+\n+        components.connect(\" + \")\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for ty::TypeParameterDef<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"TypeParameterDef({:?}, {}, {:?}/{})\",\n@@ -700,12 +759,6 @@ impl<'tcx> Repr<'tcx> for ty::BuiltinBounds {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ExistentialBounds<'tcx> {\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        self.user_string(tcx)\n-    }\n-}\n-\n impl<'tcx> Repr<'tcx> for ty::ParamBounds<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         let mut res = Vec::new();\n@@ -726,7 +779,8 @@ impl<'tcx> Repr<'tcx> for ty::TraitRef<'tcx> {\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n         format!(\"TraitRef({}, {})\",\n                 self.substs.self_ty().repr(tcx),\n-                parameterized(tcx, base.as_slice(), self.substs, &trait_def.generics, self.def_id))\n+                parameterized(tcx, base.as_slice(), self.substs,\n+                              &trait_def.generics, self.def_id, &[]))\n     }\n }\n \n@@ -1109,14 +1163,8 @@ impl<'tcx> UserString<'tcx> for ty::ParamBounds<'tcx> {\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::ExistentialBounds<'tcx> {\n-    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n-        if self.builtin_bounds.contains(&ty::BoundSend) &&\n-            self.region_bound == ty::ReStatic\n-        { // Region bound is implied by builtin bounds:\n-            return self.builtin_bounds.repr(tcx);\n-        }\n-\n+impl<'tcx> Repr<'tcx> for ty::ExistentialBounds<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         let mut res = Vec::new();\n \n         let region_str = self.region_bound.user_string(tcx);\n@@ -1128,6 +1176,10 @@ impl<'tcx> UserString<'tcx> for ty::ExistentialBounds<'tcx> {\n             res.push(bound.user_string(tcx));\n         }\n \n+        for projection_bound in self.projection_bounds.iter() {\n+            res.push(projection_bound.user_string(tcx));\n+        }\n+\n         res.connect(\"+\")\n     }\n }\n@@ -1183,7 +1235,7 @@ impl<'tcx> UserString<'tcx> for ty::TraitRef<'tcx> {\n         let path_str = ty::item_path_str(tcx, self.def_id);\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n         parameterized(tcx, path_str.as_slice(), self.substs,\n-                      &trait_def.generics, self.def_id)\n+                      &trait_def.generics, self.def_id, &[])\n     }\n }\n "}]}