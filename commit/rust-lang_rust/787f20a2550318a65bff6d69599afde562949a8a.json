{"sha": "787f20a2550318a65bff6d69599afde562949a8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4N2YyMGEyNTUwMzE4YTY1YmZmNmQ2OTU5OWFmZGU1NjI5NDlhOGE=", "commit": {"author": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2013-09-15T19:41:02Z"}, "committer": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2013-10-05T10:09:30Z"}, "message": "Use slice representation for child crate maps", "tree": {"sha": "a5df0988a702b766166b2c8fa881f47d1d367439", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5df0988a702b766166b2c8fa881f47d1d367439"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/787f20a2550318a65bff6d69599afde562949a8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/787f20a2550318a65bff6d69599afde562949a8a", "html_url": "https://github.com/rust-lang/rust/commit/787f20a2550318a65bff6d69599afde562949a8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/787f20a2550318a65bff6d69599afde562949a8a/comments", "author": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1506dac10faf4b48f3d3debb9b20f2f55352deca", "url": "https://api.github.com/repos/rust-lang/rust/commits/1506dac10faf4b48f3d3debb9b20f2f55352deca", "html_url": "https://github.com/rust-lang/rust/commit/1506dac10faf4b48f3d3debb9b20f2f55352deca"}], "stats": {"total": 273, "additions": 152, "deletions": 121}, "files": [{"sha": "e39a7b74de0303508b0f8a89c0623ba43f7a2a0e", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/787f20a2550318a65bff6d69599afde562949a8a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787f20a2550318a65bff6d69599afde562949a8a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=787f20a2550318a65bff6d69599afde562949a8a", "patch": "@@ -2949,6 +2949,7 @@ pub fn create_module_map(ccx: &mut CrateContext) -> ValueRef {\n \n pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n                       llmod: ModuleRef) -> ValueRef {\n+    \n     let targ_cfg = sess.targ_cfg;\n     let int_type = Type::int(targ_cfg.arch);\n     let mut n_subcrates = 1;\n@@ -2959,9 +2960,10 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     } else {\n         ~\"toplevel\"\n     };\n+\n     let sym_name = ~\"_rust_crate_map_\" + mapname;\n-    let arrtype = Type::array(&int_type, n_subcrates as u64);\n-    let maptype = Type::struct_([Type::i32(), int_type, arrtype], false);\n+    let vectype = Type::struct_([int_type, int_type], false);\n+    let maptype = Type::struct_([Type::i32(), int_type, vectype], false);\n     let map = do sym_name.with_c_str |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(llmod, maptype.to_ref(), buf)\n@@ -2996,14 +2998,24 @@ pub fn fill_crate_map(ccx: &mut CrateContext, map: ValueRef) {\n         subcrates.push(p2i(ccx, cr));\n         i += 1;\n     }\n-    subcrates.push(C_int(ccx, 0));\n-\n     unsafe {\n+        let maptype = Type::array(&ccx.int_type, subcrates.len() as u64);\n+        let vec_elements = do \"_crate_map_child_vectors\".with_c_str |buf| {\n+            llvm::LLVMAddGlobal(ccx.llmod, maptype.to_ref(), buf)\n+        };\n+        lib::llvm::SetLinkage(vec_elements, lib::llvm::InternalLinkage);\n+\n+        llvm::LLVMSetInitializer(vec_elements, C_array(ccx.int_type, subcrates));\n         let mod_map = create_module_map(ccx);\n+\n         llvm::LLVMSetInitializer(map, C_struct(\n             [C_i32(1),\n              p2i(ccx, mod_map),\n-             C_array(ccx.int_type, subcrates)]));\n+             C_struct(\n+                [p2i(ccx, vec_elements),\n+                 C_int(ccx, (subcrates.len() * 8) as int)\n+             ])\n+        ]));\n     }\n }\n "}, {"sha": "e9ee0709d0132e7daa0665181cff597662967d93", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 126, "deletions": 106, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/787f20a2550318a65bff6d69599afde562949a8a/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787f20a2550318a65bff6d69599afde562949a8a/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=787f20a2550318a65bff6d69599afde562949a8a", "patch": "@@ -8,13 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use libc::c_char;\n-use ptr;\n-use ptr::RawPtr;\n-use vec;\n-use hashmap::HashSet;\n+use cast::transmute;\n use container::MutableSet;\n+use hashmap::HashSet;\n+use libc::c_char;\n \n // Need to tell the linker on OS X to not barf on undefined symbols\n // and instead look them up at runtime, which we need to resolve\n@@ -34,14 +31,15 @@ pub struct ModEntry {\n     name: *c_char,\n     log_level: *mut u32\n }\n+\n struct CrateMapV0 {\n-    entries: *ModEntry,\n-    children: [*CrateMap, ..1]\n+    entries: &static [ModEntry],\n+    children: &'static [&'static CrateMap]\n }\n \n struct CrateMap {\n     version: i32,\n-    entries: *ModEntry,\n+    entries: &static [ModEntry],\n     /// a dynamically sized struct, where all pointers to children are listed adjacent\n     /// to the struct, terminated with NULL\n     children: [*CrateMap, ..1]\n@@ -71,153 +69,175 @@ pub fn get_crate_map() -> *CrateMap {\n     sym as *CrateMap\n }\n \n-unsafe fn version(crate_map: *CrateMap) -> i32 {\n-    match (*crate_map).version {\n+fn version(crate_map: &'static CrateMap) -> i32 {\n+    match crate_map.version {\n         1 => return 1,\n         _ => return 0\n     }\n }\n \n-unsafe fn entries(crate_map: *CrateMap) -> *ModEntry {\n+#[cfg(not(stage0))]\n+fn entries(crate_map: &'static CrateMap) -> *ModEntry {\n     match version(crate_map) {\n         0 => {\n-            let v0 = crate_map as (*CrateMapV0);\n-            return (*v0).entries;\n+            unsafe {\n+                let v0: &'static CrateMapV0 = transmute(crate_map);\n+                return v0.entries;\n+            }\n         }\n         1 => return (*crate_map).entries,\n         _ => fail2!(\"Unknown crate map version!\")\n     }\n }\n \n-unsafe fn iterator(crate_map: *CrateMap) -> **CrateMap {\n+#[cfg(not(stage0))]\n+fn iterator(crate_map: &'static CrateMap) -> &'static [&'static CrateMap] {\n     match version(crate_map) {\n         0 => {\n-            let v0 = crate_map as (*CrateMapV0);\n-            return vec::raw::to_ptr((*v0).children);\n+            unsafe {\n+                let v0: &'static CrateMapV0 = transmute(crate_map);\n+                return v0.children;\n+            }\n         }\n         1 => return vec::raw::to_ptr((*crate_map).children),\n         _ => fail2!(\"Unknown crate map version!\")\n     }\n }\n \n-unsafe fn iter_module_map(mod_entries: *ModEntry, f: &fn(*mut ModEntry)) {\n+fn iter_module_map(mod_entries: *ModEntry, f: &fn(&mut ModEntry)) {\n     let mut curr = mod_entries;\n \n-    while !(*curr).name.is_null() {\n-        f(curr as *mut ModEntry);\n-        curr = curr.offset(1);\n+    unsafe {\n+        while !(*curr).name.is_null() {\n+            f(transmute(curr));\n+            curr = curr.offset(1);\n+        }\n     }\n }\n \n-unsafe fn do_iter_crate_map(crate_map: *CrateMap, f: &fn(*mut ModEntry),\n+\n+\n+#[cfg(not(stage0))]\n+fn do_iter_crate_map(crate_map: &'static CrateMap, f: &fn(&mut ModEntry),\n                             visited: &mut HashSet<*CrateMap>) {\n-    if visited.insert(crate_map) {\n-        iter_module_map(entries(crate_map), |x| f(x));\n+    if visited.insert(crate_map as *CrateMap) {\n+        iter_module_map(crate_map.entries, |x| f(x));\n         let child_crates = iterator(crate_map);\n-        do ptr::array_each(child_crates) |child| {\n-            do_iter_crate_map(child, |x| f(x), visited);\n+        \n+        let mut i = 0;\n+        while i < child_crates.len() {\n+            do_iter_crate_map(child_crates[i], |x| f(x), visited);\n+            i = i + 1;\n         }\n     }\n }\n \n+#[cfg(stage0)]\n /// Iterates recursively over `crate_map` and all child crate maps\n-pub unsafe fn iter_crate_map(crate_map: *CrateMap, f: &fn(*mut ModEntry)) {\n+pub fn iter_crate_map(crate_map: *u8, f: &fn(&mut ModEntry)) {\n+}\n+\n+#[cfg(not(stage0))]\n+/// Iterates recursively over `crate_map` and all child crate maps\n+pub fn iter_crate_map(crate_map: &'static CrateMap, f: &fn(&mut ModEntry)) {\n     // XXX: use random numbers as keys from the OS-level RNG when there is a nice\n     //        way to do this\n     let mut v: HashSet<*CrateMap> = HashSet::with_capacity_and_keys(0, 0, 32);\n-    do_iter_crate_map(crate_map, f, &mut v);\n-}\n-\n-#[test]\n-fn iter_crate_map_duplicates() {\n-    use c_str::ToCStr;\n-    use cast::transmute;\n-\n-    struct CrateMapT3 {\n-        version: i32,\n-        entries: *ModEntry,\n-        children: [*CrateMap, ..3]\n-    }\n-\n     unsafe {\n-        let mod_name1 = \"c::m1\".to_c_str();\n-        let mut level3: u32 = 3;\n-\n-        let entries: ~[ModEntry] = ~[\n-            ModEntry { name: mod_name1.with_ref(|buf| buf), log_level: &mut level3},\n-            ModEntry { name: ptr::null(), log_level: ptr::mut_null()}\n-        ];\n-        let child_crate = CrateMap {\n-            version: 1,\n-            entries: vec::raw::to_ptr(entries),\n-            children: [ptr::null()]\n-        };\n-\n-        let root_crate = CrateMapT3 {\n-            version: 1,\n-            entries: vec::raw::to_ptr([ModEntry { name: ptr::null(), log_level: ptr::mut_null()}]),\n-            children: [&child_crate as *CrateMap, &child_crate as *CrateMap, ptr::null()]\n-        };\n-\n-        let mut cnt = 0;\n-        do iter_crate_map(transmute(&root_crate)) |entry| {\n-            assert!(*(*entry).log_level == 3);\n-            cnt += 1;\n-        }\n-        assert!(cnt == 1);\n+        do_iter_crate_map(transmute(crate_map), f, &mut v);\n     }\n }\n \n-#[test]\n-fn iter_crate_map_follow_children() {\n+#[cfg(test)]\n+mod tests {\n     use c_str::ToCStr;\n     use cast::transmute;\n+    use ptr;\n+    use vec;\n+\n+    use rt::crate_map::{ModEntry, iter_crate_map};\n \n-    struct CrateMapT2 {\n+    struct CrateMap<'self> { \n         version: i32,\n         entries: *ModEntry,\n-        children: [*CrateMap, ..2]\n+        /// a dynamically sized struct, where all pointers to children are listed adjacent\n+        /// to the struct, terminated with NULL\n+        children: &'self [&'self CrateMap<'self>] \n     }\n \n-    unsafe {\n-        let mod_name1 = \"c::m1\".to_c_str();\n-        let mod_name2 = \"c::m2\".to_c_str();\n-        let mut level2: u32 = 2;\n-        let mut level3: u32 = 3;\n-        let child_crate2 = CrateMap {\n-            version: 1,\n-            entries: vec::raw::to_ptr([\n-                ModEntry { name: mod_name1.with_ref(|buf| buf), log_level: &mut level2},\n-                ModEntry { name: mod_name2.with_ref(|buf| buf), log_level: &mut level3},\n-                ModEntry { name: ptr::null(), log_level: ptr::mut_null()}\n-            ]),\n-            children: [ptr::null()]\n-        };\n+    #[test]\n+    fn iter_crate_map_duplicates() {\n+        unsafe {\n+            let mod_name1 = \"c::m1\".to_c_str();\n+            let mut level3: u32 = 3;\n \n-        let child_crate1 = CrateMapT2 {\n-            version: 1,\n-            entries: vec::raw::to_ptr([\n-                ModEntry { name: \"t::f1\".with_c_str(|buf| buf), log_level: &mut 1},\n+            let entries: ~[ModEntry] = ~[\n+                ModEntry { name: mod_name1.with_ref(|buf| buf), log_level: &mut level3},\n                 ModEntry { name: ptr::null(), log_level: ptr::mut_null()}\n-            ]),\n-            children: [&child_crate2 as *CrateMap, ptr::null()]\n-        };\n-\n-        let child_crate1_ptr: *CrateMap = transmute(&child_crate1);\n-        let root_crate = CrateMapT2 {\n-            version: 1,\n-            entries: vec::raw::to_ptr([\n-                ModEntry { name: \"t::f1\".with_c_str(|buf| buf), log_level: &mut 0},\n-                ModEntry { name: ptr::null(), log_level: ptr::mut_null()}\n-            ]),\n-            children: [child_crate1_ptr, ptr::null()]\n-        };\n+            ];\n+\n+            let child_crate = CrateMap {\n+                version: 1,\n+                entries: vec::raw::to_ptr(entries),\n+                children: []\n+            };\n+\n+            let root_crate = CrateMap {\n+                version: 1,\n+                entries: vec::raw::to_ptr([ModEntry { name: ptr::null(), log_level: ptr::mut_null()}]),\n+                children: [&child_crate, &child_crate]\n+            };\n+\n+            let mut cnt = 0;\n+            do iter_crate_map(transmute(&root_crate)) |entry| {\n+                assert!(*entry.log_level == 3);\n+                cnt += 1;\n+            }\n+            assert!(cnt == 1);\n+        }\n+    }\n \n-        let mut cnt = 0;\n-        do iter_crate_map(transmute(&root_crate)) |entry| {\n-            assert!(*(*entry).log_level == cnt);\n-            cnt += 1;\n+    #[test]\n+    fn iter_crate_map_follow_children() {\n+        unsafe {\n+            let mod_name1 = \"c::m1\".to_c_str();\n+            let mod_name2 = \"c::m2\".to_c_str();\n+            let mut level2: u32 = 2;\n+            let mut level3: u32 = 3;\n+            let child_crate2 = CrateMap {\n+                version: 1,\n+                entries: vec::raw::to_ptr([\n+                    ModEntry { name: mod_name1.with_ref(|buf| buf), log_level: &mut level2},\n+                    ModEntry { name: mod_name2.with_ref(|buf| buf), log_level: &mut level3},\n+                    ModEntry { name: ptr::null(), log_level: ptr::mut_null()}\n+                ]),\n+                children: []\n+            };\n+\n+            let child_crate1 = CrateMap {\n+                version: 1,\n+                entries: vec::raw::to_ptr([\n+                    ModEntry { name: \"t::f1\".to_c_str().with_ref(|buf| buf), log_level: &mut 1},\n+                    ModEntry { name: ptr::null(), log_level: ptr::mut_null()}\n+                ]),\n+                children: [&child_crate2]\n+            };\n+\n+            let root_crate = CrateMap {\n+                version: 1,\n+                entries: vec::raw::to_ptr([\n+                    ModEntry { name: \"t::f1\".to_c_str().with_ref(|buf| buf), log_level: &mut 0},\n+                    ModEntry { name: ptr::null(), log_level: ptr::mut_null()}\n+                ]),\n+                children: [&child_crate1]\n+            };\n+\n+            let mut cnt = 0;\n+            do iter_crate_map(transmute(&root_crate)) |entry| {\n+                assert!(*entry.log_level == cnt);\n+                cnt += 1;\n+            }\n+            assert!(cnt == 4);\n         }\n-        assert!(cnt == 4);\n     }\n }"}, {"sha": "0903171f1c15d1dc67d9e717d62b47c62b67d8ad", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/787f20a2550318a65bff6d69599afde562949a8a/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/787f20a2550318a65bff6d69599afde562949a8a/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=787f20a2550318a65bff6d69599afde562949a8a", "patch": "@@ -20,6 +20,7 @@ use str::StrSlice;\n use str::raw::from_c_str;\n use u32;\n use vec::ImmutableVector;\n+use send_str::{SendStr, SendStrOwned, SendStrStatic};\n use cast::transmute;\n \n struct LogDirective {\n@@ -110,7 +111,7 @@ fn parse_logging_spec(spec: ~str) -> ~[LogDirective]{\n \n /// Set the log level of an entry in the crate map depending on the vector\n /// of log directives\n-fn update_entry(dirs: &[LogDirective], entry: *mut ModEntry) -> u32 {\n+fn update_entry(dirs: &[LogDirective], entry: &mut ModEntry) -> u32 {\n     let mut new_lvl: u32 = DEFAULT_LOG_LEVEL;\n     let mut longest_match = -1i;\n     unsafe {\n@@ -123,7 +124,7 @@ fn update_entry(dirs: &[LogDirective], entry: *mut ModEntry) -> u32 {\n                     }\n                 }\n                 Some(ref dir_name) => {\n-                    let name = from_c_str((*entry).name);\n+                    let name = from_c_str(entry.name);\n                     let len = dir_name.len() as int;\n                     if name.starts_with(*dir_name) &&\n                         len >= longest_match {\n@@ -133,7 +134,7 @@ fn update_entry(dirs: &[LogDirective], entry: *mut ModEntry) -> u32 {\n                 }\n             };\n         }\n-        *(*entry).log_level = new_lvl;\n+        *entry.log_level = new_lvl;\n     }\n     if longest_match >= 0 { return 1; } else { return 0; }\n }\n@@ -147,8 +148,8 @@ fn update_log_settings(crate_map: *u8, settings: ~str) {\n         if settings == ~\"::help\" || settings == ~\"?\" {\n             dumb_println(\"\\nCrate log map:\\n\");\n             unsafe {\n-                do iter_crate_map(transmute(crate_map)) |entry: *mut ModEntry| {\n-                    dumb_println(\" \"+from_c_str((*entry).name));\n+                do iter_crate_map(crate_map) |entry| {\n+                    dumb_println(\" \"+from_c_str(entry.name));\n                 }\n                 exit(1);\n             }\n@@ -157,11 +158,9 @@ fn update_log_settings(crate_map: *u8, settings: ~str) {\n     }\n \n     let mut n_matches: u32 = 0;\n-    unsafe {\n-        do iter_crate_map(transmute(crate_map)) |entry: *mut ModEntry| {\n-            let m = update_entry(dirs, entry);\n-            n_matches += m;\n-        }\n+    do iter_crate_map(crate_map) |entry| {\n+        let m = update_entry(dirs, entry);\n+        n_matches += m;\n     }\n \n     if n_matches < (dirs.len() as u32) {"}]}