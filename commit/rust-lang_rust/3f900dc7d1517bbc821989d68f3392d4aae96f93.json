{"sha": "3f900dc7d1517bbc821989d68f3392d4aae96f93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmOTAwZGM3ZDE1MTdiYmM4MjE5ODlkNjhmMzM5MmQ0YWFlOTZmOTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-11T23:19:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-11T23:19:42Z"}, "message": "auto merge of #7055 : thestinger/rust/iterator, r=catamorphism\n\nThis was a lot more painful than just changing `x.each` to `x.iter().advance` . I ran into my old friend #5898 and had to add underscores to some method names as a temporary workaround.\r\n\r\nThe borrow checker also had other ideas because rvalues aren't handled very well yet so temporary variables had to be added. However, storing the temporary in a variable led to dynamic `@mut` failures, so those had to be wrapped in blocks except where the scope ends immediately.\r\n\r\nAnyway, the ugliness will be fixed as the compiler issues are fixed and this change will amount to `for x.each |x|` becoming `for x.iter |x|` and making all the iterator adaptors available.\r\n\r\nI dropped the run-pass tests for `old_iter` because there's not much point in fixing a module that's on the way out in the next week or so.", "tree": {"sha": "1f8c006deabe41787f5111c47c823c0d2fb12301", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f8c006deabe41787f5111c47c823c0d2fb12301"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f900dc7d1517bbc821989d68f3392d4aae96f93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f900dc7d1517bbc821989d68f3392d4aae96f93", "html_url": "https://github.com/rust-lang/rust/commit/3f900dc7d1517bbc821989d68f3392d4aae96f93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f900dc7d1517bbc821989d68f3392d4aae96f93/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1175e94de3b6d0f6b35fd8de3599b29267f1adab", "url": "https://api.github.com/repos/rust-lang/rust/commits/1175e94de3b6d0f6b35fd8de3599b29267f1adab", "html_url": "https://github.com/rust-lang/rust/commit/1175e94de3b6d0f6b35fd8de3599b29267f1adab"}, {"sha": "bbe3d4a9dc7eae6b53871d0a59d56372c2c03479", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbe3d4a9dc7eae6b53871d0a59d56372c2c03479", "html_url": "https://github.com/rust-lang/rust/commit/bbe3d4a9dc7eae6b53871d0a59d56372c2c03479"}], "stats": {"total": 1122, "additions": 485, "deletions": 637}, "files": [{"sha": "9317858d6da4f806bb2d81a90b307ccf3273d908", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use core::prelude::*;\n+use core::iterator::IteratorUtil;\n \n use core::os;\n use core::run;\n@@ -58,7 +59,7 @@ pub fn run(lib_path: &str,\n         err_fd: None\n     });\n \n-    for input.each |input| {\n+    for input.iter().advance |input| {\n         proc.input().write_str(*input);\n     }\n     let output = proc.finish_with_output();"}, {"sha": "05fe4ed72ee8e497fc30028e2dac4869ed894359", "filename": "src/libextra/par.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibextra%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibextra%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpar.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -139,8 +139,8 @@ pub fn any<A:Copy + Owned>(\n     fn_factory: &fn() -> ~fn(&A) -> bool) -> bool {\n     let mapped = map_slices(xs, || {\n         let f = fn_factory();\n-        let result: ~fn(uint, &[A]) -> bool = |_, slice| slice.iter().any(f);\n+        let result: ~fn(uint, &[A]) -> bool = |_, slice| slice.iter().any_(f);\n         result\n     });\n-    mapped.iter().any(|&x| x)\n+    mapped.iter().any_(|&x| x)\n }"}, {"sha": "3f74b905f2a6f291faed10d48e3f46ddead49886", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -427,7 +427,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n                 b = y.next();\n             }\n         }\n-        return b.each(|&x| f(x)) && y.advance(f);\n+        b.iter().advance(|&x| f(x)) && y.advance(f)\n     }\n \n     /// Visit the values (in-order) representing the intersection\n@@ -485,7 +485,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n                 a = x.next();\n             }\n         }\n-        return b.each(|&x| f(x)) && y.advance(f);\n+        b.iter().advance(|&x| f(x)) && y.advance(f)\n     }\n }\n \n@@ -527,14 +527,14 @@ impl<K: TotalOrd, V> TreeNode<K, V> {\n \n fn each<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n                             f: &fn(&'r K, &'r V) -> bool) -> bool {\n-    node.each(|x| each(&x.left, f) && f(&x.key, &x.value) &&\n-                  each(&x.right, f))\n+    node.iter().advance(|x| each(&x.left, f) && f(&x.key, &x.value) &&\n+                            each(&x.right, f))\n }\n \n fn each_reverse<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n                                     f: &fn(&'r K, &'r V) -> bool) -> bool {\n-    node.each(|x| each_reverse(&x.right, f) && f(&x.key, &x.value) &&\n-                  each_reverse(&x.left, f))\n+    node.iter().advance(|x| each_reverse(&x.right, f) && f(&x.key, &x.value) &&\n+                            each_reverse(&x.left, f))\n }\n \n fn mutate_values<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,\n@@ -625,7 +625,7 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n     fn heir_swap<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>,\n                                  child: &mut Option<~TreeNode<K, V>>) {\n         // *could* be done without recursion, but it won't borrow check\n-        for child.each_mut |x| {\n+        for child.mut_iter().advance |x| {\n             if x.right.is_some() {\n                 heir_swap(node, &mut x.right);\n             } else {\n@@ -680,18 +680,18 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n                 save.level -= 1;\n \n                 if right_level > save.level {\n-                    for save.right.each_mut |x| { x.level = save.level }\n+                    for save.right.mut_iter().advance |x| { x.level = save.level }\n                 }\n \n                 skew(save);\n \n-                for save.right.each_mut |right| {\n+                for save.right.mut_iter().advance |right| {\n                     skew(right);\n-                    for right.right.each_mut |x| { skew(x) }\n+                    for right.right.mut_iter().advance |x| { skew(x) }\n                 }\n \n                 split(save);\n-                for save.right.each_mut |x| { split(x) }\n+                for save.right.mut_iter().advance |x| { split(x) }\n             }\n \n             return ret;\n@@ -1111,6 +1111,7 @@ mod test_set {\n \n         let mut n = 0;\n         for m.each |x| {\n+            println(fmt!(\"%?\", x));\n             assert_eq!(*x, n);\n             n += 1\n         }"}, {"sha": "5bc490937b615742db434dadf9579e36583368bf", "filename": "src/librust/rust.rc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrust%2Frust.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrust%2Frust.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rc?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -30,6 +30,7 @@ extern mod rusti;\n extern mod rustc;\n \n use core::prelude::*;\n+use core::iterator::IteratorUtil;\n \n use core::io;\n use core::os;\n@@ -242,7 +243,8 @@ pub fn main() {\n     let args = os_args.tail();\n \n     if !args.is_empty() {\n-        for find_cmd(*args.head()).each |command| {\n+        let r = find_cmd(*args.head());\n+        for r.iter().advance |command| {\n             let result = do_command(command, args.tail());\n             match result {\n                 Valid(exit_code) => unsafe { exit(exit_code.to_i32()) },"}, {"sha": "e0061f3f95e57f0725a329c94a56ab27c992e747", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -22,6 +22,7 @@ use middle::ty;\n use middle;\n use util::ppaux::ty_to_str;\n \n+use core::iterator::IteratorUtil;\n use core::hash::HashUtil;\n use core::hashmap::HashMap;\n use core::int;\n@@ -120,7 +121,7 @@ fn encode_region_param(ecx: @EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        it: @ast::item) {\n     let opt_rp = ecx.tcx.region_paramd_items.find(&it.id);\n-    for opt_rp.each |rp| {\n+    for opt_rp.iter().advance |rp| {\n         ebml_w.start_tag(tag_region_param);\n         rp.encode(ebml_w);\n         ebml_w.end_tag();\n@@ -240,7 +241,7 @@ fn encode_type(ecx: @EncodeContext,\n fn encode_transformed_self_ty(ecx: @EncodeContext,\n                               ebml_w: &mut writer::Encoder,\n                               opt_typ: Option<ty::t>) {\n-    for opt_typ.each |&typ| {\n+    for opt_typ.iter().advance |&typ| {\n         ebml_w.start_tag(tag_item_method_transformed_self_ty);\n         write_type(ecx, ebml_w, typ);\n         ebml_w.end_tag();\n@@ -956,7 +957,7 @@ fn encode_info_for_item(ecx: @EncodeContext,\n             ebml_w.writer.write(str::to_bytes(def_to_str(method_def_id)));\n             ebml_w.end_tag();\n         }\n-        for opt_trait.each |ast_trait_ref| {\n+        for opt_trait.iter().advance |ast_trait_ref| {\n             let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n             encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_trait_ref);\n         }"}, {"sha": "0c68251acbec2aaddeaef3d55afc0e702b46377e", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 83, "deletions": 52, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -25,6 +25,7 @@ use middle::{ty, typeck, moves};\n use middle;\n use util::ppaux::ty_to_str;\n \n+use core::iterator::IteratorUtil;\n use core::at_vec;\n use core::uint;\n use extra::ebml::reader;\n@@ -826,86 +827,113 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n \n     debug!(\"Encoding side tables for id %d\", id);\n \n-    for tcx.def_map.find(&id).each |def| {\n-        do ebml_w.tag(c::tag_table_def) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                (*def).encode(ebml_w)\n+    {\n+        let r = tcx.def_map.find(&id);\n+        for r.iter().advance |def| {\n+            do ebml_w.tag(c::tag_table_def) |ebml_w| {\n+                ebml_w.id(id);\n+                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                    (*def).encode(ebml_w)\n+                }\n             }\n         }\n     }\n \n-    for tcx.node_types.find(&(id as uint)).each |&ty| {\n-        do ebml_w.tag(c::tag_table_node_type) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                ebml_w.emit_ty(ecx, *ty);\n+    {\n+        let r = tcx.node_types.find(&(id as uint));\n+        for r.iter().advance |&ty| {\n+            do ebml_w.tag(c::tag_table_node_type) |ebml_w| {\n+                ebml_w.id(id);\n+                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                    ebml_w.emit_ty(ecx, *ty);\n+                }\n             }\n         }\n     }\n \n-    for tcx.node_type_substs.find(&id).each |tys| {\n-        do ebml_w.tag(c::tag_table_node_type_subst) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                ebml_w.emit_tys(ecx, **tys)\n+    {\n+        let r = tcx.node_type_substs.find(&id);\n+        for r.iter().advance |tys| {\n+            do ebml_w.tag(c::tag_table_node_type_subst) |ebml_w| {\n+                ebml_w.id(id);\n+                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                    ebml_w.emit_tys(ecx, **tys)\n+                }\n             }\n         }\n     }\n \n-    for tcx.freevars.find(&id).each |&fv| {\n-        do ebml_w.tag(c::tag_table_freevars) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                do ebml_w.emit_from_vec(**fv) |ebml_w, fv_entry| {\n-                    encode_freevar_entry(ebml_w, *fv_entry)\n+    {\n+        let r = tcx.freevars.find(&id);\n+        for r.iter().advance |&fv| {\n+            do ebml_w.tag(c::tag_table_freevars) |ebml_w| {\n+                ebml_w.id(id);\n+                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                    do ebml_w.emit_from_vec(**fv) |ebml_w, fv_entry| {\n+                        encode_freevar_entry(ebml_w, *fv_entry)\n+                    }\n                 }\n             }\n         }\n     }\n \n     let lid = ast::def_id { crate: ast::local_crate, node: id };\n-    for tcx.tcache.find(&lid).each |&tpbt| {\n-        do ebml_w.tag(c::tag_table_tcache) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                ebml_w.emit_tpbt(ecx, *tpbt);\n+    {\n+        let r = tcx.tcache.find(&lid);\n+        for r.iter().advance |&tpbt| {\n+            do ebml_w.tag(c::tag_table_tcache) |ebml_w| {\n+                ebml_w.id(id);\n+                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                    ebml_w.emit_tpbt(ecx, *tpbt);\n+                }\n             }\n         }\n     }\n \n-    for tcx.ty_param_defs.find(&id).each |&type_param_def| {\n-        do ebml_w.tag(c::tag_table_param_defs) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                ebml_w.emit_type_param_def(ecx, type_param_def)\n+    {\n+        let r = tcx.ty_param_defs.find(&id);\n+        for r.iter().advance |&type_param_def| {\n+            do ebml_w.tag(c::tag_table_param_defs) |ebml_w| {\n+                ebml_w.id(id);\n+                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                    ebml_w.emit_type_param_def(ecx, type_param_def)\n+                }\n             }\n         }\n     }\n \n-    for maps.method_map.find(&id).each |&mme| {\n-        do ebml_w.tag(c::tag_table_method_map) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                encode_method_map_entry(ecx, ebml_w, *mme)\n+    {\n+        let r = maps.method_map.find(&id);\n+        for r.iter().advance |&mme| {\n+            do ebml_w.tag(c::tag_table_method_map) |ebml_w| {\n+                ebml_w.id(id);\n+                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                    encode_method_map_entry(ecx, ebml_w, *mme)\n+                }\n             }\n         }\n     }\n \n-    for maps.vtable_map.find(&id).each |&dr| {\n-        do ebml_w.tag(c::tag_table_vtable_map) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                encode_vtable_res(ecx, ebml_w, *dr);\n+    {\n+        let r = maps.vtable_map.find(&id);\n+        for r.iter().advance |&dr| {\n+            do ebml_w.tag(c::tag_table_vtable_map) |ebml_w| {\n+                ebml_w.id(id);\n+                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                    encode_vtable_res(ecx, ebml_w, *dr);\n+                }\n             }\n         }\n     }\n \n-    for tcx.adjustments.find(&id).each |adj| {\n-        do ebml_w.tag(c::tag_table_adjustments) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                (**adj).encode(ebml_w)\n+    {\n+        let r = tcx.adjustments.find(&id);\n+        for r.iter().advance |adj| {\n+            do ebml_w.tag(c::tag_table_adjustments) |ebml_w| {\n+                ebml_w.id(id);\n+                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                    (**adj).encode(ebml_w)\n+                }\n             }\n         }\n     }\n@@ -916,12 +944,15 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n         }\n     }\n \n-    for maps.capture_map.find(&id).each |&cap_vars| {\n-        do ebml_w.tag(c::tag_table_capture_map) |ebml_w| {\n-            ebml_w.id(id);\n-            do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                do ebml_w.emit_from_vec(*cap_vars) |ebml_w, cap_var| {\n-                    cap_var.encode(ebml_w);\n+    {\n+        let r = maps.capture_map.find(&id);\n+        for r.iter().advance |&cap_vars| {\n+            do ebml_w.tag(c::tag_table_capture_map) |ebml_w| {\n+                ebml_w.id(id);\n+                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                    do ebml_w.emit_from_vec(*cap_vars) |ebml_w, cap_var| {\n+                        cap_var.encode(ebml_w);\n+                    }\n                 }\n             }\n         }"}, {"sha": "ff57653115c6f675b24572a37a98e4114a59d284", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -18,6 +18,7 @@\n // 4. moves do not affect things loaned out in any way\n \n use core::prelude::*;\n+use core::iterator::IteratorUtil;\n \n use core::hashmap::HashSet;\n use core::uint;\n@@ -581,14 +582,15 @@ impl<'self> CheckLoanCtxt<'self> {\n         // FIXME(#4384) inadequare if/when we permit `move a.b`\n \n         // check for a conflicting loan:\n-        for opt_loan_path(cmt).each |&lp| {\n+        let r = opt_loan_path(cmt);\n+        for r.iter().advance |&lp| {\n             for self.each_in_scope_restriction(cmt.id, lp) |loan, _| {\n                 // Any restriction prevents moves.\n                 return MoveWhileBorrowed(lp, loan.loan_path, loan.span);\n             }\n         }\n \n-        return MoveOk;\n+        MoveOk\n     }\n \n     pub fn check_call(&mut self,\n@@ -700,9 +702,9 @@ fn check_loans_in_expr<'a>(expr: @ast::expr,\n           if !this.move_data.is_assignee(expr.id) {\n               let cmt = this.bccx.cat_expr_unadjusted(expr);\n               debug!(\"path cmt=%s\", cmt.repr(this.tcx()));\n-              for opt_loan_path(cmt).each |&lp| {\n-                  this.check_if_path_is_moved(expr.id, expr.span,\n-                                              MovedInUse, lp);\n+              let r = opt_loan_path(cmt);\n+              for r.iter().advance |&lp| {\n+                  this.check_if_path_is_moved(expr.id, expr.span, MovedInUse, lp);\n               }\n           }\n       }"}, {"sha": "fa7c3fb52f43a1e35c56a4c669666e1ea04c899b", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -17,6 +17,7 @@\n // sure that all of these loans are honored.\n \n use core::prelude::*;\n+use core::iterator::IteratorUtil;\n \n use middle::borrowck::*;\n use middle::borrowck::move_data::MoveData;\n@@ -176,13 +177,19 @@ fn gather_loans_in_expr(ex: @ast::expr,\n \n     this.id_range.add(ex.id);\n \n-    for ex.get_callee_id().each |callee_id| {\n-        this.id_range.add(*callee_id);\n+    {\n+        let r = ex.get_callee_id();\n+        for r.iter().advance |callee_id| {\n+            this.id_range.add(*callee_id);\n+        }\n     }\n \n     // If this expression is borrowed, have to ensure it remains valid:\n-    for tcx.adjustments.find(&ex.id).each |&adjustments| {\n-        this.guarantee_adjustments(ex, *adjustments);\n+    {\n+        let r = tcx.adjustments.find(&ex.id);\n+        for r.iter().advance |&adjustments| {\n+            this.guarantee_adjustments(ex, *adjustments);\n+        }\n     }\n \n     // If this expression is a move, gather it:"}, {"sha": "6b16bb5a3c35870228a38816e94db072387267b7", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -16,6 +16,7 @@ comments in the section \"Moves and initialization\" and in `doc.rs`.\n */\n \n use core::prelude::*;\n+use core::iterator::IteratorUtil;\n \n use core::hashmap::{HashMap, HashSet};\n use core::uint;\n@@ -516,7 +517,7 @@ impl FlowedMoveData {\n                 loop;\n             }\n \n-            for opt_loan_path_index.each |&loan_path_index| {\n+            for opt_loan_path_index.iter().advance |&loan_path_index| {\n                 for self.move_data.each_base_path(moved_path) |p| {\n                     if p == loan_path_index {\n                         // Scenario 3: some extension of `loan_path`"}, {"sha": "b048a58b840096decf4ee9f729bd3738849b4c52", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::iterator::IteratorUtil;\n use core::prelude::*;\n \n use driver::session::Session;\n@@ -49,7 +50,7 @@ pub fn check_item(sess: Session,\n       }\n       item_enum(ref enum_definition, _) => {\n         for (*enum_definition).variants.each |var| {\n-            for var.node.disr_expr.each |ex| {\n+            for var.node.disr_expr.iter().advance |ex| {\n                 (v.visit_expr)(*ex, true, v);\n             }\n         }"}, {"sha": "c352771733934146b3e1322476ea967b8fa2907c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -363,7 +363,8 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n       ty::ty_enum(eid, _) => {\n         let mut found = ~[];\n         for m.each |r| {\n-            for pat_ctor_id(cx, r[0]).each |id| {\n+            let r = pat_ctor_id(cx, r[0]);\n+            for r.iter().advance |id| {\n                 if !vec::contains(found, id) {\n                     found.push(/*bad*/copy *id);\n                 }"}, {"sha": "530f16609845373fe84a3ec58a0b0078d6b37a9d", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -794,7 +794,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                      opt_expr: Option<@ast::expr>,\n                      in_out: &mut [uint],\n                      loop_scopes: &mut ~[LoopScope]) {\n-        for opt_expr.each |&expr| {\n+        for opt_expr.iter().advance |&expr| {\n             self.walk_expr(expr, in_out, loop_scopes);\n         }\n     }"}, {"sha": "0c1862d9c48b8b8412dd0a81c4fbaae8fd67325f", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -245,32 +245,35 @@ pub fn check_expr(e: @expr, cx: Context, v: visit::vt<Context>) {\n         Some(callee_id) => callee_id,\n         None => e.id,\n     };\n-    for cx.tcx.node_type_substs.find(&type_parameter_id).each |ts| {\n-        let type_param_defs = match e.node {\n-          expr_path(_) => {\n-            let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&e.id));\n-            ty::lookup_item_type(cx.tcx, did).generics.type_param_defs\n-          }\n-          _ => {\n-            // Type substitutions should only occur on paths and\n-            // method calls, so this needs to be a method call.\n-\n-            // Even though the callee_id may have been the id with\n-            // node_type_substs, e.id is correct here.\n-            ty::method_call_type_param_defs(cx.tcx, cx.method_map, e.id).expect(\n-                \"non path/method call expr has type substs??\")\n-          }\n-        };\n-        if ts.len() != type_param_defs.len() {\n-            // Fail earlier to make debugging easier\n-            fail!(\"internal error: in kind::check_expr, length \\\n-                  mismatch between actual and declared bounds: actual = \\\n-                  %s, declared = %s\",\n-                  ts.repr(cx.tcx),\n-                  type_param_defs.repr(cx.tcx));\n-        }\n-        for ts.iter().zip(type_param_defs.iter()).advance |(&ty, type_param_def)| {\n-            check_bounds(cx, type_parameter_id, e.span, ty, type_param_def)\n+    {\n+        let r = cx.tcx.node_type_substs.find(&type_parameter_id);\n+        for r.iter().advance |ts| {\n+            let type_param_defs = match e.node {\n+              expr_path(_) => {\n+                let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&e.id));\n+                ty::lookup_item_type(cx.tcx, did).generics.type_param_defs\n+              }\n+              _ => {\n+                // Type substitutions should only occur on paths and\n+                // method calls, so this needs to be a method call.\n+\n+                // Even though the callee_id may have been the id with\n+                // node_type_substs, e.id is correct here.\n+                ty::method_call_type_param_defs(cx.tcx, cx.method_map, e.id).expect(\n+                    \"non path/method call expr has type substs??\")\n+              }\n+            };\n+            if ts.len() != type_param_defs.len() {\n+                // Fail earlier to make debugging easier\n+                fail!(\"internal error: in kind::check_expr, length \\\n+                      mismatch between actual and declared bounds: actual = \\\n+                      %s, declared = %s\",\n+                      ts.repr(cx.tcx),\n+                      type_param_defs.repr(cx.tcx));\n+            }\n+            for ts.iter().zip(type_param_defs.iter()).advance |(&ty, type_param_def)| {\n+                check_bounds(cx, type_parameter_id, e.span, ty, type_param_def)\n+            }\n         }\n     }\n \n@@ -306,14 +309,15 @@ pub fn check_expr(e: @expr, cx: Context, v: visit::vt<Context>) {\n fn check_ty(aty: @Ty, cx: Context, v: visit::vt<Context>) {\n     match aty.node {\n       ty_path(_, id) => {\n-        for cx.tcx.node_type_substs.find(&id).each |ts| {\n-            let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&id));\n-            let type_param_defs =\n-                ty::lookup_item_type(cx.tcx, did).generics.type_param_defs;\n-            for ts.iter().zip(type_param_defs.iter()).advance |(&ty, type_param_def)| {\n-                check_bounds(cx, aty.id, aty.span, ty, type_param_def)\n-            }\n-        }\n+          let r = cx.tcx.node_type_substs.find(&id);\n+          for r.iter().advance |ts| {\n+              let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&id));\n+              let type_param_defs =\n+                  ty::lookup_item_type(cx.tcx, did).generics.type_param_defs;\n+              for ts.iter().zip(type_param_defs.iter()).advance |(&ty, type_param_def)| {\n+                  check_bounds(cx, aty.id, aty.span, ty, type_param_def)\n+              }\n+          }\n       }\n       _ => {}\n     }"}, {"sha": "007970067b331046f1194f81f5d12d535ee4ffc3", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -15,6 +15,7 @@ use middle::ty;\n use middle::pat_util;\n use util::ppaux::{ty_to_str};\n \n+use core::iterator::IteratorUtil;\n use core::char;\n use core::cmp;\n use core::hashmap::HashMap;\n@@ -388,7 +389,7 @@ impl Context {\n             allow => fail!(),\n         }\n \n-        for note.each |&span| {\n+        for note.iter().advance |&span| {\n             self.tcx.sess.span_note(span, \"lint level defined here\");\n         }\n     }"}, {"sha": "0fceb2261ee6ee806a7ea05179e691f103134e74", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -114,7 +114,6 @@ use core::iterator::IteratorUtil;\n use core::cast::transmute;\n use core::hashmap::HashMap;\n use core::io;\n-use core::old_iter;\n use core::to_str;\n use core::uint;\n use core::vec;\n@@ -987,8 +986,8 @@ impl Liveness {\n                                       opt_expr: Option<@expr>,\n                                       succ: LiveNode)\n                                       -> LiveNode {\n-        do old_iter::foldl(&opt_expr, succ) |succ, expr| {\n-            self.propagate_through_expr(*expr, *succ)\n+        do opt_expr.iter().fold(succ) |succ, expr| {\n+            self.propagate_through_expr(*expr, succ)\n         }\n     }\n \n@@ -1624,7 +1623,8 @@ impl Liveness {\n                              var: Variable)\n                              -> bool {\n         if !self.used_on_entry(ln, var) {\n-            for self.should_warn(var).each |name| {\n+            let r = self.should_warn(var);\n+            for r.iter().advance |name| {\n \n                 // annoying: for parameters in funcs like `fn(x: int)\n                 // {ret}`, there is only one node, so asking about\n@@ -1644,9 +1644,10 @@ impl Liveness {\n                         fmt!(\"unused variable: `%s`\", **name));\n                 }\n             }\n-            return true;\n+            true\n+        } else {\n+            false\n         }\n-        return false;\n     }\n \n     pub fn warn_about_dead_assign(&self,\n@@ -1655,7 +1656,8 @@ impl Liveness {\n                                   ln: LiveNode,\n                                   var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n-            for self.should_warn(var).each |name| {\n+            let r = self.should_warn(var);\n+            for r.iter().advance |name| {\n                 self.tcx.sess.add_lint(dead_assignment, id, sp,\n                     fmt!(\"value assigned to `%s` is never read\", **name));\n             }"}, {"sha": "2802a92a1f99a0480fa485e3500b9b37877a289b", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -47,6 +47,7 @@\n  */\n \n use core::prelude::*;\n+use core::iterator::IteratorUtil;\n \n use middle::ty;\n use middle::typeck;\n@@ -948,7 +949,7 @@ impl mem_categorization_ctxt {\n               for before.each |&before_pat| {\n                   self.cat_pattern(elt_cmt, before_pat, op);\n               }\n-              for slice.each |&slice_pat| {\n+              for slice.iter().advance |&slice_pat| {\n                   let slice_ty = self.pat_ty(slice_pat);\n                   let slice_cmt = self.cat_rvalue(pat, slice_ty);\n                   self.cat_pattern(slice_cmt, slice_pat, op);"}, {"sha": "ccdfed6f126d7bee1215d166218599eaf131abe3", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -127,6 +127,7 @@ and so on.\n */\n \n use core::prelude::*;\n+use core::iterator::IteratorUtil;\n \n use middle::pat_util::{pat_bindings};\n use middle::freevars;\n@@ -267,7 +268,7 @@ impl VisitContext {\n             (visitor.visit_stmt)(*stmt, *self, visitor);\n         }\n \n-        for blk.node.expr.each |tail_expr| {\n+        for blk.node.expr.iter().advance |tail_expr| {\n             self.consume_expr(*tail_expr, visitor);\n         }\n     }\n@@ -302,7 +303,8 @@ impl VisitContext {\n                 match comp_mode {\n                     Move => {\n                         let def = self.tcx.def_map.get_copy(&expr.id);\n-                        for moved_variable_node_id_from_def(def).each |&id| {\n+                        let r = moved_variable_node_id_from_def(def);\n+                        for r.iter().advance |&id| {\n                             self.move_maps.moved_variables_set.insert(id);\n                         }\n                     }\n@@ -350,7 +352,7 @@ impl VisitContext {\n                     self.consume_expr(field.node.expr, visitor);\n                 }\n \n-                for opt_with.each |with_expr| {\n+                for opt_with.iter().advance |with_expr| {\n                     // If there are any fields whose type is move-by-default,\n                     // then `with` is consumed, otherwise it is only read\n                     let with_ty = ty::expr_ty(self.tcx, *with_expr);\n@@ -389,7 +391,7 @@ impl VisitContext {\n             expr_if(cond_expr, ref then_blk, opt_else_expr) => {\n                 self.consume_expr(cond_expr, visitor);\n                 self.consume_block(then_blk, visitor);\n-                for opt_else_expr.each |else_expr| {\n+                for opt_else_expr.iter().advance |else_expr| {\n                     self.consume_expr(*else_expr, visitor);\n                 }\n             }\n@@ -466,7 +468,7 @@ impl VisitContext {\n             }\n \n             expr_ret(ref opt_expr) => {\n-                for opt_expr.each |expr| {\n+                for opt_expr.iter().advance |expr| {\n                     self.consume_expr(*expr, visitor);\n                 }\n             }\n@@ -541,11 +543,11 @@ impl VisitContext {\n     }\n \n     pub fn consume_arm(&self, arm: &arm, visitor: vt<VisitContext>) {\n-        for arm.pats.each |pat| {\n+        for arm.pats.iter().advance |pat| {\n             self.use_pat(*pat);\n         }\n \n-        for arm.guard.each |guard| {\n+        for arm.guard.iter().advance |guard| {\n             self.consume_expr(*guard, visitor);\n         }\n "}, {"sha": "8a526efbc3a880e5095d55f90881a30b47323ef1", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -26,6 +26,7 @@ use middle::ty::{region_variance, rv_covariant, rv_invariant};\n use middle::ty::{rv_contravariant, FreeRegion};\n use middle::ty;\n \n+use core::iterator::IteratorUtil;\n use core::hashmap::{HashMap, HashSet};\n use syntax::ast_map;\n use syntax::codemap::span;\n@@ -329,7 +330,7 @@ pub fn parent_id(cx: Context, span: span) -> ast::node_id {\n pub fn parent_to_expr(cx: Context, child_id: ast::node_id, sp: span) {\n     debug!(\"region::parent_to_expr(span=%?)\",\n            cx.sess.codemap.span_to_str(sp));\n-    for cx.parent.each |parent_id| {\n+    for cx.parent.iter().advance |parent_id| {\n         cx.region_maps.record_parent(child_id, *parent_id);\n     }\n }"}, {"sha": "7c9877a838ad77c790d9074aa94eea01167aadd0", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -1036,11 +1036,14 @@ impl Resolver {\n                         fmt!(\"duplicate definition of %s `%s`\",\n                              namespace_to_str(ns),\n                              *self.session.str_of(name)));\n-                    for child.span_for_namespace(ns).each |sp| {\n-                        self.session.span_note(*sp,\n-                             fmt!(\"first definition of %s %s here:\",\n-                                  namespace_to_str(ns),\n-                                  *self.session.str_of(name)));\n+                    {\n+                        let r = child.span_for_namespace(ns);\n+                        for r.iter().advance |sp| {\n+                            self.session.span_note(*sp,\n+                                 fmt!(\"first definition of %s %s here:\",\n+                                      namespace_to_str(ns),\n+                                      *self.session.str_of(name)));\n+                        }\n                     }\n                 }\n                 return (child, new_parent);\n@@ -3490,7 +3493,7 @@ impl Resolver {\n             // then resolve the ty params\n             item_enum(ref enum_def, ref generics) => {\n                 for (*enum_def).variants.each() |variant| {\n-                    for variant.node.disr_expr.each |dis_expr| {\n+                    for variant.node.disr_expr.iter().advance |dis_expr| {\n                         // resolve the discriminator expr\n                         // as a constant\n                         self.with_constant_rib(|| {\n@@ -3907,8 +3910,11 @@ impl Resolver {\n \n                     // Record the current set of trait references.\n                     let mut new_trait_refs = ~[];\n-                    for self.def_map.find(&trait_reference.ref_id).each |&def| {\n-                        new_trait_refs.push(def_id_of_def(*def));\n+                    {\n+                        let r = self.def_map.find(&trait_reference.ref_id);\n+                        for r.iter().advance |&def| {\n+                            new_trait_refs.push(def_id_of_def(*def));\n+                        }\n                     }\n                     original_trait_refs = Some(util::replace(\n                         &mut self.current_trait_refs,"}, {"sha": "e3e431aae590295c207d657f2acf3b3b2d172e96", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -799,7 +799,7 @@ pub fn enter_region<'r>(bcx: block,\n pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n     let ccx = bcx.ccx();\n     fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], val: Opt) {\n-        if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n+        if set.iter().any_(|l| opt_eq(tcx, l, &val)) {return;}\n         set.push(val);\n     }\n \n@@ -966,7 +966,7 @@ pub fn collect_record_or_struct_fields(bcx: block,\n     fn extend(idents: &mut ~[ast::ident], field_pats: &[ast::field_pat]) {\n         for field_pats.each |field_pat| {\n             let field_ident = field_pat.ident;\n-            if !idents.iter().any(|x| *x == field_ident) {\n+            if !idents.iter().any_(|x| *x == field_ident) {\n                 idents.push(field_ident);\n             }\n         }\n@@ -977,7 +977,7 @@ pub fn pats_require_rooting(bcx: block,\n                             m: &[@Match],\n                             col: uint)\n                          -> bool {\n-    do m.iter().any |br| {\n+    do m.iter().any_ |br| {\n         let pat_id = br.pats[col].id;\n         let key = root_map_key {id: pat_id, derefs: 0u };\n         bcx.ccx().maps.root_map.contains_key(&key)\n@@ -1006,7 +1006,7 @@ pub fn root_pats_as_necessary(mut bcx: block,\n // matches may be wildcards like _ or identifiers).\n macro_rules! any_pat (\n     ($m:expr, $pattern:pat) => (\n-        do ($m).iter().any |br| {\n+        do ($m).iter().any_ |br| {\n             match br.pats[col].node {\n                 $pattern => true,\n                 _ => false\n@@ -1032,7 +1032,7 @@ pub fn any_tup_pat(m: &[@Match], col: uint) -> bool {\n }\n \n pub fn any_tuple_struct_pat(bcx: block, m: &[@Match], col: uint) -> bool {\n-    do m.iter().any |br| {\n+    do m.iter().any_ |br| {\n         let pat = br.pats[col];\n         match pat.node {\n             ast::pat_enum(_, Some(_)) => {\n@@ -1427,7 +1427,7 @@ pub fn compile_submatch(bcx: block,\n             var(_, repr) => {\n                 let (the_kind, val_opt) = adt::trans_switch(bcx, repr, val);\n                 kind = the_kind;\n-                for val_opt.each |&tval| { test_val = tval; }\n+                for val_opt.iter().advance |&tval| { test_val = tval; }\n             }\n             lit(_) => {\n                 let pty = node_id_type(bcx, pat_id);\n@@ -1792,7 +1792,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n                 }\n             }\n \n-            for inner.each |inner_pat| {\n+            for inner.iter().advance |inner_pat| {\n                 bcx = bind_irrefutable_pat(\n                     bcx, *inner_pat, val, true, binding_mode);\n             }\n@@ -1808,7 +1808,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n                                                     repr,\n                                                     vinfo.disr_val,\n                                                     val);\n-                    for sub_pats.each |sub_pat| {\n+                    for sub_pats.iter().advance |sub_pat| {\n                         for args.vals.eachi |i, argval| {\n                             bcx = bind_irrefutable_pat(bcx,\n                                                        sub_pat[i],"}, {"sha": "f47775f0700a03b2be5761421f6f10607341c624", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -1195,7 +1195,7 @@ pub fn new_block(cx: fn_ctxt, parent: Option<block>, kind: block_kind,\n                            is_lpad,\n                            opt_node_info,\n                            cx);\n-        for parent.each |cx| {\n+        for parent.iter().advance |cx| {\n             if cx.unreachable { Unreachable(bcx); }\n         };\n         bcx\n@@ -1314,10 +1314,12 @@ pub fn cleanup_and_leave(bcx: block,\n             block_scope(inf) if !inf.empty_cleanups() => {\n                 let (sub_cx, inf_cleanups) = {\n                     let inf = &mut *inf; // FIXME(#5074) workaround stage0\n-                    for vec::find((*inf).cleanup_paths,\n-                                  |cp| cp.target == leave).each |cp| {\n-                        Br(bcx, cp.dest);\n-                        return;\n+                    {\n+                        let r = vec::find((*inf).cleanup_paths, |cp| cp.target == leave);\n+                        for r.iter().advance |cp| {\n+                            Br(bcx, cp.dest);\n+                            return;\n+                        }\n                     }\n                     let sub_cx = sub_block(bcx, \"cleanup\");\n                     Br(bcx, sub_cx.llbb);\n@@ -1423,7 +1425,7 @@ pub fn alloc_local(cx: block, local: @ast::local) -> block {\n     };\n     let val = alloc_ty(cx, t);\n     if cx.sess().opts.debuginfo {\n-        for simple_name.each |name| {\n+        for simple_name.iter().advance |name| {\n             str::as_c_str(*cx.ccx().sess.str_of(*name), |buf| {\n                 unsafe {\n                     llvm::LLVMSetValueName(val, buf)\n@@ -1599,7 +1601,7 @@ pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n                         param_substs: Option<@param_substs>,\n                         sp: Option<span>)\n                      -> fn_ctxt {\n-    for param_substs.each |p| { p.validate(); }\n+    for param_substs.iter().advance |p| { p.validate(); }\n \n     debug!(\"new_fn_ctxt_w_id(path=%s, id=%?, impl_id=%?, \\\n             param_substs=%s)\","}, {"sha": "840bad92b198696d54385b59936fa9fffb22e305", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -17,6 +17,7 @@\n // closure.\n \n use core::prelude::*;\n+use core::iterator::IteratorUtil;\n \n use back::abi;\n use driver::session;\n@@ -582,9 +583,12 @@ pub fn trans_call_inner(in_cx: block,\n         } else if ret_in_loop {\n             let ret_flag_result = bool_to_i1(bcx, Load(bcx, ret_flag.get()));\n             bcx = do with_cond(bcx, ret_flag_result) |bcx| {\n-                for (copy bcx.fcx.loop_ret).each |&(flagptr, _)| {\n-                    Store(bcx, C_bool(true), flagptr);\n-                    Store(bcx, C_bool(false), bcx.fcx.llretptr.get());\n+                {\n+                    let r = (copy bcx.fcx.loop_ret);\n+                    for r.iter().advance |&(flagptr, _)| {\n+                        Store(bcx, C_bool(true), flagptr);\n+                        Store(bcx, C_bool(false), bcx.fcx.llretptr.get());\n+                    }\n                 }\n                 base::cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n                 Unreachable(bcx);"}, {"sha": "4804058609a32c5bb92facdc5492ed985d558977", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use core::prelude::*;\n+use core::iterator::IteratorUtil;\n \n use back::abi;\n use back::link::{mangle_internal_name_by_path_and_seq};\n@@ -286,7 +287,7 @@ pub fn build_closure(bcx0: block,\n \n     // If this is a `for` loop body, add two special environment\n     // variables:\n-    for include_ret_handle.each |flagptr| {\n+    for include_ret_handle.iter().advance |flagptr| {\n         // Flag indicating we have returned (a by-ref bool):\n         let flag_datum = Datum {val: *flagptr, ty: ty::mk_bool(),\n                                 mode: ByRef(ZeroMem)};"}, {"sha": "1f0746a8170833544ec8f0ea35ac24277e69d852", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -11,6 +11,7 @@\n //! Code that is useful in various trans modules.\n \n use core::prelude::*;\n+use core::iterator::IteratorUtil;\n \n use back::{abi, upcall};\n use driver::session;\n@@ -254,7 +255,7 @@ pub struct param_substs {\n impl param_substs {\n     pub fn validate(&self) {\n         for self.tys.each |t| { assert!(!ty::type_needs_infer(*t)); }\n-        for self.self_ty.each |t| { assert!(!ty::type_needs_infer(*t)); }\n+        for self.self_ty.iter().advance |t| { assert!(!ty::type_needs_infer(*t)); }\n     }\n }\n \n@@ -554,7 +555,7 @@ pub fn revoke_clean(cx: block, val: ValueRef) {\n                 clean_temp(v, _, _) if v == val => true,\n                 _ => false\n             });\n-        for cleanup_pos.each |i| {\n+        for cleanup_pos.iter().advance |i| {\n             scope_info.cleanups =\n                 vec::append(vec::slice(scope_info.cleanups, 0u, *i).to_vec(),\n                             vec::slice(scope_info.cleanups,"}, {"sha": "5b286a78311985d067c98b2f83258f2ac8df8010", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -152,6 +152,7 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::Repr;\n \n+use core::iterator::IteratorUtil;\n use core::cast::transmute;\n use core::hashmap::HashMap;\n use core::vec;\n@@ -1223,7 +1224,7 @@ fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n             for fields.each |&(_i, e)| {\n                 bcx = trans_into(bcx, e, Ignore);\n             }\n-            for optbase.each |sbi| {\n+            for optbase.iter().advance |sbi| {\n                 bcx = trans_into(bcx, sbi.expr, Ignore);\n             }\n             return bcx;\n@@ -1239,11 +1240,11 @@ fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n         add_clean_temp_mem(bcx, dest, e_ty);\n         temp_cleanups.push(dest);\n     }\n-    for optbase.each |base| {\n+    for optbase.iter().advance |base| {\n         // FIXME #6573: is it sound to use the destination's repr on the base?\n         // And, would it ever be reasonable to be here with discr != 0?\n         let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base.expr));\n-        for base.fields.each |&(i, t)| {\n+        for base.fields.iter().advance |&(i, t)| {\n             let datum = do base_datum.get_element(bcx, t, ZeroMem) |srcval| {\n                 adt::trans_field_ptr(bcx, repr, srcval, discr, i)\n             };"}, {"sha": "866daabff339331a66977f58f04ada3d235ee247", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -76,7 +76,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     let param_uses = type_use::type_uses_for(ccx, fn_id, substs.len());\n     let hash_id = make_mono_id(ccx, fn_id, substs, vtables, impl_did_opt,\n                                Some(param_uses));\n-    if hash_id.params.iter().any(\n+    if hash_id.params.iter().any_(\n                 |p| match *p { mono_precise(_, _) => false, _ => true }) {\n         must_cast = true;\n     }"}, {"sha": "74c86354244f22d40ae0d8fbc13b60c3b0110f51", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -16,6 +16,7 @@\n // reachable as well.\n \n use core::prelude::*;\n+use core::iterator::IteratorUtil;\n \n use middle::resolve;\n use middle::ty;\n@@ -136,7 +137,7 @@ fn traverse_public_item(cx: @mut ctx, item: @item) {\n         }\n       }\n       item_struct(ref struct_def, _) => {\n-        for struct_def.ctor_id.each |&ctor_id| {\n+        for struct_def.ctor_id.iter().advance |&ctor_id| {\n             let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n             cx.rmap.insert(ctor_id);\n         }"}, {"sha": "e533bfaa980214a8156066ebb89005d7b390c104", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -242,31 +242,37 @@ pub fn node_type_needs(cx: Context, use_: uint, id: node_id) {\n \n pub fn mark_for_method_call(cx: Context, e_id: node_id, callee_id: node_id) {\n     let mut opt_static_did = None;\n-    for cx.ccx.maps.method_map.find(&e_id).each |mth| {\n-        match mth.origin {\n-          typeck::method_static(did) => {\n-              opt_static_did = Some(did);\n-          }\n-          typeck::method_param(typeck::method_param {\n-              param_num: param,\n-              _\n-          }) => {\n-            cx.uses[param] |= use_tydesc;\n-          }\n-          typeck::method_trait(*) | typeck::method_self(*)\n-              | typeck::method_super(*) => (),\n+    {\n+        let r = cx.ccx.maps.method_map.find(&e_id);\n+        for r.iter().advance |mth| {\n+            match mth.origin {\n+              typeck::method_static(did) => {\n+                  opt_static_did = Some(did);\n+              }\n+              typeck::method_param(typeck::method_param {\n+                  param_num: param,\n+                  _\n+              }) => {\n+                cx.uses[param] |= use_tydesc;\n+              }\n+              typeck::method_trait(*) | typeck::method_self(*)\n+                  | typeck::method_super(*) => (),\n+            }\n         }\n     }\n \n     // Note: we do not execute this code from within the each() call\n     // above because the recursive call to `type_needs` can trigger\n     // inlining and hence can cause `method_map` and\n     // `node_type_substs` to be modified.\n-    for opt_static_did.each |&did| {\n-        for cx.ccx.tcx.node_type_substs.find_copy(&callee_id).each |ts| {\n-            let type_uses = type_uses_for(cx.ccx, did, ts.len());\n-            for type_uses.iter().zip(ts.iter()).advance |(uses, subst)| {\n-                type_needs(cx, *uses, *subst)\n+    for opt_static_did.iter().advance |&did| {\n+        {\n+            let r = cx.ccx.tcx.node_type_substs.find_copy(&callee_id);\n+            for r.iter().advance |ts| {\n+                let type_uses = type_uses_for(cx.ccx, did, ts.len());\n+                for type_uses.iter().zip(ts.iter()).advance |(uses, subst)| {\n+                    type_needs(cx, *uses, *subst)\n+                }\n             }\n         }\n     }\n@@ -300,7 +306,7 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n       }\n       expr_path(_) | expr_self => {\n         let opt_ts = cx.ccx.tcx.node_type_substs.find_copy(&e.id);\n-        for opt_ts.each |ts| {\n+        for opt_ts.iter().advance |ts| {\n             let id = ast_util::def_id_of_def(cx.ccx.tcx.def_map.get_copy(&e.id));\n             let uses_for_ts = type_uses_for(cx.ccx, id, ts.len());\n             for uses_for_ts.iter().zip(ts.iter()).advance |(uses, subst)| {\n@@ -390,7 +396,7 @@ pub fn handle_body(cx: Context, body: &blk) {\n         },\n         visit_block: |b, cx, v| {\n             visit::visit_block(b, cx, v);\n-            for b.node.expr.each |e| {\n+            for b.node.expr.iter().advance |e| {\n                 node_type_needs(cx, use_repr, e.id);\n             }\n         },"}, {"sha": "ba446d6016c6c9e16270533f323d0ae328d39922", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -1017,7 +1017,7 @@ fn mk_t(cx: ctxt, st: sty) -> t {\n     fn sflags(substs: &substs) -> uint {\n         let mut f = 0u;\n         for substs.tps.each |tt| { f |= get(*tt).flags; }\n-        for substs.self_r.each |r| { f |= rflags(*r) }\n+        for substs.self_r.iter().advance |r| { f |= rflags(*r) }\n         return f;\n     }\n     match &st {\n@@ -1560,8 +1560,8 @@ pub fn type_needs_subst(ty: t) -> bool {\n }\n \n pub fn trait_ref_contains_error(tref: &ty::TraitRef) -> bool {\n-    tref.substs.self_ty.any(|&t| type_is_error(t)) ||\n-        tref.substs.tps.any(|&t| type_is_error(t))\n+    tref.substs.self_ty.iter().any_(|&t| type_is_error(t)) ||\n+        tref.substs.tps.iter().any_(|&t| type_is_error(t))\n }\n \n pub fn type_is_ty_var(ty: t) -> bool {\n@@ -2357,7 +2357,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             ty_struct(did, ref substs) => {\n                 seen.push(did);\n                 let fields = struct_fields(cx, did, substs);\n-                let r = fields.iter().any(|f| type_requires(cx, seen, r_ty, f.mt.ty));\n+                let r = fields.iter().any_(|f| type_requires(cx, seen, r_ty, f.mt.ty));\n                 seen.pop();\n                 r\n             }\n@@ -2374,7 +2374,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                 seen.push(did);\n                 let vs = enum_variants(cx, did);\n                 let r = !vs.is_empty() && do vs.iter().all |variant| {\n-                    do variant.args.iter().any |aty| {\n+                    do variant.args.iter().any_ |aty| {\n                         let sty = subst(cx, substs, *aty);\n                         type_requires(cx, seen, r_ty, sty)\n                     }"}, {"sha": "bf4f30fb02e3934a2df6415f4fb23842a7bcb6f9", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -231,7 +231,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n         }\n \n         if !error_happened {\n-            for subpats.each |pats| {\n+            for subpats.iter().advance |pats| {\n                 for pats.iter().zip(arg_types.iter()).advance |(subpat, arg_ty)| {\n                     check_pat(pcx, *subpat, *arg_ty);\n                 }\n@@ -248,7 +248,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n     }\n \n     if error_happened {\n-        for subpats.each |pats| {\n+        for subpats.iter().advance |pats| {\n             for pats.each |pat| {\n                 check_pat(pcx, *pat, ty::mk_err());\n             }\n@@ -569,7 +569,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n               for before.each |&elt| {\n                   check_pat(pcx, elt, ty::mk_err());\n               }\n-              for slice.each |&elt| {\n+              for slice.iter().advance |&elt| {\n                   check_pat(pcx, elt, ty::mk_err());\n               }\n               for after.each |&elt| {"}, {"sha": "19acadfc572e0c0a164003bb429d8f1d1f84f343", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -332,14 +332,14 @@ impl<'self> LookupContext<'self> {\n         // candidates.\n         let trait_map: &mut resolve::TraitMap = &mut self.fcx.ccx.trait_map;\n         let opt_applicable_traits = trait_map.find(&self.expr.id);\n-        for opt_applicable_traits.each |applicable_traits| {\n+        for opt_applicable_traits.iter().advance |applicable_traits| {\n             for applicable_traits.each |trait_did| {\n                 let coherence_info = self.fcx.ccx.coherence_info;\n \n                 // Look for explicit implementations.\n                 let opt_impl_infos =\n                     coherence_info.extension_methods.find(trait_did);\n-                for opt_impl_infos.each |impl_infos| {\n+                for opt_impl_infos.iter().advance |impl_infos| {\n                     for impl_infos.each |impl_info| {\n                         self.push_candidates_from_impl(\n                             self.extension_candidates, *impl_info);\n@@ -536,7 +536,7 @@ impl<'self> LookupContext<'self> {\n     pub fn push_inherent_impl_candidates_for_type(&self, did: def_id) {\n         let opt_impl_infos =\n             self.fcx.ccx.coherence_info.inherent_methods.find(&did);\n-        for opt_impl_infos.each |impl_infos| {\n+        for opt_impl_infos.iter().advance |impl_infos| {\n             for impl_infos.each |impl_info| {\n                 self.push_candidates_from_impl(\n                     self.inherent_candidates, *impl_info);"}, {"sha": "a75c1decd0db2d030e1bcc990cb59ec3e4ac36ca", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -410,7 +410,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n       None => ()\n     }\n \n-    for opt_self_info.each |self_info| {\n+    for opt_self_info.iter().advance |self_info| {\n         fcx.write_ty(self_info.self_id, self_info.self_ty);\n     }\n     for decl.inputs.iter().zip(arg_tys.iter()).advance |(input, arg)| {\n@@ -442,7 +442,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         };\n \n         // Add the self parameter\n-        for opt_self_info.each |self_info| {\n+        for opt_self_info.iter().advance |self_info| {\n             assign(self_info.self_id, Some(self_info.self_ty));\n             debug!(\"self is assigned to %s\",\n                    fcx.infcx().ty_to_str(\n@@ -3092,7 +3092,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                 variants: &mut ~[ty::VariantInfo]) {\n         let rty = ty::node_id_to_type(ccx.tcx, id);\n         for vs.each |v| {\n-            for v.node.disr_expr.each |e_ref| {\n+            for v.node.disr_expr.iter().advance |e_ref| {\n                 let e = *e_ref;\n                 debug!(\"disr expr, checking %s\",\n                        pprust::expr_to_str(e, ccx.tcx.sess.intr()));"}, {"sha": "e865fe4c2e3958e2525ac94ecfe896fb915ca124", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -28,6 +28,7 @@ this point a bit better.\n */\n \n use core::prelude::*;\n+use core::iterator::IteratorUtil;\n \n use middle::freevars::get_freevars;\n use middle::ty::{re_scope};\n@@ -268,7 +269,7 @@ fn visit_expr(expr: @ast::expr, rcx: @mut Rcx, v: rvt) {\n         ast::expr_match(_, ref arms) => {\n             tcx.region_maps.record_cleanup_scope(expr.id);\n             for arms.each |arm| {\n-                for arm.guard.each |guard| {\n+                for arm.guard.iter().advance |guard| {\n                     tcx.region_maps.record_cleanup_scope(guard.id);\n                 }\n             }\n@@ -281,26 +282,29 @@ fn visit_expr(expr: @ast::expr, rcx: @mut Rcx, v: rvt) {\n     }\n \n     // Check any autoderefs or autorefs that appear.\n-    for rcx.fcx.inh.adjustments.find(&expr.id).each |&adjustment| {\n-        debug!(\"adjustment=%?\", adjustment);\n-        match *adjustment {\n-            @ty::AutoDerefRef(\n-                ty::AutoDerefRef {autoderefs: autoderefs, autoref: opt_autoref}) =>\n-            {\n-                let expr_ty = rcx.resolve_node_type(expr.id);\n-                constrain_derefs(rcx, expr, autoderefs, expr_ty);\n-                for opt_autoref.each |autoref| {\n-                    guarantor::for_autoref(rcx, expr, autoderefs, autoref);\n-\n-                    // Require that the resulting region encompasses\n-                    // the current node.\n-                    //\n-                    // FIXME(#6268) remove to support nested method calls\n-                    constrain_regions_in_type_of_node(\n-                        rcx, expr.id, ty::re_scope(expr.id), expr.span);\n+    {\n+        let r = rcx.fcx.inh.adjustments.find(&expr.id);\n+        for r.iter().advance |&adjustment| {\n+            debug!(\"adjustment=%?\", adjustment);\n+            match *adjustment {\n+                @ty::AutoDerefRef(\n+                    ty::AutoDerefRef {autoderefs: autoderefs, autoref: opt_autoref}) =>\n+                {\n+                    let expr_ty = rcx.resolve_node_type(expr.id);\n+                    constrain_derefs(rcx, expr, autoderefs, expr_ty);\n+                    for opt_autoref.iter().advance |autoref| {\n+                        guarantor::for_autoref(rcx, expr, autoderefs, autoref);\n+\n+                        // Require that the resulting region encompasses\n+                        // the current node.\n+                        //\n+                        // FIXME(#6268) remove to support nested method calls\n+                        constrain_regions_in_type_of_node(\n+                            rcx, expr.id, ty::re_scope(expr.id), expr.span);\n+                    }\n                 }\n+                _ => {}\n             }\n-            _ => {}\n         }\n     }\n \n@@ -489,7 +493,7 @@ fn constrain_call(rcx: @mut Rcx,\n     }\n \n     // as loop above, but for receiver\n-    for receiver.each |&r| {\n+    for receiver.iter().advance |&r| {\n         constrain_regions_in_type_of_node(\n             rcx, r.id, callee_region, r.span);\n         if implicitly_ref_args {\n@@ -871,9 +875,8 @@ pub mod guarantor {\n             rcx: @mut Rcx,\n             expr: @ast::expr,\n             sub_region: ty::Region,\n-            sup_region: Option<ty::Region>)\n-        {\n-            for sup_region.each |r| {\n+            sup_region: Option<ty::Region>) {\n+            for sup_region.iter().advance |r| {\n                 infallibly_mk_subr(rcx, true, expr.span, sub_region, *r);\n             }\n         }\n@@ -895,7 +898,7 @@ pub mod guarantor {\n         debug!(\"guarantor::for_by_ref(expr=%?, callee_scope=%?) category=%?\",\n                expr.id, callee_scope, expr_cat);\n         let minimum_lifetime = ty::re_scope(callee_scope);\n-        for expr_cat.guarantor.each |guarantor| {\n+        for expr_cat.guarantor.iter().advance |guarantor| {\n             mk_subregion_due_to_derefence(rcx, expr.span,\n                                           minimum_lifetime, *guarantor);\n         }\n@@ -1201,12 +1204,12 @@ pub mod guarantor {\n             ast::pat_ident(ast::bind_by_ref(_), _, opt_p) => {\n                 link(rcx, pat.span, pat.id, guarantor);\n \n-                for opt_p.each |p| {\n+                for opt_p.iter().advance |p| {\n                     link_ref_bindings_in_pat(rcx, *p, guarantor);\n                 }\n             }\n             ast::pat_ident(_, _, opt_p) => {\n-                for opt_p.each |p| {\n+                for opt_p.iter().advance |p| {\n                     link_ref_bindings_in_pat(rcx, *p, guarantor);\n                 }\n             }\n@@ -1245,7 +1248,7 @@ pub mod guarantor {\n                 };\n \n                 link_ref_bindings_in_pats(rcx, before, guarantor1);\n-                for slice.each |&p| {\n+                for slice.iter().advance |&p| {\n                     link_ref_bindings_in_pat(rcx, p, guarantor);\n                 }\n                 link_ref_bindings_in_pats(rcx, after, guarantor1);"}, {"sha": "a5cfa629cf09925fba7644cee626db7ac5a5b476", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -33,11 +33,11 @@ pub fn replace_bound_regions_in_fn_sig(\n {\n     let mut all_tys = ty::tys_in_fn_sig(fn_sig);\n \n-    for opt_self_ty.each |&self_ty| {\n+    for opt_self_ty.iter().advance |&self_ty| {\n         all_tys.push(self_ty);\n     }\n \n-    for opt_self_ty.each |&t| { all_tys.push(t) }\n+    for opt_self_ty.iter().advance |&t| { all_tys.push(t) }\n \n     debug!(\"replace_bound_regions_in_fn_sig(self_ty=%?, fn_sig=%s, \\\n             all_tys=%?)\",\n@@ -200,7 +200,7 @@ pub fn relate_nested_regions(\n      */\n \n     let mut the_stack = ~[];\n-    for opt_region.each |&r| { the_stack.push(r); }\n+    for opt_region.iter().advance |&r| { the_stack.push(r); }\n     walk_ty(tcx, &mut the_stack, ty, relate_op);\n \n     fn walk_ty(tcx: ty::ctxt,\n@@ -262,7 +262,7 @@ pub fn relate_free_regions(\n     for fn_sig.inputs.each |arg| {\n         all_tys.push(*arg);\n     }\n-    for self_ty.each |&t| {\n+    for self_ty.iter().advance |&t| {\n         all_tys.push(t);\n     }\n "}, {"sha": "737abc2f6b540e0ae683406f15672917db729bb7", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use core::prelude::*;\n+use core::iterator::IteratorUtil;\n \n use middle::resolve::Impl;\n use middle::ty::param_ty;\n@@ -273,8 +274,8 @@ fn lookup_vtable(vcx: &VtableContext,\n                         // same trait as trait_ref, we need to\n                         // unify it with trait_ref in order to get all\n                         // the ty vars sorted out.\n-                        for ty::impl_trait_ref(tcx, im.did).each |&of_trait_ref|\n-                        {\n+                        let r = ty::impl_trait_ref(tcx, im.did);\n+                        for r.iter().advance |&of_trait_ref| {\n                             if of_trait_ref.def_id != trait_ref.def_id { loop; }\n \n                             // At this point, we know that of_trait_ref is"}, {"sha": "d9ebaa2cb4a9c5b2cefd94bc5135ec60f0df2704", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -13,6 +13,7 @@\n // substitutions.\n \n use core::prelude::*;\n+use core::iterator::IteratorUtil;\n \n use middle::pat_util;\n use middle::ty;\n@@ -64,13 +65,16 @@ fn resolve_method_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::node_id) {\n     match fcx.inh.method_map.find(&id) {\n         None => {}\n         Some(mme) => {\n-            for resolve_type_vars_in_type(fcx, sp, mme.self_ty).each |t| {\n-                let method_map = fcx.ccx.method_map;\n-                let new_entry = method_map_entry { self_ty: *t, ..*mme };\n-                debug!(\"writeback::resolve_method_map_entry(id=%?, \\\n-                        new_entry=%?)\",\n-                       id, new_entry);\n-                method_map.insert(id, new_entry);\n+            {\n+                let r = resolve_type_vars_in_type(fcx, sp, mme.self_ty);\n+                for r.iter().advance |t| {\n+                    let method_map = fcx.ccx.method_map;\n+                    let new_entry = method_map_entry { self_ty: *t, ..*mme };\n+                    debug!(\"writeback::resolve_method_map_entry(id=%?, \\\n+                            new_entry=%?)\",\n+                           id, new_entry);\n+                    method_map.insert(id, new_entry);\n+                }\n             }\n         }\n     }\n@@ -220,13 +224,19 @@ fn visit_expr(e: @ast::expr, wbcx: @mut WbCtxt, v: wb_vt) {\n     resolve_type_vars_for_node(wbcx, e.span, e.id);\n \n     resolve_method_map_entry(wbcx.fcx, e.span, e.id);\n-    for e.get_callee_id().each |callee_id| {\n-        resolve_method_map_entry(wbcx.fcx, e.span, *callee_id);\n+    {\n+        let r = e.get_callee_id();\n+        for r.iter().advance |callee_id| {\n+            resolve_method_map_entry(wbcx.fcx, e.span, *callee_id);\n+        }\n     }\n \n     resolve_vtable_map_entry(wbcx.fcx, e.span, e.id);\n-    for e.get_callee_id().each |callee_id| {\n-        resolve_vtable_map_entry(wbcx.fcx, e.span, *callee_id);\n+    {\n+        let r = e.get_callee_id();\n+        for r.iter().advance |callee_id| {\n+            resolve_vtable_map_entry(wbcx.fcx, e.span, *callee_id);\n+        }\n     }\n \n     match e.node {\n@@ -327,7 +337,7 @@ pub fn resolve_type_vars_in_fn(fcx: @mut FnCtxt,\n     let wbcx = @mut WbCtxt { fcx: fcx, success: true };\n     let visit = mk_visitor();\n     (visit.visit_block)(blk, wbcx, visit);\n-    for self_info.each |self_info| {\n+    for self_info.iter().advance |self_info| {\n         resolve_type_vars_for_node(wbcx,\n                                    self_info.span,\n                                    self_info.self_id);"}, {"sha": "450fe96ec9a96c8a58d2d563391797c91f55469f", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -56,7 +56,6 @@ use util::ppaux::ty_to_str;\n \n use core::iterator::IteratorUtil;\n use core::hashmap::{HashMap, HashSet};\n-use core::old_iter;\n use core::result::Ok;\n use core::uint;\n use core::vec;\n@@ -213,7 +212,7 @@ impl CoherenceChecker {\n                 match item.node {\n                     item_impl(_, opt_trait, _, _) => {\n                         self.check_implementation(item,\n-                                                  old_iter::to_vec(&opt_trait));\n+                                                  opt_trait.iter().transform(|&x| x).collect());\n                     }\n                     _ => {\n                         // Nothing to do.\n@@ -808,7 +807,7 @@ impl CoherenceChecker {\n                 }\n \n                 // Check that we have implementations of every trait method\n-                for trait_refs.each |trait_ref| {\n+                for trait_refs.iter().advance |trait_ref| {\n                     let trait_did =\n                         self.trait_ref_to_trait_def_id(*trait_ref);\n                     self.please_check_that_trait_methods_are_implemented(\n@@ -821,7 +820,7 @@ impl CoherenceChecker {\n                 // methods are provided.  For each of those methods,\n                 // if a method of that name is not inherent to the\n                 // impl, use the provided definition in the trait.\n-                for trait_refs.each |trait_ref| {\n+                for trait_refs.iter().advance |trait_ref| {\n                     let trait_did =\n                         self.trait_ref_to_trait_def_id(*trait_ref);\n \n@@ -920,7 +919,7 @@ impl CoherenceChecker {\n             }\n \n             // Record all the trait methods.\n-            for associated_traits.each |trait_ref| {\n+            for associated_traits.iter().advance |trait_ref| {\n                 self.add_trait_method(trait_ref.def_id, *implementation);\n             }\n "}, {"sha": "7cb342b78f7fcd31e82b00db56f34d05693d42d6", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -31,6 +31,7 @@ are represented as `ty_param()` instances.\n */\n \n use core::prelude::*;\n+use core::iterator::IteratorUtil;\n \n use metadata::csearch;\n use middle::ty::{substs, ty_param_bounds_and_ty};\n@@ -579,10 +580,10 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     // For both the trait and the impl, create an argument to\n     // represent the self argument (unless this is a static method).\n     // This argument will have the *transformed* self type.\n-    for trait_m.transformed_self_ty.each |&t| {\n+    for trait_m.transformed_self_ty.iter().advance |&t| {\n         trait_fn_args.push(t);\n     }\n-    for impl_m.transformed_self_ty.each |&t| {\n+    for impl_m.transformed_self_ty.iter().advance |&t| {\n         impl_fn_args.push(t);\n     }\n \n@@ -867,7 +868,7 @@ pub fn convert(ccx: &CrateCtxt, it: @ast::item) {\n         let cms = convert_methods(ccx, *ms, selfty,\n                                   &i_ty_generics, generics,\n                                   parent_visibility);\n-        for opt_trait_ref.each |t| {\n+        for opt_trait_ref.iter().advance |t| {\n             check_methods_against_trait(ccx, generics, rp, selfty, *t, cms);\n         }\n       }"}, {"sha": "7ab51c36cf858465402c744c91d62c4215d277be", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -269,6 +269,7 @@ use util::ppaux::{bound_region_to_str, ty_to_str, trait_ref_to_str};\n \n use core::result;\n use core::vec;\n+use core::iterator::IteratorUtil;\n use extra::list::Nil;\n use extra::smallintmap::SmallIntMap;\n use syntax::ast::{m_imm, m_mutbl};\n@@ -766,7 +767,7 @@ impl InferCtxt {\n                         fmt!(\"%s%s\", mk_msg(Some(self.ty_to_str(e)), actual_ty), error_str));\n                 }\n             }\n-            for err.each |err| {\n+            for err.iter().advance |err| {\n                 ty::note_and_explain_type_err(self.tcx, *err)\n             }\n         }"}, {"sha": "59f44c3c1f9c796fdb6dc126580cabaf11645d54", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -32,6 +32,7 @@ use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n \n+use core::iterator::IteratorUtil;\n use core::str;\n use core::vec;\n \n@@ -798,7 +799,7 @@ impl UserString for ty::TraitRef {\n         let base = ast_map::path_to_str(path, tcx.sess.intr());\n         if tcx.sess.verbose() && self.substs.self_ty.is_some() {\n             let mut all_tps = copy self.substs.tps;\n-            for self.substs.self_ty.each |&t| { all_tps.push(t); }\n+            for self.substs.self_ty.iter().advance |&t| { all_tps.push(t); }\n             parameterized(tcx, base, self.substs.self_r, all_tps)\n         } else {\n             parameterized(tcx, base, self.substs.self_r,"}, {"sha": "a4a392e4bbbe1d87cbf24a8c3a84ae1707dd47b5", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -131,7 +131,7 @@ impl PkgSrc {\n             return true;\n         }\n         else {\n-            for self_id.each |pth| {\n+            for self_id.iter().advance |pth| {\n                 if pth.starts_with(\"rust_\") // because p is already normalized\n                     && match p.filestem() {\n                            Some(s) => str::eq_slice(s, pth.slice(5, pth.len())),"}, {"sha": "387fa0d51d7e755390d919dae79dd629fbbc5ddc", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -346,14 +346,14 @@ impl Ctx {\n                target_exec.to_str(), target_lib,\n                maybe_executable, maybe_library);\n \n-        for maybe_executable.each |exec| {\n+        for maybe_executable.iter().advance |exec| {\n             debug!(\"Copying: %s -> %s\", exec.to_str(), target_exec.to_str());\n             if !(os::mkdir_recursive(&target_exec.dir_path(), u_rwx) &&\n                  os::copy_file(exec, &target_exec)) {\n                 cond.raise((copy *exec, copy target_exec));\n             }\n         }\n-        for maybe_library.each |lib| {\n+        for maybe_library.iter().advance |lib| {\n             let target_lib = (copy target_lib).expect(fmt!(\"I built %s but apparently \\\n                                                 didn't install it!\", lib.to_str()));\n             debug!(\"Copying: %s -> %s\", lib.to_str(), target_lib.to_str());"}, {"sha": "7a9435d2ecd0b969c9f809e893bfba7f3f406368", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -20,6 +20,7 @@ use cmp::{Eq, Equiv};\n use hash::Hash;\n use old_iter::BaseIter;\n use old_iter;\n+use iterator::{Iterator, IteratorUtil};\n use option::{None, Option, Some};\n use rand::RngUtil;\n use rand;\n@@ -316,7 +317,7 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     /// Visit all key-value pairs\n     fn each<'a>(&'a self, blk: &fn(&K, &'a V) -> bool) -> bool {\n         for self.buckets.each |bucket| {\n-            for bucket.each |pair| {\n+            for bucket.iter().advance |pair| {\n                 if !blk(&pair.key, &pair.value) {\n                     return false;\n                 }"}, {"sha": "bed74eba604ca9513b22a620980293c2b083fe0e", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -49,12 +49,12 @@ pub trait IteratorUtil<A> {\n     ///\n     /// let a = [0];\n     /// let b = [1];\n-    /// let mut it = a.iter().chain(b.iter());\n+    /// let mut it = a.iter().chain_(b.iter());\n     /// assert_eq!(it.next().get(), &0);\n     /// assert_eq!(it.next().get(), &1);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn chain<U: Iterator<A>>(self, other: U) -> ChainIterator<A, Self, U>;\n+    fn chain_<U: Iterator<A>>(self, other: U) -> ChainIterator<A, Self, U>;\n \n     /// Creates an iterator which iterates over both this and the specified\n     /// iterators simultaneously, yielding the two elements as pairs. When\n@@ -191,6 +191,7 @@ pub trait IteratorUtil<A> {\n     /// ~~~\n     fn skip(self, n: uint) -> SkipIterator<A, Self>;\n \n+    // FIXME: #5898: should be called take\n     /// Creates an iterator which yields the first `n` elements of this\n     /// iterator, and then it will always return None.\n     ///\n@@ -200,13 +201,13 @@ pub trait IteratorUtil<A> {\n     /// use std::iterator::*;\n     ///\n     /// let a = [1, 2, 3, 4, 5];\n-    /// let mut it = a.iter().take(3);\n+    /// let mut it = a.iter().take_(3);\n     /// assert_eq!(it.next().get(), &1);\n     /// assert_eq!(it.next().get(), &2);\n     /// assert_eq!(it.next().get(), &3);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn take(self, n: uint) -> TakeIterator<A, Self>;\n+    fn take_(self, n: uint) -> TakeIterator<A, Self>;\n \n     /// Creates a new iterator which behaves in a similar fashion to foldl.\n     /// There is a state which is passed between each iteration and can be\n@@ -337,10 +338,10 @@ pub trait IteratorUtil<A> {\n     ///\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n-    /// assert!(it.any(|&x| *x == 3));\n-    /// assert!(!it.any(|&x| *x == 3));\n+    /// assert!(it.any_(|&x| *x == 3));\n+    /// assert!(!it.any_(|&x| *x == 3));\n     /// ~~~\n-    fn any(&mut self, f: &fn(A) -> bool) -> bool;\n+    fn any_(&mut self, f: &fn(A) -> bool) -> bool;\n }\n \n /// Iterator adaptors provided for every `Iterator` implementation. The adaptor objects are also\n@@ -349,7 +350,7 @@ pub trait IteratorUtil<A> {\n /// In the future these will be default methods instead of a utility trait.\n impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     #[inline(always)]\n-    fn chain<U: Iterator<A>>(self, other: U) -> ChainIterator<A, T, U> {\n+    fn chain_<U: Iterator<A>>(self, other: U) -> ChainIterator<A, T, U> {\n         ChainIterator{a: self, b: other, flag: false}\n     }\n \n@@ -394,8 +395,9 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n         SkipIterator{iter: self, n: n}\n     }\n \n+    // FIXME: #5898: should be called take\n     #[inline(always)]\n-    fn take(self, n: uint) -> TakeIterator<A, T> {\n+    fn take_(self, n: uint) -> TakeIterator<A, T> {\n         TakeIterator{iter: self, n: n}\n     }\n \n@@ -467,7 +469,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     }\n \n     #[inline(always)]\n-    fn any(&mut self, f: &fn(A) -> bool) -> bool {\n+    fn any_(&mut self, f: &fn(A) -> bool) -> bool {\n         for self.advance |x| { if f(x) { return true; } }\n         return false;\n     }\n@@ -878,7 +880,7 @@ mod tests {\n \n     #[test]\n     fn test_counter_from_iter() {\n-        let mut it = Counter::new(0, 5).take(10);\n+        let mut it = Counter::new(0, 5).take_(10);\n         let xs: ~[int] = iter::FromIter::from_iter::<int, ~[int]>(|f| it.advance(f));\n         assert_eq!(xs, ~[0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n     }\n@@ -888,16 +890,16 @@ mod tests {\n         let xs = [0u, 1, 2, 3, 4, 5];\n         let ys = [30u, 40, 50, 60];\n         let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n-        let mut it = xs.iter().chain(ys.iter());\n+        let mut it = xs.iter().chain_(ys.iter());\n         let mut i = 0;\n         for it.advance |&x| {\n             assert_eq!(x, expected[i]);\n             i += 1;\n         }\n         assert_eq!(i, expected.len());\n \n-        let ys = Counter::new(30u, 10).take(4);\n-        let mut it = xs.iter().transform(|&x| x).chain(ys);\n+        let ys = Counter::new(30u, 10).take_(4);\n+        let mut it = xs.iter().transform(|&x| x).chain_(ys);\n         let mut i = 0;\n         for it.advance |x| {\n             assert_eq!(x, expected[i]);\n@@ -908,7 +910,7 @@ mod tests {\n \n     #[test]\n     fn test_filter_map() {\n-        let mut it = Counter::new(0u, 1u).take(10)\n+        let mut it = Counter::new(0u, 1u).take_(10)\n             .filter_map(|x| if x.is_even() { Some(x*x) } else { None });\n         assert_eq!(it.collect::<~[uint]>(), ~[0*0, 2*2, 4*4, 6*6, 8*8]);\n     }\n@@ -965,7 +967,7 @@ mod tests {\n     fn test_iterator_take() {\n         let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n         let ys = [0u, 1, 2, 3, 5];\n-        let mut it = xs.iter().take(5);\n+        let mut it = xs.iter().take_(5);\n         let mut i = 0;\n         for it.advance |&x| {\n             assert_eq!(x, ys[i]);\n@@ -1088,9 +1090,9 @@ mod tests {\n     #[test]\n     fn test_any() {\n         let v = ~&[1, 2, 3, 4, 5];\n-        assert!(v.iter().any(|&x| x < 10));\n-        assert!(v.iter().any(|&x| x.is_even()));\n-        assert!(!v.iter().any(|&x| x > 100));\n-        assert!(!v.slice(0, 0).iter().any(|_| fail!()));\n+        assert!(v.iter().any_(|&x| x < 10));\n+        assert!(v.iter().any_(|&x| x.is_even()));\n+        assert!(!v.iter().any_(|&x| x > 100));\n+        assert!(!v.slice(0, 0).iter().any_(|_| fail!()));\n     }\n }"}, {"sha": "80f4fb7643c8081b908f3fe4a13a7811affa3d72", "filename": "src/libstd/option.rs", "status": "modified", "additions": 41, "deletions": 45, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -46,12 +46,12 @@ use ops::Add;\n use kinds::Copy;\n use util;\n use num::Zero;\n-use old_iter::{BaseIter, MutableIter, ExtendedIter};\n-use old_iter;\n+use iterator::Iterator;\n use str::StrSlice;\n use clone::DeepClone;\n \n #[cfg(test)] use str;\n+#[cfg(test)] use iterator::IteratorUtil;\n \n /// The option type\n #[deriving(Clone, DeepClone, Eq)]\n@@ -100,53 +100,27 @@ impl<T: Copy + Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n     }\n }\n \n-impl<T> BaseIter<T> for Option<T> {\n-    /// Performs an operation on the contained value by reference\n-    #[inline(always)]\n-    fn each<'a>(&'a self, f: &fn(x: &'a T) -> bool) -> bool {\n-        match *self { None => true, Some(ref t) => { f(t) } }\n-    }\n-\n-    #[inline(always)]\n-    fn size_hint(&self) -> Option<uint> {\n-        if self.is_some() { Some(1) } else { Some(0) }\n-    }\n-}\n-\n-impl<T> MutableIter<T> for Option<T> {\n-    #[inline(always)]\n-    fn each_mut<'a>(&'a mut self, f: &fn(&'a mut T) -> bool) -> bool {\n-        match *self { None => true, Some(ref mut t) => { f(t) } }\n+impl<T> Option<T> {\n+    /// Return an iterator over the possibly contained value\n+    #[inline]\n+    pub fn iter<'r>(&'r self) -> OptionIterator<'r, T> {\n+        match *self {\n+            Some(ref x) => OptionIterator{opt: Some(x)},\n+            None => OptionIterator{opt: None}\n+        }\n     }\n-}\n \n-impl<A> ExtendedIter<A> for Option<A> {\n-    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) -> bool {\n-        old_iter::eachi(self, blk)\n-    }\n-    pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n-        old_iter::all(self, blk)\n-    }\n-    pub fn any(&self, blk: &fn(&A) -> bool) -> bool {\n-        old_iter::any(self, blk)\n-    }\n-    pub fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n-        old_iter::foldl(self, b0, blk)\n-    }\n-    pub fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n-        old_iter::position(self, f)\n-    }\n-    fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n-        old_iter::map_to_vec(self, op)\n-    }\n-    fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n-        -> ~[B] {\n-        old_iter::flat_map_to_vec(self, op)\n+    /// Return a mutable iterator over the possibly contained value\n+    #[inline]\n+    pub fn mut_iter<'r>(&'r mut self) -> OptionMutIterator<'r, T> {\n+        match *self {\n+            Some(ref mut x) => OptionMutIterator{opt: Some(x)},\n+            None => OptionMutIterator{opt: None}\n+        }\n     }\n-}\n \n-impl<T> Option<T> {\n     /// Returns true if the option equals `none`\n+    #[inline]\n     pub fn is_none(&const self) -> bool {\n         match *self { None => true, Some(_) => false }\n     }\n@@ -376,6 +350,28 @@ impl<T:Copy + Zero> Option<T> {\n     }\n }\n \n+/// Immutable iterator over an `Option<A>`\n+pub struct OptionIterator<'self, A> {\n+    priv opt: Option<&'self A>\n+}\n+\n+impl<'self, A> Iterator<&'self A> for OptionIterator<'self, A> {\n+    fn next(&mut self) -> Option<&'self A> {\n+        util::replace(&mut self.opt, None)\n+    }\n+}\n+\n+/// Mutable iterator over an `Option<A>`\n+pub struct OptionMutIterator<'self, A> {\n+    priv opt: Option<&'self mut A>\n+}\n+\n+impl<'self, A> Iterator<&'self mut A> for OptionMutIterator<'self, A> {\n+    fn next(&mut self) -> Option<&'self mut A> {\n+        util::replace(&mut self.opt, None)\n+    }\n+}\n+\n #[test]\n fn test_unwrap_ptr() {\n     unsafe {\n@@ -429,7 +425,7 @@ fn test_option_dance() {\n     let x = Some(());\n     let mut y = Some(5);\n     let mut y2 = 0;\n-    for x.each |_x| {\n+    for x.iter().advance |_x| {\n         y2 = y.swap_unwrap();\n     }\n     assert_eq!(y2, 5);"}, {"sha": "66993fb90996319cf4219f863a26b2430b8b5df3", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -1574,7 +1574,7 @@ mod tests {\n         setenv(\"HOME\", \"\");\n         assert!(os::homedir().is_none());\n \n-        for oldhome.each |s| { setenv(\"HOME\", *s) }\n+        for oldhome.iter().advance |s| { setenv(\"HOME\", *s) }\n     }\n \n     #[test]"}, {"sha": "6b2fecc500180796aa6c47c13016c0af87480341", "filename": "src/libstd/run.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -176,9 +176,9 @@ impl Process {\n                                    in_fd, out_fd, err_fd);\n \n         unsafe {\n-            for in_pipe.each  |pipe| { libc::close(pipe.in); }\n-            for out_pipe.each |pipe| { libc::close(pipe.out); }\n-            for err_pipe.each |pipe| { libc::close(pipe.out); }\n+            for in_pipe.iter().advance  |pipe| { libc::close(pipe.in); }\n+            for out_pipe.iter().advance |pipe| { libc::close(pipe.out); }\n+            for err_pipe.iter().advance |pipe| { libc::close(pipe.out); }\n         }\n \n         Process {\n@@ -323,7 +323,7 @@ impl Process {\n      * If the child has already been finished then the exit code is returned.\n      */\n     pub fn finish(&mut self) -> int {\n-        for self.exit_code.each |&code| {\n+        for self.exit_code.iter().advance |&code| {\n             return code;\n         }\n         self.close_input();\n@@ -523,7 +523,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n         CloseHandle(si.hStdOutput);\n         CloseHandle(si.hStdError);\n \n-        for create_err.each |msg| {\n+        for create_err.iter().advance |msg| {\n             fail!(\"failure in CreateProcess: %s\", *msg);\n         }\n \n@@ -589,7 +589,7 @@ pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n     return cmd;\n \n     fn append_arg(cmd: &mut ~str, arg: &str) {\n-        let quote = arg.iter().any(|c| c == ' ' || c == '\\t');\n+        let quote = arg.iter().any_(|c| c == ' ' || c == '\\t');\n         if quote {\n             cmd.push_char('\"');\n         }"}, {"sha": "780e9d6d923ed22a8f662832d24fccf02a474eba", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -92,6 +92,7 @@ use uint;\n use util;\n use unstable::sync::{Exclusive, exclusive};\n use rt::local::Local;\n+use iterator::{Iterator, IteratorUtil};\n \n #[cfg(test)] use task::default_task_opts;\n #[cfg(test)] use comm;\n@@ -276,7 +277,7 @@ fn each_ancestor(list:        &mut AncestorList,\n                  * Step 3: Maybe unwind; compute return info for our caller.\n                  *##########################################################*/\n                 if need_unwind && !nobe_is_dead {\n-                    for bail_opt.each |bail_blk| {\n+                    for bail_opt.iter().advance |bail_blk| {\n                         do with_parent_tg(&mut nobe.parent_group) |tg_opt| {\n                             (*bail_blk)(tg_opt)\n                         }\n@@ -328,7 +329,7 @@ impl Drop for TCB {\n \n             // If we are failing, the whole taskgroup needs to die.\n             if rt::rust_task_is_unwinding(self.me) {\n-                for this.notifier.each_mut |x| {\n+                for this.notifier.mut_iter().advance |x| {\n                     x.failed = true;\n                 }\n                 // Take everybody down with us.\n@@ -357,7 +358,7 @@ fn TCB(me: *rust_task,\n        ancestors: AncestorList,\n        is_main: bool,\n        mut notifier: Option<AutoNotify>) -> TCB {\n-    for notifier.each_mut |x| {\n+    for notifier.mut_iter().advance |x| {\n         x.failed = false;\n     }\n "}, {"sha": "8a6f58d7992e968d2b6581699961d68c1639fd85", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -76,8 +76,8 @@ debug!(\"hello, %s!\", \"world\");\n \n */\n \n-use cmp::Eq;\n use prelude::*;\n+use iterator::IteratorUtil;\n \n /*\n  * We have a 'ct' (compile-time) module that parses format strings into a\n@@ -607,7 +607,7 @@ pub mod rt {\n         let headsize = match head { Some(_) => 1, _ => 0 };\n         let uwidth : uint = match cv.width {\n             CountImplied => {\n-                for head.each |&c| {\n+                for head.iter().advance |&c| {\n                     buf.push_char(c);\n                 }\n                 return buf.push_str(s);\n@@ -616,15 +616,15 @@ pub mod rt {\n         };\n         let strlen = str::char_len(s) + headsize;\n         if uwidth <= strlen {\n-            for head.each |&c| {\n+            for head.iter().advance |&c| {\n                 buf.push_char(c);\n             }\n             return buf.push_str(s);\n         }\n         let mut padchar = ' ';\n         let diff = uwidth - strlen;\n         if have_flag(cv.flags, flag_left_justify) {\n-            for head.each |&c| {\n+            for head.iter().advance |&c| {\n                 buf.push_char(c);\n             }\n             buf.push_str(s);\n@@ -658,7 +658,7 @@ pub mod rt {\n         // instead.\n \n         if signed && zero_padding {\n-            for head.each |&head| {\n+            for head.iter().advance |&head| {\n                 if head == '+' || head == '-' || head == ' ' {\n                     buf.push_char(head);\n                     buf.push_str(padstr);\n@@ -668,7 +668,7 @@ pub mod rt {\n             }\n         }\n         buf.push_str(padstr);\n-        for head.each |&c| {\n+        for head.iter().advance |&c| {\n             buf.push_char(c);\n         }\n         buf.push_str(s);"}, {"sha": "42bba6d6aea76875aae4eb254b8847670fb1f648", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -22,6 +22,7 @@ use print::pprust;\n use visit;\n use syntax::parse::token::special_idents;\n \n+use core::iterator::IteratorUtil;\n use core::cmp;\n use core::hashmap::HashMap;\n use core::vec;\n@@ -317,8 +318,11 @@ pub fn map_struct_def(\n pub fn map_expr(ex: @expr, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     cx.map.insert(ex.id, node_expr(ex));\n     // Expressions which are or might be calls:\n-    for ex.get_callee_id().each |callee_id| {\n-        cx.map.insert(*callee_id, node_callee_scope(ex));\n+    {\n+        let r = ex.get_callee_id();\n+        for r.iter().advance |callee_id| {\n+            cx.map.insert(*callee_id, node_callee_scope(ex));\n+        }\n     }\n     visit::visit_expr(ex, cx, v);\n }"}, {"sha": "c531f2ca5503fa4db5e692c8fa7245c8f1f080a2", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -24,6 +24,7 @@ use core::hashmap::HashMap;\n use core::int;\n use core::option;\n use core::to_bytes;\n+use core::iterator::IteratorUtil;\n \n pub fn path_name_i(idents: &[ident]) -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n@@ -461,8 +462,11 @@ pub fn id_visitor<T: Copy>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n         },\n \n         visit_expr: |e, t, vt| {\n-            for e.get_callee_id().each |callee_id| {\n-                vfn(*callee_id, t);\n+            {\n+                let r = e.get_callee_id();\n+                for r.iter().advance |callee_id| {\n+                    vfn(*callee_id, t);\n+                }\n             }\n             vfn(e.id, t);\n             visit::visit_expr(e, t, vt);\n@@ -553,8 +557,8 @@ pub fn walk_pat(pat: @pat, it: &fn(@pat) -> bool) -> bool {\n         }\n         pat_vec(ref before, ref slice, ref after) => {\n             before.each(|&p| walk_pat(p, it)) &&\n-                slice.each(|&p| walk_pat(p, it)) &&\n-                after.each(|&p| walk_pat(p, it))\n+                slice.iter().advance(|&p| walk_pat(p, it)) &&\n+                after.iter().advance(|&p| walk_pat(p, it))\n         }\n         pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, _, _) |\n         pat_enum(_, _) => {"}, {"sha": "1a2569ef78792e030ab25d46c1f753fe52fb407e", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use core::prelude::*;\n+use core::iterator::IteratorUtil;\n \n use codemap::{Pos, span};\n use codemap;\n@@ -304,7 +305,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n }\n \n fn print_macro_backtrace(cm: @codemap::CodeMap, sp: span) {\n-    for sp.expn_info.each |ei| {\n+    for sp.expn_info.iter().advance |ei| {\n         let ss = ei.callee.span.map_default(@~\"\", |span| @cm.span_to_str(*span));\n         print_diagnostic(*ss, note,\n                          fmt!(\"in expansion of %s!\", ei.callee.name));"}, {"sha": "96ea5ecf92cae0842aaa0d21467c4c9c50b3df4a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -384,7 +384,9 @@ pub fn new_name_finder() -> @Visitor<@mut ~[ast::ident]> {\n                         _ => ()\n                     }\n                     // visit optional subpattern of pat_ident:\n-                    for inner.each |subpat: &@ast::pat| { (v.visit_pat)(*subpat, ident_accum, v) }\n+                    for inner.iter().advance |subpat: &@ast::pat| {\n+                        (v.visit_pat)(*subpat, ident_accum, v)\n+                    }\n                 }\n                 // use the default traversal for non-pat_idents\n                 _ => visit::visit_pat(p,ident_accum,v)"}, {"sha": "b6459fe30a355b44048290d31e90300b9738265a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -34,6 +34,7 @@ use core::io;\n use core::str;\n use core::u64;\n use core::uint;\n+use core::iterator::IteratorUtil;\n \n // The @ps is stored here to prevent recursive type.\n pub enum ann_node<'self> {\n@@ -371,7 +372,7 @@ pub fn print_foreign_mod(s: @ps, nmod: &ast::foreign_mod,\n }\n \n pub fn print_opt_lifetime(s: @ps, lifetime: Option<@ast::Lifetime>) {\n-    for lifetime.each |l| {\n+    for lifetime.iter().advance |l| {\n         print_lifetime(s, *l);\n         nbsp(s);\n     }\n@@ -1213,7 +1214,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         print_block(s, blk);\n       }\n       ast::expr_loop(ref blk, opt_ident) => {\n-        for opt_ident.each |ident| {\n+        for opt_ident.iter().advance |ident| {\n             word(s.s, \"'\");\n             print_ident(s, *ident);\n             word_space(s, \":\");\n@@ -1362,7 +1363,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n       ast::expr_break(opt_ident) => {\n         word(s.s, \"break\");\n         space(s.s);\n-        for opt_ident.each |ident| {\n+        for opt_ident.iter().advance |ident| {\n             word(s.s, \"'\");\n             print_ident(s, *ident);\n             space(s.s);\n@@ -1371,7 +1372,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n       ast::expr_again(opt_ident) => {\n         word(s.s, \"loop\");\n         space(s.s);\n-        for opt_ident.each |ident| {\n+        for opt_ident.iter().advance |ident| {\n             word(s.s, \"'\");\n             print_ident(s, *ident);\n             space(s.s)\n@@ -1498,7 +1499,7 @@ pub fn print_path(s: @ps, path: @ast::Path, colons_before_params: bool) {\n         if path.rp.is_some() || !path.types.is_empty() {\n             word(s.s, \"<\");\n \n-            for path.rp.each |r| {\n+            for path.rp.iter().advance |r| {\n                 print_lifetime(s, *r);\n                 if !path.types.is_empty() {\n                     word_space(s, \",\");\n@@ -1613,7 +1614,7 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n         do commasep(s, inconsistent, *before) |s, p| {\n             print_pat(s, p, refutable);\n         }\n-        for slice.each |&p| {\n+        for slice.iter().advance |&p| {\n             if !before.is_empty() { word_space(s, \",\"); }\n             word(s.s, \"..\");\n             print_pat(s, p, refutable);\n@@ -1675,7 +1676,7 @@ pub fn print_fn_args(s: @ps, decl: &ast::fn_decl,\n     // self type and the args all in the same box.\n     box(s, 0u, inconsistent);\n     let mut first = true;\n-    for opt_explicit_self.each |explicit_self| {\n+    for opt_explicit_self.iter().advance |explicit_self| {\n         first = !print_explicit_self(s, *explicit_self);\n     }\n \n@@ -1922,7 +1923,7 @@ pub fn print_ty_fn(s: @ps,\n     // self type and the args all in the same box.\n     box(s, 0u, inconsistent);\n     let mut first = true;\n-    for opt_explicit_self.each |explicit_self| {\n+    for opt_explicit_self.iter().advance |explicit_self| {\n         first = !print_explicit_self(s, *explicit_self);\n     }\n     for decl.inputs.each |arg| {"}, {"sha": "4e4330c3c1bc57eb4bbc87867c0e4ab742c85110", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use core::prelude::*;\n+use core::iterator::IteratorUtil;\n \n use abi::AbiSet;\n use ast::*;\n@@ -189,7 +190,7 @@ pub fn visit_item<E: Copy>(i: @item, e: E, v: vt<E>) {\n         }\n         item_impl(ref tps, ref traits, ty, ref methods) => {\n             (v.visit_generics)(tps, e, v);\n-            for traits.each |&p| {\n+            for traits.iter().advance |&p| {\n                 visit_trait_ref(p, e, v);\n             }\n             (v.visit_ty)(ty, e, v);\n@@ -227,7 +228,7 @@ pub fn visit_enum_def<E: Copy>(enum_definition: &ast::enum_def,\n             }\n         }\n         // Visit the disr expr if it exists\n-        for vr.node.disr_expr.each |ex| { (v.visit_expr)(*ex, e, v) }\n+        for vr.node.disr_expr.iter().advance |ex| { (v.visit_expr)(*ex, e, v) }\n     }\n }\n \n@@ -269,8 +270,8 @@ pub fn visit_pat<E: Copy>(p: @pat, e: E, v: vt<E>) {\n     match p.node {\n         pat_enum(path, ref children) => {\n             visit_path(path, e, v);\n-            for children.each |children| {\n-                for children.each |child| { (v.visit_pat)(*child, e, v); }\n+            for children.iter().advance |children| {\n+                for children.iter().advance |child| { (v.visit_pat)(*child, e, v); }\n             }\n         }\n         pat_struct(path, ref fields, _) => {\n@@ -289,7 +290,7 @@ pub fn visit_pat<E: Copy>(p: @pat, e: E, v: vt<E>) {\n         },\n         pat_ident(_, path, ref inner) => {\n             visit_path(path, e, v);\n-            for inner.each |subpat| { (v.visit_pat)(*subpat, e, v) }\n+            for inner.iter().advance |subpat| { (v.visit_pat)(*subpat, e, v) }\n         }\n         pat_lit(ex) => (v.visit_expr)(ex, e, v),\n         pat_range(e1, e2) => {\n@@ -301,7 +302,7 @@ pub fn visit_pat<E: Copy>(p: @pat, e: E, v: vt<E>) {\n             for before.each |elt| {\n                 (v.visit_pat)(*elt, e, v);\n             }\n-            for slice.each |elt| {\n+            for slice.iter().advance |elt| {\n                 (v.visit_pat)(*elt, e, v);\n             }\n             for after.each |tail| {\n@@ -550,7 +551,7 @@ pub fn visit_expr<E: Copy>(ex: @expr, e: E, v: vt<E>) {\n }\n \n pub fn visit_arm<E: Copy>(a: &arm, e: E, v: vt<E>) {\n-    for a.pats.each |p| { (v.visit_pat)(*p, e, v); }\n+    for a.pats.iter().advance |p| { (v.visit_pat)(*p, e, v); }\n     visit_expr_opt(a.guard, e, v);\n     (v.visit_block)(&a.body, e, v);\n }"}, {"sha": "bc3065fb2e6ba01c7e32de87067e5ec10aba421e", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -112,7 +112,7 @@ fn gen_search_keys(graph: &[~[node_id]], n: uint) -> ~[node_id] {\n     while keys.len() < n {\n         let k = r.gen_uint_range(0u, graph.len());\n \n-        if graph[k].len() > 0u && graph[k].iter().any(|i| {\n+        if graph[k].len() > 0u && graph[k].iter().any_(|i| {\n             *i != k as node_id\n         }) {\n             keys.insert(k as node_id);\n@@ -188,7 +188,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n     }\n \n     let mut i = 0;\n-    while colors.iter().any(is_gray) {\n+    while colors.iter().any_(is_gray) {\n         // Do the BFS.\n         info!(\"PBFS iteration %?\", i);\n         i += 1;"}, {"sha": "be575f64462bed3f67df3bc907a221a53ec3170d", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -21,28 +21,28 @@ pub fn main() {\n     }\n \n     // Usable at all:\n-    let mut any_negative = do v.iter().any |e| { e.is_negative() };\n+    let mut any_negative = do v.iter().any_ |e| { e.is_negative() };\n     assert!(any_negative);\n \n     // Higher precedence than assignments:\n-    any_negative = do v.iter().any |e| { e.is_negative() };\n+    any_negative = do v.iter().any_ |e| { e.is_negative() };\n     assert!(any_negative);\n \n     // Higher precedence than unary operations:\n     let abs_v = do vec::map(v) |e| { e.abs() };\n     assert!(do abs_v.iter().all |e| { e.is_positive() });\n-    assert!(!do abs_v.iter().any |e| { e.is_negative() });\n+    assert!(!do abs_v.iter().any_ |e| { e.is_negative() });\n \n     // Usable in funny statement-like forms:\n-    if !do v.iter().any |e| { e.is_positive() } {\n+    if !do v.iter().any_ |e| { e.is_positive() } {\n         assert!(false);\n     }\n     match do v.iter().all |e| { e.is_negative() } {\n         true => { fail!(\"incorrect answer.\"); }\n         false => { }\n     }\n     match 3 {\n-      _ if do v.iter().any |e| { e.is_negative() } => {\n+      _ if do v.iter().any_ |e| { e.is_negative() } => {\n       }\n       _ => {\n         fail!(\"wrong answer.\");\n@@ -59,7 +59,7 @@ pub fn main() {\n \n     // In the tail of a block\n     let w =\n-        if true { do abs_v.iter().any |e| { e.is_positive() } }\n+        if true { do abs_v.iter().any_ |e| { e.is_positive() } }\n       else { false };\n     assert!(w);\n }"}, {"sha": "2507c1d6def899cdaaed53edaa42827bf70de4ed", "filename": "src/test/run-pass/early-vtbl-resolution.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Ftest%2Frun-pass%2Fearly-vtbl-resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Ftest%2Frun-pass%2Fearly-vtbl-resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fearly-vtbl-resolution.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::old_iter;\n-\n trait thing<A> {\n     fn foo(&self) -> Option<A>;\n }\n@@ -21,10 +19,5 @@ fn foo_func<A, B: thing<A>>(x: B) -> Option<A> { x.foo() }\n struct A { a: int }\n \n pub fn main() {\n-\n-    for old_iter::eachi(&(Some(A {a: 0}))) |i, a| {\n-        debug!(\"%u %d\", i, a.a);\n-    }\n-\n     let _x: Option<float> = foo_func(0);\n }"}, {"sha": "b3177d1f84f2cc6222a3d86083fbcdc00707bec4", "filename": "src/test/run-pass/iter-all.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-all.rs?ref=1175e94de3b6d0f6b35fd8de3599b29267f1adab", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::old_iter;\n-\n-fn is_even(x: &uint) -> bool { (*x % 2) == 0 }\n-\n-pub fn main() {\n-    assert!(![1u, 2u].all(is_even));\n-    assert!([2u, 4u].all(is_even));\n-    assert!([].all(is_even));\n-\n-    assert!(!old_iter::all(&Some(1u), is_even));\n-    assert!(old_iter::all(&Some(2u), is_even));\n-    assert!(old_iter::all(&None::<uint>, is_even));\n-}"}, {"sha": "08a89f8dd226133ad3f54c0dc87a9f27d31d9acd", "filename": "src/test/run-pass/iter-any.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-any.rs?ref=1175e94de3b6d0f6b35fd8de3599b29267f1adab", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::old_iter;\n-\n-fn is_even(x: &uint) -> bool { (*x % 2) == 0 }\n-\n-pub fn main() {\n-    assert!(![1u, 3u].any(is_even));\n-    assert!([1u, 2u].any(is_even));\n-    assert!(![].any(is_even));\n-\n-    assert!(!old_iter::any(&Some(1u), is_even));\n-    assert!(old_iter::any(&Some(2u), is_even));\n-    assert!(!old_iter::any(&None::<uint>, is_even));\n-}"}, {"sha": "5034102c7307c43e8385f36206d04c63dc4dd38c", "filename": "src/test/run-pass/iter-contains.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-contains.rs?ref=1175e94de3b6d0f6b35fd8de3599b29267f1adab", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::old_iter;\n-\n-pub fn main() {\n-    assert_eq!([].contains(&22u), false);\n-    assert_eq!([1u, 3u].contains(&22u), false);\n-    assert_eq!([22u, 1u, 3u].contains(&22u), true);\n-    assert_eq!([1u, 22u, 3u].contains(&22u), true);\n-    assert_eq!([1u, 3u, 22u].contains(&22u), true);\n-    assert_eq!(old_iter::contains(&None::<uint>, &22u), false);\n-    assert_eq!(old_iter::contains(&Some(1u), &22u), false);\n-    assert_eq!(old_iter::contains(&Some(22u), &22u), true);\n-}"}, {"sha": "3f867e49bd43e594dc1bd3c29565b79ac42fa44c", "filename": "src/test/run-pass/iter-count.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-count.rs?ref=1175e94de3b6d0f6b35fd8de3599b29267f1adab", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::old_iter;\n-\n-pub fn main() {\n-    assert_eq!([].count(&22u), 0u);\n-    assert_eq!([1u, 3u].count(&22u), 0u);\n-    assert_eq!([22u, 1u, 3u].count(&22u), 1u);\n-    assert_eq!([22u, 1u, 22u].count(&22u), 2u);\n-    assert_eq!(old_iter::count(&None::<uint>, &22u), 0u);\n-    assert_eq!(old_iter::count(&Some(1u), &22u), 0u);\n-    assert_eq!(old_iter::count(&Some(22u), &22u), 1u);\n-}"}, {"sha": "0740f2cb8e46e10047a456314a87fc3d46ade32d", "filename": "src/test/run-pass/iter-eachi.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-eachi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-eachi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-eachi.rs?ref=1175e94de3b6d0f6b35fd8de3599b29267f1adab", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::old_iter;\n-\n-pub fn main() {\n-    let mut c = 0u;\n-    for [1u, 2u, 3u, 4u, 5u].eachi |i, v| {\n-        assert_eq!((i + 1u), *v);\n-        c += 1u;\n-    }\n-    assert_eq!(c, 5u);\n-\n-    for old_iter::eachi(&None::<uint>) |i, v| { fail!(); }\n-\n-    let mut c = 0u;\n-    for old_iter::eachi(&Some(1u)) |i, v| {\n-        assert_eq!((i + 1u), *v);\n-        c += 1u;\n-    }\n-    assert_eq!(c, 1u);\n-}"}, {"sha": "2b254765c763fe4d2d8b899ba426d8ff33ccbc7b", "filename": "src/test/run-pass/iter-filter-to-vec.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-filter-to-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-filter-to-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-filter-to-vec.rs?ref=1175e94de3b6d0f6b35fd8de3599b29267f1adab", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::old_iter;\n-\n-fn is_even(x: &uint) -> bool { (*x % 2) == 0 }\n-\n-pub fn main() {\n-    assert_eq!([1, 3].filter_to_vec(is_even), ~[]);\n-    assert_eq!([1, 2, 3].filter_to_vec(is_even), ~[2]);\n-    assert_eq!(old_iter::filter_to_vec(&None::<uint>, is_even), ~[]);\n-    assert_eq!(old_iter::filter_to_vec(&Some(1u), is_even), ~[]);\n-    assert_eq!(old_iter::filter_to_vec(&Some(2u), is_even), ~[2]);\n-}"}, {"sha": "b0b61aaa816c5a019bd3229a2ebb28881540ffde", "filename": "src/test/run-pass/iter-flat-map-to-vec.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-flat-map-to-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-flat-map-to-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-flat-map-to-vec.rs?ref=1175e94de3b6d0f6b35fd8de3599b29267f1adab", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::old_iter;\n-\n-fn repeat(x: &uint) -> ~[uint] { ~[*x, *x] }\n-\n-fn incd_if_even(x: &uint) -> Option<uint> {\n-    if (*x % 2u) == 0u {Some(*x + 1u)} else {None}\n-}\n-\n-pub fn main() {\n-    assert_eq!((~[1u, 3u]).flat_map_to_vec(repeat), ~[1u, 1u, 3u, 3u]);\n-    assert_eq!((~[]).flat_map_to_vec(repeat), ~[]);\n-    assert_eq!(old_iter::flat_map_to_vec(&None::<uint>, repeat), ~[]);\n-    assert_eq!(old_iter::flat_map_to_vec(&Some(1u), repeat), ~[1u, 1u]);\n-    assert_eq!(old_iter::flat_map_to_vec(&Some(2u), repeat), ~[2u, 2u]);\n-\n-    assert_eq!((~[1u, 2u, 5u]).flat_map_to_vec(incd_if_even), ~[3u]);\n-    assert_eq!((~[]).flat_map_to_vec(incd_if_even), ~[]);\n-    assert_eq!(old_iter::flat_map_to_vec(&None::<uint>, incd_if_even), ~[]);\n-    assert_eq!(old_iter::flat_map_to_vec(&Some(1u), incd_if_even), ~[]);\n-    assert_eq!(old_iter::flat_map_to_vec(&Some(2u), incd_if_even), ~[3u]);\n-}"}, {"sha": "7e5890b3e3a3306624fe9baaa75647a14ab75fbb", "filename": "src/test/run-pass/iter-foldl.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-foldl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-foldl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-foldl.rs?ref=1175e94de3b6d0f6b35fd8de3599b29267f1adab", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::old_iter;\n-\n-fn add(x: &float, y: &uint) -> float { *x + ((*y) as float) }\n-\n-pub fn main() {\n-    assert_eq!([1u, 3u].foldl(20f, add), 24f);\n-    assert_eq!([].foldl(20f, add), 20f);\n-    assert_eq!(old_iter::foldl(&None::<uint>, 20f, add), 20f);\n-    assert_eq!(old_iter::foldl(&Some(1u), 20f, add), 21f);\n-    assert_eq!(old_iter::foldl(&Some(2u), 20f, add), 22f);\n-}"}, {"sha": "706f0c5c150e1e5658231eb339d7e6232b68a5e4", "filename": "src/test/run-pass/iter-map-to-vec.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-map-to-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-map-to-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-map-to-vec.rs?ref=1175e94de3b6d0f6b35fd8de3599b29267f1adab", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::old_iter;\n-\n-fn inc(x: &uint) -> uint { *x + 1 }\n-\n-pub fn main() {\n-    assert_eq!([1, 3].map_to_vec(inc), ~[2, 4]);\n-    assert_eq!([1, 2, 3].map_to_vec(inc), ~[2, 3, 4]);\n-    assert_eq!(old_iter::map_to_vec(&None::<uint>, inc), ~[]);\n-    assert_eq!(old_iter::map_to_vec(&Some(1u), inc), ~[2]);\n-    assert_eq!(old_iter::map_to_vec(&Some(2u), inc), ~[3]);\n-}"}, {"sha": "9020976029d25700b46299a3eaac517680739ab9", "filename": "src/test/run-pass/iter-min-max.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-min-max.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-min-max.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-min-max.rs?ref=1175e94de3b6d0f6b35fd8de3599b29267f1adab", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::old_iter;\n-\n-fn is_even(x: uint) -> bool { (x % 2u) == 0u }\n-\n-pub fn main() {\n-    assert_eq!([1u, 3u].min(), 1u);\n-    assert_eq!([3u, 1u].min(), 1u);\n-    assert_eq!(old_iter::min(&Some(1u)), 1u);\n-\n-    assert_eq!([1u, 3u].max(), 3u);\n-    assert_eq!([3u, 1u].max(), 3u);\n-    assert_eq!(old_iter::max(&Some(3u)), 3u);\n-}"}, {"sha": "317b608963790e3edfa5082b604c1dd0187ec76e", "filename": "src/test/run-pass/iter-to-vec.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-to-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1175e94de3b6d0f6b35fd8de3599b29267f1adab/src%2Ftest%2Frun-pass%2Fiter-to-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-to-vec.rs?ref=1175e94de3b6d0f6b35fd8de3599b29267f1adab", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::old_iter;\n-\n-pub fn main() {\n-    assert_eq!([1u, 3u].to_vec(), ~[1u, 3u]);\n-    let e: ~[uint] = ~[];\n-    assert_eq!(e.to_vec(), ~[]);\n-    assert_eq!(old_iter::to_vec(&None::<uint>), ~[]);\n-    assert_eq!(old_iter::to_vec(&Some(1u)), ~[1u]);\n-    assert_eq!(old_iter::to_vec(&Some(2u)), ~[2u]);\n-}"}, {"sha": "ef1107803037fb200d3ccbd1b18b2f671c1826d5", "filename": "src/test/run-pass/test-ignore-cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f900dc7d1517bbc821989d68f3392d4aae96f93/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs?ref=3f900dc7d1517bbc821989d68f3392d4aae96f93", "patch": "@@ -31,8 +31,8 @@ fn checktests() {\n     let tests = __test::tests;\n \n     assert!(\n-        tests.iter().any(|t| t.desc.name.to_str() == ~\"shouldignore\" && t.desc.ignore));\n+        tests.iter().any_(|t| t.desc.name.to_str() == ~\"shouldignore\" && t.desc.ignore));\n \n     assert!(\n-        tests.iter().any(|t| t.desc.name.to_str() == ~\"shouldnotignore\" && !t.desc.ignore));\n+        tests.iter().any_(|t| t.desc.name.to_str() == ~\"shouldnotignore\" && !t.desc.ignore));\n }"}]}