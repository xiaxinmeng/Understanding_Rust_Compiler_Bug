{"sha": "cecffdc1d74718444b6654b120dcd57dcbad018f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlY2ZmZGMxZDc0NzE4NDQ0YjY2NTRiMTIwZGNkNTdkY2JhZDAxOGY=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-05-11T16:53:32Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-05-18T13:41:35Z"}, "message": "Fix const handling and add tests for const operands", "tree": {"sha": "1c05920507b1ac624311a3e3bea288a11a7e4cec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c05920507b1ac624311a3e3bea288a11a7e4cec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cecffdc1d74718444b6654b120dcd57dcbad018f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cecffdc1d74718444b6654b120dcd57dcbad018f", "html_url": "https://github.com/rust-lang/rust/commit/cecffdc1d74718444b6654b120dcd57dcbad018f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cecffdc1d74718444b6654b120dcd57dcbad018f/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f8be8cc8c826a4d2759e26c6514fcfcf076a105", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f8be8cc8c826a4d2759e26c6514fcfcf076a105", "html_url": "https://github.com/rust-lang/rust/commit/6f8be8cc8c826a4d2759e26c6514fcfcf076a105"}], "stats": {"total": 275, "additions": 184, "deletions": 91}, "files": [{"sha": "b487ed8dea8b69cf135a2ae5fb41f344012a35d4", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 128, "deletions": 91, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/cecffdc1d74718444b6654b120dcd57dcbad018f/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cecffdc1d74718444b6654b120dcd57dcbad018f/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=cecffdc1d74718444b6654b120dcd57dcbad018f", "patch": "@@ -13,6 +13,7 @@ use rustc_ast::ast;\n use rustc_hir::lang_items;\n use rustc_index::vec::Idx;\n use rustc_middle::mir;\n+use rustc_middle::mir::interpret::{AllocId, ConstValue, Pointer, Scalar};\n use rustc_middle::mir::AssertKind;\n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n@@ -821,6 +822,123 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             cleanup,\n         );\n     }\n+\n+    fn codegen_asm_terminator(\n+        &mut self,\n+        helper: TerminatorCodegenHelper<'tcx>,\n+        mut bx: Bx,\n+        terminator: &mir::Terminator<'tcx>,\n+        template: &[ast::InlineAsmTemplatePiece],\n+        operands: &[mir::InlineAsmOperand<'tcx>],\n+        options: ast::InlineAsmOptions,\n+        destination: Option<mir::BasicBlock>,\n+    ) {\n+        let span = terminator.source_info.span;\n+\n+        let operands: Vec<_> = operands\n+            .iter()\n+            .map(|op| match *op {\n+                mir::InlineAsmOperand::In { reg, ref value } => {\n+                    let value = self.codegen_operand(&mut bx, value);\n+                    InlineAsmOperandRef::In { reg, value }\n+                }\n+                mir::InlineAsmOperand::Out { reg, late, ref place } => {\n+                    let place = place.map(|place| self.codegen_place(&mut bx, place.as_ref()));\n+                    InlineAsmOperandRef::Out { reg, late, place }\n+                }\n+                mir::InlineAsmOperand::InOut { reg, late, ref in_value, ref out_place } => {\n+                    let in_value = self.codegen_operand(&mut bx, in_value);\n+                    let out_place =\n+                        out_place.map(|out_place| self.codegen_place(&mut bx, out_place.as_ref()));\n+                    InlineAsmOperandRef::InOut { reg, late, in_value, out_place }\n+                }\n+                mir::InlineAsmOperand::Const { ref value } => {\n+                    if let mir::Operand::Constant(constant) = value {\n+                        let const_value = self\n+                            .eval_mir_constant(constant)\n+                            .unwrap_or_else(|_| span_bug!(span, \"asm const cannot be resolved\"));\n+                        let ty = constant.literal.ty;\n+                        let size = bx.layout_of(ty).size;\n+                        let scalar = match const_value {\n+                            // Promoted constants are evaluated into a ByRef instead of a Scalar,\n+                            // but we want the scalar value here.\n+                            ConstValue::ByRef { alloc, offset } => {\n+                                let ptr = Pointer::new(AllocId(0), offset);\n+                                alloc\n+                                    .read_scalar(&bx, ptr, size)\n+                                    .and_then(|s| s.not_undef())\n+                                    .unwrap_or_else(|e| {\n+                                        bx.tcx().sess.span_err(\n+                                            span,\n+                                            &format!(\"Could not evaluate asm const: {}\", e),\n+                                        );\n+\n+                                        // We are erroring out, just emit a dummy constant.\n+                                        Scalar::from_u64(0)\n+                                    })\n+                            }\n+                            _ => span_bug!(span, \"expected ByRef for promoted asm const\"),\n+                        };\n+                        let value = scalar.assert_bits(size);\n+                        let string = match ty.kind {\n+                            ty::Uint(_) => value.to_string(),\n+                            ty::Int(int_ty) => {\n+                                match int_ty.normalize(bx.tcx().sess.target.ptr_width) {\n+                                    ast::IntTy::I8 => (value as i8).to_string(),\n+                                    ast::IntTy::I16 => (value as i16).to_string(),\n+                                    ast::IntTy::I32 => (value as i32).to_string(),\n+                                    ast::IntTy::I64 => (value as i64).to_string(),\n+                                    ast::IntTy::I128 => (value as i128).to_string(),\n+                                    ast::IntTy::Isize => unreachable!(),\n+                                }\n+                            }\n+                            ty::Float(ast::FloatTy::F32) => {\n+                                f32::from_bits(value as u32).to_string()\n+                            }\n+                            ty::Float(ast::FloatTy::F64) => {\n+                                f64::from_bits(value as u64).to_string()\n+                            }\n+                            _ => span_bug!(span, \"asm const has bad type {}\", ty),\n+                        };\n+                        InlineAsmOperandRef::Const { string }\n+                    } else {\n+                        span_bug!(span, \"asm const is not a constant\");\n+                    }\n+                }\n+                mir::InlineAsmOperand::SymFn { ref value } => {\n+                    let literal = self.monomorphize(&value.literal);\n+                    if let ty::FnDef(def_id, substs) = literal.ty.kind {\n+                        let instance = ty::Instance::resolve(\n+                            bx.tcx(),\n+                            ty::ParamEnv::reveal_all(),\n+                            def_id,\n+                            substs,\n+                        )\n+                        .unwrap()\n+                        .unwrap();\n+                        InlineAsmOperandRef::SymFn { instance }\n+                    } else {\n+                        span_bug!(span, \"invalid type for asm sym (fn)\");\n+                    }\n+                }\n+                mir::InlineAsmOperand::SymStatic { ref value } => {\n+                    if let Some(def_id) = value.check_static_ptr(bx.tcx()) {\n+                        InlineAsmOperandRef::SymStatic { def_id }\n+                    } else {\n+                        span_bug!(span, \"invalid type for asm sym (static)\");\n+                    }\n+                }\n+            })\n+            .collect();\n+\n+        bx.codegen_inline_asm(template, &operands, options, span);\n+\n+        if let Some(target) = destination {\n+            helper.funclet_br(self, &mut bx, target);\n+        } else {\n+            bx.unreachable();\n+        }\n+    }\n }\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n@@ -916,97 +1034,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 bug!(\"borrowck false edges in codegen\")\n             }\n \n-            mir::TerminatorKind::InlineAsm { template, ref operands, options, ref destination } => {\n-                let span = terminator.source_info.span;\n-\n-                let operands: Vec<_> = operands\n-                    .iter()\n-                    .map(|op| match *op {\n-                        mir::InlineAsmOperand::In { reg, ref value } => {\n-                            let value = self.codegen_operand(&mut bx, value);\n-                            InlineAsmOperandRef::In { reg, value }\n-                        }\n-                        mir::InlineAsmOperand::Out { reg, late, ref place } => {\n-                            let place =\n-                                place.map(|place| self.codegen_place(&mut bx, place.as_ref()));\n-                            InlineAsmOperandRef::Out { reg, late, place }\n-                        }\n-                        mir::InlineAsmOperand::InOut { reg, late, ref in_value, ref out_place } => {\n-                            let in_value = self.codegen_operand(&mut bx, in_value);\n-                            let out_place = out_place\n-                                .map(|out_place| self.codegen_place(&mut bx, out_place.as_ref()));\n-                            InlineAsmOperandRef::InOut { reg, late, in_value, out_place }\n-                        }\n-                        mir::InlineAsmOperand::Const { ref value } => {\n-                            if let mir::Operand::Constant(constant) = value {\n-                                let const_value =\n-                                    self.eval_mir_constant(constant).unwrap_or_else(|_| {\n-                                        span_bug!(span, \"asm const cannot be resolved\")\n-                                    });\n-                                let ty = constant.literal.ty;\n-                                let value = const_value\n-                                    .try_to_bits_for_ty(bx.tcx(), ty::ParamEnv::reveal_all(), ty)\n-                                    .unwrap_or_else(|| {\n-                                        span_bug!(span, \"asm const has non-scalar value\")\n-                                    });\n-                                let string = match ty.kind {\n-                                    ty::Uint(_) => value.to_string(),\n-                                    ty::Int(int_ty) => {\n-                                        match int_ty.normalize(bx.tcx().sess.target.ptr_width) {\n-                                            ast::IntTy::I8 => (value as i8).to_string(),\n-                                            ast::IntTy::I16 => (value as i16).to_string(),\n-                                            ast::IntTy::I32 => (value as i32).to_string(),\n-                                            ast::IntTy::I64 => (value as i64).to_string(),\n-                                            ast::IntTy::I128 => (value as i128).to_string(),\n-                                            ast::IntTy::Isize => unreachable!(),\n-                                        }\n-                                    }\n-                                    ty::Float(ast::FloatTy::F32) => {\n-                                        f32::from_bits(value as u32).to_string()\n-                                    }\n-                                    ty::Float(ast::FloatTy::F64) => {\n-                                        f64::from_bits(value as u64).to_string()\n-                                    }\n-                                    _ => span_bug!(span, \"asm const has bad type {}\", ty),\n-                                };\n-                                InlineAsmOperandRef::Const { string }\n-                            } else {\n-                                span_bug!(span, \"asm const is not a constant\");\n-                            }\n-                        }\n-                        mir::InlineAsmOperand::SymFn { ref value } => {\n-                            let literal = self.monomorphize(&value.literal);\n-                            if let ty::FnDef(def_id, substs) = literal.ty.kind {\n-                                let instance = ty::Instance::resolve(\n-                                    bx.tcx(),\n-                                    ty::ParamEnv::reveal_all(),\n-                                    def_id,\n-                                    substs,\n-                                )\n-                                .unwrap()\n-                                .unwrap();\n-                                InlineAsmOperandRef::SymFn { instance }\n-                            } else {\n-                                span_bug!(span, \"invalid type for asm sym (fn)\");\n-                            }\n-                        }\n-                        mir::InlineAsmOperand::SymStatic { ref value } => {\n-                            if let Some(def_id) = value.check_static_ptr(bx.tcx()) {\n-                                InlineAsmOperandRef::SymStatic { def_id }\n-                            } else {\n-                                span_bug!(span, \"invalid type for asm sym (static)\");\n-                            }\n-                        }\n-                    })\n-                    .collect();\n-\n-                bx.codegen_inline_asm(template, &operands, options, span);\n-\n-                if let Some(target) = destination {\n-                    helper.funclet_br(self, &mut bx, *target);\n-                } else {\n-                    bx.unreachable();\n-                }\n+            mir::TerminatorKind::InlineAsm { template, ref operands, options, destination } => {\n+                self.codegen_asm_terminator(\n+                    helper,\n+                    bx,\n+                    terminator,\n+                    template,\n+                    operands,\n+                    options,\n+                    destination,\n+                );\n             }\n         }\n     }"}, {"sha": "e08da24f44a22658a96053c328d4e74cd546264f", "filename": "src/test/ui/asm/const.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/cecffdc1d74718444b6654b120dcd57dcbad018f/src%2Ftest%2Fui%2Fasm%2Fconst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cecffdc1d74718444b6654b120dcd57dcbad018f/src%2Ftest%2Fui%2Fasm%2Fconst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fconst.rs?ref=cecffdc1d74718444b6654b120dcd57dcbad018f", "patch": "@@ -0,0 +1,56 @@\n+// no-system-llvm\n+// only-x86_64\n+// run-pass\n+\n+#![feature(asm)]\n+\n+use std::mem::size_of;\n+\n+trait Proj {\n+    const C: usize;\n+}\n+impl Proj for i8 {\n+    const C: usize = 8;\n+}\n+impl Proj for i16 {\n+    const C: usize = 16;\n+}\n+\n+const fn constfn(x: usize) -> usize {\n+    x\n+}\n+\n+fn generic<T: Proj>() {\n+    unsafe {\n+        let a: usize;\n+        asm!(\"mov {}, {}\", out(reg) a, const size_of::<T>());\n+        assert_eq!(a, size_of::<T>());\n+\n+        let b: usize;\n+        asm!(\"mov {}, {}\", out(reg) b, const size_of::<T>() + constfn(5));\n+        assert_eq!(b, size_of::<T>() + 5);\n+\n+        let c: usize;\n+        asm!(\"mov {}, {}\", out(reg) c, const T::C);\n+        assert_eq!(c, T::C);\n+    }\n+}\n+\n+fn main() {\n+    unsafe {\n+        let a: usize;\n+        asm!(\"mov {}, {}\", out(reg) a, const 5);\n+        assert_eq!(a, 5);\n+\n+        let b: usize;\n+        asm!(\"mov {}, {}\", out(reg) b, const constfn(5));\n+        assert_eq!(b, 5);\n+\n+        let c: usize;\n+        asm!(\"mov {}, {}\", out(reg) c, const constfn(5) + constfn(5));\n+        assert_eq!(c, 10);\n+    }\n+\n+    generic::<i8>();\n+    generic::<i16>();\n+}"}]}