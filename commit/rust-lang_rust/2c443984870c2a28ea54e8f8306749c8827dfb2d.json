{"sha": "2c443984870c2a28ea54e8f8306749c8827dfb2d", "node_id": "C_kwDOAAsO6NoAKDJjNDQzOTg0ODcwYzJhMjhlYTU0ZThmODMwNjc0OWM4ODI3ZGZiMmQ", "commit": {"author": {"name": "Samuel Moelius", "email": "sam@moeli.us", "date": "2022-10-30T10:47:35Z"}, "committer": {"name": "Samuel Moelius", "email": "sam@moeli.us", "date": "2022-10-30T10:47:35Z"}, "message": "Adress review comments", "tree": {"sha": "0ee7aaf4dc299da3cb2e4d7e34efe5429015bc22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ee7aaf4dc299da3cb2e4d7e34efe5429015bc22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c443984870c2a28ea54e8f8306749c8827dfb2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c443984870c2a28ea54e8f8306749c8827dfb2d", "html_url": "https://github.com/rust-lang/rust/commit/2c443984870c2a28ea54e8f8306749c8827dfb2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c443984870c2a28ea54e8f8306749c8827dfb2d/comments", "author": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "committer": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10b7fabbf36f1ab45c4d33357270d0557822ff90", "url": "https://api.github.com/repos/rust-lang/rust/commits/10b7fabbf36f1ab45c4d33357270d0557822ff90", "html_url": "https://github.com/rust-lang/rust/commit/10b7fabbf36f1ab45c4d33357270d0557822ff90"}], "stats": {"total": 376, "additions": 258, "deletions": 118}, "files": [{"sha": "36e75d45fd756fe7adc68d1fc3f5f217b1ab80f5", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 31, "deletions": 50, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/2c443984870c2a28ea54e8f8306749c8827dfb2d/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c443984870c2a28ea54e8f8306749c8827dfb2d/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=2c443984870c2a28ea54e8f8306749c8827dfb2d", "patch": "@@ -236,7 +236,6 @@ fn explicit_self_type<'tcx>(cx: &LateContext<'tcx>, func: &FnDecl<'tcx>, ident:\n     }\n }\n \n-#[expect(clippy::too_many_lines)]\n fn could_use_elision<'tcx>(\n     cx: &LateContext<'tcx>,\n     func: &'tcx FnDecl<'_>,\n@@ -331,50 +330,32 @@ fn could_use_elision<'tcx>(\n         }\n     }\n \n-    // no input lifetimes? easy case!\n-    if input_lts.is_empty() {\n-        None\n-    } else if output_lts.is_empty() {\n-        // no output lifetimes, check distinctness of input lifetimes\n+    // A lifetime can be newly elided if:\n+    // - It occurs only once among the inputs.\n+    // - If there are multiple input lifetimes, then the newly elided lifetime does not occur among the\n+    //   outputs (because eliding such an lifetime would create an ambiguity).\n+    let elidable_lts = named_lifetime_occurrences(&input_lts)\n+        .into_iter()\n+        .filter_map(|(def_id, occurrences)| {\n+            if occurrences <= 1 && (input_lts.len() <= 1 || !output_lts.contains(&RefLt::Named(def_id))) {\n+                Some((\n+                    def_id,\n+                    input_visitor\n+                        .lifetime_generic_arg_spans\n+                        .get(&def_id)\n+                        .or_else(|| output_visitor.lifetime_generic_arg_spans.get(&def_id))\n+                        .copied(),\n+                ))\n+            } else {\n+                None\n+            }\n+        })\n+        .collect::<Vec<_>>();\n \n-        // only unnamed and static, ok\n-        let unnamed_and_static = input_lts.iter().all(|lt| *lt == RefLt::Unnamed || *lt == RefLt::Static);\n-        if unnamed_and_static {\n-            return None;\n-        }\n-        // we have no output reference, so we can elide explicit lifetimes that occur at most once\n-        let elidable_lts = named_lifetime_occurrences(&input_lts)\n-            .into_iter()\n-            .filter_map(|(def_id, occurrences)| {\n-                if occurrences <= 1 {\n-                    Some((def_id, input_visitor.sample_generic_arg_span.get(&def_id).copied()))\n-                } else {\n-                    None\n-                }\n-            })\n-            .collect::<Vec<_>>();\n-        if elidable_lts.is_empty() {\n-            None\n-        } else {\n-            Some(elidable_lts)\n-        }\n+    if elidable_lts.is_empty() {\n+        None\n     } else {\n-        // we have output references, so we need one input reference,\n-        // and all output lifetimes must be the same\n-        if input_lts.len() == 1 {\n-            match (&input_lts[0], &output_lts[0]) {\n-                (&RefLt::Named(n1), &RefLt::Named(n2)) if n1 == n2 => {\n-                    Some(vec![(n1, input_visitor.sample_generic_arg_span.get(&n1).copied())])\n-                },\n-                (&RefLt::Named(n), &RefLt::Unnamed) => {\n-                    Some(vec![(n, input_visitor.sample_generic_arg_span.get(&n).copied())])\n-                },\n-                _ => None, /* already elided, different named lifetimes\n-                            * or something static going on */\n-            }\n-        } else {\n-            None\n-        }\n+        Some(elidable_lts)\n     }\n }\n \n@@ -397,11 +378,11 @@ fn named_lifetime_occurrences(lts: &[RefLt]) -> Vec<(LocalDefId, usize)> {\n     let mut occurrences = Vec::new();\n     for lt in lts {\n         if let &RefLt::Named(curr_def_id) = lt {\n-            if let Some(i) = occurrences\n-                .iter()\n-                .position(|&(prev_def_id, _)| prev_def_id == curr_def_id)\n+            if let Some(pair) = occurrences\n+                .iter_mut()\n+                .find(|(prev_def_id, _)| *prev_def_id == curr_def_id)\n             {\n-                occurrences[i].1 += 1;\n+                pair.1 += 1;\n             } else {\n                 occurrences.push((curr_def_id, 1));\n             }\n@@ -416,7 +397,7 @@ const CLOSURE_TRAIT_BOUNDS: [LangItem; 3] = [LangItem::Fn, LangItem::FnMut, Lang\n struct RefVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     lts: Vec<RefLt>,\n-    sample_generic_arg_span: FxHashMap<LocalDefId, Span>,\n+    lifetime_generic_arg_spans: FxHashMap<LocalDefId, Span>,\n     nested_elision_site_lts: Vec<RefLt>,\n     unelided_trait_object_lifetime: bool,\n }\n@@ -426,7 +407,7 @@ impl<'a, 'tcx> RefVisitor<'a, 'tcx> {\n         Self {\n             cx,\n             lts: Vec::new(),\n-            sample_generic_arg_span: FxHashMap::default(),\n+            lifetime_generic_arg_spans: FxHashMap::default(),\n             nested_elision_site_lts: Vec::new(),\n             unelided_trait_object_lifetime: false,\n         }\n@@ -525,7 +506,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n         if let GenericArg::Lifetime(l) = generic_arg\n             && let LifetimeName::Param(def_id, _) = l.name\n         {\n-            self.sample_generic_arg_span.entry(def_id).or_insert(l.span);\n+            self.lifetime_generic_arg_spans.entry(def_id).or_insert(l.span);\n         }\n         // Replace with `walk_generic_arg` if/when https://github.com/rust-lang/rust/pull/103692 lands.\n         // walk_generic_arg(self, generic_arg);"}, {"sha": "f587c69f7302d41ab7f10d3040e8d37ef9209dfd", "filename": "clippy_lints/src/matches/significant_drop_in_scrutinee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c443984870c2a28ea54e8f8306749c8827dfb2d/clippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c443984870c2a28ea54e8f8306749c8827dfb2d/clippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs?ref=2c443984870c2a28ea54e8f8306749c8827dfb2d", "patch": "@@ -83,8 +83,8 @@ fn set_diagnostic<'tcx>(diag: &mut Diagnostic, cx: &LateContext<'tcx>, expr: &'t\n \n /// If the expression is an `ExprKind::Match`, check if the scrutinee has a significant drop that\n /// may have a surprising lifetime.\n-fn has_significant_drop_in_scrutinee<'tcx, 'a>(\n-    cx: &'a LateContext<'tcx>,\n+fn has_significant_drop_in_scrutinee<'tcx>(\n+    cx: &LateContext<'tcx>,\n     scrutinee: &'tcx Expr<'tcx>,\n     source: MatchSource,\n ) -> Option<(Vec<FoundSigDrop>, &'static str)> {"}, {"sha": "7de15330594702cafa4baef7a41f4e058095caa1", "filename": "tests/ui/mut_from_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c443984870c2a28ea54e8f8306749c8827dfb2d/tests%2Fui%2Fmut_from_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c443984870c2a28ea54e8f8306749c8827dfb2d/tests%2Fui%2Fmut_from_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_from_ref.rs?ref=2c443984870c2a28ea54e8f8306749c8827dfb2d", "patch": "@@ -1,4 +1,4 @@\n-#![allow(unused)]\n+#![allow(unused, clippy::needless_lifetimes)]\n #![warn(clippy::mut_from_ref)]\n \n struct Foo;"}, {"sha": "2efc936752ef9071c7ce814128d1d9b91b87b97c", "filename": "tests/ui/needless_lifetimes.rs", "status": "modified", "additions": 79, "deletions": 11, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/2c443984870c2a28ea54e8f8306749c8827dfb2d/tests%2Fui%2Fneedless_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c443984870c2a28ea54e8f8306749c8827dfb2d/tests%2Fui%2Fneedless_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_lifetimes.rs?ref=2c443984870c2a28ea54e8f8306749c8827dfb2d", "patch": "@@ -29,11 +29,20 @@ fn multiple_in_and_out_1<'a>(x: &'a u8, _y: &'a u8) -> &'a u8 {\n     x\n }\n \n-// No error; multiple input refs.\n-fn multiple_in_and_out_2<'a, 'b>(x: &'a u8, _y: &'b u8) -> &'a u8 {\n+// Error; multiple input refs, but the output lifetime is not elided, i.e., the following is valid:\n+//   fn multiple_in_and_out_2a<'a>(x: &'a u8, _y: &u8) -> &'a u8\n+//                                                ^^^\n+fn multiple_in_and_out_2a<'a, 'b>(x: &'a u8, _y: &'b u8) -> &'a u8 {\n     x\n }\n \n+// Error; multiple input refs, but the output lifetime is not elided, i.e., the following is valid:\n+//   fn multiple_in_and_out_2b<'b>(_x: &u8, y: &'b u8) -> &'b u8\n+//                                     ^^^\n+fn multiple_in_and_out_2b<'a, 'b>(_x: &'a u8, y: &'b u8) -> &'b u8 {\n+    y\n+}\n+\n // No error; multiple input refs\n async fn func<'a>(args: &[&'a str]) -> Option<&'a str> {\n     args.get(0).cloned()\n@@ -44,11 +53,20 @@ fn in_static_and_out<'a>(x: &'a u8, _y: &'static u8) -> &'a u8 {\n     x\n }\n \n-// No error.\n-fn deep_reference_1<'a, 'b>(x: &'a u8, _y: &'b u8) -> Result<&'a u8, ()> {\n+// Error; multiple input refs, but the output lifetime is not elided, i.e., the following is valid:\n+//   fn deep_reference_1a<'a>(x: &'a u8, _y: &u8) -> Result<&'a u8, ()>\n+//                                           ^^^\n+fn deep_reference_1a<'a, 'b>(x: &'a u8, _y: &'b u8) -> Result<&'a u8, ()> {\n     Ok(x)\n }\n \n+// Error; multiple input refs, but the output lifetime is not elided, i.e., the following is valid:\n+//   fn deep_reference_1b<'b>(_x: &u8, y: &'b u8) -> Result<&'b u8, ()>\n+//                                ^^^\n+fn deep_reference_1b<'a, 'b>(_x: &'a u8, y: &'b u8) -> Result<&'b u8, ()> {\n+    Ok(y)\n+}\n+\n // No error; two input refs.\n fn deep_reference_2<'a>(x: Result<&'a u8, &'a u8>) -> &'a u8 {\n     x.unwrap()\n@@ -129,11 +147,20 @@ impl X {\n         &self.x\n     }\n \n-    // No error; multiple input refs.\n-    fn self_and_in_out<'s, 't>(&'s self, _x: &'t u8) -> &'s u8 {\n+    // Error; multiple input refs, but the output lifetime is not elided, i.e., the following is valid:\n+    //   fn self_and_in_out_1<'s>(&'s self, _x: &u8) -> &'s u8\n+    //                                          ^^^\n+    fn self_and_in_out_1<'s, 't>(&'s self, _x: &'t u8) -> &'s u8 {\n         &self.x\n     }\n \n+    // Error; multiple input refs, but the output lifetime is not elided, i.e., the following is valid:\n+    //   fn self_and_in_out_2<'t>(&self, x: &'t u8) -> &'t u8\n+    //                            ^^^^^\n+    fn self_and_in_out_2<'s, 't>(&'s self, x: &'t u8) -> &'t u8 {\n+        x\n+    }\n+\n     fn distinct_self_and_in<'s, 't>(&'s self, _x: &'t u8) {}\n \n     // No error; same lifetimes on two params.\n@@ -167,8 +194,19 @@ fn struct_with_lt3<'a>(_foo: &Foo<'a>) -> &'a str {\n     unimplemented!()\n }\n \n-// No warning; two input lifetimes.\n-fn struct_with_lt4<'a, 'b>(_foo: &'a Foo<'b>) -> &'a str {\n+// Warning; two input lifetimes, but the output lifetime is not elided, i.e., the following is\n+// valid:\n+//   fn struct_with_lt4a<'a>(_foo: &'a Foo<'_>) -> &'a str\n+//                                         ^^\n+fn struct_with_lt4a<'a, 'b>(_foo: &'a Foo<'b>) -> &'a str {\n+    unimplemented!()\n+}\n+\n+// Warning; two input lifetimes, but the output lifetime is not elided, i.e., the following is\n+// valid:\n+//   fn struct_with_lt4b<'b>(_foo: &Foo<'b>) -> &'b str\n+//                                 ^^^^\n+fn struct_with_lt4b<'a, 'b>(_foo: &'a Foo<'b>) -> &'b str {\n     unimplemented!()\n }\n \n@@ -203,8 +241,19 @@ fn alias_with_lt3<'a>(_foo: &FooAlias<'a>) -> &'a str {\n     unimplemented!()\n }\n \n-// No warning; two input lifetimes.\n-fn alias_with_lt4<'a, 'b>(_foo: &'a FooAlias<'b>) -> &'a str {\n+// Warning; two input lifetimes, but the output lifetime is not elided, i.e., the following is\n+// valid:\n+//   fn alias_with_lt4a<'a>(_foo: &'a FooAlias<'_>) -> &'a str\n+//                                             ^^\n+fn alias_with_lt4a<'a, 'b>(_foo: &'a FooAlias<'b>) -> &'a str {\n+    unimplemented!()\n+}\n+\n+// Warning; two input lifetimes, but the output lifetime is not elided, i.e., the following is\n+// valid:\n+//   fn alias_with_lt4b<'b>(_foo: &FooAlias<'b>) -> &'b str\n+//                                ^^^^^^^^^\n+fn alias_with_lt4b<'a, 'b>(_foo: &'a FooAlias<'b>) -> &'b str {\n     unimplemented!()\n }\n \n@@ -419,12 +468,31 @@ mod issue7296 {\n     }\n }\n \n-mod false_negative {\n+mod pr_9743_false_negative_fix {\n     #![allow(unused)]\n \n     fn foo<'a>(x: &'a u8, y: &'_ u8) {}\n \n     fn bar<'a>(x: &'a u8, y: &'_ u8, z: &'_ u8) {}\n }\n \n+mod pr_9743_output_lifetime_checks {\n+    #![allow(unused)]\n+\n+    // lint: only one input\n+    fn one_input<'a>(x: &'a u8) -> &'a u8 {\n+        unimplemented!()\n+    }\n+\n+    // lint: multiple inputs, output would not be elided\n+    fn multiple_inputs_output_not_elided<'a, 'b>(x: &'a u8, y: &'b u8, z: &'b u8) -> &'b u8 {\n+        unimplemented!()\n+    }\n+\n+    // don't lint: multiple inputs, output would be elided (which would create an ambiguity)\n+    fn multiple_inputs_output_would_be_elided<'a, 'b>(x: &'a u8, y: &'b u8, z: &'b u8) -> &'a u8 {\n+        unimplemented!()\n+    }\n+}\n+\n fn main() {}"}, {"sha": "5a7cf13c86dded256b80b69b5dbb75aa51e85318", "filename": "tests/ui/needless_lifetimes.stderr", "status": "modified", "additions": 125, "deletions": 35, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/2c443984870c2a28ea54e8f8306749c8827dfb2d/tests%2Fui%2Fneedless_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c443984870c2a28ea54e8f8306749c8827dfb2d/tests%2Fui%2Fneedless_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_lifetimes.stderr?ref=2c443984870c2a28ea54e8f8306749c8827dfb2d", "patch": "@@ -18,209 +18,299 @@ error: the following explicit lifetimes could be elided: 'a\n LL | fn in_and_out<'a>(x: &'a u8, _y: u8) -> &'a u8 {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: the following explicit lifetimes could be elided: 'b\n+  --> $DIR/needless_lifetimes.rs:35:1\n+   |\n+LL | fn multiple_in_and_out_2a<'a, 'b>(x: &'a u8, _y: &'b u8) -> &'a u8 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:57:1\n+  --> $DIR/needless_lifetimes.rs:42:1\n+   |\n+LL | fn multiple_in_and_out_2b<'a, 'b>(_x: &'a u8, y: &'b u8) -> &'b u8 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the following explicit lifetimes could be elided: 'b\n+  --> $DIR/needless_lifetimes.rs:59:1\n+   |\n+LL | fn deep_reference_1a<'a, 'b>(x: &'a u8, _y: &'b u8) -> Result<&'a u8, ()> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the following explicit lifetimes could be elided: 'a\n+  --> $DIR/needless_lifetimes.rs:66:1\n+   |\n+LL | fn deep_reference_1b<'a, 'b>(_x: &'a u8, y: &'b u8) -> Result<&'b u8, ()> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the following explicit lifetimes could be elided: 'a\n+  --> $DIR/needless_lifetimes.rs:75:1\n    |\n LL | fn deep_reference_3<'a>(x: &'a u8, _y: u8) -> Result<&'a u8, ()> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:62:1\n+  --> $DIR/needless_lifetimes.rs:80:1\n    |\n LL | fn where_clause_without_lt<'a, T>(x: &'a u8, _y: u8) -> Result<&'a u8, ()>\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a, 'b\n-  --> $DIR/needless_lifetimes.rs:74:1\n+  --> $DIR/needless_lifetimes.rs:92:1\n    |\n LL | fn lifetime_param_2<'a, 'b>(_x: Ref<'a>, _y: &'b u8) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: replace with `'_` in generic arguments such as here\n-  --> $DIR/needless_lifetimes.rs:74:37\n+  --> $DIR/needless_lifetimes.rs:92:37\n    |\n LL | fn lifetime_param_2<'a, 'b>(_x: Ref<'a>, _y: &'b u8) {}\n    |                                     ^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:98:1\n+  --> $DIR/needless_lifetimes.rs:116:1\n    |\n LL | fn fn_bound_2<'a, F, I>(_m: Lt<'a, I>, _f: F) -> Lt<'a, I>\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: replace with `'_` in generic arguments such as here\n-  --> $DIR/needless_lifetimes.rs:98:32\n+  --> $DIR/needless_lifetimes.rs:116:32\n    |\n LL | fn fn_bound_2<'a, F, I>(_m: Lt<'a, I>, _f: F) -> Lt<'a, I>\n    |                                ^^\n \n error: the following explicit lifetimes could be elided: 's\n-  --> $DIR/needless_lifetimes.rs:128:5\n+  --> $DIR/needless_lifetimes.rs:146:5\n    |\n LL |     fn self_and_out<'s>(&'s self) -> &'s u8 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: the following explicit lifetimes could be elided: 't\n+  --> $DIR/needless_lifetimes.rs:153:5\n+   |\n+LL |     fn self_and_in_out_1<'s, 't>(&'s self, _x: &'t u8) -> &'s u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the following explicit lifetimes could be elided: 's\n+  --> $DIR/needless_lifetimes.rs:160:5\n+   |\n+LL |     fn self_and_in_out_2<'s, 't>(&'s self, x: &'t u8) -> &'t u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: the following explicit lifetimes could be elided: 's, 't\n-  --> $DIR/needless_lifetimes.rs:137:5\n+  --> $DIR/needless_lifetimes.rs:164:5\n    |\n LL |     fn distinct_self_and_in<'s, 't>(&'s self, _x: &'t u8) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:156:1\n+  --> $DIR/needless_lifetimes.rs:183:1\n    |\n LL | fn struct_with_lt<'a>(_foo: Foo<'a>) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: replace with `'_` in generic arguments such as here\n-  --> $DIR/needless_lifetimes.rs:156:33\n+  --> $DIR/needless_lifetimes.rs:183:33\n    |\n LL | fn struct_with_lt<'a>(_foo: Foo<'a>) -> &'a str {\n    |                                 ^^\n \n+error: the following explicit lifetimes could be elided: 'b\n+  --> $DIR/needless_lifetimes.rs:201:1\n+   |\n+LL | fn struct_with_lt4a<'a, 'b>(_foo: &'a Foo<'b>) -> &'a str {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: replace with `'_` in generic arguments such as here\n+  --> $DIR/needless_lifetimes.rs:201:43\n+   |\n+LL | fn struct_with_lt4a<'a, 'b>(_foo: &'a Foo<'b>) -> &'a str {\n+   |                                           ^^\n+\n+error: the following explicit lifetimes could be elided: 'a\n+  --> $DIR/needless_lifetimes.rs:209:1\n+   |\n+LL | fn struct_with_lt4b<'a, 'b>(_foo: &'a Foo<'b>) -> &'b str {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:186:1\n+  --> $DIR/needless_lifetimes.rs:224:1\n    |\n LL | fn trait_obj_elided2<'a>(_arg: &'a dyn Drop) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:192:1\n+  --> $DIR/needless_lifetimes.rs:230:1\n    |\n LL | fn alias_with_lt<'a>(_foo: FooAlias<'a>) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: replace with `'_` in generic arguments such as here\n-  --> $DIR/needless_lifetimes.rs:192:37\n+  --> $DIR/needless_lifetimes.rs:230:37\n    |\n LL | fn alias_with_lt<'a>(_foo: FooAlias<'a>) -> &'a str {\n    |                                     ^^\n \n+error: the following explicit lifetimes could be elided: 'b\n+  --> $DIR/needless_lifetimes.rs:248:1\n+   |\n+LL | fn alias_with_lt4a<'a, 'b>(_foo: &'a FooAlias<'b>) -> &'a str {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: replace with `'_` in generic arguments such as here\n+  --> $DIR/needless_lifetimes.rs:248:47\n+   |\n+LL | fn alias_with_lt4a<'a, 'b>(_foo: &'a FooAlias<'b>) -> &'a str {\n+   |                                               ^^\n+\n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:211:1\n+  --> $DIR/needless_lifetimes.rs:256:1\n+   |\n+LL | fn alias_with_lt4b<'a, 'b>(_foo: &'a FooAlias<'b>) -> &'b str {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the following explicit lifetimes could be elided: 'a\n+  --> $DIR/needless_lifetimes.rs:260:1\n    |\n LL | fn named_input_elided_output<'a>(_arg: &'a str) -> &str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:219:1\n+  --> $DIR/needless_lifetimes.rs:268:1\n    |\n LL | fn trait_bound_ok<'a, T: WithLifetime<'static>>(_: &'a u8, _: T) {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:255:1\n+  --> $DIR/needless_lifetimes.rs:304:1\n    |\n LL | fn out_return_type_lts<'a>(e: &'a str) -> Cow<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: replace with `'_` in generic arguments such as here\n+  --> $DIR/needless_lifetimes.rs:304:47\n+   |\n+LL | fn out_return_type_lts<'a>(e: &'a str) -> Cow<'a> {\n+   |                                               ^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:262:9\n+  --> $DIR/needless_lifetimes.rs:311:9\n    |\n LL |         fn needless_lt<'a>(x: &'a u8) {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:266:9\n+  --> $DIR/needless_lifetimes.rs:315:9\n    |\n LL |         fn needless_lt<'a>(_x: &'a u8) {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:279:9\n+  --> $DIR/needless_lifetimes.rs:328:9\n    |\n LL |         fn baz<'a>(&'a self) -> impl Foo + 'a {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:311:5\n+  --> $DIR/needless_lifetimes.rs:360:5\n    |\n LL |     fn impl_trait_elidable_nested_anonymous_lifetimes<'a>(i: &'a i32, f: impl Fn(&i32) -> &i32) -> &'a i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:320:5\n+  --> $DIR/needless_lifetimes.rs:369:5\n    |\n LL |     fn generics_elidable<'a, T: Fn(&i32) -> &i32>(i: &'a i32, f: T) -> &'a i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:332:5\n+  --> $DIR/needless_lifetimes.rs:381:5\n    |\n LL |     fn where_clause_elidadable<'a, T>(i: &'a i32, f: T) -> &'a i32\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:347:5\n+  --> $DIR/needless_lifetimes.rs:396:5\n    |\n LL |     fn pointer_fn_elidable<'a>(i: &'a i32, f: fn(&i32) -> &i32) -> &'a i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:360:5\n+  --> $DIR/needless_lifetimes.rs:409:5\n    |\n LL |     fn nested_fn_pointer_3<'a>(_: &'a i32) -> fn(fn(&i32) -> &i32) -> i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:363:5\n+  --> $DIR/needless_lifetimes.rs:412:5\n    |\n LL |     fn nested_fn_pointer_4<'a>(_: &'a i32) -> impl Fn(fn(&i32)) {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:385:9\n+  --> $DIR/needless_lifetimes.rs:434:9\n    |\n LL |         fn implicit<'a>(&'a self) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:388:9\n+  --> $DIR/needless_lifetimes.rs:437:9\n    |\n LL |         fn implicit_mut<'a>(&'a mut self) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:399:9\n+  --> $DIR/needless_lifetimes.rs:448:9\n    |\n LL |         fn lifetime_elsewhere<'a>(self: Box<Self>, here: &'a ()) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:405:9\n+  --> $DIR/needless_lifetimes.rs:454:9\n    |\n LL |         fn implicit<'a>(&'a self) -> &'a ();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:406:9\n+  --> $DIR/needless_lifetimes.rs:455:9\n    |\n LL |         fn implicit_provided<'a>(&'a self) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:415:9\n+  --> $DIR/needless_lifetimes.rs:464:9\n    |\n LL |         fn lifetime_elsewhere<'a>(self: Box<Self>, here: &'a ()) -> &'a ();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:416:9\n+  --> $DIR/needless_lifetimes.rs:465:9\n    |\n LL |         fn lifetime_elsewhere_provided<'a>(self: Box<Self>, here: &'a ()) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:425:5\n+  --> $DIR/needless_lifetimes.rs:474:5\n    |\n LL |     fn foo<'a>(x: &'a u8, y: &'_ u8) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: the following explicit lifetimes could be elided: 'a\n-  --> $DIR/needless_lifetimes.rs:427:5\n+  --> $DIR/needless_lifetimes.rs:476:5\n    |\n LL |     fn bar<'a>(x: &'a u8, y: &'_ u8, z: &'_ u8) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 33 previous errors\n+error: the following explicit lifetimes could be elided: 'a\n+  --> $DIR/needless_lifetimes.rs:483:5\n+   |\n+LL |     fn one_input<'a>(x: &'a u8) -> &'a u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the following explicit lifetimes could be elided: 'a\n+  --> $DIR/needless_lifetimes.rs:488:5\n+   |\n+LL |     fn multiple_inputs_output_not_elided<'a, 'b>(x: &'a u8, y: &'b u8, z: &'b u8) -> &'b u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 45 previous errors\n "}, {"sha": "1cbacf0feab543bdf3df61bc270965713d747d76", "filename": "tests/ui/transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c443984870c2a28ea54e8f8306749c8827dfb2d/tests%2Fui%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c443984870c2a28ea54e8f8306749c8827dfb2d/tests%2Fui%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute.rs?ref=2c443984870c2a28ea54e8f8306749c8827dfb2d", "patch": "@@ -1,4 +1,4 @@\n-#![allow(dead_code, clippy::borrow_as_ptr)]\n+#![allow(dead_code, clippy::borrow_as_ptr, clippy::needless_lifetimes)]\n \n extern crate core;\n "}, {"sha": "c0af011d33d06a3f912914df7623a0f4df39766a", "filename": "tests/ui/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c443984870c2a28ea54e8f8306749c8827dfb2d/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c443984870c2a28ea54e8f8306749c8827dfb2d/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs?ref=2c443984870c2a28ea54e8f8306749c8827dfb2d", "patch": "@@ -3,6 +3,7 @@\n #![deny(clippy::trivially_copy_pass_by_ref)]\n #![allow(\n     clippy::disallowed_names,\n+    clippy::needless_lifetimes,\n     clippy::redundant_field_names,\n     clippy::uninlined_format_args\n )]"}, {"sha": "8c5cfa8a0f17c83844d31b9cb4a486b5cf572f88", "filename": "tests/ui/trivially_copy_pass_by_ref.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2c443984870c2a28ea54e8f8306749c8827dfb2d/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c443984870c2a28ea54e8f8306749c8827dfb2d/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr?ref=2c443984870c2a28ea54e8f8306749c8827dfb2d", "patch": "@@ -1,5 +1,5 @@\n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:50:11\n+  --> $DIR/trivially_copy_pass_by_ref.rs:51:11\n    |\n LL | fn bad(x: &u32, y: &Foo, z: &Baz) {}\n    |           ^^^^ help: consider passing by value instead: `u32`\n@@ -11,103 +11,103 @@ LL | #![deny(clippy::trivially_copy_pass_by_ref)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:50:20\n+  --> $DIR/trivially_copy_pass_by_ref.rs:51:20\n    |\n LL | fn bad(x: &u32, y: &Foo, z: &Baz) {}\n    |                    ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:50:29\n+  --> $DIR/trivially_copy_pass_by_ref.rs:51:29\n    |\n LL | fn bad(x: &u32, y: &Foo, z: &Baz) {}\n    |                             ^^^^ help: consider passing by value instead: `Baz`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:57:12\n+  --> $DIR/trivially_copy_pass_by_ref.rs:58:12\n    |\n LL |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {}\n    |            ^^^^^ help: consider passing by value instead: `self`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:57:22\n+  --> $DIR/trivially_copy_pass_by_ref.rs:58:22\n    |\n LL |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {}\n    |                      ^^^^ help: consider passing by value instead: `u32`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:57:31\n+  --> $DIR/trivially_copy_pass_by_ref.rs:58:31\n    |\n LL |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {}\n    |                               ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:57:40\n+  --> $DIR/trivially_copy_pass_by_ref.rs:58:40\n    |\n LL |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {}\n    |                                        ^^^^ help: consider passing by value instead: `Baz`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:59:16\n+  --> $DIR/trivially_copy_pass_by_ref.rs:60:16\n    |\n LL |     fn bad2(x: &u32, y: &Foo, z: &Baz) {}\n    |                ^^^^ help: consider passing by value instead: `u32`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:59:25\n+  --> $DIR/trivially_copy_pass_by_ref.rs:60:25\n    |\n LL |     fn bad2(x: &u32, y: &Foo, z: &Baz) {}\n    |                         ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:59:34\n+  --> $DIR/trivially_copy_pass_by_ref.rs:60:34\n    |\n LL |     fn bad2(x: &u32, y: &Foo, z: &Baz) {}\n    |                                  ^^^^ help: consider passing by value instead: `Baz`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:61:35\n+  --> $DIR/trivially_copy_pass_by_ref.rs:62:35\n    |\n LL |     fn bad_issue7518(self, other: &Self) {}\n    |                                   ^^^^^ help: consider passing by value instead: `Self`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:73:16\n+  --> $DIR/trivially_copy_pass_by_ref.rs:74:16\n    |\n LL |     fn bad2(x: &u32, y: &Foo, z: &Baz) {}\n    |                ^^^^ help: consider passing by value instead: `u32`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:73:25\n+  --> $DIR/trivially_copy_pass_by_ref.rs:74:25\n    |\n LL |     fn bad2(x: &u32, y: &Foo, z: &Baz) {}\n    |                         ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:73:34\n+  --> $DIR/trivially_copy_pass_by_ref.rs:74:34\n    |\n LL |     fn bad2(x: &u32, y: &Foo, z: &Baz) {}\n    |                                  ^^^^ help: consider passing by value instead: `Baz`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:77:34\n+  --> $DIR/trivially_copy_pass_by_ref.rs:78:34\n    |\n LL |     fn trait_method(&self, _foo: &Foo);\n    |                                  ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:109:21\n+  --> $DIR/trivially_copy_pass_by_ref.rs:110:21\n    |\n LL |     fn foo_never(x: &i32) {\n    |                     ^^^^ help: consider passing by value instead: `i32`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:114:15\n+  --> $DIR/trivially_copy_pass_by_ref.rs:115:15\n    |\n LL |     fn foo(x: &i32) {\n    |               ^^^^ help: consider passing by value instead: `i32`\n \n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:141:37\n+  --> $DIR/trivially_copy_pass_by_ref.rs:142:37\n    |\n LL | fn _unrelated_lifetimes<'a, 'b>(_x: &'a u32, y: &'b u32) -> &'b u32 {\n    |                                     ^^^^^^^ help: consider passing by value instead: `u32`"}]}