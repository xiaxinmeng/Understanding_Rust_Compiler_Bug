{"sha": "5745597e6195fe0591737f242d02350001b6c590", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3NDU1OTdlNjE5NWZlMDU5MTczN2YyNDJkMDIzNTAwMDFiNmM1OTA=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-08-14T00:21:24Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-08-16T07:52:36Z"}, "message": "Speed up NLL with `HybridIdxSetBuf`.\n\n`HybridIdxSetBuf` is a sparse-when-small but dense-when-large index set\nthat is very efficient for sets that (a) have few elements, (b) have\nlarge `universe_size` values, and (c) are cleared frequently. Which\nmakes it perfect for the `gen_set` and `kill_set` sets used by the new\nborrow checker.\n\nThis patch reduces the execution time of the five slowest NLL benchmarks\nby 55%, 21%, 16%, 10% and 9%. It also reduces the max-rss of three\nbenchmarks by 53%, 33%, and 9%.", "tree": {"sha": "4cf9f672c594d119ca97c43834ced1556f8c378e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cf9f672c594d119ca97c43834ced1556f8c378e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5745597e6195fe0591737f242d02350001b6c590", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5745597e6195fe0591737f242d02350001b6c590", "html_url": "https://github.com/rust-lang/rust/commit/5745597e6195fe0591737f242d02350001b6c590", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5745597e6195fe0591737f242d02350001b6c590/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0aa8d0320266b5579428312095fe49af05ada972", "url": "https://api.github.com/repos/rust-lang/rust/commits/0aa8d0320266b5579428312095fe49af05ada972", "html_url": "https://github.com/rust-lang/rust/commit/0aa8d0320266b5579428312095fe49af05ada972"}], "stats": {"total": 410, "additions": 320, "deletions": 90}, "files": [{"sha": "ed2e978780085dcf04248231c39f54524afee9fe", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 237, "deletions": 10, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/5745597e6195fe0591737f242d02350001b6c590/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745597e6195fe0591737f242d02350001b6c590/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=5745597e6195fe0591737f242d02350001b6c590", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use array_vec::ArrayVec;\n use std::borrow::{Borrow, BorrowMut, ToOwned};\n use std::fmt;\n use std::iter;\n@@ -25,6 +26,8 @@ use rustc_serialize;\n ///\n /// In other words, `T` is the type used to index into the bitvector\n /// this type uses to represent the set of object it holds.\n+///\n+/// The representation is dense, using one bit per possible element.\n #[derive(Eq, PartialEq)]\n pub struct IdxSetBuf<T: Idx> {\n     _pd: PhantomData<fn(&T)>,\n@@ -93,6 +96,8 @@ impl<T: Idx> ToOwned for IdxSet<T> {\n     }\n }\n \n+const BITS_PER_WORD: usize = mem::size_of::<Word>() * 8;\n+\n impl<T: Idx> fmt::Debug for IdxSetBuf<T> {\n     fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n         w.debug_list()\n@@ -111,8 +116,7 @@ impl<T: Idx> fmt::Debug for IdxSet<T> {\n \n impl<T: Idx> IdxSetBuf<T> {\n     fn new(init: Word, universe_size: usize) -> Self {\n-        let bits_per_word = mem::size_of::<Word>() * 8;\n-        let num_words = (universe_size + (bits_per_word - 1)) / bits_per_word;\n+        let num_words = (universe_size + (BITS_PER_WORD - 1)) / BITS_PER_WORD;\n         IdxSetBuf {\n             _pd: Default::default(),\n             bits: vec![init; num_words],\n@@ -163,6 +167,16 @@ impl<T: Idx> IdxSet<T> {\n         }\n     }\n \n+    /// Duplicates as a hybrid set.\n+    pub fn to_hybrid(&self) -> HybridIdxSetBuf<T> {\n+        // This universe_size may be slightly larger than the one specified\n+        // upon creation, due to rounding up to a whole word. That's ok.\n+        let universe_size = self.bits.len() * BITS_PER_WORD;\n+\n+        // Note: we currently don't bother trying to make a Sparse set.\n+        HybridIdxSetBuf::Dense(self.to_owned(), universe_size)\n+    }\n+\n     /// Removes all elements\n     pub fn clear(&mut self) {\n         for b in &mut self.bits {\n@@ -180,21 +194,19 @@ impl<T: Idx> IdxSet<T> {\n \n     /// Clear all elements above `universe_size`.\n     fn trim_to(&mut self, universe_size: usize) {\n-        let word_bits = mem::size_of::<Word>() * 8;\n-\n         // `trim_block` is the first block where some bits have\n         // to be cleared.\n-        let trim_block = universe_size / word_bits;\n+        let trim_block = universe_size / BITS_PER_WORD;\n \n         // all the blocks above it have to be completely cleared.\n         if trim_block < self.bits.len() {\n             for b in &mut self.bits[trim_block+1..] {\n                 *b = 0;\n             }\n \n-            // at that block, the `universe_size % word_bits` lsbs\n+            // at that block, the `universe_size % BITS_PER_WORD` lsbs\n             // should remain.\n-            let remaining_bits = universe_size % word_bits;\n+            let remaining_bits = universe_size % BITS_PER_WORD;\n             let mask = (1<<remaining_bits)-1;\n             self.bits[trim_block] &= mask;\n         }\n@@ -245,12 +257,46 @@ impl<T: Idx> IdxSet<T> {\n         bitwise(self.words_mut(), other.words(), &Union)\n     }\n \n+    /// Like `union()`, but takes a `SparseIdxSetBuf` argument.\n+    fn union_sparse(&mut self, other: &SparseIdxSetBuf<T>) -> bool {\n+        let mut changed = false;\n+        for elem in other.iter() {\n+            changed |= self.add(&elem);\n+        }\n+        changed\n+    }\n+\n+    /// Like `union()`, but takes a `HybridIdxSetBuf` argument.\n+    pub fn union_hybrid(&mut self, other: &HybridIdxSetBuf<T>) -> bool {\n+        match other {\n+            HybridIdxSetBuf::Sparse(sparse, _) => self.union_sparse(sparse),\n+            HybridIdxSetBuf::Dense(dense, _) => self.union(dense),\n+        }\n+    }\n+\n     /// Set `self = self - other` and return true if `self` changed.\n     /// (i.e., if any bits were removed).\n     pub fn subtract(&mut self, other: &IdxSet<T>) -> bool {\n         bitwise(self.words_mut(), other.words(), &Subtract)\n     }\n \n+    /// Like `subtract()`, but takes a `SparseIdxSetBuf` argument.\n+    fn subtract_sparse(&mut self, other: &SparseIdxSetBuf<T>) -> bool {\n+        let mut changed = false;\n+        for elem in other.iter() {\n+            changed |= self.remove(&elem);\n+        }\n+        changed\n+    }\n+\n+    /// Like `subtract()`, but takes a `HybridIdxSetBuf` argument.\n+    pub fn subtract_hybrid(&mut self, other: &HybridIdxSetBuf<T>) -> bool {\n+        match other {\n+            HybridIdxSetBuf::Sparse(sparse, _) => self.subtract_sparse(sparse),\n+            HybridIdxSetBuf::Dense(dense, _) => self.subtract(dense),\n+        }\n+    }\n+\n     /// Set `self = self & other` and return true if `self` changed.\n     /// (i.e., if any bits were removed).\n     pub fn intersect(&mut self, other: &IdxSet<T>) -> bool {\n@@ -276,19 +322,200 @@ impl<'a, T: Idx> Iterator for Iter<'a, T> {\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> {\n-        let word_bits = mem::size_of::<Word>() * 8;\n         loop {\n             if let Some((ref mut word, offset)) = self.cur {\n                 let bit_pos = word.trailing_zeros() as usize;\n-                if bit_pos != word_bits {\n+                if bit_pos != BITS_PER_WORD {\n                     let bit = 1 << bit_pos;\n                     *word ^= bit;\n                     return Some(T::new(bit_pos + offset))\n                 }\n             }\n \n             let (i, word) = self.iter.next()?;\n-            self.cur = Some((*word, word_bits * i));\n+            self.cur = Some((*word, BITS_PER_WORD * i));\n+        }\n+    }\n+}\n+\n+const SPARSE_MAX: usize = 8;\n+\n+/// A sparse index set with a maximum of SPARSE_MAX elements. Used by\n+/// HybridIdxSetBuf; do not use directly.\n+///\n+/// The elements are stored as an unsorted vector with no duplicates.\n+#[derive(Clone, Debug)]\n+pub struct SparseIdxSetBuf<T: Idx>(ArrayVec<[T; SPARSE_MAX]>);\n+\n+impl<T: Idx> SparseIdxSetBuf<T> {\n+    fn new() -> Self {\n+        SparseIdxSetBuf(ArrayVec::new())\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.0.len()\n+    }\n+\n+    fn contains(&self, elem: &T) -> bool {\n+        self.0.contains(elem)\n+    }\n+\n+    fn add(&mut self, elem: &T) -> bool {\n+        // Ensure there are no duplicates.\n+        if self.0.contains(elem) {\n+            false\n+        } else {\n+            self.0.push(*elem);\n+            true\n+        }\n+    }\n+\n+    fn remove(&mut self, elem: &T) -> bool {\n+        if let Some(i) = self.0.iter().position(|e| e == elem) {\n+            // Swap the found element to the end, then pop it.\n+            let len = self.0.len();\n+            self.0.swap(i, len - 1);\n+            self.0.pop();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn to_dense(&self, universe_size: usize) -> IdxSetBuf<T> {\n+        let mut dense = IdxSetBuf::new_empty(universe_size);\n+        for elem in self.0.iter() {\n+            dense.add(elem);\n+        }\n+        dense\n+    }\n+\n+    fn iter(&self) -> SparseIter<T> {\n+        SparseIter {\n+            iter: self.0.iter(),\n+        }\n+    }\n+}\n+\n+pub struct SparseIter<'a, T: Idx> {\n+    iter: slice::Iter<'a, T>,\n+}\n+\n+impl<'a, T: Idx> Iterator for SparseIter<'a, T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        self.iter.next().map(|e| *e)\n+    }\n+}\n+\n+/// Like IdxSetBuf, but with a hybrid representation: sparse when there are few\n+/// elements in the set, but dense when there are many. It's especially\n+/// efficient for sets that typically have a small number of elements, but a\n+/// large `universe_size`, and are cleared frequently.\n+#[derive(Clone, Debug)]\n+pub enum HybridIdxSetBuf<T: Idx> {\n+    Sparse(SparseIdxSetBuf<T>, usize),\n+    Dense(IdxSetBuf<T>, usize),\n+}\n+\n+impl<T: Idx> HybridIdxSetBuf<T> {\n+    pub fn new_empty(universe_size: usize) -> Self {\n+        HybridIdxSetBuf::Sparse(SparseIdxSetBuf::new(), universe_size)\n+    }\n+\n+    fn universe_size(&mut self) -> usize {\n+        match *self {\n+            HybridIdxSetBuf::Sparse(_, size) => size,\n+            HybridIdxSetBuf::Dense(_, size) => size,\n+        }\n+    }\n+\n+    pub fn clear(&mut self) {\n+        let universe_size = self.universe_size();\n+        *self = HybridIdxSetBuf::new_empty(universe_size);\n+    }\n+\n+    /// Returns true iff set `self` contains `elem`.\n+    pub fn contains(&self, elem: &T) -> bool {\n+        match self {\n+            HybridIdxSetBuf::Sparse(sparse, _) => sparse.contains(elem),\n+            HybridIdxSetBuf::Dense(dense, _) => dense.contains(elem),\n+        }\n+    }\n+\n+    /// Adds `elem` to the set `self`.\n+    pub fn add(&mut self, elem: &T) -> bool {\n+        match self {\n+            HybridIdxSetBuf::Sparse(sparse, _) if sparse.len() < SPARSE_MAX => {\n+                // The set is sparse and has space for `elem`.\n+                sparse.add(elem)\n+            }\n+            HybridIdxSetBuf::Sparse(sparse, _) if sparse.contains(elem) => {\n+                // The set is sparse and does not have space for `elem`, but\n+                // that doesn't matter because `elem` is already present.\n+                false\n+            }\n+            HybridIdxSetBuf::Sparse(_, _) => {\n+                // The set is sparse and full. Convert to a dense set.\n+                //\n+                // FIXME: This code is awful, but I can't work out how else to\n+                //        appease the borrow checker.\n+                let dummy = HybridIdxSetBuf::Sparse(SparseIdxSetBuf::new(), 0);\n+                match mem::replace(self, dummy) {\n+                    HybridIdxSetBuf::Sparse(sparse, universe_size) => {\n+                        let mut dense = sparse.to_dense(universe_size);\n+                        let changed = dense.add(elem);\n+                        assert!(changed);\n+                        mem::replace(self, HybridIdxSetBuf::Dense(dense, universe_size));\n+                        changed\n+                    }\n+                    _ => panic!(\"impossible\"),\n+                }\n+            }\n+\n+            HybridIdxSetBuf::Dense(dense, _) => dense.add(elem),\n+        }\n+    }\n+\n+    /// Removes `elem` from the set `self`.\n+    pub fn remove(&mut self, elem: &T) -> bool {\n+        // Note: we currently don't bother going from Dense back to Sparse.\n+        match self {\n+            HybridIdxSetBuf::Sparse(sparse, _) => sparse.remove(elem),\n+            HybridIdxSetBuf::Dense(dense, _) => dense.remove(elem),\n+        }\n+    }\n+\n+    /// Converts to a dense set, consuming itself in the process.\n+    pub fn to_dense(self) -> IdxSetBuf<T> {\n+        match self {\n+            HybridIdxSetBuf::Sparse(sparse, universe_size) => sparse.to_dense(universe_size),\n+            HybridIdxSetBuf::Dense(dense, _) => dense,\n+        }\n+    }\n+\n+    /// Iteration order is unspecified.\n+    pub fn iter(&self) -> HybridIter<T> {\n+        match self {\n+            HybridIdxSetBuf::Sparse(sparse, _) => HybridIter::Sparse(sparse.iter()),\n+            HybridIdxSetBuf::Dense(dense, _) => HybridIter::Dense(dense.iter()),\n+        }\n+    }\n+}\n+\n+pub enum HybridIter<'a, T: Idx> {\n+    Sparse(SparseIter<'a, T>),\n+    Dense(Iter<'a, T>),\n+}\n+\n+impl<'a, T: Idx> Iterator for HybridIter<'a, T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        match self {\n+            HybridIter::Sparse(sparse) => sparse.next(),\n+            HybridIter::Dense(dense) => dense.next(),\n         }\n     }\n }"}, {"sha": "d2a8a9dcf4ba2c987b501a952e80e5a041ef3613", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5745597e6195fe0591737f242d02350001b6c590/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745597e6195fe0591737f242d02350001b6c590/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=5745597e6195fe0591737f242d02350001b6c590", "patch": "@@ -12,7 +12,7 @@\n //! locations.\n \n use rustc::mir::{BasicBlock, Location};\n-use rustc_data_structures::indexed_set::{IdxSetBuf, Iter};\n+use rustc_data_structures::indexed_set::{HybridIdxSetBuf, IdxSetBuf, Iter};\n use rustc_data_structures::indexed_vec::Idx;\n \n use dataflow::{BitDenotation, BlockSets, DataflowResults};\n@@ -68,8 +68,8 @@ where\n {\n     base_results: DataflowResults<BD>,\n     curr_state: IdxSetBuf<BD::Idx>,\n-    stmt_gen: IdxSetBuf<BD::Idx>,\n-    stmt_kill: IdxSetBuf<BD::Idx>,\n+    stmt_gen: HybridIdxSetBuf<BD::Idx>,\n+    stmt_kill: HybridIdxSetBuf<BD::Idx>,\n }\n \n impl<BD> FlowAtLocation<BD>\n@@ -97,8 +97,8 @@ where\n     pub fn new(results: DataflowResults<BD>) -> Self {\n         let bits_per_block = results.sets().bits_per_block();\n         let curr_state = IdxSetBuf::new_empty(bits_per_block);\n-        let stmt_gen = IdxSetBuf::new_empty(bits_per_block);\n-        let stmt_kill = IdxSetBuf::new_empty(bits_per_block);\n+        let stmt_gen = HybridIdxSetBuf::new_empty(bits_per_block);\n+        let stmt_kill = HybridIdxSetBuf::new_empty(bits_per_block);\n         FlowAtLocation {\n             base_results: results,\n             curr_state: curr_state,\n@@ -129,8 +129,8 @@ where\n         F: FnOnce(Iter<BD::Idx>),\n     {\n         let mut curr_state = self.curr_state.clone();\n-        curr_state.union(&self.stmt_gen);\n-        curr_state.subtract(&self.stmt_kill);\n+        curr_state.union_hybrid(&self.stmt_gen);\n+        curr_state.subtract_hybrid(&self.stmt_kill);\n         f(curr_state.iter());\n     }\n }\n@@ -193,8 +193,8 @@ impl<BD> FlowsAtLocation for FlowAtLocation<BD>\n     }\n \n     fn apply_local_effect(&mut self, _loc: Location) {\n-        self.curr_state.union(&self.stmt_gen);\n-        self.curr_state.subtract(&self.stmt_kill);\n+        self.curr_state.union_hybrid(&self.stmt_gen);\n+        self.curr_state.subtract_hybrid(&self.stmt_kill);\n     }\n }\n "}, {"sha": "97d549987712bbe32a8051f1a005ae0c12f839aa", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5745597e6195fe0591737f242d02350001b6c590/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745597e6195fe0591737f242d02350001b6c590/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=5745597e6195fe0591737f242d02350001b6c590", "patch": "@@ -168,13 +168,13 @@ where MWF: MirWithFlowState<'tcx>,\n         let i = n.index();\n \n         macro_rules! dump_set_for {\n-            ($set:ident) => {\n+            ($set:ident, $interpret:ident) => {\n                 write!(w, \"<td>\")?;\n \n                 let flow = self.mbcx.flow_state();\n-                let entry_interp = flow.interpret_set(&flow.operator,\n-                                                      flow.sets.$set(i),\n-                                                      &self.render_idx);\n+                let entry_interp = flow.$interpret(&flow.operator,\n+                                                   flow.sets.$set(i),\n+                                                   &self.render_idx);\n                 for e in &entry_interp {\n                     write!(w, \"{:?}<br/>\", e)?;\n                 }\n@@ -184,7 +184,7 @@ where MWF: MirWithFlowState<'tcx>,\n \n         write!(w, \"<tr>\")?;\n         // Entry\n-        dump_set_for!(on_entry_set_for);\n+        dump_set_for!(on_entry_set_for, interpret_set);\n \n         // MIR statements\n         write!(w, \"<td>\")?;\n@@ -198,10 +198,10 @@ where MWF: MirWithFlowState<'tcx>,\n         write!(w, \"</td>\")?;\n \n         // Gen\n-        dump_set_for!(gen_set_for);\n+        dump_set_for!(gen_set_for, interpret_hybrid_set);\n \n         // Kill\n-        dump_set_for!(kill_set_for);\n+        dump_set_for!(kill_set_for, interpret_hybrid_set);\n \n         write!(w, \"</tr>\")?;\n \n@@ -217,19 +217,14 @@ where MWF: MirWithFlowState<'tcx>,\n                                           -> io::Result<()> {\n         let i = n.index();\n \n-        macro_rules! dump_set_for {\n-            ($set:ident) => {\n-                let flow = self.mbcx.flow_state();\n-                let bits_per_block = flow.sets.bits_per_block();\n-                let set = flow.sets.$set(i);\n-                write!(w, \"<td>{:?}</td>\",\n-                       dot::escape_html(&bits_to_string(set.words(), bits_per_block)))?;\n-            }\n-        }\n+        let flow = self.mbcx.flow_state();\n+        let bits_per_block = flow.sets.bits_per_block();\n \n         write!(w, \"<tr>\")?;\n+\n         // Entry\n-        dump_set_for!(on_entry_set_for);\n+        let set = flow.sets.on_entry_set_for(i);\n+        write!(w, \"<td>{:?}</td>\", dot::escape_html(&bits_to_string(set.words(), bits_per_block)))?;\n \n         // Terminator\n         write!(w, \"<td>\")?;\n@@ -242,10 +237,12 @@ where MWF: MirWithFlowState<'tcx>,\n         write!(w, \"</td>\")?;\n \n         // Gen\n-        dump_set_for!(gen_set_for);\n+        let set = flow.sets.gen_set_for(i);\n+        write!(w, \"<td>{:?}</td>\", dot::escape_html(&format!(\"{:?}\", set)))?;\n \n         // Kill\n-        dump_set_for!(kill_set_for);\n+        let set = flow.sets.kill_set_for(i);\n+        write!(w, \"<td>{:?}</td>\", dot::escape_html(&format!(\"{:?}\", set)))?;\n \n         write!(w, \"</tr>\")?;\n "}, {"sha": "56c4dac19e5049f64e4dba05fec6d6b8678693f5", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 48, "deletions": 42, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/5745597e6195fe0591737f242d02350001b6c590/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745597e6195fe0591737f242d02350001b6c590/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=5745597e6195fe0591737f242d02350001b6c590", "patch": "@@ -10,9 +10,9 @@\n \n use syntax::ast::{self, MetaItem};\n \n-use rustc_data_structures::indexed_set::{IdxSet, IdxSetBuf};\n-use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::bitslice::{bitwise, BitwiseOperator, Word};\n+use rustc_data_structures::indexed_set::{HybridIdxSetBuf, IdxSet, IdxSetBuf};\n+use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::work_queue::WorkQueue;\n \n use rustc::ty::{self, TyCtxt};\n@@ -188,7 +188,6 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n             builder: self,\n         };\n         propcx.walk_cfg(&mut temp);\n-\n     }\n \n     fn build_sets(&mut self) {\n@@ -243,8 +242,8 @@ impl<'b, 'a: 'b, 'tcx: 'a, BD> PropagationContext<'b, 'a, 'tcx, BD> where BD: Bi\n                 let sets = self.builder.flow_state.sets.for_block(bb.index());\n                 debug_assert!(in_out.words().len() == sets.on_entry.words().len());\n                 in_out.overwrite(sets.on_entry);\n-                in_out.union(sets.gen_set);\n-                in_out.subtract(sets.kill_set);\n+                in_out.union_hybrid(sets.gen_set);\n+                in_out.subtract_hybrid(sets.kill_set);\n             }\n             self.builder.propagate_bits_into_graph_successors_of(\n                 in_out, (bb, bb_data), &mut dirty_queue);\n@@ -289,15 +288,11 @@ impl<'a, 'tcx: 'a, BD> DataflowBuilder<'a, 'tcx, BD> where BD: BitDenotation\n }\n \n /// Maps each block to a set of bits\n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n pub(crate) struct Bits<E:Idx> {\n     bits: IdxSetBuf<E>,\n }\n \n-impl<E:Idx> Clone for Bits<E> {\n-    fn clone(&self) -> Self { Bits { bits: self.bits.clone() } }\n-}\n-\n impl<E:Idx> Bits<E> {\n     fn new(bits: IdxSetBuf<E>) -> Self {\n         Bits { bits: bits }\n@@ -372,13 +367,15 @@ pub fn state_for_location<'tcx, T: BitDenotation>(loc: Location,\n                                                   result: &DataflowResults<T>,\n                                                   mir: &Mir<'tcx>)\n     -> IdxSetBuf<T::Idx> {\n-    let mut entry = result.sets().on_entry_set_for(loc.block.index()).to_owned();\n+    let mut on_entry = result.sets().on_entry_set_for(loc.block.index()).to_owned();\n+    let mut kill_set = on_entry.to_hybrid();\n+    let mut gen_set = kill_set.clone();\n \n     {\n         let mut sets = BlockSets {\n-            on_entry: &mut entry.clone(),\n-            kill_set: &mut entry.clone(),\n-            gen_set: &mut entry,\n+            on_entry: &mut on_entry,\n+            kill_set: &mut kill_set,\n+            gen_set: &mut gen_set,\n         };\n \n         for stmt in 0..loc.statement_index {\n@@ -396,7 +393,7 @@ pub fn state_for_location<'tcx, T: BitDenotation>(loc: Location,\n         }\n     }\n \n-    entry\n+    gen_set.to_dense()\n }\n \n pub struct DataflowAnalysis<'a, 'tcx: 'a, O> where O: BitDenotation\n@@ -443,12 +440,22 @@ pub struct DataflowState<O: BitDenotation>\n impl<O: BitDenotation> DataflowState<O> {\n     pub(crate) fn interpret_set<'c, P>(&self,\n                                        o: &'c O,\n-                                       words: &IdxSet<O::Idx>,\n+                                       set: &IdxSet<O::Idx>,\n                                        render_idx: &P)\n                                        -> Vec<DebugFormatted>\n         where P: Fn(&O, O::Idx) -> DebugFormatted\n     {\n-        words.iter().map(|i| render_idx(o, i)).collect()\n+        set.iter().map(|i| render_idx(o, i)).collect()\n+    }\n+\n+    pub(crate) fn interpret_hybrid_set<'c, P>(&self,\n+                                              o: &'c O,\n+                                              set: &HybridIdxSetBuf<O::Idx>,\n+                                              render_idx: &P)\n+                                              -> Vec<DebugFormatted>\n+        where P: Fn(&O, O::Idx) -> DebugFormatted\n+    {\n+        set.iter().map(|i| render_idx(o, i)).collect()\n     }\n }\n \n@@ -461,18 +468,18 @@ pub struct AllSets<E: Idx> {\n     /// equal to bits_per_block / (mem::size_of::<Word> * 8), rounded up.\n     words_per_block: usize,\n \n+    /// For each block, bits valid on entry to the block.\n+    on_entry_sets: Bits<E>,\n+\n     /// For each block, bits generated by executing the statements in\n     /// the block. (For comparison, the Terminator for each block is\n     /// handled in a flow-specific manner during propagation.)\n-    gen_sets: Bits<E>,\n+    gen_sets: Vec<HybridIdxSetBuf<E>>,\n \n     /// For each block, bits killed by executing the statements in the\n     /// block. (For comparison, the Terminator for each block is\n     /// handled in a flow-specific manner during propagation.)\n-    kill_sets: Bits<E>,\n-\n-    /// For each block, bits valid on entry to the block.\n-    on_entry_sets: Bits<E>,\n+    kill_sets: Vec<HybridIdxSetBuf<E>>,\n }\n \n /// Triple of sets associated with a given block.\n@@ -494,11 +501,13 @@ pub struct BlockSets<'a, E: Idx> {\n     /// Dataflow state immediately before control flow enters the given block.\n     pub(crate) on_entry: &'a mut IdxSet<E>,\n \n-    /// Bits that are set to 1 by the time we exit the given block.\n-    pub(crate) gen_set: &'a mut IdxSet<E>,\n+    /// Bits that are set to 1 by the time we exit the given block. Hybrid\n+    /// because it usually contains only 0 or 1 elements.\n+    pub(crate) gen_set: &'a mut HybridIdxSetBuf<E>,\n \n-    /// Bits that are set to 0 by the time we exit the given block.\n-    pub(crate) kill_set: &'a mut IdxSet<E>,\n+    /// Bits that are set to 0 by the time we exit the given block. Hybrid\n+    /// because it usually contains only 0 or 1 elements.\n+    pub(crate) kill_set: &'a mut HybridIdxSetBuf<E>,\n }\n \n impl<'a, E:Idx> BlockSets<'a, E> {\n@@ -542,8 +551,8 @@ impl<'a, E:Idx> BlockSets<'a, E> {\n     }\n \n     fn apply_local_effect(&mut self) {\n-        self.on_entry.union(&self.gen_set);\n-        self.on_entry.subtract(&self.kill_set);\n+        self.on_entry.union_hybrid(&self.gen_set);\n+        self.on_entry.subtract_hybrid(&self.kill_set);\n     }\n }\n \n@@ -554,24 +563,21 @@ impl<E:Idx> AllSets<E> {\n         let range = E::new(offset)..E::new(offset + self.words_per_block);\n         BlockSets {\n             on_entry: self.on_entry_sets.bits.range_mut(&range),\n-            gen_set: self.gen_sets.bits.range_mut(&range),\n-            kill_set: self.kill_sets.bits.range_mut(&range),\n+            gen_set: &mut self.gen_sets[block_idx],\n+            kill_set: &mut self.kill_sets[block_idx],\n         }\n     }\n \n-    fn lookup_set_for<'a>(&self, sets: &'a Bits<E>, block_idx: usize) -> &'a IdxSet<E> {\n+    pub fn on_entry_set_for(&self, block_idx: usize) -> &IdxSet<E> {\n         let offset = self.words_per_block * block_idx;\n         let range = E::new(offset)..E::new(offset + self.words_per_block);\n-        sets.bits.range(&range)\n+        self.on_entry_sets.bits.range(&range)\n     }\n-    pub fn gen_set_for(&self, block_idx: usize) -> &IdxSet<E> {\n-        self.lookup_set_for(&self.gen_sets, block_idx)\n+    pub fn gen_set_for(&self, block_idx: usize) -> &HybridIdxSetBuf<E> {\n+        &self.gen_sets[block_idx]\n     }\n-    pub fn kill_set_for(&self, block_idx: usize) -> &IdxSet<E> {\n-        self.lookup_set_for(&self.kill_sets, block_idx)\n-    }\n-    pub fn on_entry_set_for(&self, block_idx: usize) -> &IdxSet<E> {\n-        self.lookup_set_for(&self.on_entry_sets, block_idx)\n+    pub fn kill_set_for(&self, block_idx: usize) -> &HybridIdxSetBuf<E> {\n+        &self.kill_sets[block_idx]\n     }\n }\n \n@@ -731,12 +737,12 @@ impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n         let num_blocks = mir.basic_blocks().len();\n         let num_overall = num_blocks * bits_per_block_rounded_up;\n \n-        let zeroes = Bits::new(IdxSetBuf::new_empty(num_overall));\n         let on_entry = Bits::new(if D::bottom_value() {\n             IdxSetBuf::new_filled(num_overall)\n         } else {\n             IdxSetBuf::new_empty(num_overall)\n         });\n+        let empties = vec![HybridIdxSetBuf::new_empty(bits_per_block); num_blocks];\n \n         DataflowAnalysis {\n             mir,\n@@ -745,9 +751,9 @@ impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n                 sets: AllSets {\n                     bits_per_block,\n                     words_per_block,\n-                    gen_sets: zeroes.clone(),\n-                    kill_sets: zeroes,\n                     on_entry_sets: on_entry,\n+                    gen_sets: empties.clone(),\n+                    kill_sets: empties,\n                 },\n                 operator: denotation,\n             }"}, {"sha": "776d7888459f78a7d862dc0ac151f46ff589dede", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5745597e6195fe0591737f242d02350001b6c590/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745597e6195fe0591737f242d02350001b6c590/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=5745597e6195fe0591737f242d02350001b6c590", "patch": "@@ -138,19 +138,19 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     };\n \n-    let mut entry = results.0.sets.on_entry_set_for(bb.index()).to_owned();\n-    let mut gen = results.0.sets.gen_set_for(bb.index()).to_owned();\n-    let mut kill = results.0.sets.kill_set_for(bb.index()).to_owned();\n+    let mut on_entry = results.0.sets.on_entry_set_for(bb.index()).to_owned();\n+    let mut gen_set = results.0.sets.gen_set_for(bb.index()).clone();\n+    let mut kill_set = results.0.sets.kill_set_for(bb.index()).clone();\n \n     // Emulate effect of all statements in the block up to (but not\n     // including) the borrow within `peek_arg_place`. Do *not* include\n     // call to `peek_arg_place` itself (since we are peeking the state\n     // of the argument at time immediate preceding Call to\n     // `rustc_peek`).\n \n-    let mut sets = dataflow::BlockSets { on_entry: &mut entry,\n-                                      gen_set: &mut gen,\n-                                      kill_set: &mut kill };\n+    let mut sets = dataflow::BlockSets { on_entry: &mut on_entry,\n+                                         gen_set: &mut gen_set,\n+                                         kill_set: &mut kill_set };\n \n     for (j, stmt) in statements.iter().enumerate() {\n         debug!(\"rustc_peek: ({:?},{}) {:?}\", bb, j, stmt);\n@@ -203,14 +203,14 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         debug!(\"rustc_peek: computing effect on place: {:?} ({:?}) in stmt: {:?}\",\n                place, lhs_mpi, stmt);\n         // reset GEN and KILL sets before emulating their effect.\n-        for e in sets.gen_set.words_mut() { *e = 0; }\n-        for e in sets.kill_set.words_mut() { *e = 0; }\n+        sets.gen_set.clear();\n+        sets.kill_set.clear();\n         results.0.operator.before_statement_effect(\n             &mut sets, Location { block: bb, statement_index: j });\n         results.0.operator.statement_effect(\n             &mut sets, Location { block: bb, statement_index: j });\n-        sets.on_entry.union(sets.gen_set);\n-        sets.on_entry.subtract(sets.kill_set);\n+        sets.on_entry.union_hybrid(sets.gen_set);\n+        sets.on_entry.subtract_hybrid(sets.kill_set);\n     }\n \n     results.0.operator.before_terminator_effect("}]}