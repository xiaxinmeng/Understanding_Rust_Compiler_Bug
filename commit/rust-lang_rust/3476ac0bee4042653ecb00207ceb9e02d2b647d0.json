{"sha": "3476ac0bee4042653ecb00207ceb9e02d2b647d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0NzZhYzBiZWU0MDQyNjUzZWNiMDAyMDdjZWI5ZTAyZDJiNjQ3ZDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-25T12:00:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-25T12:00:50Z"}, "message": "Auto merge of #55323 - nikomatsakis:nll-ICE-55219-and-55241, r=pnkfelix\n\nintroduce type-op for user-type ascription in NLL\n\nHandle user-type ascription in a type operator, which gives us a lot more flexibility around the order in which we resolve things.\n\nr? @pnkfelix\n\nFixes #55219\nFixes #55241", "tree": {"sha": "e775040e6d63bc6e550c33f8a63893bd1069b2f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e775040e6d63bc6e550c33f8a63893bd1069b2f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3476ac0bee4042653ecb00207ceb9e02d2b647d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3476ac0bee4042653ecb00207ceb9e02d2b647d0", "html_url": "https://github.com/rust-lang/rust/commit/3476ac0bee4042653ecb00207ceb9e02d2b647d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3476ac0bee4042653ecb00207ceb9e02d2b647d0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "365b9001e588cf3d91561894b0e44389e31ae000", "url": "https://api.github.com/repos/rust-lang/rust/commits/365b9001e588cf3d91561894b0e44389e31ae000", "html_url": "https://github.com/rust-lang/rust/commit/365b9001e588cf3d91561894b0e44389e31ae000"}, {"sha": "62f0fc51126795848fff540e9776ee331753344d", "url": "https://api.github.com/repos/rust-lang/rust/commits/62f0fc51126795848fff540e9776ee331753344d", "html_url": "https://github.com/rust-lang/rust/commit/62f0fc51126795848fff540e9776ee331753344d"}], "stats": {"total": 493, "additions": 367, "deletions": 126}, "files": [{"sha": "4d6d3bd56f2d803292145685b45275f90c4cad0d", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=3476ac0bee4042653ecb00207ceb9e02d2b647d0", "patch": "@@ -72,8 +72,9 @@ use std::hash::Hash;\n use syntax_pos::symbol::InternedString;\n use traits;\n use traits::query::{\n-    CanonicalProjectionGoal, CanonicalTyGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpSubtypeGoal,\n-    CanonicalPredicateGoal, CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpNormalizeGoal,\n+    CanonicalProjectionGoal, CanonicalTyGoal, CanonicalTypeOpAscribeUserTypeGoal,\n+    CanonicalTypeOpEqGoal, CanonicalTypeOpSubtypeGoal, CanonicalPredicateGoal,\n+    CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpNormalizeGoal,\n };\n use ty::{TyCtxt, FnSig, Instance, InstanceDef,\n          ParamEnv, ParamEnvAnd, Predicate, PolyFnSig, PolyTraitRef, Ty};\n@@ -654,6 +655,7 @@ define_dep_nodes!( <'tcx>\n     [] ImpliedOutlivesBounds(CanonicalTyGoal<'tcx>),\n     [] DropckOutlives(CanonicalTyGoal<'tcx>),\n     [] EvaluateObligation(CanonicalPredicateGoal<'tcx>),\n+    [] TypeOpAscribeUserType(CanonicalTypeOpAscribeUserTypeGoal<'tcx>),\n     [] TypeOpEq(CanonicalTypeOpEqGoal<'tcx>),\n     [] TypeOpSubtype(CanonicalTypeOpSubtypeGoal<'tcx>),\n     [] TypeOpProvePredicate(CanonicalTypeOpProvePredicateGoal<'tcx>),"}, {"sha": "0e4c94aaaf3942e31755f00f6eb8d13b90e23491", "filename": "src/librustc/infer/at.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fat.rs?ref=3476ac0bee4042653ecb00207ceb9e02d2b647d0", "patch": "@@ -142,6 +142,28 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         self.trace(expected, actual).eq(&expected, &actual)\n     }\n \n+    pub fn relate<T>(\n+        self,\n+        expected: T,\n+        variance: ty::Variance,\n+        actual: T,\n+    ) -> InferResult<'tcx, ()>\n+        where T: ToTrace<'tcx>\n+    {\n+        match variance {\n+            ty::Variance::Covariant => self.sub(expected, actual),\n+            ty::Variance::Invariant => self.eq(expected, actual),\n+            ty::Variance::Contravariant => self.sup(expected, actual),\n+\n+            // We could make this make sense but it's not readily\n+            // exposed and I don't feel like dealing with it. Note\n+            // that bivariance in general does a bit more than just\n+            // *nothing*, it checks that the types are the same\n+            // \"modulo variance\" basically.\n+            ty::Variance::Bivariant => panic!(\"Bivariant given to `relate()`\"),\n+        }\n+    }\n+\n     /// Compute the least-upper-bound, or mutual supertype, of two\n     /// values. The order of the arguments doesn't matter, but since\n     /// this can result in an error (e.g., if asked to compute LUB of"}, {"sha": "571beaae4596b88c014e56b694a0641f63b9546f", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=3476ac0bee4042653ecb00207ceb9e02d2b647d0", "patch": "@@ -2438,6 +2438,14 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for UserTypeAnnotation<'a> {\n+        type Lifted = UserTypeAnnotation<'tcx>;\n+        (UserTypeAnnotation::Ty)(ty),\n+        (UserTypeAnnotation::TypeOf)(def, substs),\n+    }\n+}\n+\n newtype_index! {\n     pub struct Promoted {\n         DEBUG_FORMAT = \"promoted[{}]\""}, {"sha": "13683d8544496477fdc55699ca763ec0e1768bf7", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=3476ac0bee4042653ecb00207ceb9e02d2b647d0", "patch": "@@ -34,6 +34,9 @@ pub type CanonicalTyGoal<'tcx> = Canonical<'tcx, ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n pub type CanonicalPredicateGoal<'tcx> =\n     Canonical<'tcx, ty::ParamEnvAnd<'tcx, ty::Predicate<'tcx>>>;\n \n+pub type CanonicalTypeOpAscribeUserTypeGoal<'tcx> =\n+    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::ascribe_user_type::AscribeUserType<'tcx>>>;\n+\n pub type CanonicalTypeOpEqGoal<'tcx> =\n     Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::eq::Eq<'tcx>>>;\n "}, {"sha": "b3955b8f864e55f96cc0c51619372c03e1084a4f", "filename": "src/librustc/traits/query/type_op/ascribe_user_type.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=3476ac0bee4042653ecb00207ceb9e02d2b647d0", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use traits::query::Fallible;\n+use hir::def_id::DefId;\n+use ty::{self, ParamEnvAnd, Ty, TyCtxt};\n+use ty::subst::UserSubsts;\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub struct AscribeUserType<'tcx> {\n+    pub mir_ty: Ty<'tcx>,\n+    pub variance: ty::Variance,\n+    pub def_id: DefId,\n+    pub user_substs: UserSubsts<'tcx>,\n+}\n+\n+impl<'tcx> AscribeUserType<'tcx> {\n+    pub fn new(\n+        mir_ty: Ty<'tcx>,\n+        variance: ty::Variance,\n+        def_id: DefId,\n+        user_substs: UserSubsts<'tcx>,\n+    ) -> Self {\n+        AscribeUserType { mir_ty, variance, def_id, user_substs }\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for AscribeUserType<'tcx> {\n+    type QueryResponse = ();\n+\n+    fn try_fast_path(\n+        _tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        _key: &ParamEnvAnd<'tcx, Self>,\n+    ) -> Option<Self::QueryResponse> {\n+        None\n+    }\n+\n+    fn perform_query(\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalizedQueryResponse<'gcx, ()>> {\n+        tcx.type_op_ascribe_user_type(canonicalized)\n+    }\n+\n+    fn shrink_to_tcx_lifetime(\n+        v: &'a CanonicalizedQueryResponse<'gcx, ()>,\n+    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, ()>> {\n+        v\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for AscribeUserType<'tcx> {\n+        mir_ty, variance, def_id, user_substs\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for AscribeUserType<'a> {\n+        type Lifted = AscribeUserType<'tcx>;\n+        mir_ty, variance, def_id, user_substs\n+    }\n+}\n+\n+impl_stable_hash_for! {\n+    struct AscribeUserType<'tcx> {\n+        mir_ty, variance, def_id, user_substs\n+    }\n+}"}, {"sha": "d20d43cf7578c3917bc37563ca04b2da0587042e", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=3476ac0bee4042653ecb00207ceb9e02d2b647d0", "patch": "@@ -20,6 +20,7 @@ use traits::ObligationCause;\n use ty::fold::TypeFoldable;\n use ty::{Lift, ParamEnvAnd, TyCtxt};\n \n+pub mod ascribe_user_type;\n pub mod custom;\n pub mod eq;\n pub mod implied_outlives_bounds;"}, {"sha": "5a2f062f233cf17c67e9d5e565dcb773cb46d6c9", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=3476ac0bee4042653ecb00207ceb9e02d2b647d0", "patch": "@@ -330,7 +330,7 @@ impl Visibility {\n     }\n }\n \n-#[derive(Clone, PartialEq, RustcDecodable, RustcEncodable, Copy)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcDecodable, RustcEncodable, Hash)]\n pub enum Variance {\n     Covariant,      // T<A> <: T<B> iff A <: B -- e.g., function return type\n     Invariant,      // T<A> <: T<B> iff B == A -- e.g., type of mutable cell"}, {"sha": "0f6ff93c52336c859b3f240391b8c001c9b755a1", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=3476ac0bee4042653ecb00207ceb9e02d2b647d0", "patch": "@@ -14,8 +14,9 @@ use hir::def_id::{CrateNum, DefId, DefIndex};\n use mir::interpret::GlobalId;\n use traits;\n use traits::query::{\n-    CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal, CanonicalTypeOpEqGoal,\n-    CanonicalTypeOpNormalizeGoal, CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal,\n+    CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n+    CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,\n+    CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal,\n };\n use ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use ty::subst::Substs;\n@@ -115,6 +116,15 @@ impl<'tcx> QueryDescription<'tcx> for queries::evaluate_obligation<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::type_op_ascribe_user_type<'tcx> {\n+    fn describe(\n+        _tcx: TyCtxt<'_, '_, '_>,\n+        goal: CanonicalTypeOpAscribeUserTypeGoal<'tcx>,\n+    ) -> Cow<'static, str> {\n+        format!(\"evaluating `type_op_ascribe_user_type` `{:?}`\", goal).into()\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::type_op_eq<'tcx> {\n     fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTypeOpEqGoal<'tcx>) -> Cow<'static, str> {\n         format!(\"evaluating `type_op_eq` `{:?}`\", goal).into()"}, {"sha": "a59a15da08d999842e28adb54f3711e764431bed", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=3476ac0bee4042653ecb00207ceb9e02d2b647d0", "patch": "@@ -34,9 +34,12 @@ use mir::interpret::GlobalId;\n use session::{CompileResult, CrateDisambiguator};\n use session::config::OutputFilenames;\n use traits::{self, Vtable};\n-use traits::query::{CanonicalPredicateGoal, CanonicalProjectionGoal,\n-                    CanonicalTyGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpSubtypeGoal,\n-                    CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpNormalizeGoal, NoSolution};\n+use traits::query::{\n+    CanonicalPredicateGoal, CanonicalProjectionGoal,\n+    CanonicalTyGoal, CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal,\n+    CanonicalTypeOpSubtypeGoal, CanonicalTypeOpProvePredicateGoal,\n+    CanonicalTypeOpNormalizeGoal, NoSolution,\n+};\n use traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n use traits::query::normalize::NormalizationResult;\n use traits::query::outlives_bounds::OutlivesBound;\n@@ -589,6 +592,14 @@ define_queries! { <'tcx>\n             CanonicalPredicateGoal<'tcx>\n         ) -> Result<traits::EvaluationResult, traits::OverflowError>,\n \n+        /// Do not call this query directly: part of the `Eq` type-op\n+        [] fn type_op_ascribe_user_type: TypeOpAscribeUserType(\n+            CanonicalTypeOpAscribeUserTypeGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>>,\n+            NoSolution,\n+        >,\n+\n         /// Do not call this query directly: part of the `Eq` type-op\n         [] fn type_op_eq: TypeOpEq(\n             CanonicalTypeOpEqGoal<'tcx>"}, {"sha": "789658dcf72dc25b45452464643ddd8393ebf66e", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=3476ac0bee4042653ecb00207ceb9e02d2b647d0", "patch": "@@ -1079,6 +1079,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::ImpliedOutlivesBounds |\n         DepKind::DropckOutlives |\n         DepKind::EvaluateObligation |\n+        DepKind::TypeOpAscribeUserType |\n         DepKind::TypeOpEq |\n         DepKind::TypeOpSubtype |\n         DepKind::TypeOpProvePredicate |"}, {"sha": "bbbe02fda6a84dd145035e0e6331b5117d3b100a", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 15, "deletions": 98, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=3476ac0bee4042653ecb00207ceb9e02d2b647d0", "patch": "@@ -42,7 +42,7 @@ use rustc::traits::query::type_op::custom::CustomTypeOp;\n use rustc::traits::query::{Fallible, NoSolution};\n use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::subst::{Subst, Substs, UnpackedKind, UserSelfTy, UserSubsts};\n+use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n use rustc::ty::{self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n use std::rc::Rc;\n use std::{fmt, iter};\n@@ -975,126 +975,43 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n-        let tcx = self.tcx();\n-\n         debug!(\n-            \"relate_type_and_user_type(a={:?}, v={:?}, b={:?}, locations={:?})\",\n-            a, v, user_ty, locations\n+            \"relate_type_and_user_type(a={:?}, v={:?}, user_ty={:?}, locations={:?})\",\n+            a, v, user_ty, locations,\n         );\n \n-        // The `TypeRelating` code assumes that \"unresolved inference\n-        // variables\" appear in the \"a\" side, so flip `Contravariant`\n-        // ambient variance to get the right relationship.\n-        let v1 = ty::Contravariant.xform(v);\n-\n         match user_ty {\n             UserTypeAnnotation::Ty(canonical_ty) => {\n                 let (ty, _) = self.infcx\n                     .instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_ty);\n \n-                self.relate_types(ty, v1, a, locations, category)?;\n+                // The `TypeRelating` code assumes that \"unresolved inference\n+                // variables\" appear in the \"a\" side, so flip `Contravariant`\n+                // ambient variance to get the right relationship.\n+                let v1 = ty::Contravariant.xform(v);\n \n-                self.prove_predicate(ty::Predicate::WellFormed(ty), locations, category);\n+                self.relate_types(ty, v1, a, locations, category)?;\n             }\n             UserTypeAnnotation::TypeOf(def_id, canonical_substs) => {\n                 let (\n-                    UserSubsts {\n-                        substs,\n-                        user_self_ty,\n-                    },\n+                    user_substs,\n                     _,\n                 ) = self.infcx\n                     .instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_substs);\n \n-                let ty = self.tcx().type_of(def_id);\n-                let ty = ty.subst(tcx, substs);\n-                let ty = self.normalize(ty, locations);\n-\n-                self.relate_types(ty, v1, a, locations, category)?;\n-\n-                if let Some(UserSelfTy {\n-                    impl_def_id,\n-                    self_ty,\n-                }) = user_self_ty\n-                {\n-                    let impl_self_ty = tcx.type_of(impl_def_id);\n-                    let impl_self_ty = impl_self_ty.subst(tcx, &substs);\n-                    let impl_self_ty = self.normalize(impl_self_ty, locations);\n-\n-                    // There may be type variables in `substs` and hence\n-                    // in `impl_self_ty`, but they should all have been\n-                    // resolved to some fixed value during the first call\n-                    // to `relate`, above. Therefore, if we use\n-                    // `resolve_type_vars_if_possible` we should get to\n-                    // something without type variables. This is important\n-                    // because the `b` type in `relate_with_variance`\n-                    // below is not permitted to have inference variables.\n-                    let impl_self_ty = self.infcx.resolve_type_vars_if_possible(&impl_self_ty);\n-                    assert!(!impl_self_ty.has_infer_types());\n-\n-                    self.eq_types(self_ty, impl_self_ty, locations, category)?;\n-\n-                    self.prove_predicate(\n-                        ty::Predicate::WellFormed(impl_self_ty),\n-                        locations,\n-                        category,\n-                    );\n-                }\n-\n-                // Prove the predicates coming along with `def_id`.\n-                //\n-                // Also, normalize the `instantiated_predicates`\n-                // because otherwise we wind up with duplicate \"type\n-                // outlives\" error messages.\n-                let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n-                let instantiated_predicates = self.fold_to_region_vid(instantiated_predicates);\n-                self.normalize_and_prove_instantiated_predicates(\n-                    instantiated_predicates,\n+                self.fully_perform_op(\n                     locations,\n-                );\n-\n-                // In addition to proving the predicates, we have to\n-                // prove that `ty` is well-formed -- this is because\n-                // the WF of `ty` is predicated on the substs being\n-                // well-formed, and we haven't proven *that*. We don't\n-                // want to prove the WF of types from  `substs` directly because they\n-                // haven't been normalized.\n-                //\n-                // FIXME(nmatsakis): Well, perhaps we should normalize\n-                // them?  This would only be relevant if some input\n-                // type were ill-formed but did not appear in `ty`,\n-                // which...could happen with normalization...\n-                self.prove_predicate(ty::Predicate::WellFormed(ty), locations, category);\n+                    category,\n+                    self.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n+                        a, v, def_id, user_substs,\n+                    )),\n+                )?;\n             }\n         }\n \n         Ok(())\n     }\n \n-    /// Replace all free regions in `value` with their NLL `RegionVid`\n-    /// equivalents; if not in NLL, does nothing. This is never\n-    /// particularly necessary -- we'll do it lazilly as we process\n-    /// the value anyway -- but in some specific cases it is useful to\n-    /// normalize so we can suppress duplicate error messages.\n-    fn fold_to_region_vid<T>(&self, value: T) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        if let Some(borrowck_context) = &self.borrowck_context {\n-            self.tcx().fold_regions(&value, &mut false, |r, _debruijn| {\n-                if r.has_free_regions() {\n-                    self.tcx().mk_region(ty::RegionKind::ReVar(\n-                        borrowck_context.universal_regions.to_region_vid(r),\n-                    ))\n-                } else {\n-                    r\n-                }\n-            })\n-        } else {\n-            value\n-        }\n-    }\n-\n     fn eq_opaque_type_and_type(\n         &mut self,\n         revealed_ty: Ty<'tcx>,"}, {"sha": "cf274a9c8510576d51570c8c0feba0805600834e", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 159, "deletions": 3, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=3476ac0bee4042653ecb00207ceb9e02d2b647d0", "patch": "@@ -8,22 +8,32 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::infer::at::ToTrace;\n use rustc::infer::canonical::{Canonical, QueryResponse};\n use rustc::infer::InferCtxt;\n+use rustc::hir::def_id::DefId;\n+use rustc::traits::query::type_op::ascribe_user_type::AscribeUserType;\n use rustc::traits::query::type_op::eq::Eq;\n use rustc::traits::query::type_op::normalize::Normalize;\n use rustc::traits::query::type_op::prove_predicate::ProvePredicate;\n use rustc::traits::query::type_op::subtype::Subtype;\n use rustc::traits::query::{Fallible, NoSolution};\n-use rustc::traits::{FulfillmentContext, Normalized, Obligation, ObligationCause, TraitEngine,\n-                    TraitEngineExt};\n+use rustc::traits::{\n+    FulfillmentContext, Normalized, Obligation, ObligationCause, TraitEngine, TraitEngineExt,\n+};\n use rustc::ty::query::Providers;\n-use rustc::ty::{FnSig, Lift, ParamEnvAnd, PolyFnSig, Predicate, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::subst::{Kind, Subst, UserSelfTy, UserSubsts};\n+use rustc::ty::{\n+    FnSig, Lift, ParamEnv, ParamEnvAnd, PolyFnSig, Predicate, Ty, TyCtxt, TypeFoldable, Variance,\n+};\n use rustc_data_structures::sync::Lrc;\n use std::fmt;\n+use syntax::ast;\n+use syntax_pos::DUMMY_SP;\n \n crate fn provide(p: &mut Providers) {\n     *p = Providers {\n+        type_op_ascribe_user_type,\n         type_op_eq,\n         type_op_prove_predicate,\n         type_op_subtype,\n@@ -35,6 +45,152 @@ crate fn provide(p: &mut Providers) {\n     };\n }\n \n+fn type_op_ascribe_user_type<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, AscribeUserType<'tcx>>>,\n+) -> Result<Lrc<Canonical<'tcx, QueryResponse<'tcx, ()>>>, NoSolution> {\n+    tcx.infer_ctxt()\n+        .enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n+            let (\n+                param_env,\n+                AscribeUserType {\n+                    mir_ty,\n+                    variance,\n+                    def_id,\n+                    user_substs,\n+                },\n+            ) = key.into_parts();\n+\n+            debug!(\n+                \"type_op_ascribe_user_type(\\\n+                 mir_ty={:?}, variance={:?}, def_id={:?}, user_substs={:?}\\\n+                 )\",\n+                mir_ty, variance, def_id, user_substs,\n+            );\n+\n+            let mut cx = AscribeUserTypeCx {\n+                infcx,\n+                param_env,\n+                fulfill_cx,\n+            };\n+            cx.relate_mir_and_user_ty(mir_ty, variance, def_id, user_substs)?;\n+\n+            Ok(())\n+        })\n+}\n+\n+struct AscribeUserTypeCx<'me, 'gcx: 'tcx, 'tcx: 'me> {\n+    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    fulfill_cx: &'me mut FulfillmentContext<'tcx>,\n+}\n+\n+impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n+    fn normalize<T>(&mut self, value: T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.infcx\n+            .partially_normalize_associated_types_in(\n+                DUMMY_SP,\n+                ast::CRATE_NODE_ID,\n+                self.param_env,\n+                &value,\n+            )\n+            .into_value_registering_obligations(self.infcx, self.fulfill_cx)\n+    }\n+\n+    fn relate<T>(&mut self, a: T, variance: Variance, b: T) -> Result<(), NoSolution>\n+    where\n+        T: ToTrace<'tcx>,\n+    {\n+        Ok(self.infcx\n+            .at(&ObligationCause::dummy(), self.param_env)\n+           .relate(a, variance, b)?\n+           .into_value_registering_obligations(self.infcx, self.fulfill_cx))\n+    }\n+\n+    fn prove_predicate(&mut self, predicate: Predicate<'tcx>) {\n+        self.fulfill_cx.register_predicate_obligation(\n+            self.infcx,\n+            Obligation::new(ObligationCause::dummy(), self.param_env, predicate),\n+        );\n+    }\n+\n+    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn subst<T>(&self, value: T, substs: &[Kind<'tcx>]) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        value.subst(self.tcx(), substs)\n+    }\n+\n+    fn relate_mir_and_user_ty(\n+        &mut self,\n+        mir_ty: Ty<'tcx>,\n+        variance: Variance,\n+        def_id: DefId,\n+        user_substs: UserSubsts<'tcx>,\n+    ) -> Result<(), NoSolution> {\n+        let UserSubsts {\n+            substs,\n+            user_self_ty,\n+        } = user_substs;\n+\n+        let ty = self.tcx().type_of(def_id);\n+        let ty = self.subst(ty, substs);\n+        debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n+        let ty = self.normalize(ty);\n+\n+        self.relate(mir_ty, variance, ty)?;\n+\n+        if let Some(UserSelfTy {\n+            impl_def_id,\n+            self_ty,\n+        }) = user_self_ty\n+        {\n+            let impl_self_ty = self.tcx().type_of(impl_def_id);\n+            let impl_self_ty = self.subst(impl_self_ty, &substs);\n+            let impl_self_ty = self.normalize(impl_self_ty);\n+\n+            self.relate(self_ty, Variance::Invariant, impl_self_ty)?;\n+\n+            self.prove_predicate(Predicate::WellFormed(impl_self_ty));\n+        }\n+\n+        // Prove the predicates coming along with `def_id`.\n+        //\n+        // Also, normalize the `instantiated_predicates`\n+        // because otherwise we wind up with duplicate \"type\n+        // outlives\" error messages.\n+        let instantiated_predicates = self.tcx()\n+            .predicates_of(def_id)\n+            .instantiate(self.tcx(), substs);\n+        for instantiated_predicate in instantiated_predicates.predicates {\n+            let instantiated_predicate = self.normalize(instantiated_predicate);\n+            self.prove_predicate(instantiated_predicate);\n+        }\n+\n+        // In addition to proving the predicates, we have to\n+        // prove that `ty` is well-formed -- this is because\n+        // the WF of `ty` is predicated on the substs being\n+        // well-formed, and we haven't proven *that*. We don't\n+        // want to prove the WF of types from  `substs` directly because they\n+        // haven't been normalized.\n+        //\n+        // FIXME(nmatsakis): Well, perhaps we should normalize\n+        // them?  This would only be relevant if some input\n+        // type were ill-formed but did not appear in `ty`,\n+        // which...could happen with normalization...\n+        self.prove_predicate(Predicate::WellFormed(ty));\n+\n+        Ok(())\n+    }\n+}\n+\n fn type_op_eq<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Eq<'tcx>>>,"}, {"sha": "7daa5a59b997746e63246a42d52923c38917c828", "filename": "src/test/ui/nll/user-annotations/issue-55219.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55219.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55219.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55219.rs?ref=3476ac0bee4042653ecb00207ceb9e02d2b647d0", "patch": "@@ -0,0 +1,20 @@\n+// Regression test for #55219:\n+//\n+// The `Self::HASH_LEN` here expands to a \"self-type\" where `T` is not\n+// known. This unbound inference variable was causing an ICE.\n+//\n+// run-pass\n+\n+#![feature(nll)]\n+\n+pub struct Foo<T>(T);\n+\n+impl<T> Foo<T> {\n+    const HASH_LEN: usize = 20;\n+\n+    fn stuff() {\n+        let _ = Self::HASH_LEN;\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "e5600803df85676e5361fc653ffff0a54023618e", "filename": "src/test/ui/nll/user-annotations/issue-55241.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55241.rs?ref=3476ac0bee4042653ecb00207ceb9e02d2b647d0", "patch": "@@ -0,0 +1,28 @@\n+// Regression test for #55241:\n+//\n+// The reference to `C::HASHED_NULL_NODE` resulted in a type like `<C\n+// as NodeCodec<_>>::Out`; normalizing this type requires knowing the\n+// value of `_`; solving that requires having normalized, so we can\n+// test against `C: NodeCodec<H>` in the environment.\n+//\n+// run-pass\n+\n+#![feature(nll)]\n+\n+pub trait Hasher {\n+    type Out: Eq;\n+}\n+\n+pub trait NodeCodec<H: Hasher> {\n+    const HASHED_NULL_NODE: H::Out;\n+}\n+\n+pub trait Trie<H: Hasher, C: NodeCodec<H>> {\n+    /// Return the root of the trie.\n+    fn root(&self) -> &H::Out;\n+\n+    /// Is the trie empty?\n+    fn is_empty(&self) -> bool { *self.root() == C::HASHED_NULL_NODE }\n+}\n+\n+fn main() { }"}, {"sha": "39f193c55f77aab8e43e336dfd95c196c2f96569", "filename": "src/test/ui/regions/regions-free-region-ordering-caller1.nll.stderr", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3476ac0bee4042653ecb00207ceb9e02d2b647d0/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-caller1.nll.stderr?ref=3476ac0bee4042653ecb00207ceb9e02d2b647d0", "patch": "@@ -12,21 +12,6 @@ LL |     let z: &'a & usize = &(&y);\n LL | }\n    | - temporary value is freed at the end of this statement\n \n-error[E0597]: `y` does not live long enough\n-  --> $DIR/regions-free-region-ordering-caller1.rs:19:27\n-   |\n-LL | fn call1<'a>(x: &'a usize) {\n-   |          -- lifetime `'a` defined here\n-...\n-LL |     let z: &'a & usize = &(&y);\n-   |            -----------    ^^^^ borrowed value does not live long enough\n-   |            |\n-   |            type annotation requires that `y` is borrowed for `'a`\n-...\n-LL | }\n-   | - `y` dropped here while still borrowed\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors occurred: E0597, E0716.\n-For more information about an error, try `rustc --explain E0597`.\n+For more information about this error, try `rustc --explain E0716`."}]}