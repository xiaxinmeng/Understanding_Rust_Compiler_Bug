{"sha": "4d8de63fb3159dc31fc3c3f54c4a39794e694edf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkOGRlNjNmYjMxNTlkYzMxZmMzYzNmNTRjNGEzOTc5NGU2OTRlZGY=", "commit": {"author": {"name": "Stuart Pernsteiner", "email": "spernsteiner@mozilla.com", "date": "2014-07-03T23:03:26Z"}, "committer": {"name": "Stuart Pernsteiner", "email": "spernsteiner@mozilla.com", "date": "2014-07-29T20:54:40Z"}, "message": "speed up static linking by combining `ar` invocations", "tree": {"sha": "fccd17c72394fd1c9b9257731d2d139ea052b9db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fccd17c72394fd1c9b9257731d2d139ea052b9db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d8de63fb3159dc31fc3c3f54c4a39794e694edf", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d8de63fb3159dc31fc3c3f54c4a39794e694edf", "html_url": "https://github.com/rust-lang/rust/commit/4d8de63fb3159dc31fc3c3f54c4a39794e694edf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d8de63fb3159dc31fc3c3f54c4a39794e694edf/comments", "author": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79e9f14abf50eecb7d3c53f10ad900615bb2d397", "url": "https://api.github.com/repos/rust-lang/rust/commits/79e9f14abf50eecb7d3c53f10ad900615bb2d397", "html_url": "https://github.com/rust-lang/rust/commit/79e9f14abf50eecb7d3c53f10ad900615bb2d397"}], "stats": {"total": 228, "additions": 161, "deletions": 67}, "files": [{"sha": "1f02a348be7d0f803e65bd7128b907c06e45a709", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4d8de63fb3159dc31fc3c3f54c4a39794e694edf/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d8de63fb3159dc31fc3c3f54c4a39794e694edf/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=4d8de63fb3159dc31fc3c3f54c4a39794e694edf", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::archive::{Archive, ArchiveConfig, METADATA_FILENAME};\n+use super::archive::{Archive, ArchiveBuilder, ArchiveConfig, METADATA_FILENAME};\n use super::rpath;\n use super::rpath::RPathConfig;\n use super::svh::Svh;\n@@ -983,7 +983,7 @@ fn link_binary_output(sess: &Session,\n \n     match crate_type {\n         config::CrateTypeRlib => {\n-            link_rlib(sess, Some(trans), &obj_filename, &out_filename);\n+            link_rlib(sess, Some(trans), &obj_filename, &out_filename).build();\n         }\n         config::CrateTypeStaticlib => {\n             link_staticlib(sess, &obj_filename, &out_filename);\n@@ -1019,7 +1019,7 @@ fn archive_search_paths(sess: &Session) -> Vec<Path> {\n fn link_rlib<'a>(sess: &'a Session,\n                  trans: Option<&CrateTranslation>, // None == no metadata/bytecode\n                  obj_filename: &Path,\n-                 out_filename: &Path) -> Archive<'a> {\n+                 out_filename: &Path) -> ArchiveBuilder<'a> {\n     let handler = &sess.diagnostic().handler;\n     let config = ArchiveConfig {\n         handler: handler,\n@@ -1028,17 +1028,30 @@ fn link_rlib<'a>(sess: &'a Session,\n         os: sess.targ_cfg.os,\n         maybe_ar_prog: sess.opts.cg.ar.clone()\n     };\n-    let mut a = Archive::create(config, obj_filename);\n+    let mut ab = ArchiveBuilder::create(config);\n+    ab.add_file(obj_filename).unwrap();\n \n     for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n         match kind {\n             cstore::NativeStatic => {\n-                a.add_native_library(l.as_slice()).unwrap();\n+                ab.add_native_library(l.as_slice()).unwrap();\n             }\n             cstore::NativeFramework | cstore::NativeUnknown => {}\n         }\n     }\n \n+    // After adding all files to the archive, we need to update the\n+    // symbol table of the archive.\n+    ab.update_symbols();\n+\n+    let mut ab = match sess.targ_cfg.os {\n+        // For OSX/iOS, we must be careful to update symbols only when adding\n+        // object files.  We're about to start adding non-object files, so run\n+        // `ar` now to process the object files.\n+        abi::OsMacos | abi::OsiOS => ab.build().extend(),\n+        _ => ab,\n+    };\n+\n     // Note that it is important that we add all of our non-object \"magical\n     // files\" *after* all of the object files in the archive. The reason for\n     // this is as follows:\n@@ -1078,7 +1091,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                     sess.abort_if_errors();\n                 }\n             }\n-            a.add_file(&metadata, false);\n+            ab.add_file(&metadata).unwrap();\n             remove(sess, &metadata);\n \n             // For LTO purposes, the bytecode of this library is also inserted\n@@ -1105,25 +1118,18 @@ fn link_rlib<'a>(sess: &'a Session,\n                     sess.abort_if_errors()\n                 }\n             }\n-            a.add_file(&bc_deflated, false);\n+            ab.add_file(&bc_deflated).unwrap();\n             remove(sess, &bc_deflated);\n             if !sess.opts.cg.save_temps &&\n                !sess.opts.output_types.contains(&OutputTypeBitcode) {\n                 remove(sess, &bc);\n             }\n-\n-            // After adding all files to the archive, we need to update the\n-            // symbol table of the archive. This currently dies on OSX (see\n-            // #11162), and isn't necessary there anyway\n-            match sess.targ_cfg.os {\n-                abi::OsMacos | abi::OsiOS => {}\n-                _ => { a.update_symbols(); }\n-            }\n         }\n \n         None => {}\n     }\n-    return a;\n+\n+    ab\n }\n \n // Create a static archive\n@@ -1139,9 +1145,13 @@ fn link_rlib<'a>(sess: &'a Session,\n // link in the metadata object file (and also don't prepare the archive with a\n // metadata file).\n fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n-    let mut a = link_rlib(sess, None, obj_filename, out_filename);\n-    a.add_native_library(\"morestack\").unwrap();\n-    a.add_native_library(\"compiler-rt\").unwrap();\n+    let ab = link_rlib(sess, None, obj_filename, out_filename);\n+    let mut ab = match sess.targ_cfg.os {\n+        abi::OsMacos | abi::OsiOS => ab.build().extend(),\n+        _ => ab,\n+    };\n+    ab.add_native_library(\"morestack\").unwrap();\n+    ab.add_native_library(\"compiler-rt\").unwrap();\n \n     let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n     let mut all_native_libs = vec![];\n@@ -1155,12 +1165,15 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n                 continue\n             }\n         };\n-        a.add_rlib(&p, name.as_slice(), sess.lto()).unwrap();\n+        ab.add_rlib(&p, name.as_slice(), sess.lto()).unwrap();\n \n         let native_libs = csearch::get_native_libraries(&sess.cstore, cnum);\n         all_native_libs.extend(native_libs.move_iter());\n     }\n \n+    ab.update_symbols();\n+    let _ = ab.build();\n+\n     if !all_native_libs.is_empty() {\n         sess.warn(\"link against the following native artifacts when linking against \\\n                   this static library\");"}, {"sha": "e2cadf817d5ea1e220f73006b6f070e0b37e5624", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 128, "deletions": 47, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/4d8de63fb3159dc31fc3c3f54c4a39794e694edf/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d8de63fb3159dc31fc3c3f54c4a39794e694edf/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=4d8de63fb3159dc31fc3c3f54c4a39794e694edf", "patch": "@@ -36,6 +36,17 @@ pub struct Archive<'a> {\n     maybe_ar_prog: Option<String>\n }\n \n+/// Helper for adding many files to an archive with a single invocation of\n+/// `ar`.\n+#[must_use = \"must call build() to finish building the archive\"]\n+pub struct ArchiveBuilder<'a> {\n+    archive: Archive<'a>,\n+    work_dir: TempDir,\n+    /// Filename of each member that should be added to the archive.\n+    members: Vec<Path>,\n+    should_update_symbols: bool,\n+}\n+\n fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n           args: &str, cwd: Option<&Path>,\n           paths: &[&Path]) -> ProcessOutput {\n@@ -85,10 +96,8 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n }\n \n impl<'a> Archive<'a> {\n-    /// Initializes a new static archive with the given object file\n-    pub fn create<'b>(config: ArchiveConfig<'a>, initial_object: &'b Path) -> Archive<'a> {\n+    fn new(config: ArchiveConfig<'a>) -> Archive<'a> {\n         let ArchiveConfig { handler, dst, lib_search_paths, os, maybe_ar_prog } = config;\n-        run_ar(handler, &maybe_ar_prog, \"crus\", None, [&dst, initial_object]);\n         Archive {\n             handler: handler,\n             dst: dst,\n@@ -100,17 +109,47 @@ impl<'a> Archive<'a> {\n \n     /// Opens an existing static archive\n     pub fn open(config: ArchiveConfig<'a>) -> Archive<'a> {\n-        let ArchiveConfig { handler, dst, lib_search_paths, os, maybe_ar_prog } = config;\n-        assert!(dst.exists());\n-        Archive {\n-            handler: handler,\n-            dst: dst,\n-            lib_search_paths: lib_search_paths,\n-            os: os,\n-            maybe_ar_prog: maybe_ar_prog\n+        let archive = Archive::new(config);\n+        assert!(archive.dst.exists());\n+        archive\n+    }\n+\n+    /// Removes a file from this archive\n+    pub fn remove_file(&mut self, file: &str) {\n+        run_ar(self.handler, &self.maybe_ar_prog, \"d\", None, [&self.dst, &Path::new(file)]);\n+    }\n+\n+    /// Lists all files in an archive\n+    pub fn files(&self) -> Vec<String> {\n+        let output = run_ar(self.handler, &self.maybe_ar_prog, \"t\", None, [&self.dst]);\n+        let output = str::from_utf8(output.output.as_slice()).unwrap();\n+        // use lines_any because windows delimits output with `\\r\\n` instead of\n+        // just `\\n`\n+        output.lines_any().map(|s| s.to_string()).collect()\n+    }\n+\n+    /// Creates an `ArchiveBuilder` for adding files to this archive.\n+    pub fn extend(self) -> ArchiveBuilder<'a> {\n+        ArchiveBuilder::new(self)\n+    }\n+}\n+\n+impl<'a> ArchiveBuilder<'a> {\n+    fn new(archive: Archive<'a>) -> ArchiveBuilder<'a> {\n+        ArchiveBuilder {\n+            archive: archive,\n+            work_dir: TempDir::new(\"rsar\").unwrap(),\n+            members: vec![],\n+            should_update_symbols: false,\n         }\n     }\n \n+    /// Create a new static archive, ready for adding files.\n+    pub fn create(config: ArchiveConfig<'a>) -> ArchiveBuilder<'a> {\n+        let archive = Archive::new(config);\n+        ArchiveBuilder::new(archive)\n+    }\n+\n     /// Adds all of the contents of a native library to this archive. This will\n     /// search in the relevant locations for a library named `name`.\n     pub fn add_native_library(&mut self, name: &str) -> io::IoResult<()> {\n@@ -135,48 +174,96 @@ impl<'a> Archive<'a> {\n     }\n \n     /// Adds an arbitrary file to this archive\n-    pub fn add_file(&mut self, file: &Path, has_symbols: bool) {\n-        let cmd = if has_symbols {\"r\"} else {\"rS\"};\n-        run_ar(self.handler, &self.maybe_ar_prog, cmd, None, [&self.dst, file]);\n-    }\n-\n-    /// Removes a file from this archive\n-    pub fn remove_file(&mut self, file: &str) {\n-        run_ar(self.handler, &self.maybe_ar_prog, \"d\", None, [&self.dst, &Path::new(file)]);\n+    pub fn add_file(&mut self, file: &Path) -> io::IoResult<()> {\n+        let filename = Path::new(file.filename().unwrap());\n+        let new_file = self.work_dir.path().join(&filename);\n+        try!(fs::copy(file, &new_file));\n+        self.members.push(filename);\n+        Ok(())\n     }\n \n-    /// Updates all symbols in the archive (runs 'ar s' over it)\n+    /// Indicate that the next call to `build` should updates all symbols in\n+    /// the archive (run 'ar s' over it).\n     pub fn update_symbols(&mut self) {\n-        run_ar(self.handler, &self.maybe_ar_prog, \"s\", None, [&self.dst]);\n+        self.should_update_symbols = true;\n     }\n \n-    /// Lists all files in an archive\n-    pub fn files(&self) -> Vec<String> {\n-        let output = run_ar(self.handler, &self.maybe_ar_prog, \"t\", None, [&self.dst]);\n-        let output = str::from_utf8(output.output.as_slice()).unwrap();\n-        // use lines_any because windows delimits output with `\\r\\n` instead of\n-        // just `\\n`\n-        output.lines_any().map(|s| s.to_string()).collect()\n+    /// Combine the provided files, rlibs, and native libraries into a single\n+    /// `Archive`.\n+    pub fn build(self) -> Archive<'a> {\n+        // Get an absolute path to the destination, so `ar` will work even\n+        // though we run it from `self.work_dir`.\n+        let abs_dst = os::getcwd().join(&self.archive.dst);\n+        assert!(!abs_dst.is_relative());\n+        let mut args = vec![&abs_dst];\n+        let mut total_len = abs_dst.as_vec().len();\n+\n+        if self.members.is_empty() {\n+            // OSX `ar` does not allow using `r` with no members, but it does\n+            // allow running `ar s file.a` to update symbols only.\n+            if self.should_update_symbols {\n+                run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n+                       \"s\", Some(self.work_dir.path()), args.as_slice());\n+            }\n+            return self.archive;\n+        }\n+\n+        // Don't allow the total size of `args` to grow beyond 32,000 bytes.\n+        // Windows will raise an error if the argument string is longer than\n+        // 32,768, and we leave a bit of extra space for the program name.\n+        static ARG_LENGTH_LIMIT: uint = 32000;\n+\n+        for member_name in self.members.iter() {\n+            let len = member_name.as_vec().len();\n+\n+            // `len + 1` to account for the space that's inserted before each\n+            // argument.  (Windows passes command-line arguments as a single\n+            // string, not an array of strings.)\n+            if total_len + len + 1 > ARG_LENGTH_LIMIT {\n+                // Add the archive members seen so far, without updating the\n+                // symbol table (`S`).\n+                run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n+                       \"cruS\", Some(self.work_dir.path()), args.as_slice());\n+\n+                args.clear();\n+                args.push(&abs_dst);\n+                total_len = abs_dst.as_vec().len();\n+            }\n+\n+            args.push(member_name);\n+            total_len += len + 1;\n+        }\n+\n+        // Add the remaining archive members, and update the symbol table if\n+        // necessary.\n+        let flags = if self.should_update_symbols { \"crus\" } else { \"cruS\" };\n+        run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n+               flags, Some(self.work_dir.path()), args.as_slice());\n+\n+        self.archive\n     }\n \n     fn add_archive(&mut self, archive: &Path, name: &str,\n                    skip: &[&str]) -> io::IoResult<()> {\n         let loc = TempDir::new(\"rsar\").unwrap();\n \n-        // First, extract the contents of the archive to a temporary directory\n+        // First, extract the contents of the archive to a temporary directory.\n+        // We don't unpack directly into `self.work_dir` due to the possibility\n+        // of filename collisions.\n         let archive = os::make_absolute(archive);\n-        run_ar(self.handler, &self.maybe_ar_prog, \"x\", Some(loc.path()), [&archive]);\n+        run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n+               \"x\", Some(loc.path()), [&archive]);\n \n         // Next, we must rename all of the inputs to \"guaranteed unique names\".\n-        // The reason for this is that archives are keyed off the name of the\n-        // files, so if two files have the same name they will override one\n-        // another in the archive (bad).\n+        // We move each file into `self.work_dir` under its new unique name.\n+        // The reason for this renaming is that archives are keyed off the name\n+        // of the files, so if two files have the same name they will override\n+        // one another in the archive (bad).\n         //\n         // We skip any files explicitly desired for skipping, and we also skip\n         // all SYMDEF files as these are just magical placeholders which get\n         // re-created when we make a new archive anyway.\n         let files = try!(fs::readdir(loc.path()));\n-        let mut inputs = Vec::new();\n         for file in files.iter() {\n             let filename = file.filename_str().unwrap();\n             if skip.iter().any(|s| *s == filename) { continue }\n@@ -192,29 +279,23 @@ impl<'a> Archive<'a> {\n             } else {\n                 filename\n             };\n-            let new_filename = file.with_filename(filename);\n+            let new_filename = self.work_dir.path().join(filename.as_slice());\n             try!(fs::rename(file, &new_filename));\n-            inputs.push(new_filename);\n+            self.members.push(Path::new(filename));\n         }\n-        if inputs.len() == 0 { return Ok(()) }\n-\n-        // Finally, add all the renamed files to this archive\n-        let mut args = vec!(&self.dst);\n-        args.extend(inputs.iter());\n-        run_ar(self.handler, &self.maybe_ar_prog, \"r\", None, args.as_slice());\n         Ok(())\n     }\n \n     fn find_library(&self, name: &str) -> Path {\n-        let (osprefix, osext) = match self.os {\n+        let (osprefix, osext) = match self.archive.os {\n             abi::OsWin32 => (\"\", \"lib\"), _ => (\"lib\", \"a\"),\n         };\n         // On Windows, static libraries sometimes show up as libfoo.a and other\n         // times show up as foo.lib\n         let oslibname = format!(\"{}{}.{}\", osprefix, name, osext);\n         let unixlibname = format!(\"lib{}.a\", name);\n \n-        for path in self.lib_search_paths.iter() {\n+        for path in self.archive.lib_search_paths.iter() {\n             debug!(\"looking for {} inside {}\", name, path.display());\n             let test = path.join(oslibname.as_slice());\n             if test.exists() { return test }\n@@ -223,9 +304,9 @@ impl<'a> Archive<'a> {\n                 if test.exists() { return test }\n             }\n         }\n-        self.handler.fatal(format!(\"could not find native static library `{}`, \\\n-                                 perhaps an -L flag is missing?\",\n-                                name).as_slice());\n+        self.archive.handler.fatal(format!(\"could not find native static library `{}`, \\\n+                                            perhaps an -L flag is missing?\",\n+                                           name).as_slice());\n     }\n }\n "}]}