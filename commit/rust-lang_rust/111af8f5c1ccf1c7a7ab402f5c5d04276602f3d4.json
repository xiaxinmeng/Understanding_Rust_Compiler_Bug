{"sha": "111af8f5c1ccf1c7a7ab402f5c5d04276602f3d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExMWFmOGY1YzFjY2YxYzdhN2FiNDAyZjVjNWQwNDI3NjYwMmYzZDQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-02-24T16:55:43Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-02-24T20:47:59Z"}, "message": "Rollup merge of #48206 - michaelwoerister:colors-array, r=nikomatsakis\n\nincr.comp.: Store DepNode colors in a dense array instead of a hashmap.\n\nImplements half of https://github.com/rust-lang/rust/issues/47293.\n\nr? @nikomatsakis", "tree": {"sha": "6298ecfa582f3dface1c184153160f788681be24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6298ecfa582f3dface1c184153160f788681be24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/111af8f5c1ccf1c7a7ab402f5c5d04276602f3d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/111af8f5c1ccf1c7a7ab402f5c5d04276602f3d4", "html_url": "https://github.com/rust-lang/rust/commit/111af8f5c1ccf1c7a7ab402f5c5d04276602f3d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/111af8f5c1ccf1c7a7ab402f5c5d04276602f3d4/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e96699337b6bec60f60b7c5cbb3f8cdd7647405b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e96699337b6bec60f60b7c5cbb3f8cdd7647405b", "html_url": "https://github.com/rust-lang/rust/commit/e96699337b6bec60f60b7c5cbb3f8cdd7647405b"}, {"sha": "d4b847504c2ecf32637486987ac299f91a3d1c54", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4b847504c2ecf32637486987ac299f91a3d1c54", "html_url": "https://github.com/rust-lang/rust/commit/d4b847504c2ecf32637486987ac299f91a3d1c54"}], "stats": {"total": 159, "additions": 112, "deletions": 47}, "files": [{"sha": "b77431e806a6d0ef48221b54dee73c4b00ec2397", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 104, "deletions": 44, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/111af8f5c1ccf1c7a7ab402f5c5d04276602f3d4/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/111af8f5c1ccf1c7a7ab402f5c5d04276602f3d4/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=111af8f5c1ccf1c7a7ab402f5c5d04276602f3d4", "patch": "@@ -74,7 +74,7 @@ struct DepGraphData {\n     /// nodes and edges as well as all fingerprints of nodes that have them.\n     previous: PreviousDepGraph,\n \n-    colors: RefCell<FxHashMap<DepNode, DepNodeColor>>,\n+    colors: RefCell<DepNodeColorMap>,\n \n     /// When we load, there may be `.o` files, cached mir, or other such\n     /// things available to us. If we find that they are not dirty, we\n@@ -97,16 +97,18 @@ impl DepGraph {\n         // Pre-allocate the fingerprints array. We over-allocate a little so\n         // that we hopefully don't have to re-allocate during this compilation\n         // session.\n+        let prev_graph_node_count = prev_graph.node_count();\n+\n         let fingerprints = IndexVec::from_elem_n(Fingerprint::ZERO,\n-                                                 (prev_graph.node_count() * 115) / 100);\n+                                                 (prev_graph_node_count * 115) / 100);\n         DepGraph {\n             data: Some(Rc::new(DepGraphData {\n                 previous_work_products: RefCell::new(FxHashMap()),\n                 work_products: RefCell::new(FxHashMap()),\n                 dep_node_debug: RefCell::new(FxHashMap()),\n                 current: RefCell::new(CurrentDepGraph::new()),\n                 previous: prev_graph,\n-                colors: RefCell::new(FxHashMap()),\n+                colors: RefCell::new(DepNodeColorMap::new(prev_graph_node_count)),\n                 loaded_from_cache: RefCell::new(FxHashMap()),\n             })),\n             fingerprints: Rc::new(RefCell::new(fingerprints)),\n@@ -213,8 +215,6 @@ impl DepGraph {\n               R: HashStable<HCX>,\n     {\n         if let Some(ref data) = self.data {\n-            debug_assert!(!data.colors.borrow().contains_key(&key));\n-\n             push(&data.current, key);\n             if cfg!(debug_assertions) {\n                 profq_msg(ProfileQueriesMsg::TaskBegin(key.clone()))\n@@ -254,19 +254,21 @@ impl DepGraph {\n             }\n \n             // Determine the color of the new DepNode.\n-            {\n-                let prev_fingerprint = data.previous.fingerprint_of(&key);\n+            if let Some(prev_index) = data.previous.node_to_index_opt(&key) {\n+                let prev_fingerprint = data.previous.fingerprint_by_index(prev_index);\n \n-                let color = if Some(current_fingerprint) == prev_fingerprint {\n+                let color = if current_fingerprint == prev_fingerprint {\n                     DepNodeColor::Green(dep_node_index)\n                 } else {\n                     DepNodeColor::Red\n                 };\n \n-                let old_value = data.colors.borrow_mut().insert(key, color);\n-                debug_assert!(old_value.is_none(),\n+                let mut colors = data.colors.borrow_mut();\n+                debug_assert!(colors.get(prev_index).is_none(),\n                               \"DepGraph::with_task() - Duplicate DepNodeColor \\\n                                insertion for {:?}\", key);\n+\n+                colors.insert(prev_index, color);\n             }\n \n             (result, dep_node_index)\n@@ -281,9 +283,11 @@ impl DepGraph {\n                 let mut fingerprints = self.fingerprints.borrow_mut();\n                 let dep_node_index = DepNodeIndex::new(fingerprints.len());\n                 fingerprints.push(fingerprint);\n+\n                 debug_assert!(fingerprints[dep_node_index] == fingerprint,\n                               \"DepGraph::with_task() - Assigned fingerprint to \\\n                                unexpected index for {:?}\", key);\n+\n                 (result, dep_node_index)\n             } else {\n                 (task(cx, arg), DepNodeIndex::INVALID)\n@@ -356,6 +360,15 @@ impl DepGraph {\n             .unwrap()\n     }\n \n+    #[inline]\n+    pub fn dep_node_exists(&self, dep_node: &DepNode) -> bool {\n+        if let Some(ref data) = self.data {\n+            data.current.borrow_mut().node_to_node_index.contains_key(dep_node)\n+        } else {\n+            false\n+        }\n+    }\n+\n     #[inline]\n     pub fn fingerprint_of(&self, dep_node_index: DepNodeIndex) -> Fingerprint {\n         match self.fingerprints.borrow().get(dep_node_index) {\n@@ -495,7 +508,17 @@ impl DepGraph {\n     }\n \n     pub fn node_color(&self, dep_node: &DepNode) -> Option<DepNodeColor> {\n-        self.data.as_ref().and_then(|data| data.colors.borrow().get(dep_node).cloned())\n+        if let Some(ref data) = self.data {\n+            if let Some(prev_index) = data.previous.node_to_index_opt(dep_node) {\n+                return data.colors.borrow().get(prev_index)\n+            } else {\n+                // This is a node that did not exist in the previous compilation\n+                // session, so we consider it to be red.\n+                return Some(DepNodeColor::Red)\n+            }\n+        }\n+\n+        None\n     }\n \n     pub fn try_mark_green<'tcx>(&self,\n@@ -505,7 +528,6 @@ impl DepGraph {\n         debug!(\"try_mark_green({:?}) - BEGIN\", dep_node);\n         let data = self.data.as_ref().unwrap();\n \n-        debug_assert!(!data.colors.borrow().contains_key(dep_node));\n         debug_assert!(!data.current.borrow().node_to_node_index.contains_key(dep_node));\n \n         if dep_node.kind.is_input() {\n@@ -535,19 +557,22 @@ impl DepGraph {\n             }\n         };\n \n+        debug_assert!(data.colors.borrow().get(prev_dep_node_index).is_none());\n+\n         let mut current_deps = Vec::new();\n \n         for &dep_dep_node_index in prev_deps {\n-            let dep_dep_node = &data.previous.index_to_node(dep_dep_node_index);\n+            let dep_dep_node_color = data.colors.borrow().get(dep_dep_node_index);\n \n-            let dep_dep_node_color = data.colors.borrow().get(dep_dep_node).cloned();\n             match dep_dep_node_color {\n                 Some(DepNodeColor::Green(node_index)) => {\n                     // This dependency has been marked as green before, we are\n                     // still fine and can continue with checking the other\n                     // dependencies.\n                     debug!(\"try_mark_green({:?}) --- found dependency {:?} to \\\n-                            be immediately green\", dep_node, dep_dep_node);\n+                            be immediately green\",\n+                            dep_node,\n+                            data.previous.index_to_node(dep_dep_node_index));\n                     current_deps.push(node_index);\n                 }\n                 Some(DepNodeColor::Red) => {\n@@ -556,10 +581,14 @@ impl DepGraph {\n                     // mark the DepNode as green and also don't need to bother\n                     // with checking any of the other dependencies.\n                     debug!(\"try_mark_green({:?}) - END - dependency {:?} was \\\n-                            immediately red\", dep_node, dep_dep_node);\n+                            immediately red\",\n+                            dep_node,\n+                            data.previous.index_to_node(dep_dep_node_index));\n                     return None\n                 }\n                 None => {\n+                    let dep_dep_node = &data.previous.index_to_node(dep_dep_node_index);\n+\n                     // We don't know the state of this dependency. If it isn't\n                     // an input node, let's try to mark it green recursively.\n                     if !dep_dep_node.kind.is_input() {\n@@ -601,10 +630,8 @@ impl DepGraph {\n                     debug!(\"try_mark_green({:?}) --- trying to force \\\n                             dependency {:?}\", dep_node, dep_dep_node);\n                     if ::ty::maps::force_from_dep_node(tcx, dep_dep_node) {\n-                        let dep_dep_node_color = data.colors\n-                                                     .borrow()\n-                                                     .get(dep_dep_node)\n-                                                     .cloned();\n+                        let dep_dep_node_color = data.colors.borrow().get(dep_dep_node_index);\n+\n                         match dep_dep_node_color {\n                             Some(DepNodeColor::Green(node_index)) => {\n                                 debug!(\"try_mark_green({:?}) --- managed to \\\n@@ -681,26 +708,21 @@ impl DepGraph {\n         }\n \n         // ... and finally storing a \"Green\" entry in the color map.\n-        let old_color = data.colors\n-                            .borrow_mut()\n-                            .insert(*dep_node, DepNodeColor::Green(dep_node_index));\n-        debug_assert!(old_color.is_none(),\n+        let mut colors = data.colors.borrow_mut();\n+        debug_assert!(colors.get(prev_dep_node_index).is_none(),\n                       \"DepGraph::try_mark_green() - Duplicate DepNodeColor \\\n                       insertion for {:?}\", dep_node);\n \n+        colors.insert(prev_dep_node_index, DepNodeColor::Green(dep_node_index));\n+\n         debug!(\"try_mark_green({:?}) - END - successfully marked as green\", dep_node);\n         Some(dep_node_index)\n     }\n \n-    // Used in various assertions\n-    pub fn is_green(&self, dep_node_index: DepNodeIndex) -> bool {\n-        let dep_node = self.data.as_ref().unwrap().current.borrow().nodes[dep_node_index];\n-        self.data.as_ref().unwrap().colors.borrow().get(&dep_node).map(|&color| {\n-            match color {\n-                DepNodeColor::Red => false,\n-                DepNodeColor::Green(_) => true,\n-            }\n-        }).unwrap_or(false)\n+    // Returns true if the given node has been marked as green during the\n+    // current compilation session. Used in various assertions\n+    pub fn is_green(&self, dep_node: &DepNode) -> bool {\n+        self.node_color(dep_node).map(|c| c.is_green()).unwrap_or(false)\n     }\n \n     // This method loads all on-disk cacheable query results into memory, so\n@@ -714,20 +736,25 @@ impl DepGraph {\n     pub fn exec_cache_promotions<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         let green_nodes: Vec<DepNode> = {\n             let data = self.data.as_ref().unwrap();\n-            data.colors.borrow().iter().filter_map(|(dep_node, color)| match color {\n-                DepNodeColor::Green(_) => {\n-                    if dep_node.cache_on_disk(tcx) {\n-                        Some(*dep_node)\n-                    } else {\n+            let colors = data.colors.borrow();\n+            colors.values.indices().filter_map(|prev_index| {\n+                match colors.get(prev_index) {\n+                    Some(DepNodeColor::Green(_)) => {\n+                        let dep_node = data.previous.index_to_node(prev_index);\n+                        if dep_node.cache_on_disk(tcx) {\n+                            Some(dep_node)\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    None |\n+                    Some(DepNodeColor::Red) => {\n+                        // We can skip red nodes because a node can only be marked\n+                        // as red if the query result was recomputed and thus is\n+                        // already in memory.\n                         None\n                     }\n                 }\n-                DepNodeColor::Red => {\n-                    // We can skip red nodes because a node can only be marked\n-                    // as red if the query result was recomputed and thus is\n-                    // already in memory.\n-                    None\n-                }\n             }).collect()\n         };\n \n@@ -1052,3 +1079,36 @@ enum OpenTask {\n         node: DepNode,\n     },\n }\n+\n+// A data structure that stores Option<DepNodeColor> values as a contiguous\n+// array, using one u32 per entry.\n+struct DepNodeColorMap {\n+    values: IndexVec<SerializedDepNodeIndex, u32>,\n+}\n+\n+const COMPRESSED_NONE: u32 = 0;\n+const COMPRESSED_RED: u32 = 1;\n+const COMPRESSED_FIRST_GREEN: u32 = 2;\n+\n+impl DepNodeColorMap {\n+    fn new(size: usize) -> DepNodeColorMap {\n+        DepNodeColorMap {\n+            values: IndexVec::from_elem_n(COMPRESSED_NONE, size)\n+        }\n+    }\n+\n+    fn get(&self, index: SerializedDepNodeIndex) -> Option<DepNodeColor> {\n+        match self.values[index] {\n+            COMPRESSED_NONE => None,\n+            COMPRESSED_RED => Some(DepNodeColor::Red),\n+            value => Some(DepNodeColor::Green(DepNodeIndex(value - COMPRESSED_FIRST_GREEN)))\n+        }\n+    }\n+\n+    fn insert(&mut self, index: SerializedDepNodeIndex, color: DepNodeColor) {\n+        self.values[index] = match color {\n+            DepNodeColor::Red => COMPRESSED_RED,\n+            DepNodeColor::Green(index) => index.0 + COMPRESSED_FIRST_GREEN,\n+        }\n+    }\n+}"}, {"sha": "504b60e763e23543fc9e5663acbe5bbf6a842429", "filename": "src/librustc/dep_graph/prev.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/111af8f5c1ccf1c7a7ab402f5c5d04276602f3d4/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/111af8f5c1ccf1c7a7ab402f5c5d04276602f3d4/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fprev.rs?ref=111af8f5c1ccf1c7a7ab402f5c5d04276602f3d4", "patch": "@@ -49,6 +49,11 @@ impl PreviousDepGraph {\n         self.index[dep_node]\n     }\n \n+    #[inline]\n+    pub fn node_to_index_opt(&self, dep_node: &DepNode) -> Option<SerializedDepNodeIndex> {\n+        self.index.get(dep_node).cloned()\n+    }\n+\n     #[inline]\n     pub fn fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n         self.index"}, {"sha": "626f19a1007d6a7ee650f22709b0484b6212c6f6", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/111af8f5c1ccf1c7a7ab402f5c5d04276602f3d4/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/111af8f5c1ccf1c7a7ab402f5c5d04276602f3d4/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=111af8f5c1ccf1c7a7ab402f5c5d04276602f3d4", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 match self.dep_graph.try_mark_green(self.global_tcx(), &dep_node) {\n                     Some(dep_node_index) => {\n-                        debug_assert!(self.dep_graph.is_green(dep_node_index));\n+                        debug_assert!(self.dep_graph.is_green(&dep_node));\n                         self.dep_graph.read_index(dep_node_index);\n                         Some(dep_node_index)\n                     }\n@@ -403,7 +403,7 @@ macro_rules! define_maps {\n                                                   dep_node: &DepNode)\n                                                   -> Result<$V, CycleError<'a, $tcx>>\n             {\n-                debug_assert!(tcx.dep_graph.is_green(dep_node_index));\n+                debug_assert!(tcx.dep_graph.is_green(dep_node));\n \n                 // First we try to load the result from the on-disk cache\n                 let result = if Self::cache_on_disk(key) &&\n@@ -491,7 +491,7 @@ macro_rules! define_maps {\n                      span: Span,\n                      dep_node: DepNode)\n                      -> Result<($V, DepNodeIndex), CycleError<'a, $tcx>> {\n-                debug_assert!(tcx.dep_graph.node_color(&dep_node).is_none());\n+                debug_assert!(!tcx.dep_graph.dep_node_exists(&dep_node));\n \n                 profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n                 let res = tcx.cycle_check(span, Query::$name(key), || {"}]}