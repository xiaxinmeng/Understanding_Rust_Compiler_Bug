{"sha": "11ca07c8ad5074b43d079adee37c8e0582bcad5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExY2EwN2M4YWQ1MDc0YjQzZDA3OWFkZWUzN2M4ZTA1ODJiY2FkNWQ=", "commit": {"author": {"name": "Martin Carton", "email": "cartonmartin+github@gmail.com", "date": "2016-11-24T17:12:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-24T17:12:20Z"}, "message": "Merge pull request #1360 from Manishearth/rustup\n\nRustup to *rustc 1.15.0-nightly (3bf2be9ce 2016-11-22)* and bump to 0.0.102", "tree": {"sha": "49d200511a1404313e74c012da332c2ca8040653", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49d200511a1404313e74c012da332c2ca8040653"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11ca07c8ad5074b43d079adee37c8e0582bcad5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11ca07c8ad5074b43d079adee37c8e0582bcad5d", "html_url": "https://github.com/rust-lang/rust/commit/11ca07c8ad5074b43d079adee37c8e0582bcad5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11ca07c8ad5074b43d079adee37c8e0582bcad5d/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9717b9585d69861e69144e97d51c05e4daad5ea3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9717b9585d69861e69144e97d51c05e4daad5ea3", "html_url": "https://github.com/rust-lang/rust/commit/9717b9585d69861e69144e97d51c05e4daad5ea3"}, {"sha": "9a92ed4e3ea862481485d3847d0e9af56f11ccb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a92ed4e3ea862481485d3847d0e9af56f11ccb3", "html_url": "https://github.com/rust-lang/rust/commit/9a92ed4e3ea862481485d3847d0e9af56f11ccb3"}], "stats": {"total": 107, "additions": 42, "deletions": 65}, "files": [{"sha": "c262e60230141bdabd3fd28a6f5079aa3d554636", "filename": "CHANGELOG.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11ca07c8ad5074b43d079adee37c8e0582bcad5d/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/11ca07c8ad5074b43d079adee37c8e0582bcad5d/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=11ca07c8ad5074b43d079adee37c8e0582bcad5d", "patch": "@@ -1,6 +1,9 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n+## 0.0.102 \u2014 date\n+* Update to *rustc 1.15.0-nightly (3bf2be9ce 2016-11-22)*\n+\n ## 0.0.101 \u2014 2016-11-23\n * Update to *rustc 1.15.0-nightly (7b3eeea22 2016-11-21)*\n * New lint: [`string_extend_chars`]"}, {"sha": "d0b50c3177b0e2a2e25bf0e6dcf34527305ead40", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11ca07c8ad5074b43d079adee37c8e0582bcad5d/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/11ca07c8ad5074b43d079adee37c8e0582bcad5d/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=11ca07c8ad5074b43d079adee37c8e0582bcad5d", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.101\"\n+version = \"0.0.102\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\",\n@@ -25,7 +25,7 @@ test = false\n \n [dependencies]\n # begin automatic update\n-clippy_lints = { version = \"0.0.101\", path = \"clippy_lints\" }\n+clippy_lints = { version = \"0.0.102\", path = \"clippy_lints\" }\n # end automatic update\n \n [dev-dependencies]"}, {"sha": "f19552ab3db6df490a20e024a703ae3dc8649095", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=11ca07c8ad5074b43d079adee37c8e0582bcad5d", "patch": "@@ -1,7 +1,7 @@\n [package]\n name = \"clippy_lints\"\n # begin automatic update\n-version = \"0.0.101\"\n+version = \"0.0.102\"\n # end automatic update\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\","}, {"sha": "89c57bba233b8d0ab78fcfa188049448721e583f", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=11ca07c8ad5074b43d079adee37c8e0582bcad5d", "patch": "@@ -9,7 +9,6 @@ use std::cmp::Ordering::{self, Equal};\n use std::cmp::PartialOrd;\n use std::hash::{Hash, Hasher};\n use std::mem;\n-use std::ops::Deref;\n use std::rc::Rc;\n use syntax::ast::{FloatTy, LitIntType, LitKind, StrStyle, UintTy, IntTy};\n use syntax::ptr::P;\n@@ -279,7 +278,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n \n     /// create `Some(Vec![..])` of all constants, unless there is any\n     /// non-constant part\n-    fn multi<E: Deref<Target = Expr> + Sized>(&mut self, vec: &[E]) -> Option<Vec<Constant>> {\n+    fn multi(&mut self, vec: &[Expr]) -> Option<Vec<Constant>> {\n         vec.iter()\n            .map(|elem| self.expr(elem))\n            .collect::<Option<_>>()"}, {"sha": "b369a3ae386e247cf704c94f8f7ed6292003a772", "filename": "clippy_lints/src/drop_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Fdrop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Fdrop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_ref.rs?ref=11ca07c8ad5074b43d079adee37c8e0582bcad5d", "patch": "@@ -44,7 +44,7 @@ impl LateLintPass for Pass {\n                     if args.len() != 1 {\n                         return;\n                     }\n-                    check_drop_arg(cx, expr.span, &*args[0]);\n+                    check_drop_arg(cx, expr.span, &args[0]);\n                 }\n             }\n         }"}, {"sha": "b251b02632faf714d0506560b2d430ae4a0b1d46", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=11ca07c8ad5074b43d079adee37c8e0582bcad5d", "patch": "@@ -117,7 +117,7 @@ impl<'a, 'tcx, 'v, 'b> Visitor<'v> for InsertVisitor<'a, 'tcx, 'b> {\n             let ExprMethodCall(ref name, _, ref params) = expr.node,\n             params.len() == 3,\n             &*name.node.as_str() == \"insert\",\n-            get_item_name(self.cx, self.map) == get_item_name(self.cx, &*params[0]),\n+            get_item_name(self.cx, self.map) == get_item_name(self.cx, &params[0]),\n             SpanlessEq::new(self.cx).eq_expr(self.key, &params[1])\n         ], {\n             span_lint_and_then(self.cx, MAP_ENTRY, self.span,"}, {"sha": "be93699bae65bde0b7f19f9171a33f789cae0b33", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=11ca07c8ad5074b43d079adee37c8e0582bcad5d", "patch": "@@ -4,7 +4,6 @@ use rustc::ty;\n use rustc::hir::*;\n use syntax::ast::{Lit, LitKind, Name};\n use syntax::codemap::{Span, Spanned};\n-use syntax::ptr::P;\n use utils::{get_item_name, in_macro, snippet, span_lint, span_lint_and_then, walk_ptrs_ty};\n \n /// **What it does:** Checks for getting the length of something via `.len()`\n@@ -170,7 +169,7 @@ fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str)\n     }\n }\n \n-fn check_len_zero(cx: &LateContext, span: Span, name: &Name, args: &[P<Expr>], lit: &Lit, op: &str) {\n+fn check_len_zero(cx: &LateContext, span: Span, name: &Name, args: &[Expr], lit: &Lit, op: &str) {\n     if let Spanned { node: LitKind::Int(0, _), .. } = *lit {\n         if &*name.as_str() == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n             span_lint_and_then(cx, LEN_ZERO, span, \"length comparison to zero\", |db| {"}, {"sha": "53c6eae91884cc5f494d8d5e6033212c76bdd7fe", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 19, "deletions": 39, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=11ca07c8ad5074b43d079adee37c8e0582bcad5d", "patch": "@@ -8,11 +8,9 @@ use rustc_const_eval::eval_const_expr_partial;\n use std::borrow::Cow;\n use std::fmt;\n use syntax::codemap::Span;\n-use syntax::ptr::P;\n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, match_path,\n             match_trait_method, match_type, method_chain_args, return_ty, same_tys, snippet,\n             span_lint, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n-use utils::MethodArgs;\n use utils::paths;\n use utils::sugg;\n \n@@ -693,7 +691,7 @@ impl LateLintPass for Pass {\n }\n \n /// Checks for the `OR_FUN_CALL` lint.\n-fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[P<hir::Expr>]) {\n+fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir::Expr]) {\n     /// Check for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n     fn check_unwrap_or_default(cx: &LateContext, name: &str, fun: &hir::Expr, self_expr: &hir::Expr, arg: &hir::Expr,\n                                or_has_args: bool, span: Span)\n@@ -825,7 +823,7 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n     }\n }\n \n-fn lint_vec_extend(cx: &LateContext, expr: &hir::Expr, args: &MethodArgs) {\n+fn lint_vec_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n     let arg_ty = cx.tcx.tables().expr_ty(&args[1]);\n     if let Some(slice) = derefs_to_slice(cx, &args[1], arg_ty) {\n         span_lint_and_then(cx, EXTEND_FROM_SLICE, expr.span, \"use of `extend` to extend a Vec by a slice\", |db| {\n@@ -838,7 +836,7 @@ fn lint_vec_extend(cx: &LateContext, expr: &hir::Expr, args: &MethodArgs) {\n     }\n }\n \n-fn lint_string_extend(cx: &LateContext, expr: &hir::Expr, args: &MethodArgs) {\n+fn lint_string_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n     let arg = &args[1];\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n         let target = &arglists[0][0];\n@@ -866,7 +864,7 @@ fn lint_string_extend(cx: &LateContext, expr: &hir::Expr, args: &MethodArgs) {\n     }\n }\n \n-fn lint_extend(cx: &LateContext, expr: &hir::Expr, args: &MethodArgs) {\n+fn lint_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n     let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.tables().expr_ty(&args[0]));\n     if match_type(cx, obj_ty, &paths::VEC) {\n         lint_vec_extend(cx, expr, args);\n@@ -891,9 +889,7 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwr\n     }}\n }\n \n-#[allow(ptr_arg)]\n-// Type of MethodArgs is potentially a Vec\n-fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &MethodArgs, is_mut: bool){\n+fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr], is_mut: bool){\n     let mut_str = if is_mut { \"_mut\" } else {\"\"};\n     let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tcx.tables().expr_ty(&iter_args[0])).is_some() {\n         \"slice\"\n@@ -917,7 +913,7 @@ fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &MethodArgs, is_\n     );\n }\n \n-fn lint_get_unwrap(cx: &LateContext, expr: &hir::Expr, get_args: &MethodArgs, is_mut: bool) {\n+fn lint_get_unwrap(cx: &LateContext, expr: &hir::Expr, get_args: &[hir::Expr], is_mut: bool) {\n     // Note: we don't want to lint `get_mut().unwrap` for HashMap or BTreeMap,\n     // because they do not implement `IndexMut`\n     let expr_ty = cx.tcx.tables().expr_ty(&get_args[0]);\n@@ -980,7 +976,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: ty::Ty) -> Option<sug\n \n     if let hir::ExprMethodCall(name, _, ref args) = expr.node {\n         if &*name.node.as_str() == \"iter\" && may_slice(cx, cx.tcx.tables().expr_ty(&args[0])) {\n-            sugg::Sugg::hir_opt(cx, &*args[0]).map(|sugg| {\n+            sugg::Sugg::hir_opt(cx, &args[0]).map(|sugg| {\n                 sugg.addr()\n             })\n         } else {\n@@ -1002,10 +998,8 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: ty::Ty) -> Option<sug\n     }\n }\n \n-#[allow(ptr_arg)]\n-// Type of MethodArgs is potentially a Vec\n /// lint use of `unwrap()` for `Option`s and `Result`s\n-fn lint_unwrap(cx: &LateContext, expr: &hir::Expr, unwrap_args: &MethodArgs) {\n+fn lint_unwrap(cx: &LateContext, expr: &hir::Expr, unwrap_args: &[hir::Expr]) {\n     let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.tables().expr_ty(&unwrap_args[0]));\n \n     let mess = if match_type(cx, obj_ty, &paths::OPTION) {\n@@ -1028,10 +1022,8 @@ fn lint_unwrap(cx: &LateContext, expr: &hir::Expr, unwrap_args: &MethodArgs) {\n     }\n }\n \n-#[allow(ptr_arg)]\n-// Type of MethodArgs is potentially a Vec\n /// lint use of `ok().expect()` for `Result`s\n-fn lint_ok_expect(cx: &LateContext, expr: &hir::Expr, ok_args: &MethodArgs) {\n+fn lint_ok_expect(cx: &LateContext, expr: &hir::Expr, ok_args: &[hir::Expr]) {\n     // lint if the caller of `ok()` is a `Result`\n     if match_type(cx, cx.tcx.tables().expr_ty(&ok_args[0]), &paths::RESULT) {\n         let result_type = cx.tcx.tables().expr_ty(&ok_args[0]);\n@@ -1046,10 +1038,8 @@ fn lint_ok_expect(cx: &LateContext, expr: &hir::Expr, ok_args: &MethodArgs) {\n     }\n }\n \n-#[allow(ptr_arg)]\n-// Type of MethodArgs is potentially a Vec\n /// lint use of `map().unwrap_or()` for `Option`s\n-fn lint_map_unwrap_or(cx: &LateContext, expr: &hir::Expr, map_args: &MethodArgs, unwrap_args: &MethodArgs) {\n+fn lint_map_unwrap_or(cx: &LateContext, expr: &hir::Expr, map_args: &[hir::Expr], unwrap_args: &[hir::Expr]) {\n     // lint if the caller of `map()` is an `Option`\n     if match_type(cx, cx.tcx.tables().expr_ty(&map_args[0]), &paths::OPTION) {\n         // lint message\n@@ -1077,10 +1067,8 @@ fn lint_map_unwrap_or(cx: &LateContext, expr: &hir::Expr, map_args: &MethodArgs,\n     }\n }\n \n-#[allow(ptr_arg)]\n-// Type of MethodArgs is potentially a Vec\n /// lint use of `map().unwrap_or_else()` for `Option`s\n-fn lint_map_unwrap_or_else(cx: &LateContext, expr: &hir::Expr, map_args: &MethodArgs, unwrap_args: &MethodArgs) {\n+fn lint_map_unwrap_or_else(cx: &LateContext, expr: &hir::Expr, map_args: &[hir::Expr], unwrap_args: &[hir::Expr]) {\n     // lint if the caller of `map()` is an `Option`\n     if match_type(cx, cx.tcx.tables().expr_ty(&map_args[0]), &paths::OPTION) {\n         // lint message\n@@ -1108,10 +1096,8 @@ fn lint_map_unwrap_or_else(cx: &LateContext, expr: &hir::Expr, map_args: &Method\n     }\n }\n \n-#[allow(ptr_arg)]\n-// Type of MethodArgs is potentially a Vec\n /// lint use of `filter().next()` for `Iterators`\n-fn lint_filter_next(cx: &LateContext, expr: &hir::Expr, filter_args: &MethodArgs) {\n+fn lint_filter_next(cx: &LateContext, expr: &hir::Expr, filter_args: &[hir::Expr]) {\n     // lint if caller of `.filter().next()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` \\\n@@ -1131,9 +1117,8 @@ fn lint_filter_next(cx: &LateContext, expr: &hir::Expr, filter_args: &MethodArgs\n     }\n }\n \n-// Type of MethodArgs is potentially a Vec\n /// lint use of `filter().map()` for `Iterators`\n-fn lint_filter_map(cx: &LateContext, expr: &hir::Expr, _filter_args: &MethodArgs, _map_args: &MethodArgs) {\n+fn lint_filter_map(cx: &LateContext, expr: &hir::Expr, _filter_args: &[hir::Expr], _map_args: &[hir::Expr]) {\n     // lint if caller of `.filter().map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter(p).map(q)` on an `Iterator`. \\\n@@ -1142,9 +1127,8 @@ fn lint_filter_map(cx: &LateContext, expr: &hir::Expr, _filter_args: &MethodArgs\n     }\n }\n \n-// Type of MethodArgs is potentially a Vec\n /// lint use of `filter().map()` for `Iterators`\n-fn lint_filter_map_map(cx: &LateContext, expr: &hir::Expr, _filter_args: &MethodArgs, _map_args: &MethodArgs) {\n+fn lint_filter_map_map(cx: &LateContext, expr: &hir::Expr, _filter_args: &[hir::Expr], _map_args: &[hir::Expr]) {\n     // lint if caller of `.filter().map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter_map(p).map(q)` on an `Iterator`. \\\n@@ -1153,9 +1137,8 @@ fn lint_filter_map_map(cx: &LateContext, expr: &hir::Expr, _filter_args: &Method\n     }\n }\n \n-// Type of MethodArgs is potentially a Vec\n /// lint use of `filter().flat_map()` for `Iterators`\n-fn lint_filter_flat_map(cx: &LateContext, expr: &hir::Expr, _filter_args: &MethodArgs, _map_args: &MethodArgs) {\n+fn lint_filter_flat_map(cx: &LateContext, expr: &hir::Expr, _filter_args: &[hir::Expr], _map_args: &[hir::Expr]) {\n     // lint if caller of `.filter().flat_map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter(p).flat_map(q)` on an `Iterator`. \\\n@@ -1165,9 +1148,8 @@ fn lint_filter_flat_map(cx: &LateContext, expr: &hir::Expr, _filter_args: &Metho\n     }\n }\n \n-// Type of MethodArgs is potentially a Vec\n /// lint use of `filter_map().flat_map()` for `Iterators`\n-fn lint_filter_map_flat_map(cx: &LateContext, expr: &hir::Expr, _filter_args: &MethodArgs, _map_args: &MethodArgs) {\n+fn lint_filter_map_flat_map(cx: &LateContext, expr: &hir::Expr, _filter_args: &[hir::Expr], _map_args: &[hir::Expr]) {\n     // lint if caller of `.filter_map().flat_map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter_map(p).flat_map(q)` on an `Iterator`. \\\n@@ -1177,13 +1159,11 @@ fn lint_filter_map_flat_map(cx: &LateContext, expr: &hir::Expr, _filter_args: &M\n     }\n }\n \n-#[allow(ptr_arg)]\n-// Type of MethodArgs is potentially a Vec\n /// lint searching an Iterator followed by `is_some()`\n-fn lint_search_is_some(cx: &LateContext, expr: &hir::Expr, search_method: &str, search_args: &MethodArgs,\n-                       is_some_args: &MethodArgs) {\n+fn lint_search_is_some(cx: &LateContext, expr: &hir::Expr, search_method: &str, search_args: &[hir::Expr],\n+                       is_some_args: &[hir::Expr]) {\n     // lint if caller of search is an Iterator\n-    if match_trait_method(cx, &*is_some_args[0], &paths::ITERATOR) {\n+    if match_trait_method(cx, &is_some_args[0], &paths::ITERATOR) {\n         let msg = format!(\"called `is_some()` after searching an `Iterator` with {}. This is more succinctly expressed \\\n                            by calling `any()`.\",\n                           search_method);"}, {"sha": "771408a9be631e6f046e52f20cb947b7f3cb10af", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=11ca07c8ad5074b43d079adee37c8e0582bcad5d", "patch": "@@ -2,7 +2,6 @@ use consts::{Constant, constant_simple};\n use rustc::lint::*;\n use rustc::hir::*;\n use std::cmp::{PartialOrd, Ordering};\n-use syntax::ptr::P;\n use utils::{match_def_path, paths, span_lint};\n \n /// **What it does:** Checks for expressions where `std::cmp::min` and `max` are\n@@ -80,7 +79,7 @@ fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'\n     }\n }\n \n-fn fetch_const(args: &[P<Expr>], m: MinMax) -> Option<(MinMax, Constant, &Expr)> {\n+fn fetch_const(args: &[Expr], m: MinMax) -> Option<(MinMax, Constant, &Expr)> {\n     if args.len() != 2 {\n         return None;\n     }"}, {"sha": "6ad633489200aebeb9826925e7237ef966f11b18", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=11ca07c8ad5074b43d079adee37c8e0582bcad5d", "patch": "@@ -8,7 +8,6 @@ use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::eval_const_expr_partial;\n use rustc_const_math::ConstFloat;\n use syntax::codemap::{Span, Spanned, ExpnFormat};\n-use syntax::ptr::P;\n use utils::{\n     get_item_name, get_parent_expr, implements_trait, in_macro, is_integer_literal, match_path,\n     snippet, span_lint, span_lint_and_then, walk_ptrs_ty\n@@ -412,7 +411,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: S\n \n }\n \n-fn is_str_arg(cx: &LateContext, args: &[P<Expr>]) -> bool {\n+fn is_str_arg(cx: &LateContext, args: &[Expr]) -> bool {\n     args.len() == 1 &&\n         matches!(walk_ptrs_ty(cx.tcx.tables().expr_ty(&args[0])).sty, ty::TyStr)\n }"}, {"sha": "b2cdb2cb49b4ee365291d5c835183cd0b17f8f14", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=11ca07c8ad5074b43d079adee37c8e0582bcad5d", "patch": "@@ -1,7 +1,6 @@\n use rustc::lint::*;\n use rustc::ty::{TypeAndMut, TypeVariants, MethodCall, TyS};\n use rustc::hir::*;\n-use syntax::ptr::P;\n use utils::span_lint;\n \n /// **What it does:** Detects giving a mutable reference to a function that only\n@@ -57,7 +56,7 @@ impl LateLintPass for UnnecessaryMutPassed {\n     }\n }\n \n-fn check_arguments(cx: &LateContext, arguments: &[P<Expr>], type_definition: &TyS, name: &str) {\n+fn check_arguments(cx: &LateContext, arguments: &[Expr], type_definition: &TyS, name: &str) {\n     match type_definition.sty {\n         TypeVariants::TyFnDef(_, _, fn_type) |\n         TypeVariants::TyFnPtr(fn_type) => {"}, {"sha": "973daa696b649055c3cd6ee4f9e2108d28c2f565", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=11ca07c8ad5074b43d079adee37c8e0582bcad5d", "patch": "@@ -133,7 +133,7 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n         Expr_::ExprIndex(ref a, ref b) |\n         Expr_::ExprBinary(_, ref a, ref b) => Some(vec![&**a, &**b]),\n         Expr_::ExprArray(ref v) |\n-        Expr_::ExprTup(ref v) => Some(v.iter().map(Deref::deref).collect()),\n+        Expr_::ExprTup(ref v) => Some(v.iter().collect()),\n         Expr_::ExprRepeat(ref inner, _) |\n         Expr_::ExprCast(ref inner, _) |\n         Expr_::ExprType(ref inner, _) |\n@@ -150,7 +150,7 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n                 Some(Def::Struct(..)) |\n                 Some(Def::Variant(..)) |\n                 Some(Def::StructCtor(..)) |\n-                Some(Def::VariantCtor(..)) => Some(args.iter().map(Deref::deref).collect()),\n+                Some(Def::VariantCtor(..)) => Some(args.iter().collect()),\n                 _ => None,\n             }\n         }"}, {"sha": "a7e16a56f38602992edcd275334264966228ccd5", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=11ca07c8ad5074b43d079adee37c8e0582bcad5d", "patch": "@@ -107,7 +107,7 @@ impl LateLintPass for Transmute {\n                             e.span,\n                             \"transmute from a reference to a pointer\",\n                             |db| {\n-                                if let Some(arg) = sugg::Sugg::hir_opt(cx, &*args[0]) {\n+                                if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n                                     let sugg = if ptr_ty == rty {\n                                         arg.as_ty(to_ty)\n                                     } else {\n@@ -125,7 +125,7 @@ impl LateLintPass for Transmute {\n                             e.span,\n                             \"transmute from an integer to a pointer\",\n                             |db| {\n-                                if let Some(arg) = sugg::Sugg::hir_opt(cx, &*args[0]) {\n+                                if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n                                     db.span_suggestion(e.span, \"try\", arg.as_ty(&to_ty.to_string()).to_string());\n                                 }\n                             },"}, {"sha": "41c2861c2221c1c7dc8ea91fe62ea292f5bbc642", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=11ca07c8ad5074b43d079adee37c8e0582bcad5d", "patch": "@@ -5,7 +5,6 @@\n use rustc::hir;\n use rustc::lint::LateContext;\n use syntax::ast;\n-use syntax::ptr::P;\n use utils::{is_expn_of, match_path, match_def_path, resolve_node, paths};\n \n /// Convert a hir binary operator to the corresponding `ast` type.\n@@ -160,9 +159,9 @@ pub fn for_loop(expr: &hir::Expr) -> Option<(&hir::Pat, &hir::Expr, &hir::Expr)>\n /// Represent the pre-expansion arguments of a `vec!` invocation.\n pub enum VecArgs<'a> {\n     /// `vec![elem; len]`\n-    Repeat(&'a P<hir::Expr>, &'a P<hir::Expr>),\n+    Repeat(&'a hir::Expr, &'a hir::Expr),\n     /// `vec![a, b, c]`\n-    Vec(&'a [P<hir::Expr>]),\n+    Vec(&'a [hir::Expr]),\n }\n \n /// Returns the arguments of the `vec!` macro if this expression was expanded from `vec!`."}, {"sha": "459cf238911435bb76d152e67b6f6697e0f2fa25", "filename": "clippy_lints/src/utils/hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir.rs?ref=11ca07c8ad5074b43d079adee37c8e0582bcad5d", "patch": "@@ -134,7 +134,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_exprs(&self, left: &[P<Expr>], right: &[P<Expr>]) -> bool {\n+    fn eq_exprs(&self, left: &P<[Expr]>, right: &P<[Expr]>) -> bool {\n         over(left, right, |l, r| self.eq_expr(l, r))\n     }\n \n@@ -510,7 +510,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n         }\n     }\n \n-    pub fn hash_exprs(&mut self, e: &[P<Expr>]) {\n+    pub fn hash_exprs(&mut self, e: &P<[Expr]>) {\n         for e in e {\n             self.hash_expr(e);\n         }"}, {"sha": "47d693e03b2dc1c5ccd92205345d23d677fa0b28", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ca07c8ad5074b43d079adee37c8e0582bcad5d/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=11ca07c8ad5074b43d079adee37c8e0582bcad5d", "patch": "@@ -292,14 +292,14 @@ pub fn resolve_node(cx: &LateContext, id: NodeId) -> Option<def::Def> {\n /// For example, if `expr` represents the `.baz()` in `foo.bar().baz()`,\n /// `matched_method_chain(expr, &[\"bar\", \"baz\"])` will return a `Vec` containing the `Expr`s for\n /// `.bar()` and `.baz()`\n-pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a MethodArgs>> {\n+pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a [Expr]>> {\n     let mut current = expr;\n     let mut matched = Vec::with_capacity(methods.len());\n     for method_name in methods.iter().rev() {\n         // method chains are stored last -> first\n         if let ExprMethodCall(ref name, _, ref args) = current.node {\n             if name.node == *method_name {\n-                matched.push(args); // build up `matched` backwards\n+                matched.push(&**args); // build up `matched` backwards\n                 current = &args[0] // go to parent expression\n             } else {\n                 return None;"}]}