{"sha": "c296b2d8309100b27a89707b29f2583aa17e0d3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyOTZiMmQ4MzA5MTAwYjI3YTg5NzA3YjI5ZjI1ODNhYTE3ZTBkM2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-09T23:01:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-09T23:01:06Z"}, "message": "Auto merge of #65694 - wesleywiser:uninhabited_enum_variants_pass, r=oli-obk\n\n[mir-opt] Implement pass to remove branches on uninhabited variants\n\nBased on discussion [here](https://github.com/rust-lang/rust/pull/64890#discussion_r333612125), this is a pass to eliminate dead code that is caused by branching on an enum with uninhabited variants.\n\nr? @oli-obk", "tree": {"sha": "9efb1ae454a45112f00e654bb46c12e1ce0f4707", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9efb1ae454a45112f00e654bb46c12e1ce0f4707"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c296b2d8309100b27a89707b29f2583aa17e0d3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c296b2d8309100b27a89707b29f2583aa17e0d3e", "html_url": "https://github.com/rust-lang/rust/commit/c296b2d8309100b27a89707b29f2583aa17e0d3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c296b2d8309100b27a89707b29f2583aa17e0d3e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac162c6abe34cdf965afc0389f6cefa79653c63b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac162c6abe34cdf965afc0389f6cefa79653c63b", "html_url": "https://github.com/rust-lang/rust/commit/ac162c6abe34cdf965afc0389f6cefa79653c63b"}, {"sha": "cbe2f6095a3a15318aa54362beae3535a7b049a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbe2f6095a3a15318aa54362beae3535a7b049a2", "html_url": "https://github.com/rust-lang/rust/commit/cbe2f6095a3a15318aa54362beae3535a7b049a2"}], "stats": {"total": 354, "additions": 354, "deletions": 0}, "files": [{"sha": "be3bbf46f1c76067029c3bc92e113126b4f6479c", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c296b2d8309100b27a89707b29f2583aa17e0d3e/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c296b2d8309100b27a89707b29f2583aa17e0d3e/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=c296b2d8309100b27a89707b29f2583aa17e0d3e", "patch": "@@ -26,6 +26,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(associated_type_bounds)]\n #![feature(range_is_empty)]\n #![feature(stmt_expr_attributes)]\n+#![feature(bool_to_option)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "02ed12eda67a2ad4d071e5fcd09d2931bb1aafec", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c296b2d8309100b27a89707b29f2583aa17e0d3e/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c296b2d8309100b27a89707b29f2583aa17e0d3e/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=c296b2d8309100b27a89707b29f2583aa17e0d3e", "patch": "@@ -36,6 +36,7 @@ pub mod const_prop;\n pub mod generator;\n pub mod inline;\n pub mod uniform_array_move_out;\n+pub mod uninhabited_enum_branching;\n \n pub(crate) fn provide(providers: &mut Providers<'_>) {\n     self::qualify_consts::provide(providers);\n@@ -258,6 +259,8 @@ fn run_optimization_passes<'tcx>(\n \n \n         // Optimizations begin.\n+        &uninhabited_enum_branching::UninhabitedEnumBranching,\n+        &simplify::SimplifyCfg::new(\"after-uninhabited-enum-branching\"),\n         &uniform_array_move_out::RestoreSubsliceArrayMoveOut::new(tcx),\n         &inline::Inline,\n "}, {"sha": "a6c18aee6a8891cc8b91ffb8eeb79ea5090e9d8c", "filename": "src/librustc_mir/transform/uninhabited_enum_branching.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/c296b2d8309100b27a89707b29f2583aa17e0d3e/src%2Flibrustc_mir%2Ftransform%2Funinhabited_enum_branching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c296b2d8309100b27a89707b29f2583aa17e0d3e/src%2Flibrustc_mir%2Ftransform%2Funinhabited_enum_branching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funinhabited_enum_branching.rs?ref=c296b2d8309100b27a89707b29f2583aa17e0d3e", "patch": "@@ -0,0 +1,126 @@\n+//! A pass that eliminates branches on uninhabited enum variants.\n+\n+use crate::transform::{MirPass, MirSource};\n+use rustc::mir::{\n+    BasicBlock, BasicBlockData, Body, Local, Operand, Rvalue, StatementKind, TerminatorKind,\n+};\n+use rustc::ty::layout::{Abi, TyLayout, Variants};\n+use rustc::ty::{Ty, TyCtxt};\n+\n+pub struct UninhabitedEnumBranching;\n+\n+fn get_discriminant_local(terminator: &TerminatorKind<'_>) -> Option<Local> {\n+    if let TerminatorKind::SwitchInt { discr: Operand::Move(p), .. } = terminator {\n+        p.as_local()\n+    } else {\n+        None\n+    }\n+}\n+\n+/// If the basic block terminates by switching on a discriminant, this returns the `Ty` the\n+/// discriminant is read from. Otherwise, returns None.\n+fn get_switched_on_type<'tcx>(\n+    block_data: &BasicBlockData<'tcx>,\n+    body: &Body<'tcx>,\n+) -> Option<Ty<'tcx>> {\n+    let terminator = block_data.terminator();\n+\n+    // Only bother checking blocks which terminate by switching on a local.\n+    if let Some(local) = get_discriminant_local(&terminator.kind) {\n+        let stmt_before_term = (block_data.statements.len() > 0)\n+            .then_with(|| &block_data.statements[block_data.statements.len() - 1].kind);\n+\n+        if let Some(StatementKind::Assign(box (l, Rvalue::Discriminant(place)))) = stmt_before_term\n+        {\n+            if l.as_local() == Some(local) {\n+                if let Some(r_local) = place.as_local() {\n+                    let ty = body.local_decls[r_local].ty;\n+\n+                    if ty.is_enum() {\n+                        return Some(ty);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn variant_discriminants<'tcx>(\n+    layout: &TyLayout<'tcx>,\n+    ty: Ty<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+) -> Vec<u128> {\n+    match &layout.details.variants {\n+        Variants::Single { index } => vec![index.as_u32() as u128],\n+        Variants::Multiple { variants, .. } => variants\n+            .iter_enumerated()\n+            .filter_map(|(idx, layout)| {\n+                (layout.abi != Abi::Uninhabited)\n+                    .then_with(|| ty.discriminant_for_variant(tcx, idx).unwrap().val)\n+            })\n+            .collect(),\n+    }\n+}\n+\n+impl<'tcx> MirPass<'tcx> for UninhabitedEnumBranching {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        if source.promoted.is_some() {\n+            return;\n+        }\n+\n+        trace!(\"UninhabitedEnumBranching starting for {:?}\", source);\n+\n+        let basic_block_count = body.basic_blocks().len();\n+\n+        for bb in 0..basic_block_count {\n+            let bb = BasicBlock::from_usize(bb);\n+            trace!(\"processing block {:?}\", bb);\n+\n+            let discriminant_ty =\n+                if let Some(ty) = get_switched_on_type(&body.basic_blocks()[bb], body) {\n+                    ty\n+                } else {\n+                    continue;\n+                };\n+\n+            let layout = tcx.layout_of(tcx.param_env(source.def_id()).and(discriminant_ty));\n+\n+            let allowed_variants = if let Ok(layout) = layout {\n+                variant_discriminants(&layout, discriminant_ty, tcx)\n+            } else {\n+                continue;\n+            };\n+\n+            trace!(\"allowed_variants = {:?}\", allowed_variants);\n+\n+            if let TerminatorKind::SwitchInt { values, targets, .. } =\n+                &mut body.basic_blocks_mut()[bb].terminator_mut().kind\n+            {\n+                let vals = &*values;\n+                let zipped = vals.iter().zip(targets.into_iter());\n+\n+                let mut matched_values = Vec::with_capacity(allowed_variants.len());\n+                let mut matched_targets = Vec::with_capacity(allowed_variants.len() + 1);\n+\n+                for (val, target) in zipped {\n+                    if allowed_variants.contains(val) {\n+                        matched_values.push(*val);\n+                        matched_targets.push(*target);\n+                    } else {\n+                        trace!(\"eliminating {:?} -> {:?}\", val, target);\n+                    }\n+                }\n+\n+                // handle the \"otherwise\" branch\n+                matched_targets.push(targets.pop().unwrap());\n+\n+                *values = matched_values.into();\n+                *targets = matched_targets;\n+            } else {\n+                unreachable!()\n+            }\n+        }\n+    }\n+}"}, {"sha": "1f37ff1498d9b9ec515b5470f030edf872342277", "filename": "src/test/mir-opt/uninhabited_enum_branching.rs", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/c296b2d8309100b27a89707b29f2583aa17e0d3e/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c296b2d8309100b27a89707b29f2583aa17e0d3e/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching.rs?ref=c296b2d8309100b27a89707b29f2583aa17e0d3e", "patch": "@@ -0,0 +1,224 @@\n+enum Empty { }\n+\n+// test matching an enum with uninhabited variants\n+enum Test1 {\n+    A(Empty),\n+    B(Empty),\n+    C\n+}\n+\n+// test an enum where the discriminants don't match the variant indexes\n+// (the optimization should do nothing here)\n+enum Test2 {\n+    D = 4,\n+    E = 5,\n+}\n+\n+fn main() {\n+    match Test1::C {\n+        Test1::A(_) => \"A(Empty)\",\n+        Test1::B(_) => \"B(Empty)\",\n+        Test1::C => \"C\",\n+    };\n+\n+    match Test2::D {\n+        Test2::D => \"D\",\n+        Test2::E => \"E\",\n+    };\n+}\n+\n+// END RUST SOURCE\n+//\n+// START rustc.main.UninhabitedEnumBranching.before.mir\n+// let mut _0: ();\n+// let _1: &str;\n+// let mut _2: Test1;\n+// let mut _3: isize;\n+// let mut _4: &str;\n+// let mut _5: &str;\n+// let _6: &str;\n+// let mut _7: Test2;\n+// let mut _8: isize;\n+// let mut _9: &str;\n+// bb0: {\n+//   StorageLive(_1);\n+//   StorageLive(_2);\n+//   _2 = Test1::C;\n+//   _3 = discriminant(_2);\n+//   switchInt(move _3) -> [0isize: bb3, 1isize: bb4, 2isize: bb1, otherwise: bb2];\n+// }\n+// bb1: {\n+//   StorageLive(_5);\n+//   _5 = const \"C\";\n+//   _1 = &(*_5);\n+//   StorageDead(_5);\n+//   goto -> bb5;\n+// }\n+// bb2: {\n+//   unreachable;\n+// }\n+// bb3: {\n+//   _1 = const \"A(Empty)\";\n+//   goto -> bb5;\n+// }\n+// bb4: {\n+//   StorageLive(_4);\n+//   _4 = const \"B(Empty)\";\n+//   _1 = &(*_4);\n+//   StorageDead(_4);\n+//   goto -> bb5;\n+// }\n+// bb5: {\n+//   StorageDead(_2);\n+//   StorageDead(_1);\n+//   StorageLive(_6);\n+//   StorageLive(_7);\n+//   _7 = Test2::D;\n+//   _8 = discriminant(_7);\n+//   switchInt(move _8) -> [4isize: bb8, 5isize: bb6, otherwise: bb7];\n+// }\n+// bb6: {\n+//   StorageLive(_9);\n+//   _9 = const \"E\";\n+//   _6 = &(*_9);\n+//   StorageDead(_9);\n+//   goto -> bb9;\n+// }\n+// bb7: {\n+//   unreachable;\n+// }\n+// bb8: {\n+//   _6 = const \"D\";\n+//   goto -> bb9;\n+// }\n+// bb9: {\n+//   StorageDead(_7);\n+//   StorageDead(_6);\n+//   _0 = ();\n+//   return;\n+// }\n+// END rustc.main.UninhabitedEnumBranching.before.mir\n+// START rustc.main.UninhabitedEnumBranching.after.mir\n+// let mut _0: ();\n+// let _1: &str;\n+// let mut _2: Test1;\n+// let mut _3: isize;\n+// let mut _4: &str;\n+// let mut _5: &str;\n+// let _6: &str;\n+// let mut _7: Test2;\n+// let mut _8: isize;\n+// let mut _9: &str;\n+// bb0: {\n+//   StorageLive(_1);\n+//   StorageLive(_2);\n+//   _2 = Test1::C;\n+//   _3 = discriminant(_2);\n+//   switchInt(move _3) -> [2isize: bb1, otherwise: bb2];\n+// }\n+// bb1: {\n+//   StorageLive(_5);\n+//   _5 = const \"C\";\n+//   _1 = &(*_5);\n+//   StorageDead(_5);\n+//   goto -> bb5;\n+// }\n+// bb2: {\n+//   unreachable;\n+// }\n+// bb3: {\n+//   _1 = const \"A(Empty)\";\n+//   goto -> bb5;\n+// }\n+// bb4: {\n+//   StorageLive(_4);\n+//   _4 = const \"B(Empty)\";\n+//   _1 = &(*_4);\n+//   StorageDead(_4);\n+//   goto -> bb5;\n+// }\n+// bb5: {\n+//   StorageDead(_2);\n+//   StorageDead(_1);\n+//   StorageLive(_6);\n+//   StorageLive(_7);\n+//   _7 = Test2::D;\n+//   _8 = discriminant(_7);\n+//   switchInt(move _8) -> [4isize: bb8, 5isize: bb6, otherwise: bb7];\n+// }\n+// bb6: {\n+//   StorageLive(_9);\n+//   _9 = const \"E\";\n+//   _6 = &(*_9);\n+//   StorageDead(_9);\n+//   goto -> bb9;\n+// }\n+// bb7: {\n+//   unreachable;\n+// }\n+// bb8: {\n+//   _6 = const \"D\";\n+//   goto -> bb9;\n+// }\n+// bb9: {\n+//   StorageDead(_7);\n+//   StorageDead(_6);\n+//   _0 = ();\n+//   return;\n+// }\n+// END rustc.main.UninhabitedEnumBranching.after.mir\n+// START rustc.main.SimplifyCfg-after-uninhabited-enum-branching.after.mir\n+// let mut _0: ();\n+// let _1: &str;\n+// let mut _2: Test1;\n+// let mut _3: isize;\n+// let mut _4: &str;\n+// let mut _5: &str;\n+// let _6: &str;\n+// let mut _7: Test2;\n+// let mut _8: isize;\n+// let mut _9: &str;\n+// bb0: {\n+//   StorageLive(_1);\n+//   StorageLive(_2);\n+//   _2 = Test1::C;\n+//   _3 = discriminant(_2);\n+//   switchInt(move _3) -> [2isize: bb1, otherwise: bb2];\n+// }\n+// bb1: {\n+//   StorageLive(_5);\n+//   _5 = const \"C\";\n+//   _1 = &(*_5);\n+//   StorageDead(_5);\n+//   StorageDead(_2);\n+//   StorageDead(_1);\n+//   StorageLive(_6);\n+//   StorageLive(_7);\n+//   _7 = Test2::D;\n+//   _8 = discriminant(_7);\n+//   switchInt(move _8) -> [4isize: bb5, 5isize: bb3, otherwise: bb4];\n+// }\n+// bb2: {\n+//   unreachable;\n+// }\n+// bb3: {\n+//   StorageLive(_9);\n+//   _9 = const \"E\";\n+//   _6 = &(*_9);\n+//   StorageDead(_9);\n+//   goto -> bb6;\n+// }\n+// bb4: {\n+//   unreachable;\n+// }\n+// bb5: {\n+//   _6 = const \"D\";\n+//   goto -> bb6;\n+// }\n+// bb6: {\n+//   StorageDead(_7);\n+//   StorageDead(_6);\n+//   _0 = ();\n+//   return;\n+// }\n+// END rustc.main.SimplifyCfg-after-uninhabited-enum-branching.after.mir"}]}