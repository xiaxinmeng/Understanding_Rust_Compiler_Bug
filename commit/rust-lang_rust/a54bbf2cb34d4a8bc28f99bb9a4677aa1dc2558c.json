{"sha": "a54bbf2cb34d4a8bc28f99bb9a4677aa1dc2558c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1NGJiZjJjYjM0ZDRhOGJjMjhmOTliYjlhNDY3N2FhMWRjMjU1OGM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-05-12T09:21:11Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-05-12T09:21:11Z"}, "message": "Weave the span of an import through the resolve code", "tree": {"sha": "abadc51482fcabfe24eec6f5d841ec7d7d191a89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abadc51482fcabfe24eec6f5d841ec7d7d191a89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a54bbf2cb34d4a8bc28f99bb9a4677aa1dc2558c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a54bbf2cb34d4a8bc28f99bb9a4677aa1dc2558c", "html_url": "https://github.com/rust-lang/rust/commit/a54bbf2cb34d4a8bc28f99bb9a4677aa1dc2558c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a54bbf2cb34d4a8bc28f99bb9a4677aa1dc2558c/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "644ce5e535f74be304a77dfadb9ff46c743554c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/644ce5e535f74be304a77dfadb9ff46c743554c7", "html_url": "https://github.com/rust-lang/rust/commit/644ce5e535f74be304a77dfadb9ff46c743554c7"}], "stats": {"total": 165, "additions": 101, "deletions": 64}, "files": [{"sha": "57639a1ecef7b17b359436a928f5a815602e22c7", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a54bbf2cb34d4a8bc28f99bb9a4677aa1dc2558c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54bbf2cb34d4a8bc28f99bb9a4677aa1dc2558c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=a54bbf2cb34d4a8bc28f99bb9a4677aa1dc2558c", "patch": "@@ -608,7 +608,8 @@ impl<'a> Resolver<'a> {\n         } else {\n             for (name, span) in legacy_imports.imports {\n                 let ident = Ident::with_empty_ctxt(name);\n-                let result = self.resolve_ident_in_module(module, ident, MacroNS, false, None);\n+                let result = self.resolve_ident_in_module(module, ident, MacroNS,\n+                                                          false, false, span);\n                 if let Ok(binding) = result {\n                     let directive = macro_use_directive(span);\n                     self.potentially_unused_imports.push(directive);\n@@ -622,7 +623,7 @@ impl<'a> Resolver<'a> {\n         for (name, span) in legacy_imports.reexports {\n             self.session.cstore.export_macros(module.def_id().unwrap().krate);\n             let ident = Ident::with_empty_ctxt(name);\n-            let result = self.resolve_ident_in_module(module, ident, MacroNS, false, None);\n+            let result = self.resolve_ident_in_module(module, ident, MacroNS, false, false, span);\n             if let Ok(binding) = result {\n                 self.macro_exports.push(Export { name: name, def: binding.def(), span: span });\n             } else {"}, {"sha": "6011a680dcbf50f16d7e5ca1ee625ce1c1c52467", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 46, "deletions": 34, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/a54bbf2cb34d4a8bc28f99bb9a4677aa1dc2558c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54bbf2cb34d4a8bc28f99bb9a4677aa1dc2558c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a54bbf2cb34d4a8bc28f99bb9a4677aa1dc2558c", "patch": "@@ -613,7 +613,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n             self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n         } else if let TyKind::ImplicitSelf = ty.node {\n             let self_ty = keywords::SelfType.ident();\n-            let def = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.span))\n+            let def = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, true, ty.span)\n                           .map_or(Def::Err, |d| d.def());\n             self.record_def(ty.id, PathResolution::new(def));\n         } else if let TyKind::Array(ref element, ref length) = ty.node {\n@@ -1267,11 +1267,11 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n         let hir::Path { ref segments, span, ref mut def } = *path;\n         let path: Vec<_> = segments.iter().map(|seg| Ident::with_empty_ctxt(seg.name)).collect();\n-        match self.resolve_path(&path, Some(namespace), Some(span)) {\n+        match self.resolve_path(&path, Some(namespace), true, span) {\n             PathResult::Module(module) => *def = module.def().unwrap(),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n                 *def = path_res.base_def(),\n-            PathResult::NonModule(..) => match self.resolve_path(&path, None, Some(span)) {\n+            PathResult::NonModule(..) => match self.resolve_path(&path, None, true, span) {\n                 PathResult::Failed(msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 }\n@@ -1502,7 +1502,8 @@ impl<'a> Resolver<'a> {\n     fn resolve_ident_in_lexical_scope(&mut self,\n                                       mut ident: Ident,\n                                       ns: Namespace,\n-                                      record_used: Option<Span>)\n+                                      record_used: bool,\n+                                      path_span: Span)\n                                       -> Option<LexicalScopeBinding<'a>> {\n         if ns == TypeNS {\n             ident = ident.unhygienize();\n@@ -1513,12 +1514,13 @@ impl<'a> Resolver<'a> {\n             if let Some(def) = self.ribs[ns][i].bindings.get(&ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n                 return Some(LexicalScopeBinding::Def(\n-                    self.adjust_local_def(ns, i, def, record_used)\n+                    self.adjust_local_def(ns, i, def, record_used, path_span)\n                 ));\n             }\n \n             if let ModuleRibKind(module) = self.ribs[ns][i].kind {\n-                let item = self.resolve_ident_in_module(module, ident, ns, false, record_used);\n+                let item = self.resolve_ident_in_module(module, ident, ns, false,\n+                                                        record_used, path_span);\n                 if let Ok(binding) = item {\n                     // The ident resolves to an item.\n                     return Some(LexicalScopeBinding::Item(binding));\n@@ -1527,7 +1529,8 @@ impl<'a> Resolver<'a> {\n                 if let ModuleKind::Block(..) = module.kind { // We can see through blocks\n                 } else if !module.no_implicit_prelude {\n                     return self.prelude.and_then(|prelude| {\n-                        self.resolve_ident_in_module(prelude, ident, ns, false, None).ok()\n+                        self.resolve_ident_in_module(prelude, ident, ns, false,\n+                                                     false, path_span).ok()\n                     }).map(LexicalScopeBinding::Item)\n                 } else {\n                     return None;\n@@ -2147,7 +2150,8 @@ impl<'a> Resolver<'a> {\n                 PatKind::Ident(bmode, ref ident, ref opt_pat) => {\n                     // First try to resolve the identifier as some existing\n                     // entity, then fall back to a fresh binding.\n-                    let binding = self.resolve_ident_in_lexical_scope(ident.node, ValueNS, None)\n+                    let binding = self.resolve_ident_in_lexical_scope(ident.node, ValueNS,\n+                                                                      false, pat.span)\n                                       .and_then(LexicalScopeBinding::item);\n                     let resolution = binding.map(NameBinding::def).and_then(|def| {\n                         let always_binding = !pat_src.is_refutable() || opt_pat.is_some() ||\n@@ -2253,7 +2257,7 @@ impl<'a> Resolver<'a> {\n                     (format!(\"\"), format!(\"the crate root\"))\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n-                    let mod_prefix = match this.resolve_path(mod_path, Some(TypeNS), None) {\n+                    let mod_prefix = match this.resolve_path(mod_path, Some(TypeNS), false, span) {\n                         PathResult::Module(module) => module.def(),\n                         _ => None,\n                     }.map_or(format!(\"\"), |def| format!(\"{} \", def.kind_name()));\n@@ -2303,9 +2307,9 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n             }\n-            if path.len() == 1 && this.self_type_is_available() {\n+            if path.len() == 1 && this.self_type_is_available(span) {\n                 if let Some(candidate) = this.lookup_assoc_candidate(name, ns, is_expected) {\n-                    let self_is_available = this.self_value_is_available(path[0].ctxt);\n+                    let self_is_available = this.self_value_is_available(path[0].ctxt, span);\n                     match candidate {\n                         AssocSuggestion::Field => {\n                             err.span_label(span, format!(\"did you mean `self.{}`?\", path_str));\n@@ -2329,7 +2333,7 @@ impl<'a> Resolver<'a> {\n             let mut levenshtein_worked = false;\n \n             // Try Levenshtein.\n-            if let Some(candidate) = this.lookup_typo_candidate(path, ns, is_expected) {\n+            if let Some(candidate) = this.lookup_typo_candidate(path, ns, is_expected, span) {\n                 err.span_label(ident_span, format!(\"did you mean `{}`?\", candidate));\n                 levenshtein_worked = true;\n             }\n@@ -2434,14 +2438,15 @@ impl<'a> Resolver<'a> {\n         resolution\n     }\n \n-    fn self_type_is_available(&mut self) -> bool {\n-        let binding = self.resolve_ident_in_lexical_scope(keywords::SelfType.ident(), TypeNS, None);\n+    fn self_type_is_available(&mut self, span: Span) -> bool {\n+        let binding = self.resolve_ident_in_lexical_scope(keywords::SelfType.ident(),\n+                                                          TypeNS, false, span);\n         if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n     }\n \n-    fn self_value_is_available(&mut self, ctxt: SyntaxContext) -> bool {\n+    fn self_value_is_available(&mut self, ctxt: SyntaxContext, span: Span) -> bool {\n         let ident = Ident { name: keywords::SelfValue.name(), ctxt: ctxt };\n-        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None);\n+        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, false, span);\n         if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n     }\n \n@@ -2505,7 +2510,7 @@ impl<'a> Resolver<'a> {\n             ));\n         }\n \n-        let result = match self.resolve_path(&path, Some(ns), Some(span)) {\n+        let result = match self.resolve_path(&path, Some(ns), true, span) {\n             PathResult::NonModule(path_res) => path_res,\n             PathResult::Module(module) if !module.is_normal() => {\n                 PathResolution::new(module.def().unwrap())\n@@ -2551,7 +2556,7 @@ impl<'a> Resolver<'a> {\n         if path.len() > 1 && !global_by_default && result.base_def() != Def::Err &&\n            path[0].name != keywords::CrateRoot.name() && path[0].name != \"$crate\" {\n             let unqualified_result = {\n-                match self.resolve_path(&[*path.last().unwrap()], Some(ns), None) {\n+                match self.resolve_path(&[*path.last().unwrap()], Some(ns), false, span) {\n                     PathResult::NonModule(path_res) => path_res.base_def(),\n                     PathResult::Module(module) => module.def().unwrap(),\n                     _ => return Some(result),\n@@ -2569,7 +2574,8 @@ impl<'a> Resolver<'a> {\n     fn resolve_path(&mut self,\n                     path: &[Ident],\n                     opt_ns: Option<Namespace>, // `None` indicates a module path\n-                    record_used: Option<Span>)\n+                    record_used: bool,\n+                    path_span: Span)\n                     -> PathResult<'a> {\n         let mut module = None;\n         let mut allow_super = true;\n@@ -2603,20 +2609,20 @@ impl<'a> Resolver<'a> {\n             }\n \n             let binding = if let Some(module) = module {\n-                self.resolve_ident_in_module(module, ident, ns, false, record_used)\n+                self.resolve_ident_in_module(module, ident, ns, false, record_used, path_span)\n             } else if opt_ns == Some(MacroNS) {\n-                self.resolve_lexical_macro_path_segment(ident, ns, record_used)\n+                self.resolve_lexical_macro_path_segment(ident, ns, record_used, path_span)\n                     .map(MacroBinding::binding)\n             } else {\n-                match self.resolve_ident_in_lexical_scope(ident, ns, record_used) {\n+                match self.resolve_ident_in_lexical_scope(ident, ns, record_used, path_span) {\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n                     Some(LexicalScopeBinding::Def(def))\n                             if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) => {\n                         return PathResult::NonModule(PathResolution::with_unresolved_segments(\n                             def, path.len() - 1\n                         ));\n                     }\n-                    _ => Err(if record_used.is_some() { Determined } else { Undetermined }),\n+                    _ => Err(if record_used { Determined } else { Undetermined }),\n                 }\n             };\n \n@@ -2673,12 +2679,13 @@ impl<'a> Resolver<'a> {\n                         ns: Namespace,\n                         rib_index: usize,\n                         mut def: Def,\n-                        record_used: Option<Span>) -> Def {\n+                        record_used: bool,\n+                        span: Span) -> Def {\n         let ribs = &self.ribs[ns][rib_index + 1..];\n \n         // An invalid forward use of a type parameter from a previous default.\n         if let ForwardTyParamBanRibKind = self.ribs[ns][rib_index].kind {\n-            if let Some(span) = record_used {\n+            if record_used {\n                 resolve_error(self, span,\n                         ResolutionError::ForwardDeclaredTyParam);\n             }\n@@ -2688,7 +2695,7 @@ impl<'a> Resolver<'a> {\n \n         match def {\n             Def::Upvar(..) => {\n-                span_bug!(record_used.unwrap_or(DUMMY_SP), \"unexpected {:?} in bindings\", def)\n+                span_bug!(span, \"unexpected {:?} in bindings\", def)\n             }\n             Def::Local(def_id) => {\n                 for rib in ribs {\n@@ -2714,7 +2721,7 @@ impl<'a> Resolver<'a> {\n                             let depth = vec.len();\n                             def = Def::Upvar(def_id, depth, function_id);\n \n-                            if let Some(span) = record_used {\n+                            if record_used {\n                                 vec.push(Freevar {\n                                     def: prev_def,\n                                     span: span,\n@@ -2726,15 +2733,15 @@ impl<'a> Resolver<'a> {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n                             // report an error.\n-                            if let Some(span) = record_used {\n+                            if record_used {\n                                 resolve_error(self, span,\n                                         ResolutionError::CannotCaptureDynamicEnvironmentInFnItem);\n                             }\n                             return Def::Err;\n                         }\n                         ConstantItemRibKind => {\n                             // Still doesn't deal with upvars\n-                            if let Some(span) = record_used {\n+                            if record_used {\n                                 resolve_error(self, span,\n                                         ResolutionError::AttemptToUseNonConstantValueInConstant);\n                             }\n@@ -2753,15 +2760,15 @@ impl<'a> Resolver<'a> {\n                         ItemRibKind => {\n                             // This was an attempt to use a type parameter outside\n                             // its scope.\n-                            if let Some(span) = record_used {\n+                            if record_used {\n                                 resolve_error(self, span,\n                                               ResolutionError::TypeParametersFromOuterFunction);\n                             }\n                             return Def::Err;\n                         }\n                         ConstantItemRibKind => {\n                             // see #9186\n-                            if let Some(span) = record_used {\n+                            if record_used {\n                                 resolve_error(self, span,\n                                               ResolutionError::OuterTypeParameterContext);\n                             }\n@@ -2857,7 +2864,8 @@ impl<'a> Resolver<'a> {\n     fn lookup_typo_candidate<FilterFn>(&mut self,\n                                        path: &[Ident],\n                                        ns: Namespace,\n-                                       filter_fn: FilterFn)\n+                                       filter_fn: FilterFn,\n+                                       span: Span)\n                                        -> Option<Symbol>\n         where FilterFn: Fn(Def) -> bool\n     {\n@@ -2909,7 +2917,8 @@ impl<'a> Resolver<'a> {\n         } else {\n             // Search in module.\n             let mod_path = &path[..path.len() - 1];\n-            if let PathResult::Module(module) = self.resolve_path(mod_path, Some(TypeNS), None) {\n+            if let PathResult::Module(module) = self.resolve_path(mod_path, Some(TypeNS),\n+                                                                  false, span) {\n                 add_module_candidates(module, &mut names);\n             }\n         }\n@@ -3410,7 +3419,10 @@ impl<'a> Resolver<'a> {\n                 continue\n             }\n             let ident = attr.path.segments[0].identifier;\n-            let result = self.resolve_lexical_macro_path_segment(ident, MacroNS, None);\n+            let result = self.resolve_lexical_macro_path_segment(ident,\n+                                                                 MacroNS,\n+                                                                 false,\n+                                                                 attr.path.span);\n             if let Ok(binding) = result {\n                 if let SyntaxExtension::AttrProcMacro(..) = *binding.binding().get_macro(self) {\n                     attr::mark_known(attr);"}, {"sha": "c08421cb9374eb9efa04bf4183762a66c07287cc", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a54bbf2cb34d4a8bc28f99bb9a4677aa1dc2558c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54bbf2cb34d4a8bc28f99bb9a4677aa1dc2558c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=a54bbf2cb34d4a8bc28f99bb9a4677aa1dc2558c", "patch": "@@ -379,7 +379,7 @@ impl<'a> Resolver<'a> {\n                 return Err(Determinacy::Determined);\n             }\n \n-            let def = match self.resolve_path(&path, Some(MacroNS), None) {\n+            let def = match self.resolve_path(&path, Some(MacroNS), false, span) {\n                 PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n                     def @ _ => Ok(def),\n@@ -401,7 +401,7 @@ impl<'a> Resolver<'a> {\n         let result = if let Some(MacroBinding::Legacy(binding)) = legacy_resolution {\n             Ok(Def::Macro(binding.def_id, MacroKind::Bang))\n         } else {\n-            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, None) {\n+            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, false, span) {\n                 Ok(binding) => Ok(binding.binding().def_ignoring_ambiguity()),\n                 Err(Determinacy::Undetermined) if !force => return Err(Determinacy::Undetermined),\n                 Err(_) => {\n@@ -421,18 +421,19 @@ impl<'a> Resolver<'a> {\n     pub fn resolve_lexical_macro_path_segment(&mut self,\n                                               ident: Ident,\n                                               ns: Namespace,\n-                                              record_used: Option<Span>)\n+                                              record_used: bool,\n+                                              path_span: Span)\n                                               -> Result<MacroBinding<'a>, Determinacy> {\n         let mut module = Some(self.current_module);\n         let mut potential_illegal_shadower = Err(Determinacy::Determined);\n         let determinacy =\n-            if record_used.is_some() { Determinacy::Determined } else { Determinacy::Undetermined };\n+            if record_used { Determinacy::Determined } else { Determinacy::Undetermined };\n         loop {\n             let result = if let Some(module) = module {\n                 // Since expanded macros may not shadow the lexical scope and\n                 // globs may not shadow global macros (both enforced below),\n                 // we resolve with restricted shadowing (indicated by the penultimate argument).\n-                self.resolve_ident_in_module(module, ident, ns, true, record_used)\n+                self.resolve_ident_in_module(module, ident, ns, true, record_used, path_span)\n                     .map(MacroBinding::Modern)\n             } else {\n                 self.global_macros.get(&ident.name).cloned().ok_or(determinacy)\n@@ -441,15 +442,18 @@ impl<'a> Resolver<'a> {\n \n             match result.map(MacroBinding::binding) {\n                 Ok(binding) => {\n-                    let span = match record_used {\n-                        Some(span) => span,\n-                        None => return result,\n-                    };\n+                    if !record_used {\n+                        return result;\n+                    }\n                     if let Ok(MacroBinding::Modern(shadower)) = potential_illegal_shadower {\n                         if shadower.def() != binding.def() {\n                             let name = ident.name;\n                             self.ambiguity_errors.push(AmbiguityError {\n-                                span: span, name: name, b1: shadower, b2: binding, lexical: true,\n+                                span: path_span,\n+                                name: name,\n+                                b1: shadower,\n+                                b2: binding,\n+                                lexical: true,\n                                 legacy: false,\n                             });\n                             return potential_illegal_shadower;\n@@ -543,7 +547,7 @@ impl<'a> Resolver<'a> {\n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n         for &(ref path, span) in module.macro_resolutions.borrow().iter() {\n-            match self.resolve_path(path, Some(MacroNS), Some(span)) {\n+            match self.resolve_path(path, Some(MacroNS), true, span) {\n                 PathResult::NonModule(_) => {},\n                 PathResult::Failed(msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n@@ -555,7 +559,7 @@ impl<'a> Resolver<'a> {\n         for &(mark, ident, span, kind) in module.legacy_macro_resolutions.borrow().iter() {\n             let legacy_scope = &self.invocations[&mark].legacy_scope;\n             let legacy_resolution = self.resolve_legacy_scope(legacy_scope, ident.name, true);\n-            let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, Some(span));\n+            let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, true, span);\n             match (legacy_resolution, resolution) {\n                 (Some(MacroBinding::Legacy(legacy_binding)), Ok(MacroBinding::Modern(binding))) => {\n                     let msg1 = format!(\"`{}` could refer to the macro defined here\", ident);\n@@ -579,7 +583,7 @@ impl<'a> Resolver<'a> {\n                             format!(\"cannot find derive macro `{}` in this scope\", ident),\n                     };\n                     let mut err = self.session.struct_span_err(span, &msg);\n-                    self.suggest_macro_name(&ident.name.as_str(), kind, &mut err);\n+                    self.suggest_macro_name(&ident.name.as_str(), kind, &mut err, span);\n                     err.emit();\n                 },\n                 _ => {},\n@@ -588,7 +592,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn suggest_macro_name(&mut self, name: &str, kind: MacroKind,\n-                          err: &mut DiagnosticBuilder<'a>) {\n+                          err: &mut DiagnosticBuilder<'a>, span: Span) {\n         // First check if this is a locally-defined bang macro.\n         let suggestion = if let MacroKind::Bang = kind {\n             find_best_match_for_name(self.macro_names.iter(), name, None)\n@@ -619,7 +623,7 @@ impl<'a> Resolver<'a> {\n                 }\n             };\n             let ident = Ident::from_str(name);\n-            self.lookup_typo_candidate(&vec![ident], MacroNS, is_macro)\n+            self.lookup_typo_candidate(&vec![ident], MacroNS, is_macro, span)\n         });\n \n         if let Some(suggestion) = suggestion {"}, {"sha": "1d4ba4ed100b72e3139fbcf29b42e70e1e9eed13", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a54bbf2cb34d4a8bc28f99bb9a4677aa1dc2558c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54bbf2cb34d4a8bc28f99bb9a4677aa1dc2558c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=a54bbf2cb34d4a8bc28f99bb9a4677aa1dc2558c", "patch": "@@ -146,15 +146,16 @@ impl<'a> Resolver<'a> {\n                                    ident: Ident,\n                                    ns: Namespace,\n                                    restricted_shadowing: bool,\n-                                   record_used: Option<Span>)\n+                                   record_used: bool,\n+                                   path_span: Span)\n                                    -> Result<&'a NameBinding<'a>, Determinacy> {\n         self.populate_module_if_necessary(module);\n \n         let resolution = self.resolution(module, ident, ns)\n             .try_borrow_mut()\n             .map_err(|_| Determined)?; // This happens when there is a cycle of imports\n \n-        if let Some(span) = record_used {\n+        if record_used {\n             if let Some(binding) = resolution.binding {\n                 if let Some(shadowed_glob) = resolution.shadows_glob {\n                     let name = ident.name;\n@@ -164,16 +165,20 @@ impl<'a> Resolver<'a> {\n                        ns != MacroNS && // In MacroNS, `try_define` always forbids this shadowing\n                        binding.def() != shadowed_glob.def() {\n                         self.ambiguity_errors.push(AmbiguityError {\n-                            span: span, name: name, lexical: false, b1: binding, b2: shadowed_glob,\n+                            span: path_span,\n+                            name: name,\n+                            lexical: false,\n+                            b1: binding,\n+                            b2: shadowed_glob,\n                             legacy: false,\n                         });\n                     }\n                 }\n-                if self.record_use(ident, ns, binding, span) {\n+                if self.record_use(ident, ns, binding, path_span) {\n                     return Ok(self.dummy_binding);\n                 }\n                 if !self.is_accessible(binding.vis) {\n-                    self.privacy_errors.push(PrivacyError(span, ident.name, binding));\n+                    self.privacy_errors.push(PrivacyError(path_span, ident.name, binding));\n                 }\n             }\n \n@@ -205,7 +210,7 @@ impl<'a> Resolver<'a> {\n                     SingleImport { source, .. } => source,\n                     _ => unreachable!(),\n                 };\n-                match self.resolve_ident_in_module(module, ident, ns, false, None) {\n+                match self.resolve_ident_in_module(module, ident, ns, false, false, path_span) {\n                     Err(Determined) => {}\n                     _ => return Err(Undetermined),\n                 }\n@@ -230,7 +235,12 @@ impl<'a> Resolver<'a> {\n         for directive in module.globs.borrow().iter() {\n             if self.is_accessible(directive.vis.get()) {\n                 if let Some(module) = directive.imported_module.get() {\n-                    let result = self.resolve_ident_in_module(module, ident, ns, false, None);\n+                    let result = self.resolve_ident_in_module(module,\n+                                                              ident,\n+                                                              ns,\n+                                                              false,\n+                                                              false,\n+                                                              path_span);\n                     if let Err(Undetermined) = result {\n                         return Err(Undetermined);\n                     }\n@@ -499,7 +509,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             // For better failure detection, pretend that the import will not define any names\n             // while resolving its module path.\n             directive.vis.set(ty::Visibility::Invisible);\n-            let result = self.resolve_path(&directive.module_path, None, None);\n+            let result = self.resolve_path(&directive.module_path, None, false, directive.span);\n             directive.vis.set(vis);\n \n             match result {\n@@ -523,7 +533,12 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let mut indeterminate = false;\n         self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n             if let Err(Undetermined) = result[ns].get() {\n-                result[ns].set(this.resolve_ident_in_module(module, source, ns, false, None));\n+                result[ns].set(this.resolve_ident_in_module(module,\n+                                                            source,\n+                                                            ns,\n+                                                            false,\n+                                                            false,\n+                                                            directive.span));\n             } else {\n                 return\n             };\n@@ -563,14 +578,14 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         self.current_module = directive.parent;\n \n         let ImportDirective { ref module_path, span, .. } = *directive;\n-        let module_result = self.resolve_path(&module_path, None, Some(span));\n+        let module_result = self.resolve_path(&module_path, None, true, span);\n         let module = match module_result {\n             PathResult::Module(module) => module,\n             PathResult::Failed(msg, _) => {\n                 let (mut self_path, mut self_result) = (module_path.clone(), None);\n                 if !self_path.is_empty() && !token::Ident(self_path[0]).is_path_segment_keyword() {\n                     self_path[0].name = keywords::SelfValue.name();\n-                    self_result = Some(self.resolve_path(&self_path, None, None));\n+                    self_result = Some(self.resolve_path(&self_path, None, false, span));\n                 }\n                 return if let Some(PathResult::Module(..)) = self_result {\n                     Some(format!(\"Did you mean `{}`?\", names_to_string(&self_path)))\n@@ -609,7 +624,12 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                         Some(this.dummy_binding);\n                 }\n             }\n-        } else if let Ok(binding) = this.resolve_ident_in_module(module, ident, ns, false, None) {\n+        } else if let Ok(binding) = this.resolve_ident_in_module(module,\n+                                                                 ident,\n+                                                                 ns,\n+                                                                 false,\n+                                                                 false,\n+                                                                 directive.span) {\n             legacy_self_import = Some(directive);\n             let binding = this.arenas.alloc_name_binding(NameBinding {\n                 kind: NameBindingKind::Import {\n@@ -630,7 +650,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             }\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n-                match this.resolve_ident_in_module(module, ident, ns, false, Some(span)) {\n+                match this.resolve_ident_in_module(module, ident, ns, false, true, span) {\n                     Ok(_) => all_ns_failed = false,\n                     _ => {}\n                 }"}]}