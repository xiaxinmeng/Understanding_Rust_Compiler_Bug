{"sha": "f5c51b0a9c084418ae90b8909dc10b13ff318d72", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1YzUxYjBhOWMwODQ0MThhZTkwYjg5MDlkYzEwYjEzZmYzMThkNzI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-24T16:26:58Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-24T16:52:16Z"}, "message": "remove initedness checking from typestate, as best I could", "tree": {"sha": "0068ded185af0a03e2a0e6ebfaf69f2cede39516", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0068ded185af0a03e2a0e6ebfaf69f2cede39516"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5c51b0a9c084418ae90b8909dc10b13ff318d72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5c51b0a9c084418ae90b8909dc10b13ff318d72", "html_url": "https://github.com/rust-lang/rust/commit/f5c51b0a9c084418ae90b8909dc10b13ff318d72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5c51b0a9c084418ae90b8909dc10b13ff318d72/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d3811e2759acfea03ee60892c15e018a59c12c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d3811e2759acfea03ee60892c15e018a59c12c0", "html_url": "https://github.com/rust-lang/rust/commit/0d3811e2759acfea03ee60892c15e018a59c12c0"}], "stats": {"total": 589, "additions": 89, "deletions": 500}, "files": [{"sha": "ecd6b43a7f06fa9b0dba5d544d51aa256f70bc74", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 58, "deletions": 180, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/f5c51b0a9c084418ae90b8909dc10b13ff318d72/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c51b0a9c084418ae90b8909dc10b13ff318d72/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=f5c51b0a9c084418ae90b8909dc10b13ff318d72", "patch": "@@ -49,18 +49,10 @@ fn comma_str(args: [@constr_arg_use]) -> str {\n }\n \n fn constraint_to_str(tcx: ty::ctxt, c: sp_constr) -> str {\n-    alt c.node {\n-      ninit(id, i) {\n-        ret #fmt(\"init(%s id=%d - arising from %s)\",\n-                 i, id, codemap::span_to_str(c.span, tcx.sess.codemap));\n-      }\n-      npred(p, _, args) {\n-          ret #fmt(\"%s(%s) - arising from %s\",\n-                   path_to_str(p),\n-                   comma_str(args),\n-                   codemap::span_to_str(c.span, tcx.sess.codemap));\n-      }\n-    }\n+    ret #fmt(\"%s(%s) - arising from %s\",\n+             path_to_str(c.node.path),\n+             comma_str(c.node.args),\n+             codemap::span_to_str(c.span, tcx.sess.codemap));\n }\n \n fn tritv_to_str(fcx: fn_ctxt, v: tritv::t) -> str {\n@@ -167,16 +159,14 @@ fn print_idents(&idents: [ident]) {\n /* Two different data structures represent constraints in different\n  contexts: constraint and norm_constraint.\n \n-constraint gets used to record constraints in a table keyed by def_ids.\n-cinit constraints represent a single constraint, for the initialization\n-state of a variable; a cpred constraint, with a single operator and a\n-list of possible argument lists, could represent several constraints at\n-once.\n+constraint gets used to record constraints in a table keyed by def_ids.  Each\n+constraint has a single operator but a list of possible argument lists, and\n+thus represents several constraints at once, one for each possible argument\n+list.\n \n-norm_constraint, in contrast, gets used when handling an instance\n-of a constraint rather than a definition of a constraint. It can\n-also be init or pred (ninit or npred), but the npred case just has\n-a single argument list.\n+norm_constraint, in contrast, gets used when handling an instance of a\n+constraint rather than a definition of a constraint. It has only a single\n+argument list.\n \n The representation of constraints, where multiple instances of the\n same predicate are collapsed into one entry in the table, makes it\n@@ -198,37 +188,23 @@ type pred_args = spanned<pred_args_>;\n // for this local.\n type constr_arg_use = spanned<constr_arg_general_<inst>>;\n \n-/*\n-  A constraint is either an init constraint, referring to the initialization\n-  state of a variable (not initialized, definitely initialized, or maybe\n-  initialized) or a predicate constraint, referring to the truth value of a\n-  predicate on variables (definitely false, maybe true, or definitely true).\n-\n-  cinit and ninit represent init constraints, while cpred and npred\n-  represent predicate constraints.\n-\n-  In a predicate constraint, the <path> field (and the <def_id> field\n-  in the npred constructor) names a user-defined function that may\n-  be the operator in a \"check\" expression in the source.\n- */\n-\n-enum constraint {\n-    cinit(uint, span, ident),\n+/* Predicate constraints refer to the truth value of a predicate on variables\n+(definitely false, maybe true, or definitely true).  The <path> field (and the\n+<def_id> field in the npred constructor) names a user-defined function that\n+may be the operator in a \"check\" expression in the source.  */\n \n+type constraint = {\n+    path: @path,\n     // FIXME: really only want it to be mut during collect_locals.\n     // freeze it after that.\n-    cpred(@path, @mut [pred_args]),\n-}\n+    descs: @mut [pred_args]\n+};\n \n-// An ninit variant has a node_id because it refers to a local var.\n-// An npred has a def_id since the definition of the typestate\n-// predicate need not be local.\n-// FIXME: would be nice to give both a def_id field,\n-// and give ninit a constraint saying it's local.\n-enum tsconstr {\n-    ninit(node_id, ident),\n-    npred(@path, def_id, [@constr_arg_use]),\n-}\n+type tsconstr = {\n+    path: @path,\n+    def_id: def_id,\n+    args: [@constr_arg_use]\n+};\n \n type sp_constr = spanned<tsconstr>;\n \n@@ -238,34 +214,8 @@ type constr_map = std::map::hashmap<def_id, constraint>;\n \n /* Contains stuff that has to be computed up front */\n /* For easy access, the fn_info stores two special constraints for each\n-function.  i_return holds if all control paths in this function terminate\n-in either a return expression, or an appropriate tail expression.\n-i_diverge holds if all control paths in this function terminate in a fail\n-or diverging call.\n-\n-It might be tempting to use a single constraint C for both properties,\n-where C represents i_return and !C represents i_diverge. This is\n-inadvisable, because then the sense of the bit depends on context. If we're\n-inside a ! function, that reverses the sense of the bit: C would be\n-i_diverge and !C would be i_return.  That's awkward, because we have to\n-pass extra context around to functions that shouldn't care.\n-\n-Okay, suppose C represents i_return and !C represents i_diverge, regardless\n-of context. Consider this code:\n-\n-if (foo) { ret; } else { fail; }\n-\n-C is true in the consequent and false in the alternative. What's T `join`\n-F, then?  ? doesn't work, because this code should definitely-return if the\n-context is a returning function (and be definitely-rejected if the context\n-is a ! function).  F doesn't work, because then the code gets incorrectly\n-rejected if the context is a returning function. T would work, but it\n-doesn't make sense for T `join` F to be T (consider init constraints, for\n-example).;\n-\n-So we need context. And so it seems clearer to just have separate\n-constraints.\n-*/\n+function.  So we need context. And so it seems clearer to just have separate\n+constraints. */\n type fn_info =\n     /* list, accumulated during pre/postcondition\n     computation, of all local variables that may be\n@@ -274,21 +224,8 @@ type fn_info =\n     {constrs: constr_map,\n      num_constraints: uint,\n      cf: ret_style,\n-     i_return: tsconstr,\n-     i_diverge: tsconstr,\n      used_vars: @mut [node_id]};\n \n-fn tsconstr_to_def_id(t: tsconstr) -> def_id {\n-    alt t { ninit(id, _) { local_def(id) } npred(_, id, _) { id } }\n-}\n-\n-fn tsconstr_to_node_id(t: tsconstr) -> node_id {\n-    alt t {\n-      ninit(id, _) { id }\n-      npred(_, id, _) { fail \"tsconstr_to_node_id called on pred constraint\" }\n-    }\n-}\n-\n /* mapping from node ID to typestate annotation */\n type node_ann_table = @mut [mut ts_ann];\n \n@@ -534,20 +471,15 @@ fn node_id_to_def(ccx: crate_ctxt, id: node_id) -> option<def> {\n }\n \n fn norm_a_constraint(id: def_id, c: constraint) -> [norm_constraint] {\n-    alt c {\n-      cinit(n, sp, i) {\n-        ret [{bit_num: n, c: respan(sp, ninit(id.node, i))}];\n-      }\n-      cpred(p, descs) {\n-        let mut rslt: [norm_constraint] = [];\n-        for vec::each(*descs) {|pd|\n-            rslt +=\n-                [{bit_num: pd.node.bit_num,\n-                  c: respan(pd.span, npred(p, id, pd.node.args))}];\n-        }\n-        ret rslt;\n-      }\n+    let mut rslt: [norm_constraint] = [];\n+    for vec::each(*c.descs) {|pd|\n+        rslt +=\n+            [{bit_num: pd.node.bit_num,\n+              c: respan(pd.span, {path: c.path,\n+                                  def_id: id,\n+                                  args: pd.node.args})}];\n     }\n+    ret rslt;\n }\n \n \n@@ -630,8 +562,9 @@ fn expr_to_constr(tcx: ty::ctxt, e: @expr) -> sp_constr {\n         alt operator.node {\n           expr_path(p) {\n             ret respan(e.span,\n-                       npred(p, def_id_for_constr(tcx, operator.id),\n-                             exprs_to_constr_args(tcx, args)));\n+                       {path: p,\n+                        def_id: def_id_for_constr(tcx, operator.id),\n+                        args: exprs_to_constr_args(tcx, args)});\n           }\n           _ {\n             tcx.sess.span_bug(operator.span,\n@@ -657,7 +590,9 @@ fn substitute_constr_args(cx: ty::ctxt, actuals: [@expr], c: @ty::constr) ->\n     for c.node.args.each {|a|\n         rslt += [substitute_arg(cx, actuals, a)];\n     }\n-    ret npred(c.node.path, c.node.id, rslt);\n+    ret {path: c.node.path,\n+         def_id: c.node.id,\n+         args: rslt};\n }\n \n fn substitute_arg(cx: ty::ctxt, actuals: [@expr], a: @constr_arg) ->\n@@ -718,31 +653,22 @@ enum dest {\n \n type subst = [{from: inst, to: inst}];\n \n-fn find_instances(_fcx: fn_ctxt, subst: subst, c: constraint) ->\n-   [{from: uint, to: uint}] {\n-\n-    let mut rslt = [];\n-    if vec::len(subst) == 0u { ret rslt; }\n-\n-    alt c {\n-      cinit(_, _, _) {/* this is dealt with separately */ }\n-      cpred(p, descs) {\n-        // FIXME (#2280): this temporary shouldn't be\n-        // necessary, but seems to be, for borrowing.\n-        let ds = copy *descs;\n-        for vec::each(ds) {|d|\n-            if args_mention(d.node.args, find_in_subst_bool, subst) {\n-                let old_bit_num = d.node.bit_num;\n-                let newv = replace(subst, d);\n-                alt find_instance_(newv, *descs) {\n-                  some(d1) { rslt += [{from: old_bit_num, to: d1}]; }\n-                  _ { }\n-                }\n+fn find_instances(_fcx: fn_ctxt, subst: subst,\n+                  c: constraint) -> [{from: uint, to: uint}] {\n+\n+    if vec::len(subst) == 0u { ret []; }\n+    let mut res = [];\n+    for (*c.descs).each { |d|\n+        if args_mention(d.node.args, find_in_subst_bool, subst) {\n+            let old_bit_num = d.node.bit_num;\n+            let newv = replace(subst, d);\n+            alt find_instance_(newv, *c.descs) {\n+              some(d1) {res += [{from: old_bit_num, to: d1}]}\n+              _ {}\n             }\n-        }\n-      }\n+        } else {}\n     }\n-    rslt\n+    ret res;\n }\n \n fn find_in_subst(id: node_id, s: subst) -> option<inst> {\n@@ -912,25 +838,6 @@ fn forget_in_postcond(fcx: fn_ctxt, parent_exp: node_id, dead_v: node_id) {\n     }\n }\n \n-fn forget_in_postcond_still_init(fcx: fn_ctxt, parent_exp: node_id,\n-                                 dead_v: node_id) {\n-    // In the postcondition given by parent_exp, clear the bits\n-    // for any constraints mentioning dead_v\n-    let d = local_node_id_to_local_def_id(fcx, dead_v);\n-    alt d {\n-      some(d_id) {\n-        for constraints(fcx).each {|c|\n-            if non_init_constraint_mentions(fcx, c, d_id) {\n-                clear_in_postcond(c.bit_num,\n-                                  node_id_to_ts_ann(fcx.ccx,\n-                                                    parent_exp).conditions);\n-            }\n-        }\n-      }\n-      _ { }\n-    }\n-}\n-\n fn forget_in_poststate(fcx: fn_ctxt, p: poststate, dead_v: node_id) -> bool {\n     // In the poststate given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n@@ -949,44 +856,14 @@ fn forget_in_poststate(fcx: fn_ctxt, p: poststate, dead_v: node_id) -> bool {\n     ret changed;\n }\n \n-fn forget_in_poststate_still_init(fcx: fn_ctxt, p: poststate, dead_v: node_id)\n-   -> bool {\n-    // In the poststate given by parent_exp, clear the bits\n-    // for any constraints mentioning dead_v\n-    let d = local_node_id_to_local_def_id(fcx, dead_v);\n-    let mut changed = false;\n-    alt d {\n-      some(d_id) {\n-        for constraints(fcx).each {|c|\n-            if non_init_constraint_mentions(fcx, c, d_id) {\n-                changed |= clear_in_poststate_(c.bit_num, p);\n-            }\n-        }\n-      }\n-      _ { }\n-    }\n-    ret changed;\n-}\n-\n fn any_eq(v: [node_id], d: node_id) -> bool {\n     for v.each {|i| if i == d { ret true; } }\n     false\n }\n \n fn constraint_mentions(_fcx: fn_ctxt, c: norm_constraint, v: node_id) ->\n    bool {\n-    ret alt c.c.node {\n-          ninit(id, _) { v == id }\n-          npred(_, _, args) { args_mention(args, any_eq, [v]) }\n-        };\n-}\n-\n-fn non_init_constraint_mentions(_fcx: fn_ctxt, c: norm_constraint, v: node_id)\n-   -> bool {\n-    ret alt c.c.node {\n-          ninit(_, _) { false }\n-          npred(_, _, args) { args_mention(args, any_eq, [v]) }\n-        };\n+    ret args_mention(c.c.node.args, any_eq, [v]);\n }\n \n fn args_mention<T>(args: [@constr_arg_use],\n@@ -1063,8 +940,9 @@ fn args_to_constr_args(tcx: ty::ctxt, args: [arg],\n fn ast_constr_to_ts_constr(tcx: ty::ctxt, args: [arg], c: @constr) ->\n    tsconstr {\n     let tconstr = ty::ast_constr_to_constr(tcx, c);\n-    ret npred(tconstr.node.path, tconstr.node.id,\n-              args_to_constr_args(tcx, args, tconstr.node.args));\n+    ret {path: tconstr.node.path,\n+         def_id: tconstr.node.id,\n+         args: args_to_constr_args(tcx, args, tconstr.node.args)};\n }\n \n fn ast_constr_to_sp_constr(tcx: ty::ctxt, args: [arg], c: @constr) ->"}, {"sha": "e2ce69cc91e170cf5aaccc6756b0693f3049257c", "filename": "src/rustc/middle/tstate/bitvectors.rs", "status": "modified", "additions": 5, "deletions": 58, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f5c51b0a9c084418ae90b8909dc10b13ff318d72/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c51b0a9c084418ae90b8909dc10b13ff318d72/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=f5c51b0a9c084418ae90b8909dc10b13ff318d72", "patch": "@@ -15,36 +15,19 @@ import driver::session::session;\n import std::map::hashmap;\n \n fn bit_num(fcx: fn_ctxt, c: tsconstr) -> uint {\n-    let d = tsconstr_to_def_id(c);\n+    let d = c.def_id;\n     assert (fcx.enclosing.constrs.contains_key(d));\n     let rslt = fcx.enclosing.constrs.get(d);\n-    alt c {\n-      ninit(_, _) {\n-        alt rslt {\n-          cinit(n, _, _) { ret n; }\n-          _ {\n-            fcx.ccx.tcx.sess.bug(\"bit_num: asked for init constraint,\" +\n-                                     \" found a pred constraint\");\n-          }\n-        }\n-      }\n-      npred(_, _, args) {\n-        alt rslt {\n-          cpred(_, descs) { ret match_args(fcx, descs, args); }\n-          _ {\n-            fcx.ccx.tcx.sess.bug(\"bit_num: asked for pred constraint,\" +\n-                                     \" found an init constraint\");\n-          }\n-        }\n-      }\n-    }\n+    match_args(fcx, rslt.descs, c.args)\n }\n \n fn promises(fcx: fn_ctxt, p: poststate, c: tsconstr) -> bool {\n     ret promises_(bit_num(fcx, c), p);\n }\n \n-fn promises_(n: uint, p: poststate) -> bool { ret tritv_get(p, n) == ttrue; }\n+fn promises_(n: uint, p: poststate) -> bool {\n+    ret tritv_get(p, n) == ttrue;\n+}\n \n // v \"happens after\" u\n fn seq_trit(u: trit, v: trit) -> trit {\n@@ -184,51 +167,15 @@ fn kill_poststate(fcx: fn_ctxt, id: node_id, c: tsconstr) -> bool {\n                            node_id_to_ts_ann(fcx.ccx, id).states);\n }\n \n-fn clear_in_poststate_expr(fcx: fn_ctxt, e: @expr, t: poststate) {\n-    alt e.node {\n-      expr_path(p) {\n-        alt local_node_id_to_def(fcx, e.id) {\n-          some(def_local(nid, _)) {\n-            clear_in_poststate_(bit_num(fcx, ninit(nid, vec::last(p.idents))),\n-                                t);\n-          }\n-          some(_) {/* ignore args (for now...) */ }\n-          _ { fcx.ccx.tcx.sess.bug(\"clear_in_poststate_expr: unbound var\"); }\n-        }\n-      }\n-      _ {/* do nothing */ }\n-    }\n-}\n-\n fn kill_poststate_(fcx: fn_ctxt, c: tsconstr, post: poststate) -> bool {\n     #debug(\"kill_poststate_\");\n     ret clear_in_poststate_(bit_num(fcx, c), post);\n }\n \n-fn set_in_poststate_ident(fcx: fn_ctxt, id: node_id, ident: ident,\n-                          t: poststate) -> bool {\n-    ret set_in_poststate_(bit_num(fcx, ninit(id, ident)), t);\n-}\n-\n fn set_in_prestate_constr(fcx: fn_ctxt, c: tsconstr, t: prestate) -> bool {\n     ret set_in_poststate_(bit_num(fcx, c), t);\n }\n \n-fn clear_in_poststate_ident(fcx: fn_ctxt, id: node_id, ident: ident,\n-                            parent: node_id) -> bool {\n-    ret kill_poststate(fcx, parent, ninit(id, ident));\n-}\n-\n-fn clear_in_prestate_ident(fcx: fn_ctxt, id: node_id, ident: ident,\n-                           parent: node_id) -> bool {\n-    ret kill_prestate(fcx, parent, ninit(id, ident));\n-}\n-\n-fn clear_in_poststate_ident_(fcx: fn_ctxt, id: node_id, ident: ident,\n-                             post: poststate) -> bool {\n-    ret kill_poststate_(fcx, ninit(id, ident), post);\n-}\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "1cc3a7df9dc2b16fa4d44aa4018b037bc72bc0aa", "filename": "src/rustc/middle/tstate/ck.rs", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f5c51b0a9c084418ae90b8909dc10b13ff318d72/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c51b0a9c084418ae90b8909dc10b13ff318d72/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs?ref=f5c51b0a9c084418ae90b8909dc10b13ff318d72", "patch": "@@ -17,22 +17,6 @@ import states::find_pre_post_state_fn;\n import driver::session::session;\n import std::map::hashmap;\n \n-fn check_unused_vars(fcx: fn_ctxt) {\n-\n-    // FIXME: could be more efficient\n-    for constraints(fcx).each {|c|\n-        alt c.c.node {\n-          ninit(id, v) {\n-            if !vec_contains(fcx.enclosing.used_vars, id) && v[0] != '_' as u8\n-               {\n-                fcx.ccx.tcx.sess.span_warn(c.c.span, \"unused variable \" + v);\n-            }\n-          }\n-          _ {/* ignore pred constraints */ }\n-        }\n-    }\n-}\n-\n fn check_states_expr(e: @expr, fcx: fn_ctxt, v: visit::vt<fn_ctxt>) {\n     visit::visit_expr(e, fcx, v);\n \n@@ -109,39 +93,6 @@ fn check_states_against_conditions(fcx: fn_ctxt,\n           visit_fn: bind do_nothing::<fn_ctxt>(_, _, _, _, _, _, _)\n           with *visit::default_visitor::<fn_ctxt>()});\n     visit::visit_fn(fk, f_decl, f_body, sp, id, fcx, visitor);\n-\n-    /* Check that the return value is initialized */\n-    let post = aux::block_poststate(fcx.ccx, f_body);\n-    let is_ctor = alt fk { visit::fk_ctor(_,_,_,_) { true } _ { false } };\n-    if !is_ctor && !promises(fcx, post, fcx.enclosing.i_return) &&\n-       !ty::type_is_nil(ty::ty_fn_ret(ty::node_id_to_type(\n-           fcx.ccx.tcx, id))) &&\n-       f_decl.cf == return_val {\n-        let fn_ty = ty::node_id_to_type(fcx.ccx.tcx, id);\n-        fcx.ccx.tcx.sess.span_err(f_body.span,\n-                    #fmt(\"in function `%s`, not all control paths \\\n-                          return a value\", fcx.name));\n-        fcx.ccx.tcx.sess.span_fatal(f_decl.output.span,\n-                                    #fmt(\"see function return type of `%s`\",\n-                                         ty_to_str(fcx.ccx.tcx,\n-                                           ty::ty_fn_ret(fn_ty))));\n-    } else if f_decl.cf == noreturn {\n-\n-        // check that this really always fails\n-        // Note that it's ok for i_diverge and i_return to both be true.\n-        // In fact, i_diverge implies i_return. (But not vice versa!)\n-\n-        if !promises(fcx, post, fcx.enclosing.i_diverge) {\n-            fcx.ccx.tcx.sess.span_fatal(f_body.span,\n-                                        \"in non-returning function \" +\n-                                        fcx.name +\n-                                        \", some control paths may \\\n-                                         return to the caller\");\n-        }\n-    }\n-\n-    /* Finally, check for unused variables */\n-    check_unused_vars(fcx);\n }\n \n fn check_fn_states(fcx: fn_ctxt,"}, {"sha": "bfa2fa58f778aac82495b76b5439d4756f5f4f5f", "filename": "src/rustc/middle/tstate/collect_locals.rs", "status": "modified", "additions": 13, "deletions": 58, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f5c51b0a9c084418ae90b8909dc10b13ff318d72/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c51b0a9c084418ae90b8909dc10b13ff318d72/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=f5c51b0a9c084418ae90b8909dc10b13ff318d72", "patch": "@@ -11,13 +11,6 @@ import std::map::hashmap;\n \n type ctxt = {cs: @mut [sp_constr], tcx: ty::ctxt};\n \n-fn collect_local(loc: @local, cx: ctxt, v: visit::vt<ctxt>) {\n-    pat_bindings(cx.tcx.def_map, loc.node.pat) {|p_id, _s, id|\n-       *cx.cs += [respan(loc.span, ninit(p_id, path_to_ident(id)))];\n-    };\n-    visit::visit_local(loc, cx, v);\n-}\n-\n fn collect_pred(e: @expr, cx: ctxt, v: visit::vt<ctxt>) {\n     alt e.node {\n       expr_check(_, ch) { *cx.cs += [expr_to_constr(cx.tcx, ch)]; }\n@@ -48,8 +41,7 @@ fn find_locals(tcx: ty::ctxt,\n     let cx: ctxt = {cs: @mut [], tcx: tcx};\n     let visitor = visit::default_visitor::<ctxt>();\n     let visitor =\n-        @{visit_local: collect_local,\n-          visit_expr: collect_pred,\n+        @{visit_expr: collect_pred,\n           visit_fn: bind do_nothing(_, _, _, _, _, _, _)\n           with *visitor};\n     visit::visit_fn(fk, f_decl, f_body, sp,\n@@ -61,27 +53,17 @@ fn add_constraint(tcx: ty::ctxt, c: sp_constr, next: uint, tbl: constr_map) ->\n    uint {\n     log(debug,\n              constraint_to_str(tcx, c) + \" |-> \" + uint::str(next));\n-    alt c.node {\n-      ninit(id, i) { tbl.insert(local_def(id), cinit(next, c.span, i)); }\n-      npred(p, d_id, args) {\n-        alt tbl.find(d_id) {\n-          some(ct) {\n-            alt ct {\n-              cinit(_, _, _) {\n-                tcx.sess.bug(\"add_constraint: same def_id used\" +\n-                                 \" as a variable and a pred\");\n-              }\n-              cpred(_, pds) {\n-                *pds += [respan(c.span, {args: args, bit_num: next})];\n-              }\n-            }\n-          }\n-          none {\n-            let rslt: @mut [pred_args] =\n-                @mut [respan(c.span, {args: args, bit_num: next})];\n-            tbl.insert(d_id, cpred(p, rslt));\n-          }\n-        }\n+\n+    let {path: p, def_id: d_id, args: args} = c.node;\n+    alt tbl.find(d_id) {\n+      some(ct) {\n+        let {path: _, descs: pds} = ct;\n+        *pds += [respan(c.span, {args: args, bit_num: next})];\n+      }\n+      none {\n+        let rslt: @mut [pred_args] =\n+            @mut [respan(c.span, {args: args, bit_num: next})];\n+        tbl.insert(d_id, {path:p, descs:rslt});\n       }\n     }\n     ret next + 1u;\n@@ -106,7 +88,7 @@ fn mk_fn_info(ccx: crate_ctxt,\n \n     let mut i = 0u, l = vec::len(*cx.cs);\n     while i < l {\n-        next = add_constraint(cx.tcx, cx.cs[i], next, res_map);\n+        next = add_constraint(cx.tcx, copy cx.cs[i], next, res_map);\n         i += 1u;\n     }\n     /* if this function has any constraints, instantiate them to the\n@@ -116,38 +98,11 @@ fn mk_fn_info(ccx: crate_ctxt,\n         next = add_constraint(cx.tcx, sc, next, res_map);\n     }\n \n-    /* Need to add constraints for args too, b/c they\n-    can be deinitialized */\n-    for f_decl.inputs.each {|a|\n-        next = add_constraint(\n-            cx.tcx,\n-            respan(f_sp, ninit(a.id, a.ident)),\n-            next,\n-            res_map);\n-    }\n-\n-    /* add the special i_diverge and i_return constraints\n-    (see the type definition for auxiliary::fn_info for an explanation) */\n-\n-    // use the function name for the \"returns\" constraint\"\n-    let returns_id = ccx.tcx.sess.next_node_id();\n-    let returns_constr = ninit(returns_id, name);\n-    next =\n-        add_constraint(cx.tcx, respan(f_sp, returns_constr), next, res_map);\n-    // and the name of the function, with a '!' appended to it, for the\n-    // \"diverges\" constraint\n-    let diverges_id = ccx.tcx.sess.next_node_id();\n-    let diverges_constr = ninit(diverges_id, name + \"!\");\n-    next = add_constraint(cx.tcx, respan(f_sp, diverges_constr), next,\n-                          res_map);\n-\n     let v: @mut [node_id] = @mut [];\n     let rslt =\n         {constrs: res_map,\n          num_constraints: next,\n          cf: f_decl.cf,\n-         i_return: returns_constr,\n-         i_diverge: diverges_constr,\n          used_vars: v};\n     ccx.fm.insert(id, rslt);\n     #debug(\"%s has %u constraints\", name, num_constraints(rslt));"}, {"sha": "20a1c7bff85ebc011542f7e83b0b6e65a7338ccd", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 7, "deletions": 61, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f5c51b0a9c084418ae90b8909dc10b13ff318d72/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c51b0a9c084418ae90b8909dc10b13ff318d72/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=f5c51b0a9c084418ae90b8909dc10b13ff318d72", "patch": "@@ -88,17 +88,9 @@ fn find_pre_post_exprs(fcx: fn_ctxt, args: [@expr], id: node_id) {\n                      seq_postconds(fcx, vec::map(pps, get_post)));\n }\n \n-fn find_pre_post_loop(fcx: fn_ctxt, l: @local, index: @expr, body: blk,\n-                      id: node_id) {\n+fn find_pre_post_loop(fcx: fn_ctxt, index: @expr, body: blk, id: node_id) {\n     find_pre_post_expr(fcx, index);\n     find_pre_post_block(fcx, body);\n-    pat_bindings(fcx.ccx.tcx.def_map, l.node.pat) {|p_id, _s, n|\n-        let v_init = ninit(p_id, path_to_ident(n));\n-        relax_precond_block(fcx, bit_num(fcx, v_init) as node_id, body);\n-        // Hack: for-loop index variables are frequently ignored,\n-        // so we pretend they're used\n-        use_var(fcx, p_id);\n-    };\n \n     let loop_precond =\n         seq_preconds(fcx, [expr_pp(fcx.ccx, index), block_pp(fcx.ccx, body)]);\n@@ -184,8 +176,6 @@ fn gen_if_local(fcx: fn_ctxt, lhs: @expr, rhs: @expr, larger_id: node_id,\n             let p = expr_pp(fcx.ccx, rhs);\n             set_pre_and_post(fcx.ccx, larger_id, p.precondition,\n                              p.postcondition);\n-            gen(fcx, larger_id,\n-                ninit(nid, path_to_ident(pth)));\n           }\n           _ { find_pre_post_exprs(fcx, [lhs, rhs], larger_id); }\n         }\n@@ -207,23 +197,13 @@ fn handle_update(fcx: fn_ctxt, parent: @expr, lhs: @expr, rhs: @expr,\n             if is_path(rhs) { forget_in_postcond(fcx, parent.id, rhs.id); }\n           }\n           oper_swap {\n-            forget_in_postcond_still_init(fcx, parent.id, lhs.id);\n-            forget_in_postcond_still_init(fcx, parent.id, rhs.id);\n+            forget_in_postcond(fcx, parent.id, lhs.id);\n+            forget_in_postcond(fcx, parent.id, rhs.id);\n           }\n           oper_assign {\n-            forget_in_postcond_still_init(fcx, parent.id, lhs.id);\n-          }\n-          _ {\n-            // pure and assign_op require the lhs to be init'd\n-            let df = node_id_to_def_strict(fcx.ccx.tcx, lhs.id);\n-            alt df {\n-              def_local(nid, _) {\n-                let i = bit_num(fcx, ninit(nid, path_to_ident(p)));\n-                require_and_preserve(i, expr_pp(fcx.ccx, lhs));\n-              }\n-              _ { }\n-            }\n+            forget_in_postcond(fcx, parent.id, lhs.id);\n           }\n+          _ { }\n         }\n \n         gen_if_local(fcx, lhs, rhs, parent.id, lhs.id, p);\n@@ -255,22 +235,6 @@ fn handle_update(fcx: fn_ctxt, parent: @expr, lhs: @expr, rhs: @expr,\n     }\n }\n \n-fn handle_var(fcx: fn_ctxt, rslt: pre_and_post, id: node_id, name: ident) {\n-    handle_var_def(fcx, rslt, node_id_to_def_strict(fcx.ccx.tcx, id), name);\n-}\n-\n-fn handle_var_def(fcx: fn_ctxt, rslt: pre_and_post, def: def, name: ident) {\n-    log(debug, (\"handle_var_def: \", def, name));\n-    alt def {\n-      def_local(nid, _) | def_arg(nid, _) {\n-        use_var(fcx, nid);\n-        let i = bit_num(fcx, ninit(nid, name));\n-        require_and_preserve(i, rslt);\n-      }\n-      _ {/* nothing to check */ }\n-    }\n-}\n-\n fn forget_args_moved_in(fcx: fn_ctxt, parent: @expr, modes: [mode],\n                         operands: [@expr]) {\n     vec::iteri(modes) {|i,mode|\n@@ -284,10 +248,6 @@ fn forget_args_moved_in(fcx: fn_ctxt, parent: @expr, modes: [mode],\n fn find_pre_post_expr_fn_upvars(fcx: fn_ctxt, e: @expr) {\n     let rslt = expr_pp(fcx.ccx, e);\n     clear_pp(rslt);\n-    for vec::each(*freevars::get_freevars(fcx.ccx.tcx, e.id)) {|def|\n-        log(debug, (\"handle_var_def: def=\", def));\n-        handle_var_def(fcx, rslt, def.def, \"upvar\");\n-    }\n }\n \n /* Fills in annotations as a side effect. Does not rebuild the expr */\n@@ -332,7 +292,6 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       expr_path(p) {\n         let rslt = expr_pp(fcx.ccx, e);\n         clear_pp(rslt);\n-        handle_var(fcx, rslt, e.id, path_to_ident(p));\n       }\n       expr_new(p, _, v) {\n         find_pre_post_exprs(fcx, [p, v], e.id);\n@@ -374,7 +333,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n            already be initialized */\n \n         find_pre_post_exprs(fcx, [lhs, rhs], e.id);\n-        forget_in_postcond_still_init(fcx, e.id, lhs.id);\n+        forget_in_postcond(fcx, e.id, lhs.id);\n       }\n       expr_lit(_) { clear_pp(expr_pp(fcx.ccx, e)); }\n       expr_ret(maybe_val) {\n@@ -555,25 +514,16 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                           }\n                           none { }\n                         }\n-                        gen(fcx, id, ninit(p_id, ident));\n                     };\n \n-                    if an_init.op == init_move && is_path(an_init.expr) {\n-                        forget_in_postcond(fcx, id, an_init.expr.id);\n-                    }\n-\n                     /* Clear out anything that the previous initializer\n                     guaranteed */\n                     let e_pp = expr_pp(fcx.ccx, an_init.expr);\n                     tritv_copy(prev_pp.precondition,\n                                seq_preconds(fcx, [prev_pp, e_pp]));\n+\n                     /* Include the LHSs too, since those aren't in the\n                      postconds of the RHSs themselves */\n-                    pat_bindings(fcx.ccx.tcx.def_map, alocal.node.pat)\n-                        {|pat_id, _s, n|\n-                            set_in_postcond(bit_num(fcx,\n-                               ninit(pat_id, path_to_ident(n))), prev_pp);\n-                          };\n                     copy_pre_post_(fcx.ccx, id, prev_pp.precondition,\n                                    prev_pp.postcondition);\n                   }\n@@ -659,10 +609,6 @@ fn find_pre_post_block(fcx: fn_ctxt, b: blk) {\n }\n \n fn find_pre_post_fn(fcx: fn_ctxt, body: blk) {\n-    // hack\n-    use_var(fcx, tsconstr_to_node_id(fcx.enclosing.i_return));\n-    use_var(fcx, tsconstr_to_node_id(fcx.enclosing.i_diverge));\n-\n     find_pre_post_block(fcx, body);\n \n     // Treat the tail expression as a return statement"}, {"sha": "abfe2989f780133ce7f1958e1f467bbc63d8badc", "filename": "src/rustc/middle/tstate/states.rs", "status": "modified", "additions": 6, "deletions": 86, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f5c51b0a9c084418ae90b8909dc10b13ff318d72/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c51b0a9c084418ae90b8909dc10b13ff318d72/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=f5c51b0a9c084418ae90b8909dc10b13ff318d72", "patch": "@@ -55,22 +55,6 @@ fn handle_move_or_copy(fcx: fn_ctxt, post: poststate, rhs_path: @path,\n     }\n }\n \n-fn handle_fail(fcx: fn_ctxt, pres:prestate, post:poststate) {\n-    // Remember what the old value of the \"I return\" trit was, so that\n-    // we can avoid changing that (if it was true, there was a return\n-    // that dominates this fail and the fail is unreachable)\n-    if !promises(fcx, pres, fcx.enclosing.i_return)\n-        // (only if we're in a diverging function -- you can fail when\n-        // you're supposed to return, but not vice versa).\n-        && fcx.enclosing.cf == noreturn {\n-          kill_poststate_(fcx, fcx.enclosing.i_return, post);\n-    } else {\n-        // This code is unreachable (it's dominated by a return),\n-        // so doesn't diverge.\n-        kill_poststate_(fcx, fcx.enclosing.i_diverge, post);\n-    }\n-}\n-\n fn seq_states(fcx: fn_ctxt, pres: prestate, bindings: [binding]) ->\n    {changed: bool, post: poststate} {\n     let mut changed = false;\n@@ -90,12 +74,6 @@ fn seq_states(fcx: fn_ctxt, pres: prestate, bindings: [binding]) ->\n                   }\n                   _ { }\n                 }\n-                alt d {\n-                  local_dest(i) {\n-                      set_in_poststate_ident(fcx, i.node, i.ident, post);\n-                  }\n-                  _ {}\n-                }\n             }\n \n             // Forget the RHS if we just moved it.\n@@ -104,15 +82,6 @@ fn seq_states(fcx: fn_ctxt, pres: prestate, bindings: [binding]) ->\n             }\n           }\n           none {\n-            for b.lhs.each {|d|\n-                // variables w/o an initializer\n-                 alt check d {\n-                   // would be an error to pass something uninit'd to a call\n-                   local_dest(i) {\n-                     clear_in_poststate_ident_(fcx, i.node, i.ident, post);\n-                   }\n-                 }\n-            }\n           }\n         }\n     }\n@@ -158,16 +127,15 @@ fn find_pre_post_state_two(fcx: fn_ctxt, pres: prestate, lhs: @expr,\n         alt ty {\n           oper_move {\n             if is_path(rhs) { forget_in_poststate(fcx, post, rhs.id); }\n-            forget_in_poststate_still_init(fcx, post, lhs.id);\n+            forget_in_poststate(fcx, post, lhs.id);\n           }\n           oper_swap {\n-            forget_in_poststate_still_init(fcx, post, lhs.id);\n-            forget_in_poststate_still_init(fcx, post, rhs.id);\n+            forget_in_poststate(fcx, post, lhs.id);\n+            forget_in_poststate(fcx, post, rhs.id);\n           }\n-          _ { forget_in_poststate_still_init(fcx, post, lhs.id); }\n+          _ { forget_in_poststate(fcx, post, lhs.id); }\n         }\n \n-        gen_if_local(fcx, post, lhs);\n         alt rhs.node {\n           expr_path(p1) {\n             let d = local_node_id_to_local_def_id(fcx, lhs.id);\n@@ -222,7 +190,6 @@ fn find_pre_post_state_exprs(fcx: fn_ctxt, pres: prestate, id: node_id,\n     alt cf {\n       noreturn {\n         let post = false_postcond(num_constraints(fcx.enclosing));\n-        handle_fail(fcx, pres, post);\n         changed |= set_poststate_ann(fcx.ccx, id, post);\n       }\n       _ { changed |= set_poststate_ann(fcx.ccx, id, rs.post); }\n@@ -240,16 +207,9 @@ fn find_pre_post_state_loop(fcx: fn_ctxt, pres: prestate, l: @local,\n         set_prestate_ann(fcx.ccx, id, loop_pres) |\n             find_pre_post_state_expr(fcx, pres, index);\n \n-    // Make sure the index vars are considered initialized\n-    // in the body\n     let index_post = tritv_clone(expr_poststate(fcx.ccx, index));\n-    pat_bindings(fcx.ccx.tcx.def_map, l.node.pat) {|p_id, _s, n|\n-       set_in_poststate_ident(fcx, p_id, path_to_ident(n), index_post);\n-    };\n-\n     changed |= find_pre_post_state_block(fcx, index_post, body);\n \n-\n     if has_nonlocal_exits(body) {\n         // See [Break-unsound]\n         ret changed | set_poststate_ann(fcx.ccx, id, pres);\n@@ -261,20 +221,6 @@ fn find_pre_post_state_loop(fcx: fn_ctxt, pres: prestate, l: @local,\n     }\n }\n \n-fn gen_if_local(fcx: fn_ctxt, p: poststate, e: @expr) -> bool {\n-    alt e.node {\n-      expr_path(pth) {\n-        alt fcx.ccx.tcx.def_map.find(e.id) {\n-          some(def_local(nid, _)) {\n-            ret set_in_poststate_ident(fcx, nid, path_to_ident(pth), p);\n-          }\n-          _ { ret false; }\n-        }\n-      }\n-      _ { ret false; }\n-    }\n-}\n-\n fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n                   maybe_alt: option<@expr>, id: node_id, chk: if_ty,\n                   pres: prestate) -> bool {\n@@ -465,13 +411,10 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n       }\n       expr_ret(maybe_ret_val) {\n         let mut changed = set_prestate_ann(fcx.ccx, e.id, pres);\n-        /* normally, everything is true if execution continues after\n+        /* everything is true if execution continues after\n            a ret expression (since execution never continues locally\n            after a ret expression */\n-        // FIXME should factor this out\n         let post = false_postcond(num_constrs);\n-        // except for the \"diverges\" bit...\n-        kill_poststate_(fcx, fcx.enclosing.i_diverge, post);\n \n         set_poststate_ann(fcx.ccx, e.id, post);\n \n@@ -593,7 +536,6 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n         /* if execution continues after fail, then everything is true!\n         woo! */\n         let post = false_postcond(num_constrs);\n-        handle_fail(fcx, pres, post);\n         ret set_prestate_ann(fcx.ccx, e.id, pres) |\n                 set_poststate_ann(fcx.ccx, e.id, post) |\n                 option::map_default(maybe_fail_val, false, {|fail_val|\n@@ -727,37 +669,15 @@ fn find_pre_post_state_fn(fcx: fn_ctxt,\n     // This ensures that intersect works correctly.\n     kill_all_prestate(fcx, f_body.node.id);\n \n-    // Arguments start out initialized\n-    let block_pre = block_prestate(fcx.ccx, f_body);\n-    for f_decl.inputs.each {|a|\n-        set_in_prestate_constr(fcx, ninit(a.id, a.ident), block_pre);\n-    }\n-\n     // Instantiate any constraints on the arguments so we can use them\n+    let block_pre = block_prestate(fcx.ccx, f_body);\n     for f_decl.constraints.each {|c|\n         let tsc = ast_constr_to_ts_constr(fcx.ccx.tcx, f_decl.inputs, c);\n         set_in_prestate_constr(fcx, tsc, block_pre);\n     }\n \n     let mut changed = find_pre_post_state_block(fcx, block_pre, f_body);\n \n-    // Treat the tail expression as a return statement\n-    alt f_body.node.expr {\n-      some(tailexpr) {\n-\n-        // We don't want to clear the diverges bit for bottom typed things,\n-        // which really do diverge. I feel like there is a cleaner way\n-        // to do this than checking the type.\n-        if !type_is_bot(expr_ty(fcx.ccx.tcx, tailexpr)) {\n-            let post = false_postcond(num_constrs);\n-            // except for the \"diverges\" bit...\n-            kill_poststate_(fcx, fcx.enclosing.i_diverge, post);\n-            set_poststate_ann(fcx.ccx, f_body.node.id, post);\n-        }\n-      }\n-      none {/* fallthrough */ }\n-    }\n-\n     /*\n         #error(\"find_pre_post_state_fn\");\n         log(error, changed);"}, {"sha": "83f0c9b802ac8fa6b19271b5fcd3a6fa3b369783", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5c51b0a9c084418ae90b8909dc10b13ff318d72/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c51b0a9c084418ae90b8909dc10b13ff318d72/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=f5c51b0a9c084418ae90b8909dc10b13ff318d72", "patch": "@@ -1,20 +1,14 @@\n fn f1(x: int) {\n     //!^ WARNING unused variable: `x`\n-    //!^^ WARNING unused variable x\n-    // (the 2nd one is from tstate)\n }\n \n fn f1b(&x: int) {\n     //!^ WARNING unused variable: `x`\n-    //!^^ WARNING unused variable x\n-    // (the 2nd one is from tstate)\n }\n \n fn f2() {\n     let x = 3;\n     //!^ WARNING unused variable: `x`\n-    //!^^ WARNING unused variable x\n-    // (the 2nd one is from tstate)\n }\n \n fn f3() {"}, {"sha": "cec9c25e67a21c585fa1a506bf51772a2d978c13", "filename": "src/test/run-pass/liveness-loop-break.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5c51b0a9c084418ae90b8909dc10b13ff318d72/src%2Ftest%2Frun-pass%2Fliveness-loop-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5c51b0a9c084418ae90b8909dc10b13ff318d72/src%2Ftest%2Frun-pass%2Fliveness-loop-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fliveness-loop-break.rs?ref=f5c51b0a9c084418ae90b8909dc10b13ff318d72", "patch": "@@ -1,5 +1,3 @@\n-// xfail-test --- tstate incorrectly fails this\n-\n fn test() {\n     let v;\n     loop {"}]}