{"sha": "989f480297cabee936403fd66baa429f2b8ed4ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4OWY0ODAyOTdjYWJlZTkzNjQwM2ZkNjZiYWE0MjlmMmI4ZWQ0ZWU=", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2018-10-01T21:15:22Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2018-10-03T07:00:21Z"}, "message": "simplify some unused lints code", "tree": {"sha": "123cb952b692ba1e1c27cfe6806386de53140ea1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/123cb952b692ba1e1c27cfe6806386de53140ea1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/989f480297cabee936403fd66baa429f2b8ed4ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/989f480297cabee936403fd66baa429f2b8ed4ee", "html_url": "https://github.com/rust-lang/rust/commit/989f480297cabee936403fd66baa429f2b8ed4ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/989f480297cabee936403fd66baa429f2b8ed4ee/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb", "html_url": "https://github.com/rust-lang/rust/commit/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb"}], "stats": {"total": 37, "additions": 11, "deletions": 26}, "files": [{"sha": "ae178888b6a1cda42a65a67f3ccddb11cbce2a4a", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/989f480297cabee936403fd66baa429f2b8ed4ee/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/989f480297cabee936403fd66baa429f2b8ed4ee/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=989f480297cabee936403fd66baa429f2b8ed4ee", "patch": "@@ -65,9 +65,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             ty::Adt(def, _) => {\n                 if def.variants.is_empty() {\n                     return;\n-                } else {\n-                    check_must_use(cx, def.did, s.span, \"\")\n                 }\n+                check_must_use(cx, def.did, s.span, \"\")\n             },\n             _ => false,\n         };\n@@ -337,21 +336,13 @@ impl EarlyLintPass for UnusedParens {\n             AssignOp(.., ref value) => (value, \"assigned value\", false),\n             // either function/method call, or something this lint doesn't care about\n             ref call_or_other => {\n-                let args_to_check;\n-                let call_kind;\n-                match *call_or_other {\n-                    Call(_, ref args) => {\n-                        call_kind = \"function\";\n-                        args_to_check = &args[..];\n-                    },\n-                    MethodCall(_, ref args) => {\n-                        call_kind = \"method\";\n-                        // first \"argument\" is self (which sometimes needs parens)\n-                        args_to_check = &args[1..];\n-                    }\n+                let (args_to_check, call_kind) = match *call_or_other {\n+                    Call(_, ref args) => (&args[..], \"function\"),\n+                    // first \"argument\" is self (which sometimes needs parens)\n+                    MethodCall(_, ref args) => (&args[1..], \"method\"),\n                     // actual catch-all arm\n                     _ => { return; }\n-                }\n+                };\n                 // Don't lint if this is a nested macro expansion: otherwise, the lint could\n                 // trigger in situations that macro authors shouldn't have to care about, e.g.,\n                 // when a parenthesized token tree matched in one macro expansion is matched as\n@@ -372,16 +363,11 @@ impl EarlyLintPass for UnusedParens {\n     }\n \n     fn check_stmt(&mut self, cx: &EarlyContext, s: &ast::Stmt) {\n-        let (value, msg) = match s.node {\n-            ast::StmtKind::Local(ref local) => {\n-                match local.init {\n-                    Some(ref value) => (value, \"assigned value\"),\n-                    None => return,\n-                }\n+        if let ast::StmtKind::Local(ref local) = s.node {\n+            if let Some(ref value) = local.init {\n+                self.check_unused_parens_core(cx, &value, \"assigned value\", false);\n             }\n-            _ => return,\n-        };\n-        self.check_unused_parens_core(cx, &value, msg, false);\n+        }\n     }\n }\n \n@@ -414,9 +400,8 @@ impl UnusedImportBraces {\n                     let orig_ident = items[0].0.prefix.segments.last().unwrap().ident;\n                     if orig_ident.name == keywords::SelfValue.name() {\n                         return;\n-                    } else {\n-                        node_ident = rename.unwrap_or(orig_ident);\n                     }\n+                    node_ident = rename.unwrap_or(orig_ident);\n                 }\n                 ast::UseTreeKind::Glob => {\n                     node_ident = ast::Ident::from_str(\"*\");"}]}