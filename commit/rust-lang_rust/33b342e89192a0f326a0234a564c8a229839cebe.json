{"sha": "33b342e89192a0f326a0234a564c8a229839cebe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzYjM0MmU4OTE5MmEwZjMyNmEwMjM0YTU2NGM4YTIyOTgzOWNlYmU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-20T21:11:47Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-20T21:11:47Z"}, "message": "Teach ast and parser about linear for expressions.", "tree": {"sha": "5518834cc2af7576f4c82f68d68a91594258cbec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5518834cc2af7576f4c82f68d68a91594258cbec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33b342e89192a0f326a0234a564c8a229839cebe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33b342e89192a0f326a0234a564c8a229839cebe", "html_url": "https://github.com/rust-lang/rust/commit/33b342e89192a0f326a0234a564c8a229839cebe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33b342e89192a0f326a0234a564c8a229839cebe/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d3ebd6a57b51f02788331f56681e8f593d82e60", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d3ebd6a57b51f02788331f56681e8f593d82e60", "html_url": "https://github.com/rust-lang/rust/commit/9d3ebd6a57b51f02788331f56681e8f593d82e60"}], "stats": {"total": 84, "additions": 56, "deletions": 28}, "files": [{"sha": "e2ccce7bc81f21d1e3f5d561df1fa3584943bced", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/33b342e89192a0f326a0234a564c8a229839cebe/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b342e89192a0f326a0234a564c8a229839cebe/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=33b342e89192a0f326a0234a564c8a229839cebe", "patch": "@@ -150,6 +150,7 @@ tag expr_ {\n     expr_cast(@expr, @ty, ann);\n     expr_if(@expr, block, option.t[block], ann);\n     expr_while(@expr, block, ann);\n+    expr_for(@local, @expr, block, ann);\n     expr_do_while(block, @expr, ann);\n     expr_alt(@expr, vec[arm], ann);\n     expr_block(block, ann);"}, {"sha": "049d10b4e6ab37ff6c84b55d11242378f34231a5", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 55, "deletions": 28, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/33b342e89192a0f326a0234a564c8a229839cebe/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33b342e89192a0f326a0234a564c8a229839cebe/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=33b342e89192a0f326a0234a564c8a229839cebe", "patch": "@@ -891,6 +891,29 @@ impure fn parse_if_expr(parser p) -> @ast.expr {\n     ret @spanned(lo, hi, ast.expr_if(cond, thn, els, ast.ann_none));\n }\n \n+impure fn parse_for_expr(parser p) -> @ast.expr {\n+    auto lo = p.get_span();\n+    auto hi = lo;\n+\n+    expect(p, token.FOR);\n+    expect (p, token.LPAREN);\n+\n+    let @ast.local local;\n+    if (p.peek() == token.AUTO) {\n+        p.bump();\n+        local = parse_auto_local(p);\n+    } else {\n+        local = parse_typed_local(p);\n+    }\n+    expect(p, token.IN);\n+\n+    auto seq = parse_expr(p);\n+    expect(p, token.RPAREN);\n+    auto body = parse_block(p);\n+    hi = body.span;\n+    ret @spanned(lo, hi, ast.expr_for(local, seq, body, ast.ann_none));\n+}\n+\n impure fn parse_while_expr(parser p) -> @ast.expr {\n     auto lo = p.get_span();\n     auto hi = lo;\n@@ -979,6 +1002,9 @@ impure fn parse_expr_inner(parser p) -> @ast.expr {\n         case (token.IF) {\n             ret parse_if_expr(p);\n         }\n+        case (token.FOR) {\n+            ret parse_for_expr(p);\n+        }\n         case (token.WHILE) {\n             ret parse_while_expr(p);\n         }\n@@ -1052,43 +1078,40 @@ impure fn parse_pat(parser p) -> @ast.pat {\n     ret @spanned(lo, hi, pat);\n }\n \n-impure fn parse_let(parser p) -> @ast.decl {\n-    auto lo = p.get_span();\n-\n-    expect(p, token.LET);\n-    auto ty = parse_ty(p);\n+impure fn parse_local(&option.t[@ast.ty] tyopt, parser p) -> @ast.local {\n     auto ident = parse_ident(p);\n     auto init = parse_initializer(p);\n+    ret @rec(ty = tyopt,\n+             infer = false,\n+             ident = ident,\n+             init = init,\n+             id = p.next_def_id(),\n+             ann = ast.ann_none);\n+}\n \n-    auto hi = p.get_span();\n+impure fn parse_typed_local(parser p) -> @ast.local {\n+    auto ty = parse_ty(p);\n+    ret parse_local(some(ty), p);\n+}\n \n-    let ast.local local = rec(ty = some(ty),\n-                              infer = false,\n-                              ident = ident,\n-                              init = init,\n-                              id = p.next_def_id(),\n-                              ann = ast.ann_none);\n+impure fn parse_auto_local(parser p) -> @ast.local {\n+    ret parse_local(none[@ast.ty], p);\n+}\n \n-    ret @spanned(lo, hi, ast.decl_local(@local));\n+impure fn parse_let(parser p) -> @ast.decl {\n+    auto lo = p.get_span();\n+    expect(p, token.LET);\n+    auto local = parse_typed_local(p);\n+    auto hi = p.get_span();\n+    ret @spanned(lo, hi, ast.decl_local(local));\n }\n \n impure fn parse_auto(parser p) -> @ast.decl {\n     auto lo = p.get_span();\n-\n     expect(p, token.AUTO);\n-    auto ident = parse_ident(p);\n-    auto init = parse_initializer(p);\n-\n+    auto local = parse_auto_local(p);\n     auto hi = p.get_span();\n-\n-    let ast.local local = rec(ty = none[@ast.ty],\n-                              infer = true,\n-                              ident = ident,\n-                              init = init,\n-                              id = p.next_def_id(),\n-                              ann = ast.ann_none);\n-\n-    ret @spanned(lo, hi, ast.decl_local(@local));\n+    ret @spanned(lo, hi, ast.decl_local(local));\n }\n \n impure fn parse_stmt(parser p) -> @ast.stmt {\n@@ -1150,6 +1173,11 @@ impure fn parse_stmt(parser p) -> @ast.stmt {\n             ret @spanned(lo, e.span, ast.stmt_expr(e));\n         }\n \n+        case (token.FOR) {\n+            auto e = parse_expr(p);\n+            ret @spanned(lo, e.span, ast.stmt_expr(e));\n+        }\n+\n         case (token.WHILE) {\n             auto e = parse_expr(p);\n             ret @spanned(lo, e.span, ast.stmt_expr(e));\n@@ -1279,6 +1307,7 @@ fn stmt_ends_with_semi(@ast.stmt stmt) -> bool {\n                 case (ast.expr_lit(_,_))        { ret true; }\n                 case (ast.expr_cast(_,_,_))     { ret true; }\n                 case (ast.expr_if(_,_,_,_))     { ret false; }\n+                case (ast.expr_for(_,_,_,_))    { ret false; }\n                 case (ast.expr_while(_,_,_))    { ret false; }\n                 case (ast.expr_do_while(_,_,_)) { ret false; }\n                 case (ast.expr_alt(_,_,_))      { ret false; }\n@@ -1289,10 +1318,8 @@ fn stmt_ends_with_semi(@ast.stmt stmt) -> bool {\n                 case (ast.expr_field(_,_,_))    { ret true; }\n                 case (ast.expr_index(_,_,_))    { ret true; }\n                 case (ast.expr_path(_,_,_))     { ret true; }\n-                case (_)                        { fail; }\n             }\n         }\n-        case (_)                                { fail; }\n     }\n }\n "}]}