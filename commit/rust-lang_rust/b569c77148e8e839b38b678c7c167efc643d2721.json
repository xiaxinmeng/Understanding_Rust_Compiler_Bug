{"sha": "b569c77148e8e839b38b678c7c167efc643d2721", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1NjljNzcxNDhlOGU4MzliMzhiNjc4YzdjMTY3ZWZjNjQzZDI3MjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-29T11:21:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-29T11:21:39Z"}, "message": "auto merge of #14904 : huonw/rust/cstr-remove-withref, r=alexcrichton", "tree": {"sha": "1e37ca850020293794366b73bd26a0a4719f2327", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e37ca850020293794366b73bd26a0a4719f2327"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b569c77148e8e839b38b678c7c167efc643d2721", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b569c77148e8e839b38b678c7c167efc643d2721", "html_url": "https://github.com/rust-lang/rust/commit/b569c77148e8e839b38b678c7c167efc643d2721", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b569c77148e8e839b38b678c7c167efc643d2721/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a3695d54f14491c39da7910082df9ba9c833b37", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a3695d54f14491c39da7910082df9ba9c833b37", "html_url": "https://github.com/rust-lang/rust/commit/6a3695d54f14491c39da7910082df9ba9c833b37"}, {"sha": "569f13a5217f1a699059707b1eccbdefd011ba12", "url": "https://api.github.com/repos/rust-lang/rust/commits/569f13a5217f1a699059707b1eccbdefd011ba12", "html_url": "https://github.com/rust-lang/rust/commit/569f13a5217f1a699059707b1eccbdefd011ba12"}], "stats": {"total": 392, "additions": 230, "deletions": 162}, "files": [{"sha": "5d1f0990409195c10be102241fe9fcc23d857edf", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=b569c77148e8e839b38b678c7c167efc643d2721", "patch": "@@ -682,9 +682,9 @@ pub mod test {\n             let two = \"twoTwo\".to_c_str();\n             let three = \"threeThree\".to_c_str();\n             let arr = vec![\n-                one.with_ref(|buf| buf),\n-                two.with_ref(|buf| buf),\n-                three.with_ref(|buf| buf)\n+                one.as_ptr(),\n+                two.as_ptr(),\n+                three.as_ptr()\n             ];\n             let expected_arr = [\n                 one, two, three\n@@ -694,9 +694,7 @@ pub mod test {\n             let mut iteration_count = 0;\n             array_each_with_len(arr.as_ptr(), arr.len(), |e| {\n                     let actual = str::raw::from_c_str(e);\n-                    let expected = expected_arr[ctr].with_ref(|buf| {\n-                            str::raw::from_c_str(buf)\n-                        });\n+                    let expected = str::raw::from_c_str(expected_arr[ctr].as_ptr());\n                     assert_eq!(actual.as_slice(), expected.as_slice());\n                     ctr += 1;\n                     iteration_count += 1;\n@@ -712,9 +710,9 @@ pub mod test {\n             let two = \"twoTwo\".to_c_str();\n             let three = \"threeThree\".to_c_str();\n             let arr = vec![\n-                one.with_ref(|buf| buf),\n-                two.with_ref(|buf| buf),\n-                three.with_ref(|buf| buf),\n+                one.as_ptr(),\n+                two.as_ptr(),\n+                three.as_ptr(),\n                 // fake a null terminator\n                 null()\n             ];\n@@ -727,9 +725,7 @@ pub mod test {\n             let mut iteration_count = 0u;\n             array_each(arr_ptr, |e| {\n                     let actual = str::raw::from_c_str(e);\n-                    let expected = expected_arr[ctr].with_ref(|buf| {\n-                        str::raw::from_c_str(buf)\n-                    });\n+                    let expected = str::raw::from_c_str(expected_arr[ctr].as_ptr());\n                     assert_eq!(actual.as_slice(), expected.as_slice());\n                     ctr += 1;\n                     iteration_count += 1;"}, {"sha": "0977b55d8b9780d437f385fb473e1ecf49997943", "filename": "src/libnative/io/addrinfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibnative%2Fio%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibnative%2Fio%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Faddrinfo.rs?ref=b569c77148e8e839b38b678c7c167efc643d2721", "patch": "@@ -50,8 +50,8 @@ impl GetAddrInfoRequest {\n \n         // Make the call\n         let s = unsafe {\n-            let ch = if c_host.is_null() { null() } else { c_host.with_ref(|x| x) };\n-            let cs = if c_serv.is_null() { null() } else { c_serv.with_ref(|x| x) };\n+            let ch = if c_host.is_null() { null() } else { c_host.as_ptr() };\n+            let cs = if c_serv.is_null() { null() } else { c_serv.as_ptr() };\n             getaddrinfo(ch, cs, hint_ptr, &mut res)\n         };\n "}, {"sha": "ddcff2be5f340c02eb8f43bc7aca910136c92bda", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=b569c77148e8e839b38b678c7c167efc643d2721", "patch": "@@ -339,15 +339,15 @@ pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n                             libc::S_IRUSR | libc::S_IWUSR),\n     };\n \n-    match retry(|| unsafe { libc::open(path.with_ref(|p| p), flags, mode) }) {\n+    match retry(|| unsafe { libc::open(path.as_ptr(), flags, mode) }) {\n         -1 => Err(super::last_error()),\n         fd => Ok(FileDesc::new(fd, true)),\n     }\n }\n \n pub fn mkdir(p: &CString, mode: uint) -> IoResult<()> {\n     super::mkerr_libc(retry(|| unsafe {\n-        libc::mkdir(p.with_ref(|p| p), mode as libc::mode_t)\n+        libc::mkdir(p.as_ptr(), mode as libc::mode_t)\n     }))\n }\n \n@@ -356,7 +356,7 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n     use libc::{opendir, readdir_r, closedir};\n \n     fn prune(root: &CString, dirs: Vec<Path>) -> Vec<CString> {\n-        let root = unsafe { CString::new(root.with_ref(|p| p), false) };\n+        let root = unsafe { CString::new(root.as_ptr(), false) };\n         let root = Path::new(root);\n \n         dirs.move_iter().filter(|path| {\n@@ -373,7 +373,7 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n     let mut buf = Vec::<u8>::with_capacity(size as uint);\n     let ptr = buf.as_mut_slice().as_mut_ptr() as *mut dirent_t;\n \n-    let dir_ptr = p.with_ref(|buf| unsafe { opendir(buf) });\n+    let dir_ptr = unsafe {opendir(p.as_ptr())};\n \n     if dir_ptr as uint != 0 {\n         let mut paths = vec!();\n@@ -393,36 +393,36 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n }\n \n pub fn unlink(p: &CString) -> IoResult<()> {\n-    super::mkerr_libc(retry(|| unsafe { libc::unlink(p.with_ref(|p| p)) }))\n+    super::mkerr_libc(retry(|| unsafe { libc::unlink(p.as_ptr()) }))\n }\n \n pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n     super::mkerr_libc(retry(|| unsafe {\n-        libc::rename(old.with_ref(|p| p), new.with_ref(|p| p))\n+        libc::rename(old.as_ptr(), new.as_ptr())\n     }))\n }\n \n pub fn chmod(p: &CString, mode: uint) -> IoResult<()> {\n     super::mkerr_libc(retry(|| unsafe {\n-        libc::chmod(p.with_ref(|p| p), mode as libc::mode_t)\n+        libc::chmod(p.as_ptr(), mode as libc::mode_t)\n     }))\n }\n \n pub fn rmdir(p: &CString) -> IoResult<()> {\n     super::mkerr_libc(retry(|| unsafe {\n-        libc::rmdir(p.with_ref(|p| p))\n+        libc::rmdir(p.as_ptr())\n     }))\n }\n \n pub fn chown(p: &CString, uid: int, gid: int) -> IoResult<()> {\n     super::mkerr_libc(retry(|| unsafe {\n-        libc::chown(p.with_ref(|p| p), uid as libc::uid_t,\n+        libc::chown(p.as_ptr(), uid as libc::uid_t,\n                     gid as libc::gid_t)\n     }))\n }\n \n pub fn readlink(p: &CString) -> IoResult<CString> {\n-    let p = p.with_ref(|p| p);\n+    let p = p.as_ptr();\n     let mut len = unsafe { libc::pathconf(p as *mut _, libc::_PC_NAME_MAX) };\n     if len == -1 {\n         len = 1024; // FIXME: read PATH_MAX from C ffi?\n@@ -443,13 +443,13 @@ pub fn readlink(p: &CString) -> IoResult<CString> {\n \n pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n     super::mkerr_libc(retry(|| unsafe {\n-        libc::symlink(src.with_ref(|p| p), dst.with_ref(|p| p))\n+        libc::symlink(src.as_ptr(), dst.as_ptr())\n     }))\n }\n \n pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n     super::mkerr_libc(retry(|| unsafe {\n-        libc::link(src.with_ref(|p| p), dst.with_ref(|p| p))\n+        libc::link(src.as_ptr(), dst.as_ptr())\n     }))\n }\n \n@@ -489,15 +489,15 @@ fn mkstat(stat: &libc::stat) -> rtio::FileStat {\n \n pub fn stat(p: &CString) -> IoResult<rtio::FileStat> {\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n-    match retry(|| unsafe { libc::stat(p.with_ref(|p| p), &mut stat) }) {\n+    match retry(|| unsafe { libc::stat(p.as_ptr(), &mut stat) }) {\n         0 => Ok(mkstat(&stat)),\n         _ => Err(super::last_error()),\n     }\n }\n \n pub fn lstat(p: &CString) -> IoResult<rtio::FileStat> {\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n-    match retry(|| unsafe { libc::lstat(p.with_ref(|p| p), &mut stat) }) {\n+    match retry(|| unsafe { libc::lstat(p.as_ptr(), &mut stat) }) {\n         0 => Ok(mkstat(&stat)),\n         _ => Err(super::last_error()),\n     }\n@@ -509,7 +509,7 @@ pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n         modtime: (mtime / 1000) as libc::time_t,\n     };\n     super::mkerr_libc(retry(|| unsafe {\n-        libc::utime(p.with_ref(|p| p), &buf)\n+        libc::utime(p.as_ptr(), &buf)\n     }))\n }\n "}, {"sha": "3195fa4f2d4ed301ef755c6838b312217ba1b356", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=b569c77148e8e839b38b678c7c167efc643d2721", "patch": "@@ -347,7 +347,7 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n     use std::rt::libc_heap::malloc_raw;\n \n     fn prune(root: &CString, dirs: Vec<Path>) -> Vec<CString> {\n-        let root = unsafe { CString::new(root.with_ref(|p| p), false) };\n+        let root = unsafe { CString::new(root.as_ptr(), false) };\n         let root = Path::new(root);\n \n         dirs.move_iter().filter(|path| {\n@@ -360,7 +360,7 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n         fn rust_list_dir_wfd_fp_buf(wfd: *mut libc::c_void) -> *const u16;\n     }\n     let star = Path::new(unsafe {\n-        CString::new(p.with_ref(|p| p), false)\n+        CString::new(p.as_ptr(), false)\n     }).join(\"*\");\n     let path = try!(to_utf16(&star.to_c_str()));\n "}, {"sha": "b5b2065f996ed29d079807a1454c3f86f2763269", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=b569c77148e8e839b38b678c7c167efc643d2721", "patch": "@@ -278,7 +278,7 @@ impl Drop for UnixListener {\n         // careful to unlink the path before we close the file descriptor to\n         // prevent races where we unlink someone else's path.\n         unsafe {\n-            let _ = libc::unlink(self.path.with_ref(|p| p));\n+            let _ = libc::unlink(self.path.as_ptr());\n         }\n     }\n }"}, {"sha": "00448b91dbd3492103163c94c37b1d00d087a786", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=b569c77148e8e839b38b678c7c167efc643d2721", "patch": "@@ -531,7 +531,7 @@ fn spawn_process_os(cfg: ProcessConfig,\n         assert_eq!(ret, 0);\n     }\n \n-    let dirp = cfg.cwd.map(|c| c.with_ref(|p| p)).unwrap_or(ptr::null());\n+    let dirp = cfg.cwd.map(|c| c.as_ptr()).unwrap_or(ptr::null());\n \n     let cfg = unsafe {\n         mem::transmute::<ProcessConfig,ProcessConfig<'static>>(cfg)\n@@ -633,7 +633,7 @@ fn spawn_process_os(cfg: ProcessConfig,\n                         } else {\n                             libc::O_RDWR\n                         };\n-                        devnull.with_ref(|p| libc::open(p, flags, 0))\n+                        libc::open(devnull.as_ptr(), flags, 0)\n                     }\n                     Some(obj) => {\n                         let fd = obj.fd();\n@@ -715,8 +715,8 @@ fn with_argv<T>(prog: &CString, args: &[CString],\n     // larger than the lifetime of our invocation of cb, but this is\n     // technically unsafe as the callback could leak these pointers\n     // out of our scope.\n-    ptrs.push(prog.with_ref(|buf| buf));\n-    ptrs.extend(args.iter().map(|tmp| tmp.with_ref(|buf| buf)));\n+    ptrs.push(prog.as_ptr());\n+    ptrs.extend(args.iter().map(|tmp| tmp.as_ptr()));\n \n     // Add a terminating null pointer (required by libc).\n     ptrs.push(ptr::null());"}, {"sha": "b4af291b7eae67ae4275bf7fba70449fb6decde7", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=b569c77148e8e839b38b678c7c167efc643d2721", "patch": "@@ -412,7 +412,7 @@ pub mod write {\n         {\n             let add = |arg: &str| {\n                 let s = arg.to_c_str();\n-                llvm_args.push(s.with_ref(|p| p));\n+                llvm_args.push(s.as_ptr());\n                 llvm_c_strs.push(s);\n             };\n             add(\"rustc\"); // fake program name"}, {"sha": "b9ae9530f8e1c3291aa4a15be0393484b844b0e5", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=b569c77148e8e839b38b678c7c167efc643d2721", "patch": "@@ -94,7 +94,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     // Internalize everything but the reachable symbols of the current module\n     let cstrs: Vec<::std::c_str::CString> =\n         reachable.iter().map(|s| s.as_slice().to_c_str()).collect();\n-    let arr: Vec<*const i8> = cstrs.iter().map(|c| c.with_ref(|p| p)).collect();\n+    let arr: Vec<*const i8> = cstrs.iter().map(|c| c.as_ptr()).collect();\n     let ptr = arr.as_ptr();\n     unsafe {\n         llvm::LLVMRustRunRestrictionPass(llmod,"}, {"sha": "400babb39f82cc12b8dee9be88cee6794947de08", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=b569c77148e8e839b38b678c7c167efc643d2721", "patch": "@@ -1433,24 +1433,23 @@ fn compile_unit_metadata(cx: &CrateContext) {\n     let producer = format!(\"rustc version {}\",\n                            (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n \n-    compile_unit_name.with_ref(|compile_unit_name| {\n-        work_dir.as_vec().with_c_str(|work_dir| {\n-            producer.with_c_str(|producer| {\n-                \"\".with_c_str(|flags| {\n-                    \"\".with_c_str(|split_name| {\n-                        unsafe {\n-                            llvm::LLVMDIBuilderCreateCompileUnit(\n-                                debug_context(cx).builder,\n-                                DW_LANG_RUST,\n-                                compile_unit_name,\n-                                work_dir,\n-                                producer,\n-                                cx.sess().opts.optimize != config::No,\n-                                flags,\n-                                0,\n-                                split_name);\n-                        }\n-                    })\n+    let compile_unit_name = compile_unit_name.as_ptr();\n+    work_dir.as_vec().with_c_str(|work_dir| {\n+        producer.with_c_str(|producer| {\n+            \"\".with_c_str(|flags| {\n+                \"\".with_c_str(|split_name| {\n+                    unsafe {\n+                        llvm::LLVMDIBuilderCreateCompileUnit(\n+                            debug_context(cx).builder,\n+                            DW_LANG_RUST,\n+                            compile_unit_name,\n+                            work_dir,\n+                            producer,\n+                            cx.sess().opts.optimize != config::No,\n+                            flags,\n+                            0,\n+                            split_name);\n+                    }\n                 })\n             })\n         })"}, {"sha": "de4bbeb6e30c8a6439c31d1f46424392796f15cf", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=b569c77148e8e839b38b678c7c167efc643d2721", "patch": "@@ -206,9 +206,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                     s.push_str(highlight::highlight(text.as_slice(), None, id)\n                                          .as_slice());\n                     let output = s.to_c_str();\n-                    output.with_ref(|r| {\n-                        hoedown_buffer_puts(ob, r)\n-                    })\n+                    hoedown_buffer_puts(ob, output.as_ptr());\n                 }\n             })\n         }"}, {"sha": "9734ba2d7518ef90995726a20ab5b8cd906037e9", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 152, "deletions": 77, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=b569c77148e8e839b38b678c7c167efc643d2721", "patch": "@@ -51,11 +51,11 @@ fn main() {\n     // Allocate the C string with an explicit local that owns the string. The\n     // `c_buffer` pointer will be deallocated when `my_c_string` goes out of scope.\n     let my_c_string = my_string.to_c_str();\n-    my_c_string.with_ref(|c_buffer| {\n-        unsafe { puts(c_buffer); }\n-    });\n+    unsafe {\n+        puts(my_c_string.as_ptr());\n+    }\n \n-    // Don't save off the allocation of the C string, the `c_buffer` will be\n+    // Don't save/return the pointer to the C string, the `c_buffer` will be\n     // deallocated when this block returns!\n     my_string.with_c_str(|c_buffer| {\n         unsafe { puts(c_buffer); }\n@@ -122,22 +122,79 @@ impl CString {\n         CString { buf: buf, owns_buffer_: owns_buffer }\n     }\n \n-    /// Unwraps the wrapped `*libc::c_char` from the `CString` wrapper.\n+    /// Return a pointer to the NUL-terminated string data.\n+    ///\n+    /// `.as_ptr` returns an internal pointer into the `CString`, and\n+    /// may be invalidated when the `CString` falls out of scope (the\n+    /// destructor will run, freeing the allocation if there is\n+    /// one).\n+    ///\n+    /// ```rust\n+    /// let foo = \"some string\";\n+    ///\n+    /// // right\n+    /// let x = foo.to_c_str();\n+    /// let p = x.as_ptr();\n+    ///\n+    /// // wrong (the CString will be freed, invalidating `p`)\n+    /// let p = foo.to_c_str().as_ptr();\n+    /// ```\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the CString is null.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// extern crate libc;\n     ///\n-    /// The original object is destructed after this method is called, and if\n-    /// the underlying pointer was previously allocated, care must be taken to\n-    /// ensure that it is deallocated properly.\n-    pub unsafe fn unwrap(self) -> *const libc::c_char {\n-        let mut c_str = self;\n-        c_str.owns_buffer_ = false;\n-        c_str.buf\n+    /// fn main() {\n+    ///     let c_str = \"foo bar\".to_c_str();\n+    ///     unsafe {\n+    ///         libc::puts(c_str.as_ptr());\n+    ///     }\n+    /// }\n+    /// ```\n+    pub fn as_ptr(&self) -> *const libc::c_char {\n+        if self.buf.is_null() { fail!(\"CString is null!\"); }\n+\n+        self.buf\n+    }\n+\n+    /// Return a mutable pointer to the NUL-terminated string data.\n+    ///\n+    /// `.as_mut_ptr` returns an internal pointer into the `CString`, and\n+    /// may be invalidated when the `CString` falls out of scope (the\n+    /// destructor will run, freeing the allocation if there is\n+    /// one).\n+    ///\n+    /// ```rust\n+    /// let foo = \"some string\";\n+    ///\n+    /// // right\n+    /// let mut x = foo.to_c_str();\n+    /// let p = x.as_mut_ptr();\n+    ///\n+    /// // wrong (the CString will be freed, invalidating `p`)\n+    /// let p = foo.to_c_str().as_mut_ptr();\n+    /// ```\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the CString is null.\n+    pub fn as_mut_ptr(&mut self) -> *mut libc::c_char {\n+        if self.buf.is_null() { fail!(\"CString is null!\") }\n+\n+        self.buf as *mut _\n     }\n \n     /// Calls a closure with a reference to the underlying `*libc::c_char`.\n     ///\n     /// # Failure\n     ///\n     /// Fails if the CString is null.\n+    #[deprecated=\"use `.as_ptr()`\"]\n     pub fn with_ref<T>(&self, f: |*const libc::c_char| -> T) -> T {\n         if self.buf.is_null() { fail!(\"CString is null!\"); }\n         f(self.buf)\n@@ -148,6 +205,7 @@ impl CString {\n     /// # Failure\n     ///\n     /// Fails if the CString is null.\n+    #[deprecated=\"use `.as_mut_ptr()`\"]\n     pub fn with_mut_ref<T>(&mut self, f: |*mut libc::c_char| -> T) -> T {\n         if self.buf.is_null() { fail!(\"CString is null!\"); }\n         f(self.buf as *mut libc::c_char)\n@@ -220,6 +278,22 @@ impl CString {\n             marker: marker::ContravariantLifetime,\n         }\n     }\n+\n+    /// Unwraps the wrapped `*libc::c_char` from the `CString` wrapper.\n+    ///\n+    /// Any ownership of the buffer by the `CString` wrapper is\n+    /// forgotten, meaning that the backing allocation of this\n+    /// `CString` is not automatically freed if it owns the\n+    /// allocation. In this case, a user of `.unwrap()` should ensure\n+    /// the allocation is freed, to avoid leaking memory.\n+    ///\n+    /// Prefer `.as_ptr()` when just retrieving a pointer to the\n+    /// string data, as that does not relinquish ownership.\n+    pub unsafe fn unwrap(mut self) -> *const libc::c_char {\n+        self.owns_buffer_ = false;\n+        self.buf\n+    }\n+\n }\n \n impl Drop for CString {\n@@ -285,13 +359,15 @@ pub trait ToCStr {\n     /// Fails the task if the receiver has an interior null.\n     #[inline]\n     fn with_c_str<T>(&self, f: |*const libc::c_char| -> T) -> T {\n-        self.to_c_str().with_ref(f)\n+        let c_str = self.to_c_str();\n+        f(c_str.as_ptr())\n     }\n \n     /// Unsafe variant of `with_c_str()` that doesn't check for nulls.\n     #[inline]\n     unsafe fn with_c_str_unchecked<T>(&self, f: |*const libc::c_char| -> T) -> T {\n-        self.to_c_str_unchecked().with_ref(f)\n+        let c_str = self.to_c_str_unchecked();\n+        f(c_str.as_ptr())\n     }\n }\n \n@@ -353,7 +429,7 @@ static BUF_LEN: uint = 128;\n impl<'a> ToCStr for &'a [u8] {\n     fn to_c_str(&self) -> CString {\n         let mut cs = unsafe { self.to_c_str_unchecked() };\n-        cs.with_mut_ref(|buf| check_for_null(*self, buf));\n+        check_for_null(*self, cs.as_mut_ptr());\n         cs\n     }\n \n@@ -379,7 +455,7 @@ impl<'a> ToCStr for &'a [u8] {\n // Unsafe function that handles possibly copying the &[u8] into a stack array.\n unsafe fn with_c_str<T>(v: &[u8], checked: bool,\n                         f: |*const libc::c_char| -> T) -> T {\n-    if v.len() < BUF_LEN {\n+    let c_str = if v.len() < BUF_LEN {\n         let mut buf: [u8, .. BUF_LEN] = mem::uninitialized();\n         slice::bytes::copy_memory(buf, v);\n         buf[v.len()] = 0;\n@@ -389,12 +465,14 @@ unsafe fn with_c_str<T>(v: &[u8], checked: bool,\n             check_for_null(v, buf as *mut libc::c_char);\n         }\n \n-        f(buf as *const libc::c_char)\n+        return f(buf as *const libc::c_char)\n     } else if checked {\n-        v.to_c_str().with_ref(f)\n+        v.to_c_str()\n     } else {\n-        v.to_c_str_unchecked().with_ref(f)\n-    }\n+        v.to_c_str_unchecked()\n+    };\n+\n+    f(c_str.as_ptr())\n }\n \n #[inline]\n@@ -482,53 +560,51 @@ mod tests {\n \n     #[test]\n     fn test_str_to_c_str() {\n-        \"\".to_c_str().with_ref(|buf| {\n-            unsafe {\n-                assert_eq!(*buf.offset(0), 0);\n-            }\n-        });\n+        let c_str = \"\".to_c_str();\n+        unsafe {\n+            assert_eq!(*c_str.as_ptr().offset(0), 0);\n+        }\n \n-        \"hello\".to_c_str().with_ref(|buf| {\n-            unsafe {\n-                assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n-                assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n-                assert_eq!(*buf.offset(2), 'l' as libc::c_char);\n-                assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n-                assert_eq!(*buf.offset(4), 'o' as libc::c_char);\n-                assert_eq!(*buf.offset(5), 0);\n-            }\n-        })\n+        let c_str = \"hello\".to_c_str();\n+        let buf = c_str.as_ptr();\n+        unsafe {\n+            assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n+            assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n+            assert_eq!(*buf.offset(2), 'l' as libc::c_char);\n+            assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n+            assert_eq!(*buf.offset(4), 'o' as libc::c_char);\n+            assert_eq!(*buf.offset(5), 0);\n+        }\n     }\n \n     #[test]\n     fn test_vec_to_c_str() {\n         let b: &[u8] = [];\n-        b.to_c_str().with_ref(|buf| {\n-            unsafe {\n-                assert_eq!(*buf.offset(0), 0);\n-            }\n-        });\n+        let c_str = b.to_c_str();\n+        unsafe {\n+            assert_eq!(*c_str.as_ptr().offset(0), 0);\n+        }\n \n-        let _ = b\"hello\".to_c_str().with_ref(|buf| {\n-            unsafe {\n-                assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n-                assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n-                assert_eq!(*buf.offset(2), 'l' as libc::c_char);\n-                assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n-                assert_eq!(*buf.offset(4), 'o' as libc::c_char);\n-                assert_eq!(*buf.offset(5), 0);\n-            }\n-        });\n+        let c_str = b\"hello\".to_c_str();\n+        let buf = c_str.as_ptr();\n+        unsafe {\n+            assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n+            assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n+            assert_eq!(*buf.offset(2), 'l' as libc::c_char);\n+            assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n+            assert_eq!(*buf.offset(4), 'o' as libc::c_char);\n+            assert_eq!(*buf.offset(5), 0);\n+        }\n \n-        let _ = b\"foo\\xFF\".to_c_str().with_ref(|buf| {\n-            unsafe {\n-                assert_eq!(*buf.offset(0), 'f' as libc::c_char);\n-                assert_eq!(*buf.offset(1), 'o' as libc::c_char);\n-                assert_eq!(*buf.offset(2), 'o' as libc::c_char);\n-                assert_eq!(*buf.offset(3), 0xff as i8);\n-                assert_eq!(*buf.offset(4), 0);\n-            }\n-        });\n+        let c_str = b\"foo\\xFF\".to_c_str();\n+        let buf = c_str.as_ptr();\n+        unsafe {\n+            assert_eq!(*buf.offset(0), 'f' as libc::c_char);\n+            assert_eq!(*buf.offset(1), 'o' as libc::c_char);\n+            assert_eq!(*buf.offset(2), 'o' as libc::c_char);\n+            assert_eq!(*buf.offset(3), 0xffu8 as i8);\n+            assert_eq!(*buf.offset(4), 0);\n+        }\n     }\n \n     #[test]\n@@ -545,19 +621,18 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_with_ref() {\n+    fn test_as_ptr() {\n         let c_str = \"hello\".to_c_str();\n-        let len = unsafe { c_str.with_ref(|buf| libc::strlen(buf)) };\n+        let len = unsafe { libc::strlen(c_str.as_ptr()) };\n         assert!(!c_str.is_null());\n         assert!(c_str.is_not_null());\n         assert_eq!(len, 5);\n     }\n-\n     #[test]\n     #[should_fail]\n-    fn test_with_ref_empty_fail() {\n+    fn test_as_ptr_empty_fail() {\n         let c_str = unsafe { CString::new(ptr::null(), false) };\n-        c_str.with_ref(|_| ());\n+        c_str.as_ptr();\n     }\n \n     #[test]\n@@ -584,15 +659,15 @@ mod tests {\n     #[test]\n     fn test_to_c_str_unchecked() {\n         unsafe {\n-            \"he\\x00llo\".to_c_str_unchecked().with_ref(|buf| {\n-                assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n-                assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n-                assert_eq!(*buf.offset(2), 0);\n-                assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n-                assert_eq!(*buf.offset(4), 'l' as libc::c_char);\n-                assert_eq!(*buf.offset(5), 'o' as libc::c_char);\n-                assert_eq!(*buf.offset(6), 0);\n-            })\n+            let c_string = \"he\\x00llo\".to_c_str_unchecked();\n+            let buf = c_string.as_ptr();\n+            assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n+            assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n+            assert_eq!(*buf.offset(2), 0);\n+            assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n+            assert_eq!(*buf.offset(4), 'l' as libc::c_char);\n+            assert_eq!(*buf.offset(5), 'o' as libc::c_char);\n+            assert_eq!(*buf.offset(6), 0);\n         }\n     }\n \n@@ -675,10 +750,10 @@ mod tests {\n             let s = \"test\".to_string();\n             let c = s.to_c_str();\n             // give the closure a non-owned CString\n-            let mut c_ = c.with_ref(|c| unsafe { CString::new(c, false) } );\n+            let mut c_ = unsafe { CString::new(c.as_ptr(), false) };\n             f(&c_);\n             // muck with the buffer for later printing\n-            c_.with_mut_ref(|c| unsafe { *c = 'X' as libc::c_char } );\n+            unsafe { *c_.as_mut_ptr() = 'X' as libc::c_char }\n         }\n \n         let mut c_: Option<CString> = None;\n@@ -732,7 +807,7 @@ mod bench {\n     fn bench_to_str(b: &mut Bencher, s: &str) {\n         b.iter(|| {\n             let c_str = s.to_c_str();\n-            c_str.with_ref(|c_str_buf| check(s, c_str_buf))\n+            check(s, c_str.as_ptr());\n         })\n     }\n \n@@ -754,7 +829,7 @@ mod bench {\n     fn bench_to_c_str_unchecked(b: &mut Bencher, s: &str) {\n         b.iter(|| {\n             let c_str = unsafe { s.to_c_str_unchecked() };\n-            c_str.with_ref(|c_str_buf| check(s, c_str_buf))\n+            check(s, c_str.as_ptr())\n         })\n     }\n "}, {"sha": "6eaab1c0961707347b3ab6070affe7105b3b0a82", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=b569c77148e8e839b38b678c7c167efc643d2721", "patch": "@@ -40,7 +40,7 @@ impl GetAddrInfoRequest {\n         let (_c_node, c_node_ptr) = match node {\n             Some(n) => {\n                 let c_node = n.to_c_str();\n-                let c_node_ptr = c_node.with_ref(|r| r);\n+                let c_node_ptr = c_node.as_ptr();\n                 (Some(c_node), c_node_ptr)\n             }\n             None => (None, null())\n@@ -49,7 +49,7 @@ impl GetAddrInfoRequest {\n         let (_c_service, c_service_ptr) = match service {\n             Some(s) => {\n                 let c_service = s.to_c_str();\n-                let c_service_ptr = c_service.with_ref(|r| r);\n+                let c_service_ptr = c_service.as_ptr();\n                 (Some(c_service), c_service_ptr)\n             }\n             None => (None, null())"}, {"sha": "76b2c22e86e0f3c1281c1d964220c6374ba231a0", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=b569c77148e8e839b38b678c7c167efc643d2721", "patch": "@@ -41,7 +41,7 @@ impl FsRequest {\n     {\n         execute(|req, cb| unsafe {\n             uvll::uv_fs_open(io.uv_loop(),\n-                             req, path.with_ref(|p| p), flags as c_int,\n+                             req, path.as_ptr(), flags as c_int,\n                              mode as c_int, cb)\n         }).map(|req|\n             FileWatcher::new(io, req.get_result() as c_int,\n@@ -51,7 +51,7 @@ impl FsRequest {\n \n     pub fn unlink(loop_: &Loop, path: &CString) -> Result<(), UvError> {\n         execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_unlink(loop_.handle, req, path.with_ref(|p| p),\n+            uvll::uv_fs_unlink(loop_.handle, req, path.as_ptr(),\n                                cb)\n         })\n     }\n@@ -60,14 +60,14 @@ impl FsRequest {\n         -> Result<rtio::FileStat, UvError>\n     {\n         execute(|req, cb| unsafe {\n-            uvll::uv_fs_lstat(loop_.handle, req, path.with_ref(|p| p),\n+            uvll::uv_fs_lstat(loop_.handle, req, path.as_ptr(),\n                               cb)\n         }).map(|req| req.mkstat())\n     }\n \n     pub fn stat(loop_: &Loop, path: &CString) -> Result<rtio::FileStat, UvError> {\n         execute(|req, cb| unsafe {\n-            uvll::uv_fs_stat(loop_.handle, req, path.with_ref(|p| p),\n+            uvll::uv_fs_stat(loop_.handle, req, path.as_ptr(),\n                              cb)\n         }).map(|req| req.mkstat())\n     }\n@@ -125,14 +125,14 @@ impl FsRequest {\n         -> Result<(), UvError>\n     {\n         execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_mkdir(loop_.handle, req, path.with_ref(|p| p),\n+            uvll::uv_fs_mkdir(loop_.handle, req, path.as_ptr(),\n                               mode, cb)\n         })\n     }\n \n     pub fn rmdir(loop_: &Loop, path: &CString) -> Result<(), UvError> {\n         execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_rmdir(loop_.handle, req, path.with_ref(|p| p),\n+            uvll::uv_fs_rmdir(loop_.handle, req, path.as_ptr(),\n                               cb)\n         })\n     }\n@@ -143,8 +143,8 @@ impl FsRequest {\n         execute_nop(|req, cb| unsafe {\n             uvll::uv_fs_rename(loop_.handle,\n                                req,\n-                               path.with_ref(|p| p),\n-                               to.with_ref(|p| p),\n+                               path.as_ptr(),\n+                               to.as_ptr(),\n                                cb)\n         })\n     }\n@@ -153,7 +153,7 @@ impl FsRequest {\n         -> Result<(), UvError>\n     {\n         execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_chmod(loop_.handle, req, path.with_ref(|p| p),\n+            uvll::uv_fs_chmod(loop_.handle, req, path.as_ptr(),\n                               mode, cb)\n         })\n     }\n@@ -163,10 +163,10 @@ impl FsRequest {\n     {\n         execute(|req, cb| unsafe {\n             uvll::uv_fs_readdir(loop_.handle,\n-                                req, path.with_ref(|p| p), flags, cb)\n+                                req, path.as_ptr(), flags, cb)\n         }).map(|req| unsafe {\n             let mut paths = vec!();\n-            let path = CString::new(path.with_ref(|p| p), false);\n+            let path = CString::new(path.as_ptr(), false);\n             let parent = Path::new(path);\n             let _ = c_str::from_c_multistring(req.get_ptr() as *const libc::c_char,\n                                               Some(req.get_result() as uint),\n@@ -181,7 +181,7 @@ impl FsRequest {\n     pub fn readlink(loop_: &Loop, path: &CString) -> Result<CString, UvError> {\n         execute(|req, cb| unsafe {\n             uvll::uv_fs_readlink(loop_.handle, req,\n-                                 path.with_ref(|p| p), cb)\n+                                 path.as_ptr(), cb)\n         }).map(|req| {\n             // Be sure to clone the cstring so we get an independently owned\n             // allocation to work with and return.\n@@ -196,7 +196,7 @@ impl FsRequest {\n     {\n         execute_nop(|req, cb| unsafe {\n             uvll::uv_fs_chown(loop_.handle,\n-                              req, path.with_ref(|p| p),\n+                              req, path.as_ptr(),\n                               uid as uvll::uv_uid_t,\n                               gid as uvll::uv_gid_t,\n                               cb)\n@@ -216,8 +216,8 @@ impl FsRequest {\n     {\n         execute_nop(|req, cb| unsafe {\n             uvll::uv_fs_link(loop_.handle, req,\n-                             src.with_ref(|p| p),\n-                             dst.with_ref(|p| p),\n+                             src.as_ptr(),\n+                             dst.as_ptr(),\n                              cb)\n         })\n     }\n@@ -227,8 +227,8 @@ impl FsRequest {\n     {\n         execute_nop(|req, cb| unsafe {\n             uvll::uv_fs_symlink(loop_.handle, req,\n-                                src.with_ref(|p| p),\n-                                dst.with_ref(|p| p),\n+                                src.as_ptr(),\n+                                dst.as_ptr(),\n                                 0, cb)\n         })\n     }\n@@ -252,7 +252,7 @@ impl FsRequest {\n         let atime = atime as libc::c_double / 1000.0;\n         let mtime = mtime as libc::c_double / 1000.0;\n         execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_utime(loop_.handle, req, path.with_ref(|p| p),\n+            uvll::uv_fs_utime(loop_.handle, req, path.as_ptr(),\n                               atime, mtime, cb)\n         })\n     }"}, {"sha": "cff7e9d7738516f3a07964b2098d322ce3157247", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=b569c77148e8e839b38b678c7c167efc643d2721", "patch": "@@ -94,7 +94,7 @@ impl PipeWatcher {\n         cx.connect(pipe, timeout, io, |req, pipe, cb| {\n             unsafe {\n                 uvll::uv_pipe_connect(req.handle, pipe.handle(),\n-                                      name.with_ref(|p| p), cb)\n+                                      name.as_ptr(), cb)\n             }\n             0\n         })\n@@ -227,7 +227,7 @@ impl PipeListener {\n     {\n         let pipe = PipeWatcher::new(io, false);\n         match unsafe {\n-            uvll::uv_pipe_bind(pipe.handle(), name.with_ref(|p| p))\n+            uvll::uv_pipe_bind(pipe.handle(), name.as_ptr())\n         } {\n             0 => {\n                 // If successful, unwrap the PipeWatcher because we control how"}, {"sha": "61325d0ce948eb5bb6926ec4bcee141f30af0f7a", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b569c77148e8e839b38b678c7c167efc643d2721/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=b569c77148e8e839b38b678c7c167efc643d2721", "patch": "@@ -85,7 +85,7 @@ impl Process {\n                     args: argv,\n                     env: envp,\n                     cwd: match cfg.cwd {\n-                        Some(cwd) => cwd.with_ref(|p| p),\n+                        Some(cwd) => cwd.as_ptr(),\n                         None => ptr::null(),\n                     },\n                     flags: flags as libc::c_uint,\n@@ -183,8 +183,8 @@ fn with_argv<T>(prog: &CString, args: &[CString],\n     // larger than the lifetime of our invocation of cb, but this is\n     // technically unsafe as the callback could leak these pointers\n     // out of our scope.\n-    ptrs.push(prog.with_ref(|buf| buf));\n-    ptrs.extend(args.iter().map(|tmp| tmp.with_ref(|buf| buf)));\n+    ptrs.push(prog.as_ptr());\n+    ptrs.extend(args.iter().map(|tmp| tmp.as_ptr()));\n \n     // Add a terminating null pointer (required by libc).\n     ptrs.push(ptr::null());"}, {"sha": "6790e237e26340a9212cd04a5f43dce5a35db580", "filename": "src/test/run-pass/const-str-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b569c77148e8e839b38b678c7c167efc643d2721/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b569c77148e8e839b38b678c7c167efc643d2721/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs?ref=b569c77148e8e839b38b678c7c167efc643d2721", "patch": "@@ -24,6 +24,6 @@ pub fn main() {\n         assert!(*(&B[0] as *const u8) == A[0]);\n \n         let bar = str::raw::from_utf8(A).to_c_str();\n-        assert_eq!(bar.with_ref(|buf| str::raw::from_c_str(buf)), \"hi\".to_string());\n+        assert_eq!(str::raw::from_c_str(bar.as_ptr()), \"hi\".to_string());\n     }\n }"}]}