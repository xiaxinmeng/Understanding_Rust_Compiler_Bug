{"sha": "360c3cf55818353ef87292180459e7a99b88d574", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2MGMzY2Y1NTgxODM1M2VmODcyOTIxODA0NTllN2E5OWI4OGQ1NzQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-31T00:26:06Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-31T00:26:06Z"}, "message": "rollup merge of #20316: seanmonstar/patch-1\n\nAdds back Send and Sync to BTreeMap and Set.", "tree": {"sha": "0837cf2662d63ffd8271e5f59ca0fecc3a4b1b97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0837cf2662d63ffd8271e5f59ca0fecc3a4b1b97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/360c3cf55818353ef87292180459e7a99b88d574", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/360c3cf55818353ef87292180459e7a99b88d574", "html_url": "https://github.com/rust-lang/rust/commit/360c3cf55818353ef87292180459e7a99b88d574", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/360c3cf55818353ef87292180459e7a99b88d574/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b936fb3d1643711b7bd041b7aca4d203ebb3cc7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b936fb3d1643711b7bd041b7aca4d203ebb3cc7a", "html_url": "https://github.com/rust-lang/rust/commit/b936fb3d1643711b7bd041b7aca4d203ebb3cc7a"}, {"sha": "f4ad02ffb51b6edf8b76bf27511bb1cac7e7256c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4ad02ffb51b6edf8b76bf27511bb1cac7e7256c", "html_url": "https://github.com/rust-lang/rust/commit/f4ad02ffb51b6edf8b76bf27511bb1cac7e7256c"}], "stats": {"total": 31, "additions": 16, "deletions": 15}, "files": [{"sha": "1e4d3237501fe79ea990c4e26588cc50b6235c34", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/360c3cf55818353ef87292180459e7a99b88d574/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/360c3cf55818353ef87292180459e7a99b88d574/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=360c3cf55818353ef87292180459e7a99b88d574", "patch": "@@ -21,6 +21,7 @@ use core::prelude::*;\n use core::{slice, mem, ptr, cmp, num, raw};\n use core::iter::Zip;\n use core::borrow::BorrowFrom;\n+use core::ptr::Unique;\n use alloc::heap;\n \n /// Represents the result of an Insertion: either the item fit, or the node had to split\n@@ -51,11 +52,11 @@ pub struct Node<K, V> {\n     // These will never be null during normal usage of a `Node`. However, to avoid the need for a\n     // drop flag, `Node::drop` zeroes `keys`, signaling that the `Node` has already been cleaned\n     // up.\n-    keys: *mut K,\n-    vals: *mut V,\n+    keys: Unique<K>,\n+    vals: Unique<V>,\n \n     // In leaf nodes, this will be null, and no space will be allocated for edges.\n-    edges: *mut Node<K, V>,\n+    edges: Unique<Node<K, V>>,\n \n     // At any given time, there will be `_len` keys, `_len` values, and (in an internal node)\n     // `_len + 1` edges. In a leaf node, there will never be any edges.\n@@ -255,7 +256,7 @@ impl<T> Drop for RawItems<T> {\n #[unsafe_destructor]\n impl<K, V> Drop for Node<K, V> {\n     fn drop(&mut self) {\n-        if self.keys.is_null() {\n+        if self.keys.0.is_null() {\n             // We have already cleaned up this node.\n             return;\n         }\n@@ -269,7 +270,7 @@ impl<K, V> Drop for Node<K, V> {\n             self.destroy();\n         }\n \n-        self.keys = ptr::null_mut();\n+        self.keys.0 = ptr::null_mut();\n     }\n }\n \n@@ -285,9 +286,9 @@ impl<K, V> Node<K, V> {\n         let (vals_offset, edges_offset) = calculate_offsets_generic::<K, V>(capacity, false);\n \n         Node {\n-            keys: buffer as *mut K,\n-            vals: buffer.offset(vals_offset as int) as *mut V,\n-            edges: buffer.offset(edges_offset as int) as *mut Node<K, V>,\n+            keys: Unique(buffer as *mut K),\n+            vals: Unique(buffer.offset(vals_offset as int) as *mut V),\n+            edges: Unique(buffer.offset(edges_offset as int) as *mut Node<K, V>),\n             _len: 0,\n             _capacity: capacity,\n         }\n@@ -303,9 +304,9 @@ impl<K, V> Node<K, V> {\n         let (vals_offset, _) = calculate_offsets_generic::<K, V>(capacity, true);\n \n         Node {\n-            keys: buffer as *mut K,\n-            vals: unsafe { buffer.offset(vals_offset as int) as *mut V },\n-            edges: ptr::null_mut(),\n+            keys: Unique(buffer as *mut K).\n+            vals: Unique(unsafe { buffer.offset(vals_offset as int) as *mut V }),\n+            edges: Unique(ptr::null_mut::<u8>()),\n             _len: 0,\n             _capacity: capacity,\n         }\n@@ -314,18 +315,18 @@ impl<K, V> Node<K, V> {\n     unsafe fn destroy(&mut self) {\n         let (alignment, size) =\n                 calculate_allocation_generic::<K, V>(self.capacity(), self.is_leaf());\n-        heap::deallocate(self.keys as *mut u8, size, alignment);\n+        heap::deallocate(self.keys.0 as *mut u8, size, alignment);\n     }\n \n     #[inline]\n     pub fn as_slices<'a>(&'a self) -> (&'a [K], &'a [V]) {\n         unsafe {(\n             mem::transmute(raw::Slice {\n-                data: self.keys as *const K,\n+                data: self.keys.0 as *const K,\n                 len: self.len()\n             }),\n             mem::transmute(raw::Slice {\n-                data: self.vals as *const V,\n+                data: self.vals.0 as *const V,\n                 len: self.len()\n             })\n         )}\n@@ -344,7 +345,7 @@ impl<K, V> Node<K, V> {\n         } else {\n             unsafe {\n                 mem::transmute(raw::Slice {\n-                    data: self.edges as *const Node<K, V>,\n+                    data: self.edges.0 as *const Node<K, V>,\n                     len: self.len() + 1\n                 })\n             }"}]}