{"sha": "44c10e4cb0835f34b2ac85188f0ad44fab14446b", "node_id": "C_kwDOAAsO6NoAKDQ0YzEwZTRjYjA4MzVmMzRiMmFjODUxODhmMGFkNDRmYWIxNDQ0NmI", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-25T15:08:20Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-11-11T10:11:50Z"}, "message": "Resolve lifetimes independently for each item-like.", "tree": {"sha": "7a87ec48d127819e8fbe6feb8e048b9720d0a993", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a87ec48d127819e8fbe6feb8e048b9720d0a993"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44c10e4cb0835f34b2ac85188f0ad44fab14446b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44c10e4cb0835f34b2ac85188f0ad44fab14446b", "html_url": "https://github.com/rust-lang/rust/commit/44c10e4cb0835f34b2ac85188f0ad44fab14446b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44c10e4cb0835f34b2ac85188f0ad44fab14446b/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ff1d1e122766d44292d22245c05e53d9b324f8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ff1d1e122766d44292d22245c05e53d9b324f8e", "html_url": "https://github.com/rust-lang/rust/commit/0ff1d1e122766d44292d22245c05e53d9b324f8e"}], "stats": {"total": 254, "additions": 67, "deletions": 187}, "files": [{"sha": "1fec8f027bd36fe304bb08d2921777b994c8ee90", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 66, "deletions": 177, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/44c10e4cb0835f34b2ac85188f0ad44fab14446b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44c10e4cb0835f34b2ac85188f0ad44fab14446b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=44c10e4cb0835f34b2ac85188f0ad44fab14446b", "patch": "@@ -94,11 +94,6 @@ struct LifetimeContext<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n-\n-    /// Indicates that we only care about the definition of a trait. This should\n-    /// be false if the `Item` we are resolving lifetimes for is not a trait or\n-    /// we eventually need lifetimes resolve for trait items.\n-    trait_definition_only: bool,\n }\n \n #[derive(Debug)]\n@@ -166,7 +161,9 @@ enum Scope<'a> {\n         s: ScopeRef<'a>,\n     },\n \n-    Root,\n+    Root {\n+        opt_parent_item: Option<LocalDefId>,\n+    },\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -214,95 +211,58 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"s\", &\"..\")\n                 .finish(),\n             Scope::TraitRefBoundary { s: _ } => f.debug_struct(\"TraitRefBoundary\").finish(),\n-            Scope::Root => f.debug_struct(\"Root\").finish(),\n+            Scope::Root { opt_parent_item } => {\n+                f.debug_struct(\"Root\").field(\"opt_parent_item\", &opt_parent_item).finish()\n+            }\n         }\n     }\n }\n \n type ScopeRef<'a> = &'a Scope<'a>;\n \n-const ROOT_SCOPE: ScopeRef<'static> = &Scope::Root;\n-\n pub(crate) fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n-        resolve_lifetimes_trait_definition,\n         resolve_lifetimes,\n \n-        named_region_map: |tcx, id| resolve_lifetimes_for(tcx, id).defs.get(&id),\n+        named_region_map: |tcx, id| tcx.resolve_lifetimes(id).defs.get(&id),\n         is_late_bound_map,\n         object_lifetime_default,\n-        late_bound_vars_map: |tcx, id| resolve_lifetimes_for(tcx, id).late_bound_vars.get(&id),\n+        late_bound_vars_map: |tcx, id| tcx.resolve_lifetimes(id).late_bound_vars.get(&id),\n \n         ..*providers\n     };\n }\n \n-/// Like `resolve_lifetimes`, but does not resolve lifetimes for trait items.\n-/// Also does not generate any diagnostics.\n-///\n-/// This is ultimately a subset of the `resolve_lifetimes` work. It effectively\n-/// resolves lifetimes only within the trait \"header\" -- that is, the trait\n-/// and supertrait list. In contrast, `resolve_lifetimes` resolves all the\n-/// lifetimes within the trait and its items. There is room to refactor this,\n-/// for example to resolve lifetimes for each trait item in separate queries,\n-/// but it's convenient to do the entire trait at once because the lifetimes\n-/// from the trait definition are in scope within the trait items as well.\n-///\n-/// The reason for this separate call is to resolve what would otherwise\n-/// be a cycle. Consider this example:\n-///\n-/// ```ignore UNSOLVED (maybe @jackh726 knows what lifetime parameter to give Sub)\n-/// trait Base<'a> {\n-///     type BaseItem;\n-/// }\n-/// trait Sub<'b>: for<'a> Base<'a> {\n-///    type SubItem: Sub<BaseItem = &'b u32>;\n-/// }\n-/// ```\n-///\n-/// When we resolve `Sub` and all its items, we also have to resolve `Sub<BaseItem = &'b u32>`.\n-/// To figure out the index of `'b`, we have to know about the supertraits\n-/// of `Sub` so that we can determine that the `for<'a>` will be in scope.\n-/// (This is because we -- currently at least -- flatten all the late-bound\n-/// lifetimes into a single binder.) This requires us to resolve the\n-/// *trait definition* of `Sub`; basically just enough lifetime information\n-/// to look at the supertraits.\n-#[instrument(level = \"debug\", skip(tcx))]\n-fn resolve_lifetimes_trait_definition(\n-    tcx: TyCtxt<'_>,\n-    local_def_id: LocalDefId,\n-) -> ResolveLifetimes {\n-    convert_named_region_map(do_resolve(tcx, local_def_id, true))\n-}\n-\n /// Computes the `ResolveLifetimes` map that contains data for an entire `Item`.\n /// You should not read the result of this query directly, but rather use\n /// `named_region_map`, `is_late_bound_map`, etc.\n #[instrument(level = \"debug\", skip(tcx))]\n-fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> ResolveLifetimes {\n-    convert_named_region_map(do_resolve(tcx, local_def_id, false))\n-}\n-\n-fn do_resolve(\n-    tcx: TyCtxt<'_>,\n-    local_def_id: LocalDefId,\n-    trait_definition_only: bool,\n-) -> NamedRegionMap {\n-    let item = tcx.hir().expect_item(local_def_id);\n+fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveLifetimes {\n     let mut named_region_map =\n         NamedRegionMap { defs: Default::default(), late_bound_vars: Default::default() };\n     let mut visitor = LifetimeContext {\n         tcx,\n         map: &mut named_region_map,\n-        scope: ROOT_SCOPE,\n-        trait_definition_only,\n+        scope: &Scope::Root { opt_parent_item: None },\n     };\n-    visitor.visit_item(item);\n-\n-    named_region_map\n-}\n+    match tcx.hir().owner(local_def_id) {\n+        hir::OwnerNode::Item(item) => visitor.visit_item(item),\n+        hir::OwnerNode::ForeignItem(item) => visitor.visit_foreign_item(item),\n+        hir::OwnerNode::TraitItem(item) => {\n+            let scope =\n+                Scope::Root { opt_parent_item: Some(tcx.local_parent(item.owner_id.def_id)) };\n+            visitor.scope = &scope;\n+            visitor.visit_trait_item(item)\n+        }\n+        hir::OwnerNode::ImplItem(item) => {\n+            let scope =\n+                Scope::Root { opt_parent_item: Some(tcx.local_parent(item.owner_id.def_id)) };\n+            visitor.scope = &scope;\n+            visitor.visit_impl_item(item)\n+        }\n+        hir::OwnerNode::Crate(_) => {}\n+    }\n \n-fn convert_named_region_map(named_region_map: NamedRegionMap) -> ResolveLifetimes {\n     let mut rl = ResolveLifetimes::default();\n \n     for (hir_id, v) in named_region_map.defs {\n@@ -319,53 +279,6 @@ fn convert_named_region_map(named_region_map: NamedRegionMap) -> ResolveLifetime\n     rl\n }\n \n-/// Given `any` owner (structs, traits, trait methods, etc.), does lifetime resolution.\n-/// There are two important things this does.\n-/// First, we have to resolve lifetimes for\n-/// the entire *`Item`* that contains this owner, because that's the largest \"scope\"\n-/// where we can have relevant lifetimes.\n-/// Second, if we are asking for lifetimes in a trait *definition*, we use `resolve_lifetimes_trait_definition`\n-/// instead of `resolve_lifetimes`, which does not descend into the trait items and does not emit diagnostics.\n-/// This allows us to avoid cycles. Importantly, if we ask for lifetimes for lifetimes that have an owner\n-/// other than the trait itself (like the trait methods or associated types), then we just use the regular\n-/// `resolve_lifetimes`.\n-fn resolve_lifetimes_for<'tcx>(tcx: TyCtxt<'tcx>, def_id: hir::OwnerId) -> &'tcx ResolveLifetimes {\n-    let item_id = item_for(tcx, def_id.def_id);\n-    let local_def_id = item_id.owner_id.def_id;\n-    if item_id.owner_id == def_id {\n-        let item = tcx.hir().item(item_id);\n-        match item.kind {\n-            hir::ItemKind::Trait(..) => tcx.resolve_lifetimes_trait_definition(local_def_id),\n-            _ => tcx.resolve_lifetimes(local_def_id),\n-        }\n-    } else {\n-        tcx.resolve_lifetimes(local_def_id)\n-    }\n-}\n-\n-/// Finds the `Item` that contains the given `LocalDefId`\n-fn item_for(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> hir::ItemId {\n-    match tcx.hir().find_by_def_id(local_def_id) {\n-        Some(Node::Item(item)) => {\n-            return item.item_id();\n-        }\n-        _ => {}\n-    }\n-    let item = {\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(local_def_id);\n-        let mut parent_iter = tcx.hir().parent_iter(hir_id);\n-        loop {\n-            let node = parent_iter.next().map(|n| n.1);\n-            match node {\n-                Some(hir::Node::Item(item)) => break item.item_id(),\n-                Some(hir::Node::Crate(_)) | None => bug!(\"Called `item_for` on an Item.\"),\n-                _ => {}\n-            }\n-        }\n-    };\n-    item\n-}\n-\n fn late_region_as_bound_region<'tcx>(tcx: TyCtxt<'tcx>, region: &Region) -> ty::BoundVariableKind {\n     match region {\n         Region::LateBound(_, _, def_id) => {\n@@ -383,7 +296,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut supertrait_lifetimes = vec![];\n         loop {\n             match scope {\n-                Scope::Body { .. } | Scope::Root => {\n+                Scope::Body { .. } | Scope::Root { .. } => {\n                     break (vec![], BinderScopeType::Normal);\n                 }\n \n@@ -414,21 +327,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n }\n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n-    type NestedFilter = nested_filter::All;\n+    type NestedFilter = nested_filter::OnlyBodies;\n \n     fn nested_visit_map(&mut self) -> Self::Map {\n         self.tcx.hir()\n     }\n \n-    // We want to nest trait/impl items in their parent, but nothing else.\n-    fn visit_nested_item(&mut self, _: hir::ItemId) {}\n-\n-    fn visit_trait_item_ref(&mut self, ii: &'tcx hir::TraitItemRef) {\n-        if !self.trait_definition_only {\n-            intravisit::walk_trait_item_ref(self, ii)\n-        }\n-    }\n-\n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         let body = self.tcx.hir().body(body);\n         self.with(Scope::Body { id: body.id(), s: self.scope }, |this| {\n@@ -557,33 +461,21 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // their owner, we can keep going until we find the Item that owns that. We then\n                 // conservatively add all resolved lifetimes. Otherwise we run into problems in\n                 // cases like `type Foo<'a> = impl Bar<As = impl Baz + 'a>`.\n-                for (_hir_id, node) in self.tcx.hir().parent_iter(item.owner_id.into()) {\n-                    match node {\n-                        hir::Node::Item(parent_item) => {\n-                            let resolved_lifetimes: &ResolveLifetimes = self.tcx.resolve_lifetimes(\n-                                item_for(self.tcx, parent_item.owner_id.def_id).owner_id.def_id,\n-                            );\n-                            // We need to add *all* deps, since opaque tys may want them from *us*\n-                            for (&owner, defs) in resolved_lifetimes.defs.iter() {\n-                                defs.iter().for_each(|(&local_id, region)| {\n-                                    self.map.defs.insert(hir::HirId { owner, local_id }, *region);\n-                                });\n-                            }\n-                            for (&owner, late_bound_vars) in\n-                                resolved_lifetimes.late_bound_vars.iter()\n-                            {\n-                                late_bound_vars.iter().for_each(|(&local_id, late_bound_vars)| {\n-                                    self.record_late_bound_vars(\n-                                        hir::HirId { owner, local_id },\n-                                        late_bound_vars.clone(),\n-                                    );\n-                                });\n-                            }\n-                            break;\n-                        }\n-                        hir::Node::Crate(_) => bug!(\"No Item about an OpaqueTy\"),\n-                        _ => {}\n-                    }\n+                let parent_item = self.tcx.hir().get_parent_item(item.hir_id());\n+                let resolved_lifetimes: &ResolveLifetimes = self.tcx.resolve_lifetimes(parent_item);\n+                // We need to add *all* deps, since opaque tys may want them from *us*\n+                for (&owner, defs) in resolved_lifetimes.defs.iter() {\n+                    defs.iter().for_each(|(&local_id, region)| {\n+                        self.map.defs.insert(hir::HirId { owner, local_id }, *region);\n+                    });\n+                }\n+                for (&owner, late_bound_vars) in resolved_lifetimes.late_bound_vars.iter() {\n+                    late_bound_vars.iter().for_each(|(&local_id, late_bound_vars)| {\n+                        self.record_late_bound_vars(\n+                            hir::HirId { owner, local_id },\n+                            late_bound_vars.clone(),\n+                        );\n+                    });\n                 }\n             }\n             hir::ItemKind::TyAlias(_, ref generics)\n@@ -609,7 +501,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     hir_id: item.hir_id(),\n                     lifetimes,\n                     scope_type: BinderScopeType::Normal,\n-                    s: ROOT_SCOPE,\n+                    s: self.scope,\n                     where_bound_origin: None,\n                 };\n                 self.with(scope, |this| {\n@@ -766,30 +658,26 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     // Ensure that the parent of the def is an item, not HRTB\n                     let parent_id = self.tcx.hir().get_parent_node(hir_id);\n                     if !parent_id.is_owner() {\n-                        if !self.trait_definition_only {\n-                            struct_span_err!(\n-                                self.tcx.sess,\n-                                lifetime.span,\n-                                E0657,\n-                                \"`impl Trait` can only capture lifetimes \\\n+                        struct_span_err!(\n+                            self.tcx.sess,\n+                            lifetime.span,\n+                            E0657,\n+                            \"`impl Trait` can only capture lifetimes \\\n                                     bound at the fn or impl level\"\n-                            )\n-                            .emit();\n-                        }\n+                        )\n+                        .emit();\n                         self.uninsert_lifetime_on_error(lifetime, def.unwrap());\n                     }\n                     if let hir::Node::Item(hir::Item {\n                         kind: hir::ItemKind::OpaqueTy { .. }, ..\n                     }) = self.tcx.hir().get(parent_id)\n                     {\n-                        if !self.trait_definition_only {\n-                            let mut err = self.tcx.sess.struct_span_err(\n+                        let mut err = self.tcx.sess.struct_span_err(\n                                 lifetime.span,\n                                 \"higher kinded lifetime bounds on nested opaque types are not supported yet\",\n                             );\n-                            err.span_note(self.tcx.def_span(def_id), \"lifetime declared here\");\n-                            err.emit();\n-                        }\n+                        err.span_note(self.tcx.def_span(def_id), \"lifetime declared here\");\n+                        err.emit();\n                         self.uninsert_lifetime_on_error(lifetime, def.unwrap());\n                     }\n                 }\n@@ -1193,12 +1081,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         F: for<'b> FnOnce(&mut LifetimeContext<'b, 'tcx>),\n     {\n         let LifetimeContext { tcx, map, .. } = self;\n-        let mut this = LifetimeContext {\n-            tcx: *tcx,\n-            map,\n-            scope: &wrap_scope,\n-            trait_definition_only: self.trait_definition_only,\n-        };\n+        let mut this = LifetimeContext { tcx: *tcx, map, scope: &wrap_scope };\n         let span = debug_span!(\"scope\", scope = ?TruncatedScopeDebug(&this.scope));\n         {\n             let _enter = span.enter();\n@@ -1303,7 +1186,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope = s;\n                 }\n \n-                Scope::Root => {\n+                Scope::Root { opt_parent_item } => {\n+                    if let Some(parent_item) = opt_parent_item\n+                        && let parent_generics = self.tcx.generics_of(parent_item)\n+                        && parent_generics.param_def_id_to_index.contains_key(&region_def_id.to_def_id())\n+                    {\n+                        break Some(Region::EarlyBound(region_def_id.to_def_id()));\n+                    }\n                     break None;\n                 }\n \n@@ -1417,7 +1306,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     err.emit();\n                     return;\n                 }\n-                Scope::Root => break,\n+                Scope::Root { .. } => break,\n                 Scope::Binder { s, .. }\n                 | Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n@@ -1495,7 +1384,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 let mut scope = self.scope;\n                 loop {\n                     match *scope {\n-                        Scope::Root => break false,\n+                        Scope::Root { .. } => break false,\n \n                         Scope::Body { .. } => break true,\n \n@@ -1732,7 +1621,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope = s;\n                 }\n \n-                Scope::Root | Scope::Elision { .. } => break Region::Static,\n+                Scope::Root { .. } | Scope::Elision { .. } => break Region::Static,\n \n                 Scope::Body { .. } | Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n "}, {"sha": "1564cf414bd251bda3ccd4f26b815986b8aa8141", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/44c10e4cb0835f34b2ac85188f0ad44fab14446b/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44c10e4cb0835f34b2ac85188f0ad44fab14446b/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=44c10e4cb0835f34b2ac85188f0ad44fab14446b", "patch": "@@ -1614,19 +1614,10 @@ rustc_queries! {\n         desc { |tcx| \"getting the native library for `{}`\", tcx.def_path_str(def_id) }\n     }\n \n-    /// Does lifetime resolution, but does not descend into trait items. This\n-    /// should only be used for resolving lifetimes of on trait definitions,\n-    /// and is used to avoid cycles. Importantly, `resolve_lifetimes` still visits\n-    /// the same lifetimes and is responsible for diagnostics.\n-    /// See `rustc_resolve::late::lifetimes for details.\n-    query resolve_lifetimes_trait_definition(_: LocalDefId) -> ResolveLifetimes {\n-        arena_cache\n-        desc { \"resolving lifetimes for a trait definition\" }\n-    }\n     /// Does lifetime resolution on items. Importantly, we can't resolve\n     /// lifetimes directly on things like trait methods, because of trait params.\n     /// See `rustc_resolve::late::lifetimes for details.\n-    query resolve_lifetimes(_: LocalDefId) -> ResolveLifetimes {\n+    query resolve_lifetimes(_: hir::OwnerId) -> ResolveLifetimes {\n         arena_cache\n         desc { \"resolving lifetimes\" }\n     }"}]}