{"sha": "c27ec6908793e3b1706d683dc2c2d367ac8fc061", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyN2VjNjkwODc5M2UzYjE3MDZkNjgzZGMyYzJkMzY3YWM4ZmMwNjE=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-02-08T14:55:05Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-02-08T15:03:21Z"}, "message": "Remove rust-analyzer.el\n\nThe support has been moved to emacs-lsp.", "tree": {"sha": "aed0b7bd4c6fccc34240cb796bb32d9d4ae87b23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aed0b7bd4c6fccc34240cb796bb32d9d4ae87b23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c27ec6908793e3b1706d683dc2c2d367ac8fc061", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c27ec6908793e3b1706d683dc2c2d367ac8fc061", "html_url": "https://github.com/rust-lang/rust/commit/c27ec6908793e3b1706d683dc2c2d367ac8fc061", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c27ec6908793e3b1706d683dc2c2d367ac8fc061/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5397f05bfe7f3b18229a65040c6685e762b2f9a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5397f05bfe7f3b18229a65040c6685e762b2f9a3", "html_url": "https://github.com/rust-lang/rust/commit/5397f05bfe7f3b18229a65040c6685e762b2f9a3"}], "stats": {"total": 295, "additions": 0, "deletions": 295}, "files": [{"sha": "9b426fcae92741ce216160a0fe6619b0de054e59", "filename": "editors/emacs/rust-analyzer.el", "status": "removed", "additions": 0, "deletions": 295, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/5397f05bfe7f3b18229a65040c6685e762b2f9a3/editors%2Femacs%2Frust-analyzer.el", "raw_url": "https://github.com/rust-lang/rust/raw/5397f05bfe7f3b18229a65040c6685e762b2f9a3/editors%2Femacs%2Frust-analyzer.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Femacs%2Frust-analyzer.el?ref=5397f05bfe7f3b18229a65040c6685e762b2f9a3", "patch": "@@ -1,295 +0,0 @@\n-;;; rust-analyzer.el --- Rust analyzer emacs bindings for emacs-lsp -*- lexical-binding: t; -*-\n-;;; Code:\n-\n-(require 'lsp)\n-(require 'dash)\n-(require 'ht)\n-\n-;; This currently\n-;;  - sets up rust-analyzer with emacs-lsp, giving\n-;;    - code actions\n-;;    - completion (use company-lsp for proper snippet support)\n-;;    - imenu support\n-;;    - on-type formatting\n-;;    - 'hover' type information & documentation (with lsp-ui)\n-;;  - implements source changes (for code actions etc.), except for file system changes\n-;;  - implements joinLines (you need to bind rust-analyzer-join-lines to a key)\n-;;  - implements selectionRanges (either bind lsp-extend-selection to a key, or use expand-region)\n-;;  - provides rust-analyzer-inlay-hints-mode for inline type hints\n-;;  - provides rust-analyzer-expand-macro to expand macros\n-\n-;; What's missing:\n-;;  - file system changes in apply-source-change\n-;;  - semantic highlighting\n-;;  - onEnter, parentModule, findMatchingBrace\n-;;  - runnables\n-;;  - the debugging commands (syntaxTree and analyzerStatus)\n-;;  - more\n-\n-;; Also, there's a problem with company-lsp's caching being too eager, sometimes\n-;; resulting in outdated completions.\n-\n-(defcustom rust-analyzer-command '(\"ra_lsp_server\")\n-  \"\"\n-  :type '(repeat (string)))\n-\n-(defconst rust-analyzer--notification-handlers\n-  '((\"rust-analyzer/publishDecorations\" . (lambda (_w _p)))))\n-\n-(defconst rust-analyzer--action-handlers\n-  '((\"rust-analyzer.applySourceChange\" .\n-     (lambda (p) (rust-analyzer--apply-source-change-command p)))\n-    (\"rust-analyzer.selectAndApplySourceChange\" .\n-     (lambda (p) (rust-analyzer--select-and-apply-source-change-command p)))))\n-\n-(defun rust-analyzer--uri-filename (text-document)\n-  (lsp--uri-to-path (gethash \"uri\" text-document)))\n-\n-(defun rust-analyzer--goto-lsp-loc (loc)\n-  (-let (((&hash \"line\" \"character\") loc))\n-    (goto-line (1+ line))\n-    (move-to-column character)))\n-\n-(defun rust-analyzer--apply-text-document-edit (edit)\n-  \"Like lsp--apply-text-document-edit, but it allows nil version.\"\n-  (let* ((ident (gethash \"textDocument\" edit))\n-         (filename (rust-analyzer--uri-filename ident))\n-         (version (gethash \"version\" ident)))\n-    (with-current-buffer (find-file-noselect filename)\n-      (when (or (not version) (= version (lsp--cur-file-version)))\n-        (lsp--apply-text-edits (gethash \"edits\" edit))))))\n-\n-(defun rust-analyzer--apply-source-change (data)\n-  ;; TODO fileSystemEdits\n-  (seq-doseq (it (-> data (ht-get \"workspaceEdit\") (ht-get \"documentChanges\")))\n-    (rust-analyzer--apply-text-document-edit it))\n-  (-when-let (cursor-position (ht-get data \"cursorPosition\"))\n-    (let ((filename (rust-analyzer--uri-filename (ht-get cursor-position \"textDocument\")))\n-          (position (ht-get cursor-position \"position\")))\n-      (find-file filename)\n-      (rust-analyzer--goto-lsp-loc position))))\n-\n-(defun rust-analyzer--apply-source-change-command (p)\n-  (let ((data (-> p (ht-get \"arguments\") (lsp-seq-first))))\n-    (rust-analyzer--apply-source-change data)))\n-\n-(defun rust-analyzer--select-and-apply-source-change-command (p)\n-  (let* ((options (-> p (ht-get \"arguments\") (lsp-seq-first)))\n-         (chosen-option (lsp--completing-read \"Select option:\" options\n-                                              (-lambda ((&hash \"label\")) label))))\n-    (rust-analyzer--apply-source-change chosen-option)))\n-\n-(lsp-register-client\n- (make-lsp-client\n-  :new-connection (lsp-stdio-connection (lambda () rust-analyzer-command))\n-  :notification-handlers (ht<-alist rust-analyzer--notification-handlers)\n-  :action-handlers (ht<-alist rust-analyzer--action-handlers)\n-  :major-modes '(rust-mode)\n-  :ignore-messages nil\n-  :server-id 'rust-analyzer))\n-\n-(defun rust-analyzer--initialized? ()\n-  (when-let ((workspace (lsp-find-workspace 'rust-analyzer (buffer-file-name))))\n-    (eq 'initialized (lsp--workspace-status workspace))))\n-\n-(with-eval-after-load 'company-lsp\n-  ;; company-lsp provides a snippet handler for rust by default that adds () after function calls, which RA does better\n-  (setq company-lsp--snippet-functions (cl-delete \"rust\" company-lsp--snippet-functions :key #'car :test #'equal)))\n-\n-;; join lines\n-\n-(defun rust-analyzer--join-lines-params ()\n-  \"Join lines params.\"\n-  (list :textDocument (lsp--text-document-identifier)\n-        :range (if (use-region-p)\n-                   (lsp--region-to-range (region-beginning) (region-end))\n-                 (lsp--region-to-range (point) (point)))))\n-\n-(defun rust-analyzer-join-lines ()\n-  (interactive)\n-  (->\n-   (lsp-send-request (lsp-make-request \"rust-analyzer/joinLines\"\n-                                       (rust-analyzer--join-lines-params)))\n-   (rust-analyzer--apply-source-change)))\n-\n-;; selection ranges\n-\n-(defun rust-analyzer--add-er-expansion ()\n-  (make-variable-buffer-local 'er/try-expand-list)\n-  (setq er/try-expand-list (append\n-                            er/try-expand-list\n-                            '(lsp-extend-selection))))\n-\n-(with-eval-after-load 'expand-region\n-  ;; add the expansion for all existing rust-mode buffers. If expand-region is\n-  ;; loaded lazily, it might be loaded when the first rust buffer is opened, and\n-  ;; then it's too late for the hook for that buffer\n-  (dolist (buf (buffer-list))\n-    (with-current-buffer buf\n-      (when (eq 'rust-mode major-mode)\n-        (rust-analyzer--add-er-expansion))))\n-  (add-hook 'rust-mode-hook 'rust-analyzer--add-er-expansion))\n-\n-;; runnables\n-(defvar rust-analyzer--last-runnable nil)\n-\n-(defun rust-analyzer--runnables-params ()\n-  (list :textDocument (lsp--text-document-identifier)\n-        :position (lsp--cur-position)))\n-\n-(defun rust-analyzer--runnables ()\n-  (lsp-send-request (lsp-make-request \"rust-analyzer/runnables\"\n-                                      (rust-analyzer--runnables-params))))\n-\n-(defun rust-analyzer--select-runnable ()\n-  (lsp--completing-read\n-   \"Select runnable:\"\n-   (if rust-analyzer--last-runnable\n-       (cons rust-analyzer--last-runnable (rust-analyzer--runnables))\n-       (rust-analyzer--runnables))\n-   (-lambda ((&hash \"label\")) label)))\n-\n-(defun rust-analyzer-run (runnable)\n-  (interactive (list (rust-analyzer--select-runnable)))\n-  (-let* (((&hash \"env\" \"bin\" \"args\" \"label\") runnable)\n-          (compilation-environment (-map (-lambda ((k v)) (concat k \"=\" v)) (ht-items env))))\n-    (compilation-start\n-     (string-join (append (list bin) args '()) \" \")\n-     ;; cargo-process-mode is nice, but try to work without it...\n-     (if (functionp 'cargo-process-mode) 'cargo-process-mode nil)\n-     (lambda (_) (concat \"*\" label \"*\")))\n-    (setq rust-analyzer--last-runnable runnable)))\n-\n-(defun rust-analyzer-rerun (&optional runnable)\n-  (interactive (list (or rust-analyzer--last-runnable\n-                         (rust-analyzer--select-runnable))))\n-  (rust-analyzer-run (or runnable rust-analyzer--last-runnable)))\n-\n-;; analyzer status buffer\n-(define-derived-mode rust-analyzer-status-mode special-mode \"Rust-Analyzer-Status\"\n-  \"Mode for the rust-analyzer status buffer.\")\n-\n-(defvar-local rust-analyzer--status-buffer-workspace nil)\n-\n-(defun rust-analyzer-status ()\n-  \"Displays status information for rust-analyzer.\"\n-  (interactive)\n-  (let* ((workspace (lsp-find-workspace 'rust-analyzer (buffer-file-name)))\n-         (buf (get-buffer-create (concat \"*rust-analyzer status \" (with-lsp-workspace workspace (lsp-workspace-root)) \"*\"))))\n-    (with-current-buffer buf\n-      (rust-analyzer-status-mode)\n-      (setq rust-analyzer--status-buffer-workspace workspace)\n-      (rust-analyzer-status-buffer-refresh))\n-    (pop-to-buffer buf)))\n-\n-(defun rust-analyzer-status-buffer-refresh ()\n-  (interactive)\n-  (when rust-analyzer--status-buffer-workspace\n-    (let ((inhibit-read-only t))\n-      (erase-buffer)\n-      (insert (with-lsp-workspace rust-analyzer--status-buffer-workspace\n-                (lsp-send-request (lsp-make-request\n-                                   \"rust-analyzer/analyzerStatus\")))))))\n-\n-\n-(defun rust-analyzer--syntax-tree-params ()\n-  \"Syntax tree params.\"\n-  (list :textDocument (lsp--text-document-identifier)\n-        :range (if (use-region-p)\n-                   (lsp--region-to-range (region-beginning) (region-end))\n-                 (lsp--region-to-range (point-min) (point-max)))))\n-\n-(defun rust-analyzer-syntax-tree ()\n-  \"Displays syntax tree for current buffer.\"\n-  (interactive)\n-  (when (eq 'rust-mode major-mode)\n-    (let* ((workspace (lsp-find-workspace 'rust-analyzer (buffer-file-name)))\n-           (buf (get-buffer-create (concat \"*rust-analyzer syntax tree \" (with-lsp-workspace workspace (lsp-workspace-root)) \"*\"))))\n-      (when workspace\n-        (let ((parse-result (with-lsp-workspace workspace\n-                              (lsp-send-request (lsp-make-request\n-                                                 \"rust-analyzer/syntaxTree\"\n-                                                 (rust-analyzer--syntax-tree-params))))))\n-          (with-current-buffer buf\n-            (let ((inhibit-read-only t))\n-              (erase-buffer)\n-              (insert parse-result)))\n-          (pop-to-buffer buf))))))\n-\n-;; inlay hints\n-(defun rust-analyzer--update-inlay-hints (buffer)\n-  (if (and (rust-analyzer--initialized?) (eq buffer (current-buffer)))\n-    (lsp-request-async\n-     \"rust-analyzer/inlayHints\"\n-     (list :textDocument (lsp--text-document-identifier))\n-     (lambda (res)\n-       (remove-overlays (point-min) (point-max) 'rust-analyzer--inlay-hint t)\n-       (dolist (hint res)\n-         (-let* (((&hash \"range\" \"label\" \"kind\") hint)\n-                 ((beg . end) (lsp--range-to-region range))\n-                 (overlay (make-overlay beg end)))\n-           (overlay-put overlay 'rust-analyzer--inlay-hint t)\n-           (overlay-put overlay 'evaporate t)\n-           (cond\n-            ((string= kind \"TypeHint\")\n-             (overlay-put overlay 'after-string (propertize (concat \": \" label)\n-                                                            'font-lock-face 'font-lock-comment-face)))\n-            ((string= kind \"ParameterHint\")\n-             (overlay-put overlay 'before-string (propertize (concat label \": \")\n-                                                            'font-lock-face 'font-lock-comment-face)))\n-            )\n-           )))\n-     :mode 'tick))\n-  nil)\n-\n-(defvar-local rust-analyzer--inlay-hints-timer nil)\n-\n-(defun rust-analyzer--inlay-hints-change-handler (&rest rest)\n-  (when rust-analyzer--inlay-hints-timer\n-    (cancel-timer rust-analyzer--inlay-hints-timer))\n-  (setq rust-analyzer--inlay-hints-timer\n-        (run-with-idle-timer 0.1 nil #'rust-analyzer--update-inlay-hints (current-buffer))))\n-\n-(define-minor-mode rust-analyzer-inlay-hints-mode\n-  \"Mode for showing inlay hints.\"\n-  nil nil nil\n-  (cond\n-   (rust-analyzer-inlay-hints-mode\n-    (rust-analyzer--update-inlay-hints (current-buffer))\n-    (add-hook 'lsp-after-initialize-hook #'rust-analyzer--inlay-hints-change-handler nil t)\n-    (add-hook 'after-change-functions #'rust-analyzer--inlay-hints-change-handler nil t))\n-   (t\n-    (remove-overlays (point-min) (point-max) 'rust-analyzer--inlay-hint t)\n-    (remove-hook 'lsp-after-initialize-hook #'rust-analyzer--inlay-hints-change-handler t)\n-    (remove-hook 'after-change-functions #'rust-analyzer--inlay-hints-change-handler t))))\n-\n-\n-\n-;; expand macros\n-(defun rust-analyzer-expand-macro ()\n-  \"Expands the macro call at point recursively.\"\n-  (interactive)\n-  (when (eq 'rust-mode major-mode)\n-    (let* ((workspace (lsp-find-workspace 'rust-analyzer (buffer-file-name)))\n-           (params (list :textDocument (lsp--text-document-identifier)\n-                         :position (lsp--cur-position))))\n-      (when workspace\n-        (let* ((response (with-lsp-workspace workspace\n-                           (lsp-send-request (lsp-make-request\n-                                              \"rust-analyzer/expandMacro\"\n-                                              params))))\n-               (result (when response (ht-get response \"expansion\"))))\n-          (if result\n-            (let ((buf (get-buffer-create (concat \"*rust-analyzer macro expansion \" (with-lsp-workspace workspace (lsp-workspace-root)) \"*\"))))\n-              (with-current-buffer buf\n-                (let ((inhibit-read-only t))\n-                  (erase-buffer)\n-                  (insert result)\n-                  (setq buffer-read-only t)\n-                  (special-mode)))\n-              (pop-to-buffer buf))\n-            (message \"No macro found at point, or it could not be expanded\")))))))\n-\n-\n-(provide 'rust-analyzer)\n-;;; rust-analyzer.el ends here"}]}