{"sha": "75ac0cca3678d5d309c737f1bd8ef237628a278b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1YWMwY2NhMzY3OGQ1ZDMwOWM3MzdmMWJkOGVmMjM3NjI4YTI3OGI=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-12-25T09:50:07Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-14T22:40:02Z"}, "message": "Prepare to use borrowck to resolve opaque types", "tree": {"sha": "cfa9a460a740aae7279cfc8dcbffa77187bf6e76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfa9a460a740aae7279cfc8dcbffa77187bf6e76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75ac0cca3678d5d309c737f1bd8ef237628a278b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75ac0cca3678d5d309c737f1bd8ef237628a278b", "html_url": "https://github.com/rust-lang/rust/commit/75ac0cca3678d5d309c737f1bd8ef237628a278b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75ac0cca3678d5d309c737f1bd8ef237628a278b/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43a3348fd94568b78db7755bb5196fc73fa65214", "url": "https://api.github.com/repos/rust-lang/rust/commits/43a3348fd94568b78db7755bb5196fc73fa65214", "html_url": "https://github.com/rust-lang/rust/commit/43a3348fd94568b78db7755bb5196fc73fa65214"}], "stats": {"total": 196, "additions": 128, "deletions": 68}, "files": [{"sha": "824cdfe55bfb65ec4d24e0dbce4eebf4b8d7757a", "filename": "src/librustc/mir/query.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75ac0cca3678d5d309c737f1bd8ef237628a278b/src%2Flibrustc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ac0cca3678d5d309c737f1bd8ef237628a278b/src%2Flibrustc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fquery.rs?ref=75ac0cca3678d5d309c737f1bd8ef237628a278b", "patch": "@@ -1,8 +1,10 @@\n //! Values computed by queries that use MIR.\n \n use crate::ty::{self, Ty};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitMatrix;\n use rustc_index::vec::IndexVec;\n use rustc_span::{Span, Symbol};\n@@ -59,8 +61,12 @@ pub struct GeneratorLayout<'tcx> {\n     pub storage_conflicts: BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal>,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct BorrowCheckResult<'tcx> {\n+    /// All the opaque types that are restricted to concrete types\n+    /// by this function. Unlike the value in `TypeckTables`, this has\n+    /// unerased regions.\n+    pub concrete_opaque_types: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n     pub closure_requirements: Option<ClosureRegionRequirements<'tcx>>,\n     pub used_mut_upvars: SmallVec<[Field; 8]>,\n }"}, {"sha": "1843d4bf72dc622dfe0a40d91cc3fc774fc813f0", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/75ac0cca3678d5d309c737f1bd8ef237628a278b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ac0cca3678d5d309c737f1bd8ef237628a278b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=75ac0cca3678d5d309c737f1bd8ef237628a278b", "patch": "@@ -195,19 +195,24 @@ fn do_mir_borrowck<'a, 'tcx>(\n         Rc::new(BorrowSet::build(tcx, body, locals_are_invalidated_at_exit, &mdpe.move_data));\n \n     // Compute non-lexical lifetimes.\n-    let nll::NllOutput { regioncx, polonius_output, opt_closure_req, nll_errors } =\n-        nll::compute_regions(\n-            infcx,\n-            def_id,\n-            free_regions,\n-            body,\n-            &promoted,\n-            location_table,\n-            param_env,\n-            &mut flow_inits,\n-            &mdpe.move_data,\n-            &borrow_set,\n-        );\n+    let nll::NllOutput {\n+        regioncx,\n+        opaque_type_values,\n+        polonius_output,\n+        opt_closure_req,\n+        nll_errors,\n+    } = nll::compute_regions(\n+        infcx,\n+        def_id,\n+        free_regions,\n+        body,\n+        &promoted,\n+        location_table,\n+        param_env,\n+        &mut flow_inits,\n+        &mdpe.move_data,\n+        &borrow_set,\n+    );\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging.\n@@ -389,6 +394,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     }\n \n     let result = BorrowCheckResult {\n+        concrete_opaque_types: opaque_type_values,\n         closure_requirements: opt_closure_req,\n         used_mut_upvars: mbcx.used_mut_upvars,\n     };"}, {"sha": "4acf1cf7c2b9a9614da0dc3d471d9c47955be107", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/75ac0cca3678d5d309c737f1bd8ef237628a278b/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ac0cca3678d5d309c737f1bd8ef237628a278b/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=75ac0cca3678d5d309c737f1bd8ef237628a278b", "patch": "@@ -6,6 +6,7 @@ use rustc::mir::{\n     Location, Promoted, ReadOnlyBodyAndCache,\n };\n use rustc::ty::{self, RegionKind, RegionVid};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::IndexVec;\n@@ -46,6 +47,7 @@ crate type PoloniusOutput = Output<RustcFacts>;\n /// closure requirements to propagate, and any generated errors.\n crate struct NllOutput<'tcx> {\n     pub regioncx: RegionInferenceContext<'tcx>,\n+    pub opaque_type_values: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n     pub polonius_output: Option<Rc<PoloniusOutput>>,\n     pub opt_closure_req: Option<ClosureRegionRequirements<'tcx>>,\n     pub nll_errors: RegionErrors<'tcx>,\n@@ -160,20 +162,21 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     let elements = &Rc::new(RegionValueElements::new(&body));\n \n     // Run the MIR type-checker.\n-    let MirTypeckResults { constraints, universal_region_relations } = type_check::type_check(\n-        infcx,\n-        param_env,\n-        body,\n-        promoted,\n-        def_id,\n-        &universal_regions,\n-        location_table,\n-        borrow_set,\n-        &mut all_facts,\n-        flow_inits,\n-        move_data,\n-        elements,\n-    );\n+    let MirTypeckResults { constraints, universal_region_relations, opaque_type_values } =\n+        type_check::type_check(\n+            infcx,\n+            param_env,\n+            body,\n+            promoted,\n+            def_id,\n+            &universal_regions,\n+            location_table,\n+            borrow_set,\n+            &mut all_facts,\n+            flow_inits,\n+            move_data,\n+            elements,\n+        );\n \n     if let Some(all_facts) = &mut all_facts {\n         let _prof_timer = infcx.tcx.prof.generic_activity(\"polonius_fact_generation\");\n@@ -281,6 +284,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n     NllOutput {\n         regioncx,\n+        opaque_type_values,\n         polonius_output,\n         opt_closure_req: closure_region_requirements,\n         nll_errors,"}, {"sha": "c6809f9e37e8653422df90057a9421a6a6a43261", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 64, "deletions": 37, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/75ac0cca3678d5d309c737f1bd8ef237628a278b/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ac0cca3678d5d309c737f1bd8ef237628a278b/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=75ac0cca3678d5d309c737f1bd8ef237628a278b", "patch": "@@ -158,7 +158,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         constraints: &mut constraints,\n     };\n \n-    type_check_internal(\n+    let opaque_type_values = type_check_internal(\n         infcx,\n         mir_def_id,\n         param_env,\n@@ -173,10 +173,11 @@ pub(crate) fn type_check<'mir, 'tcx>(\n             liveness::generate(&mut cx, body, elements, flow_inits, move_data, location_table);\n \n             translate_outlives_facts(&mut cx);\n+            cx.opaque_type_values\n         },\n     );\n \n-    MirTypeckResults { constraints, universal_region_relations }\n+    MirTypeckResults { constraints, universal_region_relations, opaque_type_values }\n }\n \n fn type_check_internal<'a, 'tcx, R>(\n@@ -189,7 +190,7 @@ fn type_check_internal<'a, 'tcx, R>(\n     implicit_region_bound: ty::Region<'tcx>,\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n     universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n-    mut extra: impl FnMut(&mut TypeChecker<'a, 'tcx>) -> R,\n+    extra: impl FnOnce(TypeChecker<'a, 'tcx>) -> R,\n ) -> R {\n     let mut checker = TypeChecker::new(\n         infcx,\n@@ -212,7 +213,7 @@ fn type_check_internal<'a, 'tcx, R>(\n         checker.typeck_mir(body);\n     }\n \n-    extra(&mut checker)\n+    extra(checker)\n }\n \n fn translate_outlives_facts(typeck: &mut TypeChecker<'_, '_>) {\n@@ -799,6 +800,7 @@ struct TypeChecker<'a, 'tcx> {\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n     universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n+    opaque_type_values: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n }\n \n struct BorrowCheckContext<'a, 'tcx> {\n@@ -812,6 +814,7 @@ struct BorrowCheckContext<'a, 'tcx> {\n crate struct MirTypeckResults<'tcx> {\n     crate constraints: MirTypeckRegionConstraints<'tcx>,\n     crate universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n+    crate opaque_type_values: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n }\n \n /// A collection of region constraints that must be satisfied for the\n@@ -958,6 +961,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             borrowck_context,\n             reported_errors: Default::default(),\n             universal_region_relations,\n+            opaque_type_values: FxHashMap::default(),\n         };\n         checker.check_user_type_annotations();\n         checker\n@@ -1195,6 +1199,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let tcx = infcx.tcx;\n         let param_env = self.param_env;\n         let body = self.body;\n+        let concrete_opaque_types = &tcx.typeck_tables_of(anon_owner_def_id).concrete_opaque_types;\n+        let mut opaque_type_values = Vec::new();\n+\n         debug!(\"eq_opaque_type_and_type: mir_def_id={:?}\", self.mir_def_id);\n         let opaque_type_map = self.fully_perform_op(\n             locations,\n@@ -1226,47 +1233,65 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n \n                     for (&opaque_def_id, opaque_decl) in &opaque_type_map {\n-                        let opaque_defn_ty = tcx.type_of(opaque_def_id);\n-                        let opaque_defn_ty = opaque_defn_ty.subst(tcx, opaque_decl.substs);\n-                        let opaque_defn_ty = renumber::renumber_regions(infcx, &opaque_defn_ty);\n-                        let concrete_is_opaque = infcx\n-                            .resolve_vars_if_possible(&opaque_decl.concrete_ty)\n-                            .is_impl_trait();\n+                        let resolved_ty = infcx.resolve_vars_if_possible(&opaque_decl.concrete_ty);\n+                        let concrete_is_opaque = if let ty::Opaque(def_id, _) = resolved_ty.kind {\n+                            def_id == opaque_def_id\n+                        } else {\n+                            false\n+                        };\n+                        let opaque_defn_ty = match concrete_opaque_types.get(&opaque_def_id) {\n+                            None => {\n+                                assert!(\n+                                    concrete_is_opaque,\n+                                    \"Non-defining use of {:?} with revealed type\",\n+                                    opaque_def_id,\n+                                );\n+                                continue;\n+                            }\n+                            Some(opaque_defn_ty) => opaque_defn_ty,\n+                        };\n+                        debug!(\"opaque_defn_ty = {:?}\", opaque_defn_ty);\n+                        let subst_opaque_defn_ty =\n+                            opaque_defn_ty.concrete_type.subst(tcx, opaque_decl.substs);\n+                        let renumbered_opaque_defn_ty =\n+                            renumber::renumber_regions(infcx, &subst_opaque_defn_ty);\n \n                         debug!(\n-                            \"eq_opaque_type_and_type: concrete_ty={:?}={:?} opaque_defn_ty={:?} \\\n-                            concrete_is_opaque={}\",\n-                            opaque_decl.concrete_ty,\n-                            infcx.resolve_vars_if_possible(&opaque_decl.concrete_ty),\n-                            opaque_defn_ty,\n-                            concrete_is_opaque\n+                            \"eq_opaque_type_and_type: concrete_ty={:?}={:?} opaque_defn_ty={:?}\",\n+                            opaque_decl.concrete_ty, resolved_ty, renumbered_opaque_defn_ty,\n                         );\n \n-                        // concrete_is_opaque is `true` when we're using an opaque `impl Trait`\n-                        // type without 'revealing' it. For example, code like this:\n-                        //\n-                        // type Foo = impl Debug;\n-                        // fn foo1() -> Foo { ... }\n-                        // fn foo2() -> Foo { foo1() }\n-                        //\n-                        // In `foo2`, we're not revealing the type of `Foo` - we're\n-                        // just treating it as the opaque type.\n-                        //\n-                        // When this occurs, we do *not* want to try to equate\n-                        // the concrete type with the underlying defining type\n-                        // of the opaque type - this will always fail, since\n-                        // the defining type of an opaque type is always\n-                        // some other type (e.g. not itself)\n-                        // Essentially, none of the normal obligations apply here -\n-                        // we're just passing around some unknown opaque type,\n-                        // without actually looking at the underlying type it\n-                        // gets 'revealed' into\n-\n                         if !concrete_is_opaque {\n                             obligations.add(\n                                 infcx\n                                     .at(&ObligationCause::dummy(), param_env)\n-                                    .eq(opaque_decl.concrete_ty, opaque_defn_ty)?,\n+                                    .eq(opaque_decl.concrete_ty, renumbered_opaque_defn_ty)?,\n+                            );\n+                            opaque_type_values\n+                                .push((opaque_def_id, ty::ResolvedOpaqueTy { ..*opaque_defn_ty }));\n+                        } else {\n+                            // We're using an opaque `impl Trait` type without\n+                            // 'revealing' it. For example, code like this:\n+                            //\n+                            // type Foo = impl Debug;\n+                            // fn foo1() -> Foo { ... }\n+                            // fn foo2() -> Foo { foo1() }\n+                            //\n+                            // In `foo2`, we're not revealing the type of `Foo` - we're\n+                            // just treating it as the opaque type.\n+                            //\n+                            // When this occurs, we do *not* want to try to equate\n+                            // the concrete type with the underlying defining type\n+                            // of the opaque type - this will always fail, since\n+                            // the defining type of an opaque type is always\n+                            // some other type (e.g. not itself)\n+                            // Essentially, none of the normal obligations apply here -\n+                            // we're just passing around some unknown opaque type,\n+                            // without actually looking at the underlying type it\n+                            // gets 'revealed' into\n+                            debug!(\n+                                \"eq_opaque_type_and_type: non-defining use of {:?}\",\n+                                opaque_def_id,\n                             );\n                         }\n                     }\n@@ -1282,6 +1307,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             ),\n         )?;\n \n+        self.opaque_type_values.extend(opaque_type_values);\n+\n         let universal_region_relations = self.universal_region_relations;\n \n         // Finally, if we instantiated the anon types successfully, we"}, {"sha": "cf82789482bc39d81167a98b78d772f0a37babd6", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/75ac0cca3678d5d309c737f1bd8ef237628a278b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ac0cca3678d5d309c737f1bd8ef237628a278b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=75ac0cca3678d5d309c737f1bd8ef237628a278b", "patch": "@@ -1464,7 +1464,7 @@ fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 }\n                 // Opaque types desugared from `impl Trait`.\n                 ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: Some(owner), .. }) => {\n-                    tcx.typeck_tables_of(owner)\n+                    tcx.mir_borrowck(owner)\n                         .concrete_opaque_types\n                         .get(&def_id)\n                         .map(|opaque| opaque.concrete_type)\n@@ -1687,7 +1687,7 @@ fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n }\n \n fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n-    use rustc_hir::{ImplItem, Item, TraitItem};\n+    use rustc_hir::{Expr, ImplItem, Item, TraitItem};\n \n     debug!(\"find_opaque_ty_constraints({:?})\", def_id);\n \n@@ -1713,7 +1713,17 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 );\n                 return;\n             }\n-            let ty = self.tcx.typeck_tables_of(def_id).concrete_opaque_types.get(&self.def_id);\n+            // Calling `mir_borrowck` can lead to cycle errors through\n+            // const-checking, avoid calling it if we don't have to.\n+            if !self.tcx.typeck_tables_of(def_id).concrete_opaque_types.contains_key(&self.def_id) {\n+                debug!(\n+                    \"find_opaque_ty_constraints: no constraint for `{:?}` at `{:?}`\",\n+                    self.def_id, def_id,\n+                );\n+                return;\n+            }\n+            // Use borrowck to get the type with unerased regions.\n+            let ty = self.tcx.mir_borrowck(def_id).concrete_opaque_types.get(&self.def_id);\n             if let Some(ty::ResolvedOpaqueTy { concrete_type, substs }) = ty {\n                 debug!(\n                     \"find_opaque_ty_constraints: found constraint for `{:?}` at `{:?}`: {:?}\",\n@@ -1856,6 +1866,13 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<'_, Self::Map> {\n             intravisit::NestedVisitorMap::All(&self.tcx.hir())\n         }\n+        fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+            if let hir::ExprKind::Closure(..) = ex.kind {\n+                let def_id = self.tcx.hir().local_def_id(ex.hir_id);\n+                self.check(def_id);\n+            }\n+            intravisit::walk_expr(self, ex);\n+        }\n         fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n             debug!(\"find_existential_constraints: visiting {:?}\", it);\n             let def_id = self.tcx.hir().local_def_id(it.hir_id);"}]}