{"sha": "e136bf6a4c2cff8b36e372612c6bbe42eaeeb621", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxMzZiZjZhNGMyY2ZmOGIzNmUzNzI2MTJjNmJiZTQyZWFlZWI2MjE=", "commit": {"author": {"name": "Cengiz Can", "email": "canc@thoughtworks.com", "date": "2017-02-27T19:30:47Z"}, "committer": {"name": "Cengiz Can", "email": "canc@thoughtworks.com", "date": "2017-02-27T19:30:47Z"}, "message": "Format note.rs with rustfmt", "tree": {"sha": "5a8a4c131b18fcacf19d792b94de38ce9ad96893", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a8a4c131b18fcacf19d792b94de38ce9ad96893"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e136bf6a4c2cff8b36e372612c6bbe42eaeeb621", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e136bf6a4c2cff8b36e372612c6bbe42eaeeb621", "html_url": "https://github.com/rust-lang/rust/commit/e136bf6a4c2cff8b36e372612c6bbe42eaeeb621", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e136bf6a4c2cff8b36e372612c6bbe42eaeeb621/comments", "author": null, "committer": null, "parents": [{"sha": "2f8ef50f7d197191fdcef2eade4e42feceef0c62", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f8ef50f7d197191fdcef2eade4e42feceef0c62", "html_url": "https://github.com/rust-lang/rust/commit/2f8ef50f7d197191fdcef2eade4e42feceef0c62"}], "stats": {"total": 473, "additions": 220, "deletions": 253}, "files": [{"sha": "8f8b2603dad8496de6358bdfa77c7748d5165c43", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 220, "deletions": 253, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/e136bf6a4c2cff8b36e372612c6bbe42eaeeb621/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e136bf6a4c2cff8b36e372612c6bbe42eaeeb621/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=e136bf6a4c2cff8b36e372612c6bbe42eaeeb621", "patch": "@@ -14,184 +14,150 @@ use ty::error::TypeError;\n use errors::DiagnosticBuilder;\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    pub(super) fn note_region_origin(&self, err: &mut DiagnosticBuilder, origin: &SubregionOrigin<'tcx>) {\n+    pub(super) fn note_region_origin(&self,\n+                                     err: &mut DiagnosticBuilder,\n+                                     origin: &SubregionOrigin<'tcx>) {\n         match *origin {\n             infer::Subtype(ref trace) => {\n                 if let Some((expected, found)) = self.values_str(&trace.values) {\n                     // FIXME: do we want a \"the\" here?\n-                    err.span_note(\n-                        trace.cause.span,\n-                        &format!(\"...so that {} (expected {}, found {})\",\n-                                 trace.cause.as_requirement_str(), expected, found));\n+                    err.span_note(trace.cause.span,\n+                                  &format!(\"...so that {} (expected {}, found {})\",\n+                                           trace.cause.as_requirement_str(),\n+                                           expected,\n+                                           found));\n                 } else {\n                     // FIXME: this really should be handled at some earlier stage. Our\n                     // handling of region checking when type errors are present is\n                     // *terrible*.\n \n-                    err.span_note(\n-                        trace.cause.span,\n-                        &format!(\"...so that {}\",\n-                                 trace.cause.as_requirement_str()));\n+                    err.span_note(trace.cause.span,\n+                                  &format!(\"...so that {}\", trace.cause.as_requirement_str()));\n                 }\n             }\n             infer::Reborrow(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that reference does not outlive \\\n-                    borrowed content\");\n+                err.span_note(span,\n+                              \"...so that reference does not outlive borrowed content\");\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\n-                        \"...so that closure can access `{}`\",\n-                        self.tcx.local_var_name_str(upvar_id.var_id)\n-                            .to_string()));\n+                err.span_note(span,\n+                              &format!(\"...so that closure can access `{}`\",\n+                                       self.tcx\n+                                           .local_var_name_str(upvar_id.var_id)\n+                                           .to_string()));\n             }\n             infer::InfStackClosure(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that closure does not outlive its stack frame\");\n+                err.span_note(span, \"...so that closure does not outlive its stack frame\");\n             }\n             infer::InvokeClosure(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that closure is not invoked outside its lifetime\");\n+                err.span_note(span,\n+                              \"...so that closure is not invoked outside its lifetime\");\n             }\n             infer::DerefPointer(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that pointer is not dereferenced \\\n-                    outside its lifetime\");\n+                err.span_note(span,\n+                              \"...so that pointer is not dereferenced outside its lifetime\");\n             }\n             infer::FreeVariable(span, id) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so that captured variable `{}` \\\n-                            does not outlive the enclosing closure\",\n-                             self.tcx.local_var_name_str(id)));\n+                err.span_note(span,\n+                              &format!(\"...so that captured variable `{}` does not outlive the \\\n+                                        enclosing closure\",\n+                                       self.tcx.local_var_name_str(id)));\n             }\n             infer::IndexSlice(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that slice is not indexed outside the lifetime\");\n+                err.span_note(span, \"...so that slice is not indexed outside the lifetime\");\n             }\n             infer::RelateObjectBound(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that it can be closed over into an object\");\n+                err.span_note(span, \"...so that it can be closed over into an object\");\n             }\n             infer::CallRcvr(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that method receiver is valid for the method call\");\n+                err.span_note(span,\n+                              \"...so that method receiver is valid for the method call\");\n             }\n             infer::CallArg(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that argument is valid for the call\");\n+                err.span_note(span, \"...so that argument is valid for the call\");\n             }\n             infer::CallReturn(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that return value is valid for the call\");\n+                err.span_note(span, \"...so that return value is valid for the call\");\n             }\n             infer::Operand(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that operand is valid for operation\");\n+                err.span_note(span, \"...so that operand is valid for operation\");\n             }\n             infer::AddrOf(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that reference is valid \\\n-                     at the time of borrow\");\n+                err.span_note(span, \"...so that reference is valid at the time of borrow\");\n             }\n             infer::AutoBorrow(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that auto-reference is valid \\\n-                     at the time of borrow\");\n+                err.span_note(span,\n+                              \"...so that auto-reference is valid at the time of borrow\");\n             }\n             infer::ExprTypeIsNotInScope(t, span) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so type `{}` of expression is valid during the \\\n-                             expression\",\n-                             self.ty_to_string(t)));\n+                err.span_note(span,\n+                              &format!(\"...so type `{}` of expression is valid during the \\\n+                                        expression\",\n+                                       self.ty_to_string(t)));\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that variable is valid at time of its declaration\");\n+                err.span_note(span,\n+                              \"...so that variable is valid at time of its declaration\");\n             }\n             infer::ParameterInScope(_, span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that a type/lifetime parameter is in scope here\");\n+                err.span_note(span,\n+                              \"...so that a type/lifetime parameter is in scope here\");\n             }\n             infer::DataBorrowed(ty, span) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so that the type `{}` is not borrowed for too long\",\n-                             self.ty_to_string(ty)));\n+                err.span_note(span,\n+                              &format!(\"...so that the type `{}` is not borrowed for too long\",\n+                                       self.ty_to_string(ty)));\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so that the reference type `{}` \\\n-                             does not outlive the data it points at\",\n-                             self.ty_to_string(ty)));\n+                err.span_note(span,\n+                              &format!(\"...so that the reference type `{}` does not outlive the \\\n+                                        data it points at\",\n+                                       self.ty_to_string(ty)));\n             }\n             infer::RelateParamBound(span, t) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so that the type `{}` \\\n-                             will meet its required lifetime bounds\",\n-                             self.ty_to_string(t)));\n+                err.span_note(span,\n+                              &format!(\"...so that the type `{}` will meet its required \\\n+                                        lifetime bounds\",\n+                                       self.ty_to_string(t)));\n             }\n             infer::RelateDefaultParamBound(span, t) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so that type parameter \\\n-                             instantiated with `{}`, \\\n-                             will meet its declared lifetime bounds\",\n-                             self.ty_to_string(t)));\n+                err.span_note(span,\n+                              &format!(\"...so that type parameter instantiated with `{}`, will \\\n+                                        meet its declared lifetime bounds\",\n+                                       self.ty_to_string(t)));\n             }\n             infer::RelateRegionParamBound(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that the declared lifetime parameter bounds \\\n-                                are satisfied\");\n+                err.span_note(span,\n+                              \"...so that the declared lifetime parameter bounds are satisfied\");\n             }\n             infer::SafeDestructor(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that references are valid when the destructor \\\n-                     runs\");\n+                err.span_note(span,\n+                              \"...so that references are valid when the destructor runs\");\n             }\n             infer::CompareImplMethodObligation { span, .. } => {\n-                err.span_note(\n-                    span,\n-                    \"...so that the definition in impl matches the definition from the trait\");\n+                err.span_note(span,\n+                              \"...so that the definition in impl matches the definition from the \\\n+                               trait\");\n             }\n         }\n     }\n \n     pub(super) fn report_concrete_failure(&self,\n-                               origin: SubregionOrigin<'tcx>,\n-                               sub: &'tcx Region,\n-                               sup: &'tcx Region)\n-                               -> DiagnosticBuilder<'tcx> {\n+                                          origin: SubregionOrigin<'tcx>,\n+                                          sub: &'tcx Region,\n+                                          sup: &'tcx Region)\n+                                          -> DiagnosticBuilder<'tcx> {\n         match origin {\n             infer::Subtype(trace) => {\n                 let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n                 self.report_and_explain_type_error(trace, &terr)\n             }\n             infer::Reborrow(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0312,\n-                        \"lifetime of reference outlives \\\n-                         lifetime of borrowed content...\");\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0312,\n+                                               \"lifetime of reference outlives lifetime of \\\n+                                                borrowed content...\");\n                 self.tcx.note_and_explain_region(&mut err,\n                                                  \"...the reference is valid for \",\n                                                  sub,\n@@ -203,102 +169,103 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0313,\n-                        \"lifetime of borrowed pointer outlives \\\n-                                lifetime of captured variable `{}`...\",\n-                                self.tcx.local_var_name_str(upvar_id.var_id));\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0313,\n+                                               \"lifetime of borrowed pointer outlives lifetime \\\n+                                                of captured variable `{}`...\",\n+                                               self.tcx.local_var_name_str(upvar_id.var_id));\n                 self.tcx.note_and_explain_region(&mut err,\n                                                  \"...the borrowed pointer is valid for \",\n                                                  sub,\n                                                  \"...\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                                                 &format!(\"...but `{}` is only valid for \",\n-                                                          self.tcx.local_var_name_str(upvar_id.var_id)),\n-                                                 sup,\n-                                                 \"\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err,\n+                                             &format!(\"...but `{}` is only valid for \",\n+                                                      self.tcx\n+                                                          .local_var_name_str(upvar_id.var_id)),\n+                                             sup,\n+                                             \"\");\n                 err\n             }\n             infer::InfStackClosure(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0314,\n-                        \"closure outlives stack frame\");\n+                let mut err =\n+                    struct_span_err!(self.tcx.sess, span, E0314, \"closure outlives stack frame\");\n                 self.tcx.note_and_explain_region(&mut err,\n                                                  \"...the closure must be valid for \",\n                                                  sub,\n                                                  \"...\");\n                 self.tcx.note_and_explain_region(&mut err,\n-                                                 \"...but the closure's stack frame is only valid for \",\n+                                                 \"...but the closure's stack frame is only valid \\\n+                                                  for \",\n                                                  sup,\n                                                  \"\");\n                 err\n             }\n             infer::InvokeClosure(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0315,\n-                        \"cannot invoke closure outside of its lifetime\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                                                 \"the closure is only valid for \",\n-                                                 sup,\n-                                                 \"\");\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0315,\n+                                               \"cannot invoke closure outside of its lifetime\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the closure is only valid for \", sup, \"\");\n                 err\n             }\n             infer::DerefPointer(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0473,\n-                              \"dereference of reference outside its lifetime\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                                                 \"the reference is only valid for \",\n-                                                 sup,\n-                                                 \"\");\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0473,\n+                                               \"dereference of reference outside its lifetime\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the reference is only valid for \", sup, \"\");\n                 err\n             }\n             infer::FreeVariable(span, id) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0474,\n-                              \"captured variable `{}` does not outlive the enclosing closure\",\n-                              self.tcx.local_var_name_str(id));\n-                self.tcx.note_and_explain_region(&mut err,\n-                                                 \"captured variable is valid for \",\n-                                                 sup,\n-                                                 \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                                                 \"closure is valid for \",\n-                                                 sub,\n-                                                 \"\");\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0474,\n+                                               \"captured variable `{}` does not outlive the \\\n+                                                enclosing closure\",\n+                                               self.tcx.local_var_name_str(id));\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"captured variable is valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(&mut err, \"closure is valid for \", sub, \"\");\n                 err\n             }\n             infer::IndexSlice(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0475,\n-                              \"index of slice outside its lifetime\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                                                 \"the slice is only valid for \",\n-                                                 sup,\n-                                                 \"\");\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0475,\n+                                               \"index of slice outside its lifetime\");\n+                self.tcx.note_and_explain_region(&mut err, \"the slice is only valid for \", sup, \"\");\n                 err\n             }\n             infer::RelateObjectBound(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0476,\n-                              \"lifetime of the source pointer does not outlive \\\n-                               lifetime bound of the object type\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                                                 \"object type is valid for \",\n-                                                 sub,\n-                                                 \"\");\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0476,\n+                                               \"lifetime of the source pointer does not outlive \\\n+                                                lifetime bound of the object type\");\n+                self.tcx.note_and_explain_region(&mut err, \"object type is valid for \", sub, \"\");\n                 self.tcx.note_and_explain_region(&mut err,\n                                                  \"source pointer is only valid for \",\n                                                  sup,\n                                                  \"\");\n                 err\n             }\n             infer::RelateParamBound(span, ty) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0477,\n-                              \"the type `{}` does not fulfill the required lifetime\",\n-                              self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err,\n-                                                 \"type must outlive \",\n-                                                 sub,\n-                                                 \"\");\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0477,\n+                                               \"the type `{}` does not fulfill the required \\\n+                                                lifetime\",\n+                                               self.ty_to_string(ty));\n+                self.tcx.note_and_explain_region(&mut err, \"type must outlive \", sub, \"\");\n                 err\n             }\n             infer::RelateRegionParamBound(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0478,\n-                              \"lifetime bound not satisfied\");\n+                let mut err =\n+                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n                 self.tcx.note_and_explain_region(&mut err,\n                                                  \"lifetime parameter instantiated with \",\n                                                  sup,\n@@ -310,149 +277,149 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err\n             }\n             infer::RelateDefaultParamBound(span, ty) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0479,\n-                              \"the type `{}` (provided as the value of \\\n-                               a type parameter) is not valid at this point\",\n-                              self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err,\n-                                                 \"type must outlive \",\n-                                                 sub,\n-                                                 \"\");\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0479,\n+                                               \"the type `{}` (provided as the value of a type \\\n+                                                parameter) is not valid at this point\",\n+                                               self.ty_to_string(ty));\n+                self.tcx.note_and_explain_region(&mut err, \"type must outlive \", sub, \"\");\n                 err\n             }\n             infer::CallRcvr(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0480,\n-                              \"lifetime of method receiver does not outlive \\\n-                               the method call\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                                                 \"the receiver is only valid for \",\n-                                                 sup,\n-                                                 \"\");\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0480,\n+                                               \"lifetime of method receiver does not outlive the \\\n+                                                method call\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the receiver is only valid for \", sup, \"\");\n                 err\n             }\n             infer::CallArg(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0481,\n-                              \"lifetime of function argument does not outlive \\\n-                               the function call\");\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0481,\n+                                               \"lifetime of function argument does not outlive \\\n+                                                the function call\");\n                 self.tcx.note_and_explain_region(&mut err,\n                                                  \"the function argument is only valid for \",\n                                                  sup,\n                                                  \"\");\n                 err\n             }\n             infer::CallReturn(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0482,\n-                              \"lifetime of return value does not outlive \\\n-                               the function call\");\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0482,\n+                                               \"lifetime of return value does not outlive the \\\n+                                                function call\");\n                 self.tcx.note_and_explain_region(&mut err,\n                                                  \"the return value is only valid for \",\n                                                  sup,\n                                                  \"\");\n                 err\n             }\n             infer::Operand(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0483,\n-                              \"lifetime of operand does not outlive \\\n-                               the operation\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                                                 \"the operand is only valid for \",\n-                                                 sup,\n-                                                 \"\");\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0483,\n+                                               \"lifetime of operand does not outlive the \\\n+                                                operation\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the operand is only valid for \", sup, \"\");\n                 err\n             }\n             infer::AddrOf(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0484,\n-                              \"reference is not valid at the time of borrow\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                                                 \"the borrow is only valid for \",\n-                                                 sup,\n-                                                 \"\");\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0484,\n+                                               \"reference is not valid at the time of borrow\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the borrow is only valid for \", sup, \"\");\n                 err\n             }\n             infer::AutoBorrow(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0485,\n-                              \"automatically reference is not valid \\\n-                               at the time of borrow\");\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0485,\n+                                               \"automatically reference is not valid at the time \\\n+                                                of borrow\");\n                 self.tcx.note_and_explain_region(&mut err,\n                                                  \"the automatic borrow is only valid for \",\n                                                  sup,\n                                                  \"\");\n                 err\n             }\n             infer::ExprTypeIsNotInScope(t, span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0486,\n-                              \"type of expression contains references \\\n-                               that are not valid during the expression: `{}`\",\n-                              self.ty_to_string(t));\n-                self.tcx.note_and_explain_region(&mut err,\n-                                                 \"type is only valid for \",\n-                                                 sup,\n-                                                 \"\");\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0486,\n+                                               \"type of expression contains references that are \\\n+                                                not valid during the expression: `{}`\",\n+                                               self.ty_to_string(t));\n+                self.tcx.note_and_explain_region(&mut err, \"type is only valid for \", sup, \"\");\n                 err\n             }\n             infer::SafeDestructor(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0487,\n-                              \"unsafe use of destructor: destructor might be called \\\n-                               while references are dead\");\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0487,\n+                                               \"unsafe use of destructor: destructor might be \\\n+                                                called while references are dead\");\n                 // FIXME (22171): terms \"super/subregion\" are suboptimal\n-                self.tcx.note_and_explain_region(&mut err,\n-                                                 \"superregion: \",\n-                                                 sup,\n-                                                 \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                                                 \"subregion: \",\n-                                                 sub,\n-                                                 \"\");\n+                self.tcx.note_and_explain_region(&mut err, \"superregion: \", sup, \"\");\n+                self.tcx.note_and_explain_region(&mut err, \"subregion: \", sub, \"\");\n                 err\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0488,\n-                              \"lifetime of variable does not enclose its declaration\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                                                 \"the variable is only valid for \",\n-                                                 sup,\n-                                                 \"\");\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0488,\n+                                               \"lifetime of variable does not enclose its \\\n+                                                declaration\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the variable is only valid for \", sup, \"\");\n                 err\n             }\n             infer::ParameterInScope(_, span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0489,\n-                              \"type/lifetime parameter not in scope here\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                                                 \"the parameter is only valid for \",\n-                                                 sub,\n-                                                 \"\");\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0489,\n+                                               \"type/lifetime parameter not in scope here\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the parameter is only valid for \", sub, \"\");\n                 err\n             }\n             infer::DataBorrowed(ty, span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0490,\n-                              \"a value of type `{}` is borrowed for too long\",\n-                              self.ty_to_string(ty));\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0490,\n+                                               \"a value of type `{}` is borrowed for too long\",\n+                                               self.ty_to_string(ty));\n                 self.tcx.note_and_explain_region(&mut err, \"the type is valid for \", sub, \"\");\n                 self.tcx.note_and_explain_region(&mut err, \"but the borrow lasts for \", sup, \"\");\n                 err\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0491,\n-                              \"in type `{}`, reference has a longer lifetime \\\n-                               than the data it references\",\n-                              self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err,\n-                                                 \"the pointer is valid for \",\n-                                                 sub,\n-                                                 \"\");\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0491,\n+                                               \"in type `{}`, reference has a longer lifetime \\\n+                                                than the data it references\",\n+                                               self.ty_to_string(ty));\n+                self.tcx.note_and_explain_region(&mut err, \"the pointer is valid for \", sub, \"\");\n                 self.tcx.note_and_explain_region(&mut err,\n                                                  \"but the referenced data is only valid for \",\n                                                  sup,\n                                                  \"\");\n                 err\n             }\n-            infer::CompareImplMethodObligation {\n-                span,\n-                item_name,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-                lint_id\n-            } => {\n+            infer::CompareImplMethodObligation { span,\n+                                                 item_name,\n+                                                 impl_item_def_id,\n+                                                 trait_item_def_id,\n+                                                 lint_id } => {\n                 self.report_extra_impl_obligation(span,\n                                                   item_name,\n                                                   impl_item_def_id,\n@@ -462,4 +429,4 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}]}