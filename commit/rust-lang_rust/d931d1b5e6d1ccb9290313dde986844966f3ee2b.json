{"sha": "d931d1b5e6d1ccb9290313dde986844966f3ee2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MzFkMWI1ZTZkMWNjYjkyOTAzMTNkZGU5ODY4NDQ5NjZmM2VlMmI=", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-02-26T23:29:42Z"}, "committer": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-02-28T21:53:52Z"}, "message": "lintcheck: refactor: introduce a basic LintcheckConfig struct which holds the job limit and paths to the sources and log files", "tree": {"sha": "586a1e9054b2ace01f4798625a69fd1e4e6311b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/586a1e9054b2ace01f4798625a69fd1e4e6311b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d931d1b5e6d1ccb9290313dde986844966f3ee2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d931d1b5e6d1ccb9290313dde986844966f3ee2b", "html_url": "https://github.com/rust-lang/rust/commit/d931d1b5e6d1ccb9290313dde986844966f3ee2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d931d1b5e6d1ccb9290313dde986844966f3ee2b/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac2f041b4787a128f4eaf26736c2d2df40e2bee6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac2f041b4787a128f4eaf26736c2d2df40e2bee6", "html_url": "https://github.com/rust-lang/rust/commit/ac2f041b4787a128f4eaf26736c2d2df40e2bee6"}], "stats": {"total": 111, "additions": 66, "deletions": 45}, "files": [{"sha": "423daa0d19043da70b3158a3febc879dd04f9ccd", "filename": "clippy_dev/src/lintcheck.rs", "status": "modified", "additions": 66, "deletions": 45, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/d931d1b5e6d1ccb9290313dde986844966f3ee2b/clippy_dev%2Fsrc%2Flintcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d931d1b5e6d1ccb9290313dde986844966f3ee2b/clippy_dev%2Fsrc%2Flintcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flintcheck.rs?ref=d931d1b5e6d1ccb9290313dde986844966f3ee2b", "patch": "@@ -287,6 +287,61 @@ impl Crate {\n     }\n }\n \n+#[derive(Debug)]\n+struct LintcheckConfig {\n+    // max number of jobs to spawn (default 1)\n+    max_jobs: usize,\n+    // we read the sources to check from here\n+    sources_toml_path: PathBuf,\n+    // we save the clippy lint results here\n+    lintcheck_results_path: PathBuf,\n+}\n+\n+impl LintcheckConfig {\n+    fn from_clap(clap_config: &ArgMatches) -> Self {\n+        // first, check if we got anything passed via the LINTCHECK_TOML env var,\n+        // if not, ask clap if we got any value for --crates-toml  <foo>\n+        // if not, use the default \"clippy_dev/lintcheck_crates.toml\"\n+        let sources_toml = env::var(\"LINTCHECK_TOML\").unwrap_or(\n+            clap_config\n+                .value_of(\"crates-toml\")\n+                .clone()\n+                .unwrap_or(\"clippy_dev/lintcheck_crates.toml\")\n+                .to_string(),\n+        );\n+\n+        let sources_toml_path = PathBuf::from(sources_toml);\n+\n+        // for the path where we save the lint results, get the filename without extenstion ( so for\n+        // wasd.toml, use \"wasd\"....)\n+        let filename: PathBuf = sources_toml_path.file_stem().unwrap().into();\n+        let lintcheck_results_path = PathBuf::from(format!(\"lintcheck-logs/{}_logs.txt\", filename.display()));\n+\n+        let max_jobs = match clap_config.value_of(\"threads\") {\n+            Some(threads) => {\n+                let threads: usize = threads\n+                    .parse()\n+                    .expect(&format!(\"Failed to parse '{}' to a digit\", threads));\n+                if threads == 0 {\n+                    // automatic choice\n+                    // Rayon seems to return thread count so half that for core count\n+                    (rayon::current_num_threads() / 2) as usize\n+                } else {\n+                    threads\n+                }\n+            },\n+            // no -j passed, use a single thread\n+            None => 1,\n+        };\n+\n+        LintcheckConfig {\n+            max_jobs,\n+            sources_toml_path,\n+            lintcheck_results_path,\n+        }\n+    }\n+}\n+\n /// takes a single json-formatted clippy warnings and returns true (we are interested in that line)\n /// or false (we aren't)\n fn filter_clippy_warnings(line: &str) -> bool {\n@@ -310,19 +365,6 @@ fn filter_clippy_warnings(line: &str) -> bool {\n     false\n }\n \n-/// get the path to lintchecks crate sources .toml file, check LINTCHECK_TOML first but if it's\n-/// empty use the default path\n-fn lintcheck_config_toml(toml_path: Option<&str>) -> PathBuf {\n-    PathBuf::from(\n-        env::var(\"LINTCHECK_TOML\").unwrap_or(\n-            toml_path\n-                .clone()\n-                .unwrap_or(\"clippy_dev/lintcheck_crates.toml\")\n-                .to_string(),\n-        ),\n-    )\n-}\n-\n /// Builds clippy inside the repo to make sure we have a clippy executable we can use.\n fn build_clippy() {\n     let status = Command::new(\"cargo\")\n@@ -336,9 +378,7 @@ fn build_clippy() {\n }\n \n /// Read a `toml` file and return a list of `CrateSources` that we want to check with clippy\n-fn read_crates(toml_path: &PathBuf) -> (String, Vec<CrateSource>) {\n-    // save it so that we can use the name of the sources.toml as name for the logfile later.\n-    let toml_filename = toml_path.file_stem().unwrap().to_str().unwrap().to_string();\n+fn read_crates(toml_path: &PathBuf) -> Vec<CrateSource> {\n     let toml_content: String =\n         std::fs::read_to_string(&toml_path).unwrap_or_else(|_| panic!(\"Failed to read {}\", toml_path.display()));\n     let crate_list: SourceList =\n@@ -398,7 +438,7 @@ fn read_crates(toml_path: &PathBuf) -> (String, Vec<CrateSource>) {\n     // sort the crates\n     crate_sources.sort();\n \n-    (toml_filename, crate_sources)\n+    crate_sources\n }\n \n /// Parse the json output of clippy and return a `ClippyWarning`\n@@ -476,16 +516,15 @@ fn lintcheck_needs_rerun(toml_path: &PathBuf) -> bool {\n \n /// lintchecks `main()` function\n pub fn run(clap_config: &ArgMatches) {\n+    let config = LintcheckConfig::from_clap(clap_config);\n+\n     println!(\"Compiling clippy...\");\n     build_clippy();\n     println!(\"Done compiling\");\n \n-    let clap_toml_path: Option<&str> = clap_config.value_of(\"crates-toml\");\n-    let toml_path: PathBuf = lintcheck_config_toml(clap_toml_path);\n-\n     // if the clippy bin is newer than our logs, throw away target dirs to force clippy to\n     // refresh the logs\n-    if lintcheck_needs_rerun(&toml_path) {\n+    if lintcheck_needs_rerun(&config.sources_toml_path) {\n         let shared_target_dir = \"target/lintcheck/shared_target_dir\";\n         match std::fs::metadata(&shared_target_dir) {\n             Ok(metadata) => {\n@@ -520,9 +559,8 @@ pub fn run(clap_config: &ArgMatches) {\n     // download and extract the crates, then run clippy on them and collect clippys warnings\n     // flatten into one big list of warnings\n \n-    let (filename, crates) = read_crates(&toml_path);\n-    let file = format!(\"lintcheck-logs/{}_logs.txt\", filename);\n-    let old_stats = read_stats_from_file(&file);\n+    let crates = read_crates(&config.sources_toml_path);\n+    let old_stats = read_stats_from_file(&config.lintcheck_results_path);\n \n     let clippy_warnings: Vec<ClippyWarning> = if let Some(only_one_crate) = clap_config.value_of(\"only\") {\n         // if we don't have the specified crate in the .toml, throw an error\n@@ -562,23 +600,7 @@ pub fn run(clap_config: &ArgMatches) {\n         // order to achive some kind of parallelism\n \n         // by default, use a single thread\n-        let num_cpus = match clap_config.value_of(\"threads\") {\n-            Some(threads) => {\n-                let threads: usize = threads\n-                    .parse()\n-                    .expect(&format!(\"Failed to parse '{}' to a digit\", threads));\n-                if threads == 0 {\n-                    // automatic choice\n-                    // Rayon seems to return thread count so half that for core count\n-                    (rayon::current_num_threads() / 2) as usize\n-                } else {\n-                    threads\n-                }\n-            },\n-            // no -j passed, use a single thread\n-            None => 1,\n-        };\n-\n+        let num_cpus = config.max_jobs;\n         let num_crates = crates.len();\n \n         // check all crates (default)\n@@ -612,15 +634,14 @@ pub fn run(clap_config: &ArgMatches) {\n     ices.iter()\n         .for_each(|(cratename, msg)| text.push_str(&format!(\"{}: '{}'\", cratename, msg)));\n \n-    println!(\"Writing logs to {}\", file);\n-    write(&file, text).unwrap();\n+    println!(\"Writing logs to {}\", config.lintcheck_results_path.display());\n+    write(&config.lintcheck_results_path, text).unwrap();\n \n     print_stats(old_stats, new_stats);\n }\n \n /// read the previous stats from the lintcheck-log file\n-fn read_stats_from_file(file_path: &String) -> HashMap<String, usize> {\n-    let file_path = PathBuf::from(file_path);\n+fn read_stats_from_file(file_path: &PathBuf) -> HashMap<String, usize> {\n     let file_content: String = match std::fs::read_to_string(file_path).ok() {\n         Some(content) => content,\n         None => {"}]}