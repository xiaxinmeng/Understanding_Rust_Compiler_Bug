{"sha": "cb5c011670ce8d073d0aae8c45e73c20593bfa11", "node_id": "C_kwDOAAsO6NoAKGNiNWMwMTE2NzBjZThkMDczZDBhYWU4YzQ1ZTczYzIwNTkzYmZhMTE", "commit": {"author": {"name": "yanchith", "email": "yanchi.toth@gmail.com", "date": "2023-06-09T09:22:08Z"}, "committer": {"name": "yanchith", "email": "yanchi.toth@gmail.com", "date": "2023-06-09T09:22:08Z"}, "message": "Merge branch 'master' into binary-heap-ta", "tree": {"sha": "a11259b0350c7bfc4e4c642e8e00b5cd6e901444", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a11259b0350c7bfc4e4c642e8e00b5cd6e901444"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb5c011670ce8d073d0aae8c45e73c20593bfa11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb5c011670ce8d073d0aae8c45e73c20593bfa11", "html_url": "https://github.com/rust-lang/rust/commit/cb5c011670ce8d073d0aae8c45e73c20593bfa11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb5c011670ce8d073d0aae8c45e73c20593bfa11/comments", "author": {"login": "yanchith", "id": 1099245, "node_id": "MDQ6VXNlcjEwOTkyNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/1099245?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yanchith", "html_url": "https://github.com/yanchith", "followers_url": "https://api.github.com/users/yanchith/followers", "following_url": "https://api.github.com/users/yanchith/following{/other_user}", "gists_url": "https://api.github.com/users/yanchith/gists{/gist_id}", "starred_url": "https://api.github.com/users/yanchith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yanchith/subscriptions", "organizations_url": "https://api.github.com/users/yanchith/orgs", "repos_url": "https://api.github.com/users/yanchith/repos", "events_url": "https://api.github.com/users/yanchith/events{/privacy}", "received_events_url": "https://api.github.com/users/yanchith/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yanchith", "id": 1099245, "node_id": "MDQ6VXNlcjEwOTkyNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/1099245?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yanchith", "html_url": "https://github.com/yanchith", "followers_url": "https://api.github.com/users/yanchith/followers", "following_url": "https://api.github.com/users/yanchith/following{/other_user}", "gists_url": "https://api.github.com/users/yanchith/gists{/gist_id}", "starred_url": "https://api.github.com/users/yanchith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yanchith/subscriptions", "organizations_url": "https://api.github.com/users/yanchith/orgs", "repos_url": "https://api.github.com/users/yanchith/repos", "events_url": "https://api.github.com/users/yanchith/events{/privacy}", "received_events_url": "https://api.github.com/users/yanchith/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3", "html_url": "https://github.com/rust-lang/rust/commit/24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3"}, {"sha": "9c843d9fa322596c7d525c78fa89731ecf7afbfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c843d9fa322596c7d525c78fa89731ecf7afbfe", "html_url": "https://github.com/rust-lang/rust/commit/9c843d9fa322596c7d525c78fa89731ecf7afbfe"}], "stats": {"total": 1624806, "additions": 1208997, "deletions": 415809}, "files": [{"sha": "d065fa46469fcf8e619b2de07d522694c7d3b413", "filename": ".editorconfig", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.editorconfig", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.editorconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.editorconfig?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -11,6 +11,7 @@ trim_trailing_whitespace = true\n insert_final_newline = true\n indent_style = space\n indent_size = 4\n+max_line_length = 100\n \n [*.md]\n # double whitespace at end of line\n@@ -19,3 +20,6 @@ trim_trailing_whitespace = false\n \n [*.yml]\n indent_size = 2\n+\n+[Makefile]\n+indent_style = tab"}, {"sha": "19078c1b842aee6eee3292ae8c3d16aa8fd2c61a", "filename": ".git-blame-ignore-revs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.git-blame-ignore-revs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.git-blame-ignore-revs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.git-blame-ignore-revs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -1,6 +1,18 @@\n+# Use `git config blame.ignorerevsfile .git-blame-ignore-revs` to make `git blame` ignore the following commits.\n+\n # format the world\n a06baa56b95674fc626b3c3fd680d6a65357fe60\n # format libcore\n 95e00bfed801e264e9c4ac817004153ca0f19eb6\n # reformat with new rustfmt\n 971c549ca334b7b7406e61e958efcca9c4152822\n+# refactor infcx building\n+283abbf0e7d20176f76006825b5c52e9a4234e4c\n+# format libstd/sys\n+c34fbfaad38cf5829ef5cfe780dc9d58480adeaa\n+# move tests\n+cf2dff2b1e3fa55fa5415d524200070d0d7aacfe\n+# Run rustfmt on bootstrap\n+b39a1d6f1a30ba29f25d7141038b9a5bf0126e36\n+# reorder fluent message files\n+f97fddab91fbf290ea5b691fe355d6f915220b6e"}, {"sha": "d29c15fe712f301a375385e3ad9d624937721371", "filename": ".gitattributes", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -9,7 +9,6 @@\n src/etc/installer/gfx/* binary\n src/vendor/** -text\n Cargo.lock linguist-generated=false\n-config.toml.example linguist-language=TOML\n \n # Older git versions try to fix line endings on images and fonts, this prevents it.\n *.png binary"}, {"sha": "a7b70cea927d0c3b41bbcb4b0cee906be469d192", "filename": ".github/ISSUE_TEMPLATE/diagnostics.md", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3/.github%2FISSUE_TEMPLATE%2Fdiagnostics.md", "raw_url": "https://github.com/rust-lang/rust/raw/24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3/.github%2FISSUE_TEMPLATE%2Fdiagnostics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fdiagnostics.md?ref=24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3", "patch": "@@ -1,46 +0,0 @@\n----\n-name: Diagnostic issue\n-about: Create a bug report or feature request for a change to `rustc`'s error output\n-labels: A-diagnostics, T-compiler\n----\n-<!--\n-Thank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\n-along with any information you feel relevant to replicating the bug.\n-\n-If you cannot produce a minimal reproduction case (something that would work in\n-isolation), please provide the steps or even link to a repository that causes\n-the problematic output to occur.\n--->\n-\n-Given the following code: <!-- Please provide a link to play.rust-lang.org -->\n-\n-```rust\n-<code>\n-```\n-\n-The current output is:\n-\n-```\n-<rustc output>\n-```\n-\n-<!-- The following is not always necessary. -->\n-Ideally the output should look like:\n-\n-```\n-<proposed output>\n-```\n-\n-<!--\n-If the problem is not self-explanatory, please provide a rationale for the\n-change.\n--->\n-\n-<!--\n-If dramatically different output is caused by small changes, consider also\n-adding them here.\n-\n-If you're using the stable version of the compiler, you should also check if the\n-bug also exists in the beta or nightly versions. The output might also be\n-different depending on the Edition.\n--->"}, {"sha": "873fbaaf654fd15a28a131f069144243523eb5fa", "filename": ".github/ISSUE_TEMPLATE/diagnostics.yaml", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.github%2FISSUE_TEMPLATE%2Fdiagnostics.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.github%2FISSUE_TEMPLATE%2Fdiagnostics.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fdiagnostics.yaml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -0,0 +1,65 @@\n+name: Diagnostic issue\n+description: Create a bug report or feature request for a change to `rustc`'s error output\n+labels: [\"A-diagnostics\", \"T-compiler\"]\n+body:\n+  - type: markdown\n+    attributes:\n+      value: |\n+        Thank you for filing a diagnostics bug report! \ud83d\udc1b\n+\n+        Please provide a short summary of the bug, along with any information you feel relevant to replicating the bug.\n+\n+        If you cannot produce a minimal reproduction case (something that would work in isolation), please provide the steps or even link to a repository that causes the problematic output to occur.\n+  - type: textarea\n+    id: code\n+    attributes:\n+      label: Code\n+      description: Please provide code that can reproduce the problem\n+      placeholder: code\n+      render: Rust\n+    validations:\n+      required: true\n+  - type: textarea\n+    id: output\n+    attributes:\n+      label: Current output\n+      description: Please provide the `rustc` output you see\n+      placeholder: rustc output\n+      render: Shell\n+    validations:\n+      required: true\n+  - type: textarea\n+    id: desired-output\n+    attributes:\n+      label: Desired output\n+      description: Please provide what the output *should* be\n+      placeholder: proposed output\n+      render: Shell\n+    validations:\n+      required: false\n+  - type: textarea\n+    id: rationale\n+    attributes:\n+      label: Rationale and extra context\n+      description: If the problem is not self-explanatory, please provide a rationale for the change.\n+    validations:\n+      required: false\n+  - type: textarea\n+    id: other-output\n+    attributes:\n+      label: Other cases\n+      description: If dramatically different output is caused by small changes, consider also adding them here.\n+      render: Rust\n+    validations:\n+      required: false\n+  - type: markdown\n+    attributes:\n+      value: |\n+        If you're using the stable version of the compiler, you should also check if the bug also exists in the beta or nightly versions. The output might also be different depending on the Edition.\n+  - type: textarea\n+    id: extra\n+    attributes:\n+      label: Anything else?\n+      description: If you have more details you want to give us to reproduce this issue, please add it here\n+    validations:\n+      required: false\n\\ No newline at end of file"}, {"sha": "1d93939e2336037818b4965197db80e0f308e584", "filename": ".github/ISSUE_TEMPLATE/documentation.md", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3/.github%2FISSUE_TEMPLATE%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3/.github%2FISSUE_TEMPLATE%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fdocumentation.md?ref=24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3", "patch": "@@ -1,16 +0,0 @@\n----\n-name: Documentation problem\n-about: Create a report for a documentation problem.\n-labels: A-docs\n----\n-<!--\n-Thank you for finding a documentation problem! \ud83d\udcda\n-\n-Documentation problems might be grammatical issues, typos, or unclear wording, please provide details regarding the documentation including where it is present.\n-\n--->\n-\n-### Location\n-\n-### Summary\n-"}, {"sha": "712b32759ae01427d087a47bed286643d6ada6fb", "filename": ".github/ISSUE_TEMPLATE/documentation.yaml", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.github%2FISSUE_TEMPLATE%2Fdocumentation.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.github%2FISSUE_TEMPLATE%2Fdocumentation.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fdocumentation.yaml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -0,0 +1,38 @@\n+name: Documentation problem\n+description: Create a report for a documentation problem.\n+labels: [\"A-docs\"]\n+body:\n+  - type: markdown\n+    attributes:\n+      value: |\n+        Thank you for finding a documentation problem! \ud83d\udcda\n+\n+        Documentation problems might be grammatical issues, typos, or unclear wording, please provide details regarding the documentation including where it is present.\n+\n+        Note: If your issue is for one of these, please use their dedicated issue tracker instead:\n+        - [The Rust Book](https://github.com/rust-lang/book/issues)\n+        - [Rust by Example](https://github.com/rust-lang/rust-by-example/issues)\n+        - [The Edition Guide](https://github.com/rust-lang/edition-guide/issues)\n+        - [The Cargo Book](https://github.com/rust-lang/cargo/issues)\n+        - [The Clippy Book](https://github.com/rust-lang/rust-clippy/issues)\n+        - [The Reference](https://github.com/rust-lang/reference/issues)\n+        - [The Rustonomicon](https://github.com/rust-lang/nomicon/issues)\n+        - [The Embedded Book](https://github.com/rust-embedded/book/issues)\n+\n+        All other documentation issues should be filed here.\n+\n+        Or, if you find an issue related to rustdoc (e.g. doctest, rustdoc UI), please use the bug report or blank issue template instead.\n+\n+  - type: textarea\n+    id: location\n+    attributes:\n+      label: Location\n+    validations:\n+      required: true \n+\n+  - type: textarea\n+    id: summary\n+    attributes:\n+      label: Summary\n+    validations:\n+      required: true \n\\ No newline at end of file"}, {"sha": "2afcd210a6eb7ca5c12fbb2cdc7f912f7183829a", "filename": ".github/ISSUE_TEMPLATE/ice.md", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.github%2FISSUE_TEMPLATE%2Fice.md", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.github%2FISSUE_TEMPLATE%2Fice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fice.md?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -7,9 +7,7 @@ labels: C-bug, I-ICE, T-compiler\n Thank you for finding an Internal Compiler Error! \ud83e\uddca  If possible, try to provide\n a minimal verifiable example. You can read \"Rust Bug Minimization Patterns\" for\n how to create smaller examples.\n-\n http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\n-\n -->\n \n ### Code\n@@ -49,4 +47,3 @@ environment. E.g. `RUST_BACKTRACE=1 cargo build`.\n \n </p>\n </details>\n-"}, {"sha": "7bec05cc575a875239d1ba10cc269c7827e68ada", "filename": ".github/ISSUE_TEMPLATE/ice.yaml", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.github%2FISSUE_TEMPLATE%2Fice.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.github%2FISSUE_TEMPLATE%2Fice.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fice.yaml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -0,0 +1,82 @@\n+name: Internal Compiler Error (for use by automated tooling)\n+description: For now, you'll want to use the other ICE template, as GitHub forms have strict limits on the size of fields so backtraces cannot be pasted directly.\n+labels: [\"C-bug\", \"I-ICE\", \"T-compiler\"]\n+title: \"[ICE]: \"\n+body:\n+  - type: markdown\n+    attributes:\n+      value: |\n+        Thank you for finding an Internal Compiler Error! \ud83e\uddca\n+\n+        If possible, try to provide a minimal verifiable example.\n+\n+        You can read \"[Rust Bug Minimization Patterns](http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/)\" for how to create smaller examples.\n+\n+  - type: textarea\n+    id: code\n+    attributes:\n+      label: Code\n+      description: Please provide code or a link to a repository that can reproduce the problem\n+      placeholder: code\n+      render: Rust\n+    validations:\n+      required: false\n+\n+  - type: checkboxes\n+    attributes:\n+      label: Affected release channels\n+      description: If you're using the stable version of the compiler, you should also check if the bug also exists in the beta or nightly versions\n+      options:\n+        - label: Previous Stable\n+          required: false\n+        - label: Current Stable\n+          required: false\n+        - label: Current Beta\n+          required: false\n+        - label: Current Nightly\n+          required: false\n+\n+  - type: textarea\n+    id: version\n+    attributes:\n+      label: Rust Version\n+      description: Please provide the `rustc` version, `rustc --version --verbose`\n+      placeholder: |\n+        $ rustc --version --verbose\n+        rustc 1.XX.Y (SHORTHASH DATE)\n+        binary: rustc\n+        commit-hash: LONGHASHVALUE\n+        commit-date: DATE\n+        host: PLATFORMTRIPLE\n+        release: 1.XX.Y\n+        LLVM version: XX.YY.ZZ\n+      render: Shell\n+    validations:\n+      required: true\n+\n+  - type: textarea\n+    id: output\n+    attributes:\n+      label: Current error output\n+      description: Please provide the `rustc` output you see\n+      placeholder: output\n+      render: Shell\n+    validations:\n+      required: false\n+\n+  - type: textarea\n+    id: backtrace\n+    attributes:\n+      label: Backtrace\n+      description: Include a backtrace in the code block by setting `RUST_BACKTRACE=full` in your environment, e.g. `RUST_BACKTRACE=full cargo build`\n+      render: Shell\n+    validations:\n+      required: true\n+\n+  - type: textarea\n+    id: extra\n+    attributes:\n+      label: Anything else?\n+      description: If you have more details you want to give us to reproduce this issue, please add it here\n+    validations:\n+      required: false"}, {"sha": "934312662beb66fe5f3f9e07a5d59f1600b0238e", "filename": ".github/ISSUE_TEMPLATE/library_tracking_issue.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.github%2FISSUE_TEMPLATE%2Flibrary_tracking_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.github%2FISSUE_TEMPLATE%2Flibrary_tracking_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Flibrary_tracking_issue.md?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -12,7 +12,7 @@ Tracking issues are for tracking a feature from implementation to stabilization.\n Make sure to include the relevant RFC for the feature if it has one.\n \n If the new feature is small, it may be fine to skip the RFC process. In that\n-case, you can use use `issue = \"none\"` in your initial implementation PR. The\n+case, you can use `issue = \"none\"` in your initial implementation PR. The\n reviewer will ask you to open a tracking issue if they agree your feature can be\n added without an RFC.\n -->\n@@ -65,7 +65,7 @@ the rfcbot will ask all the team members to verify they agree with\n stabilization. Once enough members agree and there are no concerns, the final\n comment period begins: this issue will be marked as such and will be listed\n in the next This Week in Rust newsletter. If no blocking concerns are raised in\n-that period of 10 days, a stabilzation PR can be opened by anyone.\n+that period of 10 days, a stabilization PR can be opened by anyone.\n -->\n \n ### Unresolved Questions"}, {"sha": "210ec72a11e0bc02bed73d36ccda1ec44e67b025", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 135, "deletions": 92, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -25,31 +25,39 @@ name: CI\n   pull_request:\n     branches:\n       - \"**\"\n+permissions:\n+  contents: read\n defaults:\n   run:\n     shell: bash\n jobs:\n   pr:\n-    name: PR\n+    permissions:\n+      actions: write\n+    name: \"PR - ${{ matrix.name }}\"\n     env:\n       CI_JOB_NAME: \"${{ matrix.name }}\"\n+      CARGO_REGISTRIES_CRATES_IO_PROTOCOL: sparse\n       SCCACHE_BUCKET: rust-lang-ci-sccache2\n       TOOLSTATE_REPO: \"https://github.com/rust-lang-nursery/rust-toolstate\"\n       CACHE_DOMAIN: ci-caches.rust-lang.org\n     if: \"github.event_name == 'pull_request'\"\n+    continue-on-error: \"${{ matrix.name == 'mingw-check-tidy' }}\"\n     strategy:\n       matrix:\n         include:\n           - name: mingw-check\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n-          - name: x86_64-gnu-llvm-12\n-            os: ubuntu-20.04-xl\n+          - name: mingw-check-tidy\n+            os: ubuntu-20.04-16core-64gb\n+            env: {}\n+          - name: x86_64-gnu-llvm-14\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: x86_64-gnu-tools\n-            env:\n-              CI_ONLY_WHEN_SUBMODULES_CHANGED: 1\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n+            env: {}\n     timeout-minutes: 600\n     runs-on: \"${{ matrix.os }}\"\n     steps:\n@@ -79,19 +87,19 @@ jobs:\n         uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n         with:\n           github_token: \"${{ secrets.github_token }}\"\n-        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try' && github.ref != 'refs/heads/try-perf'\"\n       - name: collect CPU statistics\n         run: src/ci/scripts/collect-cpu-stats.sh\n         if: success() && !env.SKIP_JOB\n       - name: show the current environment\n         run: src/ci/scripts/dump-environment.sh\n         if: success() && !env.SKIP_JOB\n-      - name: install awscli\n-        run: src/ci/scripts/install-awscli.sh\n-        if: success() && !env.SKIP_JOB\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n         if: success() && !env.SKIP_JOB\n+      - name: select Xcode\n+        run: src/ci/scripts/select-xcode.sh\n+        if: success() && !env.SKIP_JOB\n       - name: install clang\n         run: src/ci/scripts/install-clang.sh\n         if: success() && !env.SKIP_JOB\n@@ -142,16 +150,20 @@ jobs:\n           AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n         if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n   auto:\n-    name: auto\n+    permissions:\n+      actions: write\n+    name: \"auto - ${{ matrix.name }}\"\n     env:\n       CI_JOB_NAME: \"${{ matrix.name }}\"\n+      CARGO_REGISTRIES_CRATES_IO_PROTOCOL: sparse\n       SCCACHE_BUCKET: rust-lang-ci-sccache2\n       DEPLOY_BUCKET: rust-lang-ci2\n       TOOLSTATE_REPO: \"https://github.com/rust-lang-nursery/rust-toolstate\"\n       TOOLSTATE_ISSUES_API_URL: \"https://api.github.com/repos/rust-lang/rust/issues\"\n       TOOLSTATE_PUBLISH: 1\n       CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZI5DHEBFL\n       ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZN24CBO55\n+      AWS_REGION: us-west-1\n       CACHE_DOMAIN: ci-caches.rust-lang.org\n     if: \"github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\"\n     strategy:\n@@ -163,162 +175,180 @@ jobs:\n               - ARM64\n               - linux\n           - name: arm-android\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: armhf-gnu\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-aarch64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-android\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-arm-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-armhf-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-armv7-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-i586-gnu-i586-i686-musl\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-i686-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n+            env: {}\n+          - name: dist-loongarch64-linux\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-mips-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-mips64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-mips64el-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-mipsel-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-powerpc-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-powerpc64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-powerpc64le-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-riscv64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-s390x-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-various-1\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-various-2\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-x86_64-freebsd\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-x86_64-illumos\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-x86_64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-x86_64-linux-alt\n             env:\n               IMAGE: dist-x86_64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n           - name: dist-x86_64-musl\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-x86_64-netbsd\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: i686-gnu\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: i686-gnu-nopt\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: mingw-check\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-4core-16gb\n             env: {}\n           - name: test-various\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: wasm32\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: x86_64-gnu\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-4core-16gb\n             env: {}\n           - name: x86_64-gnu-stable\n             env:\n               IMAGE: x86_64-gnu\n               RUST_CI_OVERRIDE_RELEASE_CHANNEL: stable\n               CI_ONLY_WHEN_CHANNEL: nightly\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-4core-16gb\n           - name: x86_64-gnu-aux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-4core-16gb\n             env: {}\n           - name: x86_64-gnu-debug\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: x86_64-gnu-distcheck\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n-          - name: x86_64-gnu-llvm-12\n+          - name: x86_64-gnu-llvm-16\n+            env:\n+              RUST_BACKTRACE: 1\n+            os: ubuntu-20.04-8core-32gb\n+          - name: x86_64-gnu-llvm-15\n             env:\n               RUST_BACKTRACE: 1\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n+          - name: x86_64-gnu-llvm-14\n+            env:\n+              RUST_BACKTRACE: 1\n+            os: ubuntu-20.04-8core-32gb\n+          - name: x86_64-gnu-llvm-14-stage1\n+            env:\n+              RUST_BACKTRACE: 1\n+            os: ubuntu-20.04-8core-32gb\n           - name: x86_64-gnu-nopt\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-4core-16gb\n             env: {}\n           - name: x86_64-gnu-tools\n             env:\n               DEPLOY_TOOLSTATES_JSON: toolstates-linux.json\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-8core-32gb\n           - name: dist-x86_64-apple\n             env:\n-              SCRIPT: \"./x.py dist --host=x86_64-apple-darwin --target=x86_64-apple-darwin\"\n-              RUST_CONFIGURE_ARGS: \"--enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n+              SCRIPT: \"./x.py dist bootstrap --include-default-paths --host=x86_64-apple-darwin --target=x86_64-apple-darwin\"\n+              RUST_CONFIGURE_ARGS: \"--enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false --set rust.lto=thin\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.7\n+              SELECT_XCODE: /Applications/Xcode_13.4.1.app\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n             os: macos-latest\n           - name: dist-apple-various\n             env:\n-              SCRIPT: \"./x.py dist --host='' --target=aarch64-apple-ios,x86_64-apple-ios,aarch64-apple-ios-sim\"\n+              SCRIPT: \"./x.py dist bootstrap --include-default-paths --host='' --target=aarch64-apple-ios,x86_64-apple-ios,aarch64-apple-ios-sim\"\n               RUST_CONFIGURE_ARGS: \"--enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.7\n+              SELECT_XCODE: /Applications/Xcode_13.4.1.app\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n             os: macos-latest\n           - name: dist-x86_64-apple-alt\n             env:\n-              SCRIPT: \"./x.py dist\"\n+              SCRIPT: \"./x.py dist bootstrap --include-default-paths\"\n               RUST_CONFIGURE_ARGS: \"--enable-extended --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.7\n+              SELECT_XCODE: /Applications/Xcode_13.4.1.app\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n             os: macos-latest\n           - name: x86_64-apple-1\n             env:\n-              SCRIPT: \"./x.py --stage 2 test --exclude src/test/ui --exclude src/test/rustdoc --exclude src/test/run-make-fulldeps\"\n+              SCRIPT: \"./x.py --stage 2 test --exclude tests/ui --exclude tests/rustdoc --exclude tests/run-make-fulldeps\"\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.8\n@@ -329,7 +359,7 @@ jobs:\n             os: macos-latest\n           - name: x86_64-apple-2\n             env:\n-              SCRIPT: \"./x.py --stage 2 test src/test/ui src/test/rustdoc src/test/run-make-fulldeps\"\n+              SCRIPT: \"./x.py --stage 2 test tests/ui tests/rustdoc tests/run-make-fulldeps\"\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.8\n@@ -340,9 +370,10 @@ jobs:\n             os: macos-latest\n           - name: dist-aarch64-apple\n             env:\n-              SCRIPT: \"./x.py dist --stage 2\"\n+              SCRIPT: \"./x.py dist bootstrap --include-default-paths --stage 2\"\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --host=aarch64-apple-darwin --target=aarch64-apple-darwin --enable-full-tools --enable-sanitizers --enable-profiler --disable-docs --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              SELECT_XCODE: /Applications/Xcode_13.4.1.app\n               USE_XCODE_CLANG: 1\n               MACOSX_DEPLOYMENT_TARGET: 11.0\n               MACOSX_STD_DEPLOYMENT_TARGET: 11.0\n@@ -356,95 +387,101 @@ jobs:\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-profiler\"\n               SCRIPT: make ci-subset-1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: x86_64-msvc-2\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-profiler\"\n               SCRIPT: make ci-subset-2\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: i686-msvc-1\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-msvc\"\n               SCRIPT: make ci-subset-1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: i686-msvc-2\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-msvc\"\n               SCRIPT: make ci-subset-2\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: x86_64-msvc-cargo\n             env:\n               SCRIPT: python x.py --stage 2 test src/tools/cargotest src/tools/cargo\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-lld\"\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: x86_64-msvc-tools\n             env:\n               SCRIPT: src/ci/docker/host-x86_64/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstate/toolstates.json windows\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstate/toolstates.json\"\n               DEPLOY_TOOLSTATES_JSON: toolstates-windows.json\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: i686-mingw-1\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu\"\n               SCRIPT: make ci-mingw-subset-1\n+              NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: i686-mingw-2\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu\"\n               SCRIPT: make ci-mingw-subset-2\n+              NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: x86_64-mingw-1\n             env:\n               SCRIPT: make ci-mingw-subset-1\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-profiler\"\n+              NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: x86_64-mingw-2\n             env:\n               SCRIPT: make ci-mingw-subset-2\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-profiler\"\n+              NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: dist-x86_64-msvc\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=x86_64-pc-windows-msvc --target=x86_64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n-              SCRIPT: PGO_HOST=x86_64-pc-windows-msvc src/ci/pgo.sh python x.py dist\n+              SCRIPT: PGO_HOST=x86_64-pc-windows-msvc python src/ci/stage-build.py python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: dist-i686-msvc\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-msvc --host=i686-pc-windows-msvc --target=i686-pc-windows-msvc,i586-pc-windows-msvc --enable-full-tools --enable-profiler\"\n-              SCRIPT: python x.py dist\n+              SCRIPT: python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: dist-aarch64-msvc\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=aarch64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n-              SCRIPT: python x.py dist\n-              DIST_REQUIRE_ALL_TOOLS: 0\n+              SCRIPT: python x.py dist bootstrap --include-default-paths\n+              DIST_REQUIRE_ALL_TOOLS: 1\n               WINDOWS_SDK_20348_HACK: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: dist-i686-mingw\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu --enable-full-tools --enable-profiler\"\n-              SCRIPT: python x.py dist\n+              NO_DOWNLOAD_CI_LLVM: 1\n+              SCRIPT: python x.py dist bootstrap --include-default-paths\n               CUSTOM_MINGW: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: dist-x86_64-mingw\n             env:\n-              SCRIPT: python x.py dist\n+              SCRIPT: python x.py dist bootstrap --include-default-paths\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-full-tools --enable-profiler\"\n+              NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: dist-x86_64-msvc-alt\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\"\n-              SCRIPT: python x.py dist\n-            os: windows-latest-xl\n+              SCRIPT: python x.py dist bootstrap --include-default-paths\n+            os: windows-2019-8core-32gb\n     timeout-minutes: 600\n     runs-on: \"${{ matrix.os }}\"\n     steps:\n@@ -474,19 +511,19 @@ jobs:\n         uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n         with:\n           github_token: \"${{ secrets.github_token }}\"\n-        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try' && github.ref != 'refs/heads/try-perf'\"\n       - name: collect CPU statistics\n         run: src/ci/scripts/collect-cpu-stats.sh\n         if: success() && !env.SKIP_JOB\n       - name: show the current environment\n         run: src/ci/scripts/dump-environment.sh\n         if: success() && !env.SKIP_JOB\n-      - name: install awscli\n-        run: src/ci/scripts/install-awscli.sh\n-        if: success() && !env.SKIP_JOB\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n         if: success() && !env.SKIP_JOB\n+      - name: select Xcode\n+        run: src/ci/scripts/select-xcode.sh\n+        if: success() && !env.SKIP_JOB\n       - name: install clang\n         run: src/ci/scripts/install-clang.sh\n         if: success() && !env.SKIP_JOB\n@@ -537,23 +574,28 @@ jobs:\n           AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n         if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n   try:\n-    name: try\n+    permissions:\n+      actions: write\n+    name: \"try - ${{ matrix.name }}\"\n     env:\n+      DIST_TRY_BUILD: 1\n       CI_JOB_NAME: \"${{ matrix.name }}\"\n+      CARGO_REGISTRIES_CRATES_IO_PROTOCOL: sparse\n       SCCACHE_BUCKET: rust-lang-ci-sccache2\n       DEPLOY_BUCKET: rust-lang-ci2\n       TOOLSTATE_REPO: \"https://github.com/rust-lang-nursery/rust-toolstate\"\n       TOOLSTATE_ISSUES_API_URL: \"https://api.github.com/repos/rust-lang/rust/issues\"\n       TOOLSTATE_PUBLISH: 1\n       CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZI5DHEBFL\n       ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZN24CBO55\n+      AWS_REGION: us-west-1\n       CACHE_DOMAIN: ci-caches.rust-lang.org\n     if: \"github.event_name == 'push' && (github.ref == 'refs/heads/try' || github.ref == 'refs/heads/try-perf') && github.repository == 'rust-lang-ci/rust'\"\n     strategy:\n       matrix:\n         include:\n           - name: dist-x86_64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n     timeout-minutes: 600\n     runs-on: \"${{ matrix.os }}\"\n@@ -584,19 +626,19 @@ jobs:\n         uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n         with:\n           github_token: \"${{ secrets.github_token }}\"\n-        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try' && github.ref != 'refs/heads/try-perf'\"\n       - name: collect CPU statistics\n         run: src/ci/scripts/collect-cpu-stats.sh\n         if: success() && !env.SKIP_JOB\n       - name: show the current environment\n         run: src/ci/scripts/dump-environment.sh\n         if: success() && !env.SKIP_JOB\n-      - name: install awscli\n-        run: src/ci/scripts/install-awscli.sh\n-        if: success() && !env.SKIP_JOB\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n         if: success() && !env.SKIP_JOB\n+      - name: select Xcode\n+        run: src/ci/scripts/select-xcode.sh\n+        if: success() && !env.SKIP_JOB\n       - name: install clang\n         run: src/ci/scripts/install-clang.sh\n         if: success() && !env.SKIP_JOB\n@@ -657,6 +699,7 @@ jobs:\n       TOOLSTATE_PUBLISH: 1\n       CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZI5DHEBFL\n       ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZN24CBO55\n+      AWS_REGION: us-west-1\n       CACHE_DOMAIN: ci-caches.rust-lang.org\n     if: \"github.event_name == 'push' && github.ref == 'refs/heads/master' && github.repository == 'rust-lang-ci/rust'\"\n     steps:"}, {"sha": "485968d9c56ff5a3a37c74b331704914da82011c", "filename": ".gitignore", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -21,12 +21,13 @@ Session.vim\n .project\n .favorites.json\n .settings/\n+.vs/\n \n ## Tool\n .valgrindrc\n .cargo\n # Included because it is part of the test case\n-!/src/test/run-make/thumb-none-qemu/example/.cargo\n+!/tests/run-make/thumb-none-qemu/example/.cargo\n \n ## Configuration\n /config.toml\n@@ -41,10 +42,13 @@ no_llvm_build\n /inst/\n /llvm/\n /mingw-build/\n-/build/\n+build/\n+!/compiler/rustc_mir_build/src/build/\n+/build-rust-analyzer/\n /dist/\n /unicode-downloads\n /target\n+/src/bootstrap/target\n /src/tools/x/target\n # Created by default with `src/ci/docker/run.sh`\n /obj/\n@@ -72,6 +76,6 @@ package-lock.json\n package.json\n \n ## Rustdoc GUI tests\n-src/test/rustdoc-gui/src/**.lock\n+tests/rustdoc-gui/src/**.lock\n \n # Before adding new lines, see the comment at the top."}, {"sha": "6b7160bfe1530994fc1296e13b9e1a14bb7a8cb8", "filename": ".gitmodules", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -1,6 +1,3 @@\n-[submodule \"src/rust-installer\"]\n-\tpath = src/tools/rust-installer\n-\turl = https://github.com/rust-lang/rust-installer.git\n [submodule \"src/doc/nomicon\"]\n \tpath = src/doc/nomicon\n \turl = https://github.com/rust-lang/nomicon.git\n@@ -13,12 +10,6 @@\n [submodule \"src/doc/book\"]\n \tpath = src/doc/book\n \turl = https://github.com/rust-lang/book.git\n-[submodule \"src/tools/rls\"]\n-\tpath = src/tools/rls\n-\turl = https://github.com/rust-lang/rls.git\n-[submodule \"src/tools/miri\"]\n-\tpath = src/tools/miri\n-\turl = https://github.com/rust-lang/miri.git\n [submodule \"src/doc/rust-by-example\"]\n \tpath = src/doc/rust-by-example\n \turl = https://github.com/rust-lang/rust-by-example.git\n@@ -34,13 +25,10 @@\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n-\tbranch = rustc/14.0-2022-06-20\n+\tbranch = rustc/16.0-2023-06-05\n [submodule \"src/doc/embedded-book\"]\n \tpath = src/doc/embedded-book\n \turl = https://github.com/rust-embedded/book.git\n-[submodule \"src/tools/rust-analyzer\"]\n-\tpath = src/tools/rust-analyzer\n-\turl = https://github.com/rust-analyzer/rust-analyzer.git\n [submodule \"library/backtrace\"]\n \tpath = library/backtrace\n \turl = https://github.com/rust-lang/backtrace-rs.git"}, {"sha": "92be31747501e83187c06706d3d5be1909f331a2", "filename": ".mailmap", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -15,6 +15,7 @@ Adrien T\u00e9tar <adri-from-59@hotmail.fr>\n Ahmed Charles <ahmedcharles@gmail.com> <acharles@outlook.com>\n Alan Egerton <eggyal@gmail.com>\n Alan Stoate <alan.stoate@gmail.com>\n+Albert Larsan <albert.larsan@gmail.com> <74931857+albertlarsan68@users.noreply.github.com>\n Alessandro Decina <alessandro.d@gmail.com>\n Alex Burka <durka42+github@gmail.com> Alex Burka <aburka@seas.upenn.edu>\n Alex Hansen <ahansen2@trinity.edu>\n@@ -28,6 +29,8 @@ Alexander Ronald Altman <alexanderaltman@me.com>\n Alexandre Martin <martin.alex32@hotmail.fr>\n Alexis Beingessner <a.beingessner@gmail.com>\n Alfie John <alfie@alfie.wtf> Alfie John <alfiej@fastmail.fm>\n+Alona Enraght-Moony <code@alona.page> <nixon.emoony@gmail.com>\n+Alona Enraght-Moony <code@alona.page> <nixon@caminus.local>\n Amos Onn <amosonn@gmail.com>\n Ana-Maria Mihalache <mihalacheana.maria@yahoo.com>\n Anatoly Ikorsky <aikorsky@gmail.com>\n@@ -73,6 +76,8 @@ Bj\u00f6rn Steinbrink <bsteinbr@gmail.com> <B.Steinbrink@gmx.de>\n blake2-ppc <ulrik.sverdrup@gmail.com> <blake2-ppc>\n boolean_coercion <booleancoercion@gmail.com>\n Boris Egorov <jightuse@gmail.com> <egorov@linux.com>\n+bors <bors@rust-lang.org> bors[bot] <26634292+bors[bot]@users.noreply.github.com>\n+bors <bors@rust-lang.org> bors[bot] <bors[bot]@users.noreply.github.com>\n Braden Nelson <moonheart08@users.noreply.github.com>\n Brandon Sanderson <singingboyo@gmail.com> Brandon Sanderson <singingboyo@hotmail.com>\n Brett Cannon <brett@python.org> Brett Cannon <brettcannon@users.noreply.github.com>\n@@ -97,6 +102,7 @@ Carol Willing <carolcode@willingconsulting.com>\n Chandler Deng <chandde@microsoft.com>\n Charles Lew <crlf0710@gmail.com> CrLF0710 <crlf0710@gmail.com>\n Chris C Cerami <chrisccerami@users.noreply.github.com> Chris C Cerami <chrisccerami@gmail.com>\n+Chris Denton <chris@chrisdenton.dev> Chris Denton <ChrisDenton@users.noreply.github.com>\n Chris Gregory <czipperz@gmail.com>\n Chris Pardy <chrispardy36@gmail.com>\n Chris Pressey <cpressey@gmail.com>\n@@ -139,6 +145,10 @@ David Ross <daboross@daboross.net>\n David Wood <david@davidtw.co> <david.wood@huawei.com>\n Deadbeef <ent3rm4n@gmail.com>\n Deadbeef <ent3rm4n@gmail.com> <fee1-dead-beef@protonmail.com>\n+dependabot[bot] <dependabot[bot]@users.noreply.github.com> <27856297+dependabot-preview[bot]@users.noreply.github.com>\n+dependabot[bot] <dependabot[bot]@users.noreply.github.com> <49699333+dependabot[bot]@users.noreply.github.com>\n+dependabot[bot] <dependabot[bot]@users.noreply.github.com> <dependabot-preview[bot]@users.noreply.github.com>\n+dependabot[bot] <dependabot[bot]@users.noreply.github.com> <support@dependabot.com>\n Derek Chiang <derekchiang93@gmail.com> Derek Chiang (Enchi Jiang) <derekchiang93@gmail.com>\n DeveloperC <DeveloperC@protonmail.com>\n Devin Ragotzy <devin.ragotzy@gmail.com>\n@@ -159,6 +169,7 @@ Eduard-Mihai Burtescu <edy.burt@gmail.com>\n Eduardo Bautista <me@eduardobautista.com> <=>\n Eduardo Bautista <me@eduardobautista.com> <mail@eduardobautista.com>\n Eduardo Broto <ebroto@tutanota.com>\n+Edward Shen <code@eddie.sh> <xes@meta.com>\n Elliott Slaughter <elliottslaughter@gmail.com> <eslaughter@mozilla.com>\n Elly Fong-Jones <elly@leptoquark.net>\n Eric Holk <eric.holk@gmail.com> <eholk@cs.indiana.edu>\n@@ -217,7 +228,7 @@ Hsiang-Cheng Yang <rick68@users.noreply.github.com>\n Ian Jackson <ijackson@chiark.greenend.org.uk> <ian.jackson@citrix.com>\n Ian Jackson <ijackson@chiark.greenend.org.uk> <ijackson+github@slimy.greenend.org.uk>\n Ian Jackson <ijackson@chiark.greenend.org.uk> <iwj@xenproject.org>\n-Ibraheem Ahmed <ibrah1440@gmail.com>\n+Ibraheem Ahmed <ibraheem@ibraheem.ca> <ibrah1440@gmail.com>\n Ilyong Cho <ilyoan@gmail.com>\n inquisitivecrystal <22333129+inquisitivecrystal@users.noreply.github.com>\n Irina Popa <irinagpopa@gmail.com>\n@@ -229,7 +240,7 @@ Jacob <jacob.macritchie@gmail.com>\n Jacob Greenfield <xales@naveria.com>\n Jacob Pratt <jacob@jhpratt.dev> <the.z.cuber@gmail.com>\n Jake Vossen <jake@vossen.dev>\n-Jakob Degen <jakob@degen.com>\n+Jakob Degen <jakob.e.degen@gmail.com> <jakob@degen.com>\n Jakob Lautrup Nysom <jako3047@gmail.com>\n Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com>\n Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakub.bukaj@yahoo.com>\n@@ -318,6 +329,7 @@ Lennart Kudling <github@kudling.de>\n L\u00e9o Lanteri Thauvin <leseulartichaut@gmail.com>\n L\u00e9o Lanteri Thauvin <leseulartichaut@gmail.com> <38361244+LeSeulArtichaut@users.noreply.github.com>\n L\u00e9o Testard <leo.testard@gmail.com>\n+Le\u00f3n Orell Valerian Liehr <me@fmease.dev> <liehr.exchange@gmx.net>\n Leonardo Yvens <leoyvens@gmail.com>\n Liigo Zhuang <liigo@qq.com>\n Lily Ballard <lily@ballards.net> <kevin@sb.org>\n@@ -396,28 +408,32 @@ Nathaniel Herman <nherman@post.harvard.edu> Nathaniel Herman <nherman@college.ha\n Neil Pankey <npankey@gmail.com> <neil@wire.im>\n Ngo Iok Ui (Wu Yu Wei) <wusyong9104@gmail.com>\n Nicholas Baron <nicholas.baron.ten@gmail.com>\n+Nicholas Bishop <nbishop@nbishop.net> <nicholasbishop@gmail.com>\n+Nicholas Bishop <nbishop@nbishop.net> <nicholasbishop@google.com>\n+Nicholas Nethercote <n.nethercote@gmail.com> <nnethercote@apple.com>\n+Nicholas Nethercote <n.nethercote@gmail.com> <nnethercote@mozilla.com>\n Nick Platt <platt.nicholas@gmail.com>\n Niclas Schwarzlose <15schnic@gmail.com>\n Nicolas Abram <abramlujan@gmail.com>\n Nicole Mazzuca <npmazzuca@gmail.com>\n+Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> nils <48135649+Nilstrieb@users.noreply.github.com>\n Nif Ward <nif.ward@gmail.com>\n Nika Layzell <nika@thelayzells.com> <michael@thelayzells.com>\n-Nixon Enraght-Moony <nixon.emoony@gmail.com>\n NODA Kai <nodakai@gmail.com>\n oliver <16816606+o752d@users.noreply.github.com>\n Oliver Middleton <olliemail27@gmail.com> <ollie27@users.noreply.github.com>\n-Oliver Scherer <oliver.schneider@kit.edu> <git-spam-no-reply9815368754983@oli-obk.de>\n-Oliver Scherer <oliver.schneider@kit.edu> <git-spam9815368754983@oli-obk.de>\n-Oliver Scherer <oliver.schneider@kit.edu> <github333195615777966@oli-obk.de>\n-Oliver Scherer <oliver.schneider@kit.edu> <rust19446194516@oli-obk.de>\n-Oliver Scherer <oliver.schneider@kit.edu> <git-no-reply-9879165716479413131@oli-obk.de>\n-Oliver Scherer <oliver.schneider@kit.edu> <git1984941651981@oli-obk.de>\n-Oliver Scherer <oliver.schneider@kit.edu> <github35764891676564198441@oli-obk.de>\n-Oliver Scherer <oliver.schneider@kit.edu> <github6541940@oli-obk.de>\n-Oliver Scherer <oliver.schneider@kit.edu> <oli-obk@users.noreply.github.com>\n-Oliver Scherer <oliver.schneider@kit.edu> <public.oliver.schneider@kit.edu>\n-Oliver Scherer <oliver.schneider@kit.edu> <obk8176014uqher834@olio-obk.de>\n-Oliver Scherer <oliver.schneider@kit.edu>\n+Oliver Scherer <oli-obk@users.noreply.github.com> <git-spam-no-reply9815368754983@oli-obk.de>\n+Oliver Scherer <oli-obk@users.noreply.github.com> <git-spam9815368754983@oli-obk.de>\n+Oliver Scherer <oli-obk@users.noreply.github.com> <github333195615777966@oli-obk.de>\n+Oliver Scherer <oli-obk@users.noreply.github.com> <rust19446194516@oli-obk.de>\n+Oliver Scherer <oli-obk@users.noreply.github.com> <git-no-reply-9879165716479413131@oli-obk.de>\n+Oliver Scherer <oli-obk@users.noreply.github.com> <git1984941651981@oli-obk.de>\n+Oliver Scherer <oli-obk@users.noreply.github.com> <github35764891676564198441@oli-obk.de>\n+Oliver Scherer <oli-obk@users.noreply.github.com> <github6541940@oli-obk.de>\n+Oliver Scherer <oli-obk@users.noreply.github.com> <public.oliver.schneider@kit.edu>\n+Oliver Scherer <oli-obk@users.noreply.github.com> <oliver.schneider@kit.edu>\n+Oliver Scherer <oli-obk@users.noreply.github.com> <obk8176014uqher834@olio-obk.de>\n+Oliver Scherer <oli-obk@users.noreply.github.com>\n \u00d6mer Sinan A\u011facan <omeragacan@gmail.com>\n Ophir LOJKINE <pere.jobs@gmail.com>\n O\u017ebolt Menegatti <ozbolt.menegatti@gmail.com> gareins <ozbolt.menegatti@gmail.com>\n@@ -522,6 +538,7 @@ Tomas Koutsky <tomas@stepnivlk.net>\n Torsten Weber <TorstenWeber12@gmail.com>\n Torsten Weber <TorstenWeber12@gmail.com> <torstenweber12@gmail.com>\n Trevor Spiteri <tspiteri@ieee.org> <trevor.spiteri@um.edu.mt>\n+Tshepang Mbambo <tshepang@gmail.com>\n Ty Overby <ty@pre-alpha.com>\n Tyler Mandry <tmandry@gmail.com> <tmandry@google.com>\n Tyler Ruckinger <t.ruckinger@gmail.com>"}, {"sha": "9a59f455fe9afdf4156bb99f3f54bf07d2df6b59", "filename": ".reuse/dep5", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.reuse%2Fdep5", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/.reuse%2Fdep5", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.reuse%2Fdep5?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -0,0 +1,99 @@\n+# WARNING: this metadata is currently incomplete, do not rely on it yet.\n+\n+Format: https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/\n+Files-Excluded:\n+ src/llvm-project\n+\n+# Note that we're explicitly listing the individual files at the root of the\n+# repository rather than just having `Files: *`. This is explicitly done to\n+# help downstream forks of the Rust compiler: this way, the files they add\n+# won't be automatically marked as authored by the Rust project.\n+Files: compiler/*\n+       library/*\n+       tests/*\n+       src/*\n+       .github/*\n+       Cargo.lock\n+       Cargo.toml\n+       CODE_OF_CONDUCT.md\n+       config.example.toml\n+       configure\n+       CONTRIBUTING.md\n+       COPYRIGHT\n+       LICENSE-APACHE\n+       LICENSE-MIT\n+       README.md\n+       RELEASES.md\n+       rustfmt.toml\n+       triagebot.toml\n+       x\n+       x.ps1\n+       x.py\n+       .editorconfig\n+       .git-blame-ignore-revs\n+       .gitattributes\n+       .gitignore\n+       .gitmodules\n+       .mailmap\n+Copyright: The Rust Project Developers (see https://thanks.rust-lang.org)\n+License: MIT or Apache-2.0\n+\n+Files: compiler/rustc_apfloat/*\n+Copyright: LLVM APFloat authors\n+           The Rust Project Developers (see https://thanks.rust-lang.org)\n+License: NCSA AND (MIT OR Apache-2.0)\n+\n+Files: compiler/rustc_codegen_cranelift/src/cranelift_native.rs\n+Copyright: The Cranelift Project Developers\n+           The Rust Project Developers (see https://thanks.rust-lang.org)\n+License: Apache-2.0 WITH LLVM-exception AND (Apache-2.0 OR MIT)\n+\n+Files: compiler/rustc_llvm/llvm-wrapper/SymbolWrapper.cpp\n+Copyright: LLVM authors\n+           The Rust Project Developers (see https://thanks.rust-lang.org)\n+License: Apache-2.0 WITH LLVM-exception AND (Apache-2.0 OR MIT)\n+\n+Files: library/core/src/unicode/unicode_data.rs\n+Copyright: 1991-2022 Unicode, Inc. All rights reserved.\n+License: Unicode-DFS-2016\n+\n+Files: library/std/src/sync/mpmc/*\n+Copyright: 2019 The Crossbeam Project Developers\n+           The Rust Project Developers (see https://thanks.rust-lang.org)\n+License: MIT OR Apache-2.0\n+\n+Files: library/std/src/sys/unix/locks/fuchsia_mutex.rs\n+Copyright: 2016 The Fuchsia Authors\n+           The Rust Project Developers (see https://thanks.rust-lang.org)\n+License: BSD-2-Clause AND (MIT OR Apache-2.0)\n+\n+Files: src/test/rustdoc/auxiliary/enum-primitive.rs\n+Copyright: 2015 Anders Kaseorg <andersk@mit.edu>\n+License: MIT\n+\n+Files: src/librustdoc/html/static/fonts/FiraSans*\n+Copyright: 2014, Mozilla Foundation\n+           2014, Telefonica S.A.\n+License: OFL-1.1\n+\n+Files: src/librustdoc/html/static/fonts/NanumBarun*\n+Copyright: 2010 NAVER Corporation\n+License: OFL-1.1\n+\n+Files: src/librustdoc/html/static/fonts/SourceCodePro*\n+       src/librustdoc/html/static/fonts/SourceSerif4*\n+Copyright: 2010, 2012, 2014-2023, Adobe Systems Incorporated\n+License: OFL-1.1\n+\n+Files: src/librustdoc/html/static/css/normalize.css\n+Copyright: Nicolas Gallagher and Jonathan Neal\n+License: MIT\n+\n+Files: src/librustdoc/html/static/css/themes/ayu.css\n+Copyright: Ike Ku, Jessica Stokes, Leon Guan\n+           The Rust Project Developers (see https://thanks.rust-lang.org)\n+License: MIT OR Apache-2.0\n+\n+Files: src/doc/rustc-dev-guide/mermaid.min.js\n+Copyright: Knut Sveidqvist\n+License: MIT"}, {"sha": "dfaa70bb9db005a2d79c5064f57d95640e2af079", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -8,9 +8,9 @@ members](https://rust-lang.zulipchat.com/#narrow/stream/122652-new-members)\n Zulip stream. We have lots of docs below of how to get started on your own, but\n the Zulip stream is the best place to *ask* for help.\n \n-Documentation for contributing to Rust is located in the [Guide to Rustc Development](https://rustc-dev-guide.rust-lang.org/),\n-commonly known as the [rustc-dev-guide]. Despite the name, this guide documents\n-not just how to develop rustc (the Rust compiler), but also how to contribute to the standard library and rustdoc.\n+Documentation for contributing to the compiler or tooling is located in the [Guide to Rustc\n+Development][rustc-dev-guide], commonly known as the [rustc-dev-guide]. Documentation for the\n+standard library in the [Standard library developers Guide][std-dev-guide], commonly known as the [std-dev-guide].\n \n ## About the [rustc-dev-guide]\n \n@@ -33,8 +33,8 @@ find a mentor! You can learn more about asking questions and getting help in the\n Did a compiler error message tell you to come here? If you want to create an ICE report,\n refer to [this section][contributing-bug-reports] and [open an issue][issue template].\n \n-[Contributing to Rust]: https://rustc-dev-guide.rust-lang.org/contributing.html#contributing-to-rust\n [rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/\n+[std-dev-guide]: https://std-dev-guide.rust-lang.org/\n [contributing-bug-reports]: https://rustc-dev-guide.rust-lang.org/contributing.html#bug-reports\n [issue template]: https://github.com/rust-lang/rust/issues/new/choose\n [internals]: https://internals.rust-lang.org"}, {"sha": "05993830a0fb4ab5d30336f75be3e5001e1fc770", "filename": "COPYRIGHT", "status": "modified", "additions": 320, "deletions": 160, "changes": 480, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/COPYRIGHT", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/COPYRIGHT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/COPYRIGHT?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -23,65 +23,251 @@ The Rust Project includes packages written by third parties.\n The following third party packages are included, and carry\n their own copyright notices and license terms:\n \n-* LLVM. Code for this package is found in src/llvm-project.\n-\n-    Copyright (c) 2003-2013 University of Illinois at\n-    Urbana-Champaign.  All rights reserved.\n-\n-    Developed by:\n-\n-        LLVM Team\n-\n-        University of Illinois at Urbana-Champaign\n-\n-        http://llvm.org\n-\n-    Permission is hereby granted, free of charge, to any\n-    person obtaining a copy of this software and associated\n-    documentation files (the \"Software\"), to deal with the\n-    Software without restriction, including without\n-    limitation the rights to use, copy, modify, merge,\n-    publish, distribute, sublicense, and/or sell copies of\n-    the Software, and to permit persons to whom the Software\n-    is furnished to do so, subject to the following\n-    conditions:\n-\n-        * Redistributions of source code must retain the\n-          above copyright notice, this list of conditions\n-          and the following disclaimers.\n-\n-        * Redistributions in binary form must reproduce the\n-          above copyright notice, this list of conditions\n-          and the following disclaimers in the documentation\n-          and/or other materials provided with the\n-          distribution.\n-\n-        * Neither the names of the LLVM Team, University of\n-          Illinois at Urbana-Champaign, nor the names of its\n-          contributors may be used to endorse or promote\n-          products derived from this Software without\n-          specific prior written permission.\n-\n-    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n-    ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n-    TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n-    PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT\n-    SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE\n-    FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n-    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT\n-    OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-    OTHER DEALINGS WITH THE SOFTWARE.\n-\n-* Additional libraries included in LLVM carry separate\n-  BSD-compatible licenses. See src/llvm-project/llvm/LICENSE.TXT\n-  for details.\n-\n-* compiler-rt, in src/compiler-rt is dual licensed under\n-  LLVM's license and MIT:\n-\n-    Copyright (c) 2009-2014 by the contributors listed in\n-    CREDITS.TXT\n-\n+* LLVM, located in src/llvm-project, is licensed under the following\n+  terms.\n+\n+    ==============================================================================\n+    The LLVM Project is under the Apache License v2.0 with LLVM Exceptions:\n+    ==============================================================================\n+\n+                                    Apache License\n+                              Version 2.0, January 2004\n+                            http://www.apache.org/licenses/\n+\n+        TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+        1. Definitions.\n+\n+          \"License\" shall mean the terms and conditions for use, reproduction,\n+          and distribution as defined by Sections 1 through 9 of this document.\n+\n+          \"Licensor\" shall mean the copyright owner or entity authorized by\n+          the copyright owner that is granting the License.\n+\n+          \"Legal Entity\" shall mean the union of the acting entity and all\n+          other entities that control, are controlled by, or are under common\n+          control with that entity. For the purposes of this definition,\n+          \"control\" means (i) the power, direct or indirect, to cause the\n+          direction or management of such entity, whether by contract or\n+          otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+          outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+          \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+          exercising permissions granted by this License.\n+\n+          \"Source\" form shall mean the preferred form for making modifications,\n+          including but not limited to software source code, documentation\n+          source, and configuration files.\n+\n+          \"Object\" form shall mean any form resulting from mechanical\n+          transformation or translation of a Source form, including but\n+          not limited to compiled object code, generated documentation,\n+          and conversions to other media types.\n+\n+          \"Work\" shall mean the work of authorship, whether in Source or\n+          Object form, made available under the License, as indicated by a\n+          copyright notice that is included in or attached to the work\n+          (an example is provided in the Appendix below).\n+\n+          \"Derivative Works\" shall mean any work, whether in Source or Object\n+          form, that is based on (or derived from) the Work and for which the\n+          editorial revisions, annotations, elaborations, or other modifications\n+          represent, as a whole, an original work of authorship. For the purposes\n+          of this License, Derivative Works shall not include works that remain\n+          separable from, or merely link (or bind by name) to the interfaces of,\n+          the Work and Derivative Works thereof.\n+\n+          \"Contribution\" shall mean any work of authorship, including\n+          the original version of the Work and any modifications or additions\n+          to that Work or Derivative Works thereof, that is intentionally\n+          submitted to Licensor for inclusion in the Work by the copyright owner\n+          or by an individual or Legal Entity authorized to submit on behalf of\n+          the copyright owner. For the purposes of this definition, \"submitted\"\n+          means any form of electronic, verbal, or written communication sent\n+          to the Licensor or its representatives, including but not limited to\n+          communication on electronic mailing lists, source code control systems,\n+          and issue tracking systems that are managed by, or on behalf of, the\n+          Licensor for the purpose of discussing and improving the Work, but\n+          excluding communication that is conspicuously marked or otherwise\n+          designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+          \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+          on behalf of whom a Contribution has been received by Licensor and\n+          subsequently incorporated within the Work.\n+\n+        2. Grant of Copyright License. Subject to the terms and conditions of\n+          this License, each Contributor hereby grants to You a perpetual,\n+          worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+          copyright license to reproduce, prepare Derivative Works of,\n+          publicly display, publicly perform, sublicense, and distribute the\n+          Work and such Derivative Works in Source or Object form.\n+\n+        3. Grant of Patent License. Subject to the terms and conditions of\n+          this License, each Contributor hereby grants to You a perpetual,\n+          worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+          (except as stated in this section) patent license to make, have made,\n+          use, offer to sell, sell, import, and otherwise transfer the Work,\n+          where such license applies only to those patent claims licensable\n+          by such Contributor that are necessarily infringed by their\n+          Contribution(s) alone or by combination of their Contribution(s)\n+          with the Work to which such Contribution(s) was submitted. If You\n+          institute patent litigation against any entity (including a\n+          cross-claim or counterclaim in a lawsuit) alleging that the Work\n+          or a Contribution incorporated within the Work constitutes direct\n+          or contributory patent infringement, then any patent licenses\n+          granted to You under this License for that Work shall terminate\n+          as of the date such litigation is filed.\n+\n+        4. Redistribution. You may reproduce and distribute copies of the\n+          Work or Derivative Works thereof in any medium, with or without\n+          modifications, and in Source or Object form, provided that You\n+          meet the following conditions:\n+\n+          (a) You must give any other recipients of the Work or\n+              Derivative Works a copy of this License; and\n+\n+          (b) You must cause any modified files to carry prominent notices\n+              stating that You changed the files; and\n+\n+          (c) You must retain, in the Source form of any Derivative Works\n+              that You distribute, all copyright, patent, trademark, and\n+              attribution notices from the Source form of the Work,\n+              excluding those notices that do not pertain to any part of\n+              the Derivative Works; and\n+\n+          (d) If the Work includes a \"NOTICE\" text file as part of its\n+              distribution, then any Derivative Works that You distribute must\n+              include a readable copy of the attribution notices contained\n+              within such NOTICE file, excluding those notices that do not\n+              pertain to any part of the Derivative Works, in at least one\n+              of the following places: within a NOTICE text file distributed\n+              as part of the Derivative Works; within the Source form or\n+              documentation, if provided along with the Derivative Works; or,\n+              within a display generated by the Derivative Works, if and\n+              wherever such third-party notices normally appear. The contents\n+              of the NOTICE file are for informational purposes only and\n+              do not modify the License. You may add Your own attribution\n+              notices within Derivative Works that You distribute, alongside\n+              or as an addendum to the NOTICE text from the Work, provided\n+              that such additional attribution notices cannot be construed\n+              as modifying the License.\n+\n+          You may add Your own copyright statement to Your modifications and\n+          may provide additional or different license terms and conditions\n+          for use, reproduction, or distribution of Your modifications, or\n+          for any such Derivative Works as a whole, provided Your use,\n+          reproduction, and distribution of the Work otherwise complies with\n+          the conditions stated in this License.\n+\n+        5. Submission of Contributions. Unless You explicitly state otherwise,\n+          any Contribution intentionally submitted for inclusion in the Work\n+          by You to the Licensor shall be under the terms and conditions of\n+          this License, without any additional terms or conditions.\n+          Notwithstanding the above, nothing herein shall supersede or modify\n+          the terms of any separate license agreement you may have executed\n+          with Licensor regarding such Contributions.\n+\n+        6. Trademarks. This License does not grant permission to use the trade\n+          names, trademarks, service marks, or product names of the Licensor,\n+          except as required for reasonable and customary use in describing the\n+          origin of the Work and reproducing the content of the NOTICE file.\n+\n+        7. Disclaimer of Warranty. Unless required by applicable law or\n+          agreed to in writing, Licensor provides the Work (and each\n+          Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+          WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+          implied, including, without limitation, any warranties or conditions\n+          of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+          PARTICULAR PURPOSE. You are solely responsible for determining the\n+          appropriateness of using or redistributing the Work and assume any\n+          risks associated with Your exercise of permissions under this License.\n+\n+        8. Limitation of Liability. In no event and under no legal theory,\n+          whether in tort (including negligence), contract, or otherwise,\n+          unless required by applicable law (such as deliberate and grossly\n+          negligent acts) or agreed to in writing, shall any Contributor be\n+          liable to You for damages, including any direct, indirect, special,\n+          incidental, or consequential damages of any character arising as a\n+          result of this License or out of the use or inability to use the\n+          Work (including but not limited to damages for loss of goodwill,\n+          work stoppage, computer failure or malfunction, or any and all\n+          other commercial damages or losses), even if such Contributor\n+          has been advised of the possibility of such damages.\n+\n+        9. Accepting Warranty or Additional Liability. While redistributing\n+          the Work or Derivative Works thereof, You may choose to offer,\n+          and charge a fee for, acceptance of support, warranty, indemnity,\n+          or other liability obligations and/or rights consistent with this\n+          License. However, in accepting such obligations, You may act only\n+          on Your own behalf and on Your sole responsibility, not on behalf\n+          of any other Contributor, and only if You agree to indemnify,\n+          defend, and hold each Contributor harmless for any liability\n+          incurred by, or claims asserted against, such Contributor by reason\n+          of your accepting any such warranty or additional liability.\n+\n+        END OF TERMS AND CONDITIONS\n+\n+        APPENDIX: How to apply the Apache License to your work.\n+\n+          To apply the Apache License to your work, attach the following\n+          boilerplate notice, with the fields enclosed by brackets \"[]\"\n+          replaced with your own identifying information. (Don't include\n+          the brackets!)  The text should be enclosed in the appropriate\n+          comment syntax for the file format. We also recommend that a\n+          file or class name and description of purpose be included on the\n+          same \"printed page\" as the copyright notice for easier\n+          identification within third-party archives.\n+\n+        Copyright [yyyy] [name of copyright owner]\n+\n+        Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+          http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+\n+\n+    ---- LLVM Exceptions to the Apache 2.0 License ----\n+\n+    As an exception, if, as a result of your compiling your source code, portions\n+    of this Software are embedded into an Object form of such source code, you\n+    may redistribute such embedded portions in such Object form without complying\n+    with the conditions of Sections 4(a), 4(b) and 4(d) of the License.\n+\n+    In addition, if you combine or link compiled forms of this Software with\n+    software that is licensed under the GPLv2 (\"Combined Software\") and if a\n+    court of competent jurisdiction determines that the patent provision (Section\n+    3), the indemnity provision (Section 9) or other Section of the License\n+    conflicts with the conditions of the GPLv2, you may retroactively and\n+    prospectively choose to deem waived or otherwise exclude such Section(s) of\n+    the License, but only in their entirety and only with respect to the Combined\n+    Software.\n+\n+    ==============================================================================\n+    Software from third parties included in the LLVM Project:\n+    ==============================================================================\n+    The LLVM Project contains third party software which is under different license\n+    terms. All such code will be identified clearly using at least one of two\n+    mechanisms:\n+    1) It will be in a separate directory tree with its own `LICENSE.txt` or\n+      `LICENSE` file at the top containing the specific license and restrictions\n+      which apply to that software, or\n+    2) It will contain specific license and restriction terms at the top of every\n+      file.\n+\n+    ==============================================================================\n+    Legacy LLVM License (https://llvm.org/docs/DeveloperPolicy.html#legacy):\n+    ==============================================================================\n+    University of Illinois/NCSA\n+    Open Source License\n+\n+    Copyright (c) 2003-2019 University of Illinois at Urbana-Champaign.\n     All rights reserved.\n \n     Developed by:\n@@ -92,70 +278,32 @@ their own copyright notices and license terms:\n \n         http://llvm.org\n \n-    Permission is hereby granted, free of charge, to any\n-    person obtaining a copy of this software and associated\n-    documentation files (the \"Software\"), to deal with the\n-    Software without restriction, including without\n-    limitation the rights to use, copy, modify, merge,\n-    publish, distribute, sublicense, and/or sell copies of\n-    the Software, and to permit persons to whom the Software\n-    is furnished to do so, subject to the following\n-    conditions:\n-\n-        * Redistributions of source code must retain the\n-          above copyright notice, this list of conditions\n-          and the following disclaimers.\n-\n-        * Redistributions in binary form must reproduce the\n-          above copyright notice, this list of conditions\n-          and the following disclaimers in the documentation\n-          and/or other materials provided with the\n-          distribution.\n-\n-        * Neither the names of the LLVM Team, University of\n-          Illinois at Urbana-Champaign, nor the names of its\n-          contributors may be used to endorse or promote\n-          products derived from this Software without\n-          specific prior written permission.\n-\n-    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n-    ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n-    TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n-    PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT\n-    SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE\n-    FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n-    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT\n-    OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-    OTHER DEALINGS WITH THE SOFTWARE.\n-\n-    ========================================================\n-\n-    Copyright (c) 2009-2014 by the contributors listed in\n-    CREDITS.TXT\n-\n-    Permission is hereby granted, free of charge, to any\n-    person obtaining a copy of this software and associated\n-    documentation files (the \"Software\"), to deal in the\n-    Software without restriction, including without\n-    limitation the rights to use, copy, modify, merge,\n-    publish, distribute, sublicense, and/or sell copies of\n-    the Software, and to permit persons to whom the Software\n-    is furnished to do so, subject to the following\n-    conditions:\n-\n-    The above copyright notice and this permission notice\n-    shall be included in all copies or substantial portions\n-    of the Software.\n-\n-    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n-    ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n-    TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n-    PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n-    SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n-    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n-    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n-    IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n-    DEALINGS IN THE SOFTWARE.\n+    Permission is hereby granted, free of charge, to any person obtaining a copy of\n+    this software and associated documentation files (the \"Software\"), to deal with\n+    the Software without restriction, including without limitation the rights to\n+    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n+    of the Software, and to permit persons to whom the Software is furnished to do\n+    so, subject to the following conditions:\n+\n+        * Redistributions of source code must retain the above copyright notice,\n+          this list of conditions and the following disclaimers.\n+\n+        * Redistributions in binary form must reproduce the above copyright notice,\n+          this list of conditions and the following disclaimers in the\n+          documentation and/or other materials provided with the distribution.\n+\n+        * Neither the names of the LLVM Team, University of Illinois at\n+          Urbana-Champaign, nor the names of its contributors may be used to\n+          endorse or promote products derived from this Software without specific\n+          prior written permission.\n+\n+    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n+    CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE\n+    SOFTWARE.\n \n * Portions of the FFI code for interacting with the native ABI\n   is derived from the Clay programming language, which carries\n@@ -192,40 +340,52 @@ their own copyright notices and license terms:\n     USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n     OF SUCH DAMAGE.\n \n-* libbacktrace, under src/libbacktrace:\n-\n-    Copyright (C) 2012-2014 Free Software Foundation, Inc.\n-    Written by Ian Lance Taylor, Google.\n-\n-    Redistribution and use in source and binary forms, with\n-    or without modification, are permitted provided that the\n-    following conditions are met:\n-\n-        (1) Redistributions of source code must retain the\n-        above copyright notice, this list of conditions and\n-        the following disclaimer.\n-\n-        (2) Redistributions in binary form must reproduce\n-        the above copyright notice, this list of conditions\n-        and the following disclaimer in the documentation\n-        and/or other materials provided with the\n-        distribution.\n-\n-        (3) The name of the author may not be used to\n-        endorse or promote products derived from this\n-        software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND\n-    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n-    AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN\n-    NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n-    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n-    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n-    USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n-    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n-    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n-    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n-    USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n-    OF SUCH DAMAGE.  */\n+* Portions of internationalization code use code or data from Unicode, which\n+  carry the following license:\n+\n+      UNICODE, INC. LICENSE AGREEMENT - DATA FILES AND SOFTWARE\n+\n+    See Terms of Use <https://www.unicode.org/copyright.html>\n+    for definitions of Unicode Inc.\u2019s Data Files and Software.\n+\n+    NOTICE TO USER: Carefully read the following legal agreement.\n+    BY DOWNLOADING, INSTALLING, COPYING OR OTHERWISE USING UNICODE INC.'S\n+    DATA FILES (\"DATA FILES\"), AND/OR SOFTWARE (\"SOFTWARE\"),\n+    YOU UNEQUIVOCALLY ACCEPT, AND AGREE TO BE BOUND BY, ALL OF THE\n+    TERMS AND CONDITIONS OF THIS AGREEMENT.\n+    IF YOU DO NOT AGREE, DO NOT DOWNLOAD, INSTALL, COPY, DISTRIBUTE OR USE\n+    THE DATA FILES OR SOFTWARE.\n+\n+    COPYRIGHT AND PERMISSION NOTICE\n+\n+    Copyright \u00a9 1991-2022 Unicode, Inc. All rights reserved.\n+    Distributed under the Terms of Use in https://www.unicode.org/copyright.html.\n+\n+    Permission is hereby granted, free of charge, to any person obtaining\n+    a copy of the Unicode data files and any associated documentation\n+    (the \"Data Files\") or Unicode software and any associated documentation\n+    (the \"Software\") to deal in the Data Files or Software\n+    without restriction, including without limitation the rights to use,\n+    copy, modify, merge, publish, distribute, and/or sell copies of\n+    the Data Files or Software, and to permit persons to whom the Data Files\n+    or Software are furnished to do so, provided that either\n+    (a) this copyright and permission notice appear with all copies\n+    of the Data Files or Software, or\n+    (b) this copyright and permission notice appear in associated\n+    Documentation.\n+\n+    THE DATA FILES AND SOFTWARE ARE PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+    ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n+    WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+    NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n+    IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS\n+    NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL\n+    DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n+    DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n+    TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n+    PERFORMANCE OF THE DATA FILES OR SOFTWARE.\n+\n+    Except as contained in this notice, the name of a copyright holder\n+    shall not be used in advertising or otherwise to promote the sale,\n+    use or other dealings in these Data Files or Software without prior\n+    written authorization of the copyright holder."}, {"sha": "0355c45d7e94a3701c1704099bb30929dfc0bb67", "filename": "Cargo.lock", "status": "modified", "additions": 1793, "deletions": 1833, "changes": 3626, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "6e84df5c693b9732796e45a6ad47dbcb0bcb8671", "filename": "Cargo.toml", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -1,16 +1,19 @@\n [workspace]\n+resolver = \"1\"\n members = [\n   \"compiler/rustc\",\n   \"library/std\",\n-  \"library/test\",\n+  \"library/sysroot\",\n   \"src/rustdoc-json-types\",\n+  \"src/tools/build_helper\",\n   \"src/tools/cargotest\",\n   \"src/tools/clippy\",\n   \"src/tools/clippy/clippy_dev\",\n   \"src/tools/compiletest\",\n   \"src/tools/error_index_generator\",\n   \"src/tools/linkchecker\",\n   \"src/tools/lint-docs\",\n+  \"src/tools/miropt-test-tools\",\n   \"src/tools/rustbook\",\n   \"src/tools/unstable-book-gen\",\n   \"src/tools/tidy\",\n@@ -20,10 +23,6 @@ members = [\n   \"src/tools/remote-test-server\",\n   \"src/tools/rust-installer\",\n   \"src/tools/rust-demangler\",\n-  \"src/tools/cargo\",\n-  \"src/tools/cargo/crates/credential/cargo-credential-1password\",\n-  \"src/tools/cargo/crates/credential/cargo-credential-macos-keychain\",\n-  \"src/tools/cargo/crates/credential/cargo-credential-wincred\",\n   \"src/tools/rustdoc\",\n   \"src/tools/rls\",\n   \"src/tools/rustfmt\",\n@@ -33,17 +32,24 @@ members = [\n   \"src/tools/unicode-table-generator\",\n   \"src/tools/expand-yaml-anchors\",\n   \"src/tools/jsondocck\",\n+  \"src/tools/jsondoclint\",\n   \"src/tools/html-checker\",\n   \"src/tools/bump-stage0\",\n+  \"src/tools/replace-version-placeholder\",\n   \"src/tools/lld-wrapper\",\n+  \"src/tools/collect-license-metadata\",\n+  \"src/tools/generate-copyright\",\n+  \"src/tools/suggest-tests\",\n+  \"src/tools/generate-windows-sys\",\n+  \"src/tools/rustdoc-gui-test\",\n ]\n \n exclude = [\n   \"build\",\n   \"compiler/rustc_codegen_cranelift\",\n   \"compiler/rustc_codegen_gcc\",\n   \"src/bootstrap\",\n-  \"src/test/rustdoc-gui\",\n+  \"tests/rustdoc-gui\",\n   # HACK(eddyb) This hardcodes the fact that our CI uses `/checkout/obj`.\n   \"obj\",\n   # The `x` binary is a thin wrapper that calls `x.py`, which initializes\n@@ -60,7 +66,7 @@ exclude = [\n # verify that this is the case. This requires, however, that the crate is built\n # without overflow checks and debug assertions. Forcefully disable debug\n # assertions and overflow checks here which should ensure that even if these\n-# assertions are enabled for libstd we won't enable then for compiler_builtins\n+# assertions are enabled for libstd we won't enable them for compiler_builtins\n # which should ensure we still link everything correctly.\n debug-assertions = false\n overflow-checks = false\n@@ -96,26 +102,7 @@ gimli.debug = 0\n miniz_oxide.debug = 0\n object.debug = 0\n \n-# We want the RLS to use the version of Cargo that we've got vendored in this\n-# repository to ensure that the same exact version of Cargo is used by both the\n-# RLS and the Cargo binary itself. The RLS depends on Cargo as a git repository\n-# so we use a `[patch]` here to override the github repository with our local\n-# vendored copy.\n-[patch.\"https://github.com/rust-lang/cargo\"]\n-cargo = { path = \"src/tools/cargo\" }\n-cargo-util = { path = \"src/tools/cargo/crates/cargo-util\" }\n-\n-[patch.\"https://github.com/rust-lang/rustfmt\"]\n-# Similar to Cargo above we want the RLS to use a vendored version of `rustfmt`\n-# that we're shipping as well (to ensure that the rustfmt in RLS and the\n-# `rustfmt` executable are the same exact version).\n-rustfmt-nightly = { path = \"src/tools/rustfmt\" }\n-\n [patch.crates-io]\n-# See comments in `src/tools/rustc-workspace-hack/README.md` for what's going on\n-# here\n-rustc-workspace-hack = { path = 'src/tools/rustc-workspace-hack' }\n-\n # See comments in `library/rustc-std-workspace-core/README.md` for what's going on\n # here\n rustc-std-workspace-core = { path = 'library/rustc-std-workspace-core' }"}, {"sha": "137069b823873b8bcf42979bcf8e9371052d26a2", "filename": "LICENSES/Apache-2.0.txt", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/LICENSES%2FApache-2.0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/LICENSES%2FApache-2.0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FApache-2.0.txt?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -0,0 +1,73 @@\n+Apache License\n+Version 2.0, January 2004\n+http://www.apache.org/licenses/\n+\n+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+1. Definitions.\n+\n+\"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.\n+\n+\"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.\n+\n+\"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+\"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License.\n+\n+\"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.\n+\n+\"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.\n+\n+\"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).\n+\n+\"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.\n+\n+\"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+\"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.\n+\n+2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.\n+\n+3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.\n+\n+4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:\n+\n+     (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and\n+\n+     (b) You must cause any modified files to carry prominent notices stating that You changed the files; and\n+\n+     (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and\n+\n+     (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.\n+\n+     You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.\n+\n+5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.\n+\n+6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.\n+\n+7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.\n+\n+8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.\n+\n+9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.\n+\n+END OF TERMS AND CONDITIONS\n+\n+APPENDIX: How to apply the Apache License to your work.\n+\n+To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!)  The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives.\n+\n+Copyright [yyyy] [name of copyright owner]\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License."}, {"sha": "5f662b354cd40cd5339d5aa05d74b15405138230", "filename": "LICENSES/BSD-2-Clause.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/LICENSES%2FBSD-2-Clause.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/LICENSES%2FBSD-2-Clause.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FBSD-2-Clause.txt?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -0,0 +1,9 @@\n+Copyright (c) <year> <owner> \n+\n+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n+\n+1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n+\n+2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."}, {"sha": "fa4b725a0ee50ef723ce5292865e54de7b0bfca4", "filename": "LICENSES/LLVM-exception.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/LICENSES%2FLLVM-exception.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/LICENSES%2FLLVM-exception.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FLLVM-exception.txt?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -0,0 +1,15 @@\n+---- LLVM Exceptions to the Apache 2.0 License ----\n+\n+   As an exception, if, as a result of your compiling your source code, portions\n+   of this Software are embedded into an Object form of such source code, you\n+   may redistribute such embedded portions in such Object form without complying\n+   with the conditions of Sections 4(a), 4(b) and 4(d) of the License.\n+\n+   In addition, if you combine or link compiled forms of this Software with\n+   software that is licensed under the GPLv2 (\"Combined Software\") and if a\n+   court of competent jurisdiction determines that the patent provision (Section\n+   3), the indemnity provision (Section 9) or other Section of the License\n+   conflicts with the conditions of the GPLv2, you may retroactively and\n+   prospectively choose to deem waived or otherwise exclude such Section(s) of\n+   the License, but only in their entirety and only with respect to the Combined\n+   Software."}, {"sha": "2071b23b0e08594ea6bc99ac71129ef992abf498", "filename": "LICENSES/MIT.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/LICENSES%2FMIT.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/LICENSES%2FMIT.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FMIT.txt?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -0,0 +1,9 @@\n+MIT License\n+\n+Copyright (c) <year> <copyright holders>\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."}, {"sha": "cf5413effa25a89cae2ef0de21ade82e3672cb3b", "filename": "LICENSES/NCSA.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/LICENSES%2FNCSA.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/LICENSES%2FNCSA.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FNCSA.txt?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -0,0 +1,15 @@\n+University of Illinois/NCSA Open Source License\n+\n+Copyright (c) <Year> <Owner Organization Name>. All rights reserved.\n+\n+Developed by: <Name of Development Group> <Name of Institution> <URL for Development Group/Institution>\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal with the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n+\n+     * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimers.\n+\n+     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimers in the documentation and/or other materials provided with the distribution.\n+\n+     * Neither the names of <Name of Development Group, Name of Institution>, nor the names of its contributors may be used to endorse or promote products derived from this Software without specific prior written permission.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE SOFTWARE."}, {"sha": "6fe84ee21ebe5d2b54dc63b53b4d5c404c083409", "filename": "LICENSES/OFL-1.1.txt", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/LICENSES%2FOFL-1.1.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/LICENSES%2FOFL-1.1.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FOFL-1.1.txt?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -0,0 +1,43 @@\n+SIL OPEN FONT LICENSE\n+\n+Version 1.1 - 26 February 2007\n+\n+PREAMBLE\n+\n+The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others.\n+\n+The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives.\n+\n+DEFINITIONS\n+\n+\"Font Software\" refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation.\n+\n+\"Reserved Font Name\" refers to any names specified as such after the copyright statement(s).\n+\n+\"Original Version\" refers to the collection of Font Software components as distributed by the Copyright Holder(s).\n+\n+\"Modified Version\" refers to any derivative made by adding to, deleting, or substituting \u2014 in part or in whole \u2014 any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment.\n+\n+\"Author\" refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software.\n+\n+PERMISSION & CONDITIONS\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions:\n+\n+1) Neither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself.\n+\n+2) Original or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user.\n+\n+3) No Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users.\n+\n+4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission.\n+\n+5) The Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software.\n+\n+TERMINATION\n+\n+This license becomes null and void if any of the above conditions are not met.\n+\n+DISCLAIMER\n+\n+THE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE."}, {"sha": "71fd6ac5e12e1703f2d2445393326649d30a49f5", "filename": "LICENSES/Unicode-DFS-2016.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/LICENSES%2FUnicode-DFS-2016.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/LICENSES%2FUnicode-DFS-2016.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FUnicode-DFS-2016.txt?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -0,0 +1,22 @@\n+UNICODE, INC. LICENSE AGREEMENT - DATA FILES AND SOFTWARE\n+\n+Unicode Data Files include all data files under the directories http://www.unicode.org/Public/, http://www.unicode.org/reports/, http://www.unicode.org/cldr/data/, http://source.icu-project.org/repos/icu/, and http://www.unicode.org/utility/trac/browser/.\n+\n+Unicode Data Files do not include PDF online code charts under the directory http://www.unicode.org/Public/.\n+\n+Software includes any source code published in the Unicode Standard or under the directories http://www.unicode.org/Public/, http://www.unicode.org/reports/, http://www.unicode.org/cldr/data/, http://source.icu-project.org/repos/icu/, and http://www.unicode.org/utility/trac/browser/.\n+\n+NOTICE TO USER: Carefully read the following legal agreement. BY DOWNLOADING, INSTALLING, COPYING OR OTHERWISE USING UNICODE INC.'S DATA FILES (\"DATA FILES\"), AND/OR SOFTWARE (\"SOFTWARE\"), YOU UNEQUIVOCALLY ACCEPT, AND AGREE TO BE BOUND BY, ALL OF THE TERMS AND CONDITIONS OF THIS AGREEMENT. IF YOU DO NOT AGREE, DO NOT DOWNLOAD, INSTALL, COPY, DISTRIBUTE OR USE THE DATA FILES OR SOFTWARE.\n+\n+COPYRIGHT AND PERMISSION NOTICE\n+\n+Copyright \u00a9 1991-2016 Unicode, Inc. All rights reserved. Distributed under the Terms of Use in http://www.unicode.org/copyright.html.\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy of the Unicode data files and any associated documentation (the \"Data Files\") or Unicode software and any associated documentation (the \"Software\") to deal in the Data Files or Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, and/or sell copies of the Data Files or Software, and to permit persons to whom the Data Files or Software are furnished to do so, provided that either\n+\n+     (a) this copyright and permission notice appear with all copies of the Data Files or Software, or\n+     (b) this copyright and permission notice appear in associated Documentation.\n+\n+THE DATA FILES AND SOFTWARE ARE PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THE DATA FILES OR SOFTWARE.\n+\n+Except as contained in this notice, the name of a copyright holder shall not be used in advertising or otherwise to promote the sale, use or other dealings in these Data Files or Software without prior written authorization of the copyright holder."}, {"sha": "41b135972af11458ebc394377610af743f8731ae", "filename": "README.md", "status": "modified", "additions": 149, "deletions": 130, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -1,16 +1,15 @@\n # The Rust Programming Language\n \n+[![Rust Community](https://img.shields.io/badge/Rust_Community%20-Join_us-brightgreen?style=plastic&logo=rust)](https://www.rust-lang.org/community)\n+\n This is the main source code repository for [Rust]. It contains the compiler,\n standard library, and documentation.\n \n-[Rust]: https://www.rust-lang.org\n-\n-**Note: this README is for _users_ rather than _contributors_.\n-If you wish to _contribute_ to the compiler, you should read the\n-[Getting Started][gettingstarted] section of the rustc-dev-guide instead.\n-You can ask for help in the [#new members Zulip stream][new-members].**\n+[Rust]: https://www.rust-lang.org/\n \n-[new-members]: https://rust-lang.zulipchat.com/#narrow/stream/122652-new-members\n+**Note: this README is for _users_ rather than _contributors_.**\n+If you wish to _contribute_ to the compiler, you should read\n+[CONTRIBUTING.md](CONTRIBUTING.md) instead.\n \n ## Quick Start\n \n@@ -22,46 +21,75 @@ Read [\"Installation\"] from [The Book].\n ## Installing from Source\n \n The Rust build system uses a Python script called `x.py` to build the compiler,\n-which manages the bootstrapping process. It lives in the root of the project.\n+which manages the bootstrapping process. It lives at the root of the project.\n+It also uses a file named `config.toml` to determine various configuration settings for the build.\n+You can see a full list of options in `config.example.toml`.\n \n-The `x.py` command can be run directly on most systems in the following format:\n+The `x.py` command can be run directly on most Unix systems in the following\n+format:\n \n ```sh\n ./x.py <subcommand> [flags]\n ```\n \n This is how the documentation and examples assume you are running `x.py`.\n-\n-Systems such as Ubuntu 20.04 LTS do not create the necessary `python` command by default when Python is installed that allows `x.py` to be run directly. In that case you can either create a symlink for `python` (Ubuntu provides the `python-is-python3` package for this), or run `x.py` using Python itself:\n+Some alternative ways are:\n \n ```sh\n-# Python 3\n-python3 x.py <subcommand> [flags]\n+# On a Unix shell if you don't have the necessary `python3` command\n+./x <subcommand> [flags]\n \n-# Python 2.7\n-python2.7 x.py <subcommand> [flags]\n+# On the Windows Command Prompt (if .py files are configured to run Python)\n+x.py <subcommand> [flags]\n+\n+# You can also run Python yourself, e.g.:\n+python x.py <subcommand> [flags]\n ```\n \n-More information about `x.py` can be found\n-by running it with the `--help` flag or reading the [rustc dev guide][rustcguidebuild].\n+More information about `x.py` can be found by running it with the `--help` flag\n+or reading the [rustc dev guide][rustcguidebuild].\n \n [gettingstarted]: https://rustc-dev-guide.rust-lang.org/getting-started.html\n [rustcguidebuild]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html\n \n+### Dependencies\n+\n+Make sure you have installed the dependencies:\n+\n+* `python` 3 or 2.7\n+* `git`\n+* A C compiler (when building for the host, `cc` is enough; cross-compiling may\n+  need additional compilers)\n+* `curl` (not needed on Windows)\n+* `pkg-config` if you are compiling on Linux and targeting Linux\n+* `libiconv` (already included with glibc on Debian-based distros)\n+\n+To build Cargo, you'll also need OpenSSL (`libssl-dev` or `openssl-devel` on\n+most Unix distros).\n+\n+If building LLVM from source, you'll need additional tools:\n+\n+* `g++`, `clang++`, or MSVC with versions listed on\n+  [LLVM's documentation](https://llvm.org/docs/GettingStarted.html#host-c-toolchain-both-compiler-and-standard-library)\n+* `ninja`, or GNU `make` 3.81 or later (Ninja is recommended, especially on\n+  Windows)\n+* `cmake` 3.13.4 or later\n+* `libstdc++-static` may be required on some Linux distributions such as Fedora\n+  and Ubuntu\n+\n+On tier 1 or tier 2 with host tools platforms, you can also choose to download\n+LLVM by setting `llvm.download-ci-llvm = true`.\n+Otherwise, you'll need LLVM installed and `llvm-config` in your path.\n+See [the rustc-dev-guide for more info][sysllvm].\n+\n+[sysllvm]: https://rustc-dev-guide.rust-lang.org/building/new-target.html#using-pre-built-llvm\n+\n+\n ### Building on a Unix-like system\n-1. Make sure you have installed the dependencies:\n \n-   * `g++` 5.1 or later or `clang++` 3.5 or later\n-   * `python` 3 or 2.7\n-   * GNU `make` 3.81 or later\n-   * `cmake` 3.13.4 or later\n-   * `ninja`\n-   * `curl`\n-   * `git`\n-   * `ssl` which comes in `libssl-dev` or `openssl-devel`\n-   * `pkg-config` if you are compiling on Linux and targeting Linux\n+#### Build steps\n \n-2. Clone the [source] with `git`:\n+1. Clone the [source] with `git`:\n \n    ```sh\n    git clone https://github.com/rust-lang/rust.git\n@@ -70,57 +98,80 @@ by running it with the `--help` flag or reading the [rustc dev guide][rustcguide\n \n [source]: https://github.com/rust-lang/rust\n \n-3. Configure the build settings:\n+2. Configure the build settings:\n \n-    The Rust build system uses a file named `config.toml` in the root of the\n-    source tree to determine various configuration settings for the build.\n-    Copy the default `config.toml.example` to `config.toml` to get started.\n+   ```sh\n+   ./configure\n+   ```\n \n-    ```sh\n-    cp config.toml.example config.toml\n-    ```\n+   If you plan to use `x.py install` to create an installation, it is\n+   recommended that you set the `prefix` value in the `[install]` section to a\n+   directory: `./configure --set install.prefix=<path>`\n \n-    If you plan to use `x.py install` to create an installation, it is recommended\n-    that you set the `prefix` value in the `[install]` section to a directory.\n+3. Build and install:\n \n-    Create install directory if you are not installing in default directory.\n+   ```sh\n+   ./x.py build && ./x.py install\n+   ```\n \n-4. Build and install:\n+   When complete, `./x.py install` will place several programs into\n+   `$PREFIX/bin`: `rustc`, the Rust compiler, and `rustdoc`, the\n+   API-documentation tool. By default, it will also include [Cargo], Rust's package manager.\n+   You can disable this behavior by passing `--set build.extended=false` to `./configure`.\n \n-    ```sh\n-    ./x.py build && ./x.py install\n-    ```\n+[Cargo]: https://github.com/rust-lang/cargo\n \n-    When complete, `./x.py install` will place several programs into\n-    `$PREFIX/bin`: `rustc`, the Rust compiler, and `rustdoc`, the\n-    API-documentation tool. This install does not include [Cargo],\n-    Rust's package manager. To build and install Cargo, you may\n-    run `./x.py install cargo` or set the `build.extended` key in\n-    `config.toml` to `true` to build and install all tools.\n+#### Configure and Make\n \n-[Cargo]: https://github.com/rust-lang/cargo\n+This project provides a configure script and makefile (the latter of which just invokes `x.py`).\n+`./configure` is the recommended way to programatically generate a `config.toml`. `make` is not\n+recommended (we suggest using `x.py` directly), but it is supported and we try not to break it\n+unnecessarily.\n+\n+```sh\n+./configure\n+make && sudo make install\n+```\n+\n+`configure` generates a `config.toml` which can also be used with normal `x.py` invocations.\n \n ### Building on Windows\n \n+On Windows, we suggest using [winget] to install dependencies by running the\n+following in a terminal:\n+\n+```powershell\n+winget install -e Python.Python.3\n+winget install -e Kitware.CMake\n+winget install -e Git.Git\n+```\n+\n+Then edit your system's `PATH` variable and add: `C:\\Program Files\\CMake\\bin`.\n+See\n+[this guide on editing the system `PATH`](https://www.java.com/en/download/help/path.html)\n+from the Java documentation.\n+\n+[winget]: https://github.com/microsoft/winget-cli\n+\n There are two prominent ABIs in use on Windows: the native (MSVC) ABI used by\n-Visual Studio, and the GNU ABI used by the GCC toolchain. Which version of Rust\n-you need depends largely on what C/C++ libraries you want to interoperate with:\n-for interop with software produced by Visual Studio use the MSVC build of Rust;\n-for interop with GNU software built using the MinGW/MSYS2 toolchain use the GNU\n-build.\n+Visual Studio and the GNU ABI used by the GCC toolchain. Which version of Rust\n+you need depends largely on what C/C++ libraries you want to interoperate with.\n+Use the MSVC build of Rust to interop with software produced by Visual Studio\n+and the GNU build to interop with GNU software built using the MinGW/MSYS2\n+toolchain.\n \n #### MinGW\n \n [MSYS2][msys2] can be used to easily build Rust on Windows:\n \n [msys2]: https://www.msys2.org/\n \n-1. Grab the latest [MSYS2 installer][msys2] and go through the installer.\n+1. Download the latest [MSYS2 installer][msys2] and go through the installer.\n \n-2. Run `mingw32_shell.bat` or `mingw64_shell.bat` from wherever you installed\n-   MSYS2 (i.e. `C:\\msys64`), depending on whether you want 32-bit or 64-bit\n+2. Run `mingw32_shell.bat` or `mingw64_shell.bat` from the MSYS2 installation\n+   directory (e.g. `C:\\msys64`), depending on whether you want 32-bit or 64-bit\n    Rust. (As of the latest version of MSYS2 you have to run `msys2_shell.cmd\n-   -mingw32` or `msys2_shell.cmd -mingw64` from the command line instead)\n+   -mingw32` or `msys2_shell.cmd -mingw64` from the command line instead.)\n \n 3. From this terminal, install the required tools:\n \n@@ -129,11 +180,11 @@ build.\n    pacman -Sy pacman-mirrors\n \n    # Install build tools needed for Rust. If you're building a 32-bit compiler,\n-   # then replace \"x86_64\" below with \"i686\". If you've already got git, python,\n-   # or CMake installed and in PATH you can remove them from this list. Note\n-   # that it is important that you do **not** use the 'python2', 'cmake' and 'ninja'\n-   # packages from the 'msys2' subsystem. The build has historically been known\n-   # to fail with these packages.\n+   # then replace \"x86_64\" below with \"i686\". If you've already got Git, Python,\n+   # or CMake installed and in PATH you can remove them from this list.\n+   # Note that it is important that you do **not** use the 'python2', 'cmake',\n+   # and 'ninja' packages from the 'msys2' subsystem.\n+   # The build has historically been known to fail with these packages.\n    pacman -S git \\\n                make \\\n                diffutils \\\n@@ -147,31 +198,33 @@ build.\n 4. Navigate to Rust's source code (or clone it), then build it:\n \n    ```sh\n-   ./x.py build && ./x.py install\n+   python x.py setup user && python x.py build && python x.py install\n    ```\n \n #### MSVC\n \n MSVC builds of Rust additionally require an installation of Visual Studio 2017\n-(or later) so `rustc` can use its linker.  The simplest way is to get the\n-[Visual Studio], check the \u201cC++ build tools\u201d and \u201cWindows 10 SDK\u201d workload.\n+(or later) so `rustc` can use its linker.  The simplest way is to get\n+[Visual Studio], check the \"C++ build tools\" and \"Windows 10 SDK\" workload.\n \n [Visual Studio]: https://visualstudio.microsoft.com/downloads/\n \n-(If you're installing cmake yourself, be careful that \u201cC++ CMake tools for\n-Windows\u201d doesn't get included under \u201cIndividual components\u201d.)\n+(If you're installing CMake yourself, be careful that \"C++ CMake tools for\n+Windows\" doesn't get included under \"Individual components\".)\n \n With these dependencies installed, you can build the compiler in a `cmd.exe`\n shell with:\n \n ```sh\n+python x.py setup user\n python x.py build\n ```\n \n-Currently, building Rust only works with some known versions of Visual Studio. If\n-you have a more recent version installed and the build system doesn't understand,\n-you may need to force rustbuild to use an older version. This can be done\n-by manually calling the appropriate vcvars file before running the bootstrap.\n+Right now, building Rust only works with some known versions of Visual Studio.\n+If you have a more recent version installed and the build system doesn't\n+understand, you may need to force rustbuild to use an older version.\n+This can be done by manually calling the appropriate vcvars file before running\n+the bootstrap.\n \n ```batch\n CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat\"\n@@ -191,98 +244,64 @@ Windows build triples are:\n     - `x86_64-pc-windows-msvc`\n \n The build triple can be specified by either specifying `--build=<triple>` when\n-invoking `x.py` commands, or by copying the `config.toml` file (as described\n-in [Installing From Source](#installing-from-source)), and modifying the\n-`build` option under the `[build]` section.\n-\n-### Configure and Make\n-\n-While it's not the recommended build system, this project also provides a\n-configure script and makefile (the latter of which just invokes `x.py`).\n-\n-```sh\n-./configure\n-make && sudo make install\n-```\n-\n-When using the configure script, the generated `config.mk` file may override the\n-`config.toml` file. To go back to the `config.toml` file, delete the generated\n-`config.mk` file.\n+invoking `x.py` commands, or by creating a `config.toml` file (as described in\n+[Building on a Unix-like system](#building-on-a-unix-like-system)), and passing `--set build.build=<triple>` to `./configure`.\n \n ## Building Documentation\n \n-If you\u2019d like to build the documentation, it\u2019s almost the same:\n+If you'd like to build the documentation, it's almost the same:\n \n ```sh\n ./x.py doc\n ```\n \n The generated documentation will appear under `doc` in the `build` directory for\n-the ABI used. I.e., if the ABI was `x86_64-pc-windows-msvc`, the directory will be\n-`build\\x86_64-pc-windows-msvc\\doc`.\n+the ABI used. That is, if the ABI was `x86_64-pc-windows-msvc`, the directory\n+will be `build\\x86_64-pc-windows-msvc\\doc`.\n \n ## Notes\n \n-Since the Rust compiler is written in Rust, it must be built by a\n-precompiled \"snapshot\" version of itself (made in an earlier stage of\n-development). As such, source builds require a connection to the Internet, to\n-fetch snapshots, and an OS that can execute the available snapshot binaries.\n-\n-Snapshot binaries are currently built and tested on several platforms:\n+Since the Rust compiler is written in Rust, it must be built by a precompiled\n+\"snapshot\" version of itself (made in an earlier stage of development).\n+As such, source builds require an Internet connection to fetch snapshots, and an\n+OS that can execute the available snapshot binaries.\n \n-| Platform / Architecture                     | x86 | x86_64 |\n-|---------------------------------------------|-----|--------|\n-| Windows (7, 8, 10, ...)                     | \u2713   | \u2713      |\n-| Linux (kernel 2.6.32, glibc 2.11 or later)  | \u2713   | \u2713      |\n-| macOS (10.7 Lion or later)                  | (\\*) | \u2713      |\n+See https://doc.rust-lang.org/nightly/rustc/platform-support.html for a list of\n+supported platforms.\n+Only \"host tools\" platforms have a pre-compiled snapshot binary available; to\n+compile for a platform without host tools you must cross-compile.\n \n-(\\*): Apple dropped support for running 32-bit binaries starting from macOS 10.15 and iOS 11.\n-Due to this decision from Apple, the targets are no longer useful to our users.\n-Please read [our blog post][macx32] for more info.\n-\n-[macx32]: https://blog.rust-lang.org/2020/01/03/reducing-support-for-32-bit-apple-targets.html\n-\n-You may find that other platforms work, but these are our officially\n-supported build environments that are most likely to work.\n+You may find that other platforms work, but these are our officially supported\n+build environments that are most likely to work.\n \n ## Getting Help\n \n-The Rust community congregates in a few places:\n-\n-* [Stack Overflow] - Direct questions about using the language.\n-* [users.rust-lang.org] - General discussion and broader questions.\n-* [/r/rust] - News and general discussion.\n-\n-[Stack Overflow]: https://stackoverflow.com/questions/tagged/rust\n-[/r/rust]: https://reddit.com/r/rust\n-[users.rust-lang.org]: https://users.rust-lang.org/\n+See https://www.rust-lang.org/community for a list of chat platforms and forums.\n \n ## Contributing\n \n-If you are interested in contributing to the Rust project, please take a look\n-at the [Getting Started][gettingstarted] guide in the [rustc-dev-guide].\n-\n-[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org\n+See [CONTRIBUTING.md](CONTRIBUTING.md).\n \n ## License\n \n-Rust is primarily distributed under the terms of both the MIT license\n-and the Apache License (Version 2.0), with portions covered by various\n-BSD-like licenses.\n+Rust is primarily distributed under the terms of both the MIT license and the\n+Apache License (Version 2.0), with portions covered by various BSD-like\n+licenses.\n \n See [LICENSE-APACHE](LICENSE-APACHE), [LICENSE-MIT](LICENSE-MIT), and\n [COPYRIGHT](COPYRIGHT) for details.\n \n ## Trademark\n \n [The Rust Foundation][rust-foundation] owns and protects the Rust and Cargo\n-trademarks and logos (the \u201cRust Trademarks\u201d).\n+trademarks and logos (the \"Rust Trademarks\").\n \n-If you want to use these names or brands, please read the [media guide][media-guide].\n+If you want to use these names or brands, please read the\n+[media guide][media-guide].\n \n Third-party logos may be subject to third-party copyrights and trademarks. See\n [Licenses][policies-licenses] for details.\n \n [rust-foundation]: https://foundation.rust-lang.org/\n-[media-guide]: https://www.rust-lang.org/policies/media-guide\n+[media-guide]: https://foundation.rust-lang.org/policies/logo-policy-and-media-guide/\n [policies-licenses]: https://www.rust-lang.org/policies/licenses"}, {"sha": "fa95df685aaa4bbd6a8e70e531ce380b2403303d", "filename": "RELEASES.md", "status": "modified", "additions": 1037, "deletions": 9, "changes": 1046, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -1,3 +1,1027 @@\n+Version 1.70.0 (2023-06-01)\n+==========================\n+\n+<a id=\"1.70.0-Language\"></a>\n+\n+Language\n+--------\n+- [Relax ordering rules for `asm!` operands](https://github.com/rust-lang/rust/pull/105798/)\n+- [Properly allow macro expanded `format_args` invocations to uses captures](https://github.com/rust-lang/rust/pull/106505/)\n+- [Lint ambiguous glob re-exports](https://github.com/rust-lang/rust/pull/107880/)\n+- [Perform const and unsafe checking for expressions in `let _ = expr` position.](https://github.com/rust-lang/rust/pull/102256/)\n+\n+<a id=\"1.70.0-Compiler\"></a>\n+\n+Compiler\n+--------\n+- [Extend -Cdebuginfo with new options and named aliases](https://github.com/rust-lang/rust/pull/109808/)\n+  This provides a smaller version of debuginfo for cases that only need line number information\n+  (`-Cdebuginfo=line-tables-only`), which may eventually become the default for `-Cdebuginfo=1`.\n+- [Make `unused_allocation` lint against `Box::new` too](https://github.com/rust-lang/rust/pull/104363/)\n+- [Detect uninhabited types early in const eval](https://github.com/rust-lang/rust/pull/109435/)\n+- [Switch to LLD as default linker for {arm,thumb}v4t-none-eabi](https://github.com/rust-lang/rust/pull/109721/)\n+- [Add tier 3 target `loongarch64-unknown-linux-gnu`](https://github.com/rust-lang/rust/pull/96971)\n+- [Add tier 3 target for `i586-pc-nto-qnx700` (QNX Neutrino RTOS, version 7.0)](https://github.com/rust-lang/rust/pull/109173/), \n+- [Insert alignment checks for pointer dereferences as debug assertions](https://github.com/rust-lang/rust/pull/98112)\n+  This catches undefined behavior at runtime, and may cause existing code to fail.\n+\n+Refer to Rust's [platform support page][platform-support-doc]\n+for more information on Rust's tiered platform support.\n+\n+<a id=\"1.70.0-Libraries\"></a>\n+\n+Libraries\n+---------\n+- [Document NonZeroXxx layout guarantees](https://github.com/rust-lang/rust/pull/94786/)\n+- [Windows: make `Command` prefer non-verbatim paths](https://github.com/rust-lang/rust/pull/96391/)\n+- [Implement Default for some alloc/core iterators](https://github.com/rust-lang/rust/pull/99929/)\n+- [Fix handling of trailing bare CR in str::lines](https://github.com/rust-lang/rust/pull/100311/)\n+- [allow negative numeric literals in `concat!`](https://github.com/rust-lang/rust/pull/106844/)\n+- [Add documentation about the memory layout of `Cell`](https://github.com/rust-lang/rust/pull/106921/)\n+- [Use `partial_cmp` to implement tuple `lt`/`le`/`ge`/`gt`](https://github.com/rust-lang/rust/pull/108157/)\n+- [Stabilize `atomic_as_ptr`](https://github.com/rust-lang/rust/pull/108419/)\n+- [Stabilize `nonnull_slice_from_raw_parts`](https://github.com/rust-lang/rust/pull/97506/)\n+- [Partial stabilization of `once_cell`](https://github.com/rust-lang/rust/pull/105587/)\n+- [Stabilize `nonzero_min_max`](https://github.com/rust-lang/rust/pull/106633/)\n+- [Flatten/inline format_args!() and (string and int) literal arguments into format_args!()](https://github.com/rust-lang/rust/pull/106824/)\n+- [Stabilize movbe target feature](https://github.com/rust-lang/rust/pull/107711/)\n+- [don't splice from files into pipes in io::copy](https://github.com/rust-lang/rust/pull/108283/)\n+- [Add a builtin unstable `FnPtr` trait that is implemented for all function pointers](https://github.com/rust-lang/rust/pull/108080/)\n+  This extends `Debug`, `Pointer`, `Hash`, `PartialEq`, `Eq`, `PartialOrd`, and `Ord`\n+  implementations for function pointers with all ABIs.\n+\n+<a id=\"1.70.0-Stabilized-APIs\"></a>\n+\n+Stabilized APIs\n+---------------\n+\n+- [`NonZero*::MIN/MAX`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroI8.html#associatedconstant.MIN)\n+- [`BinaryHeap::retain`](https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html#method.retain)\n+- [`Default for std::collections::binary_heap::IntoIter`](https://doc.rust-lang.org/stable/std/collections/binary_heap/struct.IntoIter.html)\n+- [`Default for std::collections::btree_map::{IntoIter, Iter, IterMut}`](https://doc.rust-lang.org/stable/std/collections/btree_map/struct.IntoIter.html)\n+- [`Default for std::collections::btree_map::{IntoKeys, Keys}`](https://doc.rust-lang.org/stable/std/collections/btree_map/struct.IntoKeys.html)\n+- [`Default for std::collections::btree_map::{IntoValues, Values}`](https://doc.rust-lang.org/stable/std/collections/btree_map/struct.IntoKeys.html)\n+- [`Default for std::collections::btree_map::Range`](https://doc.rust-lang.org/stable/std/collections/btree_map/struct.Range.html)\n+- [`Default for std::collections::btree_set::{IntoIter, Iter}`](https://doc.rust-lang.org/stable/std/collections/btree_set/struct.IntoIter.html)\n+- [`Default for std::collections::btree_set::Range`](https://doc.rust-lang.org/stable/std/collections/btree_set/struct.Range.html)\n+- [`Default for std::collections::linked_list::{IntoIter, Iter, IterMut}`](https://doc.rust-lang.org/stable/alloc/collections/linked_list/struct.IntoIter.html)\n+- [`Default for std::vec::IntoIter`](https://doc.rust-lang.org/stable/alloc/vec/struct.IntoIter.html#impl-Default-for-IntoIter%3CT,+A%3E)\n+- [`Default for std::iter::Chain`](https://doc.rust-lang.org/stable/std/iter/struct.Chain.html)\n+- [`Default for std::iter::Cloned`](https://doc.rust-lang.org/stable/std/iter/struct.Cloned.html)\n+- [`Default for std::iter::Copied`](https://doc.rust-lang.org/stable/std/iter/struct.Copied.html)\n+- [`Default for std::iter::Enumerate`](https://doc.rust-lang.org/stable/std/iter/struct.Enumerate.html)\n+- [`Default for std::iter::Flatten`](https://doc.rust-lang.org/stable/std/iter/struct.Flatten.html)\n+- [`Default for std::iter::Fuse`](https://doc.rust-lang.org/stable/std/iter/struct.Fuse.html)\n+- [`Default for std::iter::Rev`](https://doc.rust-lang.org/stable/std/iter/struct.Rev.html)\n+- [`Default for std::slice::Iter`](https://doc.rust-lang.org/stable/std/slice/struct.Iter.html)\n+- [`Default for std::slice::IterMut`](https://doc.rust-lang.org/stable/std/slice/struct.IterMut.html)\n+- [`Rc::into_inner`](https://doc.rust-lang.org/stable/alloc/rc/struct.Rc.html#method.into_inner)\n+- [`Arc::into_inner`](https://doc.rust-lang.org/stable/alloc/sync/struct.Arc.html#method.into_inner)\n+- [`std::cell::OnceCell`](https://doc.rust-lang.org/stable/std/cell/struct.OnceCell.html)\n+- [`Option::is_some_and`](https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.is_some_and)\n+- [`NonNull::slice_from_raw_parts`](https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.slice_from_raw_parts)\n+- [`Result::is_ok_and`](https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.is_ok_and)\n+- [`Result::is_err_and`](https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.is_err_and)\n+- [`std::sync::atomic::Atomic*::as_ptr`](https://doc.rust-lang.org/stable/std/sync/atomic/struct.AtomicU8.html#method.as_ptr)\n+- [`std::io::IsTerminal`](https://doc.rust-lang.org/stable/std/io/trait.IsTerminal.html)\n+- [`std::os::linux::net::SocketAddrExt`](https://doc.rust-lang.org/stable/std/os/linux/net/trait.SocketAddrExt.html)\n+- [`std::os::unix::net::UnixDatagram::bind_addr`](https://doc.rust-lang.org/stable/std/os/unix/net/struct.UnixDatagram.html#method.bind_addr)\n+- [`std::os::unix::net::UnixDatagram::connect_addr`](https://doc.rust-lang.org/stable/std/os/unix/net/struct.UnixDatagram.html#method.connect_addr)\n+- [`std::os::unix::net::UnixDatagram::send_to_addr`](https://doc.rust-lang.org/stable/std/os/unix/net/struct.UnixDatagram.html#method.send_to_addr)\n+- [`std::os::unix::net::UnixListener::bind_addr`](https://doc.rust-lang.org/stable/std/os/unix/net/struct.UnixListener.html#method.bind_addr)\n+- [`std::path::Path::as_mut_os_str`](https://doc.rust-lang.org/stable/std/path/struct.Path.html#method.as_mut_os_str)\n+- [`std::sync::OnceLock`](https://doc.rust-lang.org/stable/std/sync/struct.OnceLock.html)\n+\n+<a id=\"1.70.0-Cargo\"></a>\n+\n+Cargo\n+-----\n+\n+- [Add `CARGO_PKG_README`](https://github.com/rust-lang/cargo/pull/11645/)\n+- [Make `sparse` the default protocol for crates.io](https://github.com/rust-lang/cargo/pull/11791/)\n+- [Accurately show status when downgrading dependencies](https://github.com/rust-lang/cargo/pull/11839/)\n+- [Use registry.default for login/logout](https://github.com/rust-lang/cargo/pull/11949/)\n+- [Stabilize `cargo logout`](https://github.com/rust-lang/cargo/pull/11950/)\n+\n+<a id=\"1.70.0-Misc\"></a>\n+\n+Misc\n+----\n+\n+- [Stabilize rustdoc `--test-run-directory`](https://github.com/rust-lang/rust/pull/103682/)\n+\n+<a id=\"1.70.0-Compatibility-Notes\"></a>\n+\n+Compatibility Notes\n+-------------------\n+\n+- [Prevent stable `libtest` from supporting `-Zunstable-options`](https://github.com/rust-lang/rust/pull/109044/)\n+- [Perform const and unsafe checking for expressions in `let _ = expr` position.](https://github.com/rust-lang/rust/pull/102256/)\n+- [WebAssembly targets enable `sign-ext` and `mutable-globals` features in codegen](https://github.com/rust-lang/rust/issues/109807)\n+  This may cause incompatibility with older execution environments.\n+- [Insert alignment checks for pointer dereferences as debug assertions](https://github.com/rust-lang/rust/pull/98112)\n+  This catches undefined behavior at runtime, and may cause existing code to fail.\n+\n+<a id=\"1.70.0-Internal-Changes\"></a>\n+\n+Internal Changes\n+----------------\n+\n+These changes do not affect any public interfaces of Rust, but they represent\n+significant improvements to the performance or internals of rustc and related\n+tools.\n+\n+- [Upgrade to LLVM 16](https://github.com/rust-lang/rust/pull/109474/)\n+- [Use SipHash-1-3 instead of SipHash-2-4 for StableHasher](https://github.com/rust-lang/rust/pull/107925/)\n+\n+Version 1.69.0 (2023-04-20)\n+==========================\n+\n+<a id=\"1.69.0-Language\"></a>\n+\n+Language\n+--------\n+\n+- [Deriving built-in traits on packed structs works with `Copy` fields.](https://github.com/rust-lang/rust/pull/104429/)\n+- [Stabilize the `cmpxchg16b` target feature on x86 and x86_64.](https://github.com/rust-lang/rust/pull/106774/)\n+- [Improve analysis of trait bounds for associated types.](https://github.com/rust-lang/rust/pull/103695/)\n+- [Allow associated types to be used as union fields.](https://github.com/rust-lang/rust/pull/106938/)\n+- [Allow `Self: Autotrait` bounds on dyn-safe trait methods.](https://github.com/rust-lang/rust/pull/107082/)\n+- [Treat `str` as containing `[u8]` for auto trait purposes.](https://github.com/rust-lang/rust/pull/107941/)\n+\n+<a id=\"1.69.0-Compiler\"></a>\n+\n+Compiler\n+--------\n+\n+- [Upgrade `*-pc-windows-gnu` on CI to mingw-w64 v10 and GCC 12.2.](https://github.com/rust-lang/rust/pull/100178/)\n+- [Rework min_choice algorithm of member constraints.](https://github.com/rust-lang/rust/pull/105300/)\n+- [Support `true` and `false` as boolean flags in compiler arguments.](https://github.com/rust-lang/rust/pull/107043/)\n+- [Default `repr(C)` enums to `c_int` size.](https://github.com/rust-lang/rust/pull/107592/)\n+\n+<a id=\"1.69.0-Libraries\"></a>\n+\n+Libraries\n+---------\n+\n+- [Implement the unstable `DispatchFromDyn` for cell types, allowing downstream experimentation with custom method receivers.](https://github.com/rust-lang/rust/pull/97373/)\n+- [Document that `fmt::Arguments::as_str()` may return `Some(_)` in more cases after optimization, subject to change.](https://github.com/rust-lang/rust/pull/106823/)\n+- [Implement `AsFd` and `AsRawFd` for `Rc`.](https://github.com/rust-lang/rust/pull/107317/)\n+\n+<a id=\"1.69.0-Stabilized-APIs\"></a>\n+\n+Stabilized APIs\n+---------------\n+\n+- [`CStr::from_bytes_until_nul`](https://doc.rust-lang.org/stable/core/ffi/struct.CStr.html#method.from_bytes_until_nul)\n+- [`core::ffi::FromBytesUntilNulError`](https://doc.rust-lang.org/stable/core/ffi/struct.FromBytesUntilNulError.html)\n+\n+These APIs are now stable in const contexts:\n+\n+- [`SocketAddr::new`](https://doc.rust-lang.org/stable/std/net/enum.SocketAddr.html#method.new)\n+- [`SocketAddr::ip`](https://doc.rust-lang.org/stable/std/net/enum.SocketAddr.html#method.ip)\n+- [`SocketAddr::port`](https://doc.rust-lang.org/stable/std/net/enum.SocketAddr.html#method.port)\n+- [`SocketAddr::is_ipv4`](https://doc.rust-lang.org/stable/std/net/enum.SocketAddr.html#method.is_ipv4)\n+- [`SocketAddr::is_ipv6`](https://doc.rust-lang.org/stable/std/net/enum.SocketAddr.html#method.is_ipv6)\n+- [`SocketAddrV4::new`](https://doc.rust-lang.org/stable/std/net/struct.SocketAddrV4.html#method.new)\n+- [`SocketAddrV4::ip`](https://doc.rust-lang.org/stable/std/net/struct.SocketAddrV4.html#method.ip)\n+- [`SocketAddrV4::port`](https://doc.rust-lang.org/stable/std/net/struct.SocketAddrV4.html#method.port)\n+- [`SocketAddrV6::new`](https://doc.rust-lang.org/stable/std/net/struct.SocketAddrV6.html#method.new)\n+- [`SocketAddrV6::ip`](https://doc.rust-lang.org/stable/std/net/struct.SocketAddrV6.html#method.ip)\n+- [`SocketAddrV6::port`](https://doc.rust-lang.org/stable/std/net/struct.SocketAddrV6.html#method.port)\n+- [`SocketAddrV6::flowinfo`](https://doc.rust-lang.org/stable/std/net/struct.SocketAddrV6.html#method.flowinfo)\n+- [`SocketAddrV6::scope_id`](https://doc.rust-lang.org/stable/std/net/struct.SocketAddrV6.html#method.scope_id)\n+\n+<a id=\"1.69.0-Cargo\"></a>\n+\n+Cargo\n+-----\n+\n+- [Cargo now suggests `cargo fix` or `cargo clippy --fix` when compilation warnings are auto-fixable.](https://github.com/rust-lang/cargo/pull/11558/)\n+- [Cargo now suggests `cargo add` if you try to install a library crate.](https://github.com/rust-lang/cargo/pull/11410/)\n+- [Cargo now sets the `CARGO_BIN_NAME` environment variable also for binary examples.](https://github.com/rust-lang/cargo/pull/11705/)\n+\n+<a id=\"1.69.0-Rustdoc\"></a>\n+\n+Rustdoc\n+-----\n+\n+- [Vertically compact trait bound formatting.](https://github.com/rust-lang/rust/pull/102842/)\n+- [Only include stable lints in `rustdoc::all` group.](https://github.com/rust-lang/rust/pull/106316/)\n+- [Compute maximum Levenshtein distance based on the query.](https://github.com/rust-lang/rust/pull/107141/)\n+- [Remove inconsistently-present sidebar tooltips.](https://github.com/rust-lang/rust/pull/107490/)\n+- [Search by macro when query ends with `!`.](https://github.com/rust-lang/rust/pull/108143/)\n+\n+<a id=\"1.69.0-Compatibility-Notes\"></a>\n+\n+Compatibility Notes\n+-------------------\n+\n+- [The `rust-analysis` component from `rustup` now only contains a warning placeholder.](https://github.com/rust-lang/rust/pull/101841/) This was primarily intended for RLS, and the corresponding `-Zsave-analysis` flag has been removed from the compiler as well.\n+- [Unaligned references to packed fields are now a hard error.](https://github.com/rust-lang/rust/pull/102513/) This has been a warning since 1.53, and denied by default with a future-compatibility warning since 1.62.\n+- [Update the minimum external LLVM to 14.](https://github.com/rust-lang/rust/pull/107573/)\n+- [Cargo now emits errors on invalid characters in a registry token.](https://github.com/rust-lang/cargo/pull/11600/)\n+- [When `default-features` is set to false of a workspace dependency, and an inherited dependency of a member has `default-features = true`, Cargo will enable default features of that dependency.](https://github.com/rust-lang/cargo/pull/11409/)\n+- [Cargo denies `CARGO_HOME` in the `[env]` configuration table. Cargo itself doesn't pick up this value, but recursive calls to cargo would, which was not intended.](https://github.com/rust-lang/cargo/pull/11644/)\n+- [Debuginfo for build dependencies is now off if not explicitly set. This is expected to improve the overall build time.](https://github.com/rust-lang/cargo/pull/11252/)\n+- [The Rust distribution no longer always includes rustdoc](https://github.com/rust-lang/rust/pull/106886)\n+  If `tools = [...]` is set in config.toml, we will respect a missing rustdoc in that list. By\n+  default rustdoc remains included. To retain the prior behavior explicitly add `\"rustdoc\"` to the\n+  list.\n+  \n+<a id=\"1.69.0-Internal-Changes\"></a>\n+\n+Internal Changes\n+----------------\n+\n+These changes do not affect any public interfaces of Rust, but they represent\n+significant improvements to the performance or internals of rustc and related\n+tools.\n+\n+- [Move `format_args!()` into AST (and expand it during AST lowering)](https://github.com/rust-lang/rust/pull/106745/)\n+\n+Version 1.68.2 (2023-03-28)\n+===========================\n+\n+- [Update the GitHub RSA host key bundled within Cargo](https://github.com/rust-lang/cargo/pull/11883).\n+  The key was [rotated by GitHub](https://github.blog/2023-03-23-we-updated-our-rsa-ssh-host-key/)\n+  on 2023-03-24 after the old one leaked.\n+- [Mark the old GitHub RSA host key as revoked](https://github.com/rust-lang/cargo/pull/11889).\n+  This will prevent Cargo from accepting the leaked key even when trusted by\n+  the system.\n+- [Add support for `@revoked` and a better error message for `@cert-authority` in Cargo's SSH host key verification](https://github.com/rust-lang/cargo/pull/11635)\n+\n+Version 1.68.1 (2023-03-23)\n+===========================\n+\n+- [Fix miscompilation in produced Windows MSVC artifacts](https://github.com/rust-lang/rust/pull/109094)\n+  This was introduced by enabling ThinLTO for the distributed rustc which led\n+  to miscompilations in the resulting binary. Currently this is believed to be\n+  limited to the -Zdylib-lto flag used for rustc compilation, rather than a\n+  general bug in ThinLTO, so only rustc artifacts should be affected.\n+- [Fix --enable-local-rust builds](https://github.com/rust-lang/rust/pull/109111/)\n+- [Treat `$prefix-clang` as `clang` in linker detection code](https://github.com/rust-lang/rust/pull/109156)\n+- [Fix panic in compiler code](https://github.com/rust-lang/rust/pull/108162)\n+\n+Version 1.68.0 (2023-03-09)\n+==========================\n+\n+<a id=\"1.68.0-Language\"></a>\n+\n+Language\n+--------\n+\n+- [Stabilize default_alloc_error_handler](https://github.com/rust-lang/rust/pull/102318/)\n+  This allows usage of `alloc` on stable without requiring the \n+  definition of a handler for allocation failure. Defining custom handlers is still unstable.\n+- [Stabilize `efiapi` calling convention.](https://github.com/rust-lang/rust/pull/105795/)\n+- [Remove implicit promotion for types with drop glue](https://github.com/rust-lang/rust/pull/105085/)\n+\n+<a id=\"1.68.0-Compiler\"></a>\n+\n+Compiler\n+--------\n+\n+- [Change `bindings_with_variant_name` to deny-by-default](https://github.com/rust-lang/rust/pull/104154/)\n+- [Allow .. to be parsed as let initializer](https://github.com/rust-lang/rust/pull/105701/)\n+- [Add `armv7-sony-vita-newlibeabihf` as a tier 3 target](https://github.com/rust-lang/rust/pull/105712/)\n+- [Always check alignment during compile-time const evaluation](https://github.com/rust-lang/rust/pull/104616/)\n+- [Disable \"split dwarf inlining\" by default.](https://github.com/rust-lang/rust/pull/106709/)\n+- [Add vendor to Fuchsia's target triple](https://github.com/rust-lang/rust/pull/106429/)\n+- [Enable sanitizers for s390x-linux](https://github.com/rust-lang/rust/pull/107127/)\n+\n+<a id=\"1.68.0-Libraries\"></a>\n+\n+Libraries\n+---------\n+\n+- [Loosen the bound on the Debug implementation of Weak.](https://github.com/rust-lang/rust/pull/90291/)\n+- [Make `std::task::Context` !Send and !Sync](https://github.com/rust-lang/rust/pull/95985/)\n+- [PhantomData layout guarantees](https://github.com/rust-lang/rust/pull/104081/)\n+- [Don't derive Debug for `OnceWith` & `RepeatWith`](https://github.com/rust-lang/rust/pull/104163/)\n+- [Implement DerefMut for PathBuf](https://github.com/rust-lang/rust/pull/105018/)\n+- [Add O(1) `Vec -> VecDeque` conversion guarantee](https://github.com/rust-lang/rust/pull/105128/)\n+- [Leak amplification for peek_mut() to ensure BinaryHeap's invariant is always met](https://github.com/rust-lang/rust/pull/105851/)\n+\n+<a id=\"1.68.0-Stabilized-APIs\"></a>\n+\n+Stabilized APIs\n+---------------\n+\n+- [`{core,std}::pin::pin!`](https://doc.rust-lang.org/stable/std/pin/macro.pin.html)\n+- [`impl From<bool> for {f32,f64}`](https://doc.rust-lang.org/stable/std/primitive.f32.html#impl-From%3Cbool%3E-for-f32)\n+- [`std::path::MAIN_SEPARATOR_STR`](https://doc.rust-lang.org/stable/std/path/constant.MAIN_SEPARATOR_STR.html)\n+- [`impl DerefMut for PathBuf`](https://doc.rust-lang.org/stable/std/path/struct.PathBuf.html#impl-DerefMut-for-PathBuf)\n+\n+These APIs are now stable in const contexts:\n+\n+- [`VecDeque::new`](https://doc.rust-lang.org/stable/std/collections/struct.VecDeque.html#method.new)\n+\n+<a id=\"1.68.0-Cargo\"></a>\n+\n+Cargo\n+-----\n+\n+- [Stabilize sparse registry support for crates.io](https://github.com/rust-lang/cargo/pull/11224/)\n+- [`cargo build --verbose` tells you more about why it recompiles.](https://github.com/rust-lang/cargo/pull/11407/)\n+- [Show progress of crates.io index update even `net.git-fetch-with-cli` option enabled](https://github.com/rust-lang/cargo/pull/11579/)\n+\n+<a id=\"1.68.0-Misc\"></a>\n+\n+Misc\n+----\n+\n+<a id=\"1.68.0-Compatibility-Notes\"></a>\n+\n+Compatibility Notes\n+-------------------\n+\n+- [Only support Android NDK 25 or newer](https://blog.rust-lang.org/2023/01/09/android-ndk-update-r25.html)\n+- [Add `SEMICOLON_IN_EXPRESSIONS_FROM_MACROS` to future-incompat report](https://github.com/rust-lang/rust/pull/103418/)\n+- [Only specify `--target` by default for `-Zgcc-ld=lld` on wasm](https://github.com/rust-lang/rust/pull/101792/)\n+- [Bump `IMPLIED_BOUNDS_ENTAILMENT` to Deny + ReportNow](https://github.com/rust-lang/rust/pull/106465/)\n+- [`std::task::Context` no longer implements Send and Sync](https://github.com/rust-lang/rust/pull/95985)\n+\n+<a id=\"1.68.0-Internal-Changes\"></a>\n+\n+Internal Changes\n+----------------\n+\n+These changes do not affect any public interfaces of Rust, but they represent\n+significant improvements to the performance or internals of rustc and related\n+tools.\n+\n+- [Encode spans relative to the enclosing item](https://github.com/rust-lang/rust/pull/84762/)\n+- [Don't normalize in AstConv](https://github.com/rust-lang/rust/pull/101947/)\n+- [Find the right lower bound region in the scenario of partial order relations](https://github.com/rust-lang/rust/pull/104765/)\n+- [Fix impl block in const expr](https://github.com/rust-lang/rust/pull/104889/)\n+- [Check ADT fields for copy implementations considering regions](https://github.com/rust-lang/rust/pull/105102/)\n+- [rustdoc: simplify JS search routine by not messing with lev distance](https://github.com/rust-lang/rust/pull/105796/)\n+- [Enable ThinLTO for rustc on `x86_64-pc-windows-msvc`](https://github.com/rust-lang/rust/pull/103591/)\n+- [Enable ThinLTO for rustc on `x86_64-apple-darwin`](https://github.com/rust-lang/rust/pull/103647/)\n+\n+Version 1.67.1 (2023-02-09)\n+===========================\n+\n+- [Fix interoperability with thin archives.](https://github.com/rust-lang/rust/pull/107360)\n+- [Fix an internal error in the compiler build process.](https://github.com/rust-lang/rust/pull/105624)\n+- [Downgrade `clippy::uninlined_format_args` to pedantic.](https://github.com/rust-lang/rust-clippy/pull/10265)\n+\n+Version 1.67.0 (2023-01-26)\n+==========================\n+\n+<a id=\"1.67.0-Language\"></a>\n+\n+Language\n+--------\n+\n+- [Make `Sized` predicates coinductive, allowing cycles.](https://github.com/rust-lang/rust/pull/100386/)\n+- [`#[must_use]` annotations on `async fn` also affect the `Future::Output`.](https://github.com/rust-lang/rust/pull/100633/)\n+- [Elaborate supertrait obligations when deducing closure signatures.](https://github.com/rust-lang/rust/pull/101834/)\n+- [Invalid literals are no longer an error under `cfg(FALSE)`.](https://github.com/rust-lang/rust/pull/102944/)\n+- [Unreserve braced enum variants in value namespace.](https://github.com/rust-lang/rust/pull/103578/)\n+\n+<a id=\"1.67.0-Compiler\"></a>\n+\n+Compiler\n+--------\n+\n+- [Enable varargs support for calling conventions other than `C` or `cdecl`.](https://github.com/rust-lang/rust/pull/97971/)\n+- [Add new MIR constant propagation based on dataflow analysis.](https://github.com/rust-lang/rust/pull/101168/)\n+- [Optimize field ordering by grouping m\\*2^n-sized fields with equivalently aligned ones.](https://github.com/rust-lang/rust/pull/102750/)\n+- [Stabilize native library modifier `verbatim`.](https://github.com/rust-lang/rust/pull/104360/)\n+\n+Added, updated, and removed targets:\n+\n+- [Add a tier 3 target for PowerPC on AIX](https://github.com/rust-lang/rust/pull/102293/), `powerpc64-ibm-aix`.\n+- [Add a tier 3 target for the Sony PlayStation 1](https://github.com/rust-lang/rust/pull/102689/), `mipsel-sony-psx`.\n+- [Add tier 3 `no_std` targets for the QNX Neutrino RTOS](https://github.com/rust-lang/rust/pull/102701/),\n+  `aarch64-unknown-nto-qnx710` and `x86_64-pc-nto-qnx710`.\n+- [Promote UEFI targets to tier 2](https://github.com/rust-lang/rust/pull/103933/), `aarch64-unknown-uefi`, `i686-unknown-uefi`, and `x86_64-unknown-uefi`.\n+- [Remove tier 3 `linuxkernel` targets](https://github.com/rust-lang/rust/pull/104015/) (not used by the actual kernel).\n+\n+Refer to Rust's [platform support page][platform-support-doc]\n+for more information on Rust's tiered platform support.\n+\n+<a id=\"1.67.0-Libraries\"></a>\n+\n+Libraries\n+---------\n+\n+- [Merge `crossbeam-channel` into `std::sync::mpsc`.](https://github.com/rust-lang/rust/pull/93563/)\n+- [Fix inconsistent rounding of 0.5 when formatted to 0 decimal places.](https://github.com/rust-lang/rust/pull/102935/)\n+- [Derive `Eq` and `Hash` for `ControlFlow`.](https://github.com/rust-lang/rust/pull/103084/)\n+- [Don't build `compiler_builtins` with `-C panic=abort`.](https://github.com/rust-lang/rust/pull/103786/)\n+\n+<a id=\"1.67.0-Stabilized-APIs\"></a>\n+\n+Stabilized APIs\n+---------------\n+\n+- [`{integer}::checked_ilog`](https://doc.rust-lang.org/stable/std/primitive.i32.html#method.checked_ilog)\n+- [`{integer}::checked_ilog2`](https://doc.rust-lang.org/stable/std/primitive.i32.html#method.checked_ilog2)\n+- [`{integer}::checked_ilog10`](https://doc.rust-lang.org/stable/std/primitive.i32.html#method.checked_ilog10)\n+- [`{integer}::ilog`](https://doc.rust-lang.org/stable/std/primitive.i32.html#method.ilog)\n+- [`{integer}::ilog2`](https://doc.rust-lang.org/stable/std/primitive.i32.html#method.ilog2)\n+- [`{integer}::ilog10`](https://doc.rust-lang.org/stable/std/primitive.i32.html#method.ilog10)\n+- [`NonZeroU*::ilog2`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroU32.html#method.ilog2)\n+- [`NonZeroU*::ilog10`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroU32.html#method.ilog10)\n+- [`NonZero*::BITS`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroU32.html#associatedconstant.BITS)\n+\n+These APIs are now stable in const contexts:\n+\n+- [`char::from_u32`](https://doc.rust-lang.org/stable/std/primitive.char.html#method.from_u32)\n+- [`char::from_digit`](https://doc.rust-lang.org/stable/std/primitive.char.html#method.from_digit)\n+- [`char::to_digit`](https://doc.rust-lang.org/stable/std/primitive.char.html#method.to_digit)\n+- [`core::char::from_u32`](https://doc.rust-lang.org/stable/core/char/fn.from_u32.html)\n+- [`core::char::from_digit`](https://doc.rust-lang.org/stable/core/char/fn.from_digit.html)\n+\n+<a id=\"1.67.0-Compatibility-Notes\"></a>\n+\n+Compatibility Notes\n+-------------------\n+\n+- [The layout of `repr(Rust)` types now groups m\\*2^n-sized fields with\n+  equivalently aligned ones.](https://github.com/rust-lang/rust/pull/102750/)\n+  This is intended to be an optimization, but it is also known to increase type\n+  sizes in a few cases for the placement of enum tags. As a reminder, the layout\n+  of `repr(Rust)` types is an implementation detail, subject to change.\n+- [0.5 now rounds to 0 when formatted to 0 decimal places.](https://github.com/rust-lang/rust/pull/102935/)\n+  This makes it consistent with the rest of floating point formatting that\n+  rounds ties toward even digits.\n+- [Chains of `&&` and `||` will now drop temporaries from their sub-expressions in\n+  evaluation order, left-to-right.](https://github.com/rust-lang/rust/pull/103293/)\n+  Previously, it was \"twisted\" such that the _first_ expression dropped its\n+  temporaries _last_, after all of the other expressions dropped in order.\n+- [Underscore suffixes on string literals are now a hard error.](https://github.com/rust-lang/rust/pull/103914/)\n+  This has been a future-compatibility warning since 1.20.0.\n+- [Stop passing `-export-dynamic` to `wasm-ld`.](https://github.com/rust-lang/rust/pull/105405/)\n+- [`main` is now mangled as `__main_void` on `wasm32-wasi`.](https://github.com/rust-lang/rust/pull/105468/)\n+- [Cargo now emits an error if there are multiple registries in the configuration\n+  with the same index URL.](https://github.com/rust-lang/cargo/pull/10592)\n+\n+<a id=\"1.67.0-Internal-Changes\"></a>\n+\n+Internal Changes\n+----------------\n+\n+These changes do not affect any public interfaces of Rust, but they represent\n+significant improvements to the performance or internals of rustc and related\n+tools.\n+\n+- [Rewrite LLVM's archive writer in Rust.](https://github.com/rust-lang/rust/pull/97485/)\n+\n+Version 1.66.1 (2023-01-10)\n+===========================\n+\n+- Added validation of SSH host keys for git URLs in Cargo ([CVE-2022-46176](https://www.cve.org/CVERecord?id=CVE-2022-46176))\n+\n+Version 1.66.0 (2022-12-15)\n+==========================\n+\n+Language\n+--------\n+- [Permit specifying explicit discriminants on all `repr(Int)` enums](https://github.com/rust-lang/rust/pull/95710/)\n+  ```rust\n+  #[repr(u8)]\n+  enum Foo {\n+      A(u8) = 0,\n+      B(i8) = 1,\n+      C(bool) = 42,\n+  }\n+  ```\n+- [Allow transmutes between the same type differing only in lifetimes](https://github.com/rust-lang/rust/pull/101520/)\n+- [Change constant evaluation errors from a deny-by-default lint to a hard error](https://github.com/rust-lang/rust/pull/102091/)\n+- [Trigger `must_use` on `impl Trait` for supertraits](https://github.com/rust-lang/rust/pull/102287/)\n+  This makes `impl ExactSizeIterator` respect the existing `#[must_use]` annotation on `Iterator`.\n+- [Allow `..=X` in patterns](https://github.com/rust-lang/rust/pull/102275/)\n+- [Uplift `clippy::for_loops_over_fallibles` lint into rustc](https://github.com/rust-lang/rust/pull/99696/)\n+- [Stabilize `sym` operands in inline assembly](https://github.com/rust-lang/rust/pull/103168/)\n+- [Update to Unicode 15](https://github.com/rust-lang/rust/pull/101912/)\n+- [Opaque types no longer imply lifetime bounds](https://github.com/rust-lang/rust/pull/95474/)\n+  This is a soundness fix which may break code that was erroneously relying on this behavior.\n+\n+Compiler\n+--------\n+- [Add armv5te-none-eabi and thumbv5te-none-eabi tier 3 targets](https://github.com/rust-lang/rust/pull/101329/)\n+  - Refer to Rust's [platform support page][platform-support-doc] for more\n+    information on Rust's tiered platform support.\n+- [Add support for linking against macOS universal libraries](https://github.com/rust-lang/rust/pull/98736)\n+\n+Libraries\n+---------\n+- [Fix `#[derive(Default)]` on a generic `#[default]` enum adding unnecessary `Default` bounds](https://github.com/rust-lang/rust/pull/101040/)\n+- [Update to Unicode 15](https://github.com/rust-lang/rust/pull/101821/)\n+\n+Stabilized APIs\n+---------------\n+\n+- [`proc_macro::Span::source_text`](https://doc.rust-lang.org/stable/proc_macro/struct.Span.html#method.source_text)\n+- [`uX::{checked_add_signed, overflowing_add_signed, saturating_add_signed, wrapping_add_signed}`](https://doc.rust-lang.org/stable/std/primitive.u8.html#method.checked_add_signed)\n+- [`iX::{checked_add_unsigned, overflowing_add_unsigned, saturating_add_unsigned, wrapping_add_unsigned}`](https://doc.rust-lang.org/stable/std/primitive.i8.html#method.checked_add_unsigned)\n+- [`iX::{checked_sub_unsigned, overflowing_sub_unsigned, saturating_sub_unsigned, wrapping_sub_unsigned}`](https://doc.rust-lang.org/stable/std/primitive.i8.html#method.checked_sub_unsigned)\n+- [`BTreeSet::{first, last, pop_first, pop_last}`](https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html#method.first)\n+- [`BTreeMap::{first_key_value, last_key_value, first_entry, last_entry, pop_first, pop_last}`](https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html#method.first_key_value)\n+- [Add `AsFd` implementations for stdio lock types on WASI.](https://github.com/rust-lang/rust/pull/101768/)\n+- [`impl TryFrom<Vec<T>> for Box<[T; N]>`](https://doc.rust-lang.org/stable/std/boxed/struct.Box.html#impl-TryFrom%3CVec%3CT%2C%20Global%3E%3E-for-Box%3C%5BT%3B%20N%5D%2C%20Global%3E)\n+- [`core::hint::black_box`](https://doc.rust-lang.org/stable/std/hint/fn.black_box.html)\n+- [`Duration::try_from_secs_{f32,f64}`](https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.try_from_secs_f32)\n+- [`Option::unzip`](https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.unzip)\n+- [`std::os::fd`](https://doc.rust-lang.org/stable/std/os/fd/index.html)\n+\n+\n+Rustdoc\n+-------\n+\n+- [Add Rustdoc warning for invalid HTML tags in the documentation](https://github.com/rust-lang/rust/pull/101720/)\n+\n+Cargo\n+-----\n+\n+- [Added `cargo remove` to remove dependencies from Cargo.toml](https://doc.rust-lang.org/nightly/cargo/commands/cargo-remove.html)\n+- [`cargo publish` now waits for the new version to be downloadable before exiting](https://github.com/rust-lang/cargo/pull/11062)\n+\n+See [detailed release notes](https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-166-2022-12-15) for more.\n+\n+Compatibility Notes\n+-------------------\n+\n+- [Only apply `ProceduralMasquerade` hack to older versions of `rental`](https://github.com/rust-lang/rust/pull/94063/)\n+- [Don't export `__heap_base` and `__data_end` on wasm32-wasi.](https://github.com/rust-lang/rust/pull/102385/)\n+- [Don't export `__wasm_init_memory` on WebAssembly.](https://github.com/rust-lang/rust/pull/102426/)\n+- [Only export `__tls_*` on wasm32-unknown-unknown.](https://github.com/rust-lang/rust/pull/102440/)\n+- [Don't link to `libresolv` in libstd on Darwin](https://github.com/rust-lang/rust/pull/102766/)\n+- [Update libstd's libc to 0.2.135 (to make `libstd` no longer pull in `libiconv.dylib` on Darwin)](https://github.com/rust-lang/rust/pull/103277/)\n+- [Opaque types no longer imply lifetime bounds](https://github.com/rust-lang/rust/pull/95474/)\n+  This is a soundness fix which may break code that was erroneously relying on this behavior.\n+- [Make `order_dependent_trait_objects` show up in future-breakage reports](https://github.com/rust-lang/rust/pull/102635/)\n+- [Change std::process::Command spawning to default to inheriting the parent's signal mask](https://github.com/rust-lang/rust/pull/101077/)\n+\n+Internal Changes\n+----------------\n+\n+These changes do not affect any public interfaces of Rust, but they represent\n+significant improvements to the performance or internals of rustc and related\n+tools.\n+\n+- [Enable BOLT for LLVM compilation](https://github.com/rust-lang/rust/pull/94381/)\n+- [Enable LTO for rustc_driver.so](https://github.com/rust-lang/rust/pull/101403/)\n+\n+Version 1.65.0 (2022-11-03)\n+==========================\n+\n+Language\n+--------\n+- [Error on `as` casts of enums with `#[non_exhaustive]` variants](https://github.com/rust-lang/rust/pull/92744/)\n+- [Stabilize `let else`](https://github.com/rust-lang/rust/pull/93628/)\n+- [Stabilize generic associated types (GATs)](https://github.com/rust-lang/rust/pull/96709/)\n+- [Add lints `let_underscore_drop` and `let_underscore_lock` from Clippy](https://github.com/rust-lang/rust/pull/97739/)\n+- [Stabilize `break`ing from arbitrary labeled blocks (\"label-break-value\")](https://github.com/rust-lang/rust/pull/99332/)\n+- [Uninitialized integers, floats, and raw pointers are now considered immediate UB](https://github.com/rust-lang/rust/pull/98919/).\n+  Usage of `MaybeUninit` is the correct way to work with uninitialized memory.\n+- [Stabilize raw-dylib for Windows x86_64, aarch64, and thumbv7a](https://github.com/rust-lang/rust/pull/99916/)\n+- [Do not allow `Drop` impl on foreign ADTs](https://github.com/rust-lang/rust/pull/99576/)\n+\n+Compiler\n+--------\n+- [Stabilize -Csplit-debuginfo on Linux](https://github.com/rust-lang/rust/pull/98051/)\n+- [Use niche-filling optimization even when multiple variants have data](https://github.com/rust-lang/rust/pull/94075/)\n+- [Associated type projections are now verified to be well-formed prior to resolving the underlying type](https://github.com/rust-lang/rust/pull/99217/#issuecomment-1209365630)\n+- [Stringify non-shorthand visibility correctly](https://github.com/rust-lang/rust/pull/100350/)\n+- [Normalize struct field types when unsizing](https://github.com/rust-lang/rust/pull/101831/)\n+- [Update to LLVM 15](https://github.com/rust-lang/rust/pull/99464/)\n+- [Fix aarch64 call abi to correctly zeroext when needed](https://github.com/rust-lang/rust/pull/97800/)\n+- [debuginfo: Generalize C++-like encoding for enums](https://github.com/rust-lang/rust/pull/98393/)\n+- [Add `special_module_name` lint](https://github.com/rust-lang/rust/pull/94467/)\n+- [Add support for generating unique profraw files by default when using `-C instrument-coverage`](https://github.com/rust-lang/rust/pull/100384/)\n+- [Allow dynamic linking for iOS/tvOS targets](https://github.com/rust-lang/rust/pull/100636/)\n+\n+New targets:\n+\n+- [Add armv4t-none-eabi as a tier 3 target](https://github.com/rust-lang/rust/pull/100244/)\n+- [Add powerpc64-unknown-openbsd and riscv64-unknown-openbsd as tier 3 targets](https://github.com/rust-lang/rust/pull/101025/)\n+  - Refer to Rust's [platform support page][platform-support-doc] for more\n+    information on Rust's tiered platform support.\n+\n+Libraries\n+---------\n+\n+- [Don't generate `PartialEq::ne` in derive(PartialEq)](https://github.com/rust-lang/rust/pull/98655/)\n+- [Windows RNG: Use `BCRYPT_RNG_ALG_HANDLE` by default](https://github.com/rust-lang/rust/pull/101325/)\n+- [Forbid mixing `System` with direct system allocator calls](https://github.com/rust-lang/rust/pull/101394/)\n+- [Document no support for writing to non-blocking stdio/stderr](https://github.com/rust-lang/rust/pull/101416/)\n+- [`std::layout::Layout` size must not overflow `isize::MAX` when rounded up to `align`](https://github.com/rust-lang/rust/pull/95295)\n+  This also changes the safety conditions on `Layout::from_size_align_unchecked`.\n+\n+Stabilized APIs\n+---------------\n+\n+- [`std::backtrace::Backtrace`](https://doc.rust-lang.org/stable/std/backtrace/struct.Backtrace.html)\n+- [`Bound::as_ref`](https://doc.rust-lang.org/stable/std/ops/enum.Bound.html#method.as_ref)\n+- [`std::io::read_to_string`](https://doc.rust-lang.org/stable/std/io/fn.read_to_string.html)\n+- [`<*const T>::cast_mut`](https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.cast_mut)\n+- [`<*mut T>::cast_const`](https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.cast_const)\n+\n+These APIs are now stable in const contexts:\n+\n+- [`<*const T>::offset_from`](https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset_from)\n+- [`<*mut T>::offset_from`](https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset_from)\n+\n+Cargo\n+-----\n+\n+- [Apply GitHub fast path even for partial hashes](https://github.com/rust-lang/cargo/pull/10807/)\n+- [Do not add home bin path to PATH if it's already there](https://github.com/rust-lang/cargo/pull/11023/)\n+- [Take priority into account within the pending queue](https://github.com/rust-lang/cargo/pull/11032/).\n+  This slightly optimizes job scheduling by Cargo, with typically small improvements on larger crate graph builds.\n+\n+Compatibility Notes\n+-------------------\n+\n+- [`std::layout::Layout` size must not overflow `isize::MAX` when rounded up to `align`](https://github.com/rust-lang/rust/pull/95295).\n+  This also changes the safety conditions on `Layout::from_size_align_unchecked`.\n+- [`PollFn` now only implements `Unpin` if the closure is `Unpin`](https://github.com/rust-lang/rust/pull/102737).\n+  This is a possible breaking change if users were relying on the blanket unpin implementation.\n+  See discussion on the PR for details of why this change was made.\n+- [Drop ExactSizeIterator impl from std::char::EscapeAscii](https://github.com/rust-lang/rust/pull/99880)\n+  This is a backwards-incompatible change to the standard library's surface\n+  area, but is unlikely to affect real world usage.\n+- [Do not consider a single repeated lifetime eligible for elision in the return type](https://github.com/rust-lang/rust/pull/103450)\n+  This behavior was unintentionally changed in 1.64.0, and this release reverts that change by making this an error again.\n+- [Reenable disabled early syntax gates as future-incompatibility lints](https://github.com/rust-lang/rust/pull/99935/)\n+- [Update the minimum external LLVM to 13](https://github.com/rust-lang/rust/pull/100460/)\n+- [Don't duplicate file descriptors into stdio fds](https://github.com/rust-lang/rust/pull/101426/)\n+- [Sunset RLS](https://github.com/rust-lang/rust/pull/100863/)\n+- [Deny usage of `#![cfg_attr(..., crate_type = ...)]` to set the crate type](https://github.com/rust-lang/rust/pull/99784/)\n+  This strengthens the forward compatibility lint deprecated_cfg_attr_crate_type_name to deny.\n+- [`llvm-has-rust-patches` allows setting the build system to treat the LLVM as having Rust-specific patches](https://github.com/rust-lang/rust/pull/101072)\n+  This option may need to be set for distributions that are building Rust with a patched LLVM via `llvm-config`, not the built-in LLVM.\n+- Combining three or more languages (e.g. Objective C, C++ and Rust) into one binary may hit linker limitations when using `lld`. For more information, see [issue 102754][102754].\n+\n+[102754]: https://github.com/rust-lang/rust/issues/102754\n+\n+Internal Changes\n+----------------\n+\n+These changes do not affect any public interfaces of Rust, but they represent\n+significant improvements to the performance or internals of rustc and related\n+tools.\n+\n+- [Add `x.sh` and `x.ps1` shell scripts](https://github.com/rust-lang/rust/pull/99992/)\n+- [compiletest: use target cfg instead of hard-coded tables](https://github.com/rust-lang/rust/pull/100260/)\n+- [Use object instead of LLVM for reading bitcode from rlibs](https://github.com/rust-lang/rust/pull/98100/)\n+- [Enable MIR inlining for optimized compilations](https://github.com/rust-lang/rust/pull/91743)\n+  This provides a 3-10% improvement in compiletimes for real world crates. See [perf results](https://perf.rust-lang.org/compare.html?start=aedf78e56b2279cc869962feac5153b6ba7001ed&end=0075bb4fad68e64b6d1be06bf2db366c30bc75e1&stat=instructions:u).\n+\n+Version 1.64.0 (2022-09-22)\n+===========================\n+\n+Language\n+--------\n+- [Unions with mutable references or tuples of allowed types are now allowed](https://github.com/rust-lang/rust/pull/97995/)\n+- It is now considered valid to deallocate memory pointed to by a shared reference `&T` [if every byte in `T` is inside an `UnsafeCell`](https://github.com/rust-lang/rust/pull/98017/)\n+- Unused tuple struct fields are now warned against in an allow-by-default lint, [`unused_tuple_struct_fields`](https://github.com/rust-lang/rust/pull/95977/), similar to the existing warning for unused struct fields. This lint will become warn-by-default in the future.\n+\n+Compiler\n+--------\n+- [Add Nintendo Switch as tier 3 target](https://github.com/rust-lang/rust/pull/88991/)\n+  - Refer to Rust's [platform support page][platform-support-doc] for more\n+    information on Rust's tiered platform support.\n+- [Only compile `#[used]` as llvm.compiler.used for ELF targets](https://github.com/rust-lang/rust/pull/93718/)\n+- [Add the `--diagnostic-width` compiler flag to define the terminal width.](https://github.com/rust-lang/rust/pull/95635/)\n+- [Add support for link-flavor `rust-lld` for iOS, tvOS and watchOS](https://github.com/rust-lang/rust/pull/98771/)\n+\n+Libraries\n+---------\n+- [Remove restrictions on compare-exchange memory ordering.](https://github.com/rust-lang/rust/pull/98383/)\n+- You can now `write!` or `writeln!` into an `OsString`: [Implement `fmt::Write` for `OsString`](https://github.com/rust-lang/rust/pull/97915/)\n+- [Make RwLockReadGuard covariant](https://github.com/rust-lang/rust/pull/96820/)\n+- [Implement `FusedIterator` for `std::net::[Into]Incoming`](https://github.com/rust-lang/rust/pull/97300/)\n+- [`impl<T: AsRawFd> AsRawFd for {Arc,Box}<T>`](https://github.com/rust-lang/rust/pull/97437/)\n+- [`ptr::copy` and `ptr::swap` are doing untyped copies](https://github.com/rust-lang/rust/pull/97712/)\n+- [Add cgroupv1 support to `available_parallelism`](https://github.com/rust-lang/rust/pull/97925/)\n+- [Mitigate many incorrect uses of `mem::uninitialized`](https://github.com/rust-lang/rust/pull/99182/)\n+\n+Stabilized APIs\n+---------------\n+\n+- [`future::IntoFuture`](https://doc.rust-lang.org/stable/std/future/trait.IntoFuture.html)\n+- [`future::poll_fn`](https://doc.rust-lang.org/stable/std/future/fn.poll_fn.html)\n+- [`task::ready!`](https://doc.rust-lang.org/stable/std/task/macro.ready.html)\n+- [`num::NonZero*::checked_mul`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_mul)\n+- [`num::NonZero*::checked_pow`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_pow)\n+- [`num::NonZero*::saturating_mul`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.saturating_mul)\n+- [`num::NonZero*::saturating_pow`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.saturating_pow)\n+- [`num::NonZeroI*::abs`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.abs)\n+- [`num::NonZeroI*::checked_abs`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.checked_abs)\n+- [`num::NonZeroI*::overflowing_abs`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.overflowing_abs)\n+- [`num::NonZeroI*::saturating_abs`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.saturating_abs)\n+- [`num::NonZeroI*::unsigned_abs`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.unsigned_abs)\n+- [`num::NonZeroI*::wrapping_abs`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.wrapping_abs)\n+- [`num::NonZeroU*::checked_add`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_add)\n+- [`num::NonZeroU*::checked_next_power_of_two`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_next_power_of_two)\n+- [`num::NonZeroU*::saturating_add`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.saturating_add)\n+- [`os::unix::process::CommandExt::process_group`](https://doc.rust-lang.org/stable/std/os/unix/process/trait.CommandExt.html#tymethod.process_group)\n+- [`os::windows::fs::FileTypeExt::is_symlink_dir`](https://doc.rust-lang.org/stable/std/os/windows/fs/trait.FileTypeExt.html#tymethod.is_symlink_dir)\n+- [`os::windows::fs::FileTypeExt::is_symlink_file`](https://doc.rust-lang.org/stable/std/os/windows/fs/trait.FileTypeExt.html#tymethod.is_symlink_file)\n+\n+These types were previously stable in `std::ffi`, but are now also available in `core` and `alloc`:\n+\n+- [`core::ffi::CStr`](https://doc.rust-lang.org/stable/core/ffi/struct.CStr.html)\n+- [`core::ffi::FromBytesWithNulError`](https://doc.rust-lang.org/stable/core/ffi/struct.FromBytesWithNulError.html)\n+- [`alloc::ffi::CString`](https://doc.rust-lang.org/stable/alloc/ffi/struct.CString.html)\n+- [`alloc::ffi::FromVecWithNulError`](https://doc.rust-lang.org/stable/alloc/ffi/struct.FromVecWithNulError.html)\n+- [`alloc::ffi::IntoStringError`](https://doc.rust-lang.org/stable/alloc/ffi/struct.IntoStringError.html)\n+- [`alloc::ffi::NulError`](https://doc.rust-lang.org/stable/alloc/ffi/struct.NulError.html)\n+\n+These types were previously stable in `std::os::raw`, but are now also available in `core::ffi` and `std::ffi`:\n+\n+- [`ffi::c_char`](https://doc.rust-lang.org/stable/std/ffi/type.c_char.html)\n+- [`ffi::c_double`](https://doc.rust-lang.org/stable/std/ffi/type.c_double.html)\n+- [`ffi::c_float`](https://doc.rust-lang.org/stable/std/ffi/type.c_float.html)\n+- [`ffi::c_int`](https://doc.rust-lang.org/stable/std/ffi/type.c_int.html)\n+- [`ffi::c_long`](https://doc.rust-lang.org/stable/std/ffi/type.c_long.html)\n+- [`ffi::c_longlong`](https://doc.rust-lang.org/stable/std/ffi/type.c_longlong.html)\n+- [`ffi::c_schar`](https://doc.rust-lang.org/stable/std/ffi/type.c_schar.html)\n+- [`ffi::c_short`](https://doc.rust-lang.org/stable/std/ffi/type.c_short.html)\n+- [`ffi::c_uchar`](https://doc.rust-lang.org/stable/std/ffi/type.c_uchar.html)\n+- [`ffi::c_uint`](https://doc.rust-lang.org/stable/std/ffi/type.c_uint.html)\n+- [`ffi::c_ulong`](https://doc.rust-lang.org/stable/std/ffi/type.c_ulong.html)\n+- [`ffi::c_ulonglong`](https://doc.rust-lang.org/stable/std/ffi/type.c_ulonglong.html)\n+- [`ffi::c_ushort`](https://doc.rust-lang.org/stable/std/ffi/type.c_ushort.html)\n+\n+These APIs are now usable in const contexts:\n+\n+- [`slice::from_raw_parts`](https://doc.rust-lang.org/stable/core/slice/fn.from_raw_parts.html)\n+\n+Cargo\n+-----\n+- [Packages can now inherit settings from the workspace so that the settings\n+  can be centralized in one place.](https://github.com/rust-lang/cargo/pull/10859) See\n+  [`workspace.package`](https://doc.rust-lang.org/nightly/cargo/reference/workspaces.html#the-workspacepackage-table)\n+  and\n+  [`workspace.dependencies`](https://doc.rust-lang.org/nightly/cargo/reference/workspaces.html#the-workspacedependencies-table)\n+  for more details on how to define these common settings.\n+- [Cargo commands can now accept multiple `--target` flags to build for\n+  multiple targets at once](https://github.com/rust-lang/cargo/pull/10766), and the\n+  [`build.target`](https://doc.rust-lang.org/nightly/cargo/reference/config.html#buildtarget)\n+  config option may now take an array of multiple targets.\n+- [The `--jobs` argument can now take a negative number to count backwards from\n+  the max CPUs.](https://github.com/rust-lang/cargo/pull/10844)\n+- [`cargo add` will now update `Cargo.lock`.](https://github.com/rust-lang/cargo/pull/10902)\n+- [Added](https://github.com/rust-lang/cargo/pull/10838) the\n+  [`--crate-type`](https://doc.rust-lang.org/nightly/cargo/commands/cargo-rustc.html#option-cargo-rustc---crate-type)\n+  flag to `cargo rustc` to override the crate type.\n+- [Significantly improved the performance fetching git dependencies from GitHub\n+  when using a hash in the `rev` field.](https://github.com/rust-lang/cargo/pull/10079)\n+\n+Misc\n+----\n+- [The `rust-analyzer` rustup component is now available on the stable channel.](https://github.com/rust-lang/rust/pull/98640/)\n+\n+Compatibility Notes\n+-------------------\n+- The minimum required versions for all `-linux-gnu` targets are now at least kernel 3.2 and glibc 2.17, for targets that previously supported older versions: [Increase the minimum linux-gnu versions](https://github.com/rust-lang/rust/pull/95026/)\n+- [Network primitives are now implemented with the ideal Rust layout, not the C system layout](https://github.com/rust-lang/rust/pull/78802/). This can cause problems when transmuting the types.\n+- [Add assertion that `transmute_copy`'s `U` is not larger than `T`](https://github.com/rust-lang/rust/pull/98839/)\n+- [A soundness bug in `BTreeMap` was fixed](https://github.com/rust-lang/rust/pull/99413/) that allowed data it was borrowing to be dropped before the container.\n+- [The Drop behavior of C-like enums cast to ints has changed](https://github.com/rust-lang/rust/pull/96862/). These are already discouraged by a compiler warning.\n+- [Relate late-bound closure lifetimes to parent fn in NLL](https://github.com/rust-lang/rust/pull/98835/)\n+- [Errors at const-eval time are now in future incompatibility reports](https://github.com/rust-lang/rust/pull/97743/)\n+- On the `thumbv6m-none-eabi` target, some incorrect `asm!` statements were erroneously accepted if they used the high registers (r8 to r14) as an input/output operand. [This is no longer accepted](https://github.com/rust-lang/rust/pull/99155/).\n+- [`impl Trait` was accidentally accepted as the associated type value of return-position `impl Trait`](https://github.com/rust-lang/rust/pull/97346/), without fulfilling all the trait bounds of that associated type, as long as the hidden type satisfies said bounds. This has been fixed.\n+\n+Internal Changes\n+----------------\n+\n+These changes do not affect any public interfaces of Rust, but they represent\n+significant improvements to the performance or internals of rustc and related\n+tools.\n+\n+- Windows builds now use profile-guided optimization, providing 10-20% improvements to compiler performance: [Utilize PGO for windows x64 rustc dist builds](https://github.com/rust-lang/rust/pull/96978/)\n+- [Stop keeping metadata in memory before writing it to disk](https://github.com/rust-lang/rust/pull/96544/)\n+- [compiletest: strip debuginfo by default for mode=ui](https://github.com/rust-lang/rust/pull/98140/)\n+- Many improvements to generated code for derives, including performance improvements:\n+  - [Don't use match-destructuring for derived ops on structs.](https://github.com/rust-lang/rust/pull/98446/)\n+  - [Many small deriving cleanups](https://github.com/rust-lang/rust/pull/98741/)\n+  - [More derive output improvements](https://github.com/rust-lang/rust/pull/98758/)\n+  - [Clarify deriving code](https://github.com/rust-lang/rust/pull/98915/)\n+  - [Final derive output improvements](https://github.com/rust-lang/rust/pull/99046/)\n+  - [Stop injecting `#[allow(unused_qualifications)]` in generated `derive` implementations](https://github.com/rust-lang/rust/pull/99485/)\n+  - [Improve `derive(Debug)`](https://github.com/rust-lang/rust/pull/98190/)\n+- [Bump to clap 3](https://github.com/rust-lang/rust/pull/98213/)\n+- [fully move dropck to mir](https://github.com/rust-lang/rust/pull/98641/)\n+- [Optimize `Vec::insert` for the case where `index == len`.](https://github.com/rust-lang/rust/pull/98755/)\n+- [Convert rust-analyzer to an in-tree tool](https://github.com/rust-lang/rust/pull/99603/)\n+\n+Version 1.63.0 (2022-08-11)\n+==========================\n+\n+Language\n+--------\n+- [Remove migrate borrowck mode for pre-NLL errors.][95565]\n+- [Modify MIR building to drop repeat expressions with length zero.][95953]\n+- [Remove label/lifetime shadowing warnings.][96296]\n+- [Allow explicit generic arguments in the presence of `impl Trait` args.][96868]\n+- [Make `cenum_impl_drop_cast` warnings deny-by-default.][97652]\n+- [Prevent unwinding when `-C panic=abort` is used regardless of declared ABI.][96959]\n+- [lub: don't bail out due to empty binders.][97867]\n+\n+Compiler\n+--------\n+- [Stabilize the `bundle` native library modifier,][95818] also removing the\n+  deprecated `static-nobundle` linking kind.\n+- [Add Apple WatchOS compile targets\\*.][95243]\n+- [Add a Windows application manifest to rustc-main.][96737]\n+\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n+   information on Rust's tiered platform support.\n+\n+Libraries\n+---------\n+- [Implement `Copy`, `Clone`, `PartialEq` and `Eq` for `core::fmt::Alignment`.][94530]\n+- [Extend `ptr::null` and `null_mut` to all thin (including extern) types.][94954]\n+- [`impl Read and Write for VecDeque<u8>`.][95632]\n+- [STD support for the Nintendo 3DS.][95897]\n+- [Use rounding in float to Duration conversion methods.][96051]\n+- [Make write/print macros eagerly drop temporaries.][96455]\n+- [Implement internal traits that enable `[OsStr]::join`.][96881]\n+- [Implement `Hash` for `core::alloc::Layout`.][97034]\n+- [Add capacity documentation for `OsString`.][97202]\n+- [Put a bound on collection misbehavior.][97316]\n+- [Make `std::mem::needs_drop` accept `?Sized`.][97675]\n+- [`impl Termination for Infallible` and then make the `Result` impls of `Termination` more generic.][97803]\n+- [Document Rust's stance on `/proc/self/mem`.][97837]\n+\n+Stabilized APIs\n+---------------\n+\n+- [`array::from_fn`]\n+- [`Box::into_pin`]\n+- [`BinaryHeap::try_reserve`]\n+- [`BinaryHeap::try_reserve_exact`]\n+- [`OsString::try_reserve`]\n+- [`OsString::try_reserve_exact`]\n+- [`PathBuf::try_reserve`]\n+- [`PathBuf::try_reserve_exact`]\n+- [`Path::try_exists`]\n+- [`Ref::filter_map`]\n+- [`RefMut::filter_map`]\n+- [`NonNull::<[T]>::len`][`NonNull::<slice>::len`]\n+- [`ToOwned::clone_into`]\n+- [`Ipv6Addr::to_ipv4_mapped`]\n+- [`unix::io::AsFd`]\n+- [`unix::io::BorrowedFd<'fd>`]\n+- [`unix::io::OwnedFd`]\n+- [`windows::io::AsHandle`]\n+- [`windows::io::BorrowedHandle<'handle>`]\n+- [`windows::io::OwnedHandle`]\n+- [`windows::io::HandleOrInvalid`]\n+- [`windows::io::HandleOrNull`]\n+- [`windows::io::InvalidHandleError`]\n+- [`windows::io::NullHandleError`]\n+- [`windows::io::AsSocket`]\n+- [`windows::io::BorrowedSocket<'handle>`]\n+- [`windows::io::OwnedSocket`]\n+- [`thread::scope`]\n+- [`thread::Scope`]\n+- [`thread::ScopedJoinHandle`]\n+\n+These APIs are now usable in const contexts:\n+\n+- [`array::from_ref`]\n+- [`slice::from_ref`]\n+- [`intrinsics::copy`]\n+- [`intrinsics::copy_nonoverlapping`]\n+- [`<*const T>::copy_to`]\n+- [`<*const T>::copy_to_nonoverlapping`]\n+- [`<*mut T>::copy_to`]\n+- [`<*mut T>::copy_to_nonoverlapping`]\n+- [`<*mut T>::copy_from`]\n+- [`<*mut T>::copy_from_nonoverlapping`]\n+- [`str::from_utf8`]\n+- [`Utf8Error::error_len`]\n+- [`Utf8Error::valid_up_to`]\n+- [`Condvar::new`]\n+- [`Mutex::new`]\n+- [`RwLock::new`]\n+\n+Cargo\n+-----\n+- [Stabilize the `--config path` command-line argument.][cargo/10755]\n+- [Expose rust-version in the environment as `CARGO_PKG_RUST_VERSION`.][cargo/10713]\n+\n+Compatibility Notes\n+-------------------\n+\n+- [`#[link]` attributes are now checked more strictly,][96885] which may introduce\n+  errors for invalid attribute arguments that were previously ignored.\n+- [Rounding is now used when converting a float to a `Duration`.][96051] The converted\n+  duration can differ slightly from what it was.\n+\n+Internal Changes\n+----------------\n+\n+These changes provide no direct user facing benefits, but represent significant\n+improvements to the internals and overall performance of rustc\n+and related tools.\n+\n+- [Prepare Rust for LLVM opaque pointers.][94214]\n+\n+[94214]: https://github.com/rust-lang/rust/pull/94214/\n+[94530]: https://github.com/rust-lang/rust/pull/94530/\n+[94954]: https://github.com/rust-lang/rust/pull/94954/\n+[95243]: https://github.com/rust-lang/rust/pull/95243/\n+[95565]: https://github.com/rust-lang/rust/pull/95565/\n+[95632]: https://github.com/rust-lang/rust/pull/95632/\n+[95818]: https://github.com/rust-lang/rust/pull/95818/\n+[95897]: https://github.com/rust-lang/rust/pull/95897/\n+[95953]: https://github.com/rust-lang/rust/pull/95953/\n+[96051]: https://github.com/rust-lang/rust/pull/96051/\n+[96296]: https://github.com/rust-lang/rust/pull/96296/\n+[96455]: https://github.com/rust-lang/rust/pull/96455/\n+[96737]: https://github.com/rust-lang/rust/pull/96737/\n+[96868]: https://github.com/rust-lang/rust/pull/96868/\n+[96881]: https://github.com/rust-lang/rust/pull/96881/\n+[96885]: https://github.com/rust-lang/rust/pull/96885/\n+[96959]: https://github.com/rust-lang/rust/pull/96959/\n+[97034]: https://github.com/rust-lang/rust/pull/97034/\n+[97202]: https://github.com/rust-lang/rust/pull/97202/\n+[97316]: https://github.com/rust-lang/rust/pull/97316/\n+[97652]: https://github.com/rust-lang/rust/pull/97652/\n+[97675]: https://github.com/rust-lang/rust/pull/97675/\n+[97803]: https://github.com/rust-lang/rust/pull/97803/\n+[97837]: https://github.com/rust-lang/rust/pull/97837/\n+[97867]: https://github.com/rust-lang/rust/pull/97867/\n+[cargo/10713]: https://github.com/rust-lang/cargo/pull/10713/\n+[cargo/10755]: https://github.com/rust-lang/cargo/pull/10755/\n+\n+[`array::from_fn`]: https://doc.rust-lang.org/stable/std/array/fn.from_fn.html\n+[`Box::into_pin`]: https://doc.rust-lang.org/stable/std/boxed/struct.Box.html#method.into_pin\n+[`BinaryHeap::try_reserve_exact`]: https://doc.rust-lang.org/stable/alloc/collections/binary_heap/struct.BinaryHeap.html#method.try_reserve_exact\n+[`BinaryHeap::try_reserve`]: https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html#method.try_reserve\n+[`OsString::try_reserve`]: https://doc.rust-lang.org/stable/std/ffi/struct.OsString.html#method.try_reserve\n+[`OsString::try_reserve_exact`]: https://doc.rust-lang.org/stable/std/ffi/struct.OsString.html#method.try_reserve_exact\n+[`PathBuf::try_reserve`]: https://doc.rust-lang.org/stable/std/path/struct.PathBuf.html#method.try_reserve\n+[`PathBuf::try_reserve_exact`]: https://doc.rust-lang.org/stable/std/path/struct.PathBuf.html#method.try_reserve_exact\n+[`Path::try_exists`]: https://doc.rust-lang.org/stable/std/path/struct.Path.html#method.try_exists\n+[`Ref::filter_map`]: https://doc.rust-lang.org/stable/std/cell/struct.Ref.html#method.filter_map\n+[`RefMut::filter_map`]: https://doc.rust-lang.org/stable/std/cell/struct.RefMut.html#method.filter_map\n+[`NonNull::<slice>::len`]: https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.len\n+[`ToOwned::clone_into`]: https://doc.rust-lang.org/stable/std/borrow/trait.ToOwned.html#method.clone_into\n+[`Ipv6Addr::to_ipv4_mapped`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv6Addr.html#method.to_ipv4_mapped\n+[`unix::io::AsFd`]: https://doc.rust-lang.org/stable/std/os/unix/io/trait.AsFd.html\n+[`unix::io::BorrowedFd<'fd>`]: https://doc.rust-lang.org/stable/std/os/unix/io/struct.BorrowedFd.html\n+[`unix::io::OwnedFd`]: https://doc.rust-lang.org/stable/std/os/unix/io/struct.OwnedFd.html\n+[`windows::io::AsHandle`]: https://doc.rust-lang.org/stable/std/os/windows/io/trait.AsHandle.html\n+[`windows::io::BorrowedHandle<'handle>`]: https://doc.rust-lang.org/stable/std/os/windows/io/struct.BorrowedHandle.html\n+[`windows::io::OwnedHandle`]: https://doc.rust-lang.org/stable/std/os/windows/io/struct.OwnedHandle.html\n+[`windows::io::HandleOrInvalid`]: https://doc.rust-lang.org/stable/std/os/windows/io/struct.HandleOrInvalid.html\n+[`windows::io::HandleOrNull`]: https://doc.rust-lang.org/stable/std/os/windows/io/struct.HandleOrNull.html\n+[`windows::io::InvalidHandleError`]: https://doc.rust-lang.org/stable/std/os/windows/io/struct.InvalidHandleError.html\n+[`windows::io::NullHandleError`]: https://doc.rust-lang.org/stable/std/os/windows/io/struct.NullHandleError.html\n+[`windows::io::AsSocket`]: https://doc.rust-lang.org/stable/std/os/windows/io/trait.AsSocket.html\n+[`windows::io::BorrowedSocket<'handle>`]: https://doc.rust-lang.org/stable/std/os/windows/io/struct.BorrowedSocket.html\n+[`windows::io::OwnedSocket`]: https://doc.rust-lang.org/stable/std/os/windows/io/struct.OwnedSocket.html\n+[`thread::scope`]: https://doc.rust-lang.org/stable/std/thread/fn.scope.html\n+[`thread::Scope`]: https://doc.rust-lang.org/stable/std/thread/struct.Scope.html\n+[`thread::ScopedJoinHandle`]: https://doc.rust-lang.org/stable/std/thread/struct.ScopedJoinHandle.html\n+\n+[`array::from_ref`]: https://doc.rust-lang.org/stable/std/array/fn.from_ref.html\n+[`slice::from_ref`]: https://doc.rust-lang.org/stable/std/slice/fn.from_ref.html\n+[`intrinsics::copy`]: https://doc.rust-lang.org/stable/std/intrinsics/fn.copy.html\n+[`intrinsics::copy_nonoverlapping`]: https://doc.rust-lang.org/stable/std/intrinsics/fn.copy_nonoverlapping.html\n+[`<*const T>::copy_to`]: https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_to\n+[`<*const T>::copy_to_nonoverlapping`]: https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_to_nonoverlapping\n+[`<*mut T>::copy_to`]: https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_to-1\n+[`<*mut T>::copy_to_nonoverlapping`]: https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_to_nonoverlapping-1\n+[`<*mut T>::copy_from`]: https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_from\n+[`<*mut T>::copy_from_nonoverlapping`]: https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_from_nonoverlapping\n+[`str::from_utf8`]: https://doc.rust-lang.org/stable/std/str/fn.from_utf8.html\n+[`Utf8Error::error_len`]: https://doc.rust-lang.org/stable/std/str/struct.Utf8Error.html#method.error_len\n+[`Utf8Error::valid_up_to`]: https://doc.rust-lang.org/stable/std/str/struct.Utf8Error.html#method.valid_up_to\n+[`Condvar::new`]: https://doc.rust-lang.org/stable/std/sync/struct.Condvar.html#method.new\n+[`Mutex::new`]: https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html#method.new\n+[`RwLock::new`]: https://doc.rust-lang.org/stable/std/sync/struct.RwLock.html#method.new\n+\n+Version 1.62.1 (2022-07-19)\n+==========================\n+\n+Rust 1.62.1 addresses a few recent regressions in the compiler and standard\n+library, and also mitigates a CPU vulnerability on Intel SGX.\n+\n+* [The compiler fixed unsound function coercions involving `impl Trait` return types.][98608]\n+* [The compiler fixed an incremental compilation bug with `async fn` lifetimes.][98890]\n+* [Windows added a fallback for overlapped I/O in synchronous reads and writes.][98950]\n+* [The `x86_64-fortanix-unknown-sgx` target added a mitigation for the\n+  MMIO stale data vulnerability][98126], advisory [INTEL-SA-00615].\n+\n+[98608]: https://github.com/rust-lang/rust/issues/98608\n+[98890]: https://github.com/rust-lang/rust/issues/98890\n+[98950]: https://github.com/rust-lang/rust/pull/98950\n+[98126]: https://github.com/rust-lang/rust/pull/98126\n+[INTEL-SA-00615]: https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00615.html\n+\n Version 1.62.0 (2022-06-30)\n ==========================\n \n@@ -9,6 +1033,7 @@ Language\n - [Fix constants not getting dropped if part of a diverging expression][94775]\n - [Support unit struct/enum variant in destructuring assignment][95380]\n - [Remove mutable_borrow_reservation_conflict lint and allow the code pattern][96268]\n+- [`const` functions may now specify `extern \"C\"` or `extern \"Rust\"`][95346]\n \n Compiler\n --------\n@@ -78,7 +1103,7 @@ Compatibility Notes\n - [rustdoc: doctests are now run on unexported `macro_rules!` macros, matching other private items][96630]\n - [rustdoc: Remove .woff font files][96279]\n - [Enforce Copy bounds for repeat elements while considering lifetimes][95819]\n-- [Windows: Fix potentinal unsoundness by aborting if `File` reads or writes cannot\n+- [Windows: Fix potential unsoundness by aborting if `File` reads or writes cannot\n   complete synchronously][95469].\n \n Internal Changes\n@@ -98,6 +1123,7 @@ and related tools.\n [94872]: https://github.com/rust-lang/rust/pull/94872/\n [95006]: https://github.com/rust-lang/rust/pull/95006/\n [95035]: https://github.com/rust-lang/rust/pull/95035/\n+[95346]: https://github.com/rust-lang/rust/pull/95346/\n [95372]: https://github.com/rust-lang/rust/pull/95372/\n [95380]: https://github.com/rust-lang/rust/pull/95380/\n [95431]: https://github.com/rust-lang/rust/pull/95431/\n@@ -591,7 +1617,7 @@ and related tools.\n [is_power_of_two_usize]: https://doc.rust-lang.org/stable/core/num/struct.NonZeroUsize.html#method.is_power_of_two\n [stdarch/1266]: https://github.com/rust-lang/stdarch/pull/1266\n \n-Version 1.58.1 (2022-01-19)\n+Version 1.58.1 (2022-01-20)\n ===========================\n \n * Fix race condition in `std::fs::remove_dir_all` ([CVE-2022-21658])\n@@ -908,10 +1934,10 @@ Libraries\n - [impl Default, Copy, Clone for std::io::Sink and std::io::Empty][rust#86744]\n - [`impl From<[(K, V); N]>` for all collections.][rust#84111]\n - [Remove `P: Unpin` bound on impl Future for Pin.][rust#81363]\n-- [Treat invalid environment variable names as non-existent.][rust#86183]\n+- [Treat invalid environment variable names as nonexistent.][rust#86183]\n   Previously, the environment functions would panic if given a variable name\n   with an internal null character or equal sign (`=`). Now, these functions will\n-  just treat such names as non-existent variables, since the OS cannot represent\n+  just treat such names as nonexistent variables, since the OS cannot represent\n   the existence of a variable with such a name.\n \n Stabilised APIs\n@@ -1104,7 +2130,7 @@ Compatibility Notes\n   kinds of errors could be categorised [into newer more specific `ErrorKind`\n   variants][79965], and that they do not represent a user error.\n - [Using environment variable names with `process::Command` on Windows now\n-  behaves as expected.][85270] Previously using envionment variables with\n+  behaves as expected.][85270] Previously using environment variables with\n   `Command` would cause them to be ASCII-uppercased.\n - [Rustdoc will now warn on using rustdoc lints that aren't prefixed\n   with `rustdoc::`][86849]\n@@ -1234,7 +2260,7 @@ Compatibility Notes\n - [Mixing Option and Result via `?` is no longer permitted in closures for inferred types.][86831]\n - [Previously unsound code is no longer permitted where different constructors in branches\n   could require different lifetimes.][85574]\n-- As previously mentioned the [`std::arch` instrinsics now uses stricter const checking][83278]\n+- As previously mentioned the [`std::arch` intrinsics now uses stricter const checking][83278]\n   than before and may reject some previously accepted code.\n - [`i128` multiplication on Cortex M0+ platforms currently unconditionally causes overflow\n    when compiled with `codegen-units = 1`.][86063]\n@@ -2312,7 +3338,7 @@ Compatibility Notes\n - [Fixed a regression parsing `{} && false` in tail expressions.][74650]\n - [Added changes to how proc-macros are expanded in `macro_rules!` that should\n   help to preserve more span information.][73084] These changes may cause\n-  compiliation errors if your macro was unhygenic or didn't correctly handle\n+  compilation errors if your macro was unhygenic or didn't correctly handle\n   `Delimiter::None`.\n - [Moved support for the CloudABI target to tier 3.][75568]\n - [`linux-gnu` targets now require minimum kernel 2.6.32 and glibc 2.11.][74163]\n@@ -3102,6 +4128,8 @@ Version 1.41.1 (2020-02-27)\n * [Always check types of static items][69145]\n * [Always check lifetime bounds of `Copy` impls][69145]\n * [Fix miscompilation in callers of `Layout::repeat`][69225]\n+* [Rust 1.41.0 was announced as the last Rust release with tier 1 or tier 2 support for 32-bit Apple targets][apple-32bit-drop].\n+  That announcement did not expect a patch release. 1.41.1 also includes release binaries for these targets.\n \n [69225]: https://github.com/rust-lang/rust/issues/69225\n [69145]: https://github.com/rust-lang/rust/pull/69145\n@@ -3194,7 +4222,7 @@ Misc\n Compatibility Notes\n -------------------\n \n-- [As previously announced 1.41.0 will be the last tier 1 release for 32-bit\n+- [As previously announced 1.41 will be the last tier 1 release for 32-bit\n   Apple targets.][apple-32bit-drop] This means that the source code is still\n   available to build, but the targets are no longer being tested and release\n   binaries for those platforms will no longer be distributed by the Rust project.\n@@ -5479,7 +6507,7 @@ eg. `static MINUTE: Duration = Duration::from_secs(60);`\n \n Cargo\n -----\n-- [`cargo new` no longer removes `rust` or `rs` prefixs/suffixs.][cargo/5013]\n+- [`cargo new` no longer removes `rust` or `rs` prefixes/suffixes.][cargo/5013]\n - [`cargo new` now defaults to creating a binary crate, instead of a\n   library crate.][cargo/5029]\n "}, {"sha": "41003ad83f31152956dce55a9feb2623f6b4fcc9", "filename": "compiler/rustc/Cargo.toml", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2FCargo.toml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -5,6 +5,7 @@ edition = \"2021\"\n \n [dependencies]\n rustc_driver = { path = \"../rustc_driver\" }\n+rustc_driver_impl = { path = \"../rustc_driver_impl\" }\n \n # Make sure rustc_codegen_ssa ends up in the sysroot, because this\n # crate is intended to be used by codegen backends, which may not be in-tree.\n@@ -20,6 +21,6 @@ features = ['unprefixed_malloc_on_supported_platforms']\n \n [features]\n jemalloc = ['jemalloc-sys']\n-llvm = ['rustc_driver/llvm']\n-max_level_info = ['rustc_driver/max_level_info']\n-rustc_use_parallel_compiler = ['rustc_driver/rustc_use_parallel_compiler']\n+llvm = ['rustc_driver_impl/llvm']\n+max_level_info = ['rustc_driver_impl/max_level_info']\n+rustc_use_parallel_compiler = ['rustc_driver_impl/rustc_use_parallel_compiler']"}, {"sha": "434b978ae3151caa16781f2cddca9c9f5b8e5b46", "filename": "compiler/rustc/src/main.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2Fsrc%2Fmain.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -1,3 +1,5 @@\n+#![feature(unix_sigpipe)]\n+\n // A note about jemalloc: rustc uses jemalloc when built for CI and\n // distribution. The obvious way to do this is with the `#[global_allocator]`\n // mechanism. However, for complicated reasons (see\n@@ -22,7 +24,17 @@\n // The two crates we link to here, `std` and `rustc_driver`, are both dynamic\n // libraries. So we must reference jemalloc symbols one way or another, because\n // this file is the only object code in the rustc executable.\n+//\n+// NOTE: if you are reading this comment because you want to set a custom `global_allocator` for\n+// benchmarking, consider using the benchmarks in the `rustc-perf` collector suite instead:\n+// https://github.com/rust-lang/rustc-perf/blob/master/collector/README.md#profiling\n+//\n+// NOTE: if you are reading this comment because you want to replace jemalloc with another allocator\n+// to compare their performance, see\n+// https://github.com/rust-lang/rust/commit/b90cfc887c31c3e7a9e6d462e2464db1fe506175#diff-43914724af6e464c1da2171e4a9b6c7e607d5bc1203fa95c0ab85be4122605ef\n+// for an example of how to do so.\n \n+#[unix_sigpipe = \"sig_dfl\"]\n fn main() {\n     // See the comment at the top of this file for an explanation of this.\n     #[cfg(feature = \"jemalloc-sys\")]\n@@ -58,6 +70,5 @@ fn main() {\n         }\n     }\n \n-    rustc_driver::set_sigpipe_handler();\n     rustc_driver::main()\n }"}, {"sha": "48b199cb8eed9dad92c33e20ffb6390b2062992b", "filename": "compiler/rustc_abi/Cargo.toml", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_abi%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_abi%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2FCargo.toml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -0,0 +1,24 @@\n+[package]\n+name = \"rustc_abi\"\n+version = \"0.0.0\"\n+edition = \"2021\"\n+\n+[dependencies]\n+bitflags = \"1.2.1\"\n+tracing = \"0.1\"\n+rand = { version = \"0.8.4\", default-features = false, optional = true }\n+rand_xoshiro = { version = \"0.6.0\", optional = true }\n+rustc_data_structures = { path = \"../rustc_data_structures\", optional = true  }\n+rustc_index = { path = \"../rustc_index\", default-features = false }\n+rustc_macros = { path = \"../rustc_macros\", optional = true }\n+rustc_serialize = { path = \"../rustc_serialize\", optional = true  }\n+\n+[features]\n+default = [\"nightly\", \"randomize\"]\n+randomize = [\"rand\", \"rand_xoshiro\"]\n+nightly = [\n+    \"rustc_data_structures\",\n+    \"rustc_index/nightly\",\n+    \"rustc_macros\",\n+    \"rustc_serialize\",\n+]"}, {"sha": "f11c1c77f9cfc30a180ae8f3f669105dc22804af", "filename": "compiler/rustc_abi/src/layout.rs", "status": "added", "additions": 1128, "deletions": 0, "changes": 1128, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -0,0 +1,1128 @@\n+use super::*;\n+use std::fmt::Write;\n+use std::{borrow::Borrow, cmp, iter, ops::Bound};\n+\n+#[cfg(feature = \"randomize\")]\n+use rand::{seq::SliceRandom, SeedableRng};\n+#[cfg(feature = \"randomize\")]\n+use rand_xoshiro::Xoshiro128StarStar;\n+\n+use tracing::debug;\n+\n+pub trait LayoutCalculator {\n+    type TargetDataLayoutRef: Borrow<TargetDataLayout>;\n+\n+    fn delay_bug(&self, txt: String);\n+    fn current_data_layout(&self) -> Self::TargetDataLayoutRef;\n+\n+    fn scalar_pair(&self, a: Scalar, b: Scalar) -> LayoutS {\n+        let dl = self.current_data_layout();\n+        let dl = dl.borrow();\n+        let b_align = b.align(dl);\n+        let align = a.align(dl).max(b_align).max(dl.aggregate_align);\n+        let b_offset = a.size(dl).align_to(b_align.abi);\n+        let size = (b_offset + b.size(dl)).align_to(align.abi);\n+\n+        // HACK(nox): We iter on `b` and then `a` because `max_by_key`\n+        // returns the last maximum.\n+        let largest_niche = Niche::from_scalar(dl, b_offset, b)\n+            .into_iter()\n+            .chain(Niche::from_scalar(dl, Size::ZERO, a))\n+            .max_by_key(|niche| niche.available(dl));\n+\n+        LayoutS {\n+            variants: Variants::Single { index: FIRST_VARIANT },\n+            fields: FieldsShape::Arbitrary {\n+                offsets: [Size::ZERO, b_offset].into(),\n+                memory_index: [0, 1].into(),\n+            },\n+            abi: Abi::ScalarPair(a, b),\n+            largest_niche,\n+            align,\n+            size,\n+        }\n+    }\n+\n+    fn univariant(\n+        &self,\n+        dl: &TargetDataLayout,\n+        fields: &IndexSlice<FieldIdx, Layout<'_>>,\n+        repr: &ReprOptions,\n+        kind: StructKind,\n+    ) -> Option<LayoutS> {\n+        let layout = univariant(self, dl, fields, repr, kind, NicheBias::Start);\n+        // Enums prefer niches close to the beginning or the end of the variants so that other (smaller)\n+        // data-carrying variants can be packed into the space after/before the niche.\n+        // If the default field ordering does not give us a niche at the front then we do a second\n+        // run and bias niches to the right and then check which one is closer to one of the struct's\n+        // edges.\n+        if let Some(layout) = &layout {\n+            if let Some(niche) = layout.largest_niche {\n+                let head_space = niche.offset.bytes();\n+                let niche_length = niche.value.size(dl).bytes();\n+                let tail_space = layout.size.bytes() - head_space - niche_length;\n+\n+                // This may end up doing redundant work if the niche is already in the last field\n+                // (e.g. a trailing bool) and there is tail padding. But it's non-trivial to get\n+                // the unpadded size so we try anyway.\n+                if fields.len() > 1 && head_space != 0 && tail_space > 0 {\n+                    let alt_layout = univariant(self, dl, fields, repr, kind, NicheBias::End)\n+                        .expect(\"alt layout should always work\");\n+                    let niche = alt_layout\n+                        .largest_niche\n+                        .expect(\"alt layout should have a niche like the regular one\");\n+                    let alt_head_space = niche.offset.bytes();\n+                    let alt_niche_len = niche.value.size(dl).bytes();\n+                    let alt_tail_space = alt_layout.size.bytes() - alt_head_space - alt_niche_len;\n+\n+                    debug_assert_eq!(layout.size.bytes(), alt_layout.size.bytes());\n+\n+                    let prefer_alt_layout =\n+                        alt_head_space > head_space && alt_head_space > tail_space;\n+\n+                    debug!(\n+                        \"sz: {}, default_niche_at: {}+{}, default_tail_space: {}, alt_niche_at/head_space: {}+{}, alt_tail: {}, num_fields: {}, better: {}\\n\\\n+                        layout: {}\\n\\\n+                        alt_layout: {}\\n\",\n+                        layout.size.bytes(),\n+                        head_space,\n+                        niche_length,\n+                        tail_space,\n+                        alt_head_space,\n+                        alt_niche_len,\n+                        alt_tail_space,\n+                        layout.fields.count(),\n+                        prefer_alt_layout,\n+                        format_field_niches(&layout, &fields, &dl),\n+                        format_field_niches(&alt_layout, &fields, &dl),\n+                    );\n+\n+                    if prefer_alt_layout {\n+                        return Some(alt_layout);\n+                    }\n+                }\n+            }\n+        }\n+        layout\n+    }\n+\n+    fn layout_of_never_type(&self) -> LayoutS {\n+        let dl = self.current_data_layout();\n+        let dl = dl.borrow();\n+        LayoutS {\n+            variants: Variants::Single { index: FIRST_VARIANT },\n+            fields: FieldsShape::Primitive,\n+            abi: Abi::Uninhabited,\n+            largest_niche: None,\n+            align: dl.i8_align,\n+            size: Size::ZERO,\n+        }\n+    }\n+\n+    fn layout_of_struct_or_enum(\n+        &self,\n+        repr: &ReprOptions,\n+        variants: &IndexSlice<VariantIdx, IndexVec<FieldIdx, Layout<'_>>>,\n+        is_enum: bool,\n+        is_unsafe_cell: bool,\n+        scalar_valid_range: (Bound<u128>, Bound<u128>),\n+        discr_range_of_repr: impl Fn(i128, i128) -> (Integer, bool),\n+        discriminants: impl Iterator<Item = (VariantIdx, i128)>,\n+        niche_optimize_enum: bool,\n+        always_sized: bool,\n+    ) -> Option<LayoutS> {\n+        let dl = self.current_data_layout();\n+        let dl = dl.borrow();\n+\n+        let scalar_unit = |value: Primitive| {\n+            let size = value.size(dl);\n+            assert!(size.bits() <= 128);\n+            Scalar::Initialized { value, valid_range: WrappingRange::full(size) }\n+        };\n+\n+        // A variant is absent if it's uninhabited and only has ZST fields.\n+        // Present uninhabited variants only require space for their fields,\n+        // but *not* an encoding of the discriminant (e.g., a tag value).\n+        // See issue #49298 for more details on the need to leave space\n+        // for non-ZST uninhabited data (mostly partial initialization).\n+        let absent = |fields: &IndexSlice<FieldIdx, Layout<'_>>| {\n+            let uninhabited = fields.iter().any(|f| f.abi().is_uninhabited());\n+            let is_zst = fields.iter().all(|f| f.0.is_zst());\n+            uninhabited && is_zst\n+        };\n+        let (present_first, present_second) = {\n+            let mut present_variants = variants\n+                .iter_enumerated()\n+                .filter_map(|(i, v)| if absent(v) { None } else { Some(i) });\n+            (present_variants.next(), present_variants.next())\n+        };\n+        let present_first = match present_first {\n+            Some(present_first) => present_first,\n+            // Uninhabited because it has no variants, or only absent ones.\n+            None if is_enum => {\n+                return Some(self.layout_of_never_type());\n+            }\n+            // If it's a struct, still compute a layout so that we can still compute the\n+            // field offsets.\n+            None => FIRST_VARIANT,\n+        };\n+\n+        let is_struct = !is_enum ||\n+                    // Only one variant is present.\n+                    (present_second.is_none() &&\n+                        // Representation optimizations are allowed.\n+                        !repr.inhibit_enum_layout_opt());\n+        if is_struct {\n+            // Struct, or univariant enum equivalent to a struct.\n+            // (Typechecking will reject discriminant-sizing attrs.)\n+\n+            let v = present_first;\n+            let kind = if is_enum || variants[v].is_empty() {\n+                StructKind::AlwaysSized\n+            } else {\n+                if !always_sized { StructKind::MaybeUnsized } else { StructKind::AlwaysSized }\n+            };\n+\n+            let mut st = self.univariant(dl, &variants[v], repr, kind)?;\n+            st.variants = Variants::Single { index: v };\n+\n+            if is_unsafe_cell {\n+                let hide_niches = |scalar: &mut _| match scalar {\n+                    Scalar::Initialized { value, valid_range } => {\n+                        *valid_range = WrappingRange::full(value.size(dl))\n+                    }\n+                    // Already doesn't have any niches\n+                    Scalar::Union { .. } => {}\n+                };\n+                match &mut st.abi {\n+                    Abi::Uninhabited => {}\n+                    Abi::Scalar(scalar) => hide_niches(scalar),\n+                    Abi::ScalarPair(a, b) => {\n+                        hide_niches(a);\n+                        hide_niches(b);\n+                    }\n+                    Abi::Vector { element, count: _ } => hide_niches(element),\n+                    Abi::Aggregate { sized: _ } => {}\n+                }\n+                st.largest_niche = None;\n+                return Some(st);\n+            }\n+\n+            let (start, end) = scalar_valid_range;\n+            match st.abi {\n+                Abi::Scalar(ref mut scalar) | Abi::ScalarPair(ref mut scalar, _) => {\n+                    // Enlarging validity ranges would result in missed\n+                    // optimizations, *not* wrongly assuming the inner\n+                    // value is valid. e.g. unions already enlarge validity ranges,\n+                    // because the values may be uninitialized.\n+                    //\n+                    // Because of that we only check that the start and end\n+                    // of the range is representable with this scalar type.\n+\n+                    let max_value = scalar.size(dl).unsigned_int_max();\n+                    if let Bound::Included(start) = start {\n+                        // FIXME(eddyb) this might be incorrect - it doesn't\n+                        // account for wrap-around (end < start) ranges.\n+                        assert!(start <= max_value, \"{start} > {max_value}\");\n+                        scalar.valid_range_mut().start = start;\n+                    }\n+                    if let Bound::Included(end) = end {\n+                        // FIXME(eddyb) this might be incorrect - it doesn't\n+                        // account for wrap-around (end < start) ranges.\n+                        assert!(end <= max_value, \"{end} > {max_value}\");\n+                        scalar.valid_range_mut().end = end;\n+                    }\n+\n+                    // Update `largest_niche` if we have introduced a larger niche.\n+                    let niche = Niche::from_scalar(dl, Size::ZERO, *scalar);\n+                    if let Some(niche) = niche {\n+                        match st.largest_niche {\n+                            Some(largest_niche) => {\n+                                // Replace the existing niche even if they're equal,\n+                                // because this one is at a lower offset.\n+                                if largest_niche.available(dl) <= niche.available(dl) {\n+                                    st.largest_niche = Some(niche);\n+                                }\n+                            }\n+                            None => st.largest_niche = Some(niche),\n+                        }\n+                    }\n+                }\n+                _ => assert!(\n+                    start == Bound::Unbounded && end == Bound::Unbounded,\n+                    \"nonscalar layout for layout_scalar_valid_range type: {:#?}\",\n+                    st,\n+                ),\n+            }\n+\n+            return Some(st);\n+        }\n+\n+        // At this point, we have handled all unions and\n+        // structs. (We have also handled univariant enums\n+        // that allow representation optimization.)\n+        assert!(is_enum);\n+\n+        // Until we've decided whether to use the tagged or\n+        // niche filling LayoutS, we don't want to intern the\n+        // variant layouts, so we can't store them in the\n+        // overall LayoutS. Store the overall LayoutS\n+        // and the variant LayoutSs here until then.\n+        struct TmpLayout {\n+            layout: LayoutS,\n+            variants: IndexVec<VariantIdx, LayoutS>,\n+        }\n+\n+        let calculate_niche_filling_layout = || -> Option<TmpLayout> {\n+            if niche_optimize_enum {\n+                return None;\n+            }\n+\n+            if variants.len() < 2 {\n+                return None;\n+            }\n+\n+            let mut align = dl.aggregate_align;\n+            let mut variant_layouts = variants\n+                .iter_enumerated()\n+                .map(|(j, v)| {\n+                    let mut st = self.univariant(dl, v, repr, StructKind::AlwaysSized)?;\n+                    st.variants = Variants::Single { index: j };\n+\n+                    align = align.max(st.align);\n+\n+                    Some(st)\n+                })\n+                .collect::<Option<IndexVec<VariantIdx, _>>>()?;\n+\n+            let largest_variant_index = variant_layouts\n+                .iter_enumerated()\n+                .max_by_key(|(_i, layout)| layout.size.bytes())\n+                .map(|(i, _layout)| i)?;\n+\n+            let all_indices = variants.indices();\n+            let needs_disc =\n+                |index: VariantIdx| index != largest_variant_index && !absent(&variants[index]);\n+            let niche_variants = all_indices.clone().find(|v| needs_disc(*v)).unwrap()\n+                ..=all_indices.rev().find(|v| needs_disc(*v)).unwrap();\n+\n+            let count = niche_variants.size_hint().1.unwrap() as u128;\n+\n+            // Find the field with the largest niche\n+            let (field_index, niche, (niche_start, niche_scalar)) = variants[largest_variant_index]\n+                .iter()\n+                .enumerate()\n+                .filter_map(|(j, field)| Some((j, field.largest_niche()?)))\n+                .max_by_key(|(_, niche)| niche.available(dl))\n+                .and_then(|(j, niche)| Some((j, niche, niche.reserve(dl, count)?)))?;\n+            let niche_offset =\n+                niche.offset + variant_layouts[largest_variant_index].fields.offset(field_index);\n+            let niche_size = niche.value.size(dl);\n+            let size = variant_layouts[largest_variant_index].size.align_to(align.abi);\n+\n+            let all_variants_fit = variant_layouts.iter_enumerated_mut().all(|(i, layout)| {\n+                if i == largest_variant_index {\n+                    return true;\n+                }\n+\n+                layout.largest_niche = None;\n+\n+                if layout.size <= niche_offset {\n+                    // This variant will fit before the niche.\n+                    return true;\n+                }\n+\n+                // Determine if it'll fit after the niche.\n+                let this_align = layout.align.abi;\n+                let this_offset = (niche_offset + niche_size).align_to(this_align);\n+\n+                if this_offset + layout.size > size {\n+                    return false;\n+                }\n+\n+                // It'll fit, but we need to make some adjustments.\n+                match layout.fields {\n+                    FieldsShape::Arbitrary { ref mut offsets, .. } => {\n+                        for (j, offset) in offsets.iter_enumerated_mut() {\n+                            if !variants[i][j].0.is_zst() {\n+                                *offset += this_offset;\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        panic!(\"Layout of fields should be Arbitrary for variants\")\n+                    }\n+                }\n+\n+                // It can't be a Scalar or ScalarPair because the offset isn't 0.\n+                if !layout.abi.is_uninhabited() {\n+                    layout.abi = Abi::Aggregate { sized: true };\n+                }\n+                layout.size += this_offset;\n+\n+                true\n+            });\n+\n+            if !all_variants_fit {\n+                return None;\n+            }\n+\n+            let largest_niche = Niche::from_scalar(dl, niche_offset, niche_scalar);\n+\n+            let others_zst = variant_layouts\n+                .iter_enumerated()\n+                .all(|(i, layout)| i == largest_variant_index || layout.size == Size::ZERO);\n+            let same_size = size == variant_layouts[largest_variant_index].size;\n+            let same_align = align == variant_layouts[largest_variant_index].align;\n+\n+            let abi = if variant_layouts.iter().all(|v| v.abi.is_uninhabited()) {\n+                Abi::Uninhabited\n+            } else if same_size && same_align && others_zst {\n+                match variant_layouts[largest_variant_index].abi {\n+                    // When the total alignment and size match, we can use the\n+                    // same ABI as the scalar variant with the reserved niche.\n+                    Abi::Scalar(_) => Abi::Scalar(niche_scalar),\n+                    Abi::ScalarPair(first, second) => {\n+                        // Only the niche is guaranteed to be initialised,\n+                        // so use union layouts for the other primitive.\n+                        if niche_offset == Size::ZERO {\n+                            Abi::ScalarPair(niche_scalar, second.to_union())\n+                        } else {\n+                            Abi::ScalarPair(first.to_union(), niche_scalar)\n+                        }\n+                    }\n+                    _ => Abi::Aggregate { sized: true },\n+                }\n+            } else {\n+                Abi::Aggregate { sized: true }\n+            };\n+\n+            let layout = LayoutS {\n+                variants: Variants::Multiple {\n+                    tag: niche_scalar,\n+                    tag_encoding: TagEncoding::Niche {\n+                        untagged_variant: largest_variant_index,\n+                        niche_variants,\n+                        niche_start,\n+                    },\n+                    tag_field: 0,\n+                    variants: IndexVec::new(),\n+                },\n+                fields: FieldsShape::Arbitrary {\n+                    offsets: [niche_offset].into(),\n+                    memory_index: [0].into(),\n+                },\n+                abi,\n+                largest_niche,\n+                size,\n+                align,\n+            };\n+\n+            Some(TmpLayout { layout, variants: variant_layouts })\n+        };\n+\n+        let niche_filling_layout = calculate_niche_filling_layout();\n+\n+        let (mut min, mut max) = (i128::MAX, i128::MIN);\n+        let discr_type = repr.discr_type();\n+        let bits = Integer::from_attr(dl, discr_type).size().bits();\n+        for (i, mut val) in discriminants {\n+            if variants[i].iter().any(|f| f.abi().is_uninhabited()) {\n+                continue;\n+            }\n+            if discr_type.is_signed() {\n+                // sign extend the raw representation to be an i128\n+                val = (val << (128 - bits)) >> (128 - bits);\n+            }\n+            if val < min {\n+                min = val;\n+            }\n+            if val > max {\n+                max = val;\n+            }\n+        }\n+        // We might have no inhabited variants, so pretend there's at least one.\n+        if (min, max) == (i128::MAX, i128::MIN) {\n+            min = 0;\n+            max = 0;\n+        }\n+        assert!(min <= max, \"discriminant range is {}...{}\", min, max);\n+        let (min_ity, signed) = discr_range_of_repr(min, max); //Integer::repr_discr(tcx, ty, &repr, min, max);\n+\n+        let mut align = dl.aggregate_align;\n+        let mut size = Size::ZERO;\n+\n+        // We're interested in the smallest alignment, so start large.\n+        let mut start_align = Align::from_bytes(256).unwrap();\n+        assert_eq!(Integer::for_align(dl, start_align), None);\n+\n+        // repr(C) on an enum tells us to make a (tag, union) layout,\n+        // so we need to grow the prefix alignment to be at least\n+        // the alignment of the union. (This value is used both for\n+        // determining the alignment of the overall enum, and the\n+        // determining the alignment of the payload after the tag.)\n+        let mut prefix_align = min_ity.align(dl).abi;\n+        if repr.c() {\n+            for fields in variants {\n+                for field in fields {\n+                    prefix_align = prefix_align.max(field.align().abi);\n+                }\n+            }\n+        }\n+\n+        // Create the set of structs that represent each variant.\n+        let mut layout_variants = variants\n+            .iter_enumerated()\n+            .map(|(i, field_layouts)| {\n+                let mut st = self.univariant(\n+                    dl,\n+                    field_layouts,\n+                    repr,\n+                    StructKind::Prefixed(min_ity.size(), prefix_align),\n+                )?;\n+                st.variants = Variants::Single { index: i };\n+                // Find the first field we can't move later\n+                // to make room for a larger discriminant.\n+                for field_idx in st.fields.index_by_increasing_offset() {\n+                    let field = &field_layouts[FieldIdx::from_usize(field_idx)];\n+                    if !field.0.is_zst() || field.align().abi.bytes() != 1 {\n+                        start_align = start_align.min(field.align().abi);\n+                        break;\n+                    }\n+                }\n+                size = cmp::max(size, st.size);\n+                align = align.max(st.align);\n+                Some(st)\n+            })\n+            .collect::<Option<IndexVec<VariantIdx, _>>>()?;\n+\n+        // Align the maximum variant size to the largest alignment.\n+        size = size.align_to(align.abi);\n+\n+        if size.bytes() >= dl.obj_size_bound() {\n+            return None;\n+        }\n+\n+        let typeck_ity = Integer::from_attr(dl, repr.discr_type());\n+        if typeck_ity < min_ity {\n+            // It is a bug if Layout decided on a greater discriminant size than typeck for\n+            // some reason at this point (based on values discriminant can take on). Mostly\n+            // because this discriminant will be loaded, and then stored into variable of\n+            // type calculated by typeck. Consider such case (a bug): typeck decided on\n+            // byte-sized discriminant, but layout thinks we need a 16-bit to store all\n+            // discriminant values. That would be a bug, because then, in codegen, in order\n+            // to store this 16-bit discriminant into 8-bit sized temporary some of the\n+            // space necessary to represent would have to be discarded (or layout is wrong\n+            // on thinking it needs 16 bits)\n+            panic!(\n+                \"layout decided on a larger discriminant type ({:?}) than typeck ({:?})\",\n+                min_ity, typeck_ity\n+            );\n+            // However, it is fine to make discr type however large (as an optimisation)\n+            // after this point \u2013 we\u2019ll just truncate the value we load in codegen.\n+        }\n+\n+        // Check to see if we should use a different type for the\n+        // discriminant. We can safely use a type with the same size\n+        // as the alignment of the first field of each variant.\n+        // We increase the size of the discriminant to avoid LLVM copying\n+        // padding when it doesn't need to. This normally causes unaligned\n+        // load/stores and excessive memcpy/memset operations. By using a\n+        // bigger integer size, LLVM can be sure about its contents and\n+        // won't be so conservative.\n+\n+        // Use the initial field alignment\n+        let mut ity = if repr.c() || repr.int.is_some() {\n+            min_ity\n+        } else {\n+            Integer::for_align(dl, start_align).unwrap_or(min_ity)\n+        };\n+\n+        // If the alignment is not larger than the chosen discriminant size,\n+        // don't use the alignment as the final size.\n+        if ity <= min_ity {\n+            ity = min_ity;\n+        } else {\n+            // Patch up the variants' first few fields.\n+            let old_ity_size = min_ity.size();\n+            let new_ity_size = ity.size();\n+            for variant in &mut layout_variants {\n+                match variant.fields {\n+                    FieldsShape::Arbitrary { ref mut offsets, .. } => {\n+                        for i in offsets {\n+                            if *i <= old_ity_size {\n+                                assert_eq!(*i, old_ity_size);\n+                                *i = new_ity_size;\n+                            }\n+                        }\n+                        // We might be making the struct larger.\n+                        if variant.size <= old_ity_size {\n+                            variant.size = new_ity_size;\n+                        }\n+                    }\n+                    _ => panic!(),\n+                }\n+            }\n+        }\n+\n+        let tag_mask = ity.size().unsigned_int_max();\n+        let tag = Scalar::Initialized {\n+            value: Int(ity, signed),\n+            valid_range: WrappingRange {\n+                start: (min as u128 & tag_mask),\n+                end: (max as u128 & tag_mask),\n+            },\n+        };\n+        let mut abi = Abi::Aggregate { sized: true };\n+\n+        if layout_variants.iter().all(|v| v.abi.is_uninhabited()) {\n+            abi = Abi::Uninhabited;\n+        } else if tag.size(dl) == size {\n+            // Make sure we only use scalar layout when the enum is entirely its\n+            // own tag (i.e. it has no padding nor any non-ZST variant fields).\n+            abi = Abi::Scalar(tag);\n+        } else {\n+            // Try to use a ScalarPair for all tagged enums.\n+            let mut common_prim = None;\n+            let mut common_prim_initialized_in_all_variants = true;\n+            for (field_layouts, layout_variant) in iter::zip(variants, &layout_variants) {\n+                let FieldsShape::Arbitrary { ref offsets, .. } = layout_variant.fields else {\n+                    panic!();\n+                };\n+                let mut fields = iter::zip(field_layouts, offsets).filter(|p| !p.0.0.is_zst());\n+                let (field, offset) = match (fields.next(), fields.next()) {\n+                    (None, None) => {\n+                        common_prim_initialized_in_all_variants = false;\n+                        continue;\n+                    }\n+                    (Some(pair), None) => pair,\n+                    _ => {\n+                        common_prim = None;\n+                        break;\n+                    }\n+                };\n+                let prim = match field.abi() {\n+                    Abi::Scalar(scalar) => {\n+                        common_prim_initialized_in_all_variants &=\n+                            matches!(scalar, Scalar::Initialized { .. });\n+                        scalar.primitive()\n+                    }\n+                    _ => {\n+                        common_prim = None;\n+                        break;\n+                    }\n+                };\n+                if let Some(pair) = common_prim {\n+                    // This is pretty conservative. We could go fancier\n+                    // by conflating things like i32 and u32, or even\n+                    // realising that (u8, u8) could just cohabit with\n+                    // u16 or even u32.\n+                    if pair != (prim, offset) {\n+                        common_prim = None;\n+                        break;\n+                    }\n+                } else {\n+                    common_prim = Some((prim, offset));\n+                }\n+            }\n+            if let Some((prim, offset)) = common_prim {\n+                let prim_scalar = if common_prim_initialized_in_all_variants {\n+                    scalar_unit(prim)\n+                } else {\n+                    // Common prim might be uninit.\n+                    Scalar::Union { value: prim }\n+                };\n+                let pair = self.scalar_pair(tag, prim_scalar);\n+                let pair_offsets = match pair.fields {\n+                    FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n+                        assert_eq!(memory_index.raw, [0, 1]);\n+                        offsets\n+                    }\n+                    _ => panic!(),\n+                };\n+                if pair_offsets[FieldIdx::from_u32(0)] == Size::ZERO\n+                    && pair_offsets[FieldIdx::from_u32(1)] == *offset\n+                    && align == pair.align\n+                    && size == pair.size\n+                {\n+                    // We can use `ScalarPair` only when it matches our\n+                    // already computed layout (including `#[repr(C)]`).\n+                    abi = pair.abi;\n+                }\n+            }\n+        }\n+\n+        // If we pick a \"clever\" (by-value) ABI, we might have to adjust the ABI of the\n+        // variants to ensure they are consistent. This is because a downcast is\n+        // semantically a NOP, and thus should not affect layout.\n+        if matches!(abi, Abi::Scalar(..) | Abi::ScalarPair(..)) {\n+            for variant in &mut layout_variants {\n+                // We only do this for variants with fields; the others are not accessed anyway.\n+                // Also do not overwrite any already existing \"clever\" ABIs.\n+                if variant.fields.count() > 0 && matches!(variant.abi, Abi::Aggregate { .. }) {\n+                    variant.abi = abi;\n+                    // Also need to bump up the size and alignment, so that the entire value fits in here.\n+                    variant.size = cmp::max(variant.size, size);\n+                    variant.align.abi = cmp::max(variant.align.abi, align.abi);\n+                }\n+            }\n+        }\n+\n+        let largest_niche = Niche::from_scalar(dl, Size::ZERO, tag);\n+\n+        let tagged_layout = LayoutS {\n+            variants: Variants::Multiple {\n+                tag,\n+                tag_encoding: TagEncoding::Direct,\n+                tag_field: 0,\n+                variants: IndexVec::new(),\n+            },\n+            fields: FieldsShape::Arbitrary {\n+                offsets: [Size::ZERO].into(),\n+                memory_index: [0].into(),\n+            },\n+            largest_niche,\n+            abi,\n+            align,\n+            size,\n+        };\n+\n+        let tagged_layout = TmpLayout { layout: tagged_layout, variants: layout_variants };\n+\n+        let mut best_layout = match (tagged_layout, niche_filling_layout) {\n+            (tl, Some(nl)) => {\n+                // Pick the smaller layout; otherwise,\n+                // pick the layout with the larger niche; otherwise,\n+                // pick tagged as it has simpler codegen.\n+                use cmp::Ordering::*;\n+                let niche_size =\n+                    |tmp_l: &TmpLayout| tmp_l.layout.largest_niche.map_or(0, |n| n.available(dl));\n+                match (tl.layout.size.cmp(&nl.layout.size), niche_size(&tl).cmp(&niche_size(&nl))) {\n+                    (Greater, _) => nl,\n+                    (Equal, Less) => nl,\n+                    _ => tl,\n+                }\n+            }\n+            (tl, None) => tl,\n+        };\n+\n+        // Now we can intern the variant layouts and store them in the enum layout.\n+        best_layout.layout.variants = match best_layout.layout.variants {\n+            Variants::Multiple { tag, tag_encoding, tag_field, .. } => {\n+                Variants::Multiple { tag, tag_encoding, tag_field, variants: best_layout.variants }\n+            }\n+            _ => panic!(),\n+        };\n+        Some(best_layout.layout)\n+    }\n+\n+    fn layout_of_union(\n+        &self,\n+        repr: &ReprOptions,\n+        variants: &IndexSlice<VariantIdx, IndexVec<FieldIdx, Layout<'_>>>,\n+    ) -> Option<LayoutS> {\n+        let dl = self.current_data_layout();\n+        let dl = dl.borrow();\n+        let mut align = if repr.pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n+\n+        if let Some(repr_align) = repr.align {\n+            align = align.max(AbiAndPrefAlign::new(repr_align));\n+        }\n+\n+        // If all the non-ZST fields have the same ABI and union ABI optimizations aren't\n+        // disabled, we can use that common ABI for the union as a whole.\n+        struct AbiMismatch;\n+        let mut common_non_zst_abi_and_align = if repr.inhibit_union_abi_opt() {\n+            // Can't optimize\n+            Err(AbiMismatch)\n+        } else {\n+            Ok(None)\n+        };\n+\n+        let mut size = Size::ZERO;\n+        let only_variant = &variants[FIRST_VARIANT];\n+        for field in only_variant {\n+            assert!(field.0.is_sized());\n+\n+            align = align.max(field.align());\n+            size = cmp::max(size, field.size());\n+\n+            if field.0.is_zst() {\n+                // Nothing more to do for ZST fields\n+                continue;\n+            }\n+\n+            if let Ok(common) = common_non_zst_abi_and_align {\n+                // Discard valid range information and allow undef\n+                let field_abi = field.abi().to_union();\n+\n+                if let Some((common_abi, common_align)) = common {\n+                    if common_abi != field_abi {\n+                        // Different fields have different ABI: disable opt\n+                        common_non_zst_abi_and_align = Err(AbiMismatch);\n+                    } else {\n+                        // Fields with the same non-Aggregate ABI should also\n+                        // have the same alignment\n+                        if !matches!(common_abi, Abi::Aggregate { .. }) {\n+                            assert_eq!(\n+                                common_align,\n+                                field.align().abi,\n+                                \"non-Aggregate field with matching ABI but differing alignment\"\n+                            );\n+                        }\n+                    }\n+                } else {\n+                    // First non-ZST field: record its ABI and alignment\n+                    common_non_zst_abi_and_align = Ok(Some((field_abi, field.align().abi)));\n+                }\n+            }\n+        }\n+\n+        if let Some(pack) = repr.pack {\n+            align = align.min(AbiAndPrefAlign::new(pack));\n+        }\n+\n+        // If all non-ZST fields have the same ABI, we may forward that ABI\n+        // for the union as a whole, unless otherwise inhibited.\n+        let abi = match common_non_zst_abi_and_align {\n+            Err(AbiMismatch) | Ok(None) => Abi::Aggregate { sized: true },\n+            Ok(Some((abi, _))) => {\n+                if abi.inherent_align(dl).map(|a| a.abi) != Some(align.abi) {\n+                    // Mismatched alignment (e.g. union is #[repr(packed)]): disable opt\n+                    Abi::Aggregate { sized: true }\n+                } else {\n+                    abi\n+                }\n+            }\n+        };\n+\n+        Some(LayoutS {\n+            variants: Variants::Single { index: FIRST_VARIANT },\n+            fields: FieldsShape::Union(NonZeroUsize::new(only_variant.len())?),\n+            abi,\n+            largest_niche: None,\n+            align,\n+            size: size.align_to(align.abi),\n+        })\n+    }\n+}\n+\n+/// Determines towards which end of a struct layout optimizations will try to place the best niches.\n+enum NicheBias {\n+    Start,\n+    End,\n+}\n+\n+fn univariant(\n+    this: &(impl LayoutCalculator + ?Sized),\n+    dl: &TargetDataLayout,\n+    fields: &IndexSlice<FieldIdx, Layout<'_>>,\n+    repr: &ReprOptions,\n+    kind: StructKind,\n+    niche_bias: NicheBias,\n+) -> Option<LayoutS> {\n+    let pack = repr.pack;\n+    let mut align = if pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n+    let mut inverse_memory_index: IndexVec<u32, FieldIdx> = fields.indices().collect();\n+    let optimize = !repr.inhibit_struct_field_reordering_opt();\n+    if optimize && fields.len() > 1 {\n+        let end = if let StructKind::MaybeUnsized = kind { fields.len() - 1 } else { fields.len() };\n+        let optimizing = &mut inverse_memory_index.raw[..end];\n+\n+        // If `-Z randomize-layout` was enabled for the type definition we can shuffle\n+        // the field ordering to try and catch some code making assumptions about layouts\n+        // we don't guarantee\n+        if repr.can_randomize_type_layout() && cfg!(feature = \"randomize\") {\n+            #[cfg(feature = \"randomize\")]\n+            {\n+                // `ReprOptions.layout_seed` is a deterministic seed that we can use to\n+                // randomize field ordering with\n+                let mut rng = Xoshiro128StarStar::seed_from_u64(repr.field_shuffle_seed.as_u64());\n+\n+                // Shuffle the ordering of the fields\n+                optimizing.shuffle(&mut rng);\n+            }\n+            // Otherwise we just leave things alone and actually optimize the type's fields\n+        } else {\n+            let max_field_align = fields.iter().map(|f| f.align().abi.bytes()).max().unwrap_or(1);\n+            let largest_niche_size = fields\n+                .iter()\n+                .filter_map(|f| f.largest_niche())\n+                .map(|n| n.available(dl))\n+                .max()\n+                .unwrap_or(0);\n+\n+            // Calculates a sort key to group fields by their alignment or possibly some size-derived\n+            // pseudo-alignment.\n+            let alignment_group_key = |layout: Layout<'_>| {\n+                if let Some(pack) = pack {\n+                    // return the packed alignment in bytes\n+                    layout.align().abi.min(pack).bytes()\n+                } else {\n+                    // returns log2(effective-align).\n+                    // This is ok since `pack` applies to all fields equally.\n+                    // The calculation assumes that size is an integer multiple of align, except for ZSTs.\n+                    //\n+                    let align = layout.align().abi.bytes();\n+                    let size = layout.size().bytes();\n+                    let niche_size = layout.largest_niche().map(|n| n.available(dl)).unwrap_or(0);\n+                    // group [u8; 4] with align-4 or [u8; 6] with align-2 fields\n+                    let size_as_align = align.max(size).trailing_zeros();\n+                    let size_as_align = if largest_niche_size > 0 {\n+                        match niche_bias {\n+                            // Given `A(u8, [u8; 16])` and `B(bool, [u8; 16])` we want to bump the array\n+                            // to the front in the first case (for aligned loads) but keep the bool in front\n+                            // in the second case for its niches.\n+                            NicheBias::Start => max_field_align.trailing_zeros().min(size_as_align),\n+                            // When moving niches towards the end of the struct then for\n+                            // A((u8, u8, u8, bool), (u8, bool, u8)) we want to keep the first tuple\n+                            // in the align-1 group because its bool can be moved closer to the end.\n+                            NicheBias::End if niche_size == largest_niche_size => {\n+                                align.trailing_zeros()\n+                            }\n+                            NicheBias::End => size_as_align,\n+                        }\n+                    } else {\n+                        size_as_align\n+                    };\n+                    size_as_align as u64\n+                }\n+            };\n+\n+            match kind {\n+                StructKind::AlwaysSized | StructKind::MaybeUnsized => {\n+                    // Currently `LayoutS` only exposes a single niche so sorting is usually sufficient\n+                    // to get one niche into the preferred position. If it ever supported multiple niches\n+                    // then a more advanced pick-and-pack approach could provide better results.\n+                    // But even for the single-niche cache it's not optimal. E.g. for\n+                    // A(u32, (bool, u8), u16) it would be possible to move the bool to the front\n+                    // but it would require packing the tuple together with the u16 to build a 4-byte\n+                    // group so that the u32 can be placed after it without padding. This kind\n+                    // of packing can't be achieved by sorting.\n+                    optimizing.sort_by_key(|&x| {\n+                        let f = fields[x];\n+                        let field_size = f.size().bytes();\n+                        let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n+                        let niche_size_key = match niche_bias {\n+                            // large niche first\n+                            NicheBias::Start => !niche_size,\n+                            // large niche last\n+                            NicheBias::End => niche_size,\n+                        };\n+                        let inner_niche_offset_key = match niche_bias {\n+                            NicheBias::Start => f.largest_niche().map_or(0, |n| n.offset.bytes()),\n+                            NicheBias::End => f.largest_niche().map_or(0, |n| {\n+                                !(field_size - n.value.size(dl).bytes() - n.offset.bytes())\n+                            }),\n+                        };\n+\n+                        (\n+                            // Place ZSTs first to avoid \"interesting offsets\", especially with only one\n+                            // or two non-ZST fields. This helps Scalar/ScalarPair layouts.\n+                            !f.0.is_zst(),\n+                            // Then place largest alignments first.\n+                            cmp::Reverse(alignment_group_key(f)),\n+                            // Then prioritize niche placement within alignment group according to\n+                            // `niche_bias_start`.\n+                            niche_size_key,\n+                            // Then among fields with equally-sized niches prefer the ones\n+                            // closer to the start/end of the field.\n+                            inner_niche_offset_key,\n+                        )\n+                    });\n+                }\n+\n+                StructKind::Prefixed(..) => {\n+                    // Sort in ascending alignment so that the layout stays optimal\n+                    // regardless of the prefix.\n+                    // And put the largest niche in an alignment group at the end\n+                    // so it can be used as discriminant in jagged enums\n+                    optimizing.sort_by_key(|&x| {\n+                        let f = fields[x];\n+                        let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n+                        (alignment_group_key(f), niche_size)\n+                    });\n+                }\n+            }\n+\n+            // FIXME(Kixiron): We can always shuffle fields within a given alignment class\n+            //                 regardless of the status of `-Z randomize-layout`\n+        }\n+    }\n+    // inverse_memory_index holds field indices by increasing memory offset.\n+    // That is, if field 5 has offset 0, the first element of inverse_memory_index is 5.\n+    // We now write field offsets to the corresponding offset slot;\n+    // field 5 with offset 0 puts 0 in offsets[5].\n+    // At the bottom of this function, we invert `inverse_memory_index` to\n+    // produce `memory_index` (see `invert_mapping`).\n+    let mut sized = true;\n+    let mut offsets = IndexVec::from_elem(Size::ZERO, &fields);\n+    let mut offset = Size::ZERO;\n+    let mut largest_niche = None;\n+    let mut largest_niche_available = 0;\n+    if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n+        let prefix_align =\n+            if let Some(pack) = pack { prefix_align.min(pack) } else { prefix_align };\n+        align = align.max(AbiAndPrefAlign::new(prefix_align));\n+        offset = prefix_size.align_to(prefix_align);\n+    }\n+    for &i in &inverse_memory_index {\n+        let field = &fields[i];\n+        if !sized {\n+            this.delay_bug(format!(\n+                \"univariant: field #{} comes after unsized field\",\n+                offsets.len(),\n+            ));\n+        }\n+\n+        if field.0.is_unsized() {\n+            sized = false;\n+        }\n+\n+        // Invariant: offset < dl.obj_size_bound() <= 1<<61\n+        let field_align = if let Some(pack) = pack {\n+            field.align().min(AbiAndPrefAlign::new(pack))\n+        } else {\n+            field.align()\n+        };\n+        offset = offset.align_to(field_align.abi);\n+        align = align.max(field_align);\n+\n+        debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n+        offsets[i] = offset;\n+\n+        if let Some(mut niche) = field.largest_niche() {\n+            let available = niche.available(dl);\n+            // Pick up larger niches.\n+            let prefer_new_niche = match niche_bias {\n+                NicheBias::Start => available > largest_niche_available,\n+                // if there are several niches of the same size then pick the last one\n+                NicheBias::End => available >= largest_niche_available,\n+            };\n+            if prefer_new_niche {\n+                largest_niche_available = available;\n+                niche.offset += offset;\n+                largest_niche = Some(niche);\n+            }\n+        }\n+\n+        offset = offset.checked_add(field.size(), dl)?;\n+    }\n+    if let Some(repr_align) = repr.align {\n+        align = align.max(AbiAndPrefAlign::new(repr_align));\n+    }\n+    debug!(\"univariant min_size: {:?}\", offset);\n+    let min_size = offset;\n+    // As stated above, inverse_memory_index holds field indices by increasing offset.\n+    // This makes it an already-sorted view of the offsets vec.\n+    // To invert it, consider:\n+    // If field 5 has offset 0, offsets[0] is 5, and memory_index[5] should be 0.\n+    // Field 5 would be the first element, so memory_index is i:\n+    // Note: if we didn't optimize, it's already right.\n+    let memory_index = if optimize {\n+        inverse_memory_index.invert_bijective_mapping()\n+    } else {\n+        debug_assert!(inverse_memory_index.iter().copied().eq(fields.indices()));\n+        inverse_memory_index.into_iter().map(FieldIdx::as_u32).collect()\n+    };\n+    let size = min_size.align_to(align.abi);\n+    let mut abi = Abi::Aggregate { sized };\n+    // Unpack newtype ABIs and find scalar pairs.\n+    if sized && size.bytes() > 0 {\n+        // All other fields must be ZSTs.\n+        let mut non_zst_fields = fields.iter_enumerated().filter(|&(_, f)| !f.0.is_zst());\n+\n+        match (non_zst_fields.next(), non_zst_fields.next(), non_zst_fields.next()) {\n+            // We have exactly one non-ZST field.\n+            (Some((i, field)), None, None) => {\n+                // Field fills the struct and it has a scalar or scalar pair ABI.\n+                if offsets[i].bytes() == 0 && align.abi == field.align().abi && size == field.size()\n+                {\n+                    match field.abi() {\n+                        // For plain scalars, or vectors of them, we can't unpack\n+                        // newtypes for `#[repr(C)]`, as that affects C ABIs.\n+                        Abi::Scalar(_) | Abi::Vector { .. } if optimize => {\n+                            abi = field.abi();\n+                        }\n+                        // But scalar pairs are Rust-specific and get\n+                        // treated as aggregates by C ABIs anyway.\n+                        Abi::ScalarPair(..) => {\n+                            abi = field.abi();\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+\n+            // Two non-ZST fields, and they're both scalars.\n+            (Some((i, a)), Some((j, b)), None) => {\n+                match (a.abi(), b.abi()) {\n+                    (Abi::Scalar(a), Abi::Scalar(b)) => {\n+                        // Order by the memory placement, not source order.\n+                        let ((i, a), (j, b)) = if offsets[i] < offsets[j] {\n+                            ((i, a), (j, b))\n+                        } else {\n+                            ((j, b), (i, a))\n+                        };\n+                        let pair = this.scalar_pair(a, b);\n+                        let pair_offsets = match pair.fields {\n+                            FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n+                                assert_eq!(memory_index.raw, [0, 1]);\n+                                offsets\n+                            }\n+                            _ => panic!(),\n+                        };\n+                        if offsets[i] == pair_offsets[FieldIdx::from_usize(0)]\n+                            && offsets[j] == pair_offsets[FieldIdx::from_usize(1)]\n+                            && align == pair.align\n+                            && size == pair.size\n+                        {\n+                            // We can use `ScalarPair` only when it matches our\n+                            // already computed layout (including `#[repr(C)]`).\n+                            abi = pair.abi;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+    }\n+    if fields.iter().any(|f| f.abi().is_uninhabited()) {\n+        abi = Abi::Uninhabited;\n+    }\n+    Some(LayoutS {\n+        variants: Variants::Single { index: FIRST_VARIANT },\n+        fields: FieldsShape::Arbitrary { offsets, memory_index },\n+        abi,\n+        largest_niche,\n+        align,\n+        size,\n+    })\n+}\n+\n+fn format_field_niches(\n+    layout: &LayoutS,\n+    fields: &IndexSlice<FieldIdx, Layout<'_>>,\n+    dl: &TargetDataLayout,\n+) -> String {\n+    let mut s = String::new();\n+    for i in layout.fields.index_by_increasing_offset() {\n+        let offset = layout.fields.offset(i);\n+        let f = fields[i.into()];\n+        write!(s, \"[o{}a{}s{}\", offset.bytes(), f.align().abi.bytes(), f.size().bytes()).unwrap();\n+        if let Some(n) = f.largest_niche() {\n+            write!(\n+                s,\n+                \" n{}b{}s{}\",\n+                n.offset.bytes(),\n+                n.available(dl).ilog2(),\n+                n.value.size(dl).bytes()\n+            )\n+            .unwrap();\n+        }\n+        write!(s, \"] \").unwrap();\n+    }\n+    s\n+}"}, {"sha": "e1b9987f5781619a813c31e172b9f51238e58845", "filename": "compiler/rustc_abi/src/lib.rs", "status": "added", "additions": 1663, "deletions": 0, "changes": 1663, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -0,0 +1,1663 @@\n+#![cfg_attr(feature = \"nightly\", feature(step_trait, rustc_attrs, min_specialization))]\n+\n+use std::fmt;\n+#[cfg(feature = \"nightly\")]\n+use std::iter::Step;\n+use std::num::{NonZeroUsize, ParseIntError};\n+use std::ops::{Add, AddAssign, Mul, RangeInclusive, Sub};\n+use std::str::FromStr;\n+\n+use bitflags::bitflags;\n+use rustc_data_structures::intern::Interned;\n+use rustc_data_structures::stable_hasher::Hash64;\n+#[cfg(feature = \"nightly\")]\n+use rustc_data_structures::stable_hasher::StableOrd;\n+use rustc_index::{IndexSlice, IndexVec};\n+#[cfg(feature = \"nightly\")]\n+use rustc_macros::HashStable_Generic;\n+#[cfg(feature = \"nightly\")]\n+use rustc_macros::{Decodable, Encodable};\n+\n+mod layout;\n+\n+pub use layout::LayoutCalculator;\n+\n+/// Requirements for a `StableHashingContext` to be used in this crate.\n+/// This is a hack to allow using the `HashStable_Generic` derive macro\n+/// instead of implementing everything in `rustc_middle`.\n+pub trait HashStableContext {}\n+\n+use Integer::*;\n+use Primitive::*;\n+\n+bitflags! {\n+    #[derive(Default)]\n+    #[cfg_attr(feature = \"nightly\", derive(Encodable, Decodable, HashStable_Generic))]\n+    pub struct ReprFlags: u8 {\n+        const IS_C               = 1 << 0;\n+        const IS_SIMD            = 1 << 1;\n+        const IS_TRANSPARENT     = 1 << 2;\n+        // Internal only for now. If true, don't reorder fields.\n+        const IS_LINEAR          = 1 << 3;\n+        // If true, the type's layout can be randomized using\n+        // the seed stored in `ReprOptions.layout_seed`\n+        const RANDOMIZE_LAYOUT   = 1 << 4;\n+        // Any of these flags being set prevent field reordering optimisation.\n+        const IS_UNOPTIMISABLE   = ReprFlags::IS_C.bits\n+                                 | ReprFlags::IS_SIMD.bits\n+                                 | ReprFlags::IS_LINEAR.bits;\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+#[cfg_attr(feature = \"nightly\", derive(Encodable, Decodable, HashStable_Generic))]\n+pub enum IntegerType {\n+    /// Pointer sized integer type, i.e. isize and usize. The field shows signedness, that\n+    /// is, `Pointer(true)` is isize.\n+    Pointer(bool),\n+    /// Fix sized integer type, e.g. i8, u32, i128 The bool field shows signedness, `Fixed(I8, false)` means `u8`\n+    Fixed(Integer, bool),\n+}\n+\n+impl IntegerType {\n+    pub fn is_signed(&self) -> bool {\n+        match self {\n+            IntegerType::Pointer(b) => *b,\n+            IntegerType::Fixed(_, b) => *b,\n+        }\n+    }\n+}\n+\n+/// Represents the repr options provided by the user,\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Default)]\n+#[cfg_attr(feature = \"nightly\", derive(Encodable, Decodable, HashStable_Generic))]\n+pub struct ReprOptions {\n+    pub int: Option<IntegerType>,\n+    pub align: Option<Align>,\n+    pub pack: Option<Align>,\n+    pub flags: ReprFlags,\n+    /// The seed to be used for randomizing a type's layout\n+    ///\n+    /// Note: This could technically be a `Hash128` which would\n+    /// be the \"most accurate\" hash as it'd encompass the item and crate\n+    /// hash without loss, but it does pay the price of being larger.\n+    /// Everything's a tradeoff, a 64-bit seed should be sufficient for our\n+    /// purposes (primarily `-Z randomize-layout`)\n+    pub field_shuffle_seed: Hash64,\n+}\n+\n+impl ReprOptions {\n+    #[inline]\n+    pub fn simd(&self) -> bool {\n+        self.flags.contains(ReprFlags::IS_SIMD)\n+    }\n+\n+    #[inline]\n+    pub fn c(&self) -> bool {\n+        self.flags.contains(ReprFlags::IS_C)\n+    }\n+\n+    #[inline]\n+    pub fn packed(&self) -> bool {\n+        self.pack.is_some()\n+    }\n+\n+    #[inline]\n+    pub fn transparent(&self) -> bool {\n+        self.flags.contains(ReprFlags::IS_TRANSPARENT)\n+    }\n+\n+    #[inline]\n+    pub fn linear(&self) -> bool {\n+        self.flags.contains(ReprFlags::IS_LINEAR)\n+    }\n+\n+    /// Returns the discriminant type, given these `repr` options.\n+    /// This must only be called on enums!\n+    pub fn discr_type(&self) -> IntegerType {\n+        self.int.unwrap_or(IntegerType::Pointer(true))\n+    }\n+\n+    /// Returns `true` if this `#[repr()]` should inhabit \"smart enum\n+    /// layout\" optimizations, such as representing `Foo<&T>` as a\n+    /// single pointer.\n+    pub fn inhibit_enum_layout_opt(&self) -> bool {\n+        self.c() || self.int.is_some()\n+    }\n+\n+    /// Returns `true` if this `#[repr()]` should inhibit struct field reordering\n+    /// optimizations, such as with `repr(C)`, `repr(packed(1))`, or `repr(<int>)`.\n+    pub fn inhibit_struct_field_reordering_opt(&self) -> bool {\n+        if let Some(pack) = self.pack {\n+            if pack.bytes() == 1 {\n+                return true;\n+            }\n+        }\n+\n+        self.flags.intersects(ReprFlags::IS_UNOPTIMISABLE) || self.int.is_some()\n+    }\n+\n+    /// Returns `true` if this type is valid for reordering and `-Z randomize-layout`\n+    /// was enabled for its declaration crate\n+    pub fn can_randomize_type_layout(&self) -> bool {\n+        !self.inhibit_struct_field_reordering_opt()\n+            && self.flags.contains(ReprFlags::RANDOMIZE_LAYOUT)\n+    }\n+\n+    /// Returns `true` if this `#[repr()]` should inhibit union ABI optimisations.\n+    pub fn inhibit_union_abi_opt(&self) -> bool {\n+        self.c()\n+    }\n+}\n+\n+/// Parsed [Data layout](https://llvm.org/docs/LangRef.html#data-layout)\n+/// for a target, which contains everything needed to compute layouts.\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct TargetDataLayout {\n+    pub endian: Endian,\n+    pub i1_align: AbiAndPrefAlign,\n+    pub i8_align: AbiAndPrefAlign,\n+    pub i16_align: AbiAndPrefAlign,\n+    pub i32_align: AbiAndPrefAlign,\n+    pub i64_align: AbiAndPrefAlign,\n+    pub i128_align: AbiAndPrefAlign,\n+    pub f32_align: AbiAndPrefAlign,\n+    pub f64_align: AbiAndPrefAlign,\n+    pub pointer_size: Size,\n+    pub pointer_align: AbiAndPrefAlign,\n+    pub aggregate_align: AbiAndPrefAlign,\n+\n+    /// Alignments for vector types.\n+    pub vector_align: Vec<(Size, AbiAndPrefAlign)>,\n+\n+    pub instruction_address_space: AddressSpace,\n+\n+    /// Minimum size of #[repr(C)] enums (default c_int::BITS, usually 32)\n+    /// Note: This isn't in LLVM's data layout string, it is `short_enum`\n+    /// so the only valid spec for LLVM is c_int::BITS or 8\n+    pub c_enum_min_size: Integer,\n+}\n+\n+impl Default for TargetDataLayout {\n+    /// Creates an instance of `TargetDataLayout`.\n+    fn default() -> TargetDataLayout {\n+        let align = |bits| Align::from_bits(bits).unwrap();\n+        TargetDataLayout {\n+            endian: Endian::Big,\n+            i1_align: AbiAndPrefAlign::new(align(8)),\n+            i8_align: AbiAndPrefAlign::new(align(8)),\n+            i16_align: AbiAndPrefAlign::new(align(16)),\n+            i32_align: AbiAndPrefAlign::new(align(32)),\n+            i64_align: AbiAndPrefAlign { abi: align(32), pref: align(64) },\n+            i128_align: AbiAndPrefAlign { abi: align(32), pref: align(64) },\n+            f32_align: AbiAndPrefAlign::new(align(32)),\n+            f64_align: AbiAndPrefAlign::new(align(64)),\n+            pointer_size: Size::from_bits(64),\n+            pointer_align: AbiAndPrefAlign::new(align(64)),\n+            aggregate_align: AbiAndPrefAlign { abi: align(0), pref: align(64) },\n+            vector_align: vec![\n+                (Size::from_bits(64), AbiAndPrefAlign::new(align(64))),\n+                (Size::from_bits(128), AbiAndPrefAlign::new(align(128))),\n+            ],\n+            instruction_address_space: AddressSpace::DATA,\n+            c_enum_min_size: Integer::I32,\n+        }\n+    }\n+}\n+\n+pub enum TargetDataLayoutErrors<'a> {\n+    InvalidAddressSpace { addr_space: &'a str, cause: &'a str, err: ParseIntError },\n+    InvalidBits { kind: &'a str, bit: &'a str, cause: &'a str, err: ParseIntError },\n+    MissingAlignment { cause: &'a str },\n+    InvalidAlignment { cause: &'a str, err: AlignFromBytesError },\n+    InconsistentTargetArchitecture { dl: &'a str, target: &'a str },\n+    InconsistentTargetPointerWidth { pointer_size: u64, target: u32 },\n+    InvalidBitsSize { err: String },\n+}\n+\n+impl TargetDataLayout {\n+    /// Parse data layout from an [llvm data layout string](https://llvm.org/docs/LangRef.html#data-layout)\n+    ///\n+    /// This function doesn't fill `c_enum_min_size` and it will always be `I32` since it can not be\n+    /// determined from llvm string.\n+    pub fn parse_from_llvm_datalayout_string<'a>(\n+        input: &'a str,\n+    ) -> Result<TargetDataLayout, TargetDataLayoutErrors<'a>> {\n+        // Parse an address space index from a string.\n+        let parse_address_space = |s: &'a str, cause: &'a str| {\n+            s.parse::<u32>().map(AddressSpace).map_err(|err| {\n+                TargetDataLayoutErrors::InvalidAddressSpace { addr_space: s, cause, err }\n+            })\n+        };\n+\n+        // Parse a bit count from a string.\n+        let parse_bits = |s: &'a str, kind: &'a str, cause: &'a str| {\n+            s.parse::<u64>().map_err(|err| TargetDataLayoutErrors::InvalidBits {\n+                kind,\n+                bit: s,\n+                cause,\n+                err,\n+            })\n+        };\n+\n+        // Parse a size string.\n+        let size = |s: &'a str, cause: &'a str| parse_bits(s, \"size\", cause).map(Size::from_bits);\n+\n+        // Parse an alignment string.\n+        let align = |s: &[&'a str], cause: &'a str| {\n+            if s.is_empty() {\n+                return Err(TargetDataLayoutErrors::MissingAlignment { cause });\n+            }\n+            let align_from_bits = |bits| {\n+                Align::from_bits(bits)\n+                    .map_err(|err| TargetDataLayoutErrors::InvalidAlignment { cause, err })\n+            };\n+            let abi = parse_bits(s[0], \"alignment\", cause)?;\n+            let pref = s.get(1).map_or(Ok(abi), |pref| parse_bits(pref, \"alignment\", cause))?;\n+            Ok(AbiAndPrefAlign { abi: align_from_bits(abi)?, pref: align_from_bits(pref)? })\n+        };\n+\n+        let mut dl = TargetDataLayout::default();\n+        let mut i128_align_src = 64;\n+        for spec in input.split('-') {\n+            let spec_parts = spec.split(':').collect::<Vec<_>>();\n+\n+            match &*spec_parts {\n+                [\"e\"] => dl.endian = Endian::Little,\n+                [\"E\"] => dl.endian = Endian::Big,\n+                [p] if p.starts_with('P') => {\n+                    dl.instruction_address_space = parse_address_space(&p[1..], \"P\")?\n+                }\n+                [\"a\", ref a @ ..] => dl.aggregate_align = align(a, \"a\")?,\n+                [\"f32\", ref a @ ..] => dl.f32_align = align(a, \"f32\")?,\n+                [\"f64\", ref a @ ..] => dl.f64_align = align(a, \"f64\")?,\n+                // FIXME(erikdesjardins): we should be parsing nonzero address spaces\n+                // this will require replacing TargetDataLayout::{pointer_size,pointer_align}\n+                // with e.g. `fn pointer_size_in(AddressSpace)`\n+                [p @ \"p\", s, ref a @ ..] | [p @ \"p0\", s, ref a @ ..] => {\n+                    dl.pointer_size = size(s, p)?;\n+                    dl.pointer_align = align(a, p)?;\n+                }\n+                [s, ref a @ ..] if s.starts_with('i') => {\n+                    let Ok(bits) = s[1..].parse::<u64>() else {\n+                        size(&s[1..], \"i\")?; // For the user error.\n+                        continue;\n+                    };\n+                    let a = align(a, s)?;\n+                    match bits {\n+                        1 => dl.i1_align = a,\n+                        8 => dl.i8_align = a,\n+                        16 => dl.i16_align = a,\n+                        32 => dl.i32_align = a,\n+                        64 => dl.i64_align = a,\n+                        _ => {}\n+                    }\n+                    if bits >= i128_align_src && bits <= 128 {\n+                        // Default alignment for i128 is decided by taking the alignment of\n+                        // largest-sized i{64..=128}.\n+                        i128_align_src = bits;\n+                        dl.i128_align = a;\n+                    }\n+                }\n+                [s, ref a @ ..] if s.starts_with('v') => {\n+                    let v_size = size(&s[1..], \"v\")?;\n+                    let a = align(a, s)?;\n+                    if let Some(v) = dl.vector_align.iter_mut().find(|v| v.0 == v_size) {\n+                        v.1 = a;\n+                        continue;\n+                    }\n+                    // No existing entry, add a new one.\n+                    dl.vector_align.push((v_size, a));\n+                }\n+                _ => {} // Ignore everything else.\n+            }\n+        }\n+        Ok(dl)\n+    }\n+\n+    /// Returns exclusive upper bound on object size.\n+    ///\n+    /// The theoretical maximum object size is defined as the maximum positive `isize` value.\n+    /// This ensures that the `offset` semantics remain well-defined by allowing it to correctly\n+    /// index every address within an object along with one byte past the end, along with allowing\n+    /// `isize` to store the difference between any two pointers into an object.\n+    ///\n+    /// The upper bound on 64-bit currently needs to be lower because LLVM uses a 64-bit integer\n+    /// to represent object size in bits. It would need to be 1 << 61 to account for this, but is\n+    /// currently conservatively bounded to 1 << 47 as that is enough to cover the current usable\n+    /// address space on 64-bit ARMv8 and x86_64.\n+    #[inline]\n+    pub fn obj_size_bound(&self) -> u64 {\n+        match self.pointer_size.bits() {\n+            16 => 1 << 15,\n+            32 => 1 << 31,\n+            64 => 1 << 47,\n+            bits => panic!(\"obj_size_bound: unknown pointer bit size {}\", bits),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn ptr_sized_integer(&self) -> Integer {\n+        match self.pointer_size.bits() {\n+            16 => I16,\n+            32 => I32,\n+            64 => I64,\n+            bits => panic!(\"ptr_sized_integer: unknown pointer bit size {}\", bits),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn vector_align(&self, vec_size: Size) -> AbiAndPrefAlign {\n+        for &(size, align) in &self.vector_align {\n+            if size == vec_size {\n+                return align;\n+            }\n+        }\n+        // Default to natural alignment, which is what LLVM does.\n+        // That is, use the size, rounded up to a power of 2.\n+        AbiAndPrefAlign::new(Align::from_bytes(vec_size.bytes().next_power_of_two()).unwrap())\n+    }\n+}\n+\n+pub trait HasDataLayout {\n+    fn data_layout(&self) -> &TargetDataLayout;\n+}\n+\n+impl HasDataLayout for TargetDataLayout {\n+    #[inline]\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        self\n+    }\n+}\n+\n+/// Endianness of the target, which must match cfg(target-endian).\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub enum Endian {\n+    Little,\n+    Big,\n+}\n+\n+impl Endian {\n+    pub fn as_str(&self) -> &'static str {\n+        match self {\n+            Self::Little => \"little\",\n+            Self::Big => \"big\",\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for Endian {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(self.as_str())\n+    }\n+}\n+\n+impl FromStr for Endian {\n+    type Err = String;\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"little\" => Ok(Self::Little),\n+            \"big\" => Ok(Self::Big),\n+            _ => Err(format!(r#\"unknown endian: \"{}\"\"#, s)),\n+        }\n+    }\n+}\n+\n+/// Size of a type in bytes.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[cfg_attr(feature = \"nightly\", derive(Encodable, Decodable, HashStable_Generic))]\n+pub struct Size {\n+    raw: u64,\n+}\n+\n+// Safety: Ord is implement as just comparing numerical values and numerical values\n+// are not changed by (de-)serialization.\n+#[cfg(feature = \"nightly\")]\n+unsafe impl StableOrd for Size {\n+    const CAN_USE_UNSTABLE_SORT: bool = true;\n+}\n+\n+// This is debug-printed a lot in larger structs, don't waste too much space there\n+impl fmt::Debug for Size {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"Size({} bytes)\", self.bytes())\n+    }\n+}\n+\n+impl Size {\n+    pub const ZERO: Size = Size { raw: 0 };\n+\n+    /// Rounds `bits` up to the next-higher byte boundary, if `bits` is\n+    /// not a multiple of 8.\n+    pub fn from_bits(bits: impl TryInto<u64>) -> Size {\n+        let bits = bits.try_into().ok().unwrap();\n+        // Avoid potential overflow from `bits + 7`.\n+        Size { raw: bits / 8 + ((bits % 8) + 7) / 8 }\n+    }\n+\n+    #[inline]\n+    pub fn from_bytes(bytes: impl TryInto<u64>) -> Size {\n+        let bytes: u64 = bytes.try_into().ok().unwrap();\n+        Size { raw: bytes }\n+    }\n+\n+    #[inline]\n+    pub fn bytes(self) -> u64 {\n+        self.raw\n+    }\n+\n+    #[inline]\n+    pub fn bytes_usize(self) -> usize {\n+        self.bytes().try_into().unwrap()\n+    }\n+\n+    #[inline]\n+    pub fn bits(self) -> u64 {\n+        #[cold]\n+        fn overflow(bytes: u64) -> ! {\n+            panic!(\"Size::bits: {} bytes in bits doesn't fit in u64\", bytes)\n+        }\n+\n+        self.bytes().checked_mul(8).unwrap_or_else(|| overflow(self.bytes()))\n+    }\n+\n+    #[inline]\n+    pub fn bits_usize(self) -> usize {\n+        self.bits().try_into().unwrap()\n+    }\n+\n+    #[inline]\n+    pub fn align_to(self, align: Align) -> Size {\n+        let mask = align.bytes() - 1;\n+        Size::from_bytes((self.bytes() + mask) & !mask)\n+    }\n+\n+    #[inline]\n+    pub fn is_aligned(self, align: Align) -> bool {\n+        let mask = align.bytes() - 1;\n+        self.bytes() & mask == 0\n+    }\n+\n+    #[inline]\n+    pub fn checked_add<C: HasDataLayout>(self, offset: Size, cx: &C) -> Option<Size> {\n+        let dl = cx.data_layout();\n+\n+        let bytes = self.bytes().checked_add(offset.bytes())?;\n+\n+        if bytes < dl.obj_size_bound() { Some(Size::from_bytes(bytes)) } else { None }\n+    }\n+\n+    #[inline]\n+    pub fn checked_mul<C: HasDataLayout>(self, count: u64, cx: &C) -> Option<Size> {\n+        let dl = cx.data_layout();\n+\n+        let bytes = self.bytes().checked_mul(count)?;\n+        if bytes < dl.obj_size_bound() { Some(Size::from_bytes(bytes)) } else { None }\n+    }\n+\n+    /// Truncates `value` to `self` bits and then sign-extends it to 128 bits\n+    /// (i.e., if it is negative, fill with 1's on the left).\n+    #[inline]\n+    pub fn sign_extend(self, value: u128) -> u128 {\n+        let size = self.bits();\n+        if size == 0 {\n+            // Truncated until nothing is left.\n+            return 0;\n+        }\n+        // Sign-extend it.\n+        let shift = 128 - size;\n+        // Shift the unsigned value to the left, then shift back to the right as signed\n+        // (essentially fills with sign bit on the left).\n+        (((value << shift) as i128) >> shift) as u128\n+    }\n+\n+    /// Truncates `value` to `self` bits.\n+    #[inline]\n+    pub fn truncate(self, value: u128) -> u128 {\n+        let size = self.bits();\n+        if size == 0 {\n+            // Truncated until nothing is left.\n+            return 0;\n+        }\n+        let shift = 128 - size;\n+        // Truncate (shift left to drop out leftover values, shift right to fill with zeroes).\n+        (value << shift) >> shift\n+    }\n+\n+    #[inline]\n+    pub fn signed_int_min(&self) -> i128 {\n+        self.sign_extend(1_u128 << (self.bits() - 1)) as i128\n+    }\n+\n+    #[inline]\n+    pub fn signed_int_max(&self) -> i128 {\n+        i128::MAX >> (128 - self.bits())\n+    }\n+\n+    #[inline]\n+    pub fn unsigned_int_max(&self) -> u128 {\n+        u128::MAX >> (128 - self.bits())\n+    }\n+}\n+\n+// Panicking addition, subtraction and multiplication for convenience.\n+// Avoid during layout computation, return `LayoutError` instead.\n+\n+impl Add for Size {\n+    type Output = Size;\n+    #[inline]\n+    fn add(self, other: Size) -> Size {\n+        Size::from_bytes(self.bytes().checked_add(other.bytes()).unwrap_or_else(|| {\n+            panic!(\"Size::add: {} + {} doesn't fit in u64\", self.bytes(), other.bytes())\n+        }))\n+    }\n+}\n+\n+impl Sub for Size {\n+    type Output = Size;\n+    #[inline]\n+    fn sub(self, other: Size) -> Size {\n+        Size::from_bytes(self.bytes().checked_sub(other.bytes()).unwrap_or_else(|| {\n+            panic!(\"Size::sub: {} - {} would result in negative size\", self.bytes(), other.bytes())\n+        }))\n+    }\n+}\n+\n+impl Mul<Size> for u64 {\n+    type Output = Size;\n+    #[inline]\n+    fn mul(self, size: Size) -> Size {\n+        size * self\n+    }\n+}\n+\n+impl Mul<u64> for Size {\n+    type Output = Size;\n+    #[inline]\n+    fn mul(self, count: u64) -> Size {\n+        match self.bytes().checked_mul(count) {\n+            Some(bytes) => Size::from_bytes(bytes),\n+            None => panic!(\"Size::mul: {} * {} doesn't fit in u64\", self.bytes(), count),\n+        }\n+    }\n+}\n+\n+impl AddAssign for Size {\n+    #[inline]\n+    fn add_assign(&mut self, other: Size) {\n+        *self = *self + other;\n+    }\n+}\n+\n+#[cfg(feature = \"nightly\")]\n+impl Step for Size {\n+    #[inline]\n+    fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n+        u64::steps_between(&start.bytes(), &end.bytes())\n+    }\n+\n+    #[inline]\n+    fn forward_checked(start: Self, count: usize) -> Option<Self> {\n+        u64::forward_checked(start.bytes(), count).map(Self::from_bytes)\n+    }\n+\n+    #[inline]\n+    fn forward(start: Self, count: usize) -> Self {\n+        Self::from_bytes(u64::forward(start.bytes(), count))\n+    }\n+\n+    #[inline]\n+    unsafe fn forward_unchecked(start: Self, count: usize) -> Self {\n+        Self::from_bytes(u64::forward_unchecked(start.bytes(), count))\n+    }\n+\n+    #[inline]\n+    fn backward_checked(start: Self, count: usize) -> Option<Self> {\n+        u64::backward_checked(start.bytes(), count).map(Self::from_bytes)\n+    }\n+\n+    #[inline]\n+    fn backward(start: Self, count: usize) -> Self {\n+        Self::from_bytes(u64::backward(start.bytes(), count))\n+    }\n+\n+    #[inline]\n+    unsafe fn backward_unchecked(start: Self, count: usize) -> Self {\n+        Self::from_bytes(u64::backward_unchecked(start.bytes(), count))\n+    }\n+}\n+\n+/// Alignment of a type in bytes (always a power of two).\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[cfg_attr(feature = \"nightly\", derive(Encodable, Decodable, HashStable_Generic))]\n+pub struct Align {\n+    pow2: u8,\n+}\n+\n+// This is debug-printed a lot in larger structs, don't waste too much space there\n+impl fmt::Debug for Align {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"Align({} bytes)\", self.bytes())\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+pub enum AlignFromBytesError {\n+    NotPowerOfTwo(u64),\n+    TooLarge(u64),\n+}\n+\n+impl AlignFromBytesError {\n+    pub fn diag_ident(self) -> &'static str {\n+        match self {\n+            Self::NotPowerOfTwo(_) => \"not_power_of_two\",\n+            Self::TooLarge(_) => \"too_large\",\n+        }\n+    }\n+\n+    pub fn align(self) -> u64 {\n+        let (Self::NotPowerOfTwo(align) | Self::TooLarge(align)) = self;\n+        align\n+    }\n+}\n+\n+impl fmt::Debug for AlignFromBytesError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Display for AlignFromBytesError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            AlignFromBytesError::NotPowerOfTwo(align) => write!(f, \"`{align}` is not a power of 2\"),\n+            AlignFromBytesError::TooLarge(align) => write!(f, \"`{align}` is too large\"),\n+        }\n+    }\n+}\n+\n+impl Align {\n+    pub const ONE: Align = Align { pow2: 0 };\n+    pub const MAX: Align = Align { pow2: 29 };\n+\n+    #[inline]\n+    pub fn from_bits(bits: u64) -> Result<Align, AlignFromBytesError> {\n+        Align::from_bytes(Size::from_bits(bits).bytes())\n+    }\n+\n+    #[inline]\n+    pub fn from_bytes(align: u64) -> Result<Align, AlignFromBytesError> {\n+        // Treat an alignment of 0 bytes like 1-byte alignment.\n+        if align == 0 {\n+            return Ok(Align::ONE);\n+        }\n+\n+        #[cold]\n+        fn not_power_of_2(align: u64) -> AlignFromBytesError {\n+            AlignFromBytesError::NotPowerOfTwo(align)\n+        }\n+\n+        #[cold]\n+        fn too_large(align: u64) -> AlignFromBytesError {\n+            AlignFromBytesError::TooLarge(align)\n+        }\n+\n+        let tz = align.trailing_zeros();\n+        if align != (1 << tz) {\n+            return Err(not_power_of_2(align));\n+        }\n+\n+        let pow2 = tz as u8;\n+        if pow2 > Self::MAX.pow2 {\n+            return Err(too_large(align));\n+        }\n+\n+        Ok(Align { pow2 })\n+    }\n+\n+    #[inline]\n+    pub fn bytes(self) -> u64 {\n+        1 << self.pow2\n+    }\n+\n+    #[inline]\n+    pub fn bits(self) -> u64 {\n+        self.bytes() * 8\n+    }\n+\n+    /// Computes the best alignment possible for the given offset\n+    /// (the largest power of two that the offset is a multiple of).\n+    ///\n+    /// N.B., for an offset of `0`, this happens to return `2^64`.\n+    #[inline]\n+    pub fn max_for_offset(offset: Size) -> Align {\n+        Align { pow2: offset.bytes().trailing_zeros() as u8 }\n+    }\n+\n+    /// Lower the alignment, if necessary, such that the given offset\n+    /// is aligned to it (the offset is a multiple of the alignment).\n+    #[inline]\n+    pub fn restrict_for_offset(self, offset: Size) -> Align {\n+        self.min(Align::max_for_offset(offset))\n+    }\n+}\n+\n+/// A pair of alignments, ABI-mandated and preferred.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+\n+pub struct AbiAndPrefAlign {\n+    pub abi: Align,\n+    pub pref: Align,\n+}\n+\n+impl AbiAndPrefAlign {\n+    #[inline]\n+    pub fn new(align: Align) -> AbiAndPrefAlign {\n+        AbiAndPrefAlign { abi: align, pref: align }\n+    }\n+\n+    #[inline]\n+    pub fn min(self, other: AbiAndPrefAlign) -> AbiAndPrefAlign {\n+        AbiAndPrefAlign { abi: self.abi.min(other.abi), pref: self.pref.min(other.pref) }\n+    }\n+\n+    #[inline]\n+    pub fn max(self, other: AbiAndPrefAlign) -> AbiAndPrefAlign {\n+        AbiAndPrefAlign { abi: self.abi.max(other.abi), pref: self.pref.max(other.pref) }\n+    }\n+}\n+\n+/// Integers, also used for enum discriminants.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(Encodable, Decodable, HashStable_Generic))]\n+\n+pub enum Integer {\n+    I8,\n+    I16,\n+    I32,\n+    I64,\n+    I128,\n+}\n+\n+impl Integer {\n+    #[inline]\n+    pub fn size(self) -> Size {\n+        match self {\n+            I8 => Size::from_bytes(1),\n+            I16 => Size::from_bytes(2),\n+            I32 => Size::from_bytes(4),\n+            I64 => Size::from_bytes(8),\n+            I128 => Size::from_bytes(16),\n+        }\n+    }\n+\n+    /// Gets the Integer type from an IntegerType.\n+    pub fn from_attr<C: HasDataLayout>(cx: &C, ity: IntegerType) -> Integer {\n+        let dl = cx.data_layout();\n+\n+        match ity {\n+            IntegerType::Pointer(_) => dl.ptr_sized_integer(),\n+            IntegerType::Fixed(x, _) => x,\n+        }\n+    }\n+\n+    pub fn align<C: HasDataLayout>(self, cx: &C) -> AbiAndPrefAlign {\n+        let dl = cx.data_layout();\n+\n+        match self {\n+            I8 => dl.i8_align,\n+            I16 => dl.i16_align,\n+            I32 => dl.i32_align,\n+            I64 => dl.i64_align,\n+            I128 => dl.i128_align,\n+        }\n+    }\n+\n+    /// Returns the largest signed value that can be represented by this Integer.\n+    #[inline]\n+    pub fn signed_max(self) -> i128 {\n+        match self {\n+            I8 => i8::MAX as i128,\n+            I16 => i16::MAX as i128,\n+            I32 => i32::MAX as i128,\n+            I64 => i64::MAX as i128,\n+            I128 => i128::MAX,\n+        }\n+    }\n+\n+    /// Finds the smallest Integer type which can represent the signed value.\n+    #[inline]\n+    pub fn fit_signed(x: i128) -> Integer {\n+        match x {\n+            -0x0000_0000_0000_0080..=0x0000_0000_0000_007f => I8,\n+            -0x0000_0000_0000_8000..=0x0000_0000_0000_7fff => I16,\n+            -0x0000_0000_8000_0000..=0x0000_0000_7fff_ffff => I32,\n+            -0x8000_0000_0000_0000..=0x7fff_ffff_ffff_ffff => I64,\n+            _ => I128,\n+        }\n+    }\n+\n+    /// Finds the smallest Integer type which can represent the unsigned value.\n+    #[inline]\n+    pub fn fit_unsigned(x: u128) -> Integer {\n+        match x {\n+            0..=0x0000_0000_0000_00ff => I8,\n+            0..=0x0000_0000_0000_ffff => I16,\n+            0..=0x0000_0000_ffff_ffff => I32,\n+            0..=0xffff_ffff_ffff_ffff => I64,\n+            _ => I128,\n+        }\n+    }\n+\n+    /// Finds the smallest integer with the given alignment.\n+    pub fn for_align<C: HasDataLayout>(cx: &C, wanted: Align) -> Option<Integer> {\n+        let dl = cx.data_layout();\n+\n+        [I8, I16, I32, I64, I128].into_iter().find(|&candidate| {\n+            wanted == candidate.align(dl).abi && wanted.bytes() == candidate.size().bytes()\n+        })\n+    }\n+\n+    /// Find the largest integer with the given alignment or less.\n+    pub fn approximate_align<C: HasDataLayout>(cx: &C, wanted: Align) -> Integer {\n+        let dl = cx.data_layout();\n+\n+        // FIXME(eddyb) maybe include I128 in the future, when it works everywhere.\n+        for candidate in [I64, I32, I16] {\n+            if wanted >= candidate.align(dl).abi && wanted.bytes() >= candidate.size().bytes() {\n+                return candidate;\n+            }\n+        }\n+        I8\n+    }\n+\n+    // FIXME(eddyb) consolidate this and other methods that find the appropriate\n+    // `Integer` given some requirements.\n+    #[inline]\n+    pub fn from_size(size: Size) -> Result<Self, String> {\n+        match size.bits() {\n+            8 => Ok(Integer::I8),\n+            16 => Ok(Integer::I16),\n+            32 => Ok(Integer::I32),\n+            64 => Ok(Integer::I64),\n+            128 => Ok(Integer::I128),\n+            _ => Err(format!(\"rust does not support integers with {} bits\", size.bits())),\n+        }\n+    }\n+}\n+\n+/// Fundamental unit of memory access and layout.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+pub enum Primitive {\n+    /// The `bool` is the signedness of the `Integer` type.\n+    ///\n+    /// One would think we would not care about such details this low down,\n+    /// but some ABIs are described in terms of C types and ISAs where the\n+    /// integer arithmetic is done on {sign,zero}-extended registers, e.g.\n+    /// a negative integer passed by zero-extension will appear positive in\n+    /// the callee, and most operations on it will produce the wrong values.\n+    Int(Integer, bool),\n+    F32,\n+    F64,\n+    Pointer(AddressSpace),\n+}\n+\n+impl Primitive {\n+    pub fn size<C: HasDataLayout>(self, cx: &C) -> Size {\n+        let dl = cx.data_layout();\n+\n+        match self {\n+            Int(i, _) => i.size(),\n+            F32 => Size::from_bits(32),\n+            F64 => Size::from_bits(64),\n+            // FIXME(erikdesjardins): ignoring address space is technically wrong, pointers in\n+            // different address spaces can have different sizes\n+            // (but TargetDataLayout doesn't currently parse that part of the DL string)\n+            Pointer(_) => dl.pointer_size,\n+        }\n+    }\n+\n+    pub fn align<C: HasDataLayout>(self, cx: &C) -> AbiAndPrefAlign {\n+        let dl = cx.data_layout();\n+\n+        match self {\n+            Int(i, _) => i.align(dl),\n+            F32 => dl.f32_align,\n+            F64 => dl.f64_align,\n+            // FIXME(erikdesjardins): ignoring address space is technically wrong, pointers in\n+            // different address spaces can have different alignments\n+            // (but TargetDataLayout doesn't currently parse that part of the DL string)\n+            Pointer(_) => dl.pointer_align,\n+        }\n+    }\n+}\n+\n+/// Inclusive wrap-around range of valid values, that is, if\n+/// start > end, it represents `start..=MAX`,\n+/// followed by `0..=end`.\n+///\n+/// That is, for an i8 primitive, a range of `254..=2` means following\n+/// sequence:\n+///\n+///    254 (-2), 255 (-1), 0, 1, 2\n+///\n+/// This is intended specifically to mirror LLVM\u2019s `!range` metadata semantics.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+pub struct WrappingRange {\n+    pub start: u128,\n+    pub end: u128,\n+}\n+\n+impl WrappingRange {\n+    pub fn full(size: Size) -> Self {\n+        Self { start: 0, end: size.unsigned_int_max() }\n+    }\n+\n+    /// Returns `true` if `v` is contained in the range.\n+    #[inline(always)]\n+    pub fn contains(&self, v: u128) -> bool {\n+        if self.start <= self.end {\n+            self.start <= v && v <= self.end\n+        } else {\n+            self.start <= v || v <= self.end\n+        }\n+    }\n+\n+    /// Returns `self` with replaced `start`\n+    #[inline(always)]\n+    pub fn with_start(mut self, start: u128) -> Self {\n+        self.start = start;\n+        self\n+    }\n+\n+    /// Returns `self` with replaced `end`\n+    #[inline(always)]\n+    pub fn with_end(mut self, end: u128) -> Self {\n+        self.end = end;\n+        self\n+    }\n+\n+    /// Returns `true` if `size` completely fills the range.\n+    #[inline]\n+    pub fn is_full_for(&self, size: Size) -> bool {\n+        let max_value = size.unsigned_int_max();\n+        debug_assert!(self.start <= max_value && self.end <= max_value);\n+        self.start == (self.end.wrapping_add(1) & max_value)\n+    }\n+}\n+\n+impl fmt::Debug for WrappingRange {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.start > self.end {\n+            write!(fmt, \"(..={}) | ({}..)\", self.end, self.start)?;\n+        } else {\n+            write!(fmt, \"{}..={}\", self.start, self.end)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+/// Information about one scalar component of a Rust type.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+pub enum Scalar {\n+    Initialized {\n+        value: Primitive,\n+\n+        // FIXME(eddyb) always use the shortest range, e.g., by finding\n+        // the largest space between two consecutive valid values and\n+        // taking everything else as the (shortest) valid range.\n+        valid_range: WrappingRange,\n+    },\n+    Union {\n+        /// Even for unions, we need to use the correct registers for the kind of\n+        /// values inside the union, so we keep the `Primitive` type around. We\n+        /// also use it to compute the size of the scalar.\n+        /// However, unions never have niches and even allow undef,\n+        /// so there is no `valid_range`.\n+        value: Primitive,\n+    },\n+}\n+\n+impl Scalar {\n+    #[inline]\n+    pub fn is_bool(&self) -> bool {\n+        matches!(\n+            self,\n+            Scalar::Initialized {\n+                value: Int(I8, false),\n+                valid_range: WrappingRange { start: 0, end: 1 }\n+            }\n+        )\n+    }\n+\n+    /// Get the primitive representation of this type, ignoring the valid range and whether the\n+    /// value is allowed to be undefined (due to being a union).\n+    pub fn primitive(&self) -> Primitive {\n+        match *self {\n+            Scalar::Initialized { value, .. } | Scalar::Union { value } => value,\n+        }\n+    }\n+\n+    pub fn align(self, cx: &impl HasDataLayout) -> AbiAndPrefAlign {\n+        self.primitive().align(cx)\n+    }\n+\n+    pub fn size(self, cx: &impl HasDataLayout) -> Size {\n+        self.primitive().size(cx)\n+    }\n+\n+    #[inline]\n+    pub fn to_union(&self) -> Self {\n+        Self::Union { value: self.primitive() }\n+    }\n+\n+    #[inline]\n+    pub fn valid_range(&self, cx: &impl HasDataLayout) -> WrappingRange {\n+        match *self {\n+            Scalar::Initialized { valid_range, .. } => valid_range,\n+            Scalar::Union { value } => WrappingRange::full(value.size(cx)),\n+        }\n+    }\n+\n+    #[inline]\n+    /// Allows the caller to mutate the valid range. This operation will panic if attempted on a union.\n+    pub fn valid_range_mut(&mut self) -> &mut WrappingRange {\n+        match self {\n+            Scalar::Initialized { valid_range, .. } => valid_range,\n+            Scalar::Union { .. } => panic!(\"cannot change the valid range of a union\"),\n+        }\n+    }\n+\n+    /// Returns `true` if all possible numbers are valid, i.e `valid_range` covers the whole layout\n+    #[inline]\n+    pub fn is_always_valid<C: HasDataLayout>(&self, cx: &C) -> bool {\n+        match *self {\n+            Scalar::Initialized { valid_range, .. } => valid_range.is_full_for(self.size(cx)),\n+            Scalar::Union { .. } => true,\n+        }\n+    }\n+\n+    /// Returns `true` if this type can be left uninit.\n+    #[inline]\n+    pub fn is_uninit_valid(&self) -> bool {\n+        match *self {\n+            Scalar::Initialized { .. } => false,\n+            Scalar::Union { .. } => true,\n+        }\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    /// The *source-order* index of a field in a variant.\n+    ///\n+    /// This is how most code after type checking refers to fields, rather than\n+    /// using names (as names have hygiene complications and more complex lookup).\n+    ///\n+    /// Particularly for `repr(Rust)` types, this may not be the same as *layout* order.\n+    /// (It is for `repr(C)` `struct`s, however.)\n+    ///\n+    /// For example, in the following types,\n+    /// ```rust\n+    /// # enum Never {}\n+    /// # #[repr(u16)]\n+    /// enum Demo1 {\n+    ///    Variant0 { a: Never, b: i32 } = 100,\n+    ///    Variant1 { c: u8, d: u64 } = 10,\n+    /// }\n+    /// struct Demo2 { e: u8, f: u16, g: u8 }\n+    /// ```\n+    /// `b` is `FieldIdx(1)` in `VariantIdx(0)`,\n+    /// `d` is `FieldIdx(1)` in `VariantIdx(1)`, and\n+    /// `f` is `FieldIdx(1)` in `VariantIdx(0)`.\n+    #[derive(HashStable_Generic)]\n+    pub struct FieldIdx {}\n+}\n+\n+/// Describes how the fields of a type are located in memory.\n+#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+pub enum FieldsShape {\n+    /// Scalar primitives and `!`, which never have fields.\n+    Primitive,\n+\n+    /// All fields start at no offset. The `usize` is the field count.\n+    Union(NonZeroUsize),\n+\n+    /// Array/vector-like placement, with all fields of identical types.\n+    Array { stride: Size, count: u64 },\n+\n+    /// Struct-like placement, with precomputed offsets.\n+    ///\n+    /// Fields are guaranteed to not overlap, but note that gaps\n+    /// before, between and after all the fields are NOT always\n+    /// padding, and as such their contents may not be discarded.\n+    /// For example, enum variants leave a gap at the start,\n+    /// where the discriminant field in the enum layout goes.\n+    Arbitrary {\n+        /// Offsets for the first byte of each field,\n+        /// ordered to match the source definition order.\n+        /// This vector does not go in increasing order.\n+        // FIXME(eddyb) use small vector optimization for the common case.\n+        offsets: IndexVec<FieldIdx, Size>,\n+\n+        /// Maps source order field indices to memory order indices,\n+        /// depending on how the fields were reordered (if at all).\n+        /// This is a permutation, with both the source order and the\n+        /// memory order using the same (0..n) index ranges.\n+        ///\n+        /// Note that during computation of `memory_index`, sometimes\n+        /// it is easier to operate on the inverse mapping (that is,\n+        /// from memory order to source order), and that is usually\n+        /// named `inverse_memory_index`.\n+        ///\n+        // FIXME(eddyb) build a better abstraction for permutations, if possible.\n+        // FIXME(camlorn) also consider small vector optimization here.\n+        memory_index: IndexVec<FieldIdx, u32>,\n+    },\n+}\n+\n+impl FieldsShape {\n+    #[inline]\n+    pub fn count(&self) -> usize {\n+        match *self {\n+            FieldsShape::Primitive => 0,\n+            FieldsShape::Union(count) => count.get(),\n+            FieldsShape::Array { count, .. } => count.try_into().unwrap(),\n+            FieldsShape::Arbitrary { ref offsets, .. } => offsets.len(),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn offset(&self, i: usize) -> Size {\n+        match *self {\n+            FieldsShape::Primitive => {\n+                unreachable!(\"FieldsShape::offset: `Primitive`s have no fields\")\n+            }\n+            FieldsShape::Union(count) => {\n+                assert!(\n+                    i < count.get(),\n+                    \"tried to access field {} of union with {} fields\",\n+                    i,\n+                    count\n+                );\n+                Size::ZERO\n+            }\n+            FieldsShape::Array { stride, count } => {\n+                let i = u64::try_from(i).unwrap();\n+                assert!(i < count);\n+                stride * i\n+            }\n+            FieldsShape::Arbitrary { ref offsets, .. } => offsets[FieldIdx::from_usize(i)],\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn memory_index(&self, i: usize) -> usize {\n+        match *self {\n+            FieldsShape::Primitive => {\n+                unreachable!(\"FieldsShape::memory_index: `Primitive`s have no fields\")\n+            }\n+            FieldsShape::Union(_) | FieldsShape::Array { .. } => i,\n+            FieldsShape::Arbitrary { ref memory_index, .. } => {\n+                memory_index[FieldIdx::from_usize(i)].try_into().unwrap()\n+            }\n+        }\n+    }\n+\n+    /// Gets source indices of the fields by increasing offsets.\n+    #[inline]\n+    pub fn index_by_increasing_offset(&self) -> impl Iterator<Item = usize> + '_ {\n+        let mut inverse_small = [0u8; 64];\n+        let mut inverse_big = IndexVec::new();\n+        let use_small = self.count() <= inverse_small.len();\n+\n+        // We have to write this logic twice in order to keep the array small.\n+        if let FieldsShape::Arbitrary { ref memory_index, .. } = *self {\n+            if use_small {\n+                for (field_idx, &mem_idx) in memory_index.iter_enumerated() {\n+                    inverse_small[mem_idx as usize] = field_idx.as_u32() as u8;\n+                }\n+            } else {\n+                inverse_big = memory_index.invert_bijective_mapping();\n+            }\n+        }\n+\n+        (0..self.count()).map(move |i| match *self {\n+            FieldsShape::Primitive | FieldsShape::Union(_) | FieldsShape::Array { .. } => i,\n+            FieldsShape::Arbitrary { .. } => {\n+                if use_small {\n+                    inverse_small[i] as usize\n+                } else {\n+                    inverse_big[i as u32].as_usize()\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+/// An identifier that specifies the address space that some operation\n+/// should operate on. Special address spaces have an effect on code generation,\n+/// depending on the target and the address spaces it implements.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+pub struct AddressSpace(pub u32);\n+\n+impl AddressSpace {\n+    /// The default address space, corresponding to data space.\n+    pub const DATA: Self = AddressSpace(0);\n+}\n+\n+/// Describes how values of the type are passed by target ABIs,\n+/// in terms of categories of C types there are ABI rules for.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+\n+pub enum Abi {\n+    Uninhabited,\n+    Scalar(Scalar),\n+    ScalarPair(Scalar, Scalar),\n+    Vector {\n+        element: Scalar,\n+        count: u64,\n+    },\n+    Aggregate {\n+        /// If true, the size is exact, otherwise it's only a lower bound.\n+        sized: bool,\n+    },\n+}\n+\n+impl Abi {\n+    /// Returns `true` if the layout corresponds to an unsized type.\n+    #[inline]\n+    pub fn is_unsized(&self) -> bool {\n+        match *self {\n+            Abi::Uninhabited | Abi::Scalar(_) | Abi::ScalarPair(..) | Abi::Vector { .. } => false,\n+            Abi::Aggregate { sized } => !sized,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn is_sized(&self) -> bool {\n+        !self.is_unsized()\n+    }\n+\n+    /// Returns `true` if this is a single signed integer scalar\n+    #[inline]\n+    pub fn is_signed(&self) -> bool {\n+        match self {\n+            Abi::Scalar(scal) => match scal.primitive() {\n+                Primitive::Int(_, signed) => signed,\n+                _ => false,\n+            },\n+            _ => panic!(\"`is_signed` on non-scalar ABI {:?}\", self),\n+        }\n+    }\n+\n+    /// Returns `true` if this is an uninhabited type\n+    #[inline]\n+    pub fn is_uninhabited(&self) -> bool {\n+        matches!(*self, Abi::Uninhabited)\n+    }\n+\n+    /// Returns `true` is this is a scalar type\n+    #[inline]\n+    pub fn is_scalar(&self) -> bool {\n+        matches!(*self, Abi::Scalar(_))\n+    }\n+\n+    /// Returns the fixed alignment of this ABI, if any is mandated.\n+    pub fn inherent_align<C: HasDataLayout>(&self, cx: &C) -> Option<AbiAndPrefAlign> {\n+        Some(match *self {\n+            Abi::Scalar(s) => s.align(cx),\n+            Abi::ScalarPair(s1, s2) => s1.align(cx).max(s2.align(cx)),\n+            Abi::Vector { element, count } => {\n+                cx.data_layout().vector_align(element.size(cx) * count)\n+            }\n+            Abi::Uninhabited | Abi::Aggregate { .. } => return None,\n+        })\n+    }\n+\n+    /// Returns the fixed size of this ABI, if any is mandated.\n+    pub fn inherent_size<C: HasDataLayout>(&self, cx: &C) -> Option<Size> {\n+        Some(match *self {\n+            Abi::Scalar(s) => {\n+                // No padding in scalars.\n+                s.size(cx)\n+            }\n+            Abi::ScalarPair(s1, s2) => {\n+                // May have some padding between the pair.\n+                let field2_offset = s1.size(cx).align_to(s2.align(cx).abi);\n+                (field2_offset + s2.size(cx)).align_to(self.inherent_align(cx)?.abi)\n+            }\n+            Abi::Vector { element, count } => {\n+                // No padding in vectors, except possibly for trailing padding\n+                // to make the size a multiple of align (e.g. for vectors of size 3).\n+                (element.size(cx) * count).align_to(self.inherent_align(cx)?.abi)\n+            }\n+            Abi::Uninhabited | Abi::Aggregate { .. } => return None,\n+        })\n+    }\n+\n+    /// Discard validity range information and allow undef.\n+    pub fn to_union(&self) -> Self {\n+        assert!(self.is_sized());\n+        match *self {\n+            Abi::Scalar(s) => Abi::Scalar(s.to_union()),\n+            Abi::ScalarPair(s1, s2) => Abi::ScalarPair(s1.to_union(), s2.to_union()),\n+            Abi::Vector { element, count } => Abi::Vector { element: element.to_union(), count },\n+            Abi::Uninhabited | Abi::Aggregate { .. } => Abi::Aggregate { sized: true },\n+        }\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+pub enum Variants {\n+    /// Single enum variants, structs/tuples, unions, and all non-ADTs.\n+    Single { index: VariantIdx },\n+\n+    /// Enum-likes with more than one inhabited variant: each variant comes with\n+    /// a *discriminant* (usually the same as the variant index but the user can\n+    /// assign explicit discriminant values). That discriminant is encoded\n+    /// as a *tag* on the machine. The layout of each variant is\n+    /// a struct, and they all have space reserved for the tag.\n+    /// For enums, the tag is the sole field of the layout.\n+    Multiple {\n+        tag: Scalar,\n+        tag_encoding: TagEncoding,\n+        tag_field: usize,\n+        variants: IndexVec<VariantIdx, LayoutS>,\n+    },\n+}\n+\n+#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+pub enum TagEncoding {\n+    /// The tag directly stores the discriminant, but possibly with a smaller layout\n+    /// (so converting the tag to the discriminant can require sign extension).\n+    Direct,\n+\n+    /// Niche (values invalid for a type) encoding the discriminant:\n+    /// Discriminant and variant index coincide.\n+    /// The variant `untagged_variant` contains a niche at an arbitrary\n+    /// offset (field `tag_field` of the enum), which for a variant with\n+    /// discriminant `d` is set to\n+    /// `(d - niche_variants.start).wrapping_add(niche_start)`.\n+    ///\n+    /// For example, `Option<(usize, &T)>`  is represented such that\n+    /// `None` has a null pointer for the second tuple field, and\n+    /// `Some` is the identity function (with a non-null reference).\n+    Niche {\n+        untagged_variant: VariantIdx,\n+        niche_variants: RangeInclusive<VariantIdx>,\n+        niche_start: u128,\n+    },\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+pub struct Niche {\n+    pub offset: Size,\n+    pub value: Primitive,\n+    pub valid_range: WrappingRange,\n+}\n+\n+impl Niche {\n+    pub fn from_scalar<C: HasDataLayout>(cx: &C, offset: Size, scalar: Scalar) -> Option<Self> {\n+        let Scalar::Initialized { value, valid_range } = scalar else { return None };\n+        let niche = Niche { offset, value, valid_range };\n+        if niche.available(cx) > 0 { Some(niche) } else { None }\n+    }\n+\n+    pub fn available<C: HasDataLayout>(&self, cx: &C) -> u128 {\n+        let Self { value, valid_range: v, .. } = *self;\n+        let size = value.size(cx);\n+        assert!(size.bits() <= 128);\n+        let max_value = size.unsigned_int_max();\n+\n+        // Find out how many values are outside the valid range.\n+        let niche = v.end.wrapping_add(1)..v.start;\n+        niche.end.wrapping_sub(niche.start) & max_value\n+    }\n+\n+    pub fn reserve<C: HasDataLayout>(&self, cx: &C, count: u128) -> Option<(u128, Scalar)> {\n+        assert!(count > 0);\n+\n+        let Self { value, valid_range: v, .. } = *self;\n+        let size = value.size(cx);\n+        assert!(size.bits() <= 128);\n+        let max_value = size.unsigned_int_max();\n+\n+        let niche = v.end.wrapping_add(1)..v.start;\n+        let available = niche.end.wrapping_sub(niche.start) & max_value;\n+        if count > available {\n+            return None;\n+        }\n+\n+        // Extend the range of valid values being reserved by moving either `v.start` or `v.end` bound.\n+        // Given an eventual `Option<T>`, we try to maximize the chance for `None` to occupy the niche of zero.\n+        // This is accomplished by preferring enums with 2 variants(`count==1`) and always taking the shortest path to niche zero.\n+        // Having `None` in niche zero can enable some special optimizations.\n+        //\n+        // Bound selection criteria:\n+        // 1. Select closest to zero given wrapping semantics.\n+        // 2. Avoid moving past zero if possible.\n+        //\n+        // In practice this means that enums with `count > 1` are unlikely to claim niche zero, since they have to fit perfectly.\n+        // If niche zero is already reserved, the selection of bounds are of little interest.\n+        let move_start = |v: WrappingRange| {\n+            let start = v.start.wrapping_sub(count) & max_value;\n+            Some((start, Scalar::Initialized { value, valid_range: v.with_start(start) }))\n+        };\n+        let move_end = |v: WrappingRange| {\n+            let start = v.end.wrapping_add(1) & max_value;\n+            let end = v.end.wrapping_add(count) & max_value;\n+            Some((start, Scalar::Initialized { value, valid_range: v.with_end(end) }))\n+        };\n+        let distance_end_zero = max_value - v.end;\n+        if v.start > v.end {\n+            // zero is unavailable because wrapping occurs\n+            move_end(v)\n+        } else if v.start <= distance_end_zero {\n+            if count <= v.start {\n+                move_start(v)\n+            } else {\n+                // moved past zero, use other bound\n+                move_end(v)\n+            }\n+        } else {\n+            let end = v.end.wrapping_add(count) & max_value;\n+            let overshot_zero = (1..=v.end).contains(&end);\n+            if overshot_zero {\n+                // moved past zero, use other bound\n+                move_start(v)\n+            } else {\n+                move_end(v)\n+            }\n+        }\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    /// The *source-order* index of a variant in a type.\n+    ///\n+    /// For enums, these are always `0..variant_count`, regardless of any\n+    /// custom discriminants that may have been defined, and including any\n+    /// variants that may end up uninhabited due to field types.  (Some of the\n+    /// variants may not be present in a monomorphized ABI [`Variants`], but\n+    /// those skipped variants are always counted when determining the *index*.)\n+    ///\n+    /// `struct`s, `tuples`, and `unions`s are considered to have a single variant\n+    /// with variant index zero, aka [`FIRST_VARIANT`].\n+    #[derive(HashStable_Generic)]\n+    pub struct VariantIdx {\n+        /// Equivalent to `VariantIdx(0)`.\n+        const FIRST_VARIANT = 0;\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Hash, Clone)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+pub struct LayoutS {\n+    /// Says where the fields are located within the layout.\n+    pub fields: FieldsShape,\n+\n+    /// Encodes information about multi-variant layouts.\n+    /// Even with `Multiple` variants, a layout still has its own fields! Those are then\n+    /// shared between all variants. One of them will be the discriminant,\n+    /// but e.g. generators can have more.\n+    ///\n+    /// To access all fields of this layout, both `fields` and the fields of the active variant\n+    /// must be taken into account.\n+    pub variants: Variants,\n+\n+    /// The `abi` defines how this data is passed between functions, and it defines\n+    /// value restrictions via `valid_range`.\n+    ///\n+    /// Note that this is entirely orthogonal to the recursive structure defined by\n+    /// `variants` and `fields`; for example, `ManuallyDrop<Result<isize, isize>>` has\n+    /// `Abi::ScalarPair`! So, even with non-`Aggregate` `abi`, `fields` and `variants`\n+    /// have to be taken into account to find all fields of this layout.\n+    pub abi: Abi,\n+\n+    /// The leaf scalar with the largest number of invalid values\n+    /// (i.e. outside of its `valid_range`), if it exists.\n+    pub largest_niche: Option<Niche>,\n+\n+    pub align: AbiAndPrefAlign,\n+    pub size: Size,\n+}\n+\n+impl LayoutS {\n+    pub fn scalar<C: HasDataLayout>(cx: &C, scalar: Scalar) -> Self {\n+        let largest_niche = Niche::from_scalar(cx, Size::ZERO, scalar);\n+        let size = scalar.size(cx);\n+        let align = scalar.align(cx);\n+        LayoutS {\n+            variants: Variants::Single { index: FIRST_VARIANT },\n+            fields: FieldsShape::Primitive,\n+            abi: Abi::Scalar(scalar),\n+            largest_niche,\n+            size,\n+            align,\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for LayoutS {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // This is how `Layout` used to print before it become\n+        // `Interned<LayoutS>`. We print it like this to avoid having to update\n+        // expected output in a lot of tests.\n+        let LayoutS { size, align, abi, fields, largest_niche, variants } = self;\n+        f.debug_struct(\"Layout\")\n+            .field(\"size\", size)\n+            .field(\"align\", align)\n+            .field(\"abi\", abi)\n+            .field(\"fields\", fields)\n+            .field(\"largest_niche\", largest_niche)\n+            .field(\"variants\", variants)\n+            .finish()\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, HashStable_Generic)]\n+#[rustc_pass_by_value]\n+pub struct Layout<'a>(pub Interned<'a, LayoutS>);\n+\n+impl<'a> fmt::Debug for Layout<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // See comment on `<LayoutS as Debug>::fmt` above.\n+        self.0.0.fmt(f)\n+    }\n+}\n+\n+impl<'a> Layout<'a> {\n+    pub fn fields(self) -> &'a FieldsShape {\n+        &self.0.0.fields\n+    }\n+\n+    pub fn variants(self) -> &'a Variants {\n+        &self.0.0.variants\n+    }\n+\n+    pub fn abi(self) -> Abi {\n+        self.0.0.abi\n+    }\n+\n+    pub fn largest_niche(self) -> Option<Niche> {\n+        self.0.0.largest_niche\n+    }\n+\n+    pub fn align(self) -> AbiAndPrefAlign {\n+        self.0.0.align\n+    }\n+\n+    pub fn size(self) -> Size {\n+        self.0.0.size\n+    }\n+\n+    /// Whether the layout is from a type that implements [`std::marker::PointerLike`].\n+    ///\n+    /// Currently, that means that the type is pointer-sized, pointer-aligned,\n+    /// and has a scalar ABI.\n+    pub fn is_pointer_like(self, data_layout: &TargetDataLayout) -> bool {\n+        self.size() == data_layout.pointer_size\n+            && self.align().abi == data_layout.pointer_align.abi\n+            && matches!(self.abi(), Abi::Scalar(..))\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum PointerKind {\n+    /// Shared reference. `frozen` indicates the absence of any `UnsafeCell`.\n+    SharedRef { frozen: bool },\n+    /// Mutable reference. `unpin` indicates the absence of any pinned data.\n+    MutableRef { unpin: bool },\n+    /// Box. `unpin` indicates the absence of any pinned data.\n+    Box { unpin: bool },\n+}\n+\n+/// Note that this information is advisory only, and backends are free to ignore it.\n+/// It can only be used to encode potential optimizations, but no critical information.\n+#[derive(Copy, Clone, Debug)]\n+pub struct PointeeInfo {\n+    pub size: Size,\n+    pub align: Align,\n+    pub safe: Option<PointerKind>,\n+}\n+\n+impl LayoutS {\n+    /// Returns `true` if the layout corresponds to an unsized type.\n+    pub fn is_unsized(&self) -> bool {\n+        self.abi.is_unsized()\n+    }\n+\n+    pub fn is_sized(&self) -> bool {\n+        self.abi.is_sized()\n+    }\n+\n+    /// Returns `true` if the type is a ZST and not unsized.\n+    pub fn is_zst(&self) -> bool {\n+        match self.abi {\n+            Abi::Scalar(_) | Abi::ScalarPair(..) | Abi::Vector { .. } => false,\n+            Abi::Uninhabited => self.size.bytes() == 0,\n+            Abi::Aggregate { sized } => sized && self.size.bytes() == 0,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum StructKind {\n+    /// A tuple, closure, or univariant which cannot be coerced to unsized.\n+    AlwaysSized,\n+    /// A univariant, the last field of which may be coerced to unsized.\n+    MaybeUnsized,\n+    /// A univariant, but with a prefix of an arbitrary size & alignment (e.g., enum tag).\n+    Prefixed(Size, Align),\n+}"}, {"sha": "2286712f02565974f2623901844c82328e562ff6", "filename": "compiler/rustc_apfloat/src/ieee.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -2,7 +2,6 @@ use crate::{Category, ExpInt, IEK_INF, IEK_NAN, IEK_ZERO};\n use crate::{Float, FloatConvert, ParseError, Round, Status, StatusAnd};\n \n use core::cmp::{self, Ordering};\n-use core::convert::TryFrom;\n use core::fmt::{self, Write};\n use core::marker::PhantomData;\n use core::mem;"}, {"sha": "dde368e7b924fa870e29482e041b0d96bbce4f76", "filename": "compiler/rustc_apfloat/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -33,6 +33,8 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![no_std]\n #![forbid(unsafe_code)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate alloc;"}, {"sha": "65a0f66645befec023eb9de8fd11e6a373033072", "filename": "compiler/rustc_apfloat/src/ppc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_apfloat%2Fsrc%2Fppc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_apfloat%2Fsrc%2Fppc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Fsrc%2Fppc.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -30,7 +30,7 @@ pub type DoubleDouble = DoubleFloat<ieee::Double>;\n // FIXME: Implement all operations in DoubleDouble, and delete these\n // semantics.\n // FIXME(eddyb) This shouldn't need to be `pub`, it's only used in bounds.\n-pub struct FallbackS<F>(F);\n+pub struct FallbackS<F>(#[allow(unused)] F);\n type Fallback<F> = ieee::IeeeFloat<FallbackS<F>>;\n impl<F: Float> ieee::Semantics for FallbackS<F> {\n     // Forbid any conversion to/from bits.\n@@ -45,7 +45,7 @@ impl<F: Float> ieee::Semantics for FallbackS<F> {\n // truncate the mantissa. The result of that second conversion\n // may be inexact, but should never underflow.\n // FIXME(eddyb) This shouldn't need to be `pub`, it's only used in bounds.\n-pub struct FallbackExtendedS<F>(F);\n+pub struct FallbackExtendedS<F>(#[allow(unused)] F);\n type FallbackExtended<F> = ieee::IeeeFloat<FallbackExtendedS<F>>;\n impl<F: Float> ieee::Semantics for FallbackExtendedS<F> {\n     // Forbid any conversion to/from bits."}, {"sha": "6e15f06a76de015dc8c62ac25d5fdf1fd0901654", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 49, "deletions": 18, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -16,17 +16,21 @@\n #![feature(maybe_uninit_slice)]\n #![feature(min_specialization)]\n #![feature(decl_macro)]\n+#![feature(pointer_byte_offsets)]\n #![feature(rustc_attrs)]\n #![cfg_attr(test, feature(test))]\n #![feature(strict_provenance)]\n-#![feature(ptr_const_cast)]\n+#![deny(unsafe_op_in_unsafe_fn)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+#![allow(clippy::mut_from_ref)] // Arena allocators are one of the places where this pattern is fine.\n \n use smallvec::SmallVec;\n \n use std::alloc::Layout;\n use std::cell::{Cell, RefCell};\n use std::cmp;\n-use std::marker::{PhantomData, Send};\n+use std::marker::PhantomData;\n use std::mem::{self, MaybeUninit};\n use std::ptr::{self, NonNull};\n use std::slice;\n@@ -71,19 +75,27 @@ impl<T> ArenaChunk<T> {\n     #[inline]\n     unsafe fn new(capacity: usize) -> ArenaChunk<T> {\n         ArenaChunk {\n-            storage: NonNull::new(Box::into_raw(Box::new_uninit_slice(capacity))).unwrap(),\n+            storage: NonNull::from(Box::leak(Box::new_uninit_slice(capacity))),\n             entries: 0,\n         }\n     }\n \n     /// Destroys this arena chunk.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that `len` elements of this chunk have been initialized.\n     #[inline]\n     unsafe fn destroy(&mut self, len: usize) {\n         // The branch on needs_drop() is an -O1 performance optimization.\n-        // Without the branch, dropping TypedArena<u8> takes linear time.\n+        // Without the branch, dropping TypedArena<T> takes linear time.\n         if mem::needs_drop::<T>() {\n-            let slice = &mut *(self.storage.as_mut());\n-            ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(&mut slice[..len]));\n+            // SAFETY: The caller must ensure that `len` elements of this chunk have\n+            // been initialized.\n+            unsafe {\n+                let slice = self.storage.as_mut();\n+                ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(&mut slice[..len]));\n+            }\n         }\n     }\n \n@@ -101,7 +113,7 @@ impl<T> ArenaChunk<T> {\n                 // A pointer as large as possible for zero-sized elements.\n                 ptr::invalid_mut(!0)\n             } else {\n-                self.start().add((*self.storage.as_ptr()).len())\n+                self.start().add(self.storage.len())\n             }\n         }\n     }\n@@ -210,15 +222,15 @@ impl<T> TypedArena<T> {\n \n         unsafe {\n             if mem::size_of::<T>() == 0 {\n-                self.ptr.set((self.ptr.get() as *mut u8).wrapping_offset(1) as *mut T);\n+                self.ptr.set(self.ptr.get().wrapping_byte_add(1));\n                 let ptr = ptr::NonNull::<T>::dangling().as_ptr();\n                 // Don't drop the object. This `write` is equivalent to `forget`.\n                 ptr::write(ptr, object);\n                 &mut *ptr\n             } else {\n                 let ptr = self.ptr.get();\n                 // Advance the pointer.\n-                self.ptr.set(self.ptr.get().offset(1));\n+                self.ptr.set(self.ptr.get().add(1));\n                 // Write into uninitialized memory.\n                 ptr::write(ptr, object);\n                 &mut *ptr\n@@ -252,7 +264,9 @@ impl<T> TypedArena<T> {\n         self.ensure_capacity(len);\n \n         let start_ptr = self.ptr.get();\n-        self.ptr.set(start_ptr.add(len));\n+        // SAFETY: `self.ensure_capacity` makes sure that there is enough space\n+        // for `len` elements.\n+        unsafe { self.ptr.set(start_ptr.add(len)) };\n         start_ptr\n     }\n \n@@ -285,7 +299,7 @@ impl<T> TypedArena<T> {\n                 // If the previous chunk's len is less than HUGE_PAGE\n                 // bytes, then this chunk will be least double the previous\n                 // chunk's size.\n-                new_cap = (*last_chunk.storage.as_ptr()).len().min(HUGE_PAGE / elem_size / 2);\n+                new_cap = last_chunk.storage.len().min(HUGE_PAGE / elem_size / 2);\n                 new_cap *= 2;\n             } else {\n                 new_cap = PAGE / elem_size;\n@@ -393,7 +407,7 @@ impl DroplessArena {\n                 // If the previous chunk's len is less than HUGE_PAGE\n                 // bytes, then this chunk will be least double the previous\n                 // chunk's size.\n-                new_cap = (*last_chunk.storage.as_ptr()).len().min(HUGE_PAGE / 2);\n+                new_cap = last_chunk.storage.len().min(HUGE_PAGE / 2);\n                 new_cap *= 2;\n             } else {\n                 new_cap = PAGE;\n@@ -480,6 +494,10 @@ impl DroplessArena {\n         }\n     }\n \n+    /// # Safety\n+    ///\n+    /// The caller must ensure that `mem` is valid for writes up to\n+    /// `size_of::<T>() * len`.\n     #[inline]\n     unsafe fn write_from_iter<T, I: Iterator<Item = T>>(\n         &self,\n@@ -491,13 +509,18 @@ impl DroplessArena {\n         // Use a manual loop since LLVM manages to optimize it better for\n         // slice iterators\n         loop {\n-            let value = iter.next();\n-            if i >= len || value.is_none() {\n-                // We only return as many items as the iterator gave us, even\n-                // though it was supposed to give us `len`\n-                return slice::from_raw_parts_mut(mem, i);\n+            // SAFETY: The caller must ensure that `mem` is valid for writes up to\n+            // `size_of::<T>() * len`.\n+            unsafe {\n+                match iter.next() {\n+                    Some(value) if i < len => mem.add(i).write(value),\n+                    Some(_) | None => {\n+                        // We only return as many items as the iterator gave us, even\n+                        // though it was supposed to give us `len`\n+                        return slice::from_raw_parts_mut(mem, i);\n+                    }\n+                }\n             }\n-            ptr::write(mem.add(i), value.unwrap());\n             i += 1;\n         }\n     }\n@@ -566,7 +589,9 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n     }\n \n     pub trait ArenaAllocatable<'tcx, C = rustc_arena::IsNotCopy>: Sized {\n+        #[allow(clippy::mut_from_ref)]\n         fn allocate_on<'a>(self, arena: &'a Arena<'tcx>) -> &'a mut Self;\n+        #[allow(clippy::mut_from_ref)]\n         fn allocate_from_iter<'a>(\n             arena: &'a Arena<'tcx>,\n             iter: impl ::std::iter::IntoIterator<Item = Self>,\n@@ -576,10 +601,12 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n     // Any type that impls `Copy` can be arena-allocated in the `DroplessArena`.\n     impl<'tcx, T: Copy> ArenaAllocatable<'tcx, rustc_arena::IsCopy> for T {\n         #[inline]\n+        #[allow(clippy::mut_from_ref)]\n         fn allocate_on<'a>(self, arena: &'a Arena<'tcx>) -> &'a mut Self {\n             arena.dropless.alloc(self)\n         }\n         #[inline]\n+        #[allow(clippy::mut_from_ref)]\n         fn allocate_from_iter<'a>(\n             arena: &'a Arena<'tcx>,\n             iter: impl ::std::iter::IntoIterator<Item = Self>,\n@@ -599,6 +626,7 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n             }\n \n             #[inline]\n+            #[allow(clippy::mut_from_ref)]\n             fn allocate_from_iter<'a>(\n                 arena: &'a Arena<'tcx>,\n                 iter: impl ::std::iter::IntoIterator<Item = Self>,\n@@ -614,19 +642,22 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n \n     impl<'tcx> Arena<'tcx> {\n         #[inline]\n+        #[allow(clippy::mut_from_ref)]\n         pub fn alloc<T: ArenaAllocatable<'tcx, C>, C>(&self, value: T) -> &mut T {\n             value.allocate_on(self)\n         }\n \n         // Any type that impls `Copy` can have slices be arena-allocated in the `DroplessArena`.\n         #[inline]\n+        #[allow(clippy::mut_from_ref)]\n         pub fn alloc_slice<T: ::std::marker::Copy>(&self, value: &[T]) -> &mut [T] {\n             if value.is_empty() {\n                 return &mut [];\n             }\n             self.dropless.alloc_slice(value)\n         }\n \n+        #[allow(clippy::mut_from_ref)]\n         pub fn alloc_from_iter<'a, T: ArenaAllocatable<'tcx, C>, C>(\n             &'a self,\n             iter: impl ::std::iter::IntoIterator<Item = T>,"}, {"sha": "49a070badc6de5c30c6cbd4b81b0407b970d9621", "filename": "compiler/rustc_arena/src/tests.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_arena%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_arena%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Ftests.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -52,19 +52,15 @@ fn test_arena_alloc_nested() {\n \n     impl<'a> Wrap<'a> {\n         fn alloc_inner<F: Fn() -> Inner>(&self, f: F) -> &Inner {\n-            let r: &EI<'_> = self.0.alloc(EI::I(f()));\n-            if let &EI::I(ref i) = r {\n-                i\n-            } else {\n-                panic!(\"mismatch\");\n+            match self.0.alloc(EI::I(f())) {\n+                EI::I(i) => i,\n+                _ => panic!(\"mismatch\"),\n             }\n         }\n         fn alloc_outer<F: Fn() -> Outer<'a>>(&self, f: F) -> &Outer<'_> {\n-            let r: &EI<'_> = self.0.alloc(EI::O(f()));\n-            if let &EI::O(ref o) = r {\n-                o\n-            } else {\n-                panic!(\"mismatch\");\n+            match self.0.alloc(EI::O(f())) {\n+                EI::O(o) => o,\n+                _ => panic!(\"mismatch\"),\n             }\n         }\n     }"}, {"sha": "f0632ac92e96f3698dc9806a5fa70f46b1f5ae49", "filename": "compiler/rustc_ast/Cargo.toml", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2FCargo.toml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -4,15 +4,16 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [lib]\n-doctest = false\n \n [dependencies]\n-rustc_serialize = { path = \"../rustc_serialize\" }\n-tracing = \"0.1\"\n-rustc_span = { path = \"../rustc_span\" }\n+bitflags = \"1.2.1\"\n+memchr = \"2.5.0\"\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_lexer = { path = \"../rustc_lexer\" }\n rustc_macros = { path = \"../rustc_macros\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }\n+rustc_span = { path = \"../rustc_span\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-bitflags = \"1.2.1\"\n+thin-vec = \"0.2.12\"\n+tracing = \"0.1\""}, {"sha": "4360fbeb9bbc1f828f550f908a80d6fbfd11497e", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 555, "deletions": 405, "changes": 960, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -13,33 +13,30 @@\n //! - [`FnDecl`], [`FnHeader`] and [`Param`]: Metadata associated with a function declaration.\n //! - [`Generics`], [`GenericParam`], [`WhereClause`]: Metadata associated with generic parameters.\n //! - [`EnumDef`] and [`Variant`]: Enum declaration.\n-//! - [`Lit`] and [`LitKind`]: Literal expressions.\n+//! - [`MetaItemLit`] and [`LitKind`]: Literal expressions.\n //! - [`MacroDef`], [`MacStmtStyle`], [`MacCall`], [`MacDelimiter`]: Macro definition and invocation.\n //! - [`Attribute`]: Metadata associated with item.\n //! - [`UnOp`], [`BinOp`], and [`BinOpKind`]: Unary and binary operators.\n \n+pub use crate::format::*;\n pub use crate::util::parser::ExprPrecedence;\n pub use GenericArgs::*;\n pub use UnsafeSource::*;\n \n use crate::ptr::P;\n use crate::token::{self, CommentKind, Delimiter};\n-use crate::tokenstream::{DelimSpan, LazyTokenStream, TokenStream};\n-\n+use crate::tokenstream::{DelimSpan, LazyAttrTokenStream, TokenStream};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::sync::Lrc;\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_macros::HashStable_Generic;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_span::source_map::{respan, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n-\n-use std::cmp::Ordering;\n-use std::convert::TryFrom;\n use std::fmt;\n use std::mem;\n+use thin_vec::{thin_vec, ThinVec};\n \n /// A \"Label\" is an identifier of some point in sources,\n /// e.g. in the following code:\n@@ -64,7 +61,7 @@ impl fmt::Debug for Label {\n \n /// A \"Lifetime\" is an annotation of the scope in which variable\n /// can be used, e.g. `'a` in `&'a i32`.\n-#[derive(Clone, Encodable, Decodable, Copy)]\n+#[derive(Clone, Encodable, Decodable, Copy, PartialEq, Eq)]\n pub struct Lifetime {\n     pub id: NodeId,\n     pub ident: Ident,\n@@ -93,8 +90,8 @@ pub struct Path {\n     pub span: Span,\n     /// The segments in the path: the things separated by `::`.\n     /// Global paths begin with `kw::PathRoot`.\n-    pub segments: Vec<PathSegment>,\n-    pub tokens: Option<LazyTokenStream>,\n+    pub segments: ThinVec<PathSegment>,\n+    pub tokens: Option<LazyAttrTokenStream>,\n }\n \n impl PartialEq<Symbol> for Path {\n@@ -114,15 +111,21 @@ impl<CTX: rustc_span::HashStableContext> HashStable<CTX> for Path {\n }\n \n impl Path {\n-    // Convert a span and an identifier to the corresponding\n-    // one-segment path.\n+    /// Convert a span and an identifier to the corresponding\n+    /// one-segment path.\n     pub fn from_ident(ident: Ident) -> Path {\n-        Path { segments: vec![PathSegment::from_ident(ident)], span: ident.span, tokens: None }\n+        Path { segments: thin_vec![PathSegment::from_ident(ident)], span: ident.span, tokens: None }\n     }\n \n     pub fn is_global(&self) -> bool {\n         !self.segments.is_empty() && self.segments[0].ident.name == kw::PathRoot\n     }\n+\n+    /// If this path is a single identifier with no arguments, does not ensure\n+    /// that the path resolves to a const param, the caller should check this.\n+    pub fn is_potential_trivial_const_arg(&self) -> bool {\n+        self.segments.len() == 1 && self.segments[0].args.is_none()\n+    }\n }\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of types.\n@@ -178,9 +181,9 @@ impl GenericArgs {\n     }\n \n     pub fn span(&self) -> Span {\n-        match *self {\n-            AngleBracketed(ref data) => data.span,\n-            Parenthesized(ref data) => data.span,\n+        match self {\n+            AngleBracketed(data) => data.span,\n+            Parenthesized(data) => data.span,\n         }\n     }\n }\n@@ -212,7 +215,7 @@ pub struct AngleBracketedArgs {\n     /// The overall span.\n     pub span: Span,\n     /// The comma separated parts in the `<...>`.\n-    pub args: Vec<AngleBracketedArg>,\n+    pub args: ThinVec<AngleBracketedArg>,\n }\n \n /// Either an argument for a parameter e.g., `'a`, `Vec<u8>`, `0`,\n@@ -234,15 +237,15 @@ impl AngleBracketedArg {\n     }\n }\n \n-impl Into<Option<P<GenericArgs>>> for AngleBracketedArgs {\n-    fn into(self) -> Option<P<GenericArgs>> {\n-        Some(P(GenericArgs::AngleBracketed(self)))\n+impl Into<P<GenericArgs>> for AngleBracketedArgs {\n+    fn into(self) -> P<GenericArgs> {\n+        P(GenericArgs::AngleBracketed(self))\n     }\n }\n \n-impl Into<Option<P<GenericArgs>>> for ParenthesizedArgs {\n-    fn into(self) -> Option<P<GenericArgs>> {\n-        Some(P(GenericArgs::Parenthesized(self)))\n+impl Into<P<GenericArgs>> for ParenthesizedArgs {\n+    fn into(self) -> P<GenericArgs> {\n+        P(GenericArgs::Parenthesized(self))\n     }\n }\n \n@@ -256,7 +259,7 @@ pub struct ParenthesizedArgs {\n     pub span: Span,\n \n     /// `(A, B)`\n-    pub inputs: Vec<P<Ty>>,\n+    pub inputs: ThinVec<P<Ty>>,\n \n     /// ```text\n     /// Foo(A, B) -> C\n@@ -290,12 +293,20 @@ pub enum TraitBoundModifier {\n     /// No modifiers\n     None,\n \n+    /// `!Trait`\n+    Negative,\n+\n     /// `?Trait`\n     Maybe,\n \n     /// `~const Trait`\n     MaybeConst,\n \n+    /// `~const !Trait`\n+    //\n+    // This parses but will be rejected during AST validation.\n+    MaybeConstNegative,\n+\n     /// `~const ?Trait`\n     //\n     // This parses but will be rejected during AST validation.\n@@ -315,8 +326,8 @@ pub enum GenericBound {\n impl GenericBound {\n     pub fn span(&self) -> Span {\n         match self {\n-            GenericBound::Trait(ref t, ..) => t.span,\n-            GenericBound::Outlives(ref l) => l.ident.span,\n+            GenericBound::Trait(t, ..) => t.span,\n+            GenericBound::Outlives(l) => l.ident.span,\n         }\n     }\n }\n@@ -326,46 +337,17 @@ pub type GenericBounds = Vec<GenericBound>;\n /// Specifies the enforced ordering for generic parameters. In the future,\n /// if we wanted to relax this order, we could override `PartialEq` and\n /// `PartialOrd`, to allow the kinds to be unordered.\n-#[derive(Hash, Clone, Copy)]\n+#[derive(Hash, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub enum ParamKindOrd {\n     Lifetime,\n-    Type,\n-    Const,\n-    // `Infer` is not actually constructed directly from the AST, but is implicitly constructed\n-    // during HIR lowering, and `ParamKindOrd` will implicitly order inferred variables last.\n-    Infer,\n-}\n-\n-impl Ord for ParamKindOrd {\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        use ParamKindOrd::*;\n-        let to_int = |v| match v {\n-            Lifetime => 0,\n-            Infer | Type | Const => 1,\n-        };\n-\n-        to_int(*self).cmp(&to_int(*other))\n-    }\n-}\n-impl PartialOrd for ParamKindOrd {\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-impl PartialEq for ParamKindOrd {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.cmp(other) == Ordering::Equal\n-    }\n+    TypeOrConst,\n }\n-impl Eq for ParamKindOrd {}\n \n impl fmt::Display for ParamKindOrd {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             ParamKindOrd::Lifetime => \"lifetime\".fmt(f),\n-            ParamKindOrd::Type => \"type\".fmt(f),\n-            ParamKindOrd::Const { .. } => \"const\".fmt(f),\n-            ParamKindOrd::Infer => \"infer\".fmt(f),\n+            ParamKindOrd::TypeOrConst => \"type and const\".fmt(f),\n         }\n     }\n }\n@@ -416,23 +398,15 @@ impl GenericParam {\n /// a function, enum, trait, etc.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Generics {\n-    pub params: Vec<GenericParam>,\n+    pub params: ThinVec<GenericParam>,\n     pub where_clause: WhereClause,\n     pub span: Span,\n }\n \n impl Default for Generics {\n     /// Creates an instance of `Generics`.\n     fn default() -> Generics {\n-        Generics {\n-            params: Vec::new(),\n-            where_clause: WhereClause {\n-                has_where_token: false,\n-                predicates: Vec::new(),\n-                span: DUMMY_SP,\n-            },\n-            span: DUMMY_SP,\n-        }\n+        Generics { params: ThinVec::new(), where_clause: Default::default(), span: DUMMY_SP }\n     }\n }\n \n@@ -443,10 +417,16 @@ pub struct WhereClause {\n     /// if we parsed no predicates (e.g. `struct Foo where {}`).\n     /// This allows us to pretty-print accurately.\n     pub has_where_token: bool,\n-    pub predicates: Vec<WherePredicate>,\n+    pub predicates: ThinVec<WherePredicate>,\n     pub span: Span,\n }\n \n+impl Default for WhereClause {\n+    fn default() -> WhereClause {\n+        WhereClause { has_where_token: false, predicates: ThinVec::new(), span: DUMMY_SP }\n+    }\n+}\n+\n /// A single predicate in a where-clause.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum WherePredicate {\n@@ -475,7 +455,7 @@ impl WherePredicate {\n pub struct WhereBoundPredicate {\n     pub span: Span,\n     /// Any generics from a `for` binding.\n-    pub bound_generic_params: Vec<GenericParam>,\n+    pub bound_generic_params: ThinVec<GenericParam>,\n     /// The type being bounded.\n     pub bounded_ty: P<Ty>,\n     /// Trait and lifetime bounds (`Clone + Send + 'static`).\n@@ -497,37 +477,26 @@ pub struct WhereRegionPredicate {\n /// E.g., `T = int`.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct WhereEqPredicate {\n-    pub id: NodeId,\n     pub span: Span,\n     pub lhs_ty: P<Ty>,\n     pub rhs_ty: P<Ty>,\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Crate {\n-    pub attrs: Vec<Attribute>,\n-    pub items: Vec<P<Item>>,\n+    pub attrs: AttrVec,\n+    pub items: ThinVec<P<Item>>,\n     pub spans: ModSpans,\n     /// Must be equal to `CRATE_NODE_ID` after the crate root is expanded, but may hold\n     /// expansion placeholders or an unassigned value (`DUMMY_NODE_ID`) before that.\n     pub id: NodeId,\n     pub is_placeholder: bool,\n }\n \n-/// Possible values inside of compile-time attribute lists.\n-///\n-/// E.g., the '..' in `#[name(..)]`.\n-#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n-pub enum NestedMetaItem {\n-    /// A full MetaItem, for recursive meta items.\n-    MetaItem(MetaItem),\n-    /// A literal.\n-    ///\n-    /// E.g., `\"foo\"`, `64`, `true`.\n-    Literal(Lit),\n-}\n-\n-/// A spanned compile-time attribute item.\n+/// A semantic representation of a meta item. A meta item is a slightly\n+/// restricted form of an attribute -- it can only contain expressions in\n+/// certain leaf positions, rather than arbitrary token streams -- that is used\n+/// for most built-in attributes.\n ///\n /// E.g., `#[test]`, `#[derive(..)]`, `#[rustfmt::skip]` or `#[feature = \"foo\"]`.\n #[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n@@ -537,23 +506,37 @@ pub struct MetaItem {\n     pub span: Span,\n }\n \n-/// A compile-time attribute item.\n-///\n-/// E.g., `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`.\n+/// The meta item kind, containing the data after the initial path.\n #[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum MetaItemKind {\n     /// Word meta item.\n     ///\n-    /// E.g., `test` as in `#[test]`.\n+    /// E.g., `#[test]`, which lacks any arguments after `test`.\n     Word,\n+\n     /// List meta item.\n     ///\n-    /// E.g., `derive(..)` as in `#[derive(..)]`.\n-    List(Vec<NestedMetaItem>),\n+    /// E.g., `#[derive(..)]`, where the field represents the `..`.\n+    List(ThinVec<NestedMetaItem>),\n+\n     /// Name value meta item.\n     ///\n-    /// E.g., `feature = \"foo\"` as in `#[feature = \"foo\"]`.\n-    NameValue(Lit),\n+    /// E.g., `#[feature = \"foo\"]`, where the field represents the `\"foo\"`.\n+    NameValue(MetaItemLit),\n+}\n+\n+/// Values inside meta item lists.\n+///\n+/// E.g., each of `Clone`, `Copy` in `#[derive(Clone, Copy)]`.\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n+pub enum NestedMetaItem {\n+    /// A full MetaItem, for recursive meta items.\n+    MetaItem(MetaItem),\n+\n+    /// A literal.\n+    ///\n+    /// E.g., `\"foo\"`, `64`, `true`.\n+    Lit(MetaItemLit),\n }\n \n /// A block (`{ .. }`).\n@@ -562,12 +545,12 @@ pub enum MetaItemKind {\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Block {\n     /// The statements in the block.\n-    pub stmts: Vec<Stmt>,\n+    pub stmts: ThinVec<Stmt>,\n     pub id: NodeId,\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`.\n     pub rules: BlockCheckMode,\n     pub span: Span,\n-    pub tokens: Option<LazyTokenStream>,\n+    pub tokens: Option<LazyAttrTokenStream>,\n     /// The following *isn't* a parse error, but will cause multiple errors in following stages.\n     /// ```compile_fail\n     /// let x = {\n@@ -586,7 +569,7 @@ pub struct Pat {\n     pub id: NodeId,\n     pub kind: PatKind,\n     pub span: Span,\n-    pub tokens: Option<LazyTokenStream>,\n+    pub tokens: Option<LazyAttrTokenStream>,\n }\n \n impl Pat {\n@@ -597,22 +580,22 @@ impl Pat {\n             // In a type expression `_` is an inference variable.\n             PatKind::Wild => TyKind::Infer,\n             // An IDENT pattern with no binding mode would be valid as path to a type. E.g. `u32`.\n-            PatKind::Ident(BindingMode::ByValue(Mutability::Not), ident, None) => {\n+            PatKind::Ident(BindingAnnotation::NONE, ident, None) => {\n                 TyKind::Path(None, Path::from_ident(*ident))\n             }\n             PatKind::Path(qself, path) => TyKind::Path(qself.clone(), path.clone()),\n             PatKind::MacCall(mac) => TyKind::MacCall(mac.clone()),\n             // `&mut? P` can be reinterpreted as `&mut? T` where `T` is `P` reparsed as a type.\n             PatKind::Ref(pat, mutbl) => {\n-                pat.to_ty().map(|ty| TyKind::Rptr(None, MutTy { ty, mutbl: *mutbl }))?\n+                pat.to_ty().map(|ty| TyKind::Ref(None, MutTy { ty, mutbl: *mutbl }))?\n             }\n             // A slice/array pattern `[P]` can be reparsed as `[T]`, an unsized array,\n             // when `P` can be reparsed as a type `T`.\n             PatKind::Slice(pats) if pats.len() == 1 => pats[0].to_ty().map(TyKind::Slice)?,\n             // A tuple pattern `(P0, .., Pn)` can be reparsed as `(T0, .., Tn)`\n             // assuming `T0` to `Tn` are all syntactically valid as types.\n             PatKind::Tuple(pats) => {\n-                let mut tys = Vec::with_capacity(pats.len());\n+                let mut tys = ThinVec::with_capacity(pats.len());\n                 // FIXME(#48994) - could just be collected into an Option<Vec>\n                 for pat in pats {\n                     tys.push(pat.to_ty()?);\n@@ -684,10 +667,43 @@ pub struct PatField {\n     pub is_placeholder: bool,\n }\n \n-#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n-pub enum BindingMode {\n-    ByRef(Mutability),\n-    ByValue(Mutability),\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n+pub enum ByRef {\n+    Yes,\n+    No,\n+}\n+\n+impl From<bool> for ByRef {\n+    fn from(b: bool) -> ByRef {\n+        match b {\n+            false => ByRef::No,\n+            true => ByRef::Yes,\n+        }\n+    }\n+}\n+\n+/// Explicit binding annotations given in the HIR for a binding. Note\n+/// that this is not the final binding *mode* that we infer after type\n+/// inference.\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n+pub struct BindingAnnotation(pub ByRef, pub Mutability);\n+\n+impl BindingAnnotation {\n+    pub const NONE: Self = Self(ByRef::No, Mutability::Not);\n+    pub const REF: Self = Self(ByRef::Yes, Mutability::Not);\n+    pub const MUT: Self = Self(ByRef::No, Mutability::Mut);\n+    pub const REF_MUT: Self = Self(ByRef::Yes, Mutability::Mut);\n+\n+    pub fn prefix_str(self) -> &'static str {\n+        match self {\n+            Self::NONE => \"\",\n+            Self::REF => \"ref \",\n+            Self::MUT => \"mut \",\n+            Self::REF_MUT => \"ref mut \",\n+        }\n+    }\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n@@ -716,27 +732,27 @@ pub enum PatKind {\n     /// or a unit struct/variant pattern, or a const pattern (in the last two cases the third\n     /// field must be `None`). Disambiguation cannot be done with parser alone, so it happens\n     /// during name resolution.\n-    Ident(BindingMode, Ident, Option<P<Pat>>),\n+    Ident(BindingAnnotation, Ident, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n-    Struct(Option<QSelf>, Path, Vec<PatField>, /* recovered */ bool),\n+    Struct(Option<P<QSelf>>, Path, ThinVec<PatField>, /* recovered */ bool),\n \n     /// A tuple struct/variant pattern (`Variant(x, y, .., z)`).\n-    TupleStruct(Option<QSelf>, Path, Vec<P<Pat>>),\n+    TupleStruct(Option<P<QSelf>>, Path, ThinVec<P<Pat>>),\n \n     /// An or-pattern `A | B | C`.\n     /// Invariant: `pats.len() >= 2`.\n-    Or(Vec<P<Pat>>),\n+    Or(ThinVec<P<Pat>>),\n \n     /// A possibly qualified path pattern.\n     /// Unqualified path patterns `A::B::C` can legally refer to variants, structs, constants\n     /// or associated constants. Qualified path patterns `<A>::B::C`/`<A as Trait>::B::C` can\n     /// only legally refer to associated constants.\n-    Path(Option<QSelf>, Path),\n+    Path(Option<P<QSelf>>, Path),\n \n     /// A tuple pattern (`(a, b)`).\n-    Tuple(Vec<P<Pat>>),\n+    Tuple(ThinVec<P<Pat>>),\n \n     /// A `box` pattern.\n     Box(P<Pat>),\n@@ -751,7 +767,7 @@ pub enum PatKind {\n     Range(Option<P<Expr>>, Option<P<Expr>>, Spanned<RangeEnd>),\n \n     /// A slice pattern `[a, b, c]`.\n-    Slice(Vec<P<Pat>>),\n+    Slice(ThinVec<P<Pat>>),\n \n     /// A rest pattern `..`.\n     ///\n@@ -771,14 +787,15 @@ pub enum PatKind {\n     Paren(P<Pat>),\n \n     /// A macro pattern; pre-expansion.\n-    MacCall(MacCall),\n+    MacCall(P<MacCall>),\n }\n \n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Copy)]\n #[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum Mutability {\n-    Mut,\n+    // N.B. Order is deliberate, so that Not < Mut\n     Not,\n+    Mut,\n }\n \n impl Mutability {\n@@ -789,12 +806,39 @@ impl Mutability {\n         }\n     }\n \n-    pub fn prefix_str(&self) -> &'static str {\n+    /// Returns `\"\"` (empty string) or `\"mut \"` depending on the mutability.\n+    pub fn prefix_str(self) -> &'static str {\n         match self {\n             Mutability::Mut => \"mut \",\n             Mutability::Not => \"\",\n         }\n     }\n+\n+    /// Returns `\"&\"` or `\"&mut \"` depending on the mutability.\n+    pub fn ref_prefix_str(self) -> &'static str {\n+        match self {\n+            Mutability::Not => \"&\",\n+            Mutability::Mut => \"&mut \",\n+        }\n+    }\n+\n+    /// Returns `\"\"` (empty string) or `\"mutably \"` depending on the mutability.\n+    pub fn mutably_str(self) -> &'static str {\n+        match self {\n+            Mutability::Not => \"\",\n+            Mutability::Mut => \"mutably \",\n+        }\n+    }\n+\n+    /// Return `true` if self is mutable\n+    pub fn is_mut(self) -> bool {\n+        matches!(self, Self::Mut)\n+    }\n+\n+    /// Return `true` if self is **not** mutable\n+    pub fn is_not(self) -> bool {\n+        matches!(self, Self::Not)\n+    }\n }\n \n /// The kind of borrow in an `AddrOf` expression,\n@@ -937,8 +981,8 @@ impl Stmt {\n     /// a trailing semicolon.\n     ///\n     /// This only modifies the parsed AST struct, not the attached\n-    /// `LazyTokenStream`. The parser is responsible for calling\n-    /// `CreateTokenStream::add_trailing_semi` when there is actually\n+    /// `LazyAttrTokenStream`. The parser is responsible for calling\n+    /// `ToAttrTokenStream::add_trailing_semi` when there is actually\n     /// a semicolon in the tokenstream.\n     pub fn add_trailing_semicolon(mut self) -> Self {\n         self.kind = match self.kind {\n@@ -981,10 +1025,10 @@ pub enum StmtKind {\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct MacCallStmt {\n-    pub mac: MacCall,\n+    pub mac: P<MacCall>,\n     pub style: MacStmtStyle,\n     pub attrs: AttrVec,\n-    pub tokens: Option<LazyTokenStream>,\n+    pub tokens: Option<LazyAttrTokenStream>,\n }\n \n #[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug)]\n@@ -1009,7 +1053,7 @@ pub struct Local {\n     pub kind: LocalKind,\n     pub span: Span,\n     pub attrs: AttrVec,\n-    pub tokens: Option<LazyTokenStream>,\n+    pub tokens: Option<LazyAttrTokenStream>,\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n@@ -1108,60 +1152,39 @@ pub struct Expr {\n     pub kind: ExprKind,\n     pub span: Span,\n     pub attrs: AttrVec,\n-    pub tokens: Option<LazyTokenStream>,\n+    pub tokens: Option<LazyAttrTokenStream>,\n }\n \n-// `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Expr, 104);\n-\n impl Expr {\n-    /// Returns `true` if this expression would be valid somewhere that expects a value;\n-    /// for example, an `if` condition.\n-    pub fn returns(&self) -> bool {\n-        if let ExprKind::Block(ref block, _) = self.kind {\n-            match block.stmts.last().map(|last_stmt| &last_stmt.kind) {\n-                // Implicit return\n-                Some(StmtKind::Expr(_)) => true,\n-                // Last statement is an explicit return?\n-                Some(StmtKind::Semi(expr)) => matches!(expr.kind, ExprKind::Ret(_)),\n-                // This is a block that doesn't end in either an implicit or explicit return.\n-                _ => false,\n-            }\n-        } else {\n-            // This is not a block, it is a value.\n-            true\n-        }\n-    }\n-\n     /// Is this expr either `N`, or `{ N }`.\n     ///\n     /// If this is not the case, name resolution does not resolve `N` when using\n     /// `min_const_generics` as more complex expressions are not supported.\n-    pub fn is_potential_trivial_const_param(&self) -> bool {\n-        let this = if let ExprKind::Block(ref block, None) = self.kind {\n-            if block.stmts.len() == 1 {\n-                if let StmtKind::Expr(ref expr) = block.stmts[0].kind { expr } else { self }\n-            } else {\n-                self\n-            }\n+    ///\n+    /// Does not ensure that the path resolves to a const param, the caller should check this.\n+    pub fn is_potential_trivial_const_arg(&self) -> bool {\n+        let this = if let ExprKind::Block(block, None) = &self.kind\n+            && block.stmts.len() == 1\n+            && let StmtKind::Expr(expr) = &block.stmts[0].kind\n+        {\n+            expr\n         } else {\n             self\n         };\n \n-        if let ExprKind::Path(None, ref path) = this.kind {\n-            if path.segments.len() == 1 && path.segments[0].args.is_none() {\n-                return true;\n-            }\n+        if let ExprKind::Path(None, path) = &this.kind\n+            && path.is_potential_trivial_const_arg()\n+        {\n+            true\n+        } else {\n+            false\n         }\n-\n-        false\n     }\n \n     pub fn to_bound(&self) -> Option<GenericBound> {\n         match &self.kind {\n             ExprKind::Path(None, path) => Some(GenericBound::Trait(\n-                PolyTraitRef::new(Vec::new(), path.clone(), self.span),\n+                PolyTraitRef::new(ThinVec::new(), path.clone(), self.span),\n                 TraitBoundModifier::None,\n             )),\n             _ => None,\n@@ -1171,7 +1194,16 @@ impl Expr {\n     pub fn peel_parens(&self) -> &Expr {\n         let mut expr = self;\n         while let ExprKind::Paren(inner) = &expr.kind {\n-            expr = &inner;\n+            expr = inner;\n+        }\n+        expr\n+    }\n+\n+    pub fn peel_parens_and_refs(&self) -> &Expr {\n+        let mut expr = self;\n+        while let ExprKind::Paren(inner) | ExprKind::AddrOf(BorrowKind::Ref, _, inner) = &expr.kind\n+        {\n+            expr = inner;\n         }\n         expr\n     }\n@@ -1186,7 +1218,7 @@ impl Expr {\n             ExprKind::Paren(expr) => expr.to_ty().map(TyKind::Paren)?,\n \n             ExprKind::AddrOf(BorrowKind::Ref, mutbl, expr) => {\n-                expr.to_ty().map(|ty| TyKind::Rptr(None, MutTy { ty, mutbl: *mutbl }))?\n+                expr.to_ty().map(|ty| TyKind::Ref(None, MutTy { ty, mutbl: *mutbl }))?\n             }\n \n             ExprKind::Repeat(expr, expr_len) => {\n@@ -1196,7 +1228,7 @@ impl Expr {\n             ExprKind::Array(exprs) if exprs.len() == 1 => exprs[0].to_ty().map(TyKind::Slice)?,\n \n             ExprKind::Tup(exprs) => {\n-                let tys = exprs.iter().map(|expr| expr.to_ty()).collect::<Option<Vec<_>>>()?;\n+                let tys = exprs.iter().map(|expr| expr.to_ty()).collect::<Option<ThinVec<_>>>()?;\n                 TyKind::Tup(tys)\n             }\n \n@@ -1222,15 +1254,14 @@ impl Expr {\n \n     pub fn precedence(&self) -> ExprPrecedence {\n         match self.kind {\n-            ExprKind::Box(_) => ExprPrecedence::Box,\n             ExprKind::Array(_) => ExprPrecedence::Array,\n             ExprKind::ConstBlock(_) => ExprPrecedence::ConstBlock,\n             ExprKind::Call(..) => ExprPrecedence::Call,\n             ExprKind::MethodCall(..) => ExprPrecedence::MethodCall,\n             ExprKind::Tup(_) => ExprPrecedence::Tup,\n             ExprKind::Binary(op, ..) => ExprPrecedence::Binary(op.node),\n             ExprKind::Unary(..) => ExprPrecedence::Unary,\n-            ExprKind::Lit(_) => ExprPrecedence::Lit,\n+            ExprKind::Lit(_) | ExprKind::IncludedBytes(..) => ExprPrecedence::Lit,\n             ExprKind::Type(..) | ExprKind::Cast(..) => ExprPrecedence::Cast,\n             ExprKind::Let(..) => ExprPrecedence::Let,\n             ExprKind::If(..) => ExprPrecedence::If,\n@@ -1255,13 +1286,15 @@ impl Expr {\n             ExprKind::Continue(..) => ExprPrecedence::Continue,\n             ExprKind::Ret(..) => ExprPrecedence::Ret,\n             ExprKind::InlineAsm(..) => ExprPrecedence::InlineAsm,\n+            ExprKind::OffsetOf(..) => ExprPrecedence::OffsetOf,\n             ExprKind::MacCall(..) => ExprPrecedence::Mac,\n             ExprKind::Struct(..) => ExprPrecedence::Struct,\n             ExprKind::Repeat(..) => ExprPrecedence::Repeat,\n             ExprKind::Paren(..) => ExprPrecedence::Paren,\n             ExprKind::Try(..) => ExprPrecedence::Try,\n             ExprKind::Yield(..) => ExprPrecedence::Yield,\n             ExprKind::Yeet(..) => ExprPrecedence::Yeet,\n+            ExprKind::FormatArgs(..) => ExprPrecedence::FormatArgs,\n             ExprKind::Err => ExprPrecedence::Err,\n         }\n     }\n@@ -1273,29 +1306,43 @@ impl Expr {\n                 id: DUMMY_NODE_ID,\n                 kind: ExprKind::Err,\n                 span: DUMMY_SP,\n-                attrs: ThinVec::new(),\n+                attrs: AttrVec::new(),\n                 tokens: None,\n             },\n         )\n     }\n \n-    // To a first-order approximation, is this a pattern\n+    /// To a first-order approximation, is this a pattern?\n     pub fn is_approximately_pattern(&self) -> bool {\n-        match &self.peel_parens().kind {\n-            ExprKind::Box(_)\n-            | ExprKind::Array(_)\n-            | ExprKind::Call(_, _)\n-            | ExprKind::Tup(_)\n-            | ExprKind::Lit(_)\n-            | ExprKind::Range(_, _, _)\n-            | ExprKind::Underscore\n-            | ExprKind::Path(_, _)\n-            | ExprKind::Struct(_) => true,\n-            _ => false,\n-        }\n+        matches!(\n+            &self.peel_parens().kind,\n+            ExprKind::Array(_)\n+                | ExprKind::Call(_, _)\n+                | ExprKind::Tup(_)\n+                | ExprKind::Lit(_)\n+                | ExprKind::Range(_, _, _)\n+                | ExprKind::Underscore\n+                | ExprKind::Path(_, _)\n+                | ExprKind::Struct(_)\n+        )\n     }\n }\n \n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct Closure {\n+    pub binder: ClosureBinder,\n+    pub capture_clause: CaptureBy,\n+    pub constness: Const,\n+    pub asyncness: Async,\n+    pub movability: Movability,\n+    pub fn_decl: P<FnDecl>,\n+    pub body: P<Expr>,\n+    /// The span of the declaration block: 'move |...| -> ...'\n+    pub fn_decl_span: Span,\n+    /// The span of the argument block `|...|`\n+    pub fn_arg_span: Span,\n+}\n+\n /// Limit types of a range (inclusive or exclusive)\n #[derive(Copy, Clone, PartialEq, Encodable, Decodable, Debug)]\n pub enum RangeLimits {\n@@ -1305,6 +1352,20 @@ pub enum RangeLimits {\n     Closed,\n }\n \n+/// A method call (e.g. `x.foo::<Bar, Baz>(a, b, c)`).\n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct MethodCall {\n+    /// The method name and its generic arguments, e.g. `foo::<Bar, Baz>`.\n+    pub seg: PathSegment,\n+    /// The receiver, e.g. `x`.\n+    pub receiver: P<Expr>,\n+    /// The arguments, e.g. `a, b, c`.\n+    pub args: ThinVec<P<Expr>>,\n+    /// The span of the function, without the dot and receiver e.g. `foo::<Bar,\n+    /// Baz>(a, b, c)`.\n+    pub span: Span,\n+}\n+\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum StructRest {\n     /// `..x`.\n@@ -1317,18 +1378,16 @@ pub enum StructRest {\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct StructExpr {\n-    pub qself: Option<QSelf>,\n+    pub qself: Option<P<QSelf>>,\n     pub path: Path,\n-    pub fields: Vec<ExprField>,\n+    pub fields: ThinVec<ExprField>,\n     pub rest: StructRest,\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum ExprKind {\n-    /// A `box x` expression.\n-    Box(P<Expr>),\n     /// An array (`[a, b, c, d]`)\n-    Array(Vec<P<Expr>>),\n+    Array(ThinVec<P<Expr>>),\n     /// Allow anonymous constants from an inline `const` block\n     ConstBlock(AnonConst),\n     /// A function call\n@@ -1337,27 +1396,17 @@ pub enum ExprKind {\n     /// and the second field is the list of arguments.\n     /// This also represents calling the constructor of\n     /// tuple-like ADTs such as tuple structs and enum variants.\n-    Call(P<Expr>, Vec<P<Expr>>),\n-    /// A method call (`x.foo::<'static, Bar, Baz>(a, b, c, d)`)\n-    ///\n-    /// The `PathSegment` represents the method name and its generic arguments\n-    /// (within the angle brackets).\n-    /// The first element of the vector of an `Expr` is the expression that evaluates\n-    /// to the object on which the method is being called on (the receiver),\n-    /// and the remaining elements are the rest of the arguments.\n-    /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n-    /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d])`.\n-    /// This `Span` is the span of the function, without the dot and receiver\n-    /// (e.g. `foo(a, b)` in `x.foo(a, b)`\n-    MethodCall(PathSegment, Vec<P<Expr>>, Span),\n+    Call(P<Expr>, ThinVec<P<Expr>>),\n+    /// A method call (e.g. `x.foo::<Bar, Baz>(a, b, c)`).\n+    MethodCall(Box<MethodCall>),\n     /// A tuple (e.g., `(a, b, c, d)`).\n-    Tup(Vec<P<Expr>>),\n+    Tup(ThinVec<P<Expr>>),\n     /// A binary operation (e.g., `a + b`, `a * b`).\n     Binary(BinOp, P<Expr>, P<Expr>),\n     /// A unary operation (e.g., `!x`, `*x`).\n     Unary(UnOp, P<Expr>),\n     /// A literal (e.g., `1`, `\"foo\"`).\n-    Lit(Lit),\n+    Lit(token::Lit),\n     /// A cast (e.g., `foo as f64`).\n     Cast(P<Expr>, P<Ty>),\n     /// A type ascription (e.g., `42: usize`).\n@@ -1384,26 +1433,20 @@ pub enum ExprKind {\n     /// Conditionless loop (can be exited with `break`, `continue`, or `return`).\n     ///\n     /// `'label: loop { block }`\n-    Loop(P<Block>, Option<Label>),\n+    Loop(P<Block>, Option<Label>, Span),\n     /// A `match` block.\n-    Match(P<Expr>, Vec<Arm>),\n+    Match(P<Expr>, ThinVec<Arm>),\n     /// A closure (e.g., `move |a, b, c| a + b + c`).\n-    ///\n-    /// The final span is the span of the argument block `|...|`.\n-    Closure(ClosureBinder, CaptureBy, Async, Movability, P<FnDecl>, P<Expr>, Span),\n+    Closure(Box<Closure>),\n     /// A block (`'label: { ... }`).\n     Block(P<Block>, Option<Label>),\n     /// An async block (`async move { ... }`).\n     ///\n-    /// The `NodeId` is the `NodeId` for the closure that results from\n-    /// desugaring an async block, just like the NodeId field in the\n-    /// `Async::Yes` variant. This is necessary in order to create a def for the\n-    /// closure which can be used as a parent of any child defs. Defs\n-    /// created during lowering cannot be made the parent of any other\n-    /// preexisting defs.\n-    Async(CaptureBy, NodeId, P<Block>),\n-    /// An await expression (`my_future.await`).\n-    Await(P<Expr>),\n+    /// The async block used to have a `NodeId`, which was removed in favor of\n+    /// using the parent `NodeId` of the parent `Expr`.\n+    Async(CaptureBy, P<Block>),\n+    /// An await expression (`my_future.await`). Span is of await keyword.\n+    Await(P<Expr>, Span),\n \n     /// A try block (`try { ... }`).\n     TryBlock(P<Block>),\n@@ -1428,7 +1471,7 @@ pub enum ExprKind {\n     /// parameters (e.g., `foo::bar::<baz>`).\n     ///\n     /// Optionally \"qualified\" (e.g., `<Vec<T> as SomeTrait>::SomeType`).\n-    Path(Option<QSelf>, Path),\n+    Path(Option<P<QSelf>>, Path),\n \n     /// A referencing operation (`&a`, `&mut a`, `&raw const a` or `&raw mut a`).\n     AddrOf(BorrowKind, Mutability, P<Expr>),\n@@ -1442,8 +1485,11 @@ pub enum ExprKind {\n     /// Output of the `asm!()` macro.\n     InlineAsm(P<InlineAsm>),\n \n+    /// Output of the `offset_of!()` macro.\n+    OffsetOf(P<Ty>, P<[Ident]>),\n+\n     /// A macro invocation; pre-expansion.\n-    MacCall(MacCall),\n+    MacCall(P<MacCall>),\n \n     /// A struct literal expression.\n     ///\n@@ -1469,6 +1515,15 @@ pub enum ExprKind {\n     /// with an optional value to be returned.\n     Yeet(Option<P<Expr>>),\n \n+    /// Bytes included via `include_bytes!`\n+    /// Added for optimization purposes to avoid the need to escape\n+    /// large binary blobs - should always behave like [`ExprKind::Lit`]\n+    /// with a `ByteStr` literal.\n+    IncludedBytes(Lrc<[u8]>),\n+\n+    /// A `format_args!()` expression.\n+    FormatArgs(P<FormatArgs>),\n+\n     /// Placeholder for an expression that wasn't syntactically well formed in some way.\n     Err,\n }\n@@ -1539,7 +1594,7 @@ pub enum ClosureBinder {\n         /// for<'a, 'b> |_: &'a (), _: &'b ()| { ... }\n         ///     ^^^^^^ -- this\n         /// ```\n-        generic_params: P<[GenericParam]>,\n+        generic_params: ThinVec<GenericParam>,\n     },\n }\n \n@@ -1548,55 +1603,47 @@ pub enum ClosureBinder {\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct MacCall {\n     pub path: Path,\n-    pub args: P<MacArgs>,\n-    pub prior_type_ascription: Option<(Span, bool)>,\n+    pub args: P<DelimArgs>,\n }\n \n impl MacCall {\n     pub fn span(&self) -> Span {\n-        self.path.span.to(self.args.span().unwrap_or(self.path.span))\n+        self.path.span.to(self.args.dspan.entire())\n     }\n }\n \n-/// Arguments passed to an attribute or a function-like macro.\n+/// Arguments passed to an attribute macro.\n #[derive(Clone, Encodable, Decodable, Debug)]\n-pub enum MacArgs {\n-    /// No arguments - `#[attr]`.\n+pub enum AttrArgs {\n+    /// No arguments: `#[attr]`.\n     Empty,\n-    /// Delimited arguments - `#[attr()/[]/{}]` or `mac!()/[]/{}`.\n-    Delimited(DelimSpan, MacDelimiter, TokenStream),\n-    /// Arguments of a key-value attribute - `#[attr = \"value\"]`.\n+    /// Delimited arguments: `#[attr()/[]/{}]`.\n+    Delimited(DelimArgs),\n+    /// Arguments of a key-value attribute: `#[attr = \"value\"]`.\n     Eq(\n         /// Span of the `=` token.\n         Span,\n         /// The \"value\".\n-        MacArgsEq,\n+        AttrArgsEq,\n     ),\n }\n \n-// The RHS of a `MacArgs::Eq` starts out as an expression. Once macro expansion\n-// is completed, all cases end up either as a literal, which is the form used\n-// after lowering to HIR, or as an error.\n+// The RHS of an `AttrArgs::Eq` starts out as an expression. Once macro\n+// expansion is completed, all cases end up either as a meta item literal,\n+// which is the form used after lowering to HIR, or as an error.\n #[derive(Clone, Encodable, Decodable, Debug)]\n-pub enum MacArgsEq {\n+pub enum AttrArgsEq {\n     Ast(P<Expr>),\n-    Hir(Lit),\n+    Hir(MetaItemLit),\n }\n \n-impl MacArgs {\n-    pub fn delim(&self) -> Option<Delimiter> {\n-        match self {\n-            MacArgs::Delimited(_, delim, _) => Some(delim.to_token()),\n-            MacArgs::Empty | MacArgs::Eq(..) => None,\n-        }\n-    }\n-\n+impl AttrArgs {\n     pub fn span(&self) -> Option<Span> {\n         match self {\n-            MacArgs::Empty => None,\n-            MacArgs::Delimited(dspan, ..) => Some(dspan.entire()),\n-            MacArgs::Eq(eq_span, MacArgsEq::Ast(expr)) => Some(eq_span.to(expr.span)),\n-            MacArgs::Eq(_, MacArgsEq::Hir(lit)) => {\n+            AttrArgs::Empty => None,\n+            AttrArgs::Delimited(args) => Some(args.dspan.entire()),\n+            AttrArgs::Eq(eq_span, AttrArgsEq::Ast(expr)) => Some(eq_span.to(expr.span)),\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n                 unreachable!(\"in literal form when getting span: {:?}\", lit);\n             }\n         }\n@@ -1606,46 +1653,64 @@ impl MacArgs {\n     /// Proc macros see these tokens, for example.\n     pub fn inner_tokens(&self) -> TokenStream {\n         match self {\n-            MacArgs::Empty => TokenStream::default(),\n-            MacArgs::Delimited(.., tokens) => tokens.clone(),\n-            MacArgs::Eq(_, MacArgsEq::Ast(expr)) => TokenStream::from_ast(expr),\n-            MacArgs::Eq(_, MacArgsEq::Hir(lit)) => {\n+            AttrArgs::Empty => TokenStream::default(),\n+            AttrArgs::Delimited(args) => args.tokens.clone(),\n+            AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => TokenStream::from_ast(expr),\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n                 unreachable!(\"in literal form when getting inner tokens: {:?}\", lit)\n             }\n         }\n     }\n-\n-    /// Whether a macro with these arguments needs a semicolon\n-    /// when used as a standalone item or statement.\n-    pub fn need_semicolon(&self) -> bool {\n-        !matches!(self, MacArgs::Delimited(_, MacDelimiter::Brace, _))\n-    }\n }\n \n-impl<CTX> HashStable<CTX> for MacArgs\n+impl<CTX> HashStable<CTX> for AttrArgs\n where\n     CTX: crate::HashStableContext,\n {\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(ctx, hasher);\n         match self {\n-            MacArgs::Empty => {}\n-            MacArgs::Delimited(dspan, delim, tokens) => {\n-                dspan.hash_stable(ctx, hasher);\n-                delim.hash_stable(ctx, hasher);\n-                tokens.hash_stable(ctx, hasher);\n-            }\n-            MacArgs::Eq(_eq_span, MacArgsEq::Ast(expr)) => {\n+            AttrArgs::Empty => {}\n+            AttrArgs::Delimited(args) => args.hash_stable(ctx, hasher),\n+            AttrArgs::Eq(_eq_span, AttrArgsEq::Ast(expr)) => {\n                 unreachable!(\"hash_stable {:?}\", expr);\n             }\n-            MacArgs::Eq(eq_span, MacArgsEq::Hir(lit)) => {\n+            AttrArgs::Eq(eq_span, AttrArgsEq::Hir(lit)) => {\n                 eq_span.hash_stable(ctx, hasher);\n                 lit.hash_stable(ctx, hasher);\n             }\n         }\n     }\n }\n \n+/// Delimited arguments, as used in `#[attr()/[]/{}]` or `mac!()/[]/{}`.\n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct DelimArgs {\n+    pub dspan: DelimSpan,\n+    pub delim: MacDelimiter,\n+    pub tokens: TokenStream,\n+}\n+\n+impl DelimArgs {\n+    /// Whether a macro with these arguments needs a semicolon\n+    /// when used as a standalone item or statement.\n+    pub fn need_semicolon(&self) -> bool {\n+        !matches!(self, DelimArgs { delim: MacDelimiter::Brace, .. })\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for DelimArgs\n+where\n+    CTX: crate::HashStableContext,\n+{\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        let DelimArgs { dspan, delim, tokens } = self;\n+        dspan.hash_stable(ctx, hasher);\n+        delim.hash_stable(ctx, hasher);\n+        tokens.hash_stable(ctx, hasher);\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum MacDelimiter {\n     Parenthesis,\n@@ -1675,7 +1740,7 @@ impl MacDelimiter {\n /// Represents a macro definition.\n #[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct MacroDef {\n-    pub body: P<MacArgs>,\n+    pub body: P<DelimArgs>,\n     /// `true` if macro was defined with `macro_rules`.\n     pub macro_rules: bool,\n }\n@@ -1691,42 +1756,39 @@ pub enum StrStyle {\n     Raw(u8),\n }\n \n-/// An AST literal.\n+/// A literal in a meta item.\n #[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n-pub struct Lit {\n-    /// The original literal token as written in source code.\n-    pub token: token::Lit,\n+pub struct MetaItemLit {\n+    /// The original literal as written in the source code.\n+    pub symbol: Symbol,\n+    /// The original suffix as written in the source code.\n+    pub suffix: Option<Symbol>,\n     /// The \"semantic\" representation of the literal lowered from the original tokens.\n     /// Strings are unescaped, hexadecimal forms are eliminated, etc.\n-    /// FIXME: Remove this and only create the semantic representation during lowering to HIR.\n     pub kind: LitKind,\n     pub span: Span,\n }\n \n-/// Same as `Lit`, but restricted to string literals.\n+/// Similar to `MetaItemLit`, but restricted to string literals.\n #[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub struct StrLit {\n-    /// The original literal token as written in source code.\n-    pub style: StrStyle,\n+    /// The original literal as written in source code.\n     pub symbol: Symbol,\n+    /// The original suffix as written in source code.\n     pub suffix: Option<Symbol>,\n-    pub span: Span,\n-    /// The unescaped \"semantic\" representation of the literal lowered from the original token.\n-    /// FIXME: Remove this and only create the semantic representation during lowering to HIR.\n+    /// The semantic (unescaped) representation of the literal.\n     pub symbol_unescaped: Symbol,\n+    pub style: StrStyle,\n+    pub span: Span,\n }\n \n impl StrLit {\n-    pub fn as_lit(&self) -> Lit {\n+    pub fn as_token_lit(&self) -> token::Lit {\n         let token_kind = match self.style {\n             StrStyle::Cooked => token::Str,\n             StrStyle::Raw(n) => token::StrRaw(n),\n         };\n-        Lit {\n-            token: token::Lit::new(token_kind, self.symbol, self.suffix),\n-            span: self.span,\n-            kind: LitKind::Str(self.symbol_unescaped, self.style),\n-        }\n+        token::Lit::new(token_kind, self.symbol, self.suffix)\n     }\n }\n \n@@ -1752,38 +1814,54 @@ pub enum LitFloatType {\n     Unsuffixed,\n }\n \n-/// Literal kind.\n+/// This type is used within both `ast::MetaItemLit` and `hir::Lit`.\n ///\n-/// E.g., `\"foo\"`, `42`, `12.34`, or `bool`.\n+/// Note that the entire literal (including the suffix) is considered when\n+/// deciding the `LitKind`. This means that float literals like `1f32` are\n+/// classified by this type as `Float`. This is different to `token::LitKind`\n+/// which does *not* consider the suffix.\n #[derive(Clone, Encodable, Decodable, Debug, Hash, Eq, PartialEq, HashStable_Generic)]\n pub enum LitKind {\n-    /// A string literal (`\"foo\"`).\n+    /// A string literal (`\"foo\"`). The symbol is unescaped, and so may differ\n+    /// from the original token's symbol.\n     Str(Symbol, StrStyle),\n-    /// A byte string (`b\"foo\"`).\n-    ByteStr(Lrc<[u8]>),\n+    /// A byte string (`b\"foo\"`). Not stored as a symbol because it might be\n+    /// non-utf8, and symbols only allow utf8 strings.\n+    ByteStr(Lrc<[u8]>, StrStyle),\n+    /// A C String (`c\"foo\"`). Guaranteed to only have `\\0` at the end.\n+    CStr(Lrc<[u8]>, StrStyle),\n     /// A byte char (`b'f'`).\n     Byte(u8),\n     /// A character literal (`'a'`).\n     Char(char),\n     /// An integer literal (`1`).\n     Int(u128, LitIntType),\n-    /// A float literal (`1f64` or `1E10f64`).\n+    /// A float literal (`1.0`, `1f64` or `1E10f64`). The pre-suffix part is\n+    /// stored as a symbol rather than `f64` so that `LitKind` can impl `Eq`\n+    /// and `Hash`.\n     Float(Symbol, LitFloatType),\n-    /// A boolean literal.\n+    /// A boolean literal (`true`, `false`).\n     Bool(bool),\n     /// Placeholder for a literal that wasn't well-formed in some way.\n-    Err(Symbol),\n+    Err,\n }\n \n impl LitKind {\n+    pub fn str(&self) -> Option<Symbol> {\n+        match *self {\n+            LitKind::Str(s, _) => Some(s),\n+            _ => None,\n+        }\n+    }\n+\n     /// Returns `true` if this literal is a string.\n     pub fn is_str(&self) -> bool {\n         matches!(self, LitKind::Str(..))\n     }\n \n     /// Returns `true` if this literal is byte literal string.\n     pub fn is_bytestr(&self) -> bool {\n-        matches!(self, LitKind::ByteStr(_))\n+        matches!(self, LitKind::ByteStr(..))\n     }\n \n     /// Returns `true` if this is a numeric literal.\n@@ -1806,12 +1884,13 @@ impl LitKind {\n             // unsuffixed variants\n             LitKind::Str(..)\n             | LitKind::ByteStr(..)\n+            | LitKind::CStr(..)\n             | LitKind::Byte(..)\n             | LitKind::Char(..)\n             | LitKind::Int(_, LitIntType::Unsuffixed)\n             | LitKind::Float(_, LitFloatType::Unsuffixed)\n             | LitKind::Bool(..)\n-            | LitKind::Err(..) => false,\n+            | LitKind::Err => false,\n         }\n     }\n }\n@@ -1970,7 +2049,7 @@ pub struct Ty {\n     pub id: NodeId,\n     pub kind: TyKind,\n     pub span: Span,\n-    pub tokens: Option<LazyTokenStream>,\n+    pub tokens: Option<LazyAttrTokenStream>,\n }\n \n impl Clone for Ty {\n@@ -1987,8 +2066,9 @@ impl Clone for Ty {\n impl Ty {\n     pub fn peel_refs(&self) -> &Self {\n         let mut final_ty = self;\n-        while let TyKind::Rptr(_, MutTy { ty, .. }) = &final_ty.kind {\n-            final_ty = &ty;\n+        while let TyKind::Ref(_, MutTy { ty, .. }) | TyKind::Ptr(MutTy { ty, .. }) = &final_ty.kind\n+        {\n+            final_ty = ty;\n         }\n         final_ty\n     }\n@@ -1998,7 +2078,7 @@ impl Ty {\n pub struct BareFnTy {\n     pub unsafety: Unsafe,\n     pub ext: Extern,\n-    pub generic_params: Vec<GenericParam>,\n+    pub generic_params: ThinVec<GenericParam>,\n     pub decl: P<FnDecl>,\n     /// Span of the `fn(...) -> ...` part.\n     pub decl_span: Span,\n@@ -2014,18 +2094,18 @@ pub enum TyKind {\n     /// A raw pointer (`*const T` or `*mut T`).\n     Ptr(MutTy),\n     /// A reference (`&'a T` or `&'a mut T`).\n-    Rptr(Option<Lifetime>, MutTy),\n+    Ref(Option<Lifetime>, MutTy),\n     /// A bare function (e.g., `fn(usize) -> bool`).\n     BareFn(P<BareFnTy>),\n     /// The never type (`!`).\n     Never,\n     /// A tuple (`(A, B, C, D,...)`).\n-    Tup(Vec<P<Ty>>),\n+    Tup(ThinVec<P<Ty>>),\n     /// A path (`module::module::...::Type`), optionally\n     /// \"qualified\", e.g., `<Vec<T> as SomeTrait>::SomeType`.\n     ///\n     /// Type parameters are stored in the `Path` itself.\n-    Path(Option<QSelf>, Path),\n+    Path(Option<P<QSelf>>, Path),\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n     TraitObject(GenericBounds, TraitObjectSyntax),\n@@ -2046,7 +2126,7 @@ pub enum TyKind {\n     /// Inferred type of a `self` or `&self` argument in a method.\n     ImplicitSelf,\n     /// A macro in the type position.\n-    MacCall(MacCall),\n+    MacCall(P<MacCall>),\n     /// Placeholder for a kind that has failed to be defined.\n     Err,\n     /// Placeholder for a `va_list`.\n@@ -2063,8 +2143,11 @@ impl TyKind {\n     }\n \n     pub fn is_simple_path(&self) -> Option<Symbol> {\n-        if let TyKind::Path(None, Path { segments, .. }) = &self && segments.len() == 1 {\n-            Some(segments[0].ident.name)\n+        if let TyKind::Path(None, Path { segments, .. }) = &self\n+            && let [segment] = &segments[..]\n+            && segment.args.is_none()\n+        {\n+            Some(segment.ident.name)\n         } else {\n             None\n         }\n@@ -2075,6 +2158,7 @@ impl TyKind {\n #[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum TraitObjectSyntax {\n     Dyn,\n+    DynStar,\n     None,\n }\n \n@@ -2090,15 +2174,15 @@ pub enum InlineAsmRegOrRegClass {\n bitflags::bitflags! {\n     #[derive(Encodable, Decodable, HashStable_Generic)]\n     pub struct InlineAsmOptions: u16 {\n-        const PURE = 1 << 0;\n-        const NOMEM = 1 << 1;\n-        const READONLY = 1 << 2;\n+        const PURE            = 1 << 0;\n+        const NOMEM           = 1 << 1;\n+        const READONLY        = 1 << 2;\n         const PRESERVES_FLAGS = 1 << 3;\n-        const NORETURN = 1 << 4;\n-        const NOSTACK = 1 << 5;\n-        const ATT_SYNTAX = 1 << 6;\n-        const RAW = 1 << 7;\n-        const MAY_UNWIND = 1 << 8;\n+        const NORETURN        = 1 << 4;\n+        const NOSTACK         = 1 << 5;\n+        const ATT_SYNTAX      = 1 << 6;\n+        const RAW             = 1 << 7;\n+        const MAY_UNWIND      = 1 << 8;\n     }\n }\n \n@@ -2122,10 +2206,10 @@ impl fmt::Display for InlineAsmTemplatePiece {\n                 Ok(())\n             }\n             Self::Placeholder { operand_idx, modifier: Some(modifier), .. } => {\n-                write!(f, \"{{{}:{}}}\", operand_idx, modifier)\n+                write!(f, \"{{{operand_idx}:{modifier}}}\")\n             }\n             Self::Placeholder { operand_idx, modifier: None, .. } => {\n-                write!(f, \"{{{}}}\", operand_idx)\n+                write!(f, \"{{{operand_idx}}}\")\n             }\n         }\n     }\n@@ -2137,7 +2221,7 @@ impl InlineAsmTemplatePiece {\n         use fmt::Write;\n         let mut out = String::new();\n         for p in s.iter() {\n-            let _ = write!(out, \"{}\", p);\n+            let _ = write!(out, \"{p}\");\n         }\n         out\n     }\n@@ -2153,7 +2237,7 @@ impl InlineAsmTemplatePiece {\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct InlineAsmSym {\n     pub id: NodeId,\n-    pub qself: Option<QSelf>,\n+    pub qself: Option<P<QSelf>>,\n     pub path: Path,\n }\n \n@@ -2234,11 +2318,11 @@ pub type ExplicitSelf = Spanned<SelfKind>;\n impl Param {\n     /// Attempts to cast parameter to `ExplicitSelf`.\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n-        if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.kind {\n+        if let PatKind::Ident(BindingAnnotation(ByRef::No, mutbl), ident, _) = self.pat.kind {\n             if ident.name == kw::SelfLower {\n                 return match self.ty.kind {\n                     TyKind::ImplicitSelf => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n-                    TyKind::Rptr(lt, MutTy { ref ty, mutbl }) if ty.kind.is_implicit_self() => {\n+                    TyKind::Ref(lt, MutTy { ref ty, mutbl }) if ty.kind.is_implicit_self() => {\n                         Some(respan(self.pat.span, SelfKind::Region(lt, mutbl)))\n                     }\n                     _ => Some(respan(\n@@ -2264,31 +2348,31 @@ impl Param {\n     pub fn from_self(attrs: AttrVec, eself: ExplicitSelf, eself_ident: Ident) -> Param {\n         let span = eself.span.to(eself_ident.span);\n         let infer_ty = P(Ty { id: DUMMY_NODE_ID, kind: TyKind::ImplicitSelf, span, tokens: None });\n-        let param = |mutbl, ty| Param {\n+        let (mutbl, ty) = match eself.node {\n+            SelfKind::Explicit(ty, mutbl) => (mutbl, ty),\n+            SelfKind::Value(mutbl) => (mutbl, infer_ty),\n+            SelfKind::Region(lt, mutbl) => (\n+                Mutability::Not,\n+                P(Ty {\n+                    id: DUMMY_NODE_ID,\n+                    kind: TyKind::Ref(lt, MutTy { ty: infer_ty, mutbl }),\n+                    span,\n+                    tokens: None,\n+                }),\n+            ),\n+        };\n+        Param {\n             attrs,\n             pat: P(Pat {\n                 id: DUMMY_NODE_ID,\n-                kind: PatKind::Ident(BindingMode::ByValue(mutbl), eself_ident, None),\n+                kind: PatKind::Ident(BindingAnnotation(ByRef::No, mutbl), eself_ident, None),\n                 span,\n                 tokens: None,\n             }),\n             span,\n             ty,\n             id: DUMMY_NODE_ID,\n             is_placeholder: false,\n-        };\n-        match eself.node {\n-            SelfKind::Explicit(ty, mutbl) => param(mutbl, ty),\n-            SelfKind::Value(mutbl) => param(mutbl, infer_ty),\n-            SelfKind::Region(lt, mutbl) => param(\n-                Mutability::Not,\n-                P(Ty {\n-                    id: DUMMY_NODE_ID,\n-                    kind: TyKind::Rptr(lt, MutTy { ty: infer_ty, mutbl }),\n-                    span,\n-                    tokens: None,\n-                }),\n-            ),\n         }\n     }\n }\n@@ -2301,16 +2385,16 @@ impl Param {\n /// which contains metadata about function safety, asyncness, constness and ABI.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FnDecl {\n-    pub inputs: Vec<Param>,\n+    pub inputs: ThinVec<Param>,\n     pub output: FnRetTy,\n }\n \n impl FnDecl {\n     pub fn has_self(&self) -> bool {\n-        self.inputs.get(0).map_or(false, Param::is_self)\n+        self.inputs.get(0).is_some_and(Param::is_self)\n     }\n     pub fn c_variadic(&self) -> bool {\n-        self.inputs.last().map_or(false, |arg| matches!(arg.ty.kind, TyKind::CVarArgs))\n+        self.inputs.last().is_some_and(|arg| matches!(arg.ty.kind, TyKind::CVarArgs))\n     }\n }\n \n@@ -2340,9 +2424,9 @@ impl Async {\n     }\n \n     /// In this case this is an `async` return, the `NodeId` for the generated `impl Trait` item.\n-    pub fn opt_return_id(self) -> Option<NodeId> {\n+    pub fn opt_return_id(self) -> Option<(NodeId, Span)> {\n         match self {\n-            Async::Yes { return_impl_trait_id, .. } => Some(return_impl_trait_id),\n+            Async::Yes { return_impl_trait_id, span, .. } => Some((return_impl_trait_id, span)),\n             Async::No => None,\n         }\n     }\n@@ -2380,6 +2464,16 @@ impl fmt::Debug for ImplPolarity {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Encodable, Decodable, HashStable_Generic)]\n+pub enum BoundPolarity {\n+    /// `Type: Trait`\n+    Positive,\n+    /// `Type: !Trait`\n+    Negative(Span),\n+    /// `Type: ?Trait`\n+    Maybe(Span),\n+}\n+\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum FnRetTy {\n     /// Returns type is not specified.\n@@ -2393,9 +2487,9 @@ pub enum FnRetTy {\n \n impl FnRetTy {\n     pub fn span(&self) -> Span {\n-        match *self {\n-            FnRetTy::Default(span) => span,\n-            FnRetTy::Ty(ref ty) => ty.span,\n+        match self {\n+            &FnRetTy::Default(span) => span,\n+            FnRetTy::Ty(ty) => ty.span,\n         }\n     }\n }\n@@ -2413,25 +2507,19 @@ pub enum ModKind {\n     /// or with definition outlined to a separate file `mod foo;` and already loaded from it.\n     /// The inner span is from the first token past `{` to the last token until `}`,\n     /// or from the first to the last token in the loaded file.\n-    Loaded(Vec<P<Item>>, Inline, ModSpans),\n+    Loaded(ThinVec<P<Item>>, Inline, ModSpans),\n     /// Module with definition outlined to a separate file `mod foo;` but not yet loaded from it.\n     Unloaded,\n }\n \n-#[derive(Copy, Clone, Encodable, Decodable, Debug)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, Default)]\n pub struct ModSpans {\n     /// `inner_span` covers the body of the module; for a file module, its the whole file.\n     /// For an inline module, its the span inside the `{ ... }`, not including the curly braces.\n     pub inner_span: Span,\n     pub inject_use_span: Span,\n }\n \n-impl Default for ModSpans {\n-    fn default() -> ModSpans {\n-        ModSpans { inner_span: Default::default(), inject_use_span: Default::default() }\n-    }\n-}\n-\n /// Foreign module declaration.\n ///\n /// E.g., `extern { .. }` or `extern \"C\" { .. }`.\n@@ -2441,12 +2529,12 @@ pub struct ForeignMod {\n     /// semantically by Rust.\n     pub unsafety: Unsafe,\n     pub abi: Option<StrLit>,\n-    pub items: Vec<P<ForeignItem>>,\n+    pub items: ThinVec<P<ForeignItem>>,\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct EnumDef {\n-    pub variants: Vec<Variant>,\n+    pub variants: ThinVec<Variant>,\n }\n /// Enum variant.\n #[derive(Clone, Encodable, Decodable, Debug)]\n@@ -2474,12 +2562,9 @@ pub struct Variant {\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum UseTreeKind {\n     /// `use prefix` or `use prefix as rename`\n-    ///\n-    /// The extra `NodeId`s are for HIR lowering, when additional statements are created for each\n-    /// namespace.\n-    Simple(Option<Ident>, NodeId, NodeId),\n+    Simple(Option<Ident>),\n     /// `use prefix::{...}`\n-    Nested(Vec<(UseTree, NodeId)>),\n+    Nested(ThinVec<(UseTree, NodeId)>),\n     /// `use prefix::*`\n     Glob,\n }\n@@ -2496,8 +2581,8 @@ pub struct UseTree {\n impl UseTree {\n     pub fn ident(&self) -> Ident {\n         match self.kind {\n-            UseTreeKind::Simple(Some(rename), ..) => rename,\n-            UseTreeKind::Simple(None, ..) => {\n+            UseTreeKind::Simple(Some(rename)) => rename,\n+            UseTreeKind::Simple(None) => {\n                 self.prefix.segments.last().expect(\"empty prefix in a simple import\").ident\n             }\n             _ => panic!(\"`UseTree::ident` can only be used on a simple import\"),\n@@ -2515,33 +2600,25 @@ pub enum AttrStyle {\n }\n \n rustc_index::newtype_index! {\n-    pub struct AttrId {\n-        ENCODABLE = custom\n-        DEBUG_FORMAT = \"AttrId({})\"\n-    }\n+    #[custom_encodable]\n+    #[debug_format = \"AttrId({})\"]\n+    pub struct AttrId {}\n }\n \n impl<S: Encoder> Encodable<S> for AttrId {\n     fn encode(&self, _s: &mut S) {}\n }\n \n impl<D: Decoder> Decodable<D> for AttrId {\n-    fn decode(_: &mut D) -> AttrId {\n-        crate::attr::mk_attr_id()\n+    default fn decode(_: &mut D) -> AttrId {\n+        panic!(\"cannot decode `AttrId` with `{}`\", std::any::type_name::<D>());\n     }\n }\n \n-#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n-pub struct AttrItem {\n-    pub path: Path,\n-    pub args: MacArgs,\n-    pub tokens: Option<LazyTokenStream>,\n-}\n-\n /// A list of attributes.\n pub type AttrVec = ThinVec<Attribute>;\n \n-/// Metadata associated with an item.\n+/// A syntax-level representation of an attribute.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Attribute {\n     pub kind: AttrKind,\n@@ -2555,14 +2632,27 @@ pub struct Attribute {\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum AttrKind {\n     /// A normal attribute.\n-    Normal(AttrItem, Option<LazyTokenStream>),\n+    Normal(P<NormalAttr>),\n \n     /// A doc comment (e.g. `/// ...`, `//! ...`, `/** ... */`, `/*! ... */`).\n     /// Doc attributes (e.g. `#[doc=\"...\"]`) are represented with the `Normal`\n     /// variant (which is much less compact and thus more expensive).\n     DocComment(CommentKind, Symbol),\n }\n \n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct NormalAttr {\n+    pub item: AttrItem,\n+    pub tokens: Option<LazyAttrTokenStream>,\n+}\n+\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n+pub struct AttrItem {\n+    pub path: Path,\n+    pub args: AttrArgs,\n+    pub tokens: Option<LazyAttrTokenStream>,\n+}\n+\n /// `TraitRef`s appear in impls.\n ///\n /// Resolution maps each `TraitRef`'s `ref_id` to its defining trait; that's all\n@@ -2578,7 +2668,7 @@ pub struct TraitRef {\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct PolyTraitRef {\n     /// The `'a` in `for<'a> Foo<&'a T>`.\n-    pub bound_generic_params: Vec<GenericParam>,\n+    pub bound_generic_params: ThinVec<GenericParam>,\n \n     /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`.\n     pub trait_ref: TraitRef,\n@@ -2587,7 +2677,7 @@ pub struct PolyTraitRef {\n }\n \n impl PolyTraitRef {\n-    pub fn new(generic_params: Vec<GenericParam>, path: Path, span: Span) -> Self {\n+    pub fn new(generic_params: ThinVec<GenericParam>, path: Path, span: Span) -> Self {\n         PolyTraitRef {\n             bound_generic_params: generic_params,\n             trait_ref: TraitRef { path, ref_id: DUMMY_NODE_ID },\n@@ -2600,13 +2690,13 @@ impl PolyTraitRef {\n pub struct Visibility {\n     pub kind: VisibilityKind,\n     pub span: Span,\n-    pub tokens: Option<LazyTokenStream>,\n+    pub tokens: Option<LazyAttrTokenStream>,\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum VisibilityKind {\n     Public,\n-    Restricted { path: P<Path>, id: NodeId },\n+    Restricted { path: P<Path>, id: NodeId, shorthand: bool },\n     Inherited,\n }\n \n@@ -2637,11 +2727,11 @@ pub enum VariantData {\n     /// Struct variant.\n     ///\n     /// E.g., `Bar { .. }` as in `enum Foo { Bar { .. } }`.\n-    Struct(Vec<FieldDef>, bool),\n+    Struct(ThinVec<FieldDef>, bool),\n     /// Tuple variant.\n     ///\n     /// E.g., `Bar(..)` as in `enum Foo { Bar(..) }`.\n-    Tuple(Vec<FieldDef>, NodeId),\n+    Tuple(ThinVec<FieldDef>, NodeId),\n     /// Unit variant.\n     ///\n     /// E.g., `Bar = ..` as in `enum Foo { Bar = .. }`.\n@@ -2651,14 +2741,14 @@ pub enum VariantData {\n impl VariantData {\n     /// Return the fields of this variant.\n     pub fn fields(&self) -> &[FieldDef] {\n-        match *self {\n-            VariantData::Struct(ref fields, ..) | VariantData::Tuple(ref fields, _) => fields,\n+        match self {\n+            VariantData::Struct(fields, ..) | VariantData::Tuple(fields, _) => fields,\n             _ => &[],\n         }\n     }\n \n     /// Return the `NodeId` of this variant's constructor, if it has one.\n-    pub fn ctor_id(&self) -> Option<NodeId> {\n+    pub fn ctor_node_id(&self) -> Option<NodeId> {\n         match *self {\n             VariantData::Struct(..) => None,\n             VariantData::Tuple(_, id) | VariantData::Unit(id) => Some(id),\n@@ -2669,7 +2759,7 @@ impl VariantData {\n /// An item definition.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Item<K = ItemKind> {\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: AttrVec,\n     pub id: NodeId,\n     pub span: Span,\n     pub vis: Visibility,\n@@ -2686,7 +2776,7 @@ pub struct Item<K = ItemKind> {\n     ///\n     /// Note that the tokens here do not include the outer attributes, but will\n     /// include inner attributes.\n-    pub tokens: Option<LazyTokenStream>,\n+    pub tokens: Option<LazyAttrTokenStream>,\n }\n \n impl Item {\n@@ -2699,8 +2789,19 @@ impl Item {\n /// `extern` qualifier on a function item or function type.\n #[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub enum Extern {\n+    /// No explicit extern keyword was used\n+    ///\n+    /// E.g. `fn foo() {}`\n     None,\n+    /// An explicit extern keyword was used, but with implicit ABI\n+    ///\n+    /// E.g. `extern fn foo() {}`\n+    ///\n+    /// This is just `extern \"C\"` (see `rustc_target::spec::abi::Abi::FALLBACK`)\n     Implicit(Span),\n+    /// An explicit extern keyword was used with an explicit ABI\n+    ///\n+    /// E.g. `extern \"C\" fn foo() {}`\n     Explicit(StrLit, Span),\n }\n \n@@ -2719,9 +2820,13 @@ impl Extern {\n /// included in this struct (e.g., `async unsafe fn` or `const extern \"C\" fn`).\n #[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub struct FnHeader {\n+    /// The `unsafe` keyword, if any\n     pub unsafety: Unsafe,\n+    /// The `async` keyword, if any\n     pub asyncness: Async,\n+    /// The `const` keyword, if any\n     pub constness: Const,\n+    /// The `extern` keyword and corresponding ABI string, if any\n     pub ext: Extern,\n }\n \n@@ -2753,7 +2858,7 @@ pub struct Trait {\n     pub is_auto: IsAuto,\n     pub generics: Generics,\n     pub bounds: GenericBounds,\n-    pub items: Vec<P<AssocItem>>,\n+    pub items: ThinVec<P<AssocItem>>,\n }\n \n /// The location of a where clause on a `TyAlias` (`Span`) and whether there was\n@@ -2801,7 +2906,7 @@ pub struct Impl {\n     /// The trait being implemented, if any.\n     pub of_trait: Option<TraitRef>,\n     pub self_ty: P<Ty>,\n-    pub items: Vec<P<AssocItem>>,\n+    pub items: ThinVec<P<AssocItem>>,\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n@@ -2812,6 +2917,20 @@ pub struct Fn {\n     pub body: Option<P<Block>>,\n }\n \n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct StaticItem {\n+    pub ty: P<Ty>,\n+    pub mutability: Mutability,\n+    pub expr: Option<P<Expr>>,\n+}\n+\n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct ConstItem {\n+    pub defaultness: Defaultness,\n+    pub ty: P<Ty>,\n+    pub expr: Option<P<Expr>>,\n+}\n+\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum ItemKind {\n     /// An `extern crate` item, with the optional *original* crate name if the crate was renamed.\n@@ -2825,11 +2944,11 @@ pub enum ItemKind {\n     /// A static item (`static`).\n     ///\n     /// E.g., `static FOO: i32 = 42;` or `static FOO: &'static str = \"bar\";`.\n-    Static(P<Ty>, Mutability, Option<P<Expr>>),\n+    Static(Box<StaticItem>),\n     /// A constant item (`const`).\n     ///\n     /// E.g., `const FOO: i32 = 42;`.\n-    Const(Defaultness, P<Ty>, Option<P<Expr>>),\n+    Const(Box<ConstItem>),\n     /// A function declaration (`fn`).\n     ///\n     /// E.g., `fn foo(bar: usize) -> usize { .. }`.\n@@ -2877,17 +2996,14 @@ pub enum ItemKind {\n     /// A macro invocation.\n     ///\n     /// E.g., `foo!(..)`.\n-    MacCall(MacCall),\n+    MacCall(P<MacCall>),\n \n     /// A macro definition.\n     MacroDef(MacroDef),\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(ItemKind, 112);\n-\n impl ItemKind {\n-    pub fn article(&self) -> &str {\n+    pub fn article(&self) -> &'static str {\n         use ItemKind::*;\n         match self {\n             Use(..) | Static(..) | Const(..) | Fn(..) | Mod(..) | GlobalAsm(..) | TyAlias(..)\n@@ -2896,7 +3012,7 @@ impl ItemKind {\n         }\n     }\n \n-    pub fn descr(&self) -> &str {\n+    pub fn descr(&self) -> &'static str {\n         match self {\n             ItemKind::ExternCrate(..) => \"extern crate\",\n             ItemKind::Use(..) => \"`use` import\",\n@@ -2948,24 +3064,21 @@ pub type AssocItem = Item<AssocItemKind>;\n pub enum AssocItemKind {\n     /// An associated constant, `const $ident: $ty $def?;` where `def ::= \"=\" $expr? ;`.\n     /// If `def` is parsed, then the constant is provided, and otherwise required.\n-    Const(Defaultness, P<Ty>, Option<P<Expr>>),\n+    Const(Box<ConstItem>),\n     /// An associated function.\n     Fn(Box<Fn>),\n     /// An associated type.\n-    TyAlias(Box<TyAlias>),\n+    Type(Box<TyAlias>),\n     /// A macro expanding to associated items.\n-    MacCall(MacCall),\n+    MacCall(P<MacCall>),\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(AssocItemKind, 72);\n-\n impl AssocItemKind {\n     pub fn defaultness(&self) -> Defaultness {\n         match *self {\n-            Self::Const(defaultness, ..)\n+            Self::Const(box ConstItem { defaultness, .. })\n             | Self::Fn(box Fn { defaultness, .. })\n-            | Self::TyAlias(box TyAlias { defaultness, .. }) => defaultness,\n+            | Self::Type(box TyAlias { defaultness, .. }) => defaultness,\n             Self::MacCall(..) => Defaultness::Final,\n         }\n     }\n@@ -2974,9 +3087,9 @@ impl AssocItemKind {\n impl From<AssocItemKind> for ItemKind {\n     fn from(assoc_item_kind: AssocItemKind) -> ItemKind {\n         match assoc_item_kind {\n-            AssocItemKind::Const(a, b, c) => ItemKind::Const(a, b, c),\n+            AssocItemKind::Const(item) => ItemKind::Const(item),\n             AssocItemKind::Fn(fn_kind) => ItemKind::Fn(fn_kind),\n-            AssocItemKind::TyAlias(ty_alias_kind) => ItemKind::TyAlias(ty_alias_kind),\n+            AssocItemKind::Type(ty_alias_kind) => ItemKind::TyAlias(ty_alias_kind),\n             AssocItemKind::MacCall(a) => ItemKind::MacCall(a),\n         }\n     }\n@@ -2987,9 +3100,9 @@ impl TryFrom<ItemKind> for AssocItemKind {\n \n     fn try_from(item_kind: ItemKind) -> Result<AssocItemKind, ItemKind> {\n         Ok(match item_kind {\n-            ItemKind::Const(a, b, c) => AssocItemKind::Const(a, b, c),\n+            ItemKind::Const(item) => AssocItemKind::Const(item),\n             ItemKind::Fn(fn_kind) => AssocItemKind::Fn(fn_kind),\n-            ItemKind::TyAlias(ty_alias_kind) => AssocItemKind::TyAlias(ty_alias_kind),\n+            ItemKind::TyAlias(ty_kind) => AssocItemKind::Type(ty_kind),\n             ItemKind::MacCall(a) => AssocItemKind::MacCall(a),\n             _ => return Err(item_kind),\n         })\n@@ -3006,16 +3119,15 @@ pub enum ForeignItemKind {\n     /// An foreign type.\n     TyAlias(Box<TyAlias>),\n     /// A macro expanding to foreign items.\n-    MacCall(MacCall),\n+    MacCall(P<MacCall>),\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(ForeignItemKind, 72);\n-\n impl From<ForeignItemKind> for ItemKind {\n     fn from(foreign_item_kind: ForeignItemKind) -> ItemKind {\n         match foreign_item_kind {\n-            ForeignItemKind::Static(a, b, c) => ItemKind::Static(a, b, c),\n+            ForeignItemKind::Static(a, b, c) => {\n+                ItemKind::Static(StaticItem { ty: a, mutability: b, expr: c }.into())\n+            }\n             ForeignItemKind::Fn(fn_kind) => ItemKind::Fn(fn_kind),\n             ForeignItemKind::TyAlias(ty_alias_kind) => ItemKind::TyAlias(ty_alias_kind),\n             ForeignItemKind::MacCall(a) => ItemKind::MacCall(a),\n@@ -3028,7 +3140,9 @@ impl TryFrom<ItemKind> for ForeignItemKind {\n \n     fn try_from(item_kind: ItemKind) -> Result<ForeignItemKind, ItemKind> {\n         Ok(match item_kind {\n-            ItemKind::Static(a, b, c) => ForeignItemKind::Static(a, b, c),\n+            ItemKind::Static(box StaticItem { ty: a, mutability: b, expr: c }) => {\n+                ForeignItemKind::Static(a, b, c)\n+            }\n             ItemKind::Fn(fn_kind) => ForeignItemKind::Fn(fn_kind),\n             ItemKind::TyAlias(ty_alias_kind) => ForeignItemKind::TyAlias(ty_alias_kind),\n             ItemKind::MacCall(a) => ForeignItemKind::MacCall(a),\n@@ -3038,3 +3152,39 @@ impl TryFrom<ItemKind> for ForeignItemKind {\n }\n \n pub type ForeignItem = Item<ForeignItemKind>;\n+\n+// Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+mod size_asserts {\n+    use super::*;\n+    use rustc_data_structures::static_assert_size;\n+    // tidy-alphabetical-start\n+    static_assert_size!(AssocItem, 88);\n+    static_assert_size!(AssocItemKind, 16);\n+    static_assert_size!(Attribute, 32);\n+    static_assert_size!(Block, 32);\n+    static_assert_size!(Expr, 72);\n+    static_assert_size!(ExprKind, 40);\n+    static_assert_size!(Fn, 152);\n+    static_assert_size!(ForeignItem, 96);\n+    static_assert_size!(ForeignItemKind, 24);\n+    static_assert_size!(GenericArg, 24);\n+    static_assert_size!(GenericBound, 56);\n+    static_assert_size!(Generics, 40);\n+    static_assert_size!(Impl, 136);\n+    static_assert_size!(Item, 136);\n+    static_assert_size!(ItemKind, 64);\n+    static_assert_size!(LitKind, 24);\n+    static_assert_size!(Local, 72);\n+    static_assert_size!(MetaItemLit, 40);\n+    static_assert_size!(Param, 40);\n+    static_assert_size!(Pat, 72);\n+    static_assert_size!(Path, 24);\n+    static_assert_size!(PathSegment, 24);\n+    static_assert_size!(PatKind, 48);\n+    static_assert_size!(Stmt, 32);\n+    static_assert_size!(StmtKind, 16);\n+    static_assert_size!(Ty, 64);\n+    static_assert_size!(TyKind, 40);\n+    // tidy-alphabetical-end\n+}"}, {"sha": "4dc9c30a2c807a2050c8fb72638cb2b3e4a4d2a8", "filename": "compiler/rustc_ast/src/ast_traits.rs", "status": "modified", "additions": 34, "deletions": 60, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Fast_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Fast_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast_traits.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -4,7 +4,7 @@\n \n use crate::ptr::P;\n use crate::token::Nonterminal;\n-use crate::tokenstream::LazyTokenStream;\n+use crate::tokenstream::LazyAttrTokenStream;\n use crate::{Arm, Crate, ExprField, FieldDef, GenericParam, Param, PatField, Variant};\n use crate::{AssocItem, Expr, ForeignItem, Item, NodeId};\n use crate::{AttrItem, AttrKind, Block, Pat, Path, Ty, Visibility};\n@@ -124,18 +124,18 @@ impl HasSpan for AttrItem {\n \n /// A trait for AST nodes having (or not having) collected tokens.\n pub trait HasTokens {\n-    fn tokens(&self) -> Option<&LazyTokenStream>;\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>>;\n+    fn tokens(&self) -> Option<&LazyAttrTokenStream>;\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyAttrTokenStream>>;\n }\n \n macro_rules! impl_has_tokens {\n     ($($T:ty),+ $(,)?) => {\n         $(\n             impl HasTokens for $T {\n-                fn tokens(&self) -> Option<&LazyTokenStream> {\n+                fn tokens(&self) -> Option<&LazyAttrTokenStream> {\n                     self.tokens.as_ref()\n                 }\n-                fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+                fn tokens_mut(&mut self) -> Option<&mut Option<LazyAttrTokenStream>> {\n                     Some(&mut self.tokens)\n                 }\n             }\n@@ -147,10 +147,10 @@ macro_rules! impl_has_tokens_none {\n     ($($T:ty),+ $(,)?) => {\n         $(\n             impl HasTokens for $T {\n-                fn tokens(&self) -> Option<&LazyTokenStream> {\n+                fn tokens(&self) -> Option<&LazyAttrTokenStream> {\n                     None\n                 }\n-                fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+                fn tokens_mut(&mut self) -> Option<&mut Option<LazyAttrTokenStream>> {\n                     None\n                 }\n             }\n@@ -162,25 +162,25 @@ impl_has_tokens!(AssocItem, AttrItem, Block, Expr, ForeignItem, Item, Pat, Path,\n impl_has_tokens_none!(Arm, ExprField, FieldDef, GenericParam, Param, PatField, Variant);\n \n impl<T: AstDeref<Target: HasTokens>> HasTokens for T {\n-    fn tokens(&self) -> Option<&LazyTokenStream> {\n+    fn tokens(&self) -> Option<&LazyAttrTokenStream> {\n         self.ast_deref().tokens()\n     }\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyAttrTokenStream>> {\n         self.ast_deref_mut().tokens_mut()\n     }\n }\n \n impl<T: HasTokens> HasTokens for Option<T> {\n-    fn tokens(&self) -> Option<&LazyTokenStream> {\n+    fn tokens(&self) -> Option<&LazyAttrTokenStream> {\n         self.as_ref().and_then(|inner| inner.tokens())\n     }\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyAttrTokenStream>> {\n         self.as_mut().and_then(|inner| inner.tokens_mut())\n     }\n }\n \n impl HasTokens for StmtKind {\n-    fn tokens(&self) -> Option<&LazyTokenStream> {\n+    fn tokens(&self) -> Option<&LazyAttrTokenStream> {\n         match self {\n             StmtKind::Local(local) => local.tokens.as_ref(),\n             StmtKind::Item(item) => item.tokens(),\n@@ -189,7 +189,7 @@ impl HasTokens for StmtKind {\n             StmtKind::MacCall(mac) => mac.tokens.as_ref(),\n         }\n     }\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyAttrTokenStream>> {\n         match self {\n             StmtKind::Local(local) => Some(&mut local.tokens),\n             StmtKind::Item(item) => item.tokens_mut(),\n@@ -201,35 +201,35 @@ impl HasTokens for StmtKind {\n }\n \n impl HasTokens for Stmt {\n-    fn tokens(&self) -> Option<&LazyTokenStream> {\n+    fn tokens(&self) -> Option<&LazyAttrTokenStream> {\n         self.kind.tokens()\n     }\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyAttrTokenStream>> {\n         self.kind.tokens_mut()\n     }\n }\n \n impl HasTokens for Attribute {\n-    fn tokens(&self) -> Option<&LazyTokenStream> {\n+    fn tokens(&self) -> Option<&LazyAttrTokenStream> {\n         match &self.kind {\n-            AttrKind::Normal(_, tokens) => tokens.as_ref(),\n+            AttrKind::Normal(normal) => normal.tokens.as_ref(),\n             kind @ AttrKind::DocComment(..) => {\n-                panic!(\"Called tokens on doc comment attr {:?}\", kind)\n+                panic!(\"Called tokens on doc comment attr {kind:?}\")\n             }\n         }\n     }\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyAttrTokenStream>> {\n         Some(match &mut self.kind {\n-            AttrKind::Normal(_, tokens) => tokens,\n+            AttrKind::Normal(normal) => &mut normal.tokens,\n             kind @ AttrKind::DocComment(..) => {\n-                panic!(\"Called tokens_mut on doc comment attr {:?}\", kind)\n+                panic!(\"Called tokens_mut on doc comment attr {kind:?}\")\n             }\n         })\n     }\n }\n \n impl HasTokens for Nonterminal {\n-    fn tokens(&self) -> Option<&LazyTokenStream> {\n+    fn tokens(&self) -> Option<&LazyAttrTokenStream> {\n         match self {\n             Nonterminal::NtItem(item) => item.tokens(),\n             Nonterminal::NtStmt(stmt) => stmt.tokens(),\n@@ -243,7 +243,7 @@ impl HasTokens for Nonterminal {\n             Nonterminal::NtIdent(..) | Nonterminal::NtLifetime(..) => None,\n         }\n     }\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyAttrTokenStream>> {\n         match self {\n             Nonterminal::NtItem(item) => item.tokens_mut(),\n             Nonterminal::NtStmt(stmt) => stmt.tokens_mut(),\n@@ -270,7 +270,7 @@ pub trait HasAttrs {\n     /// during token collection.\n     const SUPPORTS_CUSTOM_INNER_ATTRS: bool;\n     fn attrs(&self) -> &[Attribute];\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut AttrVec));\n }\n \n macro_rules! impl_has_attrs {\n@@ -279,12 +279,13 @@ macro_rules! impl_has_attrs {\n             impl HasAttrs for $T {\n                 const SUPPORTS_CUSTOM_INNER_ATTRS: bool = $inner;\n \n+                #[inline]\n                 fn attrs(&self) -> &[Attribute] {\n                     &self.attrs\n                 }\n \n-                fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-                    VecOrAttrVec::visit(&mut self.attrs, f)\n+                fn visit_attrs(&mut self, f: impl FnOnce(&mut AttrVec)) {\n+                    f(&mut self.attrs)\n                 }\n             }\n         )+\n@@ -299,7 +300,7 @@ macro_rules! impl_has_attrs_none {\n                 fn attrs(&self) -> &[Attribute] {\n                     &[]\n                 }\n-                fn visit_attrs(&mut self, _f: impl FnOnce(&mut Vec<Attribute>)) {}\n+                fn visit_attrs(&mut self, _f: impl FnOnce(&mut AttrVec)) {}\n             }\n         )+\n     };\n@@ -330,7 +331,7 @@ impl<T: AstDeref<Target: HasAttrs>> HasAttrs for T {\n     fn attrs(&self) -> &[Attribute] {\n         self.ast_deref().attrs()\n     }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut AttrVec)) {\n         self.ast_deref_mut().visit_attrs(f)\n     }\n }\n@@ -340,7 +341,7 @@ impl<T: HasAttrs> HasAttrs for Option<T> {\n     fn attrs(&self) -> &[Attribute] {\n         self.as_ref().map(|inner| inner.attrs()).unwrap_or(&[])\n     }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut AttrVec)) {\n         if let Some(inner) = self.as_mut() {\n             inner.visit_attrs(f);\n         }\n@@ -362,13 +363,13 @@ impl HasAttrs for StmtKind {\n         }\n     }\n \n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut AttrVec)) {\n         match self {\n-            StmtKind::Local(local) => visit_attrvec(&mut local.attrs, f),\n+            StmtKind::Local(local) => f(&mut local.attrs),\n             StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr.visit_attrs(f),\n             StmtKind::Item(item) => item.visit_attrs(f),\n             StmtKind::Empty => {}\n-            StmtKind::MacCall(mac) => visit_attrvec(&mut mac.attrs, f),\n+            StmtKind::MacCall(mac) => f(&mut mac.attrs),\n         }\n     }\n }\n@@ -378,38 +379,11 @@ impl HasAttrs for Stmt {\n     fn attrs(&self) -> &[Attribute] {\n         self.kind.attrs()\n     }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut AttrVec)) {\n         self.kind.visit_attrs(f);\n     }\n }\n \n-/// Helper trait for the impls above. Abstracts over\n-/// the two types of attribute fields that AST nodes\n-/// may have (`Vec<Attribute>` or `AttrVec`).\n-trait VecOrAttrVec {\n-    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n-}\n-\n-impl VecOrAttrVec for Vec<Attribute> {\n-    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        f(self)\n-    }\n-}\n-\n-impl VecOrAttrVec for AttrVec {\n-    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        visit_attrvec(self, f)\n-    }\n-}\n-\n-fn visit_attrvec(attrs: &mut AttrVec, f: impl FnOnce(&mut Vec<Attribute>)) {\n-    crate::mut_visit::visit_clobber(attrs, |attrs| {\n-        let mut vec = attrs.into();\n-        f(&mut vec);\n-        vec.into()\n-    });\n-}\n-\n /// A newtype around an AST node that implements the traits above if the node implements them.\n pub struct AstNodeWrapper<Wrapped, Tag> {\n     pub wrapped: Wrapped,"}, {"sha": "15fe29580c29ce9acb1da1bd0209ff86651e6539", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 392, "deletions": 399, "changes": 791, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -1,31 +1,28 @@\n //! Functions dealing with attributes and meta items.\n \n-use crate::ast;\n-use crate::ast::{AttrId, AttrItem, AttrKind, AttrStyle, Attribute};\n-use crate::ast::{Lit, LitKind};\n-use crate::ast::{MacArgs, MacArgsEq, MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n-use crate::ast::{Path, PathSegment};\n+use crate::ast::{AttrArgs, AttrArgsEq, AttrId, AttrItem, AttrKind, AttrStyle, AttrVec, Attribute};\n+use crate::ast::{DelimArgs, Expr, ExprKind, LitKind, MetaItemLit};\n+use crate::ast::{MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem, NormalAttr};\n+use crate::ast::{Path, PathSegment, DUMMY_NODE_ID};\n use crate::ptr::P;\n use crate::token::{self, CommentKind, Delimiter, Token};\n-use crate::tokenstream::{AttrAnnotatedTokenStream, AttrAnnotatedTokenTree};\n-use crate::tokenstream::{DelimSpan, Spacing, TokenTree, TreeAndSpacing};\n-use crate::tokenstream::{LazyTokenStream, TokenStream};\n+use crate::tokenstream::{DelimSpan, Spacing, TokenTree};\n+use crate::tokenstream::{LazyAttrTokenStream, TokenStream};\n use crate::util::comments;\n-\n-use rustc_data_structures::thin_vec::ThinVec;\n+use crate::util::literal::escape_string_symbol;\n use rustc_index::bit_set::GrowableBitSet;\n-use rustc_span::source_map::BytePos;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n-\n use std::iter;\n+use std::sync::atomic::{AtomicU32, Ordering};\n+use thin_vec::{thin_vec, ThinVec};\n \n pub struct MarkedAttrs(GrowableBitSet<AttrId>);\n \n impl MarkedAttrs {\n-    // We have no idea how many attributes there will be, so just\n-    // initiate the vectors with 0 bits. We'll grow them as necessary.\n     pub fn new() -> Self {\n+        // We have no idea how many attributes there will be, so just\n+        // initiate the vectors with 0 bits. We'll grow them as necessary.\n         MarkedAttrs(GrowableBitSet::new_empty())\n     }\n \n@@ -38,93 +35,51 @@ impl MarkedAttrs {\n     }\n }\n \n-impl NestedMetaItem {\n-    /// Returns the `MetaItem` if `self` is a `NestedMetaItem::MetaItem`.\n-    pub fn meta_item(&self) -> Option<&MetaItem> {\n-        match *self {\n-            NestedMetaItem::MetaItem(ref item) => Some(item),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Returns the `Lit` if `self` is a `NestedMetaItem::Literal`s.\n-    pub fn literal(&self) -> Option<&Lit> {\n-        match *self {\n-            NestedMetaItem::Literal(ref lit) => Some(lit),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Returns `true` if this list item is a MetaItem with a name of `name`.\n-    pub fn has_name(&self, name: Symbol) -> bool {\n-        self.meta_item().map_or(false, |meta_item| meta_item.has_name(name))\n-    }\n-\n-    /// For a single-segment meta item, returns its name; otherwise, returns `None`.\n-    pub fn ident(&self) -> Option<Ident> {\n-        self.meta_item().and_then(|meta_item| meta_item.ident())\n-    }\n-    pub fn name_or_empty(&self) -> Symbol {\n-        self.ident().unwrap_or_else(Ident::empty).name\n-    }\n-\n-    /// Gets the string value if `self` is a `MetaItem` and the `MetaItem` is a\n-    /// `MetaItemKind::NameValue` variant containing a string, otherwise `None`.\n-    pub fn value_str(&self) -> Option<Symbol> {\n-        self.meta_item().and_then(|meta_item| meta_item.value_str())\n-    }\n+pub struct AttrIdGenerator(AtomicU32);\n \n-    /// Returns a name and single literal value tuple of the `MetaItem`.\n-    pub fn name_value_literal(&self) -> Option<(Symbol, &Lit)> {\n-        self.meta_item().and_then(|meta_item| {\n-            meta_item.meta_item_list().and_then(|meta_item_list| {\n-                if meta_item_list.len() == 1\n-                    && let Some(ident) = meta_item.ident()\n-                    && let Some(lit) = meta_item_list[0].literal()\n-                {\n-                    return Some((ident.name, lit));\n-                }\n-                None\n-            })\n-        })\n-    }\n-\n-    /// Gets a list of inner meta items from a list `MetaItem` type.\n-    pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n-        self.meta_item().and_then(|meta_item| meta_item.meta_item_list())\n+impl AttrIdGenerator {\n+    pub fn new() -> Self {\n+        AttrIdGenerator(AtomicU32::new(0))\n     }\n \n-    /// Returns `true` if the variant is `MetaItem`.\n-    pub fn is_meta_item(&self) -> bool {\n-        self.meta_item().is_some()\n+    pub fn mk_attr_id(&self) -> AttrId {\n+        let id = self.0.fetch_add(1, Ordering::Relaxed);\n+        assert!(id != u32::MAX);\n+        AttrId::from_u32(id)\n     }\n+}\n \n-    /// Returns `true` if `self` is a `MetaItem` and the meta item is a word.\n-    pub fn is_word(&self) -> bool {\n-        self.meta_item().map_or(false, |meta_item| meta_item.is_word())\n+impl Attribute {\n+    pub fn get_normal_item(&self) -> &AttrItem {\n+        match &self.kind {\n+            AttrKind::Normal(normal) => &normal.item,\n+            AttrKind::DocComment(..) => panic!(\"unexpected doc comment\"),\n+        }\n     }\n \n-    /// See [`MetaItem::name_value_literal_span`].\n-    pub fn name_value_literal_span(&self) -> Option<Span> {\n-        self.meta_item()?.name_value_literal_span()\n+    pub fn unwrap_normal_item(self) -> AttrItem {\n+        match self.kind {\n+            AttrKind::Normal(normal) => normal.into_inner().item,\n+            AttrKind::DocComment(..) => panic!(\"unexpected doc comment\"),\n+        }\n     }\n-}\n \n-impl Attribute {\n-    #[inline]\n-    pub fn has_name(&self, name: Symbol) -> bool {\n+    /// Returns `true` if it is a sugared doc comment (`///` or `//!` for example).\n+    /// So `#[doc = \"doc\"]` (which is a doc comment) and `#[doc(...)]` (which is not\n+    /// a doc comment) will return `false`.\n+    pub fn is_doc_comment(&self) -> bool {\n         match self.kind {\n-            AttrKind::Normal(ref item, _) => item.path == name,\n-            AttrKind::DocComment(..) => false,\n+            AttrKind::Normal(..) => false,\n+            AttrKind::DocComment(..) => true,\n         }\n     }\n \n     /// For a single-segment attribute, returns its name; otherwise, returns `None`.\n     pub fn ident(&self) -> Option<Ident> {\n-        match self.kind {\n-            AttrKind::Normal(ref item, _) => {\n-                if item.path.segments.len() == 1 {\n-                    Some(item.path.segments[0].ident)\n+        match &self.kind {\n+            AttrKind::Normal(normal) => {\n+                if let [ident] = &*normal.item.path.segments {\n+                    Some(ident.ident)\n                 } else {\n                     None\n                 }\n@@ -136,273 +91,198 @@ impl Attribute {\n         self.ident().unwrap_or_else(Ident::empty).name\n     }\n \n-    pub fn value_str(&self) -> Option<Symbol> {\n-        match self.kind {\n-            AttrKind::Normal(ref item, _) => item.meta_kind().and_then(|kind| kind.value_str()),\n-            AttrKind::DocComment(..) => None,\n-        }\n-    }\n-\n-    pub fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n-        match self.kind {\n-            AttrKind::Normal(ref item, _) => match item.meta_kind() {\n-                Some(MetaItemKind::List(list)) => Some(list),\n-                _ => None,\n-            },\n-            AttrKind::DocComment(..) => None,\n+    #[inline]\n+    pub fn has_name(&self, name: Symbol) -> bool {\n+        match &self.kind {\n+            AttrKind::Normal(normal) => normal.item.path == name,\n+            AttrKind::DocComment(..) => false,\n         }\n     }\n \n     pub fn is_word(&self) -> bool {\n-        if let AttrKind::Normal(item, _) = &self.kind {\n-            matches!(item.args, MacArgs::Empty)\n+        if let AttrKind::Normal(normal) = &self.kind {\n+            matches!(normal.item.args, AttrArgs::Empty)\n         } else {\n             false\n         }\n     }\n-}\n-\n-impl MetaItem {\n-    /// For a single-segment meta item, returns its name; otherwise, returns `None`.\n-    pub fn ident(&self) -> Option<Ident> {\n-        if self.path.segments.len() == 1 { Some(self.path.segments[0].ident) } else { None }\n-    }\n-    pub fn name_or_empty(&self) -> Symbol {\n-        self.ident().unwrap_or_else(Ident::empty).name\n-    }\n \n-    // Example:\n-    //     #[attribute(name = \"value\")]\n-    //                 ^^^^^^^^^^^^^^\n-    pub fn name_value_literal(&self) -> Option<&Lit> {\n+    pub fn meta_item_list(&self) -> Option<ThinVec<NestedMetaItem>> {\n         match &self.kind {\n-            MetaItemKind::NameValue(v) => Some(v),\n-            _ => None,\n+            AttrKind::Normal(normal) => normal.item.meta_item_list(),\n+            AttrKind::DocComment(..) => None,\n         }\n     }\n \n     pub fn value_str(&self) -> Option<Symbol> {\n-        match self.kind {\n-            MetaItemKind::NameValue(ref v) => match v.kind {\n-                LitKind::Str(ref s, _) => Some(*s),\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n-        match self.kind {\n-            MetaItemKind::List(ref l) => Some(&l[..]),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn is_word(&self) -> bool {\n-        matches!(self.kind, MetaItemKind::Word)\n-    }\n-\n-    pub fn has_name(&self, name: Symbol) -> bool {\n-        self.path == name\n-    }\n-\n-    /// This is used in case you want the value span instead of the whole attribute. Example:\n-    ///\n-    /// ```text\n-    /// #[doc(alias = \"foo\")]\n-    /// ```\n-    ///\n-    /// In here, it'll return a span for `\"foo\"`.\n-    pub fn name_value_literal_span(&self) -> Option<Span> {\n-        Some(self.name_value_literal()?.span)\n-    }\n-}\n-\n-impl AttrItem {\n-    pub fn span(&self) -> Span {\n-        self.args.span().map_or(self.path.span, |args_span| self.path.span.to(args_span))\n-    }\n-\n-    pub fn meta(&self, span: Span) -> Option<MetaItem> {\n-        Some(MetaItem {\n-            path: self.path.clone(),\n-            kind: MetaItemKind::from_mac_args(&self.args)?,\n-            span,\n-        })\n-    }\n-\n-    pub fn meta_kind(&self) -> Option<MetaItemKind> {\n-        MetaItemKind::from_mac_args(&self.args)\n-    }\n-}\n-\n-impl Attribute {\n-    pub fn is_doc_comment(&self) -> bool {\n-        match self.kind {\n-            AttrKind::Normal(..) => false,\n-            AttrKind::DocComment(..) => true,\n+        match &self.kind {\n+            AttrKind::Normal(normal) => normal.item.value_str(),\n+            AttrKind::DocComment(..) => None,\n         }\n     }\n \n+    /// Returns the documentation and its kind if this is a doc comment or a sugared doc comment.\n+    /// * `///doc` returns `Some((\"doc\", CommentKind::Line))`.\n+    /// * `/** doc */` returns `Some((\"doc\", CommentKind::Block))`.\n+    /// * `#[doc = \"doc\"]` returns `Some((\"doc\", CommentKind::Line))`.\n+    /// * `#[doc(...)]` returns `None`.\n     pub fn doc_str_and_comment_kind(&self) -> Option<(Symbol, CommentKind)> {\n-        match self.kind {\n-            AttrKind::DocComment(kind, data) => Some((data, kind)),\n-            AttrKind::Normal(ref item, _) if item.path == sym::doc => item\n-                .meta_kind()\n-                .and_then(|kind| kind.value_str())\n-                .map(|data| (data, CommentKind::Line)),\n+        match &self.kind {\n+            AttrKind::DocComment(kind, data) => Some((*data, *kind)),\n+            AttrKind::Normal(normal) if normal.item.path == sym::doc => {\n+                normal.item.value_str().map(|s| (s, CommentKind::Line))\n+            }\n             _ => None,\n         }\n     }\n \n+    /// Returns the documentation if this is a doc comment or a sugared doc comment.\n+    /// * `///doc` returns `Some(\"doc\")`.\n+    /// * `#[doc = \"doc\"]` returns `Some(\"doc\")`.\n+    /// * `#[doc(...)]` returns `None`.\n     pub fn doc_str(&self) -> Option<Symbol> {\n-        match self.kind {\n-            AttrKind::DocComment(.., data) => Some(data),\n-            AttrKind::Normal(ref item, _) if item.path == sym::doc => {\n-                item.meta_kind().and_then(|kind| kind.value_str())\n-            }\n+        match &self.kind {\n+            AttrKind::DocComment(.., data) => Some(*data),\n+            AttrKind::Normal(normal) if normal.item.path == sym::doc => normal.item.value_str(),\n             _ => None,\n         }\n     }\n \n     pub fn may_have_doc_links(&self) -> bool {\n-        self.doc_str().map_or(false, |s| comments::may_have_doc_links(s.as_str()))\n+        self.doc_str().is_some_and(|s| comments::may_have_doc_links(s.as_str()))\n     }\n \n-    pub fn get_normal_item(&self) -> &AttrItem {\n-        match self.kind {\n-            AttrKind::Normal(ref item, _) => item,\n-            AttrKind::DocComment(..) => panic!(\"unexpected doc comment\"),\n-        }\n-    }\n-\n-    pub fn unwrap_normal_item(self) -> AttrItem {\n-        match self.kind {\n-            AttrKind::Normal(item, _) => item,\n-            AttrKind::DocComment(..) => panic!(\"unexpected doc comment\"),\n-        }\n+    pub fn is_proc_macro_attr(&self) -> bool {\n+        [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n+            .iter()\n+            .any(|kind| self.has_name(*kind))\n     }\n \n     /// Extracts the MetaItem from inside this Attribute.\n     pub fn meta(&self) -> Option<MetaItem> {\n-        match self.kind {\n-            AttrKind::Normal(ref item, _) => item.meta(self.span),\n+        match &self.kind {\n+            AttrKind::Normal(normal) => normal.item.meta(self.span),\n             AttrKind::DocComment(..) => None,\n         }\n     }\n \n     pub fn meta_kind(&self) -> Option<MetaItemKind> {\n-        match self.kind {\n-            AttrKind::Normal(ref item, _) => item.meta_kind(),\n+        match &self.kind {\n+            AttrKind::Normal(normal) => normal.item.meta_kind(),\n             AttrKind::DocComment(..) => None,\n         }\n     }\n \n-    pub fn tokens(&self) -> AttrAnnotatedTokenStream {\n-        match self.kind {\n-            AttrKind::Normal(_, ref tokens) => tokens\n+    pub fn tokens(&self) -> TokenStream {\n+        match &self.kind {\n+            AttrKind::Normal(normal) => normal\n+                .tokens\n                 .as_ref()\n-                .unwrap_or_else(|| panic!(\"attribute is missing tokens: {:?}\", self))\n-                .create_token_stream(),\n-            AttrKind::DocComment(comment_kind, data) => AttrAnnotatedTokenStream::from((\n-                AttrAnnotatedTokenTree::Token(Token::new(\n-                    token::DocComment(comment_kind, self.style, data),\n-                    self.span,\n-                )),\n+                .unwrap_or_else(|| panic!(\"attribute is missing tokens: {self:?}\"))\n+                .to_attr_token_stream()\n+                .to_tokenstream(),\n+            &AttrKind::DocComment(comment_kind, data) => TokenStream::new(vec![TokenTree::Token(\n+                Token::new(token::DocComment(comment_kind, self.style, data), self.span),\n                 Spacing::Alone,\n-            )),\n+            )]),\n         }\n     }\n }\n \n-/* Constructors */\n+impl AttrItem {\n+    pub fn span(&self) -> Span {\n+        self.args.span().map_or(self.path.span, |args_span| self.path.span.to(args_span))\n+    }\n \n-pub fn mk_name_value_item_str(ident: Ident, str: Symbol, str_span: Span) -> MetaItem {\n-    let lit_kind = LitKind::Str(str, ast::StrStyle::Cooked);\n-    mk_name_value_item(ident, lit_kind, str_span)\n-}\n+    fn meta_item_list(&self) -> Option<ThinVec<NestedMetaItem>> {\n+        match &self.args {\n+            AttrArgs::Delimited(args) if args.delim == MacDelimiter::Parenthesis => {\n+                MetaItemKind::list_from_tokens(args.tokens.clone())\n+            }\n+            AttrArgs::Delimited(_) | AttrArgs::Eq(..) | AttrArgs::Empty => None,\n+        }\n+    }\n \n-pub fn mk_name_value_item(ident: Ident, lit_kind: LitKind, lit_span: Span) -> MetaItem {\n-    let lit = Lit::from_lit_kind(lit_kind, lit_span);\n-    let span = ident.span.to(lit_span);\n-    MetaItem { path: Path::from_ident(ident), span, kind: MetaItemKind::NameValue(lit) }\n-}\n+    fn value_str(&self) -> Option<Symbol> {\n+        match &self.args {\n+            AttrArgs::Eq(_, args) => args.value_str(),\n+            AttrArgs::Delimited(_) | AttrArgs::Empty => None,\n+        }\n+    }\n \n-pub fn mk_list_item(ident: Ident, items: Vec<NestedMetaItem>) -> MetaItem {\n-    MetaItem { path: Path::from_ident(ident), span: ident.span, kind: MetaItemKind::List(items) }\n-}\n+    pub fn meta(&self, span: Span) -> Option<MetaItem> {\n+        Some(MetaItem { path: self.path.clone(), kind: self.meta_kind()?, span })\n+    }\n \n-pub fn mk_word_item(ident: Ident) -> MetaItem {\n-    MetaItem { path: Path::from_ident(ident), span: ident.span, kind: MetaItemKind::Word }\n+    pub fn meta_kind(&self) -> Option<MetaItemKind> {\n+        MetaItemKind::from_attr_args(&self.args)\n+    }\n }\n \n-pub fn mk_nested_word_item(ident: Ident) -> NestedMetaItem {\n-    NestedMetaItem::MetaItem(mk_word_item(ident))\n+impl AttrArgsEq {\n+    fn value_str(&self) -> Option<Symbol> {\n+        match self {\n+            AttrArgsEq::Ast(expr) => match expr.kind {\n+                ExprKind::Lit(token_lit) => {\n+                    LitKind::from_token_lit(token_lit).ok().and_then(|lit| lit.str())\n+                }\n+                _ => None,\n+            },\n+            AttrArgsEq::Hir(lit) => lit.kind.str(),\n+        }\n+    }\n }\n \n-pub(crate) fn mk_attr_id() -> AttrId {\n-    use std::sync::atomic::AtomicU32;\n-    use std::sync::atomic::Ordering;\n-\n-    static NEXT_ATTR_ID: AtomicU32 = AtomicU32::new(0);\n-\n-    let id = NEXT_ATTR_ID.fetch_add(1, Ordering::SeqCst);\n-    assert!(id != u32::MAX);\n-    AttrId::from_u32(id)\n-}\n+impl MetaItem {\n+    /// For a single-segment meta item, returns its name; otherwise, returns `None`.\n+    pub fn ident(&self) -> Option<Ident> {\n+        if self.path.segments.len() == 1 { Some(self.path.segments[0].ident) } else { None }\n+    }\n \n-pub fn mk_attr(style: AttrStyle, path: Path, args: MacArgs, span: Span) -> Attribute {\n-    mk_attr_from_item(AttrItem { path, args, tokens: None }, None, style, span)\n-}\n+    pub fn name_or_empty(&self) -> Symbol {\n+        self.ident().unwrap_or_else(Ident::empty).name\n+    }\n \n-pub fn mk_attr_from_item(\n-    item: AttrItem,\n-    tokens: Option<LazyTokenStream>,\n-    style: AttrStyle,\n-    span: Span,\n-) -> Attribute {\n-    Attribute { kind: AttrKind::Normal(item, tokens), id: mk_attr_id(), style, span }\n-}\n+    pub fn has_name(&self, name: Symbol) -> bool {\n+        self.path == name\n+    }\n \n-/// Returns an inner attribute with the given value and span.\n-pub fn mk_attr_inner(item: MetaItem) -> Attribute {\n-    mk_attr(AttrStyle::Inner, item.path, item.kind.mac_args(item.span), item.span)\n-}\n+    pub fn is_word(&self) -> bool {\n+        matches!(self.kind, MetaItemKind::Word)\n+    }\n \n-/// Returns an outer attribute with the given value and span.\n-pub fn mk_attr_outer(item: MetaItem) -> Attribute {\n-    mk_attr(AttrStyle::Outer, item.path, item.kind.mac_args(item.span), item.span)\n-}\n+    pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n+        match &self.kind {\n+            MetaItemKind::List(l) => Some(&**l),\n+            _ => None,\n+        }\n+    }\n \n-pub fn mk_doc_comment(\n-    comment_kind: CommentKind,\n-    style: AttrStyle,\n-    data: Symbol,\n-    span: Span,\n-) -> Attribute {\n-    Attribute { kind: AttrKind::DocComment(comment_kind, data), id: mk_attr_id(), style, span }\n-}\n+    /// ```text\n+    /// Example:\n+    ///     #[attribute(name = \"value\")]\n+    ///                 ^^^^^^^^^^^^^^\n+    /// ```\n+    pub fn name_value_literal(&self) -> Option<&MetaItemLit> {\n+        match &self.kind {\n+            MetaItemKind::NameValue(v) => Some(v),\n+            _ => None,\n+        }\n+    }\n \n-pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n-    items.iter().any(|item| item.has_name(name))\n-}\n+    /// This is used in case you want the value span instead of the whole attribute. Example:\n+    ///\n+    /// ```text\n+    /// #[doc(alias = \"foo\")]\n+    /// ```\n+    ///\n+    /// In here, it'll return a span for `\"foo\"`.\n+    pub fn name_value_literal_span(&self) -> Option<Span> {\n+        Some(self.name_value_literal()?.span)\n+    }\n \n-impl MetaItem {\n-    fn token_trees_and_spacings(&self) -> Vec<TreeAndSpacing> {\n-        let mut idents = vec![];\n-        let mut last_pos = BytePos(0_u32);\n-        for (i, segment) in self.path.segments.iter().enumerate() {\n-            let is_first = i == 0;\n-            if !is_first {\n-                let mod_sep_span =\n-                    Span::new(last_pos, segment.ident.span.lo(), segment.ident.span.ctxt(), None);\n-                idents.push(TokenTree::token(token::ModSep, mod_sep_span).into());\n-            }\n-            idents.push(TokenTree::Token(Token::from_ast_ident(segment.ident)).into());\n-            last_pos = segment.ident.span.hi();\n-        }\n-        idents.extend(self.kind.token_trees_and_spacings(self.span));\n-        idents\n+    pub fn value_str(&self) -> Option<Symbol> {\n+        self.kind.value_str()\n     }\n \n     fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItem>\n@@ -411,30 +291,32 @@ impl MetaItem {\n     {\n         // FIXME: Share code with `parse_path`.\n         let path = match tokens.next().map(TokenTree::uninterpolate) {\n-            Some(TokenTree::Token(Token {\n-                kind: kind @ (token::Ident(..) | token::ModSep),\n-                span,\n-            })) => 'arm: {\n+            Some(TokenTree::Token(\n+                Token { kind: kind @ (token::Ident(..) | token::ModSep), span },\n+                _,\n+            )) => 'arm: {\n                 let mut segments = if let token::Ident(name, _) = kind {\n-                    if let Some(TokenTree::Token(Token { kind: token::ModSep, .. })) = tokens.peek()\n+                    if let Some(TokenTree::Token(Token { kind: token::ModSep, .. }, _)) =\n+                        tokens.peek()\n                     {\n                         tokens.next();\n-                        vec![PathSegment::from_ident(Ident::new(name, span))]\n+                        thin_vec![PathSegment::from_ident(Ident::new(name, span))]\n                     } else {\n                         break 'arm Path::from_ident(Ident::new(name, span));\n                     }\n                 } else {\n-                    vec![PathSegment::path_root(span)]\n+                    thin_vec![PathSegment::path_root(span)]\n                 };\n                 loop {\n-                    if let Some(TokenTree::Token(Token { kind: token::Ident(name, _), span })) =\n+                    if let Some(TokenTree::Token(Token { kind: token::Ident(name, _), span }, _)) =\n                         tokens.next().map(TokenTree::uninterpolate)\n                     {\n                         segments.push(PathSegment::from_ident(Ident::new(name, span)));\n                     } else {\n                         return None;\n                     }\n-                    if let Some(TokenTree::Token(Token { kind: token::ModSep, .. })) = tokens.peek()\n+                    if let Some(TokenTree::Token(Token { kind: token::ModSep, .. }, _)) =\n+                        tokens.peek()\n                     {\n                         tokens.next();\n                     } else {\n@@ -444,17 +326,17 @@ impl MetaItem {\n                 let span = span.with_hi(segments.last().unwrap().ident.span.hi());\n                 Path { span, segments, tokens: None }\n             }\n-            Some(TokenTree::Token(Token { kind: token::Interpolated(nt), .. })) => match *nt {\n-                token::Nonterminal::NtMeta(ref item) => return item.meta(item.path.span),\n-                token::Nonterminal::NtPath(ref path) => (**path).clone(),\n+            Some(TokenTree::Token(Token { kind: token::Interpolated(nt), .. }, _)) => match &*nt {\n+                token::Nonterminal::NtMeta(item) => return item.meta(item.path.span),\n+                token::Nonterminal::NtPath(path) => (**path).clone(),\n                 _ => return None,\n             },\n             _ => return None,\n         };\n         let list_closing_paren_pos = tokens.peek().map(|tt| tt.span().hi());\n         let kind = MetaItemKind::from_tokens(tokens)?;\n-        let hi = match kind {\n-            MetaItemKind::NameValue(ref lit) => lit.span.hi(),\n+        let hi = match &kind {\n+            MetaItemKind::NameValue(lit) => lit.span.hi(),\n             MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(path.span.hi()),\n             _ => path.span.hi(),\n         };\n@@ -466,85 +348,23 @@ impl MetaItem {\n impl MetaItemKind {\n     pub fn value_str(&self) -> Option<Symbol> {\n         match self {\n-            MetaItemKind::NameValue(ref v) => match v.kind {\n-                LitKind::Str(ref s, _) => Some(*s),\n-                _ => None,\n-            },\n+            MetaItemKind::NameValue(v) => v.kind.str(),\n             _ => None,\n         }\n     }\n \n-    pub fn mac_args(&self, span: Span) -> MacArgs {\n-        match self {\n-            MetaItemKind::Word => MacArgs::Empty,\n-            MetaItemKind::NameValue(lit) => {\n-                let expr = P(ast::Expr {\n-                    id: ast::DUMMY_NODE_ID,\n-                    kind: ast::ExprKind::Lit(lit.clone()),\n-                    span: lit.span,\n-                    attrs: ThinVec::new(),\n-                    tokens: None,\n-                });\n-                MacArgs::Eq(span, MacArgsEq::Ast(expr))\n-            }\n-            MetaItemKind::List(list) => {\n-                let mut tts = Vec::new();\n-                for (i, item) in list.iter().enumerate() {\n-                    if i > 0 {\n-                        tts.push(TokenTree::token(token::Comma, span).into());\n-                    }\n-                    tts.extend(item.token_trees_and_spacings())\n-                }\n-                MacArgs::Delimited(\n-                    DelimSpan::from_single(span),\n-                    MacDelimiter::Parenthesis,\n-                    TokenStream::new(tts),\n-                )\n-            }\n-        }\n-    }\n-\n-    fn token_trees_and_spacings(&self, span: Span) -> Vec<TreeAndSpacing> {\n-        match *self {\n-            MetaItemKind::Word => vec![],\n-            MetaItemKind::NameValue(ref lit) => {\n-                vec![\n-                    TokenTree::token(token::Eq, span).into(),\n-                    TokenTree::Token(lit.to_token()).into(),\n-                ]\n-            }\n-            MetaItemKind::List(ref list) => {\n-                let mut tokens = Vec::new();\n-                for (i, item) in list.iter().enumerate() {\n-                    if i > 0 {\n-                        tokens.push(TokenTree::token(token::Comma, span).into());\n-                    }\n-                    tokens.extend(item.token_trees_and_spacings())\n-                }\n-                vec![\n-                    TokenTree::Delimited(\n-                        DelimSpan::from_single(span),\n-                        Delimiter::Parenthesis,\n-                        TokenStream::new(tokens),\n-                    )\n-                    .into(),\n-                ]\n-            }\n-        }\n-    }\n-\n-    fn list_from_tokens(tokens: TokenStream) -> Option<MetaItemKind> {\n+    fn list_from_tokens(tokens: TokenStream) -> Option<ThinVec<NestedMetaItem>> {\n         let mut tokens = tokens.into_trees().peekable();\n-        let mut result = Vec::new();\n+        let mut result = ThinVec::new();\n         while tokens.peek().is_some() {\n             let item = NestedMetaItem::from_tokens(&mut tokens)?;\n             result.push(item);\n             match tokens.next() {\n-                None | Some(TokenTree::Token(Token { kind: token::Comma, .. })) => {}\n+                None | Some(TokenTree::Token(Token { kind: token::Comma, .. }, _)) => {}\n                 _ => return None,\n             }\n         }\n-        Some(MetaItemKind::List(result))\n+        Some(result)\n     }\n \n     fn name_value_from_tokens(\n@@ -554,72 +374,143 @@ impl MetaItemKind {\n             Some(TokenTree::Delimited(_, Delimiter::Invisible, inner_tokens)) => {\n                 MetaItemKind::name_value_from_tokens(&mut inner_tokens.into_trees())\n             }\n-            Some(TokenTree::Token(token)) => {\n-                Lit::from_token(&token).ok().map(MetaItemKind::NameValue)\n+            Some(TokenTree::Token(token, _)) => {\n+                MetaItemLit::from_token(&token).map(MetaItemKind::NameValue)\n             }\n             _ => None,\n         }\n     }\n \n-    fn from_mac_args(args: &MacArgs) -> Option<MetaItemKind> {\n-        match args {\n-            MacArgs::Empty => Some(MetaItemKind::Word),\n-            MacArgs::Delimited(_, MacDelimiter::Parenthesis, tokens) => {\n-                MetaItemKind::list_from_tokens(tokens.clone())\n-            }\n-            MacArgs::Delimited(..) => None,\n-            MacArgs::Eq(_, MacArgsEq::Ast(expr)) => match &expr.kind {\n-                ast::ExprKind::Lit(lit) => Some(MetaItemKind::NameValue(lit.clone())),\n-                _ => None,\n-            },\n-            MacArgs::Eq(_, MacArgsEq::Hir(lit)) => Some(MetaItemKind::NameValue(lit.clone())),\n-        }\n-    }\n-\n     fn from_tokens(\n         tokens: &mut iter::Peekable<impl Iterator<Item = TokenTree>>,\n     ) -> Option<MetaItemKind> {\n         match tokens.peek() {\n             Some(TokenTree::Delimited(_, Delimiter::Parenthesis, inner_tokens)) => {\n                 let inner_tokens = inner_tokens.clone();\n                 tokens.next();\n-                MetaItemKind::list_from_tokens(inner_tokens)\n+                MetaItemKind::list_from_tokens(inner_tokens).map(MetaItemKind::List)\n             }\n             Some(TokenTree::Delimited(..)) => None,\n-            Some(TokenTree::Token(Token { kind: token::Eq, .. })) => {\n+            Some(TokenTree::Token(Token { kind: token::Eq, .. }, _)) => {\n                 tokens.next();\n                 MetaItemKind::name_value_from_tokens(tokens)\n             }\n             _ => Some(MetaItemKind::Word),\n         }\n     }\n+\n+    fn from_attr_args(args: &AttrArgs) -> Option<MetaItemKind> {\n+        match args {\n+            AttrArgs::Empty => Some(MetaItemKind::Word),\n+            AttrArgs::Delimited(DelimArgs {\n+                dspan: _,\n+                delim: MacDelimiter::Parenthesis,\n+                tokens,\n+            }) => MetaItemKind::list_from_tokens(tokens.clone()).map(MetaItemKind::List),\n+            AttrArgs::Delimited(..) => None,\n+            AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => match expr.kind {\n+                ExprKind::Lit(token_lit) => {\n+                    // Turn failures to `None`, we'll get parse errors elsewhere.\n+                    MetaItemLit::from_token_lit(token_lit, expr.span)\n+                        .ok()\n+                        .map(|lit| MetaItemKind::NameValue(lit))\n+                }\n+                _ => None,\n+            },\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => Some(MetaItemKind::NameValue(lit.clone())),\n+        }\n+    }\n }\n \n impl NestedMetaItem {\n     pub fn span(&self) -> Span {\n-        match *self {\n-            NestedMetaItem::MetaItem(ref item) => item.span,\n-            NestedMetaItem::Literal(ref lit) => lit.span,\n+        match self {\n+            NestedMetaItem::MetaItem(item) => item.span,\n+            NestedMetaItem::Lit(lit) => lit.span,\n         }\n     }\n \n-    fn token_trees_and_spacings(&self) -> Vec<TreeAndSpacing> {\n-        match *self {\n-            NestedMetaItem::MetaItem(ref item) => item.token_trees_and_spacings(),\n-            NestedMetaItem::Literal(ref lit) => vec![TokenTree::Token(lit.to_token()).into()],\n+    /// For a single-segment meta item, returns its name; otherwise, returns `None`.\n+    pub fn ident(&self) -> Option<Ident> {\n+        self.meta_item().and_then(|meta_item| meta_item.ident())\n+    }\n+\n+    pub fn name_or_empty(&self) -> Symbol {\n+        self.ident().unwrap_or_else(Ident::empty).name\n+    }\n+\n+    /// Returns `true` if this list item is a MetaItem with a name of `name`.\n+    pub fn has_name(&self, name: Symbol) -> bool {\n+        self.meta_item().is_some_and(|meta_item| meta_item.has_name(name))\n+    }\n+\n+    /// Returns `true` if `self` is a `MetaItem` and the meta item is a word.\n+    pub fn is_word(&self) -> bool {\n+        self.meta_item().is_some_and(|meta_item| meta_item.is_word())\n+    }\n+\n+    /// Gets a list of inner meta items from a list `MetaItem` type.\n+    pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n+        self.meta_item().and_then(|meta_item| meta_item.meta_item_list())\n+    }\n+\n+    /// Returns a name and single literal value tuple of the `MetaItem`.\n+    pub fn name_value_literal(&self) -> Option<(Symbol, &MetaItemLit)> {\n+        self.meta_item().and_then(|meta_item| {\n+            meta_item.meta_item_list().and_then(|meta_item_list| {\n+                if meta_item_list.len() == 1\n+                    && let Some(ident) = meta_item.ident()\n+                    && let Some(lit) = meta_item_list[0].lit()\n+                {\n+                    return Some((ident.name, lit));\n+                }\n+                None\n+            })\n+        })\n+    }\n+\n+    /// See [`MetaItem::name_value_literal_span`].\n+    pub fn name_value_literal_span(&self) -> Option<Span> {\n+        self.meta_item()?.name_value_literal_span()\n+    }\n+\n+    /// Gets the string value if `self` is a `MetaItem` and the `MetaItem` is a\n+    /// `MetaItemKind::NameValue` variant containing a string, otherwise `None`.\n+    pub fn value_str(&self) -> Option<Symbol> {\n+        self.meta_item().and_then(|meta_item| meta_item.value_str())\n+    }\n+\n+    /// Returns the `MetaItemLit` if `self` is a `NestedMetaItem::Literal`s.\n+    pub fn lit(&self) -> Option<&MetaItemLit> {\n+        match self {\n+            NestedMetaItem::Lit(lit) => Some(lit),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Returns the `MetaItem` if `self` is a `NestedMetaItem::MetaItem`.\n+    pub fn meta_item(&self) -> Option<&MetaItem> {\n+        match self {\n+            NestedMetaItem::MetaItem(item) => Some(item),\n+            _ => None,\n         }\n     }\n \n+    /// Returns `true` if the variant is `MetaItem`.\n+    pub fn is_meta_item(&self) -> bool {\n+        self.meta_item().is_some()\n+    }\n+\n     fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<NestedMetaItem>\n     where\n         I: Iterator<Item = TokenTree>,\n     {\n         match tokens.peek() {\n-            Some(TokenTree::Token(token))\n-                if let Ok(lit) = Lit::from_token(token) =>\n+            Some(TokenTree::Token(token, _))\n+                if let Some(lit) = MetaItemLit::from_token(token) =>\n             {\n                 tokens.next();\n-                return Some(NestedMetaItem::Literal(lit));\n+                return Some(NestedMetaItem::Lit(lit));\n             }\n             Some(TokenTree::Delimited(_, Delimiter::Invisible, inner_tokens)) => {\n                 let inner_tokens = inner_tokens.clone();\n@@ -631,3 +522,105 @@ impl NestedMetaItem {\n         MetaItem::from_tokens(tokens).map(NestedMetaItem::MetaItem)\n     }\n }\n+\n+pub fn mk_doc_comment(\n+    g: &AttrIdGenerator,\n+    comment_kind: CommentKind,\n+    style: AttrStyle,\n+    data: Symbol,\n+    span: Span,\n+) -> Attribute {\n+    Attribute { kind: AttrKind::DocComment(comment_kind, data), id: g.mk_attr_id(), style, span }\n+}\n+\n+pub fn mk_attr(\n+    g: &AttrIdGenerator,\n+    style: AttrStyle,\n+    path: Path,\n+    args: AttrArgs,\n+    span: Span,\n+) -> Attribute {\n+    mk_attr_from_item(g, AttrItem { path, args, tokens: None }, None, style, span)\n+}\n+\n+pub fn mk_attr_from_item(\n+    g: &AttrIdGenerator,\n+    item: AttrItem,\n+    tokens: Option<LazyAttrTokenStream>,\n+    style: AttrStyle,\n+    span: Span,\n+) -> Attribute {\n+    Attribute {\n+        kind: AttrKind::Normal(P(NormalAttr { item, tokens })),\n+        id: g.mk_attr_id(),\n+        style,\n+        span,\n+    }\n+}\n+\n+pub fn mk_attr_word(g: &AttrIdGenerator, style: AttrStyle, name: Symbol, span: Span) -> Attribute {\n+    let path = Path::from_ident(Ident::new(name, span));\n+    let args = AttrArgs::Empty;\n+    mk_attr(g, style, path, args, span)\n+}\n+\n+pub fn mk_attr_nested_word(\n+    g: &AttrIdGenerator,\n+    style: AttrStyle,\n+    outer: Symbol,\n+    inner: Symbol,\n+    span: Span,\n+) -> Attribute {\n+    let inner_tokens = TokenStream::new(vec![TokenTree::Token(\n+        Token::from_ast_ident(Ident::new(inner, span)),\n+        Spacing::Alone,\n+    )]);\n+    let outer_ident = Ident::new(outer, span);\n+    let path = Path::from_ident(outer_ident);\n+    let attr_args = AttrArgs::Delimited(DelimArgs {\n+        dspan: DelimSpan::from_single(span),\n+        delim: MacDelimiter::Parenthesis,\n+        tokens: inner_tokens,\n+    });\n+    mk_attr(g, style, path, attr_args, span)\n+}\n+\n+pub fn mk_attr_name_value_str(\n+    g: &AttrIdGenerator,\n+    style: AttrStyle,\n+    name: Symbol,\n+    val: Symbol,\n+    span: Span,\n+) -> Attribute {\n+    let lit = token::Lit::new(token::Str, escape_string_symbol(val), None);\n+    let expr = P(Expr {\n+        id: DUMMY_NODE_ID,\n+        kind: ExprKind::Lit(lit),\n+        span,\n+        attrs: AttrVec::new(),\n+        tokens: None,\n+    });\n+    let path = Path::from_ident(Ident::new(name, span));\n+    let args = AttrArgs::Eq(span, AttrArgsEq::Ast(expr));\n+    mk_attr(g, style, path, args, span)\n+}\n+\n+pub fn filter_by_name(attrs: &[Attribute], name: Symbol) -> impl Iterator<Item = &Attribute> {\n+    attrs.iter().filter(move |attr| attr.has_name(name))\n+}\n+\n+pub fn find_by_name(attrs: &[Attribute], name: Symbol) -> Option<&Attribute> {\n+    filter_by_name(attrs, name).next()\n+}\n+\n+pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: Symbol) -> Option<Symbol> {\n+    find_by_name(attrs, name).and_then(|attr| attr.value_str())\n+}\n+\n+pub fn contains_name(attrs: &[Attribute], name: Symbol) -> bool {\n+    find_by_name(attrs, name).is_some()\n+}\n+\n+pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n+    items.iter().any(|item| item.has_name(name))\n+}"}, {"sha": "e87f6e820a1fcae6feeb67959990f25ab60cd7e0", "filename": "compiler/rustc_ast/src/expand/allocator.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fallocator.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -1,20 +1,28 @@\n use rustc_span::symbol::{sym, Symbol};\n \n-#[derive(Clone, Debug, Copy, HashStable_Generic)]\n+#[derive(Clone, Debug, Copy, Eq, PartialEq, HashStable_Generic)]\n pub enum AllocatorKind {\n     Global,\n     Default,\n }\n \n-impl AllocatorKind {\n-    pub fn fn_name(&self, base: Symbol) -> String {\n-        match *self {\n-            AllocatorKind::Global => format!(\"__rg_{}\", base),\n-            AllocatorKind::Default => format!(\"__rdl_{}\", base),\n-        }\n+pub fn global_fn_name(base: Symbol) -> String {\n+    format!(\"__rust_{base}\")\n+}\n+\n+pub fn default_fn_name(base: Symbol) -> String {\n+    format!(\"__rdl_{base}\")\n+}\n+\n+pub fn alloc_error_handler_name(alloc_error_handler_kind: AllocatorKind) -> &'static str {\n+    match alloc_error_handler_kind {\n+        AllocatorKind::Global => \"__rg_oom\",\n+        AllocatorKind::Default => \"__rdl_oom\",\n     }\n }\n \n+pub const NO_ALLOC_SHIM_IS_UNSTABLE: &str = \"__rust_no_alloc_shim_is_unstable\";\n+\n pub enum AllocatorTy {\n     Layout,\n     Ptr,"}, {"sha": "942347383ce312c775f68e2097882ce850c56afa", "filename": "compiler/rustc_ast/src/expand/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fmod.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -1,3 +1,20 @@\n //! Definitions shared by macros / syntax extensions and e.g. `rustc_middle`.\n \n+use rustc_span::{def_id::DefId, symbol::Ident};\n+\n+use crate::MetaItem;\n+\n pub mod allocator;\n+\n+#[derive(Debug, Clone, Encodable, Decodable, HashStable_Generic)]\n+pub struct StrippedCfgItem<ModId = DefId> {\n+    pub parent_module: ModId,\n+    pub name: Ident,\n+    pub cfg: MetaItem,\n+}\n+\n+impl<ModId> StrippedCfgItem<ModId> {\n+    pub fn map_mod_id<New>(self, f: impl FnOnce(ModId) -> New) -> StrippedCfgItem<New> {\n+        StrippedCfgItem { parent_module: f(self.parent_module), name: self.name, cfg: self.cfg }\n+    }\n+}"}, {"sha": "699946f307b50820e07ac545f50d16ca386df861", "filename": "compiler/rustc_ast/src/format.rs", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fformat.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -0,0 +1,272 @@\n+use crate::ptr::P;\n+use crate::Expr;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::Span;\n+\n+// Definitions:\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+//                     FormatArgs\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//                                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+//                                      argument\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+//                     template\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//               \u2514\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2518\n+//                      pieces\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//               \u2514\u2500\u2500\u2500\u2500\u2518           \u2514\u2518\n+//                   literal pieces\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+//                     placeholder\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//                      \u2514\u2500\u2518  \u2514\u2500\u2518\n+//                      positions (could be names, numbers, empty, or `*`)\n+\n+/// (Parsed) format args.\n+///\n+/// Basically the \"AST\" for a complete `format_args!()`.\n+///\n+/// E.g., `format_args!(\"hello {name}\");`.\n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct FormatArgs {\n+    pub span: Span,\n+    pub template: Vec<FormatArgsPiece>,\n+    pub arguments: FormatArguments,\n+}\n+\n+/// A piece of a format template string.\n+///\n+/// E.g. \"hello\" or \"{name}\".\n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub enum FormatArgsPiece {\n+    Literal(Symbol),\n+    Placeholder(FormatPlaceholder),\n+}\n+\n+/// The arguments to format_args!().\n+///\n+/// E.g. `1, 2, name=\"ferris\", n=3`,\n+/// but also implicit captured arguments like `x` in `format_args!(\"{x}\")`.\n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct FormatArguments {\n+    arguments: Vec<FormatArgument>,\n+    num_unnamed_args: usize,\n+    num_explicit_args: usize,\n+    names: FxHashMap<Symbol, usize>,\n+}\n+\n+// FIXME: Rustdoc has trouble proving Send/Sync for this. See #106930.\n+#[cfg(parallel_compiler)]\n+unsafe impl Sync for FormatArguments {}\n+#[cfg(parallel_compiler)]\n+unsafe impl Send for FormatArguments {}\n+\n+impl FormatArguments {\n+    pub fn new() -> Self {\n+        Self {\n+            arguments: Vec::new(),\n+            names: FxHashMap::default(),\n+            num_unnamed_args: 0,\n+            num_explicit_args: 0,\n+        }\n+    }\n+\n+    pub fn add(&mut self, arg: FormatArgument) -> usize {\n+        let index = self.arguments.len();\n+        if let Some(name) = arg.kind.ident() {\n+            self.names.insert(name.name, index);\n+        } else if self.names.is_empty() {\n+            // Only count the unnamed args before the first named arg.\n+            // (Any later ones are errors.)\n+            self.num_unnamed_args += 1;\n+        }\n+        if !matches!(arg.kind, FormatArgumentKind::Captured(..)) {\n+            // This is an explicit argument.\n+            // Make sure that all arguments so far are explicit.\n+            assert_eq!(\n+                self.num_explicit_args,\n+                self.arguments.len(),\n+                \"captured arguments must be added last\"\n+            );\n+            self.num_explicit_args += 1;\n+        }\n+        self.arguments.push(arg);\n+        index\n+    }\n+\n+    pub fn by_name(&self, name: Symbol) -> Option<(usize, &FormatArgument)> {\n+        let i = *self.names.get(&name)?;\n+        Some((i, &self.arguments[i]))\n+    }\n+\n+    pub fn by_index(&self, i: usize) -> Option<&FormatArgument> {\n+        (i < self.num_explicit_args).then(|| &self.arguments[i])\n+    }\n+\n+    pub fn unnamed_args(&self) -> &[FormatArgument] {\n+        &self.arguments[..self.num_unnamed_args]\n+    }\n+\n+    pub fn named_args(&self) -> &[FormatArgument] {\n+        &self.arguments[self.num_unnamed_args..self.num_explicit_args]\n+    }\n+\n+    pub fn explicit_args(&self) -> &[FormatArgument] {\n+        &self.arguments[..self.num_explicit_args]\n+    }\n+\n+    pub fn all_args(&self) -> &[FormatArgument] {\n+        &self.arguments[..]\n+    }\n+\n+    pub fn all_args_mut(&mut self) -> &mut Vec<FormatArgument> {\n+        &mut self.arguments\n+    }\n+}\n+\n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct FormatArgument {\n+    pub kind: FormatArgumentKind,\n+    pub expr: P<Expr>,\n+}\n+\n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub enum FormatArgumentKind {\n+    /// `format_args(\u2026, arg)`\n+    Normal,\n+    /// `format_args(\u2026, arg = 1)`\n+    Named(Ident),\n+    /// `format_args(\"\u2026 {arg} \u2026\")`\n+    Captured(Ident),\n+}\n+\n+impl FormatArgumentKind {\n+    pub fn ident(&self) -> Option<Ident> {\n+        match self {\n+            &Self::Normal => None,\n+            &Self::Named(id) => Some(id),\n+            &Self::Captured(id) => Some(id),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n+pub struct FormatPlaceholder {\n+    /// Index into [`FormatArgs::arguments`].\n+    pub argument: FormatArgPosition,\n+    /// The span inside the format string for the full `{\u2026}` placeholder.\n+    pub span: Option<Span>,\n+    /// `{}`, `{:?}`, or `{:x}`, etc.\n+    pub format_trait: FormatTrait,\n+    /// `{}` or `{:.5}` or `{:-^20}`, etc.\n+    pub format_options: FormatOptions,\n+}\n+\n+#[derive(Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n+pub struct FormatArgPosition {\n+    /// Which argument this position refers to (Ok),\n+    /// or would've referred to if it existed (Err).\n+    pub index: Result<usize, usize>,\n+    /// What kind of position this is. See [`FormatArgPositionKind`].\n+    pub kind: FormatArgPositionKind,\n+    /// The span of the name or number.\n+    pub span: Option<Span>,\n+}\n+\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n+pub enum FormatArgPositionKind {\n+    /// `{}` or `{:.*}`\n+    Implicit,\n+    /// `{1}` or `{:1$}` or `{:.1$}`\n+    Number,\n+    /// `{a}` or `{:a$}` or `{:.a$}`\n+    Named,\n+}\n+\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, PartialEq, Eq, Hash)]\n+pub enum FormatTrait {\n+    /// `{}`\n+    Display,\n+    /// `{:?}`\n+    Debug,\n+    /// `{:e}`\n+    LowerExp,\n+    /// `{:E}`\n+    UpperExp,\n+    /// `{:o}`\n+    Octal,\n+    /// `{:p}`\n+    Pointer,\n+    /// `{:b}`\n+    Binary,\n+    /// `{:x}`\n+    LowerHex,\n+    /// `{:X}`\n+    UpperHex,\n+}\n+\n+#[derive(Clone, Encodable, Decodable, Default, Debug, PartialEq, Eq)]\n+pub struct FormatOptions {\n+    /// The width. E.g. `{:5}` or `{:width$}`.\n+    pub width: Option<FormatCount>,\n+    /// The precision. E.g. `{:.5}` or `{:.precision$}`.\n+    pub precision: Option<FormatCount>,\n+    /// The alignment. E.g. `{:>}` or `{:<}` or `{:^}`.\n+    pub alignment: Option<FormatAlignment>,\n+    /// The fill character. E.g. the `.` in `{:.>10}`.\n+    pub fill: Option<char>,\n+    /// The `+` or `-` flag.\n+    pub sign: Option<FormatSign>,\n+    /// The `#` flag.\n+    pub alternate: bool,\n+    /// The `0` flag. E.g. the `0` in `{:02x}`.\n+    pub zero_pad: bool,\n+    /// The `x` or `X` flag (for `Debug` only). E.g. the `x` in `{:x?}`.\n+    pub debug_hex: Option<FormatDebugHex>,\n+}\n+\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n+pub enum FormatSign {\n+    /// The `+` flag.\n+    Plus,\n+    /// The `-` flag.\n+    Minus,\n+}\n+\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n+pub enum FormatDebugHex {\n+    /// The `x` flag in `{:x?}`.\n+    Lower,\n+    /// The `X` flag in `{:X?}`.\n+    Upper,\n+}\n+\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n+pub enum FormatAlignment {\n+    /// `{:<}`\n+    Left,\n+    /// `{:>}`\n+    Right,\n+    /// `{:^}`\n+    Center,\n+}\n+\n+#[derive(Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n+pub enum FormatCount {\n+    /// `{:5}` or `{:.5}`\n+    Literal(usize),\n+    /// `{:.*}`, `{:.5$}`, or `{:a$}`, etc.\n+    Argument(FormatArgPosition),\n+}"}, {"sha": "b07ed1d1c741eeb372d57c0f80a9e6d935bbb3f8", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -10,21 +10,24 @@\n )]\n #![feature(associated_type_bounds)]\n #![feature(box_patterns)]\n-#![feature(const_default_impls)]\n #![feature(const_trait_impl)]\n #![feature(if_let_guard)]\n-#![feature(label_break_value)]\n #![feature(let_chains)]\n #![feature(min_specialization)]\n #![feature(negative_impls)]\n-#![feature(slice_internals)]\n #![feature(stmt_expr_attributes)]\n #![recursion_limit = \"256\"]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate rustc_macros;\n \n+#[macro_use]\n+extern crate tracing;\n+\n pub mod util {\n+    pub mod case;\n     pub mod classify;\n     pub mod comments;\n     pub mod literal;\n@@ -37,6 +40,7 @@ pub mod ast_traits;\n pub mod attr;\n pub mod entry;\n pub mod expand;\n+pub mod format;\n pub mod mut_visit;\n pub mod node_id;\n pub mod ptr;\n@@ -46,6 +50,7 @@ pub mod visit;\n \n pub use self::ast::*;\n pub use self::ast_traits::{AstDeref, AstNodeWrapper, HasAttrs, HasNodeId, HasSpan, HasTokens};\n+pub use self::format::*;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n "}, {"sha": "66b94d12a32c6c11933eaf9e209a298694f187a2", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 174, "deletions": 115, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -7,21 +7,20 @@\n //! a `MutVisitor` renaming item names in a module will miss all of those\n //! that are created by the expansion of a macro.\n \n-use crate::ast::*;\n use crate::ptr::P;\n use crate::token::{self, Token};\n use crate::tokenstream::*;\n+use crate::{ast::*, StaticItem};\n \n-use rustc_data_structures::map_in_place::MapInPlace;\n+use rustc_data_structures::flat_map_in_place::FlatMapInPlace;\n use rustc_data_structures::sync::Lrc;\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n-\n use smallvec::{smallvec, Array, SmallVec};\n use std::ops::DerefMut;\n use std::{panic, ptr};\n+use thin_vec::ThinVec;\n \n pub trait ExpectOne<A: Array> {\n     fn expect_one(self, err: &'static str) -> A::Item;\n@@ -153,6 +152,12 @@ pub trait MutVisitor: Sized {\n         noop_visit_expr(e, self);\n     }\n \n+    /// This method is a hack to workaround unstable of `stmt_expr_attributes`.\n+    /// It can be removed once that feature is stabilized.\n+    fn visit_method_receiver_expr(&mut self, ex: &mut P<Expr>) {\n+        self.visit_expr(ex)\n+    }\n+\n     fn filter_map_expr(&mut self, e: P<Expr>) -> Option<P<Expr>> {\n         noop_filter_map_expr(e, self)\n     }\n@@ -189,7 +194,7 @@ pub trait MutVisitor: Sized {\n         noop_visit_path(p, self);\n     }\n \n-    fn visit_qself(&mut self, qs: &mut Option<QSelf>) {\n+    fn visit_qself(&mut self, qs: &mut Option<P<QSelf>>) {\n         noop_visit_qself(qs, self);\n     }\n \n@@ -292,6 +297,10 @@ pub trait MutVisitor: Sized {\n     fn visit_inline_asm_sym(&mut self, sym: &mut InlineAsmSym) {\n         noop_visit_inline_asm_sym(sym, self)\n     }\n+\n+    fn visit_format_args(&mut self, fmt: &mut FormatArgs) {\n+        noop_visit_format_args(fmt, self)\n+    }\n }\n \n /// Use a map-style function (`FnOnce(T) -> T`) to overwrite a `&mut T`. Useful\n@@ -328,22 +337,28 @@ where\n \n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n #[inline]\n-pub fn visit_opt<T, F>(opt: &mut Option<T>, mut visit_elem: F)\n+pub fn visit_thin_vec<T, F>(elems: &mut ThinVec<T>, mut visit_elem: F)\n where\n     F: FnMut(&mut T),\n {\n-    if let Some(elem) = opt {\n+    for elem in elems {\n         visit_elem(elem);\n     }\n }\n \n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n-pub fn visit_attrs<T: MutVisitor>(attrs: &mut Vec<Attribute>, vis: &mut T) {\n-    visit_vec(attrs, |attr| vis.visit_attribute(attr));\n+#[inline]\n+pub fn visit_opt<T, F>(opt: &mut Option<T>, mut visit_elem: F)\n+where\n+    F: FnMut(&mut T),\n+{\n+    if let Some(elem) = opt {\n+        visit_elem(elem);\n+    }\n }\n \n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n-pub fn visit_thin_attrs<T: MutVisitor>(attrs: &mut AttrVec, vis: &mut T) {\n+pub fn visit_attrs<T: MutVisitor>(attrs: &mut AttrVec, vis: &mut T) {\n     for attr in attrs.iter_mut() {\n         vis.visit_attribute(attr);\n     }\n@@ -354,6 +369,11 @@ pub fn visit_exprs<T: MutVisitor>(exprs: &mut Vec<P<Expr>>, vis: &mut T) {\n     exprs.flat_map_in_place(|expr| vis.filter_map_expr(expr))\n }\n \n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+pub fn visit_thin_exprs<T: MutVisitor>(exprs: &mut ThinVec<P<Expr>>, vis: &mut T) {\n+    exprs.flat_map_in_place(|expr| vis.filter_map_expr(expr))\n+}\n+\n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n pub fn visit_bounds<T: MutVisitor>(bounds: &mut GenericBounds, vis: &mut T) {\n     visit_vec(bounds, |bound| vis.visit_param_bound(bound));\n@@ -367,23 +387,27 @@ pub fn visit_fn_sig<T: MutVisitor>(FnSig { header, decl, span }: &mut FnSig, vis\n }\n \n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n-pub fn visit_mac_args<T: MutVisitor>(args: &mut MacArgs, vis: &mut T) {\n+pub fn visit_attr_args<T: MutVisitor>(args: &mut AttrArgs, vis: &mut T) {\n     match args {\n-        MacArgs::Empty => {}\n-        MacArgs::Delimited(dspan, _delim, tokens) => {\n-            visit_delim_span(dspan, vis);\n-            visit_tts(tokens, vis);\n-        }\n-        MacArgs::Eq(eq_span, MacArgsEq::Ast(expr)) => {\n+        AttrArgs::Empty => {}\n+        AttrArgs::Delimited(args) => visit_delim_args(args, vis),\n+        AttrArgs::Eq(eq_span, AttrArgsEq::Ast(expr)) => {\n             vis.visit_span(eq_span);\n             vis.visit_expr(expr);\n         }\n-        MacArgs::Eq(_, MacArgsEq::Hir(lit)) => {\n+        AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n             unreachable!(\"in literal form when visiting mac args eq: {:?}\", lit)\n         }\n     }\n }\n \n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+pub fn visit_delim_args<T: MutVisitor>(args: &mut DelimArgs, vis: &mut T) {\n+    let DelimArgs { dspan, delim: _, tokens } = args;\n+    visit_delim_span(dspan, vis);\n+    visit_tts(tokens, vis);\n+}\n+\n pub fn visit_delim_span<T: MutVisitor>(dspan: &mut DelimSpan, vis: &mut T) {\n     vis.visit_span(&mut dspan.open);\n     vis.visit_span(&mut dspan.close);\n@@ -398,19 +422,15 @@ pub fn noop_flat_map_pat_field<T: MutVisitor>(\n     vis.visit_ident(ident);\n     vis.visit_pat(pat);\n     vis.visit_span(span);\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     smallvec![fp]\n }\n \n pub fn noop_visit_use_tree<T: MutVisitor>(use_tree: &mut UseTree, vis: &mut T) {\n     let UseTree { prefix, kind, span } = use_tree;\n     vis.visit_path(prefix);\n     match kind {\n-        UseTreeKind::Simple(rename, id1, id2) => {\n-            visit_opt(rename, |rename| vis.visit_ident(rename));\n-            vis.visit_id(id1);\n-            vis.visit_id(id2);\n-        }\n+        UseTreeKind::Simple(rename) => visit_opt(rename, |rename| vis.visit_ident(rename)),\n         UseTreeKind::Nested(items) => {\n             for (tree, id) in items {\n                 vis.visit_use_tree(tree);\n@@ -424,7 +444,7 @@ pub fn noop_visit_use_tree<T: MutVisitor>(use_tree: &mut UseTree, vis: &mut T) {\n \n pub fn noop_flat_map_arm<T: MutVisitor>(mut arm: Arm, vis: &mut T) -> SmallVec<[Arm; 1]> {\n     let Arm { attrs, pat, guard, body, span, id, is_placeholder: _ } = &mut arm;\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     vis.visit_id(id);\n     vis.visit_pat(pat);\n     visit_opt(guard, |guard| vis.visit_expr(guard));\n@@ -439,15 +459,15 @@ pub fn noop_visit_constraint<T: MutVisitor>(\n ) {\n     vis.visit_id(id);\n     vis.visit_ident(ident);\n-    if let Some(ref mut gen_args) = gen_args {\n+    if let Some(gen_args) = gen_args {\n         vis.visit_generic_args(gen_args);\n     }\n     match kind {\n-        AssocConstraintKind::Equality { ref mut term } => match term {\n+        AssocConstraintKind::Equality { term } => match term {\n             Term::Ty(ty) => vis.visit_ty(ty),\n             Term::Const(c) => vis.visit_anon_const(c),\n         },\n-        AssocConstraintKind::Bound { ref mut bounds } => visit_bounds(bounds, vis),\n+        AssocConstraintKind::Bound { bounds } => visit_bounds(bounds, vis),\n     }\n     vis.visit_span(span);\n }\n@@ -459,7 +479,7 @@ pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n         TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err | TyKind::Never | TyKind::CVarArgs => {}\n         TyKind::Slice(ty) => vis.visit_ty(ty),\n         TyKind::Ptr(mt) => vis.visit_mt(mt),\n-        TyKind::Rptr(lt, mt) => {\n+        TyKind::Ref(lt, mt) => {\n             visit_opt(lt, |lt| noop_visit_lifetime(lt, vis));\n             vis.visit_mt(mt);\n         }\n@@ -470,7 +490,7 @@ pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n             vis.visit_fn_decl(decl);\n             vis.visit_span(decl_span);\n         }\n-        TyKind::Tup(tys) => visit_vec(tys, |ty| vis.visit_ty(ty)),\n+        TyKind::Tup(tys) => visit_thin_vec(tys, |ty| vis.visit_ty(ty)),\n         TyKind::Paren(ty) => vis.visit_ty(ty),\n         TyKind::Path(qself, path) => {\n             vis.visit_qself(qself);\n@@ -507,7 +527,7 @@ pub fn noop_flat_map_variant<T: MutVisitor>(\n     let Variant { ident, vis, attrs, id, data, disr_expr, span, is_placeholder: _ } = &mut variant;\n     visitor.visit_ident(ident);\n     visitor.visit_vis(vis);\n-    visit_thin_attrs(attrs, visitor);\n+    visit_attrs(attrs, visitor);\n     visitor.visit_id(id);\n     visitor.visit_variant_data(data);\n     visit_opt(disr_expr, |disr_expr| visitor.visit_anon_const(disr_expr));\n@@ -529,8 +549,9 @@ pub fn noop_visit_path<T: MutVisitor>(Path { segments, span, tokens }: &mut Path\n     visit_lazy_tts(tokens, vis);\n }\n \n-pub fn noop_visit_qself<T: MutVisitor>(qself: &mut Option<QSelf>, vis: &mut T) {\n-    visit_opt(qself, |QSelf { ty, path_span, position: _ }| {\n+pub fn noop_visit_qself<T: MutVisitor>(qself: &mut Option<P<QSelf>>, vis: &mut T) {\n+    visit_opt(qself, |qself| {\n+        let QSelf { ty, path_span, position: _ } = &mut **qself;\n         vis.visit_ty(ty);\n         vis.visit_span(path_span);\n     })\n@@ -556,7 +577,7 @@ pub fn noop_visit_angle_bracketed_parameter_data<T: MutVisitor>(\n     vis: &mut T,\n ) {\n     let AngleBracketedArgs { args, span } = data;\n-    visit_vec(args, |arg| match arg {\n+    visit_thin_vec(args, |arg| match arg {\n         AngleBracketedArg::Arg(arg) => vis.visit_generic_arg(arg),\n         AngleBracketedArg::Constraint(constraint) => vis.visit_constraint(constraint),\n     });\n@@ -568,7 +589,7 @@ pub fn noop_visit_parenthesized_parameter_data<T: MutVisitor>(\n     vis: &mut T,\n ) {\n     let ParenthesizedArgs { inputs, output, span, .. } = args;\n-    visit_vec(inputs, |input| vis.visit_ty(input));\n+    visit_thin_vec(inputs, |input| vis.visit_ty(input));\n     noop_visit_fn_ret_ty(output, vis);\n     vis.visit_span(span);\n }\n@@ -589,16 +610,18 @@ pub fn noop_visit_local<T: MutVisitor>(local: &mut P<Local>, vis: &mut T) {\n         }\n     }\n     vis.visit_span(span);\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     visit_lazy_tts(tokens, vis);\n }\n \n pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n     let Attribute { kind, id: _, style: _, span } = attr;\n     match kind {\n-        AttrKind::Normal(AttrItem { path, args, tokens }, attr_tokens) => {\n+        AttrKind::Normal(normal) => {\n+            let NormalAttr { item: AttrItem { path, args, tokens }, tokens: attr_tokens } =\n+                &mut **normal;\n             vis.visit_path(path);\n-            visit_mac_args(args, vis);\n+            visit_attr_args(args, vis);\n             visit_lazy_tts(tokens, vis);\n             visit_lazy_tts(attr_tokens, vis);\n         }\n@@ -608,28 +631,28 @@ pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n }\n \n pub fn noop_visit_mac<T: MutVisitor>(mac: &mut MacCall, vis: &mut T) {\n-    let MacCall { path, args, prior_type_ascription: _ } = mac;\n+    let MacCall { path, args } = mac;\n     vis.visit_path(path);\n-    visit_mac_args(args, vis);\n+    visit_delim_args(args, vis);\n }\n \n pub fn noop_visit_macro_def<T: MutVisitor>(macro_def: &mut MacroDef, vis: &mut T) {\n     let MacroDef { body, macro_rules: _ } = macro_def;\n-    visit_mac_args(body, vis);\n+    visit_delim_args(body, vis);\n }\n \n pub fn noop_visit_meta_list_item<T: MutVisitor>(li: &mut NestedMetaItem, vis: &mut T) {\n     match li {\n         NestedMetaItem::MetaItem(mi) => vis.visit_meta_item(mi),\n-        NestedMetaItem::Literal(_lit) => {}\n+        NestedMetaItem::Lit(_lit) => {}\n     }\n }\n \n pub fn noop_visit_meta_item<T: MutVisitor>(mi: &mut MetaItem, vis: &mut T) {\n     let MetaItem { path: _, kind, span } = mi;\n     match kind {\n         MetaItemKind::Word => {}\n-        MetaItemKind::List(mis) => visit_vec(mis, |mi| vis.visit_meta_list_item(mi)),\n+        MetaItemKind::List(mis) => visit_thin_vec(mis, |mi| vis.visit_meta_list_item(mi)),\n         MetaItemKind::NameValue(_s) => {}\n     }\n     vis.visit_span(span);\n@@ -638,29 +661,29 @@ pub fn noop_visit_meta_item<T: MutVisitor>(mi: &mut MetaItem, vis: &mut T) {\n pub fn noop_flat_map_param<T: MutVisitor>(mut param: Param, vis: &mut T) -> SmallVec<[Param; 1]> {\n     let Param { attrs, id, pat, span, ty, is_placeholder: _ } = &mut param;\n     vis.visit_id(id);\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     vis.visit_pat(pat);\n     vis.visit_span(span);\n     vis.visit_ty(ty);\n     smallvec![param]\n }\n \n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n-pub fn visit_attr_annotated_tt<T: MutVisitor>(tt: &mut AttrAnnotatedTokenTree, vis: &mut T) {\n+pub fn visit_attr_tt<T: MutVisitor>(tt: &mut AttrTokenTree, vis: &mut T) {\n     match tt {\n-        AttrAnnotatedTokenTree::Token(token) => {\n+        AttrTokenTree::Token(token, _) => {\n             visit_token(token, vis);\n         }\n-        AttrAnnotatedTokenTree::Delimited(DelimSpan { open, close }, _delim, tts) => {\n+        AttrTokenTree::Delimited(DelimSpan { open, close }, _delim, tts) => {\n             vis.visit_span(open);\n             vis.visit_span(close);\n-            visit_attr_annotated_tts(tts, vis);\n+            visit_attr_tts(tts, vis);\n         }\n-        AttrAnnotatedTokenTree::Attributes(data) => {\n+        AttrTokenTree::Attributes(data) => {\n             for attr in &mut *data.attrs {\n                 match &mut attr.kind {\n-                    AttrKind::Normal(_, attr_tokens) => {\n-                        visit_lazy_tts(attr_tokens, vis);\n+                    AttrKind::Normal(normal) => {\n+                        visit_lazy_tts(&mut normal.tokens, vis);\n                     }\n                     AttrKind::DocComment(..) => {\n                         vis.visit_span(&mut attr.span);\n@@ -675,7 +698,7 @@ pub fn visit_attr_annotated_tt<T: MutVisitor>(tt: &mut AttrAnnotatedTokenTree, v\n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n pub fn visit_tt<T: MutVisitor>(tt: &mut TokenTree, vis: &mut T) {\n     match tt {\n-        TokenTree::Token(token) => {\n+        TokenTree::Token(token, _) => {\n             visit_token(token, vis);\n         }\n         TokenTree::Delimited(DelimSpan { open, close }, _delim, tts) => {\n@@ -690,38 +713,38 @@ pub fn visit_tt<T: MutVisitor>(tt: &mut TokenTree, vis: &mut T) {\n pub fn visit_tts<T: MutVisitor>(TokenStream(tts): &mut TokenStream, vis: &mut T) {\n     if T::VISIT_TOKENS && !tts.is_empty() {\n         let tts = Lrc::make_mut(tts);\n-        visit_vec(tts, |(tree, _is_joint)| visit_tt(tree, vis));\n+        visit_vec(tts, |tree| visit_tt(tree, vis));\n     }\n }\n \n-pub fn visit_attr_annotated_tts<T: MutVisitor>(\n-    AttrAnnotatedTokenStream(tts): &mut AttrAnnotatedTokenStream,\n-    vis: &mut T,\n-) {\n+pub fn visit_attr_tts<T: MutVisitor>(AttrTokenStream(tts): &mut AttrTokenStream, vis: &mut T) {\n     if T::VISIT_TOKENS && !tts.is_empty() {\n         let tts = Lrc::make_mut(tts);\n-        visit_vec(tts, |(tree, _is_joint)| visit_attr_annotated_tt(tree, vis));\n+        visit_vec(tts, |tree| visit_attr_tt(tree, vis));\n     }\n }\n \n-pub fn visit_lazy_tts_opt_mut<T: MutVisitor>(lazy_tts: Option<&mut LazyTokenStream>, vis: &mut T) {\n+pub fn visit_lazy_tts_opt_mut<T: MutVisitor>(\n+    lazy_tts: Option<&mut LazyAttrTokenStream>,\n+    vis: &mut T,\n+) {\n     if T::VISIT_TOKENS {\n         if let Some(lazy_tts) = lazy_tts {\n-            let mut tts = lazy_tts.create_token_stream();\n-            visit_attr_annotated_tts(&mut tts, vis);\n-            *lazy_tts = LazyTokenStream::new(tts);\n+            let mut tts = lazy_tts.to_attr_token_stream();\n+            visit_attr_tts(&mut tts, vis);\n+            *lazy_tts = LazyAttrTokenStream::new(tts);\n         }\n     }\n }\n \n-pub fn visit_lazy_tts<T: MutVisitor>(lazy_tts: &mut Option<LazyTokenStream>, vis: &mut T) {\n+pub fn visit_lazy_tts<T: MutVisitor>(lazy_tts: &mut Option<LazyAttrTokenStream>, vis: &mut T) {\n     visit_lazy_tts_opt_mut(lazy_tts.as_mut(), vis);\n }\n \n+/// Applies ident visitor if it's an ident; applies other visits to interpolated nodes.\n+/// In practice the ident part is not actually used by specific visitors right now,\n+/// but there's a test below checking that it works.\n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n-// Applies ident visitor if it's an ident; applies other visits to interpolated nodes.\n-// In practice the ident part is not actually used by specific visitors right now,\n-// but there's a test below checking that it works.\n pub fn visit_token<T: MutVisitor>(t: &mut Token, vis: &mut T) {\n     let Token { kind, span } = t;\n     match kind {\n@@ -733,8 +756,7 @@ pub fn visit_token<T: MutVisitor>(t: &mut Token, vis: &mut T) {\n             return; // Avoid visiting the span for the second time.\n         }\n         token::Interpolated(nt) => {\n-            let mut nt = Lrc::make_mut(nt);\n-            visit_nonterminal(&mut nt, vis);\n+            visit_nonterminal(Lrc::make_mut(nt), vis);\n         }\n         _ => {}\n     }\n@@ -789,7 +811,7 @@ pub fn visit_nonterminal<T: MutVisitor>(nt: &mut token::Nonterminal, vis: &mut T\n         token::NtMeta(item) => {\n             let AttrItem { path, args, tokens } = item.deref_mut();\n             vis.visit_path(path);\n-            visit_mac_args(args, vis);\n+            visit_attr_args(args, vis);\n             visit_lazy_tts(tokens, vis);\n         }\n         token::NtPath(path) => vis.visit_path(path),\n@@ -833,9 +855,7 @@ pub fn noop_visit_closure_binder<T: MutVisitor>(binder: &mut ClosureBinder, vis:\n     match binder {\n         ClosureBinder::NotPresent => {}\n         ClosureBinder::For { span: _, generic_params } => {\n-            let mut vec = std::mem::take(generic_params).into_vec();\n-            vec.flat_map_in_place(|param| vis.flat_map_generic_param(param));\n-            *generic_params = P::from_vec(vec);\n+            generic_params.flat_map_in_place(|param| vis.flat_map_generic_param(param));\n         }\n     }\n }\n@@ -877,10 +897,10 @@ pub fn noop_flat_map_generic_param<T: MutVisitor>(\n     let GenericParam { id, ident, attrs, bounds, kind, colon_span, is_placeholder: _ } = &mut param;\n     vis.visit_id(id);\n     vis.visit_ident(ident);\n-    if let Some(ref mut colon_span) = colon_span {\n+    if let Some(colon_span) = colon_span {\n         vis.visit_span(colon_span);\n     }\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     visit_vec(bounds, |bound| noop_visit_param_bound(bound, vis));\n     match kind {\n         GenericParamKind::Lifetime => {}\n@@ -913,7 +933,7 @@ pub fn noop_visit_generics<T: MutVisitor>(generics: &mut Generics, vis: &mut T)\n \n pub fn noop_visit_where_clause<T: MutVisitor>(wc: &mut WhereClause, vis: &mut T) {\n     let WhereClause { has_where_token: _, predicates, span } = wc;\n-    visit_vec(predicates, |predicate| vis.visit_where_predicate(predicate));\n+    visit_thin_vec(predicates, |predicate| vis.visit_where_predicate(predicate));\n     vis.visit_span(span);\n }\n \n@@ -933,8 +953,7 @@ pub fn noop_visit_where_predicate<T: MutVisitor>(pred: &mut WherePredicate, vis:\n             visit_vec(bounds, |bound| noop_visit_param_bound(bound, vis));\n         }\n         WherePredicate::EqPredicate(ep) => {\n-            let WhereEqPredicate { id, span, lhs_ty, rhs_ty } = ep;\n-            vis.visit_id(id);\n+            let WhereEqPredicate { span, lhs_ty, rhs_ty } = ep;\n             vis.visit_span(span);\n             vis.visit_ty(lhs_ty);\n             vis.visit_ty(rhs_ty);\n@@ -977,7 +996,7 @@ pub fn noop_flat_map_field_def<T: MutVisitor>(\n     visitor.visit_vis(vis);\n     visitor.visit_id(id);\n     visitor.visit_ty(ty);\n-    visit_thin_attrs(attrs, visitor);\n+    visit_attrs(attrs, visitor);\n     smallvec![fd]\n }\n \n@@ -990,7 +1009,7 @@ pub fn noop_flat_map_expr_field<T: MutVisitor>(\n     vis.visit_expr(expr);\n     vis.visit_id(id);\n     vis.visit_span(span);\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     smallvec![f]\n }\n \n@@ -1010,14 +1029,12 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n     match kind {\n         ItemKind::ExternCrate(_orig_name) => {}\n         ItemKind::Use(use_tree) => vis.visit_use_tree(use_tree),\n-        ItemKind::Static(ty, _, expr) => {\n+        ItemKind::Static(box StaticItem { ty, mutability: _, expr }) => {\n             vis.visit_ty(ty);\n             visit_opt(expr, |expr| vis.visit_expr(expr));\n         }\n-        ItemKind::Const(defaultness, ty, expr) => {\n-            visit_defaultness(defaultness, vis);\n-            vis.visit_ty(ty);\n-            visit_opt(expr, |expr| vis.visit_expr(expr));\n+        ItemKind::Const(item) => {\n+            visit_const_item(item, vis);\n         }\n         ItemKind::Fn(box Fn { defaultness, generics, sig, body }) => {\n             visit_defaultness(defaultness, vis);\n@@ -1100,18 +1117,16 @@ pub fn noop_flat_map_assoc_item<T: MutVisitor>(\n     visitor.visit_vis(vis);\n     visit_attrs(attrs, visitor);\n     match kind {\n-        AssocItemKind::Const(defaultness, ty, expr) => {\n-            visit_defaultness(defaultness, visitor);\n-            visitor.visit_ty(ty);\n-            visit_opt(expr, |expr| visitor.visit_expr(expr));\n+        AssocItemKind::Const(item) => {\n+            visit_const_item(item, visitor);\n         }\n         AssocItemKind::Fn(box Fn { defaultness, generics, sig, body }) => {\n             visit_defaultness(defaultness, visitor);\n             visitor.visit_generics(generics);\n             visit_fn_sig(sig, visitor);\n             visit_opt(body, |body| visitor.visit_block(body));\n         }\n-        AssocItemKind::TyAlias(box TyAlias {\n+        AssocItemKind::Type(box TyAlias {\n             defaultness,\n             generics,\n             where_clauses,\n@@ -1133,6 +1148,15 @@ pub fn noop_flat_map_assoc_item<T: MutVisitor>(\n     smallvec![item]\n }\n \n+fn visit_const_item<T: MutVisitor>(\n+    ConstItem { defaultness, ty, expr }: &mut ConstItem,\n+    visitor: &mut T,\n+) {\n+    visit_defaultness(defaultness, visitor);\n+    visitor.visit_ty(ty);\n+    visit_opt(expr, |expr| visitor.visit_expr(expr));\n+}\n+\n pub fn noop_visit_fn_header<T: MutVisitor>(header: &mut FnHeader, vis: &mut T) {\n     let FnHeader { unsafety, asyncness, constness, ext: _ } = header;\n     visit_constness(constness, vis);\n@@ -1222,7 +1246,7 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n         PatKind::TupleStruct(qself, path, elems) => {\n             vis.visit_qself(qself);\n             vis.visit_path(path);\n-            visit_vec(elems, |elem| vis.visit_pat(elem));\n+            visit_thin_vec(elems, |elem| vis.visit_pat(elem));\n         }\n         PatKind::Path(qself, path) => {\n             vis.visit_qself(qself);\n@@ -1241,7 +1265,7 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n             vis.visit_span(span);\n         }\n         PatKind::Tuple(elems) | PatKind::Slice(elems) | PatKind::Or(elems) => {\n-            visit_vec(elems, |elem| vis.visit_pat(elem))\n+            visit_thin_vec(elems, |elem| vis.visit_pat(elem))\n         }\n         PatKind::Paren(inner) => vis.visit_pat(inner),\n         PatKind::MacCall(mac) => vis.visit_mac_call(mac),\n@@ -1283,30 +1307,44 @@ pub fn noop_visit_inline_asm_sym<T: MutVisitor>(\n     vis.visit_path(path);\n }\n \n+pub fn noop_visit_format_args<T: MutVisitor>(fmt: &mut FormatArgs, vis: &mut T) {\n+    for arg in fmt.arguments.all_args_mut() {\n+        if let FormatArgumentKind::Named(name) = &mut arg.kind {\n+            vis.visit_ident(name);\n+        }\n+        vis.visit_expr(&mut arg.expr);\n+    }\n+}\n+\n pub fn noop_visit_expr<T: MutVisitor>(\n     Expr { kind, id, span, attrs, tokens }: &mut Expr,\n     vis: &mut T,\n ) {\n     match kind {\n-        ExprKind::Box(expr) => vis.visit_expr(expr),\n-        ExprKind::Array(exprs) => visit_exprs(exprs, vis),\n+        ExprKind::Array(exprs) => visit_thin_exprs(exprs, vis),\n         ExprKind::ConstBlock(anon_const) => {\n             vis.visit_anon_const(anon_const);\n         }\n         ExprKind::Repeat(expr, count) => {\n             vis.visit_expr(expr);\n             vis.visit_anon_const(count);\n         }\n-        ExprKind::Tup(exprs) => visit_exprs(exprs, vis),\n+        ExprKind::Tup(exprs) => visit_thin_exprs(exprs, vis),\n         ExprKind::Call(f, args) => {\n             vis.visit_expr(f);\n-            visit_exprs(args, vis);\n+            visit_thin_exprs(args, vis);\n         }\n-        ExprKind::MethodCall(PathSegment { ident, id, args }, exprs, span) => {\n+        ExprKind::MethodCall(box MethodCall {\n+            seg: PathSegment { ident, id, args: seg_args },\n+            receiver,\n+            args: call_args,\n+            span,\n+        }) => {\n             vis.visit_ident(ident);\n             vis.visit_id(id);\n-            visit_opt(args, |args| vis.visit_generic_args(args));\n-            visit_exprs(exprs, vis);\n+            visit_opt(seg_args, |args| vis.visit_generic_args(args));\n+            vis.visit_method_receiver_expr(receiver);\n+            visit_thin_exprs(call_args, vis);\n             vis.visit_span(span);\n         }\n         ExprKind::Binary(_binop, lhs, rhs) => {\n@@ -1343,30 +1381,44 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             vis.visit_block(body);\n             visit_opt(label, |label| vis.visit_label(label));\n         }\n-        ExprKind::Loop(body, label) => {\n+        ExprKind::Loop(body, label, span) => {\n             vis.visit_block(body);\n             visit_opt(label, |label| vis.visit_label(label));\n+            vis.visit_span(span);\n         }\n         ExprKind::Match(expr, arms) => {\n             vis.visit_expr(expr);\n             arms.flat_map_in_place(|arm| vis.flat_map_arm(arm));\n         }\n-        ExprKind::Closure(binder, _capture_by, asyncness, _movability, decl, body, span) => {\n+        ExprKind::Closure(box Closure {\n+            binder,\n+            capture_clause: _,\n+            constness,\n+            asyncness,\n+            movability: _,\n+            fn_decl,\n+            body,\n+            fn_decl_span,\n+            fn_arg_span: _,\n+        }) => {\n             vis.visit_closure_binder(binder);\n+            visit_constness(constness, vis);\n             vis.visit_asyncness(asyncness);\n-            vis.visit_fn_decl(decl);\n+            vis.visit_fn_decl(fn_decl);\n             vis.visit_expr(body);\n-            vis.visit_span(span);\n+            vis.visit_span(fn_decl_span);\n         }\n         ExprKind::Block(blk, label) => {\n             vis.visit_block(blk);\n             visit_opt(label, |label| vis.visit_label(label));\n         }\n-        ExprKind::Async(_capture_by, node_id, body) => {\n-            vis.visit_id(node_id);\n+        ExprKind::Async(_capture_by, body) => {\n             vis.visit_block(body);\n         }\n-        ExprKind::Await(expr) => vis.visit_expr(expr),\n+        ExprKind::Await(expr, await_kw_span) => {\n+            vis.visit_expr(expr);\n+            vis.visit_span(await_kw_span);\n+        }\n         ExprKind::Assign(el, er, _) => {\n             vis.visit_expr(el);\n             vis.visit_expr(er);\n@@ -1406,6 +1458,13 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             visit_opt(expr, |expr| vis.visit_expr(expr));\n         }\n         ExprKind::InlineAsm(asm) => vis.visit_inline_asm(asm),\n+        ExprKind::FormatArgs(fmt) => vis.visit_format_args(fmt),\n+        ExprKind::OffsetOf(container, fields) => {\n+            vis.visit_ty(container);\n+            for field in fields.iter_mut() {\n+                vis.visit_ident(field);\n+            }\n+        }\n         ExprKind::MacCall(mac) => vis.visit_mac_call(mac),\n         ExprKind::Struct(se) => {\n             let StructExpr { qself, path, fields, rest } = se.deref_mut();\n@@ -1426,11 +1485,11 @@ pub fn noop_visit_expr<T: MutVisitor>(\n         }\n         ExprKind::Try(expr) => vis.visit_expr(expr),\n         ExprKind::TryBlock(body) => vis.visit_block(body),\n-        ExprKind::Lit(_) | ExprKind::Err => {}\n+        ExprKind::Lit(_) | ExprKind::IncludedBytes(..) | ExprKind::Err => {}\n     }\n     vis.visit_id(id);\n     vis.visit_span(span);\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     visit_lazy_tts(tokens, vis);\n }\n \n@@ -1476,7 +1535,7 @@ pub fn noop_flat_map_stmt_kind<T: MutVisitor>(\n         StmtKind::MacCall(mut mac) => {\n             let MacCallStmt { mac: mac_, style: _, attrs, tokens } = mac.deref_mut();\n             vis.visit_mac_call(mac_);\n-            visit_thin_attrs(attrs, vis);\n+            visit_attrs(attrs, vis);\n             visit_lazy_tts(tokens, vis);\n             smallvec![StmtKind::MacCall(mac)]\n         }\n@@ -1486,7 +1545,7 @@ pub fn noop_flat_map_stmt_kind<T: MutVisitor>(\n pub fn noop_visit_vis<T: MutVisitor>(visibility: &mut Visibility, vis: &mut T) {\n     match &mut visibility.kind {\n         VisibilityKind::Public | VisibilityKind::Inherited => {}\n-        VisibilityKind::Restricted { path, id } => {\n+        VisibilityKind::Restricted { path, id, shorthand: _ } => {\n             vis.visit_path(path);\n             vis.visit_id(id);\n         }\n@@ -1511,12 +1570,6 @@ impl<T: DummyAstNode + 'static> DummyAstNode for P<T> {\n     }\n }\n \n-impl<T> DummyAstNode for ThinVec<T> {\n-    fn dummy() -> Self {\n-        Default::default()\n-    }\n-}\n-\n impl DummyAstNode for Item {\n     fn dummy() -> Self {\n         Item {\n@@ -1599,3 +1652,9 @@ impl DummyAstNode for Crate {\n         }\n     }\n }\n+\n+impl<N: DummyAstNode, T: DummyAstNode> DummyAstNode for crate::ast_traits::AstNodeWrapper<N, T> {\n+    fn dummy() -> Self {\n+        crate::ast_traits::AstNodeWrapper::new(N::dummy(), T::dummy())\n+    }\n+}"}, {"sha": "d16741757d1f1e03f8882021f36c4aef39ba2ece", "filename": "compiler/rustc_ast/src/node_id.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -8,15 +8,14 @@ rustc_index::newtype_index! {\n     /// This is later turned into [`DefId`] and `HirId` for the HIR.\n     ///\n     /// [`DefId`]: rustc_span::def_id::DefId\n+    #[debug_format = \"NodeId({})\"]\n     pub struct NodeId {\n-        DEBUG_FORMAT = \"NodeId({})\"\n+        /// The [`NodeId`] used to represent the root of the crate.\n+        const CRATE_NODE_ID = 0;\n     }\n }\n \n-rustc_data_structures::define_id_collections!(NodeMap, NodeSet, NodeId);\n-\n-/// The [`NodeId`] used to represent the root of the crate.\n-pub const CRATE_NODE_ID: NodeId = NodeId::from_u32(0);\n+rustc_data_structures::define_id_collections!(NodeMap, NodeSet, NodeMapEntry, NodeId);\n \n /// When parsing and at the beginning of doing expansions, we initially give all AST nodes\n /// this dummy AST [`NodeId`]. Then, during a later phase of expansion, we renumber them"}, {"sha": "0140fb752bf92f8c9f11c265f5ae99e527abdaa8", "filename": "compiler/rustc_ast/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fptr.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -22,7 +22,6 @@\n //!   Moreover, a switch to, e.g., `P<'a, T>` would be easy and mostly automated.\n \n use std::fmt::{self, Debug, Display};\n-use std::iter::FromIterator;\n use std::ops::{Deref, DerefMut};\n use std::{slice, vec};\n \n@@ -127,7 +126,8 @@ impl<S: Encoder, T: Encodable<S>> Encodable<S> for P<T> {\n }\n \n impl<T> P<[T]> {\n-    pub const fn new() -> P<[T]> {\n+    // FIXME(const-hack) make this const again\n+    pub fn new() -> P<[T]> {\n         P { ptr: Box::default() }\n     }\n "}, {"sha": "6646fa9446fb1c2ac57ac1a515d47c1b24aa16dc", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 160, "deletions": 54, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -5,15 +5,17 @@ pub use TokenKind::*;\n \n use crate::ast;\n use crate::ptr::P;\n+use crate::util::case::Case;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_macros::HashStable_Generic;\n use rustc_span::symbol::{kw, sym};\n+#[cfg_attr(not(bootstrap), allow(hidden_glob_reexports))]\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{self, edition::Edition, Span, DUMMY_SP};\n use std::borrow::Cow;\n-use std::{fmt, mem};\n+use std::fmt;\n \n #[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum CommentKind {\n@@ -58,17 +60,23 @@ pub enum Delimiter {\n     Invisible,\n }\n \n+// Note that the suffix is *not* considered when deciding the `LitKind` in this\n+// type. This means that float literals like `1f32` are classified by this type\n+// as `Int`. Only upon conversion to `ast::LitKind` will such a literal be\n+// given the `Float` kind.\n #[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum LitKind {\n     Bool, // AST only, must never appear in a `Token`\n     Byte,\n     Char,\n-    Integer,\n-    Float,\n+    Integer, // e.g. `1`, `1u8`, `1f32`\n+    Float,   // e.g. `1.`, `1.0`, `1e3f32`\n     Str,\n     StrRaw(u8), // raw string delimited by `n` hash symbols\n     ByteStr,\n     ByteStrRaw(u8), // raw byte string delimited by `n` hash symbols\n+    CStr,\n+    CStrRaw(u8),\n     Err,\n }\n \n@@ -80,31 +88,71 @@ pub struct Lit {\n     pub suffix: Option<Symbol>,\n }\n \n+impl Lit {\n+    pub fn new(kind: LitKind, symbol: Symbol, suffix: Option<Symbol>) -> Lit {\n+        Lit { kind, symbol, suffix }\n+    }\n+\n+    /// Returns `true` if this is semantically a float literal. This includes\n+    /// ones like `1f32` that have an `Integer` kind but a float suffix.\n+    pub fn is_semantic_float(&self) -> bool {\n+        match self.kind {\n+            LitKind::Float => true,\n+            LitKind::Integer => match self.suffix {\n+                Some(sym) => sym == sym::f32 || sym == sym::f64,\n+                None => false,\n+            },\n+            _ => false,\n+        }\n+    }\n+\n+    /// Keep this in sync with `Token::can_begin_literal_or_bool` excluding unary negation.\n+    pub fn from_token(token: &Token) -> Option<Lit> {\n+        match token.uninterpolate().kind {\n+            Ident(name, false) if name.is_bool_lit() => {\n+                Some(Lit::new(Bool, name, None))\n+            }\n+            Literal(token_lit) => Some(token_lit),\n+            Interpolated(ref nt)\n+                if let NtExpr(expr) | NtLiteral(expr) = &**nt\n+                && let ast::ExprKind::Lit(token_lit) = expr.kind =>\n+            {\n+                Some(token_lit)\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+\n impl fmt::Display for Lit {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let Lit { kind, symbol, suffix } = *self;\n         match kind {\n-            Byte => write!(f, \"b'{}'\", symbol)?,\n-            Char => write!(f, \"'{}'\", symbol)?,\n-            Str => write!(f, \"\\\"{}\\\"\", symbol)?,\n+            Byte => write!(f, \"b'{symbol}'\")?,\n+            Char => write!(f, \"'{symbol}'\")?,\n+            Str => write!(f, \"\\\"{symbol}\\\"\")?,\n             StrRaw(n) => write!(\n                 f,\n                 \"r{delim}\\\"{string}\\\"{delim}\",\n                 delim = \"#\".repeat(n as usize),\n                 string = symbol\n             )?,\n-            ByteStr => write!(f, \"b\\\"{}\\\"\", symbol)?,\n+            ByteStr => write!(f, \"b\\\"{symbol}\\\"\")?,\n             ByteStrRaw(n) => write!(\n                 f,\n                 \"br{delim}\\\"{string}\\\"{delim}\",\n                 delim = \"#\".repeat(n as usize),\n                 string = symbol\n             )?,\n-            Integer | Float | Bool | Err => write!(f, \"{}\", symbol)?,\n+            CStr => write!(f, \"c\\\"{symbol}\\\"\")?,\n+            CStrRaw(n) => {\n+                write!(f, \"cr{delim}\\\"{symbol}\\\"{delim}\", delim = \"#\".repeat(n as usize))?\n+            }\n+            Integer | Float | Bool | Err => write!(f, \"{symbol}\")?,\n         }\n \n         if let Some(suffix) = suffix {\n-            write!(f, \"{}\", suffix)?;\n+            write!(f, \"{suffix}\")?;\n         }\n \n         Ok(())\n@@ -129,6 +177,7 @@ impl LitKind {\n             Float => \"float\",\n             Str | StrRaw(..) => \"string\",\n             ByteStr | ByteStrRaw(..) => \"byte string\",\n+            CStr | CStrRaw(..) => \"C string\",\n             Err => \"error\",\n         }\n     }\n@@ -138,12 +187,6 @@ impl LitKind {\n     }\n }\n \n-impl Lit {\n-    pub fn new(kind: LitKind, symbol: Symbol, suffix: Option<Symbol>) -> Lit {\n-        Lit { kind, symbol, suffix }\n-    }\n-}\n-\n pub fn ident_can_begin_expr(name: Symbol, span: Span, is_raw: bool) -> bool {\n     let ident_token = Token::new(Ident(name, is_raw), span);\n \n@@ -256,10 +299,6 @@ pub enum TokenKind {\n     Eof,\n }\n \n-// `TokenKind` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(TokenKind, 16);\n-\n #[derive(Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct Token {\n     pub kind: TokenKind,\n@@ -271,9 +310,9 @@ impl TokenKind {\n         Literal(Lit::new(kind, symbol, suffix))\n     }\n \n-    // An approximation to proc-macro-style single-character operators used by rustc parser.\n-    // If the operator token can be broken into two tokens, the first of which is single-character,\n-    // then this function performs that operation, otherwise it returns `None`.\n+    /// An approximation to proc-macro-style single-character operators used by rustc parser.\n+    /// If the operator token can be broken into two tokens, the first of which is single-character,\n+    /// then this function performs that operation, otherwise it returns `None`.\n     pub fn break_two_token_op(&self) -> Option<(TokenKind, TokenKind)> {\n         Some(match *self {\n             Le => (Lt, Eq),\n@@ -335,11 +374,6 @@ impl Token {\n         Token::new(Ident(ident.name, ident.is_raw_guess()), ident.span)\n     }\n \n-    /// Return this token by value and leave a dummy token in its place.\n-    pub fn take(&mut self) -> Self {\n-        mem::replace(self, Token::dummy())\n-    }\n-\n     /// For interpolated tokens, returns a span of the fragment to which the interpolated\n     /// token refers. For all other tokens this is just a regular span.\n     /// It is particularly important to use this for identifiers and lifetimes\n@@ -353,18 +387,19 @@ impl Token {\n         }\n     }\n \n+    pub fn is_range_separator(&self) -> bool {\n+        [DotDot, DotDotDot, DotDotEq].contains(&self.kind)\n+    }\n+\n     pub fn is_op(&self) -> bool {\n-        !matches!(\n-            self.kind,\n-            OpenDelim(..)\n-                | CloseDelim(..)\n-                | Literal(..)\n-                | DocComment(..)\n-                | Ident(..)\n-                | Lifetime(..)\n-                | Interpolated(..)\n-                | Eof\n-        )\n+        match self.kind {\n+            Eq | Lt | Le | EqEq | Ne | Ge | Gt | AndAnd | OrOr | Not | Tilde | BinOp(_)\n+            | BinOpEq(_) | At | Dot | DotDot | DotDotDot | DotDotEq | Comma | Semi | Colon\n+            | ModSep | RArrow | LArrow | FatArrow | Pound | Dollar | Question | SingleQuote => true,\n+\n+            OpenDelim(..) | CloseDelim(..) | Literal(..) | DocComment(..) | Ident(..)\n+            | Lifetime(..) | Interpolated(..) | Eof => false,\n+        }\n     }\n \n     pub fn is_like_plus(&self) -> bool {\n@@ -398,6 +433,30 @@ impl Token {\n         }\n     }\n \n+    /// Returns `true` if the token can appear at the start of an pattern.\n+    ///\n+    /// Shamelessly borrowed from `can_begin_expr`, only used for diagnostics right now.\n+    pub fn can_begin_pattern(&self) -> bool {\n+        match self.uninterpolate().kind {\n+            Ident(name, is_raw)              =>\n+                ident_can_begin_expr(name, self.span, is_raw), // value name or keyword\n+            | OpenDelim(Delimiter::Bracket | Delimiter::Parenthesis)  // tuple or array\n+            | Literal(..)                        // literal\n+            | BinOp(Minus)                       // unary minus\n+            | BinOp(And)                         // reference\n+            | AndAnd                             // double reference\n+            // DotDotDot is no longer supported\n+            | DotDot | DotDotDot | DotDotEq      // ranges\n+            | Lt | BinOp(Shl)                    // associated path\n+            | ModSep                    => true, // global path\n+            Interpolated(ref nt) => matches!(**nt, NtLiteral(..) |\n+                NtPat(..)     |\n+                NtBlock(..)   |\n+                NtPath(..)),\n+            _ => false,\n+        }\n+    }\n+\n     /// Returns `true` if the token can appear at the start of a type.\n     pub fn can_begin_type(&self) -> bool {\n         match self.uninterpolate().kind {\n@@ -436,6 +495,31 @@ impl Token {\n             || self == &OpenDelim(Delimiter::Parenthesis)\n     }\n \n+    /// Returns `true` if the token can appear at the start of an item.\n+    pub fn can_begin_item(&self) -> bool {\n+        match self.kind {\n+            Ident(name, _) => [\n+                kw::Fn,\n+                kw::Use,\n+                kw::Struct,\n+                kw::Enum,\n+                kw::Pub,\n+                kw::Trait,\n+                kw::Extern,\n+                kw::Impl,\n+                kw::Unsafe,\n+                kw::Const,\n+                kw::Static,\n+                kw::Union,\n+                kw::Macro,\n+                kw::Mod,\n+                kw::Type,\n+            ]\n+            .contains(&name),\n+            _ => false,\n+        }\n+    }\n+\n     /// Returns `true` if the token is any literal.\n     pub fn is_lit(&self) -> bool {\n         matches!(self.kind, Literal(..))\n@@ -466,10 +550,10 @@ impl Token {\n         }\n     }\n \n-    // A convenience function for matching on identifiers during parsing.\n-    // Turns interpolated identifier (`$i: ident`) or lifetime (`$l: lifetime`) token\n-    // into the regular identifier or lifetime token it refers to,\n-    // otherwise returns the original token.\n+    /// A convenience function for matching on identifiers during parsing.\n+    /// Turns interpolated identifier (`$i: ident`) or lifetime (`$l: lifetime`) token\n+    /// into the regular identifier or lifetime token it refers to,\n+    /// otherwise returns the original token.\n     pub fn uninterpolate(&self) -> Cow<'_, Token> {\n         match &self.kind {\n             Interpolated(nt) => match **nt {\n@@ -524,22 +608,23 @@ impl Token {\n     /// Returns `true` if the token is an identifier whose name is the given\n     /// string slice.\n     pub fn is_ident_named(&self, name: Symbol) -> bool {\n-        self.ident().map_or(false, |(ident, _)| ident.name == name)\n+        self.ident().is_some_and(|(ident, _)| ident.name == name)\n     }\n \n     /// Returns `true` if the token is an interpolated path.\n     fn is_path(&self) -> bool {\n-        if let Interpolated(ref nt) = self.kind && let NtPath(..) = **nt {\n+        if let Interpolated(nt) = &self.kind && let NtPath(..) = **nt {\n             return true;\n         }\n+\n         false\n     }\n \n     /// Would `maybe_whole_expr` in `parser.rs` return `Ok(..)`?\n     /// That is, is this a pre-parsed expression dropped into the token stream\n     /// (which happens while parsing the result of macro expansion)?\n     pub fn is_whole_expr(&self) -> bool {\n-        if let Interpolated(ref nt) = self.kind\n+        if let Interpolated(nt) = &self.kind\n             && let NtExpr(_) | NtLiteral(_) | NtPath(_) | NtBlock(_) = **nt\n         {\n             return true;\n@@ -548,11 +633,12 @@ impl Token {\n         false\n     }\n \n-    // Is the token an interpolated block (`$b:block`)?\n+    /// Is the token an interpolated block (`$b:block`)?\n     pub fn is_whole_block(&self) -> bool {\n-        if let Interpolated(ref nt) = self.kind && let NtBlock(..) = **nt {\n+        if let Interpolated(nt) = &self.kind && let NtBlock(..) = **nt {\n             return true;\n         }\n+\n         false\n     }\n \n@@ -578,12 +664,21 @@ impl Token {\n         self.is_non_raw_ident_where(|id| id.name == kw)\n     }\n \n+    /// Returns `true` if the token is a given keyword, `kw` or if `case` is `Insensitive` and this token is an identifier equal to `kw` ignoring the case.\n+    pub fn is_keyword_case(&self, kw: Symbol, case: Case) -> bool {\n+        self.is_keyword(kw)\n+            || (case == Case::Insensitive\n+                && self.is_non_raw_ident_where(|id| {\n+                    id.name.as_str().to_lowercase() == kw.as_str().to_lowercase()\n+                }))\n+    }\n+\n     pub fn is_path_segment_keyword(&self) -> bool {\n         self.is_non_raw_ident_where(Ident::is_path_segment_keyword)\n     }\n \n-    // Returns true for reserved identifiers used internally for elided lifetimes,\n-    // unnamed method parameters, crate root module, error recovery etc.\n+    /// Returns true for reserved identifiers used internally for elided lifetimes,\n+    /// unnamed method parameters, crate root module, error recovery etc.\n     pub fn is_special_ident(&self) -> bool {\n         self.is_non_raw_ident_where(Ident::is_special)\n     }\n@@ -669,7 +764,7 @@ impl Token {\n                 _ => return None,\n             },\n             SingleQuote => match joint.kind {\n-                Ident(name, false) => Lifetime(Symbol::intern(&format!(\"'{}\", name))),\n+                Ident(name, false) => Lifetime(Symbol::intern(&format!(\"'{name}\"))),\n                 _ => return None,\n             },\n \n@@ -684,6 +779,7 @@ impl Token {\n }\n \n impl PartialEq<TokenKind> for Token {\n+    #[inline]\n     fn eq(&self, rhs: &TokenKind) -> bool {\n         self.kind == *rhs\n     }\n@@ -707,10 +803,6 @@ pub enum Nonterminal {\n     NtVis(P<ast::Visibility>),\n }\n \n-// `Nonterminal` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Nonterminal, 16);\n-\n #[derive(Debug, Copy, Clone, PartialEq, Encodable, Decodable)]\n pub enum NonterminalKind {\n     Item,\n@@ -849,3 +941,17 @@ where\n         panic!(\"interpolated tokens should not be present in the HIR\")\n     }\n }\n+\n+// Some types are used a lot. Make sure they don't unintentionally get bigger.\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+mod size_asserts {\n+    use super::*;\n+    use rustc_data_structures::static_assert_size;\n+    // tidy-alphabetical-start\n+    static_assert_size!(Lit, 12);\n+    static_assert_size!(LitKind, 2);\n+    static_assert_size!(Nonterminal, 16);\n+    static_assert_size!(Token, 24);\n+    static_assert_size!(TokenKind, 16);\n+    // tidy-alphabetical-end\n+}"}, {"sha": "db296aa44db2b6edc65f820c55f62132c7bad6c7", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 227, "deletions": 240, "changes": 467, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -41,30 +41,32 @@ use std::{fmt, iter};\n /// Nothing special happens to misnamed or misplaced `SubstNt`s.\n #[derive(Debug, Clone, PartialEq, Encodable, Decodable, HashStable_Generic)]\n pub enum TokenTree {\n-    /// A single token.\n-    Token(Token),\n+    /// A single token. Should never be `OpenDelim` or `CloseDelim`, because\n+    /// delimiters are implicitly represented by `Delimited`.\n+    Token(Token, Spacing),\n     /// A delimited sequence of token trees.\n     Delimited(DelimSpan, Delimiter, TokenStream),\n }\n \n-// Ensure all fields of `TokenTree` is `Send` and `Sync`.\n+// Ensure all fields of `TokenTree` are `DynSend` and `DynSync`.\n #[cfg(parallel_compiler)]\n fn _dummy()\n where\n-    Token: Send + Sync,\n-    DelimSpan: Send + Sync,\n-    Delimiter: Send + Sync,\n-    TokenStream: Send + Sync,\n+    Token: sync::DynSend + sync::DynSync,\n+    Spacing: sync::DynSend + sync::DynSync,\n+    DelimSpan: sync::DynSend + sync::DynSync,\n+    Delimiter: sync::DynSend + sync::DynSync,\n+    TokenStream: sync::DynSend + sync::DynSync,\n {\n }\n \n impl TokenTree {\n     /// Checks if this `TokenTree` is equal to the other, regardless of span information.\n     pub fn eq_unspanned(&self, other: &TokenTree) -> bool {\n         match (self, other) {\n-            (TokenTree::Token(token), TokenTree::Token(token2)) => token.kind == token2.kind,\n+            (TokenTree::Token(token, _), TokenTree::Token(token2, _)) => token.kind == token2.kind,\n             (TokenTree::Delimited(_, delim, tts), TokenTree::Delimited(_, delim2, tts2)) => {\n-                delim == delim2 && tts.eq_unspanned(&tts2)\n+                delim == delim2 && tts.eq_unspanned(tts2)\n             }\n             _ => false,\n         }\n@@ -73,26 +75,34 @@ impl TokenTree {\n     /// Retrieves the `TokenTree`'s span.\n     pub fn span(&self) -> Span {\n         match self {\n-            TokenTree::Token(token) => token.span,\n+            TokenTree::Token(token, _) => token.span,\n             TokenTree::Delimited(sp, ..) => sp.entire(),\n         }\n     }\n \n     /// Modify the `TokenTree`'s span in-place.\n     pub fn set_span(&mut self, span: Span) {\n         match self {\n-            TokenTree::Token(token) => token.span = span,\n+            TokenTree::Token(token, _) => token.span = span,\n             TokenTree::Delimited(dspan, ..) => *dspan = DelimSpan::from_single(span),\n         }\n     }\n \n-    pub fn token(kind: TokenKind, span: Span) -> TokenTree {\n-        TokenTree::Token(Token::new(kind, span))\n+    /// Create a `TokenTree::Token` with alone spacing.\n+    pub fn token_alone(kind: TokenKind, span: Span) -> TokenTree {\n+        TokenTree::Token(Token::new(kind, span), Spacing::Alone)\n+    }\n+\n+    /// Create a `TokenTree::Token` with joint spacing.\n+    pub fn token_joint(kind: TokenKind, span: Span) -> TokenTree {\n+        TokenTree::Token(Token::new(kind, span), Spacing::Joint)\n     }\n \n     pub fn uninterpolate(self) -> TokenTree {\n         match self {\n-            TokenTree::Token(token) => TokenTree::Token(token.uninterpolate().into_owned()),\n+            TokenTree::Token(token, spacing) => {\n+                TokenTree::Token(token.uninterpolate().into_owned(), spacing)\n+            }\n             tt => tt,\n         }\n     }\n@@ -109,12 +119,12 @@ where\n     }\n }\n \n-pub trait CreateTokenStream: sync::Send + sync::Sync {\n-    fn create_token_stream(&self) -> AttrAnnotatedTokenStream;\n+pub trait ToAttrTokenStream: sync::DynSend + sync::DynSync {\n+    fn to_attr_token_stream(&self) -> AttrTokenStream;\n }\n \n-impl CreateTokenStream for AttrAnnotatedTokenStream {\n-    fn create_token_stream(&self) -> AttrAnnotatedTokenStream {\n+impl ToAttrTokenStream for AttrTokenStream {\n+    fn to_attr_token_stream(&self) -> AttrTokenStream {\n         self.clone()\n     }\n }\n@@ -123,101 +133,96 @@ impl CreateTokenStream for AttrAnnotatedTokenStream {\n /// of an actual `TokenStream` until it is needed.\n /// `Box` is here only to reduce the structure size.\n #[derive(Clone)]\n-pub struct LazyTokenStream(Lrc<Box<dyn CreateTokenStream>>);\n+pub struct LazyAttrTokenStream(Lrc<Box<dyn ToAttrTokenStream>>);\n \n-impl LazyTokenStream {\n-    pub fn new(inner: impl CreateTokenStream + 'static) -> LazyTokenStream {\n-        LazyTokenStream(Lrc::new(Box::new(inner)))\n+impl LazyAttrTokenStream {\n+    pub fn new(inner: impl ToAttrTokenStream + 'static) -> LazyAttrTokenStream {\n+        LazyAttrTokenStream(Lrc::new(Box::new(inner)))\n     }\n \n-    pub fn create_token_stream(&self) -> AttrAnnotatedTokenStream {\n-        self.0.create_token_stream()\n+    pub fn to_attr_token_stream(&self) -> AttrTokenStream {\n+        self.0.to_attr_token_stream()\n     }\n }\n \n-impl fmt::Debug for LazyTokenStream {\n+impl fmt::Debug for LazyAttrTokenStream {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"LazyTokenStream({:?})\", self.create_token_stream())\n+        write!(f, \"LazyAttrTokenStream({:?})\", self.to_attr_token_stream())\n     }\n }\n \n-impl<S: Encoder> Encodable<S> for LazyTokenStream {\n+impl<S: Encoder> Encodable<S> for LazyAttrTokenStream {\n     fn encode(&self, s: &mut S) {\n         // Used by AST json printing.\n-        Encodable::encode(&self.create_token_stream(), s);\n+        Encodable::encode(&self.to_attr_token_stream(), s);\n     }\n }\n \n-impl<D: Decoder> Decodable<D> for LazyTokenStream {\n+impl<D: Decoder> Decodable<D> for LazyAttrTokenStream {\n     fn decode(_d: &mut D) -> Self {\n-        panic!(\"Attempted to decode LazyTokenStream\");\n+        panic!(\"Attempted to decode LazyAttrTokenStream\");\n     }\n }\n \n-impl<CTX> HashStable<CTX> for LazyTokenStream {\n+impl<CTX> HashStable<CTX> for LazyAttrTokenStream {\n     fn hash_stable(&self, _hcx: &mut CTX, _hasher: &mut StableHasher) {\n-        panic!(\"Attempted to compute stable hash for LazyTokenStream\");\n+        panic!(\"Attempted to compute stable hash for LazyAttrTokenStream\");\n     }\n }\n \n-/// A `AttrAnnotatedTokenStream` is similar to a `TokenStream`, but with extra\n+/// An `AttrTokenStream` is similar to a `TokenStream`, but with extra\n /// information about the tokens for attribute targets. This is used\n /// during expansion to perform early cfg-expansion, and to process attributes\n /// during proc-macro invocations.\n #[derive(Clone, Debug, Default, Encodable, Decodable)]\n-pub struct AttrAnnotatedTokenStream(pub Lrc<Vec<(AttrAnnotatedTokenTree, Spacing)>>);\n+pub struct AttrTokenStream(pub Lrc<Vec<AttrTokenTree>>);\n \n-/// Like `TokenTree`, but for `AttrAnnotatedTokenStream`\n+/// Like `TokenTree`, but for `AttrTokenStream`.\n #[derive(Clone, Debug, Encodable, Decodable)]\n-pub enum AttrAnnotatedTokenTree {\n-    Token(Token),\n-    Delimited(DelimSpan, Delimiter, AttrAnnotatedTokenStream),\n+pub enum AttrTokenTree {\n+    Token(Token, Spacing),\n+    Delimited(DelimSpan, Delimiter, AttrTokenStream),\n     /// Stores the attributes for an attribute target,\n     /// along with the tokens for that attribute target.\n     /// See `AttributesData` for more information\n     Attributes(AttributesData),\n }\n \n-impl AttrAnnotatedTokenStream {\n-    pub fn new(tokens: Vec<(AttrAnnotatedTokenTree, Spacing)>) -> AttrAnnotatedTokenStream {\n-        AttrAnnotatedTokenStream(Lrc::new(tokens))\n+impl AttrTokenStream {\n+    pub fn new(tokens: Vec<AttrTokenTree>) -> AttrTokenStream {\n+        AttrTokenStream(Lrc::new(tokens))\n     }\n \n-    /// Converts this `AttrAnnotatedTokenStream` to a plain `TokenStream\n-    /// During conversion, `AttrAnnotatedTokenTree::Attributes` get 'flattened'\n+    /// Converts this `AttrTokenStream` to a plain `TokenStream`.\n+    /// During conversion, `AttrTokenTree::Attributes` get 'flattened'\n     /// back to a `TokenStream` of the form `outer_attr attr_target`.\n     /// If there are inner attributes, they are inserted into the proper\n     /// place in the attribute target tokens.\n     pub fn to_tokenstream(&self) -> TokenStream {\n         let trees: Vec<_> = self\n             .0\n             .iter()\n-            .flat_map(|tree| match &tree.0 {\n-                AttrAnnotatedTokenTree::Token(inner) => {\n-                    smallvec![(TokenTree::Token(inner.clone()), tree.1)].into_iter()\n+            .flat_map(|tree| match &tree {\n+                AttrTokenTree::Token(inner, spacing) => {\n+                    smallvec![TokenTree::Token(inner.clone(), *spacing)].into_iter()\n                 }\n-                AttrAnnotatedTokenTree::Delimited(span, delim, stream) => smallvec![(\n-                    TokenTree::Delimited(*span, *delim, stream.to_tokenstream()),\n-                    tree.1,\n-                )]\n-                .into_iter(),\n-                AttrAnnotatedTokenTree::Attributes(data) => {\n+                AttrTokenTree::Delimited(span, delim, stream) => {\n+                    smallvec![TokenTree::Delimited(*span, *delim, stream.to_tokenstream()),]\n+                        .into_iter()\n+                }\n+                AttrTokenTree::Attributes(data) => {\n                     let mut outer_attrs = Vec::new();\n                     let mut inner_attrs = Vec::new();\n                     for attr in &data.attrs {\n                         match attr.style {\n-                            crate::AttrStyle::Outer => {\n-                                outer_attrs.push(attr);\n-                            }\n-                            crate::AttrStyle::Inner => {\n-                                inner_attrs.push(attr);\n-                            }\n+                            crate::AttrStyle::Outer => outer_attrs.push(attr),\n+                            crate::AttrStyle::Inner => inner_attrs.push(attr),\n                         }\n                     }\n \n                     let mut target_tokens: Vec<_> = data\n                         .tokens\n-                        .create_token_stream()\n+                        .to_attr_token_stream()\n                         .to_tokenstream()\n                         .0\n                         .iter()\n@@ -226,11 +231,11 @@ impl AttrAnnotatedTokenStream {\n                     if !inner_attrs.is_empty() {\n                         let mut found = false;\n                         // Check the last two trees (to account for a trailing semi)\n-                        for (tree, _) in target_tokens.iter_mut().rev().take(2) {\n+                        for tree in target_tokens.iter_mut().rev().take(2) {\n                             if let TokenTree::Delimited(span, delim, delim_tokens) = tree {\n-                                // Inner attributes are only supported on extern blocks, functions, impls,\n-                                // and modules. All of these have their inner attributes placed at\n-                                // the beginning of the rightmost outermost braced group:\n+                                // Inner attributes are only supported on extern blocks, functions,\n+                                // impls, and modules. All of these have their inner attributes\n+                                // placed at the beginning of the rightmost outermost braced group:\n                                 // e.g. fn foo() { #![my_attr} }\n                                 //\n                                 // Therefore, we can insert them back into the right location\n@@ -242,27 +247,26 @@ impl AttrAnnotatedTokenStream {\n                                 // properly implemented - we always synthesize fake tokens,\n                                 // so we never reach this code.\n \n-                                let mut builder = TokenStreamBuilder::new();\n+                                let mut stream = TokenStream::default();\n                                 for inner_attr in inner_attrs {\n-                                    builder.push(inner_attr.tokens().to_tokenstream());\n+                                    stream.push_stream(inner_attr.tokens());\n                                 }\n-                                builder.push(delim_tokens.clone());\n-                                *tree = TokenTree::Delimited(*span, *delim, builder.build());\n+                                stream.push_stream(delim_tokens.clone());\n+                                *tree = TokenTree::Delimited(*span, *delim, stream);\n                                 found = true;\n                                 break;\n                             }\n                         }\n \n                         assert!(\n                             found,\n-                            \"Failed to find trailing delimited group in: {:?}\",\n-                            target_tokens\n+                            \"Failed to find trailing delimited group in: {target_tokens:?}\"\n                         );\n                     }\n                     let mut flat: SmallVec<[_; 1]> = SmallVec::new();\n                     for attr in outer_attrs {\n                         // FIXME: Make this more efficient\n-                        flat.extend(attr.tokens().to_tokenstream().0.clone().iter().cloned());\n+                        flat.extend(attr.tokens().0.clone().iter().cloned());\n                     }\n                     flat.extend(target_tokens);\n                     flat.into_iter()\n@@ -289,7 +293,7 @@ pub struct AttributesData {\n     pub attrs: AttrVec,\n     /// The underlying tokens for the attribute target that `attrs`\n     /// are applied to\n-    pub tokens: LazyTokenStream,\n+    pub tokens: LazyAttrTokenStream,\n }\n \n /// A `TokenStream` is an abstract sequence of tokens, organized into [`TokenTree`]s.\n@@ -299,17 +303,22 @@ pub struct AttributesData {\n /// Today's `TokenTree`s can still contain AST via `token::Interpolated` for\n /// backwards compatibility.\n #[derive(Clone, Debug, Default, Encodable, Decodable)]\n-pub struct TokenStream(pub(crate) Lrc<Vec<TreeAndSpacing>>);\n-\n-pub type TreeAndSpacing = (TokenTree, Spacing);\n+pub struct TokenStream(pub(crate) Lrc<Vec<TokenTree>>);\n \n-// `TokenStream` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(TokenStream, 8);\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Encodable, Decodable)]\n+/// Similar to `proc_macro::Spacing`, but for tokens.\n+///\n+/// Note that all `ast::TokenTree::Token` instances have a `Spacing`, but when\n+/// we convert to `proc_macro::TokenTree` for proc macros only `Punct`\n+/// `TokenTree`s have a `proc_macro::Spacing`.\n+#[derive(Clone, Copy, Debug, PartialEq, Encodable, Decodable, HashStable_Generic)]\n pub enum Spacing {\n+    /// The token is not immediately followed by an operator token (as\n+    /// determined by `Token::is_op`). E.g. a `+` token is `Alone` in `+ =`,\n+    /// `+/*foo*/=`, `+ident`, and `+()`.\n     Alone,\n+\n+    /// The token is immediately followed by an operator token. E.g. a `+`\n+    /// token is `Joint` in `+=` and `++`.\n     Joint,\n }\n \n@@ -323,22 +332,22 @@ impl TokenStream {\n         while let Some((pos, ts)) = iter.next() {\n             if let Some((_, next)) = iter.peek() {\n                 let sp = match (&ts, &next) {\n-                    (_, (TokenTree::Token(Token { kind: token::Comma, .. }), _)) => continue,\n+                    (_, TokenTree::Token(Token { kind: token::Comma, .. }, _)) => continue,\n                     (\n-                        (TokenTree::Token(token_left), Spacing::Alone),\n-                        (TokenTree::Token(token_right), _),\n+                        TokenTree::Token(token_left, Spacing::Alone),\n+                        TokenTree::Token(token_right, _),\n                     ) if ((token_left.is_ident() && !token_left.is_reserved_ident())\n                         || token_left.is_lit())\n                         && ((token_right.is_ident() && !token_right.is_reserved_ident())\n                             || token_right.is_lit()) =>\n                     {\n                         token_left.span\n                     }\n-                    ((TokenTree::Delimited(sp, ..), Spacing::Alone), _) => sp.entire(),\n+                    (TokenTree::Delimited(sp, ..), _) => sp.entire(),\n                     _ => continue,\n                 };\n                 let sp = sp.shrink_to_hi();\n-                let comma = (TokenTree::token(token::Comma, sp), Spacing::Alone);\n+                let comma = TokenTree::token_alone(token::Comma, sp);\n                 suggestion = Some((pos, comma, sp));\n             }\n         }\n@@ -354,27 +363,9 @@ impl TokenStream {\n     }\n }\n \n-impl From<(AttrAnnotatedTokenTree, Spacing)> for AttrAnnotatedTokenStream {\n-    fn from((tree, spacing): (AttrAnnotatedTokenTree, Spacing)) -> AttrAnnotatedTokenStream {\n-        AttrAnnotatedTokenStream::new(vec![(tree, spacing)])\n-    }\n-}\n-\n-impl From<TokenTree> for TokenStream {\n-    fn from(tree: TokenTree) -> TokenStream {\n-        TokenStream::new(vec![(tree, Spacing::Alone)])\n-    }\n-}\n-\n-impl From<TokenTree> for TreeAndSpacing {\n-    fn from(tree: TokenTree) -> TreeAndSpacing {\n-        (tree, Spacing::Alone)\n-    }\n-}\n-\n-impl iter::FromIterator<TokenTree> for TokenStream {\n+impl FromIterator<TokenTree> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenTree>>(iter: I) -> Self {\n-        TokenStream::new(iter.into_iter().map(Into::into).collect::<Vec<TreeAndSpacing>>())\n+        TokenStream::new(iter.into_iter().collect::<Vec<TokenTree>>())\n     }\n }\n \n@@ -387,7 +378,7 @@ impl PartialEq<TokenStream> for TokenStream {\n }\n \n impl TokenStream {\n-    pub fn new(streams: Vec<TreeAndSpacing>) -> TokenStream {\n+    pub fn new(streams: Vec<TokenTree>) -> TokenStream {\n         TokenStream(Lrc::new(streams))\n     }\n \n@@ -399,69 +390,73 @@ impl TokenStream {\n         self.0.len()\n     }\n \n-    pub fn trees(&self) -> CursorRef<'_> {\n-        CursorRef::new(self)\n+    pub fn trees(&self) -> RefTokenTreeCursor<'_> {\n+        RefTokenTreeCursor::new(self)\n     }\n \n-    pub fn into_trees(self) -> Cursor {\n-        Cursor::new(self)\n+    pub fn into_trees(self) -> TokenTreeCursor {\n+        TokenTreeCursor::new(self)\n     }\n \n     /// Compares two `TokenStream`s, checking equality without regarding span information.\n     pub fn eq_unspanned(&self, other: &TokenStream) -> bool {\n         let mut t1 = self.trees();\n         let mut t2 = other.trees();\n         for (t1, t2) in iter::zip(&mut t1, &mut t2) {\n-            if !t1.eq_unspanned(&t2) {\n+            if !t1.eq_unspanned(t2) {\n                 return false;\n             }\n         }\n         t1.next().is_none() && t2.next().is_none()\n     }\n \n     pub fn map_enumerated<F: FnMut(usize, &TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream {\n-        TokenStream(Lrc::new(\n-            self.0\n-                .iter()\n-                .enumerate()\n-                .map(|(i, (tree, is_joint))| (f(i, tree), *is_joint))\n-                .collect(),\n-        ))\n+        TokenStream(Lrc::new(self.0.iter().enumerate().map(|(i, tree)| f(i, tree)).collect()))\n     }\n \n-    fn opt_from_ast(node: &(impl HasAttrs + HasTokens)) -> Option<TokenStream> {\n-        let tokens = node.tokens()?;\n-        let attrs = node.attrs();\n-        let attr_annotated = if attrs.is_empty() {\n-            tokens.create_token_stream()\n-        } else {\n-            let attr_data = AttributesData { attrs: attrs.to_vec().into(), tokens: tokens.clone() };\n-            AttrAnnotatedTokenStream::new(vec![(\n-                AttrAnnotatedTokenTree::Attributes(attr_data),\n-                Spacing::Alone,\n-            )])\n-        };\n-        Some(attr_annotated.to_tokenstream())\n+    /// Create a token stream containing a single token with alone spacing.\n+    pub fn token_alone(kind: TokenKind, span: Span) -> TokenStream {\n+        TokenStream::new(vec![TokenTree::token_alone(kind, span)])\n+    }\n+\n+    /// Create a token stream containing a single token with joint spacing.\n+    pub fn token_joint(kind: TokenKind, span: Span) -> TokenStream {\n+        TokenStream::new(vec![TokenTree::token_joint(kind, span)])\n+    }\n+\n+    /// Create a token stream containing a single `Delimited`.\n+    pub fn delimited(span: DelimSpan, delim: Delimiter, tts: TokenStream) -> TokenStream {\n+        TokenStream::new(vec![TokenTree::Delimited(span, delim, tts)])\n     }\n \n     pub fn from_ast(node: &(impl HasAttrs + HasSpan + HasTokens + fmt::Debug)) -> TokenStream {\n-        TokenStream::opt_from_ast(node)\n-            .unwrap_or_else(|| panic!(\"missing tokens for node at {:?}: {:?}\", node.span(), node))\n+        let Some(tokens) = node.tokens() else {\n+            panic!(\"missing tokens for node at {:?}: {:?}\", node.span(), node);\n+        };\n+        let attrs = node.attrs();\n+        let attr_stream = if attrs.is_empty() {\n+            tokens.to_attr_token_stream()\n+        } else {\n+            let attr_data =\n+                AttributesData { attrs: attrs.iter().cloned().collect(), tokens: tokens.clone() };\n+            AttrTokenStream::new(vec![AttrTokenTree::Attributes(attr_data)])\n+        };\n+        attr_stream.to_tokenstream()\n     }\n \n     pub fn from_nonterminal_ast(nt: &Nonterminal) -> TokenStream {\n         match nt {\n             Nonterminal::NtIdent(ident, is_raw) => {\n-                TokenTree::token(token::Ident(ident.name, *is_raw), ident.span).into()\n+                TokenStream::token_alone(token::Ident(ident.name, *is_raw), ident.span)\n             }\n             Nonterminal::NtLifetime(ident) => {\n-                TokenTree::token(token::Lifetime(ident.name), ident.span).into()\n+                TokenStream::token_alone(token::Lifetime(ident.name), ident.span)\n             }\n             Nonterminal::NtItem(item) => TokenStream::from_ast(item),\n             Nonterminal::NtBlock(block) => TokenStream::from_ast(block),\n             Nonterminal::NtStmt(stmt) if let StmtKind::Empty = stmt.kind => {\n                 // FIXME: Properly collect tokens for empty statements.\n-                TokenTree::token(token::Semi, stmt.span).into()\n+                TokenStream::token_alone(token::Semi, stmt.span)\n             }\n             Nonterminal::NtStmt(stmt) => TokenStream::from_ast(stmt),\n             Nonterminal::NtPat(pat) => TokenStream::from_ast(pat),\n@@ -473,23 +468,23 @@ impl TokenStream {\n         }\n     }\n \n-    fn flatten_token(token: &Token) -> TokenTree {\n+    fn flatten_token(token: &Token, spacing: Spacing) -> TokenTree {\n         match &token.kind {\n             token::Interpolated(nt) if let token::NtIdent(ident, is_raw) = **nt => {\n-                TokenTree::token(token::Ident(ident.name, is_raw), ident.span)\n+                TokenTree::Token(Token::new(token::Ident(ident.name, is_raw), ident.span), spacing)\n             }\n             token::Interpolated(nt) => TokenTree::Delimited(\n                 DelimSpan::from_single(token.span),\n                 Delimiter::Invisible,\n-                TokenStream::from_nonterminal_ast(&nt).flattened(),\n+                TokenStream::from_nonterminal_ast(nt).flattened(),\n             ),\n-            _ => TokenTree::Token(token.clone()),\n+            _ => TokenTree::Token(token.clone(), spacing),\n         }\n     }\n \n     fn flatten_token_tree(tree: &TokenTree) -> TokenTree {\n         match tree {\n-            TokenTree::Token(token) => TokenStream::flatten_token(token),\n+            TokenTree::Token(token, spacing) => TokenStream::flatten_token(token, *spacing),\n             TokenTree::Delimited(span, delim, tts) => {\n                 TokenTree::Delimited(*span, *delim, tts.flattened())\n             }\n@@ -500,7 +495,7 @@ impl TokenStream {\n     pub fn flattened(&self) -> TokenStream {\n         fn can_skip(stream: &TokenStream) -> bool {\n             stream.trees().all(|tree| match tree {\n-                TokenTree::Token(token) => !matches!(token.kind, token::Interpolated(_)),\n+                TokenTree::Token(token, _) => !matches!(token.kind, token::Interpolated(_)),\n                 TokenTree::Delimited(_, _, inner) => can_skip(inner),\n             })\n         }\n@@ -511,152 +506,130 @@ impl TokenStream {\n \n         self.trees().map(|tree| TokenStream::flatten_token_tree(tree)).collect()\n     }\n-}\n \n-// 99.5%+ of the time we have 1 or 2 elements in this vector.\n-#[derive(Clone)]\n-pub struct TokenStreamBuilder(SmallVec<[TokenStream; 2]>);\n-\n-impl TokenStreamBuilder {\n-    pub fn new() -> TokenStreamBuilder {\n-        TokenStreamBuilder(SmallVec::new())\n-    }\n-\n-    pub fn push<T: Into<TokenStream>>(&mut self, stream: T) {\n-        self.0.push(stream.into());\n-    }\n-\n-    pub fn build(self) -> TokenStream {\n-        let mut streams = self.0;\n-        match streams.len() {\n-            0 => TokenStream::default(),\n-            1 => streams.pop().unwrap(),\n-            _ => {\n-                // We will extend the first stream in `streams` with the\n-                // elements from the subsequent streams. This requires using\n-                // `make_mut()` on the first stream, and in practice this\n-                // doesn't cause cloning 99.9% of the time.\n-                //\n-                // One very common use case is when `streams` has two elements,\n-                // where the first stream has any number of elements within\n-                // (often 1, but sometimes many more) and the second stream has\n-                // a single element within.\n-\n-                // Determine how much the first stream will be extended.\n-                // Needed to avoid quadratic blow up from on-the-fly\n-                // reallocations (#57735).\n-                let num_appends = streams.iter().skip(1).map(|ts| ts.len()).sum();\n-\n-                // Get the first stream, which will become the result stream.\n-                // If it's `None`, create an empty stream.\n-                let mut iter = streams.drain(..);\n-                let mut res_stream_lrc = iter.next().unwrap().0;\n-\n-                // Append the subsequent elements to the result stream, after\n-                // reserving space for them.\n-                let res_vec_mut = Lrc::make_mut(&mut res_stream_lrc);\n-                res_vec_mut.reserve(num_appends);\n-                for stream in iter {\n-                    let stream_iter = stream.0.iter().cloned();\n-\n-                    // If (a) `res_mut_vec` is not empty and the last tree\n-                    // within it is a token tree marked with `Joint`, and (b)\n-                    // `stream` is not empty and the first tree within it is a\n-                    // token tree, and (c) the two tokens can be glued\n-                    // together...\n-                    if let Some((TokenTree::Token(last_tok), Spacing::Joint)) = res_vec_mut.last()\n-                        && let Some((TokenTree::Token(tok), spacing)) = stream.0.first()\n-                        && let Some(glued_tok) = last_tok.glue(&tok)\n-                    {\n-                        // ...then overwrite the last token tree in\n-                        // `res_vec_mut` with the glued token, and skip the\n-                        // first token tree from `stream`.\n-                        *res_vec_mut.last_mut().unwrap() = (TokenTree::Token(glued_tok), *spacing);\n-                        res_vec_mut.extend(stream_iter.skip(1));\n-                    } else {\n-                        // Append all of `stream`.\n-                        res_vec_mut.extend(stream_iter);\n-                    }\n-                }\n+    // If `vec` is not empty, try to glue `tt` onto its last token. The return\n+    // value indicates if gluing took place.\n+    fn try_glue_to_last(vec: &mut Vec<TokenTree>, tt: &TokenTree) -> bool {\n+        if let Some(TokenTree::Token(last_tok, Spacing::Joint)) = vec.last()\n+            && let TokenTree::Token(tok, spacing) = tt\n+            && let Some(glued_tok) = last_tok.glue(tok)\n+        {\n+            // ...then overwrite the last token tree in `vec` with the\n+            // glued token, and skip the first token tree from `stream`.\n+            *vec.last_mut().unwrap() = TokenTree::Token(glued_tok, *spacing);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n \n-                TokenStream(res_stream_lrc)\n-            }\n+    /// Push `tt` onto the end of the stream, possibly gluing it to the last\n+    /// token. Uses `make_mut` to maximize efficiency.\n+    pub fn push_tree(&mut self, tt: TokenTree) {\n+        let vec_mut = Lrc::make_mut(&mut self.0);\n+\n+        if Self::try_glue_to_last(vec_mut, &tt) {\n+            // nothing else to do\n+        } else {\n+            vec_mut.push(tt);\n+        }\n+    }\n+\n+    /// Push `stream` onto the end of the stream, possibly gluing the first\n+    /// token tree to the last token. (No other token trees will be glued.)\n+    /// Uses `make_mut` to maximize efficiency.\n+    pub fn push_stream(&mut self, stream: TokenStream) {\n+        let vec_mut = Lrc::make_mut(&mut self.0);\n+\n+        let stream_iter = stream.0.iter().cloned();\n+\n+        if let Some(first) = stream.0.first() && Self::try_glue_to_last(vec_mut, first) {\n+            // Now skip the first token tree from `stream`.\n+            vec_mut.extend(stream_iter.skip(1));\n+        } else {\n+            // Append all of `stream`.\n+            vec_mut.extend(stream_iter);\n         }\n     }\n+\n+    pub fn chunks(&self, chunk_size: usize) -> core::slice::Chunks<'_, TokenTree> {\n+        self.0.chunks(chunk_size)\n+    }\n }\n \n-/// By-reference iterator over a [`TokenStream`].\n+/// By-reference iterator over a [`TokenStream`], that produces `&TokenTree`\n+/// items.\n #[derive(Clone)]\n-pub struct CursorRef<'t> {\n+pub struct RefTokenTreeCursor<'t> {\n     stream: &'t TokenStream,\n     index: usize,\n }\n \n-impl<'t> CursorRef<'t> {\n+impl<'t> RefTokenTreeCursor<'t> {\n     fn new(stream: &'t TokenStream) -> Self {\n-        CursorRef { stream, index: 0 }\n-    }\n-\n-    #[inline]\n-    fn next_with_spacing(&mut self) -> Option<&'t TreeAndSpacing> {\n-        self.stream.0.get(self.index).map(|tree| {\n-            self.index += 1;\n-            tree\n-        })\n+        RefTokenTreeCursor { stream, index: 0 }\n     }\n \n     pub fn look_ahead(&self, n: usize) -> Option<&TokenTree> {\n-        self.stream.0[self.index..].get(n).map(|(tree, _)| tree)\n+        self.stream.0.get(self.index + n)\n     }\n }\n \n-impl<'t> Iterator for CursorRef<'t> {\n+impl<'t> Iterator for RefTokenTreeCursor<'t> {\n     type Item = &'t TokenTree;\n \n     fn next(&mut self) -> Option<&'t TokenTree> {\n-        self.next_with_spacing().map(|(tree, _)| tree)\n+        self.stream.0.get(self.index).map(|tree| {\n+            self.index += 1;\n+            tree\n+        })\n     }\n }\n \n-/// Owning by-value iterator over a [`TokenStream`].\n+/// Owning by-value iterator over a [`TokenStream`], that produces `TokenTree`\n+/// items.\n // FIXME: Many uses of this can be replaced with by-reference iterator to avoid clones.\n #[derive(Clone)]\n-pub struct Cursor {\n+pub struct TokenTreeCursor {\n     pub stream: TokenStream,\n     index: usize,\n }\n \n-impl Iterator for Cursor {\n+impl Iterator for TokenTreeCursor {\n     type Item = TokenTree;\n \n     fn next(&mut self) -> Option<TokenTree> {\n-        self.next_with_spacing().map(|(tree, _)| tree)\n-    }\n-}\n-\n-impl Cursor {\n-    fn new(stream: TokenStream) -> Self {\n-        Cursor { stream, index: 0 }\n-    }\n-\n-    #[inline]\n-    pub fn next_with_spacing(&mut self) -> Option<TreeAndSpacing> {\n         self.stream.0.get(self.index).map(|tree| {\n             self.index += 1;\n             tree.clone()\n         })\n     }\n+}\n+\n+impl TokenTreeCursor {\n+    fn new(stream: TokenStream) -> Self {\n+        TokenTreeCursor { stream, index: 0 }\n+    }\n \n     #[inline]\n-    pub fn next_with_spacing_ref(&mut self) -> Option<&TreeAndSpacing> {\n+    pub fn next_ref(&mut self) -> Option<&TokenTree> {\n         self.stream.0.get(self.index).map(|tree| {\n             self.index += 1;\n             tree\n         })\n     }\n \n     pub fn look_ahead(&self, n: usize) -> Option<&TokenTree> {\n-        self.stream.0[self.index..].get(n).map(|(tree, _)| tree)\n+        self.stream.0.get(self.index + n)\n+    }\n+\n+    // Replace the previously obtained token tree with `tts`, and rewind to\n+    // just before them.\n+    pub fn replace_prev_and_rewind(&mut self, tts: Vec<TokenTree>) {\n+        assert!(self.index > 0);\n+        self.index -= 1;\n+        let stream = Lrc::make_mut(&mut self.stream.0);\n+        stream.splice(self.index..self.index + 1, tts);\n     }\n }\n \n@@ -683,3 +656,17 @@ impl DelimSpan {\n         self.open.with_hi(self.close.hi())\n     }\n }\n+\n+// Some types are used a lot. Make sure they don't unintentionally get bigger.\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+mod size_asserts {\n+    use super::*;\n+    use rustc_data_structures::static_assert_size;\n+    // tidy-alphabetical-start\n+    static_assert_size!(AttrTokenStream, 8);\n+    static_assert_size!(AttrTokenTree, 32);\n+    static_assert_size!(LazyAttrTokenStream, 8);\n+    static_assert_size!(TokenStream, 8);\n+    static_assert_size!(TokenTree, 32);\n+    // tidy-alphabetical-end\n+}"}, {"sha": "1afd7dea7408ecb9c247e101ac7f4f951c636cf3", "filename": "compiler/rustc_ast/src/util/case.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcase.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -0,0 +1,6 @@\n+/// Whatever to ignore case (`fn` vs `Fn` vs `FN`) or not. Used for recovering.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub enum Case {\n+    Sensitive,\n+    Insensitive,\n+}"}, {"sha": "607b77705cf83987acf0038e8d1683c48148e117", "filename": "compiler/rustc_ast/src/util/classify.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -21,6 +21,7 @@ pub fn expr_requires_semi_to_be_stmt(e: &ast::Expr) -> bool {\n             | ast::ExprKind::Loop(..)\n             | ast::ExprKind::ForLoop(..)\n             | ast::ExprKind::TryBlock(..)\n+            | ast::ExprKind::ConstBlock(..)\n     )\n }\n \n@@ -34,16 +35,17 @@ pub fn expr_trailing_brace(mut expr: &ast::Expr) -> Option<&ast::Expr> {\n             | Assign(_, e, _)\n             | AssignOp(_, _, e)\n             | Binary(_, _, e)\n-            | Box(e)\n             | Break(_, Some(e))\n-            | Closure(.., e, _)\n             | Let(_, e, _)\n             | Range(_, Some(e), _)\n             | Ret(Some(e))\n             | Unary(_, e)\n             | Yield(Some(e)) => {\n                 expr = e;\n             }\n+            Closure(closure) => {\n+                expr = &closure.body;\n+            }\n             Async(..) | Block(..) | ForLoop(..) | If(..) | Loop(..) | Match(..) | Struct(..)\n             | TryBlock(..) | While(..) => break Some(expr),\n             _ => break None,"}, {"sha": "eece99a3eef0358c29f2792a6762955e1e9a03c6", "filename": "compiler/rustc_ast/src/util/comments.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -51,30 +51,31 @@ pub fn beautify_doc_string(data: Symbol, kind: CommentKind) -> Symbol {\n         if i != 0 || j != lines.len() { Some((i, j)) } else { None }\n     }\n \n-    fn get_horizontal_trim<'a>(lines: &'a [&str], kind: CommentKind) -> Option<String> {\n+    fn get_horizontal_trim(lines: &[&str], kind: CommentKind) -> Option<String> {\n         let mut i = usize::MAX;\n         let mut first = true;\n \n         // In case we have doc comments like `/**` or `/*!`, we want to remove stars if they are\n         // present. However, we first need to strip the empty lines so they don't get in the middle\n         // when we try to compute the \"horizontal trim\".\n-        let lines = if kind == CommentKind::Block {\n-            // Whatever happens, we skip the first line.\n-            let mut i = lines\n-                .get(0)\n-                .map(|l| if l.trim_start().starts_with('*') { 0 } else { 1 })\n-                .unwrap_or(0);\n-            let mut j = lines.len();\n-\n-            while i < j && lines[i].trim().is_empty() {\n-                i += 1;\n-            }\n-            while j > i && lines[j - 1].trim().is_empty() {\n-                j -= 1;\n+        let lines = match kind {\n+            CommentKind::Block => {\n+                // Whatever happens, we skip the first line.\n+                let mut i = lines\n+                    .get(0)\n+                    .map(|l| if l.trim_start().starts_with('*') { 0 } else { 1 })\n+                    .unwrap_or(0);\n+                let mut j = lines.len();\n+\n+                while i < j && lines[i].trim().is_empty() {\n+                    i += 1;\n+                }\n+                while j > i && lines[j - 1].trim().is_empty() {\n+                    j -= 1;\n+                }\n+                &lines[i..j]\n             }\n-            &lines[i..j]\n-        } else {\n-            lines\n+            CommentKind::Line => lines,\n         };\n \n         for line in lines {\n@@ -110,7 +111,7 @@ pub fn beautify_doc_string(data: Symbol, kind: CommentKind) -> Symbol {\n         } else {\n             &mut lines\n         };\n-        if let Some(horizontal) = get_horizontal_trim(&lines, kind) {\n+        if let Some(horizontal) = get_horizontal_trim(lines, kind) {\n             changes = true;\n             // remove a \"[ \\t]*\\*\" block from each line, if possible\n             for line in lines.iter_mut() {\n@@ -147,7 +148,7 @@ fn all_whitespace(s: &str, col: CharPos) -> Option<usize> {\n \n fn trim_whitespace_prefix(s: &str, col: CharPos) -> &str {\n     let len = s.len();\n-    match all_whitespace(&s, col) {\n+    match all_whitespace(s, col) {\n         Some(col) => {\n             if col < len {\n                 &s[col..]\n@@ -194,7 +195,7 @@ pub fn gather_comments(sm: &SourceMap, path: FileName, src: String) -> Vec<Comme\n     }\n \n     for token in rustc_lexer::tokenize(&text[pos..]) {\n-        let token_text = &text[pos..pos + token.len];\n+        let token_text = &text[pos..pos + token.len as usize];\n         match token.kind {\n             rustc_lexer::TokenKind::Whitespace => {\n                 if let Some(mut idx) = token_text.find('\\n') {\n@@ -211,8 +212,10 @@ pub fn gather_comments(sm: &SourceMap, path: FileName, src: String) -> Vec<Comme\n             }\n             rustc_lexer::TokenKind::BlockComment { doc_style, .. } => {\n                 if doc_style.is_none() {\n-                    let code_to_the_right =\n-                        !matches!(text[pos + token.len..].chars().next(), Some('\\r' | '\\n'));\n+                    let code_to_the_right = !matches!(\n+                        text[pos + token.len as usize..].chars().next(),\n+                        Some('\\r' | '\\n')\n+                    );\n                     let style = match (code_to_the_left, code_to_the_right) {\n                         (_, true) => CommentStyle::Mixed,\n                         (false, false) => CommentStyle::Isolated,\n@@ -246,7 +249,7 @@ pub fn gather_comments(sm: &SourceMap, path: FileName, src: String) -> Vec<Comme\n                 code_to_the_left = true;\n             }\n         }\n-        pos += token.len;\n+        pos += token.len as usize;\n     }\n \n     comments"}, {"sha": "50eb92125b9450d15d54091823de59ccc96adf16", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 175, "deletions": 113, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -1,29 +1,50 @@\n //! Code related to parsing literals.\n \n-use crate::ast::{self, Lit, LitKind};\n+use crate::ast::{self, LitKind, MetaItemLit, StrStyle};\n use crate::token::{self, Token};\n-\n-use rustc_lexer::unescape::{unescape_byte, unescape_char};\n-use rustc_lexer::unescape::{unescape_byte_literal, unescape_literal, Mode};\n+use rustc_lexer::unescape::{\n+    byte_from_char, unescape_byte, unescape_c_string, unescape_char, unescape_literal, CStrUnit,\n+    Mode,\n+};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n+use std::ops::Range;\n+use std::{ascii, fmt, str};\n+\n+// Escapes a string, represented as a symbol. Reuses the original symbol,\n+// avoiding interning, if no changes are required.\n+pub fn escape_string_symbol(symbol: Symbol) -> Symbol {\n+    let s = symbol.as_str();\n+    let escaped = s.escape_default().to_string();\n+    if s == escaped { symbol } else { Symbol::intern(&escaped) }\n+}\n \n-use std::ascii;\n-use tracing::debug;\n+// Escapes a char.\n+pub fn escape_char_symbol(ch: char) -> Symbol {\n+    let s: String = ch.escape_default().map(Into::<char>::into).collect();\n+    Symbol::intern(&s)\n+}\n+\n+// Escapes a byte string.\n+pub fn escape_byte_str_symbol(bytes: &[u8]) -> Symbol {\n+    let s = bytes.escape_ascii().to_string();\n+    Symbol::intern(&s)\n+}\n \n+#[derive(Debug)]\n pub enum LitError {\n-    NotLiteral,\n     LexerError,\n     InvalidSuffix,\n     InvalidIntSuffix,\n     InvalidFloatSuffix,\n     NonDecimalFloat(u32),\n-    IntTooLarge,\n+    IntTooLarge(u32),\n+    NulInCStr(Range<usize>),\n }\n \n impl LitKind {\n     /// Converts literal token into a semantic literal.\n-    pub fn from_lit_token(lit: token::Lit) -> Result<LitKind, LitError> {\n+    pub fn from_token_lit(lit: token::Lit) -> Result<LitKind, LitError> {\n         let token::Lit { kind, symbol, suffix } = lit;\n         if suffix.is_some() && !kind.may_have_suffix() {\n             return Err(LitError::InvalidSuffix);\n@@ -56,14 +77,14 @@ impl LitKind {\n                 // new symbol because the string in the LitKind is different to the\n                 // string in the token.\n                 let s = symbol.as_str();\n-                let symbol = if s.contains(&['\\\\', '\\r']) {\n+                let symbol = if s.contains(['\\\\', '\\r']) {\n                     let mut buf = String::with_capacity(s.len());\n                     let mut error = Ok(());\n                     // Force-inlining here is aggressive but the closure is\n                     // called on every char in the string, so it can be\n                     // hot in programs with many long strings.\n                     unescape_literal(\n-                        &s,\n+                        s,\n                         Mode::Str,\n                         &mut #[inline(always)]\n                         |_, unescaped_char| match unescaped_char {\n@@ -89,7 +110,7 @@ impl LitKind {\n                     if s.contains('\\r') {\n                         let mut buf = String::with_capacity(s.len());\n                         let mut error = Ok(());\n-                        unescape_literal(&s, Mode::RawStr, &mut |_, unescaped_char| {\n+                        unescape_literal(s, Mode::RawStr, &mut |_, unescaped_char| {\n                             match unescaped_char {\n                                 Ok(c) => buf.push(c),\n                                 Err(err) => {\n@@ -110,31 +131,27 @@ impl LitKind {\n                 let s = symbol.as_str();\n                 let mut buf = Vec::with_capacity(s.len());\n                 let mut error = Ok(());\n-                unescape_byte_literal(&s, Mode::ByteStr, &mut |_, unescaped_byte| {\n-                    match unescaped_byte {\n-                        Ok(c) => buf.push(c),\n-                        Err(err) => {\n-                            if err.is_fatal() {\n-                                error = Err(LitError::LexerError);\n-                            }\n+                unescape_literal(s, Mode::ByteStr, &mut |_, c| match c {\n+                    Ok(c) => buf.push(byte_from_char(c)),\n+                    Err(err) => {\n+                        if err.is_fatal() {\n+                            error = Err(LitError::LexerError);\n                         }\n                     }\n                 });\n                 error?;\n-                LitKind::ByteStr(buf.into())\n+                LitKind::ByteStr(buf.into(), StrStyle::Cooked)\n             }\n-            token::ByteStrRaw(_) => {\n+            token::ByteStrRaw(n) => {\n                 let s = symbol.as_str();\n                 let bytes = if s.contains('\\r') {\n                     let mut buf = Vec::with_capacity(s.len());\n                     let mut error = Ok(());\n-                    unescape_byte_literal(&s, Mode::RawByteStr, &mut |_, unescaped_byte| {\n-                        match unescaped_byte {\n-                            Ok(c) => buf.push(c),\n-                            Err(err) => {\n-                                if err.is_fatal() {\n-                                    error = Err(LitError::LexerError);\n-                                }\n+                    unescape_literal(s, Mode::RawByteStr, &mut |_, c| match c {\n+                        Ok(c) => buf.push(byte_from_char(c)),\n+                        Err(err) => {\n+                            if err.is_fatal() {\n+                                error = Err(LitError::LexerError);\n                             }\n                         }\n                     });\n@@ -144,111 +161,157 @@ impl LitKind {\n                     symbol.to_string().into_bytes()\n                 };\n \n-                LitKind::ByteStr(bytes.into())\n+                LitKind::ByteStr(bytes.into(), StrStyle::Raw(n))\n             }\n-            token::Err => LitKind::Err(symbol),\n+            token::CStr => {\n+                let s = symbol.as_str();\n+                let mut buf = Vec::with_capacity(s.len());\n+                let mut error = Ok(());\n+                unescape_c_string(s, Mode::CStr, &mut |span, c| match c {\n+                    Ok(CStrUnit::Byte(0) | CStrUnit::Char('\\0')) => {\n+                        error = Err(LitError::NulInCStr(span));\n+                    }\n+                    Ok(CStrUnit::Byte(b)) => buf.push(b),\n+                    Ok(CStrUnit::Char(c)) if c.len_utf8() == 1 => buf.push(c as u8),\n+                    Ok(CStrUnit::Char(c)) => {\n+                        buf.extend_from_slice(c.encode_utf8(&mut [0; 4]).as_bytes())\n+                    }\n+                    Err(err) => {\n+                        if err.is_fatal() {\n+                            error = Err(LitError::LexerError);\n+                        }\n+                    }\n+                });\n+                error?;\n+                buf.push(0);\n+                LitKind::CStr(buf.into(), StrStyle::Cooked)\n+            }\n+            token::CStrRaw(n) => {\n+                let s = symbol.as_str();\n+                let mut buf = Vec::with_capacity(s.len());\n+                let mut error = Ok(());\n+                unescape_c_string(s, Mode::RawCStr, &mut |span, c| match c {\n+                    Ok(CStrUnit::Byte(0) | CStrUnit::Char('\\0')) => {\n+                        error = Err(LitError::NulInCStr(span));\n+                    }\n+                    Ok(CStrUnit::Byte(b)) => buf.push(b),\n+                    Ok(CStrUnit::Char(c)) if c.len_utf8() == 1 => buf.push(c as u8),\n+                    Ok(CStrUnit::Char(c)) => {\n+                        buf.extend_from_slice(c.encode_utf8(&mut [0; 4]).as_bytes())\n+                    }\n+                    Err(err) => {\n+                        if err.is_fatal() {\n+                            error = Err(LitError::LexerError);\n+                        }\n+                    }\n+                });\n+                error?;\n+                buf.push(0);\n+                LitKind::CStr(buf.into(), StrStyle::Raw(n))\n+            }\n+            token::Err => LitKind::Err,\n         })\n     }\n+}\n \n-    /// Attempts to recover a token from semantic literal.\n-    /// This function is used when the original token doesn't exist (e.g. the literal is created\n-    /// by an AST-based macro) or unavailable (e.g. from HIR pretty-printing).\n-    pub fn to_lit_token(&self) -> token::Lit {\n-        let (kind, symbol, suffix) = match *self {\n-            LitKind::Str(symbol, ast::StrStyle::Cooked) => {\n-                // Don't re-intern unless the escaped string is different.\n-                let s = symbol.as_str();\n-                let escaped = s.escape_default().to_string();\n-                let symbol = if s == escaped { symbol } else { Symbol::intern(&escaped) };\n-                (token::Str, symbol, None)\n+impl fmt::Display for LitKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            LitKind::Byte(b) => {\n+                let b: String = ascii::escape_default(b).map(Into::<char>::into).collect();\n+                write!(f, \"b'{b}'\")?;\n+            }\n+            LitKind::Char(ch) => write!(f, \"'{}'\", escape_char_symbol(ch))?,\n+            LitKind::Str(sym, StrStyle::Cooked) => write!(f, \"\\\"{}\\\"\", escape_string_symbol(sym))?,\n+            LitKind::Str(sym, StrStyle::Raw(n)) => write!(\n+                f,\n+                \"r{delim}\\\"{string}\\\"{delim}\",\n+                delim = \"#\".repeat(n as usize),\n+                string = sym\n+            )?,\n+            LitKind::ByteStr(ref bytes, StrStyle::Cooked) => {\n+                write!(f, \"b\\\"{}\\\"\", escape_byte_str_symbol(bytes))?\n             }\n-            LitKind::Str(symbol, ast::StrStyle::Raw(n)) => (token::StrRaw(n), symbol, None),\n-            LitKind::ByteStr(ref bytes) => {\n-                let string = bytes\n-                    .iter()\n-                    .cloned()\n-                    .flat_map(ascii::escape_default)\n-                    .map(Into::<char>::into)\n-                    .collect::<String>();\n-                (token::ByteStr, Symbol::intern(&string), None)\n+            LitKind::ByteStr(ref bytes, StrStyle::Raw(n)) => {\n+                // Unwrap because raw byte string literals can only contain ASCII.\n+                let symbol = str::from_utf8(bytes).unwrap();\n+                write!(\n+                    f,\n+                    \"br{delim}\\\"{string}\\\"{delim}\",\n+                    delim = \"#\".repeat(n as usize),\n+                    string = symbol\n+                )?;\n             }\n-            LitKind::Byte(byte) => {\n-                let string: String = ascii::escape_default(byte).map(Into::<char>::into).collect();\n-                (token::Byte, Symbol::intern(&string), None)\n+            LitKind::CStr(ref bytes, StrStyle::Cooked) => {\n+                write!(f, \"c\\\"{}\\\"\", escape_byte_str_symbol(bytes))?\n             }\n-            LitKind::Char(ch) => {\n-                let string: String = ch.escape_default().map(Into::<char>::into).collect();\n-                (token::Char, Symbol::intern(&string), None)\n+            LitKind::CStr(ref bytes, StrStyle::Raw(n)) => {\n+                // This can only be valid UTF-8.\n+                let symbol = str::from_utf8(bytes).unwrap();\n+                write!(f, \"cr{delim}\\\"{symbol}\\\"{delim}\", delim = \"#\".repeat(n as usize),)?;\n             }\n             LitKind::Int(n, ty) => {\n-                let suffix = match ty {\n-                    ast::LitIntType::Unsigned(ty) => Some(ty.name()),\n-                    ast::LitIntType::Signed(ty) => Some(ty.name()),\n-                    ast::LitIntType::Unsuffixed => None,\n-                };\n-                (token::Integer, sym::integer(n), suffix)\n+                write!(f, \"{n}\")?;\n+                match ty {\n+                    ast::LitIntType::Unsigned(ty) => write!(f, \"{}\", ty.name())?,\n+                    ast::LitIntType::Signed(ty) => write!(f, \"{}\", ty.name())?,\n+                    ast::LitIntType::Unsuffixed => {}\n+                }\n             }\n             LitKind::Float(symbol, ty) => {\n-                let suffix = match ty {\n-                    ast::LitFloatType::Suffixed(ty) => Some(ty.name()),\n-                    ast::LitFloatType::Unsuffixed => None,\n-                };\n-                (token::Float, symbol, suffix)\n+                write!(f, \"{symbol}\")?;\n+                match ty {\n+                    ast::LitFloatType::Suffixed(ty) => write!(f, \"{}\", ty.name())?,\n+                    ast::LitFloatType::Unsuffixed => {}\n+                }\n             }\n-            LitKind::Bool(value) => {\n-                let symbol = if value { kw::True } else { kw::False };\n-                (token::Bool, symbol, None)\n+            LitKind::Bool(b) => write!(f, \"{}\", if b { \"true\" } else { \"false\" })?,\n+            LitKind::Err => {\n+                // This only shows up in places like `-Zunpretty=hir` output, so we\n+                // don't bother to produce something useful.\n+                write!(f, \"<bad-literal>\")?;\n             }\n-            LitKind::Err(symbol) => (token::Err, symbol, None),\n-        };\n+        }\n \n-        token::Lit::new(kind, symbol, suffix)\n+        Ok(())\n     }\n }\n \n-impl Lit {\n-    /// Converts literal token into an AST literal.\n-    pub fn from_lit_token(token: token::Lit, span: Span) -> Result<Lit, LitError> {\n-        Ok(Lit { token, kind: LitKind::from_lit_token(token)?, span })\n+impl MetaItemLit {\n+    /// Converts a token literal into a meta item literal.\n+    pub fn from_token_lit(token_lit: token::Lit, span: Span) -> Result<MetaItemLit, LitError> {\n+        Ok(MetaItemLit {\n+            symbol: token_lit.symbol,\n+            suffix: token_lit.suffix,\n+            kind: LitKind::from_token_lit(token_lit)?,\n+            span,\n+        })\n     }\n \n-    /// Converts arbitrary token into an AST literal.\n-    ///\n-    /// Keep this in sync with `Token::can_begin_literal_or_bool` excluding unary negation.\n-    pub fn from_token(token: &Token) -> Result<Lit, LitError> {\n-        let lit = match token.uninterpolate().kind {\n-            token::Ident(name, false) if name.is_bool_lit() => {\n-                token::Lit::new(token::Bool, name, None)\n-            }\n-            token::Literal(lit) => lit,\n-            token::Interpolated(ref nt) => {\n-                if let token::NtExpr(expr) | token::NtLiteral(expr) = &**nt\n-                    && let ast::ExprKind::Lit(lit) = &expr.kind\n-                {\n-                    return Ok(lit.clone());\n-                }\n-                return Err(LitError::NotLiteral);\n-            }\n-            _ => return Err(LitError::NotLiteral),\n+    /// Cheaply converts a meta item literal into a token literal.\n+    pub fn as_token_lit(&self) -> token::Lit {\n+        let kind = match self.kind {\n+            LitKind::Bool(_) => token::Bool,\n+            LitKind::Str(_, ast::StrStyle::Cooked) => token::Str,\n+            LitKind::Str(_, ast::StrStyle::Raw(n)) => token::StrRaw(n),\n+            LitKind::ByteStr(_, ast::StrStyle::Cooked) => token::ByteStr,\n+            LitKind::ByteStr(_, ast::StrStyle::Raw(n)) => token::ByteStrRaw(n),\n+            LitKind::CStr(_, ast::StrStyle::Cooked) => token::CStr,\n+            LitKind::CStr(_, ast::StrStyle::Raw(n)) => token::CStrRaw(n),\n+            LitKind::Byte(_) => token::Byte,\n+            LitKind::Char(_) => token::Char,\n+            LitKind::Int(..) => token::Integer,\n+            LitKind::Float(..) => token::Float,\n+            LitKind::Err => token::Err,\n         };\n \n-        Lit::from_lit_token(lit, token.span)\n+        token::Lit::new(kind, self.symbol, self.suffix)\n     }\n \n-    /// Attempts to recover an AST literal from semantic literal.\n-    /// This function is used when the original token doesn't exist (e.g. the literal is created\n-    /// by an AST-based macro) or unavailable (e.g. from HIR pretty-printing).\n-    pub fn from_lit_kind(kind: LitKind, span: Span) -> Lit {\n-        Lit { token: kind.to_lit_token(), kind, span }\n-    }\n-\n-    /// Losslessly convert an AST literal into a token.\n-    pub fn to_token(&self) -> Token {\n-        let kind = match self.token.kind {\n-            token::Bool => token::Ident(self.token.symbol, false),\n-            _ => token::Literal(self.token),\n-        };\n-        Token::new(kind, self.span)\n+    /// Converts an arbitrary token into meta item literal.\n+    pub fn from_token(token: &Token) -> Option<MetaItemLit> {\n+        token::Lit::from_token(token)\n+            .and_then(|token_lit| MetaItemLit::from_token_lit(token_lit, token.span).ok())\n     }\n }\n \n@@ -329,8 +392,7 @@ fn integer_lit(symbol: Symbol, suffix: Option<Symbol>) -> Result<LitKind, LitErr\n         // Small bases are lexed as if they were base 10, e.g, the string\n         // might be `0b10201`. This will cause the conversion above to fail,\n         // but these kinds of errors are already reported by the lexer.\n-        let from_lexer =\n-            base < 10 && s.chars().any(|c| c.to_digit(10).map_or(false, |d| d >= base));\n-        if from_lexer { LitError::LexerError } else { LitError::IntTooLarge }\n+        let from_lexer = base < 10 && s.chars().any(|c| c.to_digit(10).is_some_and(|d| d >= base));\n+        if from_lexer { LitError::LexerError } else { LitError::IntTooLarge(base) }\n     })\n }"}, {"sha": "35afd5423721d980a2c57f438cefcd745f512040", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 60, "deletions": 63, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -53,8 +53,6 @@ pub enum AssocOp {\n     DotDot,\n     /// `..=` range\n     DotDotEq,\n-    /// `:`\n-    Colon,\n }\n \n #[derive(PartialEq, Debug)]\n@@ -96,7 +94,6 @@ impl AssocOp {\n             token::DotDotEq => Some(DotDotEq),\n             // DotDotDot is no longer supported, but we need some way to display the error\n             token::DotDotDot => Some(DotDotEq),\n-            token::Colon => Some(Colon),\n             // `<-` should probably be `< -`\n             token::LArrow => Some(Less),\n             _ if t.is_keyword(kw::As) => Some(As),\n@@ -133,7 +130,7 @@ impl AssocOp {\n     pub fn precedence(&self) -> usize {\n         use AssocOp::*;\n         match *self {\n-            As | Colon => 14,\n+            As => 14,\n             Multiply | Divide | Modulus => 13,\n             Add | Subtract => 12,\n             ShiftLeft | ShiftRight => 11,\n@@ -156,7 +153,7 @@ impl AssocOp {\n             Assign | AssignOp(_) => Fixity::Right,\n             As | Multiply | Divide | Modulus | Add | Subtract | ShiftLeft | ShiftRight | BitAnd\n             | BitXor | BitOr | Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual\n-            | LAnd | LOr | Colon => Fixity::Left,\n+            | LAnd | LOr => Fixity::Left,\n             DotDot | DotDotEq => Fixity::None,\n         }\n     }\n@@ -166,8 +163,9 @@ impl AssocOp {\n         match *self {\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual => true,\n             Assign | AssignOp(_) | As | Multiply | Divide | Modulus | Add | Subtract\n-            | ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd | LOr | DotDot | DotDotEq\n-            | Colon => false,\n+            | ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd | LOr | DotDot | DotDotEq => {\n+                false\n+            }\n         }\n     }\n \n@@ -177,7 +175,7 @@ impl AssocOp {\n             Assign | AssignOp(_) => true,\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual | As | Multiply\n             | Divide | Modulus | Add | Subtract | ShiftLeft | ShiftRight | BitAnd | BitXor\n-            | BitOr | LAnd | LOr | DotDot | DotDotEq | Colon => false,\n+            | BitOr | LAnd | LOr | DotDot | DotDotEq => false,\n         }\n     }\n \n@@ -202,7 +200,7 @@ impl AssocOp {\n             BitOr => Some(BinOpKind::BitOr),\n             LAnd => Some(BinOpKind::And),\n             LOr => Some(BinOpKind::Or),\n-            Assign | AssignOp(_) | As | DotDot | DotDotEq | Colon => None,\n+            Assign | AssignOp(_) | As | DotDot | DotDotEq => None,\n         }\n     }\n \n@@ -223,10 +221,9 @@ impl AssocOp {\n             Greater | // `{ 42 } > 3`\n             GreaterEqual | // `{ 42 } >= 3`\n             AssignOp(_) | // `{ 42 } +=`\n-            As | // `{ 42 } as usize`\n             // Equal | // `{ 42 } == { 42 }`    Accepting these here would regress incorrect\n             // NotEqual | // `{ 42 } != { 42 }  struct literals parser recovery.\n-            Colon, // `{ 42 }: usize`\n+            As // `{ 42 } as usize`\n         )\n     }\n }\n@@ -254,12 +251,10 @@ pub enum ExprPrecedence {\n     Binary(BinOpKind),\n \n     Cast,\n-    Type,\n \n     Assign,\n     AssignOp,\n \n-    Box,\n     AddrOf,\n     Let,\n     Unary,\n@@ -270,7 +265,9 @@ pub enum ExprPrecedence {\n     Index,\n     Try,\n     InlineAsm,\n+    OffsetOf,\n     Mac,\n+    FormatArgs,\n \n     Array,\n     Repeat,\n@@ -297,64 +294,64 @@ impl ExprPrecedence {\n         match self {\n             ExprPrecedence::Closure => PREC_CLOSURE,\n \n-            ExprPrecedence::Break |\n-            ExprPrecedence::Continue |\n-            ExprPrecedence::Ret |\n-            ExprPrecedence::Yield |\n-            ExprPrecedence::Yeet => PREC_JUMP,\n+            ExprPrecedence::Break\n+            | ExprPrecedence::Continue\n+            | ExprPrecedence::Ret\n+            | ExprPrecedence::Yield\n+            | ExprPrecedence::Yeet => PREC_JUMP,\n \n             // `Range` claims to have higher precedence than `Assign`, but `x .. x = x` fails to\n-            // parse, instead of parsing as `(x .. x) = x`.  Giving `Range` a lower precedence\n+            // parse, instead of parsing as `(x .. x) = x`. Giving `Range` a lower precedence\n             // ensures that `pprust` will add parentheses in the right places to get the desired\n             // parse.\n             ExprPrecedence::Range => PREC_RANGE,\n \n             // Binop-like expr kinds, handled by `AssocOp`.\n             ExprPrecedence::Binary(op) => AssocOp::from_ast_binop(op).precedence() as i8,\n             ExprPrecedence::Cast => AssocOp::As.precedence() as i8,\n-            ExprPrecedence::Type => AssocOp::Colon.precedence() as i8,\n \n             ExprPrecedence::Assign |\n             ExprPrecedence::AssignOp => AssocOp::Assign.precedence() as i8,\n \n             // Unary, prefix\n-            ExprPrecedence::Box |\n-            ExprPrecedence::AddrOf |\n+            ExprPrecedence::AddrOf\n             // Here `let pats = expr` has `let pats =` as a \"unary\" prefix of `expr`.\n             // However, this is not exactly right. When `let _ = a` is the LHS of a binop we\n             // need parens sometimes. E.g. we can print `(let _ = a) && b` as `let _ = a && b`\n             // but we need to print `(let _ = a) < b` as-is with parens.\n-            ExprPrecedence::Let |\n-            ExprPrecedence::Unary => PREC_PREFIX,\n+            | ExprPrecedence::Let\n+            | ExprPrecedence::Unary => PREC_PREFIX,\n \n             // Unary, postfix\n-            ExprPrecedence::Await |\n-            ExprPrecedence::Call |\n-            ExprPrecedence::MethodCall |\n-            ExprPrecedence::Field |\n-            ExprPrecedence::Index |\n-            ExprPrecedence::Try |\n-            ExprPrecedence::InlineAsm |\n-            ExprPrecedence::Mac => PREC_POSTFIX,\n+            ExprPrecedence::Await\n+            | ExprPrecedence::Call\n+            | ExprPrecedence::MethodCall\n+            | ExprPrecedence::Field\n+            | ExprPrecedence::Index\n+            | ExprPrecedence::Try\n+            | ExprPrecedence::InlineAsm\n+            | ExprPrecedence::Mac\n+            | ExprPrecedence::FormatArgs\n+            | ExprPrecedence::OffsetOf => PREC_POSTFIX,\n \n             // Never need parens\n-            ExprPrecedence::Array |\n-            ExprPrecedence::Repeat |\n-            ExprPrecedence::Tup |\n-            ExprPrecedence::Lit |\n-            ExprPrecedence::Path |\n-            ExprPrecedence::Paren |\n-            ExprPrecedence::If |\n-            ExprPrecedence::While |\n-            ExprPrecedence::ForLoop |\n-            ExprPrecedence::Loop |\n-            ExprPrecedence::Match |\n-            ExprPrecedence::ConstBlock |\n-            ExprPrecedence::Block |\n-            ExprPrecedence::TryBlock |\n-            ExprPrecedence::Async |\n-            ExprPrecedence::Struct |\n-            ExprPrecedence::Err => PREC_PAREN,\n+            ExprPrecedence::Array\n+            | ExprPrecedence::Repeat\n+            | ExprPrecedence::Tup\n+            | ExprPrecedence::Lit\n+            | ExprPrecedence::Path\n+            | ExprPrecedence::Paren\n+            | ExprPrecedence::If\n+            | ExprPrecedence::While\n+            | ExprPrecedence::ForLoop\n+            | ExprPrecedence::Loop\n+            | ExprPrecedence::Match\n+            | ExprPrecedence::ConstBlock\n+            | ExprPrecedence::Block\n+            | ExprPrecedence::TryBlock\n+            | ExprPrecedence::Async\n+            | ExprPrecedence::Struct\n+            | ExprPrecedence::Err => PREC_PAREN,\n         }\n     }\n }\n@@ -377,28 +374,28 @@ pub fn needs_par_as_let_scrutinee(order: i8) -> bool {\n /// parens or other delimiters, e.g., `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n pub fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n-    match value.kind {\n+    match &value.kind {\n         ast::ExprKind::Struct(..) => true,\n \n-        ast::ExprKind::Assign(ref lhs, ref rhs, _)\n-        | ast::ExprKind::AssignOp(_, ref lhs, ref rhs)\n-        | ast::ExprKind::Binary(_, ref lhs, ref rhs) => {\n+        ast::ExprKind::Assign(lhs, rhs, _)\n+        | ast::ExprKind::AssignOp(_, lhs, rhs)\n+        | ast::ExprKind::Binary(_, lhs, rhs) => {\n             // X { y: 1 } + X { y: 2 }\n-            contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n+            contains_exterior_struct_lit(lhs) || contains_exterior_struct_lit(rhs)\n         }\n-        ast::ExprKind::Await(ref x)\n-        | ast::ExprKind::Unary(_, ref x)\n-        | ast::ExprKind::Cast(ref x, _)\n-        | ast::ExprKind::Type(ref x, _)\n-        | ast::ExprKind::Field(ref x, _)\n-        | ast::ExprKind::Index(ref x, _) => {\n+        ast::ExprKind::Await(x, _)\n+        | ast::ExprKind::Unary(_, x)\n+        | ast::ExprKind::Cast(x, _)\n+        | ast::ExprKind::Type(x, _)\n+        | ast::ExprKind::Field(x, _)\n+        | ast::ExprKind::Index(x, _) => {\n             // &X { y: 1 }, X { y: 1 }.y\n-            contains_exterior_struct_lit(&x)\n+            contains_exterior_struct_lit(x)\n         }\n \n-        ast::ExprKind::MethodCall(.., ref exprs, _) => {\n+        ast::ExprKind::MethodCall(box ast::MethodCall { receiver, .. }) => {\n             // X { y: 1 }.bar(...)\n-            contains_exterior_struct_lit(&exprs[0])\n+            contains_exterior_struct_lit(receiver)\n         }\n \n         _ => false,"}, {"sha": "6f57d66b2273a2cf4421d42f8057c4290dfc653e", "filename": "compiler/rustc_ast/src/util/unicode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Futil%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Futil%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Funicode.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -17,7 +17,7 @@ pub fn contains_text_flow_control_chars(s: &str) -> bool {\n     // U+2069 - E2 81 A9\n     let mut bytes = s.as_bytes();\n     loop {\n-        match core::slice::memchr::memchr(0xE2, &bytes) {\n+        match memchr::memchr(0xE2, bytes) {\n             Some(idx) => {\n                 // bytes are valid UTF-8 -> E2 must be followed by two bytes\n                 let ch = &bytes[idx..idx + 3];"}, {"sha": "275692ad5dda7f54a2341fccfc9df7e7ee6fd058", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 211, "deletions": 216, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -13,9 +13,9 @@\n //! instance, a walker looking for item names in a module will miss all of\n //! those that are created by the expansion of a macro.\n \n-use crate::ast::*;\n+use crate::{ast::*, StaticItem};\n \n-use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n@@ -92,7 +92,7 @@ impl<'a> FnKind<'a> {\n #[derive(Copy, Clone, Debug)]\n pub enum LifetimeCtxt {\n     /// Appears in a reference type.\n-    Rptr,\n+    Ref,\n     /// Appears as a bound on a type or another lifetime.\n     Bound,\n     /// Appears as a generic argument.\n@@ -109,12 +109,7 @@ pub enum LifetimeCtxt {\n /// to monitor future changes to `Visitor` in case a new method with a\n /// new default implementation gets introduced.)\n pub trait Visitor<'ast>: Sized {\n-    fn visit_name(&mut self, _span: Span, _name: Symbol) {\n-        // Nothing to do.\n-    }\n-    fn visit_ident(&mut self, ident: Ident) {\n-        walk_ident(self, ident);\n-    }\n+    fn visit_ident(&mut self, _ident: Ident) {}\n     fn visit_foreign_item(&mut self, i: &'ast ForeignItem) {\n         walk_foreign_item(self, i)\n     }\n@@ -145,6 +140,11 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_expr(&mut self, ex: &'ast Expr) {\n         walk_expr(self, ex)\n     }\n+    /// This method is a hack to workaround unstable of `stmt_expr_attributes`.\n+    /// It can be removed once that feature is stabilized.\n+    fn visit_method_receiver_expr(&mut self, ex: &'ast Expr) {\n+        self.visit_expr(ex)\n+    }\n     fn visit_expr_post(&mut self, _ex: &'ast Expr) {}\n     fn visit_ty(&mut self, t: &'ast Ty) {\n         walk_ty(self, t)\n@@ -161,8 +161,8 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_where_predicate(&mut self, p: &'ast WherePredicate) {\n         walk_where_predicate(self, p)\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'ast>, s: Span, _: NodeId) {\n-        walk_fn(self, fk, s)\n+    fn visit_fn(&mut self, fk: FnKind<'ast>, _: Span, _: NodeId) {\n+        walk_fn(self, fk)\n     }\n     fn visit_assoc_item(&mut self, i: &'ast AssocItem, ctxt: AssocCtxt) {\n         walk_assoc_item(self, i, ctxt)\n@@ -173,27 +173,24 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_param_bound(&mut self, bounds: &'ast GenericBound, _ctxt: BoundKind) {\n         walk_param_bound(self, bounds)\n     }\n-    fn visit_poly_trait_ref(&mut self, t: &'ast PolyTraitRef, m: &'ast TraitBoundModifier) {\n-        walk_poly_trait_ref(self, t, m)\n+    fn visit_poly_trait_ref(&mut self, t: &'ast PolyTraitRef) {\n+        walk_poly_trait_ref(self, t)\n     }\n     fn visit_variant_data(&mut self, s: &'ast VariantData) {\n         walk_struct_def(self, s)\n     }\n     fn visit_field_def(&mut self, s: &'ast FieldDef) {\n         walk_field_def(self, s)\n     }\n-    fn visit_enum_def(\n-        &mut self,\n-        enum_definition: &'ast EnumDef,\n-        generics: &'ast Generics,\n-        item_id: NodeId,\n-        _: Span,\n-    ) {\n-        walk_enum_def(self, enum_definition, generics, item_id)\n+    fn visit_enum_def(&mut self, enum_definition: &'ast EnumDef) {\n+        walk_enum_def(self, enum_definition)\n     }\n     fn visit_variant(&mut self, v: &'ast Variant) {\n         walk_variant(self, v)\n     }\n+    fn visit_variant_discr(&mut self, discr: &'ast AnonConst) {\n+        self.visit_anon_const(discr);\n+    }\n     fn visit_label(&mut self, label: &'ast Label) {\n         walk_label(self, label)\n     }\n@@ -212,11 +209,11 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_use_tree(&mut self, use_tree: &'ast UseTree, id: NodeId, _nested: bool) {\n         walk_use_tree(self, use_tree, id)\n     }\n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'ast PathSegment) {\n-        walk_path_segment(self, path_span, path_segment)\n+    fn visit_path_segment(&mut self, path_segment: &'ast PathSegment) {\n+        walk_path_segment(self, path_segment)\n     }\n-    fn visit_generic_args(&mut self, path_span: Span, generic_args: &'ast GenericArgs) {\n-        walk_generic_args(self, path_span, generic_args)\n+    fn visit_generic_args(&mut self, generic_args: &'ast GenericArgs) {\n+        walk_generic_args(self, generic_args)\n     }\n     fn visit_generic_arg(&mut self, generic_arg: &'ast GenericArg) {\n         walk_generic_arg(self, generic_arg)\n@@ -248,29 +245,26 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_inline_asm(&mut self, asm: &'ast InlineAsm) {\n         walk_inline_asm(self, asm)\n     }\n+    fn visit_format_args(&mut self, fmt: &'ast FormatArgs) {\n+        walk_format_args(self, fmt)\n+    }\n     fn visit_inline_asm_sym(&mut self, sym: &'ast InlineAsmSym) {\n         walk_inline_asm_sym(self, sym)\n     }\n }\n \n #[macro_export]\n macro_rules! walk_list {\n-    ($visitor: expr, $method: ident, $list: expr) => {\n-        for elem in $list {\n-            $visitor.$method(elem)\n-        }\n-    };\n-    ($visitor: expr, $method: ident, $list: expr, $($extra_args: expr),*) => {\n-        for elem in $list {\n-            $visitor.$method(elem, $($extra_args,)*)\n+    ($visitor: expr, $method: ident, $list: expr $(, $($extra_args: expr),* )?) => {\n+        {\n+            #[allow(for_loops_over_fallibles)]\n+            for elem in $list {\n+                $visitor.$method(elem $(, $($extra_args,)* )?)\n+            }\n         }\n     }\n }\n \n-pub fn walk_ident<'a, V: Visitor<'a>>(visitor: &mut V, ident: Ident) {\n-    visitor.visit_name(ident.span, ident.name);\n-}\n-\n pub fn walk_crate<'a, V: Visitor<'a>>(visitor: &mut V, krate: &'a Crate) {\n     walk_list!(visitor, visit_item, &krate.items);\n     walk_list!(visitor, visit_attribute, &krate.attrs);\n@@ -296,11 +290,8 @@ pub fn walk_lifetime<'a, V: Visitor<'a>>(visitor: &mut V, lifetime: &'a Lifetime\n     visitor.visit_ident(lifetime.ident);\n }\n \n-pub fn walk_poly_trait_ref<'a, V>(\n-    visitor: &mut V,\n-    trait_ref: &'a PolyTraitRef,\n-    _: &TraitBoundModifier,\n-) where\n+pub fn walk_poly_trait_ref<'a, V>(visitor: &mut V, trait_ref: &'a PolyTraitRef)\n+where\n     V: Visitor<'a>,\n {\n     walk_list!(visitor, visit_generic_param, &trait_ref.bound_generic_params);\n@@ -314,88 +305,74 @@ pub fn walk_trait_ref<'a, V: Visitor<'a>>(visitor: &mut V, trait_ref: &'a TraitR\n pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n     visitor.visit_vis(&item.vis);\n     visitor.visit_ident(item.ident);\n-    match item.kind {\n-        ItemKind::ExternCrate(orig_name) => {\n-            if let Some(orig_name) = orig_name {\n-                visitor.visit_name(item.span, orig_name);\n-            }\n-        }\n-        ItemKind::Use(ref use_tree) => visitor.visit_use_tree(use_tree, item.id, false),\n-        ItemKind::Static(ref typ, _, ref expr) | ItemKind::Const(_, ref typ, ref expr) => {\n-            visitor.visit_ty(typ);\n+    match &item.kind {\n+        ItemKind::ExternCrate(_) => {}\n+        ItemKind::Use(use_tree) => visitor.visit_use_tree(use_tree, item.id, false),\n+        ItemKind::Static(box StaticItem { ty, mutability: _, expr })\n+        | ItemKind::Const(box ConstItem { ty, expr, .. }) => {\n+            visitor.visit_ty(ty);\n             walk_list!(visitor, visit_expr, expr);\n         }\n-        ItemKind::Fn(box Fn { defaultness: _, ref generics, ref sig, ref body }) => {\n+        ItemKind::Fn(box Fn { defaultness: _, generics, sig, body }) => {\n             let kind =\n                 FnKind::Fn(FnCtxt::Free, item.ident, sig, &item.vis, generics, body.as_deref());\n             visitor.visit_fn(kind, item.span, item.id)\n         }\n-        ItemKind::Mod(_unsafety, ref mod_kind) => match mod_kind {\n+        ItemKind::Mod(_unsafety, mod_kind) => match mod_kind {\n             ModKind::Loaded(items, _inline, _inner_span) => {\n                 walk_list!(visitor, visit_item, items)\n             }\n             ModKind::Unloaded => {}\n         },\n-        ItemKind::ForeignMod(ref foreign_module) => {\n+        ItemKind::ForeignMod(foreign_module) => {\n             walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n         }\n-        ItemKind::GlobalAsm(ref asm) => visitor.visit_inline_asm(asm),\n-        ItemKind::TyAlias(box TyAlias { ref generics, ref bounds, ref ty, .. }) => {\n+        ItemKind::GlobalAsm(asm) => visitor.visit_inline_asm(asm),\n+        ItemKind::TyAlias(box TyAlias { generics, bounds, ty, .. }) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n             walk_list!(visitor, visit_ty, ty);\n         }\n-        ItemKind::Enum(ref enum_definition, ref generics) => {\n+        ItemKind::Enum(enum_definition, generics) => {\n             visitor.visit_generics(generics);\n-            visitor.visit_enum_def(enum_definition, generics, item.id, item.span)\n+            visitor.visit_enum_def(enum_definition)\n         }\n         ItemKind::Impl(box Impl {\n             defaultness: _,\n             unsafety: _,\n-            ref generics,\n+            generics,\n             constness: _,\n             polarity: _,\n-            ref of_trait,\n-            ref self_ty,\n-            ref items,\n+            of_trait,\n+            self_ty,\n+            items,\n         }) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_trait_ref, of_trait);\n             visitor.visit_ty(self_ty);\n             walk_list!(visitor, visit_assoc_item, items, AssocCtxt::Impl);\n         }\n-        ItemKind::Struct(ref struct_definition, ref generics)\n-        | ItemKind::Union(ref struct_definition, ref generics) => {\n+        ItemKind::Struct(struct_definition, generics)\n+        | ItemKind::Union(struct_definition, generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_variant_data(struct_definition);\n         }\n-        ItemKind::Trait(box Trait {\n-            unsafety: _,\n-            is_auto: _,\n-            ref generics,\n-            ref bounds,\n-            ref items,\n-        }) => {\n+        ItemKind::Trait(box Trait { unsafety: _, is_auto: _, generics, bounds, items }) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::SuperTraits);\n             walk_list!(visitor, visit_assoc_item, items, AssocCtxt::Trait);\n         }\n-        ItemKind::TraitAlias(ref generics, ref bounds) => {\n+        ItemKind::TraitAlias(generics, bounds) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n         }\n-        ItemKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n-        ItemKind::MacroDef(ref ts) => visitor.visit_mac_def(ts, item.id),\n+        ItemKind::MacCall(mac) => visitor.visit_mac_call(mac),\n+        ItemKind::MacroDef(ts) => visitor.visit_mac_def(ts, item.id),\n     }\n     walk_list!(visitor, visit_attribute, &item.attrs);\n }\n \n-pub fn walk_enum_def<'a, V: Visitor<'a>>(\n-    visitor: &mut V,\n-    enum_definition: &'a EnumDef,\n-    _: &'a Generics,\n-    _: NodeId,\n-) {\n+pub fn walk_enum_def<'a, V: Visitor<'a>>(visitor: &mut V, enum_definition: &'a EnumDef) {\n     walk_list!(visitor, visit_variant, &enum_definition.variants);\n }\n \n@@ -406,7 +383,7 @@ where\n     visitor.visit_ident(variant.ident);\n     visitor.visit_vis(&variant.vis);\n     visitor.visit_variant_data(&variant.data);\n-    walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n+    walk_list!(visitor, visit_variant_discr, &variant.disr_expr);\n     walk_list!(visitor, visit_attribute, &variant.attrs);\n }\n \n@@ -423,92 +400,88 @@ pub fn walk_pat_field<'a, V: Visitor<'a>>(visitor: &mut V, fp: &'a PatField) {\n }\n \n pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n-    match typ.kind {\n-        TyKind::Slice(ref ty) | TyKind::Paren(ref ty) => visitor.visit_ty(ty),\n-        TyKind::Ptr(ref mutable_type) => visitor.visit_ty(&mutable_type.ty),\n-        TyKind::Rptr(ref opt_lifetime, ref mutable_type) => {\n-            walk_list!(visitor, visit_lifetime, opt_lifetime, LifetimeCtxt::Rptr);\n+    match &typ.kind {\n+        TyKind::Slice(ty) | TyKind::Paren(ty) => visitor.visit_ty(ty),\n+        TyKind::Ptr(mutable_type) => visitor.visit_ty(&mutable_type.ty),\n+        TyKind::Ref(opt_lifetime, mutable_type) => {\n+            walk_list!(visitor, visit_lifetime, opt_lifetime, LifetimeCtxt::Ref);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyKind::Tup(ref tuple_element_types) => {\n+        TyKind::Tup(tuple_element_types) => {\n             walk_list!(visitor, visit_ty, tuple_element_types);\n         }\n-        TyKind::BareFn(ref function_declaration) => {\n+        TyKind::BareFn(function_declaration) => {\n             walk_list!(visitor, visit_generic_param, &function_declaration.generic_params);\n             walk_fn_decl(visitor, &function_declaration.decl);\n         }\n-        TyKind::Path(ref maybe_qself, ref path) => {\n-            if let Some(ref qself) = *maybe_qself {\n+        TyKind::Path(maybe_qself, path) => {\n+            if let Some(qself) = maybe_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, typ.id);\n         }\n-        TyKind::Array(ref ty, ref length) => {\n+        TyKind::Array(ty, length) => {\n             visitor.visit_ty(ty);\n             visitor.visit_anon_const(length)\n         }\n-        TyKind::TraitObject(ref bounds, ..) => {\n+        TyKind::TraitObject(bounds, ..) => {\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::TraitObject);\n         }\n-        TyKind::ImplTrait(_, ref bounds) => {\n+        TyKind::ImplTrait(_, bounds) => {\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Impl);\n         }\n-        TyKind::Typeof(ref expression) => visitor.visit_anon_const(expression),\n+        TyKind::Typeof(expression) => visitor.visit_anon_const(expression),\n         TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err => {}\n-        TyKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n+        TyKind::MacCall(mac) => visitor.visit_mac_call(mac),\n         TyKind::Never | TyKind::CVarArgs => {}\n     }\n }\n \n pub fn walk_path<'a, V: Visitor<'a>>(visitor: &mut V, path: &'a Path) {\n     for segment in &path.segments {\n-        visitor.visit_path_segment(path.span, segment);\n+        visitor.visit_path_segment(segment);\n     }\n }\n \n pub fn walk_use_tree<'a, V: Visitor<'a>>(visitor: &mut V, use_tree: &'a UseTree, id: NodeId) {\n     visitor.visit_path(&use_tree.prefix, id);\n-    match use_tree.kind {\n-        UseTreeKind::Simple(rename, ..) => {\n+    match &use_tree.kind {\n+        UseTreeKind::Simple(rename) => {\n             // The extra IDs are handled during HIR lowering.\n-            if let Some(rename) = rename {\n+            if let &Some(rename) = rename {\n                 visitor.visit_ident(rename);\n             }\n         }\n         UseTreeKind::Glob => {}\n-        UseTreeKind::Nested(ref use_trees) => {\n+        UseTreeKind::Nested(use_trees) => {\n             for &(ref nested_tree, nested_id) in use_trees {\n                 visitor.visit_use_tree(nested_tree, nested_id, true);\n             }\n         }\n     }\n }\n \n-pub fn walk_path_segment<'a, V: Visitor<'a>>(\n-    visitor: &mut V,\n-    path_span: Span,\n-    segment: &'a PathSegment,\n-) {\n+pub fn walk_path_segment<'a, V: Visitor<'a>>(visitor: &mut V, segment: &'a PathSegment) {\n     visitor.visit_ident(segment.ident);\n-    if let Some(ref args) = segment.args {\n-        visitor.visit_generic_args(path_span, args);\n+    if let Some(args) = &segment.args {\n+        visitor.visit_generic_args(args);\n     }\n }\n \n-pub fn walk_generic_args<'a, V>(visitor: &mut V, _path_span: Span, generic_args: &'a GenericArgs)\n+pub fn walk_generic_args<'a, V>(visitor: &mut V, generic_args: &'a GenericArgs)\n where\n     V: Visitor<'a>,\n {\n-    match *generic_args {\n-        GenericArgs::AngleBracketed(ref data) => {\n+    match generic_args {\n+        GenericArgs::AngleBracketed(data) => {\n             for arg in &data.args {\n                 match arg {\n                     AngleBracketedArg::Arg(a) => visitor.visit_generic_arg(a),\n                     AngleBracketedArg::Constraint(c) => visitor.visit_assoc_constraint(c),\n                 }\n             }\n         }\n-        GenericArgs::Parenthesized(ref data) => {\n+        GenericArgs::Parenthesized(data) => {\n             walk_list!(visitor, visit_ty, &data.inputs);\n             walk_fn_ret_ty(visitor, &data.output);\n         }\n@@ -528,64 +501,64 @@ where\n \n pub fn walk_assoc_constraint<'a, V: Visitor<'a>>(visitor: &mut V, constraint: &'a AssocConstraint) {\n     visitor.visit_ident(constraint.ident);\n-    if let Some(ref gen_args) = constraint.gen_args {\n-        visitor.visit_generic_args(gen_args.span(), gen_args);\n+    if let Some(gen_args) = &constraint.gen_args {\n+        visitor.visit_generic_args(gen_args);\n     }\n-    match constraint.kind {\n-        AssocConstraintKind::Equality { ref term } => match term {\n+    match &constraint.kind {\n+        AssocConstraintKind::Equality { term } => match term {\n             Term::Ty(ty) => visitor.visit_ty(ty),\n             Term::Const(c) => visitor.visit_anon_const(c),\n         },\n-        AssocConstraintKind::Bound { ref bounds } => {\n+        AssocConstraintKind::Bound { bounds } => {\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n         }\n     }\n }\n \n pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n-    match pattern.kind {\n-        PatKind::TupleStruct(ref opt_qself, ref path, ref elems) => {\n-            if let Some(ref qself) = *opt_qself {\n+    match &pattern.kind {\n+        PatKind::TupleStruct(opt_qself, path, elems) => {\n+            if let Some(qself) = opt_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, pattern.id);\n             walk_list!(visitor, visit_pat, elems);\n         }\n-        PatKind::Path(ref opt_qself, ref path) => {\n-            if let Some(ref qself) = *opt_qself {\n+        PatKind::Path(opt_qself, path) => {\n+            if let Some(qself) = opt_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, pattern.id)\n         }\n-        PatKind::Struct(ref opt_qself, ref path, ref fields, _) => {\n-            if let Some(ref qself) = *opt_qself {\n+        PatKind::Struct(opt_qself, path, fields, _) => {\n+            if let Some(qself) = opt_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, pattern.id);\n             walk_list!(visitor, visit_pat_field, fields);\n         }\n-        PatKind::Box(ref subpattern)\n-        | PatKind::Ref(ref subpattern, _)\n-        | PatKind::Paren(ref subpattern) => visitor.visit_pat(subpattern),\n-        PatKind::Ident(_, ident, ref optional_subpattern) => {\n-            visitor.visit_ident(ident);\n+        PatKind::Box(subpattern) | PatKind::Ref(subpattern, _) | PatKind::Paren(subpattern) => {\n+            visitor.visit_pat(subpattern)\n+        }\n+        PatKind::Ident(_, ident, optional_subpattern) => {\n+            visitor.visit_ident(*ident);\n             walk_list!(visitor, visit_pat, optional_subpattern);\n         }\n-        PatKind::Lit(ref expression) => visitor.visit_expr(expression),\n-        PatKind::Range(ref lower_bound, ref upper_bound, _) => {\n+        PatKind::Lit(expression) => visitor.visit_expr(expression),\n+        PatKind::Range(lower_bound, upper_bound, _) => {\n             walk_list!(visitor, visit_expr, lower_bound);\n             walk_list!(visitor, visit_expr, upper_bound);\n         }\n         PatKind::Wild | PatKind::Rest => {}\n-        PatKind::Tuple(ref elems) | PatKind::Slice(ref elems) | PatKind::Or(ref elems) => {\n+        PatKind::Tuple(elems) | PatKind::Slice(elems) | PatKind::Or(elems) => {\n             walk_list!(visitor, visit_pat, elems);\n         }\n-        PatKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n+        PatKind::MacCall(mac) => visitor.visit_mac_call(mac),\n     }\n }\n \n pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a ForeignItem) {\n-    let Item { id, span, ident, ref vis, ref attrs, ref kind, tokens: _ } = *item;\n+    let &Item { id, span, ident, ref vis, ref attrs, ref kind, tokens: _ } = item;\n     visitor.visit_vis(vis);\n     visitor.visit_ident(ident);\n     walk_list!(visitor, visit_attribute, attrs);\n@@ -594,7 +567,7 @@ pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a ForeignI\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_expr, expr);\n         }\n-        ForeignItemKind::Fn(box Fn { defaultness: _, ref generics, ref sig, ref body }) => {\n+        ForeignItemKind::Fn(box Fn { defaultness: _, generics, sig, body }) => {\n             let kind = FnKind::Fn(FnCtxt::Foreign, ident, sig, vis, generics, body.as_deref());\n             visitor.visit_fn(kind, span, id);\n         }\n@@ -610,22 +583,20 @@ pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a ForeignI\n }\n \n pub fn walk_param_bound<'a, V: Visitor<'a>>(visitor: &mut V, bound: &'a GenericBound) {\n-    match *bound {\n-        GenericBound::Trait(ref typ, ref modifier) => visitor.visit_poly_trait_ref(typ, modifier),\n-        GenericBound::Outlives(ref lifetime) => {\n-            visitor.visit_lifetime(lifetime, LifetimeCtxt::Bound)\n-        }\n+    match bound {\n+        GenericBound::Trait(typ, _modifier) => visitor.visit_poly_trait_ref(typ),\n+        GenericBound::Outlives(lifetime) => visitor.visit_lifetime(lifetime, LifetimeCtxt::Bound),\n     }\n }\n \n pub fn walk_generic_param<'a, V: Visitor<'a>>(visitor: &mut V, param: &'a GenericParam) {\n     visitor.visit_ident(param.ident);\n     walk_list!(visitor, visit_attribute, param.attrs.iter());\n     walk_list!(visitor, visit_param_bound, &param.bounds, BoundKind::Bound);\n-    match param.kind {\n+    match &param.kind {\n         GenericParamKind::Lifetime => (),\n-        GenericParamKind::Type { ref default } => walk_list!(visitor, visit_ty, default),\n-        GenericParamKind::Const { ref ty, ref default, .. } => {\n+        GenericParamKind::Type { default } => walk_list!(visitor, visit_ty, default),\n+        GenericParamKind::Const { ty, default, .. } => {\n             visitor.visit_ty(ty);\n             if let Some(default) = default {\n                 visitor.visit_anon_const(default);\n@@ -649,32 +620,30 @@ pub fn walk_closure_binder<'a, V: Visitor<'a>>(visitor: &mut V, binder: &'a Clos\n }\n \n pub fn walk_where_predicate<'a, V: Visitor<'a>>(visitor: &mut V, predicate: &'a WherePredicate) {\n-    match *predicate {\n+    match predicate {\n         WherePredicate::BoundPredicate(WhereBoundPredicate {\n-            ref bounded_ty,\n-            ref bounds,\n-            ref bound_generic_params,\n+            bounded_ty,\n+            bounds,\n+            bound_generic_params,\n             ..\n         }) => {\n             visitor.visit_ty(bounded_ty);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n             walk_list!(visitor, visit_generic_param, bound_generic_params);\n         }\n-        WherePredicate::RegionPredicate(WhereRegionPredicate {\n-            ref lifetime, ref bounds, ..\n-        }) => {\n+        WherePredicate::RegionPredicate(WhereRegionPredicate { lifetime, bounds, .. }) => {\n             visitor.visit_lifetime(lifetime, LifetimeCtxt::Bound);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n         }\n-        WherePredicate::EqPredicate(WhereEqPredicate { ref lhs_ty, ref rhs_ty, .. }) => {\n+        WherePredicate::EqPredicate(WhereEqPredicate { lhs_ty, rhs_ty, .. }) => {\n             visitor.visit_ty(lhs_ty);\n             visitor.visit_ty(rhs_ty);\n         }\n     }\n }\n \n pub fn walk_fn_ret_ty<'a, V: Visitor<'a>>(visitor: &mut V, ret_ty: &'a FnRetTy) {\n-    if let FnRetTy::Ty(ref output_ty) = *ret_ty {\n+    if let FnRetTy::Ty(output_ty) = ret_ty {\n         visitor.visit_ty(output_ty)\n     }\n }\n@@ -686,7 +655,7 @@ pub fn walk_fn_decl<'a, V: Visitor<'a>>(visitor: &mut V, function_declaration: &\n     visitor.visit_fn_ret_ty(&function_declaration.output);\n }\n \n-pub fn walk_fn<'a, V: Visitor<'a>>(visitor: &mut V, kind: FnKind<'a>, _span: Span) {\n+pub fn walk_fn<'a, V: Visitor<'a>>(visitor: &mut V, kind: FnKind<'a>) {\n     match kind {\n         FnKind::Fn(_, _, sig, _, generics, body) => {\n             visitor.visit_generics(generics);\n@@ -703,20 +672,20 @@ pub fn walk_fn<'a, V: Visitor<'a>>(visitor: &mut V, kind: FnKind<'a>, _span: Spa\n }\n \n pub fn walk_assoc_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem, ctxt: AssocCtxt) {\n-    let Item { id, span, ident, ref vis, ref attrs, ref kind, tokens: _ } = *item;\n+    let &Item { id, span, ident, ref vis, ref attrs, ref kind, tokens: _ } = item;\n     visitor.visit_vis(vis);\n     visitor.visit_ident(ident);\n     walk_list!(visitor, visit_attribute, attrs);\n     match kind {\n-        AssocItemKind::Const(_, ty, expr) => {\n+        AssocItemKind::Const(box ConstItem { ty, expr, .. }) => {\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_expr, expr);\n         }\n-        AssocItemKind::Fn(box Fn { defaultness: _, ref generics, ref sig, ref body }) => {\n+        AssocItemKind::Fn(box Fn { defaultness: _, generics, sig, body }) => {\n             let kind = FnKind::Fn(FnCtxt::Assoc(ctxt), ident, sig, vis, generics, body.as_deref());\n             visitor.visit_fn(kind, span, id);\n         }\n-        AssocItemKind::TyAlias(box TyAlias { generics, bounds, ty, .. }) => {\n+        AssocItemKind::Type(box TyAlias { generics, bounds, ty, .. }) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n             walk_list!(visitor, visit_ty, ty);\n@@ -745,13 +714,13 @@ pub fn walk_block<'a, V: Visitor<'a>>(visitor: &mut V, block: &'a Block) {\n }\n \n pub fn walk_stmt<'a, V: Visitor<'a>>(visitor: &mut V, statement: &'a Stmt) {\n-    match statement.kind {\n-        StmtKind::Local(ref local) => visitor.visit_local(local),\n-        StmtKind::Item(ref item) => visitor.visit_item(item),\n-        StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => visitor.visit_expr(expr),\n+    match &statement.kind {\n+        StmtKind::Local(local) => visitor.visit_local(local),\n+        StmtKind::Item(item) => visitor.visit_item(item),\n+        StmtKind::Expr(expr) | StmtKind::Semi(expr) => visitor.visit_expr(expr),\n         StmtKind::Empty => {}\n-        StmtKind::MacCall(ref mac) => {\n-            let MacCallStmt { ref mac, style: _, ref attrs, tokens: _ } = **mac;\n+        StmtKind::MacCall(mac) => {\n+            let MacCallStmt { mac, attrs, style: _, tokens: _ } = &**mac;\n             visitor.visit_mac_call(mac);\n             for attr in attrs.iter() {\n                 visitor.visit_attribute(attr);\n@@ -788,27 +757,35 @@ pub fn walk_inline_asm<'a, V: Visitor<'a>>(visitor: &mut V, asm: &'a InlineAsm)\n }\n \n pub fn walk_inline_asm_sym<'a, V: Visitor<'a>>(visitor: &mut V, sym: &'a InlineAsmSym) {\n-    if let Some(ref qself) = sym.qself {\n+    if let Some(qself) = &sym.qself {\n         visitor.visit_ty(&qself.ty);\n     }\n     visitor.visit_path(&sym.path, sym.id);\n }\n \n+pub fn walk_format_args<'a, V: Visitor<'a>>(visitor: &mut V, fmt: &'a FormatArgs) {\n+    for arg in fmt.arguments.all_args() {\n+        if let FormatArgumentKind::Named(name) = arg.kind {\n+            visitor.visit_ident(name);\n+        }\n+        visitor.visit_expr(&arg.expr);\n+    }\n+}\n+\n pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n \n-    match expression.kind {\n-        ExprKind::Box(ref subexpression) => visitor.visit_expr(subexpression),\n-        ExprKind::Array(ref subexpressions) => {\n+    match &expression.kind {\n+        ExprKind::Array(subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        ExprKind::ConstBlock(ref anon_const) => visitor.visit_anon_const(anon_const),\n-        ExprKind::Repeat(ref element, ref count) => {\n+        ExprKind::ConstBlock(anon_const) => visitor.visit_anon_const(anon_const),\n+        ExprKind::Repeat(element, count) => {\n             visitor.visit_expr(element);\n             visitor.visit_anon_const(count)\n         }\n-        ExprKind::Struct(ref se) => {\n-            if let Some(ref qself) = se.qself {\n+        ExprKind::Struct(se) => {\n+            if let Some(qself) = &se.qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(&se.path, expression.id);\n@@ -819,116 +796,134 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n                 StructRest::None => {}\n             }\n         }\n-        ExprKind::Tup(ref subexpressions) => {\n+        ExprKind::Tup(subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        ExprKind::Call(ref callee_expression, ref arguments) => {\n+        ExprKind::Call(callee_expression, arguments) => {\n             visitor.visit_expr(callee_expression);\n             walk_list!(visitor, visit_expr, arguments);\n         }\n-        ExprKind::MethodCall(ref segment, ref arguments, _span) => {\n-            visitor.visit_path_segment(expression.span, segment);\n-            walk_list!(visitor, visit_expr, arguments);\n+        ExprKind::MethodCall(box MethodCall { seg, receiver, args, span: _ }) => {\n+            visitor.visit_path_segment(seg);\n+            visitor.visit_expr(receiver);\n+            walk_list!(visitor, visit_expr, args);\n         }\n-        ExprKind::Binary(_, ref left_expression, ref right_expression) => {\n+        ExprKind::Binary(_, left_expression, right_expression) => {\n             visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression)\n         }\n-        ExprKind::AddrOf(_, _, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n+        ExprKind::AddrOf(_, _, subexpression) | ExprKind::Unary(_, subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n-        ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {\n+        ExprKind::Cast(subexpression, typ) | ExprKind::Type(subexpression, typ) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ty(typ)\n         }\n-        ExprKind::Let(ref pat, ref expr, _) => {\n+        ExprKind::Let(pat, expr, _) => {\n             visitor.visit_pat(pat);\n             visitor.visit_expr(expr);\n         }\n-        ExprKind::If(ref head_expression, ref if_block, ref optional_else) => {\n+        ExprKind::If(head_expression, if_block, optional_else) => {\n             visitor.visit_expr(head_expression);\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprKind::While(ref subexpression, ref block, ref opt_label) => {\n+        ExprKind::While(subexpression, block, opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n         }\n-        ExprKind::ForLoop(ref pattern, ref subexpression, ref block, ref opt_label) => {\n+        ExprKind::ForLoop(pattern, subexpression, block, opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n         }\n-        ExprKind::Loop(ref block, ref opt_label) => {\n+        ExprKind::Loop(block, opt_label, _) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n         }\n-        ExprKind::Match(ref subexpression, ref arms) => {\n+        ExprKind::Match(subexpression, arms) => {\n             visitor.visit_expr(subexpression);\n             walk_list!(visitor, visit_arm, arms);\n         }\n-        ExprKind::Closure(ref binder, _, _, _, ref decl, ref body, _decl_span) => {\n-            visitor.visit_fn(FnKind::Closure(binder, decl, body), expression.span, expression.id)\n+        ExprKind::Closure(box Closure {\n+            binder,\n+            capture_clause: _,\n+            asyncness: _,\n+            constness: _,\n+            movability: _,\n+            fn_decl,\n+            body,\n+            fn_decl_span: _,\n+            fn_arg_span: _,\n+        }) => {\n+            visitor.visit_fn(FnKind::Closure(binder, fn_decl, body), expression.span, expression.id)\n         }\n-        ExprKind::Block(ref block, ref opt_label) => {\n+        ExprKind::Block(block, opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n         }\n-        ExprKind::Async(_, _, ref body) => {\n+        ExprKind::Async(_, body) => {\n             visitor.visit_block(body);\n         }\n-        ExprKind::Await(ref expr) => visitor.visit_expr(expr),\n-        ExprKind::Assign(ref lhs, ref rhs, _) => {\n+        ExprKind::Await(expr, _) => visitor.visit_expr(expr),\n+        ExprKind::Assign(lhs, rhs, _) => {\n             visitor.visit_expr(lhs);\n             visitor.visit_expr(rhs);\n         }\n-        ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n+        ExprKind::AssignOp(_, left_expression, right_expression) => {\n             visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression);\n         }\n-        ExprKind::Field(ref subexpression, ident) => {\n+        ExprKind::Field(subexpression, ident) => {\n             visitor.visit_expr(subexpression);\n-            visitor.visit_ident(ident);\n+            visitor.visit_ident(*ident);\n         }\n-        ExprKind::Index(ref main_expression, ref index_expression) => {\n+        ExprKind::Index(main_expression, index_expression) => {\n             visitor.visit_expr(main_expression);\n             visitor.visit_expr(index_expression)\n         }\n-        ExprKind::Range(ref start, ref end, _) => {\n+        ExprKind::Range(start, end, _) => {\n             walk_list!(visitor, visit_expr, start);\n             walk_list!(visitor, visit_expr, end);\n         }\n         ExprKind::Underscore => {}\n-        ExprKind::Path(ref maybe_qself, ref path) => {\n-            if let Some(ref qself) = *maybe_qself {\n+        ExprKind::Path(maybe_qself, path) => {\n+            if let Some(qself) = maybe_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, expression.id)\n         }\n-        ExprKind::Break(ref opt_label, ref opt_expr) => {\n+        ExprKind::Break(opt_label, opt_expr) => {\n             walk_list!(visitor, visit_label, opt_label);\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n-        ExprKind::Continue(ref opt_label) => {\n+        ExprKind::Continue(opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n         }\n-        ExprKind::Ret(ref optional_expression) => {\n+        ExprKind::Ret(optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n-        ExprKind::Yeet(ref optional_expression) => {\n+        ExprKind::Yeet(optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n-        ExprKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n-        ExprKind::Paren(ref subexpression) => visitor.visit_expr(subexpression),\n-        ExprKind::InlineAsm(ref asm) => visitor.visit_inline_asm(asm),\n-        ExprKind::Yield(ref optional_expression) => {\n+        ExprKind::MacCall(mac) => visitor.visit_mac_call(mac),\n+        ExprKind::Paren(subexpression) => visitor.visit_expr(subexpression),\n+        ExprKind::InlineAsm(asm) => visitor.visit_inline_asm(asm),\n+        ExprKind::FormatArgs(f) => visitor.visit_format_args(f),\n+        ExprKind::OffsetOf(container, fields) => {\n+            visitor.visit_ty(container);\n+            for &field in fields {\n+                visitor.visit_ident(field);\n+            }\n+        }\n+        ExprKind::Yield(optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n-        ExprKind::Try(ref subexpression) => visitor.visit_expr(subexpression),\n-        ExprKind::TryBlock(ref body) => visitor.visit_block(body),\n-        ExprKind::Lit(_) | ExprKind::Err => {}\n+        ExprKind::Try(subexpression) => visitor.visit_expr(subexpression),\n+        ExprKind::TryBlock(body) => visitor.visit_block(body),\n+        ExprKind::Lit(_) | ExprKind::IncludedBytes(..) | ExprKind::Err => {}\n     }\n \n     visitor.visit_expr_post(expression)\n@@ -948,24 +943,24 @@ pub fn walk_arm<'a, V: Visitor<'a>>(visitor: &mut V, arm: &'a Arm) {\n }\n \n pub fn walk_vis<'a, V: Visitor<'a>>(visitor: &mut V, vis: &'a Visibility) {\n-    if let VisibilityKind::Restricted { ref path, id } = vis.kind {\n+    if let VisibilityKind::Restricted { ref path, id, shorthand: _ } = vis.kind {\n         visitor.visit_path(path, id);\n     }\n }\n \n pub fn walk_attribute<'a, V: Visitor<'a>>(visitor: &mut V, attr: &'a Attribute) {\n-    match attr.kind {\n-        AttrKind::Normal(ref item, ref _tokens) => walk_mac_args(visitor, &item.args),\n+    match &attr.kind {\n+        AttrKind::Normal(normal) => walk_attr_args(visitor, &normal.item.args),\n         AttrKind::DocComment(..) => {}\n     }\n }\n \n-pub fn walk_mac_args<'a, V: Visitor<'a>>(visitor: &mut V, args: &'a MacArgs) {\n+pub fn walk_attr_args<'a, V: Visitor<'a>>(visitor: &mut V, args: &'a AttrArgs) {\n     match args {\n-        MacArgs::Empty => {}\n-        MacArgs::Delimited(_dspan, _delim, _tokens) => {}\n-        MacArgs::Eq(_eq_span, MacArgsEq::Ast(expr)) => visitor.visit_expr(expr),\n-        MacArgs::Eq(_, MacArgsEq::Hir(lit)) => {\n+        AttrArgs::Empty => {}\n+        AttrArgs::Delimited(_) => {}\n+        AttrArgs::Eq(_eq_span, AttrArgsEq::Ast(expr)) => visitor.visit_expr(expr),\n+        AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n             unreachable!(\"in literal form when walking mac args eq: {:?}\", lit)\n         }\n     }"}, {"sha": "6b0da256505063a55be90c16f9e7a4738326bcf7", "filename": "compiler/rustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2FCargo.toml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -7,17 +7,18 @@ edition = \"2021\"\n doctest = false\n \n [dependencies]\n-rustc_arena = { path = \"../rustc_arena\" }\n-tracing = \"0.1\"\n+rustc_ast = { path = \"../rustc_ast\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n-rustc_hir = { path = \"../rustc_hir\" }\n-rustc_target = { path = \"../rustc_target\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_errors = { path = \"../rustc_errors\" }\n+rustc_hir = { path = \"../rustc_hir\" }\n+rustc_fluent_macro = { path = \"../rustc_fluent_macro\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_middle = { path = \"../rustc_middle\" }\n-rustc_query_system = { path = \"../rustc_query_system\" }\n-rustc_span = { path = \"../rustc_span\" }\n-rustc_errors = { path = \"../rustc_errors\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_session = { path = \"../rustc_session\" }\n-rustc_ast = { path = \"../rustc_ast\" }\n+rustc_span = { path = \"../rustc_span\" }\n+rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n+thin-vec = \"0.2.12\"\n+tracing = \"0.1\""}, {"sha": "f63a9bfcd705585809bda87e3c2207fcb6ca7ff1", "filename": "compiler/rustc_ast_lowering/messages.ftl", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fmessages.ftl?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -0,0 +1,153 @@\n+ast_lowering_abi_specified_multiple_times =\n+    `{$prev_name}` ABI specified multiple times\n+    .label = previously specified here\n+    .note = these ABIs are equivalent on the current target\n+\n+ast_lowering_arbitrary_expression_in_pattern =\n+    arbitrary expressions aren't allowed in patterns\n+\n+ast_lowering_argument = argument\n+\n+ast_lowering_assoc_ty_parentheses =\n+    parenthesized generic arguments cannot be used in associated type constraints\n+\n+ast_lowering_async_generators_not_supported =\n+    `async` generators are not yet supported\n+\n+ast_lowering_async_non_move_closure_not_supported =\n+    `async` non-`move` closures with parameters are not currently supported\n+    .help = consider using `let` statements to manually capture variables by reference before entering an `async move` closure\n+\n+ast_lowering_att_syntax_only_x86 =\n+    the `att_syntax` option is only supported on x86\n+\n+ast_lowering_await_only_in_async_fn_and_blocks =\n+    `await` is only allowed inside `async` functions and blocks\n+    .label = only allowed inside `async` functions and blocks\n+\n+ast_lowering_bad_return_type_notation_inputs =\n+    argument types not allowed with return type notation\n+    .suggestion = remove the input types\n+\n+ast_lowering_bad_return_type_notation_needs_dots =\n+    return type notation arguments must be elided with `..`\n+    .suggestion = add `..`\n+\n+ast_lowering_bad_return_type_notation_output =\n+    return type not allowed with return type notation\n+    .suggestion = remove the return type\n+\n+ast_lowering_base_expression_double_dot =\n+    base expression required after `..`\n+    .label = add a base expression here\n+\n+ast_lowering_clobber_abi_not_supported =\n+    `clobber_abi` is not supported on this target\n+\n+ast_lowering_closure_cannot_be_static = closures cannot be static\n+\n+ast_lowering_does_not_support_modifiers =\n+    the `{$class_name}` register class does not support template modifiers\n+\n+ast_lowering_extra_double_dot =\n+    `..` can only be used once per {$ctx} pattern\n+    .label = can only be used once per {$ctx} pattern\n+\n+ast_lowering_functional_record_update_destructuring_assignment =\n+    functional record updates are not allowed in destructuring assignments\n+    .suggestion = consider removing the trailing pattern\n+\n+ast_lowering_generator_too_many_parameters =\n+    too many parameters for a generator (expected 0 or 1 parameters)\n+\n+ast_lowering_generic_type_with_parentheses =\n+    parenthesized type parameters may only be used with a `Fn` trait\n+    .label = only `Fn` traits may use parentheses\n+\n+ast_lowering_inclusive_range_with_no_end = inclusive range with no end\n+\n+ast_lowering_inline_asm_unsupported_target =\n+    inline assembly is unsupported on this target\n+\n+ast_lowering_invalid_abi =\n+    invalid ABI: found `{$abi}`\n+    .label = invalid ABI\n+    .note = invoke `{$command}` for a full list of supported calling conventions.\n+\n+ast_lowering_invalid_abi_clobber_abi =\n+    invalid ABI for `clobber_abi`\n+    .note = the following ABIs are supported on this target: {$supported_abis}\n+\n+ast_lowering_invalid_abi_suggestion = did you mean\n+\n+ast_lowering_invalid_asm_template_modifier_const =\n+    asm template modifiers are not allowed for `const` arguments\n+\n+ast_lowering_invalid_asm_template_modifier_reg_class =\n+    invalid asm template modifier for this register class\n+\n+ast_lowering_invalid_asm_template_modifier_sym =\n+    asm template modifiers are not allowed for `sym` arguments\n+\n+ast_lowering_invalid_register =\n+    invalid register `{$reg}`: {$error}\n+\n+ast_lowering_invalid_register_class =\n+    invalid register class `{$reg_class}`: {$error}\n+\n+ast_lowering_misplaced_assoc_ty_binding =\n+    associated type bounds are only allowed in where clauses and function signatures, not in {$position}\n+\n+ast_lowering_misplaced_double_dot =\n+    `..` patterns are not allowed here\n+    .note = only allowed in tuple, tuple struct, and slice patterns\n+\n+ast_lowering_misplaced_impl_trait =\n+    `impl Trait` only allowed in function and inherent method return types, not in {$position}\n+\n+ast_lowering_misplaced_relax_trait_bound =\n+    `?Trait` bounds are only permitted at the point where a type parameter is declared\n+\n+ast_lowering_not_supported_for_lifetime_binder_async_closure =\n+    `for<...>` binders on `async` closures are not currently supported\n+\n+ast_lowering_previously_used_here = previously used here\n+\n+ast_lowering_register1 = register `{$reg1_name}`\n+\n+ast_lowering_register2 = register `{$reg2_name}`\n+\n+ast_lowering_register_class_only_clobber =\n+    register class `{$reg_class_name}` can only be used as a clobber, not as an input or output\n+\n+ast_lowering_register_conflict =\n+    register `{$reg1_name}` conflicts with register `{$reg2_name}`\n+    .help = use `lateout` instead of `out` to avoid conflict\n+\n+ast_lowering_remove_parentheses = remove these parentheses\n+\n+ast_lowering_sub_tuple_binding =\n+    `{$ident_name} @` is not allowed in a {$ctx}\n+    .label = this is only allowed in slice patterns\n+    .help = remove this and bind each tuple field independently\n+\n+ast_lowering_sub_tuple_binding_suggestion = if you don't need to use the contents of {$ident}, discard the tuple's remaining fields\n+\n+ast_lowering_support_modifiers =\n+    the `{$class_name}` register class supports the following template modifiers: {$modifiers}\n+\n+ast_lowering_template_modifier = template modifier\n+\n+ast_lowering_this_not_async = this is not `async`\n+\n+ast_lowering_trait_fn_async =\n+    functions in traits cannot be declared `async`\n+    .label = `async` because of this\n+    .note = `async` trait functions are not currently supported\n+    .note2 = consider using the `async-trait` crate: https://crates.io/crates/async-trait\n+\n+ast_lowering_underscore_expr_lhs_assign =\n+    in expressions, `_` can only be used on the left-hand side of an assignment\n+    .label = `_` not allowed here\n+\n+ast_lowering_use_angle_brackets = use angle brackets instead"}, {"sha": "d350498bc965a7063406067837d9d44988566a0d", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 109, "deletions": 150, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -1,12 +1,17 @@\n use crate::{ImplTraitContext, ImplTraitPosition, ParamMode, ResolverAstLoweringExt};\n \n+use super::errors::{\n+    AbiSpecifiedMultipleTimes, AttSyntaxOnlyX86, ClobberAbiNotSupported,\n+    InlineAsmUnsupportedTarget, InvalidAbiClobberAbi, InvalidAsmTemplateModifierConst,\n+    InvalidAsmTemplateModifierRegClass, InvalidAsmTemplateModifierRegClassSub,\n+    InvalidAsmTemplateModifierSym, InvalidRegister, InvalidRegisterClass, RegisterClassOnlyClobber,\n+    RegisterConflict,\n+};\n use super::LoweringContext;\n \n use rustc_ast::ptr::P;\n use rustc_ast::*;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::stable_set::FxHashSet;\n-use rustc_errors::struct_span_err;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::definitions::DefPathData;\n@@ -27,13 +32,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let asm_arch =\n             if self.tcx.sess.opts.actually_rustdoc { None } else { self.tcx.sess.asm_arch };\n         if asm_arch.is_none() && !self.tcx.sess.opts.actually_rustdoc {\n-            struct_span_err!(\n-                self.tcx.sess,\n-                sp,\n-                E0472,\n-                \"inline assembly is unsupported on this target\"\n-            )\n-            .emit();\n+            self.tcx.sess.emit_err(InlineAsmUnsupportedTarget { span: sp });\n         }\n         if let Some(asm_arch) = asm_arch {\n             // Inline assembly is currently only stable for these architectures.\n@@ -45,6 +44,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     | asm::InlineAsmArch::AArch64\n                     | asm::InlineAsmArch::RiscV32\n                     | asm::InlineAsmArch::RiscV64\n+                    | asm::InlineAsmArch::LoongArch64\n             );\n             if !is_stable && !self.tcx.features().asm_experimental_arch {\n                 feature_err(\n@@ -60,10 +60,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             && !matches!(asm_arch, Some(asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64))\n             && !self.tcx.sess.opts.actually_rustdoc\n         {\n-            self.tcx\n-                .sess\n-                .struct_span_err(sp, \"the `att_syntax` option is only supported on x86\")\n-                .emit();\n+            self.tcx.sess.emit_err(AttSyntaxOnlyX86 { span: sp });\n         }\n         if asm.options.contains(InlineAsmOptions::MAY_UNWIND) && !self.tcx.features().asm_unwind {\n             feature_err(\n@@ -75,59 +72,45 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .emit();\n         }\n \n-        let mut clobber_abis = FxHashMap::default();\n+        let mut clobber_abis = FxIndexMap::default();\n         if let Some(asm_arch) = asm_arch {\n             for (abi_name, abi_span) in &asm.clobber_abis {\n                 match asm::InlineAsmClobberAbi::parse(asm_arch, &self.tcx.sess.target, *abi_name) {\n                     Ok(abi) => {\n                         // If the abi was already in the list, emit an error\n                         match clobber_abis.get(&abi) {\n                             Some((prev_name, prev_sp)) => {\n-                                let mut err = self.tcx.sess.struct_span_err(\n-                                    *abi_span,\n-                                    &format!(\"`{}` ABI specified multiple times\", prev_name),\n-                                );\n-                                err.span_label(*prev_sp, \"previously specified here\");\n-\n                                 // Multiple different abi names may actually be the same ABI\n                                 // If the specified ABIs are not the same name, alert the user that they resolve to the same ABI\n                                 let source_map = self.tcx.sess.source_map();\n-                                if source_map.span_to_snippet(*prev_sp)\n-                                    != source_map.span_to_snippet(*abi_span)\n-                                {\n-                                    err.note(\"these ABIs are equivalent on the current target\");\n-                                }\n+                                let equivalent = (source_map.span_to_snippet(*prev_sp)\n+                                    != source_map.span_to_snippet(*abi_span))\n+                                .then_some(());\n \n-                                err.emit();\n+                                self.tcx.sess.emit_err(AbiSpecifiedMultipleTimes {\n+                                    abi_span: *abi_span,\n+                                    prev_name: *prev_name,\n+                                    prev_span: *prev_sp,\n+                                    equivalent,\n+                                });\n                             }\n                             None => {\n-                                clobber_abis.insert(abi, (abi_name, *abi_span));\n+                                clobber_abis.insert(abi, (*abi_name, *abi_span));\n                             }\n                         }\n                     }\n                     Err(&[]) => {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                *abi_span,\n-                                \"`clobber_abi` is not supported on this target\",\n-                            )\n-                            .emit();\n+                        self.tcx.sess.emit_err(ClobberAbiNotSupported { abi_span: *abi_span });\n                     }\n                     Err(supported_abis) => {\n-                        let mut err = self\n-                            .tcx\n-                            .sess\n-                            .struct_span_err(*abi_span, \"invalid ABI for `clobber_abi`\");\n                         let mut abis = format!(\"`{}`\", supported_abis[0]);\n                         for m in &supported_abis[1..] {\n-                            let _ = write!(abis, \", `{}`\", m);\n+                            let _ = write!(abis, \", `{m}`\");\n                         }\n-                        err.note(&format!(\n-                            \"the following ABIs are supported on this target: {}\",\n-                            abis\n-                        ));\n-                        err.emit();\n+                        self.tcx.sess.emit_err(InvalidAbiClobberAbi {\n+                            abi_span: *abi_span,\n+                            supported_abis: abis,\n+                        });\n                     }\n                 }\n             }\n@@ -141,57 +124,59 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .operands\n             .iter()\n             .map(|(op, op_sp)| {\n-                let lower_reg = |reg| match reg {\n-                    InlineAsmRegOrRegClass::Reg(s) => {\n+                let lower_reg = |&reg: &_| match reg {\n+                    InlineAsmRegOrRegClass::Reg(reg) => {\n                         asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n-                            asm::InlineAsmReg::parse(asm_arch, s).unwrap_or_else(|e| {\n-                                let msg = format!(\"invalid register `{}`: {}\", s.as_str(), e);\n-                                sess.struct_span_err(*op_sp, &msg).emit();\n+                            asm::InlineAsmReg::parse(asm_arch, reg).unwrap_or_else(|error| {\n+                                sess.emit_err(InvalidRegister { op_span: *op_sp, reg, error });\n                                 asm::InlineAsmReg::Err\n                             })\n                         } else {\n                             asm::InlineAsmReg::Err\n                         })\n                     }\n-                    InlineAsmRegOrRegClass::RegClass(s) => {\n+                    InlineAsmRegOrRegClass::RegClass(reg_class) => {\n                         asm::InlineAsmRegOrRegClass::RegClass(if let Some(asm_arch) = asm_arch {\n-                            asm::InlineAsmRegClass::parse(asm_arch, s).unwrap_or_else(|e| {\n-                                let msg = format!(\"invalid register class `{}`: {}\", s.as_str(), e);\n-                                sess.struct_span_err(*op_sp, &msg).emit();\n-                                asm::InlineAsmRegClass::Err\n-                            })\n+                            asm::InlineAsmRegClass::parse(asm_arch, reg_class).unwrap_or_else(\n+                                |error| {\n+                                    sess.emit_err(InvalidRegisterClass {\n+                                        op_span: *op_sp,\n+                                        reg_class,\n+                                        error,\n+                                    });\n+                                    asm::InlineAsmRegClass::Err\n+                                },\n+                            )\n                         } else {\n                             asm::InlineAsmRegClass::Err\n                         })\n                     }\n                 };\n \n-                let op = match *op {\n-                    InlineAsmOperand::In { reg, ref expr } => hir::InlineAsmOperand::In {\n+                let op = match op {\n+                    InlineAsmOperand::In { reg, expr } => hir::InlineAsmOperand::In {\n                         reg: lower_reg(reg),\n-                        expr: self.lower_expr_mut(expr),\n+                        expr: self.lower_expr(expr),\n                     },\n-                    InlineAsmOperand::Out { reg, late, ref expr } => hir::InlineAsmOperand::Out {\n+                    InlineAsmOperand::Out { reg, late, expr } => hir::InlineAsmOperand::Out {\n                         reg: lower_reg(reg),\n-                        late,\n-                        expr: expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n+                        late: *late,\n+                        expr: expr.as_ref().map(|expr| self.lower_expr(expr)),\n                     },\n-                    InlineAsmOperand::InOut { reg, late, ref expr } => {\n-                        hir::InlineAsmOperand::InOut {\n-                            reg: lower_reg(reg),\n-                            late,\n-                            expr: self.lower_expr_mut(expr),\n-                        }\n-                    }\n-                    InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n+                    InlineAsmOperand::InOut { reg, late, expr } => hir::InlineAsmOperand::InOut {\n+                        reg: lower_reg(reg),\n+                        late: *late,\n+                        expr: self.lower_expr(expr),\n+                    },\n+                    InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n                         hir::InlineAsmOperand::SplitInOut {\n                             reg: lower_reg(reg),\n-                            late,\n-                            in_expr: self.lower_expr_mut(in_expr),\n-                            out_expr: out_expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n+                            late: *late,\n+                            in_expr: self.lower_expr(in_expr),\n+                            out_expr: out_expr.as_ref().map(|expr| self.lower_expr(expr)),\n                         }\n                     }\n-                    InlineAsmOperand::Const { ref anon_const } => {\n+                    InlineAsmOperand::Const { anon_const } => {\n                         if !self.tcx.features().asm_const {\n                             feature_err(\n                                 &sess.parse_sess,\n@@ -205,27 +190,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             anon_const: self.lower_anon_const(anon_const),\n                         }\n                     }\n-                    InlineAsmOperand::Sym { ref sym } => {\n-                        if !self.tcx.features().asm_sym {\n-                            feature_err(\n-                                &sess.parse_sess,\n-                                sym::asm_sym,\n-                                *op_sp,\n-                                \"sym operands for inline assembly are unstable\",\n-                            )\n-                            .emit();\n-                        }\n-\n+                    InlineAsmOperand::Sym { sym } => {\n                         let static_def_id = self\n                             .resolver\n                             .get_partial_res(sym.id)\n-                            .filter(|res| res.unresolved_segments() == 0)\n-                            .and_then(|res| {\n-                                if let Res::Def(DefKind::Static(_), def_id) = res.base_res() {\n-                                    Some(def_id)\n-                                } else {\n-                                    None\n-                                }\n+                            .and_then(|res| res.full_res())\n+                            .and_then(|res| match res {\n+                                Res::Def(DefKind::Static(_), def_id) => Some(def_id),\n+                                _ => None,\n                             });\n \n                         if let Some(def_id) = static_def_id {\n@@ -234,7 +206,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 &sym.qself,\n                                 &sym.path,\n                                 ParamMode::Optional,\n-                                ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                                &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                             );\n                             hir::InlineAsmOperand::SymStatic { path, def_id }\n                         } else {\n@@ -251,7 +223,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             // Wrap the expression in an AnonConst.\n                             let parent_def_id = self.current_hir_id_owner;\n                             let node_id = self.next_node_id();\n-                            self.create_def(parent_def_id, node_id, DefPathData::AnonConst);\n+                            self.create_def(\n+                                parent_def_id.def_id,\n+                                node_id,\n+                                DefPathData::AnonConst,\n+                                *op_sp,\n+                            );\n                             let anon_const = AnonConst { id: node_id, value: P(expr) };\n                             hir::InlineAsmOperand::SymFn {\n                                 anon_const: self.lower_anon_const(&anon_const),\n@@ -283,50 +260,39 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         }\n                         let valid_modifiers = class.valid_modifiers(asm_arch.unwrap());\n                         if !valid_modifiers.contains(&modifier) {\n-                            let mut err = sess.struct_span_err(\n-                                placeholder_span,\n-                                \"invalid asm template modifier for this register class\",\n-                            );\n-                            err.span_label(placeholder_span, \"template modifier\");\n-                            err.span_label(op_sp, \"argument\");\n-                            if !valid_modifiers.is_empty() {\n+                            let sub = if !valid_modifiers.is_empty() {\n                                 let mut mods = format!(\"`{}`\", valid_modifiers[0]);\n                                 for m in &valid_modifiers[1..] {\n-                                    let _ = write!(mods, \", `{}`\", m);\n+                                    let _ = write!(mods, \", `{m}`\");\n+                                }\n+                                InvalidAsmTemplateModifierRegClassSub::SupportModifier {\n+                                    class_name: class.name(),\n+                                    modifiers: mods,\n                                 }\n-                                err.note(&format!(\n-                                    \"the `{}` register class supports \\\n-                                     the following template modifiers: {}\",\n-                                    class.name(),\n-                                    mods\n-                                ));\n                             } else {\n-                                err.note(&format!(\n-                                    \"the `{}` register class does not support template modifiers\",\n-                                    class.name()\n-                                ));\n-                            }\n-                            err.emit();\n+                                InvalidAsmTemplateModifierRegClassSub::DoesNotSupportModifier {\n+                                    class_name: class.name(),\n+                                }\n+                            };\n+                            sess.emit_err(InvalidAsmTemplateModifierRegClass {\n+                                placeholder_span,\n+                                op_span: op_sp,\n+                                sub,\n+                            });\n                         }\n                     }\n                     hir::InlineAsmOperand::Const { .. } => {\n-                        let mut err = sess.struct_span_err(\n+                        sess.emit_err(InvalidAsmTemplateModifierConst {\n                             placeholder_span,\n-                            \"asm template modifiers are not allowed for `const` arguments\",\n-                        );\n-                        err.span_label(placeholder_span, \"template modifier\");\n-                        err.span_label(op_sp, \"argument\");\n-                        err.emit();\n+                            op_span: op_sp,\n+                        });\n                     }\n                     hir::InlineAsmOperand::SymFn { .. }\n                     | hir::InlineAsmOperand::SymStatic { .. } => {\n-                        let mut err = sess.struct_span_err(\n+                        sess.emit_err(InvalidAsmTemplateModifierSym {\n                             placeholder_span,\n-                            \"asm template modifiers are not allowed for `sym` arguments\",\n-                        );\n-                        err.span_label(placeholder_span, \"template modifier\");\n-                        err.span_label(op_sp, \"argument\");\n-                        err.emit();\n+                            op_span: op_sp,\n+                        });\n                     }\n                 }\n             }\n@@ -347,12 +313,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 // require that the operand name an explicit register, not a\n                 // register class.\n                 if reg_class.is_clobber_only(asm_arch.unwrap()) && !op.is_clobber() {\n-                    let msg = format!(\n-                        \"register class `{}` can only be used as a clobber, \\\n-                             not as an input or output\",\n-                        reg_class.name()\n-                    );\n-                    sess.struct_span_err(op_sp, &msg).emit();\n+                    sess.emit_err(RegisterClassOnlyClobber {\n+                        op_span: op_sp,\n+                        reg_class_name: reg_class.name(),\n+                    });\n                     continue;\n                 }\n \n@@ -387,21 +351,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                     skip = true;\n \n                                     let idx2 = *o.get();\n-                                    let &(ref op2, op_sp2) = &operands[idx2];\n+                                    let (ref op2, op_sp2) = operands[idx2];\n                                     let Some(asm::InlineAsmRegOrRegClass::Reg(reg2)) = op2.reg() else {\n                                         unreachable!();\n                                     };\n \n-                                    let msg = format!(\n-                                        \"register `{}` conflicts with register `{}`\",\n-                                        reg.name(),\n-                                        reg2.name()\n-                                    );\n-                                    let mut err = sess.struct_span_err(op_sp, &msg);\n-                                    err.span_label(op_sp, &format!(\"register `{}`\", reg.name()));\n-                                    err.span_label(op_sp2, &format!(\"register `{}`\", reg2.name()));\n-\n-                                    match (op, op2) {\n+                                    let in_out = match (op, op2) {\n                                         (\n                                             hir::InlineAsmOperand::In { .. },\n                                             hir::InlineAsmOperand::Out { late, .. },\n@@ -412,14 +367,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                         ) => {\n                                             assert!(!*late);\n                                             let out_op_sp = if input { op_sp2 } else { op_sp };\n-                                            let msg = \"use `lateout` instead of \\\n-                                                       `out` to avoid conflict\";\n-                                            err.span_help(out_op_sp, msg);\n-                                        }\n-                                        _ => {}\n-                                    }\n+                                            Some(out_op_sp)\n+                                        },\n+                                        _ => None,\n+                                    };\n \n-                                    err.emit();\n+                                    sess.emit_err(RegisterConflict {\n+                                        op_span1: op_sp,\n+                                        op_span2: op_sp2,\n+                                        reg1_name: reg.name(),\n+                                        reg2_name: reg2.name(),\n+                                        in_out\n+                                    });\n                                 }\n                                 Entry::Vacant(v) => {\n                                     if r == reg {"}, {"sha": "d310f72f7a3f8f8bdb3527ecf0fa3cc10c0474b9", "filename": "compiler/rustc_ast_lowering/src/block.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -1,8 +1,6 @@\n use crate::{ImplTraitContext, ImplTraitPosition, LoweringContext};\n use rustc_ast::{Block, BlockCheckMode, Local, LocalKind, Stmt, StmtKind};\n use rustc_hir as hir;\n-use rustc_session::parse::feature_err;\n-use rustc_span::sym;\n \n use smallvec::SmallVec;\n \n@@ -33,16 +31,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut stmts = SmallVec::<[hir::Stmt<'hir>; 8]>::new();\n         let mut expr = None;\n         while let [s, tail @ ..] = ast_stmts {\n-            match s.kind {\n-                StmtKind::Local(ref local) => {\n+            match &s.kind {\n+                StmtKind::Local(local) => {\n                     let hir_id = self.lower_node_id(s.id);\n                     let local = self.lower_local(local);\n                     self.alias_attrs(hir_id, local.hir_id);\n                     let kind = hir::StmtKind::Local(local);\n                     let span = self.lower_span(s.span);\n                     stmts.push(hir::Stmt { hir_id, kind, span });\n                 }\n-                StmtKind::Item(ref it) => {\n+                StmtKind::Item(it) => {\n                     stmts.extend(self.lower_item_ref(it).into_iter().enumerate().map(\n                         |(i, item_id)| {\n                             let hir_id = match i {\n@@ -55,7 +53,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         },\n                     ));\n                 }\n-                StmtKind::Expr(ref e) => {\n+                StmtKind::Expr(e) => {\n                     let e = self.lower_expr(e);\n                     if tail.is_empty() {\n                         expr = Some(e);\n@@ -67,7 +65,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         stmts.push(hir::Stmt { hir_id, kind, span });\n                     }\n                 }\n-                StmtKind::Semi(ref e) => {\n+                StmtKind::Semi(e) => {\n                     let e = self.lower_expr(e);\n                     let hir_id = self.lower_node_id(s.id);\n                     self.alias_attrs(hir_id, e.hir_id);\n@@ -87,20 +85,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let ty = l\n             .ty\n             .as_ref()\n-            .map(|t| self.lower_ty(t, ImplTraitContext::Disallowed(ImplTraitPosition::Variable)));\n+            .map(|t| self.lower_ty(t, &ImplTraitContext::Disallowed(ImplTraitPosition::Variable)));\n         let init = l.kind.init().map(|init| self.lower_expr(init));\n         let hir_id = self.lower_node_id(l.id);\n         let pat = self.lower_pat(&l.pat);\n         let els = if let LocalKind::InitElse(_, els) = &l.kind {\n-            if !self.tcx.features().let_else {\n-                feature_err(\n-                    &self.tcx.sess.parse_sess,\n-                    sym::let_else,\n-                    l.span,\n-                    \"`let...else` statements are unstable\",\n-                )\n-                .emit();\n-            }\n             Some(self.lower_block(els, false))\n         } else {\n             None"}, {"sha": "72dc52a632992dff29d57cbb7cb9c6ad1af0d090", "filename": "compiler/rustc_ast_lowering/src/errors.rs", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -0,0 +1,365 @@\n+use rustc_errors::DiagnosticArgFromDisplay;\n+use rustc_macros::{Diagnostic, Subdiagnostic};\n+use rustc_span::{symbol::Ident, Span, Symbol};\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_generic_type_with_parentheses, code = \"E0214\")]\n+pub struct GenericTypeWithParentheses {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: Option<UseAngleBrackets>,\n+}\n+\n+#[derive(Clone, Copy, Subdiagnostic)]\n+#[multipart_suggestion(ast_lowering_use_angle_brackets, applicability = \"maybe-incorrect\")]\n+pub struct UseAngleBrackets {\n+    #[suggestion_part(code = \"<\")]\n+    pub open_param: Span,\n+    #[suggestion_part(code = \">\")]\n+    pub close_param: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_lowering_invalid_abi, code = \"E0703\")]\n+#[note]\n+pub struct InvalidAbi {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub abi: Symbol,\n+    pub command: String,\n+    #[subdiagnostic]\n+    pub suggestion: Option<InvalidAbiSuggestion>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    ast_lowering_invalid_abi_suggestion,\n+    code = \"{suggestion}\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub struct InvalidAbiSuggestion {\n+    #[primary_span]\n+    pub span: Span,\n+    pub suggestion: String,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_assoc_ty_parentheses)]\n+pub struct AssocTyParentheses {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: AssocTyParenthesesSub,\n+}\n+\n+#[derive(Clone, Copy, Subdiagnostic)]\n+pub enum AssocTyParenthesesSub {\n+    #[multipart_suggestion(ast_lowering_remove_parentheses)]\n+    Empty {\n+        #[suggestion_part(code = \"\")]\n+        parentheses_span: Span,\n+    },\n+    #[multipart_suggestion(ast_lowering_use_angle_brackets)]\n+    NotEmpty {\n+        #[suggestion_part(code = \"<\")]\n+        open_param: Span,\n+        #[suggestion_part(code = \">\")]\n+        close_param: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_lowering_misplaced_impl_trait, code = \"E0562\")]\n+pub struct MisplacedImplTrait<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub position: DiagnosticArgFromDisplay<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_lowering_misplaced_assoc_ty_binding)]\n+pub struct MisplacedAssocTyBinding<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub position: DiagnosticArgFromDisplay<'a>,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_underscore_expr_lhs_assign)]\n+pub struct UnderscoreExprLhsAssign {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_base_expression_double_dot)]\n+pub struct BaseExpressionDoubleDot {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_await_only_in_async_fn_and_blocks, code = \"E0728\")]\n+pub struct AwaitOnlyInAsyncFnAndBlocks {\n+    #[primary_span]\n+    #[label]\n+    pub await_kw_span: Span,\n+    #[label(ast_lowering_this_not_async)]\n+    pub item_span: Option<Span>,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_generator_too_many_parameters, code = \"E0628\")]\n+pub struct GeneratorTooManyParameters {\n+    #[primary_span]\n+    pub fn_decl_span: Span,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_closure_cannot_be_static, code = \"E0697\")]\n+pub struct ClosureCannotBeStatic {\n+    #[primary_span]\n+    pub fn_decl_span: Span,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[help]\n+#[diag(ast_lowering_async_non_move_closure_not_supported, code = \"E0708\")]\n+pub struct AsyncNonMoveClosureNotSupported {\n+    #[primary_span]\n+    pub fn_decl_span: Span,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_functional_record_update_destructuring_assignment)]\n+pub struct FunctionalRecordUpdateDestructuringAssignment {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_async_generators_not_supported, code = \"E0727\")]\n+pub struct AsyncGeneratorsNotSupported {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_inline_asm_unsupported_target, code = \"E0472\")]\n+pub struct InlineAsmUnsupportedTarget {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_att_syntax_only_x86)]\n+pub struct AttSyntaxOnlyX86 {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_abi_specified_multiple_times)]\n+pub struct AbiSpecifiedMultipleTimes {\n+    #[primary_span]\n+    pub abi_span: Span,\n+    pub prev_name: Symbol,\n+    #[label]\n+    pub prev_span: Span,\n+    #[note]\n+    pub equivalent: Option<()>,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_clobber_abi_not_supported)]\n+pub struct ClobberAbiNotSupported {\n+    #[primary_span]\n+    pub abi_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[note]\n+#[diag(ast_lowering_invalid_abi_clobber_abi)]\n+pub struct InvalidAbiClobberAbi {\n+    #[primary_span]\n+    pub abi_span: Span,\n+    pub supported_abis: String,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_invalid_register)]\n+pub struct InvalidRegister<'a> {\n+    #[primary_span]\n+    pub op_span: Span,\n+    pub reg: Symbol,\n+    pub error: &'a str,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_invalid_register_class)]\n+pub struct InvalidRegisterClass<'a> {\n+    #[primary_span]\n+    pub op_span: Span,\n+    pub reg_class: Symbol,\n+    pub error: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_lowering_invalid_asm_template_modifier_reg_class)]\n+pub struct InvalidAsmTemplateModifierRegClass {\n+    #[primary_span]\n+    #[label(ast_lowering_template_modifier)]\n+    pub placeholder_span: Span,\n+    #[label(ast_lowering_argument)]\n+    pub op_span: Span,\n+    #[subdiagnostic]\n+    pub sub: InvalidAsmTemplateModifierRegClassSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum InvalidAsmTemplateModifierRegClassSub {\n+    #[note(ast_lowering_support_modifiers)]\n+    SupportModifier { class_name: Symbol, modifiers: String },\n+    #[note(ast_lowering_does_not_support_modifiers)]\n+    DoesNotSupportModifier { class_name: Symbol },\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_invalid_asm_template_modifier_const)]\n+pub struct InvalidAsmTemplateModifierConst {\n+    #[primary_span]\n+    #[label(ast_lowering_template_modifier)]\n+    pub placeholder_span: Span,\n+    #[label(ast_lowering_argument)]\n+    pub op_span: Span,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_invalid_asm_template_modifier_sym)]\n+pub struct InvalidAsmTemplateModifierSym {\n+    #[primary_span]\n+    #[label(ast_lowering_template_modifier)]\n+    pub placeholder_span: Span,\n+    #[label(ast_lowering_argument)]\n+    pub op_span: Span,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_register_class_only_clobber)]\n+pub struct RegisterClassOnlyClobber {\n+    #[primary_span]\n+    pub op_span: Span,\n+    pub reg_class_name: Symbol,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_register_conflict)]\n+pub struct RegisterConflict<'a> {\n+    #[primary_span]\n+    #[label(ast_lowering_register1)]\n+    pub op_span1: Span,\n+    #[label(ast_lowering_register2)]\n+    pub op_span2: Span,\n+    pub reg1_name: &'a str,\n+    pub reg2_name: &'a str,\n+    #[help]\n+    pub in_out: Option<Span>,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[help]\n+#[diag(ast_lowering_sub_tuple_binding)]\n+pub struct SubTupleBinding<'a> {\n+    #[primary_span]\n+    #[label]\n+    #[suggestion(\n+        ast_lowering_sub_tuple_binding_suggestion,\n+        style = \"verbose\",\n+        code = \"..\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    pub span: Span,\n+    pub ident: Ident,\n+    pub ident_name: Symbol,\n+    pub ctx: &'a str,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_extra_double_dot)]\n+pub struct ExtraDoubleDot<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(ast_lowering_previously_used_here)]\n+    pub prev_span: Span,\n+    pub ctx: &'a str,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[note]\n+#[diag(ast_lowering_misplaced_double_dot)]\n+pub struct MisplacedDoubleDot {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_misplaced_relax_trait_bound)]\n+pub struct MisplacedRelaxTraitBound {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_not_supported_for_lifetime_binder_async_closure)]\n+pub struct NotSupportedForLifetimeBinderAsyncClosure {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_arbitrary_expression_in_pattern)]\n+pub struct ArbitraryExpressionInPattern {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_inclusive_range_with_no_end)]\n+pub struct InclusiveRangeWithNoEnd {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic, Clone, Copy)]\n+#[diag(ast_lowering_trait_fn_async, code = \"E0706\")]\n+#[note]\n+#[note(ast_lowering_note2)]\n+pub struct TraitFnAsync {\n+    #[primary_span]\n+    pub fn_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+pub enum BadReturnTypeNotation {\n+    #[diag(ast_lowering_bad_return_type_notation_inputs)]\n+    Inputs {\n+        #[primary_span]\n+        #[suggestion(code = \"()\", applicability = \"maybe-incorrect\")]\n+        span: Span,\n+    },\n+    #[diag(ast_lowering_bad_return_type_notation_output)]\n+    Output {\n+        #[primary_span]\n+        #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n+        span: Span,\n+    },\n+}"}, {"sha": "f52797c4f3f1dd4cf4a4c23dfae00de8246fc220", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 493, "deletions": 460, "changes": 953, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -1,19 +1,24 @@\n+use super::errors::{\n+    AsyncGeneratorsNotSupported, AsyncNonMoveClosureNotSupported, AwaitOnlyInAsyncFnAndBlocks,\n+    BaseExpressionDoubleDot, ClosureCannotBeStatic, FunctionalRecordUpdateDestructuringAssignment,\n+    GeneratorTooManyParameters, InclusiveRangeWithNoEnd, NotSupportedForLifetimeBinderAsyncClosure,\n+    UnderscoreExprLhsAssign,\n+};\n use super::ResolverAstLoweringExt;\n use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericArgs};\n use crate::{FnDeclKind, ImplTraitPosition};\n-\n use rustc_ast::attr;\n use rustc_ast::ptr::P as AstP;\n use rustc_ast::*;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_data_structures::thin_vec::ThinVec;\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::definitions::DefPathData;\n+use rustc_session::errors::report_lit_error;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n-use rustc_span::symbol::{sym, Ident};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::DUMMY_SP;\n+use thin_vec::{thin_vec, ThinVec};\n \n impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> &'hir [hir::Expr<'hir>] {\n@@ -26,234 +31,268 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     pub(super) fn lower_expr_mut(&mut self, e: &Expr) -> hir::Expr<'hir> {\n         ensure_sufficient_stack(|| {\n-            let kind = match e.kind {\n-                ExprKind::Box(ref inner) => hir::ExprKind::Box(self.lower_expr(inner)),\n-                ExprKind::Array(ref exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n-                ExprKind::ConstBlock(ref anon_const) => {\n-                    let anon_const = self.lower_anon_const(anon_const);\n-                    hir::ExprKind::ConstBlock(anon_const)\n+            match &e.kind {\n+                // Parenthesis expression does not have a HirId and is handled specially.\n+                ExprKind::Paren(ex) => {\n+                    let mut ex = self.lower_expr_mut(ex);\n+                    // Include parens in span, but only if it is a super-span.\n+                    if e.span.contains(ex.span) {\n+                        ex.span = self.lower_span(e.span);\n+                    }\n+                    // Merge attributes into the inner expression.\n+                    if !e.attrs.is_empty() {\n+                        let old_attrs =\n+                            self.attrs.get(&ex.hir_id.local_id).map(|la| *la).unwrap_or(&[]);\n+                        self.attrs.insert(\n+                            ex.hir_id.local_id,\n+                            &*self.arena.alloc_from_iter(\n+                                e.attrs\n+                                    .iter()\n+                                    .map(|a| self.lower_attr(a))\n+                                    .chain(old_attrs.iter().cloned()),\n+                            ),\n+                        );\n+                    }\n+                    return ex;\n                 }\n-                ExprKind::Repeat(ref expr, ref count) => {\n+                // Desugar `ExprForLoop`\n+                // from: `[opt_ident]: for <pat> in <head> <body>`\n+                //\n+                // This also needs special handling because the HirId of the returned `hir::Expr` will not\n+                // correspond to the `e.id`, so `lower_expr_for` handles attribute lowering itself.\n+                ExprKind::ForLoop(pat, head, body, opt_label) => {\n+                    return self.lower_expr_for(e, pat, head, body, *opt_label);\n+                }\n+                _ => (),\n+            }\n+\n+            let hir_id = self.lower_node_id(e.id);\n+            self.lower_attrs(hir_id, &e.attrs);\n+\n+            let kind = match &e.kind {\n+                ExprKind::Array(exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n+                ExprKind::ConstBlock(c) => {\n+                    let c = self.with_new_scopes(|this| hir::ConstBlock {\n+                        def_id: this.local_def_id(c.id),\n+                        hir_id: this.lower_node_id(c.id),\n+                        body: this.lower_const_body(c.value.span, Some(&c.value)),\n+                    });\n+                    hir::ExprKind::ConstBlock(c)\n+                }\n+                ExprKind::Repeat(expr, count) => {\n                     let expr = self.lower_expr(expr);\n                     let count = self.lower_array_length(count);\n                     hir::ExprKind::Repeat(expr, count)\n                 }\n-                ExprKind::Tup(ref elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n-                ExprKind::Call(ref f, ref args) => {\n-                    if e.attrs.get(0).map_or(false, |a| a.has_name(sym::rustc_box)) {\n-                        if let [inner] = &args[..] && e.attrs.len() == 1 {\n-                            let kind = hir::ExprKind::Box(self.lower_expr(&inner));\n-                            let hir_id = self.lower_node_id(e.id);\n-                            return hir::Expr { hir_id, kind, span: self.lower_span(e.span) };\n-                        } else {\n-                            self.tcx.sess\n-                                .struct_span_err(\n-                                    e.span,\n-                                    \"#[rustc_box] requires precisely one argument \\\n-                                    and no other attributes are allowed\",\n-                                )\n-                                .emit();\n-                            hir::ExprKind::Err\n-                        }\n-                    } else if let Some(legacy_args) = self.resolver.legacy_const_generic_args(f) {\n+                ExprKind::Tup(elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n+                ExprKind::Call(f, args) => {\n+                    if let Some(legacy_args) = self.resolver.legacy_const_generic_args(f) {\n                         self.lower_legacy_const_generics((**f).clone(), args.clone(), &legacy_args)\n                     } else {\n                         let f = self.lower_expr(f);\n                         hir::ExprKind::Call(f, self.lower_exprs(args))\n                     }\n                 }\n-                ExprKind::MethodCall(ref seg, ref args, span) => {\n+                ExprKind::MethodCall(box MethodCall { seg, receiver, args, span }) => {\n                     let hir_seg = self.arena.alloc(self.lower_path_segment(\n                         e.span,\n                         seg,\n                         ParamMode::Optional,\n                         ParenthesizedGenericArgs::Err,\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                        &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                     ));\n-                    let args = self.lower_exprs(args);\n-                    hir::ExprKind::MethodCall(hir_seg, args, self.lower_span(span))\n+                    let receiver = self.lower_expr(receiver);\n+                    let args =\n+                        self.arena.alloc_from_iter(args.iter().map(|x| self.lower_expr_mut(x)));\n+                    hir::ExprKind::MethodCall(hir_seg, receiver, args, self.lower_span(*span))\n                 }\n-                ExprKind::Binary(binop, ref lhs, ref rhs) => {\n-                    let binop = self.lower_binop(binop);\n+                ExprKind::Binary(binop, lhs, rhs) => {\n+                    let binop = self.lower_binop(*binop);\n                     let lhs = self.lower_expr(lhs);\n                     let rhs = self.lower_expr(rhs);\n                     hir::ExprKind::Binary(binop, lhs, rhs)\n                 }\n-                ExprKind::Unary(op, ref ohs) => {\n-                    let op = self.lower_unop(op);\n+                ExprKind::Unary(op, ohs) => {\n+                    let op = self.lower_unop(*op);\n                     let ohs = self.lower_expr(ohs);\n                     hir::ExprKind::Unary(op, ohs)\n                 }\n-                ExprKind::Lit(ref l) => {\n-                    hir::ExprKind::Lit(respan(self.lower_span(l.span), l.kind.clone()))\n+                ExprKind::Lit(token_lit) => {\n+                    let lit_kind = match LitKind::from_token_lit(*token_lit) {\n+                        Ok(lit_kind) => lit_kind,\n+                        Err(err) => {\n+                            report_lit_error(&self.tcx.sess.parse_sess, err, *token_lit, e.span);\n+                            LitKind::Err\n+                        }\n+                    };\n+                    let lit = self.arena.alloc(respan(self.lower_span(e.span), lit_kind));\n+                    hir::ExprKind::Lit(lit)\n+                }\n+                ExprKind::IncludedBytes(bytes) => {\n+                    let lit = self.arena.alloc(respan(\n+                        self.lower_span(e.span),\n+                        LitKind::ByteStr(bytes.clone(), StrStyle::Cooked),\n+                    ));\n+                    hir::ExprKind::Lit(lit)\n                 }\n-                ExprKind::Cast(ref expr, ref ty) => {\n+                ExprKind::Cast(expr, ty) => {\n                     let expr = self.lower_expr(expr);\n                     let ty =\n-                        self.lower_ty(ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                        self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Cast));\n                     hir::ExprKind::Cast(expr, ty)\n                 }\n-                ExprKind::Type(ref expr, ref ty) => {\n+                ExprKind::Type(expr, ty) => {\n                     let expr = self.lower_expr(expr);\n                     let ty =\n-                        self.lower_ty(ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                        self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Cast));\n                     hir::ExprKind::Type(expr, ty)\n                 }\n-                ExprKind::AddrOf(k, m, ref ohs) => {\n+                ExprKind::AddrOf(k, m, ohs) => {\n                     let ohs = self.lower_expr(ohs);\n-                    hir::ExprKind::AddrOf(k, m, ohs)\n+                    hir::ExprKind::AddrOf(*k, *m, ohs)\n                 }\n-                ExprKind::Let(ref pat, ref scrutinee, span) => {\n+                ExprKind::Let(pat, scrutinee, span) => {\n                     hir::ExprKind::Let(self.arena.alloc(hir::Let {\n                         hir_id: self.next_id(),\n-                        span: self.lower_span(span),\n+                        span: self.lower_span(*span),\n                         pat: self.lower_pat(pat),\n                         ty: None,\n                         init: self.lower_expr(scrutinee),\n                     }))\n                 }\n-                ExprKind::If(ref cond, ref then, ref else_opt) => {\n+                ExprKind::If(cond, then, else_opt) => {\n                     self.lower_expr_if(cond, then, else_opt.as_deref())\n                 }\n-                ExprKind::While(ref cond, ref body, opt_label) => {\n-                    self.with_loop_scope(e.id, |this| {\n-                        let span =\n-                            this.mark_span_with_reason(DesugaringKind::WhileLoop, e.span, None);\n-                        this.lower_expr_while_in_loop_scope(span, cond, body, opt_label)\n-                    })\n-                }\n-                ExprKind::Loop(ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n+                ExprKind::While(cond, body, opt_label) => self.with_loop_scope(e.id, |this| {\n+                    let span = this.mark_span_with_reason(DesugaringKind::WhileLoop, e.span, None);\n+                    this.lower_expr_while_in_loop_scope(span, cond, body, *opt_label)\n+                }),\n+                ExprKind::Loop(body, opt_label, span) => self.with_loop_scope(e.id, |this| {\n                     hir::ExprKind::Loop(\n                         this.lower_block(body, false),\n-                        this.lower_label(opt_label),\n+                        this.lower_label(*opt_label),\n                         hir::LoopSource::Loop,\n-                        DUMMY_SP,\n+                        this.lower_span(*span),\n                     )\n                 }),\n-                ExprKind::TryBlock(ref body) => self.lower_expr_try_block(body),\n-                ExprKind::Match(ref expr, ref arms) => hir::ExprKind::Match(\n+                ExprKind::TryBlock(body) => self.lower_expr_try_block(body),\n+                ExprKind::Match(expr, arms) => hir::ExprKind::Match(\n                     self.lower_expr(expr),\n                     self.arena.alloc_from_iter(arms.iter().map(|x| self.lower_arm(x))),\n                     hir::MatchSource::Normal,\n                 ),\n-                ExprKind::Async(capture_clause, closure_node_id, ref block) => self\n-                    .make_async_expr(\n-                        capture_clause,\n-                        closure_node_id,\n-                        None,\n-                        block.span,\n-                        hir::AsyncGeneratorKind::Block,\n-                        |this| this.with_new_scopes(|this| this.lower_block_expr(block)),\n-                    ),\n-                ExprKind::Await(ref expr) => {\n-                    let span = if expr.span.hi() < e.span.hi() {\n-                        expr.span.shrink_to_hi().with_hi(e.span.hi())\n-                    } else {\n-                        // this is a recovered `await expr`\n-                        e.span\n-                    };\n-                    self.lower_expr_await(span, expr)\n-                }\n-                ExprKind::Closure(\n-                    ref binder,\n+                ExprKind::Async(capture_clause, block) => self.make_async_expr(\n+                    *capture_clause,\n+                    e.id,\n+                    None,\n+                    e.span,\n+                    hir::AsyncGeneratorKind::Block,\n+                    |this| this.with_new_scopes(|this| this.lower_block_expr(block)),\n+                ),\n+                ExprKind::Await(expr, await_kw_span) => self.lower_expr_await(*await_kw_span, expr),\n+                ExprKind::Closure(box Closure {\n+                    binder,\n                     capture_clause,\n+                    constness,\n                     asyncness,\n                     movability,\n-                    ref decl,\n-                    ref body,\n+                    fn_decl,\n+                    body,\n                     fn_decl_span,\n-                ) => {\n+                    fn_arg_span,\n+                }) => {\n                     if let Async::Yes { closure_id, .. } = asyncness {\n                         self.lower_expr_async_closure(\n                             binder,\n-                            capture_clause,\n+                            *capture_clause,\n                             e.id,\n-                            closure_id,\n-                            decl,\n+                            hir_id,\n+                            *closure_id,\n+                            fn_decl,\n                             body,\n-                            fn_decl_span,\n+                            *fn_decl_span,\n+                            *fn_arg_span,\n                         )\n                     } else {\n                         self.lower_expr_closure(\n                             binder,\n-                            capture_clause,\n+                            *capture_clause,\n                             e.id,\n-                            movability,\n-                            decl,\n+                            *constness,\n+                            *movability,\n+                            fn_decl,\n                             body,\n-                            fn_decl_span,\n+                            *fn_decl_span,\n+                            *fn_arg_span,\n                         )\n                     }\n                 }\n-                ExprKind::Block(ref blk, opt_label) => {\n-                    let opt_label = self.lower_label(opt_label);\n+                ExprKind::Block(blk, opt_label) => {\n+                    let opt_label = self.lower_label(*opt_label);\n                     hir::ExprKind::Block(self.lower_block(blk, opt_label.is_some()), opt_label)\n                 }\n-                ExprKind::Assign(ref el, ref er, span) => {\n-                    self.lower_expr_assign(el, er, span, e.span)\n-                }\n-                ExprKind::AssignOp(op, ref el, ref er) => hir::ExprKind::AssignOp(\n-                    self.lower_binop(op),\n+                ExprKind::Assign(el, er, span) => self.lower_expr_assign(el, er, *span, e.span),\n+                ExprKind::AssignOp(op, el, er) => hir::ExprKind::AssignOp(\n+                    self.lower_binop(*op),\n                     self.lower_expr(el),\n                     self.lower_expr(er),\n                 ),\n-                ExprKind::Field(ref el, ident) => {\n-                    hir::ExprKind::Field(self.lower_expr(el), self.lower_ident(ident))\n+                ExprKind::Field(el, ident) => {\n+                    hir::ExprKind::Field(self.lower_expr(el), self.lower_ident(*ident))\n                 }\n-                ExprKind::Index(ref el, ref er) => {\n+                ExprKind::Index(el, er) => {\n                     hir::ExprKind::Index(self.lower_expr(el), self.lower_expr(er))\n                 }\n-                ExprKind::Range(Some(ref e1), Some(ref e2), RangeLimits::Closed) => {\n+                ExprKind::Range(Some(e1), Some(e2), RangeLimits::Closed) => {\n                     self.lower_expr_range_closed(e.span, e1, e2)\n                 }\n-                ExprKind::Range(ref e1, ref e2, lims) => {\n-                    self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), lims)\n+                ExprKind::Range(e1, e2, lims) => {\n+                    self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), *lims)\n                 }\n                 ExprKind::Underscore => {\n-                    self.tcx\n-                        .sess.struct_span_err(\n-                            e.span,\n-                            \"in expressions, `_` can only be used on the left-hand side of an assignment\",\n-                        )\n-                        .span_label(e.span, \"`_` not allowed here\")\n-                        .emit();\n-                    hir::ExprKind::Err\n+                    let guar = self.tcx.sess.emit_err(UnderscoreExprLhsAssign { span: e.span });\n+                    hir::ExprKind::Err(guar)\n                 }\n-                ExprKind::Path(ref qself, ref path) => {\n+                ExprKind::Path(qself, path) => {\n                     let qpath = self.lower_qpath(\n                         e.id,\n                         qself,\n                         path,\n                         ParamMode::Optional,\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                        &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                     );\n                     hir::ExprKind::Path(qpath)\n                 }\n-                ExprKind::Break(opt_label, ref opt_expr) => {\n+                ExprKind::Break(opt_label, opt_expr) => {\n                     let opt_expr = opt_expr.as_ref().map(|x| self.lower_expr(x));\n-                    hir::ExprKind::Break(self.lower_jump_destination(e.id, opt_label), opt_expr)\n+                    hir::ExprKind::Break(self.lower_jump_destination(e.id, *opt_label), opt_expr)\n                 }\n                 ExprKind::Continue(opt_label) => {\n-                    hir::ExprKind::Continue(self.lower_jump_destination(e.id, opt_label))\n+                    hir::ExprKind::Continue(self.lower_jump_destination(e.id, *opt_label))\n                 }\n-                ExprKind::Ret(ref e) => {\n+                ExprKind::Ret(e) => {\n                     let e = e.as_ref().map(|x| self.lower_expr(x));\n                     hir::ExprKind::Ret(e)\n                 }\n-                ExprKind::Yeet(ref sub_expr) => self.lower_expr_yeet(e.span, sub_expr.as_deref()),\n-                ExprKind::InlineAsm(ref asm) => {\n+                ExprKind::Yeet(sub_expr) => self.lower_expr_yeet(e.span, sub_expr.as_deref()),\n+                ExprKind::InlineAsm(asm) => {\n                     hir::ExprKind::InlineAsm(self.lower_inline_asm(e.span, asm))\n                 }\n-                ExprKind::Struct(ref se) => {\n+                ExprKind::FormatArgs(fmt) => self.lower_format_args(e.span, fmt),\n+                ExprKind::OffsetOf(container, fields) => hir::ExprKind::OffsetOf(\n+                    self.lower_ty(\n+                        container,\n+                        &mut ImplTraitContext::Disallowed(ImplTraitPosition::OffsetOf),\n+                    ),\n+                    self.arena.alloc_from_iter(fields.iter().map(|&ident| self.lower_ident(ident))),\n+                ),\n+                ExprKind::Struct(se) => {\n                     let rest = match &se.rest {\n                         StructRest::Base(e) => Some(self.lower_expr(e)),\n                         StructRest::Rest(sp) => {\n-                            self.tcx\n-                                .sess\n-                                .struct_span_err(*sp, \"base expression required after `..`\")\n-                                .span_label(*sp, \"add a base expression here\")\n-                                .emit();\n-                            Some(&*self.arena.alloc(self.expr_err(*sp)))\n+                            let guar =\n+                                self.tcx.sess.emit_err(BaseExpressionDoubleDot { span: *sp });\n+                            Some(&*self.arena.alloc(self.expr_err(*sp, guar)))\n                         }\n                         StructRest::None => None,\n                     };\n@@ -263,49 +302,26 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             &se.qself,\n                             &se.path,\n                             ParamMode::Optional,\n-                            ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                            &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                         )),\n                         self.arena\n                             .alloc_from_iter(se.fields.iter().map(|x| self.lower_expr_field(x))),\n                         rest,\n                     )\n                 }\n-                ExprKind::Yield(ref opt_expr) => self.lower_expr_yield(e.span, opt_expr.as_deref()),\n-                ExprKind::Err => hir::ExprKind::Err,\n-                ExprKind::Try(ref sub_expr) => self.lower_expr_try(e.span, sub_expr),\n-                ExprKind::Paren(ref ex) => {\n-                    let mut ex = self.lower_expr_mut(ex);\n-                    // Include parens in span, but only if it is a super-span.\n-                    if e.span.contains(ex.span) {\n-                        ex.span = self.lower_span(e.span);\n-                    }\n-                    // Merge attributes into the inner expression.\n-                    if !e.attrs.is_empty() {\n-                        let old_attrs =\n-                            self.attrs.get(&ex.hir_id.local_id).map(|la| *la).unwrap_or(&[]);\n-                        self.attrs.insert(\n-                            ex.hir_id.local_id,\n-                            &*self.arena.alloc_from_iter(\n-                                e.attrs\n-                                    .iter()\n-                                    .map(|a| self.lower_attr(a))\n-                                    .chain(old_attrs.iter().cloned()),\n-                            ),\n-                        );\n-                    }\n-                    return ex;\n-                }\n+                ExprKind::Yield(opt_expr) => self.lower_expr_yield(e.span, opt_expr.as_deref()),\n+                ExprKind::Err => hir::ExprKind::Err(\n+                    self.tcx.sess.delay_span_bug(e.span, \"lowered ExprKind::Err\"),\n+                ),\n+                ExprKind::Try(sub_expr) => self.lower_expr_try(e.span, sub_expr),\n \n-                // Desugar `ExprForLoop`\n-                // from: `[opt_ident]: for <pat> in <head> <body>`\n-                ExprKind::ForLoop(ref pat, ref head, ref body, opt_label) => {\n-                    return self.lower_expr_for(e, pat, head, body, opt_label);\n+                ExprKind::Paren(_) | ExprKind::ForLoop(..) => {\n+                    unreachable!(\"already handled\")\n                 }\n+\n                 ExprKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", e.span),\n             };\n \n-            let hir_id = self.lower_node_id(e.id);\n-            self.lower_attrs(hir_id, &e.attrs);\n             hir::Expr { hir_id, kind, span: self.lower_span(e.span) }\n         })\n     }\n@@ -347,23 +363,23 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_legacy_const_generics(\n         &mut self,\n         mut f: Expr,\n-        args: Vec<AstP<Expr>>,\n+        args: ThinVec<AstP<Expr>>,\n         legacy_args_idx: &[usize],\n     ) -> hir::ExprKind<'hir> {\n-        let ExprKind::Path(None, ref mut path) = f.kind else {\n+        let ExprKind::Path(None, path) = &mut f.kind else {\n             unreachable!();\n         };\n \n         // Split the arguments into const generics and normal arguments\n         let mut real_args = vec![];\n-        let mut generic_args = vec![];\n+        let mut generic_args = ThinVec::new();\n         for (idx, arg) in args.into_iter().enumerate() {\n             if legacy_args_idx.contains(&idx) {\n                 let parent_def_id = self.current_hir_id_owner;\n                 let node_id = self.next_node_id();\n \n                 // Add a definition for the in-band const def.\n-                self.create_def(parent_def_id, node_id, DefPathData::AnonConst);\n+                self.create_def(parent_def_id.def_id, node_id, DefPathData::AnonConst, f.span);\n \n                 let anon_const = AnonConst { id: node_id, value: arg };\n                 generic_args.push(AngleBracketedArg::Arg(GenericArg::Const(anon_const)));\n@@ -391,32 +407,54 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         then: &Block,\n         else_opt: Option<&Expr>,\n     ) -> hir::ExprKind<'hir> {\n-        let lowered_cond = self.lower_expr(cond);\n-        let new_cond = self.manage_let_cond(lowered_cond);\n+        let lowered_cond = self.lower_cond(cond);\n         let then_expr = self.lower_block_expr(then);\n         if let Some(rslt) = else_opt {\n-            hir::ExprKind::If(new_cond, self.arena.alloc(then_expr), Some(self.lower_expr(rslt)))\n+            hir::ExprKind::If(\n+                lowered_cond,\n+                self.arena.alloc(then_expr),\n+                Some(self.lower_expr(rslt)),\n+            )\n         } else {\n-            hir::ExprKind::If(new_cond, self.arena.alloc(then_expr), None)\n+            hir::ExprKind::If(lowered_cond, self.arena.alloc(then_expr), None)\n         }\n     }\n \n-    // If `cond` kind is `let`, returns `let`. Otherwise, wraps and returns `cond`\n-    // in a temporary block.\n-    fn manage_let_cond(&mut self, cond: &'hir hir::Expr<'hir>) -> &'hir hir::Expr<'hir> {\n-        fn has_let_expr<'hir>(expr: &'hir hir::Expr<'hir>) -> bool {\n-            match expr.kind {\n-                hir::ExprKind::Binary(_, lhs, rhs) => has_let_expr(lhs) || has_let_expr(rhs),\n-                hir::ExprKind::Let(..) => true,\n+    // Lowers a condition (i.e. `cond` in `if cond` or `while cond`), wrapping it in a terminating scope\n+    // so that temporaries created in the condition don't live beyond it.\n+    fn lower_cond(&mut self, cond: &Expr) -> &'hir hir::Expr<'hir> {\n+        fn has_let_expr(expr: &Expr) -> bool {\n+            match &expr.kind {\n+                ExprKind::Binary(_, lhs, rhs) => has_let_expr(lhs) || has_let_expr(rhs),\n+                ExprKind::Let(..) => true,\n                 _ => false,\n             }\n         }\n-        if has_let_expr(cond) {\n-            cond\n-        } else {\n-            let reason = DesugaringKind::CondTemporary;\n-            let span_block = self.mark_span_with_reason(reason, cond.span, None);\n-            self.expr_drop_temps(span_block, cond, AttrVec::new())\n+\n+        // We have to take special care for `let` exprs in the condition, e.g. in\n+        // `if let pat = val` or `if foo && let pat = val`, as we _do_ want `val` to live beyond the\n+        // condition in this case.\n+        //\n+        // In order to maintain the drop behavior for the non `let` parts of the condition,\n+        // we still wrap them in terminating scopes, e.g. `if foo && let pat = val` essentially\n+        // gets transformed into `if { let _t = foo; _t } && let pat = val`\n+        match &cond.kind {\n+            ExprKind::Binary(op @ Spanned { node: ast::BinOpKind::And, .. }, lhs, rhs)\n+                if has_let_expr(cond) =>\n+            {\n+                let op = self.lower_binop(*op);\n+                let lhs = self.lower_cond(lhs);\n+                let rhs = self.lower_cond(rhs);\n+\n+                self.arena.alloc(self.expr(cond.span, hir::ExprKind::Binary(op, lhs, rhs)))\n+            }\n+            ExprKind::Let(..) => self.lower_expr(cond),\n+            _ => {\n+                let cond = self.lower_expr(cond);\n+                let reason = DesugaringKind::CondTemporary;\n+                let span_block = self.mark_span_with_reason(reason, cond.span, None);\n+                self.expr_drop_temps(span_block, cond)\n+            }\n         }\n     }\n \n@@ -443,15 +481,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         body: &Block,\n         opt_label: Option<Label>,\n     ) -> hir::ExprKind<'hir> {\n-        let lowered_cond = self.with_loop_condition_scope(|t| t.lower_expr(cond));\n-        let new_cond = self.manage_let_cond(lowered_cond);\n+        let lowered_cond = self.with_loop_condition_scope(|t| t.lower_cond(cond));\n         let then = self.lower_block_expr(body);\n-        let expr_break = self.expr_break(span, ThinVec::new());\n+        let expr_break = self.expr_break(span);\n         let stmt_break = self.stmt_expr(span, expr_break);\n         let else_blk = self.block_all(span, arena_vec![self; stmt_break], None);\n-        let else_expr = self.arena.alloc(self.expr_block(else_blk, ThinVec::new()));\n-        let if_kind = hir::ExprKind::If(new_cond, self.arena.alloc(then), Some(else_expr));\n-        let if_expr = self.expr(span, if_kind, ThinVec::new());\n+        let else_expr = self.arena.alloc(self.expr_block(else_blk));\n+        let if_kind = hir::ExprKind::If(lowered_cond, self.arena.alloc(then), Some(else_expr));\n+        let if_expr = self.expr(span, if_kind);\n         let block = self.block_expr(self.arena.alloc(if_expr));\n         let span = self.lower_span(span.with_hi(cond.span.hi()));\n         let opt_label = self.lower_label(opt_label);\n@@ -507,22 +544,17 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         expr: &'hir hir::Expr<'hir>,\n         overall_span: Span,\n     ) -> &'hir hir::Expr<'hir> {\n-        let constructor = self.arena.alloc(self.expr_lang_item_path(\n-            method_span,\n-            lang_item,\n-            ThinVec::new(),\n-            None,\n-        ));\n+        let constructor = self.arena.alloc(self.expr_lang_item_path(method_span, lang_item, None));\n         self.expr_call(overall_span, constructor, std::slice::from_ref(expr))\n     }\n \n     fn lower_arm(&mut self, arm: &Arm) -> hir::Arm<'hir> {\n         let pat = self.lower_pat(&arm.pat);\n         let guard = arm.guard.as_ref().map(|cond| {\n-            if let ExprKind::Let(ref pat, ref scrutinee, span) = cond.kind {\n+            if let ExprKind::Let(pat, scrutinee, span) = &cond.kind {\n                 hir::Guard::IfLet(self.arena.alloc(hir::Let {\n                     hir_id: self.next_id(),\n-                    span: self.lower_span(span),\n+                    span: self.lower_span(*span),\n                     pat: self.lower_pat(pat),\n                     ty: None,\n                     init: self.lower_expr(scrutinee),\n@@ -542,37 +574,34 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    /// Lower an `async` construct to a generator that is then wrapped so it implements `Future`.\n+    /// Lower an `async` construct to a generator that implements `Future`.\n     ///\n     /// This results in:\n     ///\n     /// ```text\n-    /// std::future::from_generator(static move? |_task_context| -> <ret_ty> {\n+    /// static move? |_task_context| -> <ret_ty> {\n     ///     <body>\n-    /// })\n+    /// }\n     /// ```\n     pub(super) fn make_async_expr(\n         &mut self,\n         capture_clause: CaptureBy,\n         closure_node_id: NodeId,\n-        ret_ty: Option<AstP<Ty>>,\n+        ret_ty: Option<hir::FnRetTy<'hir>>,\n         span: Span,\n         async_gen_kind: hir::AsyncGeneratorKind,\n         body: impl FnOnce(&mut Self) -> hir::Expr<'hir>,\n     ) -> hir::ExprKind<'hir> {\n-        let output = match ret_ty {\n-            Some(ty) => hir::FnRetTy::Return(\n-                self.lower_ty(&ty, ImplTraitContext::Disallowed(ImplTraitPosition::AsyncBlock)),\n-            ),\n-            None => hir::FnRetTy::DefaultReturn(self.lower_span(span)),\n-        };\n+        let output = ret_ty.unwrap_or_else(|| hir::FnRetTy::DefaultReturn(self.lower_span(span)));\n \n-        // Resume argument type. We let the compiler infer this to simplify the lowering. It is\n-        // fully constrained by `future::from_generator`.\n+        // Resume argument type: `ResumeTy`\n+        let unstable_span =\n+            self.mark_span_with_reason(DesugaringKind::Async, span, self.allow_gen_future.clone());\n+        let resume_ty = hir::QPath::LangItem(hir::LangItem::ResumeTy, unstable_span, None);\n         let input_ty = hir::Ty {\n             hir_id: self.next_id(),\n-            kind: hir::TyKind::Infer,\n-            span: self.lower_span(span),\n+            kind: hir::TyKind::Path(resume_ty),\n+            span: unstable_span,\n         };\n \n         // The closure/generator `FnDecl` takes a single (resume) argument of type `input_ty`.\n@@ -581,13 +610,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             output,\n             c_variadic: false,\n             implicit_self: hir::ImplicitSelfKind::None,\n+            lifetime_elision_allowed: false,\n         });\n \n         // Lower the argument pattern/ident. The ident is used again in the `.await` lowering.\n         let (pat, task_context_hid) = self.pat_ident_binding_mode(\n             span,\n             Ident::with_dummy_span(sym::_task_context),\n-            hir::BindingAnnotation::Mutable,\n+            hir::BindingAnnotation::MUT,\n         );\n         let param = hir::Param {\n             hir_id: self.next_id(),\n@@ -608,37 +638,51 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         });\n \n         // `static |_task_context| -> <ret_ty> { body }`:\n-        let generator_kind = {\n-            let c = self.arena.alloc(hir::Closure {\n-                binder: hir::ClosureBinder::Default,\n-                capture_clause,\n-                bound_generic_params: &[],\n-                fn_decl,\n-                body,\n-                fn_decl_span: self.lower_span(span),\n-                movability: Some(hir::Movability::Static),\n-            });\n-\n-            hir::ExprKind::Closure(c)\n-        };\n-        let generator = hir::Expr {\n-            hir_id: self.lower_node_id(closure_node_id),\n-            kind: generator_kind,\n-            span: self.lower_span(span),\n-        };\n-\n-        // `future::from_generator`:\n-        let unstable_span =\n-            self.mark_span_with_reason(DesugaringKind::Async, span, self.allow_gen_future.clone());\n-        let gen_future = self.expr_lang_item_path(\n-            unstable_span,\n-            hir::LangItem::FromGenerator,\n-            ThinVec::new(),\n-            None,\n-        );\n+        hir::ExprKind::Closure(self.arena.alloc(hir::Closure {\n+            def_id: self.local_def_id(closure_node_id),\n+            binder: hir::ClosureBinder::Default,\n+            capture_clause,\n+            bound_generic_params: &[],\n+            fn_decl,\n+            body,\n+            fn_decl_span: self.lower_span(span),\n+            fn_arg_span: None,\n+            movability: Some(hir::Movability::Static),\n+            constness: hir::Constness::NotConst,\n+        }))\n+    }\n \n-        // `future::from_generator(generator)`:\n-        hir::ExprKind::Call(self.arena.alloc(gen_future), arena_vec![self; generator])\n+    /// Forwards a possible `#[track_caller]` annotation from `outer_hir_id` to\n+    /// `inner_hir_id` in case the `closure_track_caller` feature is enabled.\n+    pub(super) fn maybe_forward_track_caller(\n+        &mut self,\n+        span: Span,\n+        outer_hir_id: hir::HirId,\n+        inner_hir_id: hir::HirId,\n+    ) {\n+        if self.tcx.features().closure_track_caller\n+            && let Some(attrs) = self.attrs.get(&outer_hir_id.local_id)\n+            && attrs.into_iter().any(|attr| attr.has_name(sym::track_caller))\n+        {\n+            let unstable_span =\n+                self.mark_span_with_reason(DesugaringKind::Async, span, self.allow_gen_future.clone());\n+            self.lower_attrs(\n+                inner_hir_id,\n+                &[Attribute {\n+                    kind: AttrKind::Normal(ptr::P(NormalAttr {\n+                        item: AttrItem {\n+                            path: Path::from_ident(Ident::new(sym::track_caller, span)),\n+                            args: AttrArgs::Empty,\n+                            tokens: None,\n+                        },\n+                        tokens: None,\n+                    })),\n+                    id: self.tcx.sess.parse_sess.attr_id_generator.mk_attr_id(),\n+                    style: AttrStyle::Outer,\n+                    span: unstable_span,\n+                }],\n+            );\n+        }\n     }\n \n     /// Desugar `<expr>.await` into:\n@@ -656,25 +700,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ///     }\n     /// }\n     /// ```\n-    fn lower_expr_await(&mut self, dot_await_span: Span, expr: &Expr) -> hir::ExprKind<'hir> {\n-        let full_span = expr.span.to(dot_await_span);\n+    fn lower_expr_await(&mut self, await_kw_span: Span, expr: &Expr) -> hir::ExprKind<'hir> {\n+        let full_span = expr.span.to(await_kw_span);\n         match self.generator_kind {\n             Some(hir::GeneratorKind::Async(_)) => {}\n             Some(hir::GeneratorKind::Gen) | None => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    dot_await_span,\n-                    E0728,\n-                    \"`await` is only allowed inside `async` functions and blocks\"\n-                );\n-                err.span_label(dot_await_span, \"only allowed inside `async` functions and blocks\");\n-                if let Some(item_sp) = self.current_item {\n-                    err.span_label(item_sp, \"this is not `async`\");\n-                }\n-                err.emit();\n+                self.tcx.sess.emit_err(AwaitOnlyInAsyncFnAndBlocks {\n+                    await_kw_span,\n+                    item_span: self.current_item,\n+                });\n             }\n         }\n-        let span = self.mark_span_with_reason(DesugaringKind::Await, dot_await_span, None);\n+        let span = self.mark_span_with_reason(DesugaringKind::Await, await_kw_span, None);\n         let gen_future_span = self.mark_span_with_reason(\n             DesugaringKind::Await,\n             full_span,\n@@ -688,7 +725,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // this name to identify what is being awaited by a suspended async functions.\n         let awaitee_ident = Ident::with_dummy_span(sym::__awaitee);\n         let (awaitee_pat, awaitee_pat_hid) =\n-            self.pat_ident_binding_mode(span, awaitee_ident, hir::BindingAnnotation::Mutable);\n+            self.pat_ident_binding_mode(span, awaitee_ident, hir::BindingAnnotation::MUT);\n \n         let task_context_ident = Ident::with_dummy_span(sym::_task_context);\n \n@@ -705,7 +742,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self.expr_ident_mut(span, task_context_ident, task_context_hid)\n             } else {\n                 // Use of `await` outside of an async context, we cannot use `task_context` here.\n-                self.expr_err(span)\n+                self.expr_err(span, self.tcx.sess.delay_span_bug(span, \"no task_context hir id\"))\n             };\n             let new_unchecked = self.expr_call_lang_item_fn_mut(\n                 span,\n@@ -745,7 +782,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let break_x = self.with_loop_scope(loop_node_id, move |this| {\n                 let expr_break =\n                     hir::ExprKind::Break(this.lower_loop_destination(None), Some(x_expr));\n-                this.arena.alloc(this.expr(gen_future_span, expr_break, ThinVec::new()))\n+                this.arena.alloc(this.expr(gen_future_span, expr_break))\n             });\n             self.arm(ready_pat, break_x)\n         };\n@@ -778,17 +815,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let yield_expr = self.expr(\n                 span,\n                 hir::ExprKind::Yield(unit, hir::YieldSource::Await { expr: Some(expr_hir_id) }),\n-                ThinVec::new(),\n             );\n             let yield_expr = self.arena.alloc(yield_expr);\n \n             if let Some(task_context_hid) = self.task_context {\n                 let lhs = self.expr_ident(span, task_context_ident, task_context_hid);\n-                let assign = self.expr(\n-                    span,\n-                    hir::ExprKind::Assign(lhs, yield_expr, self.lower_span(span)),\n-                    AttrVec::new(),\n-                );\n+                let assign =\n+                    self.expr(span, hir::ExprKind::Assign(lhs, yield_expr, self.lower_span(span)));\n                 self.stmt_expr(span, assign)\n             } else {\n                 // Use of `await` outside of an async context. Return `yield_expr` so that we can\n@@ -815,13 +848,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let awaitee_arm = self.arm(awaitee_pat, loop_expr);\n \n         // `match ::std::future::IntoFuture::into_future(<expr>) { ... }`\n-        let into_future_span = self.mark_span_with_reason(\n-            DesugaringKind::Await,\n-            dot_await_span,\n-            self.allow_into_future.clone(),\n-        );\n         let into_future_expr = self.expr_call_lang_item_fn(\n-            into_future_span,\n+            span,\n             hir::LangItem::IntoFutureIntoFuture,\n             arena_vec![self; expr],\n             Some(expr_hir_id),\n@@ -842,10 +870,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         binder: &ClosureBinder,\n         capture_clause: CaptureBy,\n         closure_id: NodeId,\n+        constness: Const,\n         movability: Movability,\n         decl: &FnDecl,\n         body: &Expr,\n         fn_decl_span: Span,\n+        fn_arg_span: Span,\n     ) -> hir::ExprKind<'hir> {\n         let (binder_clause, generic_params) = self.lower_closure_binder(binder);\n \n@@ -864,22 +894,24 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             (body_id, generator_option)\n         });\n \n-        self.with_lifetime_binder(closure_id, generic_params, |this, bound_generic_params| {\n-            // Lower outside new scope to preserve `is_in_loop_condition`.\n-            let fn_decl = this.lower_fn_decl(decl, None, FnDeclKind::Closure, None);\n-\n-            let c = self.arena.alloc(hir::Closure {\n-                binder: binder_clause,\n-                capture_clause,\n-                bound_generic_params,\n-                fn_decl,\n-                body: body_id,\n-                fn_decl_span: this.lower_span(fn_decl_span),\n-                movability: generator_option,\n-            });\n+        let bound_generic_params = self.lower_lifetime_binder(closure_id, generic_params);\n+        // Lower outside new scope to preserve `is_in_loop_condition`.\n+        let fn_decl = self.lower_fn_decl(decl, closure_id, fn_decl_span, FnDeclKind::Closure, None);\n+\n+        let c = self.arena.alloc(hir::Closure {\n+            def_id: self.local_def_id(closure_id),\n+            binder: binder_clause,\n+            capture_clause,\n+            bound_generic_params,\n+            fn_decl,\n+            body: body_id,\n+            fn_decl_span: self.lower_span(fn_decl_span),\n+            fn_arg_span: Some(self.lower_span(fn_arg_span)),\n+            movability: generator_option,\n+            constness: self.lower_constness(constness),\n+        });\n \n-            hir::ExprKind::Closure(c)\n-        })\n+        hir::ExprKind::Closure(c)\n     }\n \n     fn generator_movability_for_fn(\n@@ -892,13 +924,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         match generator_kind {\n             Some(hir::GeneratorKind::Gen) => {\n                 if decl.inputs.len() > 1 {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        fn_decl_span,\n-                        E0628,\n-                        \"too many parameters for a generator (expected 0 or 1 parameters)\"\n-                    )\n-                    .emit();\n+                    self.tcx.sess.emit_err(GeneratorTooManyParameters { fn_decl_span });\n                 }\n                 Some(movability)\n             }\n@@ -907,13 +933,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             None => {\n                 if movability == Movability::Static {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        fn_decl_span,\n-                        E0697,\n-                        \"closures cannot be static\"\n-                    )\n-                    .emit();\n+                    self.tcx.sess.emit_err(ClosureCannotBeStatic { fn_decl_span });\n                 }\n                 None\n             }\n@@ -926,8 +946,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> (hir::ClosureBinder, &'c [GenericParam]) {\n         let (binder, params) = match binder {\n             ClosureBinder::NotPresent => (hir::ClosureBinder::Default, &[][..]),\n-            &ClosureBinder::For { span, ref generic_params } => {\n-                let span = self.lower_span(span);\n+            ClosureBinder::For { span, generic_params } => {\n+                let span = self.lower_span(*span);\n                 (hir::ClosureBinder::For { span }, &**generic_params)\n             }\n         };\n@@ -940,16 +960,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         binder: &ClosureBinder,\n         capture_clause: CaptureBy,\n         closure_id: NodeId,\n+        closure_hir_id: hir::HirId,\n         inner_closure_id: NodeId,\n         decl: &FnDecl,\n         body: &Expr,\n         fn_decl_span: Span,\n+        fn_arg_span: Span,\n     ) -> hir::ExprKind<'hir> {\n         if let &ClosureBinder::For { span, .. } = binder {\n-            self.tcx.sess.span_err(\n-                span,\n-                \"`for<...>` binders on `async` closures are not currently supported\",\n-            );\n+            self.tcx.sess.emit_err(NotSupportedForLifetimeBinderAsyncClosure { span });\n         }\n \n         let (binder_clause, generic_params) = self.lower_closure_binder(binder);\n@@ -960,24 +979,19 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let body = self.with_new_scopes(|this| {\n             // FIXME(cramertj): allow `async` non-`move` closures with arguments.\n             if capture_clause == CaptureBy::Ref && !decl.inputs.is_empty() {\n-                struct_span_err!(\n-                    this.tcx.sess,\n-                    fn_decl_span,\n-                    E0708,\n-                    \"`async` non-`move` closures with parameters are not currently supported\",\n-                )\n-                .help(\n-                    \"consider using `let` statements to manually capture \\\n-                    variables by reference before entering an `async move` closure\",\n-                )\n-                .emit();\n+                this.tcx.sess.emit_err(AsyncNonMoveClosureNotSupported { fn_decl_span });\n             }\n \n             // Transform `async |x: u8| -> X { ... }` into\n-            // `|x: u8| future_from_generator(|| -> X { ... })`.\n+            // `|x: u8| || -> X { ... }`.\n             let body_id = this.lower_fn_body(&outer_decl, |this| {\n-                let async_ret_ty =\n-                    if let FnRetTy::Ty(ty) = &decl.output { Some(ty.clone()) } else { None };\n+                let async_ret_ty = if let FnRetTy::Ty(ty) = &decl.output {\n+                    let itctx = ImplTraitContext::Disallowed(ImplTraitPosition::AsyncBlock);\n+                    Some(hir::FnRetTy::Return(this.lower_ty(&ty, &itctx)))\n+                } else {\n+                    None\n+                };\n+\n                 let async_body = this.make_async_expr(\n                     capture_clause,\n                     inner_closure_id,\n@@ -986,28 +1000,33 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     hir::AsyncGeneratorKind::Closure,\n                     |this| this.with_new_scopes(|this| this.lower_expr_mut(body)),\n                 );\n-                this.expr(fn_decl_span, async_body, ThinVec::new())\n+                let hir_id = this.lower_node_id(inner_closure_id);\n+                this.maybe_forward_track_caller(body.span, closure_hir_id, hir_id);\n+                hir::Expr { hir_id, kind: async_body, span: this.lower_span(body.span) }\n             });\n             body_id\n         });\n \n-        self.with_lifetime_binder(closure_id, generic_params, |this, bound_generic_params| {\n-            // We need to lower the declaration outside the new scope, because we\n-            // have to conserve the state of being inside a loop condition for the\n-            // closure argument types.\n-            let fn_decl = this.lower_fn_decl(&outer_decl, None, FnDeclKind::Closure, None);\n-\n-            let c = self.arena.alloc(hir::Closure {\n-                binder: binder_clause,\n-                capture_clause,\n-                bound_generic_params,\n-                fn_decl,\n-                body,\n-                fn_decl_span: this.lower_span(fn_decl_span),\n-                movability: None,\n-            });\n-            hir::ExprKind::Closure(c)\n-        })\n+        let bound_generic_params = self.lower_lifetime_binder(closure_id, generic_params);\n+        // We need to lower the declaration outside the new scope, because we\n+        // have to conserve the state of being inside a loop condition for the\n+        // closure argument types.\n+        let fn_decl =\n+            self.lower_fn_decl(&outer_decl, closure_id, fn_decl_span, FnDeclKind::Closure, None);\n+\n+        let c = self.arena.alloc(hir::Closure {\n+            def_id: self.local_def_id(closure_id),\n+            binder: binder_clause,\n+            capture_clause,\n+            bound_generic_params,\n+            fn_decl,\n+            body,\n+            fn_decl_span: self.lower_span(fn_decl_span),\n+            fn_arg_span: Some(self.lower_span(fn_arg_span)),\n+            movability: None,\n+            constness: hir::Constness::NotConst,\n+        });\n+        hir::ExprKind::Closure(c)\n     }\n \n     /// Destructure the LHS of complex assignments.\n@@ -1077,13 +1096,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn extract_tuple_struct_path<'a>(\n         &mut self,\n         expr: &'a Expr,\n-    ) -> Option<(&'a Option<QSelf>, &'a Path)> {\n+    ) -> Option<(&'a Option<AstP<QSelf>>, &'a Path)> {\n         if let ExprKind::Path(qself, path) = &expr.kind {\n             // Does the path resolve to something disallowed in a tuple struct/variant pattern?\n             if let Some(partial_res) = self.resolver.get_partial_res(expr.id) {\n-                if partial_res.unresolved_segments() == 0\n-                    && !partial_res.base_res().expected_in_tuple_struct_pat()\n-                {\n+                if let Some(res) = partial_res.full_res() && !res.expected_in_tuple_struct_pat() {\n                     return None;\n                 }\n             }\n@@ -1099,13 +1116,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn extract_unit_struct_path<'a>(\n         &mut self,\n         expr: &'a Expr,\n-    ) -> Option<(&'a Option<QSelf>, &'a Path)> {\n+    ) -> Option<(&'a Option<AstP<QSelf>>, &'a Path)> {\n         if let ExprKind::Path(qself, path) = &expr.kind {\n             // Does the path resolve to something disallowed in a unit struct/variant pattern?\n             if let Some(partial_res) = self.resolver.get_partial_res(expr.id) {\n-                if partial_res.unresolved_segments() == 0\n-                    && !partial_res.base_res().expected_in_unit_struct_pat()\n-                {\n+                if let Some(res) = partial_res.full_res() && !res.expected_in_unit_struct_pat() {\n                     return None;\n                 }\n             }\n@@ -1166,11 +1181,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         qself,\n                         path,\n                         ParamMode::Optional,\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                        &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                     );\n                     // Destructure like a tuple struct.\n-                    let tuple_struct_pat =\n-                        hir::PatKind::TupleStruct(qpath, pats, rest.map(|r| r.0));\n+                    let tuple_struct_pat = hir::PatKind::TupleStruct(\n+                        qpath,\n+                        pats,\n+                        hir::DotDotPos::new(rest.map(|r| r.0)),\n+                    );\n                     return self.pat_without_dbm(lhs.span, tuple_struct_pat);\n                 }\n             }\n@@ -1182,7 +1200,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         qself,\n                         path,\n                         ParamMode::Optional,\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                        &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                     );\n                     // Destructure like a unit struct.\n                     let unit_struct_pat = hir::PatKind::Path(qpath);\n@@ -1206,24 +1224,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     &se.qself,\n                     &se.path,\n                     ParamMode::Optional,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                 );\n                 let fields_omitted = match &se.rest {\n                     StructRest::Base(e) => {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                e.span,\n-                                \"functional record updates are not allowed in destructuring \\\n-                                    assignments\",\n-                            )\n-                            .span_suggestion(\n-                                e.span,\n-                                \"consider removing the trailing pattern\",\n-                                \"\",\n-                                rustc_errors::Applicability::MachineApplicable,\n-                            )\n-                            .emit();\n+                        self.tcx.sess.emit_err(FunctionalRecordUpdateDestructuringAssignment {\n+                            span: e.span,\n+                        });\n                         true\n                     }\n                     StructRest::Rest(_) => true,\n@@ -1236,13 +1243,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             ExprKind::Tup(elements) => {\n                 let (pats, rest) =\n                     self.destructure_sequence(elements, \"tuple\", eq_sign_span, assignments);\n-                let tuple_pat = hir::PatKind::Tuple(pats, rest.map(|r| r.0));\n+                let tuple_pat = hir::PatKind::Tuple(pats, hir::DotDotPos::new(rest.map(|r| r.0)));\n                 return self.pat_without_dbm(lhs.span, tuple_pat);\n             }\n             ExprKind::Paren(e) => {\n                 // We special-case `(..)` for consistency with patterns.\n                 if let ExprKind::Range(None, None, RangeLimits::HalfOpen) = e.kind {\n-                    let tuple_pat = hir::PatKind::Tuple(&[], Some(0));\n+                    let tuple_pat = hir::PatKind::Tuple(&[], hir::DotDotPos::new(Some(0)));\n                     return self.pat_without_dbm(lhs.span, tuple_pat);\n                 } else {\n                     return self.destructure_assign_mut(e, eq_sign_span, assignments);\n@@ -1256,7 +1263,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let ident = self.expr_ident(lhs.span, ident, binding);\n         let assign =\n             hir::ExprKind::Assign(self.lower_expr(lhs), ident, self.lower_span(eq_sign_span));\n-        let expr = self.expr(lhs.span, assign, ThinVec::new());\n+        let expr = self.expr(lhs.span, assign);\n         assignments.push(self.stmt_expr(lhs.span, expr));\n         pat\n     }\n@@ -1297,8 +1304,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let e2 = self.lower_expr_mut(e2);\n         let fn_path =\n             hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, self.lower_span(span), None);\n-        let fn_expr =\n-            self.arena.alloc(self.expr(span, hir::ExprKind::Path(fn_path), ThinVec::new()));\n+        let fn_expr = self.arena.alloc(self.expr(span, hir::ExprKind::Path(fn_path)));\n         hir::ExprKind::Call(fn_expr, arena_vec![self; e1, e2])\n     }\n \n@@ -1318,7 +1324,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             (Some(..), Some(..), HalfOpen) => hir::LangItem::Range,\n             (None, Some(..), Closed) => hir::LangItem::RangeToInclusive,\n             (Some(..), Some(..), Closed) => unreachable!(),\n-            (_, None, Closed) => self.diagnostic().span_fatal(span, \"inclusive range with no end\"),\n+            (start, None, Closed) => {\n+                self.tcx.sess.emit_err(InclusiveRangeWithNoEnd { span });\n+                match start {\n+                    Some(..) => hir::LangItem::RangeFrom,\n+                    None => hir::LangItem::RangeFull,\n+                }\n+            }\n         };\n \n         let fields = self.arena.alloc_from_iter(\n@@ -1405,8 +1417,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_expr_field(&mut self, f: &ExprField) -> hir::ExprField<'hir> {\n+        let hir_id = self.lower_node_id(f.id);\n+        self.lower_attrs(hir_id, &f.attrs);\n         hir::ExprField {\n-            hir_id: self.next_id(),\n+            hir_id,\n             ident: self.lower_ident(f.ident),\n             expr: self.lower_expr(&f.expr),\n             span: self.lower_span(f.span),\n@@ -1418,13 +1432,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         match self.generator_kind {\n             Some(hir::GeneratorKind::Gen) => {}\n             Some(hir::GeneratorKind::Async(_)) => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0727,\n-                    \"`async` generators are not yet supported\"\n-                )\n-                .emit();\n+                self.tcx.sess.emit_err(AsyncGeneratorsNotSupported { span });\n             }\n             None => self.generator_kind = Some(hir::GeneratorKind::Gen),\n         }\n@@ -1468,8 +1476,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         // `None => break`\n         let none_arm = {\n-            let break_expr =\n-                self.with_loop_scope(e.id, |this| this.expr_break_alloc(for_span, ThinVec::new()));\n+            let break_expr = self.with_loop_scope(e.id, |this| this.expr_break_alloc(for_span));\n             let pat = self.pat_none(for_span);\n             self.arm(pat, break_expr)\n         };\n@@ -1478,14 +1485,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let some_arm = {\n             let some_pat = self.pat_some(pat_span, pat);\n             let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body, false));\n-            let body_expr = self.arena.alloc(self.expr_block(body_block, ThinVec::new()));\n+            let body_expr = self.arena.alloc(self.expr_block(body_block));\n             self.arm(some_pat, body_expr)\n         };\n \n         // `mut iter`\n         let iter = Ident::with_dummy_span(sym::iter);\n         let (iter_pat, iter_pat_nid) =\n-            self.pat_ident_binding_mode(head_span, iter, hir::BindingAnnotation::Mutable);\n+            self.pat_ident_binding_mode(head_span, iter, hir::BindingAnnotation::MUT);\n \n         // `match Iterator::next(&mut iter) { ... }`\n         let match_expr = {\n@@ -1535,15 +1542,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             hir::MatchSource::ForLoopDesugar,\n         ));\n \n-        let attrs: Vec<_> = e.attrs.iter().map(|a| self.lower_attr(a)).collect();\n-\n         // This is effectively `{ let _result = ...; _result }`.\n         // The construct was introduced in #21984 and is necessary to make sure that\n         // temporaries in the `head` expression are dropped and do not leak to the\n         // surrounding scope of the `match` since the `match` is not a terminating scope.\n         //\n         // Also, add the attributes to the outer returned expr node.\n-        self.expr_drop_temps_mut(for_span, match_expr, attrs.into())\n+        let expr = self.expr_drop_temps_mut(for_span, match_expr);\n+        self.lower_attrs(expr.hir_id, &e.attrs);\n+        expr\n     }\n \n     /// Desugar `ExprKind::Try` from: `<expr>?` into:\n@@ -1585,28 +1592,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         };\n \n         // `#[allow(unreachable_code)]`\n-        let attr = {\n-            // `allow(unreachable_code)`\n-            let allow = {\n-                let allow_ident = Ident::new(sym::allow, self.lower_span(span));\n-                let uc_ident = Ident::new(sym::unreachable_code, self.lower_span(span));\n-                let uc_nested = attr::mk_nested_word_item(uc_ident);\n-                attr::mk_list_item(allow_ident, vec![uc_nested])\n-            };\n-            attr::mk_attr_outer(allow)\n-        };\n-        let attrs = vec![attr];\n+        let attr = attr::mk_attr_nested_word(\n+            &self.tcx.sess.parse_sess.attr_id_generator,\n+            AttrStyle::Outer,\n+            sym::allow,\n+            sym::unreachable_code,\n+            self.lower_span(span),\n+        );\n+        let attrs: AttrVec = thin_vec![attr];\n \n         // `ControlFlow::Continue(val) => #[allow(unreachable_code)] val,`\n         let continue_arm = {\n             let val_ident = Ident::with_dummy_span(sym::val);\n             let (val_pat, val_pat_nid) = self.pat_ident(span, val_ident);\n-            let val_expr = self.arena.alloc(self.expr_ident_with_attrs(\n-                span,\n-                val_ident,\n-                val_pat_nid,\n-                ThinVec::from(attrs.clone()),\n-            ));\n+            let val_expr = self.expr_ident(span, val_ident, val_pat_nid);\n+            self.lower_attrs(val_expr.hir_id, &attrs);\n             let continue_pat = self.pat_cf_continue(unstable_span, val_pat);\n             self.arm(continue_pat, val_expr)\n         };\n@@ -1624,7 +1624,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self.arena.alloc(residual_expr),\n                 unstable_span,\n             );\n-            let thin_attrs = ThinVec::from(attrs);\n             let ret_expr = if let Some(catch_node) = self.catch_scope {\n                 let target_id = Ok(self.lower_node_id(catch_node));\n                 self.arena.alloc(self.expr(\n@@ -1633,15 +1632,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         hir::Destination { label: None, target_id },\n                         Some(from_residual_expr),\n                     ),\n-                    thin_attrs,\n                 ))\n             } else {\n-                self.arena.alloc(self.expr(\n-                    try_span,\n-                    hir::ExprKind::Ret(Some(from_residual_expr)),\n-                    thin_attrs,\n-                ))\n+                self.arena.alloc(self.expr(try_span, hir::ExprKind::Ret(Some(from_residual_expr))))\n             };\n+            self.lower_attrs(ret_expr.hir_id, &attrs);\n \n             let break_pat = self.pat_cf_break(try_span, residual_local);\n             self.arm(break_pat, ret_expr)\n@@ -1655,11 +1650,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     /// Desugar `ExprKind::Yeet` from: `do yeet <expr>` into:\n-    /// ```rust\n+    /// ```ignore(illustrative)\n     /// // If there is an enclosing `try {...}`:\n-    /// break 'catch_target FromResidual::from_residual(Yeet(residual)),\n+    /// break 'catch_target FromResidual::from_residual(Yeet(residual));\n     /// // Otherwise:\n-    /// return FromResidual::from_residual(Yeet(residual)),\n+    /// return FromResidual::from_residual(Yeet(residual));\n     /// ```\n     /// But to simplify this, there's a `from_yeet` lang item function which\n     /// handles the combined `FromResidual::from_residual(Yeet(residual))`.\n@@ -1706,62 +1701,84 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         span: Span,\n         expr: &'hir hir::Expr<'hir>,\n-        attrs: AttrVec,\n     ) -> &'hir hir::Expr<'hir> {\n-        self.arena.alloc(self.expr_drop_temps_mut(span, expr, attrs))\n+        self.arena.alloc(self.expr_drop_temps_mut(span, expr))\n     }\n \n     pub(super) fn expr_drop_temps_mut(\n         &mut self,\n         span: Span,\n         expr: &'hir hir::Expr<'hir>,\n-        attrs: AttrVec,\n     ) -> hir::Expr<'hir> {\n-        self.expr(span, hir::ExprKind::DropTemps(expr), attrs)\n+        self.expr(span, hir::ExprKind::DropTemps(expr))\n     }\n \n-    fn expr_match(\n+    pub(super) fn expr_match(\n         &mut self,\n         span: Span,\n         arg: &'hir hir::Expr<'hir>,\n         arms: &'hir [hir::Arm<'hir>],\n         source: hir::MatchSource,\n     ) -> hir::Expr<'hir> {\n-        self.expr(span, hir::ExprKind::Match(arg, arms, source), ThinVec::new())\n+        self.expr(span, hir::ExprKind::Match(arg, arms, source))\n     }\n \n-    fn expr_break(&mut self, span: Span, attrs: AttrVec) -> hir::Expr<'hir> {\n+    fn expr_break(&mut self, span: Span) -> hir::Expr<'hir> {\n         let expr_break = hir::ExprKind::Break(self.lower_loop_destination(None), None);\n-        self.expr(span, expr_break, attrs)\n+        self.expr(span, expr_break)\n     }\n \n-    fn expr_break_alloc(&mut self, span: Span, attrs: AttrVec) -> &'hir hir::Expr<'hir> {\n-        let expr_break = self.expr_break(span, attrs);\n+    fn expr_break_alloc(&mut self, span: Span) -> &'hir hir::Expr<'hir> {\n+        let expr_break = self.expr_break(span);\n         self.arena.alloc(expr_break)\n     }\n \n     fn expr_mut_addr_of(&mut self, span: Span, e: &'hir hir::Expr<'hir>) -> hir::Expr<'hir> {\n-        self.expr(\n-            span,\n-            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, e),\n-            ThinVec::new(),\n-        )\n+        self.expr(span, hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, e))\n     }\n \n     fn expr_unit(&mut self, sp: Span) -> &'hir hir::Expr<'hir> {\n-        self.arena.alloc(self.expr(sp, hir::ExprKind::Tup(&[]), ThinVec::new()))\n+        self.arena.alloc(self.expr(sp, hir::ExprKind::Tup(&[])))\n+    }\n+\n+    pub(super) fn expr_usize(&mut self, sp: Span, value: usize) -> hir::Expr<'hir> {\n+        let lit = self.arena.alloc(hir::Lit {\n+            span: sp,\n+            node: ast::LitKind::Int(value as u128, ast::LitIntType::Unsigned(ast::UintTy::Usize)),\n+        });\n+        self.expr(sp, hir::ExprKind::Lit(lit))\n+    }\n+\n+    pub(super) fn expr_u32(&mut self, sp: Span, value: u32) -> hir::Expr<'hir> {\n+        let lit = self.arena.alloc(hir::Lit {\n+            span: sp,\n+            node: ast::LitKind::Int(value.into(), ast::LitIntType::Unsigned(ast::UintTy::U32)),\n+        });\n+        self.expr(sp, hir::ExprKind::Lit(lit))\n     }\n \n-    fn expr_call_mut(\n+    pub(super) fn expr_char(&mut self, sp: Span, value: char) -> hir::Expr<'hir> {\n+        let lit = self.arena.alloc(hir::Lit { span: sp, node: ast::LitKind::Char(value) });\n+        self.expr(sp, hir::ExprKind::Lit(lit))\n+    }\n+\n+    pub(super) fn expr_str(&mut self, sp: Span, value: Symbol) -> hir::Expr<'hir> {\n+        let lit = self\n+            .arena\n+            .alloc(hir::Lit { span: sp, node: ast::LitKind::Str(value, ast::StrStyle::Cooked) });\n+        self.expr(sp, hir::ExprKind::Lit(lit))\n+    }\n+\n+    pub(super) fn expr_call_mut(\n         &mut self,\n         span: Span,\n         e: &'hir hir::Expr<'hir>,\n         args: &'hir [hir::Expr<'hir>],\n     ) -> hir::Expr<'hir> {\n-        self.expr(span, hir::ExprKind::Call(e, args), ThinVec::new())\n+        self.expr(span, hir::ExprKind::Call(e, args))\n     }\n \n-    fn expr_call(\n+    pub(super) fn expr_call(\n         &mut self,\n         span: Span,\n         e: &'hir hir::Expr<'hir>,\n@@ -1777,8 +1794,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         args: &'hir [hir::Expr<'hir>],\n         hir_id: Option<hir::HirId>,\n     ) -> hir::Expr<'hir> {\n-        let path =\n-            self.arena.alloc(self.expr_lang_item_path(span, lang_item, ThinVec::new(), hir_id));\n+        let path = self.arena.alloc(self.expr_lang_item_path(span, lang_item, hir_id));\n         self.expr_call_mut(span, path, args)\n     }\n \n@@ -1796,16 +1812,35 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         span: Span,\n         lang_item: hir::LangItem,\n-        attrs: AttrVec,\n         hir_id: Option<hir::HirId>,\n     ) -> hir::Expr<'hir> {\n         self.expr(\n             span,\n             hir::ExprKind::Path(hir::QPath::LangItem(lang_item, self.lower_span(span), hir_id)),\n-            attrs,\n         )\n     }\n \n+    /// `<LangItem>::name`\n+    pub(super) fn expr_lang_item_type_relative(\n+        &mut self,\n+        span: Span,\n+        lang_item: hir::LangItem,\n+        name: Symbol,\n+    ) -> hir::Expr<'hir> {\n+        let path = hir::ExprKind::Path(hir::QPath::TypeRelative(\n+            self.arena.alloc(self.ty(\n+                span,\n+                hir::TyKind::Path(hir::QPath::LangItem(lang_item, self.lower_span(span), None)),\n+            )),\n+            self.arena.alloc(hir::PathSegment::new(\n+                Ident::new(name, span),\n+                self.next_id(),\n+                Res::Err,\n+            )),\n+        ));\n+        self.expr(span, path)\n+    }\n+\n     pub(super) fn expr_ident(\n         &mut self,\n         sp: Span,\n@@ -1816,31 +1851,23 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     pub(super) fn expr_ident_mut(\n-        &mut self,\n-        sp: Span,\n-        ident: Ident,\n-        binding: hir::HirId,\n-    ) -> hir::Expr<'hir> {\n-        self.expr_ident_with_attrs(sp, ident, binding, ThinVec::new())\n-    }\n-\n-    fn expr_ident_with_attrs(\n         &mut self,\n         span: Span,\n         ident: Ident,\n         binding: hir::HirId,\n-        attrs: AttrVec,\n     ) -> hir::Expr<'hir> {\n+        let hir_id = self.next_id();\n+        let res = Res::Local(binding);\n         let expr_path = hir::ExprKind::Path(hir::QPath::Resolved(\n             None,\n             self.arena.alloc(hir::Path {\n                 span: self.lower_span(span),\n-                res: Res::Local(binding),\n-                segments: arena_vec![self; hir::PathSegment::from_ident(ident)],\n+                res,\n+                segments: arena_vec![self; hir::PathSegment::new(ident, hir_id, res)],\n             }),\n         ));\n \n-        self.expr(span, expr_path, attrs)\n+        self.expr(span, expr_path)\n     }\n \n     fn expr_unsafe(&mut self, expr: &'hir hir::Expr<'hir>) -> hir::Expr<'hir> {\n@@ -1859,36 +1886,38 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }),\n                 None,\n             ),\n-            ThinVec::new(),\n         )\n     }\n \n     fn expr_block_empty(&mut self, span: Span) -> &'hir hir::Expr<'hir> {\n         let blk = self.block_all(span, &[], None);\n-        let expr = self.expr_block(blk, ThinVec::new());\n+        let expr = self.expr_block(blk);\n         self.arena.alloc(expr)\n     }\n \n-    pub(super) fn expr_block(\n-        &mut self,\n-        b: &'hir hir::Block<'hir>,\n-        attrs: AttrVec,\n-    ) -> hir::Expr<'hir> {\n-        self.expr(b.span, hir::ExprKind::Block(b, None), attrs)\n+    pub(super) fn expr_block(&mut self, b: &'hir hir::Block<'hir>) -> hir::Expr<'hir> {\n+        self.expr(b.span, hir::ExprKind::Block(b, None))\n     }\n \n-    pub(super) fn expr(\n+    pub(super) fn expr_array_ref(\n         &mut self,\n         span: Span,\n-        kind: hir::ExprKind<'hir>,\n-        attrs: AttrVec,\n+        elements: &'hir [hir::Expr<'hir>],\n     ) -> hir::Expr<'hir> {\n+        let addrof = hir::ExprKind::AddrOf(\n+            hir::BorrowKind::Ref,\n+            hir::Mutability::Not,\n+            self.arena.alloc(self.expr(span, hir::ExprKind::Array(elements))),\n+        );\n+        self.expr(span, addrof)\n+    }\n+\n+    pub(super) fn expr(&mut self, span: Span, kind: hir::ExprKind<'hir>) -> hir::Expr<'hir> {\n         let hir_id = self.next_id();\n-        self.lower_attrs(hir_id, &attrs);\n         hir::Expr { hir_id, kind, span: self.lower_span(span) }\n     }\n \n-    fn expr_field(\n+    pub(super) fn expr_field(\n         &mut self,\n         ident: Ident,\n         expr: &'hir hir::Expr<'hir>,\n@@ -1903,7 +1932,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    fn arm(&mut self, pat: &'hir hir::Pat<'hir>, expr: &'hir hir::Expr<'hir>) -> hir::Arm<'hir> {\n+    pub(super) fn arm(\n+        &mut self,\n+        pat: &'hir hir::Pat<'hir>,\n+        expr: &'hir hir::Expr<'hir>,\n+    ) -> hir::Arm<'hir> {\n         hir::Arm {\n             hir_id: self.next_id(),\n             pat,"}, {"sha": "afcf8b15cd80053910711345b36d6a8542f80fa5", "filename": "compiler/rustc_ast_lowering/src/format.rs", "status": "added", "additions": 648, "deletions": 0, "changes": 648, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -0,0 +1,648 @@\n+use super::LoweringContext;\n+use rustc_ast as ast;\n+use rustc_ast::visit::{self, Visitor};\n+use rustc_ast::*;\n+use rustc_data_structures::fx::FxIndexMap;\n+use rustc_hir as hir;\n+use rustc_span::{\n+    sym,\n+    symbol::{kw, Ident},\n+    Span, Symbol,\n+};\n+use std::borrow::Cow;\n+\n+impl<'hir> LoweringContext<'_, 'hir> {\n+    pub(crate) fn lower_format_args(&mut self, sp: Span, fmt: &FormatArgs) -> hir::ExprKind<'hir> {\n+        // Never call the const constructor of `fmt::Arguments` if the\n+        // format_args!() had any arguments _before_ flattening/inlining.\n+        let allow_const = fmt.arguments.all_args().is_empty();\n+        let mut fmt = Cow::Borrowed(fmt);\n+        if self.tcx.sess.opts.unstable_opts.flatten_format_args {\n+            fmt = flatten_format_args(fmt);\n+            fmt = inline_literals(fmt);\n+        }\n+        expand_format_args(self, sp, &fmt, allow_const)\n+    }\n+}\n+\n+/// Flattens nested `format_args!()` into one.\n+///\n+/// Turns\n+///\n+/// `format_args!(\"a {} {} {}.\", 1, format_args!(\"b{}!\", 2), 3)`\n+///\n+/// into\n+///\n+/// `format_args!(\"a {} b{}! {}.\", 1, 2, 3)`.\n+fn flatten_format_args(mut fmt: Cow<'_, FormatArgs>) -> Cow<'_, FormatArgs> {\n+    let mut i = 0;\n+    while i < fmt.template.len() {\n+        if let FormatArgsPiece::Placeholder(placeholder) = &fmt.template[i]\n+            && let FormatTrait::Display | FormatTrait::Debug = &placeholder.format_trait\n+            && let Ok(arg_index) = placeholder.argument.index\n+            && let arg = fmt.arguments.all_args()[arg_index].expr.peel_parens_and_refs()\n+            && let ExprKind::FormatArgs(_) = &arg.kind\n+            // Check that this argument is not used by any other placeholders.\n+            && fmt.template.iter().enumerate().all(|(j, p)|\n+                i == j ||\n+                !matches!(p, FormatArgsPiece::Placeholder(placeholder)\n+                    if placeholder.argument.index == Ok(arg_index))\n+            )\n+        {\n+            // Now we need to mutate the outer FormatArgs.\n+            // If this is the first time, this clones the outer FormatArgs.\n+            let fmt = fmt.to_mut();\n+\n+            // Take the inner FormatArgs out of the outer arguments, and\n+            // replace it by the inner arguments. (We can't just put those at\n+            // the end, because we need to preserve the order of evaluation.)\n+\n+            let args = fmt.arguments.all_args_mut();\n+            let remaining_args = args.split_off(arg_index + 1);\n+            let old_arg_offset = args.len();\n+            let mut fmt2 = &mut args.pop().unwrap().expr; // The inner FormatArgs.\n+            let fmt2 = loop { // Unwrap the Expr to get to the FormatArgs.\n+                match &mut fmt2.kind {\n+                    ExprKind::Paren(inner) | ExprKind::AddrOf(BorrowKind::Ref, _, inner) => fmt2 = inner,\n+                    ExprKind::FormatArgs(fmt2) => break fmt2,\n+                    _ => unreachable!(),\n+                }\n+            };\n+\n+            args.append(fmt2.arguments.all_args_mut());\n+            let new_arg_offset = args.len();\n+            args.extend(remaining_args);\n+\n+            // Correct the indexes that refer to the arguments after the newly inserted arguments.\n+            for_all_argument_indexes(&mut fmt.template, |index| {\n+                if *index >= old_arg_offset {\n+                    *index -= old_arg_offset;\n+                    *index += new_arg_offset;\n+                }\n+            });\n+\n+            // Now merge the placeholders:\n+\n+            let rest = fmt.template.split_off(i + 1);\n+            fmt.template.pop(); // remove the placeholder for the nested fmt args.\n+            // Insert the pieces from the nested format args, but correct any\n+            // placeholders to point to the correct argument index.\n+            for_all_argument_indexes(&mut fmt2.template, |index| *index += arg_index);\n+            fmt.template.append(&mut fmt2.template);\n+            fmt.template.extend(rest);\n+\n+            // Don't increment `i` here, so we recurse into the newly added pieces.\n+        } else {\n+            i += 1;\n+        }\n+    }\n+    fmt\n+}\n+\n+/// Inline literals into the format string.\n+///\n+/// Turns\n+///\n+/// `format_args!(\"Hello, {}! {} {}\", \"World\", 123, x)`\n+///\n+/// into\n+///\n+/// `format_args!(\"Hello, World! 123 {}\", x)`.\n+fn inline_literals(mut fmt: Cow<'_, FormatArgs>) -> Cow<'_, FormatArgs> {\n+    let mut was_inlined = vec![false; fmt.arguments.all_args().len()];\n+    let mut inlined_anything = false;\n+\n+    for i in 0..fmt.template.len() {\n+        let FormatArgsPiece::Placeholder(placeholder) = &fmt.template[i] else { continue };\n+        let Ok(arg_index) = placeholder.argument.index else { continue };\n+\n+        let mut literal = None;\n+\n+        if let FormatTrait::Display = placeholder.format_trait\n+            && placeholder.format_options == Default::default()\n+            && let arg = fmt.arguments.all_args()[arg_index].expr.peel_parens_and_refs()\n+            && let ExprKind::Lit(lit) = arg.kind\n+        {\n+            if let token::LitKind::Str | token::LitKind::StrRaw(_) = lit.kind\n+                && let Ok(LitKind::Str(s, _)) = LitKind::from_token_lit(lit)\n+            {\n+                literal = Some(s);\n+            } else if let token::LitKind::Integer = lit.kind\n+                && let Ok(LitKind::Int(n, _)) = LitKind::from_token_lit(lit)\n+            {\n+                literal = Some(Symbol::intern(&n.to_string()));\n+            }\n+        }\n+\n+        if let Some(literal) = literal {\n+            // Now we need to mutate the outer FormatArgs.\n+            // If this is the first time, this clones the outer FormatArgs.\n+            let fmt = fmt.to_mut();\n+            // Replace the placeholder with the literal.\n+            fmt.template[i] = FormatArgsPiece::Literal(literal);\n+            was_inlined[arg_index] = true;\n+            inlined_anything = true;\n+        }\n+    }\n+\n+    // Remove the arguments that were inlined.\n+    if inlined_anything {\n+        let fmt = fmt.to_mut();\n+\n+        let mut remove = was_inlined;\n+\n+        // Don't remove anything that's still used.\n+        for_all_argument_indexes(&mut fmt.template, |index| remove[*index] = false);\n+\n+        // Drop all the arguments that are marked for removal.\n+        let mut remove_it = remove.iter();\n+        fmt.arguments.all_args_mut().retain(|_| remove_it.next() != Some(&true));\n+\n+        // Calculate the mapping of old to new indexes for the remaining arguments.\n+        let index_map: Vec<usize> = remove\n+            .into_iter()\n+            .scan(0, |i, remove| {\n+                let mapped = *i;\n+                *i += !remove as usize;\n+                Some(mapped)\n+            })\n+            .collect();\n+\n+        // Correct the indexes that refer to arguments that have shifted position.\n+        for_all_argument_indexes(&mut fmt.template, |index| *index = index_map[*index]);\n+    }\n+\n+    fmt\n+}\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+enum ArgumentType {\n+    Format(FormatTrait),\n+    Usize,\n+}\n+\n+/// Generate a hir expression representing an argument to a format_args invocation.\n+///\n+/// Generates:\n+///\n+/// ```text\n+///     <core::fmt::Argument>::new_\u2026(arg)\n+/// ```\n+fn make_argument<'hir>(\n+    ctx: &mut LoweringContext<'_, 'hir>,\n+    sp: Span,\n+    arg: &'hir hir::Expr<'hir>,\n+    ty: ArgumentType,\n+) -> hir::Expr<'hir> {\n+    use ArgumentType::*;\n+    use FormatTrait::*;\n+    let new_fn = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+        sp,\n+        hir::LangItem::FormatArgument,\n+        match ty {\n+            Format(Display) => sym::new_display,\n+            Format(Debug) => sym::new_debug,\n+            Format(LowerExp) => sym::new_lower_exp,\n+            Format(UpperExp) => sym::new_upper_exp,\n+            Format(Octal) => sym::new_octal,\n+            Format(Pointer) => sym::new_pointer,\n+            Format(Binary) => sym::new_binary,\n+            Format(LowerHex) => sym::new_lower_hex,\n+            Format(UpperHex) => sym::new_upper_hex,\n+            Usize => sym::from_usize,\n+        },\n+    ));\n+    ctx.expr_call_mut(sp, new_fn, std::slice::from_ref(arg))\n+}\n+\n+/// Generate a hir expression for a format_args Count.\n+///\n+/// Generates:\n+///\n+/// ```text\n+///     <core::fmt::rt::Count>::Is(\u2026)\n+/// ```\n+///\n+/// or\n+///\n+/// ```text\n+///     <core::fmt::rt::Count>::Param(\u2026)\n+/// ```\n+///\n+/// or\n+///\n+/// ```text\n+///     <core::fmt::rt::Count>::Implied\n+/// ```\n+fn make_count<'hir>(\n+    ctx: &mut LoweringContext<'_, 'hir>,\n+    sp: Span,\n+    count: &Option<FormatCount>,\n+    argmap: &mut FxIndexMap<(usize, ArgumentType), Option<Span>>,\n+) -> hir::Expr<'hir> {\n+    match count {\n+        Some(FormatCount::Literal(n)) => {\n+            let count_is = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+                sp,\n+                hir::LangItem::FormatCount,\n+                sym::Is,\n+            ));\n+            let value = ctx.arena.alloc_from_iter([ctx.expr_usize(sp, *n)]);\n+            ctx.expr_call_mut(sp, count_is, value)\n+        }\n+        Some(FormatCount::Argument(arg)) => {\n+            if let Ok(arg_index) = arg.index {\n+                let (i, _) = argmap.insert_full((arg_index, ArgumentType::Usize), arg.span);\n+                let count_param = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+                    sp,\n+                    hir::LangItem::FormatCount,\n+                    sym::Param,\n+                ));\n+                let value = ctx.arena.alloc_from_iter([ctx.expr_usize(sp, i)]);\n+                ctx.expr_call_mut(sp, count_param, value)\n+            } else {\n+                ctx.expr(\n+                    sp,\n+                    hir::ExprKind::Err(\n+                        ctx.tcx.sess.delay_span_bug(sp, \"lowered bad format_args count\"),\n+                    ),\n+                )\n+            }\n+        }\n+        None => ctx.expr_lang_item_type_relative(sp, hir::LangItem::FormatCount, sym::Implied),\n+    }\n+}\n+\n+/// Generate a hir expression for a format_args placeholder specification.\n+///\n+/// Generates\n+///\n+/// ```text\n+///     <core::fmt::rt::Placeholder::new(\n+///         \u2026usize, // position\n+///         '\u2026', // fill\n+///         <core::fmt::rt::Alignment>::\u2026, // alignment\n+///         \u2026u32, // flags\n+///         <core::fmt::rt::Count::\u2026>, // width\n+///         <core::fmt::rt::Count::\u2026>, // precision\n+///     )\n+/// ```\n+fn make_format_spec<'hir>(\n+    ctx: &mut LoweringContext<'_, 'hir>,\n+    sp: Span,\n+    placeholder: &FormatPlaceholder,\n+    argmap: &mut FxIndexMap<(usize, ArgumentType), Option<Span>>,\n+) -> hir::Expr<'hir> {\n+    let position = match placeholder.argument.index {\n+        Ok(arg_index) => {\n+            let (i, _) = argmap.insert_full(\n+                (arg_index, ArgumentType::Format(placeholder.format_trait)),\n+                placeholder.span,\n+            );\n+            ctx.expr_usize(sp, i)\n+        }\n+        Err(_) => ctx.expr(\n+            sp,\n+            hir::ExprKind::Err(ctx.tcx.sess.delay_span_bug(sp, \"lowered bad format_args count\")),\n+        ),\n+    };\n+    let &FormatOptions {\n+        ref width,\n+        ref precision,\n+        alignment,\n+        fill,\n+        sign,\n+        alternate,\n+        zero_pad,\n+        debug_hex,\n+    } = &placeholder.format_options;\n+    let fill = ctx.expr_char(sp, fill.unwrap_or(' '));\n+    let align = ctx.expr_lang_item_type_relative(\n+        sp,\n+        hir::LangItem::FormatAlignment,\n+        match alignment {\n+            Some(FormatAlignment::Left) => sym::Left,\n+            Some(FormatAlignment::Right) => sym::Right,\n+            Some(FormatAlignment::Center) => sym::Center,\n+            None => sym::Unknown,\n+        },\n+    );\n+    // This needs to match `Flag` in library/core/src/fmt/rt.rs.\n+    let flags: u32 = ((sign == Some(FormatSign::Plus)) as u32)\n+        | ((sign == Some(FormatSign::Minus)) as u32) << 1\n+        | (alternate as u32) << 2\n+        | (zero_pad as u32) << 3\n+        | ((debug_hex == Some(FormatDebugHex::Lower)) as u32) << 4\n+        | ((debug_hex == Some(FormatDebugHex::Upper)) as u32) << 5;\n+    let flags = ctx.expr_u32(sp, flags);\n+    let precision = make_count(ctx, sp, &precision, argmap);\n+    let width = make_count(ctx, sp, &width, argmap);\n+    let format_placeholder_new = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+        sp,\n+        hir::LangItem::FormatPlaceholder,\n+        sym::new,\n+    ));\n+    let args = ctx.arena.alloc_from_iter([position, fill, align, flags, precision, width]);\n+    ctx.expr_call_mut(sp, format_placeholder_new, args)\n+}\n+\n+fn expand_format_args<'hir>(\n+    ctx: &mut LoweringContext<'_, 'hir>,\n+    macsp: Span,\n+    fmt: &FormatArgs,\n+    allow_const: bool,\n+) -> hir::ExprKind<'hir> {\n+    let mut incomplete_lit = String::new();\n+    let lit_pieces =\n+        ctx.arena.alloc_from_iter(fmt.template.iter().enumerate().filter_map(|(i, piece)| {\n+            match piece {\n+                &FormatArgsPiece::Literal(s) => {\n+                    // Coalesce adjacent literal pieces.\n+                    if let Some(FormatArgsPiece::Literal(_)) = fmt.template.get(i + 1) {\n+                        incomplete_lit.push_str(s.as_str());\n+                        None\n+                    } else if !incomplete_lit.is_empty() {\n+                        incomplete_lit.push_str(s.as_str());\n+                        let s = Symbol::intern(&incomplete_lit);\n+                        incomplete_lit.clear();\n+                        Some(ctx.expr_str(fmt.span, s))\n+                    } else {\n+                        Some(ctx.expr_str(fmt.span, s))\n+                    }\n+                }\n+                &FormatArgsPiece::Placeholder(_) => {\n+                    // Inject empty string before placeholders when not already preceded by a literal piece.\n+                    if i == 0 || matches!(fmt.template[i - 1], FormatArgsPiece::Placeholder(_)) {\n+                        Some(ctx.expr_str(fmt.span, kw::Empty))\n+                    } else {\n+                        None\n+                    }\n+                }\n+            }\n+        }));\n+    let lit_pieces = ctx.expr_array_ref(fmt.span, lit_pieces);\n+\n+    // Whether we'll use the `Arguments::new_v1_formatted` form (true),\n+    // or the `Arguments::new_v1` form (false).\n+    let mut use_format_options = false;\n+\n+    // Create a list of all _unique_ (argument, format trait) combinations.\n+    // E.g. \"{0} {0:x} {0} {1}\" -> [(0, Display), (0, LowerHex), (1, Display)]\n+    let mut argmap = FxIndexMap::default();\n+    for piece in &fmt.template {\n+        let FormatArgsPiece::Placeholder(placeholder) = piece else { continue };\n+        if placeholder.format_options != Default::default() {\n+            // Can't use basic form if there's any formatting options.\n+            use_format_options = true;\n+        }\n+        if let Ok(index) = placeholder.argument.index {\n+            if argmap\n+                .insert((index, ArgumentType::Format(placeholder.format_trait)), placeholder.span)\n+                .is_some()\n+            {\n+                // Duplicate (argument, format trait) combination,\n+                // which we'll only put once in the args array.\n+                use_format_options = true;\n+            }\n+        }\n+    }\n+\n+    let format_options = use_format_options.then(|| {\n+        // Generate:\n+        //     &[format_spec_0, format_spec_1, format_spec_2]\n+        let elements: Vec<_> = fmt\n+            .template\n+            .iter()\n+            .filter_map(|piece| {\n+                let FormatArgsPiece::Placeholder(placeholder) = piece else { return None };\n+                Some(make_format_spec(ctx, macsp, placeholder, &mut argmap))\n+            })\n+            .collect();\n+        ctx.expr_array_ref(macsp, ctx.arena.alloc_from_iter(elements))\n+    });\n+\n+    let arguments = fmt.arguments.all_args();\n+\n+    if allow_const && arguments.is_empty() && argmap.is_empty() {\n+        // Generate:\n+        //     <core::fmt::Arguments>::new_const(lit_pieces)\n+        let new = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+            macsp,\n+            hir::LangItem::FormatArguments,\n+            sym::new_const,\n+        ));\n+        let new_args = ctx.arena.alloc_from_iter([lit_pieces]);\n+        return hir::ExprKind::Call(new, new_args);\n+    }\n+\n+    // If the args array contains exactly all the original arguments once,\n+    // in order, we can use a simple array instead of a `match` construction.\n+    // However, if there's a yield point in any argument except the first one,\n+    // we don't do this, because an Argument cannot be kept across yield points.\n+    //\n+    // This is an optimization, speeding up compilation about 1-2% in some cases.\n+    // See https://github.com/rust-lang/rust/pull/106770#issuecomment-1380790609\n+    let use_simple_array = argmap.len() == arguments.len()\n+        && argmap.iter().enumerate().all(|(i, (&(j, _), _))| i == j)\n+        && arguments.iter().skip(1).all(|arg| !may_contain_yield_point(&arg.expr));\n+\n+    let args = if arguments.is_empty() {\n+        // Generate:\n+        //    &<core::fmt::Argument>::none()\n+        //\n+        // Note:\n+        //     `none()` just returns `[]`. We use `none()` rather than `[]` to limit the lifetime.\n+        //\n+        //     This makes sure that this still fails to compile, even when the argument is inlined:\n+        //\n+        //     ```\n+        //     let f = format_args!(\"{}\", \"a\");\n+        //     println!(\"{f}\"); // error E0716\n+        //     ```\n+        //\n+        //     Cases where keeping the object around is allowed, such as `format_args!(\"a\")`,\n+        //     are handled above by the `allow_const` case.\n+        let none_fn = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+            macsp,\n+            hir::LangItem::FormatArgument,\n+            sym::none,\n+        ));\n+        let none = ctx.expr_call(macsp, none_fn, &[]);\n+        ctx.expr(macsp, hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, none))\n+    } else if use_simple_array {\n+        // Generate:\n+        //     &[\n+        //         <core::fmt::Argument>::new_display(&arg0),\n+        //         <core::fmt::Argument>::new_lower_hex(&arg1),\n+        //         <core::fmt::Argument>::new_debug(&arg2),\n+        //         \u2026\n+        //     ]\n+        let elements: Vec<_> = arguments\n+            .iter()\n+            .zip(argmap)\n+            .map(|(arg, ((_, ty), placeholder_span))| {\n+                let placeholder_span =\n+                    placeholder_span.unwrap_or(arg.expr.span).with_ctxt(macsp.ctxt());\n+                let arg_span = match arg.kind {\n+                    FormatArgumentKind::Captured(_) => placeholder_span,\n+                    _ => arg.expr.span.with_ctxt(macsp.ctxt()),\n+                };\n+                let arg = ctx.lower_expr(&arg.expr);\n+                let ref_arg = ctx.arena.alloc(ctx.expr(\n+                    arg_span,\n+                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, arg),\n+                ));\n+                make_argument(ctx, placeholder_span, ref_arg, ty)\n+            })\n+            .collect();\n+        ctx.expr_array_ref(macsp, ctx.arena.alloc_from_iter(elements))\n+    } else {\n+        // Generate:\n+        //     &match (&arg0, &arg1, &\u2026) {\n+        //         args => [\n+        //             <core::fmt::Argument>::new_display(args.0),\n+        //             <core::fmt::Argument>::new_lower_hex(args.1),\n+        //             <core::fmt::Argument>::new_debug(args.0),\n+        //             \u2026\n+        //         ]\n+        //     }\n+        let args_ident = Ident::new(sym::args, macsp);\n+        let (args_pat, args_hir_id) = ctx.pat_ident(macsp, args_ident);\n+        let args = ctx.arena.alloc_from_iter(argmap.iter().map(\n+            |(&(arg_index, ty), &placeholder_span)| {\n+                let arg = &arguments[arg_index];\n+                let placeholder_span =\n+                    placeholder_span.unwrap_or(arg.expr.span).with_ctxt(macsp.ctxt());\n+                let arg_span = match arg.kind {\n+                    FormatArgumentKind::Captured(_) => placeholder_span,\n+                    _ => arg.expr.span.with_ctxt(macsp.ctxt()),\n+                };\n+                let args_ident_expr = ctx.expr_ident(macsp, args_ident, args_hir_id);\n+                let arg = ctx.arena.alloc(ctx.expr(\n+                    arg_span,\n+                    hir::ExprKind::Field(\n+                        args_ident_expr,\n+                        Ident::new(sym::integer(arg_index), macsp),\n+                    ),\n+                ));\n+                make_argument(ctx, placeholder_span, arg, ty)\n+            },\n+        ));\n+        let elements: Vec<_> = arguments\n+            .iter()\n+            .map(|arg| {\n+                let arg_expr = ctx.lower_expr(&arg.expr);\n+                ctx.expr(\n+                    arg.expr.span.with_ctxt(macsp.ctxt()),\n+                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, arg_expr),\n+                )\n+            })\n+            .collect();\n+        let args_tuple = ctx\n+            .arena\n+            .alloc(ctx.expr(macsp, hir::ExprKind::Tup(ctx.arena.alloc_from_iter(elements))));\n+        let array = ctx.arena.alloc(ctx.expr(macsp, hir::ExprKind::Array(args)));\n+        let match_arms = ctx.arena.alloc_from_iter([ctx.arm(args_pat, array)]);\n+        let match_expr = ctx.arena.alloc(ctx.expr_match(\n+            macsp,\n+            args_tuple,\n+            match_arms,\n+            hir::MatchSource::FormatArgs,\n+        ));\n+        ctx.expr(\n+            macsp,\n+            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, match_expr),\n+        )\n+    };\n+\n+    if let Some(format_options) = format_options {\n+        // Generate:\n+        //     <core::fmt::Arguments>::new_v1_formatted(\n+        //         lit_pieces,\n+        //         args,\n+        //         format_options,\n+        //         unsafe { ::core::fmt::UnsafeArg::new() }\n+        //     )\n+        let new_v1_formatted = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+            macsp,\n+            hir::LangItem::FormatArguments,\n+            sym::new_v1_formatted,\n+        ));\n+        let unsafe_arg_new = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+            macsp,\n+            hir::LangItem::FormatUnsafeArg,\n+            sym::new,\n+        ));\n+        let unsafe_arg_new_call = ctx.expr_call(macsp, unsafe_arg_new, &[]);\n+        let hir_id = ctx.next_id();\n+        let unsafe_arg = ctx.expr_block(ctx.arena.alloc(hir::Block {\n+            stmts: &[],\n+            expr: Some(unsafe_arg_new_call),\n+            hir_id,\n+            rules: hir::BlockCheckMode::UnsafeBlock(hir::UnsafeSource::CompilerGenerated),\n+            span: macsp,\n+            targeted_by_break: false,\n+        }));\n+        let args = ctx.arena.alloc_from_iter([lit_pieces, args, format_options, unsafe_arg]);\n+        hir::ExprKind::Call(new_v1_formatted, args)\n+    } else {\n+        // Generate:\n+        //     <core::fmt::Arguments>::new_v1(\n+        //         lit_pieces,\n+        //         args,\n+        //     )\n+        let new_v1 = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+            macsp,\n+            hir::LangItem::FormatArguments,\n+            sym::new_v1,\n+        ));\n+        let new_args = ctx.arena.alloc_from_iter([lit_pieces, args]);\n+        hir::ExprKind::Call(new_v1, new_args)\n+    }\n+}\n+\n+fn may_contain_yield_point(e: &ast::Expr) -> bool {\n+    struct MayContainYieldPoint(bool);\n+\n+    impl Visitor<'_> for MayContainYieldPoint {\n+        fn visit_expr(&mut self, e: &ast::Expr) {\n+            if let ast::ExprKind::Await(_, _) | ast::ExprKind::Yield(_) = e.kind {\n+                self.0 = true;\n+            } else {\n+                visit::walk_expr(self, e);\n+            }\n+        }\n+\n+        fn visit_mac_call(&mut self, _: &ast::MacCall) {\n+            // Macros should be expanded at this point.\n+            unreachable!(\"unexpanded macro in ast lowering\");\n+        }\n+\n+        fn visit_item(&mut self, _: &ast::Item) {\n+            // Do not recurse into nested items.\n+        }\n+    }\n+\n+    let mut visitor = MayContainYieldPoint(false);\n+    visitor.visit_expr(e);\n+    visitor.0\n+}\n+\n+fn for_all_argument_indexes(template: &mut [FormatArgsPiece], mut f: impl FnMut(&mut usize)) {\n+    for piece in template {\n+        let FormatArgsPiece::Placeholder(placeholder) = piece else { continue };\n+        if let Ok(index) = &mut placeholder.argument.index {\n+            f(index);\n+        }\n+        if let Some(FormatCount::Argument(FormatArgPosition { index: Ok(index), .. })) =\n+            &mut placeholder.format_options.width\n+        {\n+            f(index);\n+        }\n+        if let Some(FormatCount::Argument(FormatArgPosition { index: Ok(index), .. })) =\n+            &mut placeholder.format_options.precision\n+        {\n+            f(index);\n+        }\n+    }\n+}"}, {"sha": "ce847906fb99a7f65ee327afccf3ddd313462e34", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 54, "deletions": 49, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -5,14 +5,12 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_hir::definitions;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::*;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::{Idx, IndexVec};\n use rustc_middle::span_bug;\n use rustc_session::Session;\n use rustc_span::source_map::SourceMap;\n use rustc_span::{Span, DUMMY_SP};\n \n-use tracing::debug;\n-\n /// A visitor that walks over the HIR and collects `Node`s into a HIR map.\n pub(super) struct NodeCollector<'a, 'hir> {\n     /// Source map\n@@ -26,12 +24,12 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     /// The parent of this node\n     parent_node: hir::ItemLocalId,\n \n-    owner: LocalDefId,\n+    owner: OwnerId,\n \n     definitions: &'a definitions::Definitions,\n }\n \n-#[tracing::instrument(level = \"debug\", skip(sess, definitions, bodies))]\n+#[instrument(level = \"debug\", skip(sess, definitions, bodies))]\n pub(super) fn index_hir<'hir>(\n     sess: &Session,\n     definitions: &definitions::Definitions,\n@@ -40,7 +38,7 @@ pub(super) fn index_hir<'hir>(\n ) -> (IndexVec<ItemLocalId, Option<ParentedNode<'hir>>>, FxHashMap<LocalDefId, ItemLocalId>) {\n     let mut nodes = IndexVec::new();\n     // This node's parent should never be accessed: the owner's parent is computed by the\n-    // hir_owner_parent query.  Make it invalid (= ItemLocalId::MAX) to force an ICE whenever it is\n+    // hir_owner_parent query. Make it invalid (= ItemLocalId::MAX) to force an ICE whenever it is\n     // used.\n     nodes.push(Some(ParentedNode { parent: ItemLocalId::INVALID, node: item.into() }));\n     let mut collector = NodeCollector {\n@@ -67,24 +65,25 @@ pub(super) fn index_hir<'hir>(\n }\n \n impl<'a, 'hir> NodeCollector<'a, 'hir> {\n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self))]\n     fn insert(&mut self, span: Span, hir_id: HirId, node: Node<'hir>) {\n         debug_assert_eq!(self.owner, hir_id.owner);\n         debug_assert_ne!(hir_id.local_id.as_u32(), 0);\n+        debug_assert_ne!(hir_id.local_id, self.parent_node);\n \n         // Make sure that the DepNode of some node coincides with the HirId\n         // owner of that node.\n         if cfg!(debug_assertions) {\n             if hir_id.owner != self.owner {\n                 span_bug!(\n                     span,\n-                    \"inconsistent DepNode at `{:?}` for `{:?}`: \\\n+                    \"inconsistent HirId at `{:?}` for `{:?}`: \\\n                      current_dep_node_owner={} ({:?}), hir_id.owner={} ({:?})\",\n                     self.source_map.span_to_diagnostic_string(span),\n                     node,\n-                    self.definitions.def_path(self.owner).to_string_no_crate_verbose(),\n+                    self.definitions.def_path(self.owner.def_id).to_string_no_crate_verbose(),\n                     self.owner,\n-                    self.definitions.def_path(hir_id.owner).to_string_no_crate_verbose(),\n+                    self.definitions.def_path(hir_id.owner.def_id).to_string_no_crate_verbose(),\n                     hir_id.owner,\n                 )\n             }\n@@ -113,19 +112,19 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_nested_item(&mut self, item: ItemId) {\n         debug!(\"visit_nested_item: {:?}\", item);\n-        self.insert_nested(item.def_id);\n+        self.insert_nested(item.owner_id.def_id);\n     }\n \n     fn visit_nested_trait_item(&mut self, item_id: TraitItemId) {\n-        self.insert_nested(item_id.def_id);\n+        self.insert_nested(item_id.owner_id.def_id);\n     }\n \n     fn visit_nested_impl_item(&mut self, item_id: ImplItemId) {\n-        self.insert_nested(item_id.def_id);\n+        self.insert_nested(item_id.owner_id.def_id);\n     }\n \n     fn visit_nested_foreign_item(&mut self, foreign_id: ForeignItemId) {\n-        self.insert_nested(foreign_id.def_id);\n+        self.insert_nested(foreign_id.owner_id.def_id);\n     }\n \n     fn visit_nested_body(&mut self, id: BodyId) {\n@@ -142,11 +141,11 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self))]\n     fn visit_item(&mut self, i: &'hir Item<'hir>) {\n-        debug_assert_eq!(i.def_id, self.owner);\n+        debug_assert_eq!(i.owner_id, self.owner);\n         self.with_parent(i.hir_id(), |this| {\n-            if let ItemKind::Struct(ref struct_def, _) = i.kind {\n+            if let ItemKind::Struct(struct_def, _) = &i.kind {\n                 // If this is a tuple or unit-like struct, register the constructor.\n                 if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n                     this.insert(i.span, ctor_hir_id, Node::Ctor(struct_def));\n@@ -156,9 +155,9 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self))]\n     fn visit_foreign_item(&mut self, fi: &'hir ForeignItem<'hir>) {\n-        debug_assert_eq!(fi.def_id, self.owner);\n+        debug_assert_eq!(fi.owner_id, self.owner);\n         self.with_parent(fi.hir_id(), |this| {\n             intravisit::walk_foreign_item(this, fi);\n         });\n@@ -175,17 +174,17 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         })\n     }\n \n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self))]\n     fn visit_trait_item(&mut self, ti: &'hir TraitItem<'hir>) {\n-        debug_assert_eq!(ti.def_id, self.owner);\n+        debug_assert_eq!(ti.owner_id, self.owner);\n         self.with_parent(ti.hir_id(), |this| {\n             intravisit::walk_trait_item(this, ti);\n         });\n     }\n \n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self))]\n     fn visit_impl_item(&mut self, ii: &'hir ImplItem<'hir>) {\n-        debug_assert_eq!(ii.def_id, self.owner);\n+        debug_assert_eq!(ii.owner_id, self.owner);\n         self.with_parent(ii.hir_id(), |this| {\n             intravisit::walk_impl_item(this, ii);\n         });\n@@ -199,6 +198,13 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n+    fn visit_pat_field(&mut self, field: &'hir PatField<'hir>) {\n+        self.insert(field.span, field.hir_id, Node::PatField(field));\n+        self.with_parent(field.hir_id, |this| {\n+            intravisit::walk_pat_field(this, field);\n+        });\n+    }\n+\n     fn visit_arm(&mut self, arm: &'hir Arm<'hir>) {\n         let node = Node::Arm(arm);\n \n@@ -217,6 +223,14 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n+    fn visit_inline_const(&mut self, constant: &'hir ConstBlock) {\n+        self.insert(DUMMY_SP, constant.hir_id, Node::ConstBlock(constant));\n+\n+        self.with_parent(constant.hir_id, |this| {\n+            intravisit::walk_inline_const(this, constant);\n+        });\n+    }\n+\n     fn visit_expr(&mut self, expr: &'hir Expr<'hir>) {\n         self.insert(expr.span, expr.hir_id, Node::Expr(expr));\n \n@@ -225,6 +239,13 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n+    fn visit_expr_field(&mut self, field: &'hir ExprField<'hir>) {\n+        self.insert(field.span, field.hir_id, Node::ExprField(field));\n+        self.with_parent(field.hir_id, |this| {\n+            intravisit::walk_expr_field(this, field);\n+        });\n+    }\n+\n     fn visit_stmt(&mut self, stmt: &'hir Stmt<'hir>) {\n         self.insert(stmt.span, stmt.hir_id, Node::Stmt(stmt));\n \n@@ -233,11 +254,9 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'hir PathSegment<'hir>) {\n-        if let Some(hir_id) = path_segment.hir_id {\n-            self.insert(path_span, hir_id, Node::PathSegment(path_segment));\n-        }\n-        intravisit::walk_path_segment(self, path_span, path_segment);\n+    fn visit_path_segment(&mut self, path_segment: &'hir PathSegment<'hir>) {\n+        self.insert(path_segment.ident.span, path_segment.hir_id, Node::PathSegment(path_segment));\n+        intravisit::walk_path_segment(self, path_segment);\n     }\n \n     fn visit_ty(&mut self, ty: &'hir Ty<'hir>) {\n@@ -264,19 +283,6 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_fn(\n-        &mut self,\n-        fk: intravisit::FnKind<'hir>,\n-        fd: &'hir FnDecl<'hir>,\n-        b: BodyId,\n-        s: Span,\n-        id: HirId,\n-    ) {\n-        assert_eq!(self.owner, id.owner);\n-        assert_eq!(self.parent_node, id.local_id);\n-        intravisit::walk_fn(self, fk, fd, b, s, id);\n-    }\n-\n     fn visit_block(&mut self, block: &'hir Block<'hir>) {\n         self.insert(block.span, block.hir_id, Node::Block(block));\n         self.with_parent(block.hir_id, |this| {\n@@ -292,17 +298,17 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &'hir Lifetime) {\n-        self.insert(lifetime.span, lifetime.hir_id, Node::Lifetime(lifetime));\n+        self.insert(lifetime.ident.span, lifetime.hir_id, Node::Lifetime(lifetime));\n     }\n \n-    fn visit_variant(&mut self, v: &'hir Variant<'hir>, g: &'hir Generics<'hir>, item_id: HirId) {\n-        self.insert(v.span, v.id, Node::Variant(v));\n-        self.with_parent(v.id, |this| {\n+    fn visit_variant(&mut self, v: &'hir Variant<'hir>) {\n+        self.insert(v.span, v.hir_id, Node::Variant(v));\n+        self.with_parent(v.hir_id, |this| {\n             // Register the constructor of this variant.\n             if let Some(ctor_hir_id) = v.data.ctor_hir_id() {\n                 this.insert(v.span, ctor_hir_id, Node::Ctor(&v.data));\n             }\n-            intravisit::walk_variant(this, v, g, item_id);\n+            intravisit::walk_variant(this, v);\n         });\n     }\n \n@@ -323,16 +329,15 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_trait_item_ref(&mut self, ii: &'hir TraitItemRef) {\n         // Do not visit the duplicate information in TraitItemRef. We want to\n         // map the actual nodes, not the duplicate ones in the *Ref.\n-        let TraitItemRef { id, ident: _, kind: _, span: _, defaultness: _ } = *ii;\n+        let TraitItemRef { id, ident: _, kind: _, span: _ } = *ii;\n \n         self.visit_nested_trait_item(id);\n     }\n \n     fn visit_impl_item_ref(&mut self, ii: &'hir ImplItemRef) {\n         // Do not visit the duplicate information in ImplItemRef. We want to\n         // map the actual nodes, not the duplicate ones in the *Ref.\n-        let ImplItemRef { id, ident: _, kind: _, span: _, defaultness: _, trait_item_def_id: _ } =\n-            *ii;\n+        let ImplItemRef { id, ident: _, kind: _, span: _, trait_item_def_id: _ } = *ii;\n \n         self.visit_nested_impl_item(id);\n     }"}, {"sha": "08ee3761bac2b33141c1206a89b3ff558919ed23", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 358, "deletions": 372, "changes": 730, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "patch": "@@ -1,31 +1,31 @@\n+use super::errors::{InvalidAbi, InvalidAbiSuggestion, MisplacedRelaxTraitBound};\n use super::ResolverAstLoweringExt;\n use super::{AstOwner, ImplTraitContext, ImplTraitPosition};\n use super::{FnDeclKind, LoweringContext, ParamMode};\n \n use rustc_ast::ptr::P;\n use rustc_ast::visit::AssocCtxt;\n use rustc_ast::*;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sorted_map::SortedMap;\n-use rustc_errors::struct_span_err;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::PredicateOrigin;\n-use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::ty::{DefIdTree, ResolverAstLowering, TyCtxt};\n+use rustc_index::{Idx, IndexSlice, IndexVec};\n+use rustc_middle::ty::{ResolverAstLowering, TyCtxt};\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n use rustc_target::spec::abi;\n use smallvec::{smallvec, SmallVec};\n-\n-use std::iter;\n+use thin_vec::ThinVec;\n \n pub(super) struct ItemLowerer<'a, 'hir> {\n     pub(super) tcx: TyCtxt<'hir>,\n     pub(super) resolver: &'a mut ResolverAstLowering,\n-    pub(super) ast_index: &'a IndexVec<LocalDefId, AstOwner<'a>>,\n+    pub(super) ast_index: &'a IndexSlice<LocalDefId, AstOwner<'a>>,\n     pub(super) owners: &'a mut IndexVec<LocalDefId, hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>>>,\n }\n \n@@ -64,11 +64,10 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             // HirId handling.\n             bodies: Vec::new(),\n             attrs: SortedMap::default(),\n-            children: FxHashMap::default(),\n-            current_hir_id_owner: CRATE_DEF_ID,\n+            children: Vec::default(),\n+            current_hir_id_owner: hir::CRATE_OWNER_ID,\n             item_local_id_counter: hir::ItemLocalId::new(0),\n             node_id_to_local_id: Default::default(),\n-            local_id_to_def_id: SortedMap::new(),\n             trait_map: Default::default(),\n \n             // Lowering state.\n@@ -80,28 +79,27 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             generator_kind: None,\n             task_context: None,\n             current_item: None,\n-            captured_lifetimes: None,\n             impl_trait_defs: Vec::new(),\n             impl_trait_bounds: Vec::new(),\n             allow_try_trait: Some([sym::try_trait_v2, sym::yeet_desugar_details][..].into()),\n-            allow_gen_future: Some([sym::gen_future][..].into()),\n-            allow_into_future: Some([sym::into_future][..].into()),\n+            allow_gen_future: Some([sym::gen_future, sym::closure_track_caller][..].into()),\n+            generics_def_id_map: Default::default(),\n         };\n         lctx.with_hir_id_owner(owner, |lctx| f(lctx));\n \n         for (def_id, info) in lctx.children {\n-            self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n-            debug_assert!(matches!(self.owners[def_id], hir::MaybeOwner::Phantom));\n-            self.owners[def_id] = info;\n+            let owner = self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n+            debug_assert!(matches!(owner, hir::MaybeOwner::Phantom));\n+            *owner = info;\n         }\n     }\n \n     pub(super) fn lower_node(\n         &mut self,\n         def_id: LocalDefId,\n     ) -> hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>> {\n-        self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n-        if let hir::MaybeOwner::Phantom = self.owners[def_id] {\n+        let owner = self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n+        if let hir::MaybeOwner::Phantom = owner {\n             let node = self.ast_index[def_id];\n             match node {\n                 AstOwner::NonOwner => {}\n@@ -121,7 +119,7 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n         self.with_lctx(CRATE_NODE_ID, |lctx| {\n             let module = lctx.lower_mod(&c.items, &c.spans);\n             lctx.lower_attrs(hir::CRATE_HIR_ID, &c.attrs);\n-            hir::OwnerNode::Crate(lctx.arena.alloc(module))\n+            hir::OwnerNode::Crate(module)\n         })\n     }\n \n@@ -139,12 +137,10 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             // Evaluate with the lifetimes in `params` in-scope.\n             // This is used to track which lifetimes have already been defined,\n             // and which need to be replicated when lowering an async fn.\n-            match parent_hir.node().expect_item().kind {\n-                hir::ItemKind::Impl(hir::Impl { ref of_trait, .. }) => {\n-                    lctx.is_in_trait_impl = of_trait.is_some();\n-                }\n-                _ => {}\n-            };\n+\n+            if let hir::ItemKind::Impl(impl_) = parent_hir.node().expect_item().kind {\n+                lctx.is_in_trait_impl = impl_.of_trait.is_some();\n+            }\n \n             match ctxt {\n                 AssocCtxt::Trait => hir::OwnerNode::TraitItem(lctx.lower_trait_item(item)),\n@@ -159,45 +155,40 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n }\n \n impl<'hir> LoweringContext<'_, 'hir> {\n-    pub(super) fn lower_mod(&mut self, items: &[P<Item>], spans: &ModSpans) -> hir::Mod<'hir> {\n-        hir::Mod {\n+    pub(super) fn lower_mod(\n+        &mut self,\n+        items: &[P<Item>],\n+        spans: &ModSpans,\n+    ) -> &'hir hir::Mod<'hir> {\n+        self.arena.alloc(hir::Mod {\n             spans: hir::ModSpans {\n                 inner_span: self.lower_span(spans.inner_span),\n                 inject_use_span: self.lower_span(spans.inject_use_span),\n             },\n             item_ids: self.arena.alloc_from_iter(items.iter().flat_map(|x| self.lower_item_ref(x))),\n-        }\n+        })\n     }\n \n     pub(super) fn lower_item_ref(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n-        let mut node_ids = smallvec![hir::ItemId { def_id: self.local_def_id(i.id) }];\n-        if let ItemKind::Use(ref use_tree) = &i.kind {\n-            self.lower_item_id_use_tree(use_tree, i.id, &mut node_ids);\n+        let mut node_ids =\n+            smallvec![hir::ItemId { owner_id: hir::OwnerId { def_id: self.local_def_id(i.id) } }];\n+        if let ItemKind::Use(use_tree) = &i.kind {\n+            self.lower_item_id_use_tree(use_tree, &mut node_ids);\n         }\n         node_ids\n     }\n \n-    fn lower_item_id_use_tree(\n-        &mut self,\n-        tree: &UseTree,\n-        base_id: NodeId,\n-        vec: &mut SmallVec<[hir::ItemId; 1]>,\n-    ) {\n-        match tree.kind {\n-            UseTreeKind::Nested(ref nested_vec) => {\n+    fn lower_item_id_use_tree(&mut self, tree: &UseTree, vec: &mut SmallVec<[hir::ItemId; 1]>) {\n+        match &tree.kind {\n+            UseTreeKind::Nested(nested_vec) => {\n                 for &(ref nested, id) in nested_vec {\n-                    vec.push(hir::ItemId { def_id: self.local_def_id(id) });\n-                    self.lower_item_id_use_tree(nested, id, vec);\n-                }\n-            }\n-            UseTreeKind::Glob => {}\n-            UseTreeKind::Simple(_, id1, id2) => {\n-                for (_, &id) in\n-                    iter::zip(self.expect_full_res_from_use(base_id).skip(1), &[id1, id2])\n-                {\n-                    vec.push(hir::ItemId { def_id: self.local_def_id(id) });\n+                    vec.push(hir::ItemId {\n+                        owner_id: hir::OwnerId { def_id: self.local_def_id(id) },\n+                    });\n+                    self.lower_item_id_use_tree(nested, vec);\n                 }\n             }\n+            UseTreeKind::Simple(..) | UseTreeKind::Glob => {}\n         }\n     }\n \n@@ -208,7 +199,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let attrs = self.lower_attrs(hir_id, &i.attrs);\n         let kind = self.lower_item_kind(i.span, i.id, hir_id, &mut ident, attrs, vis_span, &i.kind);\n         let item = hir::Item {\n-            def_id: hir_id.expect_owner(),\n+            owner_id: hir_id.expect_owner(),\n             ident: self.lower_ident(ident),\n             kind,\n             vis_span,\n@@ -227,26 +218,26 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         vis_span: Span,\n         i: &ItemKind,\n     ) -> hir::ItemKind<'hir> {\n-        match *i {\n-            ItemKind::ExternCrate(orig_name) => hir::ItemKind::ExternCrate(orig_name),\n-            ItemKind::Use(ref use_tree) => {\n+        match i {\n+            ItemKind::ExternCrate(orig_name) => hir::ItemKind::ExternCrate(*orig_name),\n+            ItemKind::Use(use_tree) => {\n                 // Start with an empty prefix.\n-                let prefix = Path { segments: vec![], span: use_tree.span, tokens: None };\n+                let prefix = Path { segments: ThinVec::new(), span: use_tree.span, tokens: None };\n \n                 self.lower_use_tree(use_tree, &prefix, id, vis_span, ident, attrs)\n             }\n-            ItemKind::Static(ref t, m, ref e) => {\n+            ItemKind::Static(box ast::StaticItem { ty: t, mutability: m, expr: e }) => {\n                 let (ty, body_id) = self.lower_const_item(t, span, e.as_deref());\n-                hir::ItemKind::Static(ty, m, body_id)\n+                hir::ItemKind::Static(ty, *m, body_id)\n             }\n-            ItemKind::Const(_, ref t, ref e) => {\n-                let (ty, body_id) = self.lower_const_item(t, span, e.as_deref());\n+            ItemKind::Const(box ast::ConstItem { ty, expr, .. }) => {\n+                let (ty, body_id) = self.lower_const_item(ty, span, expr.as_deref());\n                 hir::ItemKind::Const(ty, body_id)\n             }\n             ItemKind::Fn(box Fn {\n-                sig: FnSig { ref decl, header, span: fn_sig_span },\n-                ref generics,\n-                ref body,\n+                sig: FnSig { decl, header, span: fn_sig_span },\n+                generics,\n+                body,\n                 ..\n             }) => {\n                 self.with_new_scopes(|this| {\n@@ -257,43 +248,41 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     // only cares about the input argument patterns in the function\n                     // declaration (decl), not the return types.\n                     let asyncness = header.asyncness;\n-                    let body_id =\n-                        this.lower_maybe_async_body(span, &decl, asyncness, body.as_deref());\n+                    let body_id = this.lower_maybe_async_body(\n+                        span,\n+                        hir_id,\n+                        &decl,\n+                        asyncness,\n+                        body.as_deref(),\n+                    );\n \n                     let itctx = ImplTraitContext::Universal;\n-                    let (generics, decl) = this.lower_generics(generics, id, itctx, |this| {\n+                    let (generics, decl) = this.lower_generics(generics, id, &itctx, |this| {\n                         let ret_id = asyncness.opt_return_id();\n-                        this.lower_fn_decl(&decl, Some(id), FnDeclKind::Fn, ret_id)\n+                        this.lower_fn_decl(&decl, id, *fn_sig_span, FnDeclKind::Fn, ret_id)\n                     });\n                     let sig = hir::FnSig {\n                         decl,\n-                        header: this.lower_fn_header(header),\n-                        span: this.lower_span(fn_sig_span),\n+                        header: this.lower_fn_header(*header),\n+                        span: this.lower_span(*fn_sig_span),\n                     };\n                     hir::ItemKind::Fn(sig, generics, body_id)\n                 })\n             }\n-            ItemKind::Mod(_, ref mod_kind) => match mod_kind {\n+            ItemKind::Mod(_, mod_kind) => match mod_kind {\n                 ModKind::Loaded(items, _, spans) => {\n                     hir::ItemKind::Mod(self.lower_mod(items, spans))\n                 }\n                 ModKind::Unloaded => panic!(\"`mod` items should have been loaded by now\"),\n             },\n-            ItemKind::ForeignMod(ref fm) => hir::ItemKind::ForeignMod {\n+            ItemKind::ForeignMod(fm) => hir::ItemKind::ForeignMod {\n                 abi: fm.abi.map_or(abi::Abi::FALLBACK, |abi| self.lower_abi(abi)),\n                 items: self\n                     .arena\n                     .alloc_from_iter(fm.items.iter().map(|x| self.lower_foreign_item_ref(x))),\n             },\n-            ItemKind::GlobalAsm(ref asm) => {\n-                hir::ItemKind::GlobalAsm(self.lower_inline_asm(span, asm))\n-            }\n-            ItemKind::TyAlias(box TyAlias {\n-                ref generics,\n-                where_clauses,\n-                ty: Some(ref ty),\n-                ..\n-            }) => {\n+            ItemKind::GlobalAsm(asm) => hir::ItemKind::GlobalAsm(self.lower_inline_asm(span, asm)),\n+            ItemKind::TyAlias(box TyAlias { generics, where_clauses, ty, .. }) => {\n                 // We lower\n                 //\n                 // type Foo = impl Trait\n@@ -302,34 +291,33 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 //\n                 // type Foo = Foo1\n                 // opaque type Foo1: Trait\n-                let mut generics = generics.clone();\n-                add_ty_alias_where_clause(&mut generics, where_clauses, true);\n-                let (generics, ty) = self.lower_generics(\n-                    &generics,\n-                    id,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                    |this| this.lower_ty(ty, ImplTraitContext::TypeAliasesOpaqueTy),\n-                );\n-                hir::ItemKind::TyAlias(ty, generics)\n-            }\n-            ItemKind::TyAlias(box TyAlias {\n-                ref generics, ref where_clauses, ty: None, ..\n-            }) => {\n                 let mut generics = generics.clone();\n                 add_ty_alias_where_clause(&mut generics, *where_clauses, true);\n                 let (generics, ty) = self.lower_generics(\n                     &generics,\n                     id,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                    |this| this.arena.alloc(this.ty(span, hir::TyKind::Err)),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    |this| match ty {\n+                        None => {\n+                            let guar = this.tcx.sess.delay_span_bug(\n+                                span,\n+                                \"expected to lower type alias type, but it was missing\",\n+                            );\n+                            this.arena.alloc(this.ty(span, hir::TyKind::Err(guar)))\n+                        }\n+                        Some(ty) => this.lower_ty(\n+                            ty,\n+                            &ImplTraitContext::TypeAliasesOpaqueTy { in_assoc_ty: false },\n+                        ),\n+                    },\n                 );\n                 hir::ItemKind::TyAlias(ty, generics)\n             }\n-            ItemKind::Enum(ref enum_definition, ref generics) => {\n+            ItemKind::Enum(enum_definition, generics) => {\n                 let (generics, variants) = self.lower_generics(\n                     generics,\n                     id,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| {\n                         this.arena.alloc_from_iter(\n                             enum_definition.variants.iter().map(|x| this.lower_variant(x)),\n@@ -338,20 +326,20 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 hir::ItemKind::Enum(hir::EnumDef { variants }, generics)\n             }\n-            ItemKind::Struct(ref struct_def, ref generics) => {\n+            ItemKind::Struct(struct_def, generics) => {\n                 let (generics, struct_def) = self.lower_generics(\n                     generics,\n                     id,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| this.lower_variant_data(hir_id, struct_def),\n                 );\n                 hir::ItemKind::Struct(struct_def, generics)\n             }\n-            ItemKind::Union(ref vdata, ref generics) => {\n+            ItemKind::Union(vdata, generics) => {\n                 let (generics, vdata) = self.lower_generics(\n                     generics,\n                     id,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| this.lower_variant_data(hir_id, vdata),\n                 );\n                 hir::ItemKind::Union(vdata, generics)\n@@ -361,10 +349,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 polarity,\n                 defaultness,\n                 constness,\n-                generics: ref ast_generics,\n-                of_trait: ref trait_ref,\n-                self_ty: ref ty,\n-                items: ref impl_items,\n+                generics: ast_generics,\n+                of_trait: trait_ref,\n+                self_ty: ty,\n+                items: impl_items,\n             }) => {\n                 // Lower the \"impl header\" first. This ordering is important\n                 // for in-band lifetimes! Consider `'a` here:\n@@ -381,16 +369,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // parent lifetime.\n                 let itctx = ImplTraitContext::Universal;\n                 let (generics, (trait_ref, lowered_ty)) =\n-                    self.lower_generics(ast_generics, id, itctx, |this| {\n+                    self.lower_generics(ast_generics, id, &itctx, |this| {\n                         let trait_ref = trait_ref.as_ref().map(|trait_ref| {\n                             this.lower_trait_ref(\n                                 trait_ref,\n-                                ImplTraitContext::Disallowed(ImplTraitPosition::Trait),\n+                                &ImplTraitContext::Disallowed(ImplTraitPosition::Trait),\n                             )\n                         });\n \n-                        let lowered_ty = this\n-                            .lower_ty(ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+                        let lowered_ty = this.lower_ty(\n+                            ty,\n+                            &ImplTraitContext::Disallowed(ImplTraitPosition::ImplSelf),\n+                        );\n \n                         (trait_ref, lowered_ty)\n                     });\n@@ -402,66 +392,61 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // `defaultness.has_value()` is never called for an `impl`, always `true` in order\n                 // to not cause an assertion failure inside the `lower_defaultness` function.\n                 let has_val = true;\n-                let (defaultness, defaultness_span) = self.lower_defaultness(defaultness, has_val);\n+                let (defaultness, defaultness_span) = self.lower_defaultness(*defaultness, has_val);\n                 let polarity = match polarity {\n                     ImplPolarity::Positive => ImplPolarity::Positive,\n-                    ImplPolarity::Negative(s) => ImplPolarity::Negative(self.lower_span(s)),\n+                    ImplPolarity::Negative(s) => ImplPolarity::Negative(self.lower_span(*s)),\n                 };\n                 hir::ItemKind::Impl(self.arena.alloc(hir::Impl {\n-                    unsafety: self.lower_unsafety(unsafety),\n+                    unsafety: self.lower_unsafety(*unsafety),\n                     polarity,\n                     defaultness,\n                     defaultness_span,\n-                    constness: self.lower_constness(constness),\n+                    constness: self.lower_constness(*constness),\n                     generics,\n                     of_trait: trait_ref,\n                     self_ty: lowered_ty,\n                     items: new_impl_items,\n                 }))\n             }\n-            ItemKind::Trait(box Trait {\n-                is_auto,\n-                unsafety,\n-                ref generics,\n-                ref bounds,\n-                ref items,\n-            }) => {\n+            ItemKind::Trait(box Trait { is_auto, unsafety, generics, bounds, items }) => {\n                 let (generics, (unsafety, items, bounds)) = self.lower_generics(\n                     generics,\n                     id,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| {\n                         let bounds = this.lower_param_bounds(\n                             bounds,\n-                            ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n+                            &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n                         );\n                         let items = this.arena.alloc_from_iter(\n                             items.iter().map(|item| this.lower_trait_item_ref(item)),\n                         );\n-                        let unsafety = this.lower_unsafety(unsafety);\n+                        let unsafety = this.lower_unsafety(*unsafety);\n                         (unsafety, items, bounds)\n                     },\n                 );\n-                hir::ItemKind::Trait(is_auto, unsafety, generics, bounds, items)\n+                hir::ItemKind::Trait(*is_auto, unsafety, generics, bounds, items)\n             }\n-            ItemKind::TraitAlias(ref generics, ref bounds) => {\n+            ItemKind::TraitAlias(generics, bounds) => {\n                 let (generics, bounds) = self.lower_generics(\n                     generics,\n                     id,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| {\n                         this.lower_param_bounds(\n                             bounds,\n-                            ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n+                            &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n                         )\n                     },\n                 );\n                 hir::ItemKind::TraitAlias(generics, bounds)\n             }\n-            ItemKind::MacroDef(MacroDef { ref body, macro_rules }) => {\n-                let body = P(self.lower_mac_args(body));\n+            ItemKind::MacroDef(MacroDef { body, macro_rules }) => {\n+                let body = P(self.lower_delim_args(body));\n                 let macro_kind = self.resolver.decl_macro_kind(self.local_def_id(id));\n-                hir::ItemKind::Macro(ast::MacroDef { body, macro_rules }, macro_kind)\n+                let macro_def = self.arena.alloc(ast::MacroDef { body, macro_rules: *macro_rules });\n+                hir::ItemKind::Macro(macro_def, macro_kind)\n             }\n             ItemKind::MacCall(..) => {\n                 panic!(\"`TyMac` should have been expanded by now\")\n@@ -475,7 +460,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         span: Span,\n         body: Option<&Expr>,\n     ) -> (&'hir hir::Ty<'hir>, hir::BodyId) {\n-        let ty = self.lower_ty(ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+        let ty = self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::ConstTy));\n         (ty, self.lower_const_body(span, body))\n     }\n \n@@ -493,7 +478,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let segments = prefix.segments.iter().chain(path.segments.iter()).cloned().collect();\n \n         match tree.kind {\n-            UseTreeKind::Simple(rename, id1, id2) => {\n+            UseTreeKind::Simple(rename) => {\n                 *ident = tree.ident();\n \n                 // First, apply the prefix to the path.\n@@ -509,62 +494,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     }\n                 }\n \n-                let mut resolutions = self.expect_full_res_from_use(id).fuse();\n-                // We want to return *something* from this function, so hold onto the first item\n-                // for later.\n-                let ret_res = self.lower_res(resolutions.next().unwrap_or(Res::Err));\n-\n-                // Here, we are looping over namespaces, if they exist for the definition\n-                // being imported. We only handle type and value namespaces because we\n-                // won't be dealing with macros in the rest of the compiler.\n-                // Essentially a single `use` which imports two names is desugared into\n-                // two imports.\n-                for new_node_id in [id1, id2] {\n-                    let new_id = self.local_def_id(new_node_id);\n-                    let Some(res) = resolutions.next() else {\n-                        // Associate an HirId to both ids even if there is no resolution.\n-                        let _old = self.children.insert(\n-                            new_id,\n-                            hir::MaybeOwner::NonOwner(hir::HirId::make_owner(new_id)),\n-                        );\n-                        debug_assert!(_old.is_none());\n-                        continue;\n-                    };\n-                    let ident = *ident;\n-                    let mut path = path.clone();\n-                    for seg in &mut path.segments {\n-                        seg.id = self.next_node_id();\n-                    }\n-                    let span = path.span;\n-\n-                    self.with_hir_id_owner(new_node_id, |this| {\n-                        let res = this.lower_res(res);\n-                        let path = this.lower_path_extra(res, &path, ParamMode::Explicit);\n-                        let kind = hir::ItemKind::Use(path, hir::UseKind::Single);\n-                        if let Some(attrs) = attrs {\n-                            this.attrs.insert(hir::ItemLocalId::new(0), attrs);\n-                        }\n-\n-                        let item = hir::Item {\n-                            def_id: new_id,\n-                            ident: this.lower_ident(ident),\n-                            kind,\n-                            vis_span,\n-                            span: this.lower_span(span),\n-                        };\n-                        hir::OwnerNode::Item(this.arena.alloc(item))\n-                    });\n-                }\n-\n-                let path = self.lower_path_extra(ret_res, &path, ParamMode::Explicit);\n+                let res =\n+                    self.expect_full_res_from_use(id).map(|res| self.lower_res(res)).collect();\n+                let path = self.lower_use_path(res, &path, ParamMode::Explicit);\n                 hir::ItemKind::Use(path, hir::UseKind::Single)\n             }\n             UseTreeKind::Glob => {\n-                let path = self.lower_path(\n-                    id,\n-                    &Path { segments, span: path.span, tokens: None },\n-                    ParamMode::Explicit,\n-                );\n+                let res = self.expect_full_res(id);\n+                let res = smallvec![self.lower_res(res)];\n+                let path = Path { segments, span: path.span, tokens: None };\n+                let path = self.lower_use_path(res, &path, ParamMode::Explicit);\n                 hir::ItemKind::Use(path, hir::UseKind::Glob)\n             }\n             UseTreeKind::Nested(ref trees) => {\n@@ -585,7 +524,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 //\n                 // The first two are produced by recursively invoking\n                 // `lower_use_tree` (and indeed there may be things\n-                // like `use foo::{a::{b, c}}` and so forth).  They\n+                // like `use foo::{a::{b, c}}` and so forth). They\n                 // wind up being directly added to\n                 // `self.items`. However, the structure of this\n                 // function also requires us to return one item, and\n@@ -602,7 +541,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                     // Give the segments new node-ids since they are being cloned.\n                     for seg in &mut prefix.segments {\n-                        seg.id = self.next_node_id();\n+                        // Give the cloned segment the same resolution information\n+                        // as the old one (this is needed for stability checking).\n+                        let new_id = self.next_node_id();\n+                        self.resolver.clone_res(seg.id, new_id);\n+                        seg.id = new_id;\n                     }\n \n                     // Each `use` import is an item and thus are owners of the\n@@ -620,7 +563,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         }\n \n                         let item = hir::Item {\n-                            def_id: new_hir_id,\n+                            owner_id: hir::OwnerId { def_id: new_hir_id },\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis_span,\n@@ -630,40 +573,46 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     });\n                 }\n \n-                let res = self.expect_full_res_from_use(id).next().unwrap_or(Res::Err);\n-                let res = self.lower_res(res);\n-                let path = self.lower_path_extra(res, &prefix, ParamMode::Explicit);\n+                let res =\n+                    self.expect_full_res_from_use(id).map(|res| self.lower_res(res)).collect();\n+                let path = self.lower_use_path(res, &prefix, ParamMode::Explicit);\n                 hir::ItemKind::Use(path, hir::UseKind::ListStem)\n             }\n         }\n     }\n \n     fn lower_foreign_item(&mut self, i: &ForeignItem) -> &'hir hir::ForeignItem<'hir> {\n         let hir_id = self.lower_node_id(i.id);\n-        let def_id = hir_id.expect_owner();\n+        let owner_id = hir_id.expect_owner();\n         self.lower_attrs(hir_id, &i.attrs);\n         let item = hir::ForeignItem {\n-            def_id,\n+            owner_id,\n             ident: self.lower_ident(i.ident),\n-            kind: match i.kind {\n-                ForeignItemKind::Fn(box Fn { ref sig, ref generics, .. }) => {\n+            kind: match &i.kind {\n+                ForeignItemKind::Fn(box Fn { sig, generics, .. }) => {\n                     let fdec = &sig.decl;\n                     let itctx = ImplTraitContext::Universal;\n                     let (generics, (fn_dec, fn_args)) =\n-                        self.lower_generics(generics, i.id, itctx, |this| {\n+                        self.lower_generics(generics, i.id, &itctx, |this| {\n                             (\n                                 // Disallow `impl Trait` in foreign items.\n-                                this.lower_fn_decl(fdec, None, FnDeclKind::ExternFn, None),\n+                                this.lower_fn_decl(\n+                                    fdec,\n+                                    i.id,\n+                                    sig.span,\n+                                    FnDeclKind::ExternFn,\n+                                    None,\n+                                ),\n                                 this.lower_fn_params_to_names(fdec),\n                             )\n                         });\n \n                     hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n                 }\n-                ForeignItemKind::Static(ref t, m, _) => {\n-                    let ty =\n-                        self.lower_ty(t, ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n-                    hir::ForeignItemKind::Static(ty, m)\n+                ForeignItemKind::Static(t, m, _) => {\n+                    let ty = self\n+                        .lower_ty(t, &ImplTraitContext::Disallowed(ImplTraitPosition::StaticTy));\n+                    hir::ForeignItemKind::Static(ty, *m)\n                 }\n                 ForeignItemKind::TyAlias(..) => hir::ForeignItemKind::Type,\n                 ForeignItemKind::MacCall(_) => panic!(\"macro shouldn't exist here\"),\n@@ -676,18 +625,19 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_foreign_item_ref(&mut self, i: &ForeignItem) -> hir::ForeignItemRef {\n         hir::ForeignItemRef {\n-            id: hir::ForeignItemId { def_id: self.local_def_id(i.id) },\n+            id: hir::ForeignItemId { owner_id: hir::OwnerId { def_id: self.local_def_id(i.id) } },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n         }\n     }\n \n     fn lower_variant(&mut self, v: &Variant) -> hir::Variant<'hir> {\n-        let id = self.lower_node_id(v.id);\n-        self.lower_attrs(id, &v.attrs);\n+        let hir_id = self.lower_node_id(v.id);\n+        self.lower_attrs(hir_id, &v.attrs);\n         hir::Variant {\n-            id,\n-            data: self.lower_variant_data(id, &v.data),\n+            hir_id,\n+            def_id: self.local_def_id(v.id),\n+            data: self.lower_variant_data(hir_id, &v.data),\n             disr_expr: v.disr_expr.as_ref().map(|e| self.lower_anon_const(e)),\n             ident: self.lower_ident(v.ident),\n             span: self.lower_span(v.span),\n@@ -699,48 +649,50 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         parent_id: hir::HirId,\n         vdata: &VariantData,\n     ) -> hir::VariantData<'hir> {\n-        match *vdata {\n-            VariantData::Struct(ref fields, recovered) => hir::VariantData::Struct(\n+        match vdata {\n+            VariantData::Struct(fields, recovered) => hir::VariantData::Struct(\n                 self.arena\n                     .alloc_from_iter(fields.iter().enumerate().map(|f| self.lower_field_def(f))),\n-                recovered,\n+                *recovered,\n             ),\n-            VariantData::Tuple(ref fields, id) => {\n-                let ctor_id = self.lower_node_id(id);\n+            VariantData::Tuple(fields, id) => {\n+                let ctor_id = self.lower_node_id(*id);\n                 self.alias_attrs(ctor_id, parent_id);\n                 hir::VariantData::Tuple(\n                     self.arena.alloc_from_iter(\n                         fields.iter().enumerate().map(|f| self.lower_field_def(f)),\n                     ),\n                     ctor_id,\n+                    self.local_def_id(*id),\n                 )\n             }\n             VariantData::Unit(id) => {\n-                let ctor_id = self.lower_node_id(id);\n+                let ctor_id = self.lower_node_id(*id);\n                 self.alias_attrs(ctor_id, parent_id);\n-                hir::VariantData::Unit(ctor_id)\n+                hir::VariantData::Unit(ctor_id, self.local_def_id(*id))\n             }\n         }\n     }\n \n     fn lower_field_def(&mut self, (index, f): (usize, &FieldDef)) -> hir::FieldDef<'hir> {\n-        let ty = if let TyKind::Path(ref qself, ref path) = f.ty.kind {\n+        let ty = if let TyKind::Path(qself, path) = &f.ty.kind {\n             let t = self.lower_path_ty(\n                 &f.ty,\n                 qself,\n                 path,\n                 ParamMode::ExplicitNamed, // no `'_` in declarations (Issue #61124)\n-                ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n+                &ImplTraitContext::Disallowed(ImplTraitPosition::FieldTy),\n             );\n             self.arena.alloc(t)\n         } else {\n-            self.lower_ty(&f.ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n+            self.lower_ty(&f.ty, &ImplTraitContext::Disallowed(ImplTraitPosition::FieldTy))\n         };\n         let hir_id = self.lower_node_id(f.id);\n         self.lower_attrs(hir_id, &f.attrs);\n         hir::FieldDef {\n             span: self.lower_span(f.span),\n             hir_id,\n+            def_id: self.local_def_id(f.id),\n             ident: match f.ident {\n                 Some(ident) => self.lower_ident(ident),\n                 // FIXME(jseyfried): positional field hygiene.\n@@ -753,105 +705,114 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_trait_item(&mut self, i: &AssocItem) -> &'hir hir::TraitItem<'hir> {\n         let hir_id = self.lower_node_id(i.id);\n+        self.lower_attrs(hir_id, &i.attrs);\n         let trait_item_def_id = hir_id.expect_owner();\n \n-        let (generics, kind) = match i.kind {\n-            AssocItemKind::Const(_, ref ty, ref default) => {\n-                let ty = self.lower_ty(ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n-                let body = default.as_ref().map(|x| self.lower_const_body(i.span, Some(x)));\n-                (hir::Generics::empty(), hir::TraitItemKind::Const(ty, body))\n+        let (generics, kind, has_default) = match &i.kind {\n+            AssocItemKind::Const(box ConstItem { ty, expr, .. }) => {\n+                let ty =\n+                    self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::ConstTy));\n+                let body = expr.as_ref().map(|x| self.lower_const_body(i.span, Some(x)));\n+                (hir::Generics::empty(), hir::TraitItemKind::Const(ty, body), body.is_some())\n             }\n-            AssocItemKind::Fn(box Fn { ref sig, ref generics, body: None, .. }) => {\n+            AssocItemKind::Fn(box Fn { sig, generics, body: None, .. }) => {\n+                let asyncness = sig.header.asyncness;\n                 let names = self.lower_fn_params_to_names(&sig.decl);\n-                let (generics, sig) =\n-                    self.lower_method_sig(generics, sig, i.id, FnDeclKind::Trait, None);\n-                (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Required(names)))\n+                let (generics, sig) = self.lower_method_sig(\n+                    generics,\n+                    sig,\n+                    i.id,\n+                    FnDeclKind::Trait,\n+                    asyncness.opt_return_id(),\n+                );\n+                (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Required(names)), false)\n             }\n-            AssocItemKind::Fn(box Fn { ref sig, ref generics, body: Some(ref body), .. }) => {\n+            AssocItemKind::Fn(box Fn { sig, generics, body: Some(body), .. }) => {\n                 let asyncness = sig.header.asyncness;\n                 let body_id =\n-                    self.lower_maybe_async_body(i.span, &sig.decl, asyncness, Some(&body));\n+                    self.lower_maybe_async_body(i.span, hir_id, &sig.decl, asyncness, Some(&body));\n                 let (generics, sig) = self.lower_method_sig(\n                     generics,\n                     sig,\n                     i.id,\n                     FnDeclKind::Trait,\n                     asyncness.opt_return_id(),\n                 );\n-                (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Provided(body_id)))\n+                (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Provided(body_id)), true)\n             }\n-            AssocItemKind::TyAlias(box TyAlias {\n-                ref generics,\n-                where_clauses,\n-                ref bounds,\n-                ref ty,\n-                ..\n-            }) => {\n+            AssocItemKind::Type(box TyAlias { generics, where_clauses, bounds, ty, .. }) => {\n                 let mut generics = generics.clone();\n-                add_ty_alias_where_clause(&mut generics, where_clauses, false);\n-                self.lower_generics(\n+                add_ty_alias_where_clause(&mut generics, *where_clauses, false);\n+                let (generics, kind) = self.lower_generics(\n                     &generics,\n                     i.id,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| {\n                         let ty = ty.as_ref().map(|x| {\n-                            this.lower_ty(x, ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n+                            this.lower_ty(\n+                                x,\n+                                &ImplTraitContext::Disallowed(ImplTraitPosition::AssocTy),\n+                            )\n                         });\n                         hir::TraitItemKind::Type(\n                             this.lower_param_bounds(\n                                 bounds,\n-                                ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                                &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                             ),\n                             ty,\n                         )\n                     },\n-                )\n+                );\n+                (generics, kind, ty.is_some())\n             }\n             AssocItemKind::MacCall(..) => panic!(\"macro item shouldn't exist at this point\"),\n         };\n \n-        self.lower_attrs(hir_id, &i.attrs);\n         let item = hir::TraitItem {\n-            def_id: trait_item_def_id,\n+            owner_id: trait_item_def_id,\n             ident: self.lower_ident(i.ident),\n             generics,\n             kind,\n             span: self.lower_span(i.span),\n+            defaultness: hir::Defaultness::Default { has_value: has_default },\n         };\n         self.arena.alloc(item)\n     }\n \n     fn lower_trait_item_ref(&mut self, i: &AssocItem) -> hir::TraitItemRef {\n-        let (kind, has_default) = match &i.kind {\n-            AssocItemKind::Const(_, _, default) => (hir::AssocItemKind::Const, default.is_some()),\n-            AssocItemKind::TyAlias(box TyAlias { ty, .. }) => {\n-                (hir::AssocItemKind::Type, ty.is_some())\n-            }\n-            AssocItemKind::Fn(box Fn { sig, body, .. }) => {\n-                (hir::AssocItemKind::Fn { has_self: sig.decl.has_self() }, body.is_some())\n+        let kind = match &i.kind {\n+            AssocItemKind::Const(..) => hir::AssocItemKind::Const,\n+            AssocItemKind::Type(..) => hir::AssocItemKind::Type,\n+            AssocItemKind::Fn(box Fn { sig, .. }) => {\n+                hir::AssocItemKind::Fn { has_self: sig.decl.has_self() }\n             }\n             AssocItemKind::MacCall(..) => unimplemented!(),\n         };\n-        let id = hir::TraitItemId { def_id: self.local_def_id(i.id) };\n-        let defaultness = hir::Defaultness::Default { has_value: has_default };\n+        let id = hir::TraitItemId { owner_id: hir::OwnerId { def_id: self.local_def_id(i.id) } };\n         hir::TraitItemRef {\n             id,\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n-            defaultness,\n             kind,\n         }\n     }\n \n     /// Construct `ExprKind::Err` for the given `span`.\n-    pub(crate) fn expr_err(&mut self, span: Span) -> hir::Expr<'hir> {\n-        self.expr(span, hir::ExprKind::Err, AttrVec::new())\n+    pub(crate) fn expr_err(&mut self, span: Span, guar: ErrorGuaranteed) -> hir::Expr<'hir> {\n+        self.expr(span, hir::ExprKind::Err(guar))\n     }\n \n     fn lower_impl_item(&mut self, i: &AssocItem) -> &'hir hir::ImplItem<'hir> {\n+        // Since `default impl` is not yet implemented, this is always true in impls.\n+        let has_value = true;\n+        let (defaultness, _) = self.lower_defaultness(i.kind.defaultness(), has_value);\n+        let hir_id = self.lower_node_id(i.id);\n+        self.lower_attrs(hir_id, &i.attrs);\n+\n         let (generics, kind) = match &i.kind {\n-            AssocItemKind::Const(_, ty, expr) => {\n-                let ty = self.lower_ty(ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n+            AssocItemKind::Const(box ConstItem { ty, expr, .. }) => {\n+                let ty =\n+                    self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::ConstTy));\n                 (\n                     hir::Generics::empty(),\n                     hir::ImplItemKind::Const(ty, self.lower_const_body(i.span, expr.as_deref())),\n@@ -860,8 +821,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             AssocItemKind::Fn(box Fn { sig, generics, body, .. }) => {\n                 self.current_item = Some(i.span);\n                 let asyncness = sig.header.asyncness;\n-                let body_id =\n-                    self.lower_maybe_async_body(i.span, &sig.decl, asyncness, body.as_deref());\n+                let body_id = self.lower_maybe_async_body(\n+                    i.span,\n+                    hir_id,\n+                    &sig.decl,\n+                    asyncness,\n+                    body.as_deref(),\n+                );\n                 let (generics, sig) = self.lower_method_sig(\n                     generics,\n                     sig,\n@@ -872,59 +838,64 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                 (generics, hir::ImplItemKind::Fn(sig, body_id))\n             }\n-            AssocItemKind::TyAlias(box TyAlias { generics, where_clauses, ty, .. }) => {\n+            AssocItemKind::Type(box TyAlias { generics, where_clauses, ty, .. }) => {\n                 let mut generics = generics.clone();\n                 add_ty_alias_where_clause(&mut generics, *where_clauses, false);\n                 self.lower_generics(\n                     &generics,\n                     i.id,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| match ty {\n                         None => {\n-                            let ty = this.arena.alloc(this.ty(i.span, hir::TyKind::Err));\n-                            hir::ImplItemKind::TyAlias(ty)\n+                            let guar = this.tcx.sess.delay_span_bug(\n+                                i.span,\n+                                \"expected to lower associated type, but it was missing\",\n+                            );\n+                            let ty = this.arena.alloc(this.ty(i.span, hir::TyKind::Err(guar)));\n+                            hir::ImplItemKind::Type(ty)\n                         }\n                         Some(ty) => {\n-                            let ty = this.lower_ty(ty, ImplTraitContext::TypeAliasesOpaqueTy);\n-                            hir::ImplItemKind::TyAlias(ty)\n+                            let ty = this.lower_ty(\n+                                ty,\n+                                &ImplTraitContext::TypeAliasesOpaqueTy { in_assoc_ty: true },\n+                            );\n+                            hir::ImplItemKind::Type(ty)\n                         }\n                     },\n                 )\n             }\n             AssocItemKind::MacCall(..) => panic!(\"`TyMac` should have been expanded by now\"),\n         };\n \n-        let hir_id = self.lower_node_id(i.id);\n-        self.lower_attrs(hir_id, &i.attrs);\n         let item = hir::ImplItem {\n-            def_id: hir_id.expect_owner(),\n+            owner_id: hir_id.expect_owner(),\n             ident: self.lower_ident(i.ident),\n             generics,\n             kind,\n             vis_span: self.lower_span(i.vis.span),\n             span: self.lower_span(i.span),\n+            defaultness,\n         };\n         self.arena.alloc(item)\n     }\n \n     fn lower_impl_item_ref(&mut self, i: &AssocItem) -> hir::ImplItemRef {\n-        // Since `default impl` is not yet implemented, this is always true in impls.\n-        let has_value = true;\n-        let (defaultness, _) = self.lower_defaultness(i.kind.defaultness(), has_value);\n         hir::ImplItemRef {\n-            id: hir::ImplItemId { def_id: self.local_def_id(i.id) },\n+            id: hir::ImplItemId { owner_id: hir::OwnerId { def_id: self.local_def_id(i.id) } },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n-            defaultness,\n             kind: match &i.kind {\n                 AssocItemKind::Const(..) => hir::AssocItemKind::Const,\n-                AssocItemKind::TyAlias(..) => hir::AssocItemKind::Type,\n+                AssocItemKind::Type(..) => hir::AssocItemKind::Type,\n                 AssocItemKind::Fn(box Fn { sig, .. }) => {\n                     hir::AssocItemKind::Fn { has_self: sig.decl.has_self() }\n                 }\n                 AssocItemKind::MacCall(..) => unimplemented!(),\n             },\n-            trait_item_def_id: self.resolver.get_partial_res(i.id).map(|r| r.base_res().def_id()),\n+            trait_item_def_id: self\n+                .resolver\n+                .get_partial_res(i.id)\n+                .map(|r| r.expect_full_res().def_id()),\n         }\n     }\n \n@@ -949,7 +920,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         params: &'hir [hir::Param<'hir>],\n         value: hir::Expr<'hir>,\n     ) -> hir::BodyId {\n-        let body = hir::Body { generator_kind: self.generator_kind, params, value };\n+        let body = hir::Body {\n+            generator_kind: self.generator_kind,\n+            params,\n+            value: self.arena.alloc(value),\n+        };\n         let id = body.id();\n         debug_assert_eq!(id.hir_id.owner, self.current_hir_id_owner);\n         self.bodies.push((id.hir_id.local_id, self.arena.alloc(body)));\n@@ -1005,7 +980,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_block_expr_opt(&mut self, span: Span, block: Option<&Block>) -> hir::Expr<'hir> {\n         match block {\n             Some(block) => self.lower_block_expr(block),\n-            None => self.expr_err(span),\n+            None => self.expr_err(span, self.tcx.sess.delay_span_bug(span, \"no block\")),\n         }\n     }\n \n@@ -1015,7 +990,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 &[],\n                 match expr {\n                     Some(expr) => this.lower_expr_mut(expr),\n-                    None => this.expr_err(span),\n+                    None => this.expr_err(span, this.tcx.sess.delay_span_bug(span, \"no block\")),\n                 },\n             )\n         })\n@@ -1024,13 +999,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_maybe_async_body(\n         &mut self,\n         span: Span,\n+        fn_id: hir::HirId,\n         decl: &FnDecl,\n         asyncness: Async,\n         body: Option<&Block>,\n     ) -> hir::BodyId {\n-        let closure_id = match asyncness {\n-            Async::Yes { closure_id, .. } => closure_id,\n-            Async::No => return self.lower_fn_body_block(span, decl, body),\n+        let (closure_id, body) = match (asyncness, body) {\n+            (Async::Yes { closure_id, .. }, Some(body)) => (closure_id, body),\n+            _ => return self.lower_fn_body_block(span, decl, body),\n         };\n \n         self.lower_body(|this| {\n@@ -1076,12 +1052,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // Check if this is a binding pattern, if so, we can optimize and avoid adding a\n                 // `let <pat> = __argN;` statement. In this case, we do not rename the parameter.\n                 let (ident, is_simple_parameter) = match parameter.pat.kind {\n-                    hir::PatKind::Binding(\n-                        hir::BindingAnnotation::Unannotated | hir::BindingAnnotation::Mutable,\n-                        _,\n-                        ident,\n-                        _,\n-                    ) => (ident, true),\n+                    hir::PatKind::Binding(hir::BindingAnnotation(ByRef::No, _), _, ident, _) => {\n+                        (ident, true)\n+                    }\n                     // For `ref mut` or wildcard arguments, we can't reuse the binding, but\n                     // we can keep the same name for the parameter.\n                     // This lets rustdoc render it correctly in documentation.\n@@ -1091,7 +1064,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     }\n                     _ => {\n                         // Replace the ident for bindings that aren't simple.\n-                        let name = format!(\"__arg{}\", index);\n+                        let name = format!(\"__arg{index}\");\n                         let ident = Ident::from_str(&name);\n \n                         (ident, false)\n@@ -1146,7 +1119,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let (move_pat, move_id) = this.pat_ident_binding_mode(\n                         desugared_span,\n                         ident,\n-                        hir::BindingAnnotation::Mutable,\n+                        hir::BindingAnnotation::MUT,\n                     );\n                     let move_expr = this.expr_ident(desugared_span, ident, new_parameter_id);\n                     let move_stmt = this.stmt_let_pat(\n@@ -1175,25 +1148,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 parameters.push(new_parameter);\n             }\n \n-            let body_span = body.map_or(span, |b| b.span);\n             let async_expr = this.make_async_expr(\n                 CaptureBy::Value,\n                 closure_id,\n                 None,\n-                body_span,\n+                body.span,\n                 hir::AsyncGeneratorKind::Fn,\n                 |this| {\n                     // Create a block from the user's function body:\n-                    let user_body = this.lower_block_expr_opt(body_span, body);\n+                    let user_body = this.lower_block_expr(body);\n \n                     // Transform into `drop-temps { <user-body> }`, an expression:\n                     let desugared_span =\n                         this.mark_span_with_reason(DesugaringKind::Async, user_body.span, None);\n-                    let user_body = this.expr_drop_temps(\n-                        desugared_span,\n-                        this.arena.alloc(user_body),\n-                        AttrVec::new(),\n-                    );\n+                    let user_body =\n+                        this.expr_drop_temps(desugared_span, this.arena.alloc(user_body));\n \n                     // As noted above, create the final block like\n                     //\n@@ -1210,14 +1179,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         Some(user_body),\n                     );\n \n-                    this.expr_block(body, AttrVec::new())\n+                    this.expr_block(body)\n                 },\n             );\n \n-            (\n-                this.arena.alloc_from_iter(parameters),\n-                this.expr(body_span, async_expr, AttrVec::new()),\n-            )\n+            let hir_id = this.lower_node_id(closure_id);\n+            this.maybe_forward_track_caller(body.span, fn_id, hir_id);\n+            let expr = hir::Expr { hir_id, kind: async_expr, span: this.lower_span(body.span) };\n+\n+            (this.arena.alloc_from_iter(parameters), expr)\n         })\n     }\n \n@@ -1227,12 +1197,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         sig: &FnSig,\n         id: NodeId,\n         kind: FnDeclKind,\n-        is_async: Option<NodeId>,\n+        is_async: Option<(NodeId, Span)>,\n     ) -> (&'hir hir::Generics<'hir>, hir::FnSig<'hir>) {\n         let header = self.lower_fn_header(sig.header);\n         let itctx = ImplTraitContext::Universal;\n-        let (generics, decl) = self.lower_generics(generics, id, itctx, |this| {\n-            this.lower_fn_decl(&sig.decl, Some(id), kind, is_async)\n+        let (generics, decl) = self.lower_generics(generics, id, &itctx, |this| {\n+            this.lower_fn_decl(&sig.decl, id, sig.span, kind, is_async)\n         });\n         (generics, hir::FnSig { header, decl, span: self.lower_span(sig.span) })\n     }\n@@ -1262,10 +1232,20 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn error_on_invalid_abi(&self, abi: StrLit) {\n-        struct_span_err!(self.tcx.sess, abi.span, E0703, \"invalid ABI: found `{}`\", abi.symbol)\n-            .span_label(abi.span, \"invalid ABI\")\n-            .help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")))\n-            .emit();\n+        let abi_names = abi::enabled_names(self.tcx.features(), abi.span)\n+            .iter()\n+            .map(|s| Symbol::intern(s))\n+            .collect::<Vec<_>>();\n+        let suggested_name = find_best_match_for_name(&abi_names, abi.symbol_unescaped, None);\n+        self.tcx.sess.emit_err(InvalidAbi {\n+            abi: abi.symbol_unescaped,\n+            span: abi.span,\n+            suggestion: suggested_name.map(|suggested_name| InvalidAbiSuggestion {\n+                span: abi.span,\n+                suggestion: format!(\"\\\"{suggested_name}\\\"\"),\n+            }),\n+            command: \"rustc --print=calling-conventions\".to_string(),\n+        });\n     }\n \n     fn lower_asyncness(&mut self, a: Async) -> hir::IsAsync {\n@@ -1275,7 +1255,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    fn lower_constness(&mut self, c: Const) -> hir::Constness {\n+    pub(super) fn lower_constness(&mut self, c: Const) -> hir::Constness {\n         match c {\n             Const::Yes(_) => hir::Constness::Const,\n             Const::No => hir::Constness::NotConst,\n@@ -1296,7 +1276,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         generics: &Generics,\n         parent_node_id: NodeId,\n-        itctx: ImplTraitContext,\n+        itctx: &ImplTraitContext,\n         f: impl FnOnce(&mut Self) -> T,\n     ) -> (&'hir hir::Generics<'hir>, T) {\n         debug_assert!(self.impl_trait_defs.is_empty());\n@@ -1308,17 +1288,17 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // keep track of the Span info. Now, `add_implicitly_sized` in `AstConv` checks both param bounds and\n         // where clauses for `?Sized`.\n         for pred in &generics.where_clause.predicates {\n-            let WherePredicate::BoundPredicate(ref bound_pred) = *pred else {\n+            let WherePredicate::BoundPredicate(bound_pred) = pred else {\n                 continue;\n             };\n             let compute_is_param = || {\n                 // Check if the where clause type is a plain type parameter.\n                 match self\n                     .resolver\n                     .get_partial_res(bound_pred.bounded_ty.id)\n-                    .map(|d| (d.base_res(), d.unresolved_segments()))\n+                    .and_then(|r| r.full_res())\n                 {\n-                    Some((Res::Def(DefKind::TyParam, def_id), 0))\n+                    Some(Res::Def(DefKind::TyParam, def_id))\n                         if bound_pred.bound_generic_params.is_empty() =>\n                     {\n                         generics\n@@ -1340,23 +1320,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n                 let is_param = *is_param.get_or_insert_with(compute_is_param);\n                 if !is_param {\n-                    self.diagnostic().span_err(\n-                        bound.span(),\n-                        \"`?Trait` bounds are only permitted at the \\\n-                        point where a type parameter is declared\",\n-                    );\n+                    self.tcx.sess.emit_err(MisplacedRelaxTraitBound { span: bound.span() });\n                 }\n             }\n         }\n \n         let mut predicates: SmallVec<[hir::WherePredicate<'hir>; 4]> = SmallVec::new();\n         predicates.extend(generics.params.iter().filter_map(|param| {\n-            let bounds = self.lower_param_bounds(&param.bounds, itctx);\n             self.lower_generic_bound_predicate(\n                 param.ident,\n                 param.id,\n                 &param.kind,\n-                bounds,\n+                &param.bounds,\n+                param.colon_span,\n+                generics.span,\n+                itctx,\n                 PredicateOrigin::GenericParam,\n             )\n         }));\n@@ -1368,13 +1346,19 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 .map(|predicate| self.lower_where_predicate(predicate)),\n         );\n \n-        let mut params: SmallVec<[hir::GenericParam<'hir>; 4]> =\n-            self.lower_generic_params_mut(&generics.params).collect();\n+        let mut params: SmallVec<[hir::GenericParam<'hir>; 4]> = self\n+            .lower_generic_params_mut(&generics.params, hir::GenericParamSource::Generics)\n+            .collect();\n \n         // Introduce extra lifetimes if late resolution tells us to.\n         let extra_lifetimes = self.resolver.take_extra_lifetime_params(parent_node_id);\n         params.extend(extra_lifetimes.into_iter().filter_map(|(ident, node_id, res)| {\n-            self.lifetime_res_to_generic_param(ident, node_id, res)\n+            self.lifetime_res_to_generic_param(\n+                ident,\n+                node_id,\n+                res,\n+                hir::GenericParamSource::Generics,\n+            )\n         }));\n \n         let has_where_clause_predicates = !generics.where_clause.predicates.is_empty();\n@@ -1404,43 +1388,50 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         ident: Ident,\n         id: NodeId,\n         kind: &GenericParamKind,\n-        bounds: &'hir [hir::GenericBound<'hir>],\n+        bounds: &[GenericBound],\n+        colon_span: Option<Span>,\n+        parent_span: Span,\n+        itctx: &ImplTraitContext,\n         origin: PredicateOrigin,\n     ) -> Option<hir::WherePredicate<'hir>> {\n         // Do not create a clause if we do not have anything inside it.\n         if bounds.is_empty() {\n             return None;\n         }\n+\n+        let bounds = self.lower_param_bounds(bounds, itctx);\n+\n         let ident = self.lower_ident(ident);\n         let param_span = ident.span;\n-        let span = bounds\n-            .iter()\n-            .fold(Some(param_span.shrink_to_hi()), |span: Option<Span>, bound| {\n-                let bound_span = bound.span();\n-                // We include bounds that come from a `#[derive(_)]` but point at the user's code,\n-                // as we use this method to get a span appropriate for suggestions.\n-                if !bound_span.can_be_used_for_suggestions() {\n-                    None\n-                } else if let Some(span) = span {\n-                    Some(span.to(bound_span))\n-                } else {\n-                    Some(bound_span)\n-                }\n-            })\n-            .unwrap_or(param_span.shrink_to_hi());\n+\n+        // Reconstruct the span of the entire predicate from the individual generic bounds.\n+        let span_start = colon_span.unwrap_or_else(|| param_span.shrink_to_hi());\n+        let span = bounds.iter().fold(span_start, |span_accum, bound| {\n+            match bound.span().find_ancestor_inside(parent_span) {\n+                Some(bound_span) => span_accum.to(bound_span),\n+                None => span_accum,\n+            }\n+        });\n+        let span = self.lower_span(span);\n+\n         match kind {\n             GenericParamKind::Const { .. } => None,\n             GenericParamKind::Type { .. } => {\n                 let def_id = self.local_def_id(id).to_def_id();\n+                let hir_id = self.next_id();\n+                let res = Res::Def(DefKind::TyParam, def_id);\n                 let ty_path = self.arena.alloc(hir::Path {\n                     span: param_span,\n-                    res: Res::Def(DefKind::TyParam, def_id),\n-                    segments: self.arena.alloc_from_iter([hir::PathSegment::from_ident(ident)]),\n+                    res,\n+                    segments: self\n+                        .arena\n+                        .alloc_from_iter([hir::PathSegment::new(ident, hir_id, res)]),\n                 });\n                 let ty_id = self.next_id();\n                 let bounded_ty =\n                     self.ty_path(ty_id, param_span, hir::QPath::Resolved(None, ty_path));\n                 Some(hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n+                    hir_id: self.next_id(),\n                     bounded_ty: self.arena.alloc(bounded_ty),\n                     bounds,\n                     span,\n@@ -1449,13 +1440,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }))\n             }\n             GenericParamKind::Lifetime => {\n-                let ident_span = self.lower_span(ident.span);\n                 let ident = self.lower_ident(ident);\n-                let res = self.resolver.get_lifetime_res(id).unwrap_or_else(|| {\n-                    panic!(\"Missing resolution for lifetime {:?} at {:?}\", id, ident.span)\n-                });\n                 let lt_id = self.next_node_id();\n-                let lifetime = self.new_named_lifetime_with_res(lt_id, ident_span, ident, res);\n+                let lifetime = self.new_named_lifetime(id, lt_id, ident);\n                 Some(hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n                     lifetime,\n                     span,\n@@ -1467,46 +1454,45 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_where_predicate(&mut self, pred: &WherePredicate) -> hir::WherePredicate<'hir> {\n-        match *pred {\n+        match pred {\n             WherePredicate::BoundPredicate(WhereBoundPredicate {\n-                ref bound_generic_params,\n-                ref bounded_ty,\n-                ref bounds,\n+                bound_generic_params,\n+                bounded_ty,\n+                bounds,\n                 span,\n             }) => hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n-                bound_generic_params: self.lower_generic_params(bound_generic_params),\n+                hir_id: self.next_id(),\n+                bound_generic_params: self\n+                    .lower_generic_params(bound_generic_params, hir::GenericParamSource::Binder),\n                 bounded_ty: self\n-                    .lower_ty(bounded_ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n+                    .lower_ty(bounded_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Bound)),\n                 bounds: self.arena.alloc_from_iter(bounds.iter().map(|bound| {\n                     self.lower_param_bound(\n                         bound,\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n+                        &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n                     )\n                 })),\n-                span: self.lower_span(span),\n+                span: self.lower_span(*span),\n                 origin: PredicateOrigin::WhereClause,\n             }),\n-            WherePredicate::RegionPredicate(WhereRegionPredicate {\n-                ref lifetime,\n-                ref bounds,\n-                span,\n-            }) => hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n-                span: self.lower_span(span),\n-                lifetime: self.lower_lifetime(lifetime),\n-                bounds: self.lower_param_bounds(\n-                    bounds,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n-                ),\n-                in_where_clause: true,\n-            }),\n-            WherePredicate::EqPredicate(WhereEqPredicate { id, ref lhs_ty, ref rhs_ty, span }) => {\n+            WherePredicate::RegionPredicate(WhereRegionPredicate { lifetime, bounds, span }) => {\n+                hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n+                    span: self.lower_span(*span),\n+                    lifetime: self.lower_lifetime(lifetime),\n+                    bounds: self.lower_param_bounds(\n+                        bounds,\n+                        &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n+                    ),\n+                    in_where_clause: true,\n+                })\n+            }\n+            WherePredicate::EqPredicate(WhereEqPredicate { lhs_ty, rhs_ty, span }) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n-                    hir_id: self.lower_node_id(id),\n                     lhs_ty: self\n-                        .lower_ty(lhs_ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n+                        .lower_ty(lhs_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Bound)),\n                     rhs_ty: self\n-                        .lower_ty(rhs_ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n-                    span: self.lower_span(span),\n+                        .lower_ty(rhs_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Bound)),\n+                    span: self.lower_span(*span),\n                 })\n             }\n         }"}, {"sha": "8d4f96639efbd0d64a6553311d72b385bf900a88", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "3989fc486193e6d25922c6100b0ba91917f17e6d", "filename": "compiler/rustc_ast_lowering/src/lifetime_collector.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Flifetime_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Flifetime_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flifetime_collector.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "2509b70563956758860d1f855675d71d5e2c68f7", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 77, "deletions": 88, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "441282c05b42466848cc991a142f43e5378b3fe5", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 75, "deletions": 64, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "eb73612352072607f0acbb5e83bcd05b61d6a602", "filename": "compiler/rustc_ast_passes/Cargo.toml", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2FCargo.toml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "2f0ac0c2b1987e3c78b0421c8070cc80fb43a9ac", "filename": "compiler/rustc_ast_passes/messages.ftl", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_passes%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_passes%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fmessages.ftl?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "04ed27678765259a9cc47ce1eec644b3699a9f2b", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 370, "deletions": 762, "changes": 1132, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "82fe2a21d0876910bcb72fc82e951cb8715a5bfd", "filename": "compiler/rustc_ast_passes/src/errors.rs", "status": "added", "additions": 710, "deletions": 0, "changes": 710, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "2125349909ef154b90a78db0cf7f4940733a277b", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 189, "deletions": 414, "changes": 603, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "7db413c5bbd420ca927d2dbb50b967877c601244", "filename": "compiler/rustc_ast_passes/src/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "fa42f87786de913c477daf8ebcb1d764e6a4196f", "filename": "compiler/rustc_ast_passes/src/node_count.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "280cf3284c38ccd4940902c8c6346a7059ba7603", "filename": "compiler/rustc_ast_passes/src/show_span.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "980a8fa93a97d531c1647b902d36e21857f1bd39", "filename": "compiler/rustc_ast_pretty/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2FCargo.toml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "c3e0eccd3d4046a98fb52bb231f7eb1b018dd2c4", "filename": "compiler/rustc_ast_pretty/src/helpers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_pretty%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_pretty%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fhelpers.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "bf094af5f7bb0910beec66e0b3d114457345943c", "filename": "compiler/rustc_ast_pretty/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "7ab8c3eaba2273d96a6a4693dc53653f314eba36", "filename": "compiler/rustc_ast_pretty/src/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "3f80728a2606b64280820c1ba80b2dfe45b06a57", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 190, "deletions": 170, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "87c32ffce1214b6ffbced065d7eb358561f0509b", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 233, "deletions": 94, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "c465f8c948a801ee468f3b6927d371fdd8218e26", "filename": "compiler/rustc_ast_pretty/src/pprust/state/item.rs", "status": "modified", "additions": 76, "deletions": 72, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "3b2b60a86f06e8d5728a6b0539290f6c9fd3c414", "filename": "compiler/rustc_ast_pretty/src/pprust/tests.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Ftests.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "2c4c3a0c2635b5ff1888e32fc60fc22ac3646139", "filename": "compiler/rustc_attr/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_attr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_attr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2FCargo.toml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "e6cbbaf3704bc3e63e75458a67b76fe3e52475b2", "filename": "compiler/rustc_attr/messages.ftl", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_attr%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_attr%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fmessages.ftl?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "372a58857f3d38bbca4e62f9832f0a06122368d4", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 527, "deletions": 512, "changes": 1039, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "cfed2acfb3a41dec0806f114a8b3d67a5e19706a", "filename": "compiler/rustc_attr/src/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Flib.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "ee79545e304aea65772b3fc521f4575753063304", "filename": "compiler/rustc_attr/src/session_diagnostics.rs", "status": "added", "additions": 394, "deletions": 0, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "d3a307675ac4bcd1286d039da3be52de84ccf7c6", "filename": "compiler/rustc_baked_icu_data/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2FCargo.toml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "230288766764caab87ef151e34e3847949bdbf98", "filename": "compiler/rustc_baked_icu_data/src/data/any.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Fany.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "57f7496dcff8b8bbfe7ceee7abdf43cb4ea5862f", "filename": "compiler/rustc_baked_icu_data/src/data/fallback/likelysubtags_v1/mod.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Flikelysubtags_v1%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Flikelysubtags_v1%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Flikelysubtags_v1%2Fmod.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "e4aaf50f5d674f53f1bdd67b8f21708ffbd424aa", "filename": "compiler/rustc_baked_icu_data/src/data/fallback/likelysubtags_v1/und.rs.data", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Flikelysubtags_v1%2Fund.rs.data", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Flikelysubtags_v1%2Fund.rs.data", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Flikelysubtags_v1%2Fund.rs.data?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "a485a5af64ca56e15f8e1a3fb5485c4388966105", "filename": "compiler/rustc_baked_icu_data/src/data/fallback/mod.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Fmod.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "ce04af868aa54561590e20e8c3d2a703e0de24c7", "filename": "compiler/rustc_baked_icu_data/src/data/fallback/parents_v1/mod.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Fparents_v1%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Fparents_v1%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Fparents_v1%2Fmod.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "a13646a0b925e1c4b2750e515ef068ccaef14272", "filename": "compiler/rustc_baked_icu_data/src/data/fallback/parents_v1/und.rs.data", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Fparents_v1%2Fund.rs.data", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Fparents_v1%2Fund.rs.data", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Fparents_v1%2Fund.rs.data?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "9023647138b1bd7597812cc96db0839bf2fe8169", "filename": "compiler/rustc_baked_icu_data/src/data/fallback/supplement/co_v1/mod.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Fsupplement%2Fco_v1%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Fsupplement%2Fco_v1%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Fsupplement%2Fco_v1%2Fmod.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "647f8f5160191bf585603c18aa4446736576c976", "filename": "compiler/rustc_baked_icu_data/src/data/fallback/supplement/co_v1/und.rs.data", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Fsupplement%2Fco_v1%2Fund.rs.data", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Fsupplement%2Fco_v1%2Fund.rs.data", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Fsupplement%2Fco_v1%2Fund.rs.data?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "62957134f0755fd40905fdf63d9de5afa3cc1e5c", "filename": "compiler/rustc_baked_icu_data/src/data/fallback/supplement/mod.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Fsupplement%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Fsupplement%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Ffallback%2Fsupplement%2Fmod.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "4bf244019ff19fb5b345db6ff2a67b90d5f69808", "filename": "compiler/rustc_baked_icu_data/src/data/list/and_v1/en.rs.data", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fen.rs.data", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fen.rs.data", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fen.rs.data?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "84de7cd01a7e0b74d70f22cd1bb27d443cab5e32", "filename": "compiler/rustc_baked_icu_data/src/data/list/and_v1/es.rs.data", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fes.rs.data", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fes.rs.data", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fes.rs.data?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "79a97e50f5a8618384ac3e7889f045e96fdc6ad0", "filename": "compiler/rustc_baked_icu_data/src/data/list/and_v1/fr.rs.data", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Ffr.rs.data", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Ffr.rs.data", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Ffr.rs.data?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "b976b6cb65aaf53318e80394b1059ddd47bc5fd4", "filename": "compiler/rustc_baked_icu_data/src/data/list/and_v1/it.rs.data", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fit.rs.data", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fit.rs.data", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fit.rs.data?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "d76d567ebf875ec47f9b08d68948fbfbc64ccb1c", "filename": "compiler/rustc_baked_icu_data/src/data/list/and_v1/ja.rs.data", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fja.rs.data", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fja.rs.data", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fja.rs.data?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "e20941f0c6767339ed000e4655062ea6072533de", "filename": "compiler/rustc_baked_icu_data/src/data/list/and_v1/mod.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fmod.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "3d8c89f9072fd75ee1649bb488e47f66e82bb4fd", "filename": "compiler/rustc_baked_icu_data/src/data/list/and_v1/pt.rs.data", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fpt.rs.data", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fpt.rs.data", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fpt.rs.data?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "653ce28d615add410a51221b31dec74a5f9dd452", "filename": "compiler/rustc_baked_icu_data/src/data/list/and_v1/ru.rs.data", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fru.rs.data", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fru.rs.data", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fru.rs.data?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "9fa6eb56ade201ad809ed20f3984e5d74c547066", "filename": "compiler/rustc_baked_icu_data/src/data/list/and_v1/tr.rs.data", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Ftr.rs.data", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Ftr.rs.data", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Ftr.rs.data?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "66b55c253688daada7e1cadcaa5bf3c453b68fd0", "filename": "compiler/rustc_baked_icu_data/src/data/list/and_v1/und.rs.data", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fund.rs.data", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fund.rs.data", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fund.rs.data?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "38da6ecf8152a3ae9bfa64404cb2ea9a1ab0349a", "filename": "compiler/rustc_baked_icu_data/src/data/list/and_v1/zh-Hant.rs.data", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fzh-Hant.rs.data", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fzh-Hant.rs.data", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fzh-Hant.rs.data?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "d4dac1c386eced9c1fc9fda4f2c1cc5637fb84f9", "filename": "compiler/rustc_baked_icu_data/src/data/list/and_v1/zh.rs.data", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fzh.rs.data", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fzh.rs.data", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fand_v1%2Fzh.rs.data?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "931822513cc06fe771488385e4da26ef1dea6e80", "filename": "compiler/rustc_baked_icu_data/src/data/list/mod.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Flist%2Fmod.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "943187808b8180364264158675c7dcb33f082498", "filename": "compiler/rustc_baked_icu_data/src/data/mod.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Fdata%2Fmod.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "4651e03f77166857e3d193c190789c89e6b9f24f", "filename": "compiler/rustc_baked_icu_data/src/lib.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_baked_icu_data%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_baked_icu_data%2Fsrc%2Flib.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "56a9deb6aab1443d4b52da4f8f6d08cb4d9d2a0b", "filename": "compiler/rustc_borrowck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2FCargo.toml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "67fdb671742da838921bd3d5daf9df1c3d6fc1b6", "filename": "compiler/rustc_borrowck/messages.ftl", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fmessages.ftl?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "6be20b0974ddb6c74e74650401b72dc2da8bf533", "filename": "compiler/rustc_borrowck/src/borrow_set.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "acca1a1477f2540d21165f7748d1ee84d482a4e2", "filename": "compiler/rustc_borrowck/src/borrowck_errors.rs", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "743d117e00f2ba19a0515d7c957db4ab4809b3b1", "filename": "compiler/rustc_borrowck/src/constraint_generation.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "8b7d9ec2cd671cf659ddfddf303802c26d68ceb0", "filename": "compiler/rustc_borrowck/src/constraints/graph.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "315886bbe29ba53f302159f7f1c3268c660d916f", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "d257145373f72e9a562c4f7802771b966387c2d0", "filename": "compiler/rustc_borrowck/src/consumers.rs", "status": "modified", "additions": 94, "deletions": 18, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "5f837816ba76db6e133b1237740a4da35d1563f5", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 95, "deletions": 92, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "b719a610e07c78f41e289dcc1bc435e871ce51c4", "filename": "compiler/rustc_borrowck/src/def_use.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "cfcf31fce32bd128ad320aa6b8e96cc07c15f169", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 89, "deletions": 125, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "15d73ed732f502b7db33c80d4c3f024c858c59ac", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 947, "deletions": 345, "changes": 1292, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "1d430a93a876d2c9588f2c50d7a52e7223977fc2", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 134, "deletions": 218, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "2c4d953f011fc013c8058fc17506cecb12e76832", "filename": "compiler/rustc_borrowck/src/diagnostics/find_all_local_uses.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_all_local_uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_all_local_uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_all_local_uses.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "2495613fea1d2c9e6473f7a299c9199c6630f0cf", "filename": "compiler/rustc_borrowck/src/diagnostics/find_use.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "20370e4c6ac3cc17ff84876ab31bfeda4f5d9c4c", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 369, "deletions": 273, "changes": 642, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "8b77477a31a337bc0c6310531055ae5d0bbe8cd8", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 131, "deletions": 73, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "34d466db2b4090dc4868ad797a6e5f53d7e027cd", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 565, "deletions": 341, "changes": 906, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "b6eb9ae980e4e28501d68ad28e8e91994ef76f03", "filename": "compiler/rustc_borrowck/src/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "8ec872e205792b909a67e4bfec76711045c9ce2f", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 323, "deletions": 181, "changes": 504, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "f38e1605fa5caeff69bde95b388e9ece6bd0af1e", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 143, "deletions": 88, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "98418e2372f0e612b6675a7cf199396355b10ce0", "filename": "compiler/rustc_borrowck/src/diagnostics/var_name.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "87fad9a355d3d69dc0d69ca770fcfdbdc3fa899d", "filename": "compiler/rustc_borrowck/src/facts.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "b2ff25ecb96f4e47e1efeccaa0610a21d8d6320f", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 59, "deletions": 58, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "99a988f2c629edabc9ed246f473fb6296ee8d770", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 295, "deletions": 244, "changes": 539, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "0e669abfd14aa5b9da32ff8fbe5ac01ce631a894", "filename": "compiler/rustc_borrowck/src/location.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "842e90080582f5b7f40bf4059e0c5634a12c2a7e", "filename": "compiler/rustc_borrowck/src/member_constraints.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "b5014a3f479c70a1dec9f6612cfb892b031da263", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 68, "deletions": 76, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "ea9f8683ca7bbb24e50c5916a913c0335890b5f9", "filename": "compiler/rustc_borrowck/src/path_utils.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fpath_utils.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "d521d0db21323df8526d25c5309cf5302f122dc3", "filename": "compiler/rustc_borrowck/src/place_ext.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "25c485b814f4a1ae1220bce79757c8d2e5dab821", "filename": "compiler/rustc_borrowck/src/places_conflict.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "6f281349863763f0cbb578f0a93102ef6ec19b81", "filename": "compiler/rustc_borrowck/src/prefixes.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "6524b594e44dc02083d629688966c151ae0965c5", "filename": "compiler/rustc_borrowck/src/region_infer/dump_mir.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "2e15586e03b3bb49ec35331d11cdeaa9d9026b25", "filename": "compiler/rustc_borrowck/src/region_infer/graphviz.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fgraphviz.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "2a0cb49672b8359299a00cffeba0eacd9ee501c7", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 337, "deletions": 411, "changes": 748, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "a561496b02639ae3d2d529bd768fbbacf2271e06", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 155, "deletions": 388, "changes": 543, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "fe56bd54a3f17450209691fef5c5b28f81115832", "filename": "compiler/rustc_borrowck/src/region_infer/reverse_sccs.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "9290e7479144ade256caeb11b57b91bca5b8ca1b", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "4389d2b60bc5573ffbc62ae92527d575e805747f", "filename": "compiler/rustc_borrowck/src/renumber.rs", "status": "modified", "additions": 72, "deletions": 30, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "fceae5bb3ffe030eccd9806c4b0b2909a767da4e", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "modified", "additions": 423, "deletions": 13, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "f527eee7bda054f217087d039864942e803139f8", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 99, "deletions": 47, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "71eae7b27d1db7835d8e4625781d9b6f3f9013ac", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 106, "deletions": 42, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "c8ec1257d376ef4faf78995507244cd60b111f14", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 116, "deletions": 142, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "a06d4bcc6c7aeb2c45b1a424300f7915972093ef", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 47, "deletions": 121, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "a9ca94567878a598e79bbb481aaa2dafef2494b0", "filename": "compiler/rustc_borrowck/src/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "f1ad0ca55ccfd45b0a9dc8bdc11345dcbb286984", "filename": "compiler/rustc_borrowck/src/type_check/liveness/mod.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fmod.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "b344ab46adbde37ba6f064beb3dc68bf2e8bfa83", "filename": "compiler/rustc_borrowck/src/type_check/liveness/polonius.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fpolonius.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fpolonius.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fpolonius.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "eb02604b9d925e4b4a076da6eac89ad8a3c623ff", "filename": "compiler/rustc_borrowck/src/type_check/liveness/trace.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "00fd3762fa773d19dbdf11607aaa1c2fb6082123", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 554, "deletions": 482, "changes": 1036, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "8c4bfb2c6e0d30721edb6459c35c95292bcb6cb8", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 82, "deletions": 52, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "c871703429a5e83dfb4721265c862b66d921e87c", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 236, "deletions": 141, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "c5991e0bc254e302714cdedee048b3f641f508e8", "filename": "compiler/rustc_borrowck/src/used_muts.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "8d92bb359385780cdccebde4885f6c141640dc9b", "filename": "compiler/rustc_borrowck/src/util/collect_writes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Futil%2Fcollect_writes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Futil%2Fcollect_writes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Futil%2Fcollect_writes.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11", "previous_filename": "compiler/rustc_const_eval/src/util/collect_writes.rs"}, {"sha": "7377d4de7274f93d180207ee6301feb519f6f12e", "filename": "compiler/rustc_borrowck/src/util/mod.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_borrowck%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Futil%2Fmod.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "44012e802aa7bb472e8a864e756e2dd70621daaf", "filename": "compiler/rustc_builtin_macros/Cargo.toml", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2FCargo.toml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "f00cd39cbc82a3613b42078e8a4b9fd1ce02cc98", "filename": "compiler/rustc_builtin_macros/messages.ftl", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fmessages.ftl?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "82bae9157e79d173e760a685968bafa4fa090a72", "filename": "compiler/rustc_builtin_macros/src/alloc_error_handler.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "5217e317adfee7898ca63c950b80dccc86aaaff8", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 68, "deletions": 144, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "ab4ea9c8c20525ff7c3a989a63bcc4520c7c689f", "filename": "compiler/rustc_builtin_macros/src/assert.rs", "status": "modified", "additions": 15, "deletions": 31, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "b619e80e15f3c36041d1645c9274ae86b209b8ec", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 71, "deletions": 67, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "1397cee7af83b93b43ca8216010f92a423a05855", "filename": "compiler/rustc_builtin_macros/src/cfg.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "37ac09ccdff4d4bf20843245a014562415e61944", "filename": "compiler/rustc_builtin_macros/src/cfg_accessible.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "49401e9ca94960669b17ba704360074b6009ed72", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 50, "deletions": 33, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "2b6fcc169be067ee2a92555de44aaae52bf654bf", "filename": "compiler/rustc_builtin_macros/src/cmdline_attrs.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "5efc5a4e3eea334ed31e12916fae1473de5993c9", "filename": "compiler/rustc_builtin_macros/src/compile_error.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fcompile_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fcompile_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcompile_error.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "50e88ae2eeeded88a87001354979231f75cc6792", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 37, "deletions": 18, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "5ef35af0a059ad4cd12a7b6e71cde3dcc2bfea6f", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 80, "deletions": 79, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "ee56d45c9c826eb85c79865d34ba3710ece3685f", "filename": "compiler/rustc_builtin_macros/src/concat_idents.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_idents.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "fe4483104eeb3d09dd0185c4f2be73b3ac879cec", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 46, "deletions": 56, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "2c8e6f99c6739a1787ecc43d6527b7c215852fff", "filename": "compiler/rustc_builtin_macros/src/deriving/bounds.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "9ba98d0a5d187a9d4a35b0ea49b6d35c28cfa1c9", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "c78a0eb04a074c2d73b66d351ed0640c1406dba4", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "4401cf8a9c5650f0768792a3a4167224cbd9701b", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "a71ecc5db7d97def9041cb8d59622d4b6c5589ff", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 47, "deletions": 49, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "54b6cb7d71301f97c16370fcf880d2176bf1e5c5", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 81, "deletions": 18, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "809f9838d20becd0965c226095302737ce40d2b2", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 97, "deletions": 37, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "3921533c84a19562343aed2b4e70e3f07052c56b", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "07b172bc757b2ae7f26e6c026431caaa9c97da89", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 82, "deletions": 102, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "a3b11309d0ce1a7eaae6ada7378ed84e559ff4ca", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "4ba09335cb7abfe961631ad5234889ca6a475ef7", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 300, "deletions": 281, "changes": 581, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "26f91b714b46836d1c577dddc91af4463bc8170f", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/ty.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "101401f9c85b7929c9582086fc8e5b62e515f74b", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "d34336e7679c03bf3a0cd3a1542fcfdd6054997f", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 43, "deletions": 27, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "ef0db23ff2f2d8cb15e4e3954bed4d27c27bd0e5", "filename": "compiler/rustc_builtin_macros/src/edition_panic.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "8f64e3328619e054b0c24c2ee3966b9c6b12f43b", "filename": "compiler/rustc_builtin_macros/src/env.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "f1ab279dababf5daf87d3eaac0fc8359cb86a0af", "filename": "compiler/rustc_builtin_macros/src/errors.rs", "status": "added", "additions": 734, "deletions": 0, "changes": 734, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "4c878785b7b45bc35b5dd0798f580d2529b05f1a", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 681, "deletions": 1176, "changes": 1857, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "bd5356575ca872d759289b5e5db5a11d392b21a1", "filename": "compiler/rustc_builtin_macros/src/format_foreign.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "df773910dbc8fd7313f2ada1d89495c4646d9366", "filename": "compiler/rustc_builtin_macros/src/format_foreign/printf/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fprintf%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fprintf%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fprintf%2Ftests.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "93a7afcd6e8b620fff102430c03c455ae8d5b490", "filename": "compiler/rustc_builtin_macros/src/format_foreign/shell/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fshell%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fshell%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fshell%2Ftests.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "f0d378d12f71245de599e0eef72767b08b210170", "filename": "compiler/rustc_builtin_macros/src/global_allocator.rs", "status": "modified", "additions": 27, "deletions": 34, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "ebf1448f55c9985818089ee8dd9e71a31d7781dd", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "52b5601bb11b8c8aee6178637d07a809ec336c2c", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "e613b904d2eaf66439115ddb07f72b9cb93a29b4", "filename": "compiler/rustc_builtin_macros/src/source_util.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "6493c6f13d54138ff2dc51830fdd210d4267eacd", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "49ee276af4e6f2b13af83b7664d5370d4d185784", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 209, "deletions": 141, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "9bc1e27b4ec74032c514114f09b375f6eb571f14", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 51, "deletions": 41, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "9c98723e1f43f96ccedc581d6603987c760cc938", "filename": "compiler/rustc_builtin_macros/src/trace_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftrace_macros.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "72b85af1486384f61f5c2651ac40d054002020d1", "filename": "compiler/rustc_builtin_macros/src/type_ascribe.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Ftype_ascribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Ftype_ascribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftype_ascribe.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "9463a1418ce31bc5242c3288155c51a2d8a482c7", "filename": "compiler/rustc_builtin_macros/src/util.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "7886cae42a15ab1902d7d79ce677e8c4dd0be075", "filename": "compiler/rustc_codegen_cranelift/.cirrus.yml", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "c70ba8f495387012782acf740be67aa5d14eadf8", "filename": "compiler/rustc_codegen_cranelift/.github/actions/github-release/README.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2FREADME.md?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "36e5209f50c3b8aa0cb441bfd159673f5c32e4f1", "filename": "compiler/rustc_codegen_cranelift/.github/actions/github-release/action.yml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Faction.yml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Faction.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Faction.yml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "6fcfca34ea7766ab8096465f89010bb4fec8584f", "filename": "compiler/rustc_codegen_cranelift/.github/actions/github-release/main.js", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Fmain.js?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "dd3b2a048f09455080245ec1d29240830f378edb", "filename": "compiler/rustc_codegen_cranelift/.github/actions/github-release/package-lock.json", "status": "added", "additions": 571, "deletions": 0, "changes": 571, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Fpackage-lock.json", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Fpackage-lock.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Fpackage-lock.json?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "d9c23f8873ece8afe2ef7a7703e1fa13306f16b2", "filename": "compiler/rustc_codegen_cranelift/.github/actions/github-release/package.json", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Fpackage.json?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "3c40555669cb38e8d19984fdbce0344ea9dc060c", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/abi-cafe.yml", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fabi-cafe.yml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fabi-cafe.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fabi-cafe.yml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "e4af73ea6442e5bcd3a6c9439d6a3565a09d5178", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 164, "deletions": 88, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "0a3e7ca073b45debb68785811cf0f727a7e0bde7", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/nightly-cranelift.yml", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fnightly-cranelift.yml", "raw_url": "https://github.com/rust-lang/rust/raw/24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fnightly-cranelift.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fnightly-cranelift.yml?ref=24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3"}, {"sha": "b2f772c4fc4441f4c96606db8840c01271897b1c", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/rustc.yml", "status": "modified", "additions": 11, "deletions": 49, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "e5d10a937ae2497a7deb53af1554123c846cce8e", "filename": "compiler/rustc_codegen_cranelift/.gitignore", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.gitignore?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "7c8703cba505c6e221910aabcef2a5ea4f712a41", "filename": "compiler/rustc_codegen_cranelift/.vscode/settings.json", "status": "modified", "additions": 9, "deletions": 37, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "07a8e431a0e31ab93966eb700f0fb64c81b17d64", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 206, "deletions": 62, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "a2890f6ddf9d462375f8236559918868f02d18f4", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "26dccf309e1e402ff3e8700850bc1a2e81ad43d0", "filename": "compiler/rustc_codegen_cranelift/Readme.md", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FReadme.md?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "7ddf91ad01faa83ea1902f1cd88122b010b1748c", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 29, "deletions": 38, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "8219e6b6ccf3bca19d613a2b7331639a30a8d7e1", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "0da27f529b3ecd730a2f7a0cdfe16c55b04909b1", "filename": "compiler/rustc_codegen_cranelift/build_system/abi_cafe.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "a9a851d0a8afc882e0c24cc7f60c8259c0905fbf", "filename": "compiler/rustc_codegen_cranelift/build_system/bench.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbench.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "4b740fa2db65f32947b1f86663193b22074ac585", "filename": "compiler/rustc_codegen_cranelift/build_system/build_backend.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "76b602fe7196326f9949430b549669862e9a0766", "filename": "compiler/rustc_codegen_cranelift/build_system/build_sysroot.rs", "status": "modified", "additions": 224, "deletions": 144, "changes": 368, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "c31784e1097dc25f1b43a8a4dc1f59a4666c192f", "filename": "compiler/rustc_codegen_cranelift/build_system/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fconfig.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "e4ed9be23b70528ee83174f4ad5059fa83fe88bd", "filename": "compiler/rustc_codegen_cranelift/build_system/mod.rs", "status": "modified", "additions": 119, "deletions": 54, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "3290723005dd92b939486489e4acda090b0a8ac0", "filename": "compiler/rustc_codegen_cranelift/build_system/path.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fpath.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "6769e42d44b94181f427210c803616f2e2b8f31e", "filename": "compiler/rustc_codegen_cranelift/build_system/prepare.rs", "status": "modified", "additions": 154, "deletions": 97, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "a70453b4422898e31f0030f1613cf7877260e481", "filename": "compiler/rustc_codegen_cranelift/build_system/rustc_info.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "0c25b4aadfa087bd4f826e3d3ba60f5ed9b8f936", "filename": "compiler/rustc_codegen_cranelift/build_system/tests.rs", "status": "added", "additions": 416, "deletions": 0, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "ab98ccc35a58a595e0e0bc3ffc7621194ae7e27d", "filename": "compiler/rustc_codegen_cranelift/build_system/usage.txt", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fusage.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fusage.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fusage.txt?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "abc5bab49422468454948ea77f79891c6c5f873c", "filename": "compiler/rustc_codegen_cranelift/build_system/utils.rs", "status": "modified", "additions": 254, "deletions": 2, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "cdfc2e143e6748247d056e11488b5adae5ea21f7", "filename": "compiler/rustc_codegen_cranelift/clean_all.sh", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "d6e3924a24d643f7550553874b7eb4d47495f577", "filename": "compiler/rustc_codegen_cranelift/config.txt", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fconfig.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fconfig.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fconfig.txt?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "4c2b0fa170498812b976b67041cc62ab73ff3f81", "filename": "compiler/rustc_codegen_cranelift/docs/usage.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fusage.md", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fusage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fusage.md?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "d994e2fbc0ae0be69e0c06676cf630506030d69c", "filename": "compiler/rustc_codegen_cranelift/example/alloc_example.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "e64daf96b01c92f26dac3a49d21adc43dc6d8975", "filename": "compiler/rustc_codegen_cranelift/example/alloc_system.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "f7edfa960a229407174223b8aa70ad84c7282b13", "filename": "compiler/rustc_codegen_cranelift/example/arbitrary_self_types_pointers_and_wrappers.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "22fc6ff33e33f0ffb2069c8e21b15769fb284815", "filename": "compiler/rustc_codegen_cranelift/example/dst-field-align.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Fdst-field-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Fdst-field-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fdst-field-align.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "885e55bc764232e17087b5864de9d18d8563562b", "filename": "compiler/rustc_codegen_cranelift/example/example.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Fexample.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Fexample.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fexample.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "166b006004385b225d8488fb08affc72299d2c55", "filename": "compiler/rustc_codegen_cranelift/example/issue-72793.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-72793.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-72793.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-72793.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "6f39c5edcad209057161c09c5b606f4b395ff1e8", "filename": "compiler/rustc_codegen_cranelift/example/issue-91827-extern-types.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-91827-extern-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-91827-extern-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-91827-extern-types.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "ea97e9f060e04a903e6c843f4b38df3f6e71a59d", "filename": "compiler/rustc_codegen_cranelift/example/mini_core.rs", "status": "modified", "additions": 71, "deletions": 21, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "5a55aa215bfd7316fa3710487f87dbb8c19687a6", "filename": "compiler/rustc_codegen_cranelift/example/mini_core_hello_world.rs", "status": "modified", "additions": 430, "deletions": 84, "changes": 514, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "f15e48acc41e52cd5809dd25b9f28f22e5158755", "filename": "compiler/rustc_codegen_cranelift/example/mod_bench.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmod_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmod_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmod_bench.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "ab4045d11a6636d007bbfaf7469bd7bedeaf96df", "filename": "compiler/rustc_codegen_cranelift/example/std_example.rs", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "3c87891666399297f2c16719b5c9f68aa58d4b10", "filename": "compiler/rustc_codegen_cranelift/example/subslice-patterns-const-eval.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Fsubslice-patterns-const-eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fexample%2Fsubslice-patterns-const-eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fsubslice-patterns-const-eval.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "0e5e7cdfcdf1a44028d6ada6cc17c59ee28d96f2", "filename": "compiler/rustc_codegen_cranelift/patches/0001-abi-cafe-Disable-some-test-on-x86_64-pc-windows-gnu.patch", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-cafe-Disable-some-test-on-x86_64-pc-windows-gnu.patch", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-cafe-Disable-some-test-on-x86_64-pc-windows-gnu.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-cafe-Disable-some-test-on-x86_64-pc-windows-gnu.patch?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "54e13b090abda43a8d66147207b16c09c27dae64", "filename": "compiler/rustc_codegen_cranelift/patches/0001-portable-simd-Disable-unsupported-tests.patch", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-portable-simd-Disable-unsupported-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-portable-simd-Disable-unsupported-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-portable-simd-Disable-unsupported-tests.patch?ref=24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3"}, {"sha": "eb452c5cd377268b031cee0a3890c3b625333ef5", "filename": "compiler/rustc_codegen_cranelift/patches/0003-rand-Disable-rand-tests-on-mingw.patch", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0003-rand-Disable-rand-tests-on-mingw.patch", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0003-rand-Disable-rand-tests-on-mingw.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0003-rand-Disable-rand-tests-on-mingw.patch?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "6afa5c71fe51fa8cb16c78ff116d07292e35acef", "filename": "compiler/rustc_codegen_cranelift/patches/0022-coretests-Disable-not-compiling-tests.patch", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-coretests-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-coretests-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-coretests-Disable-not-compiling-tests.patch?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "8d9ee3f25c49db03b35c65208fe8fc6740c63b63", "filename": "compiler/rustc_codegen_cranelift/patches/0022-sysroot-Disable-not-compiling-tests.patch", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-sysroot-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-sysroot-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-sysroot-Disable-not-compiling-tests.patch?ref=24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3"}, {"sha": "f2cb82751f0821ff857fe2ae0f229d5aca450501", "filename": "compiler/rustc_codegen_cranelift/patches/0023-coretests-Ignore-failing-tests.patch", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-coretests-Ignore-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-coretests-Ignore-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-coretests-Ignore-failing-tests.patch?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "50ef0bd9418c74f8a760ca8b80629edc223be08c", "filename": "compiler/rustc_codegen_cranelift/patches/0023-sysroot-Ignore-failing-tests.patch", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-sysroot-Ignore-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-sysroot-Ignore-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-sysroot-Ignore-failing-tests.patch?ref=24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3"}, {"sha": "1d5479beddee915871f801c0892a4c2c25baf73d", "filename": "compiler/rustc_codegen_cranelift/patches/0027-coretests-128bit-atomic-operations.patch", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-coretests-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-coretests-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-coretests-128bit-atomic-operations.patch?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "45f73f36b93171ddd2b32b2571666fd25674ced6", "filename": "compiler/rustc_codegen_cranelift/patches/0027-stdlib-128bit-atomic-operations.patch", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-stdlib-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-stdlib-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-stdlib-128bit-atomic-operations.patch?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "77f437974c2d66527e965c27a36cf0f3aff62546", "filename": "compiler/rustc_codegen_cranelift/patches/0027-sysroot-128bit-atomic-operations.patch", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-sysroot-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-sysroot-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-sysroot-128bit-atomic-operations.patch?ref=24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3"}, {"sha": "440177018f428e66a124963332c13a9f328e3c9c", "filename": "compiler/rustc_codegen_cranelift/patches/0028-coretests-Disable-long-running-tests.patch", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0028-coretests-Disable-long-running-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0028-coretests-Disable-long-running-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0028-coretests-Disable-long-running-tests.patch?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "d804a78cc1061f3204d2e224ebf0212753eaf0e3", "filename": "compiler/rustc_codegen_cranelift/patches/0028-sysroot-Disable-long-running-tests.patch", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0028-sysroot-Disable-long-running-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0028-sysroot-Disable-long-running-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0028-sysroot-Disable-long-running-tests.patch?ref=24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3"}, {"sha": "59ad80c3207dca8924e694191208423c1eee2c49", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "ebeca8662a5195c6408e8707a06248c189ffab99", "filename": "compiler/rustc_codegen_cranelift/rustfmt.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Frustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Frustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frustfmt.toml?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "e2db7d03a9d386c80f16dfbc9e5b3a3b765678d8", "filename": "compiler/rustc_codegen_cranelift/scripts/cargo-clif.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo-clif.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "f782671fe36f9b45fab05a5c6f335d9880211c23", "filename": "compiler/rustc_codegen_cranelift/scripts/filter_profile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ffilter_profile.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "ab496a4a6844eb5ef703443acc450ccf41515999", "filename": "compiler/rustc_codegen_cranelift/scripts/rustc-clif.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustc-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustc-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustc-clif.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "545844446c508cd32216f435e2cda732767a3e80", "filename": "compiler/rustc_codegen_cranelift/scripts/rustdoc-clif.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "3cbeb6375de109011fb29e3847f40173b188cae2", "filename": "compiler/rustc_codegen_cranelift/scripts/rustup.sh", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "abb09775d213511041756911473c75632643ef2a", "filename": "compiler/rustc_codegen_cranelift/scripts/setup_rust_fork.sh", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "1329d3ea076b480d8d0c45f892c4f1f116aff553", "filename": "compiler/rustc_codegen_cranelift/scripts/test_rustc_tests.sh", "status": "modified", "additions": 124, "deletions": 57, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "9b5ffa4096049c04b9b2b509e9ec80107a7e1a92", "filename": "compiler/rustc_codegen_cranelift/scripts/tests.sh", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh?ref=24df5f28e12c6ca4c1c6ef36f6d42f376c6060c3"}, {"sha": "364503fd3639a159b5e18d918594fc4b10fda3af", "filename": "compiler/rustc_codegen_cranelift/src/abi/comments.rs", "status": "modified", "additions": 2, "deletions": 32, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "84e09cf0abe4fe54d1f82263d110a1f8c0c733b5", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 199, "deletions": 94, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "d847e524f8cfa7740488cf3b847ccfadf1309da8", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 28, "deletions": 35, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "14e54d5ee3814f97acb5ed7391d7992b4a70af55", "filename": "compiler/rustc_codegen_cranelift/src/abi/returning.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "d4b1ae2b61383e655bf1cc832f853769187711e2", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 63, "deletions": 106, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "359d581c1535ab07bc3024050a1151153c33af68", "filename": "compiler/rustc_codegen_cranelift/src/analyze.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "5a29bc18def549cd035bb0a1144b5cab54addef4", "filename": "compiler/rustc_codegen_cranelift/src/archive.rs", "status": "modified", "additions": 14, "deletions": 204, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "fcfa0b862d4b5a8755a13374945a7e57766af4af", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 292, "deletions": 246, "changes": 538, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "6bf3a866ba46ac37e33a57ae5d42d3b2bd4124ee", "filename": "compiler/rustc_codegen_cranelift/src/cast.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "f751d8c179db59c3e60e84a053bc05dc584ad659", "filename": "compiler/rustc_codegen_cranelift/src/codegen_i128.rs", "status": "modified", "additions": 91, "deletions": 105, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "7243cf6da232e3afe06fe45ae47fded5766c79a9", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 106, "deletions": 43, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "f3b963200a0fb022f34bc48a2307b9c114830ace", "filename": "compiler/rustc_codegen_cranelift/src/compiler_builtins.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "d2b928db7d4df774ee35df3f8d07832abd520e9f", "filename": "compiler/rustc_codegen_cranelift/src/concurrency_limiter.rs", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "263401e1c4b8343f76a2ad52e8fc90097a58a1c7", "filename": "compiler/rustc_codegen_cranelift/src/config.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconfig.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "77af561a58724c1fda56b2a1b1e1767412a453d1", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 174, "deletions": 157, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "c4a5627e662f1d06907855640591c6cb985153c2", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/emit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}, {"sha": "463de6a91c74c62f620eaa69c715133b8707f3ad", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/line_info.rs", "status": "modified", "additions": 93, "deletions": 120, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb5c011670ce8d073d0aae8c45e73c20593bfa11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs?ref=cb5c011670ce8d073d0aae8c45e73c20593bfa11"}]}