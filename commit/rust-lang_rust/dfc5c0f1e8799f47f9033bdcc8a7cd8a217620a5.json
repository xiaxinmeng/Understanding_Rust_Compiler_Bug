{"sha": "dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmYzVjMGYxZTg3OTlmNDdmOTAzM2JkY2M4YTdjZDhhMjE3NjIwYTU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-02-18T12:50:21Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-02-18T12:50:21Z"}, "message": " Manual merge of #22475 - alexcrichton:rollup, r=alexcrichton\n\n One windows bot failed spuriously.", "tree": {"sha": "e9c32f2e58b3462a23dd9c472d2f236640b78811", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9c32f2e58b3462a23dd9c472d2f236640b78811"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "html_url": "https://github.com/rust-lang/rust/commit/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c065fc8cb036785f61ff03e05c1563cbb2dd081", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c065fc8cb036785f61ff03e05c1563cbb2dd081", "html_url": "https://github.com/rust-lang/rust/commit/6c065fc8cb036785f61ff03e05c1563cbb2dd081"}, {"sha": "47f91a9484eceef10536d4caac6ef578cd254567", "url": "https://api.github.com/repos/rust-lang/rust/commits/47f91a9484eceef10536d4caac6ef578cd254567", "html_url": "https://github.com/rust-lang/rust/commit/47f91a9484eceef10536d4caac6ef578cd254567"}], "stats": {"total": 10084, "additions": 6860, "deletions": 3224}, "files": [{"sha": "a4656dd415bbd3ec0972c1daad931a0945bba38c", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 139, "deletions": 43, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -1,60 +1,156 @@\n-## How to submit a bug report\n+# Contributing to Rust\n \n-If you're just reporting a bug, please see:\n+Thank you for your interest in contributing to Rust! There are many ways to\n+contribute, and we appreciate all of them. This document is a bit long, so here's\n+links to the major sections:\n \n-http://doc.rust-lang.org/complement-bugreport.html\n+* [Feature Requests](#feature-requests)\n+* [Bug Reports](#bug-reports)\n+* [Pull Requests](#pull-requests)\n+* [Writing Documentation](#writing-documentation)\n+* [Issue Triage](#issue-triage)\n+* [Out-of-tree Contributions](#out-of-tree-contributions)\n \n-## Submitting an issue\n+If you have questions, please make a post on [internals.rust-lang.org][internals] or\n+hop on [#rust-internals][pound-rust-internals].\n \n-Please submit issues here for bug reports or implementation details. For feature\n-requests, language changes, or major changes to the libraries, please submit an\n-issue against the [RFCs repository](https://github.com/rust-lang/rfcs).\n+As a reminder, all contributors are expected to follow our [Code of Conduct](coc).\n \n-## Pull request procedure\n+[pound-rust-internals]: http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust-internals\n+[internals]: http://internals.rust-lang.org\n+[coc]: http://www.rust-lang.org/conduct.html\n \n-Pull requests should be targeted at Rust's `master` branch.\n-Before pushing to your Github repo and issuing the pull request,\n-please do two things:\n+## Feature Requests\n \n-1. [Rebase](http://git-scm.com/book/en/Git-Branching-Rebasing) your\n-   local changes against the `master` branch. Resolve any conflicts\n-   that arise.\n+To request a change to the way that the Rust language works, please open an\n+issue in the [RFCs repository](https://github.com/rust-lang/rfcs/issues/new)\n+rather than this one. New features and other significant language changes\n+must go through the RFC process.\n \n-2. Run the full Rust test suite with the `make check` command.  You're\n-   not off the hook even if you just stick to documentation; code\n-   examples in the docs are tested as well! Although for simple\n-   wording or grammar fixes, this is probably unnecessary.\n+## Bug Reports\n \n-Pull requests will be treated as \"review requests\", and we will give\n-feedback we expect to see corrected on\n-[style](http://aturon.github.io/) and\n-substance before pulling.  Changes contributed via pull request should\n-focus on a single issue at a time, like any other.  We will not accept\n-pull-requests that try to \"sneak\" unrelated changes in.\n+While bugs are unfortunate, they're a reality in software. We can't fix what we\n+don't know about, so please report liberally. If you're not sure if something\n+is a bug or not, feel free to file a bug anyway.\n \n-Normally, all pull requests must include regression tests (see\n-[Note-testsuite](https://github.com/rust-lang/rust/wiki/Note-testsuite))\n-that test your change.  Occasionally, a change will be very difficult\n-to test for.  In those cases, please include a note in your commit\n-message explaining why.\n+If you have the chance, before reporting a bug, please [search existing\n+issues](https://github.com/rust-lang/rust/search?q=&type=Issues&utf8=%E2%9C%93),\n+as it's possible that someone else has already reported your error. This doesn't\n+always work, and sometimes it's hard to know what to search for, so consider this\n+extra credit. We won't mind if you accidentally file a duplicate report.\n \n-In the licensing header at the beginning of any files you change,\n-please make sure the listed date range includes the current year.  For\n-example, if it's 2014, and you change a Rust file that was created in\n-2010, it should begin:\n+Opening an issue is as easy as following [this\n+link](https://github.com/rust-lang/rust/issues/new) and filling out the fields.\n+Here's a template that you can use to file a bug, though it's not necessary to\n+use it exactly:\n \n-```\n-// Copyright 2010-2014 The Rust Project Developers.\n+    <short summary of the bug>\n+\n+    I tried this code:\n+\n+    <code sample that causes the bug>\n+\n+    I expected to see this happen: <explanation>\n+\n+    Instead, this happened: <explanation>\n+\n+    ## Meta\n+\n+    `rustc --version --verbose`:\n+\n+    Backtrace:\n+\n+All three components are important: what you did, what you expected, what\n+happened instead. Please include the output of `rustc --version --verbose`,\n+which includes important information about what platform you're on, what\n+version of Rust you're using, etc.\n+\n+Sometimes, a backtrace is helpful, and so including that is nice. To get\n+a backtrace, set the `RUST_BACKTRACE` environment variable. The easiest way\n+to do this is to invoke `rustc` like this:\n+\n+```bash\n+$ RUST_BACKTRACE=1 rustc ...\n ```\n \n-# Coordination and communication\n+## Pull Requests\n \n-Get feedback from other developers on\n-[internals.rust-lang.org][internals], and\n-[#rust-internals][pound-rust-internals].\n+Pull requests are the primary mechanism we use to change Rust. GitHub itself\n+has some [great documentation][pull-requests] on using the Pull Request\n+feature. We use the 'fork and pull' model described there.\n \n-[pound-rust-internals]: http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust-internals\n-[internals]: http://internals.rust-lang.org\n+[pull-requests]: https://help.github.com/articles/using-pull-requests/\n+\n+Please make pull requests against the `master` branch.\n+\n+All pull requests are reviewed by another person. We have a bot,\n+@rust-highfive, that will automatically assign a random person to review your request.\n+\n+If you want to request that a specific person reviews your pull request,\n+you can add an `r?` to the message. For example, Steve usually reviews\n+documentation changes. So if you were to make a documentation change, add\n+\n+    r? @steveklabnik\n+\n+to the end of the message, and @rust-highfive will assign @steveklabnik instead\n+of a random person. This is entirely optional.\n+\n+After someone has reviewed your pull request, they will leave an annotation\n+on the pull request with an `r+`. It will look something like this:\n+\n+    @bors: r+ 38fe8d2\n+\n+This tells @bors, our lovable integration bot, that your pull request has\n+been approved. The PR then enters the [merge queue][merge-queue], where @bors\n+will run all the tests on every platform we support. If it all works out,\n+@bors will merge your code into `master` and close the pull request.\n+\n+[merge-queue]: http://buildbot.rust-lang.org/homu/queue/rust\n+\n+## Writing Documentation\n+\n+Documentation improvements are very welcome. The source of `doc.rust-lang.org`\n+is located in `src/doc` in the tree, and standard API documentation is generated\n+from the source code itself.\n+\n+Documentation pull requests function in the same as other pull requests, though\n+you may see a slightly different form of `r+`:\n+\n+    @bors: r+ 38fe8d2 rollup\n+\n+That additional `rollup` tells @bors that this change is eligible for a 'rollup'.\n+To save @bors some work, and to get small changes through more quickly, when\n+@bors attempts to merge a commit that's rollup-eligible, it will also merge\n+the other rollup-eligible patches too, and they'll get tested and merged at\n+the same time.\n+\n+## Issue Triage\n+\n+Sometimes, an issue will stay open, even though the bug has been fixed. And\n+sometimes, the original bug may go stale because something has changed in the\n+meantime.\n+\n+It can be helpful to go through older bug reports and make sure that they are\n+still valid. Load up an older issue, double check that it's still true, and\n+leave a comment letting us know if it is or is not. The [least recently updated sort][lru] is good for finding issues like this.\n+\n+[lru]: https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-asc\n+\n+## Out-of-tree Contributions\n+\n+There are a number of other ways to contribute to Rust that don't deal with\n+this repository.\n+\n+Answer questions in [#rust][pound-rust], or on [users.rust-lang.org][users],\n+or on [StackOverflow][so].\n+\n+Participate in the [RFC process](https://github.com/rust-lang/rfcs).\n+\n+Find a [requested community library][community-library], build it, and publish\n+it to [Crates.io](http://crates.io). Easier said than done, but very, very\n+valuable!\n \n-For more details, please refer to\n-[Note-development-policy](https://github.com/rust-lang/rust/wiki/Note-development-policy).\n+[pound-rust]: http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust\n+[users]: http://users.rust-lang.org/\n+[so]: http://stackoverflow.com/questions/tagged/rust\n+[community-library]: https://github.com/rust-lang/rfcs/labels/A-community-library"}, {"sha": "065c4ed7c7bcba936febf4094080f62ae189118c", "filename": "README.md", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -18,6 +18,7 @@ Read [\"Installing Rust\"][install] from [The Book][trpl].\n     * GNU `make` 3.81 or later\n     * `curl`\n     * `git`\n+\n 2. Download and build Rust:\n \n     You can either download a [tarball] or build directly from the [repo].\n@@ -97,19 +98,21 @@ There is a lot more documentation in the [wiki].\n \n [wiki]: https://github.com/rust-lang/rust/wiki\n \n-## Getting help and getting involved\n+## Getting help\n \n The Rust community congregates in a few places:\n \n * [StackOverflow] - Direct questions about using the language here.\n * [users.rust-lang.org] - General discussion, broader questions.\n-* [internals.rust-lang.org] - For development of the Rust language itself.\n * [/r/rust] - News and general discussion.\n \n [StackOverflow]: http://stackoverflow.com/questions/tagged/rust\n [/r/rust]: http://reddit.com/r/rust\n [users.rust-lang.org]: http://users.rust-lang.org/\n-[internals.rust-lang.org]: http://internals.rust-lang.org/\n+\n+## Contributing\n+\n+To contribute to Rust, please see [CONTRIBUTING.md](CONTRIBUTING.md).\n \n ## License\n "}, {"sha": "743032f676d217d4201246b9cf8d5984ff8608d0", "filename": "mk/docs.mk", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -25,7 +25,7 @@\n # L10N_LANGS are the languages for which the docs have been\n # translated.\n ######################################################################\n-DOCS := index intro tutorial complement-bugreport \\\n+DOCS := index intro tutorial \\\n     complement-lang-faq complement-design-faq complement-project-faq \\\n     rustdoc reference grammar\n \n@@ -73,7 +73,7 @@ RUSTBOOK = $(RPATH_VAR2_T_$(CFG_BUILD)_H_$(CFG_BUILD)) $(RUSTBOOK_EXE)\n \n D := $(S)src/doc\n \n-DOC_TARGETS := trpl\n+DOC_TARGETS := trpl style\n COMPILER_DOC_TARGETS :=\n DOC_L10N_TARGETS :=\n \n@@ -275,3 +275,9 @@ trpl: doc/book/index.html\n doc/book/index.html: $(RUSTBOOK_EXE) $(wildcard $(S)/src/doc/trpl/*.md) | doc/\n \t$(Q)rm -rf doc/book\n \t$(Q)$(RUSTBOOK) build $(S)src/doc/trpl doc/book\n+\n+style: doc/style/index.html\n+\n+doc/style/index.html: $(RUSTBOOK_EXE) $(wildcard $(S)/src/doc/style/*.md) | doc/\n+\t$(Q)rm -rf doc/style\n+\t$(Q)$(RUSTBOOK) build $(S)src/doc/style doc/style"}, {"sha": "86710d50d8a065b0b9e6b9bc212ab862e7c13399", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -13,8 +13,8 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(int_uint)]\n-#![feature(io)]\n-#![feature(path)]\n+#![feature(old_io)]\n+#![feature(old_path)]\n #![feature(rustc_private)]\n #![feature(unboxed_closures)]\n #![feature(std_misc)]"}, {"sha": "658c0cb3f4e83955019aa990658884961afcfdb8", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -35,7 +35,7 @@ use std::env;\n use std::iter::repeat;\n use std::str;\n use std::string::String;\n-use std::thread::Thread;\n+use std::thread;\n use std::time::Duration;\n use test::MetricMap;\n \n@@ -458,7 +458,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             loop {\n                 //waiting 1 second for gdbserver start\n                 timer::sleep(Duration::milliseconds(1000));\n-                let result = Thread::scoped(move || {\n+                let result = thread::spawn(move || {\n                     tcp::TcpStream::connect(\"127.0.0.1:5039\").unwrap();\n                 }).join();\n                 if result.is_err() {"}, {"sha": "1a28cd682e70c626c3dba7feda3ff4b33acdf8f9", "filename": "src/doc/complement-bugreport.md", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6c065fc8cb036785f61ff03e05c1563cbb2dd081/src%2Fdoc%2Fcomplement-bugreport.md", "raw_url": "https://github.com/rust-lang/rust/raw/6c065fc8cb036785f61ff03e05c1563cbb2dd081/src%2Fdoc%2Fcomplement-bugreport.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-bugreport.md?ref=6c065fc8cb036785f61ff03e05c1563cbb2dd081", "patch": "@@ -1,61 +0,0 @@\n-% How to submit a Rust bug report\n-\n-# I think I found a bug in the compiler!\n-\n-If you see this message: `error: internal compiler error: unexpected panic`,\n-then you have definitely found a bug in the compiler. It's also possible that\n-your code is not well-typed, but if you saw this message, it's still a bug in\n-error reporting.\n-\n-If you see a message about an LLVM assertion failure, then you have also\n-definitely found a bug in the compiler. In both of these cases, it's not your\n-fault and you should report a bug!\n-\n-If you see a compiler error message that you think is meant for users to see,\n-but it confuses you, *that's a bug too*. If it wasn't clear to you, then it's\n-an error message we want to improve, so please report it so that we can try\n-to make it better.\n-\n-# How do I know the bug I found isn't a bug that already exists in the issue tracker?\n-\n-If you don't have enough time for a search, then don't worry about that. Just submit\n-the bug. If it's a duplicate, somebody will notice that and close it during triage.\n-\n-If you have the time for it, it would be useful to type the text of the error\n-message you got [into the issue tracker search box](https://github.com/rust-lang/rust/issues)\n-to see if there's an existing bug that resembles your problem. If there is,\n-and it's an open bug, you can comment on that issue and say you are also affected.\n-This will encourage the devs to fix it. But again, don't let this stop you from\n-submitting a bug. We'd rather have to do the work of closing duplicates than\n-miss out on valid bug reports.\n-\n-# What information should I include in a bug report?\n-\n-It generally helps our diagnosis to include your specific OS (for example: Mac OS X 10.8.3,\n-Windows 7, Ubuntu 12.04) and your hardware architecture (for example: i686, x86_64).\n-It's also helpful to provide the exact version and host by copying the output of\n-re-running the erroneous rustc command with the `--version --verbose` flags, which will\n-produce something like this:\n-\n-```text\n-rustc 0.12.0 (ba4081a5a 2014-10-07 13:44:41 -0700)\n-binary: rustc\n-commit-hash: ba4081a5a8573875fed17545846f6f6902c8ba8d\n-commit-date: 2014-10-07 13:44:41 -0700\n-host: i686-apple-darwin\n-release: 0.12.0\n-```\n-\n-Finally, if you can also provide a backtrace, that'd be great. You can get a\n-backtrace by setting the `RUST_BACKTRACE` environment variable to `1`, like\n-this: \n-\n-```bash\n-$ RUST_BACKTRACE=1 rustc ...\n-```\n-\n-# I submitted a bug, but nobody has commented on it!\n-\n-This is sad, but does happen sometimes, since we're short-staffed. If you submit a\n-bug and you haven't received a comment on it within 3 business days, it's entirely\n-reasonable to ask about the status of the bug in #rust on irc.mozilla.org."}, {"sha": "00ed5d4562b11e248da5d959486910e08ec4dcad", "filename": "src/doc/reference.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -2398,6 +2398,10 @@ The currently implemented features of the reference compiler are:\n                     ways insufficient for concatenating identifiers, and may be\n                     removed entirely for something more wholesome.\n \n+* `custom_attribute` - Allows the usage of attributes unknown to the compiler\n+                       so that new attributes can be added in a bacwards compatible\n+                       manner (RFC 572).\n+\n * `intrinsics` - Allows use of the \"rust-intrinsics\" ABI. Compiler intrinsics\n                  are inherently unstable and no promise about them is made.\n \n@@ -2458,6 +2462,9 @@ The currently implemented features of the reference compiler are:\n             implemented very poorly and will likely change significantly\n             with a proper implementation.\n \n+* `rustc_attrs` - Gates internal `#[rustc_*]` attributes which may be\n+                  for internal use only or have meaning added to them in the future.\n+\n * `rustc_diagnostic_macros`- A mysterious feature, used in the implementation\n                              of rustc, not meant for mortals.\n "}, {"sha": "9b328b5d393c59f0183bd36cc4587f0e28907cf5", "filename": "src/doc/style/README.md", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2FREADME.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,64 @@\n+% Style Guidelines\n+\n+This document collects the emerging principles, conventions, abstractions, and\n+best practices for writing Rust code.\n+\n+Since Rust is evolving at a rapid pace, these guidelines are\n+preliminary. The hope is that writing them down explicitly will help\n+drive discussion, consensus and adoption.\n+\n+Whenever feasible, guidelines provide specific examples from Rust's standard\n+libraries.\n+\n+### Guideline statuses\n+\n+Every guideline has a status:\n+\n+* **[FIXME]**: Marks places where there is more work to be done. In\n+  some cases, that just means going through the RFC process.\n+\n+* **[FIXME #NNNNN]**: Like **[FIXME]**, but links to the issue tracker.\n+\n+* **[RFC #NNNN]**: Marks accepted guidelines, linking to the rust-lang\n+  RFC establishing them.\n+\n+### Guideline stabilization\n+\n+One purpose of these guidelines is to reach decisions on a number of\n+cross-cutting API and stylistic choices. Discussion and development of\n+the guidelines will happen primarily on http://discuss.rust-lang.org/,\n+using the Guidelines category. Discussion can also occur on the\n+[guidelines issue tracker](https://github.com/rust-lang/rust-guidelines).\n+\n+Guidelines that are under development or discussion will be marked with the\n+status **[FIXME]**, with a link to the issue tracker when appropriate.\n+\n+Once a concrete guideline is ready to be proposed, it should be filed\n+as an [FIXME: needs RFC](https://github.com/rust-lang/rfcs). If the RFC is\n+accepted, the official guidelines will be updated to match, and will\n+include the tag **[RFC #NNNN]** linking to the RFC document.\n+\n+### What's in this document\n+\n+This document is broken into four parts:\n+\n+* **[Style](style/README.md)** provides a set of rules governing naming conventions,\n+  whitespace, and other stylistic issues.\n+\n+* **[Guidelines by Rust feature](features/README.md)** places the focus on each of\n+  Rust's features, starting from expressions and working the way out toward\n+  crates, dispensing guidelines relevant to each.\n+\n+* **Topical guidelines and patterns**. The rest of the document proceeds by\n+  cross-cutting topic, starting with\n+  [Ownership and resources](ownership/README.md).\n+\n+* **[APIs for a changing Rust](changing/README.md)**\n+  discusses the forward-compatibility hazards, especially those that interact\n+  with the pre-1.0 library stabilization process.\n+\n+> **[FIXME]** Add cross-references throughout this document to the tutorial,\n+> reference manual, and other guides.\n+\n+> **[FIXME]** What are some _non_-goals, _non_-principles, or _anti_-patterns that\n+> we should document?"}, {"sha": "41bc08f229e7c9f65f5120d82507ca216da21c8e", "filename": "src/doc/style/SUMMARY.md", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2FSUMMARY.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,54 @@\n+# Summary\n+\n+* [Style](style/README.md)\n+    * [Whitespace](style/whitespace.md)\n+    * [Comments](style/comments.md)\n+    * [Braces, semicolons, commas](style/braces.md)\n+    * [Naming](style/naming/README.md)\n+        * [Ownership variants](style/naming/ownership.md)\n+        * [Containers/wrappers](style/naming/containers.md)\n+        * [Conversions](style/naming/conversions.md)\n+        * [Iterators](style/naming/iterators.md)\n+    * [Imports](style/imports.md)\n+    * [Organization](style/organization.md)\n+* [Guidelines by Rust feature](features/README.md)\n+    * [Let binding](features/let.md)\n+    * [Pattern matching](features/match.md)\n+    * [Loops](features/loops.md)\n+    * [Functions and methods](features/functions-and-methods/README.md)\n+        * [Input](features/functions-and-methods/input.md)\n+        * [Output](features/functions-and-methods/output.md)\n+        * [For convenience](features/functions-and-methods/convenience.md)\n+    * [Types](features/types/README.md)\n+        * [Conversions](features/types/conversions.md)\n+        * [The newtype pattern](features/types/newtype.md)\n+    * [Traits](features/traits/README.md)\n+        * [For generics](features/traits/generics.md)\n+        * [For objects](features/traits/objects.md)\n+        * [For overloading](features/traits/overloading.md)\n+        * [For extensions](features/traits/extensions.md)\n+        * [For reuse](features/traits/reuse.md)\n+        * [Common traits](features/traits/common.md)\n+    * [Modules](features/modules.md)\n+    * [Crates](features/crates.md)\n+* [Ownership and resources](ownership/README.md)\n+    * [Constructors](ownership/constructors.md)\n+    * [Builders](ownership/builders.md)\n+    * [Destructors](ownership/destructors.md)\n+    * [RAII](ownership/raii.md)\n+    * [Cells and smart pointers](ownership/cell-smart.md)\n+* [Errors](errors/README.md)\n+    * [Signaling](errors/signaling.md)\n+    * [Handling](errors/handling.md)\n+    * [Propagation](errors/propagation.md)\n+    * [Ergonomics](errors/ergonomics.md)\n+* [Safety and guarantees](safety/README.md)\n+    * [Using unsafe](safety/unsafe.md)\n+    * [Library guarantees](safety/lib-guarantees.md)\n+* [Testing](testing/README.md)\n+    * [Unit testing](testing/unit.md)\n+* [FFI, platform-specific code](platform.md)\n+* [APIs for a changing Rust](changing/README.md)\n+    * [Pre-1.0 changes](changing/pre-1-0.md)\n+    * [Post-1.0 changes](changing/post-1-0.md)\n+    * [Timing unclear](changing/unclear.md)"}, {"sha": "38e76f6970c810feee03999cac78a6d334e9afde", "filename": "src/doc/style/changing/README.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fchanging%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fchanging%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fchanging%2FREADME.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,5 @@\n+% API design for a changing Rust\n+\n+A number of planned Rust features will drastically affect the API design\n+story. This section collects some of the biggest features with concrete examples\n+of how the API will change."}, {"sha": "7ac1c837c071fda7eeae7e1194c978e76d0b93c0", "filename": "src/doc/style/changing/post-1-0.md", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fchanging%2Fpost-1-0.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fchanging%2Fpost-1-0.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fchanging%2Fpost-1-0.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,12 @@\n+% Post-1.0 changes\n+\n+### Higher-kinded types\n+\n+* A trait encompassing both `Iterable<T>` for some fixed `T` and\n+  `FromIterator<U>` for _all_ `U` (where HKT comes in).  The train\n+  could provide e.g. a default `map` method producing the same kind of\n+  the container, but with a new type parameter.\n+\n+* **Monadic-generic programming**? Can we add this without deprecating\n+  huge swaths of the API (including `Option::map`, `option::collect`,\n+  `result::collect`, `try!` etc."}, {"sha": "adadfe31a59d138b1c7dc0fd4b5f328826860d7b", "filename": "src/doc/style/changing/pre-1-0.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fchanging%2Fpre-1-0.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fchanging%2Fpre-1-0.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fchanging%2Fpre-1-0.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,17 @@\n+% Pre-1.0 changes\n+\n+### `std` facade\n+\n+We should revisit some APIs in `libstd` now that the facade effort is complete.\n+\n+For example, the treatment of environment variables in the new\n+`Command` API is waiting on access to hashtables before being\n+approved.\n+\n+### Trait reform\n+\n+Potential for standard conversion traits (`to`, `into`, `as`).\n+\n+Probably many other opportunities here.\n+\n+### Unboxed closures"}, {"sha": "e4b8a98e1a1622f1ac4e051facc9a3c649998050", "filename": "src/doc/style/changing/unclear.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fchanging%2Funclear.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fchanging%2Funclear.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fchanging%2Funclear.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,28 @@\n+% Changes with unclear timing\n+\n+### Associated items\n+\n+* Many traits that currently take type parameters should instead use associated\n+  types; this will _drastically_ simplify signatures in some cases.\n+\n+* Associated constants would be useful in a few places, e.g. traits for\n+  numerics, traits for paths.\n+\n+### Anonymous, unboxed return types (aka `impl Trait` types)\n+\n+* See https://github.com/rust-lang/rfcs/pull/105\n+\n+* Could affect API design in several places, e.g. the `Iterator` trait.\n+\n+### Default type parameters\n+\n+We are already using this in a few places (e.g. `HashMap`), but it's\n+feature-gated.\n+\n+### Compile-time function evaluation (CTFE)\n+\n+https://github.com/mozilla/rust/issues/11621\n+\n+### Improved constant folding\n+\n+https://github.com/rust-lang/rust/issues/7834"}, {"sha": "444da26ff8fed7191bc82d15eb88d5ed11156174", "filename": "src/doc/style/errors/README.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ferrors%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ferrors%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2FREADME.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,3 @@\n+% Errors\n+\n+> **[FIXME]** Add some general text here."}, {"sha": "33f1e82b187e7ddb6ee68fa2465e131e16a0435e", "filename": "src/doc/style/errors/ergonomics.md", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ferrors%2Fergonomics.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ferrors%2Fergonomics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2Fergonomics.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,66 @@\n+% Ergonomic error handling\n+\n+Error propagation with raw `Result`s can require tedious matching and\n+repackaging. This tedium is largely alleviated by the `try!` macro,\n+and can be completely removed (in some cases) by the \"`Result`-`impl`\"\n+pattern.\n+\n+### The `try!` macro\n+\n+Prefer\n+\n+```rust\n+use std::io::{File, Open, Write, IoError};\n+\n+struct Info {\n+    name: String,\n+    age: int,\n+    rating: int\n+}\n+\n+fn write_info(info: &Info) -> Result<(), IoError> {\n+    let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"),\n+                                   Open, Write);\n+    // Early return on error\n+    try!(file.write_line(format!(\"name: {}\", info.name).as_slice()));\n+    try!(file.write_line(format!(\"age: {}\", info.age).as_slice()));\n+    try!(file.write_line(format!(\"rating: {}\", info.rating).as_slice()));\n+    return Ok(());\n+}\n+```\n+\n+over\n+\n+```rust\n+use std::io::{File, Open, Write, IoError};\n+\n+struct Info {\n+    name: String,\n+    age: int,\n+    rating: int\n+}\n+\n+fn write_info(info: &Info) -> Result<(), IoError> {\n+    let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"),\n+                                   Open, Write);\n+    // Early return on error\n+    match file.write_line(format!(\"name: {}\", info.name).as_slice()) {\n+        Ok(_) => (),\n+        Err(e) => return Err(e)\n+    }\n+    match file.write_line(format!(\"age: {}\", info.age).as_slice()) {\n+        Ok(_) => (),\n+        Err(e) => return Err(e)\n+    }\n+    return file.write_line(format!(\"rating: {}\", info.rating).as_slice());\n+}\n+```\n+\n+See\n+[the `result` module documentation](http://static.rust-lang.org/doc/master/std/result/index.html#the-try!-macro)\n+for more details.\n+\n+### The `Result`-`impl` pattern [FIXME]\n+\n+> **[FIXME]** Document the way that the `io` module uses trait impls\n+> on `IoResult` to painlessly propagate errors."}, {"sha": "cc5b5b475769c55cfcd4bd5044c5c18514c9b18a", "filename": "src/doc/style/errors/handling.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ferrors%2Fhandling.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ferrors%2Fhandling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2Fhandling.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,7 @@\n+% Handling errors\n+\n+### Use task isolation to cope with failure. [FIXME]\n+\n+> **[FIXME]** Explain how to isolate tasks and detect task failure for recovery.\n+\n+### Consuming `Result` [FIXME]"}, {"sha": "0a347cd577b906136b2129909a7cde31e25f701e", "filename": "src/doc/style/errors/propagation.md", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ferrors%2Fpropagation.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ferrors%2Fpropagation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2Fpropagation.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,8 @@\n+% Propagation\n+\n+> **[FIXME]** We need guidelines on how to layer error information up a stack of\n+> abstractions.\n+\n+### Error interoperation [FIXME]\n+\n+> **[FIXME]** Document the `FromError` infrastructure."}, {"sha": "95db4f8afa03c515b7c3300956a8776849ec4892", "filename": "src/doc/style/errors/signaling.md", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ferrors%2Fsignaling.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ferrors%2Fsignaling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2Fsignaling.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,125 @@\n+% Signaling errors [RFC #236]\n+\n+> The guidelines below were approved by [RFC #236](https://github.com/rust-lang/rfcs/pull/236).\n+\n+Errors fall into one of three categories:\n+\n+* Catastrophic errors, e.g. out-of-memory.\n+* Contract violations, e.g. wrong input encoding, index out of bounds.\n+* Obstructions, e.g. file not found, parse error.\n+\n+The basic principle of the convention is that:\n+\n+* Catastrophic errors and programming errors (bugs) can and should only be\n+recovered at a *coarse grain*, i.e. a task boundary.\n+* Obstructions preventing an operation should be reported at a maximally *fine\n+grain* -- to the immediate invoker of the operation.\n+\n+## Catastrophic errors\n+\n+An error is _catastrophic_ if there is no meaningful way for the current task to\n+continue after the error occurs.\n+\n+Catastrophic errors are _extremely_ rare, especially outside of `libstd`.\n+\n+**Canonical examples**: out of memory, stack overflow.\n+\n+### For catastrophic errors, panic\n+\n+For errors like stack overflow, Rust currently aborts the process, but\n+could in principle panic, which (in the best case) would allow\n+reporting and recovery from a supervisory task.\n+\n+## Contract violations\n+\n+An API may define a contract that goes beyond the type checking enforced by the\n+compiler. For example, slices support an indexing operation, with the contract\n+that the supplied index must be in bounds.\n+\n+Contracts can be complex and involve more than a single function invocation. For\n+example, the `RefCell` type requires that `borrow_mut` not be called until all\n+existing borrows have been relinquished.\n+\n+### For contract violations, panic\n+\n+A contract violation is always a bug, and for bugs we follow the Erlang\n+philosophy of \"let it crash\": we assume that software *will* have bugs, and we\n+design coarse-grained task boundaries to report, and perhaps recover, from these\n+bugs.\n+\n+### Contract design\n+\n+One subtle aspect of these guidelines is that the contract for a function is\n+chosen by an API designer -- and so the designer also determines what counts as\n+a violation.\n+\n+This RFC does not attempt to give hard-and-fast rules for designing\n+contracts. However, here are some rough guidelines:\n+\n+* Prefer expressing contracts through static types whenever possible.\n+\n+* It *must* be possible to write code that uses the API without violating the\n+  contract.\n+\n+* Contracts are most justified when violations are *inarguably* bugs -- but this\n+  is surprisingly rare.\n+\n+* Consider whether the API client could benefit from the contract-checking\n+  logic.  The checks may be expensive. Or there may be useful programming\n+  patterns where the client does not want to check inputs before hand, but would\n+  rather attempt the operation and then find out whether the inputs were invalid.\n+\n+* When a contract violation is the *only* kind of error a function may encounter\n+  -- i.e., there are no obstructions to its success other than \"bad\" inputs --\n+  using `Result` or `Option` instead is especially warranted. Clients can then use\n+  `unwrap` to assert that they have passed valid input, or re-use the error\n+  checking done by the API for their own purposes.\n+\n+* When in doubt, use loose contracts and instead return a `Result` or `Option`.\n+\n+## Obstructions\n+\n+An operation is *obstructed* if it cannot be completed for some reason, even\n+though the operation's contract has been satisfied. Obstructed operations may\n+have (documented!) side effects -- they are not required to roll back after\n+encountering an obstruction.  However, they should leave the data structures in\n+a \"coherent\" state (satisfying their invariants, continuing to guarantee safety,\n+etc.).\n+\n+Obstructions may involve external conditions (e.g., I/O), or they may involve\n+aspects of the input that are not covered by the contract.\n+\n+**Canonical examples**: file not found, parse error.\n+\n+### For obstructions, use `Result`\n+\n+The\n+[`Result<T,E>` type](http://static.rust-lang.org/doc/master/std/result/index.html)\n+represents either a success (yielding `T`) or failure (yielding `E`). By\n+returning a `Result`, a function allows its clients to discover and react to\n+obstructions in a fine-grained way.\n+\n+#### What about `Option`?\n+\n+The `Option` type should not be used for \"obstructed\" operations; it\n+should only be used when a `None` return value could be considered a\n+\"successful\" execution of the operation.\n+\n+This is of course a somewhat subjective question, but a good litmus\n+test is: would a reasonable client ever ignore the result? The\n+`Result` type provides a lint that ensures the result is actually\n+inspected, while `Option` does not, and this difference of behavior\n+can help when deciding between the two types.\n+\n+Another litmus test: can the operation be understood as asking a\n+question (possibly with sideeffects)? Operations like `pop` on a\n+vector can be viewed as asking for the contents of the first element,\n+with the side effect of removing it if it exists -- with an `Option`\n+return value.\n+\n+## Do not provide both `Result` and `panic!` variants.\n+\n+An API should not provide both `Result`-producing and `panic`king versions of an\n+operation. It should provide just the `Result` version, allowing clients to use\n+`try!` or `unwrap` instead as needed. This is part of the general pattern of\n+cutting down on redundant variants by instead using method chaining."}, {"sha": "09657503d20d1cebf0c84eb194d2d315809590a4", "filename": "src/doc/style/features/README.md", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2FREADME.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,9 @@\n+% Guidelines by language feature\n+\n+Rust provides a unique combination of language features, some new and some\n+old. This section gives guidance on when and how to use Rust's features, and\n+brings attention to some of the tradeoffs between different features.\n+\n+Notably missing from this section is an in-depth discussion of Rust's pointer\n+types (both built-in and in the library). The topic of pointers is discussed at\n+length in a [separate section on ownership](../ownership/README.md)."}, {"sha": "4748b05f17f74a189f5681bcd584657ac1cf6c83", "filename": "src/doc/style/features/crates.md", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Fcrates.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Fcrates.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Fcrates.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,6 @@\n+% Crates\n+\n+> **[FIXME]** What general guidelines should we provide for crate design?\n+\n+> Possible topics: facades; per-crate preludes (to be imported as globs);\n+> \"lib.rs\""}, {"sha": "2dcfc382d0baf43c7a3657a31719114436dfb7e4", "filename": "src/doc/style/features/functions-and-methods/README.md", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2FREADME.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,43 @@\n+% Functions and methods\n+\n+### Prefer methods to functions if there is a clear receiver. **[FIXME: needs RFC]**\n+\n+Prefer\n+\n+```rust\n+impl Foo {\n+    pub fn frob(&self, w: widget) { ... }\n+}\n+```\n+\n+over\n+\n+```rust\n+pub fn frob(foo: &Foo, w: widget) { ... }\n+```\n+\n+for any operation that is clearly associated with a particular\n+type.\n+\n+Methods have numerous advantages over functions:\n+* They do not need to be imported or qualified to be used: all you\n+  need is a value of the appropriate type.\n+* Their invocation performs autoborrowing (including mutable borrows).\n+* They make it easy to answer the question \"what can I do with a value\n+  of type `T`\" (especially when using rustdoc).\n+* They provide `self` notation, which is more concise and often more\n+  clearly conveys ownership distinctions.\n+\n+> **[FIXME]** Revisit these guidelines with\n+> [UFCS](https://github.com/nick29581/rfcs/blob/ufcs/0000-ufcs.md) and\n+> conventions developing around it.\n+\n+\n+\n+### Guidelines for inherent methods. **[FIXME]**\n+\n+> **[FIXME]** We need guidelines for when to provide inherent methods on a type,\n+> versus methods through a trait or functions.\n+\n+> **NOTE**: Rules for method resolution around inherent methods are in flux,\n+> which may impact the guidelines."}, {"sha": "69fd3772a761f8521bcf5153d2ec2b9aae2c28f5", "filename": "src/doc/style/features/functions-and-methods/convenience.md", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Fconvenience.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Fconvenience.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Fconvenience.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,43 @@\n+% Convenience methods\n+\n+### Provide small, coherent sets of convenience methods. **[FIXME: needs RFC]**\n+\n+_Convenience methods_ wrap up existing functionality in a more convenient\n+way. The work done by a convenience method varies widely:\n+\n+* _Re-providing functions as methods_. For example, the `std::path::Path` type\n+  provides methods like `stat` on `Path`s that simply invoke the corresponding\n+  function in `std::io::fs`.\n+* _Skipping through conversions_. For example, the `str` type provides a\n+  `.len()` convenience method which is also expressible as `.as_bytes().len()`.\n+  Sometimes the conversion is more complex: the `str` module also provides\n+  `from_chars`, which encapsulates a simple use of iterators.\n+* _Encapsulating common arguments_. For example, vectors of `&str`s\n+  provide a `connect` as well as a special case, `concat`, that is expressible\n+  using `connect` with a fixed separator of `\"\"`.\n+* _Providing more efficient special cases_. The `connect` and `concat` example\n+  also applies here: singling out `concat` as a special case allows for a more\n+  efficient implementation.\n+\n+  Note, however, that the `connect` method actually detects the special case\n+  internally and invokes `concat`. Usually, it is not necessary to add a public\n+  convenience method just for efficiency gains; there should also be a\n+  _conceptual_ reason to add it, e.g. because it is such a common special case.\n+\n+It is tempting to add convenience methods in a one-off, haphazard way as\n+common use patterns emerge. Avoid this temptation, and instead _design_ small,\n+coherent sets of convenience methods that are easy to remember:\n+\n+* _Small_: Avoid combinatorial explosions of convenience methods. For example,\n+  instead of adding `_str` variants of methods that provide a `str` output,\n+  instead ensure that the normal output type of methods is easily convertible to\n+  `str`.\n+* _Coherent_: Look for small groups of convenience methods that make sense to\n+  include together. For example, the `Path` API mentioned above includes a small\n+  selection of the most common filesystem operations that take a `Path`\n+  argument.  If one convenience method strongly suggests the existence of others,\n+  consider adding the whole group.\n+* _Memorable_: It is not worth saving a few characters of typing if you have to\n+  look up the name of a convenience method every time you use it. Add\n+  convenience methods with names that are obvious and easy to remember, and add\n+  them for the most common or painful use cases."}, {"sha": "b0912ea0203dc0f50f802d15d2d75f16053f0f5b", "filename": "src/doc/style/features/functions-and-methods/input.md", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Finput.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Finput.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Finput.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,201 @@\n+% Input to functions and methods\n+\n+### Let the client decide when to copy and where to place data. [FIXME: needs RFC]\n+\n+#### Copying:\n+\n+Prefer\n+\n+```rust\n+fn foo(b: Bar) {\n+   // use b as owned, directly\n+}\n+```\n+\n+over\n+\n+```rust\n+fn foo(b: &Bar) {\n+    let b = b.clone();\n+    // use b as owned after cloning\n+}\n+```\n+\n+If a function requires ownership of a value of unknown type `T`, but does not\n+otherwise need to make copies, the function should take ownership of the\n+argument (pass by value `T`) rather than using `.clone()`. That way, the caller\n+can decide whether to relinquish ownership or to `clone`.\n+\n+Similarly, the `Copy` trait bound should only be demanded it when absolutely\n+needed, not as a way of signaling that copies should be cheap to make.\n+\n+#### Placement:\n+\n+Prefer\n+\n+```rust\n+fn foo(b: Bar) -> Bar { ... }\n+```\n+\n+over\n+\n+```rust\n+fn foo(b: Box<Bar>) -> Box<Bar> { ... }\n+```\n+\n+for concrete types `Bar` (as opposed to trait objects). This way, the caller can\n+decide whether to place data on the stack or heap. No overhead is imposed by\n+letting the caller determine the placement.\n+\n+### Minimize assumptions about parameters. [FIXME: needs RFC]\n+\n+The fewer assumptions a function makes about its inputs, the more widely usable\n+it becomes.\n+\n+#### Minimizing assumptions through generics:\n+\n+Prefer\n+\n+```rust\n+fn foo<T: Iterator<int>>(c: T) { ... }\n+```\n+\n+over any of\n+\n+```rust\n+fn foo(c: &[int]) { ... }\n+fn foo(c: &Vec<int>) { ... }\n+fn foo(c: &SomeOtherCollection<int>) { ... }\n+```\n+\n+if the function only needs to iterate over the data.\n+\n+More generally, consider using generics to pinpoint the assumptions a function\n+needs to make about its arguments.\n+\n+On the other hand, generics can make it more difficult to read and understand a\n+function's signature. Aim for \"natural\" parameter types that a neither overly\n+concrete nor overly abstract. See the discussion on\n+[traits](../../traits/README.md) for more guidance.\n+\n+\n+#### Minimizing ownership assumptions:\n+\n+Prefer either of\n+\n+```rust\n+fn foo(b: &Bar) { ... }\n+fn foo(b: &mut Bar) { ... }\n+```\n+\n+over\n+\n+```rust\n+fn foo(b: Bar) { ... }\n+```\n+\n+That is, prefer borrowing arguments rather than transferring ownership, unless\n+ownership is actually needed.\n+\n+### Prefer compound return types to out-parameters. [FIXME: needs RFC]\n+\n+Prefer\n+\n+```rust\n+fn foo() -> (Bar, Bar)\n+```\n+\n+over\n+\n+```rust\n+fn foo(output: &mut Bar) -> Bar\n+```\n+\n+for returning multiple `Bar` values.\n+\n+Compound return types like tuples and structs are efficiently compiled\n+and do not require heap allocation. If a function needs to return\n+multiple values, it should do so via one of these types.\n+\n+The primary exception: sometimes a function is meant to modify data\n+that the caller already owns, for example to re-use a buffer:\n+\n+```rust\n+fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>\n+```\n+\n+(From the [Reader trait](http://static.rust-lang.org/doc/master/std/io/trait.Reader.html#tymethod.read).)\n+\n+### Consider validating arguments, statically or dynamically. [FIXME: needs RFC]\n+\n+_Note: this material is closely related to\n+  [library-level guarantees](../../safety/lib-guarantees.md)._\n+\n+Rust APIs do _not_ generally follow the\n+[robustness principle](http://en.wikipedia.org/wiki/Robustness_principle): \"be\n+conservative in what you send; be liberal in what you accept\".\n+\n+Instead, Rust code should _enforce_ the validity of input whenever practical.\n+\n+Enforcement can be achieved through the following mechanisms (listed\n+in order of preference).\n+\n+#### Static enforcement:\n+\n+Choose an argument type that rules out bad inputs.\n+\n+For example, prefer\n+\n+```rust\n+fn foo(a: ascii::Ascii) { ... }\n+```\n+\n+over\n+\n+```rust\n+fn foo(a: u8) { ... }\n+```\n+\n+Note that\n+[`ascii::Ascii`](http://static.rust-lang.org/doc/master/std/ascii/struct.Ascii.html)\n+is a _wrapper_ around `u8` that guarantees the highest bit is zero; see\n+[newtype patterns]() for more details on creating typesafe wrappers.\n+\n+Static enforcement usually comes at little run-time cost: it pushes the\n+costs to the boundaries (e.g. when a `u8` is first converted into an\n+`Ascii`). It also catches bugs early, during compilation, rather than through\n+run-time failures.\n+\n+On the other hand, some properties are difficult or impossible to\n+express using types.\n+\n+#### Dynamic enforcement:\n+\n+Validate the input as it is processed (or ahead of time, if necessary).  Dynamic\n+checking is often easier to implement than static checking, but has several\n+downsides:\n+\n+1. Runtime overhead (unless checking can be done as part of processing the input).\n+2. Delayed detection of bugs.\n+3. Introduces failure cases, either via `fail!` or `Result`/`Option` types (see\n+   the [error handling guidelines](../../errors/README.md)), which must then be\n+   dealt with by client code.\n+\n+#### Dynamic enforcement with `debug_assert!`:\n+\n+Same as dynamic enforcement, but with the possibility of easily turning off\n+expensive checks for production builds.\n+\n+#### Dynamic enforcement with opt-out:\n+\n+Same as dynamic enforcement, but adds sibling functions that opt out of the\n+checking.\n+\n+The convention is to mark these opt-out functions with a suffix like\n+`_unchecked` or by placing them in a `raw` submodule.\n+\n+The unchecked functions can be used judiciously in cases where (1) performance\n+dictates avoiding checks and (2) the client is otherwise confident that the\n+inputs are valid.\n+\n+> **[FIXME]** Should opt-out functions be marked `unsafe`?"}, {"sha": "a83e2b76bcb7f457c71c8ef2247ae0713675490a", "filename": "src/doc/style/features/functions-and-methods/output.md", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Foutput.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Foutput.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ffunctions-and-methods%2Foutput.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,56 @@\n+% Output from functions and methods\n+\n+### Don't overpromise. [FIXME]\n+\n+> **[FIXME]** Add discussion of overly-specific return types,\n+> e.g. returning a compound iterator type rather than hiding it behind\n+> a use of newtype.\n+\n+### Let clients choose what to throw away. [FIXME: needs RFC]\n+\n+#### Return useful intermediate results:\n+\n+Many functions that answer a question also compute interesting related data.  If\n+this data is potentially of interest to the client, consider exposing it in the\n+API.\n+\n+Prefer\n+\n+```rust\n+struct SearchResult {\n+    found: bool,          // item in container?\n+    expected_index: uint  // what would the item's index be?\n+}\n+\n+fn binary_search(&self, k: Key) -> SearchResult\n+```\n+or\n+\n+```rust\n+fn binary_search(&self, k: Key) -> (bool, uint)\n+```\n+\n+over\n+\n+```rust\n+fn binary_search(&self, k: Key) -> bool\n+```\n+\n+#### Yield back ownership:\n+\n+Prefer\n+\n+```rust\n+fn from_utf8_owned(vv: Vec<u8>) -> Result<String, Vec<u8>>\n+```\n+\n+over\n+\n+```rust\n+fn from_utf8_owned(vv: Vec<u8>) -> Option<String>\n+```\n+\n+The `from_utf8_owned` function gains ownership of a vector.  In the successful\n+case, the function consumes its input, returning an owned string without\n+allocating or copying. In the unsuccessful case, however, the function returns\n+back ownership of the original slice."}, {"sha": "87117a20d7a4957392497b1dbec79978748a5e55", "filename": "src/doc/style/features/let.md", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Flet.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Flet.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Flet.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,103 @@\n+% Let binding\n+\n+### Always separately bind RAII guards. [FIXME: needs RFC]\n+\n+Prefer\n+\n+```rust\n+fn use_mutex(m: sync::mutex::Mutex<int>) {\n+    let guard = m.lock();\n+    do_work(guard);\n+    drop(guard); // unlock the lock\n+    // do other work\n+}\n+```\n+\n+over\n+\n+```rust\n+fn use_mutex(m: sync::mutex::Mutex<int>) {\n+    do_work(m.lock());\n+    // do other work\n+}\n+```\n+\n+As explained in the [RAII guide](../ownership/raii.md), RAII guards are values\n+that represent ownership of some resource and whose destructor releases the\n+resource. Because the lifetime of guards are significant, they should always be\n+explicitly `let`-bound to make the lifetime clear. Consider using an explicit\n+`drop` to release the resource early.\n+\n+### Prefer conditional expressions to deferred initialization. [FIXME: needs RFC]\n+\n+Prefer\n+\n+```rust\n+let foo = match bar {\n+    Baz  => 0,\n+    Quux => 1\n+};\n+```\n+\n+over\n+\n+```rust\n+let foo;\n+match bar {\n+    Baz  => {\n+        foo = 0;\n+    }\n+    Quux => {\n+        foo = 1;\n+    }\n+}\n+```\n+\n+unless the conditions for initialization are too complex to fit into a simple\n+conditional expression.\n+\n+### Use type annotations for clarification; prefer explicit generics when inference fails. [FIXME: needs RFC]\n+\n+Prefer\n+\n+```rust\n+s.iter().map(|x| x * 2)\n+        .collect::<Vec<_>>()\n+```\n+\n+over\n+\n+```rust\n+let v: Vec<_> = s.iter().map(|x| x * 2)\n+                        .collect();\n+```\n+\n+When the type of a value might be unclear to the _reader_ of the code, consider\n+explicitly annotating it in a `let`.\n+\n+On the other hand, when the type is unclear to the _compiler_, prefer to specify\n+the type by explicit generics instantiation, which is usually more clear.\n+\n+### Shadowing [FIXME]\n+\n+> **[FIXME]** Repeatedly shadowing a binding is somewhat common in Rust code. We\n+> need to articulate a guideline on when it is appropriate/useful and when not.\n+\n+### Prefer immutable bindings. [FIXME: needs RFC]\n+\n+Use `mut` bindings to signal the span during which a value is mutated:\n+\n+```rust\n+let mut v = Vec::new();\n+// push things onto v\n+let v = v;\n+// use v immutably henceforth\n+```\n+\n+### Prefer to bind all `struct` or tuple fields. [FIXME: needs RFC]\n+\n+When consuming a `struct` or tuple via a `let`, bind all of the fields rather\n+than using `..` to elide the ones you don't need. The benefit is that when\n+fields are added, the compiler will pinpoint all of the places where that type\n+of value was consumed, which will often need to be adjusted to take the new\n+field properly into account."}, {"sha": "b144825f98183d8a44bd6143d2b72d5a8c9e188d", "filename": "src/doc/style/features/loops.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Floops.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Floops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Floops.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,13 @@\n+% Loops\n+\n+### Prefer `for` to `while`. [FIXME: needs RFC]\n+\n+A `for` loop is preferable to a `while` loop, unless the loop counts in a\n+non-uniform way (making it difficult to express using `for`).\n+\n+### Guidelines for `loop`. [FIXME]\n+\n+> **[FIXME]** When is `loop` recommended? Some possibilities:\n+> * For optimistic retry algorithms\n+> * For servers\n+> * To avoid mutating local variables sometimes needed to fit `while`"}, {"sha": "131e0fad79a92d33b460e5c7a8d6315b32b866d8", "filename": "src/doc/style/features/match.md", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Fmatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Fmatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Fmatch.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,26 @@\n+% Pattern matching\n+\n+### Dereference `match` targets when possible. [FIXME: needs RFC]\n+\n+Prefer\n+\n+~~~~\n+match *foo {\n+    X(...) => ...\n+    Y(...) => ...\n+}\n+~~~~\n+\n+over\n+\n+~~~~\n+match foo {\n+    box X(...) => ...\n+    box Y(...) => ...\n+}\n+~~~~\n+\n+<!-- ### Clearly indicate important scopes. **[FIXME: needs RFC]** -->\n+\n+<!-- If it is important that the destructor for a value be executed at a specific -->\n+<!-- time, clearly bind that value using a standalone `let` -->"}, {"sha": "04aae226f72b59414c635ccd763f26ac0a245edb", "filename": "src/doc/style/features/modules.md", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Fmodules.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Fmodules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Fmodules.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,133 @@\n+% Modules\n+\n+> **[FIXME]** What general guidelines should we provide for module design?\n+\n+> We should discuss visibility, nesting, `mod.rs`, and any interesting patterns\n+> around modules.\n+\n+### Headers [FIXME: needs RFC]\n+\n+Organize module headers as follows:\n+  1. [Imports](../style/imports.md).\n+  1. `mod` declarations.\n+  1. `pub mod` declarations.\n+\n+### Avoid `path` directives. [FIXME: needs RFC]\n+\n+Avoid using `#[path=\"...\"]` directives; make the file system and\n+module hierarchy match, instead.\n+\n+### Use the module hirearchy to organize APIs into coherent sections. [FIXME]\n+\n+> **[FIXME]** Flesh this out with examples; explain what a \"coherent\n+> section\" is with examples.\n+>\n+> The module hirearchy defines both the public and internal API of your module.\n+> Breaking related functionality into submodules makes it understandable to both\n+> users and contributors to the module.\n+\n+### Place modules in their own file. [FIXME: needs RFC]\n+\n+> **[FIXME]**\n+> - \"<100 lines\" is arbitrary, but it's a clearer recommendation\n+>   than \"~1 page\" or similar suggestions that vary by screen size, etc.\n+\n+For all except very short modules (<100 lines) and [tests](../testing/README.md),\n+place the module `foo` in a separate file, as in:\n+\n+```rust\n+pub mod foo;\n+\n+// in foo.rs or foo/mod.rs\n+pub fn bar() { println!(\"...\"); }\n+/* ... */\n+```\n+\n+rather than declaring it inline:\n+\n+```rust\n+pub mod foo {\n+    pub fn bar() { println!(\"...\"); }\n+    /* ... */\n+}\n+```\n+\n+#### Use subdirectories for modules with children. [FIXME: needs RFC]\n+\n+For modules that themselves have submodules, place the module in a separate\n+directory (e.g., `bar/mod.rs` for a module `bar`) rather than the same directory.\n+\n+Note the structure of\n+[`std::io`](http://doc.rust-lang.org/std/io/). Many of the submodules lack\n+children, like\n+[`io::fs`](http://doc.rust-lang.org/std/io/fs/)\n+and\n+[`io::stdio`](http://doc.rust-lang.org/std/io/stdio/).\n+On the other hand,\n+[`io::net`](http://doc.rust-lang.org/std/io/net/)\n+contains submodules, so it lives in a separate directory:\n+\n+```\n+io/mod.rs\n+   io/extensions.rs\n+   io/fs.rs\n+   io/net/mod.rs\n+          io/net/addrinfo.rs\n+          io/net/ip.rs\n+          io/net/tcp.rs\n+          io/net/udp.rs\n+          io/net/unix.rs\n+   io/pipe.rs\n+   ...\n+```\n+\n+While it is possible to define all of `io` within a single directory,\n+mirroring the module hirearchy in the directory structure makes\n+submodules of `io::net` easier to find.\n+\n+### Consider top-level definitions or reexports. [FIXME: needs RFC]\n+\n+For modules with submodules,\n+define or [reexport](http://doc.rust-lang.org/std/io/#reexports) commonly used\n+definitions at the top level:\n+\n+* Functionality relevant to the module itself or to many of its\n+  children should be defined in `mod.rs`.\n+* Functionality specific to a submodule should live in that\n+  submodule. Reexport at the top level for the most important or\n+  common definitions.\n+\n+For example,\n+[`IoError`](http://doc.rust-lang.org/std/io/struct.IoError.html)\n+is defined in `io/mod.rs`, since it pertains to the entirety of `io`,\n+while\n+[`TcpStream`](http://doc.rust-lang.org/std/io/net/tcp/struct.TcpStream.html)\n+is defined in `io/net/tcp.rs` and reexported in the `io` module.\n+\n+### Use internal module hirearchies for organization. [FIXME: needs RFC]\n+\n+> **[FIXME]**\n+> - Referencing internal modules from the standard library is subject to\n+>   becoming outdated.\n+\n+Internal module hirearchies (i.e., private submodules) may be used to\n+hide implementation details that are not part of the module's API.\n+\n+For example, in [`std::io`](http://doc.rust-lang.org/std/io/), `mod mem`\n+provides implementations for\n+[`BufReader`](http://doc.rust-lang.org/std/io/struct.BufReader.html)\n+and\n+[`BufWriter`](http://doc.rust-lang.org/std/io/struct.BufWriter.html),\n+but these are re-exported in `io/mod.rs` at the top level of the module:\n+\n+```rust\n+// libstd/io/mod.rs\n+\n+pub use self::mem::{MemReader, BufReader, MemWriter, BufWriter};\n+/* ... */\n+mod mem;\n+```\n+\n+This hides the detail that there even exists a `mod mem` in `io`, and\n+helps keep code organized while offering freedom to change the\n+implementation."}, {"sha": "1893db24466fa861a075035a917092a81b021094", "filename": "src/doc/style/features/traits/README.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2FREADME.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,22 @@\n+% Traits\n+\n+Traits are probably Rust's most complex feature, supporting a wide range of use\n+cases and design tradeoffs. Patterns of trait usage are still emerging.\n+\n+### Know whether a trait will be used as an object. [FIXME: needs RFC]\n+\n+Trait objects have some [significant limitations](objects.md): methods\n+invoked through a trait object cannot use generics, and cannot use\n+`Self` except in receiver position.\n+\n+When designing a trait, decide early on whether the trait will be used\n+as an [object](objects.md) or as a [bound on generics](generics.md);\n+the tradeoffs are discussed in each of the linked sections.\n+\n+If a trait is meant to be used as an object, its methods should take\n+and return trait objects rather than use generics.\n+\n+\n+### Default methods [FIXME]\n+\n+> **[FIXME]** Guidelines for default methods."}, {"sha": "48c37eabcaaa13ab200aa90da74a281e2758501b", "filename": "src/doc/style/features/traits/common.md", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fcommon.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fcommon.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fcommon.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,71 @@\n+% Common traits\n+\n+### Eagerly implement common traits. [FIXME: needs RFC]\n+\n+Rust's trait system does not allow _orphans_: roughly, every `impl` must live\n+either in the crate that defines the trait or the implementing\n+type. Consequently, crates that define new types should eagerly implement all\n+applicable, common traits.\n+\n+To see why, consider the following situation:\n+\n+* Crate `std` defines trait `Show`.\n+* Crate `url` defines type `Url`, without implementing `Show`.\n+* Crate `webapp` imports from both `std` and `url`,\n+\n+There is no way for `webapp` to add `Show` to `url`, since it defines neither.\n+(Note: the newtype pattern can provide an efficient, but inconvenient\n+workaround; see [newtype for views](../types/newtype.md))\n+\n+The most important common traits to implement from `std` are:\n+\n+```rust\n+Clone, Show, Hash, Eq\n+```\n+\n+#### When safe, derive or otherwise implement `Send` and `Share`. [FIXME]\n+\n+> **[FIXME]**. This guideline is in flux while the \"opt-in\" nature of\n+> built-in traits is being decided. See https://github.com/rust-lang/rfcs/pull/127\n+\n+### Prefer to derive, rather than implement. [FIXME: needs RFC]\n+\n+Deriving saves implementation effort, makes correctness trivial, and\n+automatically adapts to upstream changes.\n+\n+### Do not overload operators in surprising ways. [FIXME: needs RFC]\n+\n+Operators with built in syntax (`*`, `|`, and so on) can be provided for a type\n+by implementing the traits in `core::ops`. These operators come with strong\n+expectations: implement `Mul` only for an operation that bears some resemblance\n+to multiplication (and shares the expected properties, e.g. associativity), and\n+so on for the other traits.\n+\n+### The `Drop` trait\n+\n+The `Drop` trait is treated specially by the compiler as a way of\n+associating destructors with types. See\n+[the section on destructors](../../ownership/destructors.md) for\n+guidance.\n+\n+### The `Deref`/`DerefMut` traits\n+\n+#### Use `Deref`/`DerefMut` only for smart pointers. [FIXME: needs RFC]\n+\n+The `Deref` traits are used implicitly by the compiler in many circumstances,\n+and interact with method resolution. The relevant rules are designed\n+specifically to accommodate smart pointers, and so the traits should be used\n+only for that purpose.\n+\n+#### Do not fail within a `Deref`/`DerefMut` implementation. [FIXME: needs RFC]\n+\n+Because the `Deref` traits are invoked implicitly by the compiler in sometimes\n+subtle ways, failure during dereferencing can be extremely confusing. If a\n+dereference might not succeed, target the `Deref` trait as a `Result` or\n+`Option` type instead.\n+\n+#### Avoid inherent methods when implementing `Deref`/`DerefMut` [FIXME: needs RFC]\n+\n+The rules around method resolution and `Deref` are in flux, but inherent methods\n+on a type implementing `Deref` are likely to shadow any methods of the referent\n+with the same name."}, {"sha": "fc3a03c01f5a184e5afdb75d62ec6e32f3cd1fa0", "filename": "src/doc/style/features/traits/extensions.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fextensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fextensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fextensions.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,7 @@\n+% Using traits to add extension methods\n+\n+> **[FIXME]** Elaborate.\n+\n+### Consider using default methods rather than extension traits **[FIXME]**\n+\n+> **[FIXME]** Elaborate."}, {"sha": "ab4f9cb1579611fdfc951e06856e8c637c557a6f", "filename": "src/doc/style/features/traits/generics.md", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fgenerics.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,68 @@\n+% Using traits for bounds on generics\n+\n+The most widespread use of traits is for writing generic functions or types. For\n+example, the following signature describes a function for consuming any iterator\n+yielding items of type `A` to produce a collection of `A`:\n+\n+```rust\n+fn from_iter<T: Iterator<A>>(iterator: T) -> SomeCollection<A>\n+```\n+\n+Here, the `Iterator` trait is specifies an interface that a type `T` must\n+explicitly implement to be used by this generic function.\n+\n+**Pros**:\n+\n+* _Reusability_. Generic functions can be applied to an open-ended collection of\n+  types, while giving a clear contract for the functionality those types must\n+  provide.\n+* _Static dispatch and optimization_. Each use of a generic function is\n+  specialized (\"monomorphized\") to the particular types implementing the trait\n+  bounds, which means that (1) invocations of trait methods are static, direct\n+  calls to the implementation and (2) the compiler can inline and otherwise\n+  optimize these calls.\n+* _Inline layout_. If a `struct` and `enum` type is generic over some type\n+  parameter `T`, values of type `T` will be laid out _inline_ in the\n+  `struct`/`enum`, without any indirection.\n+* _Inference_. Since the type parameters to generic functions can usually be\n+  inferred, generic functions can help cut down on verbosity in code where\n+  explicit conversions or other method calls would usually be necessary. See the\n+  [overloading/implicits use case](#use-case:-limited-overloading-and/or-implicit-conversions)\n+  below.\n+* _Precise types_. Because generic give a _name_ to the specific type\n+  implementing a trait, it is possible to be precise about places where that\n+  exact type is required or produced. For example, a function\n+\n+  ```rust\n+  fn binary<T: Trait>(x: T, y: T) -> T\n+  ```\n+\n+  is guaranteed to consume and produce elements of exactly the same type `T`; it\n+  cannot be invoked with parameters of different types that both implement\n+  `Trait`.\n+\n+**Cons**:\n+\n+* _Code size_. Specializing generic functions means that the function body is\n+  duplicated. The increase in code size must be weighed against the performance\n+  benefits of static dispatch.\n+* _Homogeneous types_. This is the other side of the \"precise types\" coin: if\n+  `T` is a type parameter, it stands for a _single_ actual type. So for example\n+  a `Vec<T>` contains elements of a single concrete type (and, indeed, the\n+  vector representation is specialized to lay these out in line). Sometimes\n+  heterogeneous collections are useful; see\n+  [trait objects](#use-case:-trait-objects) below.\n+* _Signature verbosity_. Heavy use of generics can bloat function signatures.\n+  **[Ed. note]** This problem may be mitigated by some language improvements; stay tuned.\n+\n+### Favor widespread traits. **[FIXME: needs RFC]**\n+\n+Generic types are a form of abstraction, which entails a mental indirection: if\n+a function takes an argument of type `T` bounded by `Trait`, clients must first\n+think about the concrete types that implement `Trait` to understand how and when\n+the function is callable.\n+\n+To keep the cost of abstraction low, favor widely-known traits. Whenever\n+possible, implement and use traits provided as part of the standard library.  Do\n+not introduce new traits for generics lightly; wait until there are a wide range\n+of types that can implement the type."}, {"sha": "38494a9b9bc3c02a0b7f529849c1584990e5bb23", "filename": "src/doc/style/features/traits/objects.md", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fobjects.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fobjects.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Fobjects.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,49 @@\n+% Using trait objects\n+\n+> **[FIXME]** What are uses of trait objects other than heterogeneous collections?\n+\n+Trait objects are useful primarily when _heterogeneous_ collections of objects\n+need to be treated uniformly; it is the closest that Rust comes to\n+object-oriented programming.\n+\n+```rust\n+struct Frame  { ... }\n+struct Button { ... }\n+struct Label  { ... }\n+\n+trait Widget  { ... }\n+\n+impl Widget for Frame  { ... }\n+impl Widget for Button { ... }\n+impl Widget for Label  { ... }\n+\n+impl Frame {\n+    fn new(contents: &[Box<Widget>]) -> Frame {\n+        ...\n+    }\n+}\n+\n+fn make_gui() -> Box<Widget> {\n+    let b: Box<Widget> = box Button::new(...);\n+    let l: Box<Widget> = box Label::new(...);\n+\n+    box Frame::new([b, l]) as Box<Widget>\n+}\n+```\n+\n+By using trait objects, we can set up a GUI framework with a `Frame` widget that\n+contains a heterogeneous collection of children widgets.\n+\n+**Pros**:\n+\n+* _Heterogeneity_. When you need it, you really need it.\n+* _Code size_. Unlike generics, trait objects do not generate specialized\n+  (monomorphized) versions of code, which can greatly reduce code size.\n+\n+**Cons**:\n+\n+* _No generic methods_. Trait objects cannot currently provide generic methods.\n+* _Dynamic dispatch and fat pointers_. Trait objects inherently involve\n+  indirection and vtable dispatch, which can carry a performance penalty.\n+* _No Self_. Except for the method receiver argument, methods on trait objects\n+  cannot use the `Self` type."}, {"sha": "d7482c96190723e943812db84cb4e1a4774a2fac", "filename": "src/doc/style/features/traits/overloading.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Foverloading.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Foverloading.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Foverloading.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,7 @@\n+% Using traits for overloading\n+\n+> **[FIXME]** Elaborate.\n+\n+> **[FIXME]** We need to decide on guidelines for this use case. There are a few\n+> patterns emerging in current Rust code, but it's not clear how widespread they\n+> should be."}, {"sha": "6735023ae680098dd9223ddb6583221961c83c28", "filename": "src/doc/style/features/traits/reuse.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Freuse.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Freuse.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Freuse.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,30 @@\n+% Using traits to share implementations\n+\n+> **[FIXME]** Elaborate.\n+\n+> **[FIXME]** We probably want to discourage this, at least when used in a way\n+> that is publicly exposed.\n+\n+Traits that provide default implmentations for function can provide code reuse\n+across types. For example, a `print` method can be defined across multiple\n+types as follows:\n+\n+``` Rust\n+trait Printable {\n+    // Default method implementation\n+    fn print(&self) { println!(\"{:?}\", *self) }\n+}\n+\n+impl Printable for int {}\n+\n+impl Printable for String {\n+    fn print(&self) { println!(\"{}\", *self) }\n+}\n+\n+impl Printable for bool {}\n+\n+impl Printable for f32 {}\n+```\n+\n+This allows the implementation of `print` to be shared across types, yet\n+overridden where needed, as seen in the `impl` for `String`."}, {"sha": "c675eb581c6ae328945c815116f2fe989baf570f", "filename": "src/doc/style/features/types/README.md", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2FREADME.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,68 @@\n+% Data types\n+\n+### Use custom types to imbue meaning; do not abuse `bool`, `Option` or other core types. **[FIXME: needs RFC]**\n+\n+Prefer\n+\n+```rust\n+let w = Widget::new(Small, Round)\n+```\n+\n+over\n+\n+```rust\n+let w = Widget::new(true, false)\n+```\n+\n+Core types like `bool`, `u8` and `Option` have many possible interpretations.\n+\n+Use custom types (whether `enum`s, `struct`, or tuples) to convey\n+interpretation and invariants. In the above example,\n+it is not immediately clear what `true` and `false` are conveying without\n+looking up the argument names, but `Small` and `Round` are more suggestive.\n+\n+Using custom types makes it easier to expand the\n+options later on, for example by adding an `ExtraLarge` variant.\n+\n+See [the newtype pattern](newtype.md) for a no-cost way to wrap\n+existing types with a distinguished name.\n+\n+### Prefer private fields, except for passive data. **[FIXME: needs RFC]**\n+\n+Making a field public is a strong commitment: it pins down a representation\n+choice, _and_ prevents the type from providing any validation or maintaining any\n+invariants on the contents of the field, since clients can mutate it arbitrarily.\n+\n+Public fields are most appropriate for `struct` types in the C spirit: compound,\n+passive data structures. Otherwise, consider providing getter/setter methods\n+and hiding fields instead.\n+\n+> **[FIXME]** Cross-reference validation for function arguments.\n+\n+### Use custom `enum`s for alternatives, `bitflags` for C-style flags. **[FIXME: needs RFC]**\n+\n+Rust supports `enum` types with \"custom discriminants\":\n+\n+~~~~\n+enum Color {\n+  Red = 0xff0000,\n+  Green = 0x00ff00,\n+  Blue = 0x0000ff\n+}\n+~~~~\n+\n+Custom discriminants are useful when an `enum` type needs to be serialized to an\n+integer value compatibly with some other system/language. They support\n+\"typesafe\" APIs: by taking a `Color`, rather than an integer, a function is\n+guaranteed to get well-formed inputs, even if it later views those inputs as\n+integers.\n+\n+An `enum` allows an API to request exactly one choice from among many. Sometimes\n+an API's input is instead the presence or absence of a set of flags. In C code,\n+this is often done by having each flag correspond to a particular bit, allowing\n+a single integer to represent, say, 32 or 64 flags. Rust's `std::bitflags`\n+module provides a typesafe way for doing so.\n+\n+### Phantom types. [FIXME]\n+\n+> **[FIXME]** Add some material on phantom types (https://blog.mozilla.org/research/2014/06/23/static-checking-of-units-in-servo/)"}, {"sha": "f0f230f57e557cf2c08d8058ecd1cb5ec41a4652", "filename": "src/doc/style/features/types/conversions.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2Fconversions.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2Fconversions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2Fconversions.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,22 @@\n+% Conversions between types\n+\n+### Associate conversions with the most specific type involved. **[FIXME: needs RFC]**\n+\n+When in doubt, prefer `to_`/`as_`/`into_` to `from_`, because they are\n+more ergonomic to use (and can be chained with other methods).\n+\n+For many conversions between two types, one of the types is clearly more\n+\"specific\": it provides some additional invariant or interpretation that is not\n+present in the other type. For example, `str` is more specific than `&[u8]`,\n+since it is a utf-8 encoded sequence of bytes.\n+\n+Conversions should live with the more specific of the involved types. Thus,\n+`str` provides both the `as_bytes` method and the `from_utf8` constructor for\n+converting to and from `&[u8]` values. Besides being intuitive, this convention\n+avoids polluting concrete types like `&[u8]` with endless conversion methods.\n+\n+### Explicitly mark lossy conversions, or do not label them as conversions. **[FIXME: needs RFC]**\n+\n+If a function's name implies that it is a conversion (prefix `from_`, `as_`,\n+`to_` or `into_`), but the function loses information, add a suffix `_lossy` or\n+otherwise indicate the lossyness. Consider avoiding the conversion name prefix."}, {"sha": "60c17fc2a52e2985277387b609bbfb74409a919e", "filename": "src/doc/style/features/types/newtype.md", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2Fnewtype.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2Fnewtype.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftypes%2Fnewtype.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,69 @@\n+% The newtype pattern\n+\n+A \"newtype\" is a tuple or `struct` with a single field. The terminology is borrowed from Haskell.\n+\n+Newtypes are a zero-cost abstraction: they introduce a new, distinct name for an\n+existing type, with no runtime overhead when converting between the two types.\n+\n+### Use newtypes to provide static distinctions. [FIXME: needs RFC]\n+\n+Newtypes can statically distinguish between different interpretations of an\n+underlying type.\n+\n+For example, a `f64` value might be used to represent a quantity in miles or in\n+kilometers. Using newtypes, we can keep track of the intended interpretation:\n+\n+```rust\n+struct Miles(pub f64);\n+struct Kilometers(pub f64);\n+\n+impl Miles {\n+    fn as_kilometers(&self) -> Kilometers { ... }\n+}\n+impl Kilometers {\n+    fn as_miles(&self) -> Miles { ... }\n+}\n+```\n+\n+Once we have separated these two types, we can statically ensure that we do not\n+confuse them. For example, the function\n+\n+```rust\n+fn are_we_there_yet(distance_travelled: Miles) -> bool { ... }\n+```\n+\n+cannot accidentally be called with a `Kilometers` value. The compiler will\n+remind us to perform the conversion, thus averting certain\n+[catastrophic bugs](http://en.wikipedia.org/wiki/Mars_Climate_Orbiter).\n+\n+### Use newtypes with private fields for hiding. [FIXME: needs RFC]\n+\n+A newtype can be used to hide representation details while making precise\n+promises to the client.\n+\n+For example, consider a function `my_transform` that returns a compound iterator\n+type `Enumerate<Skip<vec::MoveItems<T>>>`. We wish to hide this type from the\n+client, so that the client's view of the return type is roughly `Iterator<(uint,\n+T)>`. We can do so using the newtype pattern:\n+\n+```rust\n+struct MyTransformResult<T>(Enumerate<Skip<vec::MoveItems<T>>>);\n+impl<T> Iterator<(uint, T)> for MyTransformResult<T> { ... }\n+\n+fn my_transform<T, Iter: Iterator<T>>(iter: Iter) -> MyTransformResult<T> {\n+    ...\n+}\n+```\n+\n+Aside from simplifying the signature, this use of newtypes allows us to make a\n+expose and promise less to the client. The client does not know _how_ the result\n+iterator is constructed or represented, which means the representation can\n+change in the future without breaking client code.\n+\n+> **[FIXME]** Interaction with auto-deref.\n+\n+### Use newtypes to provide cost-free _views_ of another type. **[FIXME]**\n+\n+> **[FIXME]** Describe the pattern of using newtypes to provide a new set of\n+> inherent or trait methods, providing a different perspective on the underlying\n+> type."}, {"sha": "11bdb03a3a81851cc6e77b56a62b779ef5172b79", "filename": "src/doc/style/ownership/README.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fownership%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fownership%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2FREADME.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,3 @@\n+% Ownership and resource management\n+\n+> **[FIXME]** Add general remarks about ownership/resources here."}, {"sha": "94eda59b95b6510f8f6774959d39daa26e456207", "filename": "src/doc/style/ownership/builders.md", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fownership%2Fbuilders.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fownership%2Fbuilders.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2Fbuilders.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,176 @@\n+% The builder pattern\n+\n+Some data structures are complicated to construct, due to their construction needing:\n+\n+* a large number of inputs\n+* compound data (e.g. slices)\n+* optional configuration data\n+* choice between several flavors\n+\n+which can easily lead to a large number of distinct constructors with\n+many arguments each.\n+\n+If `T` is such a data structure, consider introducing a `T` _builder_:\n+\n+1. Introduce a separate data type `TBuilder` for incrementally configuring a `T`\n+   value. When possible, choose a better name: e.g. `Command` is the builder for\n+   `Process`.\n+2. The builder constructor should take as parameters only the data _required_ to\n+   to make a `T`.\n+3. The builder should offer a suite of convenient methods for configuration,\n+   including setting up compound inputs (like slices) incrementally.\n+   These methods should return `self` to allow chaining.\n+4. The builder should provide one or more \"_terminal_\" methods for actually building a `T`.\n+\n+The builder pattern is especially appropriate when building a `T` involves side\n+effects, such as spawning a task or launching a process.\n+\n+In Rust, there are two variants of the builder pattern, differing in the\n+treatment of ownership, as described below.\n+\n+### Non-consuming builders (preferred):\n+\n+In some cases, constructing the final `T` does not require the builder itself to\n+be consumed. The follow variant on\n+[`std::io::process::Command`](http://static.rust-lang.org/doc/master/std/io/process/struct.Command.html)\n+is one example:\n+\n+```rust\n+// NOTE: the actual Command API does not use owned Strings;\n+// this is a simplified version.\n+\n+pub struct Command {\n+    program: String,\n+    args: Vec<String>,\n+    cwd: Option<String>,\n+    // etc\n+}\n+\n+impl Command {\n+    pub fn new(program: String) -> Command {\n+        Command {\n+            program: program,\n+            args: Vec::new(),\n+            cwd: None,\n+        }\n+    }\n+\n+    /// Add an argument to pass to the program.\n+    pub fn arg<'a>(&'a mut self, arg: String) -> &'a mut Command {\n+        self.args.push(arg);\n+        self\n+    }\n+\n+    /// Add multiple arguments to pass to the program.\n+    pub fn args<'a>(&'a mut self, args: &[String])\n+                    -> &'a mut Command {\n+        self.args.push_all(args);\n+        self\n+    }\n+\n+    /// Set the working directory for the child process.\n+    pub fn cwd<'a>(&'a mut self, dir: String) -> &'a mut Command {\n+        self.cwd = Some(dir);\n+        self\n+    }\n+\n+    /// Executes the command as a child process, which is returned.\n+    pub fn spawn(&self) -> IoResult<Process> {\n+        ...\n+    }\n+}\n+```\n+\n+Note that the `spawn` method, which actually uses the builder configuration to\n+spawn a process, takes the builder by immutable reference. This is possible\n+because spawning the process does not require ownership of the configuration\n+data.\n+\n+Because the terminal `spawn` method only needs a reference, the configuration\n+methods take and return a mutable borrow of `self`.\n+\n+#### The benefit\n+\n+By using borrows throughout, `Command` can be used conveniently for both\n+one-liner and more complex constructions:\n+\n+```rust\n+// One-liners\n+Command::new(\"/bin/cat\").arg(\"file.txt\").spawn();\n+\n+// Complex configuration\n+let mut cmd = Command::new(\"/bin/ls\");\n+cmd.arg(\".\");\n+\n+if size_sorted {\n+    cmd.arg(\"-S\");\n+}\n+\n+cmd.spawn();\n+```\n+\n+### Consuming builders:\n+\n+Sometimes builders must transfer ownership when constructing the final type\n+`T`, meaning that the terminal methods must take `self` rather than `&self`:\n+\n+```rust\n+// A simplified excerpt from std::task::TaskBuilder\n+\n+impl TaskBuilder {\n+    /// Name the task-to-be. Currently the name is used for identification\n+    /// only in failure messages.\n+    pub fn named(mut self, name: String) -> TaskBuilder {\n+        self.name = Some(name);\n+        self\n+    }\n+\n+    /// Redirect task-local stdout.\n+    pub fn stdout(mut self, stdout: Box<Writer + Send>) -> TaskBuilder {\n+        self.stdout = Some(stdout);\n+        //   ^~~~~~ this is owned and cannot be cloned/re-used\n+        self\n+    }\n+\n+    /// Creates and executes a new child task.\n+    pub fn spawn(self, f: proc():Send) {\n+        // consume self\n+        ...\n+    }\n+}\n+```\n+\n+Here, the `stdout` configuration involves passing ownership of a `Writer`,\n+which must be transferred to the task upon construction (in `spawn`).\n+\n+When the terminal methods of the builder require ownership, there is a basic tradeoff:\n+\n+* If the other builder methods take/return a mutable borrow, the complex\n+  configuration case will work well, but one-liner configuration becomes\n+  _impossible_.\n+\n+* If the other builder methods take/return an owned `self`, one-liners\n+  continue to work well but complex configuration is less convenient.\n+\n+Under the rubric of making easy things easy and hard things possible, _all_\n+builder methods for a consuming builder should take and returned an owned\n+`self`. Then client code works as follows:\n+\n+```rust\n+// One-liners\n+TaskBuilder::new().named(\"my_task\").spawn(proc() { ... });\n+\n+// Complex configuration\n+let mut task = TaskBuilder::new();\n+task = task.named(\"my_task_2\"); // must re-assign to retain ownership\n+\n+if reroute {\n+    task = task.stdout(mywriter);\n+}\n+\n+task.spawn(proc() { ... });\n+```\n+\n+One-liners work as before, because ownership is threaded through each of the\n+builder methods until being consumed by `spawn`. Complex configuration,\n+however, is more verbose: it requires re-assigning the builder at each step."}, {"sha": "cd027cc4aaffc96728ae64289533043b8f8471ed", "filename": "src/doc/style/ownership/cell-smart.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fownership%2Fcell-smart.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fownership%2Fcell-smart.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2Fcell-smart.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,4 @@\n+% Cells and smart pointers\n+\n+> **[FIXME]** Add guidelines about when to use Cell, RefCell, Rc and\n+> Arc (and how to use them together)."}, {"sha": "b4a1147315679f09dbcbaa30306977a8f474d6b1", "filename": "src/doc/style/ownership/constructors.md", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fownership%2Fconstructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fownership%2Fconstructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2Fconstructors.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,62 @@\n+% Constructors\n+\n+### Define constructors as static, inherent methods. [FIXME: needs RFC]\n+\n+In Rust, \"constructors\" are just a convention:\n+\n+```rust\n+impl<T> Vec<T> {\n+    pub fn new() -> Vec<T> { ... }\n+}\n+```\n+\n+Constructors are static (no `self`) inherent methods for the type that they\n+construct. Combined with the practice of\n+[fully importing type names](../style/imports.md), this convention leads to\n+informative but concise construction:\n+\n+```rust\n+use vec::Vec;\n+\n+// construct a new vector\n+let mut v = Vec::new();\n+```\n+\n+This convention also applied to conversion constructors (prefix `from` rather\n+than `new`).\n+\n+### Provide constructors for passive `struct`s with defaults. [FIXME: needs RFC]\n+\n+Given the `struct`\n+\n+```rust\n+pub struct Config {\n+    pub color: Color,\n+    pub size:  Size,\n+    pub shape: Shape,\n+}\n+```\n+\n+provide a constructor if there are sensible defaults:\n+\n+```rust\n+impl Config {\n+    pub fn new() -> Config {\n+        Config {\n+            color: Brown,\n+            size: Medium,\n+            shape: Square,\n+        }\n+    }\n+}\n+```\n+\n+which then allows clients to concisely override using `struct` update syntax:\n+\n+```rust\n+Config { color: Red, .. Config::new() };\n+```\n+\n+See the [guideline for field privacy](../features/types/README.md) for\n+discussion on when to create such \"passive\" `struct`s with public\n+fields."}, {"sha": "8f58aa6c6d2f1e862018032c0096c1754e78f491", "filename": "src/doc/style/ownership/destructors.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fownership%2Fdestructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fownership%2Fdestructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2Fdestructors.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,22 @@\n+% Destructors\n+\n+Unlike constructors, destructors in Rust have a special status: they are added\n+by implementing `Drop` for a type, and they are automatically invoked as values\n+go out of scope.\n+\n+> **[FIXME]** This section needs to be expanded.\n+\n+### Destructors should not fail. [FIXME: needs RFC]\n+\n+Destructors are executed on task failure, and in that context a failing\n+destructor causes the program to abort.\n+\n+Instead of failing in a destructor, provide a separate method for checking for\n+clean teardown, e.g. a `close` method, that returns a `Result` to signal\n+problems.\n+\n+### Destructors should not block. [FIXME: needs RFC]\n+\n+Similarly, destructors should not invoke blocking operations, which can make\n+debugging much more difficult. Again, consider providing a separate method for\n+preparing for an infallible, nonblocking teardown."}, {"sha": "244e8096a1a2f26a230512c1f1d91ab4abfd5547", "filename": "src/doc/style/ownership/raii.md", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fownership%2Fraii.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fownership%2Fraii.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2Fraii.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,12 @@\n+% RAII\n+\n+Resource Acquisition is Initialization\n+\n+> **[FIXME]** Explain the RAII pattern and give best practices.\n+\n+### Whenever possible, tie resource access to guard scopes [FIXME]\n+\n+> **[FIXME]** Example: Mutex guards guarantee that access to the\n+> protected resource only happens when the guard is in scope.\n+\n+`must_use`"}, {"sha": "d29d060b6946195deb8238a438d77f05a8c65412", "filename": "src/doc/style/platform.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fplatform.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fplatform.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fplatform.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,7 @@\n+% FFI and platform-specific code **[FIXME]**\n+\n+> **[FIXME]** Not sure where this should live.\n+\n+When writing cross-platform code, group platform-specific code into a\n+module called `platform`. Avoid `#[cfg]` directives outside this\n+`platform` module."}, {"sha": "1ac6e704d23ebcca784d34df02987c859f8c2144", "filename": "src/doc/style/safety/README.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fsafety%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fsafety%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fsafety%2FREADME.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,19 @@\n+% Safety and guarantees\n+\n+> **[FIXME]** Is there a better phrase than \"strong guarantees\" that encompasses\n+> both e.g. memory safety and e.g. data structure invariants?\n+\n+A _guarantee_ is a property that holds no matter what client code does, unless\n+the client explicitly opts out:\n+\n+* Rust guarantees memory safety and data-race freedom, with `unsafe`\n+  blocks as an opt-out mechanism.\n+\n+* APIs in Rust often provide their own guarantees. For example, `std::str`\n+guarantees that its underlying buffer is valid utf-8. The `std::path::Path` type\n+guarantees no interior nulls. Both strings and paths provide `unsafe` mechanisms\n+for opting out of these guarantees (and thereby avoiding runtime checks).\n+\n+Thinking about guarantees is an essential part of writing good Rust code.  The\n+rest of this subsection outlines some cross-cutting principles around\n+guarantees."}, {"sha": "aa87223383a10d0f38fe4af7ece9ec96425f64f1", "filename": "src/doc/style/safety/lib-guarantees.md", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fsafety%2Flib-guarantees.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fsafety%2Flib-guarantees.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fsafety%2Flib-guarantees.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,81 @@\n+% Library-level guarantees\n+\n+Most libraries rely on internal invariants, e.g. about their data, resource\n+ownership, or protocol states. In Rust, broken invariants cannot produce\n+segfaults, but they can still lead to wrong answers.\n+\n+### Provide library-level guarantees whenever practical. **[FIXME: needs RFC]**\n+\n+Library-level invariants should be turned into guarantees whenever\n+practical. They should hold no matter what the client does, modulo\n+explicit opt-outs. Depending on the kind of invariant, this can be\n+achieved through a combination of static and dynamic enforcement, as\n+described below.\n+\n+#### Static enforcement:\n+\n+Guaranteeing invariants almost always requires _hiding_,\n+i.e. preventing the client from directly accessing or modifying\n+internal data.\n+\n+For example, the representation of the `str` type is hidden,\n+which means that any value of type `str` must have been produced\n+through an API under the control of the `str` module, and these\n+APIs in turn ensure valid utf-8 encoding.\n+\n+Rust's type system makes it possible to provide guarantees even while\n+revealing more of the representation than usual. For example, the\n+`as_bytes()` method on `&str` gives a _read-only_ view into the\n+underlying buffer, which cannot be used to violate the utf-8 property.\n+\n+#### Dynamic enforcement:\n+\n+Malformed inputs from the client are hazards to library-level\n+guarantees, so library APIs should validate their input.\n+\n+For example, `std::str::from_utf8_owned` attempts to convert a `u8`\n+slice into an owned string, but dynamically checks that the slice is\n+valid utf-8 and returns `Err` if not.\n+\n+See\n+[the discussion on input validation](../features/functions-and-methods/input.md)\n+for more detail.\n+\n+\n+### Prefer static enforcement of guarantees. **[FIXME: needs RFC]**\n+\n+Static enforcement provides two strong benefits over dynamic enforcement:\n+\n+* Bugs are caught at compile time.\n+* There is no runtime cost.\n+\n+Sometimes purely static enforcement is impossible or impractical. In these\n+cases, a library should check as much as possible statically, but defer to\n+dynamic checks where needed.\n+\n+For example, the `std::string` module exports a `String` type with the guarantee\n+that all instances are valid utf-8:\n+\n+* Any _consumer_ of a `String` is statically guaranteed utf-8 contents. For example,\n+  the `append` method can push a `&str` onto the end of a `String` without\n+  checking anything dynamically, since the existing `String` and `&str` are\n+  statically guaranteed to be in utf-8.\n+\n+* Some _producers_ of a `String` must perform dynamic checks. For example, the\n+  `from_utf8` function attempts to convert a `Vec<u8>` into a `String`, but\n+  dynamically checks that the contents are utf-8.\n+\n+### Provide opt-outs with caution; make them explicit. **[FIXME: needs RFC]**\n+\n+Providing library-level guarantees sometimes entails inconvenience (for static\n+checks) or overhead (for dynamic checks). So it is sometimes desirable to allow\n+clients to sidestep this checking, while promising to use the API in a way that\n+still provides the guarantee. Such escape hatches should only be be introduced\n+when there is a demonstrated need for them.\n+\n+It should be trivial for clients to audit their use of the library for\n+escape hatches.\n+\n+See\n+[the discussion on input validation](../features/functions-and-methods/input.md)\n+for conventions on marking opt-out functions."}, {"sha": "a8a50af044c2916e1fc6e9de79bd75bf3f05266b", "filename": "src/doc/style/safety/unsafe.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fsafety%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fsafety%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fsafety%2Funsafe.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,22 @@\n+% Using `unsafe`\n+\n+### Unconditionally guarantee safety, or mark API as `unsafe`. **[FIXME: needs RFC]**\n+\n+Memory safety, type safety, and data race freedom are basic assumptions for all\n+Rust code.\n+\n+APIs that use `unsafe` blocks internally thus have two choices:\n+\n+* They can guarantee safety _unconditionally_ (i.e., regardless of client\n+  behavior or inputs) and be exported as safe code. Any safety violation is then\n+  the library's fault, not the client's fault.\n+\n+* They can export potentially unsafe functions with the `unsafe` qualifier. In\n+  this case, the documentation should make very clear the conditions under which\n+  safety is guaranteed.\n+\n+The result is that a client program can never violate safety merely by having a\n+bug; it must have explicitly opted out by using an `unsafe` block.\n+\n+Of the two options for using `unsafe`, creating such safe abstractions (the\n+first option above) is strongly preferred."}, {"sha": "87449710543c01f0ec0f7e57bf47448abef704e1", "filename": "src/doc/style/style/README.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2FREADME.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,5 @@\n+% Style\n+\n+This section gives a set of strict rules for styling Rust code.\n+\n+> **[FIXME]** General remarks about the style guidelines"}, {"sha": "0f61bac9fd229133729efd7359518747238c0c6b", "filename": "src/doc/style/style/braces.md", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Fbraces.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Fbraces.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fbraces.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,77 @@\n+% Braces, semicolons, and commas [FIXME: needs RFC]\n+\n+### Opening braces always go on the same line.\n+\n+``` rust\n+fn foo() {\n+    ...\n+}\n+\n+fn frobnicate(a: Bar, b: Bar,\n+              c: Bar, d: Bar)\n+              -> Bar {\n+    ...\n+}\n+\n+trait Bar {\n+    fn baz(&self);\n+}\n+\n+impl Bar for Baz {\n+    fn baz(&self) {\n+        ...\n+    }\n+}\n+\n+frob(|x| {\n+    x.transpose()\n+})\n+```\n+\n+### `match` arms get braces, except for single-line expressions.\n+\n+``` rust\n+match foo {\n+    bar => baz,\n+    quux => {\n+        do_something();\n+        do_something_else()\n+    }\n+}\n+```\n+\n+### `return` statements get semicolons.\n+\n+``` rust\n+fn foo() {\n+    do_something();\n+\n+    if condition() {\n+        return;\n+    }\n+\n+    do_something_else();\n+}\n+```\n+\n+### Trailing commas\n+\n+> **[FIXME]** We should have a guideline for when to include trailing\n+> commas in `struct`s, `match`es, function calls, etc.\n+>\n+> One possible rule: a trailing comma should be included whenever the\n+> closing delimiter appears on a separate line:\n+\n+```rust\n+Foo { bar: 0, baz: 1 }\n+\n+Foo {\n+    bar: 0,\n+    baz: 1,\n+}\n+\n+match a_thing {\n+    None => 0,\n+    Some(x) => 1,\n+}\n+```"}, {"sha": "347750ce6020df1da5afcb74b583c6bf3aa4799c", "filename": "src/doc/style/style/comments.md", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Fcomments.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Fcomments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fcomments.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,87 @@\n+% Comments [FIXME: needs RFC]\n+\n+### Avoid block comments.\n+\n+Use line comments:\n+\n+``` rust\n+// Wait for the main task to return, and set the process error code\n+// appropriately.\n+```\n+\n+Instead of:\n+\n+``` rust\n+/*\n+ * Wait for the main task to return, and set the process error code\n+ * appropriately.\n+ */\n+```\n+\n+## Doc comments\n+\n+Doc comments are prefixed by three slashes (`///`) and indicate\n+documentation that you would like to be included in Rustdoc's output.\n+They support\n+[Markdown syntax](https://en.wikipedia.org/wiki/Markdown)\n+and are the main way of documenting your public APIs.\n+\n+The supported markdown syntax includes all of the extensions listed in the\n+[GitHub Flavored Markdown]\n+(https://help.github.com/articles/github-flavored-markdown) documentation,\n+plus superscripts.\n+\n+### Summary line\n+\n+The first line in any doc comment should be a single-line short sentence\n+providing a summary of the code. This line is used as a short summary\n+description throughout Rustdoc's output, so it's a good idea to keep it\n+short.\n+\n+### Sentence structure\n+\n+All doc comments, including the summary line, should begin with a\n+capital letter and end with a period, question mark, or exclamation\n+point. Prefer full sentences to fragments.\n+\n+The summary line should be written in\n+[third person singular present indicative form]\n+(http://en.wikipedia.org/wiki/English_verbs#Third_person_singular_present).\n+Basically, this means write \"Returns\" instead of \"Return\".\n+\n+For example:\n+\n+``` rust\n+/// Sets up a default runtime configuration, given compiler-supplied arguments.\n+///\n+/// This function will block until the entire pool of M:N schedulers has\n+/// exited. This function also requires a local task to be available.\n+///\n+/// # Arguments\n+///\n+/// * `argc` & `argv` - The argument vector. On Unix this information is used\n+///                     by `os::args`.\n+/// * `main` - The initial procedure to run inside of the M:N scheduling pool.\n+///            Once this procedure exits, the scheduling pool will begin to shut\n+///            down. The entire pool (and this function) will only return once\n+///            all child tasks have finished executing.\n+///\n+/// # Return value\n+///\n+/// The return value is used as the process return code. 0 on success, 101 on\n+/// error.\n+```\n+\n+### Code snippets\n+\n+> **[FIXME]**\n+\n+### Avoid inner doc comments.\n+\n+Use inner doc comments _only_ to document crates and file-level modules:\n+\n+``` rust\n+//! The core library.\n+//!\n+//! The core library is a something something...\n+```"}, {"sha": "f73517c2b9c3b6ce1d9853103d12eda07311d0fd", "filename": "src/doc/style/style/features.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Ffeatures.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Ffeatures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Ffeatures.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,13 @@\n+## `return` [FIXME: needs RFC]\n+\n+Terminate `return` statements with semicolons:\n+\n+``` rust\n+fn foo(bar: int) -> Option<int> {\n+    if some_condition() {\n+        return None;\n+    }\n+\n+    ...\n+}\n+```"}, {"sha": "207a3fd7f8d165d81d58740d97f5368ea4f0a7f4", "filename": "src/doc/style/style/imports.md", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Fimports.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Fimports.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fimports.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,50 @@\n+% Imports [FIXME: needs RFC]\n+\n+The imports of a crate/module should consist of the following\n+sections, in order, with a blank space between each:\n+\n+* `extern crate` directives\n+* external `use` imports\n+* local `use` imports\n+* `pub use` imports\n+\n+For example:\n+\n+```rust\n+// Crates.\n+extern crate getopts;\n+extern crate mylib;\n+\n+// Standard library imports.\n+use getopts::{optopt, getopts};\n+use std::os;\n+\n+// Import from a library that we wrote.\n+use mylib::webserver;\n+\n+// Will be reexported when we import this module.\n+pub use self::types::Webdata;\n+```\n+\n+### Avoid `use *`, except in tests.\n+\n+Glob imports have several downsides:\n+* They make it harder to tell where names are bound.\n+* They are forwards-incompatible, since new upstream exports can clash\n+  with existing names.\n+\n+When writing a [`test` submodule](../testing/README.md), importing `super::*` is appropriate\n+as a convenience.\n+\n+### Prefer fully importing types/traits while module-qualifying functions.\n+\n+For example:\n+\n+```rust\n+use option::Option;\n+use mem;\n+\n+let i: int = mem::transmute(Option(0));\n+```\n+\n+> **[FIXME]** Add rationale."}, {"sha": "9d78721ad3644965a11e0fb1b6dd7115a20ae841", "filename": "src/doc/style/style/naming/README.md", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2FREADME.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,115 @@\n+% Naming conventions\n+\n+### General conventions [RFC #430]\n+\n+> The guidelines below were approved by [RFC #430](https://github.com/rust-lang/rfcs/pull/430).\n+\n+In general, Rust tends to use `CamelCase` for \"type-level\" constructs\n+(types and traits) and `snake_case` for \"value-level\" constructs. More\n+precisely:\n+\n+| Item | Convention |\n+| ---- | ---------- |\n+| Crates | `snake_case` (but prefer single word) |\n+| Modules | `snake_case` |\n+| Types | `CamelCase` |\n+| Traits | `CamelCase` |\n+| Enum variants | `CamelCase` |\n+| Functions | `snake_case` |\n+| Methods | `snake_case` |\n+| General constructors | `new` or `with_more_details` |\n+| Conversion constructors | `from_some_other_type` |\n+| Local variables | `snake_case` |\n+| Static variables | `SCREAMING_SNAKE_CASE` |\n+| Constant variables | `SCREAMING_SNAKE_CASE` |\n+| Type parameters | concise `CamelCase`, usually single uppercase letter: `T` |\n+| Lifetimes | short, lowercase: `'a` |\n+\n+<p>\n+In `CamelCase`, acronyms count as one word: use `Uuid` rather than\n+`UUID`.  In `snake_case`, acronyms are lower-cased: `is_xid_start`.\n+\n+In `snake_case` or `SCREAMING_SNAKE_CASE`, a \"word\" should never\n+consist of a single letter unless it is the last \"word\". So, we have\n+`btree_map` rather than `b_tree_map`, but `PI_2` rather than `PI2`.\n+\n+### Referring to types in function/method names [RFC 344]\n+\n+> The guidelines below were approved by [RFC #344](https://github.com/rust-lang/rfcs/pull/344).\n+\n+Function names often involve type names, the most common example being conversions\n+like `as_slice`. If the type has a purely textual name (ignoring parameters), it\n+is straightforward to convert between type conventions and function conventions:\n+\n+Type name | Text in methods\n+--------- | ---------------\n+`String`  | `string`\n+`Vec<T>`  | `vec`\n+`YourType`| `your_type`\n+\n+Types that involve notation follow the convention below. There is some\n+overlap on these rules; apply the most specific applicable rule:\n+\n+Type name | Text in methods\n+--------- | ---------------\n+`&str`    | `str`\n+`&[T]`    | `slice`\n+`&mut [T]`| `mut_slice`\n+`&[u8]`   | `bytes`\n+`&T`      | `ref`\n+`&mut T`  | `mut`\n+`*const T`| `ptr`\n+`*mut T`  | `mut_ptr`\n+\n+### Avoid redundant prefixes [RFC 356]\n+\n+> The guidelines below were approved by [RFC #356](https://github.com/rust-lang/rfcs/pull/356).\n+\n+Names of items within a module should not be prefixed with that module's name:\n+\n+Prefer\n+\n+``` rust\n+mod foo {\n+    pub struct Error { ... }\n+}\n+```\n+\n+over\n+\n+``` rust\n+mod foo {\n+    pub struct FooError { ... }\n+}\n+```\n+\n+This convention avoids stuttering (like `io::IoError`). Library clients can\n+rename on import to avoid clashes.\n+\n+### Getter/setter methods [RFC 344]\n+\n+> The guidelines below were approved by [RFC #344](https://github.com/rust-lang/rfcs/pull/344).\n+\n+Some data structures do not wish to provide direct access to their fields, but\n+instead offer \"getter\" and \"setter\" methods for manipulating the field state\n+(often providing checking or other functionality).\n+\n+The convention for a field `foo: T` is:\n+\n+* A method `foo(&self) -> &T` for getting the current value of the field.\n+* A method `set_foo(&self, val: T)` for setting the field. (The `val` argument\n+  here may take `&T` or some other type, depending on the context.)\n+\n+Note that this convention is about getters/setters on ordinary data types, *not*\n+on [builder objects](../ownership/builders.html).\n+\n+### Escape hatches [FIXME]\n+\n+> **[FIXME]** Should we standardize a convention for functions that may break API\n+> guarantees? e.g. `ToCStr::to_c_str_unchecked`\n+\n+### Predicates\n+\n+* Simple boolean predicates should be prefixed with `is_` or another\n+  short question word, e.g., `is_empty`.\n+* Common exceptions: `lt`, `gt`, and other established predicate names."}, {"sha": "04204f0f88aec18efc15a5c24e753628a38501c3", "filename": "src/doc/style/style/naming/containers.md", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fcontainers.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fcontainers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fcontainers.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,69 @@\n+% Common container/wrapper methods [FIXME: needs RFC]\n+\n+Containers, wrappers, and cells all provide ways to access the data\n+they enclose.  Accessor methods often have variants to access the data\n+by value, by reference, and by mutable reference.\n+\n+In general, the `get` family of methods is used to access contained\n+data without any risk of task failure; they return `Option` as\n+appropriate. This name is chosen rather than names like `find` or\n+`lookup` because it is appropriate for a wider range of container types.\n+\n+#### Containers\n+\n+For a container with keys/indexes of type `K` and elements of type `V`:\n+\n+```rust\n+// Look up element without failing\n+fn get(&self, key: K) -> Option<&V>\n+fn get_mut(&mut self, key: K) -> Option<&mut V>\n+\n+// Convenience for .get(key).map(|elt| elt.clone())\n+fn get_clone(&self, key: K) -> Option<V>\n+\n+// Lookup element, failing if it is not found:\n+impl Index<K, V> for Container { ... }\n+impl IndexMut<K, V> for Container { ... }\n+```\n+\n+#### Wrappers/Cells\n+\n+Prefer specific conversion functions like `as_bytes` or `into_vec` whenever\n+possible. Otherwise, use:\n+\n+```rust\n+// Extract contents without failing\n+fn get(&self) -> &V\n+fn get_mut(&mut self) -> &mut V\n+fn unwrap(self) -> V\n+```\n+\n+#### Wrappers/Cells around `Copy` data\n+\n+```rust\n+// Extract contents without failing\n+fn get(&self) -> V\n+```\n+\n+#### `Option`-like types\n+\n+Finally, we have the cases of types like `Option` and `Result`, which\n+play a special role for failure.\n+\n+For `Option<V>`:\n+\n+```rust\n+// Extract contents or fail if not available\n+fn assert(self) -> V\n+fn expect(self, &str) -> V\n+```\n+\n+For `Result<V, E>`:\n+\n+```rust\n+// Extract the contents of Ok variant; fail if Err\n+fn assert(self) -> V\n+\n+// Extract the contents of Err variant; fail if Ok\n+fn assert_err(self) -> E\n+```"}, {"sha": "0287919c78aae22b7dfc069b04d895d892b8807a", "filename": "src/doc/style/style/naming/conversions.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fconversions.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fconversions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fconversions.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,32 @@\n+% Conversions [Rust issue #7087]\n+\n+> The guidelines below were approved by [rust issue #7087](https://github.com/rust-lang/rust/issues/7087).\n+\n+> **[FIXME]** Should we provide standard traits for conversions? Doing\n+> so nicely will require\n+> [trait reform](https://github.com/rust-lang/rfcs/pull/48) to land.\n+\n+Conversions should be provided as methods, with names prefixed as follows:\n+\n+| Prefix | Cost | Consumes convertee |\n+| ------ | ---- | ------------------ |\n+| `as_` | Free | No |\n+| `to_` | Expensive | No |\n+| `into_` | Variable | Yes |\n+\n+<p>\n+For example:\n+\n+* `as_bytes()` gives a `&[u8]` view into a `&str`, which is a no-op.\n+* `to_owned()` copies a `&str` to a new `String`.\n+* `into_bytes()` consumes a `String` and yields the underlying\n+  `Vec<u8>`, which is a no-op.\n+\n+Conversions prefixed `as_` and `into_` typically _decrease abstraction_, either\n+exposing a view into the underlying representation (`as`) or deconstructing data\n+into its underlying representation (`into`). Conversions prefixed `to_`, on the\n+other hand, typically stay at the same level of abstraction but do some work to\n+change one representation into another.\n+\n+> **[FIXME]** The distinctions between conversion methods does not work\n+> so well for `from_` conversion constructors. Is that a problem?"}, {"sha": "38138b5e39d3a0781efb0e333adc62646ee4672a", "filename": "src/doc/style/style/naming/iterators.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fiterators.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,32 @@\n+% Iterators\n+\n+#### Method names [RFC #199]\n+\n+> The guidelines below were approved by [RFC #199](https://github.com/rust-lang/rfcs/pull/199).\n+\n+For a container with elements of type `U`, iterator methods should be named:\n+\n+```rust\n+fn iter(&self) -> T           // where T implements Iterator<&U>\n+fn iter_mut(&mut self) -> T   // where T implements Iterator<&mut U>\n+fn into_iter(self) -> T       // where T implements Iterator<U>\n+```\n+\n+The default iterator variant yields shared references `&U`.\n+\n+#### Type names [RFC #344]\n+\n+> The guidelines below were approved by [RFC #344](https://github.com/rust-lang/rfcs/pull/344).\n+\n+The name of an iterator type should be the same as the method that\n+produces the iterator.\n+\n+For example:\n+\n+* `iter` should yield an `Iter`\n+* `iter_mut` should yield an `IterMut`\n+* `into_iter` should yield an `IntoIter`\n+* `keys` should yield `Keys`\n+\n+These type names make the most sense when prefixed with their owning module,\n+e.g. `vec::IntoIter`."}, {"sha": "32cd8a1595afb0a245ae6062c7218fe65fe29940", "filename": "src/doc/style/style/naming/ownership.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fownership.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,34 @@\n+% Ownership variants [RFC #199]\n+\n+> The guidelines below were approved by [RFC #199](https://github.com/rust-lang/rfcs/pull/199).\n+\n+Functions often come in multiple variants: immutably borrowed, mutably\n+borrowed, and owned.\n+\n+The right default depends on the function in question. Variants should\n+be marked through suffixes.\n+\n+#### Immutably borrowed by default\n+\n+If `foo` uses/produces an immutable borrow by default, use:\n+\n+* The `_mut` suffix (e.g. `foo_mut`) for the mutably borrowed variant.\n+* The `_move` suffix (e.g. `foo_move`) for the owned variant.\n+\n+#### Owned by default\n+\n+If `foo` uses/produces owned data by default, use:\n+\n+* The `_ref` suffix (e.g. `foo_ref`) for the immutably borrowed variant.\n+* The `_mut` suffix (e.g. `foo_mut`) for the mutably borrowed variant.\n+\n+#### Exceptions\n+\n+In the case of iterators, the moving variant can also be understood as\n+an `into` conversion, `into_iter`, and `for x in v.into_iter()` reads\n+arguably better than `for x in v.iter_move()`, so the convention is\n+`into_iter`.\n+\n+For mutably borrowed variants, if the `mut` qualifier is part of a\n+type name (e.g. `as_mut_slice`), it should appear as it would appear\n+in the type."}, {"sha": "d3c2178cc993fc6f66a41f25a18bae6883f67883", "filename": "src/doc/style/style/optional.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Foptional.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Foptional.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Foptional.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,3 @@\n+*\n+\n+*"}, {"sha": "85065406d761c7ec76deffe71400f2c2c2d2a448", "filename": "src/doc/style/style/organization.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Forganization.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Forganization.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Forganization.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,14 @@\n+% Organization [FIXME: needs RFC]\n+\n+> **[FIXME]** What else?\n+\n+### Reexport the most important types at the crate level.\n+\n+Crates `pub use` the most common types for convenience, so that clients do not\n+have to remember or write the crate's module hierarchy to use these types.\n+\n+### Define types and operations together.\n+\n+Type definitions and the functions/methods that operate on them should be\n+defined together in a single module, with the type appearing above the\n+functions/methods."}, {"sha": "b21b280dff0d7feb6651af866de507234b6d5a97", "filename": "src/doc/style/style/whitespace.md", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Fwhitespace.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Fstyle%2Fwhitespace.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fwhitespace.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,133 @@\n+% Whitespace [FIXME: needs RFC]\n+\n+* Lines must not exceed 99 characters.\n+* Use 4 spaces for indentation, _not_ tabs.\n+* No trailing whitespace at the end of lines or files.\n+\n+### Spaces\n+\n+* Use spaces around binary operators, including the equals sign in attributes:\n+\n+``` rust\n+#[deprecated = \"Use `bar` instead.\"]\n+fn foo(a: uint, b: uint) -> uint {\n+    a + b\n+}\n+```\n+\n+* Use a space after colons and commas:\n+\n+``` rust\n+fn foo(a: Bar);\n+\n+MyStruct { foo: 3, bar: 4 }\n+\n+foo(bar, baz);\n+```\n+\n+* Use a space after the opening and before the closing brace for\n+  single line blocks or `struct` expressions:\n+\n+``` rust\n+spawn(proc() { do_something(); })\n+\n+Point { x: 0.1, y: 0.3 }\n+```\n+\n+### Line wrapping\n+\n+* For multiline function signatures, each new line should align with the\n+  first parameter. Multiple parameters per line are permitted:\n+\n+``` rust\n+fn frobnicate(a: Bar, b: Bar,\n+              c: Bar, d: Bar)\n+              -> Bar {\n+    ...\n+}\n+\n+fn foo<T: This,\n+       U: That>(\n+       a: Bar,\n+       b: Bar)\n+       -> Baz {\n+    ...\n+}\n+```\n+\n+* Multiline function invocations generally follow the same rule as for\n+  signatures. However, if the final argument begins a new block, the\n+  contents of the block may begin on a new line, indented one level:\n+\n+``` rust\n+fn foo_bar(a: Bar, b: Bar,\n+           c: |Bar|) -> Bar {\n+    ...\n+}\n+\n+// Same line is fine:\n+foo_bar(x, y, |z| { z.transpose(y) });\n+\n+// Indented body on new line is also fine:\n+foo_bar(x, y, |z| {\n+    z.quux();\n+    z.rotate(x)\n+})\n+```\n+\n+> **[FIXME]** Do we also want to allow the following?\n+>\n+> ```rust\n+> frobnicate(\n+>     arg1,\n+>     arg2,\n+>     arg3)\n+> ```\n+>\n+> This style could ease the conflict between line length and functions\n+> with many parameters (or long method chains).\n+\n+### Matches\n+\n+> * **[Deprecated]** If you have multiple patterns in a single `match`\n+>   arm, write each pattern on a separate line:\n+>\n+>     ``` rust\n+>     match foo {\n+>         bar(_)\n+>         | baz => quux,\n+>         x\n+>         | y\n+>         | z => {\n+>             quuux\n+>         }\n+>     }\n+>     ```\n+\n+### Alignment\n+\n+Idiomatic code should not use extra whitespace in the middle of a line\n+to provide alignment.\n+\n+\n+``` rust\n+// Good\n+struct Foo {\n+    short: f64,\n+    really_long: f64,\n+}\n+\n+// Bad\n+struct Bar {\n+    short:       f64,\n+    really_long: f64,\n+}\n+\n+// Good\n+let a = 0;\n+let radius = 7;\n+\n+// Bad\n+let b        = 0;\n+let diameter = 7;\n+```"}, {"sha": "a21f69414d326b15cb1a617ebba77a1b23807dc4", "filename": "src/doc/style/testing/README.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ftesting%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ftesting%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ftesting%2FREADME.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,5 @@\n+% Testing\n+\n+> **[FIXME]** Add some general remarks about when and how to unit\n+> test, versus other kinds of testing. What are our expectations for\n+> Rust's core libraries?"}, {"sha": "813660d8fdfb945e90196b3c5518d27688e71ce3", "filename": "src/doc/style/testing/unit.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ftesting%2Funit.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ftesting%2Funit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ftesting%2Funit.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,30 @@\n+% Unit testing\n+\n+Unit tests should live in a `test` submodule at the bottom of the module they\n+test. Mark the `test` submodule with `#[cfg(test)]` so it is only compiled when\n+testing.\n+\n+The `test` module should contain:\n+\n+* Imports needed only for testing.\n+* Functions marked with `#[test]` striving for full coverage of the parent module's\n+  definitions.\n+* Auxiliary functions needed for writing the tests.\n+\n+For example:\n+\n+``` rust\n+// Excerpt from std::str\n+\n+#[cfg(test)]\n+mod test {\n+    #[test]\n+    fn test_eq() {\n+        assert!((eq(&\"\".to_owned(), &\"\".to_owned())));\n+        assert!((eq(&\"foo\".to_owned(), &\"foo\".to_owned())));\n+        assert!((!eq(&\"foo\".to_owned(), &\"bar\".to_owned())));\n+    }\n+}\n+```\n+\n+> **[FIXME]** add details about useful macros for testing, e.g. `assert!`"}, {"sha": "28ef2a1832d8bf175682a7709ba6409ae1ec0ea7", "filename": "src/doc/style/todo.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ftodo.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Fstyle%2Ftodo.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ftodo.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,5 @@\n+* [Containers and iteration]()\n+* [The visitor pattern]()\n+* [Concurrency]()\n+* [Documentation]()\n+* [Macros]()"}, {"sha": "d57aff7f4f411fbc9974666127a02150b324301d", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -28,13 +28,14 @@\n     * [Generics](generics.md)\n     * [Traits](traits.md)\n     * [Static and Dynamic Dispatch](static-and-dynamic-dispatch.md)\n+    * [Macros](macros.md)\n     * [Concurrency](concurrency.md)\n     * [Error Handling](error-handling.md)\n     * [Documentation](documentation.md)\n * [III: Advanced Topics](advanced.md)\n     * [FFI](ffi.md)\n     * [Unsafe Code](unsafe.md)\n-    * [Macros](macros.md)\n+    * [Advanced Macros](advanced-macros.md)\n     * [Compiler Plugins](plugins.md)\n * [Conclusion](conclusion.md)\n * [Glossary](glossary.md)"}, {"sha": "aff365051a4eadfc67819f0e9c45487abd1b70ad", "filename": "src/doc/trpl/advanced-macros.md", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,210 @@\n+% Advanced macros\n+\n+This chapter picks up where the [introductory macro chapter](macros.html) left\n+off.\n+\n+# Syntactic requirements\n+\n+Even when Rust code contains un-expanded macros, it can be parsed as a full\n+syntax tree. This property can be very useful for editors and other tools that\n+process code. It also has a few consequences for the design of Rust's macro\n+system.\n+\n+One consequence is that Rust must determine, when it parses a macro invocation,\n+whether the macro stands in for\n+\n+* zero or more items,\n+* zero or more methods,\n+* an expression,\n+* a statement, or\n+* a pattern.\n+\n+A macro invocation within a block could stand for some items, or for an\n+expression / statement. Rust uses a simple rule to resolve this ambiguity. A\n+macro invocation that stands for items must be either\n+\n+* delimited by curly braces, e.g. `foo! { ... }`, or\n+* terminated by a semicolon, e.g. `foo!(...);`\n+\n+Another consequence of pre-expansion parsing is that the macro invocation must\n+consist of valid Rust tokens. Furthermore, parentheses, brackets, and braces\n+must be balanced within a macro invocation. For example, `foo!([)` is\n+forbidden. This allows Rust to know where the macro invocation ends.\n+\n+More formally, the macro invocation body must be a sequence of *token trees*.\n+A token tree is defined recursively as either\n+\n+* a sequence of token trees surrounded by matching `()`, `[]`, or `{}`, or\n+* any other single token.\n+\n+Within a matcher, each metavariable has a *fragment specifier*, identifying\n+which syntactic form it matches.\n+\n+* `ident`: an identifier. Examples: `x`; `foo`.\n+* `path`: a qualified name. Example: `T::SpecialA`.\n+* `expr`: an expression. Examples: `2 + 2`; `if true then { 1 } else { 2 }`; `f(42)`.\n+* `ty`: a type. Examples: `i32`; `Vec<(char, String)>`; `&T`.\n+* `pat`: a pattern. Examples: `Some(t)`; `(17, 'a')`; `_`.\n+* `stmt`: a single statement. Example: `let x = 3`.\n+* `block`: a brace-delimited sequence of statements. Example:\n+  `{ log(error, \"hi\"); return 12; }`.\n+* `item`: an [item][]. Examples: `fn foo() { }`; `struct Bar;`.\n+* `meta`: a \"meta item\", as found in attributes. Example: `cfg(target_os = \"windows\")`.\n+* `tt`: a single token tree.\n+\n+There are additional rules regarding the next token after a metavariable:\n+\n+* `expr` variables must be followed by one of: `=> , ;`\n+* `ty` and `path` variables must be followed by one of: `=> , : = > as`\n+* `pat` variables must be followed by one of: `=> , =`\n+* Other variables may be followed by any token.\n+\n+These rules provide some flexibility for Rust's syntax to evolve without\n+breaking existing macros.\n+\n+The macro system does not deal with parse ambiguity at all. For example, the\n+grammar `$($t:ty)* $e:expr` will always fail to parse, because the parser would\n+be forced to choose between parsing `$t` and parsing `$e`. Changing the\n+invocation syntax to put a distinctive token in front can solve the problem. In\n+this case, you can write `$(T $t:ty)* E $e:exp`.\n+\n+[item]: ../reference.html#items\n+\n+# Scoping and macro import/export\n+\n+Macros are expanded at an early stage in compilation, before name resolution.\n+One downside is that scoping works differently for macros, compared to other\n+constructs in the language.\n+\n+Definition and expansion of macros both happen in a single depth-first,\n+lexical-order traversal of a crate's source. So a macro defined at module scope\n+is visible to any subsequent code in the same module, which includes the body\n+of any subsequent child `mod` items.\n+\n+A macro defined within the body of a single `fn`, or anywhere else not at\n+module scope, is visible only within that item.\n+\n+If a module has the `macro_use` attribute, its macros are also visible in its\n+parent module after the child's `mod` item. If the parent also has `macro_use`\n+then the macros will be visible in the grandparent after the parent's `mod`\n+item, and so forth.\n+\n+The `macro_use` attribute can also appear on `extern crate`. In this context\n+it controls which macros are loaded from the external crate, e.g.\n+\n+```rust,ignore\n+#[macro_use(foo, bar)]\n+extern crate baz;\n+```\n+\n+If the attribute is given simply as `#[macro_use]`, all macros are loaded. If\n+there is no `#[macro_use]` attribute then no macros are loaded. Only macros\n+defined with the `#[macro_export]` attribute may be loaded.\n+\n+To load a crate's macros *without* linking it into the output, use `#[no_link]`\n+as well.\n+\n+An example:\n+\n+```rust\n+macro_rules! m1 { () => (()) }\n+\n+// visible here: m1\n+\n+mod foo {\n+    // visible here: m1\n+\n+    #[macro_export]\n+    macro_rules! m2 { () => (()) }\n+\n+    // visible here: m1, m2\n+}\n+\n+// visible here: m1\n+\n+macro_rules! m3 { () => (()) }\n+\n+// visible here: m1, m3\n+\n+#[macro_use]\n+mod bar {\n+    // visible here: m1, m3\n+\n+    macro_rules! m4 { () => (()) }\n+\n+    // visible here: m1, m3, m4\n+}\n+\n+// visible here: m1, m3, m4\n+# fn main() { }\n+```\n+\n+When this library is loaded with `#[macro_use] extern crate`, only `m2` will\n+be imported.\n+\n+The Rust Reference has a [listing of macro-related\n+attributes](../reference.html#macro--and-plugin-related-attributes).\n+\n+# The variable `$crate`\n+\n+A further difficulty occurs when a macro is used in multiple crates. Say that\n+`mylib` defines\n+\n+```rust\n+pub fn increment(x: u32) -> u32 {\n+    x + 1\n+}\n+\n+#[macro_export]\n+macro_rules! inc_a {\n+    ($x:expr) => ( ::increment($x) )\n+}\n+\n+#[macro_export]\n+macro_rules! inc_b {\n+    ($x:expr) => ( ::mylib::increment($x) )\n+}\n+# fn main() { }\n+```\n+\n+`inc_a` only works within `mylib`, while `inc_b` only works outside the\n+library. Furthermore, `inc_b` will break if the user imports `mylib` under\n+another name.\n+\n+Rust does not (yet) have a hygiene system for crate references, but it does\n+provide a simple workaround for this problem. Within a macro imported from a\n+crate named `foo`, the special macro variable `$crate` will expand to `::foo`.\n+By contrast, when a macro is defined and then used in the same crate, `$crate`\n+will expand to nothing. This means we can write\n+\n+```rust\n+#[macro_export]\n+macro_rules! inc {\n+    ($x:expr) => ( $crate::increment($x) )\n+}\n+# fn main() { }\n+```\n+\n+to define a single macro that works both inside and outside our library. The\n+function name will expand to either `::increment` or `::mylib::increment`.\n+\n+To keep this system simple and correct, `#[macro_use] extern crate ...` may\n+only appear at the root of your crate, not inside `mod`. This ensures that\n+`$crate` is a single identifier.\n+\n+# A final note\n+\n+Macros, as currently implemented, are not for the faint of heart. Even\n+ordinary syntax errors can be more difficult to debug when they occur inside a\n+macro, and errors caused by parse problems in generated code can be very\n+tricky. Invoking the `log_syntax!` macro can help elucidate intermediate\n+states, invoking `trace_macros!(true)` will automatically print those\n+intermediate states out, and passing the flag `--pretty expanded` as a\n+command-line argument to the compiler will show the result of expansion.\n+\n+If Rust's macro system can't do what you need, you may want to write a\n+[compiler plugin](plugins.html) instead. Compared to `macro_rules!`\n+macros, this is significantly more work, the interfaces are much less stable,\n+and the warnings about debugging apply ten-fold. In exchange you get the\n+flexibility of running arbitrary Rust code within the compiler. Syntax\n+extension plugins are sometimes called *procedural macros* for this reason."}, {"sha": "85d67262c4066d9bf78b9d7185b0020fefa23877", "filename": "src/doc/trpl/compound-data-types.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -322,8 +322,8 @@ The `ordering` variable has the type `Ordering`, and so contains one of the\n three values. We then do a bunch of `if`/`else` comparisons to check which\n one it is.\n \n-This `Ordering::Greater` notation is too long. Lets use `use` to import can\n-the `enum` variants instead. This will avoid full scoping:\n+This `Ordering::Greater` notation is too long. Let's use `use` to import the\n+`enum` variants instead. This will avoid full scoping:\n \n ```{rust}\n use std::cmp::Ordering::{self, Equal, Less, Greater};"}, {"sha": "9f8f76e1fea6e2fe597d9661226921466ec4d9ce", "filename": "src/doc/trpl/concurrency.md", "status": "modified", "additions": 22, "deletions": 40, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconcurrency.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -57,13 +57,13 @@ place!\n ## Threads\n \n Rust's standard library provides a library for 'threads', which allow you to\n-run Rust code in parallel. Here's a basic example of using `Thread`:\n+run Rust code in parallel. Here's a basic example of using `std::thread`:\n \n ```\n-use std::thread::Thread;\n+use std::thread;\n \n fn main() {\n-    Thread::scoped(|| {\n+    thread::scoped(|| {\n         println!(\"Hello from a thread!\");\n     });\n }\n@@ -73,10 +73,10 @@ The `Thread::scoped()` method accepts a closure, which is executed in a new\n thread. It's called `scoped` because this thread returns a join guard:\n \n ```\n-use std::thread::Thread;\n+use std::thread;\n \n fn main() {\n-    let guard = Thread::scoped(|| {\n+    let guard = thread::scoped(|| {\n         println!(\"Hello from a thread!\");\n     });\n \n@@ -85,40 +85,22 @@ fn main() {\n ```\n \n When `guard` goes out of scope, it will block execution until the thread is\n-finished. If we didn't want this behaviour, we could use `Thread::spawn()`:\n+finished. If we didn't want this behaviour, we could use `thread::spawn()`:\n \n ```\n-use std::thread::Thread;\n+use std::thread;\n use std::old_io::timer;\n use std::time::Duration;\n \n fn main() {\n-    Thread::spawn(|| {\n+    thread::spawn(|| {\n         println!(\"Hello from a thread!\");\n     });\n \n     timer::sleep(Duration::milliseconds(50));\n }\n ```\n \n-Or call `.detach()`:\n-\n-```\n-use std::thread::Thread;\n-use std::old_io::timer;\n-use std::time::Duration;\n-\n-fn main() {\n-    let guard = Thread::scoped(|| {\n-        println!(\"Hello from a thread!\");\n-    });\n-\n-    guard.detach();\n-\n-    timer::sleep(Duration::milliseconds(50));\n-}\n-```\n-\n We need to `sleep` here because when `main()` ends, it kills all of the\n running threads.\n \n@@ -164,15 +146,15 @@ As an example, here is a Rust program that would have a data race in many\n languages. It will not compile:\n \n ```ignore\n-use std::thread::Thread;\n+use std::thread;\n use std::old_io::timer;\n use std::time::Duration;\n \n fn main() {\n     let mut data = vec![1u32, 2, 3];\n \n     for i in 0..2 {\n-        Thread::spawn(move || {\n+        thread::spawn(move || {\n             data[i] += 1;\n         });\n     }\n@@ -203,7 +185,7 @@ only one person at a time can mutate what's inside. For that, we can use the\n but for a different reason:\n \n ```ignore\n-use std::thread::Thread;\n+use std::thread;\n use std::old_io::timer;\n use std::time::Duration;\n use std::sync::Mutex;\n@@ -213,7 +195,7 @@ fn main() {\n \n     for i in 0..2 {\n         let data = data.lock().unwrap();\n-        Thread::spawn(move || {\n+        thread::spawn(move || {\n             data[i] += 1;\n         });\n     }\n@@ -255,7 +237,7 @@ We can use `Arc<T>` to fix this. Here's the working version:\n \n ```\n use std::sync::{Arc, Mutex};\n-use std::thread::Thread;\n+use std::thread;\n use std::old_io::timer;\n use std::time::Duration;\n \n@@ -264,7 +246,7 @@ fn main() {\n \n     for i in 0us..2 {\n         let data = data.clone();\n-        Thread::spawn(move || {\n+        thread::spawn(move || {\n             let mut data = data.lock().unwrap();\n             data[i] += 1;\n         });\n@@ -280,14 +262,14 @@ thread more closely:\n \n ```\n # use std::sync::{Arc, Mutex};\n-# use std::thread::Thread;\n+# use std::thread;\n # use std::old_io::timer;\n # use std::time::Duration;\n # fn main() {\n #     let data = Arc::new(Mutex::new(vec![1u32, 2, 3]));\n #     for i in 0us..2 {\n #         let data = data.clone();\n-Thread::spawn(move || {\n+thread::spawn(move || {\n     let mut data = data.lock().unwrap();\n     data[i] += 1;\n });\n@@ -315,7 +297,7 @@ than waiting for a specific time:\n \n ```\n use std::sync::{Arc, Mutex};\n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc;\n \n fn main() {\n@@ -326,7 +308,7 @@ fn main() {\n     for _ in 0..10 {\n         let (data, tx) = (data.clone(), tx.clone());\n \n-        Thread::spawn(move || {\n+        thread::spawn(move || {\n             let mut data = data.lock().unwrap();\n             *data += 1;\n \n@@ -348,7 +330,7 @@ is `Send` over the channel!\n \n ```\n use std::sync::{Arc, Mutex};\n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc;\n \n fn main() {\n@@ -357,7 +339,7 @@ fn main() {\n     for _ in 0..10 {\n         let tx = tx.clone();\n \n-        Thread::spawn(move || {\n+        thread::spawn(move || {\n             let answer = 42u32;\n \n             tx.send(answer);\n@@ -378,9 +360,9 @@ A `panic!` will crash the currently executing thread. You can use Rust's\n threads as a simple isolation mechanism:\n \n ```\n-use std::thread::Thread;\n+use std::thread;\n \n-let result = Thread::scoped(move || {\n+let result = thread::spawn(move || {\n     panic!(\"oops!\");\n }).join();\n "}, {"sha": "ded30063ebaf08fbf6a539374a1a978d70699172", "filename": "src/doc/trpl/documentation.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdocumentation.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -15,7 +15,7 @@ comments\":\n // the \"link\" crate attribute is currently required for rustdoc, but normally\n // isn't needed.\n #![crate_id = \"universe\"]\n-#![crate_type=\"lib\"]\n+#![crate_type= \"lib\"]\n \n //! Tools for dealing with universes (this is a doc comment, and is shown on\n //! the crate index page. The ! makes it apply to the parent of the comment,"}, {"sha": "45c08af04f8773c6be6469cf0b2b7031ab27c735", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -4,19 +4,19 @@ Let's talk about loops.\n \n Remember Rust's `for` loop? Here's an example:\n \n-```{rust}\n+```rust\n for x in 0..10 {\n     println!(\"{}\", x);\n }\n ```\n \n-Now that you know more Rust, we can talk in detail about how this works. The\n-`range` function returns an *iterator*. An iterator is something that we can\n+Now that you know more Rust, we can talk in detail about how this works.\n+Ranges (the `0..10`) are 'iterators'. An iterator is something that we can\n call the `.next()` method on repeatedly, and it gives us a sequence of things.\n \n Like this:\n \n-```{rust}\n+```rust\n let mut range = 0..10;\n \n loop {\n@@ -29,12 +29,12 @@ loop {\n }\n ```\n \n-We make a mutable binding to the return value of `range`, which is our iterator.\n-We then `loop`, with an inner `match`. This `match` is used on the result of\n-`range.next()`, which gives us a reference to the next value of the iterator.\n-`next` returns an `Option<i32>`, in this case, which will be `Some(i32)` when\n-we have a value and `None` once we run out. If we get `Some(i32)`, we print it\n-out, and if we get `None`, we `break` out of the loop.\n+We make a mutable binding to the range, which is our iterator. We then `loop`,\n+with an inner `match`. This `match` is used on the result of `range.next()`,\n+which gives us a reference to the next value of the iterator. `next` returns an\n+`Option<i32>`, in this case, which will be `Some(i32)` when we have a value and\n+`None` once we run out. If we get `Some(i32)`, we print it out, and if we get\n+`None`, we `break` out of the loop.\n \n This code sample is basically the same as our `for` loop version. The `for`\n loop is just a handy way to write this `loop`/`match`/`break` construct.\n@@ -43,13 +43,13 @@ loop is just a handy way to write this `loop`/`match`/`break` construct.\n own iterator involves implementing the `Iterator` trait. While doing that is\n outside of the scope of this guide, Rust provides a number of useful iterators\n to accomplish various tasks. Before we talk about those, we should talk about a\n-Rust anti-pattern. And that's `range`.\n+Rust anti-pattern. And that's using ranges like this.\n \n-Yes, we just talked about how `range` is cool. But `range` is also very\n-primitive. For example, if you needed to iterate over the contents of\n-a vector, you may be tempted to write this:\n+Yes, we just talked about how ranges are cool. But ranges are also very\n+primitive. For example, if you needed to iterate over the contents of a vector,\n+you may be tempted to write this:\n \n-```{rust}\n+```rust\n let nums = vec![1, 2, 3];\n \n for i in 0..nums.len() {\n@@ -61,7 +61,7 @@ This is strictly worse than using an actual iterator. The `.iter()` method on\n vectors returns an iterator which iterates through a reference to each element\n of the vector in turn. So write this:\n \n-```{rust}\n+```rust\n let nums = vec![1, 2, 3];\n \n for num in nums.iter() {\n@@ -83,7 +83,7 @@ works. `num` is actually of type `&i32`. That is, it's a reference to an `i32`,\n not an `i32` itself. `println!` handles the dereferencing for us, so we don't\n see it. This code works fine too:\n \n-```{rust}\n+```rust\n let nums = vec![1, 2, 3];\n \n for num in nums.iter() {\n@@ -97,7 +97,7 @@ involve making a copy of the data and giving us the copy. With references,\n we're just borrowing a reference to the data, and so it's just passing\n a reference, without needing to do the copy.\n \n-So, now that we've established that `range` is often not what you want, let's\n+So, now that we've established that ranges are often not what you want, let's\n talk about what you do want instead.\n \n There are three broad classes of things that are relevant here: iterators,\n@@ -108,8 +108,7 @@ There are three broad classes of things that are relevant here: iterators,\n   different output sequence.\n * *consumers* operate on an iterator, producing some final set of values.\n \n-Let's talk about consumers first, since you've already seen an iterator,\n-`range`.\n+Let's talk about consumers first, since you've already seen an iterator, ranges.\n \n ## Consumers\n \n@@ -118,7 +117,7 @@ The most common consumer is `collect()`. This code doesn't quite compile,\n but it shows the intention:\n \n ```{rust,ignore}\n-let one_to_one_hundred = (1..101i32).collect();\n+let one_to_one_hundred = (1..101).collect();\n ```\n \n As you can see, we call `collect()` on our iterator. `collect()` takes\n@@ -127,8 +126,8 @@ of the results. So why won't this compile? Rust can't determine what\n type of things you want to collect, and so you need to let it know.\n Here's the version that does compile:\n \n-```{rust}\n-let one_to_one_hundred = (1..101i32).collect::<Vec<i32>>();\n+```rust\n+let one_to_one_hundred = (1..101).collect::<Vec<i32>>();\n ```\n \n If you remember, the `::<>` syntax allows us to give a type hint,\n@@ -137,7 +136,7 @@ need to use the whole type, though. Using a `_` will let you provide\n a partial hint:\n \n ```rust\n-let one_to_one_hundred = range(1, 101).collect::<Vec<_>>();\n+let one_to_one_hundred = (1..101).collect::<Vec<_>>();\n ```\n \n This says \"Collect into a `Vec<T>`, please, but infer what the `T` is for me.\"\n@@ -146,8 +145,8 @@ This says \"Collect into a `Vec<T>`, please, but infer what the `T` is for me.\"\n `collect()` is the most common consumer, but there are others too. `find()`\n is one:\n \n-```{rust}\n-let greater_than_forty_two = (0..100i32)\n+```rust\n+let greater_than_forty_two = (0..100)\n                              .find(|x| *x > 42);\n \n match greater_than_forty_two {\n@@ -163,9 +162,8 @@ element, `find` returns an `Option` rather than the element itself.\n \n Another important consumer is `fold`. Here's what it looks like:\n \n-```{rust}\n-let sum = (1..4)\n-              .fold(0, |sum, x| sum + x);\n+```rust\n+let sum = (1..4).fold(0, |sum, x| sum + x);\n ```\n \n `fold()` is a consumer that looks like this:\n@@ -187,7 +185,7 @@ in this iterator:\n \n We called `fold()` with these arguments:\n \n-```{rust}\n+```rust\n # (1..4)\n .fold(0, |sum, x| sum + x);\n ```\n@@ -218,25 +216,25 @@ are *lazy* and don't need to generate all of the values upfront.\n This code, for example, does not actually generate the numbers\n `1-100`, and just creates a value that represents the sequence:\n \n-```{rust}\n+```rust\n let nums = 1..100;\n ```\n \n Since we didn't do anything with the range, it didn't generate the sequence.\n Let's add the consumer:\n \n-```{rust}\n+```rust\n let nums = (1..100).collect::<Vec<i32>>();\n ```\n \n Now, `collect()` will require that the range gives it some numbers, and so\n it will do the work of generating the sequence.\n \n-A range is one of two basic iterators that you'll see. The other is `iter()`,\n+Ranges are one of two basic iterators that you'll see. The other is `iter()`,\n which you've used before. `iter()` can turn a vector into a simple iterator\n that gives you each element in turn:\n \n-```{rust}\n+```rust\n let nums = [1, 2, 3];\n \n for num in nums.iter() {\n@@ -247,7 +245,7 @@ for num in nums.iter() {\n These two basic iterators should serve you well. There are some more\n advanced iterators, including ones that are infinite. Like `count`:\n \n-```{rust}\n+```rust\n std::iter::count(1, 5);\n ```\n \n@@ -265,15 +263,15 @@ we need to talk about with regards to iterators. Let's get to it!\n a new iterator. The simplest one is called `map`:\n \n ```{rust,ignore}\n-(1..100i32).map(|x| x + 1);\n+(1..100).map(|x| x + 1);\n ```\n \n `map` is called upon another iterator, and produces a new iterator where each\n element reference has the closure it's been given as an argument called on it.\n So this would give us the numbers from `2-100`. Well, almost! If you\n compile the example, you'll get a warning:\n \n-```{notrust,ignore}\n+```text\n warning: unused result which must be used: iterator adaptors are lazy and\n          do nothing unless consumed, #[warn(unused_must_use)] on by default\n (1..100).map(|x| x + 1);\n@@ -295,15 +293,15 @@ iterator over the next `n` elements of the original iterator, note that this\n has no side effect on the original iterator. Let's try it out with our infinite\n iterator from before, `count()`:\n \n-```{rust}\n+```rust\n for i in std::iter::count(1, 5).take(5) {\n     println!(\"{}\", i);\n }\n ```\n \n This will print\n \n-```{notrust,ignore}\n+```text\n 1\n 6\n 11\n@@ -315,8 +313,8 @@ This will print\n returns `true` or `false`. The new iterator `filter()` produces\n only the elements that that closure returns `true` for:\n \n-```{rust}\n-for i in (1..100i32).filter(|&x| x % 2 == 0) {\n+```rust\n+for i in (1..100).filter(|&x| x % 2 == 0) {\n     println!(\"{}\", i);\n }\n ```\n@@ -330,8 +328,8 @@ itself.)\n You can chain all three things together: start with an iterator, adapt it\n a few times, and then consume the result. Check it out:\n \n-```{rust}\n-(1..1000i32)\n+```rust\n+(1..1000)\n     .filter(|&x| x % 2 == 0)\n     .filter(|&x| x % 3 == 0)\n     .take(5)"}, {"sha": "ce6fa3ce949cd7a1f0878ca79bf20358a5127ba1", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 300, "deletions": 523, "changes": 823, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -1,588 +1,365 @@\n % Macros\n \n-# Introduction\n-\n-Functions are the primary tool that programmers can use to build abstractions.\n-Sometimes, however, programmers want to abstract over compile-time syntax\n-rather than run-time values.\n-Macros provide syntactic abstraction.\n-For an example of how this can be useful, consider the following two code fragments,\n-which both pattern-match on their input and both return early in one case,\n-doing nothing otherwise:\n-\n-~~~~\n-# enum T { SpecialA(u32), SpecialB(u32) }\n-# fn f() -> u32 {\n-# let input_1 = T::SpecialA(0);\n-# let input_2 = T::SpecialA(0);\n-match input_1 {\n-    T::SpecialA(x) => { return x; }\n-    _ => {}\n-}\n-// ...\n-match input_2 {\n-    T::SpecialB(x) => { return x; }\n-    _ => {}\n-}\n-# return 0;\n-# }\n-~~~~\n-\n-This code could become tiresome if repeated many times.\n-However, no function can capture its functionality to make it possible\n-to abstract the repetition away.\n-Rust's macro system, however, can eliminate the repetition. Macros are\n-lightweight custom syntax extensions, themselves defined using the\n-`macro_rules!` syntax extension. The following `early_return` macro captures\n-the pattern in the above code:\n-\n-~~~~\n-# enum T { SpecialA(u32), SpecialB(u32) }\n-# fn f() -> u32 {\n-# let input_1 = T::SpecialA(0);\n-# let input_2 = T::SpecialA(0);\n-macro_rules! early_return {\n-    ($inp:expr, $sp:path) => ( // invoke it like `(input_5, SpecialE)`\n-        match $inp {\n-            $sp(x) => { return x; }\n-            _ => {}\n-        }\n-    );\n-}\n-// ...\n-early_return!(input_1, T::SpecialA);\n-// ...\n-early_return!(input_2, T::SpecialB);\n-# return 0;\n-# }\n-# fn main() {}\n-~~~~\n-\n-Macros are defined in pattern-matching style: in the above example, the text\n-`($inp:expr, $sp:path)` that appears on the left-hand side of the `=>` is the\n-*macro invocation syntax*, a pattern denoting how to write a call to the\n-macro. The text on the right-hand side of the `=>`, beginning with `match\n-$inp`, is the *macro transcription syntax*: what the macro expands to.\n-\n-# Invocation syntax\n-\n-The macro invocation syntax specifies the syntax for the arguments to the\n-macro. It appears on the left-hand side of the `=>` in a macro definition. It\n-conforms to the following rules:\n-\n-1. It must be surrounded by parentheses.\n-2. `$` has special meaning (described below).\n-3. The `()`s, `[]`s, and `{}`s it contains must balance. For example, `([)` is\n-forbidden.\n-4. Some arguments can be followed only by a limited set of separators, to\n-avoid ambiguity (described below).\n-\n-Otherwise, the invocation syntax is free-form.\n-\n-To take a fragment of Rust code as an argument, write `$` followed by a name\n- (for use on the right-hand side), followed by a `:`, followed by a *fragment\n- specifier*. The fragment specifier denotes the sort of fragment to match. The\n- most common fragment specifiers are:\n-\n-* `ident` (an identifier, referring to a variable or item. Examples: `f`, `x`,\n-  `foo`.)\n-* `expr` (an expression. Examples: `2 + 2`; `if true then { 1 } else { 2 }`;\n-  `f(42)`.)\n-* `ty` (a type. Examples: `i32`, `Vec<(char, String)>`, `&T`.)\n-* `path` (a path to struct or enum variant. Example: `T::SpecialA`)\n-* `pat` (a pattern, usually appearing in a `match` or on the left-hand side of\n-  a declaration. Examples: `Some(t)`; `(17, 'a')`; `_`.)\n-* `block` (a sequence of actions. Example: `{ log(error, \"hi\"); return 12; }`)\n-\n-The parser interprets any token that's not preceded by a `$` literally. Rust's usual\n-rules of tokenization apply,\n-\n-So `($x:ident -> (($e:expr)))`, though excessively fancy, would designate a macro\n-that could be invoked like: `my_macro!(i->(( 2+2 )))`.\n-\n-To avoid ambiguity, macro invocation syntax must conform to the following rules:\n-\n-* `expr` must be followed by `=>`, `,` or `;`.\n-* `ty` and `path` must be followed by `=>`, `,`, `:`, `=`, `>` or `as`.\n-* `pat` must be followed by `=>`, `,` or `=`.\n-* `ident` and `block` can be followed by any token.\n-\n-## Invocation location\n-\n-A macro invocation may take the place of (and therefore expand to) an\n-expression, item, statement, or pattern.  The Rust parser will parse the macro\n-invocation as a \"placeholder\" for whichever syntactic form is appropriate for\n-the location.\n-\n-At expansion time, the output of the macro will be parsed as whichever of the\n-three nonterminals it stands in for. This means that a single macro might,\n-for example, expand to an item or an expression, depending on its arguments\n-(and cause a syntax error if it is called with the wrong argument for its\n-location). Although this behavior sounds excessively dynamic, it is known to\n-be useful under some circumstances.\n-\n-\n-# Transcription syntax\n-\n-The right-hand side of the `=>` follows the same rules as the left-hand side,\n-except that a `$` need only be followed by the name of the syntactic fragment\n-to transcribe into the macro expansion; its type need not be repeated.\n-\n-The right-hand side must be enclosed by delimiters, which the transcriber ignores.\n-Therefore `() => ((1,2,3))` is a macro that expands to a tuple expression,\n-`() => (let $x=$val)` is a macro that expands to a statement,\n-and `() => (1,2,3)` is a macro that expands to a syntax error\n-(since the transcriber interprets the parentheses on the right-hand-size as delimiters,\n-and `1,2,3` is not a valid Rust expression on its own).\n-\n-Except for permissibility of `$name` (and `$(...)*`, discussed below), the\n-right-hand side of a macro definition is ordinary Rust syntax. In particular,\n-macro invocations (including invocations of the macro currently being defined)\n-are permitted in expression, statement, and item locations. However, nothing\n-else about the code is examined or executed by the macro system; execution\n-still has to wait until run-time.\n-\n-## Interpolation location\n-\n-The interpolation `$argument_name` may appear in any location consistent with\n-its fragment specifier (i.e., if it is specified as `ident`, it may be used\n-anywhere an identifier is permitted).\n-\n-# Multiplicity\n-\n-## Invocation\n-\n-Going back to the motivating example, recall that `early_return` expanded into\n-a `match` that would `return` if the `match`'s scrutinee matched the\n-\"special case\" identifier provided as the second argument to `early_return`,\n-and do nothing otherwise. Now suppose that we wanted to write a\n-version of `early_return` that could handle a variable number of \"special\"\n-cases.\n-\n-The syntax `$(...)*` on the left-hand side of the `=>` in a macro definition\n-accepts zero or more occurrences of its contents. It works much\n-like the `*` operator in regular expressions. It also supports a\n-separator token (a comma-separated list could be written `$(...),*`), and `+`\n-instead of `*` to mean \"at least one\".\n-\n-~~~~\n-# enum T { SpecialA(u32), SpecialB(u32), SpecialC(u32), SpecialD(u32) }\n-# fn f() -> u32 {\n-# let input_1 = T::SpecialA(0);\n-# let input_2 = T::SpecialA(0);\n-macro_rules! early_return {\n-    ($inp:expr, [ $($sp:path),+ ]) => (\n-        match $inp {\n+By now you've learned about many of the tools Rust provides for abstracting and\n+reusing code. These units of code reuse have a rich semantic structure. For\n+example, functions have a type signature, type parameters have trait bounds,\n+and overloaded functions must belong to a particular trait.\n+\n+This structure means that Rust's core abstractions have powerful compile-time\n+correctness checking. But this comes at the price of reduced flexibility. If\n+you visually identify a pattern of repeated code, you may find it's difficult\n+or cumbersome to express that pattern as a generic function, a trait, or\n+anything else within Rust's semantics.\n+\n+Macros allow us to abstract at a *syntactic* level. A macro invocation is\n+shorthand for an \"expanded\" syntactic form. This expansion happens early in\n+compilation, before any static checking. As a result, macros can capture many\n+patterns of code reuse that Rust's core abstractions cannot.\n+\n+The drawback is that macro-based code can be harder to understand, because\n+fewer of the built-in rules apply. Like an ordinary function, a well-behaved\n+macro can be used without understanding its implementation. However, it can be\n+difficult to design a well-behaved macro!  Additionally, compiler errors in\n+macro code are harder to interpret, because they describe problems in the\n+expanded code, not the source-level form that developers use.\n+\n+These drawbacks make macros something of a \"feature of last resort\". That's not\n+to say that macros are bad; they are part of Rust because sometimes they're\n+needed for truly concise, well-abstracted code. Just keep this tradeoff in\n+mind.\n+\n+# Defining a macro\n+\n+You may have seen the `vec!` macro, used to initialize a [vector][] with any\n+number of elements.\n+\n+[vector]: arrays-vectors-and-slices.html\n+\n+```rust\n+let x: Vec<u32> = vec![1, 2, 3];\n+# assert_eq!(&[1,2,3], &x);\n+```\n+\n+This can't be an ordinary function, because it takes any number of arguments.\n+But we can imagine it as syntactic shorthand for\n+\n+```rust\n+let x: Vec<u32> = {\n+    let mut temp_vec = Vec::new();\n+    temp_vec.push(1);\n+    temp_vec.push(2);\n+    temp_vec.push(3);\n+    temp_vec\n+};\n+# assert_eq!(&[1,2,3], &x);\n+```\n+\n+We can implement this shorthand, using a macro: [^actual]\n+\n+[^actual]: The actual definition of `vec!` in libcollections differs from the\n+           one presented here, for reasons of efficiency and reusability. Some\n+           of these are mentioned in the [advanced macros chapter][].\n+\n+```rust\n+macro_rules! vec {\n+    ( $( $x:expr ),* ) => {\n+        {\n+            let mut temp_vec = Vec::new();\n             $(\n-                $sp(x) => { return x; }\n-            )+\n-            _ => {}\n+                temp_vec.push($x);\n+            )*\n+            temp_vec\n         }\n-    )\n-}\n-// ...\n-early_return!(input_1, [T::SpecialA,T::SpecialC,T::SpecialD]);\n-// ...\n-early_return!(input_2, [T::SpecialB]);\n-# return 0;\n-# }\n-# fn main() {}\n-~~~~\n-\n-### Transcription\n-\n-As the above example demonstrates, `$(...)*` is also valid on the right-hand\n-side of a macro definition. The behavior of `*` in transcription,\n-especially in cases where multiple `*`s are nested, and multiple different\n-names are involved, can seem somewhat magical and unintuitive at first. The\n-system that interprets them is called \"Macro By Example\". The two rules to\n-keep in mind are (1) the behavior of `$(...)*` is to walk through one \"layer\"\n-of repetitions for all of the `$name`s it contains in lockstep, and (2) each\n-`$name` must be under at least as many `$(...)*`s as it was matched against.\n-If it is under more, it'll be repeated, as appropriate.\n-\n-## Parsing limitations\n-\n-\n-For technical reasons, there are two limitations to the treatment of syntax\n-fragments by the macro parser:\n-\n-1. The parser will always parse as much as possible of a Rust syntactic\n-fragment. For example, if the comma were omitted from the syntax of\n-`early_return!` above, `input_1 [` would've been interpreted as the beginning\n-of an array index. In fact, invoking the macro would have been impossible.\n-2. The parser must have eliminated all ambiguity by the time it reaches a\n-`$name:fragment_specifier` declaration. This limitation can result in parse\n-errors when declarations occur at the beginning of, or immediately after,\n-a `$(...)*`. For example, the grammar `$($t:ty)* $e:expr` will always fail to\n-parse because the parser would be forced to choose between parsing `t` and\n-parsing `e`. Changing the invocation syntax to require a distinctive token in\n-front can solve the problem. In the above example, `$(T $t:ty)* E $e:exp`\n-solves the problem.\n-\n-# Macro argument pattern matching\n-\n-## Motivation\n-\n-Now consider code like the following:\n-\n-~~~~\n-# enum T1 { Good1(T2, u32), Bad1}\n-# struct T2 { body: T3 }\n-# enum T3 { Good2(u32), Bad2}\n-# fn f(x: T1) -> u32 {\n-match x {\n-    T1::Good1(g1, val) => {\n-        match g1.body {\n-            T3::Good2(result) => {\n-                // complicated stuff goes here\n-                return result + val;\n-            },\n-            _ => panic!(\"Didn't get good_2\")\n-        }\n-    }\n-    _ => return 0 // default value\n+    };\n }\n+# fn main() {\n+#     assert_eq!(&[1,2,3], &vec![1,2,3]);\n # }\n-# fn main() {}\n-~~~~\n-\n-All the complicated stuff is deeply indented, and the error-handling code is\n-separated from matches that fail. We'd like to write a macro that performs\n-a match, but with a syntax that suits the problem better. The following macro\n-can solve the problem:\n-\n-~~~~\n-macro_rules! biased_match {\n-    // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\n-    ( ($e:expr) -> ($p:pat) else $err:stmt ;\n-      binds $bind_res:ident\n-    ) => (\n-        let $bind_res = match $e {\n-            $p => ( $bind_res ),\n-            _ => { $err }\n-        };\n-    );\n-    // more than one name; use a tuple\n-    ( ($e:expr) -> ($p:pat) else $err:stmt ;\n-      binds $( $bind_res:ident ),*\n-    ) => (\n-        let ( $( $bind_res ),* ) = match $e {\n-            $p => ( $( $bind_res ),* ),\n-            _ => { $err }\n-        };\n-    )\n-}\n+```\n \n-# enum T1 { Good1(T2, u32), Bad1}\n-# struct T2 { body: T3 }\n-# enum T3 { Good2(u32), Bad2}\n-# fn f(x: T1) -> u32 {\n-biased_match!((x)       -> (T1::Good1(g1, val)) else { return 0 };\n-              binds g1, val );\n-biased_match!((g1.body) -> (T3::Good2(result) )\n-                  else { panic!(\"Didn't get good_2\") };\n-              binds result );\n-// complicated stuff goes here\n-return result + val;\n-# }\n-# fn main() {}\n-~~~~\n-\n-This solves the indentation problem. But if we have a lot of chained matches\n-like this, we might prefer to write a single macro invocation. The input\n-pattern we want is clear:\n-\n-~~~~\n-# fn main() {}\n-# macro_rules! b {\n-    ( $( ($e:expr) -> ($p:pat) else $err:stmt ; )*\n-      binds $( $bind_res:ident ),*\n-    )\n-# => (0) }\n-~~~~\n-\n-However, it's not possible to directly expand to nested match statements. But\n-there is a solution.\n-\n-## The recursive approach to macro writing\n-\n-A macro may accept multiple different input grammars. The first one to\n-successfully match the actual argument to a macro invocation is the one that\n-\"wins\".\n-\n-In the case of the example above, we want to write a recursive macro to\n-process the semicolon-terminated lines, one-by-one. So, we want the following\n-input patterns:\n-\n-~~~~\n-# macro_rules! b {\n-    ( binds $( $bind_res:ident ),* )\n-# => (0) }\n-# fn main() {}\n-~~~~\n-\n-...and:\n-\n-~~~~\n-# fn main() {}\n-# macro_rules! b {\n-    (    ($e     :expr) -> ($p     :pat) else $err     :stmt ;\n-      $( ($e_rest:expr) -> ($p_rest:pat) else $err_rest:stmt ; )*\n-      binds  $( $bind_res:ident ),*\n-    )\n-# => (0) }\n-~~~~\n-\n-The resulting macro looks like this. Note that the separation into\n-`biased_match!` and `biased_match_rec!` occurs only because we have an outer\n-piece of syntax (the `let`) which we only want to transcribe once.\n-\n-~~~~\n-# fn main() {\n+Whoa, that's a lot of new syntax! Let's break it down.\n \n-macro_rules! biased_match_rec {\n-    // Handle the first layer\n-    (   ($e     :expr) -> ($p     :pat) else $err     :stmt ;\n-     $( ($e_rest:expr) -> ($p_rest:pat) else $err_rest:stmt ; )*\n-     binds $( $bind_res:ident ),*\n-    ) => (\n-        match $e {\n-            $p => {\n-                // Recursively handle the next layer\n-                biased_match_rec!($( ($e_rest) -> ($p_rest) else $err_rest ; )*\n-                                  binds $( $bind_res ),*\n-                )\n-            }\n-            _ => { $err }\n-        }\n-    );\n-    // Produce the requested values\n-    ( binds $( $bind_res:ident ),* ) => ( ($( $bind_res ),*) )\n-}\n+```ignore\n+macro_rules! vec { ... }\n+```\n \n-// Wrap the whole thing in a `let`.\n-macro_rules! biased_match {\n-    // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\n-    ( $( ($e:expr) -> ($p:pat) else $err:stmt ; )*\n-      binds $bind_res:ident\n-    ) => (\n-        let $bind_res = biased_match_rec!(\n-            $( ($e) -> ($p) else $err ; )*\n-            binds $bind_res\n-        );\n-    );\n-    // more than one name: use a tuple\n-    ( $( ($e:expr) -> ($p:pat) else $err:stmt ; )*\n-      binds  $( $bind_res:ident ),*\n-    ) => (\n-        let ( $( $bind_res ),* ) = biased_match_rec!(\n-            $( ($e) -> ($p) else $err ; )*\n-            binds $( $bind_res ),*\n-        );\n-    )\n-}\n+This says we're defining a macro named `vec`, much as `fn vec` would define a\n+function named `vec`. In prose, we informally write a macro's name with an\n+exclamation point, e.g. `vec!`. The exclamation point is part of the invocation\n+syntax and serves to distinguish a macro from an ordinary function.\n \n+## Matching\n \n-# enum T1 { Good1(T2, u32), Bad1}\n-# struct T2 { body: T3 }\n-# enum T3 { Good2(u32), Bad2}\n-# fn f(x: T1) -> u32 {\n-biased_match!(\n-    (x)       -> (T1::Good1(g1, val)) else { return 0 };\n-    (g1.body) -> (T3::Good2(result) ) else { panic!(\"Didn't get Good2\") };\n-    binds val, result );\n-// complicated stuff goes here\n-return result + val;\n-# }\n-# }\n-~~~~\n-\n-This technique applies to many cases where transcribing a result all at once is not possible.\n-The resulting code resembles ordinary functional programming in some respects,\n-but has some important differences from functional programming.\n-\n-The first difference is important, but also easy to forget: the transcription\n-(right-hand) side of a `macro_rules!` rule is literal syntax, which can only\n-be executed at run-time. If a piece of transcription syntax does not itself\n-appear inside another macro invocation, it will become part of the final\n-program. If it is inside a macro invocation (for example, the recursive\n-invocation of `biased_match_rec!`), it does have the opportunity to affect\n-transcription, but only through the process of attempted pattern matching.\n-\n-The second, related, difference is that the evaluation order of macros feels\n-\"backwards\" compared to ordinary programming. Given an invocation\n-`m1!(m2!())`, the expander first expands `m1!`, giving it as input the literal\n-syntax `m2!()`. If it transcribes its argument unchanged into an appropriate\n-position (in particular, not as an argument to yet another macro invocation),\n-the expander will then proceed to evaluate `m2!()` (along with any other macro\n-invocations `m1!(m2!())` produced).\n+The macro is defined through a series of *rules*, which are pattern-matching\n+cases. Above, we had\n \n-# Hygiene\n+```ignore\n+( $( $x:expr ),* ) => { ... };\n+```\n \n-To prevent clashes, rust implements\n-[hygienic macros](http://en.wikipedia.org/wiki/Hygienic_macro).\n+This is like a `match` expression arm, but the matching happens on Rust syntax\n+trees, at compile time. The semicolon is optional on the last (here, only)\n+case. The \"pattern\" on the left-hand side of `=>` is known as a *matcher*.\n+These have [their own little grammar] within the language.\n \n-As an example, `loop` and `for-loop` labels (discussed in the lifetimes guide)\n-will not clash. The following code will print \"Hello!\" only once:\n+[their own little grammar]: ../reference.html#macros\n \n-~~~\n-macro_rules! loop_x {\n-    ($e: expr) => (\n-        // $e will not interact with this 'x\n-        'x: loop {\n-            println!(\"Hello!\");\n-            $e\n-        }\n-    );\n+The matcher `$x:expr` will match any Rust expression, binding that syntax tree\n+to the *metavariable* `$x`. The identifier `expr` is a *fragment specifier*;\n+the full possibilities are enumerated in the [advanced macros chapter][].\n+Surrounding the matcher with `$(...),*` will match zero or more expressions,\n+separated by commas.\n+\n+Aside from the special matcher syntax, any Rust tokens that appear in a matcher\n+must match exactly. For example,\n+\n+```rust\n+macro_rules! foo {\n+    (x => $e:expr) => (println!(\"mode X: {}\", $e));\n+    (y => $e:expr) => (println!(\"mode Y: {}\", $e));\n }\n \n fn main() {\n-    'x: loop {\n-        loop_x!(break 'x);\n-        println!(\"I am never printed.\");\n-    }\n+    foo!(y => 3);\n }\n-~~~\n+```\n \n-The two `'x` names did not clash, which would have caused the loop\n-to print \"I am never printed\" and to run forever.\n+will print\n \n-# Scoping and macro import/export\n+```text\n+mode Y: 3\n+```\n+\n+With\n \n-Macros are expanded at an early stage in compilation, before name resolution.\n-One downside is that scoping works differently for macros, compared to other\n-constructs in the language.\n+```rust,ignore\n+foo!(z => 3);\n+```\n \n-Definition and expansion of macros both happen in a single depth-first,\n-lexical-order traversal of a crate's source. So a macro defined at module scope\n-is visible to any subsequent code in the same module, which includes the body\n-of any subsequent child `mod` items.\n+we get the compiler error\n \n-A macro defined within the body of a single `fn`, or anywhere else not at\n-module scope, is visible only within that item.\n+```text\n+error: no rules expected the token `z`\n+```\n \n-If a module has the `macro_use` attribute, its macros are also visible in its\n-parent module after the child's `mod` item. If the parent also has `macro_use`\n-then the macros will be visible in the grandparent after the parent's `mod`\n-item, and so forth.\n+## Expansion\n \n-The `macro_use` attribute can also appear on `extern crate`.  In this context\n-it controls which macros are loaded from the external crate, e.g.\n+The right-hand side of a macro rule is ordinary Rust syntax, for the most part.\n+But we can splice in bits of syntax captured by the matcher. From the original\n+example:\n \n-```rust,ignore\n-#[macro_use(foo, bar)]\n-extern crate baz;\n+```ignore\n+$(\n+    temp_vec.push($x);\n+)*\n ```\n \n-If the attribute is given simply as `#[macro_use]`, all macros are loaded.  If\n-there is no `#[macro_use]` attribute then no macros are loaded.  Only macros\n-defined with the `#[macro_export]` attribute may be loaded.\n+Each matched expression `$x` will produce a single `push` statement in the\n+macro expansion. The repetition in the expansion proceeds in \"lockstep\" with\n+repetition in the matcher (more on this in a moment).\n \n-To load a crate's macros *without* linking it into the output, use `#[no_link]`\n-as well.\n+Because `$x` was already declared as matching an expression, we don't repeat\n+`:expr` on the right-hand side. Also, we don't include a separating comma as\n+part of the repetition operator. Instead, we have a terminating semicolon\n+within the repeated block.\n \n-An example:\n+Another detail: the `vec!` macro has *two* pairs of braces on the right-hand\n+side. They are often combined like so:\n \n-```rust\n-macro_rules! m1 { () => (()) }\n+```ignore\n+macro_rules! foo {\n+    () => {{\n+        ...\n+    }}\n+}\n+```\n+\n+The outer braces are part of the syntax of `macro_rules!`. In fact, you can use\n+`()` or `[]` instead. They simply delimit the right-hand side as a whole.\n+\n+The inner braces are part of the expanded syntax. Remember, the `vec!` macro is\n+used in an expression context. To write an expression with multiple statements,\n+including `let`-bindings, we use a block. If your macro expands to a single\n+expression, you don't need this extra layer of braces.\n+\n+Note that we never *declared* that the macro produces an expression. In fact,\n+this is not determined until we use the macro as an expression. With care, you\n+can write a macro whose expansion works in several contexts. For example,\n+shorthand for a data type could be valid as either an expression or a pattern.\n+\n+## Repetition\n \n-// visible here: m1\n+The repetition behavior can seem somewhat magical, especially when multiple\n+names are bound at multiple nested levels of repetition. The two rules to keep\n+in mind are:\n \n-mod foo {\n-    // visible here: m1\n+1. the behavior of `$(...)*` is to walk through one \"layer\" of repetitions, for\n+all of the `$name`s it contains, in lockstep, and\n+2. each `$name` must be under at least as many `$(...)*`s as it was matched\n+against. If it is under more, it'll be duplicated, as appropriate.\n \n-    #[macro_export]\n-    macro_rules! m2 { () => (()) }\n+This baroque macro illustrates the duplication of variables from outer\n+repetition levels.\n+\n+```rust\n+macro_rules! o_O {\n+    (\n+        $(\n+            $x:expr; [ $( $y:expr ),* ]\n+        );*\n+    ) => {\n+        &[ $($( $x + $y ),*),* ]\n+    }\n+}\n+\n+fn main() {\n+    let a: &[i32]\n+        = o_O!(10; [1, 2, 3];\n+               20; [4, 5, 6]);\n \n-    // visible here: m1, m2\n+    assert_eq!(a, [11, 12, 13, 24, 25, 26]);\n }\n+```\n \n-// visible here: m1\n+That's most of the matcher syntax. These examples use `$(...)*`, which is a\n+\"zero or more\" match. Alternatively you can write `$(...)+` for a \"one or\n+more\" match. Both forms optionally include a separator, which can be any token\n+except `+` or `*`.\n \n-macro_rules! m3 { () => (()) }\n+# Hygiene\n \n-// visible here: m1, m3\n+Some languages implement macros using simple text substitution, which leads to\n+various problems. For example, this C program prints `13` instead of the\n+expected `25`.\n \n-#[macro_use]\n-mod bar {\n-    // visible here: m1, m3\n+```text\n+#define FIVE_TIMES(x) 5 * x\n \n-    macro_rules! m4 { () => (()) }\n+int main() {\n+    printf(\"%d\\n\", FIVE_TIMES(2 + 3));\n+    return 0;\n+}\n+```\n \n-    // visible here: m1, m3, m4\n+After expansion we have `5 * 2 + 3`, and multiplication has greater precedence\n+than addition. If you've used C macros a lot, you probably know the standard\n+idioms for avoiding this problem, as well as five or six others. In Rust, we\n+don't have to worry about it.\n+\n+```rust\n+macro_rules! five_times {\n+    ($x:expr) => (5 * $x);\n }\n \n-// visible here: m1, m3, m4\n-# fn main() { }\n+fn main() {\n+    assert_eq!(25, five_times!(2 + 3));\n+}\n+```\n+\n+The metavariable `$x` is parsed as a single expression node, and keeps its\n+place in the syntax tree even after substitution.\n+\n+Another common problem in macro systems is *variable capture*. Here's a C\n+macro, using [a GNU C extension] to emulate Rust's expression blocks.\n+\n+[a GNU C extension]: https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html\n+\n+```text\n+#define LOG(msg) ({ \\\n+    int state = get_log_state(); \\\n+    if (state > 0) { \\\n+        printf(\"log(%d): %s\\n\", state, msg); \\\n+    } \\\n+})\n ```\n \n-When this library is loaded with `#[use_macros] extern crate`, only `m2` will\n-be imported.\n+This looks reasonable, but watch what happens in this example:\n \n-The Rust Reference has a [listing of macro-related\n-attributes](../reference.html#macro--and-plugin-related-attributes).\n+```text\n+const char *state = \"reticulating splines\";\n+LOG(state);\n+```\n+\n+The program will likely segfault, after it tries to execute\n \n-# The variable `$crate`\n+```text\n+printf(\"log(%d): %s\\n\", state, state);\n+```\n \n-A further difficulty occurs when a macro is used in multiple crates.  Say that\n-`mylib` defines\n+The equivalent Rust macro has the desired behavior.\n \n ```rust\n-pub fn increment(x: u32) -> u32 {\n-    x + 1\n+# fn get_log_state() -> i32 { 3 }\n+macro_rules! log {\n+    ($msg:expr) => {{\n+        let state: i32 = get_log_state();\n+        if state > 0 {\n+            println!(\"log({}): {}\", state, $msg);\n+        }\n+    }};\n }\n \n-#[macro_export]\n-macro_rules! inc_a {\n-    ($x:expr) => ( ::increment($x) )\n+fn main() {\n+    let state: &str = \"reticulating splines\";\n+    log!(state);\n }\n+```\n+\n+This works because Rust has a [hygienic macro system][]. Each macro expansion\n+happens in a distinct *syntax context*, and each variable is tagged with the\n+syntax context where it was introduced. It's as though the variable `state`\n+inside `main` is painted a different \"color\" from the variable `state` inside\n+the macro, and therefore they don't conflict.\n \n-#[macro_export]\n-macro_rules! inc_b {\n-    ($x:expr) => ( ::mylib::increment($x) )\n+[hygienic macro system]: http://en.wikipedia.org/wiki/Hygienic_macro\n+\n+This also restricts the ability of macros to introduce new bindings at the\n+invocation site. Code such as the following will not work:\n+\n+```rust,ignore\n+macro_rules! foo {\n+    () => (let x = 3);\n+}\n+\n+fn main() {\n+    foo!();\n+    println!(\"{}\", x);\n }\n-# fn main() { }\n ```\n \n-`inc_a` only works within `mylib`, while `inc_b` only works outside the\n-library.  Furthermore, `inc_b` will break if the user imports `mylib` under\n-another name.\n+Instead you need to pass the variable name into the invocation, so it's tagged\n+with the right syntax context.\n \n-Rust does not (yet) have a hygiene system for crate references, but it does\n-provide a simple workaround for this problem.  Within a macro imported from a\n-crate named `foo`, the special macro variable `$crate` will expand to `::foo`.\n-By contrast, when a macro is defined and then used in the same crate, `$crate`\n-will expand to nothing.  This means we can write\n+```rust\n+macro_rules! foo {\n+    ($v:ident) => (let $v = 3);\n+}\n+\n+fn main() {\n+    foo!(x);\n+    println!(\"{}\", x);\n+}\n+```\n+\n+This holds for `let` bindings and loop labels, but not for [items][].\n+So the following code does compile:\n \n ```rust\n-#[macro_export]\n-macro_rules! inc {\n-    ($x:expr) => ( $crate::increment($x) )\n+macro_rules! foo {\n+    () => (fn x() { });\n+}\n+\n+fn main() {\n+    foo!();\n+    x();\n }\n-# fn main() { }\n ```\n \n-to define a single macro that works both inside and outside our library.  The\n-function name will expand to either `::increment` or `::mylib::increment`.\n-\n-To keep this system simple and correct, `#[macro_use] extern crate ...` may\n-only appear at the root of your crate, not inside `mod`.  This ensures that\n-`$crate` is a single identifier.\n-\n-# A final note\n-\n-Macros, as currently implemented, are not for the faint of heart. Even\n-ordinary syntax errors can be more difficult to debug when they occur inside a\n-macro, and errors caused by parse problems in generated code can be very\n-tricky. Invoking the `log_syntax!` macro can help elucidate intermediate\n-states, invoking `trace_macros!(true)` will automatically print those\n-intermediate states out, and passing the flag `--pretty expanded` as a\n-command-line argument to the compiler will show the result of expansion.\n-\n-If Rust's macro system can't do what you need, you may want to write a\n-[compiler plugin](plugins.html) instead. Compared to `macro_rules!`\n-macros, this is significantly more work, the interfaces are much less stable,\n-and the warnings about debugging apply ten-fold. In exchange you get the\n-flexibility of running arbitrary Rust code within the compiler. Syntax\n-extension plugins are sometimes called *procedural macros* for this reason.\n+[items]: ../reference.html#items\n+\n+# Further reading\n+\n+The [advanced macros chapter][] goes into more detail about macro syntax. It\n+also describes how to share macros between different modules or crates.\n+\n+[advanced macros chapter]: advanced-macros.html"}, {"sha": "64d540582a3998bd7acd97c745379be9d2ba21ba", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -99,8 +99,8 @@ fn grow(&self) -> Circle {\n # Circle } }\n ```\n \n-We just say we're returning a `Circle`. With this, we can grow a new circle\n-that's twice as big as the old one.\n+We just say we're returning a `Circle`. With this method, we can grow a new\n+circle with an area that's 100 times larger than the old one.\n \n ## Static methods\n "}, {"sha": "6aced23ede08effc8c9f3f01b5c110cb5e6a421a", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -293,7 +293,7 @@ struct Foo<'a> {\n }\n \n fn main() {\n-    let y = &5; // this is the same as `let _y = 5; let y = &_y;\n+    let y = &5; // this is the same as `let _y = 5; let y = &_y;`\n     let f = Foo { x: y };\n \n     println!(\"{}\", f.x);"}, {"sha": "abd9af1af33a097e805f0b64cba83d0ccbbc6cdf", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -273,6 +273,96 @@ One last thing about traits: generic functions with a trait bound use\n dispatched. What's that mean? Check out the chapter on [static and dynamic\n dispatch](static-and-dynamic-dispatch.html) for more.\n \n+## Where clause\n+\n+Writing functions with only a few generic types and a small number of trait\n+bounds isn't too bad, but as the number increases, the syntax gets increasingly\n+awkward:\n+\n+```\n+use std::fmt::Debug;\n+\n+fn foo<T: Clone, K: Clone + Debug>(x: T, y: K) {\n+    x.clone();\n+    y.clone();\n+    println!(\"{:?}\", y);\n+}\n+```\n+\n+The name of the function is on the far left, and the parameter list is on the\n+far right. The bounds are getting in the way.\n+\n+Rust has a solution, and it's called a '`where` clause':\n+\n+```\n+use std::fmt::Debug;\n+\n+fn foo<T: Clone, K: Clone + Debug>(x: T, y: K) {\n+    x.clone();\n+    y.clone();\n+    println!(\"{:?}\", y);\n+}\n+\n+fn bar<T, K>(x: T, y: K) where T: Clone, K: Clone + Debug {\n+    x.clone();\n+    y.clone();\n+    println!(\"{:?}\", y);\n+}\n+\n+fn main() {\n+    foo(\"Hello\", \"world\");\n+    bar(\"Hello\", \"workd\");\n+}\n+```\n+\n+`foo()` uses the syntax we showed earlier, and `bar()` uses a `where` clause.\n+All you need to do is leave off the bounds when defining your type parameters,\n+and then add `where` after the parameter list. For longer lists, whitespace can\n+be added:\n+\n+```\n+use std::fmt::Debug;\n+\n+fn bar<T, K>(x: T, y: K)\n+    where T: Clone,\n+          K: Clone + Debug {\n+\n+    x.clone();\n+    y.clone();\n+    println!(\"{:?}\", y);\n+}\n+```\n+\n+This flexibility can add clarity in complex situations.\n+\n+`where` is also more powerful than the simpler syntax. For example:\n+\n+```\n+trait ConvertTo<Output> {\n+    fn convert(&self) -> Output;\n+}\n+\n+impl ConvertTo<i64> for i32 {\n+    fn convert(&self) -> i64 { *self as i64 }\n+}\n+\n+// can be called with T == i32\n+fn normal<T: ConvertTo<i64>>(x: &T) -> i64 {\n+    x.convert()\n+}\n+\n+// can be called with T == i64\n+fn inverse<T>() -> T\n+        // this is using ConvertTo as if it were \"ConvertFrom<i32>\"\n+        where i32: ConvertTo<T> {\n+    1i32.convert()\n+}\n+```\n+\n+This shows off the additional feature of `where` clauses: they allow bounds\n+where the left-hand side is an arbitrary type (`i32` in this case), not just a\n+plain type parameter (like `T`).\n+\n ## Our `inverse` Example\n \n Back in [Generics](generics.html), we were trying to write code like this:"}, {"sha": "4e14085599b603d3b640d672748c8f41eebce10f", "filename": "src/doc/trpl/unsafe.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -308,7 +308,7 @@ crate to allow) and of course requires an `unsafe` block.\n ## Assembly template\n \n The `assembly template` is the only required parameter and must be a\n-literal string (i.e `\"\"`)\n+literal string (i.e. `\"\"`)\n \n ```\n #![feature(asm)]\n@@ -412,15 +412,15 @@ memory, `memory` should also be specified.\n ## Options\n \n The last section, `options` is specific to Rust. The format is comma\n-separated literal strings (i.e `:\"foo\", \"bar\", \"baz\"`). It's used to\n+separated literal strings (i.e. `:\"foo\", \"bar\", \"baz\"`). It's used to\n specify some extra info about the inline assembly:\n \n Current valid options are:\n \n 1. *volatile* - specifying this is analogous to\n    `__asm__ __volatile__ (...)` in gcc/clang.\n 2. *alignstack* - certain instructions expect the stack to be\n-   aligned a certain way (i.e SSE) and specifying this indicates to\n+   aligned a certain way (i.e. SSE) and specifying this indicates to\n    the compiler to insert its usual stack alignment code\n 3. *intel* - use intel syntax instead of the default AT&T.\n \n@@ -646,8 +646,8 @@ The `rustc` compiler has certain pluggable operations, that is,\n functionality that isn't hard-coded into the language, but is\n implemented in libraries, with a special marker to tell the compiler\n it exists. The marker is the attribute `#[lang=\"...\"]` and there are\n-various different values of `...`, i.e. various different \"lang\n-items\".\n+various different values of `...`, i.e. various different 'lang\n+items'.\n \n For example, `Box` pointers require two lang items, one for allocation\n and one for deallocation. A freestanding program that uses the `Box`"}, {"sha": "3830d7fe29532c228a9521286bfa250ae040b06b", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -35,14 +35,14 @@\n //!\n //! ```\n //! use std::sync::Arc;\n-//! use std::thread::Thread;\n+//! use std::thread;\n //!\n //! let five = Arc::new(5);\n //!\n //! for _ in 0..10 {\n //!     let five = five.clone();\n //!\n-//!     Thread::spawn(move || {\n+//!     thread::spawn(move || {\n //!         println!(\"{:?}\", five);\n //!     });\n //! }\n@@ -52,14 +52,14 @@\n //!\n //! ```\n //! use std::sync::{Arc, Mutex};\n-//! use std::thread::Thread;\n+//! use std::thread;\n //!\n //! let five = Arc::new(Mutex::new(5));\n //!\n //! for _ in 0..10 {\n //!     let five = five.clone();\n //!\n-//!     Thread::spawn(move || {\n+//!     thread::spawn(move || {\n //!         let mut number = five.lock().unwrap();\n //!\n //!         *number += 1;\n@@ -95,7 +95,7 @@ use heap::deallocate;\n ///\n /// ```rust\n /// use std::sync::Arc;\n-/// use std::thread::Thread;\n+/// use std::thread;\n ///\n /// fn main() {\n ///     let numbers: Vec<_> = (0..100u32).map(|i| i as f32).collect();\n@@ -104,7 +104,7 @@ use heap::deallocate;\n ///     for _ in 0..10 {\n ///         let child_numbers = shared_numbers.clone();\n ///\n-///         Thread::spawn(move || {\n+///         thread::spawn(move || {\n ///             let local_numbers = child_numbers.as_slice();\n ///\n ///             // Work with the local numbers\n@@ -621,7 +621,7 @@ mod tests {\n     use std::option::Option::{Some, None};\n     use std::sync::atomic;\n     use std::sync::atomic::Ordering::{Acquire, SeqCst};\n-    use std::thread::Thread;\n+    use std::thread;\n     use std::vec::Vec;\n     use super::{Arc, Weak, weak_count, strong_count};\n     use std::sync::Mutex;\n@@ -648,7 +648,7 @@ mod tests {\n \n         let (tx, rx) = channel();\n \n-        let _t = Thread::spawn(move || {\n+        let _t = thread::spawn(move || {\n             let arc_v: Arc<Vec<i32>> = rx.recv().unwrap();\n             assert_eq!((*arc_v)[3], 4);\n         });"}, {"sha": "b3c2638f3ae282a190c5318fe147c1873f7ea844", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -126,11 +126,3 @@ pub fn oom() -> ! {\n //                optimize it out).\n #[doc(hidden)]\n pub fn fixme_14344_be_sure_to_link_to_collections() {}\n-\n-// NOTE: remove after next snapshot\n-#[cfg(all(stage0, not(test)))]\n-#[doc(hidden)]\n-mod std {\n-    pub use core::fmt;\n-    pub use core::option;\n-}"}, {"sha": "f361c36ec8fa73bafb333c6a1a5284d851164ea9", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -170,7 +170,7 @@ struct RcBox<T> {\n     weak: Cell<usize>\n }\n \n-/// An immutable reference-counted pointer type.\n+/// A reference-counted pointer type over an immutable value.\n ///\n /// See the [module level documentation](./index.html) for more details.\n #[unsafe_no_drop_flag]\n@@ -776,9 +776,7 @@ impl<T> RcBoxPtr<T> for Rc<T> {\n             // the contract anyway.\n             // This allows the null check to be elided in the destructor if we\n             // manipulated the reference count in the same function.\n-            if cfg!(not(stage0)) { // NOTE remove cfg after next snapshot\n-                assume(!self._ptr.is_null());\n-            }\n+            assume(!self._ptr.is_null());\n             &(**self._ptr)\n         }\n     }\n@@ -792,9 +790,7 @@ impl<T> RcBoxPtr<T> for Weak<T> {\n             // the contract anyway.\n             // This allows the null check to be elided in the destructor if we\n             // manipulated the reference count in the same function.\n-            if cfg!(not(stage0)) { // NOTE remove cfg after next snapshot\n-                assume(!self._ptr.is_null());\n-            }\n+            assume(!self._ptr.is_null());\n             &(**self._ptr)\n         }\n     }"}, {"sha": "6196d94b5a6bd9be2d9892530686dc557b779069", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -655,17 +655,7 @@ impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T: Ord> IntoIterator for BinaryHeap<T> {\n-    type IntoIter = IntoIter<T>;\n-\n-    fn into_iter(self) -> IntoIter<T> {\n-        self.into_iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> IntoIterator for BinaryHeap<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n@@ -675,17 +665,7 @@ impl<T: Ord> IntoIterator for BinaryHeap<T> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a, T> IntoIterator for &'a BinaryHeap<T> where T: Ord {\n-    type IntoIter = Iter<'a, T>;\n-\n-    fn into_iter(self) -> Iter<'a, T> {\n-        self.iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> IntoIterator for &'a BinaryHeap<T> where T: Ord {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;"}, {"sha": "0b762788b208aca548cd565912652c2457a8c2bf", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -1070,17 +1070,7 @@ impl<'a> RandomAccessIterator for Iter<'a> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a> IntoIterator for &'a Bitv {\n-    type IntoIter = Iter<'a>;\n-\n-    fn into_iter(self) -> Iter<'a> {\n-        self.iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> IntoIterator for &'a Bitv {\n     type Item = bool;\n     type IntoIter = Iter<'a>;\n@@ -1894,17 +1884,7 @@ impl<'a> Iterator for SymmetricDifference<'a> {\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a> IntoIterator for &'a BitvSet {\n-    type IntoIter = SetIter<'a>;\n-\n-    fn into_iter(self) -> SetIter<'a> {\n-        self.iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> IntoIterator for &'a BitvSet {\n     type Item = usize;\n     type IntoIter = SetIter<'a>;"}, {"sha": "747211e923859df6d1fbab7b13bfb3716f56afa9", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 3, "deletions": 33, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -462,17 +462,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<K, V> IntoIterator for BTreeMap<K, V> {\n-    type IntoIter = IntoIter<K, V>;\n-\n-    fn into_iter(self) -> IntoIter<K, V> {\n-        self.into_iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> IntoIterator for BTreeMap<K, V> {\n     type Item = (K, V);\n     type IntoIter = IntoIter<K, V>;\n@@ -482,17 +472,7 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a, K, V> IntoIterator for &'a BTreeMap<K, V> {\n-    type IntoIter = Iter<'a, K, V>;\n-\n-    fn into_iter(self) -> Iter<'a, K, V> {\n-        self.iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> IntoIterator for &'a BTreeMap<K, V> {\n     type Item = (&'a K, &'a V);\n     type IntoIter = Iter<'a, K, V>;\n@@ -502,17 +482,7 @@ impl<'a, K, V> IntoIterator for &'a BTreeMap<K, V> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a, K, V> IntoIterator for &'a mut BTreeMap<K, V> {\n-    type IntoIter = IterMut<'a, K, V>;\n-\n-    fn into_iter(mut self) -> IterMut<'a, K, V> {\n-        self.iter_mut()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> IntoIterator for &'a mut BTreeMap<K, V> {\n     type Item = (&'a K, &'a mut V);\n     type IntoIter = IterMut<'a, K, V>;"}, {"sha": "7ef887b70cc6ca4ec0736f56de47ba4330de0922", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -480,17 +480,7 @@ impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T> IntoIterator for BTreeSet<T> {\n-    type IntoIter = IntoIter<T>;\n-\n-    fn into_iter(self) -> IntoIter<T> {\n-        self.into_iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> IntoIterator for BTreeSet<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n@@ -500,17 +490,7 @@ impl<T> IntoIterator for BTreeSet<T> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n-    type IntoIter = Iter<'a, T>;\n-\n-    fn into_iter(self) -> Iter<'a, T> {\n-        self.iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;"}, {"sha": "eb1bf93c0aafc56da88302b57292040a0e3b430a", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 4, "deletions": 35, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -837,17 +837,7 @@ impl<A> FromIterator<A> for DList<A> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T> IntoIterator for DList<T> {\n-    type IntoIter = IntoIter<T>;\n-\n-    fn into_iter(self) -> IntoIter<T> {\n-        self.into_iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> IntoIterator for DList<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n@@ -857,17 +847,7 @@ impl<T> IntoIterator for DList<T> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a, T> IntoIterator for &'a DList<T> {\n-    type IntoIter = Iter<'a, T>;\n-\n-    fn into_iter(self) -> Iter<'a, T> {\n-        self.iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> IntoIterator for &'a DList<T> {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n@@ -877,17 +857,6 @@ impl<'a, T> IntoIterator for &'a DList<T> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a, T> IntoIterator for &'a mut DList<T> {\n-    type IntoIter = IterMut<'a, T>;\n-\n-    fn into_iter(mut self) -> IterMut<'a, T> {\n-        self.iter_mut()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n impl<'a, T> IntoIterator for &'a mut DList<T> {\n     type Item = &'a mut T;\n     type IntoIter = IterMut<'a, T>;\n@@ -971,7 +940,7 @@ mod tests {\n     use prelude::*;\n     use std::rand;\n     use std::hash::{self, SipHasher};\n-    use std::thread::Thread;\n+    use std::thread;\n     use test::Bencher;\n     use test;\n \n@@ -1320,7 +1289,7 @@ mod tests {\n     #[test]\n     fn test_send() {\n         let n = list_from(&[1,2,3]);\n-        Thread::scoped(move || {\n+        thread::spawn(move || {\n             check_links(&n);\n             let a: &[_] = &[&1,&2,&3];\n             assert_eq!(a, n.iter().collect::<Vec<_>>());"}, {"sha": "d5403ca5d9b195b0e867ad76c2dd945c850b3415", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -257,17 +257,7 @@ impl<E:CLike> FromIterator<E> for EnumSet<E> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike {\n-    type IntoIter = Iter<E>;\n-\n-    fn into_iter(self) -> Iter<E> {\n-        self.iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike {\n     type Item = E;\n     type IntoIter = Iter<E>;"}, {"sha": "cacbf3bce80f018e80016abe6d3396a407ecd402", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -111,15 +111,6 @@ pub fn fixme_14344_be_sure_to_link_to_collections() {}\n \n #[cfg(not(test))]\n mod std {\n-    // NOTE: remove after next snapshot\n-    #[cfg(stage0)] pub use core::clone;    // derive(Clone)\n-    #[cfg(stage0)] pub use core::cmp;      // derive(Eq, Ord, etc.)\n-    #[cfg(stage0)] pub use core::marker;   // derive(Copy)\n-    #[cfg(stage0)] pub use core::hash;     // derive(Hash)\n-    #[cfg(stage0)] pub use core::iter;\n-    #[cfg(stage0)] pub use core::fmt;      // necessary for panic!()\n-    #[cfg(stage0)] pub use core::option;   // necessary for panic!()\n-\n     pub use core::ops;      // RangeFull\n }\n "}, {"sha": "ebcfb8d1cf84e2a4d421e2fc000c2cf767e8e559", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -9,12 +9,34 @@\n // except according to those terms.\n \n /// Creates a `Vec` containing the arguments.\n+///\n+/// `vec!` allows `Vec`s to be defined with the same syntax as array expressions.\n+/// There are two forms of this macro:\n+///\n+/// - Create a `Vec` containing a given list of elements:\n+///\n+/// ```\n+/// let v = vec![1, 2, 3];\n+/// assert_eq!(v[0], 1);\n+/// assert_eq!(v[1], 2);\n+/// assert_eq!(v[2], 3);\n+/// ```\n+///\n+/// - Create a `Vec` from a given element and size:\n+///\n+/// ```\n+/// let v = vec![1; 3];\n+/// assert_eq!(v, vec![1, 1, 1]);\n+/// ```\n+///\n+/// Note that unlike array expressions this syntax supports all elements\n+/// which implement `Clone` and the number of elements doesn't have to be\n+/// a constant.\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! vec {\n-    ($x:expr; $y:expr) => (\n-        <[_] as $crate::slice::SliceExt>::into_vec(\n-            $crate::boxed::Box::new([$x; $y]))\n+    ($elem:expr; $n:expr) => (\n+        $crate::vec::from_elem($elem, $n)\n     );\n     ($($x:expr),*) => (\n         <[_] as $crate::slice::SliceExt>::into_vec("}, {"sha": "6dcdb21f8000b0f855b58445166cc24343787727", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 12, "deletions": 37, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -8,9 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! This crate implements a double-ended queue with `O(1)` amortized inserts and removals from both\n-//! ends of the container. It also has `O(1)` indexing like a vector. The contained elements are\n-//! not required to be copyable, and the queue will be sendable if the contained type is sendable.\n+//! RingBuf is a double-ended queue, which is implemented with the help of a\n+//! growing circular buffer.\n+//!\n+//! This queue has `O(1)` amortized inserts and removals from both ends of the\n+//! container. It also has `O(1)` indexing like a vector. The contained elements\n+//! are not required to be copyable, and the queue will be sendable if the\n+//! contained type is sendable.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -113,7 +117,8 @@ impl<T> RingBuf<T> {\n     #[inline]\n     fn is_full(&self) -> bool { self.cap - self.len() == 1 }\n \n-    /// Returns the index in the underlying buffer for a given logical element index.\n+    /// Returns the index in the underlying buffer for a given logical element\n+    /// index.\n     #[inline]\n     fn wrap_index(&self, idx: usize) -> usize { wrap_index(idx, self.cap) }\n \n@@ -1699,17 +1704,7 @@ impl<A> FromIterator<A> for RingBuf<A> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T> IntoIterator for RingBuf<T> {\n-    type IntoIter = IntoIter<T>;\n-\n-    fn into_iter(self) -> IntoIter<T> {\n-        self.into_iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> IntoIterator for RingBuf<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n@@ -1719,17 +1714,7 @@ impl<T> IntoIterator for RingBuf<T> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a, T> IntoIterator for &'a RingBuf<T> {\n-    type IntoIter = Iter<'a, T>;\n-\n-    fn into_iter(self) -> Iter<'a, T> {\n-        self.iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> IntoIterator for &'a RingBuf<T> {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n@@ -1739,17 +1724,7 @@ impl<'a, T> IntoIterator for &'a RingBuf<T> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a, T> IntoIterator for &'a mut RingBuf<T> {\n-    type IntoIter = IterMut<'a, T>;\n-\n-    fn into_iter(mut self) -> IterMut<'a, T> {\n-        self.iter_mut()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> IntoIterator for &'a mut RingBuf<T> {\n     type Item = &'a mut T;\n     type IntoIter = IterMut<'a, T>;"}, {"sha": "bde733644b5b58e4cce2a263fa5813befb555b29", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 46, "deletions": 43, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -1252,6 +1252,30 @@ unsafe fn dealloc<T>(ptr: *mut T, len: usize) {\n     }\n }\n \n+#[doc(hidden)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {\n+    unsafe {\n+        let mut v = Vec::with_capacity(n);\n+        let mut ptr = v.as_mut_ptr();\n+\n+        // Write all elements except the last one\n+        for i in 1..n {\n+            ptr::write(ptr, Clone::clone(&elem));\n+            ptr = ptr.offset(1);\n+            v.set_len(i); // Increment the length in every step in case Clone::clone() panics\n+        }\n+\n+        if n > 0 {\n+            // We can write the last element directly without cloning needlessly\n+            ptr::write(ptr, elem);\n+            v.set_len(n);\n+        }\n+\n+        v\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Common trait implementations for Vec\n ////////////////////////////////////////////////////////////////////////////////\n@@ -1383,7 +1407,7 @@ impl<T> ops::DerefMut for Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n-    fn from_iter<I:Iterator<Item=T>>(iterator: I) -> Vec<T> {\n+    fn from_iter<I:Iterator<Item=T>>(mut iterator: I) -> Vec<T> {\n         let (lower, _) = iterator.size_hint();\n         let mut vector = Vec::with_capacity(lower);\n \n@@ -1393,38 +1417,37 @@ impl<T> FromIterator<T> for Vec<T> {\n         //          vector.push(item);\n         //      }\n         //\n-        // This equivalent crucially runs the iterator precisely once. The\n-        // optimization below (eliding bound/growth checks) means that we\n-        // actually run the iterator twice. To ensure the \"moral equivalent\" we\n-        // do a `fuse()` operation to ensure that the iterator continues to\n-        // return `None` after seeing the first `None`.\n-        let mut i = iterator.fuse();\n-        for element in i.by_ref().take(vector.capacity()) {\n+        // This equivalent crucially runs the iterator precisely once. Below we\n+        // actually in theory run the iterator twice (one without bounds checks\n+        // and one with). To achieve the \"moral equivalent\", we use the `if`\n+        // statement below to break out early.\n+        //\n+        // If the first loop has terminated, then we have one of two conditions.\n+        //\n+        // 1. The underlying iterator returned `None`. In this case we are\n+        //    guaranteed that less than `vector.capacity()` elements have been\n+        //    returned, so we break out early.\n+        // 2. The underlying iterator yielded `vector.capacity()` elements and\n+        //    has not yielded `None` yet. In this case we run the iterator to\n+        //    its end below.\n+        for element in iterator.by_ref().take(vector.capacity()) {\n             let len = vector.len();\n             unsafe {\n                 ptr::write(vector.get_unchecked_mut(len), element);\n                 vector.set_len(len + 1);\n             }\n         }\n \n-        for element in i {\n-            vector.push(element)\n+        if vector.len() == vector.capacity() {\n+            for element in iterator {\n+                vector.push(element);\n+            }\n         }\n         vector\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T> IntoIterator for Vec<T> {\n-    type IntoIter = IntoIter<T>;\n-\n-    fn into_iter(self) -> IntoIter<T> {\n-        self.into_iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> IntoIterator for Vec<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n@@ -1434,17 +1457,7 @@ impl<T> IntoIterator for Vec<T> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a, T> IntoIterator for &'a Vec<T> {\n-    type IntoIter = slice::Iter<'a, T>;\n-\n-    fn into_iter(self) -> slice::Iter<'a, T> {\n-        self.iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> IntoIterator for &'a Vec<T> {\n     type Item = &'a T;\n     type IntoIter = slice::Iter<'a, T>;\n@@ -1454,17 +1467,7 @@ impl<'a, T> IntoIterator for &'a Vec<T> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a, T> IntoIterator for &'a mut Vec<T> {\n-    type IntoIter = slice::IterMut<'a, T>;\n-\n-    fn into_iter(mut self) -> slice::IterMut<'a, T> {\n-        self.iter_mut()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> IntoIterator for &'a mut Vec<T> {\n     type Item = &'a mut T;\n     type IntoIter = slice::IterMut<'a, T>;"}, {"sha": "82ccfd0614fd5e14c94f1e47a9d11efcc70410a7", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 3, "deletions": 33, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -668,17 +668,7 @@ impl<V> FromIterator<(usize, V)> for VecMap<V> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T> IntoIterator for VecMap<T> {\n-    type IntoIter = IntoIter<T>;\n-\n-    fn into_iter(self) -> IntoIter<T> {\n-        self.into_iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> IntoIterator for VecMap<T> {\n     type Item = (usize, T);\n     type IntoIter = IntoIter<T>;\n@@ -688,17 +678,7 @@ impl<T> IntoIterator for VecMap<T> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a, T> IntoIterator for &'a VecMap<T> {\n-    type IntoIter = Iter<'a, T>;\n-\n-    fn into_iter(self) -> Iter<'a, T> {\n-        self.iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> IntoIterator for &'a VecMap<T> {\n     type Item = (usize, &'a T);\n     type IntoIter = Iter<'a, T>;\n@@ -708,17 +688,7 @@ impl<'a, T> IntoIterator for &'a VecMap<T> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a, T> IntoIterator for &'a mut VecMap<T> {\n-    type IntoIter = IterMut<'a, T>;\n-\n-    fn into_iter(mut self) -> IterMut<'a, T> {\n-        self.iter_mut()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> IntoIterator for &'a mut VecMap<T> {\n     type Item = (usize, &'a mut T);\n     type IntoIter = IterMut<'a, T>;"}, {"sha": "838ca4e478b72223c20583ac4089e99a66469a04", "filename": "src/libcore/array.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -48,17 +48,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            // NOTE(stage0): remove impl after a snapshot\n-            #[cfg(stage0)]\n-            impl<'a, T> IntoIterator for &'a [T; $N] {\n-                type IntoIter = Iter<'a, T>;\n-\n-                fn into_iter(self) -> Iter<'a, T> {\n-                    self.iter()\n-                }\n-            }\n-\n-            #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<'a, T> IntoIterator for &'a [T; $N] {\n                 type Item = &'a T;\n                 type IntoIter = Iter<'a, T>;\n@@ -68,17 +58,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            // NOTE(stage0): remove impl after a snapshot\n-            #[cfg(stage0)]\n-            impl<'a, T> IntoIterator for &'a mut [T; $N] {\n-                type IntoIter = IterMut<'a, T>;\n-\n-                fn into_iter(self) -> IterMut<'a, T> {\n-                    self.iter_mut()\n-                }\n-            }\n-\n-            #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<'a, T> IntoIterator for &'a mut [T; $N] {\n                 type Item = &'a mut T;\n                 type IntoIter = IterMut<'a, T>;"}, {"sha": "05d864accc130050edb18322e7866b4fed50bc7f", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -42,13 +42,13 @@\n //! ```\n //! use std::sync::Arc;\n //! use std::sync::atomic::{AtomicUsize, Ordering};\n-//! use std::thread::Thread;\n+//! use std::thread;\n //!\n //! fn main() {\n //!     let spinlock = Arc::new(AtomicUsize::new(1));\n //!\n //!     let spinlock_clone = spinlock.clone();\n-//!     Thread::spawn(move|| {\n+//!     thread::spawn(move|| {\n //!         spinlock_clone.store(0, Ordering::SeqCst);\n //!     });\n //!"}, {"sha": "eb138e6142b80e36e5c4217225ed301dcfcea2d1", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -78,12 +78,12 @@\n //! use std::cell::RefCell;\n //!\n //! struct Graph {\n-//!     edges: Vec<(uint, uint)>,\n-//!     span_tree_cache: RefCell<Option<Vec<(uint, uint)>>>\n+//!     edges: Vec<(i32, i32)>,\n+//!     span_tree_cache: RefCell<Option<Vec<(i32, i32)>>>\n //! }\n //!\n //! impl Graph {\n-//!     fn minimum_spanning_tree(&self) -> Vec<(uint, uint)> {\n+//!     fn minimum_spanning_tree(&self) -> Vec<(i32, i32)> {\n //!         // Create a new scope to contain the lifetime of the\n //!         // dynamic borrow\n //!         {\n@@ -104,7 +104,7 @@\n //!         // This is the major hazard of using `RefCell`.\n //!         self.minimum_spanning_tree()\n //!     }\n-//! #   fn calc_span_tree(&self) -> Vec<(uint, uint)> { vec![] }\n+//! #   fn calc_span_tree(&self) -> Vec<(i32, i32)> { vec![] }\n //! }\n //! ```\n //!\n@@ -125,7 +125,7 @@\n //!\n //! struct RcBox<T> {\n //!     value: T,\n-//!     refcount: Cell<uint>\n+//!     refcount: Cell<usize>\n //! }\n //!\n //! impl<T> Clone for Rc<T> {\n@@ -279,8 +279,8 @@ pub enum BorrowState {\n }\n \n // Values [1, MAX-1] represent the number of `Ref` active\n-// (will not outgrow its range since `uint` is the size of the address space)\n-type BorrowFlag = uint;\n+// (will not outgrow its range since `usize` is the size of the address space)\n+type BorrowFlag = usize;\n const UNUSED: BorrowFlag = 0;\n const WRITING: BorrowFlag = -1;\n \n@@ -375,9 +375,9 @@ impl<T> RefCell<T> {\n     ///\n     /// ```\n     /// use std::cell::RefCell;\n-    /// use std::thread::Thread;\n+    /// use std::thread;\n     ///\n-    /// let result = Thread::scoped(move || {\n+    /// let result = thread::spawn(move || {\n     ///    let c = RefCell::new(5);\n     ///    let m = c.borrow_mut();\n     ///\n@@ -436,9 +436,9 @@ impl<T> RefCell<T> {\n     ///\n     /// ```\n     /// use std::cell::RefCell;\n-    /// use std::thread::Thread;\n+    /// use std::thread;\n     ///\n-    /// let result = Thread::scoped(move || {\n+    /// let result = thread::spawn(move || {\n     ///    let c = RefCell::new(5);\n     ///    let m = c.borrow_mut();\n     ///\n@@ -649,8 +649,7 @@ impl<'b, T> DerefMut for RefMut<'b, T> {\n ///\n /// **NOTE:** `UnsafeCell<T>`'s fields are public to allow static initializers. It is not\n /// recommended to access its fields directly, `get` should be used instead.\n-#[cfg_attr(stage0, lang=\"unsafe\")]  // NOTE: remove after next snapshot\n-#[cfg_attr(not(stage0), lang=\"unsafe_cell\")]\n+#[lang=\"unsafe_cell\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct UnsafeCell<T> {\n     /// Wrapped value"}, {"sha": "19ec245300d02ab325fec9e3cc6d834a5877201e", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 207, "deletions": 66, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -8,35 +8,33 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Defines the `PartialOrd` and `PartialEq` comparison traits.\n+//! Functionality for ordering and comparison.\n //!\n-//! This module defines both `PartialOrd` and `PartialEq` traits which are used by the\n-//! compiler to implement comparison operators. Rust programs may implement\n-//!`PartialOrd` to overload the `<`, `<=`, `>`, and `>=` operators, and may implement\n-//! `PartialEq` to overload the `==` and `!=` operators.\n+//! This module defines both `PartialOrd` and `PartialEq` traits which are used by the compiler to\n+//! implement comparison operators. Rust programs may implement `PartialOrd` to overload the `<`,\n+//! `<=`, `>`, and `>=` operators, and may implement `PartialEq` to overload the `==` and `!=`\n+//! operators.\n //!\n-//! For example, to define a type with a customized definition for the PartialEq\n-//! operators, you could do the following:\n+//! For example, to define a type with a customized definition for the PartialEq operators, you\n+//! could do the following:\n //!\n-//! ```rust\n+//! ```\n //! use core::num::SignedInt;\n //!\n-//! // Our type.\n-//! struct SketchyNum {\n-//!     num : int\n+//! struct FuzzyNum {\n+//!     num: i32,\n //! }\n //!\n-//! // Our implementation of `PartialEq` to support `==` and `!=`.\n-//! impl PartialEq for SketchyNum {\n+//! impl PartialEq for FuzzyNum {\n //!     // Our custom eq allows numbers which are near each other to be equal! :D\n-//!     fn eq(&self, other: &SketchyNum) -> bool {\n+//!     fn eq(&self, other: &FuzzyNum) -> bool {\n //!         (self.num - other.num).abs() < 5\n //!     }\n //! }\n //!\n //! // Now these binary operators will work when applied!\n-//! assert!(SketchyNum {num: 37} == SketchyNum {num: 34});\n-//! assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n+//! assert!(FuzzyNum { num: 37 } == FuzzyNum { num: 34 });\n+//! assert!(FuzzyNum { num: 25 } != FuzzyNum { num: 57 });\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -49,24 +47,22 @@ use option::Option::{self, Some, None};\n /// Trait for equality comparisons which are [partial equivalence relations](\n /// http://en.wikipedia.org/wiki/Partial_equivalence_relation).\n ///\n-/// This trait allows for partial equality, for types that do not have a full\n-/// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n-/// so floating point types implement `PartialEq` but not `Eq`.\n+/// This trait allows for partial equality, for types that do not have a full equivalence relation.\n+/// For example, in floating point numbers `NaN != NaN`, so floating point types implement\n+/// `PartialEq` but not `Eq`.\n ///\n /// Formally, the equality must be (for all `a`, `b` and `c`):\n ///\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n ///\n-/// Note that these requirements mean that the trait itself must be\n-/// implemented symmetrically and transitively: if `T: PartialEq<U>`\n-/// and `U: PartialEq<V>` then `U: PartialEq<T>` and `T:\n+/// Note that these requirements mean that the trait itself must be implemented symmetrically and\n+/// transitively: if `T: PartialEq<U>` and `U: PartialEq<V>` then `U: PartialEq<T>` and `T:\n /// PartialEq<V>`.\n ///\n-/// PartialEq only requires the `eq` method to be implemented; `ne` is defined\n-/// in terms of it by default. Any manual implementation of `ne` *must* respect\n-/// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n-/// only if `a != b`.\n+/// PartialEq only requires the `eq` method to be implemented; `ne` is defined in terms of it by\n+/// default. Any manual implementation of `ne` *must* respect the rule that `eq` is a strict\n+/// inverse of `ne`; that is, `!(a == b)` if and only if `a != b`.\n #[lang=\"eq\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[old_orphan_check]\n@@ -84,12 +80,15 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n /// Trait for equality comparisons which are [equivalence relations](\n /// https://en.wikipedia.org/wiki/Equivalence_relation).\n ///\n-/// This means, that in addition to `a == b` and `a != b` being strict\n-/// inverses, the equality must be (for all `a`, `b` and `c`):\n+/// This means, that in addition to `a == b` and `a != b` being strict inverses, the equality must\n+/// be (for all `a`, `b` and `c`):\n ///\n /// - reflexive: `a == a`;\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n+///\n+/// This property cannot be checked by the compiler, and therefore `Eq` implies\n+/// `PartialEq`, and has no extra methods.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Eq: PartialEq<Self> {\n     // FIXME #13101: this method is used solely by #[deriving] to\n@@ -101,10 +100,26 @@ pub trait Eq: PartialEq<Self> {\n     // This should never be implemented by hand.\n     #[doc(hidden)]\n     #[inline(always)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn assert_receiver_is_total_eq(&self) {}\n }\n \n-/// An ordering is, e.g, a result of a comparison between two values.\n+/// An `Ordering` is the result of a comparison between two values.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::cmp::Ordering;\n+///\n+/// let result = 1.cmp(&2);\n+/// assert_eq!(Ordering::Less, result);\n+///\n+/// let result = 1.cmp(&1);\n+/// assert_eq!(Ordering::Equal, result);\n+///\n+/// let result = 2.cmp(&1);\n+/// assert_eq!(Ordering::Greater, result);\n+/// ```\n #[derive(Clone, Copy, PartialEq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Ordering {\n@@ -120,17 +135,28 @@ pub enum Ordering {\n }\n \n impl Ordering {\n-    /// Reverse the `Ordering`, so that `Less` becomes `Greater` and\n-    /// vice versa.\n+    /// Reverse the `Ordering`.\n     ///\n-    /// # Example\n+    /// * `Less` becomes `Greater`.\n+    /// * `Greater` becomes `Less`.\n+    /// * `Equal` becomes `Equal`.\n     ///\n-    /// ```rust\n-    /// use std::cmp::Ordering::{Less, Equal, Greater};\n+    /// # Examples\n     ///\n-    /// assert_eq!(Less.reverse(), Greater);\n-    /// assert_eq!(Equal.reverse(), Equal);\n-    /// assert_eq!(Greater.reverse(), Less);\n+    /// Basic behavior:\n+    ///\n+    /// ```\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// assert_eq!(Ordering::Less.reverse(), Ordering::Greater);\n+    /// assert_eq!(Ordering::Equal.reverse(), Ordering::Equal);\n+    /// assert_eq!(Ordering::Greater.reverse(), Ordering::Less);\n+    /// ```\n+    ///\n+    /// This method can be used to reverse a comparison:\n+    ///\n+    /// ```\n+    /// use std::cmp::Ordering;\n     ///\n     /// let mut data: &mut [_] = &mut [2, 10, 5, 8];\n     ///\n@@ -155,28 +181,27 @@ impl Ordering {\n     }\n }\n \n-/// Trait for types that form a [total order](\n-/// https://en.wikipedia.org/wiki/Total_order).\n+/// Trait for types that form a [total order](https://en.wikipedia.org/wiki/Total_order).\n ///\n /// An order is a total order if it is (for all `a`, `b` and `c`):\n ///\n-/// - total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is\n-///   true; and\n-/// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n-///   both `==` and `>`.\n+/// - total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is true; and\n+/// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Ord: Eq + PartialOrd<Self> {\n-    /// This method returns an ordering between `self` and `other` values.\n+    /// This method returns an `Ordering` between `self` and `other`.\n     ///\n-    /// By convention, `self.cmp(&other)` returns the ordering matching\n-    /// the expression `self <operator> other` if true.  For example:\n+    /// By convention, `self.cmp(&other)` returns the ordering matching the expression\n+    /// `self <operator> other` if true.\n+    ///\n+    /// # Examples\n     ///\n     /// ```\n-    /// use std::cmp::Ordering::{Less, Equal, Greater};\n+    /// use std::cmp::Ordering;\n     ///\n-    /// assert_eq!( 5.cmp(&10), Less);     // because 5 < 10\n-    /// assert_eq!(10.cmp(&5),  Greater);  // because 10 > 5\n-    /// assert_eq!( 5.cmp(&5),  Equal);    // because 5 == 5\n+    /// assert_eq!(5.cmp(&10), Ordering::Less);\n+    /// assert_eq!(10.cmp(&5), Ordering::Greater);\n+    /// assert_eq!(5.cmp(&5), Ordering::Equal);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cmp(&self, other: &Self) -> Ordering;\n@@ -208,30 +233,60 @@ impl PartialOrd for Ordering {\n /// The comparison must satisfy, for all `a`, `b` and `c`:\n ///\n /// - antisymmetry: if `a < b` then `!(a > b)` and vice versa; and\n-/// - transitivity: `a < b` and `b < c` implies `a < c`. The same must hold for\n-///   both `==` and `>`.\n+/// - transitivity: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n ///\n-/// Note that these requirements mean that the trait itself must be\n-/// implemented symmetrically and transitively: if `T: PartialOrd<U>`\n-/// and `U: PartialOrd<V>` then `U: PartialOrd<T>` and `T:\n+/// Note that these requirements mean that the trait itself must be implemented symmetrically and\n+/// transitively: if `T: PartialOrd<U>` and `U: PartialOrd<V>` then `U: PartialOrd<T>` and `T:\n /// PartialOrd<V>`.\n ///\n-/// PartialOrd only requires implementation of the `partial_cmp` method,\n-/// with the others generated from default implementations.\n+/// PartialOrd only requires implementation of the `partial_cmp` method, with the others generated\n+/// from default implementations.\n ///\n-/// However it remains possible to implement the others separately for types\n-/// which do not have a total order. For example, for floating point numbers,\n-/// `NaN < 0 == false` and `NaN >= 0 == false` (cf. IEEE 754-2008 section\n-/// 5.11).\n+/// However it remains possible to implement the others separately for types which do not have a\n+/// total order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 ==\n+/// false` (cf. IEEE 754-2008 section 5.11).\n #[lang=\"ord\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n-    /// This method returns an ordering between `self` and `other` values\n-    /// if one exists.\n+    /// This method returns an ordering between `self` and `other` values if one exists.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// let result = 1.0.partial_cmp(&2.0);\n+    /// assert_eq!(result, Some(Ordering::Less));\n+    ///\n+    /// let result = 1.0.partial_cmp(&1.0);\n+    /// assert_eq!(result, Some(Ordering::Equal));\n+    ///\n+    /// let result = 2.0.partial_cmp(&1.0);\n+    /// assert_eq!(result, Some(Ordering::Greater));\n+    /// ```\n+    ///\n+    /// When comparison is impossible:\n+    ///\n+    /// ```\n+    /// let result = std::f64::NAN.partial_cmp(&1.0);\n+    /// assert_eq!(result, None);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;\n \n     /// This method tests less than (for `self` and `other`) and is used by the `<` operator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// let result = 1.0 < 2.0;\n+    /// assert_eq!(result, true);\n+    ///\n+    /// let result = 2.0 < 1.0;\n+    /// assert_eq!(result, false);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lt(&self, other: &Rhs) -> bool {\n@@ -241,7 +296,18 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n         }\n     }\n \n-    /// This method tests less than or equal to (`<=`).\n+    /// This method tests less than or equal to (for `self` and `other`) and is used by the `<=`\n+    /// operator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let result = 1.0 <= 2.0;\n+    /// assert_eq!(result, true);\n+    ///\n+    /// let result = 2.0 <= 2.0;\n+    /// assert_eq!(result, true);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn le(&self, other: &Rhs) -> bool {\n@@ -251,7 +317,17 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n         }\n     }\n \n-    /// This method tests greater than (`>`).\n+    /// This method tests greater than (for `self` and `other`) and is used by the `>` operator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let result = 1.0 > 2.0;\n+    /// assert_eq!(result, false);\n+    ///\n+    /// let result = 2.0 > 2.0;\n+    /// assert_eq!(result, false);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn gt(&self, other: &Rhs) -> bool {\n@@ -261,7 +337,18 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n         }\n     }\n \n-    /// This method tests greater than or equal to (`>=`).\n+    /// This method tests greater than or equal to (for `self` and `other`) and is used by the `>=`\n+    /// operator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let result = 2.0 >= 1.0;\n+    /// assert_eq!(result, true);\n+    ///\n+    /// let result = 2.0 >= 2.0;\n+    /// assert_eq!(result, true);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ge(&self, other: &Rhs) -> bool {\n@@ -273,13 +360,31 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n }\n \n /// Compare and return the minimum of two values.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::cmp;\n+///\n+/// assert_eq!(1, cmp::min(1, 2));\n+/// assert_eq!(2, cmp::min(2, 2));\n+/// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min<T: Ord>(v1: T, v2: T) -> T {\n     if v1 < v2 { v1 } else { v2 }\n }\n \n /// Compare and return the maximum of two values.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::cmp;\n+///\n+/// assert_eq!(2, cmp::max(1, 2));\n+/// assert_eq!(2, cmp::max(2, 2));\n+/// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn max<T: Ord>(v1: T, v2: T) -> T {\n@@ -289,6 +394,24 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n /// Compare and return the minimum of two values if there is one.\n ///\n /// Returns the first argument if the comparison determines them to be equal.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::cmp;\n+///\n+/// assert_eq!(Some(1), cmp::partial_min(1, 2));\n+/// assert_eq!(Some(2), cmp::partial_min(2, 2));\n+/// ```\n+///\n+/// When comparison is impossible:\n+///\n+/// ```\n+/// use std::cmp;\n+///\n+/// let result = cmp::partial_min(std::f64::NAN, 1.0);\n+/// assert_eq!(result, None);\n+/// ```\n #[inline]\n #[unstable(feature = \"core\")]\n pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n@@ -302,6 +425,24 @@ pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n /// Compare and return the maximum of two values if there is one.\n ///\n /// Returns the first argument if the comparison determines them to be equal.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::cmp;\n+///\n+/// assert_eq!(Some(2), cmp::partial_max(1, 2));\n+/// assert_eq!(Some(2), cmp::partial_max(2, 2));\n+/// ```\n+///\n+/// When comparison is impossible:\n+///\n+/// ```\n+/// use std::cmp;\n+///\n+/// let result = cmp::partial_max(std::f64::NAN, 1.0);\n+/// assert_eq!(result, None);\n+/// ```\n #[inline]\n #[unstable(feature = \"core\")]\n pub fn partial_max<T: PartialOrd>(v1: T, v2: T) -> Option<T> {"}, {"sha": "67c8c9fec09ab9df4fd04c16439b783dcc423e89", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -197,6 +197,7 @@ impl<'a> Arguments<'a> {\n     /// created with `argumentuint`. However, failing to do so doesn't cause\n     /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new_v1_formatted(pieces: &'a [&'a str],\n                             args: &'a [ArgumentV1<'a>],\n                             fmt: &'a [rt::v1::Argument]) -> Arguments<'a> {"}, {"sha": "fffba1561a38038d75b3df26db4cbf3bec63d646", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 6, "deletions": 24, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -118,39 +118,21 @@ pub trait FromIterator<A> {\n     fn from_iter<T: Iterator<Item=A>>(iterator: T) -> Self;\n }\n \n-// NOTE(stage0): remove trait after a snapshot\n-#[cfg(stage0)]\n /// Conversion into an `Iterator`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IntoIterator {\n-    type IntoIter: Iterator;\n-\n-    /// Consumes `Self` and returns an iterator over it\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn into_iter(self) -> Self::IntoIter;\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n-/// Conversion into an `Iterator`\n-pub trait IntoIterator {\n     type Item;\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type IntoIter: Iterator<Item=Self::Item>;\n \n     /// Consumes `Self` and returns an iterator over it\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn into_iter(self) -> Self::IntoIter;\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<I> IntoIterator for I where I: Iterator {\n-    type IntoIter = I;\n-\n-    fn into_iter(self) -> I {\n-        self\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator> IntoIterator for I {\n     type Item = I::Item;\n     type IntoIter = I;\n@@ -2374,7 +2356,7 @@ impl<A, St, F> Iterator for Unfold<St, F> where F: FnMut(&mut St) -> Option<A> {\n /// iteration\n #[derive(Clone)]\n #[unstable(feature = \"core\",\n-           reason = \"may be renamed or replaced by range notation adapaters\")]\n+           reason = \"may be renamed or replaced by range notation adapters\")]\n pub struct Counter<A> {\n     /// The current state the counter is at (next value to be yielded)\n     state: A,\n@@ -2385,7 +2367,7 @@ pub struct Counter<A> {\n /// Creates a new counter with the specified start/step\n #[inline]\n #[unstable(feature = \"core\",\n-           reason = \"may be renamed or replaced by range notation adapaters\")]\n+           reason = \"may be renamed or replaced by range notation adapters\")]\n pub fn count<A>(start: A, step: A) -> Counter<A> {\n     Counter{state: start, step: step}\n }"}, {"sha": "f0c60ffe4bf66f8bb0794d105ac56b83230c14d5", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -67,6 +67,7 @@\n #![feature(simd, unsafe_destructor)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n+#![feature(rustc_attrs)]\n \n #[macro_use]\n mod macros;\n@@ -153,25 +154,16 @@ mod array;\n mod core {\n     pub use panicking;\n     pub use fmt;\n-    #[cfg(not(stage0))] pub use clone;\n-    #[cfg(not(stage0))] pub use cmp;\n-    #[cfg(not(stage0))] pub use hash;\n-    #[cfg(not(stage0))] pub use marker;\n-    #[cfg(not(stage0))] pub use option;\n-    #[cfg(not(stage0))] pub use iter;\n+    pub use clone;\n+    pub use cmp;\n+    pub use hash;\n+    pub use marker;\n+    pub use option;\n+    pub use iter;\n }\n \n #[doc(hidden)]\n mod std {\n-    // NOTE: remove after next snapshot\n-    #[cfg(stage0)] pub use clone;\n-    #[cfg(stage0)] pub use cmp;\n-    #[cfg(stage0)] pub use hash;\n-    #[cfg(stage0)] pub use marker;\n-    #[cfg(stage0)] pub use option;\n-    #[cfg(stage0)] pub use fmt;\n-    #[cfg(stage0)] pub use iter;\n-\n     // range syntax\n     pub use ops;\n }"}, {"sha": "56e1c5dedc1cebbc06c21b043629542de6dc4bea", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -32,9 +32,19 @@ use clone::Clone;\n            reason = \"will be overhauled with new lifetime rules; see RFC 458\")]\n #[lang=\"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n+#[cfg(stage0)]\n pub unsafe trait Send: 'static {\n     // empty.\n }\n+/// Types able to be transferred across thread boundaries.\n+#[unstable(feature = \"core\",\n+           reason = \"will be overhauled with new lifetime rules; see RFC 458\")]\n+#[lang=\"send\"]\n+#[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n+#[cfg(not(stage0))]\n+pub unsafe trait Send {\n+    // empty.\n+}\n \n /// Types with a constant size known at compile-time.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -424,3 +434,11 @@ pub struct NoCopy;\n #[lang=\"managed_bound\"]\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n pub struct Managed;\n+\n+#[cfg(not(stage0))]\n+mod impls {\n+    use super::{Send, Sync, Sized};\n+\n+    unsafe impl<'a, T: Sync + ?Sized> Send for &'a T {}\n+    unsafe impl<'a, T: Send + ?Sized> Send for &'a mut T {}\n+}"}, {"sha": "740997b7a249d5a6fcdf472c2e5c277f472a0327", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -43,7 +43,7 @@ pub use intrinsics::forget;\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn size_of<T>() -> uint {\n+pub fn size_of<T>() -> usize {\n     unsafe { intrinsics::size_of::<T>() }\n }\n \n@@ -58,7 +58,7 @@ pub fn size_of<T>() -> uint {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn size_of_val<T>(_val: &T) -> uint {\n+pub fn size_of_val<T>(_val: &T) -> usize {\n     size_of::<T>()\n }\n \n@@ -75,7 +75,7 @@ pub fn size_of_val<T>(_val: &T) -> uint {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn min_align_of<T>() -> uint {\n+pub fn min_align_of<T>() -> usize {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n \n@@ -90,7 +90,7 @@ pub fn min_align_of<T>() -> uint {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn min_align_of_val<T>(_val: &T) -> uint {\n+pub fn min_align_of_val<T>(_val: &T) -> usize {\n     min_align_of::<T>()\n }\n \n@@ -108,7 +108,7 @@ pub fn min_align_of_val<T>(_val: &T) -> uint {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn align_of<T>() -> uint {\n+pub fn align_of<T>() -> usize {\n     // We use the preferred alignment as the default alignment for a type. This\n     // appears to be what clang migrated towards as well:\n     //\n@@ -130,7 +130,7 @@ pub fn align_of<T>() -> uint {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn align_of_val<T>(_val: &T) -> uint {\n+pub fn align_of_val<T>(_val: &T) -> usize {\n     align_of::<T>()\n }\n \n@@ -150,7 +150,7 @@ pub fn align_of_val<T>(_val: &T) -> uint {\n /// ```\n /// use std::mem;\n ///\n-/// let x: int = unsafe { mem::zeroed() };\n+/// let x: i32 = unsafe { mem::zeroed() };\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -171,7 +171,7 @@ pub unsafe fn zeroed<T>() -> T {\n /// ```\n /// use std::mem;\n ///\n-/// let x: int = unsafe { mem::uninitialized() };\n+/// let x: i32 = unsafe { mem::uninitialized() };\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "5644f76306929e0fbfe7a531058e679bb12a9fb3", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -19,8 +19,8 @@ pub unsafe trait Zeroable {}\n unsafe impl<T> Zeroable for *const T {}\n unsafe impl<T> Zeroable for *mut T {}\n unsafe impl<T> Zeroable for Unique<T> { }\n-unsafe impl Zeroable for int {}\n-unsafe impl Zeroable for uint {}\n+unsafe impl Zeroable for isize {}\n+unsafe impl Zeroable for usize {}\n unsafe impl Zeroable for i8 {}\n unsafe impl Zeroable for u8 {}\n unsafe impl Zeroable for i16 {}"}, {"sha": "9a89682127fb1633df1538942e52ac7a277af71e", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -605,6 +605,8 @@ impl<T> Option<T> {\n     /// Returns `None` if the option is `None`, otherwise calls `f` with the\n     /// wrapped value and returns the result.\n     ///\n+    /// Some languages call this operation flatmap.\n+    ///\n     /// # Example\n     ///\n     /// ```"}, {"sha": "bbfe7e58ef4ac4f703b0294c5e6cbab7d1da8b29", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -626,17 +626,7 @@ impl<'a, T> Default for &'a [T] {\n // Iterators\n //\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a, T> IntoIterator for &'a [T] {\n-    type IntoIter = Iter<'a, T>;\n-\n-    fn into_iter(self) -> Iter<'a, T> {\n-        self.iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> IntoIterator for &'a [T] {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n@@ -646,17 +636,7 @@ impl<'a, T> IntoIterator for &'a [T] {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a, T> IntoIterator for &'a mut [T] {\n-    type IntoIter = IterMut<'a, T>;\n-\n-    fn into_iter(self) -> IterMut<'a, T> {\n-        self.iter_mut()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> IntoIterator for &'a mut [T] {\n     type Item = &'a mut T;\n     type IntoIter = IterMut<'a, T>;"}, {"sha": "55fcb8498513c5a804cff7d0cbf3976e0b639171", "filename": "src/libcoretest/finally.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcoretest%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibcoretest%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffinally.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -11,7 +11,7 @@\n #![allow(deprecated)]\n \n use core::finally::{try_finally, Finally};\n-use std::thread::Thread;\n+use std::thread;\n \n #[test]\n fn test_success() {\n@@ -22,7 +22,7 @@ fn test_success() {\n             *i = 10;\n         },\n         |i| {\n-            assert!(!Thread::panicking());\n+            assert!(!thread::panicking());\n             assert_eq!(*i, 10);\n             *i = 20;\n         });\n@@ -40,7 +40,7 @@ fn test_fail() {\n             panic!();\n         },\n         |i| {\n-            assert!(Thread::panicking());\n+            assert!(thread::panicking());\n             assert_eq!(*i, 10);\n         })\n }"}, {"sha": "c743119f4090911bb5d69e0d7383f82e1efc6fef", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -92,6 +92,7 @@\n #![feature(collections)]\n #![feature(int_uint)]\n #![feature(staged_api)]\n+#![feature(str_words)]\n #![cfg_attr(test, feature(rustc_private))]\n \n #[cfg(test)] #[macro_use] extern crate log;"}, {"sha": "230deabee0034eaff12df6802944b6e415464fee", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -276,7 +276,7 @@\n #![feature(int_uint)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(io)]\n+#![feature(old_io)]\n \n use self::LabelText::*;\n "}, {"sha": "0aa41e03f9f71734a764e4fd06aba0da157c3be2", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -5734,10 +5734,3 @@ pub mod funcs {\n pub fn issue_14344_workaround() {} // FIXME #14344 force linkage to happen correctly\n \n #[test] fn work_on_windows() { } // FIXME #10872 needed for a happy windows\n-\n-// NOTE: remove after next snapshot\n-#[doc(hidden)]\n-#[cfg(all(stage0, not(test)))]\n-mod std {\n-    pub use core::marker;\n-}"}, {"sha": "4dab07acfd2a0285626f962f7325440adf07709f", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -171,7 +171,7 @@\n #![feature(box_syntax)]\n #![feature(int_uint)]\n #![feature(core)]\n-#![feature(io)]\n+#![feature(old_io)]\n #![feature(std_misc)]\n #![feature(env)]\n "}, {"sha": "915c70bbf8ce1d90a6818dc8367ed95c00da4588", "filename": "src/librand/lib.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -497,17 +497,6 @@ pub struct Open01<F>(pub F);\n /// ```\n pub struct Closed01<F>(pub F);\n \n-// NOTE: remove after next snapshot\n-#[cfg(all(stage0, not(test)))]\n-mod std {\n-    pub use core::{option, fmt}; // panic!()\n-    pub use core::clone; // derive Clone\n-    pub use core::marker;\n-    // for-loops\n-    pub use core::iter;\n-    pub use core::ops; // slicing syntax\n-}\n-\n #[cfg(test)]\n mod test {\n     use std::rand;"}, {"sha": "488d5999323866e5ba5bbc98606cb5c2288519a9", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -28,7 +28,7 @@\n #![feature(collections)]\n #![feature(core)]\n #![feature(int_uint)]\n-#![feature(io)]\n+#![feature(old_io)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n "}, {"sha": "37097764f717c10bc1e5c0ca2b0e21df19e83607", "filename": "src/librustc/README.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FREADME.txt?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -4,8 +4,8 @@ An informal guide to reading and working on the rustc compiler.\n If you wish to expand on this document, or have a more experienced\n Rust contributor add anything else to it, please get in touch:\n \n-https://github.com/rust-lang/rust/wiki/Note-development-policy\n-(\"Communication\" subheading)\n+* http://internals.rust-lang.org/\n+* https://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust\n \n or file a bug:\n "}, {"sha": "fe9a81bb7c984f60d7b2b40e12b9f9106ddfd4ce", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -29,10 +29,10 @@\n #![feature(core)]\n #![feature(hash)]\n #![feature(int_uint)]\n-#![feature(io)]\n+#![feature(old_io)]\n #![feature(libc)]\n #![feature(env)]\n-#![feature(path)]\n+#![feature(old_path)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}, {"sha": "ba108b5488edee23cb7d84a09192b74f2e20b987", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 10, "deletions": 57, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -47,6 +47,7 @@ use syntax::{abi, ast, ast_map};\n use syntax::ast_util::is_shift_binop;\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{self, Span};\n+use syntax::feature_gate::{KNOWN_ATTRIBUTES, AttributeType};\n use syntax::parse::token;\n use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n use syntax::ast_util;\n@@ -640,67 +641,19 @@ impl LintPass for UnusedAttributes {\n     }\n \n     fn check_attribute(&mut self, cx: &Context, attr: &ast::Attribute) {\n-        static ATTRIBUTE_WHITELIST: &'static [&'static str] = &[\n-            // FIXME: #14408 whitelist docs since rustdoc looks at them\n-            \"doc\",\n-\n-            // FIXME: #14406 these are processed in trans, which happens after the\n-            // lint pass\n-            \"cold\",\n-            \"export_name\",\n-            \"inline\",\n-            \"link\",\n-            \"link_name\",\n-            \"link_section\",\n-            \"linkage\",\n-            \"no_builtins\",\n-            \"no_mangle\",\n-            \"no_split_stack\",\n-            \"no_stack_check\",\n-            \"packed\",\n-            \"static_assert\",\n-            \"thread_local\",\n-            \"no_debug\",\n-            \"omit_gdb_pretty_printer_section\",\n-            \"unsafe_no_drop_flag\",\n-\n-            // used in resolve\n-            \"prelude_import\",\n-\n-            // FIXME: #14407 these are only looked at on-demand so we can't\n-            // guarantee they'll have already been checked\n-            \"deprecated\",\n-            \"must_use\",\n-            \"stable\",\n-            \"unstable\",\n-            \"rustc_on_unimplemented\",\n-            \"rustc_error\",\n-\n-            // FIXME: #19470 this shouldn't be needed forever\n-            \"old_orphan_check\",\n-            \"old_impl_check\",\n-            \"rustc_paren_sugar\", // FIXME: #18101 temporary unboxed closure hack\n-        ];\n-\n-        static CRATE_ATTRS: &'static [&'static str] = &[\n-            \"crate_name\",\n-            \"crate_type\",\n-            \"feature\",\n-            \"no_start\",\n-            \"no_main\",\n-            \"no_std\",\n-            \"no_builtins\",\n-        ];\n-\n-        for &name in ATTRIBUTE_WHITELIST {\n-            if attr.check_name(name) {\n-                break;\n+        for &(ref name, ty) in KNOWN_ATTRIBUTES {\n+            match ty {\n+                AttributeType::Whitelisted\n+                | AttributeType::Gated(_, _) if attr.check_name(name) => {\n+                    break;\n+                },\n+                _ => ()\n             }\n         }\n \n         if !attr::is_used(attr) {\n             cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n-            if CRATE_ATTRS.contains(&&attr.name()[]) {\n+            if KNOWN_ATTRIBUTES.contains(&(&attr.name()[], AttributeType::CrateLevel)) {\n                 let msg = match attr.node.style {\n                     ast::AttrOuter => \"crate-level attribute should be an inner \\\n                                        attribute: add an exclamation mark: #![foo]\",\n@@ -1761,7 +1714,7 @@ impl LintPass for Stability {\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        stability::check_item(cx.tcx, item,\n+        stability::check_item(cx.tcx, item, false,\n                               &mut |id, sp, stab| self.lint(cx, id, sp, stab));\n     }\n "}, {"sha": "0a0f555f977698e7581c1435489bc5bd9dfa6781", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -261,12 +261,12 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                 if self.tcx.sess.features.borrow().unmarked_api {\n                     self.tcx.sess.span_warn(span, \"use of unmarked library feature\");\n                     self.tcx.sess.span_note(span, \"this is either a bug in the library you are \\\n-                                                   using and a bug in the compiler - please \\\n+                                                   using or a bug in the compiler - please \\\n                                                    report it in both places\");\n                 } else {\n                     self.tcx.sess.span_err(span, \"use of unmarked library feature\");\n                     self.tcx.sess.span_note(span, \"this is either a bug in the library you are \\\n-                                                   using and a bug in the compiler - please \\\n+                                                   using or a bug in the compiler - please \\\n                                                    report it in both places\");\n                     self.tcx.sess.span_note(span, \"use #![feature(unmarked_api)] in the \\\n                                                    crate attributes to override this\");\n@@ -283,7 +283,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n         // name `__test`\n         if item.span == DUMMY_SP && item.ident.as_str() == \"__test\" { return }\n \n-        check_item(self.tcx, item,\n+        check_item(self.tcx, item, true,\n                    &mut |id, sp, stab| self.check(id, sp, stab));\n         visit::walk_item(self, item);\n     }\n@@ -302,7 +302,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n }\n \n /// Helper for discovering nodes to check for stability\n-pub fn check_item(tcx: &ty::ctxt, item: &ast::Item,\n+pub fn check_item(tcx: &ty::ctxt, item: &ast::Item, warn_about_defns: bool,\n                   cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n     match item.node {\n         ast::ItemExternCrate(_) => {\n@@ -316,6 +316,35 @@ pub fn check_item(tcx: &ty::ctxt, item: &ast::Item,\n             let id = ast::DefId { krate: cnum, node: ast::CRATE_NODE_ID };\n             maybe_do_stability_check(tcx, id, item.span, cb);\n         }\n+\n+        // For implementations of traits, check the stability of each item\n+        // individually as it's possible to have a stable trait with unstable\n+        // items.\n+        ast::ItemImpl(_, _, _, Some(ref t), _, ref impl_items) => {\n+            let trait_did = tcx.def_map.borrow()[t.ref_id].def_id();\n+            let trait_items = ty::trait_items(tcx, trait_did);\n+\n+            for impl_item in impl_items {\n+                let (ident, span) = match *impl_item {\n+                    ast::MethodImplItem(ref method) => {\n+                        (match method.node {\n+                            ast::MethDecl(ident, _, _, _, _, _, _, _) => ident,\n+                            ast::MethMac(..) => unreachable!(),\n+                        }, method.span)\n+                    }\n+                    ast::TypeImplItem(ref typedef) => {\n+                        (typedef.ident, typedef.span)\n+                    }\n+                };\n+                let item = trait_items.iter().find(|item| {\n+                    item.name() == ident.name\n+                }).unwrap();\n+                if warn_about_defns {\n+                    maybe_do_stability_check(tcx, item.def_id(), span, cb);\n+                }\n+            }\n+        }\n+\n         _ => (/* pass */)\n     }\n }"}, {"sha": "9bf35bd4284722c62a4f39880f5fbd70d543a042", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -530,17 +530,6 @@ impl<'a,T> Iterator for EnumeratedItems<'a,T> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T> IntoIterator for VecPerParamSpace<T> {\n-    type IntoIter = IntoIter<T>;\n-\n-    fn into_iter(self) -> IntoIter<T> {\n-        self.into_vec().into_iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n impl<T> IntoIterator for VecPerParamSpace<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n@@ -550,17 +539,6 @@ impl<T> IntoIterator for VecPerParamSpace<T> {\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a,T> IntoIterator for &'a VecPerParamSpace<T> {\n-    type IntoIter = Iter<'a, T>;\n-\n-    fn into_iter(self) -> Iter<'a, T> {\n-        self.as_slice().into_iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n impl<'a,T> IntoIterator for &'a VecPerParamSpace<T> {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;"}, {"sha": "061557eb7dccd2311c51584170c41c308ade61d6", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -20,7 +20,7 @@ use self::EvaluationResult::*;\n use super::{DerivedObligationCause};\n use super::{project};\n use super::project::Normalized;\n-use super::{PredicateObligation, Obligation, TraitObligation, ObligationCause};\n+use super::{PredicateObligation, TraitObligation, ObligationCause};\n use super::{ObligationCauseCode, BuiltinDerivedObligation};\n use super::{SelectionError, Unimplemented, Overflow, OutputTypeParameterMismatch};\n use super::{Selection};\n@@ -34,7 +34,7 @@ use super::{util};\n use middle::fast_reject;\n use middle::mem_categorization::Typer;\n use middle::subst::{Subst, Substs, TypeSpace, VecPerParamSpace};\n-use middle::ty::{self, AsPredicate, RegionEscape, ToPolyTraitRef, Ty};\n+use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n use middle::infer;\n use middle::infer::{InferCtxt, TypeFreshener};\n use middle::ty_fold::TypeFoldable;\n@@ -1459,22 +1459,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                     ty::BoundSync |\n                     ty::BoundSend => {\n-                        // Note: technically, a region pointer is only\n-                        // sendable if it has lifetime\n-                        // `'static`. However, we don't take regions\n-                        // into account when doing trait matching:\n-                        // instead, when we decide that `T : Send`, we\n-                        // will register a separate constraint with\n-                        // the region inferencer that `T : 'static`\n-                        // holds as well (because the trait `Send`\n-                        // requires it). This will ensure that there\n-                        // is no borrowed data in `T` (or else report\n-                        // an inference error). The reason we do it\n-                        // this way is that we do not yet *know* what\n-                        // lifetime the borrowed reference has, since\n-                        // we haven't finished running inference -- in\n-                        // other words, there's a kind of\n-                        // chicken-and-egg problem.\n                         Ok(If(vec![referent_ty]))\n                     }\n                 }\n@@ -1817,21 +1801,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             })\n         }).collect::<Result<_, _>>();\n-        let mut obligations = match obligations {\n+        let obligations = match obligations {\n             Ok(o) => o,\n             Err(ErrorReported) => Vec::new()\n         };\n \n-        // as a special case, `Send` requires `'static`\n-        if bound == ty::BoundSend {\n-            obligations.push(Obligation {\n-                cause: obligation.cause.clone(),\n-                recursion_depth: obligation.recursion_depth+1,\n-                predicate: ty::Binder(ty::OutlivesPredicate(obligation.self_ty(),\n-                                                            ty::ReStatic)).as_predicate(),\n-            });\n-        }\n-\n         let obligations = VecPerParamSpace::new(obligations, Vec::new(), Vec::new());\n \n         debug!(\"vtable_builtin_data: obligations={}\","}, {"sha": "8618bde95fe6fe3e0fdd498b427d14f9c9f6d024", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -73,8 +73,6 @@ use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::fmt;\n use std::hash::{Hash, Writer, SipHasher, Hasher};\n-#[cfg(stage0)]\n-use std::marker;\n use std::mem;\n use std::ops;\n use std::rc::Rc;\n@@ -944,26 +942,6 @@ pub struct TyS<'tcx> {\n \n     // the maximal depth of any bound regions appearing in this type.\n     region_depth: u32,\n-\n-    // force the lifetime to be invariant to work-around\n-    // region-inference issues with a covariant lifetime.\n-    #[cfg(stage0)]\n-    marker: ShowInvariantLifetime<'tcx>,\n-}\n-\n-#[cfg(stage0)]\n-struct ShowInvariantLifetime<'a>(marker::InvariantLifetime<'a>);\n-#[cfg(stage0)]\n-impl<'a> ShowInvariantLifetime<'a> {\n-    fn new() -> ShowInvariantLifetime<'a> {\n-        ShowInvariantLifetime(marker::InvariantLifetime)\n-    }\n-}\n-#[cfg(stage0)]\n-impl<'a> fmt::Debug for ShowInvariantLifetime<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"InvariantLifetime\")\n-    }\n }\n \n impl fmt::Debug for TypeFlags {\n@@ -972,14 +950,6 @@ impl fmt::Debug for TypeFlags {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<'tcx> PartialEq for TyS<'tcx> {\n-    fn eq<'a,'b>(&'a self, other: &'b TyS<'tcx>) -> bool {\n-        let other: &'a TyS<'tcx> = unsafe { mem::transmute(other) };\n-        (self as *const _) == (other as *const _)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<'tcx> PartialEq for TyS<'tcx> {\n     fn eq(&self, other: &TyS<'tcx>) -> bool {\n         // (self as *const _) == (other as *const _)\n@@ -2562,12 +2532,6 @@ fn intern_ty<'tcx>(type_arena: &'tcx TypedArena<TyS<'tcx>>,\n     let flags = FlagComputation::for_sty(&st);\n \n     let ty = match () {\n-        #[cfg(stage0)]\n-        () => type_arena.alloc(TyS { sty: st,\n-                                     flags: flags.flags,\n-                                     region_depth: flags.depth,\n-                                     marker: ShowInvariantLifetime::new(), }),\n-        #[cfg(not(stage0))]\n         () => type_arena.alloc(TyS { sty: st,\n                                      flags: flags.flags,\n                                      region_depth: flags.depth, }),"}, {"sha": "5768539b2cd76fe5502a20598bc5e1bee9ace8c4", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -645,7 +645,7 @@ pub fn build_target_config(opts: &Options, sp: &SpanHandler) -> Config {\n         \"32\" => (ast::TyI32, ast::TyU32),\n         \"64\" => (ast::TyI64, ast::TyU64),\n         w    => sp.handler().fatal(&format!(\"target specification was invalid: unrecognized \\\n-                                            target-word-size {}\", w)[])\n+                                             target-pointer-width {}\", w)[])\n     };\n \n     Config {"}, {"sha": "426101e858a8985e00b83c3618052c7d85d1888f", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -697,9 +697,8 @@ impl<'tcx> UserString<'tcx> for ty::TyTrait<'tcx> {\n         }\n \n         // Region, if not obviously implied by builtin bounds.\n-        if bounds.region_bound != ty::ReStatic ||\n-            !bounds.builtin_bounds.contains(&ty::BoundSend)\n-        { // Region bound is implied by builtin bounds:\n+        if bounds.region_bound != ty::ReStatic {\n+            // Region bound is implied by builtin bounds:\n             components.push(bounds.region_bound.user_string(tcx));\n         }\n "}, {"sha": "d589b063204c7d2d0fa903d6ff2848cd2de84454", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -35,9 +35,9 @@\n #![feature(core)]\n #![feature(hash)]\n #![feature(int_uint)]\n-#![feature(io)]\n+#![feature(old_io)]\n #![feature(os)]\n-#![feature(path)]\n+#![feature(old_path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(env)]"}, {"sha": "692e6b474fd27b985ba55ca7eb6f7f41372ef7e3", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -40,7 +40,7 @@\n //! this module defines the format the JSON file should take, though each\n //! underscore in the field names should be replaced with a hyphen (`-`) in the\n //! JSON file. Some fields are required in every target specification, such as\n-//! `data-layout`, `llvm-target`, `target-endian`, `target-word-size`, and\n+//! `data-layout`, `llvm-target`, `target-endian`, `target-pointer-width`, and\n //! `arch`. In general, options passed to rustc with `-C` override the target's\n //! settings, though `target-feature` and `link-args` will *add* to the list\n //! specified by the target, rather than replace.\n@@ -245,7 +245,7 @@ impl Target {\n             data_layout: get_req_field(\"data-layout\"),\n             llvm_target: get_req_field(\"llvm-target\"),\n             target_endian: get_req_field(\"target-endian\"),\n-            target_pointer_width: get_req_field(\"target-word-size\"),\n+            target_pointer_width: get_req_field(\"target-pointer-width\"),\n             arch: get_req_field(\"arch\"),\n             target_os: get_req_field(\"os\"),\n             options: Default::default(),"}, {"sha": "728ff6475999800e8300c11fece1457afb946a90", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -471,9 +471,10 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                 new_path.extend(env::split_paths(&_old_path));\n                 env::set_var(\"PATH\", &env::join_paths(new_path.iter()).unwrap());\n             }\n+            let features = sess.features.borrow();\n             let cfg = syntax::ext::expand::ExpansionConfig {\n                 crate_name: crate_name.to_string(),\n-                enable_quotes: sess.features.borrow().quote,\n+                features: Some(&features),\n                 recursion_limit: sess.recursion_limit.get(),\n             };\n             let ret = syntax::ext::expand::expand_crate(&sess.parse_sess,"}, {"sha": "ac91a0098ea75bf20b7ed1f0ef633b200a2e9c14", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -28,16 +28,15 @@\n #![feature(core)]\n #![feature(env)]\n #![feature(int_uint)]\n-#![feature(io)]\n+#![feature(old_io)]\n #![feature(libc)]\n #![feature(os)]\n-#![feature(path)]\n+#![feature(old_path)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(unsafe_destructor)]\n #![feature(staged_api)]\n-#![feature(std_misc)]\n #![feature(unicode)]\n \n extern crate arena;\n@@ -73,7 +72,7 @@ use rustc::metadata;\n use rustc::util::common::time;\n \n use std::cmp::Ordering::Equal;\n-use std::old_io;\n+use std::old_io::{self, stdio};\n use std::iter::repeat;\n use std::env;\n use std::sync::mpsc::channel;\n@@ -94,7 +93,7 @@ pub mod pretty;\n \n \n static BUG_REPORT_URL: &'static str =\n-    \"http://doc.rust-lang.org/complement-bugreport.html\";\n+    \"https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\";\n \n \n pub fn run(args: Vec<String>) -> int {\n@@ -765,7 +764,7 @@ fn parse_crate_attrs(sess: &Session, input: &Input) ->\n ///\n /// The diagnostic emitter yielded to the procedure should be used for reporting\n /// errors of the compiler.\n-pub fn monitor<F:FnOnce()+Send>(f: F) {\n+pub fn monitor<F:FnOnce()+Send+'static>(f: F) {\n     static STACK_SIZE: uint = 8 * 1024 * 1024; // 8MB\n \n     let (tx, rx) = channel();\n@@ -780,7 +779,7 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n         cfg = cfg.stack_size(STACK_SIZE);\n     }\n \n-    match cfg.scoped(move || { std::old_io::stdio::set_stderr(box w); f() }).join() {\n+    match cfg.spawn(move || { stdio::set_stderr(box w); f() }).unwrap().join() {\n         Ok(()) => { /* fallthrough */ }\n         Err(value) => {\n             // Thread panicked without emitting a fatal diagnostic"}, {"sha": "aa90d7c851ba62f8b6c75e9f38be8bb081dcd463", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 61, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -29,7 +29,7 @@\n #![feature(int_uint)]\n #![feature(libc)]\n #![feature(link_args)]\n-#![feature(path)]\n+#![feature(old_path)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n \n@@ -58,7 +58,7 @@ pub use self::Linkage::*;\n \n use std::ffi::CString;\n use std::cell::RefCell;\n-use std::{raw, mem, ptr};\n+use std::{raw, mem};\n use libc::{c_uint, c_ushort, uint64_t, c_int, size_t, c_char};\n use libc::{c_longlong, c_ulonglong, c_void};\n use debuginfo::{DIBuilderRef, DIDescriptor,\n@@ -2251,65 +2251,6 @@ pub unsafe fn debug_loc_to_string(c: ContextRef, tr: DebugLocRef) -> String {\n         .expect(\"got a non-UTF8 DebugLoc from LLVM\")\n }\n \n-// FIXME #15460 - create a public function that actually calls our\n-// static LLVM symbols. Otherwise the linker will just throw llvm\n-// away.  We're just calling lots of stuff until we transitively get\n-// all of LLVM. This is worse than anything.\n-pub unsafe fn static_link_hack_this_sucks() {\n-    LLVMInitializePasses();\n-\n-    LLVMInitializeX86TargetInfo();\n-    LLVMInitializeX86Target();\n-    LLVMInitializeX86TargetMC();\n-    LLVMInitializeX86AsmPrinter();\n-    LLVMInitializeX86AsmParser();\n-\n-    LLVMInitializeARMTargetInfo();\n-    LLVMInitializeARMTarget();\n-    LLVMInitializeARMTargetMC();\n-    LLVMInitializeARMAsmPrinter();\n-    LLVMInitializeARMAsmParser();\n-\n-    LLVMInitializeAArch64TargetInfo();\n-    LLVMInitializeAArch64Target();\n-    LLVMInitializeAArch64TargetMC();\n-    LLVMInitializeAArch64AsmPrinter();\n-    LLVMInitializeAArch64AsmParser();\n-\n-    LLVMInitializeMipsTargetInfo();\n-    LLVMInitializeMipsTarget();\n-    LLVMInitializeMipsTargetMC();\n-    LLVMInitializeMipsAsmPrinter();\n-    LLVMInitializeMipsAsmParser();\n-\n-    LLVMInitializePowerPCTargetInfo();\n-    LLVMInitializePowerPCTarget();\n-    LLVMInitializePowerPCTargetMC();\n-    LLVMInitializePowerPCAsmPrinter();\n-    LLVMInitializePowerPCAsmParser();\n-\n-    LLVMRustSetLLVMOptions(0 as c_int, ptr::null());\n-\n-    LLVMPassManagerBuilderPopulateModulePassManager(ptr::null_mut(), ptr::null_mut());\n-    LLVMPassManagerBuilderPopulateLTOPassManager(ptr::null_mut(), ptr::null_mut(), False, False);\n-    LLVMPassManagerBuilderPopulateFunctionPassManager(ptr::null_mut(), ptr::null_mut());\n-    LLVMPassManagerBuilderSetOptLevel(ptr::null_mut(), 0 as c_uint);\n-    LLVMPassManagerBuilderUseInlinerWithThreshold(ptr::null_mut(), 0 as c_uint);\n-    LLVMWriteBitcodeToFile(ptr::null_mut(), ptr::null());\n-    LLVMPassManagerBuilderCreate();\n-    LLVMPassManagerBuilderDispose(ptr::null_mut());\n-\n-    LLVMRustLinkInExternalBitcode(ptr::null_mut(), ptr::null(), 0 as size_t);\n-\n-    LLVMLinkInMCJIT();\n-    LLVMLinkInInterpreter();\n-\n-    extern {\n-        fn LLVMLinkInMCJIT();\n-        fn LLVMLinkInInterpreter();\n-    }\n-}\n-\n // The module containing the native LLVM dependencies, generated by the build system\n // Note that this must come after the rustllvm extern declaration so that\n // parts of LLVM that rustllvm depends on aren't thrown away by the linker."}, {"sha": "9934d9993d61df0b2b95e6bacc048fd181aa616d", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -939,7 +939,7 @@ fn run_work_multithreaded(sess: &Session,\n             }\n \n             tx.take().unwrap().send(()).unwrap();\n-        });\n+        }).unwrap();\n     }\n \n     let mut panicked = false;"}, {"sha": "4606200d058c6e06d43d8fe19a6f1217c4658352", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -30,10 +30,10 @@\n #![feature(core)]\n #![feature(hash)]\n #![feature(int_uint)]\n-#![feature(io)]\n+#![feature(old_io)]\n #![feature(env)]\n #![feature(libc)]\n-#![feature(path)]\n+#![feature(old_path)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}, {"sha": "b0ed6f9e727a2fdf5f64b3050df0b12bf1a66f98", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -827,7 +827,19 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                            &format!(\"comparison of `{}`\",\n                                    cx.ty_to_string(rhs_t))[],\n                            StrEqFnLangItem);\n-        callee::trans_lang_call(cx, did, &[lhs, rhs], None, debug_loc)\n+        let t = ty::mk_str_slice(cx.tcx(), cx.tcx().mk_region(ty::ReStatic), ast::MutImmutable);\n+        // The comparison function gets the slices by value, so we have to make copies here. Even\n+        // if the function doesn't write through the pointer, things like lifetime intrinsics\n+        // require that we do this properly\n+        let lhs_arg = alloc_ty(cx, t, \"lhs\");\n+        let rhs_arg = alloc_ty(cx, t, \"rhs\");\n+        memcpy_ty(cx, lhs_arg, lhs, t);\n+        memcpy_ty(cx, rhs_arg, rhs, t);\n+        let res = callee::trans_lang_call(cx, did, &[lhs_arg, rhs_arg], None, debug_loc);\n+        call_lifetime_end(res.bcx, lhs_arg);\n+        call_lifetime_end(res.bcx, rhs_arg);\n+\n+        res\n     }\n \n     let _icx = push_ctxt(\"compare_values\");"}, {"sha": "bab734db126505efa94ec072d6bd92d91fb2f6de", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -25,15 +25,16 @@\n #![feature(env)]\n #![feature(hash)]\n #![feature(int_uint)]\n-#![feature(io)]\n+#![feature(old_io)]\n #![feature(libc)]\n #![feature(os)]\n-#![feature(path)]\n+#![feature(old_path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(test)]\n #![feature(unicode)]\n+#![feature(str_words)]\n \n extern crate arena;\n extern crate getopts;\n@@ -55,6 +56,7 @@ use std::env;\n use std::old_io::File;\n use std::old_io;\n use std::rc::Rc;\n+use std::sync::mpsc::channel;\n use externalfiles::ExternalHtml;\n use serialize::Decodable;\n use serialize::json::{self, Json};\n@@ -125,8 +127,8 @@ pub fn main() {\n     let res = std::thread::Builder::new().stack_size(STACK_SIZE).scoped(move || {\n         let s = env::args().collect::<Vec<_>>();\n         main_args(&s)\n-    }).join();\n-    env::set_exit_status(res.ok().unwrap() as i32);\n+    }).unwrap().join();\n+    env::set_exit_status(res as i32);\n }\n \n pub fn opts() -> Vec<getopts::OptGroup> {\n@@ -365,12 +367,14 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     let cr = Path::new(cratefile);\n     info!(\"starting to run rustc\");\n \n-    let (mut krate, analysis) = std::thread::Thread::scoped(move || {\n+    let (tx, rx) = channel();\n+    std::thread::spawn(move || {\n         use rustc::session::config::Input;\n \n         let cr = cr;\n-        core::run_core(paths, cfgs, externs, Input::File(cr), triple)\n+        tx.send(core::run_core(paths, cfgs, externs, Input::File(cr), triple)).unwrap();\n     }).join().map_err(|_| \"rustc failed\").unwrap();\n+    let (mut krate, analysis) = rx.recv().unwrap();\n     info!(\"finished with rustc\");\n     let mut analysis = Some(analysis);\n     ANALYSISKEY.with(|s| {"}, {"sha": "bf14b86ebd1e39e21189cd0097dff9072a15fcd7", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -15,7 +15,7 @@ use std::old_io::{Command, TempDir};\n use std::old_io;\n use std::env;\n use std::str;\n-use std::thread::Thread;\n+use std::thread;\n use std::thunk::Thunk;\n \n use std::collections::{HashSet, HashMap};\n@@ -142,7 +142,7 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     let w1 = old_io::ChanWriter::new(tx);\n     let w2 = w1.clone();\n     let old = old_io::stdio::set_stderr(box w1);\n-    Thread::spawn(move || {\n+    thread::spawn(move || {\n         let mut p = old_io::ChanReader::new(rx);\n         let mut err = match old {\n             Some(old) => {"}, {"sha": "853da598ab5be8aebeaa86bf8718e4c9882b0eab", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -29,8 +29,8 @@ Core encoding and decoding interfaces.\n #![feature(collections)]\n #![feature(core)]\n #![feature(int_uint)]\n-#![feature(io)]\n-#![feature(path)]\n+#![feature(old_io)]\n+#![feature(old_path)]\n #![feature(hash)]\n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "4d38d17576ddb2a15ee7fe13624ff1a993a979e6", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 122, "deletions": 70, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -12,15 +12,12 @@\n \n //! Operations on ASCII strings and characters\n \n-#![unstable(feature = \"std_misc\",\n-            reason = \"unsure about placement and naming\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use iter::IteratorExt;\n-use ops::FnMut;\n-use slice::SliceExt;\n-use str::StrExt;\n-use string::String;\n-use vec::Vec;\n+use prelude::v1::*;\n+\n+use mem;\n+use iter::Range;\n \n /// Extension methods for ASCII-subset only operations on owned strings\n #[unstable(feature = \"std_misc\",\n@@ -38,52 +35,79 @@ pub trait OwnedAsciiExt {\n }\n \n /// Extension methods for ASCII-subset only operations on string slices\n-#[unstable(feature = \"std_misc\",\n-           reason = \"would prefer to do this in a more general way\")]\n-pub trait AsciiExt<T = Self> {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait AsciiExt {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Owned;\n+\n     /// Check if within the ASCII range.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_ascii(&self) -> bool;\n \n     /// Makes a copy of the string in ASCII upper case:\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n     /// but non-ASCII letters are unchanged.\n-    fn to_ascii_uppercase(&self) -> T;\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn to_ascii_uppercase(&self) -> Self::Owned;\n \n     /// Makes a copy of the string in ASCII lower case:\n     /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n     /// but non-ASCII letters are unchanged.\n-    fn to_ascii_lowercase(&self) -> T;\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn to_ascii_lowercase(&self) -> Self::Owned;\n \n     /// Check that two strings are an ASCII case-insensitive match.\n     /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n     /// but without allocating and copying temporary strings.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn eq_ignore_ascii_case(&self, other: &Self) -> bool;\n+\n+    /// Convert this type to its ASCII upper case equivalent in-place.\n+    ///\n+    /// See `to_ascii_uppercase` for more information.\n+    #[unstable(feature = \"ascii\")]\n+    fn make_ascii_uppercase(&mut self);\n+\n+    /// Convert this type to its ASCII lower case equivalent in-place.\n+    ///\n+    /// See `to_ascii_lowercase` for more information.\n+    #[unstable(feature = \"ascii\")]\n+    fn make_ascii_lowercase(&mut self);\n }\n \n-#[unstable(feature = \"std_misc\",\n-           reason = \"would prefer to do this in a more general way\")]\n-impl AsciiExt<String> for str {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsciiExt for str {\n+    type Owned = String;\n+\n     #[inline]\n     fn is_ascii(&self) -> bool {\n         self.bytes().all(|b| b.is_ascii())\n     }\n \n     #[inline]\n     fn to_ascii_uppercase(&self) -> String {\n-        // Vec<u8>::to_ascii_uppercase() preserves the UTF-8 invariant.\n-        unsafe { String::from_utf8_unchecked(self.as_bytes().to_ascii_uppercase()) }\n+        self.to_string().into_ascii_uppercase()\n     }\n \n     #[inline]\n     fn to_ascii_lowercase(&self) -> String {\n-        // Vec<u8>::to_ascii_lowercase() preserves the UTF-8 invariant.\n-        unsafe { String::from_utf8_unchecked(self.as_bytes().to_ascii_lowercase()) }\n+        self.to_string().into_ascii_lowercase()\n     }\n \n     #[inline]\n     fn eq_ignore_ascii_case(&self, other: &str) -> bool {\n         self.as_bytes().eq_ignore_ascii_case(other.as_bytes())\n     }\n+\n+    fn make_ascii_uppercase(&mut self) {\n+        let me: &mut [u8] = unsafe { mem::transmute(self) };\n+        me.make_ascii_uppercase()\n+    }\n+\n+    fn make_ascii_lowercase(&mut self) {\n+        let me: &mut [u8] = unsafe { mem::transmute(self) };\n+        me.make_ascii_lowercase()\n+    }\n }\n \n #[unstable(feature = \"std_misc\",\n@@ -102,22 +126,22 @@ impl OwnedAsciiExt for String {\n     }\n }\n \n-#[unstable(feature = \"std_misc\",\n-           reason = \"would prefer to do this in a more general way\")]\n-impl AsciiExt<Vec<u8>> for [u8] {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsciiExt for [u8] {\n+    type Owned = Vec<u8>;\n     #[inline]\n     fn is_ascii(&self) -> bool {\n         self.iter().all(|b| b.is_ascii())\n     }\n \n     #[inline]\n     fn to_ascii_uppercase(&self) -> Vec<u8> {\n-        self.iter().map(|b| b.to_ascii_uppercase()).collect()\n+        self.to_vec().into_ascii_uppercase()\n     }\n \n     #[inline]\n     fn to_ascii_lowercase(&self) -> Vec<u8> {\n-        self.iter().map(|b| b.to_ascii_lowercase()).collect()\n+        self.to_vec().into_ascii_lowercase()\n     }\n \n     #[inline]\n@@ -127,55 +151,58 @@ impl AsciiExt<Vec<u8>> for [u8] {\n             a.eq_ignore_ascii_case(b)\n         })\n     }\n+\n+    fn make_ascii_uppercase(&mut self) {\n+        for byte in self {\n+            byte.make_ascii_uppercase();\n+        }\n+    }\n+\n+    fn make_ascii_lowercase(&mut self) {\n+        for byte in self {\n+            byte.make_ascii_lowercase();\n+        }\n+    }\n }\n \n #[unstable(feature = \"std_misc\",\n            reason = \"would prefer to do this in a more general way\")]\n impl OwnedAsciiExt for Vec<u8> {\n     #[inline]\n     fn into_ascii_uppercase(mut self) -> Vec<u8> {\n-        for byte in &mut self {\n-            *byte = byte.to_ascii_uppercase();\n-        }\n+        self.make_ascii_uppercase();\n         self\n     }\n \n     #[inline]\n     fn into_ascii_lowercase(mut self) -> Vec<u8> {\n-        for byte in &mut self {\n-            *byte = byte.to_ascii_lowercase();\n-        }\n+        self.make_ascii_lowercase();\n         self\n     }\n }\n \n-#[unstable(feature = \"std_misc\",\n-           reason = \"would prefer to do this in a more general way\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsciiExt for u8 {\n+    type Owned = u8;\n     #[inline]\n-    fn is_ascii(&self) -> bool {\n-        *self & 128 == 0u8\n-    }\n-\n+    fn is_ascii(&self) -> bool { *self & 128 == 0u8 }\n     #[inline]\n-    fn to_ascii_uppercase(&self) -> u8 {\n-        ASCII_UPPERCASE_MAP[*self as usize]\n-    }\n-\n+    fn to_ascii_uppercase(&self) -> u8 { ASCII_UPPERCASE_MAP[*self as usize] }\n     #[inline]\n-    fn to_ascii_lowercase(&self) -> u8 {\n-        ASCII_LOWERCASE_MAP[*self as usize]\n-    }\n-\n+    fn to_ascii_lowercase(&self) -> u8 { ASCII_LOWERCASE_MAP[*self as usize] }\n     #[inline]\n     fn eq_ignore_ascii_case(&self, other: &u8) -> bool {\n         self.to_ascii_lowercase() == other.to_ascii_lowercase()\n     }\n+    #[inline]\n+    fn make_ascii_uppercase(&mut self) { *self = self.to_ascii_uppercase(); }\n+    #[inline]\n+    fn make_ascii_lowercase(&mut self) { *self = self.to_ascii_lowercase(); }\n }\n \n-#[unstable(feature = \"std_misc\",\n-           reason = \"would prefer to do this in a more general way\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsciiExt for char {\n+    type Owned = char;\n     #[inline]\n     fn is_ascii(&self) -> bool {\n         *self as u32 <= 0x7F\n@@ -203,6 +230,19 @@ impl AsciiExt for char {\n     fn eq_ignore_ascii_case(&self, other: &char) -> bool {\n         self.to_ascii_lowercase() == other.to_ascii_lowercase()\n     }\n+\n+    #[inline]\n+    fn make_ascii_uppercase(&mut self) { *self = self.to_ascii_uppercase(); }\n+    #[inline]\n+    fn make_ascii_lowercase(&mut self) { *self = self.to_ascii_lowercase(); }\n+}\n+\n+/// An iterator over the escaped version of a byte, constructed via\n+/// `std::ascii::escape_default`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct EscapeDefault {\n+    range: Range<usize>,\n+    data: [u8; 4],\n }\n \n /// Returns a 'default' ASCII and C++11-like literal escape of a `u8`\n@@ -214,34 +254,46 @@ impl AsciiExt for char {\n /// - Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n /// - Single-quote, double-quote and backslash chars are backslash-escaped.\n /// - Any other chars in the range [0x20,0x7e] are not escaped.\n-/// - Any other chars are given hex escapes.\n+/// - Any other chars are given hex escapes of the form '\\xNN'.\n /// - Unicode escapes are never generated by this function.\n-#[unstable(feature = \"std_misc\",\n-           reason = \"needs to be updated to use an iterator\")]\n-pub fn escape_default<F>(c: u8, mut f: F) where\n-    F: FnMut(u8),\n-{\n-    match c {\n-        b'\\t' => { f(b'\\\\'); f(b't'); }\n-        b'\\r' => { f(b'\\\\'); f(b'r'); }\n-        b'\\n' => { f(b'\\\\'); f(b'n'); }\n-        b'\\\\' => { f(b'\\\\'); f(b'\\\\'); }\n-        b'\\'' => { f(b'\\\\'); f(b'\\''); }\n-        b'\"'  => { f(b'\\\\'); f(b'\"'); }\n-        b'\\x20' ... b'\\x7e' => { f(c); }\n-        _ => {\n-            f(b'\\\\');\n-            f(b'x');\n-            for &offset in &[4u, 0u] {\n-                match ((c as i32) >> offset) & 0xf {\n-                    i @ 0 ... 9 => f(b'0' + (i as u8)),\n-                    i => f(b'a' + (i as u8 - 10)),\n-                }\n-            }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn escape_default(c: u8) -> EscapeDefault {\n+    let (data, len) = match c {\n+        b'\\t' => ([b'\\\\', b't', 0, 0], 2),\n+        b'\\r' => ([b'\\\\', b'r', 0, 0], 2),\n+        b'\\n' => ([b'\\\\', b'n', 0, 0], 2),\n+        b'\\\\' => ([b'\\\\', b'\\\\', 0, 0], 2),\n+        b'\\'' => ([b'\\\\', b'\\'', 0, 0], 2),\n+        b'\"' => ([b'\\\\', b'\"', 0, 0], 2),\n+        b'\\x20' ... b'\\x7e' => ([c, 0, 0, 0], 1),\n+        _ => ([b'\\\\', b'x', hexify(c >> 4), hexify(c & 0xf)], 4),\n+    };\n+\n+    return EscapeDefault { range: range(0, len), data: data };\n+\n+    fn hexify(b: u8) -> u8 {\n+        match b {\n+            0 ... 9 => b'0' + b,\n+            _ => b'a' + b - 10,\n         }\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Iterator for EscapeDefault {\n+    type Item = u8;\n+    fn next(&mut self) -> Option<u8> { self.range.next().map(|i| self.data[i]) }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl DoubleEndedIterator for EscapeDefault {\n+    fn next_back(&mut self) -> Option<u8> {\n+        self.range.next_back().map(|i| self.data[i])\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ExactSizeIterator for EscapeDefault {}\n+\n static ASCII_LOWERCASE_MAP: [u8; 256] = [\n     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n     0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,"}, {"sha": "1b9f8b9901723af27cffd7df2a72aed7c93794d9", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 3, "deletions": 45, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -1372,21 +1372,7 @@ enum VacantEntryState<K, V, M> {\n     NoElem(EmptyBucket<K, V, M>),\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a, K, V, S, H> IntoIterator for &'a HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type IntoIter = Iter<'a, K, V>;\n-\n-    fn into_iter(self) -> Iter<'a, K, V> {\n-        self.iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V, S, H> IntoIterator for &'a HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -1400,21 +1386,7 @@ impl<'a, K, V, S, H> IntoIterator for &'a HashMap<K, V, S>\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a, K, V, S, H> IntoIterator for &'a mut HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type IntoIter = IterMut<'a, K, V>;\n-\n-    fn into_iter(mut self) -> IterMut<'a, K, V> {\n-        self.iter_mut()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V, S, H> IntoIterator for &'a mut HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -1428,21 +1400,7 @@ impl<'a, K, V, S, H> IntoIterator for &'a mut HashMap<K, V, S>\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<K, V, S, H> IntoIterator for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type IntoIter = IntoIter<K, V>;\n-\n-    fn into_iter(self) -> IntoIter<K, V> {\n-        self.into_iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, H> IntoIterator for HashMap<K, V, S>\n     where K: Eq + Hash<H>,\n           S: HashState<Hasher=H>,"}, {"sha": "5fbbcb3b347afefdeba9ac386a0d62e16c5b6a0b", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -835,21 +835,7 @@ pub struct Union<'a, T: 'a, S: 'a> {\n     iter: Chain<Iter<'a, T>, Difference<'a, T, S>>\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<'a, T, S, H> IntoIterator for &'a HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type IntoIter = Iter<'a, T>;\n-\n-    fn into_iter(self) -> Iter<'a, T> {\n-        self.iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S, H> IntoIterator for &'a HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -863,21 +849,7 @@ impl<'a, T, S, H> IntoIterator for &'a HashSet<T, S>\n     }\n }\n \n-// NOTE(stage0): remove impl after a snapshot\n-#[cfg(stage0)]\n-impl<T, S, H> IntoIterator for HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type IntoIter = IntoIter<T>;\n-\n-    fn into_iter(self) -> IntoIter<T> {\n-        self.into_iter()\n-    }\n-}\n-\n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S, H> IntoIterator for HashSet<T, S>\n     where T: Eq + Hash<H>,\n           S: HashState<Hasher=H>,"}, {"sha": "93dc3efe2c4fc7a1186811dc4e346c20db8fba85", "filename": "src/libstd/env.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -488,12 +488,20 @@ impl Iterator for Args {\n     fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n+impl ExactSizeIterator for Args {\n+    fn len(&self) -> usize { self.inner.len() }\n+}\n+\n impl Iterator for ArgsOs {\n     type Item = OsString;\n     fn next(&mut self) -> Option<OsString> { self.inner.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n+impl ExactSizeIterator for ArgsOs {\n+    fn len(&self) -> usize { self.inner.len() }\n+}\n+\n /// Returns the page size of the current architecture in bytes.\n pub fn page_size() -> usize {\n     os_imp::page_size()"}, {"sha": "69791084e2f9fa77fa24301c9947e27bcdaa622b", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -114,7 +114,7 @@ impl File {\n \n     /// Open a file in write-only mode.\n     ///\n-    /// This function will create a file it it does not exist,\n+    /// This function will create a file if it does not exist,\n     /// and will truncate it if it does.\n     ///\n     /// See the `OpenOptions::open` function for more details."}, {"sha": "c38d52161c96e8484ab8e656b224d29f7f9595e8", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -443,9 +443,8 @@ pub trait Seek {\n     /// A seek beyond the end of a stream is allowed, but seeking before offset\n     /// 0 is an error.\n     ///\n-    /// Seeking past the end of the stream does not modify the underlying\n-    /// stream, but the next write may cause the previous data to be filled in\n-    /// with a bit pattern.\n+    /// The behavior when seeking past the end of the stream is implementation\n+    /// defined.\n     ///\n     /// This method returns the new position within the stream if the seek\n     /// operation completed successfully."}, {"sha": "7c9a8a7b4b5ad2a8bef03bb3337ae19d7c3346c4", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -292,13 +292,6 @@ mod tuple;\n // can be resolved within libstd.\n #[doc(hidden)]\n mod std {\n-    // NOTE: remove after next snapshot\n-    // mods used for deriving\n-    #[cfg(stage0)] pub use clone;\n-    #[cfg(stage0)] pub use cmp;\n-    #[cfg(stage0)] pub use hash;\n-    #[cfg(stage0)] pub use default;\n-\n     pub use sync; // used for select!()\n     pub use error; // used for try!()\n     pub use fmt; // used for any formatting strings\n@@ -319,7 +312,4 @@ mod std {\n     pub use slice;\n \n     pub use boxed; // used for vec![]\n-    // for-loops\n-    // NOTE: remove after next snapshot\n-    #[cfg(stage0)] pub use iter;\n }"}, {"sha": "00bb7f86b170cf47b536ed5bdfac11b0405dd590", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -60,23 +60,6 @@ macro_rules! panic {\n     });\n }\n \n-/// Use the syntax described in `std::fmt` to create a value of type `String`.\n-/// See `std::fmt` for more information.\n-///\n-/// # Example\n-///\n-/// ```\n-/// format!(\"test\");\n-/// format!(\"hello {}\", \"world!\");\n-/// format!(\"x = {}, y = {y}\", 10, y = 30);\n-/// ```\n-#[cfg(stage0)] // NOTE: remove after snapshot\n-#[macro_export]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-macro_rules! format {\n-    ($($arg:tt)*) => ($crate::fmt::format(format_args!($($arg)*)))\n-}\n-\n /// Equivalent to the `println!` macro except that a newline is not printed at\n /// the end of the message.\n #[macro_export]\n@@ -126,7 +109,7 @@ macro_rules! try {\n /// # Examples\n ///\n /// ```\n-/// use std::thread::Thread;\n+/// use std::thread;\n /// use std::sync::mpsc;\n ///\n /// // two placeholder functions for now\n@@ -136,8 +119,8 @@ macro_rules! try {\n /// let (tx1, rx1) = mpsc::channel();\n /// let (tx2, rx2) = mpsc::channel();\n ///\n-/// Thread::spawn(move|| { long_running_task(); tx1.send(()).unwrap(); });\n-/// Thread::spawn(move|| { tx2.send(calculate_the_answer()).unwrap(); });\n+/// thread::spawn(move|| { long_running_task(); tx1.send(()).unwrap(); });\n+/// thread::spawn(move|| { tx2.send(calculate_the_answer()).unwrap(); });\n ///\n /// select! (\n ///     _ = rx1.recv() => println!(\"the long running task finished first\"),"}, {"sha": "b861b74947eeb20961995bc8a48450ccc3efe25c", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -43,7 +43,7 @@ pub struct TcpStream(net_imp::TcpStream);\n ///\n /// ```no_run\n /// use std::net::{TcpListener, TcpStream};\n-/// use std::thread::Thread;\n+/// use std::thread;\n ///\n /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n ///\n@@ -55,7 +55,7 @@ pub struct TcpStream(net_imp::TcpStream);\n /// for stream in listener.incoming() {\n ///     match stream {\n ///         Ok(stream) => {\n-///             Thread::spawn(move|| {\n+///             thread::spawn(move|| {\n ///                 // connection succeeded\n ///                 handle_client(stream)\n ///             });\n@@ -217,7 +217,7 @@ mod tests {\n     use net::*;\n     use net::test::{next_test_ip4, next_test_ip6};\n     use sync::mpsc::channel;\n-    use thread::Thread;\n+    use thread;\n \n     fn each_ip(f: &mut FnMut(SocketAddr)) {\n         f(next_test_ip4());\n@@ -247,7 +247,8 @@ mod tests {\n     fn connect_error() {\n         match TcpStream::connect(\"0.0.0.0:1\") {\n             Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind(), ErrorKind::ConnectionRefused),\n+            Err(e) => assert!((e.kind() == ErrorKind::ConnectionRefused)\n+                              || (e.kind() == ErrorKind::InvalidInput)),\n         }\n     }\n \n@@ -256,7 +257,7 @@ mod tests {\n         let socket_addr = next_test_ip4();\n         let listener = t!(TcpListener::bind(&socket_addr));\n \n-        let _t = Thread::scoped(move || {\n+        let _t = thread::spawn(move || {\n             let mut stream = t!(TcpStream::connect(&(\"localhost\",\n                                                      socket_addr.port())));\n             t!(stream.write(&[144]));\n@@ -273,7 +274,7 @@ mod tests {\n         let addr = next_test_ip4();\n         let acceptor = t!(TcpListener::bind(&addr));\n \n-        let _t = Thread::scoped(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut stream = t!(TcpStream::connect(&(\"127.0.0.1\", addr.port())));\n             t!(stream.write(&[44]));\n         });\n@@ -289,7 +290,7 @@ mod tests {\n         let addr = next_test_ip6();\n         let acceptor = t!(TcpListener::bind(&addr));\n \n-        let _t = Thread::scoped(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut stream = t!(TcpStream::connect(&(\"::1\", addr.port())));\n             t!(stream.write(&[66]));\n         });\n@@ -306,7 +307,7 @@ mod tests {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n             let (tx, rx) = channel();\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut stream = t!(TcpStream::connect(&addr));\n                 t!(stream.write(&[99]));\n                 tx.send(t!(stream.socket_addr())).unwrap();\n@@ -325,7 +326,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let _stream = t!(TcpStream::connect(&addr));\n                 // Close\n             });\n@@ -345,7 +346,7 @@ mod tests {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n             let (tx, rx) = channel();\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 drop(t!(TcpStream::connect(&addr)));\n                 tx.send(()).unwrap();\n             });\n@@ -371,7 +372,7 @@ mod tests {\n             let max = 10;\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 for _ in 0..max {\n                     let mut stream = t!(TcpStream::connect(&addr));\n                     t!(stream.write(&[99]));\n@@ -393,11 +394,11 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let acceptor = acceptor;\n                 for (i, stream) in acceptor.incoming().enumerate().take(MAX) {\n                     // Start another task to handle the connection\n-                    let _t = Thread::scoped(move|| {\n+                    let _t = thread::spawn(move|| {\n                         let mut stream = t!(stream);\n                         let mut buf = [0];\n                         t!(stream.read(&mut buf));\n@@ -412,7 +413,7 @@ mod tests {\n         fn connect(i: usize, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            let t = Thread::scoped(move|| {\n+            let t = thread::spawn(move|| {\n                 let mut stream = t!(TcpStream::connect(&addr));\n                 // Connect again before writing\n                 connect(i + 1, addr);\n@@ -428,10 +429,10 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 for stream in acceptor.incoming().take(MAX) {\n                     // Start another task to handle the connection\n-                    let _t = Thread::scoped(move|| {\n+                    let _t = thread::spawn(move|| {\n                         let mut stream = t!(stream);\n                         let mut buf = [0];\n                         t!(stream.read(&mut buf));\n@@ -446,7 +447,7 @@ mod tests {\n         fn connect(i: usize, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            let t = Thread::scoped(move|| {\n+            let t = thread::spawn(move|| {\n                 let mut stream = t!(TcpStream::connect(&addr));\n                 connect(i + 1, addr);\n                 t!(stream.write(&[99]));\n@@ -467,7 +468,7 @@ mod tests {\n             let listener = t!(TcpListener::bind(&addr));\n             let so_name = t!(listener.socket_addr());\n             assert_eq!(addr, so_name);\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 t!(listener.accept());\n             });\n \n@@ -481,7 +482,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let (tx, rx) = channel();\n             let srv = t!(TcpListener::bind(&addr));\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut cl = t!(srv.accept()).0;\n                 cl.write(&[10]).unwrap();\n                 let mut b = [0];\n@@ -517,7 +518,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 t!(TcpStream::connect(&addr));\n             });\n \n@@ -532,7 +533,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut s = t!(TcpStream::connect(&addr));\n                 let mut buf = [0, 0];\n                 assert_eq!(s.read(&mut buf), Ok(1));\n@@ -545,7 +546,7 @@ mod tests {\n \n             let (tx1, rx1) = channel();\n             let (tx2, rx2) = channel();\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut s2 = s2;\n                 rx1.recv().unwrap();\n                 t!(s2.write(&[1]));\n@@ -565,7 +566,7 @@ mod tests {\n             let (tx1, rx) = channel();\n             let tx2 = tx1.clone();\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut s = t!(TcpStream::connect(&addr));\n                 t!(s.write(&[1]));\n                 rx.recv().unwrap();\n@@ -577,7 +578,7 @@ mod tests {\n             let s2 = t!(s1.try_clone());\n \n             let (done, rx) = channel();\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut s2 = s2;\n                 let mut buf = [0, 0];\n                 t!(s2.read(&mut buf));\n@@ -597,7 +598,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut s = t!(TcpStream::connect(&addr));\n                 let mut buf = [0, 1];\n                 t!(s.read(&mut buf));\n@@ -608,7 +609,7 @@ mod tests {\n             let s2 = t!(s1.try_clone());\n \n             let (done, rx) = channel();\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut s2 = s2;\n                 t!(s2.write(&[1]));\n                 done.send(()).unwrap();\n@@ -623,7 +624,7 @@ mod tests {\n     fn shutdown_smoke() {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut c = t!(a.accept()).0;\n                 let mut b = [0];\n                 assert_eq!(c.read(&mut b), Ok(0));\n@@ -644,7 +645,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n             let (tx, rx) = channel::<()>();\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let _s = t!(a.accept());\n                 let _ = rx.recv();\n             });\n@@ -682,15 +683,15 @@ mod tests {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n             let (tx1, rx) = channel::<()>();\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let _s = t!(a.accept());\n                 let _ = rx.recv();\n             });\n \n             let s = t!(TcpStream::connect(&addr));\n             let s2 = t!(s.try_clone());\n             let (tx, rx) = channel();\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut s2 = s2;\n                 assert_eq!(t!(s2.read(&mut [0])), 0);\n                 tx.send(()).unwrap();\n@@ -713,7 +714,7 @@ mod tests {\n             let (tx, rx) = channel();\n             let (txdone, rxdone) = channel();\n             let txdone2 = txdone.clone();\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut tcp = t!(TcpStream::connect(&addr));\n                 rx.recv().unwrap();\n                 t!(tcp.write(&[0]));\n@@ -724,15 +725,15 @@ mod tests {\n             let tcp = t!(accept.accept()).0;\n             let tcp2 = t!(tcp.try_clone());\n             let txdone3 = txdone.clone();\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut tcp2 = tcp2;\n                 t!(tcp2.read(&mut [0]));\n                 txdone3.send(()).unwrap();\n             });\n \n             // Try to ensure that the reading clone is indeed reading\n             for _ in 0..50 {\n-                Thread::yield_now();\n+                thread::yield_now();\n             }\n \n             // clone the handle again while it's reading, then let it finish the\n@@ -750,10 +751,10 @@ mod tests {\n             let a = t!(TcpListener::bind(&addr));\n             let a2 = t!(a.try_clone());\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let _ = TcpStream::connect(&addr);\n             });\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let _ = TcpStream::connect(&addr);\n             });\n \n@@ -771,17 +772,17 @@ mod tests {\n             let (tx, rx) = channel();\n             let tx2 = tx.clone();\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 tx.send(t!(a.accept())).unwrap();\n             });\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 tx2.send(t!(a2.accept())).unwrap();\n             });\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let _ = TcpStream::connect(&addr);\n             });\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let _ = TcpStream::connect(&addr);\n             });\n "}, {"sha": "92f00599826dd14d1e603cae5a68988a6ee55d9d", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -131,7 +131,7 @@ mod tests {\n     use net::*;\n     use net::test::{next_test_ip4, next_test_ip6};\n     use sync::mpsc::channel;\n-    use thread::Thread;\n+    use thread;\n \n     fn each_ip(f: &mut FnMut(SocketAddr, SocketAddr)) {\n         f(next_test_ip4(), next_test_ip4());\n@@ -164,7 +164,7 @@ mod tests {\n             let (tx1, rx1) = channel();\n             let (tx2, rx2) = channel();\n \n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 let client = t!(UdpSocket::bind(&client_ip));\n                 rx1.recv().unwrap();\n                 t!(client.send_to(&[99], &server_ip));\n@@ -196,7 +196,7 @@ mod tests {\n             let sock1 = t!(UdpSocket::bind(&addr1));\n             let sock2 = t!(UdpSocket::bind(&addr2));\n \n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut buf = [0, 0];\n                 assert_eq!(sock2.recv_from(&mut buf), Ok((1, addr1)));\n                 assert_eq!(buf[0], 1);\n@@ -207,7 +207,7 @@ mod tests {\n \n             let (tx1, rx1) = channel();\n             let (tx2, rx2) = channel();\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 rx1.recv().unwrap();\n                 t!(sock3.send_to(&[1], &addr2));\n                 tx2.send(()).unwrap();\n@@ -227,7 +227,7 @@ mod tests {\n             let (tx1, rx) = channel();\n             let tx2 = tx1.clone();\n \n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 t!(sock2.send_to(&[1], &addr1));\n                 rx.recv().unwrap();\n                 t!(sock2.send_to(&[2], &addr1));\n@@ -237,7 +237,7 @@ mod tests {\n             let sock3 = t!(sock1.try_clone());\n \n             let (done, rx) = channel();\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut buf = [0, 0];\n                 t!(sock3.recv_from(&mut buf));\n                 tx2.send(()).unwrap();\n@@ -260,7 +260,7 @@ mod tests {\n             let (tx, rx) = channel();\n             let (serv_tx, serv_rx) = channel();\n \n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut buf = [0, 1];\n                 rx.recv().unwrap();\n                 t!(sock2.recv_from(&mut buf));\n@@ -271,7 +271,7 @@ mod tests {\n \n             let (done, rx) = channel();\n             let tx2 = tx.clone();\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 match sock3.send_to(&[1], &addr2) {\n                     Ok(..) => { let _ = tx2.send(()); }\n                     Err(..) => {}"}, {"sha": "4582dcd2b0392f117556dc807e9e42719b5fb6ea", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 777, "deletions": 42, "changes": 819, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -51,71 +51,143 @@ pub trait Float\n     + Rem<Output=Self>\n {\n     // inlined methods from `num::Float`\n-    /// Returns the NaN value.\n+    /// Returns the `NaN` value.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let nan: f32 = Float::nan();\n+    ///\n+    /// assert!(nan.is_nan());\n+    /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn nan() -> Self;\n     /// Returns the infinite value.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f32;\n+    ///\n+    /// let infinity: f32 = Float::infinity();\n+    ///\n+    /// assert!(infinity.is_infinite());\n+    /// assert!(!infinity.is_finite());\n+    /// assert!(infinity > f32::MAX);\n+    /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn infinity() -> Self;\n     /// Returns the negative infinite value.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f32;\n+    ///\n+    /// let neg_infinity: f32 = Float::neg_infinity();\n+    ///\n+    /// assert!(neg_infinity.is_infinite());\n+    /// assert!(!neg_infinity.is_finite());\n+    /// assert!(neg_infinity < f32::MIN);\n+    /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn neg_infinity() -> Self;\n-    /// Returns the `0` value.\n+    /// Returns `0.0`.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let inf: f32 = Float::infinity();\n+    /// let zero: f32 = Float::zero();\n+    /// let neg_zero: f32 = Float::neg_zero();\n+    ///\n+    /// assert_eq!(zero, neg_zero);\n+    /// assert_eq!(7.0f32/inf, zero);\n+    /// assert_eq!(zero * 10.0, zero);\n+    /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn zero() -> Self;\n-    /// Returns -0.0.\n+    /// Returns `-0.0`.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let inf: f32 = Float::infinity();\n+    /// let zero: f32 = Float::zero();\n+    /// let neg_zero: f32 = Float::neg_zero();\n+    ///\n+    /// assert_eq!(zero, neg_zero);\n+    /// assert_eq!(7.0f32/inf, zero);\n+    /// assert_eq!(zero * 10.0, zero);\n+    /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn neg_zero() -> Self;\n-    /// Returns the `1` value.\n+    /// Returns `1.0`.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let one: f32 = Float::one();\n+    ///\n+    /// assert_eq!(one, 1.0f32);\n+    /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn one() -> Self;\n \n     // FIXME (#5527): These should be associated constants\n \n-    /// Returns the number of binary digits of mantissa that this type supports.\n+    /// Deprecated: use `std::f32::MANTISSA_DIGITS` or `std::f64::MANTISSA_DIGITS`\n+    /// instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MANTISSA_DIGITS` or \\\n                            `std::f64::MANTISSA_DIGITS` as appropriate\")]\n     fn mantissa_digits(unused_self: Option<Self>) -> uint;\n-    /// Returns the number of base-10 digits of precision that this type supports.\n+    /// Deprecated: use `std::f32::DIGITS` or `std::f64::DIGITS` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n     fn digits(unused_self: Option<Self>) -> uint;\n-    /// Returns the difference between 1.0 and the smallest representable number larger than 1.0.\n+    /// Deprecated: use `std::f32::EPSILON` or `std::f64::EPSILON` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\")]\n     fn epsilon() -> Self;\n-    /// Returns the minimum binary exponent that this type can represent.\n+    /// Deprecated: use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n     fn min_exp(unused_self: Option<Self>) -> int;\n-    /// Returns the maximum binary exponent that this type can represent.\n+    /// Deprecated: use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n     fn max_exp(unused_self: Option<Self>) -> int;\n-    /// Returns the minimum base-10 exponent that this type can represent.\n+    /// Deprecated: use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n     fn min_10_exp(unused_self: Option<Self>) -> int;\n-    /// Returns the maximum base-10 exponent that this type can represent.\n+    /// Deprecated: use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n     fn max_10_exp(unused_self: Option<Self>) -> int;\n \n     /// Returns the smallest finite value that this type can represent.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64;\n+    ///\n+    /// let x: f64 = Float::min_value();\n+    ///\n+    /// assert_eq!(x, f64::MIN);\n+    /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn min_value() -> Self;\n@@ -124,225 +196,888 @@ pub trait Float\n                reason = \"unsure about its place in the world\")]\n     fn min_pos_value(unused_self: Option<Self>) -> Self;\n     /// Returns the largest finite value that this type can represent.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64;\n+    ///\n+    /// let x: f64 = Float::max_value();\n+    /// assert_eq!(x, f64::MAX);\n+    /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn max_value() -> Self;\n-\n-    /// Returns true if this value is NaN and false otherwise.\n+    /// Returns `true` if this value is `NaN` and false otherwise.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64;\n+    ///\n+    /// let nan = f64::NAN;\n+    /// let f = 7.0;\n+    ///\n+    /// assert!(nan.is_nan());\n+    /// assert!(!f.is_nan());\n+    /// ```\n     #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n     fn is_nan(self) -> bool;\n-    /// Returns true if this value is positive infinity or negative infinity and\n+    /// Returns `true` if this value is positive infinity or negative infinity and\n     /// false otherwise.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f32;\n+    ///\n+    /// let f = 7.0f32;\n+    /// let inf: f32 = Float::infinity();\n+    /// let neg_inf: f32 = Float::neg_infinity();\n+    /// let nan: f32 = f32::NAN;\n+    ///\n+    /// assert!(!f.is_infinite());\n+    /// assert!(!nan.is_infinite());\n+    ///\n+    /// assert!(inf.is_infinite());\n+    /// assert!(neg_inf.is_infinite());\n+    /// ```\n     #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n     fn is_infinite(self) -> bool;\n-    /// Returns true if this number is neither infinite nor NaN.\n+    /// Returns `true` if this number is neither infinite nor `NaN`.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f32;\n+    ///\n+    /// let f = 7.0f32;\n+    /// let inf: f32 = Float::infinity();\n+    /// let neg_inf: f32 = Float::neg_infinity();\n+    /// let nan: f32 = f32::NAN;\n+    ///\n+    /// assert!(f.is_finite());\n+    ///\n+    /// assert!(!nan.is_finite());\n+    /// assert!(!inf.is_finite());\n+    /// assert!(!neg_inf.is_finite());\n+    /// ```\n     #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n     fn is_finite(self) -> bool;\n-    /// Returns true if this number is neither zero, infinite, denormal, or NaN.\n+    /// Returns `true` if the number is neither zero, infinite,\n+    /// [subnormal][subnormal], or `NaN`.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f32;\n+    ///\n+    /// let min = f32::MIN_POSITIVE; // 1.17549435e-38f32\n+    /// let max = f32::MAX;\n+    /// let lower_than_min = 1.0e-40_f32;\n+    /// let zero = 0.0f32;\n+    ///\n+    /// assert!(min.is_normal());\n+    /// assert!(max.is_normal());\n+    ///\n+    /// assert!(!zero.is_normal());\n+    /// assert!(!f32::NAN.is_normal());\n+    /// assert!(!f32::INFINITY.is_normal());\n+    /// // Values between `0` and `min` are Subnormal.\n+    /// assert!(!lower_than_min.is_normal());\n+    /// ```\n+    /// [subnormal]: http://en.wikipedia.org/wiki/Denormal_number\n     #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n     fn is_normal(self) -> bool;\n-    /// Returns the category that this number falls into.\n+\n+    /// Returns the floating point category of the number. If only one property\n+    /// is going to be tested, it is generally faster to use the specific\n+    /// predicate instead.\n+    ///\n+    /// ```\n+    /// use std::num::{Float, FpCategory};\n+    /// use std::f32;\n+    ///\n+    /// let num = 12.4f32;\n+    /// let inf = f32::INFINITY;\n+    ///\n+    /// assert_eq!(num.classify(), FpCategory::Normal);\n+    /// assert_eq!(inf.classify(), FpCategory::Infinite);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn classify(self) -> FpCategory;\n \n-    /// Returns the mantissa, exponent and sign as integers, respectively.\n+    /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.\n+    /// The original number can be recovered by `sign * mantissa * 2 ^ exponent`.\n+    /// The floating point encoding is documented in the [Reference][floating-point].\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let num = 2.0f32;\n+    ///\n+    /// // (8388608u64, -22i16, 1i8)\n+    /// let (mantissa, exponent, sign) = num.integer_decode();\n+    /// let sign_f = sign as f32;\n+    /// let mantissa_f = mantissa as f32;\n+    /// let exponent_f = num.powf(exponent as f32);\n+    ///\n+    /// // 1 * 8388608 * 2^(-22) == 2\n+    /// let abs_difference = (sign_f * mantissa_f * exponent_f - num).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n+    /// [floating-point]: ../../../../../reference.html#machine-types\n     #[unstable(feature = \"std_misc\", reason = \"signature is undecided\")]\n     fn integer_decode(self) -> (u64, i16, i8);\n \n-    /// Return the largest integer less than or equal to a number.\n+    /// Returns the largest integer less than or equal to a number.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let f = 3.99;\n+    /// let g = 3.0;\n+    ///\n+    /// assert_eq!(f.floor(), 3.0);\n+    /// assert_eq!(g.floor(), 3.0);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn floor(self) -> Self;\n-    /// Return the smallest integer greater than or equal to a number.\n+    /// Returns the smallest integer greater than or equal to a number.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let f = 3.01;\n+    /// let g = 4.0;\n+    ///\n+    /// assert_eq!(f.ceil(), 4.0);\n+    /// assert_eq!(g.ceil(), 4.0);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ceil(self) -> Self;\n-    /// Return the nearest integer to a number. Round half-way cases away from\n+    /// Returns the nearest integer to a number. Round half-way cases away from\n     /// `0.0`.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let f = 3.3;\n+    /// let g = -3.3;\n+    ///\n+    /// assert_eq!(f.round(), 3.0);\n+    /// assert_eq!(g.round(), -3.0);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn round(self) -> Self;\n     /// Return the integer part of a number.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let f = 3.3;\n+    /// let g = -3.7;\n+    ///\n+    /// assert_eq!(f.trunc(), 3.0);\n+    /// assert_eq!(g.trunc(), -3.0);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trunc(self) -> Self;\n-    /// Return the fractional part of a number.\n+    /// Returns the fractional part of a number.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let x = 3.5;\n+    /// let y = -3.5;\n+    /// let abs_difference_x = (x.fract() - 0.5).abs();\n+    /// let abs_difference_y = (y.fract() - (-0.5)).abs();\n+    ///\n+    /// assert!(abs_difference_x < 1e-10);\n+    /// assert!(abs_difference_y < 1e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fract(self) -> Self;\n-\n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n     /// number is `Float::nan()`.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64;\n+    ///\n+    /// let x = 3.5;\n+    /// let y = -3.5;\n+    ///\n+    /// let abs_difference_x = (x.abs() - x).abs();\n+    /// let abs_difference_y = (y.abs() - (-y)).abs();\n+    ///\n+    /// assert!(abs_difference_x < 1e-10);\n+    /// assert!(abs_difference_y < 1e-10);\n+    ///\n+    /// assert!(f64::NAN.abs().is_nan());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn abs(self) -> Self;\n     /// Returns a number that represents the sign of `self`.\n     ///\n     /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n     /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n     /// - `Float::nan()` if the number is `Float::nan()`\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64;\n+    ///\n+    /// let f = 3.5;\n+    ///\n+    /// assert_eq!(f.signum(), 1.0);\n+    /// assert_eq!(f64::NEG_INFINITY.signum(), -1.0);\n+    ///\n+    /// assert!(f64::NAN.signum().is_nan());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn signum(self) -> Self;\n     /// Returns `true` if `self` is positive, including `+0.0` and\n     /// `Float::infinity()`.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64;\n+    ///\n+    /// let nan: f64 = f64::NAN;\n+    ///\n+    /// let f = 7.0;\n+    /// let g = -7.0;\n+    ///\n+    /// assert!(f.is_positive());\n+    /// assert!(!g.is_positive());\n+    /// // Requires both tests to determine if is `NaN`\n+    /// assert!(!nan.is_positive() && !nan.is_negative());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_positive(self) -> bool;\n     /// Returns `true` if `self` is negative, including `-0.0` and\n     /// `Float::neg_infinity()`.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64;\n+    ///\n+    /// let nan = f64::NAN;\n+    ///\n+    /// let f = 7.0;\n+    /// let g = -7.0;\n+    ///\n+    /// assert!(!f.is_negative());\n+    /// assert!(g.is_negative());\n+    /// // Requires both tests to determine if is `NaN`.\n+    /// assert!(!nan.is_positive() && !nan.is_negative());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_negative(self) -> bool;\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error. This produces a more accurate result with better performance than\n     /// a separate multiplication operation followed by an add.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let m = 10.0;\n+    /// let x = 4.0;\n+    /// let b = 60.0;\n+    ///\n+    /// // 100.0\n+    /// let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn mul_add(self, a: Self, b: Self) -> Self;\n     /// Take the reciprocal (inverse) of a number, `1/x`.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let x = 2.0;\n+    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn recip(self) -> Self;\n \n     /// Raise a number to an integer power.\n     ///\n     /// Using this function is generally faster than using `powf`\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let x = 2.0;\n+    /// let abs_difference = (x.powi(2) - x*x).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn powi(self, n: i32) -> Self;\n     /// Raise a number to a floating point power.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let x = 2.0;\n+    /// let abs_difference = (x.powf(2.0) - x*x).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn powf(self, n: Self) -> Self;\n-\n     /// Take the square root of a number.\n     ///\n     /// Returns NaN if `self` is a negative number.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let positive = 4.0;\n+    /// let negative = -4.0;\n+    ///\n+    /// let abs_difference = (positive.sqrt() - 2.0).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// assert!(negative.sqrt().is_nan());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sqrt(self) -> Self;\n+\n     /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let f = 4.0;\n+    ///\n+    /// let abs_difference = (f.rsqrt() - 0.5).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn rsqrt(self) -> Self;\n \n     /// Returns `e^(self)`, (the exponential function).\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let one = 1.0;\n+    /// // e^1\n+    /// let e = one.exp();\n+    ///\n+    /// // ln(e) - 1 == 0\n+    /// let abs_difference = (e.ln() - 1.0).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn exp(self) -> Self;\n-    /// Returns 2 raised to the power of the number, `2^(self)`.\n+    /// Returns `2^(self)`.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let f = 2.0;\n+    ///\n+    /// // 2^2 - 4 == 0\n+    /// let abs_difference = (f.exp2() - 4.0).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn exp2(self) -> Self;\n     /// Returns the natural logarithm of the number.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let one = 1.0;\n+    /// // e^1\n+    /// let e = one.exp();\n+    ///\n+    /// // ln(e) - 1 == 0\n+    /// let abs_difference = (e.ln() - 1.0).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ln(self) -> Self;\n     /// Returns the logarithm of the number with respect to an arbitrary base.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let ten = 10.0;\n+    /// let two = 2.0;\n+    ///\n+    /// // log10(10) - 1 == 0\n+    /// let abs_difference_10 = (ten.log(10.0) - 1.0).abs();\n+    ///\n+    /// // log2(2) - 1 == 0\n+    /// let abs_difference_2 = (two.log(2.0) - 1.0).abs();\n+    ///\n+    /// assert!(abs_difference_10 < 1e-10);\n+    /// assert!(abs_difference_2 < 1e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn log(self, base: Self) -> Self;\n     /// Returns the base 2 logarithm of the number.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let two = 2.0;\n+    ///\n+    /// // log2(2) - 1 == 0\n+    /// let abs_difference = (two.log2() - 1.0).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn log2(self) -> Self;\n     /// Returns the base 10 logarithm of the number.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let ten = 10.0;\n+    ///\n+    /// // log10(10) - 1 == 0\n+    /// let abs_difference = (ten.log10() - 1.0).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn log10(self) -> Self;\n \n     /// Convert radians to degrees.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64::consts;\n+    ///\n+    /// let angle = consts::PI;\n+    ///\n+    /// let abs_difference = (angle.to_degrees() - 180.0).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[unstable(feature = \"std_misc\", reason = \"desirability is unclear\")]\n     fn to_degrees(self) -> Self;\n     /// Convert degrees to radians.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64::consts;\n+    ///\n+    /// let angle = 180.0;\n+    ///\n+    /// let abs_difference = (angle.to_radians() - consts::PI).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[unstable(feature = \"std_misc\", reason = \"desirability is unclear\")]\n     fn to_radians(self) -> Self;\n-\n-    /// Constructs a floating point number created by multiplying `x` by 2\n-    /// raised to the power of `exp`.\n+    /// Constructs a floating point number of `x*2^exp`.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// // 3*2^2 - 12 == 0\n+    /// let abs_difference = (Float::ldexp(3.0, 2) - 12.0).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"pending integer conventions\")]\n     fn ldexp(x: Self, exp: int) -> Self;\n     /// Breaks the number into a normalized fraction and a base-2 exponent,\n     /// satisfying:\n     ///\n-    ///  * `self = x * pow(2, exp)`\n-    ///\n+    ///  * `self = x * 2^exp`\n     ///  * `0.5 <= abs(x) < 1.0`\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let x = 4.0;\n+    ///\n+    /// // (1/2)*2^3 -> 1 * 8/2 -> 4.0\n+    /// let f = x.frexp();\n+    /// let abs_difference_0 = (f.0 - 0.5).abs();\n+    /// let abs_difference_1 = (f.1 as f64 - 3.0).abs();\n+    ///\n+    /// assert!(abs_difference_0 < 1e-10);\n+    /// assert!(abs_difference_1 < 1e-10);\n+    /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"pending integer conventions\")]\n     fn frexp(self) -> (Self, int);\n-\n     /// Returns the next representable floating-point value in the direction of\n     /// `other`.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let x = 1.0f32;\n+    ///\n+    /// let abs_diff = (x.next_after(2.0) - 1.00000011920928955078125_f32).abs();\n+    ///\n+    /// assert!(abs_diff < 1e-10);\n+    /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn next_after(self, other: Self) -> Self;\n \n     /// Returns the maximum of the two numbers.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let x = 1.0;\n+    /// let y = 2.0;\n+    ///\n+    /// assert_eq!(x.max(y), y);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn max(self, other: Self) -> Self;\n     /// Returns the minimum of the two numbers.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let x = 1.0;\n+    /// let y = 2.0;\n+    ///\n+    /// assert_eq!(x.min(y), x);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn min(self, other: Self) -> Self;\n \n-    /// The positive difference of two numbers. Returns `0.0` if the number is\n-    /// less than or equal to `other`, otherwise the difference between`self`\n-    /// and `other` is returned.\n+    /// The positive difference of two numbers.\n+    ///\n+    /// * If `self <= other`: `0:0`\n+    /// * Else: `self - other`\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let x = 3.0;\n+    /// let y = -3.0;\n+    ///\n+    /// let abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();\n+    /// let abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();\n+    ///\n+    /// assert!(abs_difference_x < 1e-10);\n+    /// assert!(abs_difference_y < 1e-10);\n+    /// ```\n     #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n     fn abs_sub(self, other: Self) -> Self;\n-\n     /// Take the cubic root of a number.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let x = 8.0;\n+    ///\n+    /// // x^(1/3) - 2 == 0\n+    /// let abs_difference = (x.cbrt() - 2.0).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n     fn cbrt(self) -> Self;\n     /// Calculate the length of the hypotenuse of a right-angle triangle given\n     /// legs of length `x` and `y`.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let x = 2.0;\n+    /// let y = 3.0;\n+    ///\n+    /// // sqrt(x^2 + y^2)\n+    /// let abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn hypot(self, other: Self) -> Self;\n \n     /// Computes the sine of a number (in radians).\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64;\n+    ///\n+    /// let x = f64::consts::PI/2.0;\n+    ///\n+    /// let abs_difference = (x.sin() - 1.0).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sin(self) -> Self;\n     /// Computes the cosine of a number (in radians).\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64;\n+    ///\n+    /// let x = 2.0*f64::consts::PI;\n+    ///\n+    /// let abs_difference = (x.cos() - 1.0).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cos(self) -> Self;\n     /// Computes the tangent of a number (in radians).\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64;\n+    ///\n+    /// let x = f64::consts::PI/4.0;\n+    /// let abs_difference = (x.tan() - 1.0).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-14);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn tan(self) -> Self;\n-\n     /// Computes the arcsine of a number. Return value is in radians in\n     /// the range [-pi/2, pi/2] or NaN if the number is outside the range\n     /// [-1, 1].\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64;\n+    ///\n+    /// let f = f64::consts::PI / 2.0;\n+    ///\n+    /// // asin(sin(pi/2))\n+    /// let abs_difference = (f.sin().asin() - f64::consts::PI / 2.0).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn asin(self) -> Self;\n     /// Computes the arccosine of a number. Return value is in radians in\n     /// the range [0, pi] or NaN if the number is outside the range\n     /// [-1, 1].\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64;\n+    ///\n+    /// let f = f64::consts::PI / 4.0;\n+    ///\n+    /// // acos(cos(pi/4))\n+    /// let abs_difference = (f.cos().acos() - f64::consts::PI / 4.0).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn acos(self) -> Self;\n     /// Computes the arctangent of a number. Return value is in radians in the\n     /// range [-pi/2, pi/2];\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let f = 1.0;\n+    ///\n+    /// // atan(tan(1))\n+    /// let abs_difference = (f.tan().atan() - 1.0).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn atan(self) -> Self;\n-    /// Computes the four quadrant arctangent of a number, `y`, and another\n-    /// number `x`. Return value is in radians in the range [-pi, pi].\n+    /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).\n+    ///\n+    /// * `x = 0`, `y = 0`: `0`\n+    /// * `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`\n+    /// * `y >= 0`: `arctan(y/x) + pi` -> `(pi/2, pi]`\n+    /// * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64;\n+    ///\n+    /// let pi = f64::consts::PI;\n+    /// // All angles from horizontal right (+x)\n+    /// // 45 deg counter-clockwise\n+    /// let x1 = 3.0;\n+    /// let y1 = -3.0;\n+    ///\n+    /// // 135 deg clockwise\n+    /// let x2 = -3.0;\n+    /// let y2 = 3.0;\n+    ///\n+    /// let abs_difference_1 = (y1.atan2(x1) - (-pi/4.0)).abs();\n+    /// let abs_difference_2 = (y2.atan2(x2) - 3.0*pi/4.0).abs();\n+    ///\n+    /// assert!(abs_difference_1 < 1e-10);\n+    /// assert!(abs_difference_2 < 1e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn atan2(self, other: Self) -> Self;\n     /// Simultaneously computes the sine and cosine of the number, `x`. Returns\n     /// `(sin(x), cos(x))`.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64;\n+    ///\n+    /// let x = f64::consts::PI/4.0;\n+    /// let f = x.sin_cos();\n+    ///\n+    /// let abs_difference_0 = (f.0 - x.sin()).abs();\n+    /// let abs_difference_1 = (f.1 - x.cos()).abs();\n+    ///\n+    /// assert!(abs_difference_0 < 1e-10);\n+    /// assert!(abs_difference_0 < 1e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sin_cos(self) -> (Self, Self);\n \n-    /// Returns the exponential of the number, minus 1, in a way that is\n-    /// accurate even if the number is close to zero.\n+    /// Returns `e^(self) - 1` in a way that is accurate even if the\n+    /// number is close to zero.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let x = 7.0;\n+    ///\n+    /// // e^(ln(7)) - 1\n+    /// let abs_difference = (x.ln().exp_m1() - 6.0).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n     fn exp_m1(self) -> Self;\n-    /// Returns the natural logarithm of the number plus 1 (`ln(1+n)`) more\n-    /// accurately than if the operations were performed separately.\n+    /// Returns `ln(1+n)` (natural logarithm) more accurately than if\n+    /// the operations were performed separately.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64;\n+    ///\n+    /// let x = f64::consts::E - 1.0;\n+    ///\n+    /// // ln(1 + (e - 1)) == ln(e) == 1\n+    /// let abs_difference = (x.ln_1p() - 1.0).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n     fn ln_1p(self) -> Self;\n \n     /// Hyperbolic sine function.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64;\n+    ///\n+    /// let e = f64::consts::E;\n+    /// let x = 1.0;\n+    ///\n+    /// let f = x.sinh();\n+    /// // Solving sinh() at 1 gives `(e^2-1)/(2e)`\n+    /// let g = (e*e - 1.0)/(2.0*e);\n+    /// let abs_difference = (f - g).abs();\n+    ///\n+    /// assert!(abs_difference < 1e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sinh(self) -> Self;\n     /// Hyperbolic cosine function.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64;\n+    ///\n+    /// let e = f64::consts::E;\n+    /// let x = 1.0;\n+    /// let f = x.cosh();\n+    /// // Solving cosh() at 1 gives this result\n+    /// let g = (e*e + 1.0)/(2.0*e);\n+    /// let abs_difference = (f - g).abs();\n+    ///\n+    /// // Same result\n+    /// assert!(abs_difference < 1.0e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cosh(self) -> Self;\n     /// Hyperbolic tangent function.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64;\n+    ///\n+    /// let e = f64::consts::E;\n+    /// let x = 1.0;\n+    ///\n+    /// let f = x.tanh();\n+    /// // Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`\n+    /// let g = (1.0 - e.powi(-2))/(1.0 + e.powi(-2));\n+    /// let abs_difference = (f - g).abs();\n+    ///\n+    /// assert!(abs_difference < 1.0e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn tanh(self) -> Self;\n     /// Inverse hyperbolic sine function.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let x = 1.0;\n+    /// let f = x.sinh().asinh();\n+    ///\n+    /// let abs_difference = (f - x).abs();\n+    ///\n+    /// assert!(abs_difference < 1.0e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn asinh(self) -> Self;\n     /// Inverse hyperbolic cosine function.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    ///\n+    /// let x = 1.0;\n+    /// let f = x.cosh().acosh();\n+    ///\n+    /// let abs_difference = (f - x).abs();\n+    ///\n+    /// assert!(abs_difference < 1.0e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn acosh(self) -> Self;\n     /// Inverse hyperbolic tangent function.\n+    ///\n+    /// ```\n+    /// use std::num::Float;\n+    /// use std::f64;\n+    ///\n+    /// let e = f64::consts::E;\n+    /// let f = e.tanh().atanh();\n+    ///\n+    /// let abs_difference = (f - e).abs();\n+    ///\n+    /// assert!(abs_difference < 1.0e-10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn atanh(self) -> Self;\n }"}, {"sha": "207d3d39167660b929225e667725357d166a1b63", "filename": "src/libstd/old_io/comm_adapters.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -161,12 +161,12 @@ mod test {\n     use sync::mpsc::channel;\n     use super::*;\n     use old_io;\n-    use thread::Thread;\n+    use thread;\n \n     #[test]\n     fn test_rx_reader() {\n         let (tx, rx) = channel();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n           tx.send(vec![1u8, 2u8]).unwrap();\n           tx.send(vec![]).unwrap();\n           tx.send(vec![3u8, 4u8]).unwrap();\n@@ -208,7 +208,7 @@ mod test {\n     #[test]\n     fn test_rx_buffer() {\n         let (tx, rx) = channel();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n           tx.send(b\"he\".to_vec()).unwrap();\n           tx.send(b\"llo wo\".to_vec()).unwrap();\n           tx.send(b\"\".to_vec()).unwrap();\n@@ -234,10 +234,7 @@ mod test {\n         writer.write_be_u32(42).unwrap();\n \n         let wanted = vec![0u8, 0u8, 0u8, 42u8];\n-        let got = match Thread::scoped(move|| { rx.recv().unwrap() }).join() {\n-            Ok(got) => got,\n-            Err(_) => panic!(),\n-        };\n+        let got = thread::scoped(move|| { rx.recv().unwrap() }).join();\n         assert_eq!(wanted, got);\n \n         match writer.write_u8(1) {"}, {"sha": "4bd0662232fecccacb64e69bcdb78395225daff8", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -124,7 +124,7 @@\n //!     # #![allow(dead_code)]\n //!     use std::old_io::{TcpListener, TcpStream};\n //!     use std::old_io::{Acceptor, Listener};\n-//!     use std::thread::Thread;\n+//!     use std::thread;\n //!\n //!     let listener = TcpListener::bind(\"127.0.0.1:80\");\n //!\n@@ -140,7 +140,7 @@\n //!         match stream {\n //!             Err(e) => { /* connection failed */ }\n //!             Ok(stream) => {\n-//!                 Thread::spawn(move|| {\n+//!                 thread::spawn(move|| {\n //!                     // connection succeeded\n //!                     handle_client(stream)\n //!                 });\n@@ -238,7 +238,7 @@\n //! concerned with error handling; instead its caller is responsible for\n //! responding to errors that may occur while attempting to read the numbers.\n \n-#![unstable(feature = \"io\")]\n+#![unstable(feature = \"old_io\")]\n #![deny(unused_must_use)]\n \n pub use self::SeekStyle::*;"}, {"sha": "6b32d936c05bec0e8352b373dbdf88ec81c20dfa", "filename": "src/libstd/old_io/net/pipe.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -282,19 +282,19 @@ mod tests {\n     use old_io::test::*;\n     use super::*;\n     use sync::mpsc::channel;\n-    use thread::Thread;\n+    use thread;\n     use time::Duration;\n \n     pub fn smalltest<F,G>(server: F, client: G)\n         where F : FnOnce(UnixStream), F : Send,\n-              G : FnOnce(UnixStream), G : Send\n+              G : FnOnce(UnixStream), G : Send + 'static\n     {\n         let path1 = next_test_unix();\n         let path2 = path1.clone();\n \n         let mut acceptor = UnixListener::bind(&path1).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             match UnixStream::connect(&path2) {\n                 Ok(c) => client(c),\n                 Err(e) => panic!(\"failed connect: {}\", e),\n@@ -389,7 +389,7 @@ mod tests {\n             Err(e) => panic!(\"failed listen: {}\", e),\n         };\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             for _ in 0u..times {\n                 let mut stream = UnixStream::connect(&path2);\n                 match stream.write(&[100]) {\n@@ -423,7 +423,7 @@ mod tests {\n         let addr = next_test_unix();\n         let mut acceptor = UnixListener::bind(&addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr);\n             let mut buf = [0, 0];\n             debug!(\"client reading\");\n@@ -439,7 +439,7 @@ mod tests {\n \n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s2 = s2;\n             rx1.recv().unwrap();\n             debug!(\"writer writing\");\n@@ -462,7 +462,7 @@ mod tests {\n         let (tx1, rx) = channel();\n         let tx2 = tx1.clone();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr);\n             s.write(&[1]).unwrap();\n             rx.recv().unwrap();\n@@ -474,7 +474,7 @@ mod tests {\n         let s2 = s1.clone();\n \n         let (done, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s2 = s2;\n             let mut buf = [0, 0];\n             s2.read(&mut buf).unwrap();\n@@ -493,7 +493,7 @@ mod tests {\n         let addr = next_test_unix();\n         let mut acceptor = UnixListener::bind(&addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr);\n             let buf = &mut [0, 1];\n             s.read(buf).unwrap();\n@@ -504,7 +504,7 @@ mod tests {\n         let s2 = s1.clone();\n \n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s2 = s2;\n             s2.write(&[1]).unwrap();\n             tx.send(()).unwrap();\n@@ -551,7 +551,7 @@ mod tests {\n         // continue to receive any pending connections.\n         let (tx, rx) = channel();\n         let addr2 = addr.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             tx.send(UnixStream::connect(&addr2).unwrap()).unwrap();\n         });\n         let l = rx.recv().unwrap();\n@@ -561,15 +561,15 @@ mod tests {\n                 Err(ref e) if e.kind == TimedOut => {}\n                 Err(e) => panic!(\"error: {}\", e),\n             }\n-            ::thread::Thread::yield_now();\n+            ::thread::yield_now();\n             if i == 1000 { panic!(\"should have a pending connection\") }\n         }\n         drop(l);\n \n         // Unset the timeout and make sure that this always blocks.\n         a.set_timeout(None);\n         let addr2 = addr.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             drop(UnixStream::connect(&addr2).unwrap());\n         });\n         a.accept().unwrap();\n@@ -607,7 +607,7 @@ mod tests {\n         let addr = next_test_unix();\n         let a = UnixListener::bind(&addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n             let _ = rx.recv();\n@@ -644,7 +644,7 @@ mod tests {\n         let addr = next_test_unix();\n         let a = UnixListener::bind(&addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n             let _ = rx.recv();\n@@ -653,7 +653,7 @@ mod tests {\n         let mut s = UnixStream::connect(&addr).unwrap();\n         let s2 = s.clone();\n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s2 = s2;\n             assert!(s2.read(&mut [0]).is_err());\n             tx.send(()).unwrap();\n@@ -670,7 +670,7 @@ mod tests {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr).unwrap();\n             rx.recv().unwrap();\n             assert!(s.write(&[0]).is_ok());\n@@ -708,7 +708,7 @@ mod tests {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr).unwrap();\n             rx.recv().unwrap();\n             let mut amt = 0;\n@@ -737,7 +737,7 @@ mod tests {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr).unwrap();\n             rx.recv().unwrap();\n             assert!(s.write(&[0]).is_ok());\n@@ -764,7 +764,7 @@ mod tests {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr).unwrap();\n             rx.recv().unwrap();\n             assert!(s.write(&[0]).is_ok());\n@@ -774,7 +774,7 @@ mod tests {\n         let mut s = a.accept().unwrap();\n         let s2 = s.clone();\n         let (tx2, rx2) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s2 = s2;\n             assert!(s2.read(&mut [0]).is_ok());\n             tx2.send(()).unwrap();\n@@ -796,10 +796,10 @@ mod tests {\n         let mut a2 = a.clone();\n \n         let addr2 = addr.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _ = UnixStream::connect(&addr2);\n         });\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _ = UnixStream::connect(&addr);\n         });\n \n@@ -819,20 +819,20 @@ mod tests {\n         let (tx, rx) = channel();\n         let tx2 = tx.clone();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut a = a;\n             tx.send(a.accept()).unwrap()\n         });\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut a = a2;\n             tx2.send(a.accept()).unwrap()\n         });\n \n         let addr2 = addr.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _ = UnixStream::connect(&addr2);\n         });\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _ = UnixStream::connect(&addr);\n         });\n \n@@ -858,7 +858,7 @@ mod tests {\n         let mut a2 = a.clone();\n \n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut a = a;\n             tx.send(a.accept()).unwrap();\n         });"}, {"sha": "2afff9fc1c9b9c2a831bbc28a027d800a255e125", "filename": "src/libstd/old_io/net/tcp.rs", "status": "modified", "additions": 67, "deletions": 65, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -137,12 +137,12 @@ impl TcpStream {\n     /// use std::old_io::timer;\n     /// use std::old_io::TcpStream;\n     /// use std::time::Duration;\n-    /// use std::thread::Thread;\n+    /// use std::thread;\n     ///\n     /// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n     /// let stream2 = stream.clone();\n     ///\n-    /// let _t = Thread::spawn(move|| {\n+    /// let _t = thread::spawn(move|| {\n     ///     // close this stream after one second\n     ///     timer::sleep(Duration::seconds(1));\n     ///     let mut stream = stream2;\n@@ -282,7 +282,7 @@ impl sys_common::AsInner<TcpStreamImp> for TcpStream {\n /// # fn foo() {\n /// use std::old_io::{TcpListener, TcpStream};\n /// use std::old_io::{Acceptor, Listener};\n-/// use std::thread::Thread;\n+/// use std::thread;\n ///\n /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n ///\n@@ -298,7 +298,7 @@ impl sys_common::AsInner<TcpStreamImp> for TcpStream {\n ///     match stream {\n ///         Err(e) => { /* connection failed */ }\n ///         Ok(stream) => {\n-///             Thread::spawn(move|| {\n+///             thread::spawn(move|| {\n ///                 // connection succeeded\n ///                 handle_client(stream)\n ///             });\n@@ -421,12 +421,12 @@ impl TcpAcceptor {\n     ///\n     /// ```\n     /// use std::old_io::{TcpListener, Listener, Acceptor, EndOfFile};\n-    /// use std::thread::Thread;\n+    /// use std::thread;\n     ///\n     /// let mut a = TcpListener::bind(\"127.0.0.1:8482\").listen().unwrap();\n     /// let a2 = a.clone();\n     ///\n-    /// let _t = Thread::spawn(move|| {\n+    /// let _t = thread::spawn(move|| {\n     ///     let mut a2 = a2;\n     ///     for socket in a2.incoming() {\n     ///         match socket {\n@@ -487,13 +487,14 @@ mod test {\n     use prelude::v1::*;\n \n     use sync::mpsc::channel;\n-    use thread::Thread;\n+    use thread;\n     use old_io::net::tcp::*;\n     use old_io::net::ip::*;\n     use old_io::test::*;\n     use old_io::{EndOfFile, TimedOut, ShortWrite, IoError};\n     use old_io::{ConnectionRefused, BrokenPipe, ConnectionAborted};\n     use old_io::{ConnectionReset, NotConnected, PermissionDenied, OtherIoError};\n+    use old_io::{InvalidInput};\n     use old_io::{Acceptor, Listener};\n \n     // FIXME #11530 this fails on android because tests are run as root\n@@ -510,7 +511,8 @@ mod test {\n     fn connect_error() {\n         match TcpStream::connect(\"0.0.0.0:1\") {\n             Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, ConnectionRefused),\n+            Err(e) => assert!((e.kind == ConnectionRefused)\n+                              || (e.kind == InvalidInput)),\n         }\n     }\n \n@@ -520,7 +522,7 @@ mod test {\n         let listener = TcpListener::bind(socket_addr);\n         let mut acceptor = listener.listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut stream = TcpStream::connect((\"localhost\", socket_addr.port));\n             stream.write(&[144]).unwrap();\n         });\n@@ -536,7 +538,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut stream = TcpStream::connect((\"localhost\", addr.port));\n             stream.write(&[64]).unwrap();\n         });\n@@ -552,7 +554,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut stream = TcpStream::connect((\"127.0.0.1\", addr.port));\n             stream.write(&[44]).unwrap();\n         });\n@@ -568,7 +570,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut stream = TcpStream::connect((\"::1\", addr.port));\n             stream.write(&[66]).unwrap();\n         });\n@@ -584,7 +586,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut stream = TcpStream::connect(addr);\n             stream.write(&[99]).unwrap();\n         });\n@@ -600,7 +602,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut stream = TcpStream::connect(addr);\n             stream.write(&[99]).unwrap();\n         });\n@@ -616,7 +618,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n@@ -632,7 +634,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n@@ -648,7 +650,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n@@ -672,7 +674,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n@@ -697,7 +699,7 @@ mod test {\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             drop(TcpStream::connect(addr));\n             tx.send(()).unwrap();\n         });\n@@ -722,7 +724,7 @@ mod test {\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             drop(TcpStream::connect(addr));\n             tx.send(()).unwrap();\n         });\n@@ -747,7 +749,7 @@ mod test {\n         let max = 10u;\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             for _ in 0..max {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write(&[99]).unwrap();\n@@ -767,7 +769,7 @@ mod test {\n         let max = 10u;\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             for _ in 0..max {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write(&[99]).unwrap();\n@@ -787,11 +789,11 @@ mod test {\n         static MAX: int = 10;\n         let acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut acceptor = acceptor;\n             for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                let _t = Thread::spawn(move|| {\n+                let _t = thread::spawn(move|| {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(&mut buf).unwrap();\n@@ -806,7 +808,7 @@ mod test {\n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n@@ -823,11 +825,11 @@ mod test {\n         static MAX: int = 10;\n         let acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut acceptor = acceptor;\n             for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                let _t = Thread::spawn(move|| {\n+                let _t = thread::spawn(move|| {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(&mut buf).unwrap();\n@@ -842,7 +844,7 @@ mod test {\n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n@@ -859,11 +861,11 @@ mod test {\n         let addr = next_test_ip4();\n         let acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut acceptor = acceptor;\n             for stream in acceptor.incoming().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                let _t = Thread::spawn(move|| {\n+                let _t = thread::spawn(move|| {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(&mut buf).unwrap();\n@@ -878,7 +880,7 @@ mod test {\n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n@@ -895,11 +897,11 @@ mod test {\n         let addr = next_test_ip6();\n         let acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut acceptor = acceptor;\n             for stream in acceptor.incoming().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                let _t = Thread::spawn(move|| {\n+                let _t = thread::spawn(move|| {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(&mut buf).unwrap();\n@@ -914,7 +916,7 @@ mod test {\n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n@@ -937,7 +939,7 @@ mod test {\n \n     pub fn peer_name(addr: SocketAddr) {\n         let acceptor = TcpListener::bind(addr).listen();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut acceptor = acceptor;\n             acceptor.accept().unwrap();\n         });\n@@ -972,7 +974,7 @@ mod test {\n     fn partial_read() {\n         let addr = next_test_ip4();\n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut srv = TcpListener::bind(addr).listen().unwrap();\n             tx.send(()).unwrap();\n             let mut cl = srv.accept().unwrap();\n@@ -1009,7 +1011,7 @@ mod test {\n         let addr = next_test_ip4();\n         let (tx, rx) = channel();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n             let _stream = TcpStream::connect(addr).unwrap();\n             // Close\n@@ -1034,7 +1036,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr);\n             let mut buf = [0, 0];\n             assert_eq!(s.read(&mut buf), Ok(1));\n@@ -1047,7 +1049,7 @@ mod test {\n \n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s2 = s2;\n             rx1.recv().unwrap();\n             s2.write(&[1]).unwrap();\n@@ -1066,7 +1068,7 @@ mod test {\n         let (tx1, rx) = channel();\n         let tx2 = tx1.clone();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr);\n             s.write(&[1]).unwrap();\n             rx.recv().unwrap();\n@@ -1078,7 +1080,7 @@ mod test {\n         let s2 = s1.clone();\n \n         let (done, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s2 = s2;\n             let mut buf = [0, 0];\n             s2.read(&mut buf).unwrap();\n@@ -1097,7 +1099,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr);\n             let mut buf = [0, 1];\n             s.read(&mut buf).unwrap();\n@@ -1108,7 +1110,7 @@ mod test {\n         let s2 = s1.clone();\n \n         let (done, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s2 = s2;\n             s2.write(&[1]).unwrap();\n             done.send(()).unwrap();\n@@ -1122,7 +1124,7 @@ mod test {\n     fn shutdown_smoke() {\n         let addr = next_test_ip4();\n         let a = TcpListener::bind(addr).unwrap().listen();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut a = a;\n             let mut c = a.accept().unwrap();\n             assert_eq!(c.read_to_end(), Ok(vec!()));\n@@ -1156,7 +1158,7 @@ mod test {\n         //        flakiness.\n         if !cfg!(target_os = \"freebsd\") {\n             let (tx, rx) = channel();\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 tx.send(TcpStream::connect(addr).unwrap()).unwrap();\n             });\n             let _l = rx.recv().unwrap();\n@@ -1166,14 +1168,14 @@ mod test {\n                     Err(ref e) if e.kind == TimedOut => {}\n                     Err(e) => panic!(\"error: {}\", e),\n                 }\n-                ::thread::Thread::yield_now();\n+                ::thread::yield_now();\n                 if i == 1000 { panic!(\"should have a pending connection\") }\n             }\n         }\n \n         // Unset the timeout and make sure that this always blocks.\n         a.set_timeout(None);\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             drop(TcpStream::connect(addr).unwrap());\n         });\n         a.accept().unwrap();\n@@ -1184,7 +1186,7 @@ mod test {\n         let addr = next_test_ip4();\n         let a = TcpListener::bind(addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n             let _ = rx.recv().unwrap();\n@@ -1221,7 +1223,7 @@ mod test {\n         let addr = next_test_ip4();\n         let a = TcpListener::bind(addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n             let _ = rx.recv().unwrap();\n@@ -1230,7 +1232,7 @@ mod test {\n         let mut s = TcpStream::connect(addr).unwrap();\n         let s2 = s.clone();\n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s2 = s2;\n             assert!(s2.read(&mut [0]).is_err());\n             tx.send(()).unwrap();\n@@ -1247,7 +1249,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv().unwrap();\n             assert!(s.write(&[0]).is_ok());\n@@ -1280,7 +1282,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv().unwrap();\n             let mut amt = 0;\n@@ -1309,7 +1311,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv().unwrap();\n             assert!(s.write(&[0]).is_ok());\n@@ -1337,7 +1339,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv().unwrap();\n             assert_eq!(s.write(&[0]), Ok(()));\n@@ -1347,7 +1349,7 @@ mod test {\n         let mut s = a.accept().unwrap();\n         let s2 = s.clone();\n         let (tx2, rx2) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s2 = s2;\n             assert_eq!(s2.read(&mut [0]), Ok(1));\n             tx2.send(()).unwrap();\n@@ -1370,7 +1372,7 @@ mod test {\n         let (tx, rx) = channel();\n         let (txdone, rxdone) = channel();\n         let txdone2 = txdone.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut tcp = TcpStream::connect(addr).unwrap();\n             rx.recv().unwrap();\n             tcp.write_u8(0).unwrap();\n@@ -1381,15 +1383,15 @@ mod test {\n         let tcp = accept.accept().unwrap();\n         let tcp2 = tcp.clone();\n         let txdone3 = txdone.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut tcp2 = tcp2;\n             tcp2.read_u8().unwrap();\n             txdone3.send(()).unwrap();\n         });\n \n         // Try to ensure that the reading clone is indeed reading\n         for _ in 0..50 {\n-            ::thread::Thread::yield_now();\n+            ::thread::yield_now();\n         }\n \n         // clone the handle again while it's reading, then let it finish the\n@@ -1407,10 +1409,10 @@ mod test {\n         let mut a = l.listen().unwrap();\n         let mut a2 = a.clone();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _ = TcpStream::connect(addr);\n         });\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _ = TcpStream::connect(addr);\n         });\n \n@@ -1428,19 +1430,19 @@ mod test {\n         let (tx, rx) = channel();\n         let tx2 = tx.clone();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut a = a;\n             tx.send(a.accept()).unwrap();\n         });\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut a = a2;\n             tx2.send(a.accept()).unwrap();\n         });\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _ = TcpStream::connect(addr);\n         });\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _ = TcpStream::connect(addr);\n         });\n \n@@ -1466,7 +1468,7 @@ mod test {\n         let mut a2 = a.clone();\n \n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut a = a;\n             tx.send(a.accept()).unwrap();\n         });"}, {"sha": "7171198e7a4aaed7d847c240ffdbbeb1ac9fe5ec", "filename": "src/libstd/old_io/net/udp.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -186,7 +186,7 @@ mod test {\n     use old_io::test::*;\n     use old_io::{IoError, TimedOut, PermissionDenied, ShortWrite};\n     use super::*;\n-    use thread::Thread;\n+    use thread;\n \n     // FIXME #11530 this fails on android because tests are run as root\n     #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n@@ -206,7 +206,7 @@ mod test {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             match UdpSocket::bind(client_ip) {\n                 Ok(ref mut client) => {\n                     rx1.recv().unwrap();\n@@ -241,7 +241,7 @@ mod test {\n         let client_ip = next_test_ip6();\n         let (tx, rx) = channel::<()>();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             match UdpSocket::bind(client_ip) {\n                 Ok(ref mut client) => {\n                     rx.recv().unwrap();\n@@ -298,7 +298,7 @@ mod test {\n         let mut sock1 = UdpSocket::bind(addr1).unwrap();\n         let sock2 = UdpSocket::bind(addr2).unwrap();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut sock2 = sock2;\n             let mut buf = [0, 0];\n             assert_eq!(sock2.recv_from(&mut buf), Ok((1, addr1)));\n@@ -310,7 +310,7 @@ mod test {\n \n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut sock3 = sock3;\n             rx1.recv().unwrap();\n             sock3.send_to(&[1], addr2).unwrap();\n@@ -331,7 +331,7 @@ mod test {\n         let (tx1, rx) = channel();\n         let tx2 = tx1.clone();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut sock2 = sock2;\n             sock2.send_to(&[1], addr1).unwrap();\n             rx.recv().unwrap();\n@@ -342,7 +342,7 @@ mod test {\n         let sock3 = sock1.clone();\n \n         let (done, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut sock3 = sock3;\n             let mut buf = [0, 0];\n             sock3.recv_from(&mut buf).unwrap();\n@@ -366,7 +366,7 @@ mod test {\n         let (tx, rx) = channel();\n         let (serv_tx, serv_rx) = channel();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut sock2 = sock2;\n             let mut buf = [0, 1];\n \n@@ -382,7 +382,7 @@ mod test {\n \n         let (done, rx) = channel();\n         let tx2 = tx.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut sock3 = sock3;\n             match sock3.send_to(&[1], addr2) {\n                 Ok(..) => { let _ = tx2.send(()); }\n@@ -410,7 +410,7 @@ mod test {\n \n         let (tx, rx) = channel();\n         let (tx2, rx2) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut a = a2;\n             assert_eq!(a.recv_from(&mut [0]), Ok((1, addr1)));\n             assert_eq!(a.send_to(&[0], addr1), Ok(()));"}, {"sha": "b7b626db034e1648076fc250b22ff4284ce30afe", "filename": "src/libstd/old_io/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_io%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_io%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fpipe.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -115,7 +115,7 @@ mod test {\n     use prelude::v1::*;\n \n     use sync::mpsc::channel;\n-    use thread::Thread;\n+    use thread;\n \n     #[test]\n     fn partial_read() {\n@@ -126,7 +126,7 @@ mod test {\n         let out = PipeStream::open(writer);\n         let mut input = PipeStream::open(reader);\n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut out = out;\n             out.write(&[10]).unwrap();\n             rx.recv().unwrap(); // don't close the pipe until the other read has finished"}, {"sha": "ea6510c61b76be626372d567d9c4818d43228f0c", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -30,7 +30,7 @@ use sync::mpsc::{channel, Receiver};\n use sys::fs::FileDesc;\n use sys::process::Process as ProcessImp;\n use sys;\n-use thread::Thread;\n+use thread;\n \n #[cfg(windows)] use hash;\n #[cfg(windows)] use str;\n@@ -703,7 +703,7 @@ impl Process {\n             let (tx, rx) = channel();\n             match stream {\n                 Some(stream) => {\n-                    Thread::spawn(move || {\n+                    thread::spawn(move || {\n                         let mut stream = stream;\n                         tx.send(stream.read_to_end()).unwrap();\n                     });\n@@ -764,7 +764,7 @@ mod tests {\n     use super::{CreatePipe};\n     use super::{InheritFd, Process, PleaseExitSignal, Command, ProcessOutput};\n     use sync::mpsc::channel;\n-    use thread::Thread;\n+    use thread;\n     use time::Duration;\n \n     // FIXME(#10380) these tests should not all be ignored on android.\n@@ -800,12 +800,12 @@ mod tests {\n     #[cfg(all(unix, not(target_os=\"android\")))]\n     #[test]\n     fn signal_reported_right() {\n-        let p = Command::new(\"/bin/sh\").arg(\"-c\").arg(\"kill -1 $$\").spawn();\n+        let p = Command::new(\"/bin/sh\").arg(\"-c\").arg(\"kill -9 $$\").spawn();\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n         match p.wait().unwrap() {\n-            process::ExitSignal(1) => {},\n-            result => panic!(\"not terminated by signal 1 (instead, {})\", result),\n+            process::ExitSignal(9) => {},\n+            result => panic!(\"not terminated by signal 9 (instead, {})\", result),\n         }\n     }\n \n@@ -1169,14 +1169,14 @@ mod tests {\n     fn wait_timeout2() {\n         let (tx, rx) = channel();\n         let tx2 = tx.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut p = sleeper();\n             p.set_timeout(Some(10));\n             assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n             p.signal_kill().unwrap();\n             tx.send(()).unwrap();\n         });\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut p = sleeper();\n             p.set_timeout(Some(10));\n             assert_eq!(p.wait().err().unwrap().kind, TimedOut);"}, {"sha": "e3d0232684fcc3a9b57c25735973550c8a00b607", "filename": "src/libstd/old_io/stdio.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -530,7 +530,7 @@ mod tests {\n \n     use super::*;\n     use sync::mpsc::channel;\n-    use thread::Thread;\n+    use thread;\n \n     #[test]\n     fn smoke() {\n@@ -546,7 +546,7 @@ mod tests {\n \n         let (tx, rx) = channel();\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             set_stdout(box w);\n             println!(\"hello!\");\n         });\n@@ -559,7 +559,7 @@ mod tests {\n \n         let (tx, rx) = channel();\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n-        let _t = Thread::spawn(move || -> () {\n+        let _t = thread::spawn(move || -> () {\n             set_stderr(box w);\n             panic!(\"my special message\");\n         });"}, {"sha": "8b84e27eae1ba83f1ed90712bf0f7403d64980cb", "filename": "src/libstd/old_io/timer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_io%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_io%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftimer.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -224,13 +224,13 @@ fn in_ms_u64(d: Duration) -> u64 {\n #[cfg(test)]\n mod test {\n     use super::Timer;\n-    use thread::Thread;\n+    use thread;\n     use time::Duration;\n \n     #[test]\n     fn test_timer_send() {\n         let mut timer = Timer::new().unwrap();\n-        Thread::spawn(move || timer.sleep(Duration::milliseconds(1)));\n+        thread::spawn(move || timer.sleep(Duration::milliseconds(1)));\n     }\n \n     #[test]\n@@ -360,7 +360,7 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n         let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let _ = timer_rx.recv();\n         });\n \n@@ -374,7 +374,7 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n         let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let _ = timer_rx.recv();\n         });\n \n@@ -387,7 +387,7 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n         let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let _ = timer_rx.recv();\n         });\n "}, {"sha": "37de2993c4d0f77ed22f01d7544f750aaedd123b", "filename": "src/libstd/old_path/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_path%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_path%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fmod.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -59,7 +59,7 @@\n //! println!(\"path exists: {}\", path.exists());\n //! ```\n \n-#![unstable(feature = \"path\")]\n+#![unstable(feature = \"old_path\")]\n \n use core::marker::Sized;\n use ffi::CString;"}, {"sha": "440d17cfd50f7df4daac853d8980dd64724861be", "filename": "src/libstd/old_path/posix.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_path%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_path%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fposix.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -518,18 +518,18 @@ mod tests {\n \n     #[test]\n     fn test_null_byte() {\n-        use thread::Thread;\n-        let result = Thread::scoped(move|| {\n-            Path::new(b\"foo/bar\\0\")\n+        use thread;\n+        let result = thread::spawn(move|| {\n+            Path::new(b\"foo/bar\\0\");\n         }).join();\n         assert!(result.is_err());\n \n-        let result = Thread::scoped(move|| {\n+        let result = thread::spawn(move|| {\n             Path::new(\"test\").set_filename(b\"f\\0o\")\n         }).join();\n         assert!(result.is_err());\n \n-        let result = Thread::scoped(move|| {\n+        let result = thread::spawn(move|| {\n             Path::new(\"test\").push(b\"f\\0o\");\n         }).join();\n         assert!(result.is_err());"}, {"sha": "07c5e10992b636c2efd20c85e19cefd5d46c2f78", "filename": "src/libstd/old_path/windows.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -1305,18 +1305,18 @@ mod tests {\n \n     #[test]\n     fn test_null_byte() {\n-        use thread::Thread;\n-        let result = Thread::scoped(move|| {\n-            Path::new(b\"foo/bar\\0\")\n+        use thread;\n+        let result = thread::spawn(move|| {\n+            Path::new(b\"foo/bar\\0\");\n         }).join();\n         assert!(result.is_err());\n \n-        let result = Thread::scoped(move|| {\n+        let result = thread::spawn(move|| {\n             Path::new(\"test\").set_filename(b\"f\\0o\")\n         }).join();\n         assert!(result.is_err());\n \n-        let result = Thread::scoped(move || {\n+        let result = thread::spawn(move || {\n             Path::new(\"test\").push(b\"f\\0o\");\n         }).join();\n         assert!(result.is_err());"}, {"sha": "35221a7e647cc728fd5896b284669567533ceb2e", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -17,7 +17,7 @@ use cell::RefCell;\n use old_io::IoResult;\n use rt::{backtrace, unwind};\n use rt::util::{Stderr, Stdio};\n-use thread::Thread;\n+use thread;\n \n // Defined in this module instead of old_io::stdio so that the unwinding\n thread_local! {\n@@ -42,7 +42,7 @@ pub fn on_panic(obj: &(Any+Send), file: &'static str, line: uint) {\n         }\n     };\n     let mut err = Stderr;\n-    let thread = Thread::current();\n+    let thread = thread::current();\n     let name = thread.name().unwrap_or(\"<unnamed>\");\n     let prev = LOCAL_STDERR.with(|s| s.borrow_mut().take());\n     match prev {"}, {"sha": "1d992668900f05b4fb8c49b189ec23951131552a", "filename": "src/libstd/path.rs", "status": "modified", "additions": 126, "deletions": 123, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -107,6 +107,7 @@\n \n use core::prelude::*;\n \n+use ascii::*;\n use borrow::BorrowFrom;\n use cmp;\n use iter;\n@@ -118,7 +119,7 @@ use fmt;\n \n use ffi::{OsStr, OsString, AsOsStr};\n \n-use self::platform::{is_sep, is_verbatim_sep, MAIN_SEP_STR, parse_prefix, Prefix};\n+use self::platform::{is_sep_byte, is_verbatim_sep, MAIN_SEP_STR, parse_prefix};\n \n ////////////////////////////////////////////////////////////////////////////////\n // GENERAL NOTES\n@@ -139,11 +140,12 @@ use self::platform::{is_sep, is_verbatim_sep, MAIN_SEP_STR, parse_prefix, Prefix\n \n #[cfg(unix)]\n mod platform {\n+    use super::Prefix;\n     use core::prelude::*;\n     use ffi::OsStr;\n \n     #[inline]\n-    pub fn is_sep(b: u8) -> bool {\n+    pub fn is_sep_byte(b: u8) -> bool {\n         b == b'/'\n     }\n \n@@ -156,34 +158,21 @@ mod platform {\n         None\n     }\n \n-    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-    pub struct Prefix<'a>;\n-\n-    impl<'a> Prefix<'a> {\n-        #[inline]\n-        pub fn len(&self) -> usize { 0 }\n-        #[inline]\n-        pub fn is_verbatim(&self) -> bool { false }\n-        #[inline]\n-        pub fn is_drive(&self) -> bool { false }\n-        #[inline]\n-        pub fn has_implicit_root(&self) -> bool { false }\n-    }\n-\n     pub const MAIN_SEP_STR: &'static str = \"/\";\n+    pub const MAIN_SEP: char = '/';\n }\n \n #[cfg(windows)]\n mod platform {\n     use core::prelude::*;\n+    use ascii::*;\n \n     use char::CharExt as UnicodeCharExt;\n-    use super::{os_str_as_u8_slice, u8_slice_as_os_str};\n-    use ascii::*;\n+    use super::{os_str_as_u8_slice, u8_slice_as_os_str, Prefix};\n     use ffi::OsStr;\n \n     #[inline]\n-    pub fn is_sep(b: u8) -> bool {\n+    pub fn is_sep_byte(b: u8) -> bool {\n         b == b'/' || b == b'\\\\'\n     }\n \n@@ -193,7 +182,7 @@ mod platform {\n     }\n \n     pub fn parse_prefix<'a>(path: &'a OsStr) -> Option<Prefix> {\n-        use self::Prefix::*;\n+        use super::Prefix::*;\n         unsafe {\n             // The unsafety here stems from converting between &OsStr and &[u8]\n             // and back. This is safe to do because (1) we only look at ASCII\n@@ -224,8 +213,7 @@ mod platform {\n                             let c = path[0];\n                             if c.is_ascii() && (c as char).is_alphabetic() {\n                                 // \\\\?\\C:\\ path\n-                                let slice = u8_slice_as_os_str(&path[0..1]);\n-                                return Some(VerbatimDisk(slice));\n+                                return Some(VerbatimDisk(c.to_ascii_uppercase()));\n                             }\n                         }\n                         let slice = &path[.. idx.unwrap_or(path.len())];\n@@ -237,7 +225,7 @@ mod platform {\n                     let slice = &path[.. path.position_elem(&b'\\\\').unwrap_or(path.len())];\n                     return Some(DeviceNS(u8_slice_as_os_str(slice)));\n                 }\n-                match parse_two_comps(path, is_sep) {\n+                match parse_two_comps(path, is_sep_byte) {\n                     Some((server, share)) if server.len() > 0 && share.len() > 0 => {\n                         // \\\\server\\share\n                         return Some(UNC(u8_slice_as_os_str(server),\n@@ -249,7 +237,7 @@ mod platform {\n                 // C:\n                 let c = path[0];\n                 if c.is_ascii() && (c as char).is_alphabetic() {\n-                    return Some(Disk(u8_slice_as_os_str(&path[0..1])));\n+                    return Some(Disk(c.to_ascii_uppercase()));\n                 }\n             }\n             return None;\n@@ -267,99 +255,102 @@ mod platform {\n         }\n     }\n \n-    /// Windows path prefixes.\n-    ///\n-    /// Windows uses a variety of path styles, including references to drive\n-    /// volumes (like `C:`), network shared (like `\\\\server\\share`) and\n-    /// others. In addition, some path prefixes are \"verbatim\", in which case\n-    /// `/` is *not* treated as a separator and essentially no normalization is\n-    /// performed.\n-    #[derive(Copy, Clone, Debug, Hash, Eq)]\n-    pub enum Prefix<'a> {\n-        /// Prefix `\\\\?\\`, together with the given component immediately following it.\n-        Verbatim(&'a OsStr),\n-\n-        /// Prefix `\\\\?\\UNC\\`, with the \"server\" and \"share\" components following it.\n-        VerbatimUNC(&'a OsStr, &'a OsStr),\n-\n-        /// Prefix like `\\\\?\\C:\\`, for the given drive letter\n-        VerbatimDisk(&'a OsStr),\n-\n-        /// Prefix `\\\\.\\`, together with the given component immediately following it.\n-        DeviceNS(&'a OsStr),\n-\n-        /// Prefix `\\\\server\\share`, with the given \"server\" and \"share\" components.\n-        UNC(&'a OsStr, &'a OsStr),\n-\n-        /// Prefix `C:` for the given disk drive.\n-        Disk(&'a OsStr),\n-    }\n-\n-    impl<'a> Prefix<'a> {\n-        #[inline]\n-        pub fn len(&self) -> usize {\n-            use self::Prefix::*;\n-            fn os_str_len(s: &OsStr) -> usize {\n-                os_str_as_u8_slice(s).len()\n-            }\n-            match *self {\n-                Verbatim(x) => 4 + os_str_len(x),\n-                VerbatimUNC(x,y) => 8 + os_str_len(x) +\n-                    if os_str_len(y) > 0 { 1 + os_str_len(y) }\n-                    else { 0 },\n-                VerbatimDisk(_) => 6,\n-                UNC(x,y) => 2 + os_str_len(x) +\n-                    if os_str_len(y) > 0 { 1 + os_str_len(y) }\n-                    else { 0 },\n-                DeviceNS(x) => 4 + os_str_len(x),\n-                Disk(_) => 2\n-            }\n+    pub const MAIN_SEP_STR: &'static str = \"\\\\\";\n+    pub const MAIN_SEP: char = '\\\\';\n+}\n \n-        }\n+////////////////////////////////////////////////////////////////////////////////\n+// Windows Prefixes\n+////////////////////////////////////////////////////////////////////////////////\n \n-        #[inline]\n-        pub fn is_verbatim(&self) -> bool {\n-            use self::Prefix::*;\n-            match *self {\n-                Verbatim(_) | VerbatimDisk(_) | VerbatimUNC(_, _) => true,\n-                _ => false\n-            }\n-        }\n+/// Path prefixes (Windows only).\n+///\n+/// Windows uses a variety of path styles, including references to drive\n+/// volumes (like `C:`), network shared (like `\\\\server\\share`) and\n+/// others. In addition, some path prefixes are \"verbatim\", in which case\n+/// `/` is *not* treated as a separator and essentially no normalization is\n+/// performed.\n+#[derive(Copy, Clone, Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]\n+pub enum Prefix<'a> {\n+    /// Prefix `\\\\?\\`, together with the given component immediately following it.\n+    Verbatim(&'a OsStr),\n+\n+    /// Prefix `\\\\?\\UNC\\`, with the \"server\" and \"share\" components following it.\n+    VerbatimUNC(&'a OsStr, &'a OsStr),\n+\n+    /// Prefix like `\\\\?\\C:\\`, for the given drive letter\n+    VerbatimDisk(u8),\n+\n+    /// Prefix `\\\\.\\`, together with the given component immediately following it.\n+    DeviceNS(&'a OsStr),\n+\n+    /// Prefix `\\\\server\\share`, with the given \"server\" and \"share\" components.\n+    UNC(&'a OsStr, &'a OsStr),\n+\n+    /// Prefix `C:` for the given disk drive.\n+    Disk(u8),\n+}\n \n-        #[inline]\n-        pub fn is_drive(&self) -> bool {\n-            match *self {\n-                Prefix::Disk(_) => true,\n-                _ => false,\n-            }\n+impl<'a> Prefix<'a> {\n+    #[inline]\n+    fn len(&self) -> usize {\n+        use self::Prefix::*;\n+        fn os_str_len(s: &OsStr) -> usize {\n+            os_str_as_u8_slice(s).len()\n+        }\n+        match *self {\n+            Verbatim(x) => 4 + os_str_len(x),\n+            VerbatimUNC(x,y) => 8 + os_str_len(x) +\n+                if os_str_len(y) > 0 { 1 + os_str_len(y) }\n+                else { 0 },\n+            VerbatimDisk(_) => 6,\n+            UNC(x,y) => 2 + os_str_len(x) +\n+                if os_str_len(y) > 0 { 1 + os_str_len(y) }\n+                else { 0 },\n+            DeviceNS(x) => 4 + os_str_len(x),\n+            Disk(_) => 2\n         }\n \n-        #[inline]\n-        pub fn has_implicit_root(&self) -> bool {\n-            !self.is_drive()\n+    }\n+\n+    /// Determine if the prefix is verbatim, i.e. begins `\\\\?\\`.\n+    #[inline]\n+    pub fn is_verbatim(&self) -> bool {\n+        use self::Prefix::*;\n+        match *self {\n+            Verbatim(_) | VerbatimDisk(_) | VerbatimUNC(_, _) => true,\n+            _ => false\n         }\n     }\n \n-    impl<'a> PartialEq for Prefix<'a> {\n-        fn eq(&self, other: &Prefix<'a>) -> bool {\n-            use self::Prefix::*;\n-            match (*self, *other) {\n-                (Verbatim(x), Verbatim(y)) => x == y,\n-                (VerbatimUNC(x1, x2), VerbatimUNC(y1, y2)) => x1 == y1 && x2 == y2,\n-                (VerbatimDisk(x), VerbatimDisk(y)) =>\n-                    os_str_as_u8_slice(x).eq_ignore_ascii_case(os_str_as_u8_slice(y)),\n-                (DeviceNS(x), DeviceNS(y)) => x == y,\n-                (UNC(x1, x2), UNC(y1, y2)) => x1 == y1 && x2 == y2,\n-                (Disk(x), Disk(y)) =>\n-                    os_str_as_u8_slice(x).eq_ignore_ascii_case(os_str_as_u8_slice(y)),\n-                _ => false,\n-            }\n+    #[inline]\n+    fn is_drive(&self) -> bool {\n+        match *self {\n+            Prefix::Disk(_) => true,\n+            _ => false,\n         }\n     }\n \n-    pub const MAIN_SEP_STR: &'static str = \"\\\\\";\n+    #[inline]\n+    fn has_implicit_root(&self) -> bool {\n+        !self.is_drive()\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Exposed parsing helpers\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Determine whether the character is one of the permitted path\n+/// separators for the current platform.\n+pub fn is_separator(c: char) -> bool {\n+    use ascii::*;\n+    c.is_ascii() && is_sep_byte(c as u8)\n }\n \n+/// The primary sperator for the current platform\n+pub const MAIN_SEPARATOR: char = platform::MAIN_SEP;\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Misc helpers\n ////////////////////////////////////////////////////////////////////////////////\n@@ -403,7 +394,7 @@ fn has_suffix(s: &[u8], prefix: Option<Prefix>) -> bool {\n         (p.len(), p.is_verbatim())\n     } else { (0, false) };\n     if prefix_len > 0 && prefix_len == s.len() && !verbatim { return true; }\n-    let mut splits = s[prefix_len..].split(|b| is_sep(*b));\n+    let mut splits = s[prefix_len..].split(|b| is_sep_byte(*b));\n     let last = splits.next_back().unwrap();\n     let more = splits.next_back().is_some();\n     more && last == b\"\"\n@@ -412,7 +403,7 @@ fn has_suffix(s: &[u8], prefix: Option<Prefix>) -> bool {\n /// Says whether the first byte after the prefix is a separator.\n fn has_physical_root(s: &[u8], prefix: Option<Prefix>) -> bool {\n     let path = if let Some(p) = prefix { &s[p.len()..] } else { s };\n-    path.len() > 0 && is_sep(path[0])\n+    path.len() > 0 && is_sep_byte(path[0])\n }\n \n fn parse_single_component(comp: &[u8]) -> Option<Component> {\n@@ -473,8 +464,16 @@ enum State {\n /// their role in the API.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n pub enum Component<'a> {\n-    /// A Windows path prefix, e.g. `C:` or `\\server\\share`\n-    Prefix(&'a OsStr),\n+    /// A Windows path prefix, e.g. `C:` or `\\server\\share`.\n+    ///\n+    /// Does not occur on Unix.\n+    Prefix {\n+        /// The prefix as an unparsed `OsStr` slice.\n+        raw: &'a OsStr,\n+\n+        /// The parsed prefix data.\n+        parsed: Prefix<'a>\n+    },\n \n     /// An empty component. Only used on Windows for the last component of\n     /// verbatim paths ending with a separator (e.g. the last component of\n@@ -498,7 +497,7 @@ impl<'a> Component<'a> {\n     /// Extract the underlying `OsStr` slice\n     pub fn as_os_str(self) -> &'a OsStr {\n         match self {\n-            Component::Prefix(path) => path,\n+            Component::Prefix { raw, .. } => &raw,\n             Component::Empty => OsStr::from_str(\"\"),\n             Component::RootDir => OsStr::from_str(MAIN_SEP_STR),\n             Component::CurDir => OsStr::from_str(\".\"),\n@@ -568,11 +567,11 @@ impl<'a> Components<'a> {\n     }\n \n     #[inline]\n-    fn is_sep(&self, b: u8) -> bool {\n+    fn is_sep_byte(&self, b: u8) -> bool {\n         if self.prefix_verbatim() {\n             is_verbatim_sep(b)\n         } else {\n-            is_sep(b)\n+            is_sep_byte(b)\n         }\n     }\n \n@@ -601,7 +600,7 @@ impl<'a> Components<'a> {\n     // remove the component\n     fn parse_next_component(&self) -> (usize, Option<Component<'a>>) {\n         debug_assert!(self.front == State::Body);\n-        let (extra, comp) = match self.path.iter().position(|b| self.is_sep(*b)) {\n+        let (extra, comp) = match self.path.iter().position(|b| self.is_sep_byte(*b)) {\n             None => (0, self.path),\n             Some(i) => (1, &self.path[.. i]),\n         };\n@@ -613,7 +612,7 @@ impl<'a> Components<'a> {\n     fn parse_next_component_back(&self) -> (usize, Option<Component<'a>>) {\n         debug_assert!(self.back == State::Body);\n         let start = self.prefix_and_root();\n-        let (extra, comp) = match self.path[start..].iter().rposition(|b| self.is_sep(*b)) {\n+        let (extra, comp) = match self.path[start..].iter().rposition(|b| self.is_sep_byte(*b)) {\n             None => (0, &self.path[start ..]),\n             Some(i) => (1, &self.path[start + i + 1 ..]),\n         };\n@@ -680,9 +679,12 @@ impl<'a> Iterator for Components<'a> {\n                 State::Prefix if self.prefix_len() > 0 => {\n                     self.front = State::Root;\n                     debug_assert!(self.prefix_len() <= self.path.len());\n-                    let prefix = &self.path[.. self.prefix_len()];\n+                    let raw = &self.path[.. self.prefix_len()];\n                     self.path = &self.path[self.prefix_len() .. ];\n-                    return Some(Component::Prefix(unsafe { u8_slice_as_os_str(prefix) }))\n+                    return Some(Component::Prefix {\n+                        raw: unsafe { u8_slice_as_os_str(raw) },\n+                        parsed: self.prefix.unwrap()\n+                    })\n                 }\n                 State::Prefix => {\n                     self.front = State::Root;\n@@ -755,9 +757,10 @@ impl<'a> DoubleEndedIterator for Components<'a> {\n                 }\n                 State::Prefix if self.prefix_len() > 0 => {\n                     self.back = State::Done;\n-                    return Some(Component::Prefix(unsafe {\n-                        u8_slice_as_os_str(self.path)\n-                    }))\n+                    return Some(Component::Prefix {\n+                        raw: unsafe { u8_slice_as_os_str(self.path) },\n+                        parsed: self.prefix.unwrap()\n+                    })\n                 }\n                 State::Prefix => {\n                     self.back = State::Done;\n@@ -844,7 +847,7 @@ impl PathBuf {\n     /// * if `path` has a prefix but no root, it replaces `self.\n     pub fn push<P: ?Sized>(&mut self, path: &P) where P: AsPath {\n         // in general, a separator is needed if the rightmost byte is not a separator\n-        let mut need_sep = self.as_mut_vec().last().map(|c| !is_sep(*c)).unwrap_or(false);\n+        let mut need_sep = self.as_mut_vec().last().map(|c| !is_sep_byte(*c)).unwrap_or(false);\n \n         // in the special case of `C:` on Windows, do *not* add a separator\n         {\n@@ -1142,11 +1145,11 @@ impl Path {\n \n         match (comp, comps.next_back()) {\n             (Some(Component::CurDir), Some(Component::RootDir)) => None,\n-            (Some(Component::CurDir), Some(Component::Prefix(_))) => None,\n+            (Some(Component::CurDir), Some(Component::Prefix { .. })) => None,\n             (Some(Component::Empty), Some(Component::RootDir)) => None,\n-            (Some(Component::Empty), Some(Component::Prefix(_))) => None,\n-            (Some(Component::Prefix(_)), None) => None,\n-            (Some(Component::RootDir), Some(Component::Prefix(_))) => None,\n+            (Some(Component::Empty), Some(Component::Prefix { .. })) => None,\n+            (Some(Component::Prefix { .. }), None) => None,\n+            (Some(Component::RootDir), Some(Component::Prefix { .. })) => None,\n             _ => rest\n         }\n     }"}, {"sha": "5baa095d35985c7b44aed14c10f4d49359f113ce", "filename": "src/libstd/process.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -27,7 +27,7 @@ use sys::process2::Process as ProcessImp;\n use sys::process2::Command as CommandImp;\n use sys::process2::ExitStatus as ExitStatusImp;\n use sys_common::{AsInner, AsInnerMut};\n-use thread::Thread;\n+use thread;\n \n /// Representation of a running or exited child process.\n ///\n@@ -458,11 +458,11 @@ impl Child {\n     /// the parent waits for the child to exit.\n     pub fn wait_with_output(mut self) -> io::Result<Output> {\n         drop(self.stdin.take());\n-        fn read<T: Read + Send>(stream: Option<T>) -> Receiver<io::Result<Vec<u8>>> {\n+        fn read<T: Read + Send + 'static>(stream: Option<T>) -> Receiver<io::Result<Vec<u8>>> {\n             let (tx, rx) = channel();\n             match stream {\n                 Some(stream) => {\n-                    Thread::spawn(move || {\n+                    thread::spawn(move || {\n                         let mut stream = stream;\n                         let mut ret = Vec::new();\n                         let res = stream.read_to_end(&mut ret);\n@@ -499,7 +499,7 @@ mod tests {\n     use str;\n     use super::{Child, Command, Output, ExitStatus, Stdio};\n     use sync::mpsc::channel;\n-    use thread::Thread;\n+    use thread;\n     use time::Duration;\n \n     // FIXME(#10380) these tests should not all be ignored on android.\n@@ -537,12 +537,12 @@ mod tests {\n     fn signal_reported_right() {\n         use os::unix::ExitStatusExt;\n \n-        let p = Command::new(\"/bin/sh\").arg(\"-c\").arg(\"kill -1 $$\").spawn();\n+        let p = Command::new(\"/bin/sh\").arg(\"-c\").arg(\"kill -9 $$\").spawn();\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n         match p.wait().unwrap().signal() {\n-            Some(1) => {},\n-            result => panic!(\"not terminated by signal 1 (instead, {:?})\", result),\n+            Some(9) => {},\n+            result => panic!(\"not terminated by signal 9 (instead, {:?})\", result),\n         }\n     }\n "}, {"sha": "0feacf5581c97414d6726b7d3ecebf598e69930b", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -360,7 +360,7 @@ mod test {\n     use sync::mpsc::channel;\n     use rand::Rng;\n     use super::OsRng;\n-    use thread::Thread;\n+    use thread;\n \n     #[test]\n     fn test_os_rng() {\n@@ -381,23 +381,23 @@ mod test {\n             let (tx, rx) = channel();\n             txs.push(tx);\n \n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 // wait until all the tasks are ready to go.\n                 rx.recv().unwrap();\n \n                 // deschedule to attempt to interleave things as much\n                 // as possible (XXX: is this a good test?)\n                 let mut r = OsRng::new().unwrap();\n-                Thread::yield_now();\n+                thread::yield_now();\n                 let mut v = [0u8; 1000];\n \n                 for _ in 0u..100 {\n                     r.next_u32();\n-                    Thread::yield_now();\n+                    thread::yield_now();\n                     r.next_u64();\n-                    Thread::yield_now();\n+                    thread::yield_now();\n                     r.fill_bytes(&mut v);\n-                    Thread::yield_now();\n+                    thread::yield_now();\n                 }\n             });\n         }"}, {"sha": "72486fc55d48ee91ef09c3e4a73b3908c9d395d0", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -20,7 +20,7 @@ use mem;\n use thunk::Thunk;\n use sys_common::mutex::{Mutex, MUTEX_INIT};\n \n-type Queue = Vec<Thunk>;\n+type Queue = Vec<Thunk<'static>>;\n \n // NB these are specifically not types from `std::sync` as they currently rely\n // on poisoning and this module needs to operate at a lower level than requiring\n@@ -65,7 +65,7 @@ pub fn cleanup() {\n     }\n }\n \n-pub fn push(f: Thunk) {\n+pub fn push(f: Thunk<'static>) {\n     unsafe {\n         LOCK.lock();\n         init();"}, {"sha": "42cca73e5e24128e2b40b92b64615277aa01da82", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -148,7 +148,7 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n ///\n /// It is forbidden for procedures to register more `at_exit` handlers when they\n /// are running, and doing so will lead to a process abort.\n-pub fn at_exit<F:FnOnce()+Send>(f: F) {\n+pub fn at_exit<F:FnOnce()+Send+'static>(f: F) {\n     at_exit_imp::push(Thunk::new(f));\n }\n "}, {"sha": "1f5eb3af695be8e09040c92463db3ce950031e97", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -74,7 +74,7 @@ use rt::libunwind as uw;\n \n struct Exception {\n     uwe: uw::_Unwind_Exception,\n-    cause: Option<Box<Any + Send>>,\n+    cause: Option<Box<Any + Send + 'static>>,\n }\n \n pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: uint);\n@@ -161,7 +161,7 @@ pub fn panicking() -> bool {\n #[inline(never)]\n #[no_mangle]\n #[allow(private_no_mangle_fns)]\n-fn rust_panic(cause: Box<Any + Send>) -> ! {\n+fn rust_panic(cause: Box<Any + Send + 'static>) -> ! {\n     rtdebug!(\"begin_unwind()\");\n \n     unsafe {"}, {"sha": "a304f1f844d748f8f263fc73db78d984ec38bbe9", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -149,7 +149,7 @@ pub fn abort(args: fmt::Arguments) -> ! {\n }\n \n pub unsafe fn report_overflow() {\n-    use thread::Thread;\n+    use thread;\n \n     // See the message below for why this is not emitted to the\n     // ^ Where did the message below go?\n@@ -159,5 +159,5 @@ pub unsafe fn report_overflow() {\n     // and the FFI call needs 2MB of stack when we just ran out.\n \n     rterrln!(\"\\nthread '{}' has overflowed its stack\",\n-             Thread::current().name().unwrap_or(\"<unknown>\"));\n+             thread::current().name().unwrap_or(\"<unknown>\"));\n }"}, {"sha": "fc781eb4bece4efa0f16b943b05875db5b7acecc", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -15,14 +15,14 @@ use sync::{Mutex, Condvar};\n ///\n /// ```rust\n /// use std::sync::{Arc, Barrier};\n-/// use std::thread::Thread;\n+/// use std::thread;\n ///\n /// let barrier = Arc::new(Barrier::new(10));\n /// for _ in 0u..10 {\n ///     let c = barrier.clone();\n ///     // The same messages will be printed together.\n ///     // You will NOT see any interleaving.\n-///     Thread::spawn(move|| {\n+///     thread::spawn(move|| {\n ///         println!(\"before wait\");\n ///         c.wait();\n ///         println!(\"after wait\");\n@@ -111,7 +111,7 @@ mod tests {\n \n     use sync::{Arc, Barrier};\n     use sync::mpsc::{channel, TryRecvError};\n-    use thread::Thread;\n+    use thread;\n \n     #[test]\n     fn test_barrier() {\n@@ -123,7 +123,7 @@ mod tests {\n         for _ in 0u..N - 1 {\n             let c = barrier.clone();\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 tx.send(c.wait().is_leader()).unwrap();\n             });\n         }"}, {"sha": "52561d482c39dcc4b5acf9a05de030865870b91d", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -38,13 +38,13 @@ use sync::{mutex, MutexGuard, PoisonError};\n ///\n /// ```\n /// use std::sync::{Arc, Mutex, Condvar};\n-/// use std::thread::Thread;\n+/// use std::thread;\n ///\n /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n /// let pair2 = pair.clone();\n ///\n /// // Inside of our lock, spawn a new thread, and then wait for it to start\n-/// Thread::spawn(move|| {\n+/// thread::spawn(move|| {\n ///     let &(ref lock, ref cvar) = &*pair2;\n ///     let mut started = lock.lock().unwrap();\n ///     *started = true;\n@@ -353,7 +353,7 @@ mod tests {\n     use sync::mpsc::channel;\n     use sync::{StaticMutex, MUTEX_INIT, Condvar, Mutex, Arc};\n     use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n-    use thread::Thread;\n+    use thread;\n     use time::Duration;\n \n     #[test]\n@@ -377,7 +377,7 @@ mod tests {\n         static M: StaticMutex = MUTEX_INIT;\n \n         let g = M.lock().unwrap();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _g = M.lock().unwrap();\n             C.notify_one();\n         });\n@@ -395,7 +395,7 @@ mod tests {\n         for _ in 0..N {\n             let data = data.clone();\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 let &(ref lock, ref cond) = &*data;\n                 let mut cnt = lock.lock().unwrap();\n                 *cnt += 1;\n@@ -431,7 +431,7 @@ mod tests {\n         let (g, _no_timeout) = C.wait_timeout(g, Duration::nanoseconds(1000)).unwrap();\n         // spurious wakeups mean this isn't necessarily true\n         // assert!(!no_timeout);\n-        let _t = Thread::spawn(move || {\n+        let _t = thread::spawn(move || {\n             let _g = M.lock().unwrap();\n             C.notify_one();\n         });\n@@ -452,7 +452,7 @@ mod tests {\n         assert!(!success);\n \n         let (tx, rx) = channel();\n-        let _t = Thread::scoped(move || {\n+        let _t = thread::spawn(move || {\n             rx.recv().unwrap();\n             let g = M.lock().unwrap();\n             S.store(1, Ordering::SeqCst);\n@@ -492,7 +492,7 @@ mod tests {\n         static C: StaticCondvar = CONDVAR_INIT;\n \n         let mut g = M1.lock().unwrap();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _g = M1.lock().unwrap();\n             C.notify_one();\n         });"}, {"sha": "d60e27388086444a4323c8f53525a8046b28ecec", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -38,15 +38,15 @@ use core::mem::replace;\n use self::FutureState::*;\n use sync::mpsc::{Receiver, channel};\n use thunk::{Thunk};\n-use thread::Thread;\n+use thread;\n \n /// A type encapsulating the result of a computation which may not be complete\n pub struct Future<A> {\n     state: FutureState<A>,\n }\n \n enum FutureState<A> {\n-    Pending(Thunk<(),A>),\n+    Pending(Thunk<'static,(),A>),\n     Evaluating,\n     Forced(A)\n }\n@@ -103,7 +103,7 @@ impl<A> Future<A> {\n     }\n \n     pub fn from_fn<F>(f: F) -> Future<A>\n-        where F : FnOnce() -> A, F : Send\n+        where F : FnOnce() -> A, F : Send + 'static\n     {\n         /*!\n          * Create a future from a function.\n@@ -117,7 +117,7 @@ impl<A> Future<A> {\n     }\n }\n \n-impl<A:Send> Future<A> {\n+impl<A:Send+'static> Future<A> {\n     pub fn from_receiver(rx: Receiver<A>) -> Future<A> {\n         /*!\n          * Create a future from a port\n@@ -132,7 +132,7 @@ impl<A:Send> Future<A> {\n     }\n \n     pub fn spawn<F>(blk: F) -> Future<A>\n-        where F : FnOnce() -> A, F : Send\n+        where F : FnOnce() -> A, F : Send + 'static\n     {\n         /*!\n          * Create a future from a unique closure.\n@@ -143,7 +143,7 @@ impl<A:Send> Future<A> {\n \n         let (tx, rx) = channel();\n \n-        Thread::spawn(move || {\n+        thread::spawn(move || {\n             // Don't panic if the other end has hung up\n             let _ = tx.send(blk());\n         });\n@@ -157,7 +157,7 @@ mod test {\n     use prelude::v1::*;\n     use sync::mpsc::channel;\n     use sync::Future;\n-    use thread::Thread;\n+    use thread;\n \n     #[test]\n     fn test_from_value() {\n@@ -215,7 +215,7 @@ mod test {\n         let expected = \"schlorf\";\n         let (tx, rx) = channel();\n         let f = Future::spawn(move|| { expected });\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut f = f;\n             tx.send(f.get()).unwrap();\n         });"}, {"sha": "69b1e242b154d472857c032aab0ff00cdec3366c", "filename": "src/libstd/sync/mpsc/blocking.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -10,7 +10,7 @@\n \n //! Generic support for building blocking abstractions.\n \n-use thread::Thread;\n+use thread::{self, Thread};\n use sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT, Ordering};\n use sync::Arc;\n use marker::{Sync, Send};\n@@ -40,7 +40,7 @@ impl !Sync for WaitToken {}\n \n pub fn tokens() -> (WaitToken, SignalToken) {\n     let inner = Arc::new(Inner {\n-        thread: Thread::current(),\n+        thread: thread::current(),\n         woken: ATOMIC_BOOL_INIT,\n     });\n     let wait_token = WaitToken {\n@@ -80,7 +80,7 @@ impl SignalToken {\n impl WaitToken {\n     pub fn wait(self) {\n         while !self.inner.woken.load(Ordering::SeqCst) {\n-            Thread::park()\n+            thread::park()\n         }\n     }\n }"}, {"sha": "410d3c0ecd5e459cb9c84c6e68386dfd0beaaa46", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 92, "deletions": 92, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -53,12 +53,12 @@\n //! Simple usage:\n //!\n //! ```\n-//! use std::thread::Thread;\n+//! use std::thread;\n //! use std::sync::mpsc::channel;\n //!\n //! // Create a simple streaming channel\n //! let (tx, rx) = channel();\n-//! Thread::spawn(move|| {\n+//! thread::spawn(move|| {\n //!     tx.send(10).unwrap();\n //! });\n //! assert_eq!(rx.recv().unwrap(), 10);\n@@ -67,7 +67,7 @@\n //! Shared usage:\n //!\n //! ```\n-//! use std::thread::Thread;\n+//! use std::thread;\n //! use std::sync::mpsc::channel;\n //!\n //! // Create a shared channel that can be sent along from many threads\n@@ -76,7 +76,7 @@\n //! let (tx, rx) = channel();\n //! for i in 0..10 {\n //!     let tx = tx.clone();\n-//!     Thread::spawn(move|| {\n+//!     thread::spawn(move|| {\n //!         tx.send(i).unwrap();\n //!     });\n //! }\n@@ -102,11 +102,11 @@\n //! Synchronous channels:\n //!\n //! ```\n-//! use std::thread::Thread;\n+//! use std::thread;\n //! use std::sync::mpsc::sync_channel;\n //!\n //! let (tx, rx) = sync_channel::<int>(0);\n-//! Thread::spawn(move|| {\n+//! thread::spawn(move|| {\n //!     // This will wait for the parent task to start receiving\n //!     tx.send(53).unwrap();\n //! });\n@@ -345,7 +345,7 @@ pub struct Receiver<T> {\n \n // The receiver port can be sent from place to place, so long as it\n // is not used to receive non-sendable things.\n-unsafe impl<T:Send> Send for Receiver<T> { }\n+unsafe impl<T: Send + 'static> Send for Receiver<T> { }\n \n /// An iterator over messages on a receiver, this iterator will block\n /// whenever `next` is called, waiting for a new message, and `None` will be\n@@ -364,7 +364,7 @@ pub struct Sender<T> {\n \n // The send port can be sent from place to place, so long as it\n // is not used to send non-sendable things.\n-unsafe impl<T:Send> Send for Sender<T> { }\n+unsafe impl<T: Send + 'static> Send for Sender<T> { }\n \n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n@@ -373,7 +373,7 @@ pub struct SyncSender<T> {\n     inner: Arc<UnsafeCell<sync::Packet<T>>>,\n }\n \n-unsafe impl<T:Send> Send for SyncSender<T> {}\n+unsafe impl<T: Send + 'static> Send for SyncSender<T> {}\n \n impl<T> !Sync for SyncSender<T> {}\n \n@@ -467,14 +467,14 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n ///\n /// ```\n /// use std::sync::mpsc::channel;\n-/// use std::thread::Thread;\n+/// use std::thread;\n ///\n /// // tx is is the sending half (tx for transmission), and rx is the receiving\n /// // half (rx for receiving).\n /// let (tx, rx) = channel();\n ///\n /// // Spawn off an expensive computation\n-/// Thread::spawn(move|| {\n+/// thread::spawn(move|| {\n /// #   fn expensive_computation() {}\n ///     tx.send(expensive_computation()).unwrap();\n /// });\n@@ -485,7 +485,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// println!(\"{:?}\", rx.recv().unwrap());\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n+pub fn channel<T: Send + 'static>() -> (Sender<T>, Receiver<T>) {\n     let a = Arc::new(UnsafeCell::new(oneshot::Packet::new()));\n     (Sender::new(Flavor::Oneshot(a.clone())), Receiver::new(Flavor::Oneshot(a)))\n }\n@@ -509,14 +509,14 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n ///\n /// ```\n /// use std::sync::mpsc::sync_channel;\n-/// use std::thread::Thread;\n+/// use std::thread;\n ///\n /// let (tx, rx) = sync_channel(1);\n ///\n /// // this returns immediately\n /// tx.send(1).unwrap();\n ///\n-/// Thread::spawn(move|| {\n+/// thread::spawn(move|| {\n ///     // this will block until the previous message has been received\n ///     tx.send(2).unwrap();\n /// });\n@@ -525,7 +525,7 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n /// assert_eq!(rx.recv().unwrap(), 2);\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n+pub fn sync_channel<T: Send + 'static>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n     let a = Arc::new(UnsafeCell::new(sync::Packet::new(bound)));\n     (SyncSender::new(a.clone()), Receiver::new(Flavor::Sync(a)))\n }\n@@ -534,7 +534,7 @@ pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n // Sender\n ////////////////////////////////////////////////////////////////////////////////\n \n-impl<T: Send> Sender<T> {\n+impl<T: Send + 'static> Sender<T> {\n     fn new(inner: Flavor<T>) -> Sender<T> {\n         Sender {\n             inner: UnsafeCell::new(inner),\n@@ -616,7 +616,7 @@ impl<T: Send> Sender<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send> Clone for Sender<T> {\n+impl<T: Send + 'static> Clone for Sender<T> {\n     fn clone(&self) -> Sender<T> {\n         let (packet, sleeper, guard) = match *unsafe { self.inner() } {\n             Flavor::Oneshot(ref p) => {\n@@ -662,7 +662,7 @@ impl<T: Send> Clone for Sender<T> {\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send> Drop for Sender<T> {\n+impl<T: Send + 'static> Drop for Sender<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {\n             Flavor::Oneshot(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n@@ -677,7 +677,7 @@ impl<T: Send> Drop for Sender<T> {\n // SyncSender\n ////////////////////////////////////////////////////////////////////////////////\n \n-impl<T: Send> SyncSender<T> {\n+impl<T: Send + 'static> SyncSender<T> {\n     fn new(inner: Arc<UnsafeCell<sync::Packet<T>>>) -> SyncSender<T> {\n         SyncSender { inner: inner }\n     }\n@@ -717,7 +717,7 @@ impl<T: Send> SyncSender<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send> Clone for SyncSender<T> {\n+impl<T: Send + 'static> Clone for SyncSender<T> {\n     fn clone(&self) -> SyncSender<T> {\n         unsafe { (*self.inner.get()).clone_chan(); }\n         return SyncSender::new(self.inner.clone());\n@@ -726,7 +726,7 @@ impl<T: Send> Clone for SyncSender<T> {\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send> Drop for SyncSender<T> {\n+impl<T: Send + 'static> Drop for SyncSender<T> {\n     fn drop(&mut self) {\n         unsafe { (*self.inner.get()).drop_chan(); }\n     }\n@@ -736,7 +736,7 @@ impl<T: Send> Drop for SyncSender<T> {\n // Receiver\n ////////////////////////////////////////////////////////////////////////////////\n \n-impl<T: Send> Receiver<T> {\n+impl<T: Send + 'static> Receiver<T> {\n     fn new(inner: Flavor<T>) -> Receiver<T> {\n         Receiver { inner: UnsafeCell::new(inner) }\n     }\n@@ -855,7 +855,7 @@ impl<T: Send> Receiver<T> {\n     }\n }\n \n-impl<T: Send> select::Packet for Receiver<T> {\n+impl<T: Send + 'static> select::Packet for Receiver<T> {\n     fn can_recv(&self) -> bool {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n@@ -942,15 +942,15 @@ impl<T: Send> select::Packet for Receiver<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: Send> Iterator for Iter<'a, T> {\n+impl<'a, T: Send + 'static> Iterator for Iter<'a, T> {\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> { self.rx.recv().ok() }\n }\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send> Drop for Receiver<T> {\n+impl<T: Send + 'static> Drop for Receiver<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {\n             Flavor::Oneshot(ref mut p) => unsafe { (*p.get()).drop_port(); },\n@@ -1026,7 +1026,7 @@ mod test {\n \n     use std::env;\n     use super::*;\n-    use thread::Thread;\n+    use thread;\n \n     pub fn stress_factor() -> uint {\n         match env::var(\"RUST_TEST_STRESS\") {\n@@ -1069,7 +1069,7 @@ mod test {\n     #[test]\n     fn smoke_threads() {\n         let (tx, rx) = channel::<int>();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             tx.send(1).unwrap();\n         });\n         assert_eq!(rx.recv().unwrap(), 1);\n@@ -1101,7 +1101,7 @@ mod test {\n     #[test]\n     fn port_gone_concurrent() {\n         let (tx, rx) = channel::<int>();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n         });\n         while tx.send(1).is_ok() {}\n@@ -1111,7 +1111,7 @@ mod test {\n     fn port_gone_concurrent_shared() {\n         let (tx, rx) = channel::<int>();\n         let tx2 = tx.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n         });\n         while tx.send(1).is_ok() && tx2.send(1).is_ok() {}\n@@ -1136,7 +1136,7 @@ mod test {\n     #[test]\n     fn chan_gone_concurrent() {\n         let (tx, rx) = channel::<int>();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             tx.send(1).unwrap();\n             tx.send(1).unwrap();\n         });\n@@ -1146,7 +1146,7 @@ mod test {\n     #[test]\n     fn stress() {\n         let (tx, rx) = channel::<int>();\n-        let t = Thread::scoped(move|| {\n+        let t = thread::spawn(move|| {\n             for _ in 0u..10000 { tx.send(1).unwrap(); }\n         });\n         for _ in 0u..10000 {\n@@ -1161,7 +1161,7 @@ mod test {\n         static NTHREADS: uint = 8;\n         let (tx, rx) = channel::<int>();\n \n-        let t = Thread::scoped(move|| {\n+        let t = thread::spawn(move|| {\n             for _ in 0..AMT * NTHREADS {\n                 assert_eq!(rx.recv().unwrap(), 1);\n             }\n@@ -1173,7 +1173,7 @@ mod test {\n \n         for _ in 0..NTHREADS {\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 for _ in 0..AMT { tx.send(1).unwrap(); }\n             });\n         }\n@@ -1185,14 +1185,14 @@ mod test {\n     fn send_from_outside_runtime() {\n         let (tx1, rx1) = channel::<()>();\n         let (tx2, rx2) = channel::<int>();\n-        let t1 = Thread::scoped(move|| {\n+        let t1 = thread::spawn(move|| {\n             tx1.send(()).unwrap();\n             for _ in 0..40 {\n                 assert_eq!(rx2.recv().unwrap(), 1);\n             }\n         });\n         rx1.recv().unwrap();\n-        let t2 = Thread::scoped(move|| {\n+        let t2 = thread::spawn(move|| {\n             for _ in 0..40 {\n                 tx2.send(1).unwrap();\n             }\n@@ -1204,7 +1204,7 @@ mod test {\n     #[test]\n     fn recv_from_outside_runtime() {\n         let (tx, rx) = channel::<int>();\n-        let t = Thread::scoped(move|| {\n+        let t = thread::spawn(move|| {\n             for _ in 0..40 {\n                 assert_eq!(rx.recv().unwrap(), 1);\n             }\n@@ -1219,11 +1219,11 @@ mod test {\n     fn no_runtime() {\n         let (tx1, rx1) = channel::<int>();\n         let (tx2, rx2) = channel::<int>();\n-        let t1 = Thread::scoped(move|| {\n+        let t1 = thread::spawn(move|| {\n             assert_eq!(rx1.recv().unwrap(), 1);\n             tx2.send(2).unwrap();\n         });\n-        let t2 = Thread::scoped(move|| {\n+        let t2 = thread::spawn(move|| {\n             tx1.send(1).unwrap();\n             assert_eq!(rx2.recv().unwrap(), 2);\n         });\n@@ -1256,7 +1256,7 @@ mod test {\n     #[test]\n     fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n-        let res = Thread::scoped(move|| {\n+        let res = thread::spawn(move|| {\n             let (tx, rx) = channel::<int>();\n             drop(tx);\n             rx.recv().unwrap();\n@@ -1325,7 +1325,7 @@ mod test {\n     #[test]\n     fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = channel::<Box<int>>();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             assert!(rx.recv().unwrap() == box 10);\n         });\n \n@@ -1335,10 +1335,10 @@ mod test {\n     #[test]\n     fn oneshot_multi_task_recv_then_close() {\n         let (tx, rx) = channel::<Box<int>>();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             drop(tx);\n         });\n-        let res = Thread::scoped(move|| {\n+        let res = thread::spawn(move|| {\n             assert!(rx.recv().unwrap() == box 10);\n         }).join();\n         assert!(res.is_err());\n@@ -1348,7 +1348,7 @@ mod test {\n     fn oneshot_multi_thread_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<int>();\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 drop(rx);\n             });\n             drop(tx);\n@@ -1359,10 +1359,10 @@ mod test {\n     fn oneshot_multi_thread_send_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<int>();\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 drop(rx);\n             });\n-            let _ = Thread::scoped(move|| {\n+            let _ = thread::spawn(move|| {\n                 tx.send(1).unwrap();\n             }).join();\n         }\n@@ -1372,14 +1372,14 @@ mod test {\n     fn oneshot_multi_thread_recv_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<int>();\n-            Thread::spawn(move|| {\n-                let res = Thread::scoped(move|| {\n+            thread::spawn(move|| {\n+                let res = thread::spawn(move|| {\n                     rx.recv().unwrap();\n                 }).join();\n                 assert!(res.is_err());\n             });\n-            let _t = Thread::spawn(move|| {\n-                Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n+                thread::spawn(move|| {\n                     drop(tx);\n                 });\n             });\n@@ -1390,7 +1390,7 @@ mod test {\n     fn oneshot_multi_thread_send_recv_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel();\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 tx.send(box 10).unwrap();\n             });\n             assert!(rx.recv().unwrap() == box 10);\n@@ -1408,7 +1408,7 @@ mod test {\n             fn send(tx: Sender<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n-                Thread::spawn(move|| {\n+                thread::spawn(move|| {\n                     tx.send(box i).unwrap();\n                     send(tx, i + 1);\n                 });\n@@ -1417,7 +1417,7 @@ mod test {\n             fn recv(rx: Receiver<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n-                Thread::spawn(move|| {\n+                thread::spawn(move|| {\n                     assert!(rx.recv().unwrap() == box i);\n                     recv(rx, i + 1);\n                 });\n@@ -1439,7 +1439,7 @@ mod test {\n         let total = stress_factor() + 100;\n         for _ in 0..total {\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 tx.send(()).unwrap();\n             });\n         }\n@@ -1454,7 +1454,7 @@ mod test {\n         let (tx, rx) = channel::<int>();\n         let (total_tx, total_rx) = channel::<int>();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut acc = 0;\n             for x in rx.iter() {\n                 acc += x;\n@@ -1474,7 +1474,7 @@ mod test {\n         let (tx, rx) = channel::<int>();\n         let (count_tx, count_rx) = channel();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut count = 0;\n             for x in rx.iter() {\n                 if count >= 3 {\n@@ -1499,7 +1499,7 @@ mod test {\n         let (tx1, rx1) = channel::<int>();\n         let (tx2, rx2) = channel::<()>();\n         let (tx3, rx3) = channel::<()>();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx2.recv().unwrap();\n             tx1.send(1).unwrap();\n             tx3.send(()).unwrap();\n@@ -1524,13 +1524,13 @@ mod test {\n     fn destroy_upgraded_shared_port_when_sender_still_active() {\n         let (tx, rx) = channel();\n         let (tx2, rx2) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx.recv().unwrap(); // wait on a oneshot\n             drop(rx);  // destroy a shared\n             tx2.send(()).unwrap();\n         });\n         // make sure the other task has gone to sleep\n-        for _ in 0u..5000 { Thread::yield_now(); }\n+        for _ in 0u..5000 { thread::yield_now(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n@@ -1547,7 +1547,7 @@ mod sync_tests {\n     use prelude::v1::*;\n \n     use std::env;\n-    use thread::Thread;\n+    use thread;\n     use super::*;\n \n     pub fn stress_factor() -> uint {\n@@ -1583,7 +1583,7 @@ mod sync_tests {\n     #[test]\n     fn smoke_threads() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             tx.send(1).unwrap();\n         });\n         assert_eq!(rx.recv().unwrap(), 1);\n@@ -1608,7 +1608,7 @@ mod sync_tests {\n     #[test]\n     fn port_gone_concurrent() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n         });\n         while tx.send(1).is_ok() {}\n@@ -1618,7 +1618,7 @@ mod sync_tests {\n     fn port_gone_concurrent_shared() {\n         let (tx, rx) = sync_channel::<int>(0);\n         let tx2 = tx.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n         });\n         while tx.send(1).is_ok() && tx2.send(1).is_ok() {}\n@@ -1643,7 +1643,7 @@ mod sync_tests {\n     #[test]\n     fn chan_gone_concurrent() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             tx.send(1).unwrap();\n             tx.send(1).unwrap();\n         });\n@@ -1653,7 +1653,7 @@ mod sync_tests {\n     #[test]\n     fn stress() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             for _ in 0u..10000 { tx.send(1).unwrap(); }\n         });\n         for _ in 0u..10000 {\n@@ -1668,7 +1668,7 @@ mod sync_tests {\n         let (tx, rx) = sync_channel::<int>(0);\n         let (dtx, drx) = sync_channel::<()>(0);\n \n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             for _ in 0..AMT * NTHREADS {\n                 assert_eq!(rx.recv().unwrap(), 1);\n             }\n@@ -1681,7 +1681,7 @@ mod sync_tests {\n \n         for _ in 0..NTHREADS {\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 for _ in 0..AMT { tx.send(1).unwrap(); }\n             });\n         }\n@@ -1714,7 +1714,7 @@ mod sync_tests {\n     #[test]\n     fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n-        let res = Thread::scoped(move|| {\n+        let res = thread::spawn(move|| {\n             let (tx, rx) = sync_channel::<int>(0);\n             drop(tx);\n             rx.recv().unwrap();\n@@ -1789,7 +1789,7 @@ mod sync_tests {\n     #[test]\n     fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = sync_channel::<Box<int>>(0);\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             assert!(rx.recv().unwrap() == box 10);\n         });\n \n@@ -1799,10 +1799,10 @@ mod sync_tests {\n     #[test]\n     fn oneshot_multi_task_recv_then_close() {\n         let (tx, rx) = sync_channel::<Box<int>>(0);\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             drop(tx);\n         });\n-        let res = Thread::scoped(move|| {\n+        let res = thread::spawn(move|| {\n             assert!(rx.recv().unwrap() == box 10);\n         }).join();\n         assert!(res.is_err());\n@@ -1812,7 +1812,7 @@ mod sync_tests {\n     fn oneshot_multi_thread_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<int>(0);\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 drop(rx);\n             });\n             drop(tx);\n@@ -1823,10 +1823,10 @@ mod sync_tests {\n     fn oneshot_multi_thread_send_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<int>(0);\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 drop(rx);\n             });\n-            let _ = Thread::scoped(move || {\n+            let _ = thread::spawn(move || {\n                 tx.send(1).unwrap();\n             }).join();\n         }\n@@ -1836,14 +1836,14 @@ mod sync_tests {\n     fn oneshot_multi_thread_recv_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<int>(0);\n-            let _t = Thread::spawn(move|| {\n-                let res = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n+                let res = thread::spawn(move|| {\n                     rx.recv().unwrap();\n                 }).join();\n                 assert!(res.is_err());\n             });\n-            let _t = Thread::spawn(move|| {\n-                Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n+                thread::spawn(move|| {\n                     drop(tx);\n                 });\n             });\n@@ -1854,7 +1854,7 @@ mod sync_tests {\n     fn oneshot_multi_thread_send_recv_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<Box<int>>(0);\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 tx.send(box 10).unwrap();\n             });\n             assert!(rx.recv().unwrap() == box 10);\n@@ -1872,7 +1872,7 @@ mod sync_tests {\n             fn send(tx: SyncSender<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n-                Thread::spawn(move|| {\n+                thread::spawn(move|| {\n                     tx.send(box i).unwrap();\n                     send(tx, i + 1);\n                 });\n@@ -1881,7 +1881,7 @@ mod sync_tests {\n             fn recv(rx: Receiver<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n-                Thread::spawn(move|| {\n+                thread::spawn(move|| {\n                     assert!(rx.recv().unwrap() == box i);\n                     recv(rx, i + 1);\n                 });\n@@ -1903,7 +1903,7 @@ mod sync_tests {\n         let total = stress_factor() + 100;\n         for _ in 0..total {\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 tx.send(()).unwrap();\n             });\n         }\n@@ -1918,7 +1918,7 @@ mod sync_tests {\n         let (tx, rx) = sync_channel::<int>(0);\n         let (total_tx, total_rx) = sync_channel::<int>(0);\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut acc = 0;\n             for x in rx.iter() {\n                 acc += x;\n@@ -1938,7 +1938,7 @@ mod sync_tests {\n         let (tx, rx) = sync_channel::<int>(0);\n         let (count_tx, count_rx) = sync_channel(0);\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut count = 0;\n             for x in rx.iter() {\n                 if count >= 3 {\n@@ -1963,7 +1963,7 @@ mod sync_tests {\n         let (tx1, rx1) = sync_channel::<int>(1);\n         let (tx2, rx2) = sync_channel::<()>(1);\n         let (tx3, rx3) = sync_channel::<()>(1);\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx2.recv().unwrap();\n             tx1.send(1).unwrap();\n             tx3.send(()).unwrap();\n@@ -1988,13 +1988,13 @@ mod sync_tests {\n     fn destroy_upgraded_shared_port_when_sender_still_active() {\n         let (tx, rx) = sync_channel::<()>(0);\n         let (tx2, rx2) = sync_channel::<()>(0);\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx.recv().unwrap(); // wait on a oneshot\n             drop(rx);  // destroy a shared\n             tx2.send(()).unwrap();\n         });\n         // make sure the other task has gone to sleep\n-        for _ in 0u..5000 { Thread::yield_now(); }\n+        for _ in 0u..5000 { thread::yield_now(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n@@ -2008,22 +2008,22 @@ mod sync_tests {\n     #[test]\n     fn send1() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        let _t = Thread::spawn(move|| { rx.recv().unwrap(); });\n+        let _t = thread::spawn(move|| { rx.recv().unwrap(); });\n         assert_eq!(tx.send(1), Ok(()));\n     }\n \n     #[test]\n     fn send2() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        let _t = Thread::spawn(move|| { drop(rx); });\n+        let _t = thread::spawn(move|| { drop(rx); });\n         assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n     fn send3() {\n         let (tx, rx) = sync_channel::<int>(1);\n         assert_eq!(tx.send(1), Ok(()));\n-        let _t =Thread::spawn(move|| { drop(rx); });\n+        let _t =thread::spawn(move|| { drop(rx); });\n         assert!(tx.send(1).is_err());\n     }\n \n@@ -2033,11 +2033,11 @@ mod sync_tests {\n         let tx2 = tx.clone();\n         let (done, donerx) = channel();\n         let done2 = done.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             assert!(tx.send(1).is_err());\n             done.send(()).unwrap();\n         });\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             assert!(tx2.send(2).is_err());\n             done2.send(()).unwrap();\n         });\n@@ -2073,7 +2073,7 @@ mod sync_tests {\n             let (tx1, rx1) = sync_channel::<()>(3);\n             let (tx2, rx2) = sync_channel::<()>(3);\n \n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 rx1.recv().unwrap();\n                 tx2.try_send(()).unwrap();\n             });"}, {"sha": "0a4ff8769abf49ba675a4e80ebf24459913c4e59", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -78,7 +78,7 @@ pub struct Queue<T> {\n }\n \n unsafe impl<T:Send> Send for Queue<T> { }\n-unsafe impl<T:Send> Sync for Queue<T> { }\n+unsafe impl<T: Send + 'static> Sync for Queue<T> { }\n \n impl<T> Node<T> {\n     unsafe fn new(v: Option<T>) -> *mut Node<T> {\n@@ -89,7 +89,7 @@ impl<T> Node<T> {\n     }\n }\n \n-impl<T: Send> Queue<T> {\n+impl<T: Send + 'static> Queue<T> {\n     /// Creates a new queue that is safe to share among multiple producers and\n     /// one consumer.\n     pub fn new() -> Queue<T> {\n@@ -140,7 +140,7 @@ impl<T: Send> Queue<T> {\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send> Drop for Queue<T> {\n+impl<T: Send + 'static> Drop for Queue<T> {\n     fn drop(&mut self) {\n         unsafe {\n             let mut cur = *self.tail.get();\n@@ -160,7 +160,7 @@ mod tests {\n     use sync::mpsc::channel;\n     use super::{Queue, Data, Empty, Inconsistent};\n     use sync::Arc;\n-    use thread::Thread;\n+    use thread;\n \n     #[test]\n     fn test_full() {\n@@ -184,7 +184,7 @@ mod tests {\n         for _ in 0..nthreads {\n             let tx = tx.clone();\n             let q = q.clone();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 for i in 0..nmsgs {\n                     q.push(i);\n                 }"}, {"sha": "55b2caf7c6d4cccea53aa2331ea3defaf0113524", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -88,7 +88,7 @@ enum MyUpgrade<T> {\n     GoUp(Receiver<T>),\n }\n \n-impl<T: Send> Packet<T> {\n+impl<T: Send + 'static> Packet<T> {\n     pub fn new() -> Packet<T> {\n         Packet {\n             data: None,\n@@ -368,7 +368,7 @@ impl<T: Send> Packet<T> {\n }\n \n #[unsafe_destructor]\n-impl<T: Send> Drop for Packet<T> {\n+impl<T: Send + 'static> Drop for Packet<T> {\n     fn drop(&mut self) {\n         assert_eq!(self.state.load(Ordering::SeqCst), DISCONNECTED);\n     }"}, {"sha": "4756ef612f947eeb8f7118388c91e13ec80c51b4", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -134,7 +134,7 @@ impl Select {\n     /// Creates a new handle into this receiver set for a new receiver. Note\n     /// that this does *not* add the receiver to the receiver set, for that you\n     /// must call the `add` method on the handle itself.\n-    pub fn handle<'a, T: Send>(&'a self, rx: &'a Receiver<T>) -> Handle<'a, T> {\n+    pub fn handle<'a, T: Send + 'static>(&'a self, rx: &'a Receiver<T>) -> Handle<'a, T> {\n         let id = self.next_id.get();\n         self.next_id.set(id + 1);\n         Handle {\n@@ -251,7 +251,7 @@ impl Select {\n     fn iter(&self) -> Packets { Packets { cur: self.head } }\n }\n \n-impl<'rx, T: Send> Handle<'rx, T> {\n+impl<'rx, T: Send + 'static> Handle<'rx, T> {\n     /// Retrieve the id of this handle.\n     #[inline]\n     pub fn id(&self) -> uint { self.id }\n@@ -322,7 +322,7 @@ impl Drop for Select {\n }\n \n #[unsafe_destructor]\n-impl<'rx, T: Send> Drop for Handle<'rx, T> {\n+impl<'rx, T: Send + 'static> Drop for Handle<'rx, T> {\n     fn drop(&mut self) {\n         unsafe { self.remove() }\n     }\n@@ -347,7 +347,7 @@ impl Iterator for Packets {\n mod test {\n     use prelude::v1::*;\n \n-    use thread::Thread;\n+    use thread;\n     use sync::mpsc::*;\n \n     // Don't use the libstd version so we can pull in the right Select structure\n@@ -427,11 +427,11 @@ mod test {\n         let (_tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<int>();\n \n-        let _t = Thread::spawn(move|| {\n-            for _ in 0u..20 { Thread::yield_now(); }\n+        let _t = thread::spawn(move|| {\n+            for _ in 0u..20 { thread::yield_now(); }\n             tx1.send(1).unwrap();\n             rx3.recv().unwrap();\n-            for _ in 0u..20 { Thread::yield_now(); }\n+            for _ in 0u..20 { thread::yield_now(); }\n         });\n \n         select! {\n@@ -451,8 +451,8 @@ mod test {\n         let (tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n \n-        let _t = Thread::spawn(move|| {\n-            for _ in 0u..20 { Thread::yield_now(); }\n+        let _t = thread::spawn(move|| {\n+            for _ in 0u..20 { thread::yield_now(); }\n             tx1.send(1).unwrap();\n             tx2.send(2).unwrap();\n             rx3.recv().unwrap();\n@@ -478,7 +478,7 @@ mod test {\n         let (tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             for i in 0..AMT {\n                 if i % 2 == 0 {\n                     tx1.send(i).unwrap();\n@@ -504,7 +504,7 @@ mod test {\n         let (_tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx3.recv().unwrap();\n             tx1.clone();\n             assert_eq!(rx3.try_recv(), Err(TryRecvError::Empty));\n@@ -526,7 +526,7 @@ mod test {\n         let (_tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx3.recv().unwrap();\n             tx1.clone();\n             assert_eq!(rx3.try_recv(), Err(TryRecvError::Empty));\n@@ -547,7 +547,7 @@ mod test {\n         let (tx1, rx1) = channel::<()>();\n         let (tx2, rx2) = channel::<()>();\n         let (tx3, rx3) = channel::<()>();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let s = Select::new();\n             let mut h1 = s.handle(&rx1);\n             let mut h2 = s.handle(&rx2);\n@@ -557,7 +557,7 @@ mod test {\n             tx3.send(()).unwrap();\n         });\n \n-        for _ in 0u..1000 { Thread::yield_now(); }\n+        for _ in 0u..1000 { thread::yield_now(); }\n         drop(tx1.clone());\n         tx2.send(()).unwrap();\n         rx3.recv().unwrap();\n@@ -663,14 +663,14 @@ mod test {\n     fn oneshot_data_waiting() {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             select! {\n                 _n = rx1.recv() => {}\n             }\n             tx2.send(()).unwrap();\n         });\n \n-        for _ in 0u..100 { Thread::yield_now() }\n+        for _ in 0u..100 { thread::yield_now() }\n         tx1.send(()).unwrap();\n         rx2.recv().unwrap();\n     }\n@@ -683,14 +683,14 @@ mod test {\n         tx1.send(()).unwrap();\n         rx1.recv().unwrap();\n         rx1.recv().unwrap();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             select! {\n                 _n = rx1.recv() => {}\n             }\n             tx2.send(()).unwrap();\n         });\n \n-        for _ in 0u..100 { Thread::yield_now() }\n+        for _ in 0u..100 { thread::yield_now() }\n         tx1.send(()).unwrap();\n         rx2.recv().unwrap();\n     }\n@@ -702,14 +702,14 @@ mod test {\n         drop(tx1.clone());\n         tx1.send(()).unwrap();\n         rx1.recv().unwrap();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             select! {\n                 _n = rx1.recv() => {}\n             }\n             tx2.send(()).unwrap();\n         });\n \n-        for _ in 0u..100 { Thread::yield_now() }\n+        for _ in 0u..100 { thread::yield_now() }\n         tx1.send(()).unwrap();\n         rx2.recv().unwrap();\n     }\n@@ -726,8 +726,8 @@ mod test {\n     #[test]\n     fn sync2() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        let _t = Thread::spawn(move|| {\n-            for _ in 0u..100 { Thread::yield_now() }\n+        let _t = thread::spawn(move|| {\n+            for _ in 0u..100 { thread::yield_now() }\n             tx.send(1).unwrap();\n         });\n         select! {\n@@ -739,8 +739,8 @@ mod test {\n     fn sync3() {\n         let (tx1, rx1) = sync_channel::<int>(0);\n         let (tx2, rx2): (Sender<int>, Receiver<int>) = channel();\n-        let _t = Thread::spawn(move|| { tx1.send(1).unwrap(); });\n-        let _t = Thread::spawn(move|| { tx2.send(2).unwrap(); });\n+        let _t = thread::spawn(move|| { tx1.send(1).unwrap(); });\n+        let _t = thread::spawn(move|| { tx2.send(2).unwrap(); });\n         select! {\n             n = rx1.recv() => {\n                 let n = n.unwrap();"}, {"sha": "bc9c73585c21fe86ff9ec4e5630191f6330289e9", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -31,7 +31,7 @@ use sync::mpsc::mpsc_queue as mpsc;\n use sync::mpsc::select::StartResult::*;\n use sync::mpsc::select::StartResult;\n use sync::{Mutex, MutexGuard};\n-use thread::Thread;\n+use thread;\n \n const DISCONNECTED: isize = isize::MIN;\n const FUDGE: isize = 1024;\n@@ -64,7 +64,7 @@ pub enum Failure {\n     Disconnected,\n }\n \n-impl<T: Send> Packet<T> {\n+impl<T: Send + 'static> Packet<T> {\n     // Creation of a packet *must* be followed by a call to postinit_lock\n     // and later by inherit_blocker\n     pub fn new() -> Packet<T> {\n@@ -194,7 +194,7 @@ impl<T: Send> Packet<T> {\n                             match self.queue.pop() {\n                                 mpsc::Data(..) => {}\n                                 mpsc::Empty => break,\n-                                mpsc::Inconsistent => Thread::yield_now(),\n+                                mpsc::Inconsistent => thread::yield_now(),\n                             }\n                         }\n                         // maybe we're done, if we're not the last ones\n@@ -283,7 +283,7 @@ impl<T: Send> Packet<T> {\n             mpsc::Inconsistent => {\n                 let data;\n                 loop {\n-                    Thread::yield_now();\n+                    thread::yield_now();\n                     match self.queue.pop() {\n                         mpsc::Data(t) => { data = t; break }\n                         mpsc::Empty => panic!(\"inconsistent => empty\"),\n@@ -460,7 +460,7 @@ impl<T: Send> Packet<T> {\n                 drop(self.take_to_wake());\n             } else {\n                 while self.to_wake.load(Ordering::SeqCst) != 0 {\n-                    Thread::yield_now();\n+                    thread::yield_now();\n                 }\n             }\n             // if the number of steals is -1, it was the pre-emptive -1 steal\n@@ -474,7 +474,7 @@ impl<T: Send> Packet<T> {\n }\n \n #[unsafe_destructor]\n-impl<T: Send> Drop for Packet<T> {\n+impl<T: Send + 'static> Drop for Packet<T> {\n     fn drop(&mut self) {\n         // Note that this load is not only an assert for correctness about\n         // disconnection, but also a proper fence before the read of"}, {"sha": "b8f835bde5191d79b6d0332d39d70c70c7c762c9", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -74,11 +74,11 @@ pub struct Queue<T> {\n     cache_subtractions: AtomicUsize,\n }\n \n-unsafe impl<T: Send> Send for Queue<T> { }\n+unsafe impl<T: Send + 'static> Send for Queue<T> { }\n \n-unsafe impl<T: Send> Sync for Queue<T> { }\n+unsafe impl<T: Send + 'static> Sync for Queue<T> { }\n \n-impl<T: Send> Node<T> {\n+impl<T: Send + 'static> Node<T> {\n     fn new() -> *mut Node<T> {\n         unsafe {\n             mem::transmute(box Node {\n@@ -89,7 +89,7 @@ impl<T: Send> Node<T> {\n     }\n }\n \n-impl<T: Send> Queue<T> {\n+impl<T: Send + 'static> Queue<T> {\n     /// Creates a new queue.\n     ///\n     /// This is unsafe as the type system doesn't enforce a single\n@@ -227,7 +227,7 @@ impl<T: Send> Queue<T> {\n }\n \n #[unsafe_destructor]\n-impl<T: Send> Drop for Queue<T> {\n+impl<T: Send + 'static> Drop for Queue<T> {\n     fn drop(&mut self) {\n         unsafe {\n             let mut cur = *self.first.get();\n@@ -246,7 +246,7 @@ mod test {\n \n     use sync::Arc;\n     use super::Queue;\n-    use thread::Thread;\n+    use thread;\n     use sync::mpsc::channel;\n \n     #[test]\n@@ -324,7 +324,7 @@ mod test {\n \n             let (tx, rx) = channel();\n             let q2 = q.clone();\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 for _ in 0u..100000 {\n                     loop {\n                         match q2.pop() {"}, {"sha": "a194c99669263e356e1ad1bf46f160a6c212f8cf", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -26,7 +26,7 @@ use core::prelude::*;\n \n use core::cmp;\n use core::isize;\n-use thread::Thread;\n+use thread;\n \n use sync::atomic::{AtomicIsize, AtomicUsize, Ordering, AtomicBool};\n use sync::mpsc::Receiver;\n@@ -74,7 +74,7 @@ enum Message<T> {\n     GoUp(Receiver<T>),\n }\n \n-impl<T: Send> Packet<T> {\n+impl<T: Send + 'static> Packet<T> {\n     pub fn new() -> Packet<T> {\n         Packet {\n             queue: unsafe { spsc::Queue::new(128) },\n@@ -440,7 +440,7 @@ impl<T: Send> Packet<T> {\n                 drop(self.take_to_wake());\n             } else {\n                 while self.to_wake.load(Ordering::SeqCst) != 0 {\n-                    Thread::yield_now();\n+                    thread::yield_now();\n                 }\n             }\n             assert_eq!(self.steals, 0);\n@@ -472,7 +472,7 @@ impl<T: Send> Packet<T> {\n }\n \n #[unsafe_destructor]\n-impl<T: Send> Drop for Packet<T> {\n+impl<T: Send + 'static> Drop for Packet<T> {\n     fn drop(&mut self) {\n         // Note that this load is not only an assert for correctness about\n         // disconnection, but also a proper fence before the read of"}, {"sha": "ae96a2491dc267ee06066c369ee6cfb838e3c204", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -55,9 +55,9 @@ pub struct Packet<T> {\n     lock: Mutex<State<T>>,\n }\n \n-unsafe impl<T:Send> Send for Packet<T> { }\n+unsafe impl<T: Send + 'static> Send for Packet<T> { }\n \n-unsafe impl<T:Send> Sync for Packet<T> { }\n+unsafe impl<T: Send + 'static> Sync for Packet<T> { }\n \n struct State<T> {\n     disconnected: bool, // Is the channel disconnected yet?\n@@ -75,7 +75,7 @@ struct State<T> {\n     canceled: Option<&'static mut bool>,\n }\n \n-unsafe impl<T: Send> Send for State<T> {}\n+unsafe impl<T: Send + 'static> Send for State<T> {}\n \n /// Possible flavors of threads who can be blocked on this channel.\n enum Blocker {\n@@ -113,7 +113,7 @@ pub enum Failure {\n \n /// Atomically blocks the current thread, placing it into `slot`, unlocking `lock`\n /// in the meantime. This re-locks the mutex upon returning.\n-fn wait<'a, 'b, T: Send>(lock: &'a Mutex<State<T>>,\n+fn wait<'a, 'b, T: Send + 'static>(lock: &'a Mutex<State<T>>,\n                          mut guard: MutexGuard<'b, State<T>>,\n                          f: fn(SignalToken) -> Blocker)\n                          -> MutexGuard<'a, State<T>>\n@@ -136,7 +136,7 @@ fn wakeup<T>(token: SignalToken, guard: MutexGuard<State<T>>) {\n     token.signal();\n }\n \n-impl<T: Send> Packet<T> {\n+impl<T: Send + 'static> Packet<T> {\n     pub fn new(cap: uint) -> Packet<T> {\n         Packet {\n             channels: AtomicUsize::new(1),\n@@ -412,7 +412,7 @@ impl<T: Send> Packet<T> {\n }\n \n #[unsafe_destructor]\n-impl<T: Send> Drop for Packet<T> {\n+impl<T: Send + 'static> Drop for Packet<T> {\n     fn drop(&mut self) {\n         assert_eq!(self.channels.load(Ordering::SeqCst), 0);\n         let mut guard = self.lock.lock().unwrap();"}, {"sha": "65cae90857e44f3b1a4c50480e122ba084c00bb9", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -47,7 +47,7 @@ use sys_common::mutex as sys;\n ///\n /// ```rust\n /// use std::sync::{Arc, Mutex};\n-/// use std::thread::Thread;\n+/// use std::thread;\n /// use std::sync::mpsc::channel;\n ///\n /// const N: uint = 10;\n@@ -62,7 +62,7 @@ use sys_common::mutex as sys;\n /// let (tx, rx) = channel();\n /// for _ in 0u..10 {\n ///     let (data, tx) = (data.clone(), tx.clone());\n-///     Thread::spawn(move || {\n+///     thread::spawn(move || {\n ///         // The shared static can only be accessed once the lock is held.\n ///         // Our non-atomic increment is safe because we're the only thread\n ///         // which can access the shared state when the lock is held.\n@@ -85,12 +85,12 @@ use sys_common::mutex as sys;\n ///\n /// ```rust\n /// use std::sync::{Arc, Mutex};\n-/// use std::thread::Thread;\n+/// use std::thread;\n ///\n /// let lock = Arc::new(Mutex::new(0u));\n /// let lock2 = lock.clone();\n ///\n-/// let _ = Thread::scoped(move || -> () {\n+/// let _ = thread::spawn(move || -> () {\n ///     // This thread will acquire the mutex first, unwrapping the result of\n ///     // `lock` because the lock has not been poisoned.\n ///     let _lock = lock2.lock().unwrap();\n@@ -120,9 +120,9 @@ pub struct Mutex<T> {\n     data: UnsafeCell<T>,\n }\n \n-unsafe impl<T:Send> Send for Mutex<T> { }\n+unsafe impl<T: Send + 'static> Send for Mutex<T> { }\n \n-unsafe impl<T:Send> Sync for Mutex<T> { }\n+unsafe impl<T: Send + 'static> Sync for Mutex<T> { }\n \n /// The static mutex type is provided to allow for static allocation of mutexes.\n ///\n@@ -180,7 +180,7 @@ pub const MUTEX_INIT: StaticMutex = StaticMutex {\n     poison: poison::FLAG_INIT,\n };\n \n-impl<T: Send> Mutex<T> {\n+impl<T: Send + 'static> Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> Mutex<T> {\n@@ -243,7 +243,7 @@ impl<T: Send> Mutex<T> {\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send> Drop for Mutex<T> {\n+impl<T: Send + 'static> Drop for Mutex<T> {\n     fn drop(&mut self) {\n         // This is actually safe b/c we know that there is no further usage of\n         // this mutex (it's up to the user to arrange for a mutex to get\n@@ -350,7 +350,7 @@ mod test {\n \n     use sync::mpsc::channel;\n     use sync::{Arc, Mutex, StaticMutex, MUTEX_INIT, Condvar};\n-    use thread::Thread;\n+    use thread;\n \n     struct Packet<T>(Arc<(Mutex<T>, Condvar)>);\n \n@@ -393,9 +393,9 @@ mod test {\n         let (tx, rx) = channel();\n         for _ in 0..K {\n             let tx2 = tx.clone();\n-            Thread::spawn(move|| { inc(); tx2.send(()).unwrap(); });\n+            thread::spawn(move|| { inc(); tx2.send(()).unwrap(); });\n             let tx2 = tx.clone();\n-            Thread::spawn(move|| { inc(); tx2.send(()).unwrap(); });\n+            thread::spawn(move|| { inc(); tx2.send(()).unwrap(); });\n         }\n \n         drop(tx);\n@@ -419,7 +419,7 @@ mod test {\n         let packet = Packet(Arc::new((Mutex::new(false), Condvar::new())));\n         let packet2 = Packet(packet.0.clone());\n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             // wait until parent gets in\n             rx.recv().unwrap();\n             let &(ref lock, ref cvar) = &*packet2.0;\n@@ -443,7 +443,7 @@ mod test {\n         let packet2 = Packet(packet.0.clone());\n         let (tx, rx) = channel();\n \n-        let _t = Thread::spawn(move || -> () {\n+        let _t = thread::spawn(move || -> () {\n             rx.recv().unwrap();\n             let &(ref lock, ref cvar) = &*packet2.0;\n             let _g = lock.lock().unwrap();\n@@ -471,7 +471,7 @@ mod test {\n         let arc = Arc::new(Mutex::new(1));\n         assert!(!arc.is_poisoned());\n         let arc2 = arc.clone();\n-        let _ = Thread::scoped(move|| {\n+        let _ = thread::spawn(move|| {\n             let lock = arc2.lock().unwrap();\n             assert_eq!(*lock, 2);\n         }).join();\n@@ -486,7 +486,7 @@ mod test {\n         let arc = Arc::new(Mutex::new(1));\n         let arc2 = Arc::new(Mutex::new(arc));\n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let lock = arc2.lock().unwrap();\n             let lock2 = lock.lock().unwrap();\n             assert_eq!(*lock2, 1);\n@@ -499,7 +499,7 @@ mod test {\n     fn test_mutex_arc_access_in_unwind() {\n         let arc = Arc::new(Mutex::new(1));\n         let arc2 = arc.clone();\n-        let _ = Thread::scoped(move|| -> () {\n+        let _ = thread::spawn(move|| -> () {\n             struct Unwinder {\n                 i: Arc<Mutex<int>>,\n             }"}, {"sha": "1e87c0d612bdcc5561eb8cf79cdf8709662be3c7", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -127,7 +127,7 @@ impl Once {\n mod test {\n     use prelude::v1::*;\n \n-    use thread::Thread;\n+    use thread;\n     use super::{ONCE_INIT, Once};\n     use sync::mpsc::channel;\n \n@@ -149,8 +149,8 @@ mod test {\n         let (tx, rx) = channel();\n         for _ in 0u..10 {\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n-                for _ in 0u..4 { Thread::yield_now() }\n+            thread::spawn(move|| {\n+                for _ in 0u..4 { thread::yield_now() }\n                 unsafe {\n                     O.call_once(|| {\n                         assert!(!run);"}, {"sha": "32c8150ba4070172473cfe7d7602dca56a8c09de", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -13,15 +13,15 @@ use prelude::v1::*;\n use cell::UnsafeCell;\n use error::{Error, FromError};\n use fmt;\n-use thread::Thread;\n+use thread;\n \n pub struct Flag { failed: UnsafeCell<bool> }\n pub const FLAG_INIT: Flag = Flag { failed: UnsafeCell { value: false } };\n \n impl Flag {\n     #[inline]\n     pub fn borrow(&self) -> LockResult<Guard> {\n-        let ret = Guard { panicking: Thread::panicking() };\n+        let ret = Guard { panicking: thread::panicking() };\n         if unsafe { *self.failed.get() } {\n             Err(PoisonError::new(ret))\n         } else {\n@@ -31,7 +31,7 @@ impl Flag {\n \n     #[inline]\n     pub fn done(&self, guard: &Guard) {\n-        if !guard.panicking && Thread::panicking() {\n+        if !guard.panicking && thread::panicking() {\n             unsafe { *self.failed.get() = true; }\n         }\n     }"}, {"sha": "b8d157d341e031e7b353d6a34207543baa018315", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -400,7 +400,7 @@ mod tests {\n \n     use rand::{self, Rng};\n     use sync::mpsc::channel;\n-    use thread::Thread;\n+    use thread;\n     use sync::{Arc, RwLock, StaticRwLock, RW_LOCK_INIT};\n \n     #[test]\n@@ -425,13 +425,13 @@ mod tests {\n     #[test]\n     fn frob() {\n         static R: StaticRwLock = RW_LOCK_INIT;\n-        static N: uint = 10;\n-        static M: uint = 1000;\n+        static N: usize = 10;\n+        static M: usize = 1000;\n \n         let (tx, rx) = channel::<()>();\n         for _ in 0..N {\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 let mut rng = rand::thread_rng();\n                 for _ in 0..M {\n                     if rng.gen_weighted_bool(N) {\n@@ -452,7 +452,7 @@ mod tests {\n     fn test_rw_arc_poison_wr() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _: Result<uint, _> = Thread::scoped(move|| {\n+        let _: Result<(), _> = thread::spawn(move|| {\n             let _lock = arc2.write().unwrap();\n             panic!();\n         }).join();\n@@ -464,7 +464,7 @@ mod tests {\n         let arc = Arc::new(RwLock::new(1));\n         assert!(!arc.is_poisoned());\n         let arc2 = arc.clone();\n-        let _: Result<uint, _> = Thread::scoped(move|| {\n+        let _: Result<(), _> = thread::spawn(move|| {\n             let _lock = arc2.write().unwrap();\n             panic!();\n         }).join();\n@@ -476,7 +476,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rr() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _: Result<uint, _> = Thread::scoped(move|| {\n+        let _: Result<(), _> = thread::spawn(move|| {\n             let _lock = arc2.read().unwrap();\n             panic!();\n         }).join();\n@@ -487,7 +487,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rw() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _: Result<uint, _> = Thread::scoped(move|| {\n+        let _: Result<(), _> = thread::spawn(move|| {\n             let _lock = arc2.read().unwrap();\n             panic!()\n         }).join();\n@@ -501,12 +501,12 @@ mod tests {\n         let arc2 = arc.clone();\n         let (tx, rx) = channel();\n \n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut lock = arc2.write().unwrap();\n             for _ in 0u..10 {\n                 let tmp = *lock;\n                 *lock = -1;\n-                Thread::yield_now();\n+                thread::yield_now();\n                 *lock = tmp + 1;\n             }\n             tx.send(()).unwrap();\n@@ -516,7 +516,7 @@ mod tests {\n         let mut children = Vec::new();\n         for _ in 0u..5 {\n             let arc3 = arc.clone();\n-            children.push(Thread::scoped(move|| {\n+            children.push(thread::spawn(move|| {\n                 let lock = arc3.read().unwrap();\n                 assert!(*lock >= 0);\n             }));\n@@ -537,7 +537,7 @@ mod tests {\n     fn test_rw_arc_access_in_unwind() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _ = Thread::scoped(move|| -> () {\n+        let _ = thread::spawn(move|| -> () {\n             struct Unwinder {\n                 i: Arc<RwLock<int>>,\n             }"}, {"sha": "410e1c11bb9a992387af0b8fa0562b7eb6e65e56", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -114,7 +114,7 @@ mod tests {\n     use sync::Arc;\n     use super::Semaphore;\n     use sync::mpsc::channel;\n-    use thread::Thread;\n+    use thread;\n \n     #[test]\n     fn test_sem_acquire_release() {\n@@ -134,7 +134,7 @@ mod tests {\n     fn test_sem_as_mutex() {\n         let s = Arc::new(Semaphore::new(1));\n         let s2 = s.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _g = s2.access();\n         });\n         let _g = s.access();\n@@ -146,7 +146,7 @@ mod tests {\n         let (tx, rx) = channel();\n         let s = Arc::new(Semaphore::new(0));\n         let s2 = s.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             s2.acquire();\n             tx.send(()).unwrap();\n         });\n@@ -157,7 +157,7 @@ mod tests {\n         let (tx, rx) = channel();\n         let s = Arc::new(Semaphore::new(0));\n         let s2 = s.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             s2.release();\n             let _ = rx.recv();\n         });\n@@ -173,7 +173,7 @@ mod tests {\n         let s2 = s.clone();\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _g = s2.access();\n             let _ = rx2.recv();\n             tx1.send(()).unwrap();\n@@ -190,7 +190,7 @@ mod tests {\n         let (tx, rx) = channel();\n         {\n             let _g = s.access();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 tx.send(()).unwrap();\n                 drop(s2.access());\n                 tx.send(()).unwrap();"}, {"sha": "f4274dd91cc7a27eef8fa80b89e6b2392f942a45", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -20,16 +20,16 @@ use core::prelude::*;\n \n use sync::{Arc, Mutex};\n use sync::mpsc::{channel, Sender, Receiver};\n-use thread::Thread;\n+use thread;\n use thunk::Thunk;\n \n struct Sentinel<'a> {\n-    jobs: &'a Arc<Mutex<Receiver<Thunk>>>,\n+    jobs: &'a Arc<Mutex<Receiver<Thunk<'static>>>>,\n     active: bool\n }\n \n impl<'a> Sentinel<'a> {\n-    fn new(jobs: &Arc<Mutex<Receiver<Thunk>>>) -> Sentinel {\n+    fn new(jobs: &'a Arc<Mutex<Receiver<Thunk<'static>>>>) -> Sentinel<'a> {\n         Sentinel {\n             jobs: jobs,\n             active: true\n@@ -80,7 +80,7 @@ pub struct TaskPool {\n     //\n     // This is the only such Sender, so when it is dropped all subthreads will\n     // quit.\n-    jobs: Sender<Thunk>\n+    jobs: Sender<Thunk<'static>>\n }\n \n impl TaskPool {\n@@ -105,14 +105,14 @@ impl TaskPool {\n \n     /// Executes the function `job` on a thread in the pool.\n     pub fn execute<F>(&self, job: F)\n-        where F : FnOnce(), F : Send\n+        where F : FnOnce(), F : Send + 'static\n     {\n         self.jobs.send(Thunk::new(job)).unwrap();\n     }\n }\n \n-fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk>>>) {\n-    Thread::spawn(move || {\n+fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk<'static>>>>) {\n+    thread::spawn(move || {\n         // Will spawn a new thread on panic unless it is cancelled.\n         let sentinel = Sentinel::new(&jobs);\n "}, {"sha": "dc1ae85efe03395660f9e63fd82b0a398e5a969e", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -30,7 +30,7 @@ use sync::{StaticMutex, StaticCondvar};\n use sync::mpsc::{channel, Sender, Receiver};\n use sys::helper_signal;\n \n-use thread::Thread;\n+use thread;\n \n /// A structure for management of a helper thread.\n ///\n@@ -81,7 +81,7 @@ impl<M: Send> Helper<M> {\n     ///\n     /// This function is safe to be called many times.\n     pub fn boot<T, F>(&'static self, f: F, helper: fn(helper_signal::signal, Receiver<M>, T)) where\n-        T: Send,\n+        T: Send + 'static,\n         F: FnOnce() -> T,\n     {\n         unsafe {\n@@ -95,7 +95,7 @@ impl<M: Send> Helper<M> {\n                 let receive = RaceBox(receive);\n \n                 let t = f();\n-                Thread::spawn(move || {\n+                thread::spawn(move || {\n                     helper(receive.0, rx, t);\n                     let _g = self.lock.lock().unwrap();\n                     *self.shutdown.get() = true;"}, {"sha": "65c706033f213034c2923f4a78b1c8ce859fe16e", "filename": "src/libstd/sys/common/thread_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -29,7 +29,7 @@ thread_local! { static THREAD_INFO: RefCell<Option<ThreadInfo>> = RefCell::new(N\n impl ThreadInfo {\n     fn with<R, F>(f: F) -> R where F: FnOnce(&mut ThreadInfo) -> R {\n         if THREAD_INFO.state() == State::Destroyed {\n-            panic!(\"Use of std::thread::Thread::current() is not possible after \\\n+            panic!(\"Use of std::thread::current() is not possible after \\\n                     the thread's local data has been destroyed\");\n         }\n \n@@ -63,7 +63,7 @@ pub fn set(stack_bounds: (uint, uint), stack_guard: uint, thread: Thread) {\n     }));\n }\n \n-// a hack to get around privacy restrictions; implemented by `std::thread::Thread`\n+// a hack to get around privacy restrictions; implemented by `std::thread`\n pub trait NewThread {\n     fn new(name: Option<String>) -> Self;\n }"}, {"sha": "27b8784e3943a6a46320fbddc45c6ee8066d88da", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -24,7 +24,7 @@\n //! # Usage\n //!\n //! This module should likely not be used directly unless other primitives are\n-//! being built on. types such as `thread_local::scoped::Key` are likely much\n+//! being built on. types such as `thread_local::spawn::Key` are likely much\n //! more useful in practice than this OS-based version which likely requires\n //! unsafe code to interoperate with.\n //!"}, {"sha": "b610f6c370bb3bcfcc99db2c47e99180f538cc8c", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -817,7 +817,9 @@ impl<'a, S: Writer + Hasher> Hash<S> for Wtf8 {\n     }\n }\n \n-impl AsciiExt<Wtf8Buf> for Wtf8 {\n+impl AsciiExt for Wtf8 {\n+    type Owned = Wtf8Buf;\n+\n     fn is_ascii(&self) -> bool {\n         self.bytes.is_ascii()\n     }\n@@ -830,6 +832,9 @@ impl AsciiExt<Wtf8Buf> for Wtf8 {\n     fn eq_ignore_ascii_case(&self, other: &Wtf8) -> bool {\n         self.bytes.eq_ignore_ascii_case(&other.bytes)\n     }\n+\n+    fn make_ascii_uppercase(&mut self) { self.bytes.make_ascii_uppercase() }\n+    fn make_ascii_lowercase(&mut self) { self.bytes.make_ascii_lowercase() }\n }\n \n #[cfg(test)]"}, {"sha": "df03841276e9e483cf22444cd9e6cc4f1559f1f2", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -247,6 +247,10 @@ impl Iterator for Args {\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n+impl ExactSizeIterator for Args {\n+    fn len(&self) -> usize { self.iter.len() }\n+}\n+\n /// Returns the command line arguments\n ///\n /// Returns a list of the command line arguments."}, {"sha": "82c52471d109719ef99d0e5aab5a6fa4103a434f", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use io;\n use boxed::Box;\n use cmp;\n use mem;\n@@ -191,7 +192,7 @@ pub mod guard {\n     }\n }\n \n-pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n+pub unsafe fn create(stack: uint, p: Thunk) -> io::Result<rust_thread> {\n     let mut native: libc::pthread_t = mem::zeroed();\n     let mut attr: libc::pthread_attr_t = mem::zeroed();\n     assert_eq!(pthread_attr_init(&mut attr), 0);\n@@ -226,9 +227,10 @@ pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n     if ret != 0 {\n         // be sure to not leak the closure\n         let _p: Box<Box<FnOnce()+Send>> = mem::transmute(arg);\n-        panic!(\"failed to spawn native thread: {}\", ret);\n+        Err(io::Error::from_os_error(ret))\n+    } else {\n+        Ok(native)\n     }\n-    native\n }\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]"}, {"sha": "502d70d4e1a16f297464b5f08b09eb202fc5dd19", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -18,7 +18,7 @@ use os::windows::*;\n use error::Error as StdError;\n use ffi::{OsString, OsStr, AsOsStr};\n use fmt;\n-use iter::Range;\n+use ops::Range;\n use libc::types::os::arch::extra::LPWCH;\n use libc::{self, c_int, c_void};\n use mem;\n@@ -303,6 +303,10 @@ impl Iterator for Args {\n     fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n }\n \n+impl ExactSizeIterator for Args {\n+    fn len(&self) -> usize { self.range.len() }\n+}\n+\n impl Drop for Args {\n     fn drop(&mut self) {\n         unsafe { c::LocalFree(self.cur as *mut c_void); }\n@@ -315,7 +319,7 @@ pub fn args() -> Args {\n         let lpCmdLine = c::GetCommandLineW();\n         let szArgList = c::CommandLineToArgvW(lpCmdLine, &mut nArgs);\n \n-        Args { cur: szArgList, range: range(0, nArgs as isize) }\n+        Args { cur: szArgList, range: 0..(nArgs as isize) }\n     }\n }\n "}, {"sha": "f3a27877e5c58512fc8c6dce9dc08749141f12d5", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use boxed::Box;\n+use prelude::v1::*;\n+\n use cmp;\n+use io;\n use mem;\n use ptr;\n use libc;\n@@ -42,7 +44,7 @@ pub mod guard {\n     }\n }\n \n-pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n+pub unsafe fn create(stack: uint, p: Thunk) -> io::Result<rust_thread> {\n     let arg: *mut libc::c_void = mem::transmute(box p);\n     // FIXME On UNIX, we guard against stack sizes that are too small but\n     // that's because pthreads enforces that stacks are at least\n@@ -60,9 +62,10 @@ pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n     if ret as uint == 0 {\n         // be sure to not leak the closure\n         let _p: Box<Thunk> = mem::transmute(arg);\n-        panic!(\"failed to spawn native thread: {:?}\", ret);\n+        Err(io::Error::last_os_error())\n+    } else {\n+        Ok(ret)\n     }\n-    return ret;\n }\n \n pub unsafe fn set_name(_name: &str) {"}, {"sha": "3137d779c4071c24cee2bfe723f79de99713b3f4", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 343, "deletions": 168, "changes": 511, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -42,32 +42,32 @@\n //! Already-running threads are represented via the `Thread` type, which you can\n //! get in one of two ways:\n //!\n-//! * By spawning a new thread, e.g. using the `Thread::spawn` constructor;\n-//! * By requesting the current thread, using the `Thread::current` function.\n+//! * By spawning a new thread, e.g. using the `thread::spawn` constructor;\n+//! * By requesting the current thread, using the `thread::current` function.\n //!\n //! Threads can be named, and provide some built-in support for low-level\n //! synchronization described below.\n //!\n-//! The `Thread::current()` function is available even for threads not spawned\n+//! The `thread::current()` function is available even for threads not spawned\n //! by the APIs of this module.\n //!\n //! ## Spawning a thread\n //!\n-//! A new thread can be spawned using the `Thread::spawn` function:\n+//! A new thread can be spawned using the `thread::spawn` function:\n //!\n //! ```rust\n-//! use std::thread::Thread;\n+//! use std::thread;\n //!\n-//! let thread = Thread::spawn(move || {\n+//! thread::spawn(move || {\n //!     println!(\"Hello, World!\");\n //!     // some computation here\n //! });\n //! ```\n //!\n-//! The spawned thread is \"detached\" from the current thread, meaning that it\n-//! can outlive the thread that spawned it. (Note, however, that when the main\n-//! thread terminates all detached threads are terminated as well.) The returned\n-//! `Thread` handle can be used for low-level synchronization as described below.\n+//! In this example, the spawned thread is \"detached\" from the current\n+//! thread, meaning that it can outlive the thread that spawned\n+//! it. (Note, however, that when the main thread terminates all\n+//! detached threads are terminated as well.)\n //!\n //! ## Scoped threads\n //!\n@@ -76,23 +76,23 @@\n //! For this scenario, use the `scoped` constructor:\n //!\n //! ```rust\n-//! use std::thread::Thread;\n+//! use std::thread;\n //!\n-//! let guard = Thread::scoped(move || {\n+//! let guard = thread::scoped(move || {\n //!     println!(\"Hello, World!\");\n //!     // some computation here\n //! });\n //! // do some other work in the meantime\n-//! let result = guard.join();\n+//! let output = guard.join();\n //! ```\n //!\n-//! The `scoped` function doesn't return a `Thread` directly; instead, it\n-//! returns a *join guard* from which a `Thread` can be extracted. The join\n-//! guard is an RAII-style guard that will automatically join the child thread\n-//! (block until it terminates) when it is dropped. You can join the child\n-//! thread in advance by calling the `join` method on the guard, which will also\n-//! return the result produced by the thread.  A handle to the thread itself is\n-//! available via the `thread` method on the join guard.\n+//! The `scoped` function doesn't return a `Thread` directly; instead,\n+//! it returns a *join guard*. The join guard is an RAII-style guard\n+//! that will automatically join the child thread (block until it\n+//! terminates) when it is dropped. You can join the child thread in\n+//! advance by calling the `join` method on the guard, which will also\n+//! return the result produced by the thread.  A handle to the thread\n+//! itself is available via the `thread` method on the join guard.\n //!\n //! (Note: eventually, the `scoped` constructor will allow the parent and child\n //! threads to data that lives on the parent thread's stack, but some language\n@@ -120,10 +120,10 @@\n //! Conceptually, each `Thread` handle has an associated token, which is\n //! initially not present:\n //!\n-//! * The `Thread::park()` function blocks the current thread unless or until\n+//! * The `thread::park()` function blocks the current thread unless or until\n //!   the token is available for its thread handle, at which point It atomically\n //!   consumes the token. It may also return *spuriously*, without consuming the\n-//!   token. `Thread::park_timeout()` does the same, but allows specifying a\n+//!   token. `thread::park_timeout()` does the same, but allows specifying a\n //!   maximum time to block the thread for.\n //!\n //! * The `unpark()` method on a `Thread` atomically makes the token available\n@@ -147,19 +147,16 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use prelude::v1::*;\n+\n use any::Any;\n-use boxed::Box;\n use cell::UnsafeCell;\n-use clone::Clone;\n-use marker::{Send, Sync};\n-use ops::{Drop, FnOnce};\n-use option::Option::{self, Some, None};\n-use result::Result::{Err, Ok};\n-use sync::{Mutex, Condvar, Arc};\n-use str::Str;\n-use string::String;\n+use fmt;\n+use io;\n+use marker;\n+use old_io::stdio;\n use rt::{self, unwind};\n-use old_io::{Writer, stdio};\n+use sync::{Mutex, Condvar, Arc};\n use thunk::Thunk;\n use time::Duration;\n \n@@ -175,9 +172,9 @@ pub struct Builder {\n     // The size of the stack for the spawned thread\n     stack_size: Option<uint>,\n     // Thread-local stdout\n-    stdout: Option<Box<Writer + Send>>,\n+    stdout: Option<Box<Writer + Send + 'static>>,\n     // Thread-local stderr\n-    stderr: Option<Box<Writer + Send>>,\n+    stderr: Option<Box<Writer + Send + 'static>>,\n }\n \n impl Builder {\n@@ -211,62 +208,73 @@ impl Builder {\n     /// Redirect thread-local stdout.\n     #[unstable(feature = \"std_misc\",\n                reason = \"Will likely go away after proc removal\")]\n-    pub fn stdout(mut self, stdout: Box<Writer + Send>) -> Builder {\n+    pub fn stdout(mut self, stdout: Box<Writer + Send + 'static>) -> Builder {\n         self.stdout = Some(stdout);\n         self\n     }\n \n     /// Redirect thread-local stderr.\n     #[unstable(feature = \"std_misc\",\n                reason = \"Will likely go away after proc removal\")]\n-    pub fn stderr(mut self, stderr: Box<Writer + Send>) -> Builder {\n+    pub fn stderr(mut self, stderr: Box<Writer + Send + 'static>) -> Builder {\n         self.stderr = Some(stderr);\n         self\n     }\n \n-    /// Spawn a new detached thread, and return a handle to it.\n+    /// Spawn a new thread, and return a join handle for it.\n     ///\n-    /// See `Thead::spawn` and the module doc for more details.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"may change with specifics of new Send semantics\")]\n-    pub fn spawn<F>(self, f: F) -> Thread where F: FnOnce(), F: Send + 'static {\n-        let (native, thread) = self.spawn_inner(Thunk::new(f), Thunk::with_arg(|_| {}));\n-        unsafe { imp::detach(native) };\n-        thread\n+    /// The child thread may outlive the parent (unless the parent thread\n+    /// is the main thread; the whole process is terminated when the main\n+    /// thread finishes.) The join handle can be used to block on\n+    /// termination of the child thread, including recovering its panics.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Unlike the `spawn` free function, this method yields an\n+    /// `io::Result` to capture any failure to create the thread at\n+    /// the OS level.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn spawn<F>(self, f: F) -> io::Result<JoinHandle> where\n+        F: FnOnce(), F: Send + 'static\n+    {\n+        self.spawn_inner(Thunk::new(f)).map(|i| JoinHandle(i))\n     }\n \n     /// Spawn a new child thread that must be joined within a given\n     /// scope, and return a `JoinGuard`.\n     ///\n-    /// See `Thead::scoped` and the module doc for more details.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"may change with specifics of new Send semantics\")]\n-    pub fn scoped<'a, T, F>(self, f: F) -> JoinGuard<'a, T> where\n+    /// The join guard can be used to explicitly join the child thread (via\n+    /// `join`), returning `Result<T>`, or it will implicitly join the child\n+    /// upon being dropped. Because the child thread may refer to data on the\n+    /// current thread's stack (hence the \"scoped\" name), it cannot be detached;\n+    /// it *must* be joined before the relevant stack frame is popped. See the\n+    /// module documentation for additional details.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Unlike the `scoped` free function, this method yields an\n+    /// `io::Result` to capture any failure to create the thread at\n+    /// the OS level.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn scoped<'a, T, F>(self, f: F) -> io::Result<JoinGuard<'a, T>> where\n         T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n     {\n-        let my_packet = Packet(Arc::new(UnsafeCell::new(None)));\n-        let their_packet = Packet(my_packet.0.clone());\n-        let (native, thread) = self.spawn_inner(Thunk::new(f), Thunk::with_arg(move |ret| unsafe {\n-            *their_packet.0.get() = Some(ret);\n-        }));\n-\n-        JoinGuard {\n-            native: native,\n-            joined: false,\n-            packet: my_packet,\n-            thread: thread,\n-        }\n+        self.spawn_inner(Thunk::new(f)).map(|inner| {\n+            JoinGuard { inner: inner, _marker: marker::CovariantType }\n+        })\n     }\n \n-    fn spawn_inner<T: Send>(self, f: Thunk<(), T>, finish: Thunk<Result<T>, ()>)\n-                      -> (imp::rust_thread, Thread)\n-    {\n+    fn spawn_inner<T: Send>(self, f: Thunk<(), T>) -> io::Result<JoinInner<T>> {\n         let Builder { name, stack_size, stdout, stderr } = self;\n \n         let stack_size = stack_size.unwrap_or(rt::min_stack());\n+\n         let my_thread = Thread::new(name);\n         let their_thread = my_thread.clone();\n \n+        let my_packet = Packet(Arc::new(UnsafeCell::new(None)));\n+        let their_packet = Packet(my_packet.0.clone());\n+\n         // Spawning a new OS thread guarantees that __morestack will never get\n         // triggered, but we must manually set up the actual stack bounds once\n         // this function starts executing. This raises the lower limit by a bit\n@@ -316,17 +324,120 @@ impl Builder {\n                     unwind::try(move || *ptr = Some(f.invoke(())))\n                 }\n             };\n-            finish.invoke(match (output, try_result) {\n-                (Some(data), Ok(_)) => Ok(data),\n-                (None, Err(cause)) => Err(cause),\n-                _ => unreachable!()\n-            });\n+            unsafe {\n+                *their_packet.0.get() = Some(match (output, try_result) {\n+                    (Some(data), Ok(_)) => Ok(data),\n+                    (None, Err(cause)) => Err(cause),\n+                    _ => unreachable!()\n+                });\n+            }\n         };\n \n-        (unsafe { imp::create(stack_size, Thunk::new(main)) }, my_thread)\n+        Ok(JoinInner {\n+            native: try!(unsafe { imp::create(stack_size, Thunk::new(main)) }),\n+            thread: my_thread,\n+            packet: my_packet,\n+            joined: false,\n+        })\n+    }\n+}\n+\n+/// Spawn a new, returning a join handle for it.\n+///\n+/// The child thread may outlive the parent (unless the parent thread\n+/// is the main thread; the whole process is terminated when the main\n+/// thread finishes.) The join handle can be used to block on\n+/// termination of the child thread, including recovering its panics.\n+///\n+/// # Panics\n+///\n+/// Panicks if the OS fails to create a thread; use `Builder::spawn`\n+/// to recover from such errors.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn spawn<F>(f: F) -> JoinHandle where F: FnOnce(), F: Send + 'static {\n+    Builder::new().spawn(f).unwrap()\n+}\n+\n+/// Spawn a new *scoped* thread, returning a `JoinGuard` for it.\n+///\n+/// The join guard can be used to explicitly join the child thread (via\n+/// `join`), returning `Result<T>`, or it will implicitly join the child\n+/// upon being dropped. Because the child thread may refer to data on the\n+/// current thread's stack (hence the \"scoped\" name), it cannot be detached;\n+/// it *must* be joined before the relevant stack frame is popped. See the\n+/// module documentation for additional details.\n+///\n+/// # Panics\n+///\n+/// Panicks if the OS fails to create a thread; use `Builder::scoped`\n+/// to recover from such errors.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn scoped<'a, T, F>(f: F) -> JoinGuard<'a, T> where\n+    T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n+{\n+    Builder::new().scoped(f).unwrap()\n+}\n+\n+/// Gets a handle to the thread that invokes it.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn current() -> Thread {\n+    thread_info::current_thread()\n+}\n+\n+/// Cooperatively give up a timeslice to the OS scheduler.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn yield_now() {\n+    unsafe { imp::yield_now() }\n+}\n+\n+/// Determines whether the current thread is unwinding because of panic.\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn panicking() -> bool {\n+    unwind::panicking()\n+}\n+\n+/// Block unless or until the current thread's token is made available (may wake spuriously).\n+///\n+/// See the module doc for more detail.\n+//\n+// The implementation currently uses the trivial strategy of a Mutex+Condvar\n+// with wakeup flag, which does not actually allow spurious wakeups. In the\n+// future, this will be implemented in a more efficient way, perhaps along the lines of\n+//   http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n+// or futuxes, and in either case may allow spurious wakeups.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn park() {\n+    let thread = current();\n+    let mut guard = thread.inner.lock.lock().unwrap();\n+    while !*guard {\n+        guard = thread.inner.cvar.wait(guard).unwrap();\n     }\n+    *guard = false;\n+}\n+\n+/// Block unless or until the current thread's token is made available or\n+/// the specified duration has been reached (may wake spuriously).\n+///\n+/// The semantics of this function are equivalent to `park()` except that the\n+/// thread will be blocked for roughly no longer than dur. This method\n+/// should not be used for precise timing due to anomalies such as\n+/// preemption or platform differences that may not cause the maximum\n+/// amount of time waited to be precisely dur\n+///\n+/// See the module doc for more detail.\n+#[unstable(feature = \"std_misc\", reason = \"recently introduced, depends on Duration\")]\n+pub fn park_timeout(dur: Duration) {\n+    let thread = current();\n+    let mut guard = thread.inner.lock.lock().unwrap();\n+    if !*guard {\n+        let (g, _) = thread.inner.cvar.wait_timeout(guard, dur).unwrap();\n+        guard = g;\n+    }\n+    *guard = false;\n }\n \n+/// The internal representation of a `Thread` handle\n struct Inner {\n     name: Option<String>,\n     lock: Mutex<bool>,          // true when there is a buffered unpark\n@@ -354,85 +465,63 @@ impl Thread {\n         }\n     }\n \n-    /// Spawn a new detached thread, returning a handle to it.\n-    ///\n-    /// The child thread may outlive the parent (unless the parent thread is the\n-    /// main thread; the whole process is terminated when the main thread\n-    /// finishes.) The thread handle can be used for low-level\n-    /// synchronization. See the module documentation for additional details.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[unstable(feature = \"std_misc\",\n                reason = \"may change with specifics of new Send semantics\")]\n     pub fn spawn<F>(f: F) -> Thread where F: FnOnce(), F: Send + 'static {\n-        Builder::new().spawn(f)\n+        Builder::new().spawn(f).unwrap().thread().clone()\n     }\n \n-    /// Spawn a new *scoped* thread, returning a `JoinGuard` for it.\n-    ///\n-    /// The join guard can be used to explicitly join the child thread (via\n-    /// `join`), returning `Result<T>`, or it will implicitly join the child\n-    /// upon being dropped. Because the child thread may refer to data on the\n-    /// current thread's stack (hence the \"scoped\" name), it cannot be detached;\n-    /// it *must* be joined before the relevant stack frame is popped. See the\n-    /// module documentation for additional details.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[unstable(feature = \"std_misc\",\n                reason = \"may change with specifics of new Send semantics\")]\n     pub fn scoped<'a, T, F>(f: F) -> JoinGuard<'a, T> where\n         T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n     {\n-        Builder::new().scoped(f)\n+        Builder::new().scoped(f).unwrap()\n     }\n \n-    /// Gets a handle to the thread that invokes it.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn current() -> Thread {\n         thread_info::current_thread()\n     }\n \n-    /// Cooperatively give up a timeslice to the OS scheduler.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[unstable(feature = \"std_misc\", reason = \"name may change\")]\n     pub fn yield_now() {\n         unsafe { imp::yield_now() }\n     }\n \n-    /// Determines whether the current thread is unwinding because of panic.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn panicking() -> bool {\n         unwind::panicking()\n     }\n \n-    /// Block unless or until the current thread's token is made available (may wake spuriously).\n-    ///\n-    /// See the module doc for more detail.\n-    //\n-    // The implementation currently uses the trivial strategy of a Mutex+Condvar\n-    // with wakeup flag, which does not actually allow spurious wakeups. In the\n-    // future, this will be implemented in a more efficient way, perhaps along the lines of\n-    //   http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n-    // or futuxes, and in either case may allow spurious wakeups.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[unstable(feature = \"std_misc\", reason = \"recently introduced\")]\n     pub fn park() {\n-        let thread = Thread::current();\n+        let thread = current();\n         let mut guard = thread.inner.lock.lock().unwrap();\n         while !*guard {\n             guard = thread.inner.cvar.wait(guard).unwrap();\n         }\n         *guard = false;\n     }\n \n-    /// Block unless or until the current thread's token is made available or\n-    /// the specified duration has been reached (may wake spuriously).\n-    ///\n-    /// The semantics of this function are equivalent to `park()` except that the\n-    /// thread will be blocked for roughly no longer than dur. This method\n-    /// should not be used for precise timing due to anomalies such as\n-    /// preemption or platform differences that may not cause the maximum\n-    /// amount of time waited to be precisely dur\n-    ///\n-    /// See the module doc for more detail.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[unstable(feature = \"std_misc\", reason = \"recently introduced\")]\n     pub fn park_timeout(dur: Duration) {\n-        let thread = Thread::current();\n+        let thread = current();\n         let mut guard = thread.inner.lock.lock().unwrap();\n         if !*guard {\n             let (g, _) = thread.inner.cvar.wait_timeout(guard, dur).unwrap();\n@@ -444,7 +533,7 @@ impl Thread {\n     /// Atomically makes the handle's token available if it is not already.\n     ///\n     /// See the module doc for more detail.\n-    #[unstable(feature = \"std_misc\", reason = \"recently introduced\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unpark(&self) {\n         let mut guard = self.inner.lock.lock().unwrap();\n         if !*guard {\n@@ -460,6 +549,13 @@ impl Thread {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for Thread {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.name(), f)\n+    }\n+}\n+\n // a hack to get around privacy restrictions\n impl thread_info::NewThread for Thread {\n     fn new(name: Option<String>) -> Thread { Thread::new(name) }\n@@ -469,24 +565,84 @@ impl thread_info::NewThread for Thread {\n ///\n /// A thread that completes without panicking is considered to exit successfully.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub type Result<T> = ::result::Result<T, Box<Any + Send>>;\n+pub type Result<T> = ::result::Result<T, Box<Any + Send + 'static>>;\n \n struct Packet<T>(Arc<UnsafeCell<Option<Result<T>>>>);\n \n-unsafe impl<T:'static+Send> Send for Packet<T> {}\n+unsafe impl<T:Send> Send for Packet<T> {}\n unsafe impl<T> Sync for Packet<T> {}\n \n+/// Inner representation for JoinHandle and JoinGuard\n+struct JoinInner<T> {\n+    native: imp::rust_thread,\n+    thread: Thread,\n+    packet: Packet<T>,\n+    joined: bool,\n+}\n+\n+impl<T> JoinInner<T> {\n+    fn join(&mut self) -> Result<T> {\n+        assert!(!self.joined);\n+        unsafe { imp::join(self.native) };\n+        self.joined = true;\n+        unsafe {\n+            (*self.packet.0.get()).take().unwrap()\n+        }\n+    }\n+}\n+\n+/// An owned permission to join on a thread (block on its termination).\n+///\n+/// Unlike a `JoinGuard`, a `JoinHandle` *detaches* the child thread\n+/// when it is dropped, rather than automatically joining on drop.\n+///\n+/// Due to platform restrictions, it is not possible to `Clone` this\n+/// handle: the ability to join a child thread is a uniquely-owned\n+/// permission.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct JoinHandle(JoinInner<()>);\n+\n+impl JoinHandle {\n+    /// Extract a handle to the underlying thread\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn thread(&self) -> &Thread {\n+        &self.0.thread\n+    }\n+\n+    /// Wait for the associated thread to finish.\n+    ///\n+    /// If the child thread panics, `Err` is returned with the parameter given\n+    /// to `panic`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn join(mut self) -> Result<()> {\n+        self.0.join()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Drop for JoinHandle {\n+    fn drop(&mut self) {\n+        if !self.0.joined {\n+            unsafe { imp::detach(self.0.native) }\n+        }\n+    }\n+}\n+\n /// An RAII-style guard that will block until thread termination when dropped.\n ///\n /// The type `T` is the return type for the thread's main function.\n+///\n+/// Joining on drop is necessary to ensure memory safety when stack\n+/// data is shared between a parent and child thread.\n+///\n+/// Due to platform restrictions, it is not possible to `Clone` this\n+/// handle: the ability to join a child thread is a uniquely-owned\n+/// permission.\n #[must_use]\n-#[unstable(feature = \"std_misc\",\n-           reason = \"may change with specifics of new Send semantics\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct JoinGuard<'a, T: 'a> {\n-    native: imp::rust_thread,\n-    thread: Thread,\n-    joined: bool,\n-    packet: Packet<T>,\n+    inner: JoinInner<T>,\n+    _marker: marker::CovariantType<&'a T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -496,41 +652,43 @@ impl<'a, T: Send + 'a> JoinGuard<'a, T> {\n     /// Extract a handle to the thread this guard will join on.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn thread(&self) -> &Thread {\n-        &self.thread\n+        &self.inner.thread\n     }\n \n     /// Wait for the associated thread to finish, returning the result of the thread's\n     /// calculation.\n     ///\n-    /// If the child thread panics, `Err` is returned with the parameter given\n-    /// to `panic`.\n+    /// # Panics\n+    ///\n+    /// Panics on the child thread are propagated by panicking the parent.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn join(mut self) -> Result<T> {\n-        assert!(!self.joined);\n-        unsafe { imp::join(self.native) };\n-        self.joined = true;\n-        unsafe {\n-            (*self.packet.0.get()).take().unwrap()\n+    pub fn join(mut self) -> T {\n+        match self.inner.join() {\n+            Ok(res) => res,\n+            Err(_) => panic!(\"child thread {:?} panicked\", self.thread()),\n         }\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Send> JoinGuard<'static, T> {\n     /// Detaches the child thread, allowing it to outlive its parent.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure whether this API imposes limitations elsewhere\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use spawn instead\")]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn detach(mut self) {\n-        unsafe { imp::detach(self.native) };\n-        self.joined = true; // avoid joining in the destructor\n+        unsafe { imp::detach(self.inner.native) };\n+        self.inner.joined = true; // avoid joining in the destructor\n     }\n }\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Send + 'a> Drop for JoinGuard<'a, T> {\n     fn drop(&mut self) {\n-        if !self.joined {\n-            unsafe { imp::join(self.native) };\n+        if !self.inner.joined {\n+            if self.inner.join().is_err() {\n+                panic!(\"child thread {:?} panicked\", self.thread());\n+            }\n         }\n     }\n }\n@@ -545,6 +703,7 @@ mod test {\n     use result;\n     use std::old_io::{ChanReader, ChanWriter};\n     use super::{Thread, Builder};\n+    use thread;\n     use thunk::Thunk;\n     use time::Duration;\n \n@@ -553,47 +712,64 @@ mod test {\n \n     #[test]\n     fn test_unnamed_thread() {\n-        Thread::scoped(move|| {\n-            assert!(Thread::current().name().is_none());\n+        thread::spawn(move|| {\n+            assert!(thread::current().name().is_none());\n         }).join().ok().unwrap();\n     }\n \n     #[test]\n     fn test_named_thread() {\n         Builder::new().name(\"ada lovelace\".to_string()).scoped(move|| {\n-            assert!(Thread::current().name().unwrap() == \"ada lovelace\".to_string());\n-        }).join().ok().unwrap();\n+            assert!(thread::current().name().unwrap() == \"ada lovelace\".to_string());\n+        }).unwrap().join();\n     }\n \n     #[test]\n     fn test_run_basic() {\n         let (tx, rx) = channel();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             tx.send(()).unwrap();\n         });\n         rx.recv().unwrap();\n     }\n \n     #[test]\n     fn test_join_success() {\n-        match Thread::scoped(move|| -> String {\n+        assert!(thread::scoped(move|| -> String {\n             \"Success!\".to_string()\n-        }).join().as_ref().map(|s| &**s) {\n-            result::Result::Ok(\"Success!\") => (),\n-            _ => panic!()\n-        }\n+        }).join() == \"Success!\");\n     }\n \n     #[test]\n     fn test_join_panic() {\n-        match Thread::scoped(move|| {\n+        match thread::spawn(move|| {\n             panic!()\n         }).join() {\n             result::Result::Err(_) => (),\n             result::Result::Ok(()) => panic!()\n         }\n     }\n \n+    #[test]\n+    fn test_scoped_success() {\n+        let res = thread::scoped(move|| -> String {\n+            \"Success!\".to_string()\n+        }).join();\n+        assert!(res == \"Success!\");\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_scoped_panic() {\n+        thread::scoped(|| panic!()).join();\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_scoped_implicit_panic() {\n+        thread::scoped(|| panic!());\n+    }\n+\n     #[test]\n     fn test_spawn_sched() {\n         use clone::Clone;\n@@ -602,7 +778,7 @@ mod test {\n \n         fn f(i: int, tx: Sender<()>) {\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 if i == 0 {\n                     tx.send(()).unwrap();\n                 } else {\n@@ -619,16 +795,16 @@ mod test {\n     fn test_spawn_sched_childs_on_default_sched() {\n         let (tx, rx) = channel();\n \n-        Thread::spawn(move|| {\n-            Thread::spawn(move|| {\n+        thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 tx.send(()).unwrap();\n             });\n         });\n \n         rx.recv().unwrap();\n     }\n \n-    fn avoid_copying_the_body<F>(spawnfn: F) where F: FnOnce(Thunk) {\n+    fn avoid_copying_the_body<F>(spawnfn: F) where F: FnOnce(Thunk<'static>) {\n         let (tx, rx) = channel::<uint>();\n \n         let x = box 1;\n@@ -646,14 +822,14 @@ mod test {\n     #[test]\n     fn test_avoid_copying_the_body_spawn() {\n         avoid_copying_the_body(|v| {\n-            Thread::spawn(move || v.invoke(()));\n+            thread::spawn(move || v.invoke(()));\n         });\n     }\n \n     #[test]\n     fn test_avoid_copying_the_body_thread_spawn() {\n         avoid_copying_the_body(|f| {\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 f.invoke(());\n             });\n         })\n@@ -662,7 +838,7 @@ mod test {\n     #[test]\n     fn test_avoid_copying_the_body_join() {\n         avoid_copying_the_body(|f| {\n-            let _ = Thread::scoped(move|| {\n+            let _ = thread::spawn(move|| {\n                 f.invoke(())\n             }).join();\n         })\n@@ -675,24 +851,24 @@ mod test {\n         // (well, it would if the constant were 8000+ - I lowered it to be more\n         // valgrind-friendly. try this at home, instead..!)\n         static GENERATIONS: uint = 16;\n-        fn child_no(x: uint) -> Thunk {\n+        fn child_no(x: uint) -> Thunk<'static> {\n             return Thunk::new(move|| {\n                 if x < GENERATIONS {\n-                    Thread::spawn(move|| child_no(x+1).invoke(()));\n+                    thread::spawn(move|| child_no(x+1).invoke(()));\n                 }\n             });\n         }\n-        Thread::spawn(|| child_no(0).invoke(()));\n+        thread::spawn(|| child_no(0).invoke(()));\n     }\n \n     #[test]\n     fn test_simple_newsched_spawn() {\n-        Thread::spawn(move || {});\n+        thread::spawn(move || {});\n     }\n \n     #[test]\n     fn test_try_panic_message_static_str() {\n-        match Thread::scoped(move|| {\n+        match thread::spawn(move|| {\n             panic!(\"static string\");\n         }).join() {\n             Err(e) => {\n@@ -706,7 +882,7 @@ mod test {\n \n     #[test]\n     fn test_try_panic_message_owned_str() {\n-        match Thread::scoped(move|| {\n+        match thread::spawn(move|| {\n             panic!(\"owned string\".to_string());\n         }).join() {\n             Err(e) => {\n@@ -720,7 +896,7 @@ mod test {\n \n     #[test]\n     fn test_try_panic_message_any() {\n-        match Thread::scoped(move|| {\n+        match thread::spawn(move|| {\n             panic!(box 413u16 as Box<Any + Send>);\n         }).join() {\n             Err(e) => {\n@@ -738,7 +914,7 @@ mod test {\n     fn test_try_panic_message_unit_struct() {\n         struct Juju;\n \n-        match Thread::scoped(move|| {\n+        match thread::spawn(move|| {\n             panic!(Juju)\n         }).join() {\n             Err(ref e) if e.is::<Juju>() => {}\n@@ -752,10 +928,9 @@ mod test {\n         let mut reader = ChanReader::new(rx);\n         let stdout = ChanWriter::new(tx);\n \n-        let r = Builder::new().stdout(box stdout as Box<Writer + Send>).scoped(move|| {\n+        Builder::new().stdout(box stdout as Box<Writer + Send>).scoped(move|| {\n             print!(\"Hello, world!\");\n-        }).join();\n-        assert!(r.is_ok());\n+        }).unwrap().join();\n \n         let output = reader.read_to_string().unwrap();\n         assert_eq!(output, \"Hello, world!\".to_string());\n@@ -764,15 +939,15 @@ mod test {\n     #[test]\n     fn test_park_timeout_unpark_before() {\n         for _ in 0..10 {\n-            Thread::current().unpark();\n-            Thread::park_timeout(Duration::seconds(10_000_000));\n+            thread::current().unpark();\n+            thread::park_timeout(Duration::seconds(10_000_000));\n         }\n     }\n \n     #[test]\n     fn test_park_timeout_unpark_not_called() {\n         for _ in 0..10 {\n-            Thread::park_timeout(Duration::milliseconds(10));\n+            thread::park_timeout(Duration::milliseconds(10));\n         }\n     }\n \n@@ -781,14 +956,14 @@ mod test {\n         use std::old_io;\n \n         for _ in 0..10 {\n-            let th = Thread::current();\n+            let th = thread::current();\n \n-            let _guard = Thread::scoped(move || {\n+            let _guard = thread::spawn(move || {\n                 old_io::timer::sleep(Duration::milliseconds(50));\n                 th.unpark();\n             });\n \n-            Thread::park_timeout(Duration::seconds(10_000_000));\n+            thread::park_timeout(Duration::seconds(10_000_000));\n         }\n     }\n "}, {"sha": "2ed296e081c90f3b4a5988fbaf4332633d43bba6", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -72,7 +72,7 @@ pub mod __impl {\n ///\n /// ```\n /// use std::cell::RefCell;\n-/// use std::thread::Thread;\n+/// use std::thread;\n ///\n /// thread_local!(static FOO: RefCell<uint> = RefCell::new(1));\n ///\n@@ -82,7 +82,7 @@ pub mod __impl {\n /// });\n ///\n /// // each thread starts out with the initial value of 1\n-/// Thread::spawn(move|| {\n+/// thread::spawn(move|| {\n ///     FOO.with(|f| {\n ///         assert_eq!(*f.borrow(), 1);\n ///         *f.borrow_mut() = 3;\n@@ -548,7 +548,7 @@ mod tests {\n     use sync::mpsc::{channel, Sender};\n     use cell::UnsafeCell;\n     use super::State;\n-    use thread::Thread;\n+    use thread;\n \n     struct Foo(Sender<()>);\n \n@@ -568,7 +568,7 @@ mod tests {\n             *f.get() = 2;\n         });\n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             FOO.with(|f| unsafe {\n                 assert_eq!(*f.get(), 1);\n             });\n@@ -595,7 +595,7 @@ mod tests {\n         }\n         thread_local!(static FOO: Foo = foo());\n \n-        Thread::scoped(|| {\n+        thread::spawn(|| {\n             assert!(FOO.state() == State::Uninitialized);\n             FOO.with(|_| {\n                 assert!(FOO.state() == State::Valid);\n@@ -611,7 +611,7 @@ mod tests {\n         });\n \n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| unsafe {\n+        let _t = thread::spawn(move|| unsafe {\n             let mut tx = Some(tx);\n             FOO.with(|f| {\n                 *f.get() = Some(Foo(tx.take().unwrap()));\n@@ -659,7 +659,7 @@ mod tests {\n             }\n         }\n \n-        Thread::scoped(move|| {\n+        thread::spawn(move|| {\n             drop(S1);\n         }).join().ok().unwrap();\n     }\n@@ -677,7 +677,7 @@ mod tests {\n             }\n         }\n \n-        Thread::scoped(move|| unsafe {\n+        thread::spawn(move|| unsafe {\n             K1.with(|s| *s.get() = Some(S1));\n         }).join().ok().unwrap();\n     }\n@@ -704,7 +704,7 @@ mod tests {\n         }\n \n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| unsafe {\n+        let _t = thread::spawn(move|| unsafe {\n             let mut tx = Some(tx);\n             K1.with(|s| *s.get() = Some(S1(tx.take().unwrap())));\n         });"}, {"sha": "fe39954f0d446fd5ae3b45d8971b097a8ecae6a6", "filename": "src/libstd/thunk.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fthunk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibstd%2Fthunk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthunk.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -16,21 +16,24 @@ use alloc::boxed::Box;\n use core::marker::Send;\n use core::ops::FnOnce;\n \n-pub struct Thunk<A=(),R=()> {\n-    invoke: Box<Invoke<A,R>+Send>\n+pub struct Thunk<'a, A=(),R=()> {\n+    #[cfg(stage0)]\n+    invoke: Box<Invoke<A,R>+Send>,\n+    #[cfg(not(stage0))]\n+    invoke: Box<Invoke<A,R>+Send + 'a>,\n }\n \n-impl<R> Thunk<(),R> {\n-    pub fn new<F>(func: F) -> Thunk<(),R>\n-        where F : FnOnce() -> R, F : Send\n+impl<'a, R> Thunk<'a,(),R> {\n+    pub fn new<F>(func: F) -> Thunk<'a,(),R>\n+        where F : FnOnce() -> R, F : Send + 'a\n     {\n         Thunk::with_arg(move|()| func())\n     }\n }\n \n-impl<A,R> Thunk<A,R> {\n-    pub fn with_arg<F>(func: F) -> Thunk<A,R>\n-        where F : FnOnce(A) -> R, F : Send\n+impl<'a,A,R> Thunk<'a,A,R> {\n+    pub fn with_arg<F>(func: F) -> Thunk<'a,A,R>\n+        where F : FnOnce(A) -> R, F : Send + 'a\n     {\n         Thunk {\n             invoke: box func"}, {"sha": "d8cba139fb5979b9258c5d8e6498a24e00be8f42", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -18,6 +18,7 @@ use codemap;\n use codemap::Span;\n use ext::base;\n use ext::base::*;\n+use feature_gate;\n use parse::token::InternedString;\n use parse::token;\n use ptr::P;\n@@ -48,6 +49,12 @@ static OPTIONS: &'static [&'static str] = &[\"volatile\", \"alignstack\", \"intel\"];\n \n pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                        -> Box<base::MacResult+'cx> {\n+    if !cx.ecfg.enable_asm() {\n+        feature_gate::emit_feature_err(\n+            &cx.parse_sess.span_diagnostic, \"asm\", sp, feature_gate::EXPLAIN_ASM);\n+        return DummyResult::expr(sp);\n+    }\n+\n     let mut p = cx.new_parser_from_tts(tts);\n     let mut asm = InternedString::new(\"\");\n     let mut asm_str_style = None;"}, {"sha": "8800ffd1e9b5f2eaea8611f8d8301dfdfdf9f693", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -439,7 +439,8 @@ impl BlockInfo {\n \n /// The base map of methods for expanding syntax extension\n /// AST nodes into full ASTs\n-fn initial_syntax_expander_table(ecfg: &expand::ExpansionConfig) -> SyntaxEnv {\n+fn initial_syntax_expander_table<'feat>(ecfg: &expand::ExpansionConfig<'feat>)\n+                                        -> SyntaxEnv {\n     // utility function to simplify creating NormalTT syntax extensions\n     fn builtin_normal_expander(f: MacroExpanderFn) -> SyntaxExtension {\n         NormalTT(box f, None)\n@@ -470,7 +471,7 @@ fn initial_syntax_expander_table(ecfg: &expand::ExpansionConfig) -> SyntaxEnv {\n     syntax_expanders.insert(intern(\"deriving\"),\n                             Decorator(box ext::deriving::expand_deprecated_deriving));\n \n-    if ecfg.enable_quotes {\n+    if ecfg.enable_quotes() {\n         // Quasi-quoting expanders\n         syntax_expanders.insert(intern(\"quote_tokens\"),\n                            builtin_normal_expander(\n@@ -541,7 +542,7 @@ pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a parse::ParseSess,\n     pub cfg: ast::CrateConfig,\n     pub backtrace: ExpnId,\n-    pub ecfg: expand::ExpansionConfig,\n+    pub ecfg: expand::ExpansionConfig<'a>,\n     pub use_std: bool,\n \n     pub mod_path: Vec<ast::Ident> ,\n@@ -554,7 +555,7 @@ pub struct ExtCtxt<'a> {\n \n impl<'a> ExtCtxt<'a> {\n     pub fn new(parse_sess: &'a parse::ParseSess, cfg: ast::CrateConfig,\n-               ecfg: expand::ExpansionConfig) -> ExtCtxt<'a> {\n+               ecfg: expand::ExpansionConfig<'a>) -> ExtCtxt<'a> {\n         let env = initial_syntax_expander_table(&ecfg);\n         ExtCtxt {\n             parse_sess: parse_sess,"}, {"sha": "63a8bd9ddf1b39972868aeba18fe19fbe52117fa", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -12,12 +12,21 @@ use ast;\n use codemap::Span;\n use ext::base::*;\n use ext::base;\n+use feature_gate;\n use parse::token;\n use parse::token::{str_to_ident};\n use ptr::P;\n \n pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                               -> Box<base::MacResult+'cx> {\n+    if !cx.ecfg.enable_concat_idents() {\n+        feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,\n+                                       \"concat_idents\",\n+                                       sp,\n+                                       feature_gate::EXPLAIN_CONCAT_IDENTS);\n+        return base::DummyResult::expr(sp);\n+    }\n+\n     let mut res_str = String::new();\n     for (i, e) in tts.iter().enumerate() {\n         if i & 1 == 1 {"}, {"sha": "6b7cecee815765f3bebd2e83f0090a5d0a1c0660", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -22,6 +22,7 @@ use attr::AttrMetaMethods;\n use codemap;\n use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use ext::base::*;\n+use feature_gate::{Features};\n use fold;\n use fold::*;\n use parse;\n@@ -1408,28 +1409,63 @@ fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n     }\n }\n \n-pub struct ExpansionConfig {\n+pub struct ExpansionConfig<'feat> {\n     pub crate_name: String,\n-    pub enable_quotes: bool,\n+    pub features: Option<&'feat Features>,\n     pub recursion_limit: usize,\n }\n \n-impl ExpansionConfig {\n-    pub fn default(crate_name: String) -> ExpansionConfig {\n+impl<'feat> ExpansionConfig<'feat> {\n+    pub fn default(crate_name: String) -> ExpansionConfig<'static> {\n         ExpansionConfig {\n             crate_name: crate_name,\n-            enable_quotes: false,\n+            features: None,\n             recursion_limit: 64,\n         }\n     }\n+\n+    pub fn enable_quotes(&self) -> bool {\n+        match self.features {\n+            Some(&Features { allow_quote: true, .. }) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn enable_asm(&self) -> bool {\n+        match self.features {\n+            Some(&Features { allow_asm: true, .. }) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn enable_log_syntax(&self) -> bool {\n+        match self.features {\n+            Some(&Features { allow_log_syntax: true, .. }) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn enable_concat_idents(&self) -> bool {\n+        match self.features {\n+            Some(&Features { allow_concat_idents: true, .. }) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn enable_trace_macros(&self) -> bool {\n+        match self.features {\n+            Some(&Features { allow_trace_macros: true, .. }) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n-pub fn expand_crate(parse_sess: &parse::ParseSess,\n-                    cfg: ExpansionConfig,\n-                    // these are the macros being imported to this crate:\n-                    imported_macros: Vec<ast::MacroDef>,\n-                    user_exts: Vec<NamedSyntaxExtension>,\n-                    c: Crate) -> Crate {\n+pub fn expand_crate<'feat>(parse_sess: &parse::ParseSess,\n+                           cfg: ExpansionConfig<'feat>,\n+                           // these are the macros being imported to this crate:\n+                           imported_macros: Vec<ast::MacroDef>,\n+                           user_exts: Vec<NamedSyntaxExtension>,\n+                           c: Crate) -> Crate {\n     let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg);\n     cx.use_std = std_inject::use_std(&c);\n \n@@ -1598,7 +1634,7 @@ mod test {\n     // these following tests are quite fragile, in that they don't test what\n     // *kind* of failure occurs.\n \n-    fn test_ecfg() -> ExpansionConfig {\n+    fn test_ecfg() -> ExpansionConfig<'static> {\n         ExpansionConfig::default(\"test\".to_string())\n     }\n "}, {"sha": "8173dd93f7468db4c5c2853d9e9f958cf63c264c", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -11,12 +11,20 @@\n use ast;\n use codemap;\n use ext::base;\n+use feature_gate;\n use print;\n \n pub fn expand_syntax_ext<'cx>(cx: &'cx mut base::ExtCtxt,\n                               sp: codemap::Span,\n                               tts: &[ast::TokenTree])\n                               -> Box<base::MacResult+'cx> {\n+    if !cx.ecfg.enable_log_syntax() {\n+        feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,\n+                                       \"log_syntax\",\n+                                       sp,\n+                                       feature_gate::EXPLAIN_LOG_SYNTAX);\n+        return base::DummyResult::any(sp);\n+    }\n \n     cx.print_backtrace();\n "}, {"sha": "3fcc6a8d69241b7cb2bfa80258589457f176dcf5", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -12,13 +12,23 @@ use ast;\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::base;\n+use feature_gate;\n use parse::token::keywords;\n \n \n pub fn expand_trace_macros(cx: &mut ExtCtxt,\n                            sp: Span,\n                            tt: &[ast::TokenTree])\n                            -> Box<base::MacResult+'static> {\n+    if !cx.ecfg.enable_trace_macros() {\n+        feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,\n+                                       \"trace_macros\",\n+                                       sp,\n+                                       feature_gate::EXPLAIN_TRACE_MACROS);\n+        return base::DummyResult::any(sp);\n+    }\n+\n+\n     match tt {\n         [ast::TtToken(_, ref tok)] if tok.is_keyword(keywords::True) => {\n             cx.set_trace_macros(true);"}, {"sha": "3bebba15a572b2e307231dd6c1a48cfade2e8ddb", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 201, "deletions": 51, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -23,6 +23,7 @@\n //! becomes stable.\n \n use self::Status::*;\n+use self::AttributeType::*;\n \n use abi::RustIntrinsic;\n use ast::NodeId;\n@@ -35,7 +36,6 @@ use visit;\n use visit::Visitor;\n use parse::token::{self, InternedString};\n \n-use std::slice;\n use std::ascii::AsciiExt;\n \n // If you change this list without updating src/doc/reference.md, @cmr will be sad\n@@ -133,6 +133,12 @@ static KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n     // Allows using the unsafe_no_drop_flag attribute (unlikely to\n     // switch to Accepted; see RFC 320)\n     (\"unsafe_no_drop_flag\", \"1.0.0\", Active),\n+\n+    // Allows the use of custom attributes; RFC 572\n+    (\"custom_attribute\", \"1.0.0\", Active),\n+\n+    // Allows the use of rustc_* attributes; RFC 572\n+    (\"rustc_attrs\", \"1.0.0\", Active),\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -152,12 +158,148 @@ enum Status {\n     Accepted,\n }\n \n+// Attributes that have a special meaning to rustc or rustdoc\n+pub static KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType)] = &[\n+    // Normal attributes\n+\n+    (\"warn\", Normal),\n+    (\"allow\", Normal),\n+    (\"forbid\", Normal),\n+    (\"deny\", Normal),\n+\n+    (\"macro_reexport\", Normal),\n+    (\"macro_use\", Normal),\n+    (\"macro_export\", Normal),\n+    (\"plugin_registrar\", Normal),\n+\n+    (\"cfg\", Normal),\n+    (\"main\", Normal),\n+    (\"start\", Normal),\n+    (\"test\", Normal),\n+    (\"bench\", Normal),\n+    (\"simd\", Normal),\n+    (\"repr\", Normal),\n+    (\"path\", Normal),\n+    (\"abi\", Normal),\n+    (\"unsafe_destructor\", Normal),\n+    (\"automatically_derived\", Normal),\n+    (\"no_mangle\", Normal),\n+    (\"no_link\", Normal),\n+    (\"derive\", Normal),\n+    (\"should_fail\", Normal),\n+    (\"ignore\", Normal),\n+    (\"no_implicit_prelude\", Normal),\n+    (\"reexport_test_harness_main\", Normal),\n+    (\"link_args\", Normal),\n+    (\"macro_escape\", Normal),\n+\n+\n+    (\"staged_api\", Gated(\"staged_api\",\n+                         \"staged_api is for use by rustc only\")),\n+    (\"plugin\", Gated(\"plugin\",\n+                     \"compiler plugins are experimental \\\n+                      and possibly buggy\")),\n+    (\"no_std\", Gated(\"no_std\",\n+                     \"no_std is experimental\")),\n+    (\"lang\", Gated(\"lang_items\",\n+                     \"language items are subject to change\")),\n+    (\"linkage\", Gated(\"linkage\",\n+                      \"the `linkage` attribute is experimental \\\n+                       and not portable across platforms\")),\n+    (\"thread_local\", Gated(\"thread_local\",\n+                            \"`#[thread_local]` is an experimental feature, and does not \\\n+                             currently handle destructors. There is no corresponding \\\n+                             `#[task_local]` mapping to the task model\")),\n+\n+    (\"rustc_on_unimplemented\", Gated(\"on_unimplemented\",\n+                                     \"the `#[rustc_on_unimplemented]` attribute \\\n+                                      is an experimental feature\")),\n+    (\"rustc_variance\", Gated(\"rustc_attrs\",\n+                             \"the `#[rustc_variance]` attribute \\\n+                              is an experimental feature\")),\n+    (\"rustc_error\", Gated(\"rustc_attrs\",\n+                          \"the `#[rustc_error]` attribute \\\n+                           is an experimental feature\")),\n+    (\"rustc_move_fragments\", Gated(\"rustc_attrs\",\n+                                   \"the `#[rustc_move_fragments]` attribute \\\n+                                    is an experimental feature\")),\n+\n+    // FIXME: #14408 whitelist docs since rustdoc looks at them\n+    (\"doc\", Whitelisted),\n+\n+    // FIXME: #14406 these are processed in trans, which happens after the\n+    // lint pass\n+    (\"cold\", Whitelisted),\n+    (\"export_name\", Whitelisted),\n+    (\"inline\", Whitelisted),\n+    (\"link\", Whitelisted),\n+    (\"link_name\", Whitelisted),\n+    (\"link_section\", Whitelisted),\n+    (\"no_builtins\", Whitelisted),\n+    (\"no_mangle\", Whitelisted),\n+    (\"no_split_stack\", Whitelisted),\n+    (\"no_stack_check\", Whitelisted),\n+    (\"packed\", Whitelisted),\n+    (\"static_assert\", Whitelisted),\n+    (\"no_debug\", Whitelisted),\n+    (\"omit_gdb_pretty_printer_section\", Whitelisted),\n+    (\"unsafe_no_drop_flag\", Whitelisted),\n+\n+    // used in resolve\n+    (\"prelude_import\", Whitelisted),\n+\n+    // FIXME: #14407 these are only looked at on-demand so we can't\n+    // guarantee they'll have already been checked\n+    (\"deprecated\", Whitelisted),\n+    (\"must_use\", Whitelisted),\n+    (\"stable\", Whitelisted),\n+    (\"unstable\", Whitelisted),\n+\n+    // FIXME: #19470 this shouldn't be needed forever\n+    (\"old_orphan_check\", Whitelisted),\n+    (\"old_impl_check\", Whitelisted),\n+    (\"rustc_paren_sugar\", Whitelisted), // FIXME: #18101 temporary unboxed closure hack\n+\n+    // Crate level attributes\n+    (\"crate_name\", CrateLevel),\n+    (\"crate_type\", CrateLevel),\n+    (\"crate_id\", CrateLevel),\n+    (\"feature\", CrateLevel),\n+    (\"no_start\", CrateLevel),\n+    (\"no_main\", CrateLevel),\n+    (\"no_builtins\", CrateLevel),\n+    (\"recursion_limit\", CrateLevel),\n+];\n+\n+#[derive(PartialEq, Copy)]\n+pub enum AttributeType {\n+    /// Normal, builtin attribute that is consumed\n+    /// by the compiler before the unused_attribute check\n+    Normal,\n+\n+    /// Builtin attribute that may not be consumed by the compiler\n+    /// before the unused_attribute check. These attributes\n+    /// will be ignored by the unused_attribute lint\n+    Whitelisted,\n+\n+    /// Is gated by a given feature gate and reason\n+    /// These get whitelisted too\n+    Gated(&'static str, &'static str),\n+\n+    /// Builtin attribute that is only allowed at the crate level\n+    CrateLevel,\n+}\n+\n /// A set of features to be used by later passes.\n pub struct Features {\n     pub unboxed_closures: bool,\n     pub rustc_diagnostic_macros: bool,\n     pub visible_private_types: bool,\n-    pub quote: bool,\n+    pub allow_quote: bool,\n+    pub allow_asm: bool,\n+    pub allow_log_syntax: bool,\n+    pub allow_concat_idents: bool,\n+    pub allow_trace_macros: bool,\n     pub old_orphan_check: bool,\n     pub simd_ffi: bool,\n     pub unmarked_api: bool,\n@@ -173,7 +315,11 @@ impl Features {\n             unboxed_closures: false,\n             rustc_diagnostic_macros: false,\n             visible_private_types: false,\n-            quote: false,\n+            allow_quote: false,\n+            allow_asm: false,\n+            allow_log_syntax: false,\n+            allow_concat_idents: false,\n+            allow_trace_macros: false,\n             old_orphan_check: false,\n             simd_ffi: false,\n             unmarked_api: false,\n@@ -222,6 +368,18 @@ pub fn emit_feature_warn(diag: &SpanHandler, feature: &str, span: Span, explain:\n     }\n }\n \n+pub const EXPLAIN_ASM: &'static str =\n+    \"inline assembly is not stable enough for use and is subject to change\";\n+\n+pub const EXPLAIN_LOG_SYNTAX: &'static str =\n+    \"`log_syntax!` is not stable enough for use and is subject to change\";\n+\n+pub const EXPLAIN_CONCAT_IDENTS: &'static str =\n+    \"`concat_idents` is not stable enough for use and is subject to change\";\n+\n+pub const EXPLAIN_TRACE_MACROS: &'static str =\n+    \"`trace_macros` is not stable enough for use and is subject to change\";\n+\n struct MacroVisitor<'a> {\n     context: &'a Context<'a>\n }\n@@ -231,24 +389,28 @@ impl<'a, 'v> Visitor<'v> for MacroVisitor<'a> {\n         let ast::MacInvocTT(ref path, _, _) = mac.node;\n         let id = path.segments.last().unwrap().identifier;\n \n+        // Issue 22234: If you add a new case here, make sure to also\n+        // add code to catch the macro during or after expansion.\n+        //\n+        // We still keep this MacroVisitor (rather than *solely*\n+        // relying on catching cases during or after expansion) to\n+        // catch uses of these macros within conditionally-compiled\n+        // code, e.g. `#[cfg]`-guarded functions.\n+\n         if id == token::str_to_ident(\"asm\") {\n-            self.context.gate_feature(\"asm\", path.span, \"inline assembly is not \\\n-                stable enough for use and is subject to change\");\n+            self.context.gate_feature(\"asm\", path.span, EXPLAIN_ASM);\n         }\n \n         else if id == token::str_to_ident(\"log_syntax\") {\n-            self.context.gate_feature(\"log_syntax\", path.span, \"`log_syntax!` is not \\\n-                stable enough for use and is subject to change\");\n+            self.context.gate_feature(\"log_syntax\", path.span, EXPLAIN_LOG_SYNTAX);\n         }\n \n         else if id == token::str_to_ident(\"trace_macros\") {\n-            self.context.gate_feature(\"trace_macros\", path.span, \"`trace_macros` is not \\\n-                stable enough for use and is subject to change\");\n+            self.context.gate_feature(\"trace_macros\", path.span, EXPLAIN_TRACE_MACROS);\n         }\n \n         else if id == token::str_to_ident(\"concat_idents\") {\n-            self.context.gate_feature(\"concat_idents\", path.span, \"`concat_idents` is not \\\n-                stable enough for use and is subject to change\");\n+            self.context.gate_feature(\"concat_idents\", path.span, EXPLAIN_CONCAT_IDENTS);\n         }\n     }\n }\n@@ -274,22 +436,6 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_item(&mut self, i: &ast::Item) {\n-        for attr in &i.attrs {\n-            if attr.name() == \"thread_local\" {\n-                self.gate_feature(\"thread_local\", i.span,\n-                                  \"`#[thread_local]` is an experimental feature, and does not \\\n-                                  currently handle destructors. There is no corresponding \\\n-                                  `#[task_local]` mapping to the task model\");\n-            } else if attr.name() == \"linkage\" {\n-                self.gate_feature(\"linkage\", i.span,\n-                                  \"the `linkage` attribute is experimental \\\n-                                   and not portable across platforms\")\n-            } else if attr.name() == \"rustc_on_unimplemented\" {\n-                self.gate_feature(\"on_unimplemented\", i.span,\n-                                  \"the `#[rustc_on_unimplemented]` attribute \\\n-                                  is an experimental feature\")\n-            }\n-        }\n         match i.node {\n             ast::ItemExternCrate(_) => {\n                 if attr::contains_name(&i.attrs[], \"macro_reexport\") {\n@@ -463,30 +609,27 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_attribute(&mut self, attr: &ast::Attribute) {\n-        if attr.check_name(\"staged_api\") {\n-            self.gate_feature(\"staged_api\", attr.span,\n-                              \"staged_api is for use by rustc only\");\n-        } else if attr.check_name(\"plugin\") {\n-            self.gate_feature(\"plugin\", attr.span,\n-                              \"compiler plugins are experimental \\\n-                               and possibly buggy\");\n-        }\n-\n-        if attr::contains_name(slice::ref_slice(attr), \"lang\") {\n-            self.gate_feature(\"lang_items\",\n-                              attr.span,\n-                              \"language items are subject to change\");\n-        }\n-\n-        if attr.check_name(\"no_std\") {\n-            self.gate_feature(\"no_std\", attr.span,\n-                              \"no_std is experimental\");\n+        let name = &*attr.name();\n+        for &(n, ty) in KNOWN_ATTRIBUTES {\n+            if n == name {\n+                if let Gated(gate, desc) = ty {\n+                    self.gate_feature(gate, attr.span, desc);\n+                }\n+                return;\n+            }\n         }\n-\n-        if attr.check_name(\"unsafe_no_drop_flag\") {\n-            self.gate_feature(\"unsafe_no_drop_flag\", attr.span,\n-                              \"unsafe_no_drop_flag has unstable semantics \\\n-                               and may be removed in the future\");\n+        if name.starts_with(\"rustc_\") {\n+            self.gate_feature(\"rustc_attrs\", attr.span,\n+                              \"unless otherwise specified, attributes \\\n+                               with the prefix `rustc_` \\\n+                               are reserved for internal compiler diagnostics\");\n+        } else {\n+            self.gate_feature(\"custom_attribute\", attr.span,\n+                       format!(\"The attribute `{}` is currently \\\n+                                unknown to the the compiler and \\\n+                                may have meaning \\\n+                                added to it in the future\",\n+                                name).as_slice());\n         }\n     }\n \n@@ -591,11 +734,18 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::C\n \n     check(&mut cx, krate);\n \n+    // FIXME (pnkfelix): Before adding the 99th entry below, change it\n+    // to a single-pass (instead of N calls to `.has_feature`).\n+\n     Features {\n         unboxed_closures: cx.has_feature(\"unboxed_closures\"),\n         rustc_diagnostic_macros: cx.has_feature(\"rustc_diagnostic_macros\"),\n         visible_private_types: cx.has_feature(\"visible_private_types\"),\n-        quote: cx.has_feature(\"quote\"),\n+        allow_quote: cx.has_feature(\"quote\"),\n+        allow_asm: cx.has_feature(\"asm\"),\n+        allow_log_syntax: cx.has_feature(\"log_syntax\"),\n+        allow_concat_idents: cx.has_feature(\"concat_idents\"),\n+        allow_trace_macros: cx.has_feature(\"trace_macros\"),\n         old_orphan_check: cx.has_feature(\"old_orphan_check\"),\n         simd_ffi: cx.has_feature(\"simd_ffi\"),\n         unmarked_api: cx.has_feature(\"unmarked_api\"),"}, {"sha": "e8bdcd62b588bbc3672a8435bf49353842829053", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -30,9 +30,9 @@\n #![feature(env)]\n #![feature(hash)]\n #![feature(int_uint)]\n-#![feature(io)]\n+#![feature(old_io)]\n #![feature(libc)]\n-#![feature(path)]\n+#![feature(old_path)]\n #![feature(quote, unsafe_destructor)]\n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "4b021f2434f054d8a45ab599a13d67a287ad48ce", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -2761,15 +2761,13 @@ impl<'a> State<'a> {\n             ast::LitStr(ref st, style) => self.print_string(&st, style),\n             ast::LitByte(byte) => {\n                 let mut res = String::from_str(\"b'\");\n-                ascii::escape_default(byte, |c| res.push(c as char));\n+                res.extend(ascii::escape_default(byte).map(|c| c as char));\n                 res.push('\\'');\n                 word(&mut self.s, &res[])\n             }\n             ast::LitChar(ch) => {\n                 let mut res = String::from_str(\"'\");\n-                for c in ch.escape_default() {\n-                    res.push(c);\n-                }\n+                res.extend(ch.escape_default());\n                 res.push('\\'');\n                 word(&mut self.s, &res[])\n             }\n@@ -2809,8 +2807,8 @@ impl<'a> State<'a> {\n             ast::LitBinary(ref v) => {\n                 let mut escaped: String = String::new();\n                 for &ch in &**v {\n-                    ascii::escape_default(ch as u8,\n-                                          |ch| escaped.push(ch as char));\n+                    escaped.extend(ascii::escape_default(ch as u8)\n+                                         .map(|c| c as char));\n                 }\n                 word(&mut self.s, &format!(\"b\\\"{}\\\"\", escaped)[])\n             }"}, {"sha": "304f370a1993e0b44284401793c4389f98774d01", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -54,12 +54,12 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(int_uint)]\n-#![feature(io)]\n-#![feature(path)]\n+#![feature(old_io)]\n+#![feature(old_path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(std_misc)]\n #![feature(unicode)]\n+#![feature(std_misc)]\n #![feature(env)]\n #![cfg_attr(windows, feature(libc))]\n "}, {"sha": "b978d2d8054e566212eb33868777ad3d9d1924ea", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -72,7 +72,7 @@ pub struct TerminfoTerminal<T> {\n     ti: Box<TermInfo>\n }\n \n-impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n+impl<T: Writer+Send+'static> Terminal<T> for TerminfoTerminal<T> {\n     fn fg(&mut self, color: color::Color) -> IoResult<bool> {\n         let color = self.dim_if_necessary(color);\n         if self.num_colors > color {\n@@ -164,11 +164,11 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n     fn get_mut<'a>(&'a mut self) -> &'a mut T { &mut self.out }\n }\n \n-impl<T: Writer+Send> UnwrappableTerminal<T> for TerminfoTerminal<T> {\n+impl<T: Writer+Send+'static> UnwrappableTerminal<T> for TerminfoTerminal<T> {\n     fn unwrap(self) -> T { self.out }\n }\n \n-impl<T: Writer+Send> TerminfoTerminal<T> {\n+impl<T: Writer+Send+'static> TerminfoTerminal<T> {\n     /// Returns `None` whenever the terminal cannot be created for some\n     /// reason.\n     pub fn new(out: T) -> Option<Box<Terminal<T>+Send+'static>> {\n@@ -229,4 +229,3 @@ impl<T: Writer> Writer for TerminfoTerminal<T> {\n         self.out.flush()\n     }\n }\n-"}, {"sha": "e93b956dc7c835eaee3f11af0606a8bcf7437ba2", "filename": "src/libterm/win.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fwin.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -86,7 +86,7 @@ fn bits_to_color(bits: u16) -> color::Color {\n     color | (bits & 0x8) // copy the hi-intensity bit\n }\n \n-impl<T: Writer+Send> WinConsole<T> {\n+impl<T: Writer+Send+'static> WinConsole<T> {\n     fn apply(&mut self) {\n         let _unused = self.buf.flush();\n         let mut accum: libc::WORD = 0;\n@@ -139,7 +139,7 @@ impl<T: Writer> Writer for WinConsole<T> {\n     }\n }\n \n-impl<T: Writer+Send> Terminal<T> for WinConsole<T> {\n+impl<T: Writer+Send+'static> Terminal<T> for WinConsole<T> {\n     fn fg(&mut self, color: color::Color) -> IoResult<bool> {\n         self.foreground = color;\n         self.apply();\n@@ -192,6 +192,6 @@ impl<T: Writer+Send> Terminal<T> for WinConsole<T> {\n     fn get_mut<'a>(&'a mut self) -> &'a mut T { &mut self.buf }\n }\n \n-impl<T: Writer+Send> UnwrappableTerminal<T> for WinConsole<T> {\n+impl<T: Writer+Send+'static> UnwrappableTerminal<T> for WinConsole<T> {\n     fn unwrap(self) -> T { self.buf }\n }"}, {"sha": "2cb30ad9804c6de074bbec45e5b29a19c909eb2e", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -39,8 +39,8 @@\n #![feature(env)]\n #![feature(hash)]\n #![feature(int_uint)]\n-#![feature(io)]\n-#![feature(path)]\n+#![feature(old_io)]\n+#![feature(old_path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n@@ -75,7 +75,7 @@ use std::iter::repeat;\n use std::num::{Float, Int};\n use std::env;\n use std::sync::mpsc::{channel, Sender};\n-use std::thread::{self, Thread};\n+use std::thread;\n use std::thunk::{Thunk, Invoke};\n use std::time::Duration;\n \n@@ -154,7 +154,7 @@ pub enum TestFn {\n     StaticTestFn(fn()),\n     StaticBenchFn(fn(&mut Bencher)),\n     StaticMetricFn(fn(&mut MetricMap)),\n-    DynTestFn(Thunk),\n+    DynTestFn(Thunk<'static>),\n     DynMetricFn(Box<for<'a> Invoke<&'a mut MetricMap>+'static>),\n     DynBenchFn(Box<TDynBenchFn+'static>)\n }\n@@ -878,8 +878,8 @@ pub fn run_test(opts: &TestOpts,\n     fn run_test_inner(desc: TestDesc,\n                       monitor_ch: Sender<MonitorMsg>,\n                       nocapture: bool,\n-                      testfn: Thunk) {\n-        Thread::spawn(move || {\n+                      testfn: Thunk<'static>) {\n+        thread::spawn(move || {\n             let (tx, rx) = channel();\n             let mut reader = ChanReader::new(rx);\n             let stdout = ChanWriter::new(tx.clone());\n@@ -895,7 +895,7 @@ pub fn run_test(opts: &TestOpts,\n                 cfg = cfg.stderr(box stderr as Box<Writer + Send>);\n             }\n \n-            let result_guard = cfg.scoped(move || { testfn.invoke(()) });\n+            let result_guard = cfg.spawn(move || { testfn.invoke(()) }).unwrap();\n             let stdout = reader.read_to_end().unwrap().into_iter().collect();\n             let test_result = calc_result(&desc, result_guard.join());\n             monitor_ch.send((desc.clone(), test_result, stdout)).unwrap();"}, {"sha": "791886be1ce5b6a6de76889ca83bc7d7f53a3f7e", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -77,16 +77,3 @@ pub mod str {\n     pub use u_str::{utf8_char_width, is_utf16, Utf16Items, Utf16Item};\n     pub use u_str::{utf16_items, Utf16Encoder};\n }\n-\n-// NOTE: remove after next snapshot\n-// this lets us use #[derive(..)]\n-#[cfg(stage0)]\n-mod std {\n-    pub use core::clone;\n-    pub use core::cmp;\n-    pub use core::fmt;\n-    pub use core::marker;\n-    // for-loops\n-    pub use core::iter;\n-    pub use core::option;\n-}"}, {"sha": "2089cab13e7f92b487ba0dc1df9f6c05116b004a", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -1 +1 @@\n-Subproject commit 4891e6382e3e8aa89d530aa18427836428c47157\n+Subproject commit 2089cab13e7f92b487ba0dc1df9f6c05116b004a"}, {"sha": "6f5fc5c1969f0a8704e0f5b8fabb27b6610877c4", "filename": "src/rustbook/build.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Frustbook%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Frustbook%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbuild.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -11,6 +11,7 @@\n //! Implementation of the `build` subcommand, used to compile a book.\n \n use std::os;\n+use std::env;\n use std::old_io;\n use std::old_io::{fs, File, BufferedWriter, TempDir, IoResult};\n \n@@ -80,10 +81,10 @@ fn render(book: &Book, tgt: &Path) -> CliResult<()> {\n         let out_path = tgt.join(item.path.dirname());\n \n         let src;\n-        if os::args().len() < 3 {\n+        if env::args().len() < 3 {\n             src = os::getcwd().unwrap().clone();\n         } else {\n-            src = Path::new(os::args()[2].clone());\n+            src = Path::new(env::args().nth(2).unwrap().clone());\n         }\n         // preprocess the markdown, rerouting markdown references to html references\n         let markdown_data = try!(File::open(&src.join(&item.path)).read_to_string());\n@@ -153,16 +154,16 @@ impl Subcommand for Build {\n         let src;\n         let tgt;\n \n-        if os::args().len() < 3 {\n+        if env::args().len() < 3 {\n             src = cwd.clone();\n         } else {\n-            src = Path::new(os::args()[2].clone());\n+            src = Path::new(env::args().nth(2).unwrap().clone());\n         }\n \n-        if os::args().len() < 4 {\n+        if env::args().len() < 4 {\n             tgt = cwd.join(\"_book\");\n         } else {\n-            tgt = Path::new(os::args()[3].clone());\n+            tgt = Path::new(env::args().nth(3).unwrap().clone());\n         }\n \n         try!(fs::mkdir(&tgt, old_io::USER_DIR));"}, {"sha": "ace57f0ac2c0b9351e6df4860955697cedd209b4", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -11,14 +11,15 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(io)]\n+#![feature(old_io)]\n #![feature(os)]\n-#![feature(path)]\n+#![feature(env)]\n+#![feature(old_path)]\n #![feature(rustdoc)]\n \n extern crate rustdoc;\n \n-use std::os;\n+use std::env;\n use subcommand::Subcommand;\n use term::Term;\n \n@@ -48,7 +49,7 @@ mod javascript;\n #[cfg(not(test))] // thanks #12327\n fn main() {\n     let mut term = Term::new();\n-    let cmd = os::args();\n+    let cmd: Vec<_> = env::args().collect();\n \n     if cmd.len() <= 1 {\n         help::usage()"}, {"sha": "98aa3fca184dca3f4c05e04fc9d09ba91641892d", "filename": "src/rustbook/term.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Frustbook%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Frustbook%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fterm.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -11,7 +11,7 @@\n //! An abstraction of the terminal. Eventually, provide color and\n //! verbosity support. For now, just a wrapper around stdout/stderr.\n \n-use std::os;\n+use std::env;\n use std::old_io::stdio;\n \n pub struct Term {\n@@ -28,6 +28,6 @@ impl Term {\n     pub fn err(&mut self, msg: &str) {\n         // swallow any errors\n         let _ = self.err.write_line(msg);\n-        os::set_exit_status(101);\n+        env::set_exit_status(101);\n     }\n }"}, {"sha": "1317343712430d241e9115d1c70fd69d63a57e4c", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2015-02-12\n+2015-02-13"}, {"sha": "4759c44259d5289d7a71a29b47a6ff1387882c2f", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -1,3 +1,12 @@\n+S 2015-02-17 f1bb6c2\n+  freebsd-x86_64 59f3a2c6350c170804fb65838e1b504eeab89105\n+  linux-i386 191ed5ec4f17e32d36abeade55a1c6085e51245c\n+  linux-x86_64 acec86045632f4f3f085c072ba696f889906dffe\n+  macos-i386 9d9e622584bfa318f32bcb5b9ce6a365febff595\n+  macos-x86_64 e96c1e9860b186507cc75c186d1b96d44df12292\n+  winnt-i386 3f43e0e71311636f9143ad6f2ee7a514e9fa3f8e\n+  winnt-x86_64 26ef3d9098ea346e5ff8945d5b224bb10c24341d\n+\n S 2015-02-04 ac134f7\n   freebsd-x86_64 483e37a02a7ebc12a872e3146145e342ba4a5c04\n   linux-i386 8af64e5df839cc945399484380a8b2ebe05a6751"}, {"sha": "b38e955231e4a7e5e7985736d4cda9ad1edb609c", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::{Receiver, channel};\n \n-pub fn foo<T:Send + Clone>(x: T) -> Receiver<T> {\n+pub fn foo<T:'static + Send + Clone>(x: T) -> Receiver<T> {\n     let (tx, rx) = channel();\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         tx.send(x.clone());\n     });\n     rx"}, {"sha": "01b2b748ba9d83910105567c020b3fb8fd52d311", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -64,16 +64,6 @@ impl MethodTester {\n     pub fn method_stable(&self) {}\n     #[stable(feature = \"rust1\", since = \"1.0.0\", reason = \"text\")]\n     pub fn method_stable_text(&self) {}\n-\n-    #[locked]\n-    pub fn method_locked(&self) {}\n-    #[locked=\"text\"]\n-    pub fn method_locked_text(&self) {}\n-\n-    #[frozen]\n-    pub fn method_frozen(&self) {}\n-    #[frozen=\"text\"]\n-    pub fn method_frozen_text(&self) {}\n }\n \n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n@@ -101,16 +91,6 @@ pub trait Trait {\n     fn trait_stable(&self) {}\n     #[stable(feature = \"rust1\", since = \"1.0.0\", reason = \"text\")]\n     fn trait_stable_text(&self) {}\n-\n-    #[locked]\n-    fn trait_locked(&self) {}\n-    #[locked=\"text\"]\n-    fn trait_locked_text(&self) {}\n-\n-    #[frozen]\n-    fn trait_frozen(&self) {}\n-    #[frozen=\"text\"]\n-    fn trait_frozen_text(&self) {}\n }\n \n impl Trait for MethodTester {}"}, {"sha": "4909d84a34f126960aadfb6e28343ceb275a34fd", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -11,7 +11,7 @@\n #![feature(unboxed_closures)]\n \n use std::collections::{BTreeMap, HashMap, HashSet};\n-use std::os;\n+use std::env;\n use std::rand::{Rng, IsaacRng, SeedableRng};\n use std::time::Duration;\n \n@@ -20,33 +20,33 @@ fn timed<F>(label: &str, f: F) where F: FnMut() {\n }\n \n trait MutableMap {\n-    fn insert(&mut self, k: uint, v: uint);\n-    fn remove(&mut self, k: &uint) -> bool;\n-    fn find(&self, k: &uint) -> Option<&uint>;\n+    fn insert(&mut self, k: usize, v: usize);\n+    fn remove(&mut self, k: &usize) -> bool;\n+    fn find(&self, k: &usize) -> Option<&usize>;\n }\n \n-impl MutableMap for BTreeMap<uint, uint> {\n-    fn insert(&mut self, k: uint, v: uint) { self.insert(k, v); }\n-    fn remove(&mut self, k: &uint) -> bool { self.remove(k).is_some() }\n-    fn find(&self, k: &uint) -> Option<&uint> { self.get(k) }\n+impl MutableMap for BTreeMap<usize, usize> {\n+    fn insert(&mut self, k: usize, v: usize) { self.insert(k, v); }\n+    fn remove(&mut self, k: &usize) -> bool { self.remove(k).is_some() }\n+    fn find(&self, k: &usize) -> Option<&usize> { self.get(k) }\n }\n-impl MutableMap for HashMap<uint, uint> {\n-    fn insert(&mut self, k: uint, v: uint) { self.insert(k, v); }\n-    fn remove(&mut self, k: &uint) -> bool { self.remove(k).is_some() }\n-    fn find(&self, k: &uint) -> Option<&uint> { self.get(k) }\n+impl MutableMap for HashMap<usize, usize> {\n+    fn insert(&mut self, k: usize, v: usize) { self.insert(k, v); }\n+    fn remove(&mut self, k: &usize) -> bool { self.remove(k).is_some() }\n+    fn find(&self, k: &usize) -> Option<&usize> { self.get(k) }\n }\n \n-fn ascending<M: MutableMap>(map: &mut M, n_keys: uint) {\n+fn ascending<M: MutableMap>(map: &mut M, n_keys: usize) {\n     println!(\" Ascending integers:\");\n \n     timed(\"insert\", || {\n-        for i in 0u..n_keys {\n+        for i in 0..n_keys {\n             map.insert(i, i + 1);\n         }\n     });\n \n     timed(\"search\", || {\n-        for i in 0u..n_keys {\n+        for i in 0..n_keys {\n             assert_eq!(map.find(&i).unwrap(), &(i + 1));\n         }\n     });\n@@ -58,7 +58,7 @@ fn ascending<M: MutableMap>(map: &mut M, n_keys: uint) {\n     });\n }\n \n-fn descending<M: MutableMap>(map: &mut M, n_keys: uint) {\n+fn descending<M: MutableMap>(map: &mut M, n_keys: usize) {\n     println!(\" Descending integers:\");\n \n     timed(\"insert\", || {\n@@ -80,32 +80,31 @@ fn descending<M: MutableMap>(map: &mut M, n_keys: uint) {\n     });\n }\n \n-fn vector<M: MutableMap>(map: &mut M, n_keys: uint, dist: &[uint]) {\n+fn vector<M: MutableMap>(map: &mut M, n_keys: usize, dist: &[usize]) {\n     timed(\"insert\", || {\n-        for i in 0u..n_keys {\n+        for i in 0..n_keys {\n             map.insert(dist[i], i + 1);\n         }\n     });\n \n     timed(\"search\", || {\n-        for i in 0u..n_keys {\n+        for i in 0..n_keys {\n             assert_eq!(map.find(&dist[i]).unwrap(), &(i + 1));\n         }\n     });\n \n     timed(\"remove\", || {\n-        for i in 0u..n_keys {\n+        for i in 0..n_keys {\n             assert!(map.remove(&dist[i]));\n         }\n     });\n }\n \n fn main() {\n-    let args = os::args();\n-    let args = args;\n+    let mut args = env::args();\n     let n_keys = {\n         if args.len() == 2 {\n-            args[1].parse::<uint>().unwrap()\n+            args.nth(1).unwrap().parse::<usize>().unwrap()\n         } else {\n             1000000\n         }\n@@ -131,37 +130,37 @@ fn main() {\n     println!(\"{}\", \"\\nBTreeMap:\");\n \n     {\n-        let mut map: BTreeMap<uint,uint> = BTreeMap::new();\n+        let mut map: BTreeMap<usize,usize> = BTreeMap::new();\n         ascending(&mut map, n_keys);\n     }\n \n     {\n-        let mut map: BTreeMap<uint,uint> = BTreeMap::new();\n+        let mut map: BTreeMap<usize,usize> = BTreeMap::new();\n         descending(&mut map, n_keys);\n     }\n \n     {\n         println!(\" Random integers:\");\n-        let mut map: BTreeMap<uint,uint> = BTreeMap::new();\n+        let mut map: BTreeMap<usize,usize> = BTreeMap::new();\n         vector(&mut map, n_keys, &rand);\n     }\n \n     // FIXME: #9970\n     println!(\"{}\", \"\\nHashMap:\");\n \n     {\n-        let mut map: HashMap<uint,uint> = HashMap::new();\n+        let mut map: HashMap<usize,usize> = HashMap::new();\n         ascending(&mut map, n_keys);\n     }\n \n     {\n-        let mut map: HashMap<uint,uint> = HashMap::new();\n+        let mut map: HashMap<usize,usize> = HashMap::new();\n         descending(&mut map, n_keys);\n     }\n \n     {\n         println!(\" Random integers:\");\n-        let mut map: HashMap<uint,uint> = HashMap::new();\n+        let mut map: HashMap<usize,usize> = HashMap::new();\n         vector(&mut map, n_keys, &rand);\n     }\n }"}, {"sha": "1d440c4540ca3e9a1110ac2fe01646659dd372c1", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -20,7 +20,7 @@ use std::collections::BitvSet;\n use std::collections::HashSet;\n use std::collections::hash_map::Hasher;\n use std::hash::Hash;\n-use std::os;\n+use std::env;\n use std::time::Duration;\n \n struct Results {\n@@ -53,29 +53,29 @@ impl<T: Ord> MutableSet<T> for BTreeSet<T> {\n     fn remove(&mut self, k: &T) -> bool { self.remove(k) }\n     fn contains(&self, k: &T) -> bool { self.contains(k) }\n }\n-impl MutableSet<uint> for BitvSet {\n-    fn insert(&mut self, k: uint) { self.insert(k); }\n-    fn remove(&mut self, k: &uint) -> bool { self.remove(k) }\n-    fn contains(&self, k: &uint) -> bool { self.contains(k) }\n+impl MutableSet<usize> for BitvSet {\n+    fn insert(&mut self, k: usize) { self.insert(k); }\n+    fn remove(&mut self, k: &usize) -> bool { self.remove(k) }\n+    fn contains(&self, k: &usize) -> bool { self.contains(k) }\n }\n \n impl Results {\n-    pub fn bench_int<T:MutableSet<uint>,\n+    pub fn bench_int<T:MutableSet<usize>,\n                      R:rand::Rng,\n                      F:FnMut() -> T>(\n                      &mut self,\n                      rng: &mut R,\n-                     num_keys: uint,\n-                     rand_cap: uint,\n+                     num_keys: usize,\n+                     rand_cap: usize,\n                      mut f: F) {\n         {\n             let mut set = f();\n             timed(&mut self.sequential_ints, || {\n-                for i in 0u..num_keys {\n+                for i in 0..num_keys {\n                     set.insert(i);\n                 }\n \n-                for i in 0u..num_keys {\n+                for i in 0..num_keys {\n                     assert!(set.contains(&i));\n                 }\n             })\n@@ -85,19 +85,19 @@ impl Results {\n             let mut set = f();\n             timed(&mut self.random_ints, || {\n                 for _ in 0..num_keys {\n-                    set.insert(rng.gen::<uint>() % rand_cap);\n+                    set.insert(rng.gen::<usize>() % rand_cap);\n                 }\n             })\n         }\n \n         {\n             let mut set = f();\n-            for i in 0u..num_keys {\n+            for i in 0..num_keys {\n                 set.insert(i);\n             }\n \n             timed(&mut self.delete_ints, || {\n-                for i in 0u..num_keys {\n+                for i in 0..num_keys {\n                     assert!(set.remove(&i));\n                 }\n             })\n@@ -109,16 +109,16 @@ impl Results {\n                      F:FnMut() -> T>(\n                      &mut self,\n                      rng: &mut R,\n-                     num_keys: uint,\n+                     num_keys: usize,\n                      mut f: F) {\n         {\n             let mut set = f();\n             timed(&mut self.sequential_strings, || {\n-                for i in 0u..num_keys {\n+                for i in 0..num_keys {\n                     set.insert(i.to_string());\n                 }\n \n-                for i in 0u..num_keys {\n+                for i in 0..num_keys {\n                     assert!(set.contains(&i.to_string()));\n                 }\n             })\n@@ -128,19 +128,19 @@ impl Results {\n             let mut set = f();\n             timed(&mut self.random_strings, || {\n                 for _ in 0..num_keys {\n-                    let s = rng.gen::<uint>().to_string();\n+                    let s = rng.gen::<usize>().to_string();\n                     set.insert(s);\n                 }\n             })\n         }\n \n         {\n             let mut set = f();\n-            for i in 0u..num_keys {\n+            for i in 0..num_keys {\n                 set.insert(i.to_string());\n             }\n             timed(&mut self.delete_strings, || {\n-                for i in 0u..num_keys {\n+                for i in 0..num_keys {\n                     assert!(set.remove(&i.to_string()));\n                 }\n             })\n@@ -179,11 +179,10 @@ fn empty_results() -> Results {\n }\n \n fn main() {\n-    let args = os::args();\n-    let args = args;\n+    let mut args = env::args();\n     let num_keys = {\n         if args.len() == 2 {\n-            args[1].parse::<uint>().unwrap()\n+            args.nth(1).unwrap().parse::<usize>().unwrap()\n         } else {\n             100 // woefully inadequate for any real measurement\n         }\n@@ -196,7 +195,7 @@ fn main() {\n         let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(seed);\n         let mut results = empty_results();\n         results.bench_int(&mut rng, num_keys, max, || {\n-            let s: HashSet<uint> = HashSet::new();\n+            let s: HashSet<usize> = HashSet::new();\n             s\n         });\n         results.bench_str(&mut rng, num_keys, || {\n@@ -210,7 +209,7 @@ fn main() {\n         let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(seed);\n         let mut results = empty_results();\n         results.bench_int(&mut rng, num_keys, max, || {\n-            let s: BTreeSet<uint> = BTreeSet::new();\n+            let s: BTreeSet<usize> = BTreeSet::new();\n             s\n         });\n         results.bench_str(&mut rng, num_keys, || {"}, {"sha": "2409487c04fc10072e225e0fe20676a67918ed52", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -16,7 +16,6 @@\n use std::old_io::File;\n use std::iter::repeat;\n use std::mem::swap;\n-use std::os;\n use std::env;\n use std::rand::Rng;\n use std::rand;\n@@ -25,8 +24,7 @@ use std::time::Duration;\n use std::vec;\n \n fn main() {\n-    let argv = os::args();\n-    let _tests = &argv[1..argv.len()];\n+    let argv: Vec<String> = env::args().collect();\n \n     macro_rules! bench {\n         ($id:ident) =>"}, {"sha": "57889053e3c1b7a4a751451dc48a00677f87cb66", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -8,17 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::os;\n use std::env;\n \n fn main() {\n-    let args = os::args();\n+    let args = env::args();\n     let args = if env::var_os(\"RUST_BENCH\").is_some() {\n         vec!(\"\".to_string(), \"10000000\".to_string())\n     } else if args.len() <= 1u {\n         vec!(\"\".to_string(), \"100000\".to_string())\n     } else {\n-        args.into_iter().collect()\n+        args.collect()\n     };\n \n     let n = args[1].parse().unwrap();"}, {"sha": "208f088442b9b401c4f13c13c0188f71f3d13663", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -19,9 +19,8 @@\n // version.\n \n use std::sync::mpsc::{channel, Sender, Receiver};\n-use std::os;\n use std::env;\n-use std::thread::Thread;\n+use std::thread;\n use std::time::Duration;\n \n fn move_out<T>(_x: T) {}\n@@ -64,15 +63,15 @@ fn run(args: &[String]) {\n         let mut worker_results = Vec::new();\n         for _ in 0u..workers {\n             let to_child = to_child.clone();\n-            worker_results.push(Thread::scoped(move|| {\n+            worker_results.push(thread::spawn(move|| {\n                 for _ in 0u..size / workers {\n                     //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                     to_child.send(request::bytes(num_bytes)).unwrap();\n                 }\n                 //println!(\"worker {} exiting\", i);\n             }));\n         }\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             server(&from_parent, &to_parent);\n         });\n \n@@ -94,13 +93,13 @@ fn run(args: &[String]) {\n }\n \n fn main() {\n-    let args = os::args();\n+    let args = env::args();\n     let args = if env::var_os(\"RUST_BENCH\").is_some() {\n         vec!(\"\".to_string(), \"1000000\".to_string(), \"10000\".to_string())\n-    } else if args.len() <= 1u {\n+    } else if args.len() <= 1 {\n         vec!(\"\".to_string(), \"10000\".to_string(), \"4\".to_string())\n     } else {\n-        args.into_iter().map(|x| x.to_string()).collect()\n+        args.map(|x| x.to_string()).collect()\n     };\n \n     println!(\"{:?}\", args);"}, {"sha": "76b91f0295bb56abbad11b5c2fa6d86d863519ba", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -15,9 +15,8 @@\n // I *think* it's the same, more or less.\n \n use std::sync::mpsc::{channel, Sender, Receiver};\n-use std::os;\n use std::env;\n-use std::thread::Thread;\n+use std::thread;\n use std::time::Duration;\n \n enum request {\n@@ -57,7 +56,7 @@ fn run(args: &[String]) {\n         let mut worker_results = Vec::new();\n         let from_parent = if workers == 1 {\n             let (to_child, from_parent) = channel();\n-            worker_results.push(Thread::scoped(move|| {\n+            worker_results.push(thread::spawn(move|| {\n                 for _ in 0u..size / workers {\n                     //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                     to_child.send(request::bytes(num_bytes));\n@@ -69,7 +68,7 @@ fn run(args: &[String]) {\n             let (to_child, from_parent) = channel();\n             for _ in 0u..workers {\n                 let to_child = to_child.clone();\n-                worker_results.push(Thread::scoped(move|| {\n+                worker_results.push(thread::spawn(move|| {\n                     for _ in 0u..size / workers {\n                         //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                         to_child.send(request::bytes(num_bytes));\n@@ -79,7 +78,7 @@ fn run(args: &[String]) {\n             }\n             from_parent\n         };\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             server(&from_parent, &to_parent);\n         });\n \n@@ -101,13 +100,13 @@ fn run(args: &[String]) {\n }\n \n fn main() {\n-    let args = os::args();\n+    let args = env::args();\n     let args = if env::var_os(\"RUST_BENCH\").is_some() {\n         vec!(\"\".to_string(), \"1000000\".to_string(), \"8\".to_string())\n-    } else if args.len() <= 1u {\n+    } else if args.len() <= 1 {\n         vec!(\"\".to_string(), \"10000\".to_string(), \"4\".to_string())\n     } else {\n-        args.clone().into_iter().map(|x| x.to_string()).collect()\n+        args.map(|x| x.to_string()).collect()\n     };\n \n     println!(\"{:?}\", args);"}, {"sha": "168fe929e12542f79e4a27d5704097a96642f1e2", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -18,7 +18,6 @@\n // no-pretty-expanded FIXME #15189\n // ignore-lexer-test FIXME #15679\n \n-use std::os;\n use std::env;\n use std::sync::{Arc, Future, Mutex, Condvar};\n use std::time::Duration;\n@@ -64,13 +63,13 @@ fn thread_ring(i: uint, count: uint, num_chan: pipe, num_port: pipe) {\n }\n \n fn main() {\n-    let args = os::args();\n+    let args = env::args();\n     let args = if env::var_os(\"RUST_BENCH\").is_some() {\n         vec!(\"\".to_string(), \"100\".to_string(), \"10000\".to_string())\n-    } else if args.len() <= 1u {\n+    } else if args.len() <= 1 {\n         vec!(\"\".to_string(), \"10\".to_string(), \"100\".to_string())\n     } else {\n-        args.clone().into_iter().collect()\n+        args.collect()\n     };\n \n     let num_tasks = args[1].parse::<uint>().unwrap();"}, {"sha": "b9512324e42d6426a5c92908c4a4825eb91fb7a4", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -18,32 +18,32 @@\n // except according to those terms.\n \n use std::sync::mpsc::channel;\n-use std::os;\n-use std::thread::Thread;\n+use std::env;\n+use std::thread;\n \n // This is a simple bench that creates M pairs of tasks. These\n // tasks ping-pong back and forth over a pair of streams. This is a\n // canonical message-passing benchmark as it heavily strains message\n // passing and almost nothing else.\n \n-fn ping_pong_bench(n: uint, m: uint) {\n+fn ping_pong_bench(n: usize, m: usize) {\n \n     // Create pairs of tasks that pingpong back and forth.\n-    fn run_pair(n: uint) {\n+    fn run_pair(n: usize) {\n         // Create a channel: A->B\n         let (atx, arx) = channel();\n         // Create a channel: B->A\n         let (btx, brx) = channel();\n \n-        let guard_a = Thread::scoped(move|| {\n+        let guard_a = thread::spawn(move|| {\n             let (tx, rx) = (atx, brx);\n             for _ in 0..n {\n                 tx.send(()).unwrap();\n                 rx.recv().unwrap();\n             }\n         });\n \n-        let guard_b = Thread::scoped(move|| {\n+        let guard_b = thread::spawn(move|| {\n             let (tx, rx) = (btx, arx);\n             for _ in 0..n {\n                 rx.recv().unwrap();\n@@ -63,19 +63,13 @@ fn ping_pong_bench(n: uint, m: uint) {\n \n \n fn main() {\n-\n-    let args = os::args();\n-    let args = args;\n-    let n = if args.len() == 3 {\n-        args[1].parse::<uint>().unwrap()\n-    } else {\n-        10000\n-    };\n-\n-    let m = if args.len() == 3 {\n-        args[2].parse::<uint>().unwrap()\n+    let mut args = env::args();\n+    let (n, m) = if args.len() == 3 {\n+        let n = args.nth(1).unwrap().parse::<usize>().unwrap();\n+        let m = args.next().unwrap().parse::<usize>().unwrap();\n+        (n, m)\n     } else {\n-        4\n+        (10000, 4)\n     };\n \n     ping_pong_bench(n, m);"}, {"sha": "d420023cf0059eacb92a27f458d0b8dfde1ef4b5", "filename": "src/test/bench/rt-parfib.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Frt-parfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Frt-parfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-parfib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -9,32 +9,30 @@\n // except according to those terms.\n \n use std::sync::mpsc::channel;\n-use std::os;\n-use std::thread::Thread;\n+use std::env;\n+use std::thread;\n \n // A simple implementation of parfib. One subtree is found in a new\n // task and communicated over a oneshot pipe, the other is found\n // locally. There is no sequential-mode threshold.\n \n-fn parfib(n: uint) -> uint {\n+fn parfib(n: u64) -> u64 {\n     if n == 0 || n == 1 {\n         return 1;\n     }\n \n     let (tx, rx) = channel();\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         tx.send(parfib(n-1)).unwrap();\n     });\n     let m2 = parfib(n-2);\n     return rx.recv().unwrap() + m2;\n }\n \n fn main() {\n-\n-    let args = os::args();\n-    let args = args;\n+    let mut args = env::args();\n     let n = if args.len() == 2 {\n-        args[1].parse::<uint>().unwrap()\n+        args.nth(1).unwrap().parse::<u64>().unwrap()\n     } else {\n         10\n     };"}, {"sha": "d07aa8850aa8306c4ca22d200db5d3a385a3d7e2", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::os;\n use std::env;\n \n-fn ack(m: int, n: int) -> int {\n+fn ack(m: i64, n: i64) -> i64 {\n     if m == 0 {\n         return n + 1\n     } else {\n@@ -24,13 +23,13 @@ fn ack(m: int, n: int) -> int {\n }\n \n fn main() {\n-    let args = os::args();\n+    let mut args = env::args();\n     let args = if env::var_os(\"RUST_BENCH\").is_some() {\n         vec!(\"\".to_string(), \"12\".to_string())\n-    } else if args.len() <= 1u {\n+    } else if args.len() <= 1 {\n         vec!(\"\".to_string(), \"8\".to_string())\n     } else {\n-        args.into_iter().collect()\n+        args.collect()\n     };\n     let n = args[1].parse().unwrap();\n     println!(\"Ack(3,{}): {}\\n\", n, ack(3, n));"}, {"sha": "1e23da3020f277b7262145bab28a0c3216e010a5", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -41,7 +41,7 @@\n extern crate arena;\n \n use std::iter::range_step;\n-use std::thread::{Thread, JoinGuard};\n+use std::thread;\n use arena::TypedArena;\n \n struct Tree<'a> {\n@@ -84,14 +84,13 @@ fn inner(depth: i32, iterations: i32) -> String {\n }\n \n fn main() {\n-    let args = std::os::args();\n-    let args = args;\n+    let mut args = std::env::args();\n     let n = if std::env::var_os(\"RUST_BENCH\").is_some() {\n         17\n-    } else if args.len() <= 1u {\n+    } else if args.len() <= 1 {\n         8\n     } else {\n-        args[1].parse().unwrap()\n+        args.nth(1).unwrap().parse().unwrap()\n     };\n     let min_depth = 4;\n     let max_depth = if min_depth + 2 > n {min_depth + 2} else {n};\n@@ -111,11 +110,11 @@ fn main() {\n     let messages = range_step(min_depth, max_depth + 1, 2).map(|depth| {\n         use std::num::Int;\n         let iterations = 2.pow((max_depth - depth + min_depth) as usize);\n-        Thread::scoped(move || inner(depth, iterations))\n+        thread::scoped(move || inner(depth, iterations))\n     }).collect::<Vec<_>>();\n \n     for message in messages {\n-        println!(\"{}\", message.join().ok().unwrap());\n+        println!(\"{}\", message.join());\n     }\n \n     println!(\"long lived tree of depth {}\\t check: {}\","}, {"sha": "5bd1e91ae14e432776ec859418e4e7dd3fb2e825", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -43,7 +43,7 @@\n use self::Color::{Red, Yellow, Blue};\n use std::sync::mpsc::{channel, Sender, Receiver};\n use std::fmt;\n-use std::thread::Thread;\n+use std::thread;\n \n fn print_complements() {\n     let all = [Blue, Red, Yellow];\n@@ -187,7 +187,7 @@ fn rendezvous(nn: uint, set: Vec<Color>) {\n             let to_rendezvous = to_rendezvous.clone();\n             let to_rendezvous_log = to_rendezvous_log.clone();\n             let (to_creature, from_rendezvous) = channel();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 creature(ii,\n                          col,\n                          from_rendezvous,\n@@ -230,10 +230,10 @@ fn main() {\n     let nn = if std::env::var_os(\"RUST_BENCH\").is_some() {\n         200000\n     } else {\n-        std::os::args()\n-                       .get(1)\n+        std::env::args()\n+                       .nth(1)\n                        .and_then(|arg| arg.parse().ok())\n-                       .unwrap_or(600u)\n+                       .unwrap_or(600us)\n     };\n \n     print_complements();"}, {"sha": "f7de935d08fdd3b67fcfc13d264a66154d48a8bf", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -39,7 +39,7 @@\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n use std::{cmp, iter, mem};\n-use std::thread::Thread;\n+use std::thread;\n \n fn rotate(x: &mut [i32]) {\n     let mut prev = x[0];\n@@ -164,24 +164,24 @@ fn fannkuch(n: i32) -> (i32, i32) {\n     for (_, j) in (0..N).zip(iter::count(0, k)) {\n         let max = cmp::min(j+k, perm.max());\n \n-        futures.push(Thread::scoped(move|| {\n+        futures.push(thread::scoped(move|| {\n             work(perm, j as uint, max as uint)\n         }))\n     }\n \n     let mut checksum = 0;\n     let mut maxflips = 0;\n     for fut in futures {\n-        let (cs, mf) = fut.join().ok().unwrap();\n+        let (cs, mf) = fut.join();\n         checksum += cs;\n         maxflips = cmp::max(maxflips, mf);\n     }\n     (checksum, maxflips)\n }\n \n fn main() {\n-    let n = std::os::args()\n-        .get(1)\n+    let n = std::env::args()\n+        .nth(1)\n         .and_then(|arg| arg.parse().ok())\n         .unwrap_or(2i32);\n "}, {"sha": "277c3ee73dff1aa8693eb4154292a13d85c8822a", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -41,11 +41,11 @@\n use std::cmp::min;\n use std::old_io::{stdout, IoResult};\n use std::iter::repeat;\n-use std::os;\n+use std::env;\n use std::slice::bytes::copy_memory;\n \n-const LINE_LEN: uint = 60;\n-const LOOKUP_SIZE: uint = 4 * 1024;\n+const LINE_LEN: usize = 60;\n+const LOOKUP_SIZE: usize = 4 * 1024;\n const LOOKUP_SCALE: f32 = (LOOKUP_SIZE - 1) as f32;\n \n // Random number generator constants\n@@ -119,7 +119,7 @@ impl<'a, W: Writer> RepeatFasta<'a, W> {\n         RepeatFasta { alu: alu, out: w }\n     }\n \n-    fn make(&mut self, n: uint) -> IoResult<()> {\n+    fn make(&mut self, n: usize) -> IoResult<()> {\n         let alu_len = self.alu.len();\n         let mut buf = repeat(0u8).take(alu_len + LINE_LEN).collect::<Vec<_>>();\n         let alu: &[u8] = self.alu.as_bytes();\n@@ -188,30 +188,29 @@ impl<'a, W: Writer> RandomFasta<'a, W> {\n         0\n     }\n \n-    fn make(&mut self, n: uint) -> IoResult<()> {\n+    fn make(&mut self, n: usize) -> IoResult<()> {\n         let lines = n / LINE_LEN;\n         let chars_left = n % LINE_LEN;\n         let mut buf = [0;LINE_LEN + 1];\n \n         for _ in 0..lines {\n-            for i in 0u..LINE_LEN {\n+            for i in 0..LINE_LEN {\n                 buf[i] = self.nextc();\n             }\n             buf[LINE_LEN] = '\\n' as u8;\n             try!(self.out.write(&buf));\n         }\n-        for i in 0u..chars_left {\n+        for i in 0..chars_left {\n             buf[i] = self.nextc();\n         }\n         self.out.write(&buf[..chars_left])\n     }\n }\n \n fn main() {\n-    let args = os::args();\n-    let args = args;\n+    let mut args = env::args();\n     let n = if args.len() > 1 {\n-        args[1].parse::<uint>().unwrap()\n+        args.nth(1).unwrap().parse::<usize>().unwrap()\n     } else {\n         5\n     };"}, {"sha": "fd559608011afdcbb851eb7643b30e74386abf86", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -42,10 +42,9 @@ use std::cmp::min;\n use std::old_io::{BufferedWriter, File};\n use std::old_io;\n use std::num::Float;\n-use std::os;\n use std::env;\n \n-const LINE_LENGTH: uint = 60;\n+const LINE_LENGTH: usize = 60;\n const IM: u32 = 139968;\n \n struct MyRandom {\n@@ -86,7 +85,7 @@ impl<'a> Iterator for AAGen<'a> {\n }\n \n fn make_fasta<W: Writer, I: Iterator<Item=u8>>(\n-    wr: &mut W, header: &str, mut it: I, mut n: uint)\n+    wr: &mut W, header: &str, mut it: I, mut n: usize)\n     -> std::old_io::IoResult<()>\n {\n     try!(wr.write(header.as_bytes()));\n@@ -104,14 +103,13 @@ fn make_fasta<W: Writer, I: Iterator<Item=u8>>(\n }\n \n fn run<W: Writer>(writer: &mut W) -> std::old_io::IoResult<()> {\n-    let args = os::args();\n-    let args = args;\n+    let mut args = env::args();\n     let n = if env::var_os(\"RUST_BENCH\").is_some() {\n         25000000\n-    } else if args.len() <= 1u {\n+    } else if args.len() <= 1 {\n         1000\n     } else {\n-        args[1].parse().unwrap()\n+        args.nth(1).unwrap().parse().unwrap()\n     };\n \n     let rng = &mut MyRandom::new();"}, {"sha": "6f9c775609af5ee6a3fd03d484140fb9753420fc", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::os;\n use std::env;\n \n-fn fib(n: int) -> int {\n+fn fib(n: i64) -> i64 {\n     if n < 2 {\n         return 1;\n     } else {\n@@ -20,13 +19,13 @@ fn fib(n: int) -> int {\n }\n \n fn main() {\n-    let args = os::args();\n+    let args = env::args();\n     let args = if env::var_os(\"RUST_BENCH\").is_some() {\n         vec!(\"\".to_string(), \"40\".to_string())\n-    } else if args.len() <= 1u {\n+    } else if args.len() <= 1 {\n         vec!(\"\".to_string(), \"30\".to_string())\n     } else {\n-        args.into_iter().collect()\n+        args.collect()\n     };\n     let n = args[1].parse().unwrap();\n     println!(\"{}\\n\", fib(n));"}, {"sha": "4d6ef3d533e3f96e3cd9c784d27bfe21e37cf10d", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -24,7 +24,7 @@ use std::option;\n use std::os;\n use std::env;\n use std::sync::mpsc::{channel, Sender, Receiver};\n-use std::thread::Thread;\n+use std::thread;\n \n fn f64_cmp(x: f64, y: f64) -> Ordering {\n     // arbitrarily decide that NaNs are larger than everything.\n@@ -172,7 +172,7 @@ fn main() {\n \n         let (to_child, from_parent) = channel();\n \n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             make_sequence_processor(sz, &from_parent, &to_parent_);\n         });\n "}, {"sha": "b5c460737b86cbdf71149c152d310d35636c34e3", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -45,7 +45,7 @@\n use std::ascii::OwnedAsciiExt;\n use std::slice;\n use std::sync::Arc;\n-use std::thread::Thread;\n+use std::thread;\n \n static TABLE: [u8;4] = [ 'A' as u8, 'C' as u8, 'G' as u8, 'T' as u8 ];\n static TABLE_SIZE: uint = 2 << 16;\n@@ -303,17 +303,17 @@ fn main() {\n \n     let nb_freqs: Vec<_> = (1u..3).map(|i| {\n         let input = input.clone();\n-        (i, Thread::scoped(move|| generate_frequencies(&input, i)))\n+        (i, thread::scoped(move|| generate_frequencies(&input, i)))\n     }).collect();\n     let occ_freqs: Vec<_> = OCCURRENCES.iter().map(|&occ| {\n         let input = input.clone();\n-        Thread::scoped(move|| generate_frequencies(&input, occ.len()))\n+        thread::scoped(move|| generate_frequencies(&input, occ.len()))\n     }).collect();\n \n     for (i, freq) in nb_freqs {\n-        print_frequencies(&freq.join().ok().unwrap(), i);\n+        print_frequencies(&freq.join(), i);\n     }\n     for (&occ, freq) in OCCURRENCES.iter().zip(occ_freqs.into_iter()) {\n-        print_occurrences(&mut freq.join().ok().unwrap(), occ);\n+        print_occurrences(&mut freq.join(), occ);\n     }\n }"}, {"sha": "bddf615322816d40e1212465d46b01e9d2503be0", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -43,10 +43,10 @@\n // ignore-pretty very bad with line comments\n \n use std::old_io;\n-use std::os;\n+use std::env;\n use std::simd::f64x2;\n use std::sync::Arc;\n-use std::thread::Thread;\n+use std::thread;\n \n const ITER: usize = 50;\n const LIMIT: f64 = 2.0;\n@@ -81,7 +81,7 @@ fn mandelbrot<W: old_io::Writer>(w: usize, mut out: W) -> old_io::IoResult<()> {\n     let mut precalc_i = Vec::with_capacity(h);\n \n     let precalc_futures = (0..WORKERS).map(|i| {\n-        Thread::scoped(move|| {\n+        thread::scoped(move|| {\n             let mut rs = Vec::with_capacity(w / WORKERS);\n             let mut is = Vec::with_capacity(w / WORKERS);\n \n@@ -107,7 +107,7 @@ fn mandelbrot<W: old_io::Writer>(w: usize, mut out: W) -> old_io::IoResult<()> {\n     }).collect::<Vec<_>>();\n \n     for res in precalc_futures {\n-        let (rs, is) = res.join().ok().unwrap();\n+        let (rs, is) = res.join();\n         precalc_r.extend(rs.into_iter());\n         precalc_i.extend(is.into_iter());\n     }\n@@ -122,7 +122,7 @@ fn mandelbrot<W: old_io::Writer>(w: usize, mut out: W) -> old_io::IoResult<()> {\n         let vec_init_r = arc_init_r.clone();\n         let vec_init_i = arc_init_i.clone();\n \n-        Thread::scoped(move|| {\n+        thread::scoped(move|| {\n             let mut res: Vec<u8> = Vec::with_capacity((chunk_size * w) / 8);\n             let init_r_slice = vec_init_r;\n \n@@ -143,7 +143,7 @@ fn mandelbrot<W: old_io::Writer>(w: usize, mut out: W) -> old_io::IoResult<()> {\n \n     try!(writeln!(&mut out as &mut Writer, \"P4\\n{} {}\", w, h));\n     for res in data {\n-        try!(out.write(&res.join().ok().unwrap()));\n+        try!(out.write(&res.join()));\n     }\n     out.flush()\n }\n@@ -197,13 +197,13 @@ fn write_line(init_i: f64, vec_init_r: &[f64], res: &mut Vec<u8>) {\n }\n \n fn main() {\n-    let args = os::args();\n+    let mut args = env::args();\n     let res = if args.len() < 2 {\n         println!(\"Test mode: do not dump the image because it's not utf8, \\\n                   which interferes with the test runner.\");\n         mandelbrot(1000, old_io::util::NullWriter)\n     } else {\n-        mandelbrot(args[1].parse().unwrap(), old_io::stdout())\n+        mandelbrot(args.nth(1).unwrap().parse().unwrap(), old_io::stdout())\n     };\n     res.unwrap();\n }"}, {"sha": "a9c4bb99a0ed15f5b13363cba37a2b5f3382b797", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -43,7 +43,7 @@\n use std::iter::repeat;\n use std::sync::Arc;\n use std::sync::mpsc::channel;\n-use std::thread::Thread;\n+use std::thread;\n \n //\n // Utilities.\n@@ -317,7 +317,7 @@ fn par_search(masks: Vec<Vec<Vec<u64>>>) -> Data {\n         let masks = masks.clone();\n         let tx = tx.clone();\n         let m = *m;\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut data = Data::new();\n             search(&*masks, m, 1, List::Cons(m, &List::Nil), &mut data);\n             tx.send(data).unwrap();"}, {"sha": "534dfe9548c2f73a5275abc4205b6028c5623c6f", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -173,7 +173,7 @@ fn main() {\n     let n = if std::env::var_os(\"RUST_BENCH\").is_some() {\n         5000000\n     } else {\n-        std::os::args().get(1)\n+        std::env::args().nth(1)\n             .and_then(|arg| arg.parse().ok())\n             .unwrap_or(1000)\n     };"}, {"sha": "a542c81f2394ea2523717305de5956469606a2a9", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -21,30 +21,29 @@\n extern crate getopts;\n \n use std::sync::mpsc::{channel, Sender};\n-use std::os;\n use std::env;\n use std::result::Result::{Ok, Err};\n-use std::thread::Thread;\n+use std::thread;\n use std::time::Duration;\n \n-fn fib(n: int) -> int {\n-    fn pfib(tx: &Sender<int>, n: int) {\n+fn fib(n: isize) -> isize {\n+    fn pfib(tx: &Sender<isize>, n: isize) {\n         if n == 0 {\n             tx.send(0).unwrap();\n         } else if n <= 2 {\n             tx.send(1).unwrap();\n         } else {\n             let (tx1, rx) = channel();\n             let tx2 = tx1.clone();\n-            Thread::spawn(move|| pfib(&tx2, n - 1));\n+            thread::spawn(move|| pfib(&tx2, n - 1));\n             let tx2 = tx1.clone();\n-            Thread::spawn(move|| pfib(&tx2, n - 2));\n+            thread::spawn(move|| pfib(&tx2, n - 2));\n             tx.send(rx.recv().unwrap() + rx.recv().unwrap());\n         }\n     }\n \n     let (tx, rx) = channel();\n-    Thread::spawn(move|| pfib(&tx, n) );\n+    thread::spawn(move|| pfib(&tx, n) );\n     rx.recv().unwrap()\n }\n \n@@ -66,7 +65,7 @@ fn parse_opts(argv: Vec<String> ) -> Config {\n     }\n }\n \n-fn stress_task(id: int) {\n+fn stress_task(id: isize) {\n     let mut i = 0;\n     loop {\n         let n = 15;\n@@ -79,7 +78,7 @@ fn stress_task(id: int) {\n fn stress(num_tasks: int) {\n     let mut results = Vec::new();\n     for i in 0..num_tasks {\n-        results.push(Thread::scoped(move|| {\n+        results.push(thread::spawn(move|| {\n             stress_task(i);\n         }));\n     }\n@@ -89,26 +88,26 @@ fn stress(num_tasks: int) {\n }\n \n fn main() {\n-    let args = os::args();\n+    let args = env::args();\n     let args = if env::var_os(\"RUST_BENCH\").is_some() {\n         vec!(\"\".to_string(), \"20\".to_string())\n-    } else if args.len() <= 1u {\n+    } else if args.len() <= 1 {\n         vec!(\"\".to_string(), \"8\".to_string())\n     } else {\n-        args.into_iter().map(|x| x.to_string()).collect()\n+        args.map(|x| x.to_string()).collect()\n     };\n \n     let opts = parse_opts(args.clone());\n \n     if opts.stress {\n         stress(2);\n     } else {\n-        let max = args[1].parse::<int>().unwrap();\n+        let max = args[1].parse::<isize>().unwrap();\n \n         let num_trials = 10;\n \n         for n in 1..max + 1 {\n-            for _ in 0u..num_trials {\n+            for _ in 0..num_trials {\n                 let mut fibn = None;\n                 let dur = Duration::span(|| fibn = Some(fib(n)));\n                 let fibn = fibn.unwrap();"}, {"sha": "33d959dfe93e35f592320a4913dd69d3c7c3a313", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -47,7 +47,7 @@ extern crate libc;\n use std::old_io::stdio::{stdin_raw, stdout_raw};\n use std::old_io::{IoResult, EndOfFile};\n use std::ptr::{copy_memory, Unique};\n-use std::thread::Thread;\n+use std::thread;\n \n struct Tables {\n     table8: [u8;1 << 8],\n@@ -229,21 +229,12 @@ unsafe impl<T: 'static> Send for Racy<T> {}\n \n /// Executes a closure in parallel over the given iterator over mutable slice.\n /// The closure `f` is run in parallel with an element of `iter`.\n-fn parallel<'a, I, T, F>(iter: I, f: F)\n-        where T: 'a+Send + Sync,\n-              I: Iterator<Item=&'a mut [T]>,\n-              F: Fn(&mut [T]) + Sync {\n-    use std::mem;\n-    use std::raw::Repr;\n-\n-    iter.map(|chunk| {\n-        // Need to convert `f` and `chunk` to something that can cross the task\n-        // boundary.\n-        let f = Racy(&f as *const F as *const uint);\n-        let raw = Racy(chunk.repr());\n-        Thread::scoped(move|| {\n-            let f = f.0 as *const F;\n-            unsafe { (*f)(mem::transmute(raw.0)) }\n+fn parallel<'a, I: Iterator, F>(iter: I, ref f: F)\n+        where I::Item: Send + 'a,\n+              F: Fn(I::Item) + Sync + 'a {\n+    iter.map(|x| {\n+        thread::scoped(move|| {\n+            f(x)\n         })\n     }).collect::<Vec<_>>();\n }"}, {"sha": "76ba5acb16ce4718b0523d1211672b87eec74b8b", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -44,7 +44,7 @@\n #![feature(unboxed_closures)]\n \n use std::iter::{repeat, AdditiveIterator};\n-use std::thread::Thread;\n+use std::thread;\n use std::mem;\n use std::num::Float;\n use std::os;\n@@ -53,13 +53,13 @@ use std::raw::Repr;\n use std::simd::f64x2;\n \n fn main() {\n-    let args = os::args();\n+    let mut args = env::args();\n     let answer = spectralnorm(if env::var_os(\"RUST_BENCH\").is_some() {\n         5500\n     } else if args.len() < 2 {\n         2000\n     } else {\n-        args[1].parse().unwrap()\n+        args.nth(1).unwrap().parse().unwrap()\n     });\n     println!(\"{:.9}\", answer);\n }\n@@ -112,26 +112,16 @@ fn dot(v: &[f64], u: &[f64]) -> f64 {\n }\n \n \n-struct Racy<T>(T);\n-\n-unsafe impl<T: 'static> Send for Racy<T> {}\n-\n // Executes a closure in parallel over the given mutable slice. The closure `f`\n // is run in parallel and yielded the starting index within `v` as well as a\n // sub-slice of `v`.\n-fn parallel<T, F>(v: &mut [T], f: F)\n-                  where T: Send + Sync,\n-                        F: Fn(uint, &mut [T]) + Sync {\n+fn parallel<'a,T, F>(v: &mut [T], ref f: F)\n+                  where T: Send + Sync + 'a,\n+                        F: Fn(uint, &mut [T]) + Sync + 'a {\n     let size = v.len() / os::num_cpus() + 1;\n-\n     v.chunks_mut(size).enumerate().map(|(i, chunk)| {\n-        // Need to convert `f` and `chunk` to something that can cross the task\n-        // boundary.\n-        let f = Racy(&f as *const _ as *const uint);\n-        let raw = Racy(chunk.repr());\n-        Thread::scoped(move|| {\n-            let f = f.0 as *const F;\n-            unsafe { (*f)(i * size, mem::transmute(raw.0)) }\n+        thread::scoped(move|| {\n+            f(i * size, chunk)\n         })\n     }).collect::<Vec<_>>();\n }"}, {"sha": "2653e758a487d256666700f2f7993bc63136902b", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -39,7 +39,7 @@\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n use std::sync::mpsc::{channel, Sender, Receiver};\n-use std::thread::Thread;\n+use std::thread;\n \n fn start(n_tasks: i32, token: i32) {\n     let (tx, mut rx) = channel();\n@@ -48,9 +48,9 @@ fn start(n_tasks: i32, token: i32) {\n     for i in 2 .. n_tasks + 1 {\n         let (tx, next_rx) = channel();\n         let cur_rx = std::mem::replace(&mut rx, next_rx);\n-        guards.push(Thread::scoped(move|| roundtrip(i, tx, cur_rx)));\n+        guards.push(thread::spawn(move|| roundtrip(i, tx, cur_rx)));\n     }\n-    let guard = Thread::scoped(move|| roundtrip(1, tx, rx));\n+    let guard = thread::spawn(move|| roundtrip(1, tx, rx));\n }\n \n fn roundtrip(id: i32, tx: Sender<i32>, rx: Receiver<i32>) {\n@@ -64,13 +64,13 @@ fn roundtrip(id: i32, tx: Sender<i32>, rx: Receiver<i32>) {\n }\n \n fn main() {\n-    let args = std::os::args();\n+    let mut args = std::env::args();\n     let token = if std::env::var_os(\"RUST_BENCH\").is_some() {\n         2000000\n     } else {\n-        args.get(1).and_then(|arg| arg.parse().ok()).unwrap_or(1000)\n+        args.nth(1).and_then(|arg| arg.parse().ok()).unwrap_or(1000)\n     };\n-    let n_tasks = args.get(2)\n+    let n_tasks = args.next()\n                       .and_then(|arg| arg.parse().ok())\n                       .unwrap_or(503);\n "}, {"sha": "a54a869412e35483529c1cd943cf6c423e7e298f", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -11,41 +11,40 @@\n // Microbenchmark for the smallintmap library\n \n use std::collections::VecMap;\n-use std::os;\n use std::env;\n use std::time::Duration;\n \n-fn append_sequential(min: uint, max: uint, map: &mut VecMap<uint>) {\n+fn append_sequential(min: usize, max: usize, map: &mut VecMap<usize>) {\n     for i in min..max {\n-        map.insert(i, i + 22u);\n+        map.insert(i, i + 22);\n     }\n }\n \n-fn check_sequential(min: uint, max: uint, map: &VecMap<uint>) {\n+fn check_sequential(min: usize, max: usize, map: &VecMap<usize>) {\n     for i in min..max {\n-        assert_eq!(map[i], i + 22u);\n+        assert_eq!(map[i], i + 22);\n     }\n }\n \n fn main() {\n-    let args = os::args();\n+    let args = env::args();\n     let args = if env::var_os(\"RUST_BENCH\").is_some() {\n         vec!(\"\".to_string(), \"100000\".to_string(), \"100\".to_string())\n-    } else if args.len() <= 1u {\n+    } else if args.len() <= 1 {\n         vec!(\"\".to_string(), \"10000\".to_string(), \"50\".to_string())\n     } else {\n-        args.into_iter().collect()\n+        args.collect()\n     };\n-    let max = args[1].parse::<uint>().unwrap();\n-    let rep = args[2].parse::<uint>().unwrap();\n+    let max = args[1].parse::<usize>().unwrap();\n+    let rep = args[2].parse::<usize>().unwrap();\n \n     let mut checkf = Duration::seconds(0);\n     let mut appendf = Duration::seconds(0);\n \n-    for _ in 0u..rep {\n+    for _ in 0..rep {\n         let mut map = VecMap::new();\n-        let d1 = Duration::span(|| append_sequential(0u, max, &mut map));\n-        let d2 = Duration::span(|| check_sequential(0u, max, &map));\n+        let d1 = Duration::span(|| append_sequential(0, max, &mut map));\n+        let d2 = Duration::span(|| check_sequential(0, max, &map));\n \n         checkf = checkf + d2;\n         appendf = appendf + d1;"}, {"sha": "ada8efcbf38e15a90090f64bc35e33b5932fac99", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -18,7 +18,7 @@ use std::old_io::stdio::StdReader;\n use std::old_io;\n use std::iter::repeat;\n use std::num::Int;\n-use std::os;\n+use std::env;\n \n // Computes a single solution to a given 9x9 sudoku\n //\n@@ -269,8 +269,8 @@ fn check_DEFAULT_SUDOKU_solution() {\n }\n \n fn main() {\n-    let args        = os::args();\n-    let use_default = args.len() == 1u;\n+    let args        = env::args();\n+    let use_default = args.len() == 1;\n     let mut sudoku = if use_default {\n         Sudoku::from_vec(&DEFAULT_SUDOKU)\n     } else {"}, {"sha": "6b412c47cd7f81bdf9d0713f8818dbd84aaa1471", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -11,7 +11,7 @@\n #![feature(unsafe_destructor, box_syntax)]\n \n use std::env;\n-use std::thread::Thread;\n+use std::thread;\n use std::time::Duration;\n \n #[derive(Clone)]\n@@ -32,7 +32,7 @@ fn main() {\n fn run(repeat: int, depth: int) {\n     for _ in 0..repeat {\n         let dur = Duration::span(|| {\n-            let _ = Thread::scoped(move|| {\n+            let _ = thread::spawn(move|| {\n                 recurse_or_panic(depth, None)\n             }).join();\n         });"}, {"sha": "e36d685d7c6ea9b73f85d29b147510ec1fc69030", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -18,17 +18,16 @@\n // ignore-pretty very bad with line comments\n \n use std::sync::mpsc::{channel, Sender};\n-use std::os;\n use std::env;\n-use std::thread::Thread;\n+use std::thread;\n \n fn child_generation(gens_left: uint, tx: Sender<()>) {\n     // This used to be O(n^2) in the number of generations that ever existed.\n     // With this code, only as many generations are alive at a time as tasks\n     // alive at a time,\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         if gens_left & 1 == 1 {\n-            Thread::yield_now(); // shake things up a bit\n+            thread::yield_now(); // shake things up a bit\n         }\n         if gens_left > 0 {\n             child_generation(gens_left - 1, tx); // recurse\n@@ -39,13 +38,13 @@ fn child_generation(gens_left: uint, tx: Sender<()>) {\n }\n \n fn main() {\n-    let args = os::args();\n+    let args = env::args();\n     let args = if env::var_os(\"RUST_BENCH\").is_some() {\n         vec!(\"\".to_string(), \"100000\".to_string())\n     } else if args.len() <= 1 {\n         vec!(\"\".to_string(), \"100\".to_string())\n     } else {\n-        args.clone().into_iter().collect()\n+        args.collect()\n     };\n \n     let (tx, rx) = channel();"}, {"sha": "69b9e89dbc5228c42f3d7f9363ce60397ee499dc", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -8,30 +8,29 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::os;\n use std::env;\n-use std::thread::Thread;\n+use std::thread;\n \n-fn f(n: uint) {\n+fn f(n: usize) {\n     let mut i = 0u;\n     while i < n {\n-        let _ = Thread::scoped(move|| g()).join();\n+        let _ = thread::spawn(move|| g()).join();\n         i += 1u;\n     }\n }\n \n fn g() { }\n \n fn main() {\n-    let args = os::args();\n+    let args = env::args();\n     let args = if env::var_os(\"RUST_BENCH\").is_some() {\n         vec!(\"\".to_string(), \"400\".to_string())\n-    } else if args.len() <= 1u {\n+    } else if args.len() <= 1 {\n         vec!(\"\".to_string(), \"10\".to_string())\n     } else {\n-        args.into_iter().collect()\n+        args.collect()\n     };\n     let n = args[1].parse().unwrap();\n-    let mut i = 0u;\n-    while i < n { Thread::spawn(move|| f(n) ); i += 1u; }\n+    let mut i = 0;\n+    while i < n { thread::spawn(move|| f(n) ); i += 1; }\n }"}, {"sha": "d2ee01109f8d8f577d97db9727f3c2d3c089f398", "filename": "src/test/compile-fail/asm-gated2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fasm-gated2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fasm-gated2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-gated2.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    unsafe {\n+        println!(\"{}\", asm!(\"\")); //~ ERROR inline assembly is not stable\n+    }\n+}"}, {"sha": "7f676f5166f7f77fb77129553870257313bc66ac", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(box_syntax)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n fn borrow<F>(v: &isize, f: F) where F: FnOnce(&isize) {\n     f(v);\n@@ -19,7 +19,7 @@ fn borrow<F>(v: &isize, f: F) where F: FnOnce(&isize) {\n fn box_imm() {\n     let v = box 3;\n     let _w = &v;\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         println!(\"v={}\", *v);\n         //~^ ERROR cannot move `v` into closure\n     });\n@@ -28,7 +28,7 @@ fn box_imm() {\n fn box_imm_explicit() {\n     let v = box 3;\n     let _w = &v;\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         println!(\"v={}\", *v);\n         //~^ ERROR cannot move\n     });"}, {"sha": "9db05d76284e8d23cdc1660fb9e834e3310a9f2f", "filename": "src/test/compile-fail/borrowck-multiple-captures.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fborrowck-multiple-captures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fborrowck-multiple-captures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-multiple-captures.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(box_syntax)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n fn borrow<T>(_: &T) { }\n \n@@ -19,7 +19,7 @@ fn different_vars_after_borrows() {\n     let p1 = &x1;\n     let x2 = box 2;\n     let p2 = &x2;\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         drop(x1); //~ ERROR cannot move `x1` into closure because it is borrowed\n         drop(x2); //~ ERROR cannot move `x2` into closure because it is borrowed\n     });\n@@ -32,7 +32,7 @@ fn different_vars_after_moves() {\n     drop(x1);\n     let x2 = box 2;\n     drop(x2);\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         drop(x1); //~ ERROR capture of moved value: `x1`\n         drop(x2); //~ ERROR capture of moved value: `x2`\n     });\n@@ -41,7 +41,7 @@ fn different_vars_after_moves() {\n fn same_var_after_borrow() {\n     let x = box 1;\n     let p = &x;\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         drop(x); //~ ERROR cannot move `x` into closure because it is borrowed\n         drop(x); //~ ERROR use of moved value: `x`\n     });\n@@ -51,7 +51,7 @@ fn same_var_after_borrow() {\n fn same_var_after_move() {\n     let x = box 1;\n     drop(x);\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         drop(x); //~ ERROR capture of moved value: `x`\n         drop(x); //~ ERROR use of moved value: `x`\n     });"}, {"sha": "c3fb6a1be8797a811819022975446ca9fabf5711", "filename": "src/test/compile-fail/builtin-superkinds-simple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -13,7 +13,7 @@\n \n trait Foo : Send { }\n \n-impl <'a> Foo for &'a mut () { }\n-//~^ ERROR the type `&'a mut ()` does not fulfill the required lifetime\n+impl Foo for std::rc::Rc<i8> { }\n+//~^ ERROR the trait `core::marker::Send` is not implemented\n \n fn main() { }"}, {"sha": "38730d241f68532b43f35c2dc15f3d1177c46d67", "filename": "src/test/compile-fail/coherence-impls-builtin.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-builtin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-builtin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-builtin.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(optin_builtin_traits)]\n+\n use std::marker::Send;\n \n enum TestE {\n@@ -16,18 +18,21 @@ enum TestE {\n \n struct MyType;\n \n+struct NotSync;\n+impl !Sync for NotSync {}\n+\n unsafe impl Send for TestE {}\n unsafe impl Send for MyType {}\n unsafe impl Send for (MyType, MyType) {}\n //~^ ERROR builtin traits can only be implemented on structs or enums\n \n-unsafe impl Send for &'static MyType {}\n+unsafe impl Send for &'static NotSync {}\n //~^ ERROR builtin traits can only be implemented on structs or enums\n \n unsafe impl Send for [MyType] {}\n //~^ ERROR builtin traits can only be implemented on structs or enums\n \n-unsafe impl Send for &'static [MyType] {}\n+unsafe impl Send for &'static [NotSync] {}\n //~^ ERROR builtin traits can only be implemented on structs or enums\n \n fn is_send<T: Send>() {}"}, {"sha": "f4d97445725cd37de1a6b5f6f57e62e78e146ad7", "filename": "src/test/compile-fail/concat_idents-gate.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fconcat_idents-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fconcat_idents-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconcat_idents-gate.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const XY_1: i32 = 10;\n+\n+fn main() {\n+    const XY_2: i32 = 20;\n+    let a = concat_idents!(X, Y_1); //~ ERROR `concat_idents` is not stable\n+    let b = concat_idents!(X, Y_2); //~ ERROR `concat_idents` is not stable\n+    assert_eq!(a, 10);\n+    assert_eq!(b, 20);\n+}"}, {"sha": "d8f8f803edcc8ad053780d8f1bbe1f732e817e17", "filename": "src/test/compile-fail/concat_idents-gate2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fconcat_idents-gate2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fconcat_idents-gate2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconcat_idents-gate2.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const XY_1: i32 = 10;\n+\n+fn main() {\n+    const XY_2: i32 = 20;\n+    assert_eq!(10, concat_idents!(X, Y_1)); //~ ERROR `concat_idents` is not stable\n+    assert_eq!(20, concat_idents!(X, Y_2)); //~ ERROR `concat_idents` is not stable\n+}"}, {"sha": "193063a98cb0057865629edcdfd7d8268b46367a", "filename": "src/test/compile-fail/custom_attribute.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fcustom_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fcustom_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcustom_attribute.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[foo] //~ ERROR The attribute `foo`\n+fn main() {\n+\n+}\n\\ No newline at end of file"}, {"sha": "735f529277c360be6c7291d432c54373e65d0446", "filename": "src/test/compile-fail/issue-12041.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fissue-12041.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fissue-12041.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12041.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n use std::sync::mpsc::channel;\n-use std::thread::Thread;\n+use std::thread;\n \n fn main() {\n     let (tx, rx) = channel();\n-    let _t = Thread::spawn(move|| -> () {\n+    let _t = thread::spawn(move|| -> () {\n         loop {\n             let tx = tx;\n             //~^ ERROR: use of moved value: `tx`"}, {"sha": "b6d371e4b119fa932b6a615caee83cd5e50c0878", "filename": "src/test/compile-fail/issue-8460-const.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -9,47 +9,47 @@\n // except according to those terms.\n \n use std::{int, i8, i16, i32, i64};\n-use std::thread::Thread;\n+use std::thread;\n \n fn main() {\n-    assert!(Thread::scoped(move|| int::MIN / -1).join().is_err());\n+    assert!(thread::spawn(move|| { int::MIN / -1; }).join().is_err());\n     //~^ ERROR attempted to divide with overflow in a constant expression\n-    assert!(Thread::scoped(move|| i8::MIN / -1).join().is_err());\n+    assert!(thread::spawn(move|| { i8::MIN / -1; }).join().is_err());\n     //~^ ERROR attempted to divide with overflow in a constant expression\n-    assert!(Thread::scoped(move|| i16::MIN / -1).join().is_err());\n+    assert!(thread::spawn(move|| { i16::MIN / -1; }).join().is_err());\n     //~^ ERROR attempted to divide with overflow in a constant expression\n-    assert!(Thread::scoped(move|| i32::MIN / -1).join().is_err());\n+    assert!(thread::spawn(move|| { i32::MIN / -1; }).join().is_err());\n     //~^ ERROR attempted to divide with overflow in a constant expression\n-    assert!(Thread::scoped(move|| i64::MIN / -1).join().is_err());\n+    assert!(thread::spawn(move|| { i64::MIN / -1; }).join().is_err());\n     //~^ ERROR attempted to divide with overflow in a constant expression\n-    assert!(Thread::scoped(move|| 1is / 0).join().is_err());\n+    assert!(thread::spawn(move|| { 1is / 0; }).join().is_err());\n     //~^ ERROR attempted to divide by zero in a constant expression\n-    assert!(Thread::scoped(move|| 1i8 / 0).join().is_err());\n+    assert!(thread::spawn(move|| { 1i8 / 0; }).join().is_err());\n     //~^ ERROR attempted to divide by zero in a constant expression\n-    assert!(Thread::scoped(move|| 1i16 / 0).join().is_err());\n+    assert!(thread::spawn(move|| { 1i16 / 0; }).join().is_err());\n     //~^ ERROR attempted to divide by zero in a constant expression\n-    assert!(Thread::scoped(move|| 1i32 / 0).join().is_err());\n+    assert!(thread::spawn(move|| { 1i32 / 0; }).join().is_err());\n     //~^ ERROR attempted to divide by zero in a constant expression\n-    assert!(Thread::scoped(move|| 1i64 / 0).join().is_err());\n+    assert!(thread::spawn(move|| { 1i64 / 0; }).join().is_err());\n     //~^ ERROR attempted to divide by zero in a constant expression\n-    assert!(Thread::scoped(move|| int::MIN % -1).join().is_err());\n+    assert!(thread::spawn(move|| { int::MIN % -1; }).join().is_err());\n     //~^ ERROR attempted remainder with overflow in a constant expression\n-    assert!(Thread::scoped(move|| i8::MIN % -1).join().is_err());\n+    assert!(thread::spawn(move|| { i8::MIN % -1; }).join().is_err());\n     //~^ ERROR attempted remainder with overflow in a constant expression\n-    assert!(Thread::scoped(move|| i16::MIN % -1).join().is_err());\n+    assert!(thread::spawn(move|| { i16::MIN % -1; }).join().is_err());\n     //~^ ERROR attempted remainder with overflow in a constant expression\n-    assert!(Thread::scoped(move|| i32::MIN % -1).join().is_err());\n+    assert!(thread::spawn(move|| { i32::MIN % -1; }).join().is_err());\n     //~^ ERROR attempted remainder with overflow in a constant expression\n-    assert!(Thread::scoped(move|| i64::MIN % -1).join().is_err());\n+    assert!(thread::spawn(move|| { i64::MIN % -1; }).join().is_err());\n     //~^ ERROR attempted remainder with overflow in a constant expression\n-    assert!(Thread::scoped(move|| 1is % 0).join().is_err());\n+    assert!(thread::spawn(move|| { 1is % 0; }).join().is_err());\n     //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n-    assert!(Thread::scoped(move|| 1i8 % 0).join().is_err());\n+    assert!(thread::spawn(move|| { 1i8 % 0; }).join().is_err());\n     //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n-    assert!(Thread::scoped(move|| 1i16 % 0).join().is_err());\n+    assert!(thread::spawn(move|| { 1i16 % 0; }).join().is_err());\n     //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n-    assert!(Thread::scoped(move|| 1i32 % 0).join().is_err());\n+    assert!(thread::spawn(move|| { 1i32 % 0; }).join().is_err());\n     //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n-    assert!(Thread::scoped(move|| 1i64 % 0).join().is_err());\n+    assert!(thread::spawn(move|| { 1i64 % 0; }).join().is_err());\n     //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n }"}, {"sha": "d5276efa8be9812649f978f8ee7da58e6238faa3", "filename": "src/test/compile-fail/kindck-impl-type-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -17,7 +17,7 @@ struct S<T>;\n \n trait Gettable<T> {}\n \n-impl<T: Send + Copy> Gettable<T> for S<T> {}\n+impl<T: Send + Copy + 'static> Gettable<T> for S<T> {}\n \n fn f<T>(val: T) {\n     let t: S<T> = S;"}, {"sha": "570f7ad7fe3bf214adae00a7ac6644053305dd6c", "filename": "src/test/compile-fail/kindck-send-object.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -20,15 +20,15 @@ trait Message : Send { }\n \n fn object_ref_with_static_bound_not_ok() {\n     assert_send::<&'static (Dummy+'static)>();\n-    //~^ ERROR the trait `core::marker::Send` is not implemented\n+    //~^ ERROR the trait `core::marker::Sync` is not implemented\n }\n \n fn box_object_with_no_bound_not_ok<'a>() {\n     assert_send::<Box<Dummy>>(); //~ ERROR the trait `core::marker::Send` is not implemented\n }\n \n fn object_with_send_bound_ok() {\n-    assert_send::<&'static (Dummy+Send)>();\n+    assert_send::<&'static (Dummy+Sync)>();\n     assert_send::<Box<Dummy+Send>>();\n }\n "}, {"sha": "48d5215b7085be78f389d72df0139f2efa25130e", "filename": "src/test/compile-fail/kindck-send-object1.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -12,22 +12,22 @@\n // is broken into two parts because some errors occur in distinct\n // phases in the compiler. See kindck-send-object2.rs as well!\n \n-fn assert_send<T:Send>() { }\n+fn assert_send<T:Send+'static>() { }\n trait Dummy { }\n \n // careful with object types, who knows what they close over...\n fn test51<'a>() {\n     assert_send::<&'a Dummy>();\n-    //~^ ERROR the trait `core::marker::Send` is not implemented\n+    //~^ ERROR the trait `core::marker::Sync` is not implemented\n }\n fn test52<'a>() {\n-    assert_send::<&'a (Dummy+Send)>();\n+    assert_send::<&'a (Dummy+Sync)>();\n     //~^ ERROR does not fulfill the required lifetime\n }\n \n // ...unless they are properly bounded\n fn test60() {\n-    assert_send::<&'static (Dummy+Send)>();\n+    assert_send::<&'static (Dummy+Sync)>();\n }\n fn test61() {\n     assert_send::<Box<Dummy+Send>>();"}, {"sha": "d3d166e2a6916181d24c32984ed212bca92a07e6", "filename": "src/test/compile-fail/kindck-send-object2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -14,7 +14,7 @@ fn assert_send<T:Send>() { }\n trait Dummy { }\n \n fn test50() {\n-    assert_send::<&'static Dummy>(); //~ ERROR the trait `core::marker::Send` is not implemented\n+    assert_send::<&'static Dummy>(); //~ ERROR the trait `core::marker::Sync` is not implemented\n }\n \n fn test53() {\n@@ -23,7 +23,7 @@ fn test53() {\n \n // ...unless they are properly bounded\n fn test60() {\n-    assert_send::<&'static (Dummy+Send)>();\n+    assert_send::<&'static (Dummy+Sync)>();\n }\n fn test61() {\n     assert_send::<Box<Dummy+Send>>();"}, {"sha": "406711902a543555547453d1900b5469d74d2ea9", "filename": "src/test/compile-fail/kindck-send-owned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fkindck-send-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fkindck-send-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-owned.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -18,8 +18,8 @@ fn test31() { assert_send::<String>(); }\n fn test32() { assert_send::<Vec<isize> >(); }\n \n // but not if they own a bad thing\n-fn test40<'a>(_: &'a isize) {\n-    assert_send::<Box<&'a isize>>(); //~ ERROR does not fulfill the required lifetime\n+fn test40() {\n+    assert_send::<Box<*mut u8>>(); //~ ERROR `core::marker::Send` is not implemented\n }\n \n fn main() { }"}, {"sha": "e2a5b0678a6283164b661393c9dd5cb1dfdf016f", "filename": "src/test/compile-fail/kindck-send-region-pointers.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6c065fc8cb036785f61ff03e05c1563cbb2dd081/src%2Ftest%2Fcompile-fail%2Fkindck-send-region-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c065fc8cb036785f61ff03e05c1563cbb2dd081/src%2Ftest%2Fcompile-fail%2Fkindck-send-region-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-region-pointers.rs?ref=6c065fc8cb036785f61ff03e05c1563cbb2dd081", "patch": "@@ -1,34 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that borrowed pointers are not sendable unless 'static.\n-\n-fn assert_send<T:Send>() { }\n-\n-// lifetime pointers with 'static lifetime are ok\n-fn test01() { assert_send::<&'static isize>(); }\n-fn test02() { assert_send::<&'static str>(); }\n-fn test03() { assert_send::<&'static [isize]>(); }\n-\n-// whether or not they are mutable\n-fn test10() { assert_send::<&'static mut isize>(); }\n-\n-// otherwise lifetime pointers are not ok\n-fn test20<'a>(_: &'a isize) {\n-    assert_send::<&'a isize>(); //~ ERROR does not fulfill the required lifetime\n-}\n-fn test21<'a>(_: &'a isize) {\n-    assert_send::<&'a str>(); //~ ERROR does not fulfill the required lifetime\n-}\n-fn test22<'a>(_: &'a isize) {\n-    assert_send::<&'a [isize]>(); //~ ERROR does not fulfill the required lifetime\n-}\n-\n-fn main() { }"}, {"sha": "35f93c13fb5e23792d071df8a27293f168a4fb5d", "filename": "src/test/compile-fail/linkage1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Flinkage1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Flinkage1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flinkage1.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -11,4 +11,5 @@\n extern {\n     #[linkage = \"extern_weak\"] static foo: isize;\n     //~^ ERROR: the `linkage` attribute is experimental and not portable\n+    //~^^ ERROR: the `linkage` attribute is experimental and not portable\n }"}, {"sha": "1cf6e90d6c855e079de891b4eedfd0c134c28a97", "filename": "src/test/compile-fail/linkage4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Flinkage4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Flinkage4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flinkage4.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -10,6 +10,6 @@\n \n #[linkage = \"external\"]\n static foo: isize = 0;\n-//~^ ERROR: the `linkage` attribute is experimental and not portable\n+//~^^ ERROR: the `linkage` attribute is experimental and not portable\n \n fn main() {}"}, {"sha": "dd4e1212a00ca0b508a1f820b622f3c302f221da", "filename": "src/test/compile-fail/lint-obsolete-attr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Flint-obsolete-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Flint-obsolete-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-obsolete-attr.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -13,6 +13,7 @@\n \n #![deny(unused_attributes)]\n #![allow(dead_code)]\n+#![feature(custom_attribute)]\n \n #[abi=\"stdcall\"] extern {} //~ ERROR unused attribute\n "}, {"sha": "f9cdfa4f7d685356f7b7d14f17494f796c7ca26b", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -133,6 +133,11 @@ mod cross_crate {\n     impl UnstableTrait for S { } //~ WARNING use of unstable library feature\n \n     trait LocalTrait : UnstableTrait { } //~ WARNING use of unstable library feature\n+\n+    impl Trait for S {\n+        fn trait_stable(&self) {}\n+        fn trait_unstable(&self) {} //~ WARNING use of unstable library feature\n+    }\n }\n \n mod inheritance {"}, {"sha": "af4e81be1951d86d73dcf6a08be63ea973311e80", "filename": "src/test/compile-fail/lint-unknown-attr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Flint-unknown-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Flint-unknown-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unknown-attr.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -11,6 +11,7 @@\n // When denying at the crate level, be sure to not get random warnings from the\n // injected intrinsics by the compiler.\n \n+#![feature(custom_attribute)]\n #![deny(unused_attributes)]\n \n #![mutable_doc] //~ ERROR unused attribute"}, {"sha": "a4f46cbd1874fade8cc21cc143f90a7f5cb0fe2d", "filename": "src/test/compile-fail/lint-uppercase-variables.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -12,11 +12,10 @@\n \n #![allow(dead_code)]\n #![deny(non_snake_case)]\n-#![feature(path)]\n-#![feature(io)]\n \n-use std::old_io::File;\n-use std::old_io::IoError;\n+mod foo {\n+    pub enum Foo { Foo }\n+}\n \n struct Something {\n     X: usize //~ ERROR structure field `X` should have a snake case name such as `x`\n@@ -30,13 +29,11 @@ fn main() {\n     let Test: usize = 0; //~ ERROR variable `Test` should have a snake case name such as `test`\n     println!(\"{}\", Test);\n \n-    let mut f = File::open(&Path::new(\"something.txt\"));\n-    let mut buff = [0u8; 16];\n-    match f.read(&mut buff) {\n-        Ok(cnt) => println!(\"read this many bytes: {}\", cnt),\n-        Err(IoError{ kind: EndOfFile, .. }) => println!(\"Got end of file: {:?}\", EndOfFile),\n-//~^ ERROR variable `EndOfFile` should have a snake case name such as `end_of_file`\n-//~^^ WARN `EndOfFile` is named the same as one of the variants of the type `std::old_io::IoErrorKind`\n+    match foo::Foo::Foo {\n+        Foo => {}\n+//~^ ERROR variable `Foo` should have a snake case name such as `foo`\n+//~^^ WARN `Foo` is named the same as one of the variants of the type `foo::Foo`\n+//~^^^ WARN unused variable: `Foo`\n     }\n \n     test(1);"}, {"sha": "bb19e97ab0fa85ec9db950293320f37cdf769326", "filename": "src/test/compile-fail/log-syntax-gate2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Flog-syntax-gate2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Flog-syntax-gate2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flog-syntax-gate2.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    println!(\"{}\", log_syntax!()); //~ ERROR `log_syntax!` is not stable\n+}"}, {"sha": "e76eaea365ea6e0e8707341f54a86e93b421ec1c", "filename": "src/test/compile-fail/macro-inner-attributes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(custom_attribute)]\n+\n macro_rules! test { ($nm:ident,\n                      #[$a:meta],\n                      $i:item) => (mod $nm { #![$a] $i }); }"}, {"sha": "cff01f36f3ad72132a4694725a2435fe45b8f82e", "filename": "src/test/compile-fail/macro-outer-attributes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(custom_attribute)]\n+\n macro_rules! test { ($nm:ident,\n                      #[$a:meta],\n                      $i:item) => (mod $nm { #[$a] $i }); }"}, {"sha": "cf7a8378b9a9a120391cf88b7298532623c0ae44", "filename": "src/test/compile-fail/missing-stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmissing-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmissing-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-stability.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -30,4 +30,4 @@ pub mod bar {\n     // #[stable] is not inherited\n     pub fn unmarked() {}\n     //~^ ERROR This node does not have a stability attribute\n-}\n\\ No newline at end of file\n+}"}, {"sha": "0219f5b6becb3bae271892a3cc559bebacc8ae56", "filename": "src/test/compile-fail/move-fragments-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmove-fragments-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmove-fragments-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-1.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -18,6 +18,8 @@\n // These are all fairly trivial cases: unused variables or direct\n // drops of substructure.\n \n+#![feature(rustc_attrs)]\n+\n pub struct D { d: isize }\n impl Drop for D { fn drop(&mut self) { } }\n "}, {"sha": "175488bf2fcd02f38c0c4a926a9aeb858342cd3c", "filename": "src/test/compile-fail/move-fragments-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmove-fragments-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmove-fragments-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-2.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -18,6 +18,8 @@\n // These are checking that enums are tracked; note that their output\n // paths include \"downcasts\" of the path to a particular enum.\n \n+#![feature(rustc_attrs)]\n+\n use self::Lonely::{Zero, One, Two};\n \n pub struct D { d: isize }"}, {"sha": "b65921177adaaf145db68235d20778b3f6c6a99c", "filename": "src/test/compile-fail/move-fragments-3.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmove-fragments-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmove-fragments-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-3.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -18,6 +18,8 @@\n // This checks the handling of `_` within variants, especially when mixed\n // with bindings.\n \n+#![feature(rustc_attrs)]\n+\n use self::Lonely::{Zero, One, Two};\n \n pub struct D { d: isize }"}, {"sha": "191e23a28638b59c8119386ae18525d6f172cc36", "filename": "src/test/compile-fail/move-fragments-4.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmove-fragments-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmove-fragments-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-4.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -19,6 +19,8 @@\n // early draft of the code did not properly traverse up through all of\n // the parents of the leaf fragment.)\n \n+#![feature(rustc_attrs)]\n+\n pub struct D { d: isize }\n impl Drop for D { fn drop(&mut self) { } }\n "}, {"sha": "38a385eacac5c07795c9a19e49c5d9288b3b7e63", "filename": "src/test/compile-fail/move-fragments-5.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmove-fragments-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmove-fragments-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-5.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -17,6 +17,8 @@\n \n // This is the first test that checks moving into local variables.\n \n+#![feature(rustc_attrs)]\n+\n pub struct D { d: isize }\n impl Drop for D { fn drop(&mut self) { } }\n "}, {"sha": "122727c3f6b64a0c1cf75e4ca4a216cf51df98b3", "filename": "src/test/compile-fail/move-fragments-6.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmove-fragments-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmove-fragments-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-6.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -18,6 +18,8 @@\n // Test that moving into a field (i.e. overwriting it) fragments the\n // receiver.\n \n+#![feature(rustc_attrs)]\n+\n use std::mem::drop;\n \n pub struct Pair<X,Y> { x: X, y: Y }"}, {"sha": "a2a37208cd6168b61f4dcbdce75f59cf93e4b65d", "filename": "src/test/compile-fail/move-fragments-7.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmove-fragments-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmove-fragments-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-7.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -19,6 +19,8 @@\n // both moving out of the structure (i.e. reading `*p.x`) and writing\n // into the container (i.e. writing `*p.x`).\n \n+#![feature(rustc_attrs)]\n+\n pub struct D { d: isize }\n impl Drop for D { fn drop(&mut self) { } }\n "}, {"sha": "e57268dbfa32aa985afb154168824b5916186a22", "filename": "src/test/compile-fail/move-fragments-8.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmove-fragments-8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmove-fragments-8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-8.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -22,6 +22,8 @@\n // also that in this case we cannot do a move out of `&T`, so we only\n // test writing `*p.x` here.\n \n+#![feature(rustc_attrs)]\n+\n pub struct D { d: isize }\n impl Drop for D { fn drop(&mut self) { } }\n "}, {"sha": "350f4169034004620cae6bf2cb6367532dfb27b2", "filename": "src/test/compile-fail/move-fragments-9.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmove-fragments-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmove-fragments-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-9.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -14,6 +14,8 @@\n // Note also that the `test_move_array_then_overwrite` tests represent\n // cases that we probably should make illegal.\n \n+#![feature(rustc_attrs)]\n+\n pub struct D { d: isize }\n impl Drop for D { fn drop(&mut self) { } }\n "}, {"sha": "32fa773ec807947f892e274386644f2c748a939a", "filename": "src/test/compile-fail/moves-based-on-type-capture-clause-bad.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::thread::Thread;\n+use std::thread;\n \n fn main() {\n     let x = \"Hello world!\".to_string();\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         println!(\"{}\", x);\n     });\n     println!(\"{}\", x); //~ ERROR use of moved value"}, {"sha": "7b7b3c414dded597ff769400ee605153b7fa192e", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -11,13 +11,13 @@\n // error-pattern: use of moved value\n \n use std::sync::Arc;\n-use std::thread::Thread;\n+use std::thread;\n \n fn main() {\n     let v = vec!(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n     let arc_v = Arc::new(v);\n \n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         assert_eq!((*arc_v)[3], 4);\n     });\n "}, {"sha": "1720b40c83bbd749256e04179b06e3ae7446f92b", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n use std::sync::Arc;\n-use std::thread::Thread;\n+use std::thread;\n \n fn main() {\n     let v = vec!(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n     let arc_v = Arc::new(v);\n \n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         assert_eq!((*arc_v)[3], 4);\n     });\n "}, {"sha": "5ebc386109a8bcdf3ce589bf37e840dc0b8757eb", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(unsafe_destructor)]\n \n-use std::thread::Thread;\n+use std::thread;\n use std::rc::Rc;\n \n #[derive(Debug)]\n@@ -35,7 +35,7 @@ fn main() {\n \n     let x = foo(Port(Rc::new(())));\n \n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         //~^ ERROR `core::marker::Send` is not implemented\n         let y = x;\n         println!(\"{:?}\", y);"}, {"sha": "ac03c085b7b6cc6c3d03bbe8f742daa7677f58a2", "filename": "src/test/compile-fail/object-lifetime-default.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(rustc_attrs)]\n+\n #[rustc_object_lifetime_default]\n struct A<T>(T); //~ ERROR None\n "}, {"sha": "2095fb903b844d7526f33321cb171bac111e5a8f", "filename": "src/test/compile-fail/region-object-lifetime-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-1.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -11,6 +11,7 @@\n // Various tests related to testing how region inference works\n // with respect to the object receivers.\n \n+#![feature(rustc_attrs)]\n #![allow(warnings)]\n \n trait Foo {"}, {"sha": "097053276c7fb99a52811aa893e2e2dcf12105c2", "filename": "src/test/compile-fail/region-object-lifetime-3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-3.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -11,6 +11,7 @@\n // Various tests related to testing how region inference works\n // with respect to the object receivers.\n \n+#![feature(rustc_attrs)]\n #![allow(warnings)]\n \n trait Foo {"}, {"sha": "71254e15d32fc37051b70324bc7e7d1942f77085", "filename": "src/test/compile-fail/regions-bounded-by-send.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/6c065fc8cb036785f61ff03e05c1563cbb2dd081/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c065fc8cb036785f61ff03e05c1563cbb2dd081/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs?ref=6c065fc8cb036785f61ff03e05c1563cbb2dd081", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test which of the builtin types are considered sendable. The tests\n-// in this file all test region bound and lifetime violations that are\n-// detected during type check.\n-\n-extern crate core;\n-use core::ptr::Unique;\n-\n-fn assert_send<T:Send>() { }\n-trait Dummy:Send { }\n-\n-// lifetime pointers with 'static lifetime are ok\n-\n-fn static_lifime_ok<'a,T,U:Send>(_: &'a isize) {\n-    assert_send::<&'static isize>();\n-    assert_send::<&'static str>();\n-    assert_send::<&'static [isize]>();\n-\n-    // whether or not they are mutable\n-    assert_send::<&'static mut isize>();\n-}\n-\n-// otherwise lifetime pointers are not ok\n-\n-fn param_not_ok<'a>(x: &'a isize) {\n-    assert_send::<&'a isize>(); //~ ERROR does not fulfill the required lifetime\n-}\n-\n-fn param_not_ok1<'a>(_: &'a isize) {\n-    assert_send::<&'a str>(); //~ ERROR does not fulfill the required lifetime\n-}\n-\n-fn param_not_ok2<'a>(_: &'a isize) {\n-    assert_send::<&'a [isize]>(); //~ ERROR does not fulfill the required lifetime\n-}\n-\n-// boxes are ok\n-\n-fn box_ok() {\n-    assert_send::<Box<isize>>();\n-    assert_send::<String>();\n-    assert_send::<Vec<isize>>();\n-}\n-\n-// but not if they own a bad thing\n-\n-fn box_with_region_not_ok<'a>() {\n-    assert_send::<Box<&'a isize>>(); //~ ERROR does not fulfill the required lifetime\n-}\n-\n-// objects with insufficient bounds no ok\n-\n-fn object_with_random_bound_not_ok<'a>() {\n-    assert_send::<&'a (Dummy+'a)>();\n-    //~^ ERROR reference has a longer lifetime\n-}\n-\n-fn object_with_send_bound_not_ok<'a>() {\n-    assert_send::<&'a (Dummy+Send)>();\n-    //~^ ERROR does not fulfill the required lifetime\n-}\n-\n-// unsafe pointers are ok unless they point at unsendable things\n-\n-struct UniqueUnsafePtr(Unique<*const isize>);\n-\n-unsafe impl Send for UniqueUnsafePtr {}\n-\n-fn unsafe_ok1<'a>(_: &'a isize) {\n-    assert_send::<UniqueUnsafePtr>();\n-}\n-\n-fn main() {\n-}"}, {"sha": "3401dd1becdd8b141dd5e8940e1af672ac7e68f2", "filename": "src/test/compile-fail/regions-pattern-typing-issue-19552.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19552.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19552.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19552.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn assert_send<T: Send>(_t: T) {}\n+fn assert_static<T: 'static>(_t: T) {}\n \n fn main() {\n     let line = String::new();\n     match [&*line] { //~ ERROR `line` does not live long enough\n-        [ word ] => { assert_send(word); }\n+        [ word ] => { assert_static(word); }\n     }\n }"}, {"sha": "82f32cbcd14e46028916269eaf210b822e7e54d8", "filename": "src/test/compile-fail/rustc-error.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Frustc-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Frustc-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frustc-error.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(rustc_attrs)]\n+\n #[rustc_error]\n fn main() {\n     //~^ ERROR compilation successful"}, {"sha": "abbcd7e45904f1b1170d897654462056bd8d6fc7", "filename": "src/test/compile-fail/send-is-not-static-ensures-scoping.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-ensures-scoping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-ensures-scoping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-ensures-scoping.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::thread;\n+\n+fn main() {\n+    let bad = {\n+        let x = 1;\n+        let y = &x;\n+\n+        thread::scoped(|| { //~ ERROR cannot infer an appropriate lifetime\n+            let _z = y;\n+        })\n+    };\n+\n+    bad.join();\n+}"}, {"sha": "6473bcece91b694f336277cea78927a1b5e8ba94", "filename": "src/test/compile-fail/trace_macros-gate.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the trace_macros feature gate is on.\n+\n+fn main() {\n+    trace_macros!(); //~ ERROR `trace_macros` is not stable\n+    trace_macros!(1); //~ ERROR `trace_macros` is not stable\n+    trace_macros!(ident); //~ ERROR `trace_macros` is not stable\n+    trace_macros!(for); //~ ERROR `trace_macros` is not stable\n+    trace_macros!(true,); //~ ERROR `trace_macros` is not stable\n+    trace_macros!(false 1); //~ ERROR `trace_macros` is not stable\n+\n+    // Errors are signalled early for the above, before expansion.\n+    // See trace_macros-gate2 and trace_macros-gate3. for examples\n+    // of the below being caught.\n+\n+    macro_rules! expando {\n+        ($x: ident) => { trace_macros!($x) }\n+    }\n+\n+    expando!(true);\n+}"}, {"sha": "71cc45e132d3385de283753010b08d1e6db467ab", "filename": "src/test/compile-fail/trace_macros-gate2.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate2.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the trace_macros feature gate is on.\n+\n+fn main() {\n+    // (Infrastructure does not attempt to detect uses in macro definitions.)\n+    macro_rules! expando {\n+        ($x: ident) => { trace_macros!($x) }\n+    }\n+\n+    expando!(true); //~ ERROR `trace_macros` is not stable\n+}"}, {"sha": "66d03cf9d8046fd32b598e797b768c5d71541a21", "filename": "src/test/compile-fail/trace_macros-gate3.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate3.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the trace_macros feature gate is on.\n+\n+pub fn main() {\n+    println!(\"arg: {}\", trace_macros!()); //~ ERROR `trace_macros` is not stable\n+    println!(\"arg: {}\", trace_macros!(1)); //~ ERROR `trace_macros` is not stable\n+    println!(\"arg: {}\", trace_macros!(ident)); //~ ERROR `trace_macros` is not stable\n+    println!(\"arg: {}\", trace_macros!(for)); //~ ERROR `trace_macros` is not stable\n+    println!(\"arg: {}\", trace_macros!(true,)); //~ ERROR `trace_macros` is not stable\n+    println!(\"arg: {}\", trace_macros!(false 1)); //~ ERROR `trace_macros` is not stable\n+}"}, {"sha": "79174552ae09c36f5ba136754f7a95cd7d6b6bc0", "filename": "src/test/compile-fail/trait-bounds-cant-coerce.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -22,7 +22,7 @@ fn c(x: Box<Foo+Sync+Send>) {\n fn d(x: Box<Foo>) {\n     a(x); //~  ERROR mismatched types\n           //~| expected `Box<Foo + Send>`\n-          //~| found `Box<Foo + 'static>`\n+          //~| found `Box<Foo>`\n           //~| expected bounds `Send`\n           //~| found no bounds\n }"}, {"sha": "2d4bc0c857a9a7ad7f8c77f05e77300e3346b644", "filename": "src/test/compile-fail/unused-attr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Funused-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Funused-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-attr.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -7,9 +7,10 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+\n #![deny(unused_attributes)]\n #![allow(dead_code, unused_imports)]\n-#![feature(core)]\n+#![feature(core, custom_attribute)]\n \n #![foo] //~ ERROR unused attribute\n "}, {"sha": "0ed0861d34af1fe7744a6db319611db233e7e1ca", "filename": "src/test/compile-fail/variance-associated-types.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -11,6 +11,8 @@\n // Test that the variance computation considers types/regions that\n // appear in projections to be invariant.\n \n+#![feature(rustc_attrs)]\n+\n trait Trait<'a> {\n     type Type;\n "}, {"sha": "2b7b05970d90f4c15f8830398eeaa50b76cc1e5d", "filename": "src/test/compile-fail/variance-object-types.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -11,6 +11,8 @@\n // Test that Cell is considered invariant with respect to its\n // type.\n \n+#![feature(rustc_attrs)]\n+\n use std::cell::Cell;\n \n // For better or worse, associated types are invariant, and hence we"}, {"sha": "d70305d1106ecd64c8a1535fddea6449fad35320", "filename": "src/test/compile-fail/variance-regions-direct.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -11,6 +11,8 @@\n // Test that we correctly infer variance for region parameters in\n // various self-contained types.\n \n+#![feature(rustc_attrs)]\n+\n // Regions that just appear in normal spots are contravariant:\n \n #[rustc_variance]"}, {"sha": "4bb329d6304cf3ec1333f980bde394d063ff5f16", "filename": "src/test/compile-fail/variance-regions-indirect.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -12,6 +12,8 @@\n // case that involve multiple intricate types.\n // Try enums too.\n \n+#![feature(rustc_attrs)]\n+\n #[rustc_variance]\n enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR regions=[[+, -, o, *];[];[]]\n     Test8A(extern \"Rust\" fn(&'a isize)),"}, {"sha": "965b9430a5e2d44095266a7b08abf700728e2147", "filename": "src/test/compile-fail/variance-trait-object-bound.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -14,6 +14,8 @@\n //\n // Issue #18262.\n \n+#![feature(rustc_attrs)]\n+\n use std::mem;\n \n trait T { fn foo(); }"}, {"sha": "79964d2a7bacab9ad9fa7b4cc63ebd28cdc08115", "filename": "src/test/pretty/attr-fn-inner.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fpretty%2Fattr-fn-inner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Fpretty%2Fattr-fn-inner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fattr-fn-inner.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -13,6 +13,8 @@\n // preserved, and that the first outer item parsed in main is not\n // accidentally carried over to each inner function\n \n+#![feature(custom_attribute)]\n+\n fn main() {\n     #![inner_attr]\n     #[outer_attr]"}, {"sha": "3a5ac5a10095742c13772734fc3e9f1c8914e458", "filename": "src/test/run-fail/panic-task-name-none.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Frun-fail%2Fpanic-task-name-none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Frun-fail%2Fpanic-task-name-none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-task-name-none.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -10,12 +10,11 @@\n \n // error-pattern:thread '<unnamed>' panicked at 'test'\n \n-use std::thread::Thread;\n+use std::thread;\n \n fn main() {\n-    let r: Result<int,_> = Thread::scoped(move|| {\n+    let r: Result<(),_> = thread::spawn(move|| {\n         panic!(\"test\");\n-        1\n     }).join();\n     assert!(r.is_ok());\n }"}, {"sha": "8cab9e05f96e87ca3f6569f7cfe461a284876f14", "filename": "src/test/run-fail/panic-task-name-owned.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -13,9 +13,9 @@\n use std::thread::Builder;\n \n fn main() {\n-    let r: Result<int,_> = Builder::new().name(\"owned name\".to_string()).scoped(move|| {\n+    let r: () = Builder::new().name(\"owned name\".to_string()).scoped(move|| {\n         panic!(\"test\");\n-        1\n-    }).join();\n-    assert!(r.is_ok());\n+        ()\n+    }).unwrap().join();\n+    panic!();\n }"}, {"sha": "775d38c8b3044ca917d8729799552664e21e90d2", "filename": "src/test/run-fail/rt-set-exit-status-panic2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs?ref=dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "patch": "@@ -12,7 +12,7 @@\n \n #[macro_use] extern crate log;\n use std::os;\n-use std::thread::Thread;\n+use std::thread;\n \n struct r {\n   x:int,\n@@ -35,7 +35,7 @@ fn r(x:int) -> r {\n \n fn main() {\n     error!(\"whatever\");\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::spawn(move|| {\n       let _i = r(5);\n     });\n     panic!();"}]}