{"sha": "7d70685eefc98668804c05428bb94f43933cca61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkNzA2ODVlZWZjOTg2Njg4MDRjMDU0MjhiYjk0ZjQzOTMzY2NhNjE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T05:09:06Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T22:54:45Z"}, "message": "Convert the rest of rustc::middle to istrs. Issue #855", "tree": {"sha": "748ae9d1ae1bd3171c4e2059fdcc78c16afa2493", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/748ae9d1ae1bd3171c4e2059fdcc78c16afa2493"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d70685eefc98668804c05428bb94f43933cca61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d70685eefc98668804c05428bb94f43933cca61", "html_url": "https://github.com/rust-lang/rust/commit/7d70685eefc98668804c05428bb94f43933cca61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d70685eefc98668804c05428bb94f43933cca61/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e01e05f3b2ba2f726271889c2bbb04c6b44aef1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e01e05f3b2ba2f726271889c2bbb04c6b44aef1", "html_url": "https://github.com/rust-lang/rust/commit/9e01e05f3b2ba2f726271889c2bbb04c6b44aef1"}], "stats": {"total": 253, "additions": 130, "deletions": 123}, "files": [{"sha": "b97327b841b0f6feb896afe09a5c388027017851", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d70685eefc98668804c05428bb94f43933cca61/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d70685eefc98668804c05428bb94f43933cca61/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=7d70685eefc98668804c05428bb94f43933cca61", "patch": "@@ -22,8 +22,8 @@ type ctxt = @{mutable next_tydesc_num: uint};\n \n fn mk_ctxt() -> ctxt { ret @{mutable next_tydesc_num: 0u}; }\n \n-fn add_global(ccx: &@crate_ctxt, llval: ValueRef, name: str) -> ValueRef {\n-    let llglobal = istr::as_buf(istr::from_estr(name), { |buf|\n+fn add_global(ccx: &@crate_ctxt, llval: ValueRef, name: &istr) -> ValueRef {\n+    let llglobal = istr::as_buf(name, { |buf|\n         lll::LLVMAddGlobal(ccx.llmod, val_ty(llval), buf)\n     });\n     lll::LLVMSetInitializer(llglobal, llval);\n@@ -63,10 +63,10 @@ fn add_gc_root(cx: &@block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n \n         let lldestindex =\n             add_global(bcx_ccx(bcx), C_struct([C_int(0), C_uint(number)]),\n-                       \"rust_gc_tydesc_dest_index\");\n+                       ~\"rust_gc_tydesc_dest_index\");\n         let llsrcindex =\n             add_global(bcx_ccx(bcx), C_struct([C_int(1), C_uint(number)]),\n-                       \"rust_gc_tydesc_src_index\");\n+                       ~\"rust_gc_tydesc_src_index\");\n \n         lldestindex = lll::LLVMConstPointerCast(lldestindex, T_ptr(T_i8()));\n         llsrcindex = lll::LLVMConstPointerCast(llsrcindex, T_ptr(T_i8()));\n@@ -86,7 +86,7 @@ fn add_gc_root(cx: &@block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n \n         let llstaticgcmeta =\n             add_global(bcx_ccx(bcx), C_struct([C_int(2), lltydesc]),\n-                       \"rust_gc_tydesc_static_gc_meta\");\n+                       ~\"rust_gc_tydesc_static_gc_meta\");\n         let llstaticgcmetaptr =\n             lll::LLVMConstPointerCast(llstaticgcmeta, T_ptr(T_i8()));\n "}, {"sha": "b292c116cb57dfce5531deb3866067c3bae1e13f", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 54, "deletions": 48, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/7d70685eefc98668804c05428bb94f43933cca61/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d70685eefc98668804c05428bb94f43933cca61/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=7d70685eefc98668804c05428bb94f43933cca61", "patch": "@@ -75,12 +75,12 @@ tag import_state {\n              option::t<def>); /* module */\n }\n \n-type ext_hash = hashmap<{did: def_id, ident: str, ns: namespace}, def>;\n+type ext_hash = hashmap<{did: def_id, ident: istr, ns: namespace}, def>;\n \n fn new_ext_hash() -> ext_hash {\n-    type key = {did: def_id, ident: str, ns: namespace};\n+    type key = {did: def_id, ident: istr, ns: namespace};\n     fn hash(v: &key) -> uint {\n-        ret str::hash(v.ident) + util::common::hash_def(v.did) +\n+        ret istr::hash(v.ident) + util::common::hash_def(v.did) +\n                 alt v.ns {\n                   ns_value. { 1u }\n                   ns_type. { 2u }\n@@ -89,7 +89,7 @@ fn new_ext_hash() -> ext_hash {\n     }\n     fn eq(v1: &key, v2: &key) -> bool {\n         ret util::common::def_eq(v1.did, v2.did) &&\n-                str::eq(v1.ident, v2.ident) && v1.ns == v2.ns;\n+                istr::eq(v1.ident, v2.ident) && v1.ns == v2.ns;\n     }\n     ret std::map::mk_hashmap::<key, def>(hash, eq);\n }\n@@ -128,7 +128,7 @@ type env =\n      mod_map: hashmap<ast::node_id, @indexed_mod>,\n      ext_map: hashmap<def_id, [ident]>,\n      ext_cache: ext_hash,\n-     mutable reported: [{ident: str, sc: scope}],\n+     mutable reported: [{ident: istr, sc: scope}],\n      sess: session};\n \n \n@@ -477,7 +477,8 @@ fn resolve_import(e: &env, defid: ast::def_id, name: &ast::ident,\n             alt lookup_in_scope(e, sc, sp, ids[0], ns_module) {\n               some(dcur) { dcur }\n               none. {\n-                unresolved_err(e, sc, sp, ids[0], ns_name(ns_module));\n+                unresolved_err(e, sc, sp, ids[0],\n+                               ns_name(ns_module));\n                 remove_if_unresolved(e.imports, defid.node);\n                 ret ()\n               }\n@@ -499,7 +500,8 @@ fn resolve_import(e: &env, defid: ast::def_id, name: &ast::ident,\n                         {\n                       some(dcur) { dcur }\n                       none. {\n-                        unresolved_err(e, sc, sp, ids[i], ns_name(ns_module));\n+                        unresolved_err(e, sc, sp, ids[i],\n+                                       ns_name(ns_module));\n                         remove_if_unresolved(e.imports, defid.node);\n                         ret () // FIXME (issue #521)\n                       }\n@@ -512,7 +514,7 @@ fn resolve_import(e: &env, defid: ast::def_id, name: &ast::ident,\n                 val: &option::t<def>, typ: &option::t<def>,\n                 md: &option::t<def>) {\n         if is_none(val) && is_none(typ) && is_none(md) {\n-            unresolved_err(e, sc, sp, name, \"import\");\n+            unresolved_err(e, sc, sp, name, ~\"import\");\n         } else { e.imports.insert(defid.node, resolved(val, typ, md)); }\n     }\n     fn remove_if_unresolved(imports: hashmap<ast::node_id, import_state>,\n@@ -532,15 +534,16 @@ fn resolve_import(e: &env, defid: ast::def_id, name: &ast::ident,\n \n \n // Utilities\n-fn ns_name(ns: namespace) -> str {\n+fn ns_name(ns: namespace) -> istr {\n     alt ns {\n-      ns_type. { ret \"typename\"; }\n-      ns_value. { ret \"name\"; }\n-      ns_module. { ret \"modulename\"; }\n+      ns_type. { ret ~\"typename\"; }\n+      ns_value. { ret ~\"name\"; }\n+      ns_module. { ret ~\"modulename\"; }\n     }\n }\n \n-fn unresolved_err(e: &env, sc: &scopes, sp: &span, name: &ident, kind: &str) {\n+fn unresolved_err(e: &env, sc: &scopes, sp: &span,\n+                  name: &ident, kind: &istr) {\n     fn find_fn_or_mod_scope(sc: scopes) -> scope {\n         while true {\n             alt sc {\n@@ -558,20 +561,21 @@ fn unresolved_err(e: &env, sc: &scopes, sp: &span, name: &ident, kind: &str) {\n         fail;\n     }\n     let err_scope = find_fn_or_mod_scope(sc);\n-    for rs: {ident: str, sc: scope} in e.reported {\n-        if str::eq(rs.ident, istr::to_estr(name))\n+    for rs: {ident: istr, sc: scope} in e.reported {\n+        if istr::eq(rs.ident, name)\n             && err_scope == rs.sc { ret; }\n     }\n-    e.reported += [{ident: istr::to_estr(name), sc: err_scope}];\n-    e.sess.span_err(sp, mk_unresolved_msg(name, kind));\n+    e.reported += [{ident: name, sc: err_scope}];\n+    e.sess.span_err(sp, istr::to_estr(mk_unresolved_msg(name, kind)));\n }\n \n-fn unresolved_fatal(e: &env, sp: &span, id: &ident, kind: &str) -> ! {\n-    e.sess.span_fatal(sp, mk_unresolved_msg(id, kind));\n+fn unresolved_fatal(e: &env, sp: &span, id: &ident, kind: &istr) -> ! {\n+    e.sess.span_fatal(sp, istr::to_estr(mk_unresolved_msg(id, kind)));\n }\n \n-fn mk_unresolved_msg(id: &ident, kind: &str) -> str {\n-    ret #fmt[\"unresolved %s: %s\", kind, istr::to_estr(id)];\n+fn mk_unresolved_msg(id: &ident, kind: &istr) -> istr {\n+    ret istr::from_estr(\n+        #fmt[\"unresolved %s: %s\", istr::to_estr(kind), istr::to_estr(id)]);\n }\n \n // Lookup helpers\n@@ -602,7 +606,8 @@ fn lookup_path_strict(e: &env, sc: &scopes, sp: &span, pth: &ast::path_,\n fn lookup_in_scope_strict(e: &env, sc: scopes, sp: &span, name: &ident,\n                           ns: namespace) -> option::t<def> {\n     alt lookup_in_scope(e, sc, sp, name, ns) {\n-      none. { unresolved_err(e, sc, sp, name, ns_name(ns)); ret none; }\n+      none. { unresolved_err(e, sc, sp, name,\n+                             ns_name(ns)); ret none; }\n       some(d) { ret some(d); }\n     }\n }\n@@ -888,7 +893,8 @@ fn found_def_item(i: &@ast::item, ns: namespace) -> option::t<def> {\n fn lookup_in_mod_strict(e: &env, sc: &scopes, m: def, sp: &span, name: &ident,\n                         ns: namespace, dr: dir) -> option::t<def> {\n     alt lookup_in_mod(e, m, sp, name, ns, dr) {\n-      none. { unresolved_err(e, sc, sp, name, ns_name(ns)); ret none; }\n+      none. { unresolved_err(e, sc, sp, name,\n+                             ns_name(ns)); ret none; }\n       some(d) { ret some(d); }\n     }\n }\n@@ -900,14 +906,14 @@ fn lookup_in_mod(e: &env, m: &def, sp: &span, name: &ident, ns: namespace,\n         // examining a module in an external crate\n \n         let cached = e.ext_cache.find({did: defid,\n-                                       ident: istr::to_estr(name), ns: ns});\n+                                       ident: name, ns: ns});\n         if !is_none(cached) { ret cached; }\n         let path = [name];\n         if defid.node != -1 { path = e.ext_map.get(defid) + path; }\n         let fnd = lookup_external(e, defid.crate, path, ns);\n         if !is_none(fnd) {\n             e.ext_cache.insert({did: defid,\n-                                ident: istr::to_estr(name), ns: ns},\n+                                ident: name, ns: ns},\n                                option::get(fnd));\n         }\n         ret fnd;\n@@ -1214,26 +1220,26 @@ fn check_mod_name(e: &env, name: &ident, entries: list<mod_index_entry>) {\n     let saw_mod = false;\n     let saw_type = false;\n     let saw_value = false;\n-    fn dup(e: &env, sp: &span, word: &str, name: &ident) {\n-        e.sess.span_fatal(sp, \"duplicate definition of \" + word\n-                          + istr::to_estr(name));\n+    fn dup(e: &env, sp: &span, word: &istr, name: &ident) {\n+        e.sess.span_fatal(sp, \"duplicate definition of \" +\n+                          istr::to_estr(word + name));\n     }\n     while true {\n         alt entries {\n           cons(entry, rest) {\n             if !is_none(lookup_in_mie(e, entry, ns_value)) {\n                 if saw_value {\n-                    dup(e, mie_span(entry), \"\", name);\n+                    dup(e, mie_span(entry), ~\"\", name);\n                 } else { saw_value = true; }\n             }\n             if !is_none(lookup_in_mie(e, entry, ns_type)) {\n                 if saw_type {\n-                    dup(e, mie_span(entry), \"type \", name);\n+                    dup(e, mie_span(entry), ~\"type \", name);\n                 } else { saw_type = true; }\n             }\n             if !is_none(lookup_in_mie(e, entry, ns_module)) {\n                 if saw_mod {\n-                    dup(e, mie_span(entry), \"module \", name);\n+                    dup(e, mie_span(entry), ~\"module \", name);\n                 } else { saw_mod = true; }\n             }\n             entries = *rest;\n@@ -1264,20 +1270,20 @@ fn check_item(e: &@env, i: &@ast::item, x: &(), v: &vt<()>) {\n       ast::item_fn(f, ty_params) {\n         check_fn(*e, i.span, f);\n         ensure_unique(*e, i.span, typaram_names(ty_params), ident_id,\n-                      \"type parameter\");\n+                      ~\"type parameter\");\n       }\n       ast::item_obj(ob, ty_params, _) {\n         fn field_name(field: &ast::obj_field) -> ident { ret field.ident; }\n-        ensure_unique(*e, i.span, ob.fields, field_name, \"object field\");\n+        ensure_unique(*e, i.span, ob.fields, field_name, ~\"object field\");\n         for m: @ast::method in ob.methods {\n             check_fn(*e, m.span, m.node.meth);\n         }\n         ensure_unique(*e, i.span, typaram_names(ty_params), ident_id,\n-                      \"type parameter\");\n+                      ~\"type parameter\");\n       }\n       ast::item_tag(_, ty_params) {\n         ensure_unique(*e, i.span, typaram_names(ty_params), ident_id,\n-                      \"type parameter\");\n+                      ~\"type parameter\");\n       }\n       _ { }\n     }\n@@ -1292,13 +1298,13 @@ fn check_pat(ch: checker, p: &@ast::pat) {\n \n fn check_arm(e: &@env, a: &ast::arm, x: &(), v: &vt<()>) {\n     visit::visit_arm(a, x, v);\n-    let ch0 = checker(*e, \"binding\");\n+    let ch0 = checker(*e, ~\"binding\");\n     check_pat(ch0, a.pats[0]);\n     let seen0 = ch0.seen;\n     let i = vec::len(a.pats);\n     while i > 1u {\n         i -= 1u;\n-        let ch = checker(*e, \"binding\");\n+        let ch = checker(*e, ~\"binding\");\n         check_pat(ch, a.pats[i]);\n \n         // Ensure the bindings introduced in this pattern are the same as in\n@@ -1322,15 +1328,15 @@ fn check_arm(e: &@env, a: &ast::arm, x: &(), v: &vt<()>) {\n \n fn check_block(e: &@env, b: &ast::blk, x: &(), v: &vt<()>) {\n     visit::visit_block(b, x, v);\n-    let values = checker(*e, \"value\");\n-    let types = checker(*e, \"type\");\n-    let mods = checker(*e, \"module\");\n+    let values = checker(*e, ~\"value\");\n+    let types = checker(*e, ~\"type\");\n+    let mods = checker(*e, ~\"module\");\n     for st: @ast::stmt in b.node.stmts {\n         alt st.node {\n           ast::stmt_decl(d, _) {\n             alt d.node {\n               ast::decl_local(locs) {\n-                let local_values = checker(*e, \"value\");\n+                let local_values = checker(*e, ~\"value\");\n                 for loc in locs {\n                     for each p in ast_util::pat_bindings(loc.node.pat) {\n                         let ident = alt p.node { pat_bind(n) { n } };\n@@ -1370,14 +1376,14 @@ fn check_block(e: &@env, b: &ast::blk, x: &(), v: &vt<()>) {\n \n fn check_fn(e: &env, sp: &span, f: &ast::_fn) {\n     fn arg_name(a: &ast::arg) -> ident { ret a.ident; }\n-    ensure_unique(e, sp, f.decl.inputs, arg_name, \"argument\");\n+    ensure_unique(e, sp, f.decl.inputs, arg_name, ~\"argument\");\n }\n \n fn check_expr(e: &@env, ex: &@ast::expr, x: &(), v: &vt<()>) {\n     alt ex.node {\n       ast::expr_rec(fields, _) {\n         fn field_name(f: &ast::field) -> ident { ret f.node.ident; }\n-        ensure_unique(*e, ex.span, fields, field_name, \"field\");\n+        ensure_unique(*e, ex.span, fields, field_name, ~\"field\");\n       }\n       _ { }\n     }\n@@ -1388,24 +1394,24 @@ fn check_ty(e: &@env, ty: &@ast::ty, x: &(), v: &vt<()>) {\n     alt ty.node {\n       ast::ty_rec(fields) {\n         fn field_name(f: &ast::ty_field) -> ident { ret f.node.ident; }\n-        ensure_unique(*e, ty.span, fields, field_name, \"field\");\n+        ensure_unique(*e, ty.span, fields, field_name, ~\"field\");\n       }\n       _ { }\n     }\n     visit::visit_ty(ty, x, v);\n }\n \n-type checker = @{mutable seen: [ident], kind: str, sess: session};\n+type checker = @{mutable seen: [ident], kind: istr, sess: session};\n \n-fn checker(e: &env, kind: str) -> checker {\n+fn checker(e: &env, kind: &istr) -> checker {\n     let seen: [ident] = [];\n     ret @{mutable seen: seen, kind: kind, sess: e.sess};\n }\n \n fn check_name(ch: &checker, sp: &span, name: &ident) {\n     for s: ident in ch.seen {\n         if istr::eq(s, name) {\n-            ch.sess.span_fatal(sp, \"duplicate \" + ch.kind\n+            ch.sess.span_fatal(sp, \"duplicate \" + istr::to_estr(ch.kind)\n                                + \" name: \" + istr::to_estr(name));\n         }\n     }\n@@ -1418,7 +1424,7 @@ fn add_name(ch: &checker, sp: &span, name: &ident) {\n fn ident_id(i: &ident) -> ident { ret i; }\n \n fn ensure_unique<T>(e: &env, sp: &span, elts: &[T], id: fn(&T) -> ident,\n-                    kind: &str) {\n+                    kind: &istr) {\n     let ch = checker(e, kind);\n     for elt: T in elts { add_name(ch, sp, id(elt)); }\n }"}, {"sha": "201e4ee0501c5fb84b43f19d05b10cc35669f30d", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d70685eefc98668804c05428bb94f43933cca61/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d70685eefc98668804c05428bb94f43933cca61/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=7d70685eefc98668804c05428bb94f43933cca61", "patch": "@@ -85,9 +85,9 @@ fn eq_res_info(a: &res_info, b: &res_info) -> bool {\n     ret a.did.crate == b.did.crate && a.did.node == b.did.node && a.t == b.t;\n }\n \n-fn mk_global(ccx: &@crate_ctxt, name: &str, llval: ValueRef,\n+fn mk_global(ccx: &@crate_ctxt, name: &istr, llval: ValueRef,\n              internal: bool) -> ValueRef {\n-    let llglobal = istr::as_buf(istr::from_estr(name), { |buf|\n+    let llglobal = istr::as_buf(name, { |buf|\n         lib::llvm::llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval), buf)\n     });\n     lib::llvm::llvm::LLVMSetInitializer(llglobal, llval);\n@@ -521,7 +521,7 @@ fn gen_tag_shapes(ccx: &@crate_ctxt) -> ValueRef {\n     header += data;\n     header += lv_table;\n \n-    ret mk_global(ccx, \"tag_shapes\", C_bytes(header), true);\n+    ret mk_global(ccx, ~\"tag_shapes\", C_bytes(header), true);\n }\n \n fn gen_resource_shapes(ccx: &@crate_ctxt) -> ValueRef {\n@@ -534,7 +534,7 @@ fn gen_resource_shapes(ccx: &@crate_ctxt) -> ValueRef {\n         i += 1u;\n     }\n \n-    ret mk_global(ccx, \"resource_shapes\", C_struct(dtors), true);\n+    ret mk_global(ccx, ~\"resource_shapes\", C_struct(dtors), true);\n }\n \n fn gen_shape_tables(ccx: &@crate_ctxt) {"}, {"sha": "aaa804fc880f24901516b5994daf2346e24f5352", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d70685eefc98668804c05428bb94f43933cca61/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d70685eefc98668804c05428bb94f43933cca61/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=7d70685eefc98668804c05428bb94f43933cca61", "patch": "@@ -6403,7 +6403,7 @@ fn write_metadata(cx: &@crate_ctxt, crate: &@ast::crate) {\n \n // Writes the current ABI version into the crate.\n fn write_abi_version(ccx: &@crate_ctxt) {\n-    shape::mk_global(ccx, \"rust_abi_version\", C_uint(abi::abi_version),\n+    shape::mk_global(ccx, ~\"rust_abi_version\", C_uint(abi::abi_version),\n                      false);\n }\n "}, {"sha": "d0c909338df0522b27406fce7793cffa2caaa190", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d70685eefc98668804c05428bb94f43933cca61/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d70685eefc98668804c05428bb94f43933cca61/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=7d70685eefc98668804c05428bb94f43933cca61", "patch": "@@ -527,7 +527,7 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n       }\n     }\n \n-    ret finish_vtbl(cx, llmethods, \"vtbl\");\n+    ret finish_vtbl(cx, llmethods, ~\"vtbl\");\n }\n \n // create_backwarding_vtbl: Create a vtable for the inner object of an\n@@ -561,16 +561,16 @@ fn create_backwarding_vtbl(cx: @local_ctxt, sp: &span, inner_obj_ty: ty::t,\n         // being forwarded to.\n         llmethods += [process_bkwding_mthd(cx, sp, @m, [], outer_obj_ty, [])];\n     }\n-    ret finish_vtbl(cx, llmethods, \"backwarding_vtbl\");\n+    ret finish_vtbl(cx, llmethods, ~\"backwarding_vtbl\");\n }\n \n // finish_vtbl: Given a vector of vtable entries, create the table in\n // read-only memory and return a pointer to it.\n-fn finish_vtbl(cx: @local_ctxt, llmethods: [ValueRef], name: str) ->\n+fn finish_vtbl(cx: @local_ctxt, llmethods: [ValueRef], name: &istr) ->\n    ValueRef {\n     let vtbl = C_struct(llmethods);\n     let vtbl_name = mangle_internal_name_by_path(\n-        cx.ccx, cx.path + [istr::from_estr(name)]);\n+        cx.ccx, cx.path + [name]);\n     let gvar = istr::as_buf(vtbl_name, { |buf|\n         llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl), buf)\n     });"}, {"sha": "d8d495d11a2715ec19492ade6034073d860923bb", "filename": "src/comp/middle/tstate/ann.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d70685eefc98668804c05428bb94f43933cca61/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d70685eefc98668804c05428bb94f43933cca61/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs?ref=7d70685eefc98668804c05428bb94f43933cca61", "patch": "@@ -239,8 +239,8 @@ fn implies(a: t, b: t) -> bool {\n     ret tritv_doesntcare(tmp);\n }\n \n-fn trit_str(t: trit) -> str {\n-    alt t { dont_care. { \"?\" } ttrue. { \"1\" } tfalse. { \"0\" } }\n+fn trit_str(t: trit) -> istr {\n+    alt t { dont_care. { ~\"?\" } ttrue. { ~\"1\" } tfalse. { ~\"0\" } }\n }\n //\n // Local Variables:"}, {"sha": "726af3dc07741ce360cbf11a9139fe6e1e0fdbfe", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7d70685eefc98668804c05428bb94f43933cca61/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d70685eefc98668804c05428bb94f43933cca61/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=7d70685eefc98668804c05428bb94f43933cca61", "patch": "@@ -56,47 +56,48 @@ tag oper_type {\n }\n \n /* logging funs */\n-fn def_id_to_str(d: def_id) -> str {\n-    ret istr::to_estr(int::str(d.crate) + ~\",\" + int::str(d.node));\n+fn def_id_to_str(d: def_id) -> istr {\n+    ret int::str(d.crate) + ~\",\" + int::str(d.node);\n }\n \n-fn comma_str(args: &[@constr_arg_use]) -> str {\n-    let rslt = \"\";\n+fn comma_str(args: &[@constr_arg_use]) -> istr {\n+    let rslt = ~\"\";\n     let comma = false;\n     for a: @constr_arg_use in args {\n-        if comma { rslt += \", \"; } else { comma = true; }\n+        if comma { rslt += ~\", \"; } else { comma = true; }\n         alt a.node {\n-          carg_base. { rslt += \"*\"; }\n-          carg_ident(i) { rslt += istr::to_estr(i.ident); }\n-          carg_lit(l) { rslt += lit_to_str(l); }\n+          carg_base. { rslt += ~\"*\"; }\n+          carg_ident(i) { rslt += i.ident; }\n+          carg_lit(l) { rslt += istr::from_estr(lit_to_str(l)); }\n         }\n     }\n     ret rslt;\n }\n \n-fn constraint_to_str(tcx: &ty::ctxt, c: &sp_constr) -> str {\n+fn constraint_to_str(tcx: &ty::ctxt, c: &sp_constr) -> istr {\n     alt c.node {\n       ninit(_, i) {\n-        ret \"init(\" +\n-            istr::to_estr(i) + \" [\" + tcx.sess.span_str(c.span) + \"])\";\n+        ret ~\"init(\" + i + ~\" [\" +\n+            istr::from_estr(tcx.sess.span_str(c.span)) + ~\"])\";\n       }\n       npred(p, _, args) {\n-        ret path_to_str(p) + \"(\" + comma_str(args) + \")\" + \"[\" +\n-                tcx.sess.span_str(c.span) + \"]\";\n+        ret istr::from_estr(path_to_str(p)) + ~\"(\" +\n+            comma_str(args) + ~\")\" + ~\"[\" +\n+                istr::from_estr(tcx.sess.span_str(c.span)) + ~\"]\";\n       }\n     }\n }\n \n-fn tritv_to_str(fcx: fn_ctxt, v: &tritv::t) -> str {\n-    let s = \"\";\n+fn tritv_to_str(fcx: fn_ctxt, v: &tritv::t) -> istr {\n+    let s = ~\"\";\n     let comma = false;\n     for p: norm_constraint in constraints(fcx) {\n         alt tritv_get(v, p.bit_num) {\n           dont_care. { }\n           t {\n             s +=\n-                if comma { \", \" } else { comma = true; \"\" } +\n-                    if t == tfalse { \"!\" } else { \"\" } +\n+                if comma { ~\", \" } else { comma = true; ~\"\" } +\n+                    if t == tfalse { ~\"!\" } else { ~\"\" } +\n                     constraint_to_str(fcx.ccx.tcx, p.c);\n           }\n         }\n@@ -107,8 +108,8 @@ fn tritv_to_str(fcx: fn_ctxt, v: &tritv::t) -> str {\n fn log_tritv(fcx: &fn_ctxt, v: &tritv::t) { log tritv_to_str(fcx, v); }\n \n fn first_difference_string(fcx: &fn_ctxt, expected: &tritv::t,\n-                           actual: &tritv::t) -> str {\n-    let s: str = \"\";\n+                           actual: &tritv::t) -> istr {\n+    let s: istr = ~\"\";\n     for c: norm_constraint in constraints(fcx) {\n         if tritv_get(expected, c.bit_num) == ttrue &&\n                tritv_get(actual, c.bit_num) != ttrue {\n@@ -120,12 +121,12 @@ fn first_difference_string(fcx: &fn_ctxt, expected: &tritv::t,\n \n fn log_tritv_err(fcx: fn_ctxt, v: tritv::t) { log_err tritv_to_str(fcx, v); }\n \n-fn tos(v: &[uint]) -> str {\n-    let rslt = \"\";\n+fn tos(v: &[uint]) -> istr {\n+    let rslt = ~\"\";\n     for i: uint in v {\n         if i == 0u {\n-            rslt += \"0\";\n-        } else if i == 1u { rslt += \"1\"; } else { rslt += \"?\"; }\n+            rslt += ~\"0\";\n+        } else if i == 1u { rslt += ~\"1\"; } else { rslt += ~\"?\"; }\n     }\n     ret rslt;\n }\n@@ -597,7 +598,7 @@ fn match_args(fcx: &fn_ctxt, occs: &@mutable [pred_args],\n                 ret istr::to_estr(i.ident);\n             }, occ);\n     for pd: pred_args in *occs {\n-        log \"match_args: candidate \" + pred_args_to_str(pd);\n+        log ~\"match_args: candidate \" + pred_args_to_str(pd);\n         fn eq(p: &inst, q: &inst) -> bool { ret p.node == q.node; }\n         if ty::args_eq(eq, pd.node.args, occ) { ret pd.node.bit_num; }\n     }\n@@ -685,12 +686,12 @@ fn expr_to_constr(tcx: ty::ctxt, e: &@expr) -> sp_constr {\n     }\n }\n \n-fn pred_args_to_str(p: &pred_args) -> str {\n-    \"<\" + istr::to_estr(uint::str(p.node.bit_num)) + \", \" +\n-        constr_args_to_str(fn (i: &inst) -> str {\n-            ret istr::to_estr(i.ident);\n-        }, p.node.args)\n-        + \">\"\n+fn pred_args_to_str(p: &pred_args) -> istr {\n+    istr::from_estr(\"<\" + istr::to_estr(uint::str(p.node.bit_num)) + \", \" +\n+                  constr_args_to_str(fn (i: &inst) -> str {\n+                      ret istr::to_estr(i.ident);\n+                  }, p.node.args)\n+                  + \">\")\n }\n \n fn substitute_constr_args(cx: &ty::ctxt, actuals: &[@expr], c: &@ty::constr)\n@@ -789,18 +790,18 @@ fn find_in_subst_bool(s: &subst, id: node_id) -> bool {\n     is_some(find_in_subst(id, s))\n }\n \n-fn insts_to_str(stuff: &[constr_arg_general_<inst>]) -> str {\n-    let rslt = \"<\";\n+fn insts_to_str(stuff: &[constr_arg_general_<inst>]) -> istr {\n+    let rslt = ~\"<\";\n     for i: constr_arg_general_<inst> in stuff {\n         rslt +=\n-            \" \" +\n+            ~\" \" +\n                 alt i {\n-                  carg_ident(p) { istr::to_estr(p.ident) }\n-                  carg_base. { \"*\" }\n-                  carg_lit(_) { \"[lit]\" }\n-                } + \" \";\n+                  carg_ident(p) { p.ident }\n+                  carg_base. { ~\"*\" }\n+                  carg_lit(_) { ~\"[lit]\" }\n+                } + ~\" \";\n     }\n-    rslt += \">\";\n+    rslt += ~\">\";\n     rslt\n }\n "}, {"sha": "75d8ec1aa6b116372ad32e1b4290b3cfb8cb6936", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7d70685eefc98668804c05428bb94f43933cca61/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d70685eefc98668804c05428bb94f43933cca61/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=7d70685eefc98668804c05428bb94f43933cca61", "patch": "@@ -82,17 +82,17 @@ fn check_states_expr(e: &@expr, fcx: &fn_ctxt, v: &visit::vt<fn_ctxt>) {\n     */\n \n     if !implies(pres, prec) {\n-        let s = \"\";\n+        let s = ~\"\";\n         let diff = first_difference_string(fcx, prec, pres);\n         s +=\n-            \"Unsatisfied precondition constraint (for example, \" + diff +\n-                \") for expression:\\n\";\n-        s += syntax::print::pprust::expr_to_str(e);\n-        s += \"\\nPrecondition:\\n\";\n+            ~\"Unsatisfied precondition constraint (for example, \" + diff +\n+                ~\") for expression:\\n\";\n+        s += istr::from_estr(syntax::print::pprust::expr_to_str(e));\n+        s += ~\"\\nPrecondition:\\n\";\n         s += tritv_to_str(fcx, prec);\n-        s += \"\\nPrestate:\\n\";\n+        s += ~\"\\nPrestate:\\n\";\n         s += tritv_to_str(fcx, pres);\n-        fcx.ccx.tcx.sess.span_fatal(e.span, s);\n+        fcx.ccx.tcx.sess.span_fatal(e.span, istr::to_estr(s));\n     }\n }\n \n@@ -114,17 +114,17 @@ fn check_states_stmt(s: &@stmt, fcx: &fn_ctxt, v: &visit::vt<fn_ctxt>) {\n     */\n \n     if !implies(pres, prec) {\n-        let ss = \"\";\n+        let ss = ~\"\";\n         let diff = first_difference_string(fcx, prec, pres);\n         ss +=\n-            \"Unsatisfied precondition constraint (for example, \" + diff +\n-                \") for statement:\\n\";\n-        ss += syntax::print::pprust::stmt_to_str(*s);\n-        ss += \"\\nPrecondition:\\n\";\n+            ~\"Unsatisfied precondition constraint (for example, \" + diff +\n+                ~\") for statement:\\n\";\n+        ss += istr::from_estr(syntax::print::pprust::stmt_to_str(*s));\n+        ss += ~\"\\nPrecondition:\\n\";\n         ss += tritv_to_str(fcx, prec);\n-        ss += \"\\nPrestate: \\n\";\n+        ss += ~\"\\nPrestate: \\n\";\n         ss += tritv_to_str(fcx, pres);\n-        fcx.ccx.tcx.sess.span_fatal(s.span, ss);\n+        fcx.ccx.tcx.sess.span_fatal(s.span, istr::to_estr(ss));\n     }\n }\n "}, {"sha": "ebf932b1fbd9332f0bd205268f240620ab4e5a7b", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d70685eefc98668804c05428bb94f43933cca61/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d70685eefc98668804c05428bb94f43933cca61/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=7d70685eefc98668804c05428bb94f43933cca61", "patch": "@@ -61,8 +61,8 @@ fn find_locals(tcx: &ty::ctxt, f: &_fn, tps: &[ty_param], sp: &span,\n \n fn add_constraint(tcx: &ty::ctxt, c: sp_constr, next: uint, tbl: constr_map)\n    -> uint {\n-    log constraint_to_str(tcx, c) + \" |-> \"\n-        + istr::to_estr(std::uint::str(next));\n+    log constraint_to_str(tcx, c) + ~\" |-> \"\n+        + std::uint::str(next);\n     alt c.node {\n       ninit(id, i) { tbl.insert(local_def(id), cinit(next, c.span, i)); }\n       npred(p, d_id, args) {"}, {"sha": "78245adc22c10d43264d6160d807bebcdf3bcd2f", "filename": "src/comp/middle/tstate/tritv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d70685eefc98668804c05428bb94f43933cca61/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d70685eefc98668804c05428bb94f43933cca61/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs?ref=7d70685eefc98668804c05428bb94f43933cca61", "patch": "@@ -261,15 +261,15 @@ fn to_vec(v: &t) -> [uint] {\n     ret rslt;\n }\n \n-fn to_str(v: &t) -> str {\n+fn to_str(v: &t) -> istr {\n     let i: uint = 0u;\n-    let rs: str = \"\";\n+    let rs: istr = ~\"\";\n     while i < v.nbits {\n         rs +=\n             alt tritv_get(v, i) {\n-              dont_care. { \"?\" }\n-              ttrue. { \"1\" }\n-              tfalse. { \"0\" }\n+              dont_care. { ~\"?\" }\n+              ttrue. { ~\"1\" }\n+              tfalse. { ~\"0\" }\n             };\n         i += 1u;\n     }"}]}