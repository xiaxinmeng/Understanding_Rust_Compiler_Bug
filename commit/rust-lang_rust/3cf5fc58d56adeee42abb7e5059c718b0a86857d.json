{"sha": "3cf5fc58d56adeee42abb7e5059c718b0a86857d", "node_id": "C_kwDOAAsO6NoAKDNjZjVmYzU4ZDU2YWRlZWU0MmFiYjdlNTA1OWM3MThiMGE4Njg1N2Q", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-13T03:33:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-13T03:33:40Z"}, "message": "Auto merge of #102995 - JohnTitor:rollup-yomkwge, r=JohnTitor\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #102641 (Support casting boxes to dyn*)\n - #102836 (rustc_target: Fix json target specs using LLD linker flavors in link args)\n - #102949 (should-skip-this: add missing backslash)\n - #102967 (Add test for issue 102964)\n - #102971 (tidy: error if a lang feature is already present)\n - #102974 (Fix small word dupe typos)\n - #102980 (rustdoc: merge separate `.item-info` CSS)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "82819af2de9e0f2863eb6ead3756f3350b81d351", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82819af2de9e0f2863eb6ead3756f3350b81d351"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cf5fc58d56adeee42abb7e5059c718b0a86857d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cf5fc58d56adeee42abb7e5059c718b0a86857d", "html_url": "https://github.com/rust-lang/rust/commit/3cf5fc58d56adeee42abb7e5059c718b0a86857d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cf5fc58d56adeee42abb7e5059c718b0a86857d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a9217601c0e5ae83fa8bca6797137a6d2f7e4e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a9217601c0e5ae83fa8bca6797137a6d2f7e4e5", "html_url": "https://github.com/rust-lang/rust/commit/2a9217601c0e5ae83fa8bca6797137a6d2f7e4e5"}, {"sha": "e8029368d3ccba813cd1ed56a7cf5c0ab124f2f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8029368d3ccba813cd1ed56a7cf5c0ab124f2f0", "html_url": "https://github.com/rust-lang/rust/commit/e8029368d3ccba813cd1ed56a7cf5c0ab124f2f0"}], "stats": {"total": 385, "additions": 226, "deletions": 159}, "files": [{"sha": "4ed99df1e81697a8116474939642a20837a6f88d", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -14,6 +14,7 @@ use rustc_middle::ty::cast::{CastTy, IntTy};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, Ty, TyCtxt};\n use rustc_span::source_map::{Span, DUMMY_SP};\n+use rustc_target::abi::Size;\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     #[instrument(level = \"trace\", skip(self, bx))]\n@@ -285,6 +286,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 bug!(\"Only valid to do a DynStar cast into a DynStar type\")\n                             };\n                         let vtable = get_vtable(bx.cx(), source.ty(self.mir, bx.tcx()), trait_ref);\n+                        let vtable = bx.pointercast(vtable, bx.cx().type_ptr_to(bx.cx().type_isize()));\n+                        // FIXME(dyn-star): this is probably not the best way to check if this is\n+                        // a pointer, and really we should ensure that the value is a suitable\n+                        // pointer earlier in the compilation process.\n+                        let data = match operand.layout.pointee_info_at(bx.cx(), Size::ZERO) {\n+                            Some(_) => bx.ptrtoint(data, bx.cx().type_isize()),\n+                            None => data,\n+                        };\n                         OperandValue::Pair(data, vtable)\n                     }\n                     mir::CastKind::Pointer("}, {"sha": "6ed8370e8c1c7f64fec42dc1cc6ff3fcbda2024c", "filename": "compiler/rustc_error_codes/src/error_codes/E0591.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0591.md", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0591.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0591.md?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -53,8 +53,8 @@ unsafe {\n ```\n \n Here, transmute is being used to convert the types of the fn arguments.\n-This pattern is incorrect because, because the type of `foo` is a function\n-**item** (`typeof(foo)`), which is zero-sized, and the target type (`fn()`)\n+This pattern is incorrect because the type of `foo` is a function **item**\n+(`typeof(foo)`), which is zero-sized, and the target type (`fn()`)\n is a function pointer, which is not zero-sized.\n This pattern should be rewritten. There are a few possible ways to do this:\n "}, {"sha": "5a5e9db81a2433d73cf78492dbe31d49bafadcde", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -1283,7 +1283,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         assert!(old_value.is_none());\n     }\n \n-    /// Process the region constraints and return any any errors that\n+    /// Process the region constraints and return any errors that\n     /// result. After this, no more unification operations should be\n     /// done -- or the compiler will panic -- but it is legal to use\n     /// `resolve_vars_if_possible` as well as `fully_resolve`."}, {"sha": "8909cf33af9118cde6a9451f93f5fb9184c6c480", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -1739,11 +1739,15 @@ impl TargetOptions {\n                     self.lld_flavor_json,\n                     self.linker_is_gnu_json,\n                 );\n-                match linker_flavor {\n-                    LinkerFlavor::Gnu(_, Lld::Yes)\n-                    | LinkerFlavor::Darwin(_, Lld::Yes)\n-                    | LinkerFlavor::Msvc(Lld::Yes) => {}\n-                    _ => add_link_args_iter(args, linker_flavor, args_json.iter().cloned()),\n+                // Normalize to no lld to avoid asserts.\n+                let linker_flavor = match linker_flavor {\n+                    LinkerFlavor::Gnu(cc, _) => LinkerFlavor::Gnu(cc, Lld::No),\n+                    LinkerFlavor::Darwin(cc, _) => LinkerFlavor::Darwin(cc, Lld::No),\n+                    LinkerFlavor::Msvc(_) => LinkerFlavor::Msvc(Lld::No),\n+                    _ => linker_flavor,\n+                };\n+                if !args.contains_key(&linker_flavor) {\n+                    add_link_args_iter(args, linker_flavor, args_json.iter().cloned());\n                 }\n             }\n         }"}, {"sha": "16c634e9afd50110519875b191aa035c3bc6e13e", "filename": "library/std/src/io/error/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -86,7 +86,7 @@ fn test_errorkind_packing() {\n     assert_eq!(Error::from(ErrorKind::NotFound).kind(), ErrorKind::NotFound);\n     assert_eq!(Error::from(ErrorKind::PermissionDenied).kind(), ErrorKind::PermissionDenied);\n     assert_eq!(Error::from(ErrorKind::Uncategorized).kind(), ErrorKind::Uncategorized);\n-    // Check that the innards look like like what we want.\n+    // Check that the innards look like what we want.\n     assert_matches!(\n         Error::from(ErrorKind::OutOfMemory).repr.data(),\n         ErrorData::Simple(ErrorKind::OutOfMemory),"}, {"sha": "94546ca09d00d859bdf3863eb4cead3f9223d120", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -20,7 +20,7 @@\n //! Since those syscalls have requirements that cannot be fully checked in advance and\n //! gathering additional information about file descriptors would require additional syscalls\n //! anyway it simply attempts to use them one after another (guided by inaccurate hints) to\n-//! figure out which one works and and falls back to the generic read-write copy loop if none of them\n+//! figure out which one works and falls back to the generic read-write copy loop if none of them\n //! does.\n //! Once a working syscall is found for a pair of file descriptors it will be called in a loop\n //! until the copy operation is completed."}, {"sha": "a8a1899317f87d37ec99930391986252d6a363f4", "filename": "src/ci/scripts/should-skip-this.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Fci%2Fscripts%2Fshould-skip-this.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Fci%2Fscripts%2Fshould-skip-this.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fshould-skip-this.sh?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -19,7 +19,7 @@ if [[ -n \"${CI_ONLY_WHEN_SUBMODULES_CHANGED-}\" ]]; then\n         # those files are present in the diff a submodule was updated.\n         echo \"Submodules were updated\"\n     elif ! (git diff --quiet \"$BASE_COMMIT\" -- \\\n-             src/tools/clippy src/tools/rustfmt src/tools/miri\n+             src/tools/clippy src/tools/rustfmt src/tools/miri \\\n              library/std/src/sys); then\n         # There is not an easy blanket search for subtrees. For now, manually list\n         # the subtrees."}, {"sha": "5958b389c9f4c5c0472abe21e1c0385848b3d1a0", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -692,16 +692,13 @@ pre, .rustdoc.source .example-wrap {\n \n .item-info {\n \tdisplay: block;\n+\tmargin-left: 24px;\n }\n \n-.content .item-info code {\n+.item-info code {\n \tfont-size: 0.875rem;\n }\n \n-.content .item-info {\n-\tmargin-left: 24px;\n-}\n-\n #main-content > .item-info {\n \tmargin-top: 0;\n \tmargin-left: 0;\n@@ -1945,7 +1942,7 @@ in storage.js plus the media query with (min-width: 701px)\n \t}\n \n \t/* Align summary-nested and unnested item-info gizmos. */\n-\t.content .impl-items > .item-info {\n+\t.impl-items > .item-info {\n \t\tmargin-left: 34px;\n \t}\n }"}, {"sha": "1714cec5221de4e8cdeb6b9819f31d25dc8c9d64", "filename": "src/test/ui/async-await/issue-64130-1-sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-1-sync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-1-sync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-1-sync.rs?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -1,7 +1,7 @@\n #![feature(negative_impls)]\n // edition:2018\n \n-// This tests the the specialized async-await-specific error when futures don't implement an\n+// This tests the specialized async-await-specific error when futures don't implement an\n // auto trait (which is specifically Sync) due to some type that was captured.\n \n struct Foo;"}, {"sha": "7a6e5952cb956df7bfed253cb716c31dd01bec01", "filename": "src/test/ui/async-await/issue-64130-2-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-2-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-2-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-2-send.rs?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -1,7 +1,7 @@\n #![feature(negative_impls)]\n // edition:2018\n \n-// This tests the the specialized async-await-specific error when futures don't implement an\n+// This tests the specialized async-await-specific error when futures don't implement an\n // auto trait (which is specifically Send) due to some type that was captured.\n \n struct Foo;"}, {"sha": "630fb2c41cded629a7d0c6eb9c452988a6e2632d", "filename": "src/test/ui/async-await/issue-64130-3-other.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-3-other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-3-other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-3-other.rs?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -2,7 +2,7 @@\n #![feature(negative_impls)]\n // edition:2018\n \n-// This tests the the unspecialized async-await-specific error when futures don't implement an\n+// This tests the unspecialized async-await-specific error when futures don't implement an\n // auto trait (which is not Send or Sync) due to some type that was captured.\n \n auto trait Qux {}"}, {"sha": "9b1212694f5ba886a0534ebb5f3c931ee65e0363", "filename": "src/test/ui/const-generics/occurs-check/unused-substs-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-2.rs?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -1,7 +1,7 @@\n #![feature(generic_const_exprs)]\n #![allow(incomplete_features)]\n \n-// The goal is is to get an unevaluated const `ct` with a `Ty::Infer(TyVar(_#1t)` subst.\n+// The goal is to get an unevaluated const `ct` with a `Ty::Infer(TyVar(_#1t)` subst.\n //\n // If we are then able to infer `ty::Infer(TyVar(_#1t) := Ty<ct>` we introduced an\n // artificial inference cycle."}, {"sha": "d5aeab47e62b0ae2ad0fd1fdab330d98edf1c246", "filename": "src/test/ui/const-generics/occurs-check/unused-substs-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-3.rs?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -1,7 +1,7 @@\n #![feature(generic_const_exprs)]\n #![allow(incomplete_features)]\n \n-// The goal is is to get an unevaluated const `ct` with a `Ty::Infer(TyVar(_#1t)` subst.\n+// The goal is to get an unevaluated const `ct` with a `Ty::Infer(TyVar(_#1t)` subst.\n //\n // If we are then able to infer `ty::Infer(TyVar(_#1t) := Ty<ct>` we introduced an\n // artificial inference cycle."}, {"sha": "0417e952eb71d3a19571384b623ada2e6cb97472", "filename": "src/test/ui/deprecation/deprecation-lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint.rs?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -51,7 +51,7 @@ mod cross_crate {\n \n         let _ = nested::DeprecatedTupleStruct (1); //~ ERROR use of deprecated tuple struct `deprecation_lint::nested::DeprecatedTupleStruct`: text\n \n-        // At the moment, the lint checker only checks stability in\n+        // At the moment, the lint checker only checks stability\n         // in the arguments of macros.\n         // Eventually, we will want to lint the contents of the\n         // macro in the module *defining* it. Also, stability levels"}, {"sha": "d1f1819d9f35f1e49f8fb9a1aa86b463f32e8458", "filename": "src/test/ui/dyn-star/box.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fdyn-star%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fdyn-star%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fbox.rs?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+// compile-flags: -C opt-level=0\n+\n+#![feature(dyn_star)]\n+#![allow(incomplete_features)]\n+\n+use std::fmt::Display;\n+\n+fn make_dyn_star() -> dyn* Display {\n+    Box::new(42) as dyn* Display\n+}\n+\n+fn main() {\n+    let x = make_dyn_star();\n+\n+    println!(\"{x}\");\n+}"}, {"sha": "ef1d866c3ff3b153a3e25b200dbbfc674106accb", "filename": "src/test/ui/explain.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fexplain.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fexplain.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexplain.stdout?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -47,8 +47,8 @@ unsafe {\n ```\n \n Here, transmute is being used to convert the types of the fn arguments.\n-This pattern is incorrect because, because the type of `foo` is a function\n-**item** (`typeof(foo)`), which is zero-sized, and the target type (`fn()`)\n+This pattern is incorrect because the type of `foo` is a function **item**\n+(`typeof(foo)`), which is zero-sized, and the target type (`fn()`)\n is a function pointer, which is not zero-sized.\n This pattern should be rewritten. There are a few possible ways to do this:\n "}, {"sha": "43ff23600766e8bc36b096ec152add8bb1b8c477", "filename": "src/test/ui/issues/issue-102964.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fissues%2Fissue-102964.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fissues%2Fissue-102964.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-102964.rs?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -0,0 +1,10 @@\n+use std::rc::Rc;\n+type Foo<'a, T> = &'a dyn Fn(&T);\n+type RcFoo<'a, T> = Rc<Foo<'a, T>>;\n+\n+fn bar_function<T>(function: Foo<T>) -> RcFoo<T> {\n+    //~^ ERROR mismatched types\n+    let rc = Rc::new(function);\n+}\n+\n+fn main() {}"}, {"sha": "4504039097b5d78c1dadaf1234828333d9ae28c2", "filename": "src/test/ui/issues/issue-102964.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fissues%2Fissue-102964.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fissues%2Fissue-102964.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-102964.stderr?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -0,0 +1,19 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-102964.rs:5:41\n+   |\n+LL | fn bar_function<T>(function: Foo<T>) -> RcFoo<T> {\n+   |    ------------                         ^^^^^^^^ expected struct `Rc`, found `()`\n+   |    |\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n+   |\n+   = note: expected struct `Rc<&dyn for<'a> Fn(&'a T)>`\n+           found unit type `()`\n+help: consider returning the local binding `rc`\n+   |\n+LL ~     let rc = Rc::new(function);\n+LL +     rc\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "3470a7e09ad8bba2948234a4df95c25a5796e53f", "filename": "src/test/ui/issues/issue-29746.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fissues%2Fissue-29746.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fissues%2Fissue-29746.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-29746.rs?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -7,7 +7,7 @@ macro_rules! zip {\n         zip!([$($rest),*], $a.zip($b), (x,y), [x,y])\n     };\n \n-    // Intermediate steps to build the zipped expression, the match pattern, and\n+    // Intermediate steps to build the zipped expression, the match pattern\n     //  and the output tuple of the closure, using macro hygiene to repeatedly\n     //  introduce new variables named 'x'.\n     ([$a:expr, $($rest:expr),*], $zip:expr, $pat:pat, [$($flat:expr),*]) => {"}, {"sha": "6da99cf6435cff9b9050d8788358eef382caced4", "filename": "src/test/ui/issues/issue-75907.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fissues%2Fissue-75907.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fissues%2Fissue-75907.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-75907.rs?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -1,4 +1,4 @@\n-// Test for for diagnostic improvement issue #75907\n+// Test for diagnostic improvement issue #75907\n \n mod foo {\n     pub(crate) struct Foo(u8);"}, {"sha": "fdfc5907c167477108221f9729ff8d9f74ed92b5", "filename": "src/test/ui/issues/issue-75907_b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fissues%2Fissue-75907_b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fissues%2Fissue-75907_b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-75907_b.rs?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -1,4 +1,4 @@\n-// Test for for diagnostic improvement issue #75907, extern crate\n+// Test for diagnostic improvement issue #75907, extern crate\n // aux-build:issue-75907.rs\n \n extern crate issue_75907 as a;"}, {"sha": "74c35083e60b5766f9e22b642a40357b6b08f9eb", "filename": "src/test/ui/lint/lint-stability-deprecated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Flint%2Flint-stability-deprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Flint%2Flint-stability-deprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-stability-deprecated.rs?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -130,7 +130,7 @@ mod cross_crate {\n         let _ = UnstableTupleStruct (1);\n         let _ = StableTupleStruct (1);\n \n-        // At the moment, the lint checker only checks stability in\n+        // At the moment, the lint checker only checks stability\n         // in the arguments of macros.\n         // Eventually, we will want to lint the contents of the\n         // macro in the module *defining* it. Also, stability levels"}, {"sha": "70b8d8da19b3261d070d3a5f28d9c35f43c053f3", "filename": "src/test/ui/proc-macro/meta-macro-hygiene.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.rs?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -19,8 +19,8 @@ macro_rules! produce_it {\n         // `print_def_site!` will respan the `$crate` identifier\n         // with `Span::def_site()`. This should cause it to resolve\n         // relative to `meta_macro`, *not* `make_macro` (despite\n-        // the fact that that `print_def_site` is produced by\n-        // a `macro_rules!` macro in `make_macro`).\n+        // the fact that `print_def_site` is produced by a\n+        // `macro_rules!` macro in `make_macro`).\n         meta_macro::print_def_site!($crate::dummy!());\n     }\n }"}, {"sha": "6b7b0c819cca6a29ce39b6885bde715f280a6223", "filename": "src/test/ui/proc-macro/meta-macro-hygiene.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -35,8 +35,8 @@ macro_rules! produce_it\n         // `print_def_site!` will respan the `$crate` identifier\n         // with `Span::def_site()`. This should cause it to resolve\n         // relative to `meta_macro`, *not* `make_macro` (despite\n-        // the fact that that `print_def_site` is produced by\n-        // a `macro_rules!` macro in `make_macro`).\n+        // the fact that `print_def_site` is produced by a\n+        // `macro_rules!` macro in `make_macro`).\n     }\n }\n "}, {"sha": "f10ecf5f201e32e83b4c72e1583057a18922d7d5", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 137, "deletions": 126, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf5fc58d56adeee42abb7e5059c718b0a86857d/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=3cf5fc58d56adeee42abb7e5059c718b0a86857d", "patch": "@@ -10,7 +10,7 @@\n //! * Language features in a group are sorted by feature name.\n \n use crate::walk::{filter_dirs, walk, walk_many};\n-use std::collections::HashMap;\n+use std::collections::hash_map::{Entry, HashMap};\n use std::fmt;\n use std::fs;\n use std::num::NonZeroU32;\n@@ -280,13 +280,14 @@ fn test_filen_gate(filen_underscore: &str, features: &mut Features) -> bool {\n }\n \n pub fn collect_lang_features(base_compiler_path: &Path, bad: &mut bool) -> Features {\n-    let mut all = collect_lang_features_in(base_compiler_path, \"active.rs\", bad);\n-    all.extend(collect_lang_features_in(base_compiler_path, \"accepted.rs\", bad));\n-    all.extend(collect_lang_features_in(base_compiler_path, \"removed.rs\", bad));\n-    all\n+    let mut features = Features::new();\n+    collect_lang_features_in(&mut features, base_compiler_path, \"active.rs\", bad);\n+    collect_lang_features_in(&mut features, base_compiler_path, \"accepted.rs\", bad);\n+    collect_lang_features_in(&mut features, base_compiler_path, \"removed.rs\", bad);\n+    features\n }\n \n-fn collect_lang_features_in(base: &Path, file: &str, bad: &mut bool) -> Features {\n+fn collect_lang_features_in(features: &mut Features, base: &Path, file: &str, bad: &mut bool) {\n     let path = base.join(\"rustc_feature\").join(\"src\").join(file);\n     let contents = t!(fs::read_to_string(&path));\n \n@@ -298,135 +299,145 @@ fn collect_lang_features_in(base: &Path, file: &str, bad: &mut bool) -> Features\n     let mut in_feature_group = false;\n     let mut prev_names = vec![];\n \n-    contents\n-        .lines()\n-        .zip(1..)\n-        .filter_map(|(line, line_number)| {\n-            let line = line.trim();\n-\n-            // Within -start and -end, the tracking issue can be omitted.\n-            match line {\n-                \"// no-tracking-issue-start\" => {\n-                    next_feature_omits_tracking_issue = true;\n-                    return None;\n-                }\n-                \"// no-tracking-issue-end\" => {\n-                    next_feature_omits_tracking_issue = false;\n-                    return None;\n-                }\n-                _ => {}\n+    let lines = contents.lines().zip(1..);\n+    for (line, line_number) in lines {\n+        let line = line.trim();\n+\n+        // Within -start and -end, the tracking issue can be omitted.\n+        match line {\n+            \"// no-tracking-issue-start\" => {\n+                next_feature_omits_tracking_issue = true;\n+                continue;\n             }\n+            \"// no-tracking-issue-end\" => {\n+                next_feature_omits_tracking_issue = false;\n+                continue;\n+            }\n+            _ => {}\n+        }\n \n-            if line.starts_with(FEATURE_GROUP_START_PREFIX) {\n-                if in_feature_group {\n-                    tidy_error!(\n-                        bad,\n-                        \"{}:{}: \\\n+        if line.starts_with(FEATURE_GROUP_START_PREFIX) {\n+            if in_feature_group {\n+                tidy_error!(\n+                    bad,\n+                    \"{}:{}: \\\n                         new feature group is started without ending the previous one\",\n-                        path.display(),\n-                        line_number,\n-                    );\n-                }\n-\n-                in_feature_group = true;\n-                prev_names = vec![];\n-                return None;\n-            } else if line.starts_with(FEATURE_GROUP_END_PREFIX) {\n-                in_feature_group = false;\n-                prev_names = vec![];\n-                return None;\n+                    path.display(),\n+                    line_number,\n+                );\n             }\n \n-            let mut parts = line.split(',');\n-            let level = match parts.next().map(|l| l.trim().trim_start_matches('(')) {\n-                Some(\"active\") => Status::Unstable,\n-                Some(\"incomplete\") => Status::Unstable,\n-                Some(\"removed\") => Status::Removed,\n-                Some(\"accepted\") => Status::Stable,\n-                _ => return None,\n-            };\n-            let name = parts.next().unwrap().trim();\n-\n-            let since_str = parts.next().unwrap().trim().trim_matches('\"');\n-            let since = match since_str.parse() {\n-                Ok(since) => Some(since),\n-                Err(err) => {\n-                    tidy_error!(\n-                        bad,\n-                        \"{}:{}: failed to parse since: {} ({:?})\",\n-                        path.display(),\n-                        line_number,\n-                        since_str,\n-                        err,\n-                    );\n-                    None\n-                }\n-            };\n-            if in_feature_group {\n-                if prev_names.last() > Some(&name) {\n-                    // This assumes the user adds the feature name at the end of the list, as we're\n-                    // not looking ahead.\n-                    let correct_index = match prev_names.binary_search(&name) {\n-                        Ok(_) => {\n-                            // This only occurs when the feature name has already been declared.\n-                            tidy_error!(\n-                                bad,\n-                                \"{}:{}: duplicate feature {}\",\n-                                path.display(),\n-                                line_number,\n-                                name,\n-                            );\n-                            // skip any additional checks for this line\n-                            return None;\n-                        }\n-                        Err(index) => index,\n-                    };\n+            in_feature_group = true;\n+            prev_names = vec![];\n+            continue;\n+        } else if line.starts_with(FEATURE_GROUP_END_PREFIX) {\n+            in_feature_group = false;\n+            prev_names = vec![];\n+            continue;\n+        }\n \n-                    let correct_placement = if correct_index == 0 {\n-                        \"at the beginning of the feature group\".to_owned()\n-                    } else if correct_index == prev_names.len() {\n-                        // I don't believe this is reachable given the above assumption, but it\n-                        // doesn't hurt to be safe.\n-                        \"at the end of the feature group\".to_owned()\n-                    } else {\n-                        format!(\n-                            \"between {} and {}\",\n-                            prev_names[correct_index - 1],\n-                            prev_names[correct_index],\n-                        )\n-                    };\n+        let mut parts = line.split(',');\n+        let level = match parts.next().map(|l| l.trim().trim_start_matches('(')) {\n+            Some(\"active\") => Status::Unstable,\n+            Some(\"incomplete\") => Status::Unstable,\n+            Some(\"removed\") => Status::Removed,\n+            Some(\"accepted\") => Status::Stable,\n+            _ => continue,\n+        };\n+        let name = parts.next().unwrap().trim();\n+\n+        let since_str = parts.next().unwrap().trim().trim_matches('\"');\n+        let since = match since_str.parse() {\n+            Ok(since) => Some(since),\n+            Err(err) => {\n+                tidy_error!(\n+                    bad,\n+                    \"{}:{}: failed to parse since: {} ({:?})\",\n+                    path.display(),\n+                    line_number,\n+                    since_str,\n+                    err,\n+                );\n+                None\n+            }\n+        };\n+        if in_feature_group {\n+            if prev_names.last() > Some(&name) {\n+                // This assumes the user adds the feature name at the end of the list, as we're\n+                // not looking ahead.\n+                let correct_index = match prev_names.binary_search(&name) {\n+                    Ok(_) => {\n+                        // This only occurs when the feature name has already been declared.\n+                        tidy_error!(\n+                            bad,\n+                            \"{}:{}: duplicate feature {}\",\n+                            path.display(),\n+                            line_number,\n+                            name,\n+                        );\n+                        // skip any additional checks for this line\n+                        continue;\n+                    }\n+                    Err(index) => index,\n+                };\n \n-                    tidy_error!(\n-                        bad,\n-                        \"{}:{}: feature {} is not sorted by feature name (should be {})\",\n-                        path.display(),\n-                        line_number,\n-                        name,\n-                        correct_placement,\n-                    );\n-                }\n-                prev_names.push(name);\n+                let correct_placement = if correct_index == 0 {\n+                    \"at the beginning of the feature group\".to_owned()\n+                } else if correct_index == prev_names.len() {\n+                    // I don't believe this is reachable given the above assumption, but it\n+                    // doesn't hurt to be safe.\n+                    \"at the end of the feature group\".to_owned()\n+                } else {\n+                    format!(\n+                        \"between {} and {}\",\n+                        prev_names[correct_index - 1],\n+                        prev_names[correct_index],\n+                    )\n+                };\n+\n+                tidy_error!(\n+                    bad,\n+                    \"{}:{}: feature {} is not sorted by feature name (should be {})\",\n+                    path.display(),\n+                    line_number,\n+                    name,\n+                    correct_placement,\n+                );\n             }\n+            prev_names.push(name);\n+        }\n \n-            let issue_str = parts.next().unwrap().trim();\n-            let tracking_issue = if issue_str.starts_with(\"None\") {\n-                if level == Status::Unstable && !next_feature_omits_tracking_issue {\n-                    tidy_error!(\n-                        bad,\n-                        \"{}:{}: no tracking issue for feature {}\",\n-                        path.display(),\n-                        line_number,\n-                        name,\n-                    );\n-                }\n-                None\n-            } else {\n-                let s = issue_str.split('(').nth(1).unwrap().split(')').next().unwrap();\n-                Some(s.parse().unwrap())\n-            };\n-            Some((name.to_owned(), Feature { level, since, has_gate_test: false, tracking_issue }))\n-        })\n-        .collect()\n+        let issue_str = parts.next().unwrap().trim();\n+        let tracking_issue = if issue_str.starts_with(\"None\") {\n+            if level == Status::Unstable && !next_feature_omits_tracking_issue {\n+                tidy_error!(\n+                    bad,\n+                    \"{}:{}: no tracking issue for feature {}\",\n+                    path.display(),\n+                    line_number,\n+                    name,\n+                );\n+            }\n+            None\n+        } else {\n+            let s = issue_str.split('(').nth(1).unwrap().split(')').next().unwrap();\n+            Some(s.parse().unwrap())\n+        };\n+        match features.entry(name.to_owned()) {\n+            Entry::Occupied(e) => {\n+                tidy_error!(\n+                    bad,\n+                    \"{}:{} feature {name} already specified with status '{}'\",\n+                    path.display(),\n+                    line_number,\n+                    e.get().level,\n+                );\n+            }\n+            Entry::Vacant(e) => {\n+                e.insert(Feature { level, since, has_gate_test: false, tracking_issue });\n+            }\n+        }\n+    }\n }\n \n fn get_and_check_lib_features("}]}