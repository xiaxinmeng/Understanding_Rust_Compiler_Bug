{"sha": "0e06f71747749e33ca590c334658bddde97a7e54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlMDZmNzE3NDc3NDllMzNjYTU5MGMzMzQ2NThiZGRkZTk3YTdlNTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-25T15:48:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-25T15:48:05Z"}, "message": "auto merge of #18234 : pnkfelix/rust/fsk-type-fragments-for-needsdrop-2, r=nikomatsakis\n\nCode to fragment paths into pieces based on subparts being moved around, e.g. moving `x.1` out of a tuple `(A,B,C)` leaves behind the fragments `x.0: A` and `x.2: C`.  Further discussion in borrowck/doc.rs.\r\n\r\nIncludes differentiation between assigned_fragments and moved_fragments, support for all-but-one array fragments, and instrumentation to print out the moved/assigned/unmmoved/parents for each function, factored out into a separate submodule.\r\n\r\nThese fragments can then be used by `trans` to inject stack-local dynamic drop flags.  (They also can be hooked up with dataflow to reduce the expected number of injected flags.)", "tree": {"sha": "57a3fc9cca2562ea6595e95c54233915ce5b4c95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57a3fc9cca2562ea6595e95c54233915ce5b4c95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e06f71747749e33ca590c334658bddde97a7e54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e06f71747749e33ca590c334658bddde97a7e54", "html_url": "https://github.com/rust-lang/rust/commit/0e06f71747749e33ca590c334658bddde97a7e54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e06f71747749e33ca590c334658bddde97a7e54/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48ca6d1840818e4a8977d00ed62cf0e8e0e5d193", "url": "https://api.github.com/repos/rust-lang/rust/commits/48ca6d1840818e4a8977d00ed62cf0e8e0e5d193", "html_url": "https://github.com/rust-lang/rust/commit/48ca6d1840818e4a8977d00ed62cf0e8e0e5d193"}, {"sha": "5fbe0cac7c568774082755ecc098caba98352a1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fbe0cac7c568774082755ecc098caba98352a1e", "html_url": "https://github.com/rust-lang/rust/commit/5fbe0cac7c568774082755ecc098caba98352a1e"}], "stats": {"total": 2444, "additions": 2189, "deletions": 255}, "files": [{"sha": "f15db7d9371de78a3b26c820ead946c6b076e4d1", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 56, "deletions": 9, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -7,6 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+use self::WhichLine::*;\n \n use std::ascii::AsciiExt;\n use std::io::{BufferedReader, File};\n@@ -18,28 +19,74 @@ pub struct ExpectedError {\n     pub msg: String,\n }\n \n-pub static EXPECTED_PATTERN : &'static str = r\"//~(?P<adjusts>\\^*)\\s*(?P<kind>\\S*)\\s*(?P<msg>.*)\";\n+/// Looks for either \"//~| KIND MESSAGE\" or \"//~^^... KIND MESSAGE\"\n+/// The former is a \"follow\" that inherits its target from the preceding line;\n+/// the latter is an \"adjusts\" that goes that many lines up.\n+///\n+/// Goal is to enable tests both like: //~^^^ ERROR go up three\n+/// and also //~^ ERROR message one for the preceding line, and\n+///          //~| ERROR message two for that same line.\n+\n+pub static EXPECTED_PATTERN : &'static str =\n+    r\"//~(?P<follow>\\|)?(?P<adjusts>\\^*)\\s*(?P<kind>\\S*)\\s*(?P<msg>.*)\";\n+\n+#[deriving(PartialEq, Show)]\n+enum WhichLine { ThisLine, FollowPrevious(uint), AdjustBackward(uint) }\n \n // Load any test directives embedded in the file\n pub fn load_errors(re: &Regex, testfile: &Path) -> Vec<ExpectedError> {\n     let mut rdr = BufferedReader::new(File::open(testfile).unwrap());\n \n+    // `last_nonfollow_error` tracks the most recently seen\n+    // line with an error template that did not use the\n+    // follow-syntax, \"//~| ...\".\n+    //\n+    // (pnkfelix could not find an easy way to compose Iterator::scan\n+    // and Iterator::filter_map to pass along this information into\n+    // `parse_expected`. So instead I am storing that state here and\n+    // updating it in the map callback below.)\n+    let mut last_nonfollow_error = None;\n+\n     rdr.lines().enumerate().filter_map(|(line_no, ln)| {\n-        parse_expected(line_no + 1, ln.unwrap().as_slice(), re)\n+        parse_expected(last_nonfollow_error,\n+                       line_no + 1,\n+                       ln.unwrap().as_slice(), re)\n+            .map(|(which, error)| {\n+                match which {\n+                    FollowPrevious(_) => {}\n+                    _ => last_nonfollow_error = Some(error.line),\n+                }\n+                error\n+            })\n     }).collect()\n }\n \n-fn parse_expected(line_num: uint, line: &str, re: &Regex) -> Option<ExpectedError> {\n+fn parse_expected(last_nonfollow_error: Option<uint>,\n+                  line_num: uint,\n+                  line: &str,\n+                  re: &Regex) -> Option<(WhichLine, ExpectedError)> {\n     re.captures(line).and_then(|caps| {\n         let adjusts = caps.name(\"adjusts\").len();\n         let kind = caps.name(\"kind\").to_ascii_lower();\n         let msg = caps.name(\"msg\").trim().to_string();\n+        let follow = caps.name(\"follow\").len() > 0;\n+\n+        let (which, line) = if follow {\n+            assert!(adjusts == 0, \"use either //~| or //~^, not both.\");\n+            let line = last_nonfollow_error.unwrap_or_else(|| {\n+                panic!(\"encountered //~| without preceding //~^ line.\")\n+            });\n+            (FollowPrevious(line), line)\n+        } else {\n+            let which =\n+                if adjusts > 0 { AdjustBackward(adjusts) } else { ThisLine };\n+            let line = line_num - adjusts;\n+            (which, line)\n+        };\n \n-        debug!(\"line={} kind={} msg={}\", line_num, kind, msg);\n-        Some(ExpectedError {\n-            line: line_num - adjusts,\n-            kind: kind,\n-            msg: msg,\n-        })\n+        debug!(\"line={} which={} kind={} msg={}\", line_num, which, kind, msg);\n+        Some((which, ExpectedError { line: line,\n+                                     kind: kind,\n+                                     msg: msg, }))\n     })\n }"}, {"sha": "afcc533ffb81c90e1a502e694230a929c4546c22", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 56, "deletions": 41, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -19,6 +19,8 @@\n use self::UseError::*;\n \n use middle::borrowck::*;\n+use middle::borrowck::LoanPathElem::*;\n+use middle::borrowck::LoanPathKind::*;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n use middle::region;\n@@ -33,49 +35,51 @@ use std::rc::Rc;\n // be less precise in its handling of Box while still allowing moves out of a\n // Box. They should be removed when OwnedPtr is removed from LoanPath.\n \n-fn owned_ptr_base_path<'a>(loan_path: &'a LoanPath) -> &'a LoanPath {\n+fn owned_ptr_base_path<'a, 'tcx>(loan_path: &'a LoanPath<'tcx>) -> &'a LoanPath<'tcx> {\n     //! Returns the base of the leftmost dereference of an OwnedPtr in\n     //! `loan_path`. If there is no dereference of an OwnedPtr in `loan_path`,\n     //! then it just returns `loan_path` itself.\n \n-    return match owned_ptr_base_path_helper(loan_path) {\n+    return match helper(loan_path) {\n         Some(new_loan_path) => new_loan_path,\n         None => loan_path.clone()\n     };\n \n-    fn owned_ptr_base_path_helper<'a>(loan_path: &'a LoanPath) -> Option<&'a LoanPath> {\n-        match *loan_path {\n+    fn helper<'a, 'tcx>(loan_path: &'a LoanPath<'tcx>) -> Option<&'a LoanPath<'tcx>> {\n+        match loan_path.kind {\n             LpVar(_) | LpUpvar(_) => None,\n             LpExtend(ref lp_base, _, LpDeref(mc::OwnedPtr)) => {\n-                match owned_ptr_base_path_helper(&**lp_base) {\n+                match helper(&**lp_base) {\n                     v @ Some(_) => v,\n                     None => Some(&**lp_base)\n                 }\n             }\n-            LpExtend(ref lp_base, _, _) => owned_ptr_base_path_helper(&**lp_base)\n+            LpDowncast(ref lp_base, _) |\n+            LpExtend(ref lp_base, _, _) => helper(&**lp_base)\n         }\n     }\n }\n \n-fn owned_ptr_base_path_rc(loan_path: &Rc<LoanPath>) -> Rc<LoanPath> {\n+fn owned_ptr_base_path_rc<'tcx>(loan_path: &Rc<LoanPath<'tcx>>) -> Rc<LoanPath<'tcx>> {\n     //! The equivalent of `owned_ptr_base_path` for an &Rc<LoanPath> rather than\n     //! a &LoanPath.\n \n-    return match owned_ptr_base_path_helper(loan_path) {\n+    return match helper(loan_path) {\n         Some(new_loan_path) => new_loan_path,\n         None => loan_path.clone()\n     };\n \n-    fn owned_ptr_base_path_helper(loan_path: &Rc<LoanPath>) -> Option<Rc<LoanPath>> {\n-        match **loan_path {\n+    fn helper<'tcx>(loan_path: &Rc<LoanPath<'tcx>>) -> Option<Rc<LoanPath<'tcx>>> {\n+        match loan_path.kind {\n             LpVar(_) | LpUpvar(_) => None,\n             LpExtend(ref lp_base, _, LpDeref(mc::OwnedPtr)) => {\n-                match owned_ptr_base_path_helper(lp_base) {\n+                match helper(lp_base) {\n                     v @ Some(_) => v,\n                     None => Some(lp_base.clone())\n                 }\n             }\n-            LpExtend(ref lp_base, _, _) => owned_ptr_base_path_helper(lp_base)\n+            LpDowncast(ref lp_base, _) |\n+            LpExtend(ref lp_base, _, _) => helper(lp_base)\n         }\n     }\n }\n@@ -84,7 +88,7 @@ struct CheckLoanCtxt<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n     dfcx_loans: &'a LoanDataFlow<'a, 'tcx>,\n     move_data: move_data::FlowedMoveData<'a, 'tcx>,\n-    all_loans: &'a [Loan],\n+    all_loans: &'a [Loan<'tcx>],\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n@@ -99,6 +103,11 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n         self.consume_common(consume_id, consume_span, cmt, mode);\n     }\n \n+    fn matched_pat(&mut self,\n+                   _matched_pat: &ast::Pat,\n+                   _cmt: mc::cmt,\n+                   _mode: euv::MatchMode) { }\n+\n     fn consume_pat(&mut self,\n                    consume_pat: &ast::Pat,\n                    cmt: mc::cmt<'tcx>,\n@@ -183,7 +192,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      dfcx_loans: &LoanDataFlow<'b, 'tcx>,\n                                      move_data: move_data::FlowedMoveData<'c, 'tcx>,\n-                                     all_loans: &[Loan],\n+                                     all_loans: &[Loan<'tcx>],\n                                      decl: &ast::FnDecl,\n                                      body: &ast::Block) {\n     debug!(\"check_loans(body id={})\", body.id);\n@@ -202,9 +211,9 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n }\n \n #[deriving(PartialEq)]\n-enum UseError {\n+enum UseError<'tcx> {\n     UseOk,\n-    UseWhileBorrowed(/*loan*/Rc<LoanPath>, /*loan*/Span)\n+    UseWhileBorrowed(/*loan*/Rc<LoanPath<'tcx>>, /*loan*/Span)\n }\n \n fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n@@ -216,7 +225,7 @@ fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.bccx.tcx }\n \n-    pub fn each_issued_loan(&self, scope: region::CodeExtent, op: |&Loan| -> bool)\n+    pub fn each_issued_loan(&self, scope: region::CodeExtent, op: |&Loan<'tcx>| -> bool)\n                             -> bool {\n         //! Iterates over each loan that has been issued\n         //! on entrance to `scope`, regardless of whether it is\n@@ -232,7 +241,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n     pub fn each_in_scope_loan(&self,\n                               scope: region::CodeExtent,\n-                              op: |&Loan| -> bool)\n+                              op: |&Loan<'tcx>| -> bool)\n                               -> bool {\n         //! Like `each_issued_loan()`, but only considers loans that are\n         //! currently in scope.\n@@ -249,8 +258,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n     fn each_in_scope_loan_affecting_path(&self,\n                                          scope: region::CodeExtent,\n-                                         loan_path: &LoanPath,\n-                                         op: |&Loan| -> bool)\n+                                         loan_path: &LoanPath<'tcx>,\n+                                         op: |&Loan<'tcx>| -> bool)\n                                          -> bool {\n         //! Iterates through all of the in-scope loans affecting `loan_path`,\n         //! calling `op`, and ceasing iteration if `false` is returned.\n@@ -294,10 +303,11 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n         let mut loan_path = loan_path;\n         loop {\n-            match *loan_path {\n+            match loan_path.kind {\n                 LpVar(_) | LpUpvar(_) => {\n                     break;\n                 }\n+                LpDowncast(ref lp_base, _) |\n                 LpExtend(ref lp_base, _, _) => {\n                     loan_path = &**lp_base;\n                 }\n@@ -363,8 +373,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     pub fn report_error_if_loans_conflict(&self,\n-                                          old_loan: &Loan,\n-                                          new_loan: &Loan) {\n+                                          old_loan: &Loan<'tcx>,\n+                                          new_loan: &Loan<'tcx>) {\n         //! Checks whether `old_loan` and `new_loan` can safely be issued\n         //! simultaneously.\n \n@@ -383,10 +393,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     pub fn report_error_if_loan_conflicts_with_restriction(&self,\n-                                                           loan1: &Loan,\n-                                                           loan2: &Loan,\n-                                                           old_loan: &Loan,\n-                                                           new_loan: &Loan)\n+                                                           loan1: &Loan<'tcx>,\n+                                                           loan2: &Loan<'tcx>,\n+                                                           old_loan: &Loan<'tcx>,\n+                                                           new_loan: &Loan<'tcx>)\n                                                            -> bool {\n         //! Checks whether the restrictions introduced by `loan1` would\n         //! prohibit `loan2`. Returns false if an error is reported.\n@@ -549,7 +559,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         true\n     }\n \n-    fn is_local_variable_or_arg(&self, cmt: mc::cmt) -> bool {\n+    fn is_local_variable_or_arg(&self, cmt: mc::cmt<'tcx>) -> bool {\n         match cmt.cat {\n           mc::cat_local(_) => true,\n           _ => false\n@@ -559,7 +569,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     fn consume_common(&self,\n                       id: ast::NodeId,\n                       span: Span,\n-                      cmt: mc::cmt,\n+                      cmt: mc::cmt<'tcx>,\n                       mode: euv::ConsumeMode) {\n         match opt_loan_path(&cmt) {\n             Some(lp) => {\n@@ -600,7 +610,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     fn check_for_copy_of_frozen_path(&self,\n                                      id: ast::NodeId,\n                                      span: Span,\n-                                     copy_path: &LoanPath) {\n+                                     copy_path: &LoanPath<'tcx>) {\n         match self.analyze_restrictions_on_use(id, copy_path, ty::ImmBorrow) {\n             UseOk => { }\n             UseWhileBorrowed(loan_path, loan_span) => {\n@@ -621,7 +631,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     fn check_for_move_of_borrowed_path(&self,\n                                        id: ast::NodeId,\n                                        span: Span,\n-                                       move_path: &LoanPath,\n+                                       move_path: &LoanPath<'tcx>,\n                                        move_kind: move_data::MoveKind) {\n         // We want to detect if there are any loans at all, so we search for\n         // any loans incompatible with MutBorrrow, since all other kinds of\n@@ -652,9 +662,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n     pub fn analyze_restrictions_on_use(&self,\n                                        expr_id: ast::NodeId,\n-                                       use_path: &LoanPath,\n+                                       use_path: &LoanPath<'tcx>,\n                                        borrow_kind: ty::BorrowKind)\n-                                       -> UseError {\n+                                       -> UseError<'tcx> {\n         debug!(\"analyze_restrictions_on_use(expr_id={}, use_path={})\",\n                self.tcx().map.node_to_string(expr_id),\n                use_path.repr(self.tcx()));\n@@ -678,7 +688,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                               id: ast::NodeId,\n                               span: Span,\n                               use_kind: MovedValueUseKind,\n-                              lp: &Rc<LoanPath>) {\n+                              lp: &Rc<LoanPath<'tcx>>) {\n         /*!\n          * Reports an error if `expr` (which should be a path)\n          * is using a moved/uninitialized value\n@@ -702,7 +712,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                        id: ast::NodeId,\n                                        span: Span,\n                                        use_kind: MovedValueUseKind,\n-                                       lp: &Rc<LoanPath>)\n+                                       lp: &Rc<LoanPath<'tcx>>)\n     {\n         /*!\n          * Reports an error if assigning to `lp` will use a\n@@ -722,10 +732,15 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n          *     (*p).x = 22; // not ok, p is uninitialized, can't deref\n          */\n \n-        match **lp {\n+        match lp.kind {\n             LpVar(_) | LpUpvar(_) => {\n                 // assigning to `x` does not require that `x` is initialized\n             }\n+            LpDowncast(ref lp_base, _) => {\n+                // assigning to `(P->Variant).f` is ok if assigning to `P` is ok\n+                self.check_if_assigned_path_is_moved(id, span,\n+                                                     use_kind, lp_base);\n+            }\n             LpExtend(ref lp_base, _, LpInterior(_)) => {\n                 // assigning to `P.f` is ok if assigning to `P` is ok\n                 self.check_if_assigned_path_is_moved(id, span,\n@@ -864,7 +879,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         cmt = b;\n                     }\n \n-                    mc::cat_downcast(b) |\n+                    mc::cat_downcast(b, _) |\n                     mc::cat_interior(b, _) => {\n                         assert_eq!(cmt.mutbl, mc::McInherited);\n                         cmt = b;\n@@ -915,11 +930,11 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             }\n         }\n \n-        fn check_for_assignment_to_borrowed_path(\n-            this: &CheckLoanCtxt,\n+        fn check_for_assignment_to_borrowed_path<'a, 'tcx>(\n+            this: &CheckLoanCtxt<'a, 'tcx>,\n             assignment_id: ast::NodeId,\n             assignment_span: Span,\n-            assignee_cmt: mc::cmt)\n+            assignee_cmt: mc::cmt<'tcx>)\n         {\n             //! Check for assignments that violate the terms of an\n             //! outstanding loan.\n@@ -939,7 +954,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n     pub fn report_illegal_mutation(&self,\n                                    span: Span,\n-                                   loan_path: &LoanPath,\n+                                   loan_path: &LoanPath<'tcx>,\n                                    loan: &Loan) {\n         self.bccx.span_err(\n             span,"}, {"sha": "5b70d97b40276dd7c06e9b1835ba92520250a337", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -27,6 +27,7 @@ These docs are long. Search for the section you are interested in.\n - Formal model\n - Borrowing and loans\n - Moves and initialization\n+- Drop flags and structural fragments\n - Future work\n \n # Overview\n@@ -1019,6 +1020,175 @@ walk back over, identify all uses, assignments, and captures, and\n check that they are legal given the set of dataflow bits we have\n computed for that program point.\n \n+# Drop flags and structural fragments\n+\n+In addition to the job of enforcing memory safety, the borrow checker\n+code is also responsible for identifying the *structural fragments* of\n+data in the function, to support out-of-band dynamic drop flags\n+allocated on the stack. (For background, see [RFC PR #320].)\n+\n+[RFC PR #320]: https://github.com/rust-lang/rfcs/pull/320\n+\n+Semantically, each piece of data that has a destructor may need a\n+boolean flag to indicate whether or not its destructor has been run\n+yet. However, in many cases there is no need to actually maintain such\n+a flag: It can be apparent from the code itself that a given path is\n+always initialized (or always deinitialized) when control reaches the\n+end of its owner's scope, and thus we can unconditionally emit (or\n+not) the destructor invocation for that path.\n+\n+A simple example of this is the following:\n+\n+```rust\n+struct D { p: int }\n+impl D { fn new(x: int) -> D { ... }\n+impl Drop for D { ... }\n+\n+fn foo(a: D, b: D, t: || -> bool) {\n+    let c: D;\n+    let d: D;\n+    if t() { c = b; }\n+}\n+```\n+\n+At the end of the body of `foo`, the compiler knows that `a` is\n+initialized, introducing a drop obligation (deallocating the boxed\n+integer) for the end of `a`'s scope that is run unconditionally.\n+Likewise the compiler knows that `d` is not initialized, and thus it\n+leave out the drop code for `d`.\n+\n+The compiler cannot statically know the drop-state of `b` nor `c` at\n+the end of their scope, since that depends on the value of\n+`t`. Therefore, we need to insert boolean flags to track whether we\n+need to drop `b` and `c`.\n+\n+However, the matter is not as simple as just mapping local variables\n+to their corresponding drop flags when necessary. In particular, in\n+addition to being able to move data out of local variables, Rust\n+allows one to move values in and out of structured data.\n+\n+Consider the following:\n+\n+```rust\n+struct S { x: D, y: D, z: D }\n+\n+fn foo(a: S, mut b: S, t: || -> bool) {\n+    let mut c: S;\n+    let d: S;\n+    let e: S = a.clone();\n+    if t() {\n+        c = b;\n+        b.x = e.y;\n+    }\n+    if t() { c.y = D::new(4); }\n+}\n+```\n+\n+As before, the drop obligations of `a` and `d` can be statically\n+determined, and again the state of `b` and `c` depend on dynamic\n+state. But additionally, the dynamic drop obligations introduced by\n+`b` and `c` are not just per-local boolean flags. For example, if the\n+first call to `t` returns `false` and the second call `true`, then at\n+the end of their scope, `b` will be completely initialized, but only\n+`c.y` in `c` will be initialized.  If both calls to `t` return `true`,\n+then at the end of their scope, `c` will be completely initialized,\n+but only `b.x` will be initialized in `b`, and only `e.x` and `e.z`\n+will be initialized in `e`.\n+\n+Note that we need to cover the `z` field in each case in some way,\n+since it may (or may not) need to be dropped, even though `z` is never\n+directly mentioned in the body of the `foo` function. We call a path\n+like `b.z` a *fragment sibling* of `b.x`, since the field `z` comes\n+from the same structure `S` that declared the field `x` in `b.x`.\n+\n+In general we need to maintain boolean flags that match the\n+`S`-structure of both `b` and `c`.  In addition, we need to consult\n+such a flag when doing an assignment (such as `c.y = D::new(4);`\n+above), in order to know whether or not there is a previous value that\n+needs to be dropped before we do the assignment.\n+\n+So for any given function, we need to determine what flags are needed\n+to track its drop obligations. Our strategy for determining the set of\n+flags is to represent the fragmentation of the structure explicitly:\n+by starting initially from the paths that are explicitly mentioned in\n+moves and assignments (such as `b.x` and `c.y` above), and then\n+traversing the structure of the path's type to identify leftover\n+*unmoved fragments*: assigning into `c.y` means that `c.x` and `c.z`\n+are leftover unmoved fragments. Each fragment represents a drop\n+obligation that may need to be tracked. Paths that are only moved or\n+assigned in their entirety (like `a` and `d`) are treated as a single\n+drop obligation.\n+\n+The fragment construction process works by piggy-backing on the\n+existing `move_data` module. We already have callbacks that visit each\n+direct move and assignment; these form the basis for the sets of\n+moved_leaf_paths and assigned_leaf_paths. From these leaves, we can\n+walk up their parent chain to identify all of their parent paths.\n+We need to identify the parents because of cases like the following:\n+\n+```rust\n+struct Pair<X,Y>{ x: X, y: Y }\n+fn foo(dd_d_d: Pair<Pair<Pair<D, D>, D>, D>) {\n+    other_function(dd_d_d.x.y);\n+}\n+```\n+\n+In this code, the move of the path `dd_d.x.y` leaves behind not only\n+the fragment drop-obligation `dd_d.x.x` but also `dd_d.y` as well.\n+\n+Once we have identified the directly-referenced leaves and their\n+parents, we compute the left-over fragments, in the function\n+`fragments::add_fragment_siblings`. As of this writing this works by\n+looking at each directly-moved or assigned path P, and blindly\n+gathering all sibling fields of P (as well as siblings for the parents\n+of P, etc). After accumulating all such siblings, we filter out the\n+entries added as siblings of P that turned out to be\n+directly-referenced paths (or parents of directly referenced paths)\n+themselves, thus leaving the never-referenced \"left-overs\" as the only\n+thing left from the gathering step.\n+\n+## Array structural fragments\n+\n+A special case of the structural fragments discussed above are\n+the elements of an array that has been passed by value, such as\n+the following:\n+\n+```rust\n+fn foo(a: [D, ..10], i: uint) -> D {\n+    a[i]\n+}\n+```\n+\n+The above code moves a single element out of the input array `a`.\n+The remainder of the array still needs to be dropped; i.e., it\n+is a structural fragment. Note that after performing such a move,\n+it is not legal to read from the array `a`. There are a number of\n+ways to deal with this, but the important thing to note is that\n+the semantics needs to distinguish in some manner between a\n+fragment that is the *entire* array versus a fragment that represents\n+all-but-one element of the array.  A place where that distinction\n+would arise is the following:\n+\n+```rust\n+fn foo(a: [D, ..10], b: [D, ..10], i: uint, t: bool) -> D {\n+    if t {\n+        a[i]\n+    } else {\n+        b[i]\n+    }\n+\n+    // When control exits, we will need either to drop all of `a`\n+    // and all-but-one of `b`, or to drop all of `b` and all-but-one\n+    // of `a`.\n+}\n+```\n+\n+There are a number of ways that the trans backend could choose to\n+compile this (e.g. a `[bool, ..10]` array for each such moved array;\n+or an `Option<uint>` for each moved array).  From the viewpoint of the\n+borrow-checker, the important thing is to record what kind of fragment\n+is implied by the relevant moves.\n+\n # Future work\n \n While writing up these docs, I encountered some rules I believe to be"}, {"sha": "7e766e9138e35f6e49a6cac4adedae312af08d58", "filename": "src/librustc/middle/borrowck/fragments.rs", "status": "added", "additions": 491, "deletions": 0, "changes": 491, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Ffragments.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -0,0 +1,491 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Helper routines used for fragmenting structural paths due to moves for\n+tracking drop obligations. Please see the extensive comments in the\n+section \"Structural fragments\" in `doc.rs`.\n+\n+*/\n+use self::Fragment::*;\n+\n+use session::config;\n+use middle::borrowck::{LoanPath};\n+use middle::borrowck::LoanPathKind::{LpVar, LpUpvar, LpDowncast, LpExtend};\n+use middle::borrowck::LoanPathElem::{LpDeref, LpInterior};\n+use middle::borrowck::move_data::{InvalidMovePathIndex};\n+use middle::borrowck::move_data::{MoveData, MovePathIndex};\n+use middle::ty;\n+use middle::mem_categorization as mc;\n+use util::ppaux::{Repr, UserString};\n+\n+use std::mem;\n+use std::rc::Rc;\n+use std::slice;\n+use syntax::ast;\n+use syntax::ast_map;\n+use syntax::attr::AttrMetaMethods;\n+use syntax::codemap::Span;\n+\n+#[deriving(PartialEq, Eq, PartialOrd, Ord)]\n+enum Fragment {\n+    // This represents the path described by the move path index\n+    Just(MovePathIndex),\n+\n+    // This represents the collection of all but one of the elements\n+    // from an array at the path described by the move path index.\n+    // Note that attached MovePathIndex should have mem_categorization\n+    // of InteriorElement (i.e. array dereference `[]`).\n+    AllButOneFrom(MovePathIndex),\n+}\n+\n+impl Fragment {\n+    fn loan_path_repr<'tcx>(&self, move_data: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) -> String {\n+        let repr = |mpi| move_data.path_loan_path(mpi).repr(tcx);\n+        match *self {\n+            Just(mpi) => repr(mpi),\n+            AllButOneFrom(mpi) => format!(\"$(allbutone {})\", repr(mpi)),\n+        }\n+    }\n+\n+    fn loan_path_user_string<'tcx>(&self,\n+                                   move_data: &MoveData<'tcx>,\n+                                   tcx: &ty::ctxt<'tcx>) -> String {\n+        let user_string = |mpi| move_data.path_loan_path(mpi).user_string(tcx);\n+        match *self {\n+            Just(mpi) => user_string(mpi),\n+            AllButOneFrom(mpi) => format!(\"$(allbutone {})\", user_string(mpi)),\n+        }\n+    }\n+}\n+\n+pub struct FragmentSets {\n+    /// During move_data construction, `moved_leaf_paths` tracks paths\n+    /// that have been used directly by being moved out of.  When\n+    /// move_data construction has been completed, `moved_leaf_paths`\n+    /// tracks such paths that are *leaf fragments* (e.g. `a.j` if we\n+    /// never move out any child like `a.j.x`); any parent paths\n+    /// (e.g. `a` for the `a.j` example) are moved over to\n+    /// `parents_of_fragments`.\n+    moved_leaf_paths: Vec<MovePathIndex>,\n+\n+    /// `assigned_leaf_paths` tracks paths that have been used\n+    /// directly by being overwritten, but is otherwise much like\n+    /// `moved_leaf_paths`.\n+    assigned_leaf_paths: Vec<MovePathIndex>,\n+\n+    /// `parents_of_fragments` tracks paths that are definitely\n+    /// parents of paths that have been moved.\n+    ///\n+    /// FIXME(pnkfelix) probably do not want/need\n+    /// `parents_of_fragments` at all, if we can avoid it.\n+    ///\n+    /// Update: I do not see a way to to avoid it.  Maybe just remove\n+    /// above fixme, or at least document why doing this may be hard.\n+    parents_of_fragments: Vec<MovePathIndex>,\n+\n+    /// During move_data construction (specifically the\n+    /// fixup_fragment_sets call), `unmoved_fragments` tracks paths\n+    /// that have been \"left behind\" after a sibling has been moved or\n+    /// assigned.  When move_data construction has been completed,\n+    /// `unmoved_fragments` tracks paths that were *only* results of\n+    /// being left-behind, and never directly moved themselves.\n+    unmoved_fragments: Vec<Fragment>,\n+}\n+\n+impl FragmentSets {\n+    pub fn new() -> FragmentSets {\n+        FragmentSets {\n+            unmoved_fragments: Vec::new(),\n+            moved_leaf_paths: Vec::new(),\n+            assigned_leaf_paths: Vec::new(),\n+            parents_of_fragments: Vec::new(),\n+        }\n+    }\n+\n+    pub fn add_move(&mut self, path_index: MovePathIndex) {\n+        self.moved_leaf_paths.push(path_index);\n+    }\n+\n+    pub fn add_assignment(&mut self, path_index: MovePathIndex) {\n+        self.assigned_leaf_paths.push(path_index);\n+    }\n+}\n+\n+pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n+                                       tcx: &ty::ctxt<'tcx>,\n+                                       sp: Span,\n+                                       id: ast::NodeId) {\n+    let (span_err, print) = {\n+        let attrs : &[ast::Attribute];\n+        attrs = match tcx.map.find(id) {\n+            Some(ast_map::NodeItem(ref item)) =>\n+                item.attrs.as_slice(),\n+            Some(ast_map::NodeImplItem(&ast::MethodImplItem(ref m))) =>\n+                m.attrs.as_slice(),\n+            Some(ast_map::NodeTraitItem(&ast::ProvidedMethod(ref m))) =>\n+                m.attrs.as_slice(),\n+            _ => [].as_slice(),\n+        };\n+\n+        let span_err =\n+            attrs.iter().any(|a| a.check_name(\"rustc_move_fragments\"));\n+        let print = tcx.sess.debugging_opt(config::PRINT_MOVE_FRAGMENTS);\n+\n+        (span_err, print)\n+    };\n+\n+    if !span_err && !print { return; }\n+\n+    let instrument_all_paths = |kind, vec_rc: &Vec<MovePathIndex>| {\n+        for (i, mpi) in vec_rc.iter().enumerate() {\n+            let render = || this.path_loan_path(*mpi).user_string(tcx);\n+            if span_err {\n+                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render()).as_slice());\n+            }\n+            if print {\n+                println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n+            }\n+        }\n+    };\n+\n+    let instrument_all_fragments = |kind, vec_rc: &Vec<Fragment>| {\n+        for (i, f) in vec_rc.iter().enumerate() {\n+            let render = || f.loan_path_user_string(this, tcx);\n+            if span_err {\n+                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render()).as_slice());\n+            }\n+            if print {\n+                println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n+            }\n+        }\n+    };\n+\n+    let fragments = this.fragments.borrow();\n+    instrument_all_paths(\"moved_leaf_path\", &fragments.moved_leaf_paths);\n+    instrument_all_fragments(\"unmoved_fragment\", &fragments.unmoved_fragments);\n+    instrument_all_paths(\"parent_of_fragments\", &fragments.parents_of_fragments);\n+    instrument_all_paths(\"assigned_leaf_path\", &fragments.assigned_leaf_paths);\n+}\n+\n+pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n+    /*!\n+     * Normalizes the fragment sets in `this`; i.e., removes\n+     * duplicate entries, constructs the set of parents, and\n+     * constructs the left-over fragments.\n+     *\n+     * Note: \"left-over fragments\" means paths that were not\n+     * directly referenced in moves nor assignments, but must\n+     * nonetheless be tracked as potential drop obligations.\n+     */\n+\n+    let mut fragments = this.fragments.borrow_mut();\n+\n+    // Swap out contents of fragments so that we can modify the fields\n+    // without borrowing the common fragments.\n+    let mut unmoved = mem::replace(&mut fragments.unmoved_fragments, vec![]);\n+    let mut parents = mem::replace(&mut fragments.parents_of_fragments, vec![]);\n+    let mut moved = mem::replace(&mut fragments.moved_leaf_paths, vec![]);\n+    let mut assigned = mem::replace(&mut fragments.assigned_leaf_paths, vec![]);\n+\n+    let path_lps = |mpis: &[MovePathIndex]| -> Vec<String> {\n+        mpis.iter().map(|mpi| this.path_loan_path(*mpi).repr(tcx)).collect()\n+    };\n+\n+    let frag_lps = |fs: &[Fragment]| -> Vec<String> {\n+        fs.iter().map(|f| f.loan_path_repr(this, tcx)).collect()\n+    };\n+\n+    // First, filter out duplicates\n+    moved.sort();\n+    moved.dedup();\n+    debug!(\"fragments 1 moved: {}\", path_lps(moved.as_slice()));\n+\n+    assigned.sort();\n+    assigned.dedup();\n+    debug!(\"fragments 1 assigned: {}\", path_lps(assigned.as_slice()));\n+\n+    // Second, build parents from the moved and assigned.\n+    for m in moved.iter() {\n+        let mut p = this.path_parent(*m);\n+        while p != InvalidMovePathIndex {\n+            parents.push(p);\n+            p = this.path_parent(p);\n+        }\n+    }\n+    for a in assigned.iter() {\n+        let mut p = this.path_parent(*a);\n+        while p != InvalidMovePathIndex {\n+            parents.push(p);\n+            p = this.path_parent(p);\n+        }\n+    }\n+\n+    parents.sort();\n+    parents.dedup();\n+    debug!(\"fragments 2 parents: {}\", path_lps(parents.as_slice()));\n+\n+    // Third, filter the moved and assigned fragments down to just the non-parents\n+    moved.retain(|f| non_member(*f, parents.as_slice()));\n+    debug!(\"fragments 3 moved: {}\", path_lps(moved.as_slice()));\n+\n+    assigned.retain(|f| non_member(*f, parents.as_slice()));\n+    debug!(\"fragments 3 assigned: {}\", path_lps(assigned.as_slice()));\n+\n+    // Fourth, build the leftover from the moved, assigned, and parents.\n+    for m in moved.as_slice().iter() {\n+        let lp = this.path_loan_path(*m);\n+        add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n+    }\n+    for a in assigned.as_slice().iter() {\n+        let lp = this.path_loan_path(*a);\n+        add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n+    }\n+    for p in parents.as_slice().iter() {\n+        let lp = this.path_loan_path(*p);\n+        add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n+    }\n+\n+    unmoved.sort();\n+    unmoved.dedup();\n+    debug!(\"fragments 4 unmoved: {}\", frag_lps(unmoved.as_slice()));\n+\n+    // Fifth, filter the leftover fragments down to its core.\n+    unmoved.retain(|f| match *f {\n+        AllButOneFrom(_) => true,\n+        Just(mpi) => non_member(mpi, parents.as_slice()) &&\n+            non_member(mpi, moved.as_slice()) &&\n+            non_member(mpi, assigned.as_slice())\n+    });\n+    debug!(\"fragments 5 unmoved: {}\", frag_lps(unmoved.as_slice()));\n+\n+    // Swap contents back in.\n+    fragments.unmoved_fragments = unmoved;\n+    fragments.parents_of_fragments = parents;\n+    fragments.moved_leaf_paths = moved;\n+    fragments.assigned_leaf_paths = assigned;\n+\n+    return;\n+\n+    fn non_member(elem: MovePathIndex, set: &[MovePathIndex]) -> bool {\n+        match set.binary_search_elem(&elem) {\n+            slice::Found(_) => false,\n+            slice::NotFound(_) => true,\n+        }\n+    }\n+}\n+\n+fn add_fragment_siblings<'tcx>(this: &MoveData<'tcx>,\n+                               tcx: &ty::ctxt<'tcx>,\n+                               gathered_fragments: &mut Vec<Fragment>,\n+                               lp: Rc<LoanPath<'tcx>>,\n+                               origin_id: Option<ast::NodeId>) {\n+    /*!\n+     * Adds all of the precisely-tracked siblings of `lp` as\n+     * potential move paths of interest. For example, if `lp`\n+     * represents `s.x.j`, then adds moves paths for `s.x.i` and\n+     * `s.x.k`, the siblings of `s.x.j`.\n+     */\n+\n+    match lp.kind {\n+        LpVar(_) | LpUpvar(..) => {} // Local variables have no siblings.\n+\n+        // Consuming a downcast is like consuming the original value, so propage inward.\n+        LpDowncast(ref loan_parent, _) => {\n+            add_fragment_siblings(this, tcx, gathered_fragments, loan_parent.clone(), origin_id);\n+        }\n+\n+        // *LV for OwnedPtr consumes the contents of the box (at\n+        // least when it is non-copy...), so propagate inward.\n+        LpExtend(ref loan_parent, _, LpDeref(mc::OwnedPtr)) => {\n+            add_fragment_siblings(this, tcx, gathered_fragments, loan_parent.clone(), origin_id);\n+        }\n+\n+        // *LV for unsafe and borrowed pointers do not consume their loan path, so stop here.\n+        LpExtend(_, _, LpDeref(mc::UnsafePtr(..)))   |\n+        LpExtend(_, _, LpDeref(mc::Implicit(..)))    |\n+        LpExtend(_, _, LpDeref(mc::BorrowedPtr(..))) => {}\n+\n+        // FIXME(pnkfelix): LV[j] should be tracked, at least in the\n+        // sense of we will track the remaining drop obligation of the\n+        // rest of the array.\n+        //\n+        // LV[j] is not tracked precisely\n+        LpExtend(_, _, LpInterior(mc::InteriorElement(_))) => {\n+            let mp = this.move_path(tcx, lp.clone());\n+            gathered_fragments.push(AllButOneFrom(mp));\n+        }\n+\n+        // field access LV.x and tuple access LV#k are the cases\n+        // we are interested in\n+        LpExtend(ref loan_parent, mc,\n+                 LpInterior(mc::InteriorField(ref field_name))) => {\n+            let enum_variant_info = match loan_parent.kind {\n+                LpDowncast(ref loan_parent_2, variant_def_id) =>\n+                    Some((variant_def_id, loan_parent_2.clone())),\n+                LpExtend(..) | LpVar(..) | LpUpvar(..) =>\n+                    None,\n+            };\n+            add_fragment_siblings_for_extension(\n+                this,\n+                tcx,\n+                gathered_fragments,\n+                loan_parent, mc, field_name, &lp, origin_id, enum_variant_info);\n+        }\n+    }\n+}\n+\n+fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n+                                             tcx: &ty::ctxt<'tcx>,\n+                                             gathered_fragments: &mut Vec<Fragment>,\n+                                             parent_lp: &Rc<LoanPath<'tcx>>,\n+                                             mc: mc::MutabilityCategory,\n+                                             origin_field_name: &mc::FieldName,\n+                                             origin_lp: &Rc<LoanPath<'tcx>>,\n+                                             origin_id: Option<ast::NodeId>,\n+                                             enum_variant_info: Option<(ast::DefId,\n+                                                                        Rc<LoanPath<'tcx>>)>) {\n+    /*!\n+     * We have determined that `origin_lp` destructures to\n+     * LpExtend(parent, original_field_name). Based on this,\n+     * add move paths for all of the siblings of `origin_lp`.\n+     */\n+\n+    let parent_ty = parent_lp.to_type();\n+\n+    let add_fragment_sibling_local = |field_name| {\n+        add_fragment_sibling_core(\n+            this, tcx, gathered_fragments, parent_lp.clone(), mc, field_name, origin_lp);\n+    };\n+\n+    match (&parent_ty.sty, enum_variant_info) {\n+        (&ty::ty_tup(ref v), None) => {\n+            let tuple_idx = match *origin_field_name {\n+                mc::PositionalField(tuple_idx) => tuple_idx,\n+                mc::NamedField(_) =>\n+                    panic!(\"tuple type {} should not have named fields.\",\n+                           parent_ty.repr(tcx)),\n+            };\n+            let tuple_len = v.len();\n+            for i in range(0, tuple_len) {\n+                if i == tuple_idx { continue }\n+                let field_name = mc::PositionalField(i);\n+                add_fragment_sibling_local(field_name);\n+            }\n+        }\n+\n+        (&ty::ty_struct(def_id, ref _substs), None) => {\n+            let fields = ty::lookup_struct_fields(tcx, def_id);\n+            match *origin_field_name {\n+                mc::NamedField(ast_name) => {\n+                    for f in fields.iter() {\n+                        if f.name == ast_name {\n+                            continue;\n+                        }\n+                        let field_name = mc::NamedField(f.name);\n+                        add_fragment_sibling_local(field_name);\n+                    }\n+                }\n+                mc::PositionalField(tuple_idx) => {\n+                    for (i, _f) in fields.iter().enumerate() {\n+                        if i == tuple_idx {\n+                            continue\n+                        }\n+                        let field_name = mc::PositionalField(i);\n+                        add_fragment_sibling_local(field_name);\n+                    }\n+                }\n+            }\n+        }\n+\n+        (&ty::ty_enum(enum_def_id, ref substs), ref enum_variant_info) => {\n+            let variant_info = {\n+                let mut variants = ty::substd_enum_variants(tcx, enum_def_id, substs);\n+                match *enum_variant_info {\n+                    Some((variant_def_id, ref _lp2)) =>\n+                        variants.iter()\n+                        .find(|variant| variant.id == variant_def_id)\n+                        .expect(\"enum_variant_with_id(): no variant exists with that ID\")\n+                        .clone(),\n+                    None => {\n+                        assert_eq!(variants.len(), 1);\n+                        variants.pop().unwrap()\n+                    }\n+                }\n+            };\n+            match *origin_field_name {\n+                mc::NamedField(ast_name) => {\n+                    let variant_arg_names = variant_info.arg_names.as_ref().unwrap();\n+                    for variant_arg_ident in variant_arg_names.iter() {\n+                        if variant_arg_ident.name == ast_name {\n+                            continue;\n+                        }\n+                        let field_name = mc::NamedField(variant_arg_ident.name);\n+                        add_fragment_sibling_local(field_name);\n+                    }\n+                }\n+                mc::PositionalField(tuple_idx) => {\n+                    let variant_arg_types = &variant_info.args;\n+                    for (i, _variant_arg_ty) in variant_arg_types.iter().enumerate() {\n+                        if tuple_idx == i {\n+                            continue;\n+                        }\n+                        let field_name = mc::PositionalField(i);\n+                        add_fragment_sibling_local(field_name);\n+                    }\n+                }\n+            }\n+        }\n+\n+        ref sty_and_variant_info => {\n+            let msg = format!(\"type {} ({}) is not fragmentable\",\n+                              parent_ty.repr(tcx), sty_and_variant_info);\n+            let opt_span = origin_id.and_then(|id|tcx.map.opt_span(id));\n+            tcx.sess.opt_span_bug(opt_span, msg.as_slice())\n+        }\n+    }\n+}\n+\n+fn add_fragment_sibling_core<'tcx>(this: &MoveData<'tcx>,\n+                                   tcx: &ty::ctxt<'tcx>,\n+                                   gathered_fragments: &mut Vec<Fragment>,\n+                                   parent: Rc<LoanPath<'tcx>>,\n+                                   mc: mc::MutabilityCategory,\n+                                   new_field_name: mc::FieldName,\n+                                   origin_lp: &Rc<LoanPath<'tcx>>) -> MovePathIndex {\n+    /*!\n+     * Adds the single sibling `LpExtend(parent, new_field_name)`\n+     * of `origin_lp` (the original loan-path).\n+     */\n+    let opt_variant_did = match parent.kind {\n+        LpDowncast(_, variant_did) => Some(variant_did),\n+        LpVar(..) | LpUpvar(..) | LpExtend(..) => None,\n+    };\n+\n+    let loan_path_elem = LpInterior(mc::InteriorField(new_field_name));\n+    let new_lp_type = match new_field_name {\n+        mc::NamedField(ast_name) =>\n+            ty::named_element_ty(tcx, parent.to_type(), ast_name, opt_variant_did),\n+        mc::PositionalField(idx) =>\n+            ty::positional_element_ty(tcx, parent.to_type(), idx, opt_variant_did),\n+    };\n+    let new_lp_variant = LpExtend(parent, mc, loan_path_elem);\n+    let new_lp = LoanPath::new(new_lp_variant, new_lp_type.unwrap());\n+    debug!(\"add_fragment_sibling_core(new_lp={}, origin_lp={})\",\n+           new_lp.repr(tcx), origin_lp.repr(tcx));\n+    let mp = this.move_path(tcx, Rc::new(new_lp));\n+\n+    // Do not worry about checking for duplicates here; we will sort\n+    // and dedup after all are added.\n+    gathered_fragments.push(Just(mp));\n+\n+    mp\n+}"}, {"sha": "1d0b0558bb16c2ae94482dcd3938217734ebe06c", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 50, "deletions": 17, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -13,6 +13,7 @@\n  */\n \n use middle::borrowck::*;\n+use middle::borrowck::LoanPathKind::*;\n use middle::borrowck::gather_loans::move_error::MoveSpanAndPath;\n use middle::borrowck::gather_loans::move_error::{MoveError, MoveErrorCollector};\n use middle::borrowck::move_data::*;\n@@ -32,17 +33,18 @@ struct GatherMoveInfo<'tcx> {\n     span_path_opt: Option<MoveSpanAndPath>\n }\n \n-pub fn gather_decl(bccx: &BorrowckCtxt,\n-                   move_data: &MoveData,\n-                   decl_id: ast::NodeId,\n-                   _decl_span: Span,\n-                   var_id: ast::NodeId) {\n-    let loan_path = Rc::new(LpVar(var_id));\n+pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                             move_data: &MoveData<'tcx>,\n+                             decl_id: ast::NodeId,\n+                             _decl_span: Span,\n+                             var_id: ast::NodeId) {\n+    let ty = ty::node_id_to_type(bccx.tcx, var_id);\n+    let loan_path = Rc::new(LoanPath::new(LpVar(var_id), ty));\n     move_data.add_move(bccx.tcx, loan_path, decl_id, Declared);\n }\n \n pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                       move_data: &MoveData,\n+                                       move_data: &MoveData<'tcx>,\n                                        move_error_collector: &MoveErrorCollector<'tcx>,\n                                        move_expr_id: ast::NodeId,\n                                        cmt: mc::cmt<'tcx>,\n@@ -60,8 +62,39 @@ pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     gather_move(bccx, move_data, move_error_collector, move_info);\n }\n \n+pub fn gather_match_variant<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                      move_data: &MoveData<'tcx>,\n+                                      _move_error_collector: &MoveErrorCollector<'tcx>,\n+                                      move_pat: &ast::Pat,\n+                                      cmt: mc::cmt<'tcx>,\n+                                      mode: euv::MatchMode) {\n+    let tcx = bccx.tcx;\n+    debug!(\"gather_match_variant(move_pat={}, cmt={}, mode={})\",\n+           move_pat.id, cmt.repr(tcx), mode);\n+\n+    let opt_lp = opt_loan_path(&cmt);\n+    match opt_lp {\n+        Some(lp) => {\n+            match lp.kind {\n+                LpDowncast(ref base_lp, _) =>\n+                    move_data.add_variant_match(\n+                        tcx, lp.clone(), move_pat.id, base_lp.clone(), mode),\n+                _ => panic!(\"should only call gather_match_variant \\\n+                             for cat_downcast cmt\"),\n+            }\n+        }\n+        None => {\n+            // We get None when input to match is non-path (e.g.\n+            // temporary result like a function call). Since no\n+            // loan-path is being matched, no need to record a\n+            // downcast.\n+            return;\n+        }\n+    }\n+}\n+\n pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                      move_data: &MoveData,\n+                                      move_data: &MoveData<'tcx>,\n                                       move_error_collector: &MoveErrorCollector<'tcx>,\n                                       move_pat: &ast::Pat,\n                                       cmt: mc::cmt<'tcx>) {\n@@ -82,7 +115,7 @@ pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n }\n \n fn gather_move<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                         move_data: &MoveData,\n+                         move_data: &MoveData<'tcx>,\n                          move_error_collector: &MoveErrorCollector<'tcx>,\n                          move_info: GatherMoveInfo<'tcx>) {\n     debug!(\"gather_move(move_id={}, cmt={})\",\n@@ -112,13 +145,13 @@ fn gather_move<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     }\n }\n \n-pub fn gather_assignment(bccx: &BorrowckCtxt,\n-                         move_data: &MoveData,\n-                         assignment_id: ast::NodeId,\n-                         assignment_span: Span,\n-                         assignee_loan_path: Rc<LoanPath>,\n-                         assignee_id: ast::NodeId,\n-                         mode: euv::MutateMode) {\n+pub fn gather_assignment<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                   move_data: &MoveData<'tcx>,\n+                                   assignment_id: ast::NodeId,\n+                                   assignment_span: Span,\n+                                   assignee_loan_path: Rc<LoanPath<'tcx>>,\n+                                   assignee_id: ast::NodeId,\n+                                   mode: euv::MutateMode) {\n     move_data.add_assignment(bccx.tcx,\n                              assignee_loan_path,\n                              assignment_id,\n@@ -144,7 +177,7 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             None\n         }\n \n-        mc::cat_downcast(ref b) |\n+        mc::cat_downcast(ref b, _) |\n         mc::cat_interior(ref b, _) => {\n             match b.ty.sty {\n                 ty::ty_struct(did, _) | ty::ty_enum(did, _) => {"}, {"sha": "7a7ed3e75d20edac25793480156aeec8dfac0eb3", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -85,7 +85,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n                 Ok(())\n             }\n \n-            mc::cat_downcast(ref base) |\n+            mc::cat_downcast(ref base, _) |\n             mc::cat_deref(ref base, _, mc::OwnedPtr) |     // L-Deref-Send\n             mc::cat_interior(ref base, _) => {             // L-Field\n                 self.check(base, discr_scope)\n@@ -130,7 +130,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             mc::cat_deref(_, _, mc::Implicit(_, r)) => {\n                 r\n             }\n-            mc::cat_downcast(ref cmt) |\n+            mc::cat_downcast(ref cmt, _) |\n             mc::cat_deref(ref cmt, _, mc::OwnedPtr) |\n             mc::cat_interior(ref cmt, _) => {\n                 self.scope(cmt)"}, {"sha": "088b62a12cf98ddad27e608d40dc4ecdba39176d", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -17,6 +17,7 @@\n // sure that all of these loans are honored.\n \n use middle::borrowck::*;\n+use middle::borrowck::LoanPathKind::*;\n use middle::borrowck::move_data::MoveData;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n@@ -35,10 +36,10 @@ mod restrictions;\n mod gather_moves;\n mod move_error;\n \n-pub fn gather_loans_in_fn(bccx: &BorrowckCtxt,\n-                          decl: &ast::FnDecl,\n-                          body: &ast::Block)\n-                          -> (Vec<Loan>, move_data::MoveData)\n+pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                    decl: &ast::FnDecl,\n+                                    body: &ast::Block)\n+                                    -> (Vec<Loan<'tcx>>, move_data::MoveData<'tcx>)\n {\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n@@ -60,9 +61,9 @@ pub fn gather_loans_in_fn(bccx: &BorrowckCtxt,\n \n struct GatherLoanCtxt<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-    move_data: move_data::MoveData,\n+    move_data: move_data::MoveData<'tcx>,\n     move_error_collector: move_error::MoveErrorCollector<'tcx>,\n-    all_loans: Vec<Loan>,\n+    all_loans: Vec<Loan<'tcx>>,\n     /// `item_ub` is used as an upper-bound on the lifetime whenever we\n     /// ask for the scope of an expression categorized as an upvar.\n     item_ub: region::CodeExtent,\n@@ -87,6 +88,24 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn matched_pat(&mut self,\n+                   matched_pat: &ast::Pat,\n+                   cmt: mc::cmt<'tcx>,\n+                   mode: euv::MatchMode) {\n+        debug!(\"matched_pat(matched_pat={}, cmt={}, mode={})\",\n+               matched_pat.repr(self.tcx()),\n+               cmt.repr(self.tcx()),\n+               mode);\n+\n+        match cmt.cat {\n+            mc::cat_downcast(..) =>\n+                gather_moves::gather_match_variant(\n+                    self.bccx, &self.move_data, &self.move_error_collector,\n+                    matched_pat, cmt, mode),\n+            _ => {}\n+        }\n+    }\n+\n     fn consume_pat(&mut self,\n                    consume_pat: &ast::Pat,\n                    cmt: mc::cmt<'tcx>,\n@@ -395,11 +414,12 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         //! For mutable loans of content whose mutability derives\n         //! from a local variable, mark the mutability decl as necessary.\n \n-        match *loan_path {\n+        match loan_path.kind {\n             LpVar(local_id) |\n             LpUpvar(ty::UpvarId{ var_id: local_id, closure_expr_id: _ }) => {\n                 self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n             }\n+            LpDowncast(ref base, _) |\n             LpExtend(ref base, mc::McInherited, _) |\n             LpExtend(ref base, mc::McDeclared, _) => {\n                 self.mark_loan_path_as_mutated(&**base);\n@@ -426,7 +446,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn compute_kill_scope(&self, loan_scope: region::CodeExtent, lp: &LoanPath)\n+    pub fn compute_kill_scope(&self, loan_scope: region::CodeExtent, lp: &LoanPath<'tcx>)\n                               -> region::CodeExtent {\n         //! Determine when the loan restrictions go out of scope.\n         //! This is either when the lifetime expires or when the"}, {"sha": "aaa0fa88242b00dbfb9d530b556c32ea3ecce632", "filename": "src/librustc/middle/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -124,7 +124,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                         bccx.cmt_to_string(&*move_from)).as_slice());\n         }\n \n-        mc::cat_downcast(ref b) |\n+        mc::cat_downcast(ref b, _) |\n         mc::cat_interior(ref b, _) => {\n             match b.ty.sty {\n                 ty::ty_struct(did, _)"}, {"sha": "adae34b49dca2d1dc386c27f14a0f6f656ef3164", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -15,6 +15,8 @@\n pub use self::RestrictionResult::*;\n \n use middle::borrowck::*;\n+use middle::borrowck::LoanPathElem::*;\n+use middle::borrowck::LoanPathKind::*;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n use middle::ty;\n@@ -24,17 +26,17 @@ use util::ppaux::Repr;\n use std::rc::Rc;\n \n #[deriving(Show)]\n-pub enum RestrictionResult {\n+pub enum RestrictionResult<'tcx> {\n     Safe,\n-    SafeIf(Rc<LoanPath>, Vec<Rc<LoanPath>>)\n+    SafeIf(Rc<LoanPath<'tcx>>, Vec<Rc<LoanPath<'tcx>>>)\n }\n \n pub fn compute_restrictions<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       span: Span,\n                                       cause: euv::LoanCause,\n                                       cmt: mc::cmt<'tcx>,\n                                       loan_region: ty::Region)\n-                                      -> RestrictionResult {\n+                                      -> RestrictionResult<'tcx> {\n     let ctxt = RestrictionsContext {\n         bccx: bccx,\n         span: span,\n@@ -57,9 +59,11 @@ struct RestrictionsContext<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n     fn restrict(&self,\n-                cmt: mc::cmt<'tcx>) -> RestrictionResult {\n+                cmt: mc::cmt<'tcx>) -> RestrictionResult<'tcx> {\n         debug!(\"restrict(cmt={})\", cmt.repr(self.bccx.tcx));\n \n+        let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n+\n         match cmt.cat.clone() {\n             mc::cat_rvalue(..) => {\n                 // Effectively, rvalues are stored into a\n@@ -72,17 +76,17 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n \n             mc::cat_local(local_id) => {\n                 // R-Variable, locally declared\n-                let lp = Rc::new(LpVar(local_id));\n+                let lp = new_lp(LpVar(local_id));\n                 SafeIf(lp.clone(), vec![lp])\n             }\n \n             mc::cat_upvar(mc::Upvar { id, .. }) => {\n                 // R-Variable, captured into closure\n-                let lp = Rc::new(LpUpvar(id));\n+                let lp = new_lp(LpUpvar(id));\n                 SafeIf(lp.clone(), vec![lp])\n             }\n \n-            mc::cat_downcast(cmt_base) => {\n+            mc::cat_downcast(cmt_base, _) => {\n                 // When we borrow the interior of an enum, we have to\n                 // ensure the enum itself is not mutated, because that\n                 // could cause the type of the memory to change.\n@@ -96,10 +100,9 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 // the memory, so no additional restrictions are\n                 // needed.\n                 let result = self.restrict(cmt_base);\n-                self.extend(result, cmt.mutbl, LpInterior(i))\n+                self.extend(result, &cmt, LpInterior(i))\n             }\n \n-\n             mc::cat_static_item(..) => {\n                 Safe\n             }\n@@ -116,7 +119,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                         // Eventually we should make these non-special and\n                         // just rely on Deref<T> implementation.\n                         let result = self.restrict(cmt_base);\n-                        self.extend(result, cmt.mutbl, LpDeref(pk))\n+                        self.extend(result, &cmt, LpDeref(pk))\n                     }\n                     mc::Implicit(bk, lt) | mc::BorrowedPtr(bk, lt) => {\n                         // R-Deref-[Mut-]Borrowed\n@@ -140,7 +143,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                                 // references lifetime ends (by a newly-unfrozen\n                                 // borrow).\n                                 let result = self.restrict(cmt_base);\n-                                self.extend(result, cmt.mutbl, LpDeref(pk))\n+                                self.extend(result, &cmt, LpDeref(pk))\n                             }\n                         }\n                     }\n@@ -152,13 +155,14 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n     }\n \n     fn extend(&self,\n-              result: RestrictionResult,\n-              mc: mc::MutabilityCategory,\n-              elem: LoanPathElem) -> RestrictionResult {\n+              result: RestrictionResult<'tcx>,\n+              cmt: &mc::cmt<'tcx>,\n+              elem: LoanPathElem) -> RestrictionResult<'tcx> {\n         match result {\n             Safe => Safe,\n             SafeIf(base_lp, mut base_vec) => {\n-                let lp = Rc::new(LpExtend(base_lp, mc, elem));\n+                let v = LpExtend(base_lp, cmt.mutbl, elem);\n+                let lp = Rc::new(LoanPath::new(v, cmt.ty));\n                 base_vec.push(lp.clone());\n                 SafeIf(lp, base_vec)\n             }"}, {"sha": "41f7b7dba1da6009f4c39f902421b60f9779ff9f", "filename": "src/librustc/middle/borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -80,7 +80,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n                                      e: EntryOrExit,\n                                      cfgidx: CFGIndex,\n                                      dfcx: &DataFlowContext<'a, 'tcx, O>,\n-                                     to_lp: |uint| -> Rc<LoanPath>) -> String {\n+                                     to_lp: |uint| -> Rc<LoanPath<'tcx>>) -> String {\n         let mut saw_some = false;\n         let mut set = \"{\".to_string();\n         dfcx.each_bit_for_node(e, cfgidx, |index| {"}, {"sha": "45040cd7b102e93d18a7fda4c24805e40dd76d72", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 180, "deletions": 51, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -12,7 +12,7 @@\n \n #![allow(non_camel_case_types)]\n \n-pub use self::LoanPath::*;\n+pub use self::LoanPathKind::*;\n pub use self::LoanPathElem::*;\n pub use self::bckerr_code::*;\n pub use self::AliasableViolationKind::*;\n@@ -125,7 +125,7 @@ fn borrowck_item(this: &mut BorrowckCtxt, item: &ast::Item) {\n \n /// Collection of conclusions determined via borrow checker analyses.\n pub struct AnalysisData<'a, 'tcx: 'a> {\n-    pub all_loans: Vec<Loan>,\n+    pub all_loans: Vec<Loan<'tcx>>,\n     pub loans: DataFlowContext<'a, 'tcx, LoanDataFlowOperator>,\n     pub move_data: move_data::FlowedMoveData<'a, 'tcx>,\n }\n@@ -143,6 +143,9 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                        move_data:flowed_moves } =\n         build_borrowck_dataflow_data(this, fk, decl, &cfg, body, sp, id);\n \n+    move_data::fragments::instrument_move_fragments(&flowed_moves.move_data,\n+                                                    this.tcx, sp, id);\n+\n     check_loans::check_loans(this, &loan_dfcx, flowed_moves,\n                              all_loans.as_slice(), decl, body);\n \n@@ -254,11 +257,11 @@ pub type BckResult<'tcx, T> = Result<T, BckError<'tcx>>;\n // Loans and loan paths\n \n /// Record of a loan that was issued.\n-pub struct Loan {\n+pub struct Loan<'tcx> {\n     index: uint,\n-    loan_path: Rc<LoanPath>,\n+    loan_path: Rc<LoanPath<'tcx>>,\n     kind: ty::BorrowKind,\n-    restricted_paths: Vec<Rc<LoanPath>>,\n+    restricted_paths: Vec<Rc<LoanPath<'tcx>>>,\n \n     /// gen_scope indicates where loan is introduced. Typically the\n     /// loan is introduced at the point of the borrow, but in some\n@@ -276,27 +279,68 @@ pub struct Loan {\n     cause: euv::LoanCause,\n }\n \n-impl Loan {\n-    pub fn loan_path(&self) -> Rc<LoanPath> {\n+impl<'tcx> Loan<'tcx> {\n+    pub fn loan_path(&self) -> Rc<LoanPath<'tcx>> {\n         self.loan_path.clone()\n     }\n }\n \n+#[deriving(Eq, Hash, Show)]\n+pub struct LoanPath<'tcx> {\n+    kind: LoanPathKind<'tcx>,\n+    ty: ty::Ty<'tcx>,\n+}\n+\n+impl<'tcx> LoanPath<'tcx> {\n+    pub fn eq_debug(&self, that: &LoanPath<'tcx>, tcx: &ty::ctxt<'tcx>) -> bool {\n+        let r = self.kind == that.kind;\n+        if r && self.ty != that.ty {\n+            panic!(\"eq variants ineq types: {} == {}, {} != {}\",\n+                   self.repr(tcx), that.repr(tcx),\n+                   self.ty.repr(tcx), that.ty.repr(tcx));\n+        }\n+        r\n+    }\n+}\n+\n+impl<'tcx> PartialEq for LoanPath<'tcx> {\n+    fn eq(&self, that: &LoanPath<'tcx>) -> bool {\n+        let r = self.kind == that.kind;\n+        debug_assert!(self.ty == that.ty || !r,\n+                      \"Somehow loan paths are equal though their tys are not.\");\n+        r\n+    }\n+}\n+\n #[deriving(PartialEq, Eq, Hash, Show)]\n-pub enum LoanPath {\n-    LpVar(ast::NodeId),               // `x` in doc.rs\n-    LpUpvar(ty::UpvarId),             // `x` captured by-value into closure\n-    LpExtend(Rc<LoanPath>, mc::MutabilityCategory, LoanPathElem)\n+pub enum LoanPathKind<'tcx> {\n+    LpVar(ast::NodeId),                         // `x` in doc.rs\n+    LpUpvar(ty::UpvarId),                       // `x` captured by-value into closure\n+    LpDowncast(Rc<LoanPath<'tcx>>, ast::DefId), // `x` downcast to particular enum variant\n+    LpExtend(Rc<LoanPath<'tcx>>, mc::MutabilityCategory, LoanPathElem)\n }\n \n+impl<'tcx> LoanPath<'tcx> {\n+    fn new(kind: LoanPathKind<'tcx>, ty: ty::Ty<'tcx>) -> LoanPath<'tcx> {\n+        LoanPath { kind: kind, ty: ty }\n+    }\n+\n+    fn to_type(&self) -> ty::Ty<'tcx> { self.ty }\n+}\n+\n+// FIXME (pnkfelix): See discussion here\n+// https://github.com/pnkfelix/rust/commit/\n+//     b2b39e8700e37ad32b486b9a8409b50a8a53aa51#commitcomment-7892003\n+static DOWNCAST_PRINTED_OPERATOR : &'static str = \" as \";\n+\n #[deriving(PartialEq, Eq, Hash, Show)]\n pub enum LoanPathElem {\n     LpDeref(mc::PointerKind),    // `*LV` in doc.rs\n     LpInterior(mc::InteriorKind) // `LV.f` in doc.rs\n }\n \n pub fn closure_to_block(closure_id: ast::NodeId,\n-                    tcx: &ty::ctxt) -> ast::NodeId {\n+                        tcx: &ty::ctxt) -> ast::NodeId {\n     match tcx.map.get(closure_id) {\n         ast_map::NodeExpr(expr) => match expr.node {\n             ast::ExprProc(_, ref block) |\n@@ -311,20 +355,21 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n     }\n }\n \n-impl LoanPath {\n-    pub fn kill_scope(&self, tcx: &ty::ctxt) -> region::CodeExtent {\n-        match *self {\n+impl<'tcx> LoanPath<'tcx> {\n+    pub fn kill_scope(&self, tcx: &ty::ctxt<'tcx>) -> region::CodeExtent {\n+        match self.kind {\n             LpVar(local_id) => tcx.region_maps.var_scope(local_id),\n             LpUpvar(upvar_id) => {\n                 let block_id = closure_to_block(upvar_id.closure_expr_id, tcx);\n                 region::CodeExtent::from_node_id(block_id)\n             }\n+            LpDowncast(ref base, _) |\n             LpExtend(ref base, _, _) => base.kill_scope(tcx),\n         }\n     }\n \n-    fn has_fork(&self, other: &LoanPath) -> bool {\n-        match (self, other) {\n+    fn has_fork(&self, other: &LoanPath<'tcx>) -> bool {\n+        match (&self.kind, &other.kind) {\n             (&LpExtend(ref base, _, LpInterior(id)), &LpExtend(ref base2, _, LpInterior(id2))) =>\n                 if id == id2 {\n                     base.has_fork(&**base2)\n@@ -338,73 +383,99 @@ impl LoanPath {\n     }\n \n     fn depth(&self) -> uint {\n-        match *self {\n+        match self.kind {\n             LpExtend(ref base, _, LpDeref(_)) => base.depth(),\n             LpExtend(ref base, _, LpInterior(_)) => base.depth() + 1,\n             _ => 0,\n         }\n     }\n \n-    fn common(&self, other: &LoanPath) -> Option<LoanPath> {\n-        match (self, other) {\n-            (&LpExtend(ref base, a, LpInterior(id)), &LpExtend(ref base2, _, LpInterior(id2))) =>\n+    fn common(&self, other: &LoanPath<'tcx>) -> Option<LoanPath<'tcx>> {\n+        match (&self.kind, &other.kind) {\n+            (&LpExtend(ref base, a, LpInterior(id)),\n+             &LpExtend(ref base2, _, LpInterior(id2))) => {\n                 if id == id2 {\n                     base.common(&**base2).map(|x| {\n                         let xd = x.depth();\n                         if base.depth() == xd && base2.depth() == xd {\n-                            LpExtend(Rc::new(x), a, LpInterior(id))\n+                            assert_eq!(base.ty, base2.ty);\n+                            assert_eq!(self.ty, other.ty);\n+                            LoanPath {\n+                                kind: LpExtend(Rc::new(x), a, LpInterior(id)),\n+                                ty: self.ty,\n+                            }\n                         } else {\n                             x\n                         }\n                     })\n                 } else {\n                     base.common(&**base2)\n-                },\n+                }\n+            }\n             (&LpExtend(ref base, _, LpDeref(_)), _) => base.common(other),\n             (_, &LpExtend(ref other, _, LpDeref(_))) => self.common(&**other),\n-            (&LpVar(id), &LpVar(id2)) => if id == id2 { Some(LpVar(id)) } else { None },\n-            (&LpUpvar(id), &LpUpvar(id2)) => if id == id2 { Some(LpUpvar(id)) } else { None },\n+            (&LpVar(id), &LpVar(id2)) => {\n+                if id == id2 {\n+                    assert_eq!(self.ty, other.ty);\n+                    Some(LoanPath { kind: LpVar(id), ty: self.ty })\n+                } else {\n+                    None\n+                }\n+            }\n+            (&LpUpvar(id), &LpUpvar(id2)) => {\n+                if id == id2 {\n+                    assert_eq!(self.ty, other.ty);\n+                    Some(LoanPath { kind: LpUpvar(id), ty: self.ty })\n+                } else {\n+                    None\n+                }\n+            }\n             _ => None,\n         }\n     }\n }\n \n-pub fn opt_loan_path(cmt: &mc::cmt) -> Option<Rc<LoanPath>> {\n+pub fn opt_loan_path<'tcx>(cmt: &mc::cmt<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n     //! Computes the `LoanPath` (if any) for a `cmt`.\n     //! Note that this logic is somewhat duplicated in\n     //! the method `compute()` found in `gather_loans::restrictions`,\n     //! which allows it to share common loan path pieces as it\n     //! traverses the CMT.\n \n+    let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n+\n     match cmt.cat {\n         mc::cat_rvalue(..) |\n         mc::cat_static_item => {\n             None\n         }\n \n         mc::cat_local(id) => {\n-            Some(Rc::new(LpVar(id)))\n+            Some(new_lp(LpVar(id)))\n         }\n \n         mc::cat_upvar(mc::Upvar { id, .. }) => {\n-            Some(Rc::new(LpUpvar(id)))\n+            Some(new_lp(LpUpvar(id)))\n         }\n \n         mc::cat_deref(ref cmt_base, _, pk) => {\n             opt_loan_path(cmt_base).map(|lp| {\n-                Rc::new(LpExtend(lp, cmt.mutbl, LpDeref(pk)))\n+                new_lp(LpExtend(lp, cmt.mutbl, LpDeref(pk)))\n             })\n         }\n \n         mc::cat_interior(ref cmt_base, ik) => {\n             opt_loan_path(cmt_base).map(|lp| {\n-                Rc::new(LpExtend(lp, cmt.mutbl, LpInterior(ik)))\n+                new_lp(LpExtend(lp, cmt.mutbl, LpInterior(ik)))\n             })\n         }\n \n-        mc::cat_downcast(ref cmt_base) => {\n+        mc::cat_downcast(ref cmt_base, variant_def_id) =>\n             opt_loan_path(cmt_base)\n-        }\n+            .map(|lp| {\n+                new_lp(LpDowncast(lp, variant_def_id))\n+            }),\n+\n     }\n }\n \n@@ -472,9 +543,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn report_use_of_moved_value(&self,\n                                      use_span: Span,\n                                      use_kind: MovedValueUseKind,\n-                                     lp: &LoanPath,\n+                                     lp: &LoanPath<'tcx>,\n                                      the_move: &move_data::Move,\n-                                     moved_lp: &LoanPath) {\n+                                     moved_lp: &LoanPath<'tcx>) {\n         let verb = match use_kind {\n             MovedInUse => \"use\",\n             MovedInCapture => \"capture\",\n@@ -623,7 +694,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n     pub fn report_reassigned_immutable_variable(&self,\n                                                 span: Span,\n-                                                lp: &LoanPath,\n+                                                lp: &LoanPath<'tcx>,\n                                                 assign:\n                                                 &move_data::Assignment) {\n         self.tcx.sess.span_err(\n@@ -854,14 +925,23 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n \n     pub fn append_loan_path_to_string(&self,\n-                                   loan_path: &LoanPath,\n-                                   out: &mut String) {\n-        match *loan_path {\n+                                      loan_path: &LoanPath<'tcx>,\n+                                      out: &mut String) {\n+        match loan_path.kind {\n             LpUpvar(ty::UpvarId{ var_id: id, closure_expr_id: _ }) |\n             LpVar(id) => {\n                 out.push_str(ty::local_var_name_str(self.tcx, id).get());\n             }\n \n+            LpDowncast(ref lp_base, variant_def_id) => {\n+                out.push('(');\n+                self.append_loan_path_to_string(&**lp_base, out);\n+                out.push_str(DOWNCAST_PRINTED_OPERATOR);\n+                out.push_str(ty::item_path_str(self.tcx, variant_def_id).as_slice());\n+                out.push(')');\n+            }\n+\n+\n             LpExtend(ref lp_base, _, LpInterior(mc::InteriorField(fname))) => {\n                 self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n                 match fname {\n@@ -889,23 +969,31 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n \n     pub fn append_autoderefd_loan_path_to_string(&self,\n-                                              loan_path: &LoanPath,\n-                                              out: &mut String) {\n-        match *loan_path {\n+                                                 loan_path: &LoanPath<'tcx>,\n+                                                 out: &mut String) {\n+        match loan_path.kind {\n             LpExtend(ref lp_base, _, LpDeref(_)) => {\n                 // For a path like `(*x).f` or `(*x)[3]`, autoderef\n                 // rules would normally allow users to omit the `*x`.\n                 // So just serialize such paths to `x.f` or x[3]` respectively.\n                 self.append_autoderefd_loan_path_to_string(&**lp_base, out)\n             }\n \n+            LpDowncast(ref lp_base, variant_def_id) => {\n+                out.push('(');\n+                self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n+                out.push(':');\n+                out.push_str(ty::item_path_str(self.tcx, variant_def_id).as_slice());\n+                out.push(')');\n+            }\n+\n             LpVar(..) | LpUpvar(..) | LpExtend(_, _, LpInterior(..)) => {\n                 self.append_loan_path_to_string(loan_path, out)\n             }\n         }\n     }\n \n-    pub fn loan_path_to_string(&self, loan_path: &LoanPath) -> String {\n+    pub fn loan_path_to_string(&self, loan_path: &LoanPath<'tcx>) -> String {\n         let mut result = String::new();\n         self.append_loan_path_to_string(loan_path, &mut result);\n         result\n@@ -942,8 +1030,8 @@ impl DataFlowOperator for LoanDataFlowOperator {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for Loan {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for Loan<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"Loan_{}({}, {}, {}-{}, {})\",\n                  self.index,\n                  self.loan_path.repr(tcx),\n@@ -954,25 +1042,66 @@ impl<'tcx> Repr<'tcx> for Loan {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for LoanPath {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n-        match self {\n-            &LpVar(id) => {\n+impl<'tcx> Repr<'tcx> for LoanPath<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        match self.kind {\n+            LpVar(id) => {\n                 format!(\"$({})\", tcx.map.node_to_string(id))\n             }\n \n-            &LpUpvar(ty::UpvarId{ var_id, closure_expr_id }) => {\n+            LpUpvar(ty::UpvarId{ var_id, closure_expr_id }) => {\n                 let s = tcx.map.node_to_string(var_id);\n                 format!(\"$({} captured by id={})\", s, closure_expr_id)\n             }\n \n-            &LpExtend(ref lp, _, LpDeref(_)) => {\n+            LpDowncast(ref lp, variant_def_id) => {\n+                let variant_str = if variant_def_id.krate == ast::LOCAL_CRATE {\n+                    ty::item_path_str(tcx, variant_def_id)\n+                } else {\n+                    variant_def_id.repr(tcx)\n+                };\n+                format!(\"({}{}{})\", lp.repr(tcx), DOWNCAST_PRINTED_OPERATOR, variant_str)\n+            }\n+\n+            LpExtend(ref lp, _, LpDeref(_)) => {\n                 format!(\"{}.*\", lp.repr(tcx))\n             }\n \n-            &LpExtend(ref lp, _, LpInterior(ref interior)) => {\n+            LpExtend(ref lp, _, LpInterior(ref interior)) => {\n                 format!(\"{}.{}\", lp.repr(tcx), interior.repr(tcx))\n             }\n         }\n     }\n }\n+\n+impl<'tcx> UserString<'tcx> for LoanPath<'tcx> {\n+    fn user_string(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        match self.kind {\n+            LpVar(id) => {\n+                format!(\"$({})\", tcx.map.node_to_user_string(id))\n+            }\n+\n+            LpUpvar(ty::UpvarId{ var_id, closure_expr_id: _ }) => {\n+                let s = tcx.map.node_to_user_string(var_id);\n+                format!(\"$({} captured by closure)\", s)\n+            }\n+\n+            LpDowncast(ref lp, variant_def_id) => {\n+                let variant_str = if variant_def_id.krate == ast::LOCAL_CRATE {\n+                    ty::item_path_str(tcx, variant_def_id)\n+                } else {\n+                    variant_def_id.repr(tcx)\n+                };\n+                format!(\"({}{}{})\", lp.user_string(tcx), DOWNCAST_PRINTED_OPERATOR, variant_str)\n+            }\n+\n+            LpExtend(ref lp, _, LpDeref(_)) => {\n+                format!(\"{}.*\", lp.user_string(tcx))\n+            }\n+\n+            LpExtend(ref lp, _, LpInterior(ref interior)) => {\n+                format!(\"{}.{}\", lp.user_string(tcx), interior.repr(tcx))\n+            }\n+        }\n+    }\n+}"}, {"sha": "dc9516ccc5da2d352c9b3938b9782ae5dd29122e", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 150, "deletions": 49, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -11,7 +11,7 @@\n /*!\n \n Data structures used for tracking moves. Please see the extensive\n-comments in the section \"Moves and initialization\" and in `doc.rs`.\n+comments in the section \"Moves and initialization\" in `doc.rs`.\n \n */\n \n@@ -21,6 +21,8 @@ use std::cell::RefCell;\n use std::rc::Rc;\n use std::uint;\n use middle::borrowck::*;\n+use middle::borrowck::LoanPathKind::{LpVar, LpUpvar, LpDowncast, LpExtend};\n+use middle::borrowck::LoanPathElem::{LpInterior};\n use middle::cfg;\n use middle::dataflow::DataFlowContext;\n use middle::dataflow::BitwiseOperator;\n@@ -34,12 +36,15 @@ use syntax::codemap::Span;\n use util::nodemap::{FnvHashMap, NodeSet};\n use util::ppaux::Repr;\n \n-pub struct MoveData {\n+#[path=\"fragments.rs\"]\n+pub mod fragments;\n+\n+pub struct MoveData<'tcx> {\n     /// Move paths. See section \"Move paths\" in `doc.rs`.\n-    pub paths: RefCell<Vec<MovePath>>,\n+    pub paths: RefCell<Vec<MovePath<'tcx>>>,\n \n     /// Cache of loan path to move path index, for easy lookup.\n-    pub path_map: RefCell<FnvHashMap<Rc<LoanPath>, MovePathIndex>>,\n+    pub path_map: RefCell<FnvHashMap<Rc<LoanPath<'tcx>>, MovePathIndex>>,\n \n     /// Each move or uninitialized variable gets an entry here.\n     pub moves: RefCell<Vec<Move>>,\n@@ -54,12 +59,19 @@ pub struct MoveData {\n     /// kill move bits.\n     pub path_assignments: RefCell<Vec<Assignment>>,\n \n+    /// Enum variant matched within a pattern on some match arm, like\n+    /// `SomeStruct{ f: Variant1(x, y) } => ...`\n+    pub variant_matches: RefCell<Vec<VariantMatch>>,\n+\n     /// Assignments to a variable or path, like `x = foo`, but not `x += foo`.\n     pub assignee_ids: RefCell<NodeSet>,\n+\n+    /// Path-fragments from moves in to or out of parts of structured data.\n+    pub fragments: RefCell<fragments::FragmentSets>,\n }\n \n pub struct FlowedMoveData<'a, 'tcx: 'a> {\n-    pub move_data: MoveData,\n+    pub move_data: MoveData<'tcx>,\n \n     pub dfcx_moves: MoveDataFlow<'a, 'tcx>,\n \n@@ -70,7 +82,7 @@ pub struct FlowedMoveData<'a, 'tcx: 'a> {\n }\n \n /// Index into `MoveData.paths`, used like a pointer\n-#[deriving(PartialEq, Show)]\n+#[deriving(PartialEq, Eq, PartialOrd, Ord, Show)]\n pub struct MovePathIndex(uint);\n \n impl MovePathIndex {\n@@ -103,9 +115,9 @@ impl MoveIndex {\n static InvalidMoveIndex: MoveIndex =\n     MoveIndex(uint::MAX);\n \n-pub struct MovePath {\n+pub struct MovePath<'tcx> {\n     /// Loan path corresponding to this move path\n-    pub loan_path: Rc<LoanPath>,\n+    pub loan_path: Rc<LoanPath<'tcx>>,\n \n     /// Parent pointer, `InvalidMovePathIndex` if root\n     pub parent: MovePathIndex,\n@@ -155,6 +167,20 @@ pub struct Assignment {\n     pub span: Span,\n }\n \n+pub struct VariantMatch {\n+    /// downcast to the variant.\n+    pub path: MovePathIndex,\n+\n+    /// path being downcast to the variant.\n+    pub base_path: MovePathIndex,\n+\n+    /// id where variant's pattern occurs\n+    pub id: ast::NodeId,\n+\n+    /// says if variant established by move (and why), by copy, or by borrow.\n+    pub mode: euv::MatchMode\n+}\n+\n #[deriving(Clone)]\n pub struct MoveDataFlowOperator;\n \n@@ -166,7 +192,7 @@ pub struct AssignDataFlowOperator;\n pub type AssignDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, AssignDataFlowOperator>;\n \n fn loan_path_is_precise(loan_path: &LoanPath) -> bool {\n-    match *loan_path {\n+    match loan_path.kind {\n         LpVar(_) | LpUpvar(_) => {\n             true\n         }\n@@ -175,25 +201,59 @@ fn loan_path_is_precise(loan_path: &LoanPath) -> bool {\n             // location, as there is no accurate tracking of the indices.\n             false\n         }\n+        LpDowncast(ref lp_base, _) |\n         LpExtend(ref lp_base, _, _) => {\n             loan_path_is_precise(&**lp_base)\n         }\n     }\n }\n \n-impl MoveData {\n-    pub fn new() -> MoveData {\n+impl Move {\n+    pub fn to_string<'tcx>(&self, move_data: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) -> String {\n+        format!(\"Move{} path: {}, id: {}, kind: {} {}\",\n+                \"{\",\n+                move_data.path_loan_path(self.path).repr(tcx),\n+                self.id,\n+                self.kind,\n+                \"}\")\n+    }\n+}\n+\n+impl Assignment {\n+    pub fn to_string<'tcx>(&self, move_data: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) -> String {\n+        format!(\"Assignment{} path: {}, id: {} {}\",\n+                \"{\",\n+                move_data.path_loan_path(self.path).repr(tcx),\n+                self.id,\n+                \"}\")\n+    }\n+}\n+\n+impl VariantMatch {\n+    pub fn to_string<'tcx>(&self, move_data: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) -> String {\n+        format!(\"VariantMatch{} path: {}, id: {} {}\",\n+                \"{\",\n+                move_data.path_loan_path(self.path).repr(tcx),\n+                self.id,\n+                \"}\")\n+    }\n+}\n+\n+impl<'tcx> MoveData<'tcx> {\n+    pub fn new() -> MoveData<'tcx> {\n         MoveData {\n             paths: RefCell::new(Vec::new()),\n             path_map: RefCell::new(FnvHashMap::new()),\n             moves: RefCell::new(Vec::new()),\n             path_assignments: RefCell::new(Vec::new()),\n             var_assignments: RefCell::new(Vec::new()),\n+            variant_matches: RefCell::new(Vec::new()),\n             assignee_ids: RefCell::new(NodeSet::new()),\n+            fragments: RefCell::new(fragments::FragmentSets::new()),\n         }\n     }\n \n-    pub fn path_loan_path(&self, index: MovePathIndex) -> Rc<LoanPath> {\n+    pub fn path_loan_path(&self, index: MovePathIndex) -> Rc<LoanPath<'tcx>> {\n         (*self.paths.borrow())[index.get()].loan_path.clone()\n     }\n \n@@ -205,6 +265,8 @@ impl MoveData {\n         (*self.paths.borrow())[index.get()].first_move\n     }\n \n+    /// Returns the index of first child, or `InvalidMovePathIndex` if\n+    /// `index` is leaf.\n     fn path_first_child(&self, index: MovePathIndex) -> MovePathIndex {\n         (*self.paths.borrow())[index.get()].first_child\n     }\n@@ -236,8 +298,8 @@ impl MoveData {\n     }\n \n     pub fn move_path(&self,\n-                     tcx: &ty::ctxt,\n-                     lp: Rc<LoanPath>) -> MovePathIndex {\n+                     tcx: &ty::ctxt<'tcx>,\n+                     lp: Rc<LoanPath<'tcx>>) -> MovePathIndex {\n         /*!\n          * Returns the existing move path index for `lp`, if any,\n          * and otherwise adds a new index for `lp` and any of its\n@@ -251,7 +313,7 @@ impl MoveData {\n             None => {}\n         }\n \n-        let index = match *lp {\n+        let index = match lp.kind {\n             LpVar(..) | LpUpvar(..) => {\n                 let index = MovePathIndex(self.paths.borrow().len());\n \n@@ -266,6 +328,7 @@ impl MoveData {\n                 index\n             }\n \n+            LpDowncast(ref base, _) |\n             LpExtend(ref base, _, _) => {\n                 let parent_index = self.move_path(tcx, base.clone());\n \n@@ -295,19 +358,19 @@ impl MoveData {\n         return index;\n     }\n \n-    fn existing_move_path(&self, lp: &Rc<LoanPath>)\n+    fn existing_move_path(&self, lp: &Rc<LoanPath<'tcx>>)\n                           -> Option<MovePathIndex> {\n         self.path_map.borrow().get(lp).cloned()\n     }\n \n-    fn existing_base_paths(&self, lp: &Rc<LoanPath>)\n+    fn existing_base_paths(&self, lp: &Rc<LoanPath<'tcx>>)\n                            -> Vec<MovePathIndex> {\n         let mut result = vec!();\n         self.add_existing_base_paths(lp, &mut result);\n         result\n     }\n \n-    fn add_existing_base_paths(&self, lp: &Rc<LoanPath>,\n+    fn add_existing_base_paths(&self, lp: &Rc<LoanPath<'tcx>>,\n                                result: &mut Vec<MovePathIndex>) {\n         /*!\n          * Adds any existing move path indices for `lp` and any base\n@@ -322,8 +385,9 @@ impl MoveData {\n                 });\n             }\n             None => {\n-                match **lp {\n+                match lp.kind {\n                     LpVar(..) | LpUpvar(..) => { }\n+                    LpDowncast(ref b, _) |\n                     LpExtend(ref b, _, _) => {\n                         self.add_existing_base_paths(b, result);\n                     }\n@@ -334,8 +398,8 @@ impl MoveData {\n     }\n \n     pub fn add_move(&self,\n-                    tcx: &ty::ctxt,\n-                    lp: Rc<LoanPath>,\n+                    tcx: &ty::ctxt<'tcx>,\n+                    lp: Rc<LoanPath<'tcx>>,\n                     id: ast::NodeId,\n                     kind: MoveKind) {\n         /*!\n@@ -348,9 +412,11 @@ impl MoveData {\n                id,\n                kind);\n \n-        let path_index = self.move_path(tcx, lp);\n+        let path_index = self.move_path(tcx, lp.clone());\n         let move_index = MoveIndex(self.moves.borrow().len());\n \n+        self.fragments.borrow_mut().add_move(path_index);\n+\n         let next_move = self.path_first_move(path_index);\n         self.set_path_first_move(path_index, move_index);\n \n@@ -363,8 +429,8 @@ impl MoveData {\n     }\n \n     pub fn add_assignment(&self,\n-                          tcx: &ty::ctxt,\n-                          lp: Rc<LoanPath>,\n+                          tcx: &ty::ctxt<'tcx>,\n+                          lp: Rc<LoanPath<'tcx>>,\n                           assign_id: ast::NodeId,\n                           span: Span,\n                           assignee_id: ast::NodeId,\n@@ -379,6 +445,8 @@ impl MoveData {\n \n         let path_index = self.move_path(tcx, lp.clone());\n \n+        self.fragments.borrow_mut().add_assignment(path_index);\n+\n         match mode {\n             euv::Init | euv::JustWrite => {\n                 self.assignee_ids.borrow_mut().insert(assignee_id);\n@@ -405,8 +473,42 @@ impl MoveData {\n         }\n     }\n \n+    pub fn add_variant_match(&self,\n+                             tcx: &ty::ctxt<'tcx>,\n+                             lp: Rc<LoanPath<'tcx>>,\n+                             pattern_id: ast::NodeId,\n+                             base_lp: Rc<LoanPath<'tcx>>,\n+                             mode: euv::MatchMode) {\n+        /*!\n+         * Adds a new record for a match of `base_lp`, downcast to\n+         * variant `lp`, that occurs at location `pattern_id`.  (One\n+         * should be able to recover the span info from the\n+         * `pattern_id` and the ast_map, I think.)\n+         */\n+        debug!(\"add_variant_match(lp={}, pattern_id={})\",\n+               lp.repr(tcx), pattern_id);\n+\n+        let path_index = self.move_path(tcx, lp.clone());\n+        let base_path_index = self.move_path(tcx, base_lp.clone());\n+\n+        self.fragments.borrow_mut().add_assignment(path_index);\n+\n+        let variant_match = VariantMatch {\n+            path: path_index,\n+            base_path: base_path_index,\n+            id: pattern_id,\n+            mode: mode,\n+        };\n+\n+        self.variant_matches.borrow_mut().push(variant_match);\n+    }\n+\n+    fn fixup_fragment_sets(&self, tcx: &ty::ctxt<'tcx>) {\n+        fragments::fixup_fragment_sets(self, tcx)\n+    }\n+\n     fn add_gen_kills(&self,\n-                     tcx: &ty::ctxt,\n+                     tcx: &ty::ctxt<'tcx>,\n                      dfcx_moves: &mut MoveDataFlow,\n                      dfcx_assign: &mut AssignDataFlow) {\n         /*!\n@@ -430,36 +532,28 @@ impl MoveData {\n             self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n         }\n \n-        // Kill all moves related to a variable `x` when it goes out\n-        // of scope:\n+        // Kill all moves related to a variable `x` when\n+        // it goes out of scope:\n         for path in self.paths.borrow().iter() {\n-            match *path.loan_path {\n-                LpVar(id) => {\n-                    let kill_scope = tcx.region_maps.var_scope(id);\n-                    let path = (*self.path_map.borrow())[path.loan_path];\n+            match path.loan_path.kind {\n+                LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n+                    let kill_scope = path.loan_path.kill_scope(tcx);\n+                    let path = self.path_map.borrow()[path.loan_path];\n                     self.kill_moves(path, kill_scope.node_id(), dfcx_moves);\n                 }\n-                LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }) => {\n-                    let kill_id = closure_to_block(closure_expr_id, tcx);\n-                    let path = (*self.path_map.borrow())[path.loan_path];\n-                    self.kill_moves(path, kill_id, dfcx_moves);\n-                }\n                 LpExtend(..) => {}\n             }\n         }\n \n         // Kill all assignments when the variable goes out of scope:\n         for (assignment_index, assignment) in\n                 self.var_assignments.borrow().iter().enumerate() {\n-            match *self.path_loan_path(assignment.path) {\n-                LpVar(id) => {\n-                    let kill_scope = tcx.region_maps.var_scope(id);\n+            let lp = self.path_loan_path(assignment.path);\n+            match lp.kind {\n+                LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n+                    let kill_scope = lp.kill_scope(tcx);\n                     dfcx_assign.add_kill(kill_scope.node_id(), assignment_index);\n                 }\n-                LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }) => {\n-                    let kill_id = closure_to_block(closure_expr_id, tcx);\n-                    dfcx_assign.add_kill(kill_id, assignment_index);\n-                }\n                 LpExtend(..) => {\n                     tcx.sess.bug(\"var assignment for non var path\");\n                 }\n@@ -536,7 +630,7 @@ impl MoveData {\n }\n \n impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n-    pub fn new(move_data: MoveData,\n+    pub fn new(move_data: MoveData<'tcx>,\n                tcx: &'a ty::ctxt<'tcx>,\n                cfg: &cfg::CFG,\n                id_range: ast_util::IdRange,\n@@ -559,9 +653,16 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n                                  AssignDataFlowOperator,\n                                  id_range,\n                                  move_data.var_assignments.borrow().len());\n-        move_data.add_gen_kills(tcx, &mut dfcx_moves, &mut dfcx_assign);\n+\n+        move_data.fixup_fragment_sets(tcx);\n+\n+        move_data.add_gen_kills(tcx,\n+                                &mut dfcx_moves,\n+                                &mut dfcx_assign);\n+\n         dfcx_moves.add_kills_from_flow_exits(cfg);\n         dfcx_assign.add_kills_from_flow_exits(cfg);\n+\n         dfcx_moves.propagate(cfg, body);\n         dfcx_assign.propagate(cfg, body);\n \n@@ -574,7 +675,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n \n     pub fn kind_of_move_of_path(&self,\n                                 id: ast::NodeId,\n-                                loan_path: &Rc<LoanPath>)\n+                                loan_path: &Rc<LoanPath<'tcx>>)\n                                 -> Option<MoveKind> {\n         //! Returns the kind of a move of `loan_path` by `id`, if one exists.\n \n@@ -596,8 +697,8 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n \n     pub fn each_move_of(&self,\n                         id: ast::NodeId,\n-                        loan_path: &Rc<LoanPath>,\n-                        f: |&Move, &LoanPath| -> bool)\n+                        loan_path: &Rc<LoanPath<'tcx>>,\n+                        f: |&Move, &LoanPath<'tcx>| -> bool)\n                         -> bool {\n         /*!\n          * Iterates through each move of `loan_path` (or some base path\n@@ -656,7 +757,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n \n     pub fn each_assignment_of(&self,\n                               id: ast::NodeId,\n-                              loan_path: &Rc<LoanPath>,\n+                              loan_path: &Rc<LoanPath<'tcx>>,\n                               f: |&Assignment| -> bool)\n                               -> bool {\n         /*!"}, {"sha": "806fea3b54fd5b7e65c6d56296424df0dd54f70b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -18,6 +18,7 @@ use middle::def::*;\n use middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Init};\n use middle::expr_use_visitor::{JustWrite, LoanCause, MutateMode};\n use middle::expr_use_visitor::{WriteAndRead};\n+use middle::expr_use_visitor as euv;\n use middle::mem_categorization::cmt;\n use middle::pat_util::*;\n use middle::ty::*;\n@@ -1024,6 +1025,7 @@ struct MutationChecker<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n+    fn matched_pat(&mut self, _: &Pat, _: cmt, _: euv::MatchMode) {}\n     fn consume(&mut self, _: NodeId, _: Span, _: cmt, _: ConsumeMode) {}\n     fn consume_pat(&mut self, _: &Pat, _: cmt, _: ConsumeMode) {}\n     fn borrow(&mut self,"}, {"sha": "dae76ba125e60f62ef32b77f5d792a16ebaa5dcf", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -59,6 +59,11 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContext<'a, 'tcx> {\n         }\n     }\n \n+    fn matched_pat(&mut self,\n+                   _matched_pat: &ast::Pat,\n+                   _cmt: mc::cmt,\n+                   _mode: euv::MatchMode) {}\n+\n     fn consume_pat(&mut self,\n                    _consume_pat: &ast::Pat,\n                    _cmt: mc::cmt,"}, {"sha": "d3c7ccf65dd722524af1e940cbf8a3768ab76cd8", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -270,7 +270,7 @@ impl<'tcx> euv::Delegate<'tcx> for GlobalChecker {\n                     break\n                 }\n                 mc::cat_deref(ref cmt, _, _) |\n-                mc::cat_downcast(ref cmt) |\n+                mc::cat_downcast(ref cmt, _) |\n                 mc::cat_interior(ref cmt, _) => cur = cmt,\n \n                 mc::cat_rvalue(..) |\n@@ -325,6 +325,12 @@ impl<'tcx> euv::Delegate<'tcx> for GlobalChecker {\n               _assignment_span: Span,\n               _assignee_cmt: mc::cmt,\n               _mode: euv::MutateMode) {}\n+\n+    fn matched_pat(&mut self,\n+                   _: &ast::Pat,\n+                   _: mc::cmt,\n+                   _: euv::MatchMode) {}\n+\n     fn consume_pat(&mut self,\n                    _consume_pat: &ast::Pat,\n                    _cmt: mc::cmt,"}, {"sha": "656feb51a1d3c9e5931ff37d2f38cd80cdb7ab41", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 249, "deletions": 10, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -18,6 +18,8 @@ pub use self::MutateMode::*;\n pub use self::LoanCause::*;\n pub use self::ConsumeMode::*;\n pub use self::MoveReason::*;\n+pub use self::MatchMode::*;\n+use self::TrackMatchMode::*;\n use self::OverloadedCallType::*;\n \n use middle::{def, region, pat_util};\n@@ -48,6 +50,23 @@ pub trait Delegate<'tcx> {\n                cmt: mc::cmt<'tcx>,\n                mode: ConsumeMode);\n \n+    // The value found at `cmt` has been determined to match the\n+    // pattern binding `matched_pat`, and its subparts are being\n+    // copied or moved depending on `mode`.  Note that `matched_pat`\n+    // is called on all variant/structs in the pattern (i.e., the\n+    // interior nodes of the pattern's tree structure) while\n+    // consume_pat is called on the binding identifiers in the pattern\n+    // (which are leaves of the pattern's tree structure).\n+    //\n+    // Note that variants/structs and identifiers are disjoint; thus\n+    // `matched_pat` and `consume_pat` are never both called on the\n+    // same input pattern structure (though of `consume_pat` can be\n+    // called on a subpart of an input passed to `matched_pat).\n+    fn matched_pat(&mut self,\n+                   matched_pat: &ast::Pat,\n+                   cmt: mc::cmt<'tcx>,\n+                   mode: MatchMode);\n+\n     // The value found at `cmt` is either copied or moved via the\n     // pattern binding `consume_pat`, depending on mode.\n     fn consume_pat(&mut self,\n@@ -103,6 +122,79 @@ pub enum MoveReason {\n     CaptureMove,\n }\n \n+#[deriving(PartialEq,Show)]\n+pub enum MatchMode {\n+    NonBindingMatch,\n+    BorrowingMatch,\n+    CopyingMatch,\n+    MovingMatch,\n+}\n+\n+#[deriving(PartialEq,Show)]\n+enum TrackMatchMode<T> {\n+    Unknown, Definite(MatchMode), Conflicting,\n+}\n+\n+impl<T> TrackMatchMode<T> {\n+    // Builds up the whole match mode for a pattern from its constituent\n+    // parts.  The lattice looks like this:\n+    //\n+    //          Conflicting\n+    //            /     \\\n+    //           /       \\\n+    //      Borrowing   Moving\n+    //           \\       /\n+    //            \\     /\n+    //            Copying\n+    //               |\n+    //          NonBinding\n+    //               |\n+    //            Unknown\n+    //\n+    // examples:\n+    //\n+    // * `(_, some_int)` pattern is Copying, since\n+    //   NonBinding + Copying => Copying\n+    //\n+    // * `(some_int, some_box)` pattern is Moving, since\n+    //   Copying + Moving => Moving\n+    //\n+    // * `(ref x, some_box)` pattern is Conflicting, since\n+    //   Borrowing + Moving => Conflicting\n+    //\n+    // Note that the `Unknown` and `Conflicting` states are\n+    // represented separately from the other more interesting\n+    // `Definite` states, which simplifies logic here somewhat.\n+    fn lub(&mut self, mode: MatchMode) {\n+        *self = match (*self, mode) {\n+            // Note that clause order below is very significant.\n+            (Unknown, new) => Definite(new),\n+            (Definite(old), new) if old == new => Definite(old),\n+\n+            (Definite(old), NonBindingMatch) => Definite(old),\n+            (Definite(NonBindingMatch), new) => Definite(new),\n+\n+            (Definite(old), CopyingMatch) => Definite(old),\n+            (Definite(CopyingMatch), new) => Definite(new),\n+\n+            (Definite(_), _) => Conflicting,\n+            (Conflicting, _) => *self,\n+        };\n+    }\n+\n+    fn match_mode(&self) -> MatchMode {\n+        match *self {\n+            Unknown => NonBindingMatch,\n+            Definite(mode) => mode,\n+            Conflicting => {\n+                // Conservatively return MovingMatch to let the\n+                // compiler continue to make progress.\n+                MovingMatch\n+            }\n+        }\n+    }\n+}\n+\n #[deriving(PartialEq,Show)]\n pub enum MutateMode {\n     Init,\n@@ -251,7 +343,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 ty::ReScope(fn_body_scope), // Args live only as long as the fn body.\n                 arg_ty);\n \n-            self.walk_pat(arg_cmt, &*arg.pat);\n+            self.walk_irrefutable_pat(arg_cmt, &*arg.pat);\n         }\n     }\n \n@@ -390,7 +482,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n                 // treatment of the discriminant is handled while walking the arms.\n                 for arm in arms.iter() {\n-                    self.walk_arm(discr_cmt.clone(), arm);\n+                    let mode = self.arm_move_mode(discr_cmt.clone(), arm);\n+                    let mode = mode.match_mode();\n+                    self.walk_arm(discr_cmt.clone(), arm, mode);\n                 }\n             }\n \n@@ -448,7 +542,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                                  pat.span,\n                                                  ty::ReScope(blk_scope),\n                                                  pattern_type);\n-                self.walk_pat(pat_cmt, &**pat);\n+                self.walk_irrefutable_pat(pat_cmt, &**pat);\n \n                 self.walk_block(&**blk);\n             }\n@@ -617,7 +711,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 // `walk_pat`:\n                 self.walk_expr(&**expr);\n                 let init_cmt = return_if_err!(self.mc.cat_expr(&**expr));\n-                self.walk_pat(init_cmt, &*local.pat);\n+                self.walk_irrefutable_pat(init_cmt, &*local.pat);\n             }\n         }\n     }\n@@ -824,9 +918,17 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         return true;\n     }\n \n-    fn walk_arm(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &ast::Arm) {\n+    fn arm_move_mode(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &ast::Arm) -> TrackMatchMode<Span> {\n+        let mut mode = Unknown;\n         for pat in arm.pats.iter() {\n-            self.walk_pat(discr_cmt.clone(), &**pat);\n+            self.determine_pat_move_mode(discr_cmt.clone(), &**pat, &mut mode);\n+        }\n+        mode\n+    }\n+\n+    fn walk_arm(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &ast::Arm, mode: MatchMode) {\n+        for pat in arm.pats.iter() {\n+            self.walk_pat(discr_cmt.clone(), &**pat, mode);\n         }\n \n         for guard in arm.guard.iter() {\n@@ -836,21 +938,71 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         self.consume_expr(&*arm.body);\n     }\n \n-    fn walk_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &ast::Pat) {\n+    /// Walks an pat that occurs in isolation (i.e. top-level of fn\n+    /// arg or let binding.  *Not* a match arm or nested pat.)\n+    fn walk_irrefutable_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &ast::Pat) {\n+        let mut mode = Unknown;\n+        self.determine_pat_move_mode(cmt_discr.clone(), pat, &mut mode);\n+        let mode = mode.match_mode();\n+        self.walk_pat(cmt_discr, pat, mode);\n+    }\n+\n+    /// Identifies any bindings within `pat` and accumulates within\n+    /// `mode` whether the overall pattern/match structure is a move,\n+    /// copy, or borrow.\n+    fn determine_pat_move_mode(&mut self,\n+                               cmt_discr: mc::cmt<'tcx>,\n+                               pat: &ast::Pat,\n+                               mode: &mut TrackMatchMode<Span>) {\n+        debug!(\"determine_pat_move_mode cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n+               pat.repr(self.tcx()));\n+        return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n+            let tcx = self.typer.tcx();\n+            let def_map = &self.typer.tcx().def_map;\n+            if pat_util::pat_is_binding(def_map, pat) {\n+                match pat.node {\n+                    ast::PatIdent(ast::BindByRef(_), _, _) =>\n+                        mode.lub(BorrowingMatch),\n+                    ast::PatIdent(ast::BindByValue(_), _, _) => {\n+                        match copy_or_move(tcx, cmt_pat.ty, PatBindingMove) {\n+                            Copy => mode.lub(CopyingMatch),\n+                            Move(_) => mode.lub(MovingMatch),\n+                        }\n+                    }\n+                    _ => {\n+                        tcx.sess.span_bug(\n+                            pat.span,\n+                            \"binding pattern not an identifier\");\n+                    }\n+                }\n+            }\n+        }));\n+    }\n+\n+    /// The core driver for walking a pattern; `match_mode` must be\n+    /// established up front, e.g. via `determine_pat_move_mode` (see\n+    /// also `walk_irrefutable_pat` for patterns that stand alone).\n+    fn walk_pat(&mut self,\n+                cmt_discr: mc::cmt<'tcx>,\n+                pat: &ast::Pat,\n+                match_mode: MatchMode) {\n         debug!(\"walk_pat cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n                pat.repr(self.tcx()));\n+\n         let mc = &self.mc;\n         let typer = self.typer;\n         let tcx = typer.tcx();\n         let def_map = &self.typer.tcx().def_map;\n         let delegate = &mut self.delegate;\n-        return_if_err!(mc.cat_pattern(cmt_discr, &*pat, |mc, cmt_pat, pat| {\n+\n+        return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n             if pat_util::pat_is_binding(def_map, pat) {\n                 let tcx = typer.tcx();\n \n-                debug!(\"binding cmt_pat={} pat={}\",\n+                debug!(\"binding cmt_pat={} pat={} match_mode={}\",\n                        cmt_pat.repr(tcx),\n-                       pat.repr(tcx));\n+                       pat.repr(tcx),\n+                       match_mode);\n \n                 // pat_ty: the type of the binding being produced.\n                 let pat_ty = return_if_err!(typer.node_ty(pat.id));\n@@ -933,6 +1085,93 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 }\n             }\n         }));\n+\n+        // Do a second pass over the pattern, calling `matched_pat` on\n+        // the interior nodes (enum variants and structs), as opposed\n+        // to the above loop's visit of than the bindings that form\n+        // the leaves of the pattern tree structure.\n+        return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n+            let def_map = def_map.borrow();\n+            let tcx = typer.tcx();\n+\n+            match pat.node {\n+                ast::PatEnum(_, _) | ast::PatIdent(_, _, None) | ast::PatStruct(..) => {\n+                    match def_map.get(&pat.id) {\n+                        None => {\n+                            // no definition found: pat is not a\n+                            // struct or enum pattern.\n+                        }\n+\n+                        Some(&def::DefVariant(enum_did, variant_did, _is_struct)) => {\n+                            let downcast_cmt =\n+                                if ty::enum_is_univariant(tcx, enum_did) {\n+                                    cmt_pat\n+                                } else {\n+                                    let cmt_pat_ty = cmt_pat.ty;\n+                                    mc.cat_downcast(pat, cmt_pat, cmt_pat_ty, variant_did)\n+                                };\n+\n+                            debug!(\"variant downcast_cmt={} pat={}\",\n+                                   downcast_cmt.repr(tcx),\n+                                   pat.repr(tcx));\n+\n+                            delegate.matched_pat(pat, downcast_cmt, match_mode);\n+                        }\n+\n+                        Some(&def::DefStruct(..)) | Some(&def::DefTy(_, false)) => {\n+                            // A struct (in either the value or type\n+                            // namespace; we encounter the former on\n+                            // e.g. patterns for unit structs).\n+\n+                            debug!(\"struct cmt_pat={} pat={}\",\n+                                   cmt_pat.repr(tcx),\n+                                   pat.repr(tcx));\n+\n+                            delegate.matched_pat(pat, cmt_pat, match_mode);\n+                        }\n+\n+                        Some(&def::DefConst(..)) |\n+                        Some(&def::DefLocal(..)) => {\n+                            // This is a leaf (i.e. identifier binding\n+                            // or constant value to match); thus no\n+                            // `matched_pat` call.\n+                        }\n+\n+                        Some(def @ &def::DefTy(_, true)) => {\n+                            // An enum's type -- should never be in a\n+                            // pattern.\n+\n+                            let msg = format!(\"Pattern has unexpected type: {}\", def);\n+                            tcx.sess.span_bug(pat.span, msg.as_slice())\n+                        }\n+\n+                        Some(def) => {\n+                            // Remaining cases are e.g. DefFn, to\n+                            // which identifiers within patterns\n+                            // should not resolve.\n+\n+                            let msg = format!(\"Pattern has unexpected def: {}\", def);\n+                            tcx.sess.span_bug(pat.span, msg.as_slice())\n+                        }\n+                    }\n+                }\n+\n+                ast::PatIdent(_, _, Some(_)) => {\n+                    // Do nothing; this is a binding (not a enum\n+                    // variant or struct), and the cat_pattern call\n+                    // will visit the substructure recursively.\n+                }\n+\n+                ast::PatWild(_) | ast::PatTup(..) | ast::PatBox(..) |\n+                ast::PatRegion(..) | ast::PatLit(..) | ast::PatRange(..) |\n+                ast::PatVec(..) | ast::PatMac(..) => {\n+                    // Similarly, each of these cases does not\n+                    // correspond to a enum variant or struct, so we\n+                    // do not do any `matched_pat` calls for these\n+                    // cases either.\n+                }\n+            }\n+        }));\n     }\n \n     fn walk_captures(&mut self, closure_expr: &ast::Expr) {"}, {"sha": "046ab162cfcb05d4c4b3df425cdd788dfb6b14df", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 49, "deletions": 21, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -98,7 +98,7 @@ pub enum categorization<'tcx> {\n     cat_local(ast::NodeId),                    // local variable\n     cat_deref(cmt<'tcx>, uint, PointerKind),   // deref of a ptr\n     cat_interior(cmt<'tcx>, InteriorKind),     // something interior: field, tuple, etc\n-    cat_downcast(cmt<'tcx>),                   // selects a particular enum variant (*1)\n+    cat_downcast(cmt<'tcx>, ast::DefId),       // selects a particular enum variant (*1)\n \n     // (*1) downcast is only required if the enum has more than one variant\n }\n@@ -410,7 +410,28 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     }\n \n     fn pat_ty(&self, pat: &ast::Pat) -> McResult<Ty<'tcx>> {\n-        self.typer.node_ty(pat.id)\n+        let tcx = self.typer.tcx();\n+        let base_ty = self.typer.node_ty(pat.id);\n+        // FIXME (Issue #18207): This code detects whether we are\n+        // looking at a `ref x`, and if so, figures out what the type\n+        // *being borrowed* is.  But ideally we would put in a more\n+        // fundamental fix to this conflated use of the node id.\n+        let ret_ty = match pat.node {\n+            ast::PatIdent(ast::BindByRef(_), _, _) => {\n+                // a bind-by-ref means that the base_ty will be the type of the ident itself,\n+                // but what we want here is the type of the underlying value being borrowed.\n+                // So peel off one-level, turning the &T into T.\n+                base_ty.map(|t| {\n+                    ty::deref(t, false).unwrap_or_else(|| {\n+                        panic!(\"encountered BindByRef with non &-type\");\n+                    }).ty\n+                })\n+            }\n+            _ => base_ty,\n+        };\n+        debug!(\"pat_ty(pat={}) base_ty={} ret_ty={}\",\n+               pat.repr(tcx), base_ty.repr(tcx), ret_ty.repr(tcx));\n+        ret_ty\n     }\n \n     pub fn cat_expr(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n@@ -1102,13 +1123,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_downcast<N:ast_node>(&self,\n                                     node: &N,\n                                     base_cmt: cmt<'tcx>,\n-                                    downcast_ty: Ty<'tcx>)\n+                                    downcast_ty: Ty<'tcx>,\n+                                    variant_did: ast::DefId)\n                                     -> cmt<'tcx> {\n         Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n-            cat: cat_downcast(base_cmt),\n+            cat: cat_downcast(base_cmt, variant_did),\n             ty: downcast_ty,\n             note: NoteNone\n         })\n@@ -1117,7 +1139,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_pattern(&self,\n                        cmt: cmt<'tcx>,\n                        pat: &ast::Pat,\n-                       op: |&MemCategorizationContext<TYPER>,\n+                       op: |&MemCategorizationContext<'t,TYPER>,\n                             cmt<'tcx>,\n                             &ast::Pat|)\n                        -> McResult<()> {\n@@ -1172,6 +1194,21 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         op(self, cmt.clone(), pat);\n \n+        let def_map = self.tcx().def_map.borrow();\n+        let opt_def = def_map.get(&pat.id);\n+\n+        // Note: This goes up here (rather than within the PatEnum arm\n+        // alone) because struct patterns can refer to struct types or\n+        // to struct variants within enums.\n+        let cmt = match opt_def {\n+            Some(&def::DefVariant(enum_did, variant_did, _))\n+                // univariant enums do not need downcasts\n+                if !ty::enum_is_univariant(self.tcx(), enum_did) => {\n+                    self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n+                }\n+            _ => cmt\n+        };\n+\n         match pat.node {\n           ast::PatWild(_) => {\n             // _\n@@ -1181,24 +1218,15 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             // variant(..)\n           }\n           ast::PatEnum(_, Some(ref subpats)) => {\n-            match self.tcx().def_map.borrow().get(&pat.id) {\n-                Some(&def::DefVariant(enum_did, _, _)) => {\n+            match opt_def {\n+                Some(&def::DefVariant(..)) => {\n                     // variant(x, y, z)\n-\n-                    let downcast_cmt = {\n-                        if ty::enum_is_univariant(self.tcx(), enum_did) {\n-                            cmt // univariant, no downcast needed\n-                        } else {\n-                            self.cat_downcast(pat, cmt.clone(), cmt.ty)\n-                        }\n-                    };\n-\n                     for (i, subpat) in subpats.iter().enumerate() {\n                         let subpat_ty = if_ok!(self.pat_ty(&**subpat)); // see (*2)\n \n                         let subcmt =\n                             self.cat_imm_interior(\n-                                pat, downcast_cmt.clone(), subpat_ty,\n+                                pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n \n                         if_ok!(self.cat_pattern(subcmt, &**subpat, |x,y,z| op(x,y,z)));\n@@ -1356,7 +1384,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           cat_upvar(ref var) => {\n               upvar_to_string(var, true)\n           }\n-          cat_downcast(ref cmt) => {\n+          cat_downcast(ref cmt, _) => {\n             self.cmt_to_string(&**cmt)\n           }\n         }\n@@ -1392,7 +1420,7 @@ impl<'tcx> cmt_<'tcx> {\n             cat_upvar(..) => {\n                 Rc::new((*self).clone())\n             }\n-            cat_downcast(ref b) |\n+            cat_downcast(ref b, _) |\n             cat_interior(ref b, _) |\n             cat_deref(ref b, _, OwnedPtr) => {\n                 b.guarantor()\n@@ -1416,7 +1444,7 @@ impl<'tcx> cmt_<'tcx> {\n             cat_deref(ref b, _, Implicit(ty::MutBorrow, _)) |\n             cat_deref(ref b, _, BorrowedPtr(ty::UniqueImmBorrow, _)) |\n             cat_deref(ref b, _, Implicit(ty::UniqueImmBorrow, _)) |\n-            cat_downcast(ref b) |\n+            cat_downcast(ref b, _) |\n             cat_deref(ref b, _, OwnedPtr) |\n             cat_interior(ref b, _) => {\n                 // Aliasability depends on base cmt\n@@ -1500,7 +1528,7 @@ impl<'tcx> Repr<'tcx> for categorization<'tcx> {\n             cat_interior(ref cmt, interior) => {\n                 format!(\"{}.{}\", cmt.cat.repr(tcx), interior.repr(tcx))\n             }\n-            cat_downcast(ref cmt) => {\n+            cat_downcast(ref cmt, _) => {\n                 format!(\"{}->(enum)\", cmt.cat.repr(tcx))\n             }\n         }"}, {"sha": "98b958749d55e64a44a066221cb84a1b33c03771", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -3442,6 +3442,62 @@ pub fn array_element_ty<'tcx>(ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     }\n }\n \n+/// Returns the type of element at index `i` in tuple or tuple-like type `t`.\n+/// For an enum `t`, `variant` is None only if `t` is a univariant enum.\n+pub fn positional_element_ty<'tcx>(cx: &ctxt<'tcx>,\n+                                   ty: Ty<'tcx>,\n+                                   i: uint,\n+                                   variant: Option<ast::DefId>) -> Option<Ty<'tcx>> {\n+\n+    match (&ty.sty, variant) {\n+        (&ty_tup(ref v), None) => v.as_slice().get(i).map(|&t| t),\n+\n+\n+        (&ty_struct(def_id, ref substs), None) => lookup_struct_fields(cx, def_id)\n+            .as_slice().get(i)\n+            .map(|&t|lookup_item_type(cx, t.id).ty.subst(cx, substs)),\n+\n+        (&ty_enum(def_id, ref substs), Some(variant_def_id)) => {\n+            let variant_info = enum_variant_with_id(cx, def_id, variant_def_id);\n+            variant_info.args.as_slice().get(i).map(|t|t.subst(cx, substs))\n+        }\n+\n+        (&ty_enum(def_id, ref substs), None) => {\n+            assert!(enum_is_univariant(cx, def_id));\n+            let enum_variants = enum_variants(cx, def_id);\n+            let variant_info = &(*enum_variants)[0];\n+            variant_info.args.as_slice().get(i).map(|t|t.subst(cx, substs))\n+        }\n+\n+        _ => None\n+    }\n+}\n+\n+/// Returns the type of element at field `n` in struct or struct-like type `t`.\n+/// For an enum `t`, `variant` must be some def id.\n+pub fn named_element_ty<'tcx>(cx: &ctxt<'tcx>,\n+                              ty: Ty<'tcx>,\n+                              n: ast::Name,\n+                              variant: Option<ast::DefId>) -> Option<Ty<'tcx>> {\n+\n+    match (&ty.sty, variant) {\n+        (&ty_struct(def_id, ref substs), None) => {\n+            let r = lookup_struct_fields(cx, def_id);\n+            r.iter().find(|f| f.name == n)\n+                .map(|&f| lookup_field_type(cx, def_id, f.id, substs))\n+        }\n+        (&ty_enum(def_id, ref substs), Some(variant_def_id)) => {\n+            let variant_info = enum_variant_with_id(cx, def_id, variant_def_id);\n+            variant_info.arg_names.as_ref()\n+                .expect(\"must have struct enum variant if accessing a named fields\")\n+                .iter().zip(variant_info.args.iter())\n+                .find(|&(ident, _)| ident.name == n)\n+                .map(|(_ident, arg_t)| arg_t.subst(cx, substs))\n+        }\n+        _ => None\n+    }\n+}\n+\n pub fn node_id_to_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId)\n                                   -> Rc<ty::TraitRef<'tcx>> {\n     match cx.trait_refs.borrow().get(&id) {"}, {"sha": "f12b5cdad9886ffae2b25d2eb3057da5264cd535", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -1503,7 +1503,7 @@ fn link_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                 }\n             }\n \n-            mc::cat_downcast(cmt_base) |\n+            mc::cat_downcast(cmt_base, _) |\n             mc::cat_deref(cmt_base, _, mc::OwnedPtr) |\n             mc::cat_interior(cmt_base, _) => {\n                 // Borrowing interior or owned data requires the base\n@@ -1744,7 +1744,7 @@ fn adjust_upvar_borrow_kind_for_mut<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n         match cmt.cat.clone() {\n             mc::cat_deref(base, _, mc::OwnedPtr) |\n             mc::cat_interior(base, _) |\n-            mc::cat_downcast(base) => {\n+            mc::cat_downcast(base, _) => {\n                 // Interior or owned data is mutable if base is\n                 // mutable, so iterate to the base.\n                 cmt = base;\n@@ -1795,7 +1795,7 @@ fn adjust_upvar_borrow_kind_for_unique<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>, cmt: mc::c\n         match cmt.cat.clone() {\n             mc::cat_deref(base, _, mc::OwnedPtr) |\n             mc::cat_interior(base, _) |\n-            mc::cat_downcast(base) => {\n+            mc::cat_downcast(base, _) => {\n                 // Interior or owned data is unique if base is\n                 // unique.\n                 cmt = base;"}, {"sha": "82cf8f28e3dfe8753c08dee1c92492c9c9aa07bd", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -208,6 +208,7 @@ debugging_opts!(\n         AST_JSON_NOEXPAND,\n         LS,\n         SAVE_ANALYSIS,\n+        PRINT_MOVE_FRAGMENTS,\n         FLOWGRAPH_PRINT_LOANS,\n         FLOWGRAPH_PRINT_MOVES,\n         FLOWGRAPH_PRINT_ASSIGNS,\n@@ -246,6 +247,8 @@ pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n      (\"ls\", \"List the symbols defined by a library crate\", LS),\n      (\"save-analysis\", \"Write syntax and type analysis information \\\n                         in addition to normal output\", SAVE_ANALYSIS),\n+     (\"print-move-fragments\", \"Print out move-fragment data for every fn\",\n+      PRINT_MOVE_FRAGMENTS),\n      (\"flowgraph-print-loans\", \"Include loan analysis data in \\\n                        --pretty flowgraph output\", FLOWGRAPH_PRINT_LOANS),\n      (\"flowgraph-print-moves\", \"Include move analysis data in \\"}, {"sha": "89f6cda64d9d3f482e7e3370b0e04fdfcb0a8281", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -90,6 +90,12 @@ impl Session {\n     pub fn warn(&self, msg: &str) {\n         self.diagnostic().handler().warn(msg)\n     }\n+    pub fn opt_span_warn(&self, opt_sp: Option<Span>, msg: &str) {\n+        match opt_sp {\n+            Some(sp) => self.span_warn(sp, msg),\n+            None => self.warn(msg),\n+        }\n+    }\n     pub fn span_note(&self, sp: Span, msg: &str) {\n         self.diagnostic().span_note(sp, msg)\n     }\n@@ -108,6 +114,12 @@ impl Session {\n     pub fn help(&self, msg: &str) {\n         self.diagnostic().handler().note(msg)\n     }\n+    pub fn opt_span_bug(&self, opt_sp: Option<Span>, msg: &str) -> ! {\n+        match opt_sp {\n+            Some(sp) => self.span_bug(sp, msg),\n+            None => self.bug(msg),\n+        }\n+    }\n     pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n         self.diagnostic().span_bug(sp, msg)\n     }"}, {"sha": "381220d587cbca9008ac916e8b8d2aad7b99d717", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -1274,6 +1274,7 @@ struct ReassignmentChecker {\n \n impl<'tcx> euv::Delegate<'tcx> for ReassignmentChecker {\n     fn consume(&mut self, _: ast::NodeId, _: Span, _: mc::cmt, _: euv::ConsumeMode) {}\n+    fn matched_pat(&mut self, _: &ast::Pat, _: mc::cmt, _: euv::MatchMode) {}\n     fn consume_pat(&mut self, _: &ast::Pat, _: mc::cmt, _: euv::ConsumeMode) {}\n     fn borrow(&mut self, _: ast::NodeId, _: Span, _: mc::cmt, _: ty::Region,\n               _: ty::BorrowKind, _: euv::LoanCause) {}"}, {"sha": "8a2202d28d5c73f45d861ce62f8ac11b06e2873e", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -551,7 +551,11 @@ impl<'ast> Map<'ast> {\n     }\n \n     pub fn node_to_string(&self, id: NodeId) -> String {\n-        node_id_to_string(self, id)\n+        node_id_to_string(self, id, true)\n+    }\n+\n+    pub fn node_to_user_string(&self, id: NodeId) -> String {\n+        node_id_to_string(self, id, false)\n     }\n }\n \n@@ -1028,7 +1032,10 @@ impl<'a> NodePrinter for pprust::State<'a> {\n     }\n }\n \n-fn node_id_to_string(map: &Map, id: NodeId) -> String {\n+fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n+    let id_str = format!(\" (id={})\", id);\n+    let id_str = if include_id { id_str.as_slice() } else { \"\" };\n+\n     match map.find(id) {\n         Some(NodeItem(item)) => {\n             let path_str = map.path_to_str_with_ident(id, item.ident);\n@@ -1045,82 +1052,82 @@ fn node_id_to_string(map: &Map, id: NodeId) -> String {\n                 ItemImpl(..) => \"impl\",\n                 ItemMac(..) => \"macro\"\n             };\n-            format!(\"{} {} (id={})\", item_str, path_str, id)\n+            format!(\"{} {}{}\", item_str, path_str, id_str)\n         }\n         Some(NodeForeignItem(item)) => {\n             let path_str = map.path_to_str_with_ident(id, item.ident);\n-            format!(\"foreign item {} (id={})\", path_str, id)\n+            format!(\"foreign item {}{}\", path_str, id_str)\n         }\n         Some(NodeImplItem(ref ii)) => {\n             match **ii {\n                 MethodImplItem(ref m) => {\n                     match m.node {\n                         MethDecl(ident, _, _, _, _, _, _, _) =>\n-                            format!(\"method {} in {} (id={})\",\n+                            format!(\"method {} in {}{}\",\n                                     token::get_ident(ident),\n-                                    map.path_to_string(id), id),\n+                                    map.path_to_string(id), id_str),\n                         MethMac(ref mac) =>\n-                            format!(\"method macro {} (id={})\",\n-                                    pprust::mac_to_string(mac), id)\n+                            format!(\"method macro {}{}\",\n+                                    pprust::mac_to_string(mac), id_str)\n                     }\n                 }\n                 TypeImplItem(ref t) => {\n-                    format!(\"typedef {} in {} (id={})\",\n+                    format!(\"typedef {} in {}{}\",\n                             token::get_ident(t.ident),\n                             map.path_to_string(id),\n-                            id)\n+                            id_str)\n                 }\n             }\n         }\n         Some(NodeTraitItem(ref tm)) => {\n             match **tm {\n                 RequiredMethod(_) | ProvidedMethod(_) => {\n                     let m = ast_util::trait_item_to_ty_method(&**tm);\n-                    format!(\"method {} in {} (id={})\",\n+                    format!(\"method {} in {}{}\",\n                             token::get_ident(m.ident),\n                             map.path_to_string(id),\n-                            id)\n+                            id_str)\n                 }\n                 TypeTraitItem(ref t) => {\n-                    format!(\"type item {} in {} (id={})\",\n+                    format!(\"type item {} in {}{}\",\n                             token::get_ident(t.ty_param.ident),\n                             map.path_to_string(id),\n-                            id)\n+                            id_str)\n                 }\n             }\n         }\n         Some(NodeVariant(ref variant)) => {\n-            format!(\"variant {} in {} (id={})\",\n+            format!(\"variant {} in {}{}\",\n                     token::get_ident(variant.node.name),\n-                    map.path_to_string(id), id)\n+                    map.path_to_string(id), id_str)\n         }\n         Some(NodeExpr(ref expr)) => {\n-            format!(\"expr {} (id={})\", pprust::expr_to_string(&**expr), id)\n+            format!(\"expr {}{}\", pprust::expr_to_string(&**expr), id_str)\n         }\n         Some(NodeStmt(ref stmt)) => {\n-            format!(\"stmt {} (id={})\", pprust::stmt_to_string(&**stmt), id)\n+            format!(\"stmt {}{}\", pprust::stmt_to_string(&**stmt), id_str)\n         }\n         Some(NodeArg(ref pat)) => {\n-            format!(\"arg {} (id={})\", pprust::pat_to_string(&**pat), id)\n+            format!(\"arg {}{}\", pprust::pat_to_string(&**pat), id_str)\n         }\n         Some(NodeLocal(ref pat)) => {\n-            format!(\"local {} (id={})\", pprust::pat_to_string(&**pat), id)\n+            format!(\"local {}{}\", pprust::pat_to_string(&**pat), id_str)\n         }\n         Some(NodePat(ref pat)) => {\n-            format!(\"pat {} (id={})\", pprust::pat_to_string(&**pat), id)\n+            format!(\"pat {}{}\", pprust::pat_to_string(&**pat), id_str)\n         }\n         Some(NodeBlock(ref block)) => {\n-            format!(\"block {} (id={})\", pprust::block_to_string(&**block), id)\n+            format!(\"block {}{}\", pprust::block_to_string(&**block), id_str)\n         }\n         Some(NodeStructCtor(_)) => {\n-            format!(\"struct_ctor {} (id={})\", map.path_to_string(id), id)\n+            format!(\"struct_ctor {}{}\", map.path_to_string(id), id_str)\n         }\n         Some(NodeLifetime(ref l)) => {\n-            format!(\"lifetime {} (id={})\",\n-                    pprust::lifetime_to_string(&**l), id)\n+            format!(\"lifetime {}{}\",\n+                    pprust::lifetime_to_string(&**l), id_str)\n         }\n         None => {\n-            format!(\"unknown node (id={})\", id)\n+            format!(\"unknown node{}\", id_str)\n         }\n     }\n }"}, {"sha": "ccf12cf79e1d6d2bc8acabeac6583fe4e166f860", "filename": "src/test/compile-fail/move-fragments-1.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Ftest%2Fcompile-fail%2Fmove-fragments-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Ftest%2Fcompile-fail%2Fmove-fragments-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-1.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(tuple_indexing)]\n+\n+// Test that we correctly compute the move fragments for a fn.\n+//\n+// Note that the code below is not actually incorrect; the\n+// `rustc_move_fragments` attribute is a hack that uses the error\n+// reporting mechanisms as a channel for communicating from the\n+// internals of the compiler.\n+\n+// These are all fairly trivial cases: unused variables or direct\n+// drops of substructure.\n+\n+pub struct D { d: int }\n+impl Drop for D { fn drop(&mut self) { } }\n+\n+#[rustc_move_fragments]\n+pub fn test_noop() {\n+}\n+\n+#[rustc_move_fragments]\n+pub fn test_take(_x: D) {\n+    //~^ ERROR                  assigned_leaf_path: `$(local _x)`\n+}\n+\n+pub struct Pair<X,Y> { x: X, y: Y }\n+\n+#[rustc_move_fragments]\n+pub fn test_take_struct(_p: Pair<D, D>) {\n+    //~^ ERROR                  assigned_leaf_path: `$(local _p)`\n+}\n+\n+#[rustc_move_fragments]\n+pub fn test_drop_struct_part(p: Pair<D, D>) {\n+    //~^ ERROR                 parent_of_fragments: `$(local p)`\n+    //~| ERROR                     moved_leaf_path: `$(local p).x`\n+    //~| ERROR                    unmoved_fragment: `$(local p).y`\n+    drop(p.x);\n+}\n+\n+#[rustc_move_fragments]\n+pub fn test_drop_tuple_part(p: (D, D)) {\n+    //~^ ERROR                 parent_of_fragments: `$(local p)`\n+    //~| ERROR                     moved_leaf_path: `$(local p).#0`\n+    //~| ERROR                    unmoved_fragment: `$(local p).#1`\n+    drop(p.0);\n+}\n+\n+pub fn main() { }"}, {"sha": "ceb1d5a0f091060e13a951519ff12f3fe40af8e7", "filename": "src/test/compile-fail/move-fragments-2.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Ftest%2Fcompile-fail%2Fmove-fragments-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Ftest%2Fcompile-fail%2Fmove-fragments-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-2.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we correctly compute the move fragments for a fn.\n+//\n+// Note that the code below is not actually incorrect; the\n+// `rustc_move_fragments` attribute is a hack that uses the error\n+// reporting mechanisms as a channel for communicating from the\n+// internals of the compiler.\n+\n+// These are checking that enums are tracked; note that their output\n+// paths include \"downcasts\" of the path to a particular enum.\n+\n+use self::Lonely::{Zero, One, Two};\n+\n+pub struct D { d: int }\n+impl Drop for D { fn drop(&mut self) { } }\n+\n+pub enum Lonely<X,Y> { Zero, One(X), Two(X, Y) }\n+\n+#[rustc_move_fragments]\n+pub fn test_match_partial(p: Lonely<D, D>) {\n+    //~^ ERROR                 parent_of_fragments: `$(local p)`\n+    //~| ERROR                  assigned_leaf_path: `($(local p) as Zero)`\n+    match p {\n+        Zero(..) => {}\n+        _ => {}\n+    }\n+}\n+\n+#[rustc_move_fragments]\n+pub fn test_match_full(p: Lonely<D, D>) {\n+    //~^ ERROR                 parent_of_fragments: `$(local p)`\n+    //~| ERROR                  assigned_leaf_path: `($(local p) as Zero)`\n+    //~| ERROR                  assigned_leaf_path: `($(local p) as One)`\n+    //~| ERROR                  assigned_leaf_path: `($(local p) as Two)`\n+    match p {\n+        Zero(..) => {}\n+        One(..) => {}\n+        Two(..) => {}\n+    }\n+}\n+\n+#[rustc_move_fragments]\n+pub fn test_match_bind_one(p: Lonely<D, D>) {\n+    //~^ ERROR                 parent_of_fragments: `$(local p)`\n+    //~| ERROR                  assigned_leaf_path: `($(local p) as Zero)`\n+    //~| ERROR                 parent_of_fragments: `($(local p) as One)`\n+    //~| ERROR                     moved_leaf_path: `($(local p) as One).#0`\n+    //~| ERROR                  assigned_leaf_path: `($(local p) as Two)`\n+    //~| ERROR                  assigned_leaf_path: `$(local data)`\n+    match p {\n+        Zero(..) => {}\n+        One(data) => {}\n+        Two(..) => {}\n+    }\n+}\n+\n+#[rustc_move_fragments]\n+pub fn test_match_bind_many(p: Lonely<D, D>) {\n+    //~^ ERROR                 parent_of_fragments: `$(local p)`\n+    //~| ERROR                  assigned_leaf_path: `($(local p) as Zero)`\n+    //~| ERROR                 parent_of_fragments: `($(local p) as One)`\n+    //~| ERROR                     moved_leaf_path: `($(local p) as One).#0`\n+    //~| ERROR                  assigned_leaf_path: `$(local data)`\n+    //~| ERROR                 parent_of_fragments: `($(local p) as Two)`\n+    //~| ERROR                     moved_leaf_path: `($(local p) as Two).#0`\n+    //~| ERROR                     moved_leaf_path: `($(local p) as Two).#1`\n+    //~| ERROR                  assigned_leaf_path: `$(local left)`\n+    //~| ERROR                  assigned_leaf_path: `$(local right)`\n+    match p {\n+        Zero(..) => {}\n+        One(data) => {}\n+        Two(left, right) => {}\n+    }\n+}\n+\n+pub fn main() { }"}, {"sha": "4540b0c5a91323f35f04de65a33bde8ccc2503e8", "filename": "src/test/compile-fail/move-fragments-3.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Ftest%2Fcompile-fail%2Fmove-fragments-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Ftest%2Fcompile-fail%2Fmove-fragments-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-3.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we correctly compute the move fragments for a fn.\n+//\n+// Note that the code below is not actually incorrect; the\n+// `rustc_move_fragments` attribute is a hack that uses the error\n+// reporting mechanisms as a channel for communicating from the\n+// internals of the compiler.\n+\n+// This checks the handling of `_` within variants, especially when mixed\n+// with bindings.\n+\n+use self::Lonely::{Zero, One, Two};\n+\n+pub struct D { d: int }\n+impl Drop for D { fn drop(&mut self) { } }\n+\n+pub enum Lonely<X,Y> { Zero, One(X), Two(X, Y) }\n+\n+#[rustc_move_fragments]\n+pub fn test_match_bind_and_underscore(p: Lonely<D, D>) {\n+    //~^ ERROR                 parent_of_fragments: `$(local p)`\n+    //~| ERROR                  assigned_leaf_path: `($(local p) as Zero)`\n+    //~| ERROR                  assigned_leaf_path: `($(local p) as One)`\n+    //~| ERROR                 parent_of_fragments: `($(local p) as Two)`\n+    //~| ERROR                     moved_leaf_path: `($(local p) as Two).#0`\n+    //~| ERROR                    unmoved_fragment: `($(local p) as Two).#1`\n+    //~| ERROR                  assigned_leaf_path: `$(local left)`\n+\n+    match p {\n+        Zero(..) => {}\n+\n+        One(_) => {}       // <-- does not fragment `($(local p) as One)` ...\n+\n+        Two(left, _) => {} // <-- ... *does* fragment `($(local p) as Two)`.\n+    }\n+}\n+\n+pub fn main() { }"}, {"sha": "dc43dcb9b0e2313f9b53a75e267501457929a878", "filename": "src/test/compile-fail/move-fragments-4.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Ftest%2Fcompile-fail%2Fmove-fragments-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Ftest%2Fcompile-fail%2Fmove-fragments-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-4.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we correctly compute the move fragments for a fn.\n+//\n+// Note that the code below is not actually incorrect; the\n+// `rustc_move_fragments` attribute is a hack that uses the error\n+// reporting mechanisms as a channel for communicating from the\n+// internals of the compiler.\n+\n+// This checks that a move of deep structure is properly tracked. (An\n+// early draft of the code did not properly traverse up through all of\n+// the parents of the leaf fragment.)\n+\n+pub struct D { d: int }\n+impl Drop for D { fn drop(&mut self) { } }\n+\n+pub struct Pair<X,Y> { x: X, y: Y }\n+\n+#[rustc_move_fragments]\n+pub fn test_move_substructure(pppp: Pair<Pair<Pair<Pair<D,D>, D>, D>, D>) {\n+    //~^ ERROR                 parent_of_fragments: `$(local pppp)`\n+    //~| ERROR                 parent_of_fragments: `$(local pppp).x`\n+    //~| ERROR                 parent_of_fragments: `$(local pppp).x.x`\n+    //~| ERROR                    unmoved_fragment: `$(local pppp).x.x.x`\n+    //~| ERROR                     moved_leaf_path: `$(local pppp).x.x.y`\n+    //~| ERROR                    unmoved_fragment: `$(local pppp).x.y`\n+    //~| ERROR                    unmoved_fragment: `$(local pppp).y`\n+    drop(pppp.x.x.y);\n+}\n+\n+pub fn main() { }"}, {"sha": "df069461ab74f810fbab21d09b2799fb9efe4e8a", "filename": "src/test/compile-fail/move-fragments-5.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Ftest%2Fcompile-fail%2Fmove-fragments-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Ftest%2Fcompile-fail%2Fmove-fragments-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-5.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we correctly compute the move fragments for a fn.\n+//\n+// Note that the code below is not actually incorrect; the\n+// `rustc_move_fragments` attribute is a hack that uses the error\n+// reporting mechanisms as a channel for communicating from the\n+// internals of the compiler.\n+\n+// This is the first test that checks moving into local variables.\n+\n+pub struct D { d: int }\n+impl Drop for D { fn drop(&mut self) { } }\n+\n+pub struct Pair<X,Y> { x: X, y: Y }\n+\n+#[rustc_move_fragments]\n+pub fn test_move_field_to_local(p: Pair<D, D>) {\n+    //~^ ERROR                 parent_of_fragments: `$(local p)`\n+    //~| ERROR                     moved_leaf_path: `$(local p).x`\n+    //~| ERROR                    unmoved_fragment: `$(local p).y`\n+    //~| ERROR                  assigned_leaf_path: `$(local _x)`\n+    let _x = p.x;\n+}\n+\n+#[rustc_move_fragments]\n+pub fn test_move_field_to_local_to_local(p: Pair<D, D>) {\n+    //~^ ERROR                 parent_of_fragments: `$(local p)`\n+    //~| ERROR                     moved_leaf_path: `$(local p).x`\n+    //~| ERROR                    unmoved_fragment: `$(local p).y`\n+    //~| ERROR                  assigned_leaf_path: `$(local _x)`\n+    //~| ERROR                     moved_leaf_path: `$(local _x)`\n+    //~| ERROR                  assigned_leaf_path: `$(local _y)`\n+    let _x = p.x;\n+    let _y = _x;\n+}\n+\n+// In the following fn's `test_move_field_to_local_delayed` and\n+// `test_uninitialized_local` , the instrumentation reports that `_x`\n+// is moved. This is unlike `test_move_field_to_local`, where `_x` is\n+// just reported as an assigned_leaf_path. Presumably because this is\n+// how we represent that it did not have an initalizing expression at\n+// the binding site.\n+\n+#[rustc_move_fragments]\n+pub fn test_uninitialized_local(_p: Pair<D, D>) {\n+    //~^ ERROR                  assigned_leaf_path: `$(local _p)`\n+    //~| ERROR                     moved_leaf_path: `$(local _x)`\n+    let _x: D;\n+}\n+\n+#[rustc_move_fragments]\n+pub fn test_move_field_to_local_delayed(p: Pair<D, D>) {\n+    //~^ ERROR                 parent_of_fragments: `$(local p)`\n+    //~| ERROR                     moved_leaf_path: `$(local p).x`\n+    //~| ERROR                    unmoved_fragment: `$(local p).y`\n+    //~| ERROR                  assigned_leaf_path: `$(local _x)`\n+    //~| ERROR                     moved_leaf_path: `$(local _x)`\n+    let _x;\n+    _x = p.x;\n+}\n+\n+#[rustc_move_fragments]\n+pub fn test_move_field_mut_to_local(mut p: Pair<D, D>) {\n+    //~^ ERROR                 parent_of_fragments: `$(local mut p)`\n+    //~| ERROR                     moved_leaf_path: `$(local mut p).x`\n+    //~| ERROR                    unmoved_fragment: `$(local mut p).y`\n+    //~| ERROR                  assigned_leaf_path: `$(local _x)`\n+    let _x = p.x;\n+}\n+\n+#[rustc_move_fragments]\n+pub fn test_move_field_to_local_to_local_mut(p: Pair<D, D>) {\n+    //~^ ERROR                 parent_of_fragments: `$(local p)`\n+    //~| ERROR                     moved_leaf_path: `$(local p).x`\n+    //~| ERROR                    unmoved_fragment: `$(local p).y`\n+    //~| ERROR                  assigned_leaf_path: `$(local mut _x)`\n+    //~| ERROR                     moved_leaf_path: `$(local mut _x)`\n+    //~| ERROR                  assigned_leaf_path: `$(local _y)`\n+    let mut _x = p.x;\n+    let _y = _x;\n+}\n+\n+pub fn main() {}"}, {"sha": "b249d0d739789921f80a7c4e153e8835234a1768", "filename": "src/test/compile-fail/move-fragments-6.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Ftest%2Fcompile-fail%2Fmove-fragments-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Ftest%2Fcompile-fail%2Fmove-fragments-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-6.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we correctly compute the move fragments for a fn.\n+//\n+// Note that the code below is not actually incorrect; the\n+// `rustc_move_fragments` attribute is a hack that uses the error\n+// reporting mechanisms as a channel for communicating from the\n+// internals of the compiler.\n+\n+// Test that moving into a field (i.e. overwriting it) fragments the\n+// receiver.\n+\n+use std::mem::drop;\n+\n+pub struct Pair<X,Y> { x: X, y: Y }\n+\n+#[rustc_move_fragments]\n+pub fn test_overwrite_uninit_field<Z>(z: Z) {\n+    //~^ ERROR                 parent_of_fragments: `$(local mut p)`\n+    //~| ERROR                  assigned_leaf_path: `$(local z)`\n+    //~| ERROR                     moved_leaf_path: `$(local z)`\n+    //~| ERROR                  assigned_leaf_path: `$(local mut p).x`\n+    //~| ERROR                    unmoved_fragment: `$(local mut p).y`\n+\n+    let mut p: Pair<Z,Z>;\n+    p.x = z;\n+}\n+\n+#[rustc_move_fragments]\n+pub fn test_overwrite_moved_field<Z>(mut p: Pair<Z,Z>, z: Z) {\n+    //~^ ERROR                 parent_of_fragments: `$(local mut p)`\n+    //~| ERROR                  assigned_leaf_path: `$(local z)`\n+    //~| ERROR                     moved_leaf_path: `$(local z)`\n+    //~| ERROR                  assigned_leaf_path: `$(local mut p).y`\n+    //~| ERROR                    unmoved_fragment: `$(local mut p).x`\n+\n+    drop(p);\n+    p.y = z;\n+}\n+\n+#[rustc_move_fragments]\n+pub fn test_overwrite_same_field<Z>(mut p: Pair<Z,Z>) {\n+    //~^ ERROR                 parent_of_fragments: `$(local mut p)`\n+    //~| ERROR                     moved_leaf_path: `$(local mut p).x`\n+    //~| ERROR                  assigned_leaf_path: `$(local mut p).x`\n+    //~| ERROR                    unmoved_fragment: `$(local mut p).y`\n+\n+    p.x = p.x;\n+}\n+\n+pub fn main() { }"}, {"sha": "6b2c77bcac15ed42c059652b65aa09f57da7857e", "filename": "src/test/compile-fail/move-fragments-7.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Ftest%2Fcompile-fail%2Fmove-fragments-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Ftest%2Fcompile-fail%2Fmove-fragments-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-7.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we correctly compute the move fragments for a fn.\n+//\n+// Note that the code below is not actually incorrect; the\n+// `rustc_move_fragments` attribute is a hack that uses the error\n+// reporting mechanisms as a channel for communicating from the\n+// internals of the compiler.\n+\n+// Test that moving a Box<T> fragments its containing structure, for\n+// both moving out of the structure (i.e. reading `*p.x`) and writing\n+// into the container (i.e. writing `*p.x`).\n+\n+pub struct D { d: int }\n+impl Drop for D { fn drop(&mut self) { } }\n+\n+pub struct Pair<X,Y> { x: X, y: Y }\n+\n+#[rustc_move_fragments]\n+pub fn test_deref_box_field(p: Pair<Box<D>, Box<D>>) {\n+    //~^ ERROR                 parent_of_fragments: `$(local p)`\n+    //~| ERROR                 parent_of_fragments: `$(local p).x`\n+    //~| ERROR                     moved_leaf_path: `$(local p).x.*`\n+    //~| ERROR                    unmoved_fragment: `$(local p).y`\n+    //~| ERROR                  assigned_leaf_path: `$(local i)`\n+    let i : D = *p.x;\n+}\n+\n+#[rustc_move_fragments]\n+pub fn test_overwrite_deref_box_field(mut p: Pair<Box<D>, Box<D>>) {\n+    //~^ ERROR                 parent_of_fragments: `$(local mut p)`\n+    //~| ERROR                 parent_of_fragments: `$(local mut p).x`\n+    //~| ERROR                  assigned_leaf_path: `$(local mut p).x.*`\n+    //~| ERROR                    unmoved_fragment: `$(local mut p).y`\n+    *p.x = D { d: 3 };\n+}\n+\n+pub fn main() { }"}, {"sha": "40ab541128c3fe8f31f1342dd454848d13b25bd1", "filename": "src/test/compile-fail/move-fragments-8.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Ftest%2Fcompile-fail%2Fmove-fragments-8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Ftest%2Fcompile-fail%2Fmove-fragments-8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-8.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we correctly compute the move fragments for a fn.\n+//\n+// Note that the code below is not actually incorrect; the\n+// `rustc_move_fragments` attribute is a hack that uses the error\n+// reporting mechanisms as a channel for communicating from the\n+// internals of the compiler.\n+\n+// Test that assigning into a `&T` within structured container does\n+// *not* fragment its containing structure.\n+//\n+// Compare against the `Box<T>` handling in move-fragments-7.rs. Note\n+// also that in this case we cannot do a move out of `&T`, so we only\n+// test writing `*p.x` here.\n+\n+pub struct D { d: int }\n+impl Drop for D { fn drop(&mut self) { } }\n+\n+pub struct Pair<X,Y> { x: X, y: Y }\n+\n+#[rustc_move_fragments]\n+pub fn test_overwrite_deref_ampersand_field<'a>(p: Pair<&'a mut D, &'a D>) {\n+    //~^ ERROR                 parent_of_fragments: `$(local p)`\n+    //~| ERROR                 parent_of_fragments: `$(local p).x`\n+    //~| ERROR                  assigned_leaf_path: `$(local p).x.*`\n+    //~| ERROR                    unmoved_fragment: `$(local p).y`\n+    *p.x = D { d: 3 };\n+}\n+\n+pub fn main() { }"}, {"sha": "ce05087f6597948ba9669df7a48263905f62acdc", "filename": "src/test/compile-fail/move-fragments-9.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/0e06f71747749e33ca590c334658bddde97a7e54/src%2Ftest%2Fcompile-fail%2Fmove-fragments-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e06f71747749e33ca590c334658bddde97a7e54/src%2Ftest%2Fcompile-fail%2Fmove-fragments-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-9.rs?ref=0e06f71747749e33ca590c334658bddde97a7e54", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test moving array structures, e.g. `[T, ..3]` as well as moving\n+// elements in and out of such arrays.\n+//\n+// Note also that the `test_move_array_then_overwrite` tests represent\n+// cases that we probably should make illegal.\n+\n+pub struct D { d: int }\n+impl Drop for D { fn drop(&mut self) { } }\n+\n+#[rustc_move_fragments]\n+pub fn test_move_array_via_return(a: [D, ..3]) -> [D, ..3] {\n+    //~^ ERROR                  assigned_leaf_path: `$(local a)`\n+    //~| ERROR                     moved_leaf_path: `$(local a)`\n+    return a;\n+}\n+\n+#[rustc_move_fragments]\n+pub fn test_move_array_into_recv(a: [D, ..3], recv: &mut [D, ..3]) {\n+    //~^ ERROR                 parent_of_fragments: `$(local recv)`\n+    //~| ERROR                  assigned_leaf_path: `$(local a)`\n+    //~| ERROR                     moved_leaf_path: `$(local a)`\n+    //~| ERROR                  assigned_leaf_path: `$(local recv).*`\n+    *recv = a;\n+}\n+\n+#[rustc_move_fragments]\n+pub fn test_extract_array_elem(a: [D, ..3], i: uint) -> D {\n+    //~^ ERROR                 parent_of_fragments: `$(local a)`\n+    //~| ERROR                  assigned_leaf_path: `$(local i)`\n+    //~| ERROR                     moved_leaf_path: `$(local a).[]`\n+    //~| ERROR                    unmoved_fragment: `$(allbutone $(local a).[])`\n+    a[i]\n+}\n+\n+#[rustc_move_fragments]\n+pub fn test_overwrite_array_elem(mut a: [D, ..3], i: uint, d: D) {\n+    //~^ ERROR                 parent_of_fragments: `$(local mut a)`\n+    //~| ERROR                  assigned_leaf_path: `$(local i)`\n+    //~| ERROR                  assigned_leaf_path: `$(local d)`\n+    //~| ERROR                     moved_leaf_path: `$(local d)`\n+    //~| ERROR                  assigned_leaf_path: `$(local mut a).[]`\n+    //~| ERROR                    unmoved_fragment: `$(allbutone $(local mut a).[])`\n+    a[i] = d;\n+}\n+\n+// FIXME (pnkfelix): Both test_move_array_then_overwrite_elem1 and\n+// test_move_array_then_overwrite_elem2 illustrate a behavior that\n+// we need to make illegal if we want to get rid of drop-flags.\n+// See RFC PR 320 for more discussion.\n+\n+#[rustc_move_fragments]\n+pub fn test_move_array_then_overwrite_elem1(mut a: [D, ..3], i: uint, recv: &mut [D, ..3], d: D) {\n+    //~^ ERROR                 parent_of_fragments: `$(local mut a)`\n+    //~| ERROR                 parent_of_fragments: `$(local recv)`\n+    //~| ERROR                  assigned_leaf_path: `$(local recv).*`\n+    //~| ERROR                  assigned_leaf_path: `$(local i)`\n+    //~| ERROR                  assigned_leaf_path: `$(local d)`\n+    //~| ERROR                     moved_leaf_path: `$(local d)`\n+    //~| ERROR                  assigned_leaf_path: `$(local mut a).[]`\n+    //~| ERROR                    unmoved_fragment: `$(allbutone $(local mut a).[])`\n+\n+    // This test covers the case where the array contents have been all moved away, but\n+    // we still need to deal with new initializing writes into the array.\n+    *recv = a;\n+    a[i] = d;\n+}\n+\n+#[rustc_move_fragments]\n+pub fn test_move_array_then_overwrite_elem2(mut a: [D, ..3], i: uint, j: uint,\n+                                            recv: &mut [D, ..3], d1: D, d2: D) {\n+    //~^^ ERROR                parent_of_fragments: `$(local mut a)`\n+    //~| ERROR                 parent_of_fragments: `$(local recv)`\n+    //~| ERROR                  assigned_leaf_path: `$(local recv).*`\n+    //~| ERROR                  assigned_leaf_path: `$(local i)`\n+    //~| ERROR                  assigned_leaf_path: `$(local j)`\n+    //~| ERROR                  assigned_leaf_path: `$(local d1)`\n+    //~| ERROR                  assigned_leaf_path: `$(local d2)`\n+    //~| ERROR                     moved_leaf_path: `$(local d1)`\n+    //~| ERROR                     moved_leaf_path: `$(local d2)`\n+    //~| ERROR                  assigned_leaf_path: `$(local mut a).[]`\n+    //~| ERROR                    unmoved_fragment: `$(allbutone $(local mut a).[])`\n+\n+    // This test covers the case where the array contents have been all moved away, but\n+    // we still need to deal with new initializing writes into the array.\n+    *recv = a;\n+    a[i] = d1;\n+    a[j] = d2;\n+}\n+\n+pub fn main() { }"}]}