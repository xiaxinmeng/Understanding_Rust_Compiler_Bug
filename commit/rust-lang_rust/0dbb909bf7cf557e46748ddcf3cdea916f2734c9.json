{"sha": "0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkYmI5MDliZjdjZjU1N2U0Njc0OGRkY2YzY2RlYTkxNmYyNzM0Yzk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-21T02:49:20Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-22T15:48:20Z"}, "message": "rustc: Fix fallout of removing get()", "tree": {"sha": "b2ecbf02798d9046a791d696208d59efca52705a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2ecbf02798d9046a791d696208d59efca52705a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "html_url": "https://github.com/rust-lang/rust/commit/0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a37416dbed5583c67bf4566a4e2395c29de7ce8", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a37416dbed5583c67bf4566a4e2395c29de7ce8", "html_url": "https://github.com/rust-lang/rust/commit/9a37416dbed5583c67bf4566a4e2395c29de7ce8"}], "stats": {"total": 3655, "additions": 1343, "deletions": 2312}, "files": [{"sha": "33b79b213d23052b16027f6f74c39f44503fd665", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -206,12 +206,8 @@ impl<'a> Archive<'a> {\n \n         let mut rustpath = filesearch::rust_path();\n         rustpath.push(self.sess.filesearch().get_target_lib_path());\n-        let addl_lib_search_paths = self.sess\n-                                        .opts\n-                                        .addl_lib_search_paths\n-                                        .borrow();\n-        let path = addl_lib_search_paths.get().iter();\n-        for path in path.chain(rustpath.iter()) {\n+        let search = self.sess.opts.addl_lib_search_paths.borrow();\n+        for path in search.iter().chain(rustpath.iter()) {\n             debug!(\"looking for {} inside {}\", name, path.display());\n             let test = path.join(oslibname.as_slice());\n             if test.exists() { return test }"}, {"sha": "201f7557398a4090f26fd80e78147f35c3d97bea", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -209,9 +209,8 @@ pub mod write {\n             // Emit the bytecode if we're either saving our temporaries or\n             // emitting an rlib. Whenever an rlib is created, the bytecode is\n             // inserted into the archive in order to allow LTO against it.\n-            let crate_types = sess.crate_types.borrow();\n             if sess.opts.cg.save_temps ||\n-               (crate_types.get().contains(&session::CrateTypeRlib) &&\n+               (sess.crate_types.borrow().contains(&session::CrateTypeRlib) &&\n                 sess.opts.output_types.contains(&OutputTypeExe)) {\n                 output.temp_path(OutputTypeBitcode).with_c_str(|buf| {\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf);\n@@ -550,15 +549,14 @@ fn symbol_hash(tcx: &ty::ctxt, symbol_hasher: &mut Sha256,\n }\n \n fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> ~str {\n-    match ccx.type_hashcodes.borrow().get().find(&t) {\n+    match ccx.type_hashcodes.borrow().find(&t) {\n         Some(h) => return h.to_str(),\n         None => {}\n     }\n \n-    let mut type_hashcodes = ccx.type_hashcodes.borrow_mut();\n     let mut symbol_hasher = ccx.symbol_hasher.borrow_mut();\n-    let hash = symbol_hash(ccx.tcx(), symbol_hasher.get(), t, &ccx.link_meta);\n-    type_hashcodes.get().insert(t, hash.clone());\n+    let hash = symbol_hash(ccx.tcx(), &mut *symbol_hasher, t, &ccx.link_meta);\n+    ccx.type_hashcodes.borrow_mut().insert(t, hash.clone());\n     hash\n }\n \n@@ -779,8 +777,7 @@ pub fn link_binary(sess: &Session,\n                    outputs: &OutputFilenames,\n                    id: &CrateId) -> Vec<Path> {\n     let mut out_filenames = Vec::new();\n-    let crate_types = sess.crate_types.borrow();\n-    for &crate_type in crate_types.get().iter() {\n+    for &crate_type in sess.crate_types.borrow().iter() {\n         let out_file = link_binary_output(sess, trans, crate_type, outputs, id);\n         out_filenames.push(out_file);\n     }\n@@ -887,9 +884,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                  out_filename: &Path) -> Archive<'a> {\n     let mut a = Archive::create(sess, out_filename, obj_filename);\n \n-    let used_libraries = sess.cstore.get_used_libraries();\n-    let used_libraries = used_libraries.borrow();\n-    for &(ref l, kind) in used_libraries.get().iter() {\n+    for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n         match kind {\n             cstore::NativeStatic => {\n                 a.add_native_library(l.as_slice()).unwrap();\n@@ -1227,9 +1222,7 @@ fn link_args(sess: &Session,\n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n     args.push_all(sess.opts.cg.link_args.as_slice());\n-    let used_link_args = sess.cstore.get_used_link_args();\n-    let used_link_args = used_link_args.borrow();\n-    for arg in used_link_args.get().iter() {\n+    for arg in sess.cstore.get_used_link_args().borrow().iter() {\n         args.push(arg.clone());\n     }\n     return args;\n@@ -1247,8 +1240,7 @@ fn link_args(sess: &Session,\n // in the current crate. Upstream crates with native library dependencies\n // may have their native library pulled in above.\n fn add_local_native_libraries(args: &mut Vec<~str>, sess: &Session) {\n-    let addl_lib_search_paths = sess.opts.addl_lib_search_paths.borrow();\n-    for path in addl_lib_search_paths.get().iter() {\n+    for path in sess.opts.addl_lib_search_paths.borrow().iter() {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         args.push(\"-L\" + path.as_str().unwrap().to_owned());\n     }\n@@ -1259,9 +1251,7 @@ fn add_local_native_libraries(args: &mut Vec<~str>, sess: &Session) {\n         args.push(\"-L\" + path.as_str().unwrap().to_owned());\n     }\n \n-    let used_libraries = sess.cstore.get_used_libraries();\n-    let used_libraries = used_libraries.borrow();\n-    for &(ref l, kind) in used_libraries.get().iter() {\n+    for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n         match kind {\n             cstore::NativeUnknown | cstore::NativeStatic => {\n                 args.push(\"-l\" + *l);"}, {"sha": "1183c78b2a878ea944df36832f919fe6ade320b9", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -27,8 +27,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     }\n \n     // Make sure we actually can run LTO\n-    let crate_types = sess.crate_types.borrow();\n-    for crate_type in crate_types.get().iter() {\n+    for crate_type in sess.crate_types.borrow().iter() {\n         match *crate_type {\n             session::CrateTypeExecutable | session::CrateTypeStaticlib => {}\n             _ => {"}, {"sha": "513aa51bfe12564ff91ab43f40deddc13a61cb3a", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -512,8 +512,7 @@ fn write_out_deps(sess: &Session,\n         let file = outputs.path(*output_type);\n         match *output_type {\n             link::OutputTypeExe => {\n-                let crate_types = sess.crate_types.borrow();\n-                for output in crate_types.get().iter() {\n+                for output in sess.crate_types.borrow().iter() {\n                     let p = link::filename_for_input(sess, *output, &id, &file);\n                     out_filenames.push(p);\n                 }\n@@ -542,7 +541,7 @@ fn write_out_deps(sess: &Session,\n \n     // Build a list of files used to compile the output and\n     // write Makefile-compatible dependency rules\n-    let files: Vec<~str> = sess.codemap().files.borrow().get()\n+    let files: Vec<~str> = sess.codemap().files.borrow()\n                                .iter().filter_map(|fmap| {\n                                     if fmap.deref().is_real_file() {\n                                         Some(fmap.deref().name.clone())"}, {"sha": "772d92a4f85bad7f60be0c5a2783399432da543a", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -253,11 +253,11 @@ impl Session {\n                     sp: Span,\n                     msg: ~str) {\n         let mut lints = self.lints.borrow_mut();\n-        match lints.get().find_mut(&id) {\n+        match lints.find_mut(&id) {\n             Some(arr) => { arr.push((lint, sp, msg)); return; }\n             None => {}\n         }\n-        lints.get().insert(id, vec!((lint, sp, msg)));\n+        lints.insert(id, vec!((lint, sp, msg)));\n     }\n     pub fn next_node_id(&self) -> ast::NodeId {\n         self.reserve_node_ids(1)"}, {"sha": "cb6b5eefadeb520276cd2bb856a8532edd668613", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -88,10 +88,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n     }\n \n     fn fold_item(&mut self, i: @ast::Item) -> SmallVector<@ast::Item> {\n-        {\n-            let mut path = self.cx.path.borrow_mut();\n-            path.get().push(i.ident);\n-        }\n+        self.cx.path.borrow_mut().push(i.ident);\n         debug!(\"current path: {}\",\n                ast_util::path_name_i(self.cx.path.get().as_slice()));\n \n@@ -112,21 +109,15 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n                         ignore: is_ignored(&self.cx, i),\n                         should_fail: should_fail(i)\n                     };\n-                    {\n-                        let mut testfns = self.cx.testfns.borrow_mut();\n-                        testfns.get().push(test);\n-                    }\n+                    self.cx.testfns.borrow_mut().push(test);\n                     // debug!(\"have {} test/bench functions\",\n                     //        cx.testfns.len());\n                 }\n             }\n         }\n \n         let res = fold::noop_fold_item(i, self);\n-        {\n-            let mut path = self.cx.path.borrow_mut();\n-            path.get().pop();\n-        }\n+        self.cx.path.borrow_mut().pop();\n         res\n     }\n \n@@ -414,12 +405,9 @@ fn is_test_crate(krate: &ast::Crate) -> bool {\n \n fn mk_test_descs(cx: &TestCtxt) -> @ast::Expr {\n     let mut descs = Vec::new();\n-    {\n-        let testfns = cx.testfns.borrow();\n-        debug!(\"building test vector from {} tests\", testfns.get().len());\n-        for test in testfns.get().iter() {\n-            descs.push(mk_test_desc_and_fn_rec(cx, test));\n-        }\n+    debug!(\"building test vector from {} tests\", cx.testfns.borrow().len());\n+    for test in cx.testfns.borrow().iter() {\n+        descs.push(mk_test_desc_and_fn_rec(cx, test));\n     }\n \n     let inner_expr = @ast::Expr {"}, {"sha": "36ebb3d513944ed399b04339cd6456a5af435744", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -1831,13 +1831,11 @@ impl TypeNames {\n     }\n \n     pub fn associate_type(&self, s: &str, t: &Type) {\n-        let mut named_types = self.named_types.borrow_mut();\n-        assert!(named_types.get().insert(s.to_owned(), t.to_ref()));\n+        assert!(self.named_types.borrow_mut().insert(s.to_owned(), t.to_ref()));\n     }\n \n     pub fn find_type(&self, s: &str) -> Option<Type> {\n-        let named_types = self.named_types.borrow();\n-        named_types.get().find_equiv(&s).map(|x| Type::from_ref(*x))\n+        self.named_types.borrow().find_equiv(&s).map(|x| Type::from_ref(*x))\n     }\n \n     pub fn type_to_str(&self, ty: Type) -> ~str {"}, {"sha": "7384d558eb6141495c7500eb0e4f6fb6a8fac1e3", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -51,11 +51,10 @@ pub fn read_crates(sess: &Session,\n     };\n     visit_crate(&e, krate);\n     visit::walk_crate(&mut e, krate, ());\n-    let crate_cache = e.crate_cache.borrow();\n-    dump_crates(crate_cache.get().as_slice());\n+    dump_crates(e.crate_cache.borrow().as_slice());\n     warn_if_multiple_versions(&mut e,\n                               sess.diagnostic(),\n-                              crate_cache.get().as_slice());\n+                              e.crate_cache.borrow().as_slice());\n }\n \n impl<'a> visit::Visitor<()> for Env<'a> {\n@@ -268,8 +267,7 @@ fn visit_item(e: &Env, i: &ast::Item) {\n \n fn existing_match(e: &Env, crate_id: &CrateId,\n                   hash: Option<&Svh>) -> Option<ast::CrateNum> {\n-    let crate_cache = e.crate_cache.borrow();\n-    for c in crate_cache.get().iter() {\n+    for c in e.crate_cache.borrow().iter() {\n         if !crate_id.matches(&c.crate_id) { continue }\n         match hash {\n             Some(hash) if *hash != c.hash => {}\n@@ -309,15 +307,12 @@ fn resolve_crate(e: &mut Env,\n \n             // Claim this crate number and cache it\n             let cnum = e.next_crate_num;\n-            {\n-                let mut crate_cache = e.crate_cache.borrow_mut();\n-                crate_cache.get().push(cache_entry {\n-                    cnum: cnum,\n-                    span: span,\n-                    hash: hash,\n-                    crate_id: crate_id,\n-                });\n-            }\n+            e.crate_cache.borrow_mut().push(cache_entry {\n+                cnum: cnum,\n+                span: span,\n+                hash: hash,\n+                crate_id: crate_id,\n+            });\n             e.next_crate_num += 1;\n \n             // Maintain a reference to the top most crate."}, {"sha": "02c092ca50832392e91e37ced09b46f77f0b52cc", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -89,8 +89,7 @@ impl CStore {\n     }\n \n     pub fn get_crate_data(&self, cnum: ast::CrateNum) -> @crate_metadata {\n-        let metas = self.metas.borrow();\n-        *metas.get().get(&cnum)\n+        *self.metas.borrow().get(&cnum)\n     }\n \n     pub fn get_crate_hash(&self, cnum: ast::CrateNum) -> Svh {\n@@ -104,33 +103,30 @@ impl CStore {\n     }\n \n     pub fn set_crate_data(&self, cnum: ast::CrateNum, data: @crate_metadata) {\n-        let mut metas = self.metas.borrow_mut();\n-        metas.get().insert(cnum, data);\n+        self.metas.borrow_mut().insert(cnum, data);\n     }\n \n     pub fn have_crate_data(&self, cnum: ast::CrateNum) -> bool {\n-        let metas = self.metas.borrow();\n-        metas.get().contains_key(&cnum)\n+        self.metas.borrow().contains_key(&cnum)\n     }\n \n     pub fn iter_crate_data(&self, i: |ast::CrateNum, @crate_metadata|) {\n-        let metas = self.metas.borrow();\n-        for (&k, &v) in metas.get().iter() {\n+        for (&k, &v) in self.metas.borrow().iter() {\n             i(k, v);\n         }\n     }\n \n     pub fn add_used_crate_source(&self, src: CrateSource) {\n         let mut used_crate_sources = self.used_crate_sources.borrow_mut();\n-        if !used_crate_sources.get().contains(&src) {\n-            used_crate_sources.get().push(src);\n+        if !used_crate_sources.contains(&src) {\n+            used_crate_sources.push(src);\n         }\n     }\n \n     pub fn get_used_crate_source(&self, cnum: ast::CrateNum)\n                                      -> Option<CrateSource> {\n-        let mut used_crate_sources = self.used_crate_sources.borrow_mut();\n-        used_crate_sources.get().iter().find(|source| source.cnum == cnum)\n+        self.used_crate_sources.borrow_mut()\n+            .iter().find(|source| source.cnum == cnum)\n             .map(|source| source.clone())\n     }\n \n@@ -158,18 +154,17 @@ impl CStore {\n                  ordering: &mut Vec<ast::CrateNum>) {\n             if ordering.as_slice().contains(&cnum) { return }\n             let meta = cstore.get_crate_data(cnum);\n-            for (_, &dep) in meta.cnum_map.borrow().get().iter() {\n+            for (_, &dep) in meta.cnum_map.borrow().iter() {\n                 visit(cstore, dep, ordering);\n             }\n             ordering.push(cnum);\n         };\n-        for (&num, _) in self.metas.borrow().get().iter() {\n+        for (&num, _) in self.metas.borrow().iter() {\n             visit(self, num, &mut ordering);\n         }\n         ordering.as_mut_slice().reverse();\n         let ordering = ordering.as_slice();\n-        let used_crate_sources = self.used_crate_sources.borrow();\n-        let mut libs = used_crate_sources.get()\n+        let mut libs = self.used_crate_sources.borrow()\n             .iter()\n             .map(|src| (src.cnum, match prefer {\n                 RequireDynamic => src.dylib.clone(),\n@@ -184,8 +179,7 @@ impl CStore {\n \n     pub fn add_used_library(&self, lib: ~str, kind: NativeLibaryKind) {\n         assert!(!lib.is_empty());\n-        let mut used_libraries = self.used_libraries.borrow_mut();\n-        used_libraries.get().push((lib, kind));\n+        self.used_libraries.borrow_mut().push((lib, kind));\n     }\n \n     pub fn get_used_libraries<'a>(&'a self)\n@@ -194,9 +188,8 @@ impl CStore {\n     }\n \n     pub fn add_used_link_args(&self, args: &str) {\n-        let mut used_link_args = self.used_link_args.borrow_mut();\n         for s in args.split(' ') {\n-            used_link_args.get().push(s.to_owned());\n+            self.used_link_args.borrow_mut().push(s.to_owned());\n         }\n     }\n \n@@ -207,14 +200,12 @@ impl CStore {\n     pub fn add_extern_mod_stmt_cnum(&self,\n                                     emod_id: ast::NodeId,\n                                     cnum: ast::CrateNum) {\n-        let mut extern_mod_crate_map = self.extern_mod_crate_map.borrow_mut();\n-        extern_mod_crate_map.get().insert(emod_id, cnum);\n+        self.extern_mod_crate_map.borrow_mut().insert(emod_id, cnum);\n     }\n \n     pub fn find_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId)\n                                      -> Option<ast::CrateNum> {\n-        let extern_mod_crate_map = self.extern_mod_crate_map.borrow();\n-        extern_mod_crate_map.get().find(&emod_id).map(|x| *x)\n+        self.extern_mod_crate_map.borrow().find(&emod_id).map(|x| *x)\n     }\n }\n "}, {"sha": "3387c47842ae4f6f7fc8eda24e8dae8e4b1e03a4", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -1187,8 +1187,7 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n         return ast::DefId { krate: cdata.cnum, node: did.node };\n     }\n \n-    let cnum_map = cdata.cnum_map.borrow();\n-    match cnum_map.get().find(&did.krate) {\n+    match cdata.cnum_map.borrow().find(&did.krate) {\n         Some(&n) => {\n             ast::DefId {\n                 krate: n,"}, {"sha": "d97e9f2b3e14a6cfa128b9f609211815ba4f306c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 46, "deletions": 82, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -270,8 +270,7 @@ fn encode_symbol(ecx: &EncodeContext,\n                  ebml_w: &mut writer::Encoder,\n                  id: NodeId) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n-    let item_symbols = ecx.item_symbols.borrow();\n-    match item_symbols.get().find(&id) {\n+    match ecx.item_symbols.borrow().find(&id) {\n         Some(x) => {\n             debug!(\"encode_symbol(id={:?}, str={})\", id, *x);\n             ebml_w.writer.write(x.as_bytes());\n@@ -334,13 +333,10 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                                ast::DefId { krate: LOCAL_CRATE, node: id });\n     for variant in variants.iter() {\n         let def_id = local_def(variant.node.id);\n-        {\n-            let mut index = index.borrow_mut();\n-            index.get().push(entry {\n-                val: variant.node.id as i64,\n-                pos: ebml_w.writer.tell().unwrap(),\n-            });\n-        }\n+        index.borrow_mut().push(entry {\n+            val: variant.node.id as i64,\n+            pos: ebml_w.writer.tell().unwrap(),\n+        });\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         match variant.node.kind {\n@@ -415,11 +411,9 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                                          ebml_w: &mut writer::Encoder,\n                                          exp: &middle::resolve::Export2)\n                                          -> bool {\n-    let inherent_impls = ecx.tcx.inherent_impls.borrow();\n-    match inherent_impls.get().find(&exp.def_id) {\n+    match ecx.tcx.inherent_impls.borrow().find(&exp.def_id) {\n         Some(implementations) => {\n-            let implementations = implementations.borrow();\n-            for &base_impl in implementations.get().iter() {\n+            for &base_impl in implementations.borrow().iter() {\n                 for &m in base_impl.methods.iter() {\n                     if m.explicit_self == ast::SelfStatic {\n                         encode_reexported_static_method(ebml_w, exp, m.def_id, m.ident);\n@@ -437,8 +431,7 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n                                           ebml_w: &mut writer::Encoder,\n                                           exp: &middle::resolve::Export2)\n                                           -> bool {\n-    let trait_methods_cache = ecx.tcx.trait_methods_cache.borrow();\n-    match trait_methods_cache.get().find(&exp.def_id) {\n+    match ecx.tcx.trait_methods_cache.borrow().find(&exp.def_id) {\n         Some(methods) => {\n             for &m in methods.iter() {\n                 if m.explicit_self == ast::SelfStatic {\n@@ -538,8 +531,7 @@ fn encode_reexports(ecx: &EncodeContext,\n                     id: NodeId,\n                     path: PathElems) {\n     debug!(\"(encoding info for module) encoding reexports for {}\", id);\n-    let reexports2 = ecx.reexports2.borrow();\n-    match reexports2.get().find(&id) {\n+    match ecx.reexports2.borrow().find(&id) {\n         Some(ref exports) => {\n             debug!(\"(encoding info for module) found reexports for {}\", id);\n             for exp in exports.iter() {\n@@ -703,13 +695,10 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n \n         let id = field.node.id;\n         index.push(entry {val: id as i64, pos: ebml_w.writer.tell().unwrap()});\n-        {\n-            let mut global_index = global_index.borrow_mut();\n-            global_index.get().push(entry {\n-                val: id as i64,\n-                pos: ebml_w.writer.tell().unwrap(),\n-            });\n-        }\n+        global_index.borrow_mut().push(entry {\n+            val: id as i64,\n+            pos: ebml_w.writer.tell().unwrap(),\n+        });\n         ebml_w.start_tag(tag_items_data_item);\n         debug!(\"encode_info_for_struct: doing {} {}\",\n                token::get_ident(nm), id);\n@@ -728,13 +717,10 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                ctor_id: NodeId,\n                                index: @RefCell<Vec<entry<i64>> >,\n                                struct_id: NodeId) {\n-    {\n-        let mut index = index.borrow_mut();\n-        index.get().push(entry {\n-            val: ctor_id as i64,\n-            pos: ebml_w.writer.tell().unwrap(),\n-        });\n-    }\n+    index.borrow_mut().push(entry {\n+        val: ctor_id as i64,\n+        pos: ebml_w.writer.tell().unwrap(),\n+    });\n \n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(ctor_id));\n@@ -746,8 +732,7 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n     ecx.tcx.map.with_path(ctor_id, |path| encode_path(ebml_w, path));\n     encode_parent_item(ebml_w, local_def(struct_id));\n \n-    let item_symbols = ecx.item_symbols.borrow();\n-    if item_symbols.get().contains_key(&ctor_id) {\n+    if ecx.item_symbols.borrow().contains_key(&ctor_id) {\n         encode_symbol(ecx, ebml_w, ctor_id);\n     }\n \n@@ -853,12 +838,10 @@ fn should_inline(attrs: &[Attribute]) -> bool {\n fn encode_inherent_implementations(ecx: &EncodeContext,\n                                    ebml_w: &mut writer::Encoder,\n                                    def_id: DefId) {\n-    let inherent_impls = ecx.tcx.inherent_impls.borrow();\n-    match inherent_impls.get().find(&def_id) {\n+    match ecx.tcx.inherent_impls.borrow().find(&def_id) {\n         None => {}\n         Some(&implementations) => {\n-            let implementations = implementations.borrow();\n-            for implementation in implementations.get().iter() {\n+            for implementation in implementations.borrow().iter() {\n                 ebml_w.start_tag(tag_items_data_item_inherent_impl);\n                 encode_def_id(ebml_w, implementation.did);\n                 ebml_w.end_tag();\n@@ -871,12 +854,10 @@ fn encode_inherent_implementations(ecx: &EncodeContext,\n fn encode_extension_implementations(ecx: &EncodeContext,\n                                     ebml_w: &mut writer::Encoder,\n                                     trait_def_id: DefId) {\n-    let trait_impls = ecx.tcx.trait_impls.borrow();\n-    match trait_impls.get().find(&trait_def_id) {\n+    match ecx.tcx.trait_impls.borrow().find(&trait_def_id) {\n         None => {}\n         Some(&implementations) => {\n-            let implementations = implementations.borrow();\n-            for implementation in implementations.get().iter() {\n+            for implementation in implementations.borrow().iter() {\n                 ebml_w.start_tag(tag_items_data_item_extension_impl);\n                 encode_def_id(ebml_w, implementation.did);\n                 ebml_w.end_tag();\n@@ -895,8 +876,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n     fn add_to_index(item: &Item, ebml_w: &writer::Encoder,\n                      index: @RefCell<Vec<entry<i64>> >) {\n-        let mut index = index.borrow_mut();\n-        index.get().push(entry {\n+        index.borrow_mut().push(entry {\n             val: item.id as i64,\n             pos: ebml_w.writer.tell().unwrap(),\n         });\n@@ -921,7 +901,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(ebml_w, item.ident.name);\n         encode_path(ebml_w, path);\n \n-        let inlineable = !ecx.non_inlineable_statics.borrow().get().contains(&item.id);\n+        let inlineable = !ecx.non_inlineable_statics.borrow().contains(&item.id);\n \n         if inlineable {\n             (ecx.encode_inlined_item)(ecx, ebml_w, IIItemRef(item));\n@@ -1065,7 +1045,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n         let impls = tcx.impls.borrow();\n-        let imp = impls.get().get(&def_id);\n+        let imp = impls.get(&def_id);\n \n         add_to_index(item, ebml_w, index);\n         ebml_w.start_tag(tag_items_data_item);\n@@ -1108,13 +1088,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 Some(*ast_methods.get(i))\n             } else { None };\n \n-            {\n-                let mut index = index.borrow_mut();\n-                index.get().push(entry {\n-                    val: m.def_id.node as i64,\n-                    pos: ebml_w.writer.tell().unwrap(),\n-                });\n-            }\n+            index.borrow_mut().push(entry {\n+                val: m.def_id.node as i64,\n+                pos: ebml_w.writer.tell().unwrap(),\n+            });\n             encode_info_for_method(ecx,\n                                    ebml_w,\n                                    *m,\n@@ -1169,13 +1146,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             let method_ty = ty::method(tcx, method_def_id);\n \n-            {\n-                let mut index = index.borrow_mut();\n-                index.get().push(entry {\n-                    val: method_def_id.node as i64,\n-                    pos: ebml_w.writer.tell().unwrap(),\n-                });\n-            }\n+            index.borrow_mut().push(entry {\n+                val: method_def_id.node as i64,\n+                pos: ebml_w.writer.tell().unwrap(),\n+            });\n \n             ebml_w.start_tag(tag_items_data_item);\n \n@@ -1242,13 +1216,10 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 index: @RefCell<Vec<entry<i64>> >,\n                                 path: PathElems,\n                                 abi: AbiSet) {\n-    {\n-        let mut index = index.borrow_mut();\n-        index.get().push(entry {\n-            val: nitem.id as i64,\n-            pos: ebml_w.writer.tell().unwrap(),\n-        });\n-    }\n+    index.borrow_mut().push(entry {\n+        val: nitem.id as i64,\n+        pos: ebml_w.writer.tell().unwrap(),\n+    });\n \n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(nitem.id));\n@@ -1347,13 +1318,10 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                          -> Vec<entry<i64>> {\n     let index = @RefCell::new(Vec::new());\n     ebml_w.start_tag(tag_items_data);\n-    {\n-        let mut index = index.borrow_mut();\n-        index.get().push(entry {\n-            val: CRATE_NODE_ID as i64,\n-            pos: ebml_w.writer.tell().unwrap(),\n-        });\n-    }\n+    index.borrow_mut().push(entry {\n+        val: CRATE_NODE_ID as i64,\n+        pos: ebml_w.writer.tell().unwrap(),\n+    });\n     encode_info_for_mod(ecx,\n                         ebml_w,\n                         &krate.module,\n@@ -1390,8 +1358,7 @@ fn create_index<T:Clone + Hash + 'static>(\n     }\n     for elt in index.iter() {\n         let h = hash::hash(&elt.val) as uint;\n-        let mut bucket = buckets.get_mut(h % 256).borrow_mut();\n-        bucket.get().push((*elt).clone());\n+        buckets.get_mut(h % 256).borrow_mut().push((*elt).clone());\n     }\n \n     let mut buckets_frozen = Vec::new();\n@@ -1584,9 +1551,8 @@ fn encode_lang_items(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n fn encode_native_libraries(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.start_tag(tag_native_libraries);\n \n-    let used_libraries = ecx.tcx.sess.cstore.get_used_libraries();\n-    let used_libraries = used_libraries.borrow();\n-    for &(ref lib, kind) in used_libraries.get().iter() {\n+    for &(ref lib, kind) in ecx.tcx.sess.cstore.get_used_libraries()\n+                               .borrow().iter() {\n         match kind {\n             cstore::NativeStatic => {} // these libraries are not propagated\n             cstore::NativeFramework | cstore::NativeUnknown => {\n@@ -1609,8 +1575,7 @@ fn encode_native_libraries(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n }\n \n fn encode_macro_registrar_fn(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n-    let ptr = ecx.tcx.sess.macro_registrar_fn.borrow();\n-    match *ptr.get() {\n+    match *ecx.tcx.sess.macro_registrar_fn.borrow() {\n         Some(did) => {\n             ebml_w.start_tag(tag_macro_registrar_fn);\n             encode_def_id(ebml_w, did);\n@@ -1665,8 +1630,7 @@ impl<'a,'b> Visitor<()> for ImplVisitor<'a,'b> {\n         match item.node {\n             ItemImpl(_, Some(ref trait_ref), _, _) => {\n                 let def_map = self.ecx.tcx.def_map;\n-                let def_map = def_map.borrow();\n-                let trait_def = def_map.get().get_copy(&trait_ref.ref_id);\n+                let trait_def = def_map.borrow().get_copy(&trait_ref.ref_id);\n                 let def_id = ast_util::def_id_of_def(trait_def);\n \n                 // Load eagerly if this is an implementation of the Drop trait"}, {"sha": "fa794c883450a928736aac6bb7eb87b2ba8b067c", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -36,10 +36,9 @@ impl<'a> FileSearch<'a> {\n         let mut visited_dirs = HashSet::new();\n         let mut found = false;\n \n-        let addl_lib_search_paths = self.addl_lib_search_paths.borrow();\n         debug!(\"filesearch: searching additional lib search paths [{:?}]\",\n-               addl_lib_search_paths.get().len());\n-        for path in addl_lib_search_paths.get().iter() {\n+               self.addl_lib_search_paths.borrow().len());\n+        for path in self.addl_lib_search_paths.borrow().iter() {\n             match f(path) {\n                 FileMatches => found = true,\n                 FileDoesntMatch => ()"}, {"sha": "f2b2a47ea9604bf5f4587386d206b3428a49bf2f", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -382,23 +382,17 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n                                          pos: pos,\n                                          len: len };\n \n-        let tt_opt = {\n-            let rcache = st.tcx.rcache.borrow();\n-            rcache.get().find_copy(&key)\n-        };\n-        match tt_opt {\n+        match st.tcx.rcache.borrow().find_copy(&key) {\n           Some(tt) => return tt,\n-          None => {\n-            let mut ps = PState {\n-                pos: pos,\n-                .. *st\n-            };\n-            let tt = parse_ty(&mut ps, |x,y| conv(x,y));\n-            let mut rcache = st.tcx.rcache.borrow_mut();\n-            rcache.get().insert(key, tt);\n-            return tt;\n-          }\n+          None => {}\n         }\n+        let mut ps = PState {\n+            pos: pos,\n+            .. *st\n+        };\n+        let tt = parse_ty(&mut ps, |x,y| conv(x,y));\n+        st.tcx.rcache.borrow_mut().insert(key, tt);\n+        return tt;\n       }\n       '\"' => {\n         let _ = parse_def(st, TypeWithId, |x,y| conv(x,y));"}, {"sha": "6649da0c4d9f3daa306b263c02c3e4213f83d847", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -63,37 +63,27 @@ fn mywrite(w: &mut MemWriter, fmt: &fmt::Arguments) {\n pub fn enc_ty(w: &mut MemWriter, cx: &ctxt, t: ty::t) {\n     match cx.abbrevs {\n       ac_no_abbrevs => {\n-          let result_str_opt;\n-          {\n-              let short_names_cache = cx.tcx.short_names_cache.borrow();\n-              result_str_opt = short_names_cache.get()\n-                                                .find(&t)\n-                                                .map(|result| {\n-                                                    (*result).clone()\n-                                                });\n-          }\n+          let result_str_opt = cx.tcx.short_names_cache.borrow()\n+                                            .find(&t)\n+                                            .map(|result| {\n+                                                (*result).clone()\n+                                            });\n           let result_str = match result_str_opt {\n             Some(s) => s,\n             None => {\n                 let wr = &mut MemWriter::new();\n                 enc_sty(wr, cx, &ty::get(t).sty);\n                 let s = str::from_utf8(wr.get_ref()).unwrap();\n-                let mut short_names_cache = cx.tcx\n-                                              .short_names_cache\n-                                              .borrow_mut();\n-                short_names_cache.get().insert(t, s.to_str());\n+                cx.tcx.short_names_cache.borrow_mut().insert(t, s.to_str());\n                 s.to_str()\n             }\n           };\n           w.write(result_str.as_bytes());\n       }\n       ac_use_abbrevs(abbrevs) => {\n-          {\n-              let mut abbrevs = abbrevs.borrow_mut();\n-              match abbrevs.get().find(&t) {\n-                  Some(a) => { w.write(a.s.as_bytes()); return; }\n-                  None => {}\n-              }\n+          match abbrevs.borrow_mut().find(&t) {\n+              Some(a) => { w.write(a.s.as_bytes()); return; }\n+              None => {}\n           }\n           let pos = w.tell().unwrap();\n           enc_sty(w, cx, &ty::get(t).sty);\n@@ -112,10 +102,7 @@ pub fn enc_ty(w: &mut MemWriter, cx: &ctxt, t: ty::t) {\n               let a = ty_abbrev { pos: pos as uint,\n                                   len: len as uint,\n                                   s: s };\n-              {\n-                  let mut abbrevs = abbrevs.borrow_mut();\n-                  abbrevs.get().insert(t, a);\n-              }\n+              abbrevs.borrow_mut().insert(t, a);\n           }\n           return;\n       }"}, {"sha": "e7bd536cae293c3da0e24ef541ea276214a3f5a8", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 60, "deletions": 111, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -958,89 +958,63 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     debug!(\"Encoding side tables for id {}\", id);\n \n-    {\n-        let def_map = tcx.def_map.borrow();\n-        let r = def_map.get().find(&id);\n-        for def in r.iter() {\n-            ebml_w.tag(c::tag_table_def, |ebml_w| {\n-                ebml_w.id(id);\n-                ebml_w.tag(c::tag_table_val, |ebml_w| (*def).encode(ebml_w));\n-            })\n-        }\n+    for def in tcx.def_map.borrow().find(&id).iter() {\n+        ebml_w.tag(c::tag_table_def, |ebml_w| {\n+            ebml_w.id(id);\n+            ebml_w.tag(c::tag_table_val, |ebml_w| (*def).encode(ebml_w));\n+        })\n     }\n \n-    {\n-        let node_types = tcx.node_types.borrow();\n-        let r = node_types.get().find(&(id as uint));\n-        for &ty in r.iter() {\n-            ebml_w.tag(c::tag_table_node_type, |ebml_w| {\n-                ebml_w.id(id);\n-                ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    ebml_w.emit_ty(ecx, *ty);\n-                })\n+    for &ty in tcx.node_types.borrow().find(&(id as uint)).iter() {\n+        ebml_w.tag(c::tag_table_node_type, |ebml_w| {\n+            ebml_w.id(id);\n+            ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                ebml_w.emit_ty(ecx, *ty);\n             })\n-        }\n+        })\n     }\n \n-    {\n-        let node_type_substs = tcx.node_type_substs.borrow();\n-        let r = node_type_substs.get().find(&id);\n-        for tys in r.iter() {\n-            ebml_w.tag(c::tag_table_node_type_subst, |ebml_w| {\n-                ebml_w.id(id);\n-                ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    ebml_w.emit_tys(ecx, tys.as_slice())\n-                })\n+    for tys in tcx.node_type_substs.borrow().find(&id).iter() {\n+        ebml_w.tag(c::tag_table_node_type_subst, |ebml_w| {\n+            ebml_w.id(id);\n+            ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                ebml_w.emit_tys(ecx, tys.as_slice())\n             })\n-        }\n+        })\n     }\n \n-    {\n-        let freevars = tcx.freevars.borrow();\n-        let r = freevars.get().find(&id);\n-        for &fv in r.iter() {\n-            ebml_w.tag(c::tag_table_freevars, |ebml_w| {\n-                ebml_w.id(id);\n-                ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    ebml_w.emit_from_vec(fv.as_slice(), |ebml_w, fv_entry| {\n-                        encode_freevar_entry(ebml_w, *fv_entry)\n-                    })\n+    for &fv in tcx.freevars.borrow().find(&id).iter() {\n+        ebml_w.tag(c::tag_table_freevars, |ebml_w| {\n+            ebml_w.id(id);\n+            ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                ebml_w.emit_from_vec(fv.as_slice(), |ebml_w, fv_entry| {\n+                    encode_freevar_entry(ebml_w, *fv_entry)\n                 })\n             })\n-        }\n+        })\n     }\n \n     let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n-    {\n-        let tcache = tcx.tcache.borrow();\n-        let r = tcache.get().find(&lid);\n-        for &tpbt in r.iter() {\n-            ebml_w.tag(c::tag_table_tcache, |ebml_w| {\n-                ebml_w.id(id);\n-                ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    ebml_w.emit_tpbt(ecx, tpbt.clone());\n-                })\n+    for &tpbt in tcx.tcache.borrow().find(&lid).iter() {\n+        ebml_w.tag(c::tag_table_tcache, |ebml_w| {\n+            ebml_w.id(id);\n+            ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                ebml_w.emit_tpbt(ecx, tpbt.clone());\n             })\n-        }\n+        })\n     }\n \n-    {\n-        let r = {\n-            let ty_param_defs = tcx.ty_param_defs.borrow();\n-            ty_param_defs.get().find(&id).map(|def| *def)\n-        };\n-        for type_param_def in r.iter() {\n-            ebml_w.tag(c::tag_table_param_defs, |ebml_w| {\n-                ebml_w.id(id);\n-                ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    ebml_w.emit_type_param_def(ecx, type_param_def)\n-                })\n+    for &type_param_def in tcx.ty_param_defs.borrow().find(&id).iter() {\n+        ebml_w.tag(c::tag_table_param_defs, |ebml_w| {\n+            ebml_w.id(id);\n+            ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                ebml_w.emit_type_param_def(ecx, type_param_def)\n             })\n-        }\n+        })\n     }\n \n     let method_call = MethodCall::expr(id);\n-    for &method in maps.method_map.borrow().get().find(&method_call).iter() {\n+    for &method in maps.method_map.borrow().find(&method_call).iter() {\n         ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n@@ -1049,33 +1023,25 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    {\n-        let vtable_map = maps.vtable_map.borrow();\n-        let r = vtable_map.get().find(&id);\n-        for &dr in r.iter() {\n-            ebml_w.tag(c::tag_table_vtable_map, |ebml_w| {\n-                ebml_w.id(id);\n-                ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    encode_vtable_res(ecx, ebml_w, *dr);\n-                })\n+    for &dr in maps.vtable_map.borrow().find(&id).iter() {\n+        ebml_w.tag(c::tag_table_vtable_map, |ebml_w| {\n+            ebml_w.id(id);\n+            ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                encode_vtable_res(ecx, ebml_w, *dr);\n             })\n-        }\n+        })\n     }\n \n-    {\n-        let adjustments = tcx.adjustments.borrow();\n-        let r = adjustments.get().find(&id);\n-        for adj in r.iter() {\n-            ebml_w.tag(c::tag_table_adjustments, |ebml_w| {\n-                ebml_w.id(id);\n-                ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    ebml_w.emit_auto_adjustment(ecx, **adj);\n-                })\n+    for adj in tcx.adjustments.borrow().find(&id).iter() {\n+        ebml_w.tag(c::tag_table_adjustments, |ebml_w| {\n+            ebml_w.id(id);\n+            ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                ebml_w.emit_auto_adjustment(ecx, **adj);\n             })\n-        }\n+        })\n     }\n \n-    for &cap_vars in maps.capture_map.borrow().get().find(&id).iter() {\n+    for &cap_vars in maps.capture_map.borrow().find(&id).iter() {\n         ebml_w.tag(c::tag_table_capture_map, |ebml_w| {\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n@@ -1343,71 +1309,54 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                 match value {\n                     c::tag_table_def => {\n                         let def = decode_def(xcx, val_doc);\n-                        let mut def_map = dcx.tcx.def_map.borrow_mut();\n-                        def_map.get().insert(id, def);\n+                        dcx.tcx.def_map.borrow_mut().insert(id, def);\n                     }\n                     c::tag_table_node_type => {\n                         let ty = val_dsr.read_ty(xcx);\n                         debug!(\"inserting ty for node {:?}: {}\",\n                                id, ty_to_str(dcx.tcx, ty));\n-                        let mut node_types = dcx.tcx.node_types.borrow_mut();\n-                        node_types.get().insert(id as uint, ty);\n+                        dcx.tcx.node_types.borrow_mut().insert(id as uint, ty);\n                     }\n                     c::tag_table_node_type_subst => {\n                         let tys = val_dsr.read_tys(xcx);\n-                        let mut node_type_substs = dcx.tcx\n-                                                      .node_type_substs\n-                                                      .borrow_mut();\n-                        node_type_substs.get().insert(id, tys);\n+                        dcx.tcx.node_type_substs.borrow_mut().insert(id, tys);\n                     }\n                     c::tag_table_freevars => {\n                         let fv_info = @val_dsr.read_to_vec(|val_dsr| {\n                             @val_dsr.read_freevar_entry(xcx)\n                         }).move_iter().collect();\n-                        let mut freevars = dcx.tcx.freevars.borrow_mut();\n-                        freevars.get().insert(id, fv_info);\n+                        dcx.tcx.freevars.borrow_mut().insert(id, fv_info);\n                     }\n                     c::tag_table_tcache => {\n                         let tpbt = val_dsr.read_ty_param_bounds_and_ty(xcx);\n                         let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n-                        let mut tcache = dcx.tcx.tcache.borrow_mut();\n-                        tcache.get().insert(lid, tpbt);\n+                        dcx.tcx.tcache.borrow_mut().insert(lid, tpbt);\n                     }\n                     c::tag_table_param_defs => {\n                         let bounds = val_dsr.read_type_param_def(xcx);\n-                        let mut ty_param_defs = dcx.tcx\n-                                                   .ty_param_defs\n-                                                   .borrow_mut();\n-                        ty_param_defs.get().insert(id, bounds);\n+                        dcx.tcx.ty_param_defs.borrow_mut().insert(id, bounds);\n                     }\n                     c::tag_table_method_map => {\n                         let method = val_dsr.read_method_callee(xcx);\n                         let method_call = MethodCall::expr(id);\n-                        dcx.maps.method_map.borrow_mut().get().insert(method_call, method);\n+                        dcx.maps.method_map.borrow_mut().insert(method_call, method);\n                     }\n                     c::tag_table_vtable_map => {\n                         let vtable_res =\n                             val_dsr.read_vtable_res(xcx.dcx.tcx,\n                                                     xcx.dcx.cdata);\n-                        let mut vtable_map = dcx.maps.vtable_map.borrow_mut();\n-                        vtable_map.get().insert(id, vtable_res);\n+                        dcx.maps.vtable_map.borrow_mut().insert(id, vtable_res);\n                     }\n                     c::tag_table_adjustments => {\n                         let adj: @ty::AutoAdjustment = @val_dsr.read_auto_adjustment(xcx);\n-                        let mut adjustments = dcx.tcx\n-                                                 .adjustments\n-                                                 .borrow_mut();\n-                        adjustments.get().insert(id, adj);\n+                        dcx.tcx.adjustments.borrow_mut().insert(id, adj);\n                     }\n                     c::tag_table_capture_map => {\n                         let cvars =\n                                 val_dsr.read_to_vec(|val_dsr| val_dsr.read_capture_var(xcx))\n                                        .move_iter()\n                                        .collect();\n-                        let mut capture_map = dcx.maps\n-                                                 .capture_map\n-                                                 .borrow_mut();\n-                        capture_map.get().insert(id, Rc::new(cvars));\n+                        dcx.maps.capture_map.borrow_mut().insert(id, Rc::new(cvars));\n                     }\n                     _ => {\n                         xcx.dcx.tcx.sess.bug("}, {"sha": "2edb18b73c7490cd0d442c1507c78538c0c424b0", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -378,11 +378,7 @@ impl<'a> CheckLoanCtxt<'a> {\n     pub fn check_assignment(&self, expr: &ast::Expr) {\n         // We don't use cat_expr() here because we don't want to treat\n         // auto-ref'd parameters in overloaded operators as rvalues.\n-        let adj = {\n-            let adjustments = self.bccx.tcx.adjustments.borrow();\n-            adjustments.get().find_copy(&expr.id)\n-        };\n-        let cmt = match adj {\n+        let cmt = match self.bccx.tcx.adjustments.borrow().find_copy(&expr.id) {\n             None => self.bccx.cat_expr_unadjusted(expr),\n             Some(adj) => self.bccx.cat_expr_autoderefd(expr, adj)\n         };\n@@ -452,10 +448,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                        cmt.repr(this.tcx()));\n                 match cmt.cat {\n                     mc::cat_local(id) | mc::cat_arg(id) => {\n-                        let mut used_mut_nodes = this.tcx()\n-                                                     .used_mut_nodes\n-                                                     .borrow_mut();\n-                        used_mut_nodes.get().insert(id);\n+                        this.tcx().used_mut_nodes.borrow_mut().insert(id);\n                         return;\n                     }\n \n@@ -839,11 +832,11 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n         this.check_call(expr, None, expr.span, args.as_slice());\n       }\n       ast::ExprIndex(_, rval) | ast::ExprBinary(_, _, rval)\n-      if method_map.get().contains_key(&MethodCall::expr(expr.id)) => {\n+      if method_map.contains_key(&MethodCall::expr(expr.id)) => {\n         this.check_call(expr, None, expr.span, [rval]);\n       }\n       ast::ExprUnary(_, _) | ast::ExprIndex(_, _)\n-      if method_map.get().contains_key(&MethodCall::expr(expr.id)) => {\n+      if method_map.contains_key(&MethodCall::expr(expr.id)) => {\n         this.check_call(expr, None, expr.span, []);\n       }\n       ast::ExprInlineAsm(ref ia) => {"}, {"sha": "a04afd6d5f3862759ef1bbe53af76f46def93e36", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -237,8 +237,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n         let rm_key = root_map_key {id: cmt_deref.id, derefs: derefs};\n         let root_info = RootInfo {scope: root_scope};\n \n-        let mut root_map = self.bccx.root_map.borrow_mut();\n-        root_map.get().insert(rm_key, root_info);\n+        self.bccx.root_map.borrow_mut().insert(rm_key, root_info);\n \n         debug!(\"root_key: {:?} root_info: {:?}\", rm_key, root_info);\n         Ok(())"}, {"sha": "ccf62dd11f7d0ae084a1d6aa61d0ec9e01a80d83", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -195,7 +195,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n     this.id_range.add(ex.id);\n \n     // If this expression is borrowed, have to ensure it remains valid:\n-    for &adjustments in tcx.adjustments.borrow().get().find(&ex.id).iter() {\n+    for &adjustments in tcx.adjustments.borrow().find(&ex.id).iter() {\n         this.guarantee_adjustments(ex, *adjustments);\n     }\n \n@@ -255,7 +255,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n \n       ast::ExprIndex(_, arg) |\n       ast::ExprBinary(_, _, arg)\n-      if method_map.get().contains_key(&MethodCall::expr(ex.id)) => {\n+      if method_map.contains_key(&MethodCall::expr(ex.id)) => {\n           // Arguments in method calls are always passed by ref.\n           //\n           // Currently these do not use adjustments, so we have to\n@@ -343,7 +343,7 @@ impl<'a> GatherLoanCtxt<'a> {\n                                 autoderefs: uint) {\n         let method_map = self.bccx.method_map.borrow();\n         for i in range(0, autoderefs) {\n-            match method_map.get().find(&MethodCall::autoderef(expr.id, i as u32)) {\n+            match method_map.find(&MethodCall::autoderef(expr.id, i as u32)) {\n                 Some(method) => {\n                     // Treat overloaded autoderefs as if an AutoRef adjustment\n                     // was applied on the base type, as that is always the case.\n@@ -466,8 +466,8 @@ impl<'a> GatherLoanCtxt<'a> {\n             // Lookup the kind of borrow the callee requires\n             let upvar_id = ty::UpvarId { var_id: var_id,\n                                          closure_expr_id: closure_expr.id };\n-            let upvar_borrow_map = self.tcx().upvar_borrow_map.borrow();\n-            let upvar_borrow = upvar_borrow_map.get().get_copy(&upvar_id);\n+            let upvar_borrow = self.tcx().upvar_borrow_map.borrow()\n+                                   .get_copy(&upvar_id);\n \n             self.guarantee_valid_kind(closure_expr.id,\n                                       closure_expr.span,\n@@ -750,10 +750,7 @@ impl<'a> GatherLoanCtxt<'a> {\n \n         match *loan_path {\n             LpVar(local_id) => {\n-                let mut used_mut_nodes = self.tcx()\n-                                             .used_mut_nodes\n-                                             .borrow_mut();\n-                used_mut_nodes.get().insert(local_id);\n+                self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n             }\n             LpExtend(base, mc::McInherited, _) => {\n                 self.mark_loan_path_as_mutated(base);"}, {"sha": "62e79fe8dbd4534345bec9e71f70a1a6d2efec6c", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -574,7 +574,7 @@ impl<'a> BorrowckCtxt<'a> {\n                 let (expr_ty, expr_span) = match self.tcx.map.find(move.id) {\n                     Some(ast_map::NodeExpr(expr)) => {\n                         (ty::expr_ty_adjusted(self.tcx, expr,\n-                                              self.method_map.borrow().get()), expr.span)\n+                                              &*self.method_map.borrow()), expr.span)\n                     }\n                     r => self.tcx.sess.bug(format!(\"MoveExpr({:?}) maps to {:?}, not Expr\",\n                                                    move.id, r))\n@@ -601,7 +601,7 @@ impl<'a> BorrowckCtxt<'a> {\n                 let (expr_ty, expr_span) = match self.tcx.map.find(move.id) {\n                     Some(ast_map::NodeExpr(expr)) => {\n                         (ty::expr_ty_adjusted(self.tcx, expr,\n-                                              self.method_map.borrow().get()), expr.span)\n+                                              &*self.method_map.borrow()), expr.span)\n                     }\n                     r => self.tcx.sess.bug(format!(\"Captured({:?}) maps to {:?}, not Expr\",\n                                                    move.id, r))\n@@ -942,24 +942,22 @@ impl<'a> mc::Typer for TcxTyper<'a> {\n     }\n \n     fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t> {\n-        self.method_map.borrow().get().find(&method_call).map(|method| method.ty)\n+        self.method_map.borrow().find(&method_call).map(|method| method.ty)\n     }\n \n     fn adjustment(&mut self, id: ast::NodeId) -> Option<@ty::AutoAdjustment> {\n-        let adjustments = self.tcx.adjustments.borrow();\n-        adjustments.get().find_copy(&id)\n+        self.tcx.adjustments.borrow().find_copy(&id)\n     }\n \n     fn is_method_call(&mut self, id: ast::NodeId) -> bool {\n-        self.method_map.borrow().get().contains_key(&typeck::MethodCall::expr(id))\n+        self.method_map.borrow().contains_key(&typeck::MethodCall::expr(id))\n     }\n \n     fn temporary_scope(&mut self, id: ast::NodeId) -> Option<ast::NodeId> {\n         self.tcx.region_maps.temporary_scope(id)\n     }\n \n     fn upvar_borrow(&mut self, id: ty::UpvarId) -> ty::UpvarBorrow {\n-        let upvar_borrow_map = self.tcx.upvar_borrow_map.borrow();\n-        upvar_borrow_map.get().get_copy(&id)\n+        self.tcx.upvar_borrow_map.borrow().get_copy(&id)\n     }\n }"}, {"sha": "22bacca5485928fad632cf6720b311eb053fea05", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 71, "deletions": 132, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -183,48 +183,40 @@ impl MoveData {\n     }\n \n     fn path_loan_path(&self, index: MovePathIndex) -> @LoanPath {\n-        let paths = self.paths.borrow();\n-        paths.get().get(index.get()).loan_path\n+        self.paths.borrow().get(index.get()).loan_path\n     }\n \n     fn path_parent(&self, index: MovePathIndex) -> MovePathIndex {\n-        let paths = self.paths.borrow();\n-        paths.get().get(index.get()).parent\n+        self.paths.borrow().get(index.get()).parent\n     }\n \n     fn path_first_move(&self, index: MovePathIndex) -> MoveIndex {\n-        let paths = self.paths.borrow();\n-        paths.get().get(index.get()).first_move\n+        self.paths.borrow().get(index.get()).first_move\n     }\n \n     fn path_first_child(&self, index: MovePathIndex) -> MovePathIndex {\n-        let paths = self.paths.borrow();\n-        paths.get().get(index.get()).first_child\n+        self.paths.borrow().get(index.get()).first_child\n     }\n \n     fn path_next_sibling(&self, index: MovePathIndex) -> MovePathIndex {\n-        let paths = self.paths.borrow();\n-        paths.get().get(index.get()).next_sibling\n+        self.paths.borrow().get(index.get()).next_sibling\n     }\n \n     fn set_path_first_move(&self,\n                            index: MovePathIndex,\n                            first_move: MoveIndex) {\n-        let mut paths = self.paths.borrow_mut();\n-        paths.get().get_mut(index.get()).first_move = first_move\n+        self.paths.borrow_mut().get_mut(index.get()).first_move = first_move\n     }\n \n     fn set_path_first_child(&self,\n                             index: MovePathIndex,\n                             first_child: MovePathIndex) {\n-        let mut paths = self.paths.borrow_mut();\n-        paths.get().get_mut(index.get()).first_child = first_child\n+        self.paths.borrow_mut().get_mut(index.get()).first_child = first_child\n     }\n \n     fn move_next_move(&self, index: MoveIndex) -> MoveIndex {\n         //! Type safe indexing operator\n-        let moves = self.moves.borrow();\n-        moves.get().get(index.get()).next_move\n+        self.moves.borrow().get(index.get()).next_move\n     }\n \n     fn is_var_path(&self, index: MovePathIndex) -> bool {\n@@ -241,22 +233,18 @@ impl MoveData {\n          * base paths that do not yet have an index.\n          */\n \n-        {\n-            let path_map = self.path_map.borrow();\n-            match path_map.get().find(&lp) {\n-                Some(&index) => {\n-                    return index;\n-                }\n-                None => {}\n+        match self.path_map.borrow().find(&lp) {\n+            Some(&index) => {\n+                return index;\n             }\n+            None => {}\n         }\n \n         let index = match *lp {\n             LpVar(..) => {\n-                let mut paths = self.paths.borrow_mut();\n-                let index = MovePathIndex(paths.get().len());\n+                let index = MovePathIndex(self.paths.borrow().len());\n \n-                paths.get().push(MovePath {\n+                self.paths.borrow_mut().push(MovePath {\n                     loan_path: lp,\n                     parent: InvalidMovePathIndex,\n                     first_move: InvalidMoveIndex,\n@@ -270,24 +258,18 @@ impl MoveData {\n             LpExtend(base, _, _) => {\n                 let parent_index = self.move_path(tcx, base);\n \n-                let index = {\n-                    let paths = self.paths.borrow();\n-                    MovePathIndex(paths.get().len())\n-                };\n+                let index = MovePathIndex(self.paths.borrow().len());\n \n                 let next_sibling = self.path_first_child(parent_index);\n                 self.set_path_first_child(parent_index, index);\n \n-                {\n-                    let mut paths = self.paths.borrow_mut();\n-                    paths.get().push(MovePath {\n-                        loan_path: lp,\n-                        parent: parent_index,\n-                        first_move: InvalidMoveIndex,\n-                        first_child: InvalidMovePathIndex,\n-                        next_sibling: next_sibling,\n-                    });\n-                }\n+                self.paths.borrow_mut().push(MovePath {\n+                    loan_path: lp,\n+                    parent: parent_index,\n+                    first_move: InvalidMoveIndex,\n+                    first_child: InvalidMovePathIndex,\n+                    next_sibling: next_sibling,\n+                });\n \n                 index\n             }\n@@ -297,19 +279,15 @@ impl MoveData {\n                lp.repr(tcx),\n                index);\n \n-        let paths = self.paths.borrow();\n-        assert_eq!(index.get(), paths.get().len() - 1);\n-\n-        let mut path_map = self.path_map.borrow_mut();\n-        path_map.get().insert(lp, index);\n+        assert_eq!(index.get(), self.paths.borrow().len() - 1);\n+        self.path_map.borrow_mut().insert(lp, index);\n         return index;\n     }\n \n     fn existing_move_path(&self,\n                           lp: @LoanPath)\n                           -> Option<MovePathIndex> {\n-        let path_map = self.path_map.borrow();\n-        path_map.get().find_copy(&lp)\n+        self.path_map.borrow().find_copy(&lp)\n     }\n \n     fn existing_base_paths(&self,\n@@ -328,11 +306,7 @@ impl MoveData {\n          * paths of `lp` to `result`, but does not add new move paths\n          */\n \n-        let index_opt = {\n-            let path_map = self.path_map.borrow();\n-            path_map.get().find_copy(&lp)\n-        };\n-        match index_opt {\n+        match self.path_map.borrow().find_copy(&lp) {\n             Some(index) => {\n                 self.each_base_path(index, |p| {\n                     result.push(p);\n@@ -367,23 +341,17 @@ impl MoveData {\n                kind);\n \n         let path_index = self.move_path(tcx, lp);\n-        let move_index = {\n-            let moves = self.moves.borrow();\n-            MoveIndex(moves.get().len())\n-        };\n+        let move_index = MoveIndex(self.moves.borrow().len());\n \n         let next_move = self.path_first_move(path_index);\n         self.set_path_first_move(path_index, move_index);\n \n-        {\n-            let mut moves = self.moves.borrow_mut();\n-            moves.get().push(Move {\n-                path: path_index,\n-                id: id,\n-                kind: kind,\n-                next_move: next_move\n-            });\n-        }\n+        self.moves.borrow_mut().push(Move {\n+            path: path_index,\n+            id: id,\n+            kind: kind,\n+            next_move: next_move\n+        });\n     }\n \n     pub fn add_assignment(&self,\n@@ -404,8 +372,7 @@ impl MoveData {\n         let path_index = self.move_path(tcx, lp);\n \n         if !is_also_move {\n-            let mut assignee_ids = self.assignee_ids.borrow_mut();\n-            assignee_ids.get().insert(assignee_id);\n+            self.assignee_ids.borrow_mut().insert(assignee_id);\n         }\n \n         let assignment = Assignment {\n@@ -415,19 +382,15 @@ impl MoveData {\n         };\n \n         if self.is_var_path(path_index) {\n-            let mut var_assignments = self.var_assignments.borrow_mut();\n             debug!(\"add_assignment[var](lp={}, assignment={}, path_index={:?})\",\n-                   lp.repr(tcx), var_assignments.get().len(), path_index);\n+                   lp.repr(tcx), self.var_assignments.borrow().len(), path_index);\n \n-            var_assignments.get().push(assignment);\n+            self.var_assignments.borrow_mut().push(assignment);\n         } else {\n             debug!(\"add_assignment[path](lp={}, path_index={:?})\",\n                    lp.repr(tcx), path_index);\n \n-            {\n-                let mut path_assignments = self.path_assignments.borrow_mut();\n-                path_assignments.get().push(assignment);\n-            }\n+            self.path_assignments.borrow_mut().push(assignment);\n         }\n     }\n \n@@ -443,60 +406,42 @@ impl MoveData {\n          * killed by scoping. See `doc.rs` for more details.\n          */\n \n-        {\n-            let moves = self.moves.borrow();\n-            for (i, move) in moves.get().iter().enumerate() {\n-                dfcx_moves.add_gen(move.id, i);\n-            }\n+        for (i, move) in self.moves.borrow().iter().enumerate() {\n+            dfcx_moves.add_gen(move.id, i);\n         }\n \n-        {\n-            let var_assignments = self.var_assignments.borrow();\n-            for (i, assignment) in var_assignments.get().iter().enumerate() {\n-                dfcx_assign.add_gen(assignment.id, i);\n-                self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n-            }\n+        for (i, assignment) in self.var_assignments.borrow().iter().enumerate() {\n+            dfcx_assign.add_gen(assignment.id, i);\n+            self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n         }\n \n-        {\n-            let path_assignments = self.path_assignments.borrow();\n-            for assignment in path_assignments.get().iter() {\n-                self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n-            }\n+        for assignment in self.path_assignments.borrow().iter() {\n+            self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n         }\n \n         // Kill all moves related to a variable `x` when it goes out\n         // of scope:\n-        {\n-            let paths = self.paths.borrow();\n-            for path in paths.get().iter() {\n-                match *path.loan_path {\n-                    LpVar(id) => {\n-                        let kill_id = tcx.region_maps.var_scope(id);\n-                        let path = {\n-                            let path_map = self.path_map.borrow();\n-                            *path_map.get().get(&path.loan_path)\n-                        };\n-                        self.kill_moves(path, kill_id, dfcx_moves);\n-                    }\n-                    LpExtend(..) => {}\n+        for path in self.paths.borrow().iter() {\n+            match *path.loan_path {\n+                LpVar(id) => {\n+                    let kill_id = tcx.region_maps.var_scope(id);\n+                    let path = *self.path_map.borrow().get(&path.loan_path);\n+                    self.kill_moves(path, kill_id, dfcx_moves);\n                 }\n+                LpExtend(..) => {}\n             }\n         }\n \n         // Kill all assignments when the variable goes out of scope:\n-        {\n-            let var_assignments = self.var_assignments.borrow();\n-            for (assignment_index, assignment) in\n-                    var_assignments.get().iter().enumerate() {\n-                match *self.path_loan_path(assignment.path) {\n-                    LpVar(id) => {\n-                        let kill_id = tcx.region_maps.var_scope(id);\n-                        dfcx_assign.add_kill(kill_id, assignment_index);\n-                    }\n-                    LpExtend(..) => {\n-                        tcx.sess.bug(\"var assignment for non var path\");\n-                    }\n+        for (assignment_index, assignment) in\n+                self.var_assignments.borrow().iter().enumerate() {\n+            match *self.path_loan_path(assignment.path) {\n+                LpVar(id) => {\n+                    let kill_id = tcx.region_maps.var_scope(id);\n+                    dfcx_assign.add_kill(kill_id, assignment_index);\n+                }\n+                LpExtend(..) => {\n+                    tcx.sess.bug(\"var assignment for non var path\");\n                 }\n             }\n         }\n@@ -570,22 +515,18 @@ impl<'a> FlowedMoveData<'a> {\n                id_range: ast_util::IdRange,\n                body: &ast::Block)\n                -> FlowedMoveData<'a> {\n-        let mut dfcx_moves = {\n-            let moves = move_data.moves.borrow();\n+        let mut dfcx_moves =\n             DataFlowContext::new(tcx,\n                                  method_map,\n                                  MoveDataFlowOperator,\n                                  id_range,\n-                                 moves.get().len())\n-        };\n-        let mut dfcx_assign = {\n-            let var_assignments = move_data.var_assignments.borrow();\n+                                 move_data.moves.borrow().len());\n+        let mut dfcx_assign =\n             DataFlowContext::new(tcx,\n                                  method_map,\n                                  AssignDataFlowOperator,\n                                  id_range,\n-                                 var_assignments.get().len())\n-        };\n+                                 move_data.var_assignments.borrow().len());\n         move_data.add_gen_kills(tcx, &mut dfcx_moves, &mut dfcx_assign);\n         dfcx_moves.propagate(body);\n         dfcx_assign.propagate(body);\n@@ -605,8 +546,8 @@ impl<'a> FlowedMoveData<'a> {\n          */\n \n         self.dfcx_moves.each_gen_bit_frozen(id, |index| {\n-            let moves = self.move_data.moves.borrow();\n-            let move = moves.get().get(index);\n+            let move = self.move_data.moves.borrow();\n+            let move = move.get(index);\n             let moved_path = move.path;\n             f(move, self.move_data.path_loan_path(moved_path))\n         })\n@@ -644,8 +585,8 @@ impl<'a> FlowedMoveData<'a> {\n         let mut ret = true;\n \n         self.dfcx_moves.each_bit_on_entry_frozen(id, |index| {\n-            let moves = self.move_data.moves.borrow();\n-            let move = moves.get().get(index);\n+            let move = self.move_data.moves.borrow();\n+            let move = move.get(index);\n             let moved_path = move.path;\n             if base_indices.iter().any(|x| x == &moved_path) {\n                 // Scenario 1 or 2: `loan_path` or some base path of\n@@ -675,9 +616,7 @@ impl<'a> FlowedMoveData<'a> {\n                        id: ast::NodeId)\n                        -> bool {\n         //! True if `id` is the id of the LHS of an assignment\n-\n-        let assignee_ids = self.move_data.assignee_ids.borrow();\n-        assignee_ids.get().iter().any(|x| x == &id)\n+        self.move_data.assignee_ids.borrow().iter().any(|x| x == &id)\n     }\n \n     pub fn each_assignment_of(&self,\n@@ -702,8 +641,8 @@ impl<'a> FlowedMoveData<'a> {\n         };\n \n         self.dfcx_assign.each_bit_on_entry_frozen(id, |index| {\n-            let var_assignments = self.move_data.var_assignments.borrow();\n-            let assignment = var_assignments.get().get(index);\n+            let assignment = self.move_data.var_assignments.borrow();\n+            let assignment = assignment.get(index);\n             if assignment.path == loan_path_index && !f(assignment) {\n                 false\n             } else {"}, {"sha": "a66e9191b33338b805a78a43d729d5c2ffddf332", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -497,8 +497,7 @@ impl<'a> CFGBuilder<'a> {\n             }\n \n             Some(_) => {\n-                let def_map = self.tcx.def_map.borrow();\n-                match def_map.get().find(&expr.id) {\n+                match self.tcx.def_map.borrow().find(&expr.id) {\n                     Some(&ast::DefLabel(loop_id)) => {\n                         for l in self.loop_scopes.iter() {\n                             if l.loop_id == loop_id {\n@@ -522,6 +521,6 @@ impl<'a> CFGBuilder<'a> {\n \n     fn is_method_call(&self, expr: &ast::Expr) -> bool {\n         let method_call = typeck::MethodCall::expr(expr.id);\n-        self.method_map.borrow().get().contains_key(&method_call)\n+        self.method_map.borrow().contains_key(&method_call)\n     }\n }"}, {"sha": "6d95202d2c14b878a8f17887718fe3ed367114bf", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -103,7 +103,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n           ExprLit(lit) if ast_util::lit_is_str(lit) => {}\n           ExprBinary(..) | ExprUnary(..) => {\n             let method_call = typeck::MethodCall::expr(e.id);\n-            if v.method_map.borrow().get().contains_key(&method_call) {\n+            if v.method_map.borrow().contains_key(&method_call) {\n                 v.tcx.sess.span_err(e.span, \"user-defined operators are not \\\n                                              allowed in constant expressions\");\n             }\n@@ -127,7 +127,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n                                     \"paths in constants may only refer to \\\n                                      items without type parameters\");\n             }\n-            match v.def_map.borrow().get().find(&e.id) {\n+            match v.def_map.borrow().find(&e.id) {\n               Some(&DefStatic(..)) |\n               Some(&DefFn(_, _)) |\n               Some(&DefVariant(_, _, _)) |\n@@ -145,7 +145,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n             }\n           }\n           ExprCall(callee, _) => {\n-            match v.def_map.borrow().get().find(&callee.id) {\n+            match v.def_map.borrow().find(&callee.id) {\n                 Some(&DefStruct(..)) => {}    // OK.\n                 Some(&DefVariant(..)) => {}    // OK.\n                 _ => {\n@@ -221,8 +221,7 @@ impl<'a> Visitor<()> for CheckItemRecursionVisitor<'a> {\n     fn visit_expr(&mut self, e: &Expr, _: ()) {\n         match e.node {\n             ExprPath(..) => {\n-                let def_map = self.def_map.borrow();\n-                match def_map.get().find(&e.id) {\n+                match self.def_map.borrow().find(&e.id) {\n                     Some(&DefStatic(def_id, _)) if\n                             ast_util::is_local(def_id) => {\n                         self.visit_item(self.ast_map.expect_item(def_id.node), ());"}, {"sha": "12c22edcd2ec9f3c68450a86b316cddd1eef89b1", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 10, "deletions": 30, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -121,10 +121,7 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n \n             // Check that we do not match against a static NaN (#6804)\n             let pat_matches_nan: |&Pat| -> bool = |p| {\n-                let opt_def = {\n-                    let def_map = cx.tcx.def_map.borrow();\n-                    def_map.get().find_copy(&p.id)\n-                };\n+                let opt_def = cx.tcx.def_map.borrow().find_copy(&p.id);\n                 match opt_def {\n                     Some(DefStatic(did, false)) => {\n                         let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n@@ -351,10 +348,7 @@ fn pat_ctor_id(cx: &MatchCheckCtxt, p: @Pat) -> Option<ctor> {\n     match pat.node {\n       PatWild | PatWildMulti => { None }\n       PatIdent(_, _, _) | PatEnum(_, _) => {\n-        let opt_def = {\n-            let def_map = cx.tcx.def_map.borrow();\n-            def_map.get().find_copy(&pat.id)\n-        };\n+        let opt_def = cx.tcx.def_map.borrow().find_copy(&pat.id);\n         match opt_def {\n           Some(DefVariant(_, id, _)) => Some(variant(id)),\n           Some(DefStatic(did, false)) => {\n@@ -369,8 +363,7 @@ fn pat_ctor_id(cx: &MatchCheckCtxt, p: @Pat) -> Option<ctor> {\n         Some(range(eval_const_expr(cx.tcx, lo), eval_const_expr(cx.tcx, hi)))\n       }\n       PatStruct(..) => {\n-        let def_map = cx.tcx.def_map.borrow();\n-        match def_map.get().find(&pat.id) {\n+        match cx.tcx.def_map.borrow().find(&pat.id) {\n           Some(&DefVariant(_, id, _)) => Some(variant(id)),\n           _ => Some(single)\n         }\n@@ -392,8 +385,7 @@ fn is_wild(cx: &MatchCheckCtxt, p: @Pat) -> bool {\n     match pat.node {\n       PatWild | PatWildMulti => { true }\n       PatIdent(_, _, _) => {\n-        let def_map = cx.tcx.def_map.borrow();\n-        match def_map.get().find(&pat.id) {\n+        match cx.tcx.def_map.borrow().find(&pat.id) {\n           Some(&DefVariant(_, _, _)) | Some(&DefStatic(..)) => { false }\n           _ => { true }\n         }\n@@ -575,10 +567,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                                     r.tail()))\n             }\n             PatIdent(_, _, _) => {\n-                let opt_def = {\n-                    let def_map = cx.tcx.def_map.borrow();\n-                    def_map.get().find_copy(&pat_id)\n-                };\n+                let opt_def = cx.tcx.def_map.borrow().find_copy(&pat_id);\n                 match opt_def {\n                     Some(DefVariant(_, id, _)) => {\n                         if variant(id) == *ctor_id {\n@@ -636,11 +625,8 @@ fn specialize(cx: &MatchCheckCtxt,\n                 }\n             }\n             PatEnum(_, args) => {\n-                let opt_def = {\n-                    let def_map = cx.tcx.def_map.borrow();\n-                    def_map.get().get_copy(&pat_id)\n-                };\n-                match opt_def {\n+                let def = cx.tcx.def_map.borrow().get_copy(&pat_id);\n+                match def {\n                     DefStatic(did, _) => {\n                         let const_expr =\n                             lookup_const_by_id(cx.tcx, did).unwrap();\n@@ -701,11 +687,8 @@ fn specialize(cx: &MatchCheckCtxt,\n             }\n             PatStruct(_, ref pattern_fields, _) => {\n                 // Is this a struct or an enum variant?\n-                let opt_def = {\n-                    let def_map = cx.tcx.def_map.borrow();\n-                    def_map.get().get_copy(&pat_id)\n-                };\n-                match opt_def {\n+                let def = cx.tcx.def_map.borrow().get_copy(&pat_id);\n+                match def {\n                     DefVariant(_, variant_id, _) => {\n                         if variant(variant_id) == *ctor_id {\n                             let struct_fields = ty::lookup_struct_fields(cx.tcx, variant_id);\n@@ -891,10 +874,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n }\n \n fn is_refutable(cx: &MatchCheckCtxt, pat: &Pat) -> bool {\n-    let opt_def = {\n-        let def_map = cx.tcx.def_map.borrow();\n-        def_map.get().find_copy(&pat.id)\n-    };\n+    let opt_def = cx.tcx.def_map.borrow().find_copy(&pat.id);\n     match opt_def {\n       Some(DefVariant(enum_id, _, _)) => {\n         if ty::enum_variants(cx.tcx, enum_id).len() != 1u {"}, {"sha": "5a3436cf8c2c0e0fa01d534710fd62f1b372cf4e", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -83,10 +83,7 @@ pub fn join_all<It: Iterator<constness>>(mut cs: It) -> constness {\n }\n \n pub fn lookup_const(tcx: &ty::ctxt, e: &Expr) -> Option<@Expr> {\n-    let opt_def = {\n-        let def_map = tcx.def_map.borrow();\n-        def_map.get().find_copy(&e.id)\n-    };\n+    let opt_def = tcx.def_map.borrow().find_copy(&e.id);\n     match opt_def {\n         Some(ast::DefStatic(def_id, false)) => {\n             lookup_const_by_id(tcx, def_id)\n@@ -125,7 +122,7 @@ pub fn lookup_variant_by_id(tcx: &ty::ctxt,\n             }\n         }\n     } else {\n-        match tcx.extern_const_variants.borrow().get().find(&variant_def) {\n+        match tcx.extern_const_variants.borrow().find(&variant_def) {\n             Some(&e) => return e,\n             None => {}\n         }\n@@ -145,7 +142,7 @@ pub fn lookup_variant_by_id(tcx: &ty::ctxt,\n             },\n             _ => None\n         };\n-        tcx.extern_const_variants.borrow_mut().get().insert(variant_def, e);\n+        tcx.extern_const_variants.borrow_mut().insert(variant_def, e);\n         return e;\n     }\n }\n@@ -166,12 +163,9 @@ pub fn lookup_const_by_id(tcx: &ty::ctxt, def_id: ast::DefId)\n             }\n         }\n     } else {\n-        {\n-            let extern_const_statics = tcx.extern_const_statics.borrow();\n-            match extern_const_statics.get().find(&def_id) {\n-                Some(&e) => return e,\n-                None => {}\n-            }\n+        match tcx.extern_const_statics.borrow().find(&def_id) {\n+            Some(&e) => return e,\n+            None => {}\n         }\n         let maps = astencode::Maps {\n             root_map: @RefCell::new(HashMap::new()),\n@@ -187,12 +181,8 @@ pub fn lookup_const_by_id(tcx: &ty::ctxt, def_id: ast::DefId)\n             },\n             _ => None\n         };\n-        {\n-            let mut extern_const_statics = tcx.extern_const_statics\n-                                              .borrow_mut();\n-            extern_const_statics.get().insert(def_id, e);\n-            return e;\n-        }\n+        tcx.extern_const_statics.borrow_mut().insert(def_id, e);\n+        return e;\n     }\n }\n "}, {"sha": "178688917e86906539d045e6a76e51fb112bd634", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -782,8 +782,7 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n             }\n \n             Some(_) => {\n-                let def_map = self.tcx().def_map.borrow();\n-                match def_map.get().find(&expr.id) {\n+                match self.tcx().def_map.borrow().find(&expr.id) {\n                     Some(&ast::DefLabel(loop_id)) => {\n                         match loop_scopes.iter().position(|l| l.loop_id == loop_id) {\n                             Some(i) => i,\n@@ -809,7 +808,7 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n \n     fn is_method_call(&self, expr: &ast::Expr) -> bool {\n         let method_call = typeck::MethodCall::expr(expr.id);\n-        self.dfcx.method_map.borrow().get().contains_key(&method_call)\n+        self.dfcx.method_map.borrow().contains_key(&method_call)\n     }\n \n     fn reset(&mut self, bits: &mut [uint]) {"}, {"sha": "1d23218583fc4b9d22effa975d7b2adfa8707c1d", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -75,8 +75,7 @@ impl<'a> MarkSymbolVisitor<'a> {\n     }\n \n     fn lookup_and_handle_definition(&mut self, id: &ast::NodeId) {\n-        let def_map = self.tcx.def_map.borrow();\n-        let def = match def_map.get().find(id) {\n+        let def = match self.tcx.def_map.borrow().find(id) {\n             Some(&def) => def,\n             None => return\n         };\n@@ -94,7 +93,7 @@ impl<'a> MarkSymbolVisitor<'a> {\n     fn lookup_and_handle_method(&mut self, id: ast::NodeId,\n                                 span: codemap::Span) {\n         let method_call = typeck::MethodCall::expr(id);\n-        match self.method_map.borrow().get().find(&method_call) {\n+        match self.method_map.borrow().find(&method_call) {\n             Some(method) => {\n                 match method.origin {\n                     typeck::MethodStatic(def_id) => {\n@@ -342,12 +341,10 @@ impl<'a> DeadVisitor<'a> {\n         // method of a private type is used, but the type itself is never\n         // called directly.\n         let def_id = local_def(id);\n-        let inherent_impls = self.tcx.inherent_impls.borrow();\n-        match inherent_impls.get().find(&def_id) {\n+        match self.tcx.inherent_impls.borrow().find(&def_id) {\n             None => (),\n             Some(ref impl_list) => {\n-                let impl_list = impl_list.borrow();\n-                for impl_ in impl_list.get().iter() {\n+                for impl_ in impl_list.borrow().iter() {\n                     for method in impl_.methods.iter() {\n                         if self.live_symbols.contains(&method.def_id.node) {\n                             return true;"}, {"sha": "5cec239783eb82194b1c8e2fcab692688346670c", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -56,8 +56,7 @@ impl<'a> EffectCheckVisitor<'a> {\n             UnsafeBlock(block_id) => {\n                 // OK, but record this.\n                 debug!(\"effect: recording unsafe block as used: {:?}\", block_id);\n-                let mut used_unsafe = self.tcx.used_unsafe.borrow_mut();\n-                let _ = used_unsafe.get().insert(block_id);\n+                self.tcx.used_unsafe.borrow_mut().insert(block_id);\n             }\n             UnsafeFn => {}\n         }\n@@ -139,7 +138,7 @@ impl<'a> Visitor<()> for EffectCheckVisitor<'a> {\n         match expr.node {\n             ast::ExprMethodCall(_, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                let base_type = self.method_map.borrow().get().get(&method_call).ty;\n+                let base_type = self.method_map.borrow().get(&method_call).ty;\n                 debug!(\"effect: method call case, base type is {}\",\n                        ppaux::ty_to_str(self.tcx, base_type));\n                 if type_is_unsafe_function(base_type) {"}, {"sha": "84a3bb525af95468d43edd7fc9c6ecaaaf1bebe4", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -51,8 +51,7 @@ impl Visitor<int> for CollectFreevarsVisitor {\n             }\n             ast::ExprPath(..) => {\n                 let mut i = 0;\n-                let def_map = self.def_map.borrow();\n-                match def_map.get().find(&expr.id) {\n+                match self.def_map.borrow().find(&expr.id) {\n                     None => fail!(\"path not found\"),\n                     Some(&df) => {\n                         let mut def = df;\n@@ -141,8 +140,7 @@ pub fn annotate_freevars(def_map: resolve::DefMap, krate: &ast::Crate) ->\n }\n \n pub fn get_freevars(tcx: &ty::ctxt, fid: ast::NodeId) -> freevar_info {\n-    let freevars = tcx.freevars.borrow();\n-    match freevars.get().find(&fid) {\n+    match tcx.freevars.borrow().find(&fid) {\n         None => fail!(\"get_freevars: {} has no freevars\", fid),\n         Some(&d) => return d\n     }"}, {"sha": "2c53c729045770a5f75e1516c5dabcd9cc9e0d7a", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -117,18 +117,13 @@ fn check_struct_safe_for_destructor(cx: &mut Context,\n }\n \n fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_type: &Ty) {\n-    let def_map = cx.tcx.def_map.borrow();\n-    let ast_trait_def = def_map.get()\n-                               .find(&trait_ref.ref_id)\n-                               .expect(\"trait ref not in def map!\");\n-    let trait_def_id = ast_util::def_id_of_def(*ast_trait_def);\n-    let trait_def;\n-    {\n-        let trait_defs = cx.tcx.trait_defs.borrow();\n-        trait_def = *trait_defs.get()\n-                               .find(&trait_def_id)\n-                               .expect(\"trait def not in trait-defs map!\");\n-    }\n+    let ast_trait_def = *cx.tcx.def_map.borrow()\n+                              .find(&trait_ref.ref_id)\n+                              .expect(\"trait ref not in def map!\");\n+    let trait_def_id = ast_util::def_id_of_def(ast_trait_def);\n+    let trait_def = *cx.tcx.trait_defs.borrow()\n+                           .find(&trait_def_id)\n+                           .expect(\"trait def not in trait-defs map!\");\n \n     // If this trait has builtin-kind supertraits, meet them.\n     let self_ty: ty::t = ty::node_id_to_type(cx.tcx, it.id);\n@@ -147,7 +142,7 @@ fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_t\n         match self_type.node {\n             TyPath(_, ref bounds, path_node_id) => {\n                 assert!(bounds.is_none());\n-                let struct_def = def_map.get().get_copy(&path_node_id);\n+                let struct_def = cx.tcx.def_map.borrow().get_copy(&path_node_id);\n                 let struct_did = ast_util::def_id_of_def(struct_def);\n                 check_struct_safe_for_destructor(cx, self_type.span, struct_did);\n             }\n@@ -266,18 +261,17 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n     // Handle any kind bounds on type parameters\n     {\n         let method_map = cx.method_map.borrow();\n-        let method = method_map.get().find(&typeck::MethodCall::expr(e.id));\n+        let method = method_map.find(&typeck::MethodCall::expr(e.id));\n         let node_type_substs = cx.tcx.node_type_substs.borrow();\n         let r = match method {\n             Some(method) => Some(&method.substs.tps),\n-            None => node_type_substs.get().find(&e.id)\n+            None => node_type_substs.find(&e.id)\n         };\n         for ts in r.iter() {\n             let def_map = cx.tcx.def_map.borrow();\n             let type_param_defs = match e.node {\n               ExprPath(_) => {\n-                let did = ast_util::def_id_of_def(def_map.get()\n-                                                         .get_copy(&e.id));\n+                let did = ast_util::def_id_of_def(def_map.get_copy(&e.id));\n                 ty::lookup_item_type(cx.tcx, did).generics.type_param_defs.clone()\n               }\n               _ => {\n@@ -334,14 +328,13 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n     }\n \n     // Search for auto-adjustments to find trait coercions.\n-    let adjustments = cx.tcx.adjustments.borrow();\n-    match adjustments.get().find(&e.id) {\n+    match cx.tcx.adjustments.borrow().find(&e.id) {\n         Some(adjustment) => {\n             match **adjustment {\n                 ty::AutoObject(..) => {\n                     let source_ty = ty::expr_ty(cx.tcx, e);\n                     let target_ty = ty::expr_ty_adjusted(cx.tcx, e,\n-                                                         cx.method_map.borrow().get());\n+                                                         &*cx.method_map.borrow());\n                     check_trait_cast(cx, source_ty, target_ty, e.span);\n                 }\n                 ty::AutoAddEnv(..) |\n@@ -368,10 +361,10 @@ fn check_ty(cx: &mut Context, aty: &Ty) {\n     match aty.node {\n         TyPath(_, _, id) => {\n             let node_type_substs = cx.tcx.node_type_substs.borrow();\n-            let r = node_type_substs.get().find(&id);\n+            let r = node_type_substs.find(&id);\n             for ts in r.iter() {\n                 let def_map = cx.tcx.def_map.borrow();\n-                let did = ast_util::def_id_of_def(def_map.get().get_copy(&id));\n+                let did = ast_util::def_id_of_def(def_map.get_copy(&id));\n                 let generics = ty::lookup_item_type(cx.tcx, did).generics;\n                 let type_param_defs = generics.type_param_defs();\n                 for (&ty, type_param_def) in ts.iter().zip(type_param_defs.iter()) {"}, {"sha": "2ba8121b479eaba9e899959111ad0ca50de745a7", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 12, "deletions": 29, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -848,8 +848,7 @@ fn check_item_ctypes(cx: &Context, it: &ast::Item) {\n     fn check_ty(cx: &Context, ty: &ast::Ty) {\n         match ty.node {\n             ast::TyPath(_, _, id) => {\n-                let def_map = cx.tcx.def_map.borrow();\n-                match def_map.get().get_copy(&id) {\n+                match cx.tcx.def_map.borrow().get_copy(&id) {\n                     ast::DefPrimTy(ast::TyInt(ast::TyI)) => {\n                         cx.span_lint(CTypes, ty.span,\n                                 \"found rust type `int` in foreign module, while \\\n@@ -1182,8 +1181,7 @@ fn check_item_non_uppercase_statics(cx: &Context, it: &ast::Item) {\n \n fn check_pat_non_uppercase_statics(cx: &Context, p: &ast::Pat) {\n     // Lint for constants that look like binding identifiers (#7526)\n-    let def_map = cx.tcx.def_map.borrow();\n-    match (&p.node, def_map.get().find(&p.id)) {\n+    match (&p.node, cx.tcx.def_map.borrow().find(&p.id)) {\n         (&ast::PatIdent(_, ref path, _), Some(&ast::DefStatic(_, false))) => {\n             // last identifier alone is right choice for this lint.\n             let ident = path.segments.last().unwrap().identifier;\n@@ -1198,10 +1196,9 @@ fn check_pat_non_uppercase_statics(cx: &Context, p: &ast::Pat) {\n }\n \n fn check_pat_uppercase_variable(cx: &Context, p: &ast::Pat) {\n-    let def_map = cx.tcx.def_map.borrow();\n     match &p.node {\n         &ast::PatIdent(_, ref path, _) => {\n-            match def_map.get().find(&p.id) {\n+            match cx.tcx.def_map.borrow().find(&p.id) {\n                 Some(&ast::DefLocal(_, _)) | Some(&ast::DefBinding(_, _)) |\n                         Some(&ast::DefArg(_, _)) => {\n                     // last identifier alone is right choice for this lint.\n@@ -1279,9 +1276,8 @@ fn check_unused_unsafe(cx: &Context, e: &ast::Expr) {\n     match e.node {\n         // Don't warn about generated blocks, that'll just pollute the output.\n         ast::ExprBlock(ref blk) => {\n-            let used_unsafe = cx.tcx.used_unsafe.borrow();\n             if blk.rules == ast::UnsafeBlock(ast::UserProvided) &&\n-                !used_unsafe.get().contains(&blk.id) {\n+                !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n                 cx.span_lint(UnusedUnsafe, blk.span,\n                              \"unnecessary `unsafe` block\");\n             }\n@@ -1315,8 +1311,8 @@ fn check_unused_mut_pat(cx: &Context, p: &ast::Pat) {\n                                       of exactly one segment\")\n             };\n \n-            let used_mut_nodes = cx.tcx.used_mut_nodes.borrow();\n-            if !initial_underscore && !used_mut_nodes.get().contains(&p.id) {\n+            if !initial_underscore &&\n+               !cx.tcx.used_mut_nodes.borrow().contains(&p.id) {\n                 cx.span_lint(UnusedMut, p.span,\n                              \"variable does not need to be mutable\");\n             }\n@@ -1353,11 +1349,7 @@ fn check_unnecessary_allocation(cx: &Context, e: &ast::Expr) {\n         cx.span_lint(UnnecessaryAllocation, e.span, msg);\n     };\n \n-    let adjustment = {\n-        let adjustments = cx.tcx.adjustments.borrow();\n-        adjustments.get().find_copy(&e.id)\n-    };\n-    match adjustment {\n+    match cx.tcx.adjustments.borrow().find_copy(&e.id) {\n         Some(adjustment) => {\n             match *adjustment {\n                 ty::AutoDerefRef(ty::AutoDerefRef { autoref, .. }) => {\n@@ -1439,13 +1431,7 @@ fn check_missing_doc_method(cx: &Context, m: &ast::Method) {\n         node: m.id\n     };\n \n-    let method_opt;\n-    {\n-        let methods = cx.tcx.methods.borrow();\n-        method_opt = methods.get().find(&did).map(|method| *method);\n-    }\n-\n-    match method_opt {\n+    match cx.tcx.methods.borrow().find(&did).map(|method| *method) {\n         None => cx.tcx.sess.span_bug(m.span, \"missing method descriptor?!\"),\n         Some(md) => {\n             match md.container {\n@@ -1503,15 +1489,14 @@ fn check_missing_doc_variant(cx: &Context, v: &ast::Variant) {\n fn check_stability(cx: &Context, e: &ast::Expr) {\n     let id = match e.node {\n         ast::ExprPath(..) | ast::ExprStruct(..) => {\n-            let def_map = cx.tcx.def_map.borrow();\n-            match def_map.get().find(&e.id) {\n+            match cx.tcx.def_map.borrow().find(&e.id) {\n                 Some(&def) => ast_util::def_id_of_def(def),\n                 None => return\n             }\n         }\n         ast::ExprMethodCall(..) => {\n             let method_call = typeck::MethodCall::expr(e.id);\n-            match cx.method_map.borrow().get().find(&method_call) {\n+            match cx.method_map.borrow().find(&method_call) {\n                 Some(method) => {\n                     match method.origin {\n                         typeck::MethodStatic(def_id) => {\n@@ -1736,8 +1721,7 @@ impl<'a> Visitor<()> for Context<'a> {\n \n impl<'a> IdVisitingOperation for Context<'a> {\n     fn visit_id(&self, id: ast::NodeId) {\n-        let mut lints = self.tcx.sess.lints.borrow_mut();\n-        match lints.get().pop(&id) {\n+        match self.tcx.sess.lints.borrow_mut().pop(&id) {\n             None => {}\n             Some(l) => {\n                 for (lint, span, msg) in l.move_iter() {\n@@ -1793,8 +1777,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n \n     // If we missed any lints added to the session, then there's a bug somewhere\n     // in the iteration code.\n-    let lints = tcx.sess.lints.borrow();\n-    for (id, v) in lints.get().iter() {\n+    for (id, v) in tcx.sess.lints.borrow().iter() {\n         for &(lint, span, ref msg) in v.iter() {\n             tcx.sess.span_bug(span, format!(\"unprocessed lint {:?} at {}: {}\",\n                                             lint, tcx.map.node_to_str(*id), *msg))"}, {"sha": "bf296b6004c34ce7a94590bd0e05def118ab4e9f", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -455,7 +455,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       ExprPath(_) => {\n-        let def = ir.tcx.def_map.borrow().get().get_copy(&expr.id);\n+        let def = ir.tcx.def_map.borrow().get_copy(&expr.id);\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n         if moves::moved_variable_node_id_from_def(def).is_some() {\n             ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -707,7 +707,7 @@ impl<'a> Liveness<'a> {\n             Some(_) => {\n                 // Refers to a labeled loop. Use the results of resolve\n                 // to find with one\n-                match self.ir.tcx.def_map.borrow().get().find(&id) {\n+                match self.ir.tcx.def_map.borrow().find(&id) {\n                     Some(&DefLabel(loop_id)) => loop_id,\n                     _ => self.ir.tcx.sess.span_bug(sp, \"label on break/loop \\\n                                                         doesn't refer to a loop\")\n@@ -1274,7 +1274,7 @@ impl<'a> Liveness<'a> {\n \n     fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: uint)\n                    -> LiveNode {\n-        let def = self.ir.tcx.def_map.borrow().get().get_copy(&expr.id);\n+        let def = self.ir.tcx.def_map.borrow().get_copy(&expr.id);\n         match moves::moved_variable_node_id_from_def(def) {\n           Some(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n@@ -1490,7 +1490,7 @@ impl<'a> Liveness<'a> {\n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n           ExprPath(_) => {\n-            match self.ir.tcx.def_map.borrow().get().get_copy(&expr.id) {\n+            match self.ir.tcx.def_map.borrow().get_copy(&expr.id) {\n               DefLocal(nid, _) => {\n                 // Assignment to an immutable variable or argument: only legal\n                 // if there is no later assignment. If this local is actually"}, {"sha": "36f981f12dd59b5a192723fa9aa6c760b546aa07", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -455,8 +455,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n           }\n \n           ast::ExprPath(_) => {\n-            let def_map = self.tcx().def_map.borrow();\n-            let def = def_map.get().get_copy(&expr.id);\n+            let def = self.tcx().def_map.borrow().get_copy(&expr.id);\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n@@ -1010,8 +1009,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n             // variant(..)\n           }\n           ast::PatEnum(_, Some(ref subpats)) => {\n-            let def_map = self.tcx().def_map.borrow();\n-            match def_map.get().find(&pat.id) {\n+            match self.tcx().def_map.borrow().find(&pat.id) {\n                 Some(&ast::DefVariant(enum_did, _, _)) => {\n                     // variant(x, y, z)\n \n@@ -1202,8 +1200,7 @@ pub fn field_mutbl(tcx: &ty::ctxt,\n         }\n       }\n       ty::ty_enum(..) => {\n-        let def_map = tcx.def_map.borrow();\n-        match def_map.get().get_copy(&node_id) {\n+        match tcx.def_map.borrow().get_copy(&node_id) {\n           ast::DefVariant(_, variant_id, _) => {\n             let r = ty::lookup_struct_fields(tcx, variant_id);\n             for fld in r.iter() {"}, {"sha": "b6cfff5c86fb6fedb3bf958ef8cae45d4e7e2dac", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -275,7 +275,7 @@ impl<'a> VisitContext<'a> {\n                expr.repr(self.tcx));\n \n         let expr_ty = ty::expr_ty_adjusted(self.tcx, expr,\n-                                           self.method_map.borrow().get());\n+                                           &*self.method_map.borrow());\n         if ty::type_moves_by_default(self.tcx, expr_ty) {\n             self.move_maps.moves_map.insert(expr.id);\n             self.use_expr(expr, Move);\n@@ -316,20 +316,17 @@ impl<'a> VisitContext<'a> {\n         // `expr_mode` refers to the post-adjustment value.  If one of\n         // those adjustments is to take a reference, then it's only\n         // reading the underlying expression, not moving it.\n-        let comp_mode = {\n-            let adjustments = self.tcx.adjustments.borrow();\n-            match adjustments.get().find(&expr.id) {\n-                Some(adjustment) => {\n-                    match **adjustment {\n-                        ty::AutoDerefRef(ty::AutoDerefRef {\n-                            autoref: Some(_),\n-                            ..\n-                        }) => Read,\n-                        _ => expr_mode,\n-                    }\n+        let comp_mode = match self.tcx.adjustments.borrow().find(&expr.id) {\n+            Some(adjustment) => {\n+                match **adjustment {\n+                    ty::AutoDerefRef(ty::AutoDerefRef {\n+                        autoref: Some(_),\n+                        ..\n+                    }) => Read,\n+                    _ => expr_mode,\n                 }\n-                _ => expr_mode,\n             }\n+            _ => expr_mode,\n         };\n \n         debug!(\"comp_mode = {:?}\", comp_mode);\n@@ -338,8 +335,7 @@ impl<'a> VisitContext<'a> {\n             ExprPath(..) => {\n                 match comp_mode {\n                     Move => {\n-                        let def_map = self.tcx.def_map.borrow();\n-                        let def = def_map.get().get_copy(&expr.id);\n+                        let def = self.tcx.def_map.borrow().get_copy(&expr.id);\n                         let r = moved_variable_node_id_from_def(def);\n                         for &id in r.iter() {\n                             self.move_maps.moved_variables_set.insert(id);\n@@ -581,7 +577,7 @@ impl<'a> VisitContext<'a> {\n                                    arg_exprs: &[@Expr])\n                                    -> bool {\n         let method_call = MethodCall::expr(expr.id);\n-        if !self.method_map.borrow().get().contains_key(&method_call) {\n+        if !self.method_map.borrow().contains_key(&method_call) {\n             return false;\n         }\n "}, {"sha": "e9d01b9048f919041ab17e0ca00491dccf144373", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -31,8 +31,7 @@ pub fn pat_id_map(dm: resolve::DefMap, pat: &Pat) -> PatIdMap {\n pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatEnum(_, _) | PatIdent(_, _, None) | PatStruct(..) => {\n-            let dm = dm.borrow();\n-            match dm.get().find(&pat.id) {\n+            match dm.borrow().find(&pat.id) {\n                 Some(&DefVariant(..)) | Some(&DefStruct(..)) => true,\n                 _ => false\n             }\n@@ -44,8 +43,7 @@ pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: &Pat) -> bool {\n pub fn pat_is_const(dm: resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatIdent(_, _, None) | PatEnum(..) => {\n-            let dm = dm.borrow();\n-            match dm.get().find(&pat.id) {\n+            match dm.borrow().find(&pat.id) {\n                 Some(&DefStatic(_, false)) => true,\n                 _ => false\n             }"}, {"sha": "0c2abfd23c3d200acb1cbcb63ef4692b8e28bb9a", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -252,8 +252,7 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n             ast::ItemImpl(_, _, ref ty, ref methods) => {\n                 let public_ty = match ty.node {\n                     ast::TyPath(_, _, id) => {\n-                        let def_map = self.tcx.def_map.borrow();\n-                        match def_map.get().get_copy(&id) {\n+                        match self.tcx.def_map.borrow().get_copy(&id) {\n                             ast::DefPrimTy(..) => true,\n                             def => {\n                                 let did = def_id_of_def(def);\n@@ -328,8 +327,8 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n         // crate module gets processed as well.\n         if self.prev_exported {\n             let exp_map2 = self.exp_map2.borrow();\n-            assert!(exp_map2.get().contains_key(&id), \"wut {:?}\", id);\n-            for export in exp_map2.get().get(&id).iter() {\n+            assert!(exp_map2.contains_key(&id), \"wut {:?}\", id);\n+            for export in exp_map2.get(&id).iter() {\n                 if is_local(export.def_id) {\n                     self.reexports.insert(export.def_id.node);\n                 }\n@@ -376,8 +375,7 @@ impl<'a> PrivacyVisitor<'a> {\n             }\n             debug!(\"privacy - is {:?} a public method\", did);\n \n-            let methods = self.tcx.methods.borrow();\n-            return match methods.get().find(&did) {\n+            return match self.tcx.methods.borrow().find(&did) {\n                 Some(meth) => {\n                     debug!(\"privacy - well at least it's a method: {:?}\", meth);\n                     match meth.container {\n@@ -639,8 +637,7 @@ impl<'a> PrivacyVisitor<'a> {\n     // Checks that a path is in scope.\n     fn check_path(&mut self, span: Span, path_id: ast::NodeId, path: &ast::Path) {\n         debug!(\"privacy - path {}\", self.nodestr(path_id));\n-        let def_map = self.tcx.def_map.borrow();\n-        let orig_def = def_map.get().get_copy(&path_id);\n+        let orig_def = self.tcx.def_map.borrow().get_copy(&path_id);\n         let ck = |tyname: &str| {\n             let ck_public = |def: ast::DefId| {\n                 let name = token::get_ident(path.segments\n@@ -722,8 +719,7 @@ impl<'a> PrivacyVisitor<'a> {\n         // def map is not. Therefore the names we work out below will not always\n         // be accurate and we can get slightly wonky error messages (but type\n         // checking is always correct).\n-        let def_map = self.tcx.def_map.borrow();\n-        match def_map.get().get_copy(&path_id) {\n+        match self.tcx.def_map.borrow().get_copy(&path_id) {\n             ast::DefStaticMethod(..) => ck(\"static method\"),\n             ast::DefFn(..) => ck(\"function\"),\n             ast::DefStatic(..) => ck(\"static\"),\n@@ -772,7 +768,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n         match expr.node {\n             ast::ExprField(base, ident, _) => {\n                 match ty::get(ty::expr_ty_adjusted(self.tcx, base,\n-                                                   self.method_map.borrow().get())).sty {\n+                                                   &*self.method_map.borrow())).sty {\n                     ty::ty_struct(id, _) => {\n                         self.check_field(expr.span, id, ident, None);\n                     }\n@@ -781,7 +777,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n             }\n             ast::ExprMethodCall(ident, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                match self.method_map.borrow().get().find(&method_call) {\n+                match self.method_map.borrow().find(&method_call) {\n                     None => {\n                         self.tcx.sess.span_bug(expr.span,\n                                                 \"method call not in \\\n@@ -802,8 +798,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n-                        let def_map = self.tcx.def_map.borrow();\n-                        match def_map.get().get_copy(&expr.id) {\n+                        match self.tcx.def_map.borrow().get_copy(&expr.id) {\n                             ast::DefVariant(enum_id, variant_id, _) => {\n                                 for field in fields.iter() {\n                                     self.check_field(expr.span, variant_id,\n@@ -877,8 +872,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n-                        let def_map = self.tcx.def_map.borrow();\n-                        match def_map.get().find(&pattern.id) {\n+                        match self.tcx.def_map.borrow().find(&pattern.id) {\n                             Some(&ast::DefVariant(enum_id, variant_id, _)) => {\n                                 for field in fields.iter() {\n                                     self.check_field(pattern.span, variant_id,\n@@ -1176,7 +1170,7 @@ struct CheckTypeForPrivatenessVisitor<'a, 'b> {\n \n impl<'a> VisiblePrivateTypesVisitor<'a> {\n     fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n-        let did = match self.tcx.def_map.borrow().get().find_copy(&path_id) {\n+        let did = match self.tcx.def_map.borrow().find_copy(&path_id) {\n             // `int` etc. (None doesn't seem to occur.)\n             None | Some(ast::DefPrimTy(..)) => return false,\n             Some(def) => def_id_of_def(def)"}, {"sha": "839f1d6039c8511c200780fbc116a953618af85c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -100,7 +100,7 @@ impl<'a> Visitor<()> for ReachableContext<'a> {\n \n         match expr.node {\n             ast::ExprPath(_) => {\n-                let def = match self.tcx.def_map.borrow().get().find(&expr.id) {\n+                let def = match self.tcx.def_map.borrow().find(&expr.id) {\n                     Some(&def) => def,\n                     None => {\n                         self.tcx.sess.span_bug(expr.span,\n@@ -133,7 +133,7 @@ impl<'a> Visitor<()> for ReachableContext<'a> {\n             }\n             ast::ExprMethodCall(..) => {\n                 let method_call = typeck::MethodCall::expr(expr.id);\n-                match self.method_map.borrow().get().get(&method_call).origin {\n+                match self.method_map.borrow().get(&method_call).origin {\n                     typeck::MethodStatic(def_id) => {\n                         if is_local(def_id) {\n                             if self.def_id_represents_local_inlined_item(def_id) {\n@@ -330,7 +330,7 @@ impl<'a> ReachableContext<'a> {\n     // this properly would result in the necessity of computing *type*\n     // reachability, which might result in a compile time loss.\n     fn mark_destructors_reachable(&mut self) {\n-        for (_, destructor_def_id) in self.tcx.destructor_for_type.borrow().get().iter() {\n+        for (_, destructor_def_id) in self.tcx.destructor_for_type.borrow().iter() {\n             if destructor_def_id.krate == ast::LOCAL_CRATE {\n                 self.reachable_symbols.insert(destructor_def_id.node);\n             }"}, {"sha": "16c513f16f3444b4665fcec4153cf2211b3e180a", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 14, "deletions": 34, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -100,8 +100,7 @@ struct RegionResolutionVisitor<'a> {\n \n impl RegionMaps {\n     pub fn relate_free_regions(&self, sub: FreeRegion, sup: FreeRegion) {\n-        let mut free_region_map = self.free_region_map.borrow_mut();\n-        match free_region_map.get().find_mut(&sub) {\n+        match self.free_region_map.borrow_mut().find_mut(&sub) {\n             Some(sups) => {\n                 if !sups.iter().any(|x| x == &sup) {\n                     sups.push(sup);\n@@ -112,32 +111,25 @@ impl RegionMaps {\n         }\n \n         debug!(\"relate_free_regions(sub={:?}, sup={:?})\", sub, sup);\n-\n-        free_region_map.get().insert(sub, vec!(sup));\n+        self.free_region_map.borrow_mut().insert(sub, vec!(sup));\n     }\n \n     pub fn record_encl_scope(&self, sub: ast::NodeId, sup: ast::NodeId) {\n         debug!(\"record_encl_scope(sub={}, sup={})\", sub, sup);\n         assert!(sub != sup);\n-\n-        let mut scope_map = self.scope_map.borrow_mut();\n-        scope_map.get().insert(sub, sup);\n+        self.scope_map.borrow_mut().insert(sub, sup);\n     }\n \n     pub fn record_var_scope(&self, var: ast::NodeId, lifetime: ast::NodeId) {\n         debug!(\"record_var_scope(sub={}, sup={})\", var, lifetime);\n         assert!(var != lifetime);\n-\n-        let mut var_map = self.var_map.borrow_mut();\n-        var_map.get().insert(var, lifetime);\n+        self.var_map.borrow_mut().insert(var, lifetime);\n     }\n \n     pub fn record_rvalue_scope(&self, var: ast::NodeId, lifetime: ast::NodeId) {\n         debug!(\"record_rvalue_scope(sub={}, sup={})\", var, lifetime);\n         assert!(var != lifetime);\n-\n-        let mut rvalue_scopes = self.rvalue_scopes.borrow_mut();\n-        rvalue_scopes.get().insert(var, lifetime);\n+        self.rvalue_scopes.borrow_mut().insert(var, lifetime);\n     }\n \n     pub fn mark_as_terminating_scope(&self, scope_id: ast::NodeId) {\n@@ -149,22 +141,17 @@ impl RegionMaps {\n          */\n \n         debug!(\"record_terminating_scope(scope_id={})\", scope_id);\n-        let mut terminating_scopes = self.terminating_scopes.borrow_mut();\n-        terminating_scopes.get().insert(scope_id);\n+        self.terminating_scopes.borrow_mut().insert(scope_id);\n     }\n \n     pub fn opt_encl_scope(&self, id: ast::NodeId) -> Option<ast::NodeId> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n-\n-        let scope_map = self.scope_map.borrow();\n-        scope_map.get().find(&id).map(|x| *x)\n+        self.scope_map.borrow().find(&id).map(|x| *x)\n     }\n \n     pub fn encl_scope(&self, id: ast::NodeId) -> ast::NodeId {\n         //! Returns the narrowest scope that encloses `id`, if any.\n-\n-        let scope_map = self.scope_map.borrow();\n-        match scope_map.get().find(&id) {\n+        match self.scope_map.borrow().find(&id) {\n             Some(&r) => r,\n             None => { fail!(\"no enclosing scope for id {}\", id); }\n         }\n@@ -174,9 +161,7 @@ impl RegionMaps {\n         /*!\n          * Returns the lifetime of the local variable `var_id`\n          */\n-\n-        let var_map = self.var_map.borrow();\n-        match var_map.get().find(&var_id) {\n+        match self.var_map.borrow().find(&var_id) {\n             Some(&r) => r,\n             None => { fail!(\"no enclosing scope for id {}\", var_id); }\n         }\n@@ -186,8 +171,7 @@ impl RegionMaps {\n         //! Returns the scope when temp created by expr_id will be cleaned up\n \n         // check for a designated rvalue scope\n-        let rvalue_scopes = self.rvalue_scopes.borrow();\n-        match rvalue_scopes.get().find(&expr_id) {\n+        match self.rvalue_scopes.borrow().find(&expr_id) {\n             Some(&s) => {\n                 debug!(\"temporary_scope({}) = {} [custom]\", expr_id, s);\n                 return Some(s);\n@@ -204,8 +188,7 @@ impl RegionMaps {\n             None => { return None; }\n         };\n \n-        let terminating_scopes = self.terminating_scopes.borrow();\n-        while !terminating_scopes.get().contains(&id) {\n+        while !self.terminating_scopes.borrow().contains(&id) {\n             match self.opt_encl_scope(id) {\n                 Some(p) => {\n                     id = p;\n@@ -249,8 +232,7 @@ impl RegionMaps {\n \n         let mut s = subscope;\n         while superscope != s {\n-            let scope_map = self.scope_map.borrow();\n-            match scope_map.get().find(&s) {\n+            match self.scope_map.borrow().find(&s) {\n                 None => {\n                     debug!(\"is_subscope_of({}, {}, s={})=false\",\n                            subscope, superscope, s);\n@@ -286,8 +268,7 @@ impl RegionMaps {\n         let mut queue = vec!(sub);\n         let mut i = 0;\n         while i < queue.len() {\n-            let free_region_map = self.free_region_map.borrow();\n-            match free_region_map.get().find(queue.get(i)) {\n+            match self.free_region_map.borrow().find(queue.get(i)) {\n                 Some(parents) => {\n                     for parent in parents.iter() {\n                         if *parent == sup {\n@@ -391,8 +372,7 @@ impl RegionMaps {\n             let mut result = vec!(scope);\n             let mut scope = scope;\n             loop {\n-                let scope_map = this.scope_map.borrow();\n-                match scope_map.get().find(&scope) {\n+                match this.scope_map.borrow().find(&scope) {\n                     None => return result,\n                     Some(&superscope) => {\n                         result.push(superscope);"}, {"sha": "292111d7fc3e52de495988e96dad1889826a61a2", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 191, "deletions": 350, "changes": 541, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -499,8 +499,7 @@ impl Module {\n     }\n \n     fn all_imports_resolved(&self) -> bool {\n-        let mut imports = self.imports.borrow_mut();\n-        return imports.get().len() == self.resolved_import_count.get();\n+        self.imports.borrow().len() == self.resolved_import_count.get()\n     }\n }\n \n@@ -641,8 +640,7 @@ impl NameBindings {\n \n     /// Returns the module node if applicable.\n     fn get_module_if_available(&self) -> Option<@Module> {\n-        let type_def = self.type_def.borrow();\n-        match *type_def.get() {\n+        match *self.type_def.borrow() {\n             Some(ref type_def) => (*type_def).module_def,\n             None => None\n         }\n@@ -1011,15 +1009,11 @@ impl<'a> Resolver<'a> {\n \n         // Add or reuse the child.\n         let new_parent = ModuleReducedGraphParent(module_);\n-        let child_opt = {\n-            let children = module_.children.borrow();\n-            children.get().find_copy(&name.name)\n-        };\n+        let child_opt = module_.children.borrow().find_copy(&name.name);\n         match child_opt {\n             None => {\n                 let child = @NameBindings();\n-                let mut children = module_.children.borrow_mut();\n-                children.get().insert(name.name, child);\n+                module_.children.borrow_mut().insert(name.name, child);\n                 return (child, new_parent);\n             }\n             Some(child) => {\n@@ -1258,11 +1252,9 @@ impl<'a> Resolver<'a> {\n                     TyPath(ref path, _, _) if path.segments.len() == 1 => {\n                         let name = path_to_ident(path);\n \n-                        let existing_parent_opt = {\n-                            let children = parent.module().children.borrow();\n-                            children.get().find_copy(&name.name)\n-                        };\n-                        let new_parent = match existing_parent_opt {\n+                        let parent_opt = parent.module().children.borrow()\n+                                               .find_copy(&name.name);\n+                        let new_parent = match parent_opt {\n                             // It already exists\n                             Some(child) if child.get_module_if_available()\n                                                 .is_some() &&\n@@ -1393,10 +1385,10 @@ impl<'a> Resolver<'a> {\n                 let def_id = local_def(item.id);\n                 for (name, _) in method_names.iter() {\n                     let mut method_map = self.method_map.borrow_mut();\n-                    if !method_map.get().contains_key(name) {\n-                        method_map.get().insert(*name, HashSet::new());\n+                    if !method_map.contains_key(name) {\n+                        method_map.insert(*name, HashSet::new());\n                     }\n-                    match method_map.get().find_mut(name) {\n+                    match method_map.find_mut(name) {\n                         Some(s) => { s.insert(def_id); },\n                         _ => fail!(\"can't happen\"),\n                     }\n@@ -1530,13 +1522,9 @@ impl<'a> Resolver<'a> {\n                                                           false,\n                                                           true);\n \n-                        {\n-                            let mut external_module_children =\n-                                parent.module().external_module_children.borrow_mut();\n-                            external_module_children.get().insert(\n-                                name.name,\n-                                external_module);\n-                        }\n+                        parent.module().external_module_children\n+                              .borrow_mut().insert(name.name,\n+                                                   external_module);\n \n                         self.build_reduced_graph_for_external_crate(\n                             external_module);\n@@ -1599,12 +1587,9 @@ impl<'a> Resolver<'a> {\n                 AnonymousModuleKind,\n                 false,\n                 false);\n-            {\n-                let mut anonymous_children = parent_module.anonymous_children\n-                                                          .borrow_mut();\n-                anonymous_children.get().insert(block_id, new_module);\n-                ModuleReducedGraphParent(new_module)\n-            }\n+            parent_module.anonymous_children.borrow_mut()\n+                         .insert(block_id, new_module);\n+            ModuleReducedGraphParent(new_module)\n         } else {\n             parent\n         }\n@@ -1711,10 +1696,10 @@ impl<'a> Resolver<'a> {\n               }\n               for name in interned_method_names.iter() {\n                   let mut method_map = self.method_map.borrow_mut();\n-                  if !method_map.get().contains_key(name) {\n-                      method_map.get().insert(*name, HashSet::new());\n+                  if !method_map.contains_key(name) {\n+                      method_map.insert(*name, HashSet::new());\n                   }\n-                  match method_map.get().find_mut(name) {\n+                  match method_map.find_mut(name) {\n                       Some(s) => { s.insert(def_id); },\n                       _ => fail!(\"can't happen\"),\n                   }\n@@ -1959,12 +1944,7 @@ impl<'a> Resolver<'a> {\n         let directive = @ImportDirective::new(module_path,\n                                               subclass, span, id,\n                                               is_public);\n-\n-        {\n-            let mut imports = module_.imports.borrow_mut();\n-            imports.get().push(directive);\n-        }\n-\n+        module_.imports.borrow_mut().push(directive);\n         // Bump the reference count on the name. Or, if this is a glob, set\n         // the appropriate flag.\n \n@@ -1977,7 +1957,7 @@ impl<'a> Resolver<'a> {\n \n                 let mut import_resolutions = module_.import_resolutions\n                                                     .borrow_mut();\n-                match import_resolutions.get().find(&target.name) {\n+                match import_resolutions.find(&target.name) {\n                     Some(&resolution) => {\n                         debug!(\"(building import directive) bumping \\\n                                 reference\");\n@@ -1992,8 +1972,7 @@ impl<'a> Resolver<'a> {\n                         debug!(\"(building import directive) creating new\");\n                         let resolution = @ImportResolution::new(id, is_public);\n                         resolution.outstanding_references.set(1);\n-                        import_resolutions.get().insert(target.name,\n-                                                        resolution);\n+                        import_resolutions.insert(target.name, resolution);\n                     }\n                 }\n             }\n@@ -2052,22 +2031,18 @@ impl<'a> Resolver<'a> {\n         self.resolve_imports_for_module(module_);\n \n         self.populate_module_if_necessary(module_);\n-        {\n-            let children = module_.children.borrow();\n-            for (_, &child_node) in children.get().iter() {\n-                match child_node.get_module_if_available() {\n-                    None => {\n-                        // Nothing to do.\n-                    }\n-                    Some(child_module) => {\n-                        self.resolve_imports_for_module_subtree(child_module);\n-                    }\n+        for (_, &child_node) in module_.children.borrow().iter() {\n+            match child_node.get_module_if_available() {\n+                None => {\n+                    // Nothing to do.\n+                }\n+                Some(child_module) => {\n+                    self.resolve_imports_for_module_subtree(child_module);\n                 }\n             }\n         }\n \n-        let anonymous_children = module_.anonymous_children.borrow();\n-        for (_, &child_module) in anonymous_children.get().iter() {\n+        for (_, &child_module) in module_.anonymous_children.borrow().iter() {\n             self.resolve_imports_for_module_subtree(child_module);\n         }\n     }\n@@ -2082,10 +2057,10 @@ impl<'a> Resolver<'a> {\n         }\n \n         let mut imports = module.imports.borrow_mut();\n-        let import_count = imports.get().len();\n+        let import_count = imports.len();\n         while module.resolved_import_count.get() < import_count {\n             let import_index = module.resolved_import_count.get();\n-            let import_directive = *imports.get().get(import_index);\n+            let import_directive = *imports.get(import_index);\n             match self.resolve_import_for_module(module, import_directive) {\n                 Failed => {\n                     // We presumably emitted an error. Continue.\n@@ -2296,21 +2271,18 @@ impl<'a> Resolver<'a> {\n         // Search for direct children of the containing module.\n         self.populate_module_if_necessary(containing_module);\n \n-        {\n-            let children = containing_module.children.borrow();\n-            match children.get().find(&source.name) {\n-                None => {\n-                    // Continue.\n+        match containing_module.children.borrow().find(&source.name) {\n+            None => {\n+                // Continue.\n+            }\n+            Some(child_name_bindings) => {\n+                if child_name_bindings.defined_in_namespace(ValueNS) {\n+                    value_result = BoundResult(containing_module,\n+                                               *child_name_bindings);\n                 }\n-                Some(child_name_bindings) => {\n-                    if child_name_bindings.defined_in_namespace(ValueNS) {\n-                        value_result = BoundResult(containing_module,\n-                                                   *child_name_bindings);\n-                    }\n-                    if child_name_bindings.defined_in_namespace(TypeNS) {\n-                        type_result = BoundResult(containing_module,\n-                                                  *child_name_bindings);\n-                    }\n+                if child_name_bindings.defined_in_namespace(TypeNS) {\n+                    type_result = BoundResult(containing_module,\n+                                              *child_name_bindings);\n                 }\n             }\n         }\n@@ -2337,7 +2309,7 @@ impl<'a> Resolver<'a> {\n \n                 let import_resolutions = containing_module.import_resolutions\n                                                           .borrow();\n-                match import_resolutions.get().find(&source.name) {\n+                match import_resolutions.find(&source.name) {\n                     None => {\n                         // The containing module definitely doesn't have an\n                         // exported import with the name in question. We can\n@@ -2411,13 +2383,8 @@ impl<'a> Resolver<'a> {\n         match type_result {\n             BoundResult(..) => {}\n             _ => {\n-                let module_opt = {\n-                    let mut external_module_children =\n-                        containing_module.external_module_children\n-                                         .borrow_mut();\n-                    external_module_children.get().find_copy(&source.name)\n-                };\n-                match module_opt {\n+                match containing_module.external_module_children.borrow_mut()\n+                                       .find_copy(&source.name) {\n                     None => {} // Continue.\n                     Some(module) => {\n                         let name_bindings =\n@@ -2434,8 +2401,8 @@ impl<'a> Resolver<'a> {\n         // We've successfully resolved the import. Write the results in.\n         let import_resolution = {\n             let import_resolutions = module_.import_resolutions.borrow();\n-            assert!(import_resolutions.get().contains_key(&target.name));\n-            import_resolutions.get().get_copy(&target.name)\n+            assert!(import_resolutions.contains_key(&target.name));\n+            import_resolutions.get_copy(&target.name)\n         };\n \n         match value_result {\n@@ -2488,8 +2455,7 @@ impl<'a> Resolver<'a> {\n         let value_private = match import_resolution.value_target.get() {\n             Some(target) => {\n                 let def = target.bindings.def_for_namespace(ValueNS).unwrap();\n-                let mut def_map = self.def_map.borrow_mut();\n-                def_map.get().insert(directive.id, def);\n+                self.def_map.borrow_mut().insert(directive.id, def);\n                 let did = def_id_of_def(def);\n                 if value_used_public {Some(lp)} else {Some(DependsOn(did))}\n             },\n@@ -2500,8 +2466,7 @@ impl<'a> Resolver<'a> {\n         let type_private = match import_resolution.type_target.get() {\n             Some(target) => {\n                 let def = target.bindings.def_for_namespace(TypeNS).unwrap();\n-                let mut def_map = self.def_map.borrow_mut();\n-                def_map.get().insert(directive.id, def);\n+                self.def_map.borrow_mut().insert(directive.id, def);\n                 let did = def_id_of_def(def);\n                 if type_used_public {Some(lp)} else {Some(DependsOn(did))}\n             },\n@@ -2545,8 +2510,7 @@ impl<'a> Resolver<'a> {\n         // Add all resolved imports from the containing module.\n         let import_resolutions = containing_module.import_resolutions\n                                                   .borrow();\n-        for (ident, target_import_resolution) in import_resolutions.get()\n-                                                                   .iter() {\n+        for (ident, target_import_resolution) in import_resolutions.iter() {\n             debug!(\"(resolving glob import) writing module resolution \\\n                     {:?} into `{}`\",\n                    target_import_resolution.type_target.get().is_none(),\n@@ -2558,9 +2522,8 @@ impl<'a> Resolver<'a> {\n             }\n \n             // Here we merge two import resolutions.\n-            let mut import_resolutions = module_.import_resolutions\n-                                                .borrow_mut();\n-            match import_resolutions.get().find(ident) {\n+            let mut import_resolutions = module_.import_resolutions.borrow_mut();\n+            match import_resolutions.find(ident) {\n                 None => {\n                     // Simple: just copy the old import resolution.\n                     let new_import_resolution =\n@@ -2570,7 +2533,7 @@ impl<'a> Resolver<'a> {\n                     new_import_resolution.type_target.set(\n                         target_import_resolution.type_target.get());\n \n-                    import_resolutions.get().insert\n+                    import_resolutions.insert\n                         (*ident, new_import_resolution);\n                 }\n                 Some(&dest_import_resolution) => {\n@@ -2603,33 +2566,27 @@ impl<'a> Resolver<'a> {\n         // Add all children from the containing module.\n         self.populate_module_if_necessary(containing_module);\n \n-        {\n-            let children = containing_module.children.borrow();\n-            for (&name, name_bindings) in children.get().iter() {\n-                self.merge_import_resolution(module_, containing_module,\n-                                             id, is_public,\n-                                             name, *name_bindings);\n-            }\n+        for (&name, name_bindings) in containing_module.children\n+                                                       .borrow().iter() {\n+            self.merge_import_resolution(module_, containing_module,\n+                                         id, is_public,\n+                                         name, *name_bindings);\n         }\n \n         // Add external module children from the containing module.\n-        {\n-            let external_module_children =\n-                containing_module.external_module_children.borrow();\n-            for (&name, module) in external_module_children.get().iter() {\n-                let name_bindings =\n-                    @Resolver::create_name_bindings_from_module(*module);\n-                self.merge_import_resolution(module_, containing_module,\n-                                             id, is_public,\n-                                             name, name_bindings);\n-            }\n+        for (&name, module) in containing_module.external_module_children\n+                                                .borrow().iter() {\n+            let name_bindings =\n+                @Resolver::create_name_bindings_from_module(*module);\n+            self.merge_import_resolution(module_, containing_module,\n+                                         id, is_public,\n+                                         name, name_bindings);\n         }\n \n         // Record the destination of this import\n         match containing_module.def_id.get() {\n             Some(did) => {\n-                let mut def_map = self.def_map.borrow_mut();\n-                def_map.get().insert(id, DefMod(did));\n+                self.def_map.borrow_mut().insert(id, DefMod(did));\n                 self.last_private.insert(id, lp);\n             }\n             None => {}\n@@ -2648,12 +2605,12 @@ impl<'a> Resolver<'a> {\n                                name_bindings: @NameBindings) {\n         let dest_import_resolution;\n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-        match import_resolutions.get().find(&name) {\n+        match import_resolutions.find(&name) {\n             None => {\n                 // Create a new import resolution from this child.\n                 dest_import_resolution =\n                     @ImportResolution::new(id, is_public);\n-                import_resolutions.get().insert(name,\n+                import_resolutions.insert(name,\n                                                 dest_import_resolution);\n             }\n             Some(&existing_import_resolution) => {\n@@ -2919,25 +2876,21 @@ impl<'a> Resolver<'a> {\n         // its immediate children.\n         self.populate_module_if_necessary(module_);\n \n-        {\n-            let children = module_.children.borrow();\n-            match children.get().find(&name.name) {\n-                Some(name_bindings)\n-                        if name_bindings.defined_in_namespace(namespace) => {\n-                    debug!(\"top name bindings succeeded\");\n-                    return Success((Target::new(module_, *name_bindings),\n-                                   false));\n-                }\n-                Some(_) | None => { /* Not found; continue. */ }\n+        match module_.children.borrow().find(&name.name) {\n+            Some(name_bindings)\n+                    if name_bindings.defined_in_namespace(namespace) => {\n+                debug!(\"top name bindings succeeded\");\n+                return Success((Target::new(module_, *name_bindings),\n+                               false));\n             }\n+            Some(_) | None => { /* Not found; continue. */ }\n         }\n \n         // Now check for its import directives. We don't have to have resolved\n         // all its imports in the usual way; this is because chains of\n         // adjacent import statements are processed as though they mutated the\n         // current scope.\n-        let import_resolutions = module_.import_resolutions.borrow();\n-        match import_resolutions.get().find(&name.name) {\n+        match module_.import_resolutions.borrow().find(&name.name) {\n             None => {\n                 // Not found; continue.\n             }\n@@ -2961,12 +2914,7 @@ impl<'a> Resolver<'a> {\n \n         // Search for external modules.\n         if namespace == TypeNS {\n-            let module_opt = {\n-                let external_module_children =\n-                    module_.external_module_children.borrow();\n-                external_module_children.get().find_copy(&name.name)\n-            };\n-            match module_opt {\n+            match module_.external_module_children.borrow().find_copy(&name.name) {\n                 None => {}\n                 Some(module) => {\n                     let name_bindings =\n@@ -3195,18 +3143,15 @@ impl<'a> Resolver<'a> {\n         // First, check the direct children of the module.\n         self.populate_module_if_necessary(module_);\n \n-        {\n-            let children = module_.children.borrow();\n-            match children.get().find(&name.name) {\n-                Some(name_bindings)\n-                        if name_bindings.defined_in_namespace(namespace) => {\n-                    debug!(\"(resolving name in module) found node as child\");\n-                    return Success((Target::new(module_, *name_bindings),\n-                                   false));\n-                }\n-                Some(_) | None => {\n-                    // Continue.\n-                }\n+        match module_.children.borrow().find(&name.name) {\n+            Some(name_bindings)\n+                    if name_bindings.defined_in_namespace(namespace) => {\n+                debug!(\"(resolving name in module) found node as child\");\n+                return Success((Target::new(module_, *name_bindings),\n+                               false));\n+            }\n+            Some(_) | None => {\n+                // Continue.\n             }\n         }\n \n@@ -3219,8 +3164,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Check the list of resolved imports.\n-        let import_resolutions = module_.import_resolutions.borrow();\n-        match import_resolutions.get().find(&name.name) {\n+        match module_.import_resolutions.borrow().find(&name.name) {\n             Some(import_resolution) => {\n                 if import_resolution.is_public.get() &&\n                         import_resolution.outstanding_references.get() != 0 {\n@@ -3247,12 +3191,7 @@ impl<'a> Resolver<'a> {\n \n         // Finally, search through external children.\n         if namespace == TypeNS {\n-            let module_opt = {\n-                let external_module_children =\n-                    module_.external_module_children.borrow();\n-                external_module_children.get().find_copy(&name.name)\n-            };\n-            match module_opt {\n+            match module_.external_module_children.borrow().find_copy(&name.name) {\n                 None => {}\n                 Some(module) => {\n                     let name_bindings =\n@@ -3270,42 +3209,38 @@ impl<'a> Resolver<'a> {\n \n     fn report_unresolved_imports(&mut self, module_: @Module) {\n         let index = module_.resolved_import_count.get();\n-        let mut imports = module_.imports.borrow_mut();\n-        let import_count = imports.get().len();\n+        let imports = module_.imports.borrow();\n+        let import_count = imports.len();\n         if index != import_count {\n             let sn = self.session\n                          .codemap()\n-                         .span_to_snippet(imports.get().get(index).span)\n+                         .span_to_snippet(imports.get(index).span)\n                          .unwrap();\n             if sn.contains(\"::\") {\n-                self.resolve_error(imports.get().get(index).span,\n+                self.resolve_error(imports.get(index).span,\n                                    \"unresolved import\");\n             } else {\n                 let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n                                sn.slice(0, sn.len()));\n-                self.resolve_error(imports.get().get(index).span, err);\n+                self.resolve_error(imports.get(index).span, err);\n             }\n         }\n \n         // Descend into children and anonymous children.\n         self.populate_module_if_necessary(module_);\n \n-        {\n-            let children = module_.children.borrow();\n-            for (_, &child_node) in children.get().iter() {\n-                match child_node.get_module_if_available() {\n-                    None => {\n-                        // Continue.\n-                    }\n-                    Some(child_module) => {\n-                        self.report_unresolved_imports(child_module);\n-                    }\n+        for (_, &child_node) in module_.children.borrow().iter() {\n+            match child_node.get_module_if_available() {\n+                None => {\n+                    // Continue.\n+                }\n+                Some(child_module) => {\n+                    self.report_unresolved_imports(child_module);\n                 }\n             }\n         }\n \n-        let anonymous_children = module_.anonymous_children.borrow();\n-        for (_, &module_) in anonymous_children.get().iter() {\n+        for (_, &module_) in module_.anonymous_children.borrow().iter() {\n             self.report_unresolved_imports(module_);\n         }\n     }\n@@ -3354,22 +3289,18 @@ impl<'a> Resolver<'a> {\n         self.record_exports_for_module(module_);\n         self.populate_module_if_necessary(module_);\n \n-        {\n-            let children = module_.children.borrow();\n-            for (_, &child_name_bindings) in children.get().iter() {\n-                match child_name_bindings.get_module_if_available() {\n-                    None => {\n-                        // Nothing to do.\n-                    }\n-                    Some(child_module) => {\n-                        self.record_exports_for_module_subtree(child_module);\n-                    }\n+        for (_, &child_name_bindings) in module_.children.borrow().iter() {\n+            match child_name_bindings.get_module_if_available() {\n+                None => {\n+                    // Nothing to do.\n+                }\n+                Some(child_module) => {\n+                    self.record_exports_for_module_subtree(child_module);\n                 }\n             }\n         }\n \n-        let anonymous_children = module_.anonymous_children.borrow();\n-        for (_, &child_module) in anonymous_children.get().iter() {\n+        for (_, &child_module) in module_.anonymous_children.borrow().iter() {\n             self.record_exports_for_module_subtree(child_module);\n         }\n     }\n@@ -3380,8 +3311,7 @@ impl<'a> Resolver<'a> {\n         self.add_exports_for_module(&mut exports2, module_);\n         match module_.def_id.get() {\n             Some(def_id) => {\n-                let mut export_map2 = self.export_map2.borrow_mut();\n-                export_map2.get().insert(def_id.node, exports2);\n+                self.export_map2.borrow_mut().insert(def_id.node, exports2);\n                 debug!(\"(computing exports) writing exports for {} (some)\",\n                        def_id.node);\n             }\n@@ -3413,8 +3343,7 @@ impl<'a> Resolver<'a> {\n     fn add_exports_for_module(&mut self,\n                               exports2: &mut Vec<Export2> ,\n                               module_: @Module) {\n-        let import_resolutions = module_.import_resolutions.borrow();\n-        for (name, importresolution) in import_resolutions.get().iter() {\n+        for (name, importresolution) in module_.import_resolutions.borrow().iter() {\n             if !importresolution.is_public.get() {\n                 continue\n             }\n@@ -3464,8 +3393,7 @@ impl<'a> Resolver<'a> {\n             Some(name) => {\n                 self.populate_module_if_necessary(orig_module);\n \n-                let children = orig_module.children.borrow();\n-                match children.get().find(&name.name) {\n+                match orig_module.children.borrow().find(&name.name) {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `{}` in `{}`\",\n                                token::get_ident(name),\n@@ -3538,8 +3466,7 @@ impl<'a> Resolver<'a> {\n                   // item, it's ok\n                   match def {\n                     DefTyParam(did, _) if {\n-                        let def_map = self.def_map.borrow();\n-                        def_map.get().find(&did.node).map(|x| *x)\n+                        self.def_map.borrow().find(&did.node).map(|x| *x)\n                             == Some(DefTyParamBinder(item_id))\n                     } => {\n                       // ok\n@@ -3621,10 +3548,7 @@ impl<'a> Resolver<'a> {\n         let mut i = ribs.len();\n         while i != 0 {\n             i -= 1;\n-            let binding_opt = {\n-                let bindings = ribs.get(i).bindings.borrow();\n-                bindings.get().find_copy(&name)\n-            };\n+            let binding_opt = ribs.get(i).bindings.borrow().find_copy(&name);\n             match binding_opt {\n                 Some(def_like) => {\n                     return self.upvarify(ribs, i, def_like, span);\n@@ -3699,16 +3623,11 @@ impl<'a> Resolver<'a> {\n             ItemTrait(ref generics, ref traits, ref methods) => {\n                 // Create a new rib for the self type.\n                 let self_type_rib = @Rib::new(NormalRibKind);\n-                {\n-                    let mut type_ribs = self.type_ribs.borrow_mut();\n-                    type_ribs.get().push(self_type_rib);\n-                }\n+                self.type_ribs.borrow_mut().push(self_type_rib);\n                 // plain insert (no renaming)\n                 let name = self.type_self_ident.name;\n-                {\n-                    let mut bindings = self_type_rib.bindings.borrow_mut();\n-                    bindings.get().insert(name, DlDef(DefSelfTy(item.id)));\n-                }\n+                self_type_rib.bindings.borrow_mut()\n+                             .insert(name, DlDef(DefSelfTy(item.id)));\n \n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_type_parameter_rib(HasTypeParameters(generics,\n@@ -3760,8 +3679,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 });\n \n-                let mut type_ribs = self.type_ribs.borrow_mut();\n-                type_ribs.get().pop();\n+                self.type_ribs.borrow_mut().pop();\n             }\n \n             ItemStruct(ref struct_def, ref generics) => {\n@@ -3831,10 +3749,7 @@ impl<'a> Resolver<'a> {\n                               rib_kind) => {\n \n                 let function_type_rib = @Rib::new(rib_kind);\n-                {\n-                    let mut type_ribs = self.type_ribs.borrow_mut();\n-                    type_ribs.get().push(function_type_rib);\n-                }\n+                self.type_ribs.borrow_mut().push(function_type_rib);\n \n                 for (index, type_parameter) in generics.ty_params.iter().enumerate() {\n                     let ident = type_parameter.ident;\n@@ -3848,9 +3763,8 @@ impl<'a> Resolver<'a> {\n                     self.record_def(type_parameter.id,\n                                     (DefTyParamBinder(node_id), LastMod(AllPublic)));\n                     // plain insert (no renaming)\n-                    let mut bindings = function_type_rib.bindings\n-                                                        .borrow_mut();\n-                    bindings.get().insert(ident.name, def_like);\n+                    function_type_rib.bindings.borrow_mut()\n+                                     .insert(ident.name, def_like);\n                 }\n             }\n \n@@ -3862,45 +3776,23 @@ impl<'a> Resolver<'a> {\n         f(self);\n \n         match type_parameters {\n-            HasTypeParameters(..) => {\n-                let mut type_ribs = self.type_ribs.borrow_mut();\n-                type_ribs.get().pop();\n-            }\n-\n-            NoTypeParameters => {\n-                // Nothing to do.\n-            }\n+            HasTypeParameters(..) => { self.type_ribs.borrow_mut().pop(); }\n+            NoTypeParameters => { }\n         }\n     }\n \n     fn with_label_rib(&mut self, f: |&mut Resolver|) {\n-        {\n-            let mut label_ribs = self.label_ribs.borrow_mut();\n-            label_ribs.get().push(@Rib::new(NormalRibKind));\n-        }\n-\n+        self.label_ribs.borrow_mut().push(@Rib::new(NormalRibKind));\n         f(self);\n-\n-        {\n-            let mut label_ribs = self.label_ribs.borrow_mut();\n-            label_ribs.get().pop();\n-        }\n+        self.label_ribs.borrow_mut().pop();\n     }\n \n     fn with_constant_rib(&mut self, f: |&mut Resolver|) {\n-        {\n-            let mut value_ribs = self.value_ribs.borrow_mut();\n-            let mut type_ribs = self.type_ribs.borrow_mut();\n-            value_ribs.get().push(@Rib::new(ConstantItemRibKind));\n-            type_ribs.get().push(@Rib::new(ConstantItemRibKind));\n-        }\n+        self.value_ribs.borrow_mut().push(@Rib::new(ConstantItemRibKind));\n+        self.type_ribs.borrow_mut().push(@Rib::new(ConstantItemRibKind));\n         f(self);\n-        {\n-            let mut value_ribs = self.value_ribs.borrow_mut();\n-            let mut type_ribs = self.type_ribs.borrow_mut();\n-            type_ribs.get().pop();\n-            value_ribs.get().pop();\n-        }\n+        self.type_ribs.borrow_mut().pop();\n+        self.value_ribs.borrow_mut().pop();\n     }\n \n     fn resolve_function(&mut self,\n@@ -3910,17 +3802,11 @@ impl<'a> Resolver<'a> {\n                         block: P<Block>) {\n         // Create a value rib for the function.\n         let function_value_rib = @Rib::new(rib_kind);\n-        {\n-            let mut value_ribs = self.value_ribs.borrow_mut();\n-            value_ribs.get().push(function_value_rib);\n-        }\n+        self.value_ribs.borrow_mut().push(function_value_rib);\n \n         // Create a label rib for the function.\n-        {\n-            let mut label_ribs = self.label_ribs.borrow_mut();\n-            let function_label_rib = @Rib::new(rib_kind);\n-            label_ribs.get().push(function_label_rib);\n-        }\n+        let function_label_rib = @Rib::new(rib_kind);\n+        self.label_ribs.borrow_mut().push(function_label_rib);\n \n         // If this function has type parameters, add them now.\n         self.with_type_parameter_rib(type_parameters, |this| {\n@@ -3961,11 +3847,8 @@ impl<'a> Resolver<'a> {\n             debug!(\"(resolving function) leaving function\");\n         });\n \n-        let mut label_ribs = self.label_ribs.borrow_mut();\n-        label_ribs.get().pop();\n-\n-        let mut value_ribs = self.value_ribs.borrow_mut();\n-        value_ribs.get().pop();\n+        self.label_ribs.borrow_mut().pop();\n+        self.value_ribs.borrow_mut().pop();\n     }\n \n     fn resolve_type_parameters(&mut self,\n@@ -4097,12 +3980,9 @@ impl<'a> Resolver<'a> {\n \n                     // Record the current set of trait references.\n                     let mut new_trait_refs = Vec::new();\n-                    {\n-                        let def_map = this.def_map.borrow();\n-                        let r = def_map.get().find(&trait_reference.ref_id);\n-                        for &def in r.iter() {\n-                            new_trait_refs.push(def_id_of_def(*def));\n-                        }\n+                    for &def in this.def_map.borrow()\n+                                    .find(&trait_reference.ref_id).iter() {\n+                        new_trait_refs.push(def_id_of_def(*def));\n                     }\n                     original_trait_refs = Some(replace(\n                         &mut this.current_trait_refs,\n@@ -4234,10 +4114,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_arm(&mut self, arm: &Arm) {\n-        {\n-            let mut value_ribs = self.value_ribs.borrow_mut();\n-            value_ribs.get().push(@Rib::new(NormalRibKind));\n-        }\n+        self.value_ribs.borrow_mut().push(@Rib::new(NormalRibKind));\n \n         let mut bindings_list = HashMap::new();\n         for pattern in arm.pats.iter() {\n@@ -4253,23 +4130,19 @@ impl<'a> Resolver<'a> {\n         visit::walk_expr_opt(self, arm.guard, ());\n         self.resolve_expr(arm.body);\n \n-        let mut value_ribs = self.value_ribs.borrow_mut();\n-        value_ribs.get().pop();\n+        self.value_ribs.borrow_mut().pop();\n     }\n \n     fn resolve_block(&mut self, block: &Block) {\n         debug!(\"(resolving block) entering block\");\n-        {\n-            let mut value_ribs = self.value_ribs.borrow_mut();\n-            value_ribs.get().push(@Rib::new(NormalRibKind));\n-        }\n+        self.value_ribs.borrow_mut().push(@Rib::new(NormalRibKind));\n \n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module;\n         let anonymous_children = self.current_module\n                                      .anonymous_children\n                                      .borrow();\n-        match anonymous_children.get().find(&block.id) {\n+        match anonymous_children.find(&block.id) {\n             None => { /* Nothing to do. */ }\n             Some(&anonymous_module) => {\n                 debug!(\"(resolving block) found anonymous module, moving \\\n@@ -4284,8 +4157,7 @@ impl<'a> Resolver<'a> {\n         // Move back up.\n         self.current_module = orig_module;\n \n-        let mut value_ribs = self.value_ribs.borrow_mut();\n-        value_ribs.get().pop();\n+        self.value_ribs.borrow_mut().pop();\n         debug!(\"(resolving block) leaving block\");\n     }\n \n@@ -4490,17 +4362,12 @@ impl<'a> Resolver<'a> {\n                                 Some(ref mut bindings_list)\n                                 if !bindings_list.contains_key(&renamed) => {\n                                     let this = &mut *self;\n-                                    {\n-                                        let mut value_ribs =\n-                                            this.value_ribs.borrow_mut();\n-                                        let length = value_ribs.get().len();\n-                                        let last_rib = value_ribs.get().get(\n-                                            length - 1);\n-                                        let mut bindings =\n-                                            last_rib.bindings.borrow_mut();\n-                                        bindings.get().insert(renamed,\n-                                                              DlDef(def));\n-                                    }\n+                                    let value_ribs = this.value_ribs.borrow();\n+                                    let length = value_ribs.len();\n+                                    let last_rib = value_ribs.get(\n+                                        length - 1);\n+                                    last_rib.bindings.borrow_mut()\n+                                            .insert(renamed, DlDef(def));\n                                     bindings_list.insert(renamed, pat_id);\n                                 }\n                                 Some(ref mut b) => {\n@@ -4518,15 +4385,12 @@ impl<'a> Resolver<'a> {\n                                 None => {\n                                     let this = &mut *self;\n                                     {\n-                                        let mut value_ribs =\n-                                            this.value_ribs.borrow_mut();\n-                                        let length = value_ribs.get().len();\n-                                        let last_rib = value_ribs.get().get(\n+                                        let value_ribs = this.value_ribs.borrow();\n+                                        let length = value_ribs.len();\n+                                        let last_rib = value_ribs.get(\n                                                 length - 1);\n-                                        let mut bindings =\n-                                            last_rib.bindings.borrow_mut();\n-                                        bindings.get().insert(renamed,\n-                                                              DlDef(def));\n+                                        last_rib.bindings.borrow_mut()\n+                                                .insert(renamed, DlDef(def));\n                                     }\n                                 }\n                             }\n@@ -4774,31 +4638,26 @@ impl<'a> Resolver<'a> {\n         // First, search children.\n         self.populate_module_if_necessary(containing_module);\n \n-        {\n-            let children = containing_module.children.borrow();\n-            match children.get().find(&name.name) {\n-                Some(child_name_bindings) => {\n-                    match child_name_bindings.def_for_namespace(namespace) {\n-                        Some(def) => {\n-                            // Found it. Stop the search here.\n-                            let p = child_name_bindings.defined_in_public_namespace(\n-                                            namespace);\n-                            let lp = if p {LastMod(AllPublic)} else {\n-                                LastMod(DependsOn(def_id_of_def(def)))\n-                            };\n-                            return ChildNameDefinition(def, lp);\n-                        }\n-                        None => {}\n+        match containing_module.children.borrow().find(&name.name) {\n+            Some(child_name_bindings) => {\n+                match child_name_bindings.def_for_namespace(namespace) {\n+                    Some(def) => {\n+                        // Found it. Stop the search here.\n+                        let p = child_name_bindings.defined_in_public_namespace(\n+                                        namespace);\n+                        let lp = if p {LastMod(AllPublic)} else {\n+                            LastMod(DependsOn(def_id_of_def(def)))\n+                        };\n+                        return ChildNameDefinition(def, lp);\n                     }\n+                    None => {}\n                 }\n-                None => {}\n             }\n+            None => {}\n         }\n \n         // Next, search import resolutions.\n-        let import_resolutions = containing_module.import_resolutions\n-                                                  .borrow();\n-        match import_resolutions.get().find(&name.name) {\n+        match containing_module.import_resolutions.borrow().find(&name.name) {\n             Some(import_resolution) if import_resolution.is_public.get() => {\n                 match (*import_resolution).target_for_namespace(namespace) {\n                     Some(target) => {\n@@ -4823,12 +4682,8 @@ impl<'a> Resolver<'a> {\n \n         // Finally, search through external children.\n         if namespace == TypeNS {\n-            let module_opt = {\n-                let external_module_children =\n-                    containing_module.external_module_children.borrow();\n-                external_module_children.get().find_copy(&name.name)\n-            };\n-            match module_opt {\n+            match containing_module.external_module_children.borrow()\n+                                   .find_copy(&name.name) {\n                 None => {}\n                 Some(module) => {\n                     match module.def_id.get() {\n@@ -4892,8 +4747,7 @@ impl<'a> Resolver<'a> {\n         };\n         match containing_module.kind.get() {\n             TraitModuleKind | ImplModuleKind => {\n-                let method_map = self.method_map.borrow();\n-                match method_map.get().find(&ident.name) {\n+                match self.method_map.borrow().find(&ident.name) {\n                     Some(s) => {\n                         match containing_module.def_id.get() {\n                             Some(def_id) if s.contains(&def_id) => {\n@@ -4967,23 +4821,17 @@ impl<'a> Resolver<'a> {\n                                             span: Span)\n                                             -> Option<Def> {\n         // Check the local set of ribs.\n-        let search_result;\n-        match namespace {\n+        let search_result = match namespace {\n             ValueNS => {\n                 let renamed = mtwt::resolve(ident);\n-                let mut value_ribs = self.value_ribs.borrow_mut();\n-                search_result = self.search_ribs(value_ribs.get(),\n-                                                 renamed,\n-                                                 span);\n+                self.search_ribs(&mut *self.value_ribs.borrow_mut(),\n+                                 renamed, span)\n             }\n             TypeNS => {\n                 let name = ident.name;\n-                let mut type_ribs = self.type_ribs.borrow_mut();\n-                search_result = self.search_ribs(type_ribs.get(),\n-                                                 name,\n-                                                 span);\n+                self.search_ribs(&mut *self.type_ribs.borrow_mut(), name, span)\n             }\n-        }\n+        };\n \n         match search_result {\n             Some(DlDef(def)) => {\n@@ -5060,15 +4908,12 @@ impl<'a> Resolver<'a> {\n         let mut maybes: Vec<token::InternedString> = Vec::new();\n         let mut values: Vec<uint> = Vec::new();\n \n-        let mut j = {\n-            let value_ribs = this.value_ribs.borrow();\n-            value_ribs.get().len()\n-        };\n+        let mut j = this.value_ribs.borrow().len();\n         while j != 0 {\n             j -= 1;\n             let value_ribs = this.value_ribs.borrow();\n-            let bindings = value_ribs.get().get(j).bindings.borrow();\n-            for (&k, _) in bindings.get().iter() {\n+            let bindings = value_ribs.get(j).bindings.borrow();\n+            for (&k, _) in bindings.iter() {\n                 maybes.push(token::get_name(k));\n                 values.push(uint::MAX);\n             }\n@@ -5213,13 +5058,13 @@ impl<'a> Resolver<'a> {\n             ExprLoop(_, Some(label)) => {\n                 self.with_label_rib(|this| {\n                     let def_like = DlDef(DefLabel(expr.id));\n+\n                     {\n-                        let mut label_ribs = this.label_ribs.borrow_mut();\n-                        let length = label_ribs.get().len();\n-                        let rib = label_ribs.get().get(length - 1);\n-                        let mut bindings = rib.bindings.borrow_mut();\n+                        let label_ribs = this.label_ribs.borrow();\n+                        let length = label_ribs.len();\n+                        let rib = label_ribs.get(length - 1);\n                         let renamed = mtwt::resolve(label);\n-                        bindings.get().insert(renamed, def_like);\n+                        rib.bindings.borrow_mut().insert(renamed, def_like);\n                     }\n \n                     visit::walk_expr(this, expr, ());\n@@ -5231,7 +5076,7 @@ impl<'a> Resolver<'a> {\n             ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n                 let mut label_ribs = self.label_ribs.borrow_mut();\n                 let renamed = mtwt::resolve(label);\n-                match self.search_ribs(label_ribs.get(), renamed, expr.span) {\n+                match self.search_ribs(&mut *label_ribs, renamed, expr.span) {\n                     None =>\n                         self.resolve_error(expr.span,\n                                               format!(\"use of undeclared label `{}`\",\n@@ -5283,8 +5128,7 @@ impl<'a> Resolver<'a> {\n \n         let mut found_traits = Vec::new();\n         let mut search_module = self.current_module;\n-        let method_map = self.method_map.borrow();\n-        match method_map.get().find(&name.name) {\n+        match self.method_map.borrow().find(&name.name) {\n             Some(candidate_traits) => loop {\n                 // Look for the current trait.\n                 match self.current_trait_refs {\n@@ -5305,8 +5149,7 @@ impl<'a> Resolver<'a> {\n                 // Look for trait children.\n                 self.populate_module_if_necessary(search_module);\n \n-                let children = search_module.children.borrow();\n-                for (_, &child_names) in children.get().iter() {\n+                for (_, &child_names) in search_module.children.borrow().iter() {\n                     let def = match child_names.def_for_namespace(TypeNS) {\n                         Some(def) => def,\n                         None => continue\n@@ -5324,7 +5167,7 @@ impl<'a> Resolver<'a> {\n                 // Look for imports.\n                 let import_resolutions = search_module.import_resolutions\n                                                       .borrow();\n-                for (_, &import) in import_resolutions.get().iter() {\n+                for (_, &import) in import_resolutions.iter() {\n                     let target = match import.target_for_namespace(TypeNS) {\n                         None => continue,\n                         Some(target) => target,\n@@ -5369,8 +5212,7 @@ impl<'a> Resolver<'a> {\n         assert!(match lp {LastImport{..} => false, _ => true},\n                 \"Import should only be used for `use` directives\");\n         self.last_private.insert(node_id, lp);\n-        let mut def_map = self.def_map.borrow_mut();\n-        def_map.get().insert_or_update_with(node_id, def, |_, old_value| {\n+        self.def_map.borrow_mut().insert_or_update_with(node_id, def, |_, old_value| {\n             // Resolve appears to \"resolve\" the same ID multiple\n             // times, so here is a sanity check it at least comes to\n             // the same conclusion! - nmatsakis\n@@ -5531,14 +5373,13 @@ impl<'a> Resolver<'a> {\n \n         debug!(\"Children:\");\n         self.populate_module_if_necessary(module_);\n-        let children = module_.children.borrow();\n-        for (&name, _) in children.get().iter() {\n+        for (&name, _) in module_.children.borrow().iter() {\n             debug!(\"* {}\", token::get_name(name));\n         }\n \n         debug!(\"Import resolutions:\");\n         let import_resolutions = module_.import_resolutions.borrow();\n-        for (&name, import_resolution) in import_resolutions.get().iter() {\n+        for (&name, import_resolution) in import_resolutions.iter() {\n             let value_repr;\n             match import_resolution.target_for_namespace(ValueNS) {\n                 None => { value_repr = ~\"\"; }"}, {"sha": "39a0597a5da1995c499f316b1d0e5df02e9c3f9c", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 22, "deletions": 41, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -355,8 +355,8 @@ fn trans_opt<'a>(bcx: &'a Block<'a>, o: &Opt) -> opt_result<'a> {\n \n fn variant_opt(bcx: &Block, pat_id: ast::NodeId) -> Opt {\n     let ccx = bcx.ccx();\n-    let def_map = ccx.tcx.def_map.borrow();\n-    match def_map.get().get_copy(&pat_id) {\n+    let def = ccx.tcx.def_map.borrow().get_copy(&pat_id);\n+    match def {\n         ast::DefVariant(enum_id, var_id, _) => {\n             let variants = ty::enum_variants(ccx.tcx(), enum_id);\n             for v in (*variants).iter() {\n@@ -636,10 +636,7 @@ fn enter_opt<'r,'b>(\n         let answer = match p.node {\n             ast::PatEnum(..) |\n             ast::PatIdent(_, _, None) if pat_is_const(tcx.def_map, p) => {\n-                let const_def = {\n-                    let def_map = tcx.def_map.borrow();\n-                    def_map.get().get_copy(&p.id)\n-                };\n+                let const_def = tcx.def_map.borrow().get_copy(&p.id);\n                 let const_def_id = ast_util::def_id_of_def(const_def);\n                 if opt_eq(tcx, &lit(ConstLit(const_def_id)), opt) {\n                     Some(Vec::new())\n@@ -678,11 +675,7 @@ fn enter_opt<'r,'b>(\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     // Look up the struct variant ID.\n                     let struct_id;\n-                    let defn = {\n-                        let def_map = tcx.def_map.borrow();\n-                        def_map.get().get_copy(&p.id)\n-                    };\n-                    match defn {\n+                    match tcx.def_map.borrow().get_copy(&p.id) {\n                         ast::DefVariant(_, found_struct_id, _) => {\n                             struct_id = found_struct_id;\n                         }\n@@ -964,10 +957,7 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n             ast::PatIdent(..) => {\n                 // This is one of: an enum variant, a unit-like struct, or a\n                 // variable binding.\n-                let opt_def = {\n-                    let def_map = ccx.tcx.def_map.borrow();\n-                    def_map.get().find_copy(&cur.id)\n-                };\n+                let opt_def = ccx.tcx.def_map.borrow().find_copy(&cur.id);\n                 match opt_def {\n                     Some(ast::DefVariant(..)) => {\n                         add_to_set(ccx.tcx(), &mut found,\n@@ -987,10 +977,7 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n             ast::PatEnum(..) | ast::PatStruct(..) => {\n                 // This could be one of: a tuple-like enum variant, a\n                 // struct-like enum variant, or a struct.\n-                let opt_def = {\n-                    let def_map = ccx.tcx.def_map.borrow();\n-                    def_map.get().find_copy(&cur.id)\n-                };\n+                let opt_def = ccx.tcx.def_map.borrow().find_copy(&cur.id);\n                 match opt_def {\n                     Some(ast::DefFn(..)) |\n                     Some(ast::DefVariant(..)) => {\n@@ -1147,8 +1134,7 @@ fn pats_require_rooting(bcx: &Block, m: &[Match], col: uint) -> bool {\n     m.iter().any(|br| {\n         let pat_id = br.pats.get(col).id;\n         let key = root_map_key {id: pat_id, derefs: 0u };\n-        let root_map = bcx.ccx().maps.root_map.borrow();\n-        root_map.get().contains_key(&key)\n+        bcx.ccx().maps.root_map.borrow().contains_key(&key)\n     })\n }\n \n@@ -1184,8 +1170,7 @@ fn any_tuple_struct_pat(bcx: &Block, m: &[Match], col: uint) -> bool {\n         let pat = *br.pats.get(col);\n         match pat.node {\n             ast::PatEnum(_, Some(_)) => {\n-                let def_map = bcx.tcx().def_map.borrow();\n-                match def_map.get().find(&pat.id) {\n+                match bcx.tcx().def_map.borrow().find(&pat.id) {\n                     Some(&ast::DefFn(..)) |\n                     Some(&ast::DefStruct(..)) => true,\n                     _ => false\n@@ -1387,13 +1372,10 @@ fn insert_lllocals<'a>(bcx: &'a Block<'a>,\n         let datum = Datum(llval, binding_info.ty, Lvalue);\n         fcx.schedule_drop_mem(cleanup_scope, llval, binding_info.ty);\n \n-        {\n-            debug!(\"binding {:?} to {}\",\n-                   binding_info.id,\n-                   bcx.val_to_str(llval));\n-            let mut llmap = bcx.fcx.lllocals.borrow_mut();\n-            llmap.get().insert(binding_info.id, datum);\n-        }\n+        debug!(\"binding {:?} to {}\",\n+               binding_info.id,\n+               bcx.val_to_str(llval));\n+        bcx.fcx.lllocals.borrow_mut().insert(binding_info.id, datum);\n \n         if bcx.sess().opts.debuginfo == FullDebugInfo {\n             debuginfo::create_match_binding_metadata(bcx,\n@@ -1458,8 +1440,7 @@ fn compile_guard<'r,\n                 }\n                 TrByRef => {}\n             }\n-            let mut lllocals = bcx.fcx.lllocals.borrow_mut();\n-            lllocals.get().remove(&binding_info.id);\n+            bcx.fcx.lllocals.borrow_mut().remove(&binding_info.id);\n         }\n         return bcx;\n     }\n@@ -2096,8 +2077,8 @@ pub fn store_arg<'a>(mut bcx: &'a Block<'a>,\n                 // already put it in a temporary alloca and gave it up, unless\n                 // we emit extra-debug-info, which requires local allocas :(.\n                 let arg_val = arg.add_clean(bcx.fcx, arg_scope);\n-                let mut llmap = bcx.fcx.llargs.borrow_mut();\n-                llmap.get().insert(pat.id, Datum(arg_val, arg_ty, Lvalue));\n+                bcx.fcx.llargs.borrow_mut()\n+                   .insert(pat.id, Datum(arg_val, arg_ty, Lvalue));\n                 bcx\n             } else {\n                 mk_binding_alloca(\n@@ -2143,7 +2124,7 @@ fn mk_binding_alloca<'a,A>(bcx: &'a Block<'a>,\n         BindLocal => bcx.fcx.lllocals.borrow_mut(),\n         BindArgument => bcx.fcx.llargs.borrow_mut()\n     };\n-    llmap.get().insert(p_id, datum);\n+    llmap.insert(p_id, datum);\n     bcx\n }\n \n@@ -2219,9 +2200,9 @@ fn bind_irrefutable_pat<'a>(\n             }\n         }\n         ast::PatEnum(_, ref sub_pats) => {\n-            let def_map = bcx.tcx().def_map.borrow();\n-            match def_map.get().find(&pat.id) {\n-                Some(&ast::DefVariant(enum_id, var_id, _)) => {\n+            let opt_def = bcx.tcx().def_map.borrow().find_copy(&pat.id);\n+            match opt_def {\n+                Some(ast::DefVariant(enum_id, var_id, _)) => {\n                     let repr = adt::represent_node(bcx, pat.id);\n                     let vinfo = ty::enum_variant_with_id(ccx.tcx(),\n                                                          enum_id,\n@@ -2238,8 +2219,8 @@ fn bind_irrefutable_pat<'a>(\n                         }\n                     }\n                 }\n-                Some(&ast::DefFn(..)) |\n-                Some(&ast::DefStruct(..)) => {\n+                Some(ast::DefFn(..)) |\n+                Some(ast::DefStruct(..)) => {\n                     match *sub_pats {\n                         None => {\n                             // This is a unit-like struct. Nothing to do here.\n@@ -2257,7 +2238,7 @@ fn bind_irrefutable_pat<'a>(\n                         }\n                     }\n                 }\n-                Some(&ast::DefStatic(_, false)) => {\n+                Some(ast::DefStatic(_, false)) => {\n                 }\n                 _ => {\n                     // Nothing to do here."}, {"sha": "1215eba17d7bbd149e985d45d05cc7c0c8183e97", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -118,18 +118,14 @@ pub fn represent_node(bcx: &Block, node: ast::NodeId) -> @Repr {\n /// Decides how to represent a given type.\n pub fn represent_type(cx: &CrateContext, t: ty::t) -> @Repr {\n     debug!(\"Representing: {}\", ty_to_str(cx.tcx(), t));\n-    {\n-        let adt_reprs = cx.adt_reprs.borrow();\n-        match adt_reprs.get().find(&t) {\n-            Some(repr) => return *repr,\n-            None => {}\n-        }\n+    match cx.adt_reprs.borrow().find(&t) {\n+        Some(repr) => return *repr,\n+        None => {}\n     }\n \n     let repr = @represent_type_uncached(cx, t);\n     debug!(\"Represented as: {:?}\", repr)\n-    let mut adt_reprs = cx.adt_reprs.borrow_mut();\n-    adt_reprs.get().insert(t, repr);\n+    cx.adt_reprs.borrow_mut().insert(t, repr);\n     return repr;\n }\n "}, {"sha": "c9cc1eedf394196f96b069afca5c4c676f41ad0b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 214, "deletions": 252, "changes": 466, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -161,12 +161,9 @@ impl<'a> Drop for StatRecorder<'a> {\n             let end = time::precise_time_ns();\n             let elapsed = ((end - self.start) / 1_000_000) as uint;\n             let iend = self.ccx.stats.n_llvm_insns.get();\n-            {\n-                let mut fn_stats = self.ccx.stats.fn_stats.borrow_mut();\n-                fn_stats.get().push((self.name.take_unwrap(),\n-                                     elapsed,\n-                                     iend - self.istart));\n-            }\n+            self.ccx.stats.fn_stats.borrow_mut().push((self.name.take_unwrap(),\n+                                                       elapsed,\n+                                                       iend - self.istart));\n             self.ccx.stats.n_fns.set(self.ccx.stats.n_fns.get() + 1);\n             // Reset LLVM insn count to avoid compound costs.\n             self.ccx.stats.n_llvm_insns.set(self.istart);\n@@ -232,21 +229,17 @@ pub fn get_extern_fn(externs: &mut ExternMap, llmod: ModuleRef,\n \n fn get_extern_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t,\n                       name: &str, did: ast::DefId) -> ValueRef {\n-    {\n-        let externs = ccx.externs.borrow();\n-        match externs.get().find_equiv(&name) {\n-            Some(n) => return *n,\n-            None => ()\n-        }\n+    match ccx.externs.borrow().find_equiv(&name) {\n+        Some(n) => return *n,\n+        None => ()\n     }\n \n     let f = decl_rust_fn(ccx, false, inputs, output, name);\n     csearch::get_item_attrs(&ccx.sess().cstore, did, |meta_items| {\n         set_llvm_fn_attrs(meta_items.iter().map(|&x| attr::mk_attr(x)).to_owned_vec(), f)\n     });\n \n-    let mut externs = ccx.externs.borrow_mut();\n-    externs.get().insert(name.to_owned(), f);\n+    ccx.externs.borrow_mut().insert(name.to_owned(), f);\n     f\n }\n \n@@ -448,19 +441,15 @@ pub fn get_tydesc_simple(ccx: &CrateContext, t: ty::t) -> ValueRef {\n }\n \n pub fn get_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n-    {\n-        let tydescs = ccx.tydescs.borrow();\n-        match tydescs.get().find(&t) {\n-            Some(&inf) => return inf,\n-            _ => { }\n-        }\n+    match ccx.tydescs.borrow().find(&t) {\n+        Some(&inf) => return inf,\n+        _ => { }\n     }\n \n     ccx.stats.n_static_tydescs.set(ccx.stats.n_static_tydescs.get() + 1u);\n     let inf = glue::declare_tydesc(ccx, t);\n \n-    let mut tydescs = ccx.tydescs.borrow_mut();\n-    tydescs.get().insert(t, inf);\n+    ccx.tydescs.borrow_mut().insert(t, inf);\n     return inf;\n }\n \n@@ -519,11 +508,10 @@ pub fn set_no_split_stack(f: ValueRef) {\n // Double-check that we never ask LLVM to declare the same symbol twice. It\n // silently mangles such symbols, breaking our linkage model.\n pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: ~str) {\n-    let mut all_llvm_symbols = ccx.all_llvm_symbols.borrow_mut();\n-    if all_llvm_symbols.get().contains(&sym) {\n+    if ccx.all_llvm_symbols.borrow().contains(&sym) {\n         ccx.sess().bug(~\"duplicate LLVM symbol: \" + sym);\n     }\n-    all_llvm_symbols.get().insert(sym);\n+    ccx.all_llvm_symbols.borrow_mut().insert(sym);\n }\n \n \n@@ -561,11 +549,8 @@ pub fn get_res_dtor(ccx: &CrateContext,\n                                      ty::lookup_item_type(tcx, parent_id).ty);\n         let llty = type_of_dtor(ccx, class_ty);\n \n-        {\n-            let mut externs = ccx.externs.borrow_mut();\n-            get_extern_fn(externs.get(), ccx.llmod, name,\n-                          lib::llvm::CCallConv, llty, ty::mk_nil())\n-        }\n+        get_extern_fn(&mut *ccx.externs.borrow_mut(), ccx.llmod, name,\n+                      lib::llvm::CCallConv, llty, ty::mk_nil())\n     }\n }\n \n@@ -889,9 +874,8 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n                     let c = foreign::llvm_calling_convention(ccx, fn_ty.abis);\n                     let cconv = c.unwrap_or(lib::llvm::CCallConv);\n                     let llty = type_of_fn_from_ty(ccx, t);\n-                    let mut externs = ccx.externs.borrow_mut();\n-                    get_extern_fn(externs.get(), ccx.llmod, name,\n-                                  cconv, llty, fn_ty.sig.output)\n+                    get_extern_fn(&mut *ccx.externs.borrow_mut(), ccx.llmod,\n+                                  name, cconv, llty, fn_ty.sig.output)\n                 }\n             }\n         }\n@@ -904,8 +888,8 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n         }\n         _ => {\n             let llty = type_of(ccx, t);\n-            let mut externs = ccx.externs.borrow_mut();\n-            get_extern_const(externs.get(), ccx.llmod, name, llty)\n+            get_extern_const(&mut *ccx.externs.borrow_mut(), ccx.llmod, name,\n+                             llty)\n         }\n     }\n }\n@@ -1709,8 +1693,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                                          static\");\n               }\n \n-              let const_values = ccx.const_values.borrow();\n-              let v = const_values.get().get_copy(&item.id);\n+              let v = ccx.const_values.borrow().get_copy(&item.id);\n               unsafe {\n                   if !(llvm::LLVMConstIntGetZExtValue(v) != 0) {\n                       ccx.sess().span_fatal(expr.span, \"static assertion failed\");\n@@ -1766,7 +1749,7 @@ pub fn trans_mod(ccx: &CrateContext, m: &ast::Mod) {\n \n fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: ~str, node_id: ast::NodeId,\n                       llfn: ValueRef) {\n-    ccx.item_symbols.borrow_mut().get().insert(node_id, sym);\n+    ccx.item_symbols.borrow_mut().insert(node_id, sym);\n \n     if !ccx.reachable.contains(&node_id) {\n         lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n@@ -1919,241 +1902,222 @@ fn exported_name(ccx: &CrateContext, id: ast::NodeId,\n pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     debug!(\"get_item_val(id=`{:?}`)\", id);\n \n-    let val = {\n-        let item_vals = ccx.item_vals.borrow();\n-        item_vals.get().find_copy(&id)\n-    };\n+    match ccx.item_vals.borrow().find_copy(&id) {\n+        Some(v) => return v,\n+        None => {}\n+    }\n \n-    match val {\n-        Some(v) => v,\n-        None => {\n-            let mut foreign = false;\n-            let item = ccx.tcx.map.get(id);\n-            let val = match item {\n-                ast_map::NodeItem(i) => {\n-                    let ty = ty::node_id_to_type(ccx.tcx(), i.id);\n-                    let sym = exported_name(ccx, id, ty, i.attrs.as_slice());\n-\n-                    let v = match i.node {\n-                        ast::ItemStatic(_, _, expr) => {\n-                            // If this static came from an external crate, then\n-                            // we need to get the symbol from csearch instead of\n-                            // using the current crate's name/version\n-                            // information in the hash of the symbol\n-                            debug!(\"making {}\", sym);\n-                            let (sym, is_local) = {\n-                                let external_srcs = ccx.external_srcs\n-                                                       .borrow();\n-                                match external_srcs.get().find(&i.id) {\n-                                    Some(&did) => {\n-                                        debug!(\"but found in other crate...\");\n-                                        (csearch::get_symbol(&ccx.sess().cstore,\n-                                                             did), false)\n-                                    }\n-                                    None => (sym, true)\n-                                }\n-                            };\n-\n-                            // We need the translated value here, because for enums the\n-                            // LLVM type is not fully determined by the Rust type.\n-                            let (v, inlineable) = consts::const_expr(ccx, expr, is_local);\n-                            {\n-                                let mut const_values = ccx.const_values\n-                                                          .borrow_mut();\n-                                const_values.get().insert(id, v);\n-                            }\n-                            let mut inlineable = inlineable;\n-\n-                            unsafe {\n-                                let llty = llvm::LLVMTypeOf(v);\n-                                let g = sym.with_c_str(|buf| {\n-                                    llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n-                                });\n-\n-                                if !ccx.reachable.contains(&id) {\n-                                    lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n-                                }\n-\n-                                // Apply the `unnamed_addr` attribute if\n-                                // requested\n-                                if attr::contains_name(i.attrs.as_slice(),\n-                                                       \"address_insignificant\") {\n-                                    if ccx.reachable.contains(&id) {\n-                                        ccx.sess().span_bug(i.span,\n-                                            \"insignificant static is reachable\");\n-                                    }\n-                                    lib::llvm::SetUnnamedAddr(g, true);\n-\n-                                    // This is a curious case where we must make\n-                                    // all of these statics inlineable. If a\n-                                    // global is tagged as\n-                                    // address_insignificant, then LLVM won't\n-                                    // coalesce globals unless they have an\n-                                    // internal linkage type. This means that\n-                                    // external crates cannot use this global.\n-                                    // This is a problem for things like inner\n-                                    // statics in generic functions, because the\n-                                    // function will be inlined into another\n-                                    // crate and then attempt to link to the\n-                                    // static in the original crate, only to\n-                                    // find that it's not there. On the other\n-                                    // side of inlininig, the crates knows to\n-                                    // not declare this static as\n-                                    // available_externally (because it isn't)\n-                                    inlineable = true;\n-                                }\n-\n-                                if attr::contains_name(i.attrs.as_slice(),\n-                                                       \"thread_local\") {\n-                                    lib::llvm::set_thread_local(g, true);\n-                                }\n-\n-                                if !inlineable {\n-                                    debug!(\"{} not inlined\", sym);\n-                                    let mut non_inlineable_statics =\n-                                        ccx.non_inlineable_statics\n-                                           .borrow_mut();\n-                                    non_inlineable_statics.get().insert(id);\n-                                }\n-\n-                                let mut item_symbols = ccx.item_symbols\n-                                                          .borrow_mut();\n-                                item_symbols.get().insert(i.id, sym);\n-                                g\n+    let mut foreign = false;\n+    let item = ccx.tcx.map.get(id);\n+    let val = match item {\n+        ast_map::NodeItem(i) => {\n+            let ty = ty::node_id_to_type(ccx.tcx(), i.id);\n+            let sym = exported_name(ccx, id, ty, i.attrs.as_slice());\n+\n+            let v = match i.node {\n+                ast::ItemStatic(_, _, expr) => {\n+                    // If this static came from an external crate, then\n+                    // we need to get the symbol from csearch instead of\n+                    // using the current crate's name/version\n+                    // information in the hash of the symbol\n+                    debug!(\"making {}\", sym);\n+                    let (sym, is_local) = {\n+                        match ccx.external_srcs.borrow().find(&i.id) {\n+                            Some(&did) => {\n+                                debug!(\"but found in other crate...\");\n+                                (csearch::get_symbol(&ccx.sess().cstore,\n+                                                     did), false)\n                             }\n+                            None => (sym, true)\n                         }\n+                    };\n \n-                        ast::ItemFn(_, purity, _, _, _) => {\n-                            let llfn = if purity != ast::ExternFn {\n-                                register_fn(ccx, i.span, sym, i.id, ty)\n-                            } else {\n-                                foreign::register_rust_fn_with_foreign_abi(ccx,\n-                                                                           i.span,\n-                                                                           sym,\n-                                                                           i.id)\n-                            };\n-                            set_llvm_fn_attrs(i.attrs.as_slice(), llfn);\n-                            llfn\n-                        }\n+                    // We need the translated value here, because for enums the\n+                    // LLVM type is not fully determined by the Rust type.\n+                    let (v, inlineable) = consts::const_expr(ccx, expr, is_local);\n+                    ccx.const_values.borrow_mut().insert(id, v);\n+                    let mut inlineable = inlineable;\n \n-                        _ => fail!(\"get_item_val: weird result in table\")\n-                    };\n+                    unsafe {\n+                        let llty = llvm::LLVMTypeOf(v);\n+                        let g = sym.with_c_str(|buf| {\n+                            llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n+                        });\n \n-                    match attr::first_attr_value_str_by_name(i.attrs\n-                                                              .as_slice(),\n-                                                             \"link_section\") {\n-                        Some(sect) => unsafe {\n-                            sect.get().with_c_str(|buf| {\n-                                llvm::LLVMSetSection(v, buf);\n-                            })\n-                        },\n-                        None => ()\n-                    }\n+                        if !ccx.reachable.contains(&id) {\n+                            lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n+                        }\n \n-                    v\n-                }\n+                        // Apply the `unnamed_addr` attribute if\n+                        // requested\n+                        if attr::contains_name(i.attrs.as_slice(),\n+                                               \"address_insignificant\") {\n+                            if ccx.reachable.contains(&id) {\n+                                ccx.sess().span_bug(i.span,\n+                                    \"insignificant static is reachable\");\n+                            }\n+                            lib::llvm::SetUnnamedAddr(g, true);\n+\n+                            // This is a curious case where we must make\n+                            // all of these statics inlineable. If a\n+                            // global is tagged as\n+                            // address_insignificant, then LLVM won't\n+                            // coalesce globals unless they have an\n+                            // internal linkage type. This means that\n+                            // external crates cannot use this global.\n+                            // This is a problem for things like inner\n+                            // statics in generic functions, because the\n+                            // function will be inlined into another\n+                            // crate and then attempt to link to the\n+                            // static in the original crate, only to\n+                            // find that it's not there. On the other\n+                            // side of inlininig, the crates knows to\n+                            // not declare this static as\n+                            // available_externally (because it isn't)\n+                            inlineable = true;\n+                        }\n \n-                ast_map::NodeTraitMethod(trait_method) => {\n-                    debug!(\"get_item_val(): processing a NodeTraitMethod\");\n-                    match *trait_method {\n-                        ast::Required(_) => {\n-                            ccx.sess().bug(\"unexpected variant: required trait method in \\\n-                                           get_item_val()\");\n+                        if attr::contains_name(i.attrs.as_slice(),\n+                                               \"thread_local\") {\n+                            lib::llvm::set_thread_local(g, true);\n                         }\n-                        ast::Provided(m) => {\n-                            register_method(ccx, id, m)\n+\n+                        if !inlineable {\n+                            debug!(\"{} not inlined\", sym);\n+                            ccx.non_inlineable_statics.borrow_mut()\n+                                                      .insert(id);\n                         }\n+\n+                        ccx.item_symbols.borrow_mut().insert(i.id, sym);\n+                        g\n                     }\n                 }\n \n-                ast_map::NodeMethod(m) => {\n-                    register_method(ccx, id, m)\n+                ast::ItemFn(_, purity, _, _, _) => {\n+                    let llfn = if purity != ast::ExternFn {\n+                        register_fn(ccx, i.span, sym, i.id, ty)\n+                    } else {\n+                        foreign::register_rust_fn_with_foreign_abi(ccx,\n+                                                                   i.span,\n+                                                                   sym,\n+                                                                   i.id)\n+                    };\n+                    set_llvm_fn_attrs(i.attrs.as_slice(), llfn);\n+                    llfn\n                 }\n \n-                ast_map::NodeForeignItem(ni) => {\n-                    foreign = true;\n+                _ => fail!(\"get_item_val: weird result in table\")\n+            };\n \n-                    match ni.node {\n-                        ast::ForeignItemFn(..) => {\n-                            let abis = ccx.tcx.map.get_foreign_abis(id);\n-                            foreign::register_foreign_item_fn(ccx, abis, ni)\n-                        }\n-                        ast::ForeignItemStatic(..) => {\n-                            foreign::register_static(ccx, ni)\n-                        }\n-                    }\n-                }\n+            match attr::first_attr_value_str_by_name(i.attrs.as_slice(),\n+                                                     \"link_section\") {\n+                Some(sect) => unsafe {\n+                    sect.get().with_c_str(|buf| {\n+                        llvm::LLVMSetSection(v, buf);\n+                    })\n+                },\n+                None => ()\n+            }\n \n-                ast_map::NodeVariant(ref v) => {\n-                    let llfn;\n-                    match v.node.kind {\n-                        ast::TupleVariantKind(ref args) => {\n-                            assert!(args.len() != 0u);\n-                            let ty = ty::node_id_to_type(ccx.tcx(), id);\n-                            let parent = ccx.tcx.map.get_parent(id);\n-                            let enm = ccx.tcx.map.expect_item(parent);\n-                            let sym = exported_name(ccx,\n-                                                    id,\n-                                                    ty,\n-                                                    enm.attrs.as_slice());\n-\n-                            llfn = match enm.node {\n-                                ast::ItemEnum(_, _) => {\n-                                    register_fn(ccx, (*v).span, sym, id, ty)\n-                                }\n-                                _ => fail!(\"NodeVariant, shouldn't happen\")\n-                            };\n-                        }\n-                        ast::StructVariantKind(_) => {\n-                            fail!(\"struct variant kind unexpected in get_item_val\")\n-                        }\n-                    }\n-                    set_inline_hint(llfn);\n-                    llfn\n+            v\n+        }\n+\n+        ast_map::NodeTraitMethod(trait_method) => {\n+            debug!(\"get_item_val(): processing a NodeTraitMethod\");\n+            match *trait_method {\n+                ast::Required(_) => {\n+                    ccx.sess().bug(\"unexpected variant: required trait method in \\\n+                                   get_item_val()\");\n+                }\n+                ast::Provided(m) => {\n+                    register_method(ccx, id, m)\n                 }\n+            }\n+        }\n \n-                ast_map::NodeStructCtor(struct_def) => {\n-                    // Only register the constructor if this is a tuple-like struct.\n-                    match struct_def.ctor_id {\n-                        None => {\n-                            ccx.sess().bug(\"attempt to register a constructor of \\\n-                                            a non-tuple-like struct\")\n-                        }\n-                        Some(ctor_id) => {\n-                            let parent = ccx.tcx.map.get_parent(id);\n-                            let struct_item = ccx.tcx.map.expect_item(parent);\n-                            let ty = ty::node_id_to_type(ccx.tcx(), ctor_id);\n-                            let sym = exported_name(ccx,\n-                                                    id,\n-                                                    ty,\n-                                                    struct_item.attrs\n-                                                               .as_slice());\n-                            let llfn = register_fn(ccx, struct_item.span,\n-                                                   sym, ctor_id, ty);\n-                            set_inline_hint(llfn);\n-                            llfn\n-                        }\n-                    }\n+        ast_map::NodeMethod(m) => {\n+            register_method(ccx, id, m)\n+        }\n+\n+        ast_map::NodeForeignItem(ni) => {\n+            foreign = true;\n+\n+            match ni.node {\n+                ast::ForeignItemFn(..) => {\n+                    let abis = ccx.tcx.map.get_foreign_abis(id);\n+                    foreign::register_foreign_item_fn(ccx, abis, ni)\n+                }\n+                ast::ForeignItemStatic(..) => {\n+                    foreign::register_static(ccx, ni)\n                 }\n+            }\n+        }\n \n-                ref variant => {\n-                    ccx.sess().bug(format!(\"get_item_val(): unexpected variant: {:?}\",\n-                                   variant))\n+        ast_map::NodeVariant(ref v) => {\n+            let llfn;\n+            let args = match v.node.kind {\n+                ast::TupleVariantKind(ref args) => args,\n+                ast::StructVariantKind(_) => {\n+                    fail!(\"struct variant kind unexpected in get_item_val\")\n+                }\n+            };\n+            assert!(args.len() != 0u);\n+            let ty = ty::node_id_to_type(ccx.tcx(), id);\n+            let parent = ccx.tcx.map.get_parent(id);\n+            let enm = ccx.tcx.map.expect_item(parent);\n+            let sym = exported_name(ccx,\n+                                    id,\n+                                    ty,\n+                                    enm.attrs.as_slice());\n+\n+            llfn = match enm.node {\n+                ast::ItemEnum(_, _) => {\n+                    register_fn(ccx, (*v).span, sym, id, ty)\n                 }\n+                _ => fail!(\"NodeVariant, shouldn't happen\")\n             };\n+            set_inline_hint(llfn);\n+            llfn\n+        }\n \n-            // foreign items (extern fns and extern statics) don't have internal\n-            // linkage b/c that doesn't quite make sense. Otherwise items can\n-            // have internal linkage if they're not reachable.\n-            if !foreign && !ccx.reachable.contains(&id) {\n-                lib::llvm::SetLinkage(val, lib::llvm::InternalLinkage);\n-            }\n+        ast_map::NodeStructCtor(struct_def) => {\n+            // Only register the constructor if this is a tuple-like struct.\n+            let ctor_id = match struct_def.ctor_id {\n+                None => {\n+                    ccx.sess().bug(\"attempt to register a constructor of \\\n+                                    a non-tuple-like struct\")\n+                }\n+                Some(ctor_id) => ctor_id,\n+            };\n+            let parent = ccx.tcx.map.get_parent(id);\n+            let struct_item = ccx.tcx.map.expect_item(parent);\n+            let ty = ty::node_id_to_type(ccx.tcx(), ctor_id);\n+            let sym = exported_name(ccx,\n+                                    id,\n+                                    ty,\n+                                    struct_item.attrs\n+                                               .as_slice());\n+            let llfn = register_fn(ccx, struct_item.span,\n+                                   sym, ctor_id, ty);\n+            set_inline_hint(llfn);\n+            llfn\n+        }\n \n-            let mut item_vals = ccx.item_vals.borrow_mut();\n-            item_vals.get().insert(id, val);\n-            val\n+        ref variant => {\n+            ccx.sess().bug(format!(\"get_item_val(): unexpected variant: {:?}\",\n+                           variant))\n         }\n+    };\n+\n+    // foreign items (extern fns and extern statics) don't have internal\n+    // linkage b/c that doesn't quite make sense. Otherwise items can\n+    // have internal linkage if they're not reachable.\n+    if !foreign && !ccx.reachable.contains(&id) {\n+        lib::llvm::SetLinkage(val, lib::llvm::InternalLinkage);\n     }\n+\n+    ccx.item_vals.borrow_mut().insert(id, val);\n+    val\n }\n \n fn register_method(ccx: &CrateContext, id: ast::NodeId,\n@@ -2542,11 +2506,10 @@ pub fn trans_crate(krate: ast::Crate,\n         println!(\"n_inlines: {}\", ccx.stats.n_inlines.get());\n         println!(\"n_closures: {}\", ccx.stats.n_closures.get());\n         println!(\"fn stats:\");\n-        let mut fn_stats = ccx.stats.fn_stats.borrow_mut();\n-        fn_stats.get().sort_by(|&(_, _, insns_a), &(_, _, insns_b)| {\n+        ccx.stats.fn_stats.borrow_mut().sort_by(|&(_, _, insns_a), &(_, _, insns_b)| {\n             insns_b.cmp(&insns_a)\n         });\n-        for tuple in fn_stats.get().iter() {\n+        for tuple in ccx.stats.fn_stats.borrow().iter() {\n             match *tuple {\n                 (ref name, ms, insns) => {\n                     println!(\"{} insns, {} ms, {}\", insns, ms, *name);\n@@ -2555,8 +2518,7 @@ pub fn trans_crate(krate: ast::Crate,\n         }\n     }\n     if ccx.sess().count_llvm_insns() {\n-        let llvm_insns = ccx.stats.llvm_insns.borrow();\n-        for (k, v) in llvm_insns.get().iter() {\n+        for (k, v) in ccx.stats.llvm_insns.borrow().iter() {\n             println!(\"{:7u} {}\", *v, *k);\n         }\n     }\n@@ -2566,7 +2528,7 @@ pub fn trans_crate(krate: ast::Crate,\n     let llmod = ccx.llmod;\n \n     let mut reachable: Vec<~str> = ccx.reachable.iter().filter_map(|id| {\n-        ccx.item_symbols.borrow().get().find(id).map(|s| s.to_owned())\n+        ccx.item_symbols.borrow().find(id).map(|s| s.to_owned())\n     }).collect();\n \n     // Make sure that some other crucial symbols are not eliminated from the"}, {"sha": "4526f3505beebacd782b9fe0f707cf979b800974", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -79,11 +79,11 @@ impl<'a> Builder<'a> {\n                 s.push_char('/');\n                 s.push_str(category);\n \n-                let n = match h.get().find(&s) {\n+                let n = match h.find(&s) {\n                     Some(&n) => n,\n                     _ => 0u\n                 };\n-                h.get().insert(s, n+1u);\n+                h.insert(s, n+1u);\n             })\n         }\n     }"}, {"sha": "5ab94240357be02eda8f5e303a54caa7fd667d2b", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -399,7 +399,7 @@ pub fn trans_fn_ref_with_vtables(\n             let ref_ty = match node {\n                 ExprId(id) => node_id_type(bcx, id),\n                 MethodCall(method_call) => {\n-                    let t = bcx.ccx().maps.method_map.borrow().get().get(&method_call).ty;\n+                    let t = bcx.ccx().maps.method_map.borrow().get(&method_call).ty;\n                     monomorphize_type(bcx, t)\n                 }\n             };\n@@ -482,7 +482,7 @@ pub fn trans_method_call<'a>(\n     let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_ex={})\", call_ex.repr(bcx.tcx()));\n     let method_call = MethodCall::expr(call_ex.id);\n-    let method_ty = bcx.ccx().maps.method_map.borrow().get().get(&method_call).ty;\n+    let method_ty = bcx.ccx().maps.method_map.borrow().get(&method_call).ty;\n     trans_call_inner(\n         bcx,\n         Some(common::expr_info(call_ex)),"}, {"sha": "a977ea99ef1028ac6289c7350b7eb4887d00eb49", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -194,8 +194,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          * Returns the id of the top-most loop scope\n          */\n \n-        let scopes = self.scopes.borrow();\n-        for scope in scopes.get().iter().rev() {\n+        for scope in self.scopes.borrow().iter().rev() {\n             match scope.kind {\n                 LoopScopeKind(id, _) => {\n                     return id;\n@@ -316,8 +315,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n         debug!(\"schedule_clean_in_ast_scope(cleanup_scope={:?})\",\n                cleanup_scope);\n \n-        let mut scopes = self.scopes.borrow_mut();\n-        for scope in scopes.get().mut_iter().rev() {\n+        for scope in self.scopes.borrow_mut().mut_iter().rev() {\n             if scope.kind.is_ast_with_id(cleanup_scope) {\n                 scope.cleanups.push(cleanup);\n                 scope.clear_cached_exits();\n@@ -347,7 +345,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n         assert!(self.is_valid_custom_scope(custom_scope));\n \n         let mut scopes = self.scopes.borrow_mut();\n-        let scope = scopes.get().get_mut(custom_scope.index);\n+        let scope = scopes.get_mut(custom_scope.index);\n         scope.cleanups.push(cleanup);\n         scope.clear_cached_exits();\n     }\n@@ -358,8 +356,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          * execute on failure.\n          */\n \n-        let scopes = self.scopes.borrow();\n-        scopes.get().iter().rev().any(|s| s.needs_invoke())\n+        self.scopes.borrow().iter().rev().any(|s| s.needs_invoke())\n     }\n \n     fn get_landing_pad(&'a self) -> BasicBlockRef {\n@@ -405,8 +402,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n         /*!\n          * Returns the id of the current top-most AST scope, if any.\n          */\n-        let scopes = self.scopes.borrow();\n-        for scope in scopes.get().iter().rev() {\n+        for scope in self.scopes.borrow().iter().rev() {\n             match scope.kind {\n                 CustomScopeKind | LoopScopeKind(..) => {}\n                 AstScopeKind(i) => {\n@@ -418,20 +414,18 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n     }\n \n     fn top_nonempty_cleanup_scope(&self) -> Option<uint> {\n-        let scopes = self.scopes.borrow();\n-        scopes.get().iter().rev().position(|s| !s.cleanups.is_empty())\n+        self.scopes.borrow().iter().rev().position(|s| !s.cleanups.is_empty())\n     }\n \n     fn is_valid_to_pop_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool {\n-        let scopes = self.scopes.borrow();\n         self.is_valid_custom_scope(custom_scope) &&\n-            custom_scope.index == scopes.get().len() - 1\n+            custom_scope.index == self.scopes.borrow().len() - 1\n     }\n \n     fn is_valid_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool {\n         let scopes = self.scopes.borrow();\n-        custom_scope.index < scopes.get().len() &&\n-            scopes.get().get(custom_scope.index).kind.is_temp()\n+        custom_scope.index < scopes.len() &&\n+            scopes.get(custom_scope.index).kind.is_temp()\n     }\n \n     fn trans_scope_cleanups(&self, // cannot borrow self, will recurse\n@@ -449,27 +443,23 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n     }\n \n     fn scopes_len(&self) -> uint {\n-        let scopes = self.scopes.borrow();\n-        scopes.get().len()\n+        self.scopes.borrow().len()\n     }\n \n     fn push_scope(&self, scope: CleanupScope<'a>) {\n-        let mut scopes = self.scopes.borrow_mut();\n-        scopes.get().push(scope);\n+        self.scopes.borrow_mut().push(scope)\n     }\n \n     fn pop_scope(&self) -> CleanupScope<'a> {\n         debug!(\"popping cleanup scope {}, {} scopes remaining\",\n                self.top_scope(|s| s.block_name(\"\")),\n                self.scopes_len() - 1);\n \n-        let mut scopes = self.scopes.borrow_mut();\n-        scopes.get().pop().unwrap()\n+        self.scopes.borrow_mut().pop().unwrap()\n     }\n \n     fn top_scope<R>(&self, f: |&CleanupScope<'a>| -> R) -> R {\n-        let scopes = self.scopes.borrow();\n-        f(scopes.get().last().unwrap())\n+        f(self.scopes.borrow().last().unwrap())\n     }\n \n     fn trans_cleanups_to_exit_scope(&'a self,\n@@ -653,7 +643,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n         // Check if a landing pad block exists; if not, create one.\n         {\n             let mut scopes = self.scopes.borrow_mut();\n-            let last_scope = scopes.get().mut_last().unwrap();\n+            let last_scope = scopes.mut_last().unwrap();\n             match last_scope.cached_landing_pad {\n                 Some(llbb) => { return llbb; }\n                 None => {"}, {"sha": "894d6e4e6f9c44fb88db7542d3cb382c5b4052b6", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -317,10 +317,7 @@ fn load_environment<'a>(bcx: &'a Block<'a>, cdata_ty: ty::t,\n         }\n         let def_id = ast_util::def_id_of_def(cap_var.def);\n \n-        {\n-            let mut llupvars = bcx.fcx.llupvars.borrow_mut();\n-            llupvars.get().insert(def_id.node, upvarptr);\n-        }\n+        bcx.fcx.llupvars.borrow_mut().insert(def_id.node, upvarptr);\n \n         for &env_pointer_alloca in env_pointer_alloca.iter() {\n             debuginfo::create_captured_var_metadata(\n@@ -395,7 +392,7 @@ pub fn trans_expr_fn<'a>(\n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n \n-    let cap_vars = ccx.maps.capture_map.borrow().get().get_copy(&id);\n+    let cap_vars = ccx.maps.capture_map.borrow().get_copy(&id);\n     let ClosureResult {llbox, cdata_ty, bcx} =\n         build_closure(bcx, cap_vars.deref().as_slice(), sigil);\n     trans_closure(ccx, decl, body, llfn,\n@@ -423,12 +420,9 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n         }\n     };\n \n-    {\n-        let cache = ccx.closure_bare_wrapper_cache.borrow();\n-        match cache.get().find(&fn_ptr) {\n-            Some(&llval) => return llval,\n-            None => {}\n-        }\n+    match ccx.closure_bare_wrapper_cache.borrow().find(&fn_ptr) {\n+        Some(&llval) => return llval,\n+        None => {}\n     }\n \n     let tcx = ccx.tcx();\n@@ -457,10 +451,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n         decl_rust_fn(ccx, true, f.sig.inputs.as_slice(), f.sig.output, name)\n     };\n \n-    {\n-        let mut cache = ccx.closure_bare_wrapper_cache.borrow_mut();\n-        cache.get().insert(fn_ptr, llfn);\n-    }\n+    ccx.closure_bare_wrapper_cache.borrow_mut().insert(fn_ptr, llfn);\n \n     // This is only used by statics inlined from a different crate.\n     if !is_local {"}, {"sha": "6c8fa0e50862686669a2576829312c50dda3ea39", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -465,8 +465,7 @@ impl<'a> Block<'a> {\n     }\n \n     pub fn def(&self, nid: ast::NodeId) -> ast::Def {\n-        let def_map = self.tcx().def_map.borrow();\n-        match def_map.get().find(&nid) {\n+        match self.tcx().def_map.borrow().find(&nid) {\n             Some(&v) => v,\n             None => {\n                 self.tcx().sess.bug(format!(\n@@ -584,12 +583,9 @@ pub fn C_u8(ccx: &CrateContext, i: uint) -> ValueRef {\n // our boxed-and-length-annotated strings.\n pub fn C_cstr(cx: &CrateContext, s: InternedString) -> ValueRef {\n     unsafe {\n-        {\n-            let const_cstr_cache = cx.const_cstr_cache.borrow();\n-            match const_cstr_cache.get().find(&s) {\n-                Some(&llval) => return llval,\n-                None => ()\n-            }\n+        match cx.const_cstr_cache.borrow().find(&s) {\n+            Some(&llval) => return llval,\n+            None => ()\n         }\n \n         let sc = llvm::LLVMConstStringInContext(cx.llcx,\n@@ -605,8 +601,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString) -> ValueRef {\n         llvm::LLVMSetGlobalConstant(g, True);\n         lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n \n-        let mut const_cstr_cache = cx.const_cstr_cache.borrow_mut();\n-        const_cstr_cache.get().insert(s, g);\n+        cx.const_cstr_cache.borrow_mut().insert(s, g);\n         g\n     }\n }\n@@ -795,7 +790,7 @@ pub fn expr_ty(bcx: &Block, ex: &ast::Expr) -> ty::t {\n \n pub fn expr_ty_adjusted(bcx: &Block, ex: &ast::Expr) -> ty::t {\n     let tcx = bcx.tcx();\n-    let t = ty::expr_ty_adjusted(tcx, ex, bcx.ccx().maps.method_map.borrow().get());\n+    let t = ty::expr_ty_adjusted(tcx, ex, &*bcx.ccx().maps.method_map.borrow());\n     monomorphize_type(bcx, t)\n }\n \n@@ -814,7 +809,7 @@ pub fn node_id_type_params(bcx: &Block, node: ExprOrMethodCall) -> Vec<ty::t> {\n     let params = match node {\n         ExprId(id) => ty::node_id_to_type_params(tcx, id),\n         MethodCall(method_call) => {\n-            bcx.ccx().maps.method_map.borrow().get().get(&method_call).substs.tps.clone()\n+            bcx.ccx().maps.method_map.borrow().get(&method_call).substs.tps.clone()\n         }\n     };\n \n@@ -837,7 +832,7 @@ pub fn node_id_type_params(bcx: &Block, node: ExprOrMethodCall) -> Vec<ty::t> {\n pub fn node_vtables(bcx: &Block, id: ast::NodeId)\n                  -> Option<typeck::vtable_res> {\n     let vtable_map = bcx.ccx().maps.vtable_map.borrow();\n-    let raw_vtables = vtable_map.get().find(&id);\n+    let raw_vtables = vtable_map.find(&id);\n     raw_vtables.map(|vts| resolve_vtables_in_fn_ctxt(bcx.fcx, *vts))\n }\n "}, {"sha": "2415a90121350358000fcc45e964787cb01d5bba", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 13, "deletions": 32, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -84,8 +84,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n pub fn const_ptrcast(cx: &CrateContext, a: ValueRef, t: Type) -> ValueRef {\n     unsafe {\n         let b = llvm::LLVMConstPointerCast(a, t.ptr_to().to_ref());\n-        let mut const_globals = cx.const_globals.borrow_mut();\n-        assert!(const_globals.get().insert(b as int, a));\n+        assert!(cx.const_globals.borrow_mut().insert(b as int, a));\n         b\n     }\n }\n@@ -118,8 +117,7 @@ fn const_addr_of(cx: &CrateContext, cv: ValueRef) -> ValueRef {\n }\n \n fn const_deref_ptr(cx: &CrateContext, v: ValueRef) -> ValueRef {\n-    let const_globals = cx.const_globals.borrow();\n-    let v = match const_globals.get().find(&(v as int)) {\n+    let v = match cx.const_globals.borrow().find(&(v as int)) {\n         Some(&v) => v,\n         None => v\n     };\n@@ -163,10 +161,7 @@ fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n \n pub fn get_const_val(cx: &CrateContext,\n                      mut def_id: ast::DefId) -> (ValueRef, bool) {\n-    let contains_key = {\n-        let const_values = cx.const_values.borrow();\n-        const_values.get().contains_key(&def_id.node)\n-    };\n+    let contains_key = cx.const_values.borrow().contains_key(&def_id.node);\n     if !ast_util::is_local(def_id) || !contains_key {\n         if !ast_util::is_local(def_id) {\n             def_id = inline::maybe_instantiate_inline(cx, def_id);\n@@ -180,10 +175,8 @@ pub fn get_const_val(cx: &CrateContext,\n         }\n     }\n \n-    let const_values = cx.const_values.borrow();\n-    let non_inlineable_statics = cx.non_inlineable_statics.borrow();\n-    (const_values.get().get_copy(&def_id.node),\n-     !non_inlineable_statics.get().contains(&def_id.node))\n+    (cx.const_values.borrow().get_copy(&def_id.node),\n+     !cx.non_inlineable_statics.borrow().contains(&def_id.node))\n }\n \n pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef, bool) {\n@@ -192,12 +185,9 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n     let mut inlineable = inlineable;\n     let ety = ty::expr_ty(cx.tcx(), e);\n     let ety_adjusted = ty::expr_ty_adjusted(cx.tcx(), e,\n-                                            cx.maps.method_map.borrow().get());\n-    let adjustment = {\n-        let adjustments = cx.tcx.adjustments.borrow();\n-        adjustments.get().find_copy(&e.id)\n-    };\n-    match adjustment {\n+                                            &*cx.maps.method_map.borrow());\n+    let opt_adj = cx.tcx.adjustments.borrow().find_copy(&e.id);\n+    match opt_adj {\n         None => { }\n         Some(adj) => {\n             match *adj {\n@@ -424,7 +414,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n           }\n           ast::ExprField(base, field, _) => {\n               let bt = ty::expr_ty_adjusted(cx.tcx(), base,\n-                                            cx.maps.method_map.borrow().get());\n+                                            &*cx.maps.method_map.borrow());\n               let brepr = adt::represent_type(cx, bt);\n               let (bv, inlineable) = const_expr(cx, base, is_local);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n@@ -435,7 +425,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n \n           ast::ExprIndex(base, index) => {\n               let bt = ty::expr_ty_adjusted(cx.tcx(), base,\n-                                            cx.maps.method_map.borrow().get());\n+                                            &*cx.maps.method_map.borrow());\n               let (bv, inlineable) = const_expr(cx, base, is_local);\n               let iv = match const_eval::eval_const_expr(cx.tcx(), index) {\n                   const_eval::const_int(i) => i as u64,\n@@ -624,11 +614,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n             // Assert that there are no type parameters in this path.\n             assert!(pth.segments.iter().all(|seg| seg.types.is_empty()));\n \n-            let tcx = cx.tcx();\n-            let opt_def = {\n-                let def_map = tcx.def_map.borrow();\n-                def_map.get().find_copy(&e.id)\n-            };\n+            let opt_def = cx.tcx().def_map.borrow().find_copy(&e.id);\n             match opt_def {\n                 Some(ast::DefFn(def_id, _purity)) => {\n                     if !ast_util::is_local(def_id) {\n@@ -661,11 +647,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n             }\n           }\n           ast::ExprCall(callee, ref args) => {\n-              let tcx = cx.tcx();\n-              let opt_def = {\n-                  let def_map = tcx.def_map.borrow();\n-                  def_map.get().find_copy(&callee.id)\n-              };\n+              let opt_def = cx.tcx().def_map.borrow().find_copy(&callee.id);\n               match opt_def {\n                   Some(ast::DefStruct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n@@ -702,8 +684,7 @@ pub fn trans_const(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n         let g = base::get_item_val(ccx, id);\n         // At this point, get_item_val has already translated the\n         // constant's initializer to determine its LLVM type.\n-        let const_values = ccx.const_values.borrow();\n-        let v = const_values.get().get_copy(&id);\n+        let v = ccx.const_values.borrow().get_copy(&id);\n         llvm::LLVMSetInitializer(g, v);\n         if m != ast::MutMutable {\n             llvm::LLVMSetGlobalConstant(g, True);"}, {"sha": "489405459ae57c969d00f1f8ce66b19fd73edb5d", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -273,8 +273,7 @@ pub fn trans_break_cont<'a>(bcx: &'a Block<'a>,\n     let loop_id = match opt_label {\n         None => fcx.top_loop_scope(),\n         Some(_) => {\n-            let def_map = bcx.tcx().def_map.borrow();\n-            match def_map.get().find(&expr_id) {\n+            match bcx.tcx().def_map.borrow().find(&expr_id) {\n                 Some(&ast::DefLabel(loop_id)) => loop_id,\n                 ref r => {\n                     bcx.tcx().sess.bug(format!(\"{:?} in def-map for label\", r))"}, {"sha": "1458e9e7f39e6085a431c79eeee3fb716535883a", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 35, "deletions": 61, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -294,15 +294,12 @@ pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n     pat_util::pat_bindings(def_map, local.pat, |_, node_id, span, path_ref| {\n         let var_ident = ast_util::path_to_ident(path_ref);\n \n-        let datum = {\n-            let lllocals = bcx.fcx.lllocals.borrow();\n-            match lllocals.get().find_copy(&node_id) {\n-                Some(datum) => datum,\n-                None => {\n-                    bcx.sess().span_bug(span,\n-                        format!(\"no entry in lllocals table for {:?}\",\n-                                node_id));\n-                }\n+        let datum = match bcx.fcx.lllocals.borrow().find_copy(&node_id) {\n+            Some(datum) => datum,\n+            None => {\n+                bcx.sess().span_bug(span,\n+                    format!(\"no entry in lllocals table for {:?}\",\n+                            node_id));\n             }\n         };\n \n@@ -436,15 +433,12 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n \n     pat_util::pat_bindings(def_map, arg.pat, |_, node_id, span, path_ref| {\n-        let llarg = {\n-            let llargs = bcx.fcx.llargs.borrow();\n-            match llargs.get().find_copy(&node_id) {\n-                Some(v) => v,\n-                None => {\n-                    bcx.sess().span_bug(span,\n-                        format!(\"no entry in llargs table for {:?}\",\n-                                node_id));\n-                }\n+        let llarg = match bcx.fcx.llargs.borrow().find_copy(&node_id) {\n+            Some(v) => v,\n+            None => {\n+                bcx.sess().span_bug(span,\n+                    format!(\"no entry in llargs table for {:?}\",\n+                            node_id));\n             }\n         };\n \n@@ -686,14 +680,11 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     };\n \n     let arg_pats = fn_decl.inputs.map(|arg_ref| arg_ref.pat);\n-    {\n-        let mut scope_map = fn_debug_context.scope_map.borrow_mut();\n-        populate_scope_map(cx,\n-                           arg_pats.as_slice(),\n-                           top_level_block,\n-                           fn_metadata,\n-                           scope_map.get());\n-    }\n+    populate_scope_map(cx,\n+                       arg_pats.as_slice(),\n+                       top_level_block,\n+                       fn_metadata,\n+                       &mut *fn_debug_context.scope_map.borrow_mut());\n \n     // Clear the debug location so we don't assign them in the function prelude\n     set_debug_location(cx, UnknownLocation);\n@@ -1014,12 +1005,9 @@ fn declare_local(bcx: &Block,\n }\n \n fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n-    {\n-        let created_files = debug_context(cx).created_files.borrow();\n-        match created_files.get().find_equiv(&full_path) {\n-            Some(file_metadata) => return *file_metadata,\n-            None => ()\n-        }\n+    match debug_context(cx).created_files.borrow().find_equiv(&full_path) {\n+        Some(file_metadata) => return *file_metadata,\n+        None => ()\n     }\n \n     debug!(\"file_metadata: {}\", full_path);\n@@ -1043,7 +1031,7 @@ fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n         });\n \n     let mut created_files = debug_context(cx).created_files.borrow_mut();\n-    created_files.get().insert(full_path.to_owned(), file_metadata);\n+    created_files.insert(full_path.to_owned(), file_metadata);\n     return file_metadata;\n }\n \n@@ -1053,9 +1041,7 @@ fn scope_metadata(fcx: &FunctionContext,\n                   span: Span)\n                -> DIScope {\n     let scope_map = &fcx.debug_context.get_ref(fcx.ccx, span).scope_map;\n-    let scope_map = scope_map.borrow();\n-\n-    match scope_map.get().find_copy(&node_id) {\n+    match scope_map.borrow().find_copy(&node_id) {\n         Some(scope_metadata) => scope_metadata,\n         None => {\n             let node = fcx.ccx.tcx.map.get(node_id);\n@@ -1243,10 +1229,8 @@ impl RecursiveTypeDescription {\n                 ref member_description_factory\n             } => {\n                 // Insert the stub into the cache in order to allow recursive references ...\n-                {\n-                    let mut created_types = debug_context(cx).created_types.borrow_mut();\n-                    created_types.get().insert(cache_id, metadata_stub);\n-                }\n+                debug_context(cx).created_types.borrow_mut()\n+                                 .insert(cache_id, metadata_stub);\n \n                 // ... then create the member descriptions ...\n                 let member_descriptions = member_description_factory.create_member_descriptions(cx);\n@@ -1649,12 +1633,12 @@ fn set_members_of_composite_type(cx: &CrateContext,\n     {\n         let mut composite_types_completed =\n             debug_context(cx).composite_types_completed.borrow_mut();\n-        if composite_types_completed.get().contains(&composite_type_metadata) {\n+        if composite_types_completed.contains(&composite_type_metadata) {\n             cx.sess().span_bug(definition_span, \"debuginfo::set_members_of_composite_type() - \\\n                                                  Already completed forward declaration \\\n                                                  re-encountered.\");\n         } else {\n-            composite_types_completed.get().insert(composite_type_metadata);\n+            composite_types_completed.insert(composite_type_metadata);\n         }\n     }\n \n@@ -2035,12 +2019,9 @@ fn type_metadata(cx: &CrateContext,\n               -> DIType {\n     let cache_id = cache_id_for_type(t);\n \n-    {\n-        let created_types = debug_context(cx).created_types.borrow();\n-        match created_types.get().find(&cache_id) {\n-            Some(type_metadata) => return *type_metadata,\n-            None => ()\n-        }\n+    match debug_context(cx).created_types.borrow().find(&cache_id) {\n+        Some(type_metadata) => return *type_metadata,\n+        None => ()\n     }\n \n     fn create_pointer_to_box_metadata(cx: &CrateContext,\n@@ -2149,8 +2130,7 @@ fn type_metadata(cx: &CrateContext,\n         _ => cx.sess().bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\", sty))\n     };\n \n-    let mut created_types = debug_context(cx).created_types.borrow_mut();\n-    created_types.get().insert(cache_id, type_metadata);\n+    debug_context(cx).created_types.borrow_mut().insert(cache_id, type_metadata);\n     type_metadata\n }\n \n@@ -2250,8 +2230,7 @@ fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n }\n \n fn assert_type_for_node_id(cx: &CrateContext, node_id: ast::NodeId, error_span: Span) {\n-    let node_types = cx.tcx.node_types.borrow();\n-    if !node_types.get().contains_key(&(node_id as uint)) {\n+    if !cx.tcx.node_types.borrow().contains_key(&(node_id as uint)) {\n         cx.sess().span_bug(error_span, \"debuginfo: Could not find type for node id!\");\n     }\n }\n@@ -2781,10 +2760,8 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> @NamespaceTreeNo\n             let name = path_element.name();\n             current_key.push(name);\n \n-            let existing_node = {\n-                let namespace_map = debug_context(cx).namespace_map.borrow();\n-                namespace_map.get().find_copy(&current_key)\n-            };\n+            let existing_node = debug_context(cx).namespace_map.borrow()\n+                                                 .find_copy(&current_key);\n             let current_node = match existing_node {\n                 Some(existing_node) => existing_node,\n                 None => {\n@@ -2813,11 +2790,8 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> @NamespaceTreeNo\n                         parent: parent_node,\n                     };\n \n-                    {\n-                        let mut namespace_map = debug_context(cx).namespace_map\n-                                                                 .borrow_mut();\n-                        namespace_map.get().insert(current_key.clone(), node);\n-                    }\n+                    debug_context(cx).namespace_map.borrow_mut()\n+                                     .insert(current_key.clone(), node);\n \n                     node\n                 }"}, {"sha": "5baf405620646103b6556b6640c304e713c8e496", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 23, "deletions": 40, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -106,12 +106,7 @@ pub fn trans_into<'a>(bcx: &'a Block<'a>,\n \n     let mut bcx = bcx;\n \n-    let is_adjusted = {\n-        let adjustments = bcx.tcx().adjustments.borrow();\n-        adjustments.get().contains_key(&expr.id)\n-    };\n-\n-    if is_adjusted {\n+    if bcx.tcx().adjustments.borrow().contains_key(&expr.id) {\n         // use trans, which may be less efficient but\n         // which will perform the adjustments:\n         let datum = unpack_datum!(bcx, trans(bcx, expr));\n@@ -172,14 +167,11 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n \n     let mut bcx = bcx;\n     let mut datum = datum;\n-    let adjustment = {\n-        let adjustments = bcx.tcx().adjustments.borrow();\n-        match adjustments.get().find_copy(&expr.id) {\n-            None => {\n-                return DatumBlock(bcx, datum);\n-            }\n-            Some(adj) => { adj }\n+    let adjustment = match bcx.tcx().adjustments.borrow().find_copy(&expr.id) {\n+        None => {\n+            return DatumBlock(bcx, datum);\n         }\n+        Some(adj) => { adj }\n     };\n     debug!(\"unadjusted datum for expr {}: {}\",\n            expr.id, datum.to_str(bcx.ccx()));\n@@ -210,7 +202,7 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n                 Some(AutoBorrowFn(..)) => {\n                     let adjusted_ty = ty::adjust_ty(bcx.tcx(), expr.span, expr.id, datum.ty,\n                                                     Some(adjustment), |method_call| {\n-                        bcx.ccx().maps.method_map.borrow().get()\n+                        bcx.ccx().maps.method_map.borrow()\n                            .find(&method_call).map(|method| method.ty)\n                     });\n                     unpack_datum!(bcx, auto_borrow_fn(bcx, adjusted_ty, datum))\n@@ -222,7 +214,7 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         }\n         AutoObject(..) => {\n             let adjusted_ty = ty::expr_ty_adjusted(bcx.tcx(), expr,\n-                                                   bcx.ccx().maps.method_map.borrow().get());\n+                                                   &*bcx.ccx().maps.method_map.borrow());\n             let scratch = rvalue_scratch_datum(bcx, adjusted_ty, \"__adjust\");\n             bcx = meth::trans_trait_cast(\n                 bcx, datum, expr.id, SaveIn(scratch.val));\n@@ -567,13 +559,10 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n                     let pty = type_of::type_of(bcx.ccx(), const_ty).ptr_to();\n                     PointerCast(bcx, val, pty)\n                 } else {\n-                    {\n-                        let extern_const_values = bcx.ccx().extern_const_values.borrow();\n-                        match extern_const_values.get().find(&did) {\n-                            None => {}  // Continue.\n-                            Some(llval) => {\n-                                return *llval;\n-                            }\n+                    match bcx.ccx().extern_const_values.borrow().find(&did) {\n+                        None => {}  // Continue.\n+                        Some(llval) => {\n+                            return *llval;\n                         }\n                     }\n \n@@ -587,8 +576,8 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n                                                     llty.to_ref(),\n                                                     buf)\n                             });\n-                        let mut extern_const_values = bcx.ccx().extern_const_values.borrow_mut();\n-                        extern_const_values.get().insert(did, llval);\n+                        bcx.ccx().extern_const_values.borrow_mut()\n+                           .insert(did, llval);\n                         llval\n                     }\n                 }\n@@ -898,8 +887,7 @@ pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n         ast::DefUpvar(nid, _, _, _) => {\n             // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n-            let llupvars = bcx.fcx.llupvars.borrow();\n-            match llupvars.get().find(&nid) {\n+            match bcx.fcx.llupvars.borrow().find(&nid) {\n                 Some(&val) => Datum(val, local_ty, Lvalue),\n                 None => {\n                     bcx.sess().bug(format!(\n@@ -908,12 +896,10 @@ pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n             }\n         }\n         ast::DefArg(nid, _) => {\n-            let llargs = bcx.fcx.llargs.borrow();\n-            take_local(bcx, llargs.get(), nid)\n+            take_local(bcx, &*bcx.fcx.llargs.borrow(), nid)\n         }\n         ast::DefLocal(nid, _) | ast::DefBinding(nid, _) => {\n-            let lllocals = bcx.fcx.lllocals.borrow();\n-            take_local(bcx, lllocals.get(), nid)\n+            take_local(bcx, &*bcx.fcx.lllocals.borrow(), nid)\n         }\n         _ => {\n             bcx.sess().unimpl(format!(\n@@ -965,11 +951,8 @@ pub fn with_field_tys<R>(tcx: &ty::ctxt,\n                         ty.repr(tcx)));\n                 }\n                 Some(node_id) => {\n-                    let opt_def = {\n-                        let def_map = tcx.def_map.borrow();\n-                        def_map.get().get_copy(&node_id)\n-                    };\n-                    match opt_def {\n+                    let def = tcx.def_map.borrow().get_copy(&node_id);\n+                    match def {\n                         ast::DefVariant(enum_id, variant_id, _) => {\n                             let variant_info = ty::enum_variant_with_id(\n                                 tcx, enum_id, variant_id);\n@@ -1159,7 +1142,7 @@ fn trans_unary<'a>(bcx: &'a Block<'a>,\n     // Otherwise, we should be in the RvalueDpsExpr path.\n     assert!(\n         op == ast::UnDeref ||\n-        !ccx.maps.method_map.borrow().get().contains_key(&method_call));\n+        !ccx.maps.method_map.borrow().contains_key(&method_call));\n \n     let un_ty = expr_ty(bcx, expr);\n \n@@ -1436,7 +1419,7 @@ fn trans_binary<'a>(bcx: &'a Block<'a>,\n     let ccx = bcx.ccx();\n \n     // if overloaded, would be RvalueDpsExpr\n-    assert!(!ccx.maps.method_map.borrow().get().contains_key(&MethodCall::expr(expr.id)));\n+    assert!(!ccx.maps.method_map.borrow().contains_key(&MethodCall::expr(expr.id)));\n \n     match op {\n         ast::BiAnd => {\n@@ -1476,7 +1459,7 @@ fn trans_overloaded_op<'a, 'b>(\n                        rhs: Option<(Datum<Expr>, ast::NodeId)>,\n                        dest: Option<Dest>)\n                        -> Result<'a> {\n-    let method_ty = bcx.ccx().maps.method_map.borrow().get().get(&method_call).ty;\n+    let method_ty = bcx.ccx().maps.method_map.borrow().get(&method_call).ty;\n     callee::trans_call_inner(bcx,\n                              Some(expr_info(expr)),\n                              monomorphize_type(bcx, method_ty),\n@@ -1644,7 +1627,7 @@ fn trans_assign_op<'a>(\n     debug!(\"trans_assign_op(expr={})\", bcx.expr_to_str(expr));\n \n     // User-defined operator methods cannot be used with `+=` etc right now\n-    assert!(!bcx.ccx().maps.method_map.borrow().get().contains_key(&MethodCall::expr(expr.id)));\n+    assert!(!bcx.ccx().maps.method_map.borrow().contains_key(&MethodCall::expr(expr.id)));\n \n     // Evaluate LHS (destination), which should be an lvalue\n     let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, dst, \"assign_op\"));\n@@ -1722,7 +1705,7 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n         expr_id: expr.id,\n         autoderef: derefs as u32\n     };\n-    let method_ty = ccx.maps.method_map.borrow().get()\n+    let method_ty = ccx.maps.method_map.borrow()\n                        .find(&method_call).map(|method| method.ty);\n     let datum = match method_ty {\n         Some(method_ty) => {"}, {"sha": "3fd677b34d98483204f08864cb0629fd14ed4bfb", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -239,16 +239,12 @@ pub fn register_foreign_item_fn(ccx: &CrateContext, abis: AbiSet,\n     // Create the LLVM value for the C extern fn\n     let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n \n-    let llfn;\n-    {\n-        let mut externs = ccx.externs.borrow_mut();\n-        llfn = base::get_extern_fn(externs.get(),\n+    let llfn = base::get_extern_fn(&mut *ccx.externs.borrow_mut(),\n                                    ccx.llmod,\n                                    lname.get(),\n                                    cc,\n                                    llfn_ty,\n                                    tys.fn_sig.output);\n-    };\n     add_argument_attributes(&tys, llfn);\n \n     llfn\n@@ -470,8 +466,8 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n         }\n \n         let lname = link_name(foreign_item);\n-        let mut item_symbols = ccx.item_symbols.borrow_mut();\n-        item_symbols.get().insert(foreign_item.id, lname.get().to_owned());\n+        ccx.item_symbols.borrow_mut().insert(foreign_item.id,\n+                                             lname.get().to_owned());\n     }\n }\n "}, {"sha": "da9d06b9a752613940d9a056bef6246e562eb361", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -128,15 +128,15 @@ pub fn drop_ty_immediate<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n \n pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n     let t = get_drop_glue_type(ccx, t);\n-    match ccx.drop_glues.borrow().get().find(&t) {\n+    match ccx.drop_glues.borrow().find(&t) {\n         Some(&glue) => return glue,\n         _ => { }\n     }\n \n     let llfnty = Type::glue_fn(ccx, type_of(ccx, t).ptr_to());\n     let glue = declare_generic_glue(ccx, t, llfnty, \"drop\");\n \n-    ccx.drop_glues.borrow_mut().get().insert(t, glue);\n+    ccx.drop_glues.borrow_mut().insert(t, glue);\n \n     make_generic_glue(ccx, t, glue, make_drop_glue, \"drop\");\n \n@@ -476,8 +476,7 @@ pub fn emit_tydescs(ccx: &CrateContext) {\n     // As of this point, allow no more tydescs to be created.\n     ccx.finished_tydescs.set(true);\n     let glue_fn_ty = Type::generic_glue_fn(ccx).ptr_to();\n-    let mut tyds = ccx.tydescs.borrow_mut();\n-    for (_, &val) in tyds.get().iter() {\n+    for (_, &val) in ccx.tydescs.borrow().iter() {\n         let ti = val;\n \n         // Each of the glue functions needs to be cast to a generic type"}, {"sha": "b96d71366e00302a61280c87e7dff3e6d94c4a97", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 23, "deletions": 45, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -22,21 +22,18 @@ use syntax::attr;\n pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n     -> ast::DefId {\n     let _icx = push_ctxt(\"maybe_instantiate_inline\");\n-    {\n-        let external = ccx.external.borrow();\n-        match external.get().find(&fn_id) {\n-            Some(&Some(node_id)) => {\n-                // Already inline\n-                debug!(\"maybe_instantiate_inline({}): already inline as node id {}\",\n-                       ty::item_path_str(ccx.tcx(), fn_id), node_id);\n-                return local_def(node_id);\n-            }\n-            Some(&None) => {\n-                return fn_id; // Not inlinable\n-            }\n-            None => {\n-                // Not seen yet\n-            }\n+    match ccx.external.borrow().find(&fn_id) {\n+        Some(&Some(node_id)) => {\n+            // Already inline\n+            debug!(\"maybe_instantiate_inline({}): already inline as node id {}\",\n+                   ty::item_path_str(ccx.tcx(), fn_id), node_id);\n+            return local_def(node_id);\n+        }\n+        Some(&None) => {\n+            return fn_id; // Not inlinable\n+        }\n+        None => {\n+            // Not seen yet\n         }\n     }\n \n@@ -46,17 +43,12 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             |a,b,c,d| astencode::decode_inlined_item(a, b, &ccx.maps, c, d));\n     return match csearch_result {\n         csearch::not_found => {\n-            let mut external = ccx.external.borrow_mut();\n-            external.get().insert(fn_id, None);\n+            ccx.external.borrow_mut().insert(fn_id, None);\n             fn_id\n         }\n         csearch::found(ast::IIItem(item)) => {\n-            {\n-                let mut external = ccx.external.borrow_mut();\n-                let mut external_srcs = ccx.external_srcs.borrow_mut();\n-                external.get().insert(fn_id, Some(item.id));\n-                external_srcs.get().insert(item.id, fn_id);\n-            }\n+            ccx.external.borrow_mut().insert(fn_id, Some(item.id));\n+            ccx.external_srcs.borrow_mut().insert(item.id, fn_id);\n \n             ccx.stats.n_inlines.set(ccx.stats.n_inlines.get() + 1);\n             trans_item(ccx, item);\n@@ -85,21 +77,13 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             local_def(item.id)\n         }\n         csearch::found(ast::IIForeign(item)) => {\n-            {\n-                let mut external = ccx.external.borrow_mut();\n-                let mut external_srcs = ccx.external_srcs.borrow_mut();\n-                external.get().insert(fn_id, Some(item.id));\n-                external_srcs.get().insert(item.id, fn_id);\n-            }\n+            ccx.external.borrow_mut().insert(fn_id, Some(item.id));\n+            ccx.external_srcs.borrow_mut().insert(item.id, fn_id);\n             local_def(item.id)\n         }\n         csearch::found_parent(parent_id, ast::IIItem(item)) => {\n-            {\n-                let mut external = ccx.external.borrow_mut();\n-                let mut external_srcs = ccx.external_srcs.borrow_mut();\n-                external.get().insert(parent_id, Some(item.id));\n-                external_srcs.get().insert(item.id, parent_id);\n-            }\n+            ccx.external.borrow_mut().insert(parent_id, Some(item.id));\n+            ccx.external_srcs.borrow_mut().insert(item.id, parent_id);\n \n           let mut my_id = 0;\n           match item.node {\n@@ -108,16 +92,14 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n               let vs_there = ty::enum_variants(ccx.tcx(), parent_id);\n               for (here, there) in vs_here.iter().zip(vs_there.iter()) {\n                   if there.id == fn_id { my_id = here.id.node; }\n-                  let mut external = ccx.external.borrow_mut();\n-                  external.get().insert(there.id, Some(here.id.node));\n+                  ccx.external.borrow_mut().insert(there.id, Some(here.id.node));\n               }\n             }\n             ast::ItemStruct(ref struct_def, _) => {\n               match struct_def.ctor_id {\n                 None => {}\n                 Some(ctor_id) => {\n-                    let mut external = ccx.external.borrow_mut();\n-                    let _ = external.get().insert(fn_id, Some(ctor_id));\n+                    ccx.external.borrow_mut().insert(fn_id, Some(ctor_id));\n                     my_id = ctor_id;\n                 }\n               }\n@@ -133,12 +115,8 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n              with a non-item parent\");\n         }\n         csearch::found(ast::IIMethod(impl_did, is_provided, mth)) => {\n-            {\n-                let mut external = ccx.external.borrow_mut();\n-                let mut external_srcs = ccx.external_srcs.borrow_mut();\n-                external.get().insert(fn_id, Some(mth.id));\n-                external_srcs.get().insert(mth.id, fn_id);\n-            }\n+            ccx.external.borrow_mut().insert(fn_id, Some(mth.id));\n+            ccx.external_srcs.borrow_mut().insert(mth.id, fn_id);\n \n           ccx.stats.n_inlines.set(ccx.stats.n_inlines.get() + 1);\n "}, {"sha": "c5e4fa49f64be2f5fd56af9759057bf6741ce3e1", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 17, "deletions": 31, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -100,7 +100,7 @@ pub fn trans_method_callee<'a>(\n     let _icx = push_ctxt(\"meth::trans_method_callee\");\n \n     let (origin, method_ty) = match bcx.ccx().maps.method_map\n-                                       .borrow().get().find(&method_call) {\n+                                       .borrow().find(&method_call) {\n         Some(method) => {\n             debug!(\"trans_method_callee({:?}, method={})\",\n                    method_call, method.repr(bcx.tcx()));\n@@ -208,7 +208,7 @@ pub fn trans_static_method_callee(bcx: &Block,\n     debug!(\"trans_static_method_callee: method_id={:?}, expr_id={:?}, \\\n             name={}\", method_id, expr_id, token::get_name(mname));\n \n-    let vtbls = ccx.maps.vtable_map.borrow().get().get_copy(&expr_id);\n+    let vtbls = ccx.maps.vtable_map.borrow().get_copy(&expr_id);\n     let vtbls = resolve_vtables_in_fn_ctxt(bcx.fcx, vtbls);\n \n     match vtbls.get(bound_index).get(0) {\n@@ -239,23 +239,18 @@ pub fn trans_static_method_callee(bcx: &Block,\n pub fn method_with_name(ccx: &CrateContext,\n                         impl_id: ast::DefId,\n                         name: ast::Name) -> ast::DefId {\n-    {\n-        let impl_method_cache = ccx.impl_method_cache.borrow();\n-        let meth_id_opt = impl_method_cache.get().find_copy(&(impl_id, name));\n-        match meth_id_opt {\n-            Some(m) => return m,\n-            None => {}\n-        }\n+    match ccx.impl_method_cache.borrow().find_copy(&(impl_id, name)) {\n+        Some(m) => return m,\n+        None => {}\n     }\n \n-    let impls = ccx.tcx.impls.borrow();\n-    let imp = impls.get().find(&impl_id)\n-        .expect(\"could not find impl while translating\");\n+    let imp = ccx.tcx.impls.borrow();\n+    let imp = imp.find(&impl_id)\n+                 .expect(\"could not find impl while translating\");\n     let meth = imp.methods.iter().find(|m| m.ident.name == name)\n-        .expect(\"could not find method while translating\");\n+                  .expect(\"could not find method while translating\");\n \n-    let mut impl_method_cache = ccx.impl_method_cache.borrow_mut();\n-    impl_method_cache.get().insert((impl_id, name), meth.def_id);\n+    ccx.impl_method_cache.borrow_mut().insert((impl_id, name), meth.def_id);\n     meth.def_id\n }\n \n@@ -478,12 +473,9 @@ pub fn get_vtable(bcx: &Block,\n \n     // Check the cache.\n     let hash_id = (self_ty, vtable_id(ccx, origins.get(0)));\n-    {\n-        let vtables = ccx.vtables.borrow();\n-        match vtables.get().find(&hash_id) {\n-            Some(&val) => { return val }\n-            None => { }\n-        }\n+    match ccx.vtables.borrow().find(&hash_id) {\n+        Some(&val) => { return val }\n+        None => { }\n     }\n \n     // Not in the cache. Actually build it.\n@@ -507,8 +499,7 @@ pub fn get_vtable(bcx: &Block,\n     let drop_glue = glue::get_drop_glue(ccx, self_ty);\n     let vtable = make_vtable(ccx, drop_glue, methods.as_slice());\n \n-    let mut vtables = ccx.vtables.borrow_mut();\n-    vtables.get().insert(hash_id, vtable);\n+    ccx.vtables.borrow_mut().insert(hash_id, vtable);\n     return vtable;\n }\n \n@@ -607,14 +598,9 @@ pub fn trans_trait_cast<'a>(bcx: &'a Block<'a>,\n \n     // Store the vtable into the second half of pair.\n     // This is structured a bit funny because of dynamic borrow failures.\n-    let origins = {\n-        let res = {\n-            let vtable_map = ccx.maps.vtable_map.borrow();\n-            *vtable_map.get().get(&id)\n-        };\n-        let res = resolve_vtables_in_fn_ctxt(bcx.fcx, res);\n-        *res.get(0)\n-    };\n+    let res = *ccx.maps.vtable_map.borrow().get(&id);\n+    let res = resolve_vtables_in_fn_ctxt(bcx.fcx, res);\n+    let origins = *res.get(0);\n     let vtable = get_vtable(bcx, v_ty, origins);\n     let llvtabledest = GEPi(bcx, lldest, [0u, abi::trt_field_vtable]);\n     let llvtabledest = PointerCast(bcx, llvtabledest, val_ty(vtable).ptr_to());"}, {"sha": "80a7fe2facfebe2f0a0f89cbc33ee24bb915fe80", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -74,16 +74,13 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n            psubsts.repr(ccx.tcx()),\n            hash_id);\n \n-    {\n-        let monomorphized = ccx.monomorphized.borrow();\n-        match monomorphized.get().find(&hash_id) {\n-          Some(&val) => {\n+    match ccx.monomorphized.borrow().find(&hash_id) {\n+        Some(&val) => {\n             debug!(\"leaving monomorphic fn {}\",\n-                   ty::item_path_str(ccx.tcx(), fn_id));\n+            ty::item_path_str(ccx.tcx(), fn_id));\n             return (val, must_cast);\n-          }\n-          None => ()\n         }\n+        None => ()\n     }\n \n     let tpt = ty::lookup_item_type(ccx.tcx(), fn_id);\n@@ -164,7 +161,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     let depth;\n     {\n         let mut monomorphizing = ccx.monomorphizing.borrow_mut();\n-        depth = match monomorphizing.get().find(&fn_id) {\n+        depth = match monomorphizing.find(&fn_id) {\n             Some(&d) => d, None => 0\n         };\n \n@@ -176,7 +173,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n                 \"reached the recursion limit during monomorphization\");\n         }\n \n-        monomorphizing.get().insert(fn_id, depth + 1);\n+        monomorphizing.insert(fn_id, depth + 1);\n     }\n \n     let s = ccx.tcx.map.with_path(fn_id.node, |path| {\n@@ -188,8 +185,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         let lldecl = decl_internal_rust_fn(ccx, false,\n                                            f.sig.inputs.as_slice(),\n                                            f.sig.output, s);\n-        let mut monomorphized = ccx.monomorphized.borrow_mut();\n-        monomorphized.get().insert(hash_id, lldecl);\n+        ccx.monomorphized.borrow_mut().insert(hash_id, lldecl);\n         lldecl\n     };\n \n@@ -284,10 +280,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         }\n     };\n \n-    {\n-        let mut monomorphizing = ccx.monomorphizing.borrow_mut();\n-        monomorphizing.get().insert(fn_id, depth);\n-    }\n+    ccx.monomorphizing.borrow_mut().insert(fn_id, depth);\n \n     debug!(\"leaving monomorphic fn {}\", ty::item_path_str(ccx.tcx(), fn_id));\n     (lldecl, must_cast)"}, {"sha": "d7c58f146e1dc04711e775fa857d92bc187ffdcb", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -102,12 +102,9 @@ pub fn type_of_fn_from_ty(cx: &CrateContext, fty: ty::t) -> Type {\n //     recursive types. For example, enum types rely on this behavior.\n \n pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n-    {\n-        let llsizingtypes = cx.llsizingtypes.borrow();\n-        match llsizingtypes.get().find_copy(&t) {\n-            Some(t) => return t,\n-            None => ()\n-        }\n+    match cx.llsizingtypes.borrow().find_copy(&t) {\n+        Some(t) => return t,\n+        None => ()\n     }\n \n     let llsizingty = match ty::get(t).sty {\n@@ -165,20 +162,16 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         }\n     };\n \n-    let mut llsizingtypes = cx.llsizingtypes.borrow_mut();\n-    llsizingtypes.get().insert(t, llsizingty);\n+    cx.llsizingtypes.borrow_mut().insert(t, llsizingty);\n     llsizingty\n }\n \n // NB: If you update this, be sure to update `sizing_type_of()` as well.\n pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     // Check the cache.\n-    {\n-        let lltypes = cx.lltypes.borrow();\n-        match lltypes.get().find(&t) {\n-            Some(&llty) => return llty,\n-            None => ()\n-        }\n+    match cx.lltypes.borrow().find(&t) {\n+        Some(&llty) => return llty,\n+        None => ()\n     }\n \n     debug!(\"type_of {} {:?}\", t.repr(cx.tcx()), t);\n@@ -198,8 +191,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n                 t_norm.repr(cx.tcx()),\n                 t_norm,\n                 cx.tn.type_to_str(llty));\n-        let mut lltypes = cx.lltypes.borrow_mut();\n-        lltypes.get().insert(t, llty);\n+        cx.lltypes.borrow_mut().insert(t, llty);\n         return llty;\n     }\n \n@@ -295,10 +287,8 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n             t.repr(cx.tcx()),\n             t,\n             cx.tn.type_to_str(llty));\n-    {\n-        let mut lltypes = cx.lltypes.borrow_mut();\n-        lltypes.get().insert(t, llty);\n-    }\n+\n+    cx.lltypes.borrow_mut().insert(t, llty);\n \n     // If this was an enum or struct, fill in the type now.\n     match ty::get(t).sty {"}, {"sha": "565805446f7c05d27b53774341db09e57e4a6bdc", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -34,8 +34,7 @@ pub fn root_and_write_guard<'a, K:KindOps>(datum: &Datum<K>,\n     //\n     // (Note: root'd values are always boxes)\n     let ccx = bcx.ccx();\n-    let root_map = ccx.maps.root_map.borrow();\n-    match root_map.get().find(&key) {\n+    match ccx.maps.root_map.borrow().find(&key) {\n         None => bcx,\n         Some(&root_info) => root(datum, bcx, span, key, root_info)\n     }"}, {"sha": "76b6c7b40fe556999bf5a6826d50aeb2a457c706", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 95, "deletions": 184, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -1154,12 +1154,9 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n \n     let key = intern_key { sty: &st };\n \n-    {\n-        let mut interner = cx.interner.borrow_mut();\n-        match interner.get().find(&key) {\n-          Some(t) => unsafe { return cast::transmute(&t.sty); },\n-          _ => ()\n-        }\n+    match cx.interner.borrow().find(&key) {\n+        Some(t) => unsafe { return cast::transmute(&t.sty); },\n+        _ => ()\n     }\n \n     let mut flags = 0u;\n@@ -1255,8 +1252,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n         sty: sty_ptr,\n     };\n \n-    let mut interner = cx.interner.borrow_mut();\n-    interner.get().insert(key, t);\n+    cx.interner.borrow_mut().insert(key, t);\n \n     cx.next_id.set(cx.next_id.get() + 1);\n \n@@ -1762,21 +1758,15 @@ pub fn type_needs_drop(cx: &ctxt, ty: t) -> bool {\n // that only contain scalars and shared boxes can avoid unwind\n // cleanups.\n pub fn type_needs_unwind_cleanup(cx: &ctxt, ty: t) -> bool {\n-    {\n-        let needs_unwind_cleanup_cache = cx.needs_unwind_cleanup_cache\n-                                           .borrow();\n-        match needs_unwind_cleanup_cache.get().find(&ty) {\n-            Some(&result) => return result,\n-            None => ()\n-        }\n+    match cx.needs_unwind_cleanup_cache.borrow().find(&ty) {\n+        Some(&result) => return result,\n+        None => ()\n     }\n \n     let mut tycache = HashSet::new();\n     let needs_unwind_cleanup =\n         type_needs_unwind_cleanup_(cx, ty, &mut tycache, false);\n-    let mut needs_unwind_cleanup_cache = cx.needs_unwind_cleanup_cache\n-                                           .borrow_mut();\n-    needs_unwind_cleanup_cache.get().insert(ty, needs_unwind_cleanup);\n+    cx.needs_unwind_cleanup_cache.borrow_mut().insert(ty, needs_unwind_cleanup);\n     return needs_unwind_cleanup;\n }\n \n@@ -2094,19 +2084,15 @@ pub fn type_interior_is_unsafe(cx: &ctxt, t: ty::t) -> bool {\n pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n     let ty_id = type_id(ty);\n \n-    {\n-        let tc_cache = cx.tc_cache.borrow();\n-        match tc_cache.get().find(&ty_id) {\n-            Some(tc) => { return *tc; }\n-            None => {}\n-        }\n+    match cx.tc_cache.borrow().find(&ty_id) {\n+        Some(tc) => { return *tc; }\n+        None => {}\n     }\n \n     let mut cache = HashMap::new();\n     let result = tc_ty(cx, ty, &mut cache);\n \n-    let mut tc_cache = cx.tc_cache.borrow_mut();\n-    tc_cache.get().insert(ty_id, result);\n+    cx.tc_cache.borrow_mut().insert(ty_id, result);\n     return result;\n \n     fn tc_ty(cx: &ctxt,\n@@ -2139,12 +2125,9 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n             Some(tc) => { return *tc; }\n             None => {}\n         }\n-        {\n-            let tc_cache = cx.tc_cache.borrow();\n-            match tc_cache.get().find(&ty_id) {    // Must check both caches!\n-                Some(tc) => { return *tc; }\n-                None => {}\n-            }\n+        match cx.tc_cache.borrow().find(&ty_id) {    // Must check both caches!\n+            Some(tc) => { return *tc; }\n+            None => {}\n         }\n         cache.insert(ty_id, TC::None);\n \n@@ -2243,7 +2226,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 assert_eq!(p.def_id.krate, ast::LOCAL_CRATE);\n \n                 let ty_param_defs = cx.ty_param_defs.borrow();\n-                let tp_def = ty_param_defs.get().get(&p.def_id.node);\n+                let tp_def = ty_param_defs.get(&p.def_id.node);\n                 kind_bounds_to_contents(cx,\n                                         tp_def.bounds.builtin_bounds,\n                                         tp_def.bounds.trait_bounds.as_slice())\n@@ -2686,7 +2669,7 @@ pub fn type_is_sized(cx: &ctxt, ty: ty::t) -> bool {\n         // FIXME(#6308) add trait, vec, str, etc here.\n         ty_param(p) => {\n             let ty_param_defs = cx.ty_param_defs.borrow();\n-            let param_def = ty_param_defs.get().get(&p.def_id.node);\n+            let param_def = ty_param_defs.get(&p.def_id.node);\n             if param_def.bounds.builtin_bounds.contains_elem(BoundSized) {\n                 return true;\n             }\n@@ -2746,8 +2729,7 @@ pub fn index(t: t) -> Option<mt> {\n }\n \n pub fn node_id_to_trait_ref(cx: &ctxt, id: ast::NodeId) -> @ty::TraitRef {\n-    let trait_refs = cx.trait_refs.borrow();\n-    match trait_refs.get().find(&id) {\n+    match cx.trait_refs.borrow().find(&id) {\n        Some(&t) => t,\n        None => cx.sess.bug(\n            format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n@@ -2756,8 +2738,7 @@ pub fn node_id_to_trait_ref(cx: &ctxt, id: ast::NodeId) -> @ty::TraitRef {\n }\n \n pub fn try_node_id_to_type(cx: &ctxt, id: ast::NodeId) -> Option<t> {\n-    let node_types = cx.node_types.borrow();\n-    node_types.get().find_copy(&(id as uint))\n+    cx.node_types.borrow().find_copy(&(id as uint))\n }\n \n pub fn node_id_to_type(cx: &ctxt, id: ast::NodeId) -> t {\n@@ -2770,26 +2751,22 @@ pub fn node_id_to_type(cx: &ctxt, id: ast::NodeId) -> t {\n }\n \n pub fn node_id_to_type_opt(cx: &ctxt, id: ast::NodeId) -> Option<t> {\n-    let node_types = cx.node_types.borrow();\n-    debug!(\"id: {:?}, node_types: {:?}\", id, node_types);\n-    match node_types.get().find(&(id as uint)) {\n+    match cx.node_types.borrow().find(&(id as uint)) {\n        Some(&t) => Some(t),\n        None => None\n     }\n }\n \n // FIXME(pcwalton): Makes a copy, bleh. Probably better to not do that.\n pub fn node_id_to_type_params(cx: &ctxt, id: ast::NodeId) -> Vec<t> {\n-    let node_type_substs = cx.node_type_substs.borrow();\n-    match node_type_substs.get().find(&id) {\n+    match cx.node_type_substs.borrow().find(&id) {\n       None => return Vec::new(),\n       Some(ts) => return (*ts).clone(),\n     }\n }\n \n fn node_id_has_type_params(cx: &ctxt, id: ast::NodeId) -> bool {\n-    let node_type_substs = cx.node_type_substs.borrow();\n-    node_type_substs.get().contains_key(&id)\n+    cx.node_type_substs.borrow().contains_key(&id)\n }\n \n pub fn fn_is_variadic(fty: t) -> bool {\n@@ -2970,7 +2947,7 @@ pub fn expr_ty_adjusted(cx: &ctxt,\n      */\n \n     let unadjusted_ty = expr_ty(cx, expr);\n-    let adjustment = cx.adjustments.borrow().get().find_copy(&expr.id);\n+    let adjustment = cx.adjustments.borrow().find_copy(&expr.id);\n     adjust_ty(cx, expr.span, expr.id, unadjusted_ty, adjustment, |method_call| {\n         method_map.find(&method_call).map(|method| method.ty)\n     })\n@@ -3260,8 +3237,7 @@ pub fn method_call_type_param_defs(tcx: &ctxt, origin: typeck::MethodOrigin)\n }\n \n pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> ast::Def {\n-    let def_map = tcx.def_map.borrow();\n-    match def_map.get().find(&expr.id) {\n+    match tcx.def_map.borrow().find(&expr.id) {\n         Some(&def) => def,\n         None => {\n             tcx.sess.span_bug(expr.span, format!(\n@@ -3294,7 +3270,7 @@ pub enum ExprKind {\n pub fn expr_kind(tcx: &ctxt,\n                  method_map: MethodMap,\n                  expr: &ast::Expr) -> ExprKind {\n-    if method_map.borrow().get().contains_key(&MethodCall::expr(expr.id)) {\n+    if method_map.borrow().contains_key(&MethodCall::expr(expr.id)) {\n         // Overloaded operations are generally calls, and hence they are\n         // generated via DPS, but there are two exceptions:\n         return match expr.node {\n@@ -3377,8 +3353,7 @@ pub fn expr_kind(tcx: &ctxt,\n         }\n \n         ast::ExprCast(..) => {\n-            let node_types = tcx.node_types.borrow();\n-            match node_types.get().find(&(expr.id as uint)) {\n+            match tcx.node_types.borrow().find(&(expr.id as uint)) {\n                 Some(&t) => {\n                     if type_is_trait(t) {\n                         RvalueDpsExpr\n@@ -3426,8 +3401,7 @@ pub fn expr_kind(tcx: &ctxt,\n \n         ast::ExprBox(place, _) => {\n             // Special case `~T` for now:\n-            let def_map = tcx.def_map.borrow();\n-            let definition = match def_map.get().find(&place.id) {\n+            let definition = match tcx.def_map.borrow().find(&place.id) {\n                 Some(&def) => def,\n                 None => fail!(\"no def for place\"),\n             };\n@@ -3709,8 +3683,7 @@ pub fn def_has_ty_params(def: ast::Def) -> bool {\n }\n \n pub fn provided_source(cx: &ctxt, id: ast::DefId) -> Option<ast::DefId> {\n-    let provided_method_sources = cx.provided_method_sources.borrow();\n-    provided_method_sources.get().find(&id).map(|x| *x)\n+    cx.provided_method_sources.borrow().find(&id).map(|x| *x)\n }\n \n pub fn provided_trait_methods(cx: &ctxt, id: ast::DefId) -> Vec<@Method> {\n@@ -3747,12 +3720,9 @@ pub fn provided_trait_methods(cx: &ctxt, id: ast::DefId) -> Vec<@Method> {\n \n pub fn trait_supertraits(cx: &ctxt, id: ast::DefId) -> @Vec<@TraitRef> {\n     // Check the cache.\n-    {\n-        let supertraits = cx.supertraits.borrow();\n-        match supertraits.get().find(&id) {\n-            Some(&trait_refs) => { return trait_refs; }\n-            None => {}  // Continue.\n-        }\n+    match cx.supertraits.borrow().find(&id) {\n+        Some(&trait_refs) => { return trait_refs; }\n+        None => {}  // Continue.\n     }\n \n     // Not in the cache. It had better be in the metadata, which means it\n@@ -3762,8 +3732,7 @@ pub fn trait_supertraits(cx: &ctxt, id: ast::DefId) -> @Vec<@TraitRef> {\n     // Get the supertraits out of the metadata and create the\n     // TraitRef for each.\n     let result = @csearch::get_supertraits(cx, id);\n-    let mut supertraits = cx.supertraits.borrow_mut();\n-    supertraits.get().insert(id, result);\n+    cx.supertraits.borrow_mut().insert(id, result);\n     return result;\n }\n \n@@ -3808,42 +3777,38 @@ pub fn trait_method(cx: &ctxt, trait_did: ast::DefId, idx: uint) -> @Method {\n \n \n pub fn trait_methods(cx: &ctxt, trait_did: ast::DefId) -> @Vec<@Method> {\n-    let mut trait_methods_cache = cx.trait_methods_cache.borrow_mut();\n-    match trait_methods_cache.get().find(&trait_did) {\n+    let mut trait_methods = cx.trait_methods_cache.borrow_mut();\n+    match trait_methods.find(&trait_did) {\n         Some(&methods) => methods,\n         None => {\n             let def_ids = ty::trait_method_def_ids(cx, trait_did);\n             let methods = @def_ids.map(|d| ty::method(cx, *d));\n-            trait_methods_cache.get().insert(trait_did, methods);\n+            trait_methods.insert(trait_did, methods);\n             methods\n         }\n     }\n }\n \n pub fn method(cx: &ctxt, id: ast::DefId) -> @Method {\n-    let mut methods = cx.methods.borrow_mut();\n-    lookup_locally_or_in_crate_store(\"methods\", id, methods.get(), || {\n+    lookup_locally_or_in_crate_store(\"methods\", id,\n+                                     &mut *cx.methods.borrow_mut(), || {\n         @csearch::get_method(cx, id)\n     })\n }\n \n pub fn trait_method_def_ids(cx: &ctxt, id: ast::DefId) -> @Vec<DefId> {\n-    let mut trait_method_def_ids = cx.trait_method_def_ids.borrow_mut();\n     lookup_locally_or_in_crate_store(\"trait_method_def_ids\",\n                                      id,\n-                                     trait_method_def_ids.get(),\n+                                     &mut *cx.trait_method_def_ids.borrow_mut(),\n                                      || {\n         @csearch::get_trait_method_def_ids(&cx.sess.cstore, id)\n     })\n }\n \n pub fn impl_trait_ref(cx: &ctxt, id: ast::DefId) -> Option<@TraitRef> {\n-    {\n-        let mut impl_trait_cache = cx.impl_trait_cache.borrow_mut();\n-        match impl_trait_cache.get().find(&id) {\n-            Some(&ret) => { return ret; }\n-            None => {}\n-        }\n+    match cx.impl_trait_cache.borrow().find(&id) {\n+        Some(&ret) => { return ret; }\n+        None => {}\n     }\n \n     let ret = if id.krate == ast::LOCAL_CRATE {\n@@ -3868,17 +3833,15 @@ pub fn impl_trait_ref(cx: &ctxt, id: ast::DefId) -> Option<@TraitRef> {\n         csearch::get_impl_trait(cx, id)\n     };\n \n-    let mut impl_trait_cache = cx.impl_trait_cache.borrow_mut();\n-    impl_trait_cache.get().insert(id, ret);\n+    cx.impl_trait_cache.borrow_mut().insert(id, ret);\n     return ret;\n }\n \n pub fn trait_ref_to_def_id(tcx: &ctxt, tr: &ast::TraitRef) -> ast::DefId {\n-    let def_map = tcx.def_map.borrow();\n-    let def = def_map.get()\n+    let def = *tcx.def_map.borrow()\n                      .find(&tr.ref_id)\n                      .expect(\"no def-map entry for trait\");\n-    ast_util::def_id_of_def(*def)\n+    ast_util::def_id_of_def(def)\n }\n \n pub fn try_add_builtin_trait(tcx: &ctxt,\n@@ -4021,8 +3984,7 @@ impl DtorKind {\n /* If struct_id names a struct with a dtor, return Some(the dtor's id).\n    Otherwise return none. */\n pub fn ty_dtor(cx: &ctxt, struct_id: DefId) -> DtorKind {\n-    let destructor_for_type = cx.destructor_for_type.borrow();\n-    match destructor_for_type.get().find(&struct_id) {\n+    match cx.destructor_for_type.borrow().find(&struct_id) {\n         Some(&method_def_id) => {\n             let flag = !has_attr(cx, struct_id, \"unsafe_no_drop_flag\");\n \n@@ -4056,12 +4018,9 @@ pub fn type_is_empty(cx: &ctxt, t: t) -> bool {\n }\n \n pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> @Vec<@VariantInfo> {\n-    {\n-        let enum_var_cache = cx.enum_var_cache.borrow();\n-        match enum_var_cache.get().find(&id) {\n-            Some(&variants) => return variants,\n-            _ => { /* fallthrough */ }\n-        }\n+    match cx.enum_var_cache.borrow().find(&id) {\n+        Some(&variants) => return variants,\n+        _ => { /* fallthrough */ }\n     }\n \n     let result = if ast::LOCAL_CRATE != id.krate {\n@@ -4129,11 +4088,8 @@ pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> @Vec<@VariantInfo> {\n         }\n     };\n \n-    {\n-        let mut enum_var_cache = cx.enum_var_cache.borrow_mut();\n-        enum_var_cache.get().insert(id, result);\n-        result\n-    }\n+    cx.enum_var_cache.borrow_mut().insert(id, result);\n+    result\n }\n \n \n@@ -4160,25 +4116,23 @@ pub fn enum_variant_with_id(cx: &ctxt,\n pub fn lookup_item_type(cx: &ctxt,\n                         did: ast::DefId)\n                      -> ty_param_bounds_and_ty {\n-    let mut tcache = cx.tcache.borrow_mut();\n     lookup_locally_or_in_crate_store(\n-        \"tcache\", did, tcache.get(),\n+        \"tcache\", did, &mut *cx.tcache.borrow_mut(),\n         || csearch::get_type(cx, did))\n }\n \n pub fn lookup_impl_vtables(cx: &ctxt,\n                            did: ast::DefId)\n                      -> typeck::impl_res {\n-    let mut impl_vtables = cx.impl_vtables.borrow_mut();\n     lookup_locally_or_in_crate_store(\n-        \"impl_vtables\", did, impl_vtables.get(),\n+        \"impl_vtables\", did, &mut *cx.impl_vtables.borrow_mut(),\n         || csearch::get_impl_vtables(cx, did) )\n }\n \n /// Given the did of a trait, returns its canonical trait ref.\n pub fn lookup_trait_def(cx: &ctxt, did: ast::DefId) -> @ty::TraitDef {\n     let mut trait_defs = cx.trait_defs.borrow_mut();\n-    match trait_defs.get().find(&did) {\n+    match trait_defs.find(&did) {\n         Some(&trait_def) => {\n             // The item is in this crate. The caller should have added it to the\n             // type cache already\n@@ -4187,7 +4141,7 @@ pub fn lookup_trait_def(cx: &ctxt, did: ast::DefId) -> @ty::TraitDef {\n         None => {\n             assert!(did.krate != ast::LOCAL_CRATE);\n             let trait_def = @csearch::get_trait_def(cx, did);\n-            trait_defs.get().insert(did, trait_def);\n+            trait_defs.insert(did, trait_def);\n             return trait_def;\n         }\n     }\n@@ -4255,16 +4209,14 @@ pub fn lookup_field_type(tcx: &ctxt,\n     let t = if id.krate == ast::LOCAL_CRATE {\n         node_id_to_type(tcx, id.node)\n     } else {\n-        {\n-            let mut tcache = tcx.tcache.borrow_mut();\n-            match tcache.get().find(&id) {\n-               Some(&ty_param_bounds_and_ty {ty, ..}) => ty,\n-               None => {\n-                   let tpt = csearch::get_field_type(tcx, struct_id, id);\n-                   tcache.get().insert(id, tpt.clone());\n-                   tpt.ty\n-               }\n-            }\n+        let mut tcache = tcx.tcache.borrow_mut();\n+        match tcache.find(&id) {\n+           Some(&ty_param_bounds_and_ty {ty, ..}) => ty,\n+           None => {\n+               let tpt = csearch::get_field_type(tcx, struct_id, id);\n+               tcache.insert(id, tpt.clone());\n+               tpt.ty\n+           }\n         }\n     };\n     subst(tcx, substs, t)\n@@ -4444,23 +4396,14 @@ pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n         fn tcx<'a>(&'a self) -> &'a ctxt { let TypeNormalizer(c) = *self; c }\n \n         fn fold_ty(&mut self, t: ty::t) -> ty::t {\n-            let normalized_opt = {\n-                let normalized_cache = self.tcx().normalized_cache.borrow();\n-                normalized_cache.get().find_copy(&t)\n-            };\n-            match normalized_opt {\n-                Some(u) => {\n-                    return u;\n-                }\n-                None => {\n-                    let t_norm = ty_fold::super_fold_ty(self, t);\n-                    let mut normalized_cache = self.tcx()\n-                                                   .normalized_cache\n-                                                   .borrow_mut();\n-                    normalized_cache.get().insert(t, t_norm);\n-                    return t_norm;\n-                }\n+            match self.tcx().normalized_cache.borrow().find_copy(&t) {\n+                None => {}\n+                Some(u) => return u\n             }\n+\n+            let t_norm = ty_fold::super_fold_ty(self, t);\n+            self.tcx().normalized_cache.borrow_mut().insert(t, t_norm);\n+            return t_norm;\n         }\n \n         fn fold_vstore(&mut self, vstore: vstore) -> vstore {\n@@ -4636,16 +4579,14 @@ pub fn count_traits_and_supertraits(tcx: &ctxt,\n \n pub fn get_tydesc_ty(tcx: &ctxt) -> Result<t, ~str> {\n     tcx.lang_items.require(TyDescStructLangItem).map(|tydesc_lang_item| {\n-        let intrinsic_defs = tcx.intrinsic_defs.borrow();\n-        intrinsic_defs.get().find_copy(&tydesc_lang_item)\n+        tcx.intrinsic_defs.borrow().find_copy(&tydesc_lang_item)\n             .expect(\"Failed to resolve TyDesc\")\n     })\n }\n \n pub fn get_opaque_ty(tcx: &ctxt) -> Result<t, ~str> {\n     tcx.lang_items.require(OpaqueStructLangItem).map(|opaque_lang_item| {\n-        let intrinsic_defs = tcx.intrinsic_defs.borrow();\n-        intrinsic_defs.get().find_copy(&opaque_lang_item)\n+        tcx.intrinsic_defs.borrow().find_copy(&opaque_lang_item)\n             .expect(\"Failed to resolve Opaque\")\n     })\n }\n@@ -4672,9 +4613,8 @@ pub fn visitor_object_ty(tcx: &ctxt,\n }\n \n pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> @ItemVariances {\n-    let mut item_variance_map = tcx.item_variance_map.borrow_mut();\n     lookup_locally_or_in_crate_store(\n-        \"item_variance_map\", item_id, item_variance_map.get(),\n+        \"item_variance_map\", item_id, &mut *tcx.item_variance_map.borrow_mut(),\n         || @csearch::get_item_variances(&tcx.sess.cstore, item_id))\n }\n \n@@ -4684,18 +4624,17 @@ fn record_trait_implementation(tcx: &ctxt,\n                                implementation: @Impl) {\n     let implementation_list;\n     let mut trait_impls = tcx.trait_impls.borrow_mut();\n-    match trait_impls.get().find(&trait_def_id) {\n+    match trait_impls.find(&trait_def_id) {\n         None => {\n             implementation_list = @RefCell::new(Vec::new());\n-            trait_impls.get().insert(trait_def_id, implementation_list);\n+            trait_impls.insert(trait_def_id, implementation_list);\n         }\n         Some(&existing_implementation_list) => {\n             implementation_list = existing_implementation_list\n         }\n     }\n \n-    let mut implementation_list = implementation_list.borrow_mut();\n-    implementation_list.get().push(implementation);\n+    implementation_list.borrow_mut().push(implementation);\n }\n \n /// Populates the type context with all the implementations for the given type\n@@ -4705,11 +4644,8 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n     if type_id.krate == LOCAL_CRATE {\n         return\n     }\n-    {\n-        let populated_external_types = tcx.populated_external_types.borrow();\n-        if populated_external_types.get().contains(&type_id) {\n-            return\n-        }\n+    if tcx.populated_external_types.borrow().contains(&type_id) {\n+        return\n     }\n \n     csearch::each_implementation_for_type(&tcx.sess.cstore, type_id,\n@@ -4729,40 +4665,32 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n         // the map. This is a bit unfortunate.\n         for method in implementation.methods.iter() {\n             for source in method.provided_source.iter() {\n-                let mut provided_method_sources =\n-                    tcx.provided_method_sources.borrow_mut();\n-                provided_method_sources.get().insert(method.def_id, *source);\n+                tcx.provided_method_sources.borrow_mut()\n+                   .insert(method.def_id, *source);\n             }\n         }\n \n         // If this is an inherent implementation, record it.\n         if associated_traits.is_none() {\n             let implementation_list;\n             let mut inherent_impls = tcx.inherent_impls.borrow_mut();\n-            match inherent_impls.get().find(&type_id) {\n+            match inherent_impls.find(&type_id) {\n                 None => {\n                     implementation_list = @RefCell::new(Vec::new());\n-                    inherent_impls.get().insert(type_id, implementation_list);\n+                    inherent_impls.insert(type_id, implementation_list);\n                 }\n                 Some(&existing_implementation_list) => {\n                     implementation_list = existing_implementation_list;\n                 }\n             }\n-            {\n-                let mut implementation_list =\n-                    implementation_list.borrow_mut();\n-                implementation_list.get().push(implementation);\n-            }\n+            implementation_list.borrow_mut().push(implementation);\n         }\n \n         // Store the implementation info.\n-        let mut impls = tcx.impls.borrow_mut();\n-        impls.get().insert(implementation_def_id, implementation);\n+        tcx.impls.borrow_mut().insert(implementation_def_id, implementation);\n     });\n \n-    let mut populated_external_types = tcx.populated_external_types\n-                                          .borrow_mut();\n-    populated_external_types.get().insert(type_id);\n+    tcx.populated_external_types.borrow_mut().insert(type_id);\n }\n \n /// Populates the type context with all the implementations for the given\n@@ -4773,12 +4701,8 @@ pub fn populate_implementations_for_trait_if_necessary(\n     if trait_id.krate == LOCAL_CRATE {\n         return\n     }\n-    {\n-        let populated_external_traits = tcx.populated_external_traits\n-                                           .borrow();\n-        if populated_external_traits.get().contains(&trait_id) {\n-            return\n-        }\n+    if tcx.populated_external_traits.borrow().contains(&trait_id) {\n+        return\n     }\n \n     csearch::each_implementation_for_trait(&tcx.sess.cstore, trait_id,\n@@ -4792,20 +4716,16 @@ pub fn populate_implementations_for_trait_if_necessary(\n         // the map. This is a bit unfortunate.\n         for method in implementation.methods.iter() {\n             for source in method.provided_source.iter() {\n-                let mut provided_method_sources =\n-                    tcx.provided_method_sources.borrow_mut();\n-                provided_method_sources.get().insert(method.def_id, *source);\n+                tcx.provided_method_sources.borrow_mut()\n+                   .insert(method.def_id, *source);\n             }\n         }\n \n         // Store the implementation info.\n-        let mut impls = tcx.impls.borrow_mut();\n-        impls.get().insert(implementation_def_id, implementation);\n+        tcx.impls.borrow_mut().insert(implementation_def_id, implementation);\n     });\n \n-    let mut populated_external_traits = tcx.populated_external_traits\n-                                           .borrow_mut();\n-    populated_external_traits.get().insert(trait_id);\n+    tcx.populated_external_traits.borrow_mut().insert(trait_id);\n }\n \n /// Given the def_id of an impl, return the def_id of the trait it implements.\n@@ -4837,12 +4757,7 @@ pub fn trait_of_method(tcx: &ctxt, def_id: ast::DefId)\n     if def_id.krate != LOCAL_CRATE {\n         return csearch::get_trait_of_method(&tcx.sess.cstore, def_id, tcx);\n     }\n-    let method;\n-    {\n-        let methods = tcx.methods.borrow();\n-        method = methods.get().find(&def_id).map(|method| *method);\n-    }\n-    match method {\n+    match tcx.methods.borrow().find(&def_id).map(|m| *m) {\n         Some(method) => {\n             match method.container {\n                 TraitContainer(def_id) => Some(def_id),\n@@ -4861,14 +4776,10 @@ pub fn trait_of_method(tcx: &ctxt, def_id: ast::DefId)\n /// Otherwise, return `None`.\n pub fn trait_method_of_method(tcx: &ctxt,\n                               def_id: ast::DefId) -> Option<ast::DefId> {\n-    let method;\n-    {\n-        let methods = tcx.methods.borrow();\n-        match methods.get().find(&def_id) {\n-            Some(m) => method = *m,\n-            None => return None,\n-        }\n-    }\n+    let method = match tcx.methods.borrow().find(&def_id) {\n+        Some(&m) => m,\n+        None => return None,\n+    };\n     let name = method.ident.name;\n     match trait_of_method(tcx, def_id) {\n         Some(trait_did) => {"}, {"sha": "93962b3e41087b3c647e641253f4129ee5f8643c", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -324,8 +324,7 @@ fn check_path_args(tcx: &ty::ctxt,\n pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n     match ast_ty.node {\n         ast::TyPath(ref path, _, id) => {\n-            let def_map = tcx.def_map.borrow();\n-            let a_def = match def_map.get().find(&id) {\n+            let a_def = match tcx.def_map.borrow().find(&id) {\n                 None => tcx.sess.span_fatal(\n                     ast_ty.span, format!(\"unbound path {}\", path_to_str(path))),\n                 Some(&d) => d\n@@ -430,8 +429,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 // Note that the \"bounds must be empty if path is not a trait\"\n                 // restriction is enforced in the below case for ty_path, which\n                 // will run after this as long as the path isn't a trait.\n-                let def_map = tcx.def_map.borrow();\n-                match def_map.get().find(&id) {\n+                match tcx.def_map.borrow().find(&id) {\n                     Some(&ast::DefPrimTy(ast::TyStr)) if\n                             a_seq_ty.mutbl == ast::MutImmutable => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n@@ -474,20 +472,19 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n \n     let tcx = this.tcx();\n \n-    {\n-        let mut ast_ty_to_ty_cache = tcx.ast_ty_to_ty_cache.borrow_mut();\n-        match ast_ty_to_ty_cache.get().find(&ast_ty.id) {\n-            Some(&ty::atttce_resolved(ty)) => return ty,\n-            Some(&ty::atttce_unresolved) => {\n-                tcx.sess.span_fatal(ast_ty.span,\n-                                    \"illegal recursive type; insert an enum \\\n-                                     or struct in the cycle, if this is \\\n-                                     desired\");\n-            }\n-            None => { /* go on */ }\n+    let mut ast_ty_to_ty_cache = tcx.ast_ty_to_ty_cache.borrow_mut();\n+    match ast_ty_to_ty_cache.find(&ast_ty.id) {\n+        Some(&ty::atttce_resolved(ty)) => return ty,\n+        Some(&ty::atttce_unresolved) => {\n+            tcx.sess.span_fatal(ast_ty.span,\n+                                \"illegal recursive type; insert an enum \\\n+                                 or struct in the cycle, if this is \\\n+                                 desired\");\n         }\n-        ast_ty_to_ty_cache.get().insert(ast_ty.id, ty::atttce_unresolved);\n+        None => { /* go on */ }\n     }\n+    ast_ty_to_ty_cache.insert(ast_ty.id, ty::atttce_unresolved);\n+    drop(ast_ty_to_ty_cache);\n \n     let typ = ast_ty_to_prim_ty(tcx, ast_ty).unwrap_or_else(|| match ast_ty.node {\n             ast::TyNil => ty::mk_nil(),\n@@ -556,8 +553,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 ty::mk_closure(tcx, fn_decl)\n             }\n             ast::TyPath(ref path, ref bounds, id) => {\n-                let def_map = tcx.def_map.borrow();\n-                let a_def = match def_map.get().find(&id) {\n+                let a_def = match tcx.def_map.borrow().find(&id) {\n                     None => tcx.sess.span_fatal(\n                         ast_ty.span, format!(\"unbound path {}\", path_to_str(path))),\n                     Some(&d) => d\n@@ -645,8 +641,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n             }\n         });\n \n-    let mut ast_ty_to_ty_cache = tcx.ast_ty_to_ty_cache.borrow_mut();\n-    ast_ty_to_ty_cache.get().insert(ast_ty.id, ty::atttce_resolved(typ));\n+    tcx.ast_ty_to_ty_cache.borrow_mut().insert(ast_ty.id, ty::atttce_resolved(typ));\n     return typ;\n }\n "}, {"sha": "9518e16d269e9d9a36eb4aa7140fa10c063ac819", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -364,8 +364,7 @@ pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::NodeId, span: Span,\n     let class_fields = ty::lookup_struct_fields(tcx, struct_id);\n \n     // Check to ensure that the struct is the one specified.\n-    let def_map = tcx.def_map.borrow();\n-    match def_map.get().find(&pat_id) {\n+    match tcx.def_map.borrow().find(&pat_id) {\n         Some(&ast::DefStruct(supplied_def_id))\n                 if supplied_def_id == struct_id => {\n             // OK.\n@@ -399,8 +398,7 @@ pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n     let tcx = pcx.fcx.ccx.tcx;\n \n     // Find the variant that was specified.\n-    let def_map = tcx.def_map.borrow();\n-    match def_map.get().find(&pat_id) {\n+    match tcx.def_map.borrow().find(&pat_id) {\n         Some(&ast::DefVariant(found_enum_id, variant_id, _))\n                 if found_enum_id == enum_id => {\n             // Get the struct fields from this struct-like enum variant.\n@@ -470,9 +468,8 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n       }\n       ast::PatEnum(..) |\n       ast::PatIdent(..) if pat_is_const(tcx.def_map, pat) => {\n-        let def_map = tcx.def_map.borrow();\n-        let const_did = ast_util::def_id_of_def(def_map.get()\n-                                                       .get_copy(&pat.id));\n+        let const_did = ast_util::def_id_of_def(tcx.def_map.borrow()\n+                                                   .get_copy(&pat.id));\n         let const_tpt = ty::lookup_item_type(tcx, const_did);\n         demand::suptype(fcx, pat.span, expected, const_tpt.ty);\n         fcx.write_ty(pat.id, const_tpt.ty);\n@@ -548,8 +545,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                                          e, actual)})},\n                                          Some(expected), ~\"a structure pattern\",\n                                          None);\n-                let def_map = tcx.def_map.borrow();\n-                match def_map.get().find(&pat.id) {\n+                match tcx.def_map.borrow().find(&pat.id) {\n                     Some(&ast::DefStruct(supplied_def_id)) => {\n                          check_struct_pat(pcx,\n                                           pat.id,"}, {"sha": "782d208e2f9b12c16fa68e9d79ebc37d8d8ea33d", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -466,8 +466,8 @@ impl<'a> LookupContext<'a> {\n         ty::populate_implementations_for_trait_if_necessary(self.tcx(), trait_did);\n \n         // Look for explicit implementations.\n-        for impl_infos in self.tcx().trait_impls.borrow().get().find(&trait_did).iter() {\n-            for impl_info in impl_infos.borrow().get().iter() {\n+        for impl_infos in self.tcx().trait_impls.borrow().find(&trait_did).iter() {\n+            for impl_info in impl_infos.borrow().iter() {\n                 self.push_candidates_from_impl(*impl_info, true);\n             }\n         }\n@@ -641,8 +641,8 @@ impl<'a> LookupContext<'a> {\n         // metadata if necessary.\n         ty::populate_implementations_for_type_if_necessary(self.tcx(), did);\n \n-        for impl_infos in self.tcx().inherent_impls.borrow().get().find(&did).iter() {\n-            for impl_info in impl_infos.borrow().get().iter() {\n+        for impl_infos in self.tcx().inherent_impls.borrow().find(&did).iter() {\n+            for impl_info in impl_infos.borrow().iter() {\n                 self.push_candidates_from_impl(*impl_info, false);\n             }\n         }\n@@ -1259,17 +1259,14 @@ impl<'a> LookupContext<'a> {\n         let bad;\n         match candidate.origin {\n             MethodStatic(method_id) => {\n-                let destructors = self.tcx().destructors.borrow();\n-                bad = destructors.get().contains(&method_id);\n+                bad = self.tcx().destructors.borrow().contains(&method_id);\n             }\n             // FIXME: does this properly enforce this on everything now\n             // that self has been merged in? -sully\n             MethodParam(MethodParam { trait_id: trait_id, .. }) |\n             MethodObject(MethodObject { trait_id: trait_id, .. }) => {\n-                let destructor_for_type = self.tcx()\n-                                              .destructor_for_type\n-                                              .borrow();\n-                bad = destructor_for_type.get().contains_key(&trait_id);\n+                bad = self.tcx().destructor_for_type.borrow()\n+                          .contains_key(&trait_id);\n             }\n         }\n "}, {"sha": "256806690fbecbe98a4f051cf4cd351f638b815b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 28, "deletions": 50, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -355,13 +355,11 @@ impl<'a> GatherLocalsVisitor<'a> {\n                     // infer the variable's type\n                     let var_id = self.fcx.infcx().next_ty_var_id();\n                     let var_ty = ty::mk_var(self.fcx.tcx(), var_id);\n-                    let mut locals = self.fcx.inh.locals.borrow_mut();\n-                    locals.get().insert(nid, var_ty);\n+                    self.fcx.inh.locals.borrow_mut().insert(nid, var_ty);\n                 }\n                 Some(typ) => {\n                     // take type that the user specified\n-                    let mut locals = self.fcx.inh.locals.borrow_mut();\n-                    locals.get().insert(nid, typ);\n+                    self.fcx.inh.locals.borrow_mut().insert(nid, typ);\n                 }\n             }\n     }\n@@ -375,13 +373,10 @@ impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n               _ => Some(self.fcx.to_ty(local.ty))\n             };\n             self.assign(local.id, o_ty);\n-            {\n-                let locals = self.fcx.inh.locals.borrow();\n-                debug!(\"Local variable {} is assigned type {}\",\n-                       self.fcx.pat_to_str(local.pat),\n-                       self.fcx.infcx().ty_to_str(\n-                           locals.get().get_copy(&local.id)));\n-            }\n+            debug!(\"Local variable {} is assigned type {}\",\n+                   self.fcx.pat_to_str(local.pat),\n+                   self.fcx.infcx().ty_to_str(\n+                       self.fcx.inh.locals.borrow().get_copy(&local.id)));\n             visit::walk_local(self, local, ());\n \n     }\n@@ -391,13 +386,10 @@ impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n               ast::PatIdent(_, ref path, _)\n                   if pat_util::pat_is_binding(self.fcx.ccx.tcx.def_map, p) => {\n                 self.assign(p.id, None);\n-                {\n-                    let locals = self.fcx.inh.locals.borrow();\n-                    debug!(\"Pattern binding {} is assigned to {}\",\n-                           token::get_ident(path.segments.get(0).identifier),\n-                           self.fcx.infcx().ty_to_str(\n-                               locals.get().get_copy(&p.id)));\n-                }\n+                debug!(\"Pattern binding {} is assigned to {}\",\n+                       token::get_ident(path.segments.get(0).identifier),\n+                       self.fcx.infcx().ty_to_str(\n+                           self.fcx.inh.locals.borrow().get_copy(&p.id)));\n               }\n               _ => {}\n             }\n@@ -1007,8 +999,7 @@ impl<'a> FnCtxt<'a> {\n     }\n \n     pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> ty::t {\n-        let locals = self.inh.locals.borrow();\n-        match locals.get().find(&nid) {\n+        match self.inh.locals.borrow().find(&nid) {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.span_bug(\n@@ -1026,8 +1017,7 @@ impl<'a> FnCtxt<'a> {\n     pub fn write_ty(&self, node_id: ast::NodeId, ty: ty::t) {\n         debug!(\"write_ty({}, {}) in fcx {}\",\n                node_id, ppaux::ty_to_str(self.tcx(), ty), self.tag());\n-        let mut node_types = self.inh.node_types.borrow_mut();\n-        node_types.get().insert(node_id, ty);\n+        self.inh.node_types.borrow_mut().insert(node_id, ty);\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::substs) {\n@@ -1037,8 +1027,7 @@ impl<'a> FnCtxt<'a> {\n                    ty::substs_to_str(self.tcx(), &substs),\n                    self.tag());\n \n-            let mut node_type_substs = self.inh.node_type_substs.borrow_mut();\n-            node_type_substs.get().insert(node_id, substs);\n+            self.inh.node_type_substs.borrow_mut().insert(node_id, substs);\n         }\n     }\n \n@@ -1067,8 +1056,7 @@ impl<'a> FnCtxt<'a> {\n                             node_id: ast::NodeId,\n                             adj: @ty::AutoAdjustment) {\n         debug!(\"write_adjustment(node_id={:?}, adj={:?})\", node_id, adj);\n-        let mut adjustments = self.inh.adjustments.borrow_mut();\n-        adjustments.get().insert(node_id, adj);\n+        self.inh.adjustments.borrow_mut().insert(node_id, adj);\n     }\n \n     pub fn write_nil(&self, node_id: ast::NodeId) {\n@@ -1090,8 +1078,7 @@ impl<'a> FnCtxt<'a> {\n     }\n \n     pub fn expr_ty(&self, ex: &ast::Expr) -> ty::t {\n-        let node_types = self.inh.node_types.borrow();\n-        match node_types.get().find(&ex.id) {\n+        match self.inh.node_types.borrow().find(&ex.id) {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(format!(\"no type for expr in fcx {}\",\n@@ -1101,7 +1088,7 @@ impl<'a> FnCtxt<'a> {\n     }\n \n     pub fn node_ty(&self, id: ast::NodeId) -> ty::t {\n-        match self.inh.node_types.borrow().get().find(&id) {\n+        match self.inh.node_types.borrow().find(&id) {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(\n@@ -1113,7 +1100,7 @@ impl<'a> FnCtxt<'a> {\n     }\n \n     pub fn node_ty_substs(&self, id: ast::NodeId) -> ty::substs {\n-        match self.inh.node_type_substs.borrow().get().find(&id) {\n+        match self.inh.node_type_substs.borrow().find(&id) {\n             Some(ts) => (*ts).clone(),\n             None => {\n                 self.tcx().sess.bug(\n@@ -1125,7 +1112,7 @@ impl<'a> FnCtxt<'a> {\n     }\n \n     pub fn method_ty_substs(&self, id: ast::NodeId) -> ty::substs {\n-        match self.inh.method_map.borrow().get().find(&MethodCall::expr(id)) {\n+        match self.inh.method_map.borrow().find(&MethodCall::expr(id)) {\n             Some(method) => method.substs.clone(),\n             None => {\n                 self.tcx().sess.bug(\n@@ -1140,8 +1127,7 @@ impl<'a> FnCtxt<'a> {\n                               id: ast::NodeId,\n                               f: |&ty::substs| -> bool)\n                               -> bool {\n-        let node_type_substs = self.inh.node_type_substs.borrow();\n-        match node_type_substs.get().find(&id) {\n+        match self.inh.node_type_substs.borrow().find(&id) {\n             Some(s) => f(s),\n             None => true\n         }\n@@ -1327,7 +1313,7 @@ fn try_overloaded_deref(fcx: &FnCtxt,\n             let ref_ty = ty::ty_fn_ret(method.ty);\n             match method_call {\n                 Some(method_call) => {\n-                    fcx.inh.method_map.borrow_mut().get().insert(method_call, method);\n+                    fcx.inh.method_map.borrow_mut().insert(method_call, method);\n                 }\n                 None => {}\n             }\n@@ -1908,7 +1894,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             Some(method) => {\n                 let method_ty = method.ty;\n                 let method_call = MethodCall::expr(expr.id);\n-                fcx.inh.method_map.borrow_mut().get().insert(method_call, method);\n+                fcx.inh.method_map.borrow_mut().insert(method_call, method);\n                 method_ty\n             }\n             None => {\n@@ -1998,7 +1984,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 let method_ty = method.ty;\n                 // HACK(eddyb) Fully qualified path to work around a resolve bug.\n                 let method_call = ::middle::typeck::MethodCall::expr(op_ex.id);\n-                fcx.inh.method_map.borrow_mut().get().insert(method_call, method);\n+                fcx.inh.method_map.borrow_mut().insert(method_call, method);\n                 check_method_argument_types(fcx, op_ex.span,\n                                             method_ty, op_ex,\n                                             args, DoDerefArgs)\n@@ -3131,8 +3117,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       }\n       ast::ExprStruct(ref path, ref fields, base_expr) => {\n         // Resolve the path.\n-        let def_map = tcx.def_map.borrow();\n-        match def_map.get().find(&id) {\n+        match tcx.def_map.borrow().find(&id) {\n             Some(&ast::DefStruct(type_def_id)) => {\n                 check_struct_constructor(fcx, id, expr.span, type_def_id,\n                                          fields.as_slice(), base_expr);\n@@ -3323,8 +3308,8 @@ pub fn check_block_with_expected(fcx: &FnCtxt,\n                                  expected: Option<ty::t>) {\n     let prev = {\n         let mut fcx_ps = fcx.ps.borrow_mut();\n-        let purity_state = fcx_ps.get().recurse(blk);\n-        replace(fcx_ps.get(), purity_state)\n+        let purity_state = fcx_ps.recurse(blk);\n+        replace(&mut *fcx_ps, purity_state)\n     };\n \n     fcx.with_region_lb(blk.id, || {\n@@ -3394,10 +3379,7 @@ pub fn check_const(ccx: &CrateCtxt,\n     let inh = blank_inherited_fields(ccx);\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx = blank_fn_ctxt(ccx, &inh, rty, e.id);\n-    let declty = {\n-        let tcache = fcx.ccx.tcx.tcache.borrow();\n-        tcache.get().get(&local_def(id)).ty\n-    };\n+    let declty = fcx.ccx.tcx.tcache.borrow().get(&local_def(id)).ty;\n     check_const_with_ty(&fcx, sp, e, declty);\n }\n \n@@ -3608,10 +3590,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n     let variants = do_check(ccx, vs, id, hint);\n \n     // cache so that ty::enum_variants won't repeat this work\n-    {\n-        let mut enum_var_cache = ccx.tcx.enum_var_cache.borrow_mut();\n-        enum_var_cache.get().insert(local_def(id), @variants);\n-    }\n+    ccx.tcx.enum_var_cache.borrow_mut().insert(local_def(id), @variants);\n \n     // Check that it is possible to represent this enum.\n     check_representable(ccx.tcx, sp, id, \"enum\");\n@@ -3958,8 +3937,7 @@ pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: ast::P<ast::Block>) -> bool\n     (block_query(b, |e| {\n         match e.node {\n             ast::ExprBreak(Some(_)) => {\n-                let def_map = cx.def_map.borrow();\n-                match def_map.get().find(&e.id) {\n+                match cx.def_map.borrow().find(&e.id) {\n                     Some(&ast::DefLabel(loop_id)) if id == loop_id => true,\n                     _ => false,\n                 }"}, {"sha": "e67a83cd9269db5eac4d092094a2d82e54483b74", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -241,7 +241,7 @@ impl<'a> Rcx<'a> {\n     }\n \n     fn resolve_method_type(&self, method_call: MethodCall) -> Option<ty::t> {\n-        let method_ty = self.fcx.inh.method_map.borrow().get()\n+        let method_ty = self.fcx.inh.method_map.borrow()\n                             .find(&method_call).map(|method| method.ty);\n         method_ty.map(|method_ty| self.resolve_type(method_ty))\n     }\n@@ -253,7 +253,7 @@ impl<'a> Rcx<'a> {\n             ty_unadjusted\n         } else {\n             let tcx = self.fcx.tcx();\n-            let adjustment = self.fcx.inh.adjustments.borrow().get().find_copy(&expr.id);\n+            let adjustment = self.fcx.inh.adjustments.borrow().find_copy(&expr.id);\n             ty::adjust_ty(tcx, expr.span, expr.id, ty_unadjusted, adjustment,\n                           |method_call| self.resolve_method_type(method_call))\n         }\n@@ -275,21 +275,19 @@ impl<'a, 'b> mc::Typer for &'a mut Rcx<'b> {\n     }\n \n     fn adjustment(&mut self, id: ast::NodeId) -> Option<@ty::AutoAdjustment> {\n-        let adjustments = self.fcx.inh.adjustments.borrow();\n-        adjustments.get().find_copy(&id)\n+        self.fcx.inh.adjustments.borrow().find_copy(&id)\n     }\n \n     fn is_method_call(&mut self, id: ast::NodeId) -> bool {\n-        self.fcx.inh.method_map.borrow().get().contains_key(&MethodCall::expr(id))\n+        self.fcx.inh.method_map.borrow().contains_key(&MethodCall::expr(id))\n     }\n \n     fn temporary_scope(&mut self, id: ast::NodeId) -> Option<ast::NodeId> {\n         self.tcx().region_maps.temporary_scope(id)\n     }\n \n     fn upvar_borrow(&mut self, id: ty::UpvarId) -> ty::UpvarBorrow {\n-        let upvar_borrow_map = self.fcx.inh.upvar_borrow_map.borrow();\n-        upvar_borrow_map.get().get_copy(&id)\n+        self.fcx.inh.upvar_borrow_map.borrow().get_copy(&id)\n     }\n }\n \n@@ -403,7 +401,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     let has_method_map = rcx.fcx.inh.method_map.get().contains_key(&method_call);\n \n     // Check any autoderefs or autorefs that appear.\n-    for &adjustment in rcx.fcx.inh.adjustments.borrow().get().find(&expr.id).iter() {\n+    for &adjustment in rcx.fcx.inh.adjustments.borrow().find(&expr.id).iter() {\n         debug!(\"adjustment={:?}\", adjustment);\n         match **adjustment {\n             ty::AutoDerefRef(ty::AutoDerefRef {autoderefs, autoref: opt_autoref}) => {\n@@ -678,8 +676,8 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             // immutable as dictated by the uses.\n             let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow,\n                                                  region: freevar_region };\n-            let mut upvar_borrow_map = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-            upvar_borrow_map.get().insert(upvar_id, upvar_borrow);\n+            rcx.fcx.inh.upvar_borrow_map.borrow_mut().insert(upvar_id,\n+                                                             upvar_borrow);\n \n             // Guarantee that the closure does not outlive the variable itself.\n             let en_region = region_of_def(rcx.fcx, def);\n@@ -951,7 +949,7 @@ fn constrain_regions_in_type_of_node(\n     // is going to fail anyway, so just stop here and let typeck\n     // report errors later on in the writeback phase.\n     let ty0 = rcx.resolve_node_type(id);\n-    let adjustment = rcx.fcx.inh.adjustments.borrow().get().find_copy(&id);\n+    let adjustment = rcx.fcx.inh.adjustments.borrow().find_copy(&id);\n     let ty = ty::adjust_ty(tcx, origin.span(), id, ty0, adjustment,\n                            |method_call| rcx.resolve_method_type(method_call));\n     debug!(\"constrain_regions_in_type_of_node(\\\n@@ -1204,9 +1202,8 @@ fn link_region(rcx: &mut Rcx,\n                 // to use for each upvar.\n                 let cause = match base.cat {\n                     mc::cat_upvar(ref upvar_id, _) => {\n-                        let mut upvar_borrow_map =\n-                            rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-                        match upvar_borrow_map.get().find_mut(upvar_id) {\n+                        match rcx.fcx.inh.upvar_borrow_map.borrow_mut()\n+                                 .find_mut(upvar_id) {\n                             Some(upvar_borrow) => {\n                                 debug!(\"link_region: {} <= {}\",\n                                        region_min.repr(rcx.tcx()),\n@@ -1324,7 +1321,7 @@ fn adjust_upvar_borrow_kind_for_mut(rcx: &mut Rcx,\n                         // is inferred to mutable if necessary\n                         let mut upvar_borrow_map =\n                             rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-                        let ub = upvar_borrow_map.get().get_mut(upvar_id);\n+                        let ub = upvar_borrow_map.get_mut(upvar_id);\n                         return adjust_upvar_borrow_kind(*upvar_id, ub, ty::MutBorrow);\n                     }\n \n@@ -1377,9 +1374,8 @@ fn adjust_upvar_borrow_kind_for_unique(rcx: &mut Rcx,\n                         // upvar, then we need to modify the\n                         // borrow_kind of the upvar to make sure it\n                         // is inferred to unique if necessary\n-                        let mut upvar_borrow_map =\n-                            rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-                        let ub = upvar_borrow_map.get().get_mut(upvar_id);\n+                        let mut ub = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n+                        let ub = ub.get_mut(upvar_id);\n                         return adjust_upvar_borrow_kind(*upvar_id, ub, ty::UniqueImmBorrow);\n                     }\n \n@@ -1419,8 +1415,8 @@ fn link_upvar_borrow_kind_for_nested_closures(rcx: &mut Rcx,\n            inner_upvar_id, outer_upvar_id);\n \n     let mut upvar_borrow_map = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-    let inner_borrow = upvar_borrow_map.get().get_copy(&inner_upvar_id);\n-    match upvar_borrow_map.get().find_mut(&outer_upvar_id) {\n+    let inner_borrow = upvar_borrow_map.get_copy(&inner_upvar_id);\n+    match upvar_borrow_map.find_mut(&outer_upvar_id) {\n         Some(outer_borrow) => {\n             adjust_upvar_borrow_kind(outer_upvar_id, outer_borrow, inner_borrow.kind);\n         }"}, {"sha": "320adcac577a042bbf82d749f5917d1264caa6fd", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -321,15 +321,10 @@ fn search_for_vtable(vcx: &VtableContext,\n \n     // FIXME: this is a bad way to do this, since we do\n     // pointless allocations.\n-    let impls = {\n-        let trait_impls = tcx.trait_impls.borrow();\n-        trait_impls.get()\n-                   .find(&trait_ref.def_id)\n-                   .map_or(@RefCell::new(Vec::new()), |x| *x)\n-    };\n+    let impls = tcx.trait_impls.borrow().find(&trait_ref.def_id)\n+                               .map_or(@RefCell::new(Vec::new()), |x| *x);\n     // impls is the list of all impls in scope for trait_ref.\n-    let impls = impls.borrow();\n-    for im in impls.get().iter() {\n+    for im in impls.borrow().iter() {\n         // im is one specific impl of trait_ref.\n \n         // First, ensure we haven't processed this impl yet.\n@@ -524,7 +519,7 @@ fn connect_trait_tps(vcx: &VtableContext,\n fn insert_vtables(fcx: &FnCtxt, expr_id: ast::NodeId, vtables: vtable_res) {\n     debug!(\"insert_vtables(expr_id={}, vtables={:?})\",\n            expr_id, vtables.repr(fcx.tcx()));\n-    fcx.inh.vtable_map.borrow_mut().get().insert(expr_id, vtables);\n+    fcx.inh.vtable_map.borrow_mut().insert(expr_id, vtables);\n }\n \n pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n@@ -640,8 +635,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n         fcx.opt_node_ty_substs(ex.id, |substs| {\n             debug!(\"vtable resolution on parameter bounds for expr {}\",\n                    ex.repr(fcx.tcx()));\n-            let def_map = cx.tcx.def_map.borrow();\n-            let def = def_map.get().get_copy(&ex.id);\n+            let def = cx.tcx.def_map.borrow().get_copy(&ex.id);\n             let did = ast_util::def_id_of_def(def);\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n             debug!(\"early resolve expr: def {:?} {:?}, {:?}, {}\", ex.id, did, def,\n@@ -667,7 +661,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n       ast::ExprAssignOp(_, _, _) |\n       ast::ExprIndex(_, _) |\n       ast::ExprMethodCall(_, _, _) => {\n-        match fcx.inh.method_map.borrow().get().find(&MethodCall::expr(ex.id)) {\n+        match fcx.inh.method_map.borrow().find(&MethodCall::expr(ex.id)) {\n           Some(method) => {\n             debug!(\"vtable resolution on parameter bounds for method call {}\",\n                    ex.repr(fcx.tcx()));\n@@ -696,8 +690,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n     }\n \n     // Search for auto-adjustments to find trait coercions\n-    let adjustments = fcx.inh.adjustments.borrow();\n-    match adjustments.get().find(&ex.id) {\n+    match fcx.inh.adjustments.borrow().find(&ex.id) {\n         Some(adjustment) => {\n             match **adjustment {\n                 AutoObject(ref sigil,\n@@ -779,8 +772,7 @@ pub fn resolve_impl(tcx: &ty::ctxt,\n     };\n     let impl_def_id = ast_util::local_def(impl_item.id);\n \n-    let mut impl_vtables = tcx.impl_vtables.borrow_mut();\n-    impl_vtables.get().insert(impl_def_id, res);\n+    tcx.impl_vtables.borrow_mut().insert(impl_def_id, res);\n }\n \n /// Resolve vtables for a method call after typeck has finished."}, {"sha": "688baa18c95d1a9130d97262b6dddec3f8d5525e", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -67,7 +67,7 @@ fn resolve_method_map_entry(wbcx: &mut WbCtxt, sp: Span, method_call: MethodCall\n     let tcx = fcx.ccx.tcx;\n \n     // Resolve any method map entry\n-    match fcx.inh.method_map.borrow().get().find(&method_call) {\n+    match fcx.inh.method_map.borrow().find(&method_call) {\n         Some(method) => {\n             debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={:?})\",\n                    method_call, method.repr(tcx));\n@@ -94,18 +94,18 @@ fn resolve_method_map_entry(wbcx: &mut WbCtxt, sp: Span, method_call: MethodCall\n                     self_ty: None\n                 }\n             };\n-            fcx.ccx.method_map.borrow_mut().get().insert(method_call, new_method);\n+            fcx.ccx.method_map.borrow_mut().insert(method_call, new_method);\n         }\n         None => {}\n     }\n }\n \n fn resolve_vtable_map_entry(fcx: &FnCtxt, sp: Span, id: ast::NodeId) {\n     // Resolve any vtable map entry\n-    match fcx.inh.vtable_map.borrow().get().find_copy(&id) {\n+    match fcx.inh.vtable_map.borrow().find_copy(&id) {\n         Some(origins) => {\n             let r_origins = resolve_origins(fcx, sp, origins);\n-            fcx.ccx.vtable_map.borrow_mut().get().insert(id, r_origins);\n+            fcx.ccx.vtable_map.borrow_mut().insert(id, r_origins);\n             debug!(\"writeback::resolve_vtable_map_entry(id={}, vtables={:?})\",\n                     id, r_origins.repr(fcx.tcx()));\n         }\n@@ -141,8 +141,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n     let tcx = fcx.ccx.tcx;\n \n     // Resolve any borrowings for the node with id `id`\n-    let adjustment = fcx.inh.adjustments.borrow().get().find_copy(&id);\n-    match adjustment {\n+    match fcx.inh.adjustments.borrow().find_copy(&id) {\n         None => (),\n \n         Some(adjustment) => {\n@@ -163,7 +162,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                             // FIXME(eddyb) #2190 Allow only statically resolved\n                             // bare functions to coerce to a closure to avoid\n                             // constructing (slower) indirect call wrappers.\n-                            match tcx.def_map.borrow().get().find(&id) {\n+                            match tcx.def_map.borrow().find(&id) {\n                                 Some(&ast::DefFn(..)) |\n                                 Some(&ast::DefStaticMethod(..)) |\n                                 Some(&ast::DefVariant(..)) |\n@@ -175,7 +174,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                             let resolved_adj = @ty::AutoAddEnv(r1, s);\n                             debug!(\"Adjustments for node {}: {:?}\",\n                                    id, resolved_adj);\n-                            tcx.adjustments.borrow_mut().get().insert(id, resolved_adj);\n+                            tcx.adjustments.borrow_mut().insert(id, resolved_adj);\n                         }\n                     }\n                 }\n@@ -213,12 +212,12 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                         autoref: resolved_autoref,\n                     });\n                     debug!(\"Adjustments for node {}: {:?}\", id, resolved_adj);\n-                    tcx.adjustments.borrow_mut().get().insert(id, resolved_adj);\n+                    tcx.adjustments.borrow_mut().insert(id, resolved_adj);\n                 }\n \n                 ty::AutoObject(..) => {\n                     debug!(\"Adjustments for node {}: {:?}\", id, adjustment);\n-                    tcx.adjustments.borrow_mut().get().insert(id, adjustment);\n+                    tcx.adjustments.borrow_mut().insert(id, adjustment);\n                 }\n             }\n         }\n@@ -355,8 +354,7 @@ fn resolve_upvar_borrow_map(wbcx: &mut WbCtxt) {\n \n     let fcx = wbcx.fcx;\n     let tcx = fcx.tcx();\n-    let upvar_borrow_map = fcx.inh.upvar_borrow_map.borrow();\n-    for (upvar_id, upvar_borrow) in upvar_borrow_map.get().iter() {\n+    for (upvar_id, upvar_borrow) in fcx.inh.upvar_borrow_map.borrow().iter() {\n         let r = upvar_borrow.region;\n         match resolve_region(fcx.infcx(), r, resolve_all | force_all) {\n             Ok(r) => {\n@@ -366,8 +364,8 @@ fn resolve_upvar_borrow_map(wbcx: &mut WbCtxt) {\n                 };\n                 debug!(\"Upvar borrow for {} resolved to {}\",\n                        upvar_id.repr(tcx), new_upvar_borrow.repr(tcx));\n-                let mut tcx_upvar_borrow_map = tcx.upvar_borrow_map.borrow_mut();\n-                tcx_upvar_borrow_map.get().insert(*upvar_id, new_upvar_borrow);\n+                tcx.upvar_borrow_map.borrow_mut().insert(*upvar_id,\n+                                                         new_upvar_borrow);\n             }\n             Err(e) => {\n                 let span = ty::expr_span(tcx, upvar_id.closure_expr_id);"}, {"sha": "321de8925acd48f4fa94ef432c78eb60cb613fd7", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 25, "deletions": 47, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -306,8 +306,7 @@ impl<'a> CoherenceChecker<'a> {\n             }\n         }\n \n-        let mut impls = tcx.impls.borrow_mut();\n-        impls.get().insert(implementation.did, implementation);\n+        tcx.impls.borrow_mut().insert(implementation.did, implementation);\n     }\n \n     // Creates default method IDs and performs type substitutions for an impl\n@@ -359,20 +358,13 @@ impl<'a> CoherenceChecker<'a> {\n             };\n             debug!(\"new_polytype={}\", new_polytype.repr(tcx));\n \n-            {\n-                let mut tcache = tcx.tcache.borrow_mut();\n-                tcache.get().insert(new_did, new_polytype);\n-            }\n-\n-            let mut methods = tcx.methods.borrow_mut();\n-            methods.get().insert(new_did, new_method_ty);\n+            tcx.tcache.borrow_mut().insert(new_did, new_polytype);\n+            tcx.methods.borrow_mut().insert(new_did, new_method_ty);\n \n             // Pair the new synthesized ID up with the\n             // ID of the method.\n-            let mut provided_method_sources =\n-                self.crate_context.tcx.provided_method_sources.borrow_mut();\n-            provided_method_sources.get().insert(new_did,\n-                                                 trait_method.def_id);\n+            self.crate_context.tcx.provided_method_sources.borrow_mut()\n+                .insert(new_did, trait_method.def_id);\n         }\n     }\n \n@@ -381,42 +373,39 @@ impl<'a> CoherenceChecker<'a> {\n         let tcx = self.crate_context.tcx;\n         let implementation_list;\n         let mut inherent_impls = tcx.inherent_impls.borrow_mut();\n-        match inherent_impls.get().find(&base_def_id) {\n+        match inherent_impls.find(&base_def_id) {\n             None => {\n                 implementation_list = @RefCell::new(Vec::new());\n-                inherent_impls.get().insert(base_def_id, implementation_list);\n+                inherent_impls.insert(base_def_id, implementation_list);\n             }\n             Some(&existing_implementation_list) => {\n                 implementation_list = existing_implementation_list;\n             }\n         }\n \n-        let mut implementation_list = implementation_list.borrow_mut();\n-        implementation_list.get().push(implementation);\n+        implementation_list.borrow_mut().push(implementation);\n     }\n \n     fn add_trait_impl(&self, base_def_id: DefId,\n                       implementation: @Impl) {\n         let tcx = self.crate_context.tcx;\n         let implementation_list;\n         let mut trait_impls = tcx.trait_impls.borrow_mut();\n-        match trait_impls.get().find(&base_def_id) {\n+        match trait_impls.find(&base_def_id) {\n             None => {\n                 implementation_list = @RefCell::new(Vec::new());\n-                trait_impls.get().insert(base_def_id, implementation_list);\n+                trait_impls.insert(base_def_id, implementation_list);\n             }\n             Some(&existing_implementation_list) => {\n                 implementation_list = existing_implementation_list;\n             }\n         }\n \n-        let mut implementation_list = implementation_list.borrow_mut();\n-        implementation_list.get().push(implementation);\n+        implementation_list.borrow_mut().push(implementation);\n     }\n \n     fn check_implementation_coherence(&self) {\n-        let trait_impls = self.crate_context.tcx.trait_impls.borrow();\n-        for &trait_id in trait_impls.get().keys() {\n+        for &trait_id in self.crate_context.tcx.trait_impls.borrow().keys() {\n             self.check_implementation_coherence_of(trait_id);\n         }\n     }\n@@ -476,11 +465,9 @@ impl<'a> CoherenceChecker<'a> {\n     }\n \n     fn iter_impls_of_trait_local(&self, trait_def_id: DefId, f: |@Impl|) {\n-        let trait_impls = self.crate_context.tcx.trait_impls.borrow();\n-        match trait_impls.get().find(&trait_def_id) {\n+        match self.crate_context.tcx.trait_impls.borrow().find(&trait_def_id) {\n             Some(impls) => {\n-                let impls = impls.borrow();\n-                for &im in impls.get().iter() {\n+                for &im in impls.borrow().iter() {\n                     f(im);\n                 }\n             }\n@@ -543,8 +530,7 @@ impl<'a> CoherenceChecker<'a> {\n \n     fn get_self_type_for_implementation(&self, implementation: @Impl)\n                                         -> ty_param_bounds_and_ty {\n-        let tcache = self.crate_context.tcx.tcache.borrow();\n-        return tcache.get().get_copy(&implementation.did);\n+        self.crate_context.tcx.tcache.borrow().get_copy(&implementation.did)\n     }\n \n     // Privileged scope checking\n@@ -555,8 +541,7 @@ impl<'a> CoherenceChecker<'a> {\n \n     fn trait_ref_to_trait_def_id(&self, trait_ref: &TraitRef) -> DefId {\n         let def_map = self.crate_context.tcx.def_map;\n-        let def_map = def_map.borrow();\n-        let trait_def = def_map.get().get_copy(&trait_ref.ref_id);\n+        let trait_def = def_map.borrow().get_copy(&trait_ref.ref_id);\n         let trait_id = def_id_of_def(trait_def);\n         return trait_id;\n     }\n@@ -567,8 +552,7 @@ impl<'a> CoherenceChecker<'a> {\n     fn ast_type_is_defined_in_local_crate(&self, original_type: &ast::Ty) -> bool {\n         match original_type.node {\n             TyPath(_, _, path_id) => {\n-                let def_map = self.crate_context.tcx.def_map.borrow();\n-                match def_map.get().get_copy(&path_id) {\n+                match self.crate_context.tcx.def_map.borrow().get_copy(&path_id) {\n                     DefTy(def_id) | DefStruct(def_id) => {\n                         if def_id.krate != LOCAL_CRATE {\n                             return false;\n@@ -666,14 +650,12 @@ impl<'a> CoherenceChecker<'a> {\n         // the map. This is a bit unfortunate.\n         for method in implementation.methods.iter() {\n             for source in method.provided_source.iter() {\n-                let mut provided_method_sources = tcx.provided_method_sources\n-                                                     .borrow_mut();\n-                provided_method_sources.get().insert(method.def_id, *source);\n+                tcx.provided_method_sources.borrow_mut()\n+                   .insert(method.def_id, *source);\n             }\n         }\n \n-        let mut impls = tcx.impls.borrow_mut();\n-        impls.get().insert(implementation.did, implementation);\n+        tcx.impls.borrow_mut().insert(implementation.did, implementation);\n     }\n \n     // Adds implementations and traits from external crates to the coherence\n@@ -701,15 +683,14 @@ impl<'a> CoherenceChecker<'a> {\n         };\n \n         let trait_impls = tcx.trait_impls.borrow();\n-        let impls_opt = trait_impls.get().find(&drop_trait);\n+        let impls_opt = trait_impls.find(&drop_trait);\n         let impls;\n         match impls_opt {\n             None => return, // No types with (new-style) dtors present.\n             Some(found_impls) => impls = found_impls\n         }\n \n-        let impls = impls.borrow();\n-        for impl_info in impls.get().iter() {\n+        for impl_info in impls.borrow().iter() {\n             if impl_info.methods.len() < 1 {\n                 // We'll error out later. For now, just don't ICE.\n                 continue;\n@@ -720,12 +701,9 @@ impl<'a> CoherenceChecker<'a> {\n             match ty::get(self_type.ty).sty {\n                 ty::ty_enum(type_def_id, _) |\n                 ty::ty_struct(type_def_id, _) => {\n-                    let mut destructor_for_type = tcx.destructor_for_type\n-                                                     .borrow_mut();\n-                    destructor_for_type.get().insert(type_def_id,\n-                                                     method_def_id);\n-                    let mut destructors = tcx.destructors.borrow_mut();\n-                    destructors.get().insert(method_def_id);\n+                    tcx.destructor_for_type.borrow_mut().insert(type_def_id,\n+                                                                method_def_id);\n+                    tcx.destructors.borrow_mut().insert(method_def_id);\n                 }\n                 _ => {\n                     // Destructors only work on nominal types."}, {"sha": "8e074149b37fd87b95c80870a92029b655d1f1fe", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 66, "deletions": 116, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -82,8 +82,7 @@ pub fn collect_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n                               lang_item: ast::DefId) {\n         let ty::ty_param_bounds_and_ty { ty: ty, .. } =\n             ccx.get_item_ty(lang_item);\n-        let mut intrinsic_defs = ccx.tcx.intrinsic_defs.borrow_mut();\n-        intrinsic_defs.get().insert(lang_item, ty);\n+        ccx.tcx.intrinsic_defs.borrow_mut().insert(lang_item, ty);\n     }\n \n     match ccx.tcx.lang_items.ty_desc() {\n@@ -180,10 +179,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n             ty: result_ty\n         };\n \n-        {\n-            let mut tcache = tcx.tcache.borrow_mut();\n-            tcache.get().insert(local_def(variant.node.id), tpt);\n-        }\n+        tcx.tcache.borrow_mut().insert(local_def(variant.node.id), tpt);\n \n         write_ty_to_tcx(tcx, variant.node.id, result_ty);\n     }\n@@ -221,8 +217,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                                                   &trait_ty_generics);\n                         }\n \n-                        let mut methods = tcx.methods.borrow_mut();\n-                        methods.get().insert(ty_method.def_id, ty_method);\n+                        tcx.methods.borrow_mut().insert(ty_method.def_id,\n+                                                        ty_method);\n                     }\n \n                     // Add an entry mapping\n@@ -238,13 +234,10 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                     });\n \n                     let trait_def_id = local_def(trait_id);\n-                    let mut trait_method_def_ids = tcx.trait_method_def_ids\n-                                                      .borrow_mut();\n-                    trait_method_def_ids.get()\n-                                        .insert(trait_def_id,\n-                                                @method_def_ids.iter()\n-                                                               .map(|x| *x)\n-                                                               .collect());\n+                    tcx.trait_method_def_ids.borrow_mut()\n+                        .insert(trait_def_id, @method_def_ids.iter()\n+                                                             .map(|x| *x)\n+                                                             .collect());\n                 }\n                 _ => {} // Ignore things that aren't traits.\n             }\n@@ -372,8 +365,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                ty.repr(tcx),\n                substs.repr(tcx));\n \n-        let mut tcache = tcx.tcache.borrow_mut();\n-        tcache.get().insert(m.def_id,\n+        tcx.tcache.borrow_mut().insert(m.def_id,\n                           ty_param_bounds_and_ty {\n                               generics: ty::Generics {\n                                   type_param_defs: Rc::new(new_type_param_defs),\n@@ -423,10 +415,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n \n     // Called only the first time trait_def_of_item is called.\n     // Supertraits are ensured at the same time.\n-    {\n-        let supertraits = tcx.supertraits.borrow();\n-        assert!(!supertraits.get().contains_key(&local_def(id)));\n-    }\n+    assert!(!tcx.supertraits.borrow().contains_key(&local_def(id)));\n \n     let self_ty = ty::mk_self(ccx.tcx, local_def(id));\n     let mut ty_trait_refs: Vec<@ty::TraitRef> = Vec::new();\n@@ -451,8 +440,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n         }\n     }\n \n-    let mut supertraits = tcx.supertraits.borrow_mut();\n-    supertraits.get().insert(local_def(id), @ty_trait_refs);\n+    tcx.supertraits.borrow_mut().insert(local_def(id), @ty_trait_refs);\n     bounds\n }\n \n@@ -462,8 +450,7 @@ pub fn convert_field(ccx: &CrateCtxt,\n     let tt = ccx.to_ty(&ExplicitRscope, v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n-    let mut tcache = ccx.tcx.tcache.borrow_mut();\n-    tcache.get().insert(local_def(v.node.id),\n+    ccx.tcx.tcache.borrow_mut().insert(local_def(v.node.id),\n                           ty::ty_param_bounds_and_ty {\n                               generics: struct_generics.clone(),\n                               ty: tt\n@@ -499,32 +486,28 @@ fn convert_methods(ccx: &CrateCtxt,\n                 m.ident.repr(ccx.tcx),\n                 m.id,\n                 fty.repr(ccx.tcx));\n-        {\n-            let mut tcache = tcx.tcache.borrow_mut();\n-            tcache.get().insert(\n-                local_def(m.id),\n-\n-                // n.b.: the type of a method is parameterized by both\n-                // the parameters on the receiver and those on the method\n-                // itself\n-                ty_param_bounds_and_ty {\n-                    generics: ty::Generics {\n-                        type_param_defs: Rc::new(vec::append(\n-                            Vec::from_slice(\n-                                rcvr_ty_generics.type_param_defs()),\n-                            m_ty_generics.type_param_defs())),\n-                        region_param_defs: Rc::new(vec::append(\n-                                Vec::from_slice(rcvr_ty_generics.region_param_defs()),\n-                                m_ty_generics.region_param_defs())),\n-                    },\n-                    ty: fty\n-                });\n-        }\n+        tcx.tcache.borrow_mut().insert(\n+            local_def(m.id),\n+\n+            // n.b.: the type of a method is parameterized by both\n+            // the parameters on the receiver and those on the method\n+            // itself\n+            ty_param_bounds_and_ty {\n+                generics: ty::Generics {\n+                    type_param_defs: Rc::new(vec::append(\n+                        Vec::from_slice(\n+                            rcvr_ty_generics.type_param_defs()),\n+                        m_ty_generics.type_param_defs())),\n+                    region_param_defs: Rc::new(vec::append(\n+                            Vec::from_slice(rcvr_ty_generics.region_param_defs()),\n+                            m_ty_generics.region_param_defs())),\n+                },\n+                ty: fty\n+            });\n \n         write_ty_to_tcx(tcx, m.id, fty);\n \n-        let mut methods = tcx.methods.borrow_mut();\n-        methods.get().insert(mty.def_id, mty);\n+        tcx.methods.borrow_mut().insert(mty.def_id, mty);\n     }\n \n     fn ty_of_method(ccx: &CrateCtxt,\n@@ -605,13 +588,10 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             let selfty = ccx.to_ty(&ExplicitRscope, selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n-            {\n-                let mut tcache = tcx.tcache.borrow_mut();\n-                tcache.get().insert(local_def(it.id),\n-                                    ty_param_bounds_and_ty {\n-                                        generics: ty_generics.clone(),\n-                                        ty: selfty});\n-            }\n+            tcx.tcache.borrow_mut().insert(local_def(it.id),\n+                                ty_param_bounds_and_ty {\n+                                    generics: ty_generics.clone(),\n+                                    ty: selfty});\n \n             // If there is a trait reference, treat the methods as always public.\n             // This is to work around some incorrect behavior in privacy checking:\n@@ -670,10 +650,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             let tpt = ty_of_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, tpt.ty);\n \n-            {\n-                let mut tcache = tcx.tcache.borrow_mut();\n-                tcache.get().insert(local_def(it.id), tpt.clone());\n-            }\n+            tcx.tcache.borrow_mut().insert(local_def(it.id), tpt.clone());\n \n             convert_struct(ccx, struct_def, tpt, it.id);\n         },\n@@ -719,32 +696,23 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                 // Enum-like.\n                 write_ty_to_tcx(tcx, ctor_id, selfty);\n \n-                {\n-                    let mut tcache = tcx.tcache.borrow_mut();\n-                    tcache.get().insert(local_def(ctor_id), tpt);\n-                }\n+                tcx.tcache.borrow_mut().insert(local_def(ctor_id), tpt);\n             } else if struct_def.fields.get(0).node.kind ==\n                     ast::UnnamedField {\n                 // Tuple-like.\n-                let inputs = {\n-                    let tcache = tcx.tcache.borrow();\n-                    struct_def.fields.map(\n-                        |field| tcache.get().get(\n-                            &local_def(field.node.id)).ty)\n-                };\n+                let inputs = struct_def.fields.map(\n+                        |field| tcx.tcache.borrow().get(\n+                            &local_def(field.node.id)).ty);\n                 let ctor_fn_ty = ty::mk_ctor_fn(tcx,\n                                                 ctor_id,\n                                                 inputs.as_slice(),\n                                                 selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n-                {\n-                    let mut tcache = tcx.tcache.borrow_mut();\n-                    tcache.get().insert(local_def(ctor_id),\n-                                      ty_param_bounds_and_ty {\n-                        generics: tpt.generics,\n-                        ty: ctor_fn_ty\n-                    });\n-                }\n+                tcx.tcache.borrow_mut().insert(local_def(ctor_id),\n+                                  ty_param_bounds_and_ty {\n+                    generics: tpt.generics,\n+                    ty: ctor_fn_ty\n+                });\n             }\n         }\n     }\n@@ -764,8 +732,7 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::ForeignItem) {\n     let tpt = ty_of_foreign_item(ccx, i, abis);\n     write_ty_to_tcx(ccx.tcx, i.id, tpt.ty);\n \n-    let mut tcache = ccx.tcx.tcache.borrow_mut();\n-    tcache.get().insert(local_def(i.id), tpt);\n+    ccx.tcx.tcache.borrow_mut().insert(local_def(i.id), tpt);\n }\n \n pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n@@ -787,8 +754,8 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n                 astconv::ast_path_to_trait_ref(\n                     ccx, &rscope, trait_did, Some(self_ty), &ast_trait_ref.path);\n \n-            let mut trait_refs = ccx.tcx.trait_refs.borrow_mut();\n-            trait_refs.get().insert(ast_trait_ref.ref_id, trait_ref);\n+            ccx.tcx.trait_refs.borrow_mut().insert(ast_trait_ref.ref_id,\n+                                                   trait_ref);\n             return trait_ref;\n         }\n         _ => {\n@@ -815,12 +782,9 @@ fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> @ty::TraitDef {\n pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> @ty::TraitDef {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n-    {\n-        let trait_defs = tcx.trait_defs.borrow();\n-        match trait_defs.get().find(&def_id) {\n-          Some(&def) => return def,\n-          _ => {}\n-        }\n+    match tcx.trait_defs.borrow().find(&def_id) {\n+        Some(&def) => return def,\n+        _ => {}\n     }\n \n     match it.node {\n@@ -837,8 +801,7 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> @ty::TraitDef {\n             let trait_def = @ty::TraitDef {generics: ty_generics,\n                                            bounds: bounds,\n                                            trait_ref: trait_ref};\n-            let mut trait_defs = tcx.trait_defs.borrow_mut();\n-            trait_defs.get().insert(def_id, trait_def);\n+            tcx.trait_defs.borrow_mut().insert(def_id, trait_def);\n             return trait_def;\n         }\n         ref s => {\n@@ -853,20 +816,16 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n                   -> ty::ty_param_bounds_and_ty {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n-    {\n-        let tcache = tcx.tcache.borrow();\n-        match tcache.get().find(&def_id) {\n-            Some(tpt) => return tpt.clone(),\n-            _ => {}\n-        }\n+    match tcx.tcache.borrow().find(&def_id) {\n+        Some(tpt) => return tpt.clone(),\n+        _ => {}\n     }\n     match it.node {\n         ast::ItemStatic(t, _, _) => {\n             let typ = ccx.to_ty(&ExplicitRscope, t);\n             let tpt = no_params(typ);\n \n-            let mut tcache = tcx.tcache.borrow_mut();\n-            tcache.get().insert(local_def(it.id), tpt.clone());\n+            tcx.tcache.borrow_mut().insert(local_def(it.id), tpt.clone());\n             return tpt;\n         }\n         ast::ItemFn(decl, purity, abi, ref generics, _) => {\n@@ -885,17 +844,13 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n                     it.id,\n                     ppaux::ty_to_str(tcx, tpt.ty));\n \n-            let mut tcache = ccx.tcx.tcache.borrow_mut();\n-            tcache.get().insert(local_def(it.id), tpt.clone());\n+            ccx.tcx.tcache.borrow_mut().insert(local_def(it.id), tpt.clone());\n             return tpt;\n         }\n         ast::ItemTy(t, ref generics) => {\n-            {\n-                let mut tcache = tcx.tcache.borrow_mut();\n-                match tcache.get().find(&local_def(it.id)) {\n-                    Some(tpt) => return tpt.clone(),\n-                    None => { }\n-                }\n+            match tcx.tcache.borrow_mut().find(&local_def(it.id)) {\n+                Some(tpt) => return tpt.clone(),\n+                None => { }\n             }\n \n             let tpt = {\n@@ -906,8 +861,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n                 }\n             };\n \n-            let mut tcache = tcx.tcache.borrow_mut();\n-            tcache.get().insert(local_def(it.id), tpt.clone());\n+            tcx.tcache.borrow_mut().insert(local_def(it.id), tpt.clone());\n             return tpt;\n         }\n         ast::ItemEnum(_, ref generics) => {\n@@ -920,8 +874,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n                 ty: t\n             };\n \n-            let mut tcache = tcx.tcache.borrow_mut();\n-            tcache.get().insert(local_def(it.id), tpt.clone());\n+            tcx.tcache.borrow_mut().insert(local_def(it.id), tpt.clone());\n             return tpt;\n         }\n         ast::ItemTrait(..) => {\n@@ -938,8 +891,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n                 ty: t\n             };\n \n-            let mut tcache = tcx.tcache.borrow_mut();\n-            tcache.get().insert(local_def(it.id), tpt.clone());\n+            tcx.tcache.borrow_mut().insert(local_def(it.id), tpt.clone());\n             return tpt;\n         }\n         ast::ItemImpl(..) | ast::ItemMod(_) |\n@@ -997,7 +949,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n         type_param_defs: Rc::new(ty_params.iter().enumerate().map(|(offset, param)| {\n             let existing_def_opt = {\n                 let ty_param_defs = ccx.tcx.ty_param_defs.borrow();\n-                ty_param_defs.get().find(&param.id).map(|&def| def)\n+                ty_param_defs.find(&param.id).map(|&def| def)\n             };\n             existing_def_opt.unwrap_or_else(|| {\n                 let param_ty = ty::param_ty {idx: base_index + offset,\n@@ -1011,8 +963,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n                     default: default\n                 };\n                 debug!(\"def for param: {}\", def.repr(ccx.tcx));\n-                let mut ty_param_defs = ccx.tcx.ty_param_defs.borrow_mut();\n-                ty_param_defs.get().insert(param.id, def);\n+                ccx.tcx.ty_param_defs.borrow_mut().insert(param.id, def);\n                 def\n             })\n         }).collect()),\n@@ -1100,8 +1051,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n         ty: t_fn\n     };\n \n-    let mut tcache = ccx.tcx.tcache.borrow_mut();\n-    tcache.get().insert(def_id, tpt.clone());\n+    ccx.tcx.tcache.borrow_mut().insert(def_id, tpt.clone());\n     return tpt;\n }\n "}, {"sha": "b0fd7d7c55ba1ea2a7231f3fbc4563237fc4e2b1", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -757,8 +757,7 @@ impl<'a> Rebuilder<'a> {\n \n     fn offset_cur_anon(&self) {\n         let mut anon = self.cur_anon.get();\n-        let inserted_anons = self.inserted_anons.borrow();\n-        while inserted_anons.get().contains(&anon) {\n+        while self.inserted_anons.borrow().contains(&anon) {\n             anon += 1;\n         }\n         self.cur_anon.set(anon);\n@@ -770,8 +769,7 @@ impl<'a> Rebuilder<'a> {\n     }\n \n     fn track_anon(&self, anon: uint) {\n-        let mut inserted_anons = self.inserted_anons.borrow_mut();\n-        inserted_anons.get().insert(anon);\n+        self.inserted_anons.borrow_mut().insert(anon);\n     }\n \n     fn rebuild_generics(&self,\n@@ -845,8 +843,7 @@ impl<'a> Rebuilder<'a> {\n                     ty_queue.push(mut_ty.ty);\n                 }\n                 ast::TyPath(ref path, _, id) => {\n-                    let def_map = self.tcx.def_map.borrow();\n-                    let a_def = match def_map.get().find(&id) {\n+                    let a_def = match self.tcx.def_map.borrow().find(&id) {\n                         None => self.tcx.sess.fatal(format!(\"unbound path {}\",\n                                                     pprust::path_to_str(path))),\n                         Some(&d) => d\n@@ -1258,8 +1255,7 @@ impl LifeGiver {\n             if !self.taken.contains(&s) {\n                 lifetime = name_to_dummy_lifetime(\n                                     token::str_to_ident(s.as_slice()).name);\n-                let mut generated = self.generated.borrow_mut();\n-                generated.get().push(lifetime);\n+                self.generated.borrow_mut().push(lifetime);\n                 break;\n             }\n             self.inc_counter();"}, {"sha": "a6baf9ef7bf9b9207b3bea8713c9d9fdc8e4ff3e", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -530,25 +530,21 @@ impl<'a> InferCtxt<'a> {\n     }\n \n     pub fn start_snapshot(&self) -> Snapshot {\n-        let ty_var_bindings = self.ty_var_bindings.borrow();\n-        let int_var_bindings = self.int_var_bindings.borrow();\n-        let float_var_bindings = self.float_var_bindings.borrow();\n         Snapshot {\n-            ty_var_bindings_len: ty_var_bindings.get().bindings.len(),\n-            int_var_bindings_len: int_var_bindings.get().bindings.len(),\n-            float_var_bindings_len: float_var_bindings.get().bindings.len(),\n+            ty_var_bindings_len: self.ty_var_bindings.borrow().bindings.len(),\n+            int_var_bindings_len: self.int_var_bindings.borrow().bindings.len(),\n+            float_var_bindings_len: self.float_var_bindings.borrow().bindings.len(),\n             region_vars_snapshot: self.region_vars.start_snapshot(),\n         }\n     }\n \n     pub fn rollback_to(&self, snapshot: &Snapshot) {\n         debug!(\"rollback!\");\n-        let mut ty_var_bindings = self.ty_var_bindings.borrow_mut();\n-        let mut int_var_bindings = self.int_var_bindings.borrow_mut();\n-        let mut float_var_bindings = self.float_var_bindings.borrow_mut();\n-        rollback_to(ty_var_bindings.get(), snapshot.ty_var_bindings_len);\n-        rollback_to(int_var_bindings.get(), snapshot.int_var_bindings_len);\n-        rollback_to(float_var_bindings.get(),\n+        rollback_to(&mut *self.ty_var_bindings.borrow_mut(),\n+                    snapshot.ty_var_bindings_len);\n+        rollback_to(&mut *self.int_var_bindings.borrow_mut(),\n+                    snapshot.int_var_bindings_len);\n+        rollback_to(&mut *self.float_var_bindings.borrow_mut(),\n                     snapshot.float_var_bindings_len);\n \n         self.region_vars.rollback_to(snapshot.region_vars_snapshot);\n@@ -562,10 +558,8 @@ impl<'a> InferCtxt<'a> {\n         indent(|| {\n             let r = self.try(|| f());\n \n-            let mut ty_var_bindings = self.ty_var_bindings.borrow_mut();\n-            let mut int_var_bindings = self.int_var_bindings.borrow_mut();\n-            ty_var_bindings.get().bindings.truncate(0);\n-            int_var_bindings.get().bindings.truncate(0);\n+            self.ty_var_bindings.borrow_mut().bindings.truncate(0);\n+            self.int_var_bindings.borrow_mut().bindings.truncate(0);\n             self.region_vars.commit();\n             r\n         })\n@@ -614,7 +608,7 @@ impl<'a> InferCtxt<'a> {\n         self.ty_var_counter.set(id + 1);\n         {\n             let mut ty_var_bindings = self.ty_var_bindings.borrow_mut();\n-            let vals = &mut ty_var_bindings.get().vals;\n+            let vals = &mut ty_var_bindings.vals;\n             vals.insert(id, Root(Bounds { lb: None, ub: None }, 0u));\n         }\n         return TyVid(id);\n@@ -632,7 +626,7 @@ impl<'a> InferCtxt<'a> {\n         let mut int_var_counter = self.int_var_counter.get();\n         let mut int_var_bindings = self.int_var_bindings.borrow_mut();\n         let result = IntVid(next_simple_var(&mut int_var_counter,\n-                                            int_var_bindings.get()));\n+                                            &mut *int_var_bindings));\n         self.int_var_counter.set(int_var_counter);\n         result\n     }\n@@ -645,7 +639,7 @@ impl<'a> InferCtxt<'a> {\n         let mut float_var_counter = self.float_var_counter.get();\n         let mut float_var_bindings = self.float_var_bindings.borrow_mut();\n         let result = FloatVid(next_simple_var(&mut float_var_counter,\n-                                              float_var_bindings.get()));\n+                                              &mut *float_var_bindings));\n         self.float_var_counter.set(float_var_counter);\n         result\n     }"}, {"sha": "9d2713539887341300ff06690e4e16c4e6cd916f", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 64, "deletions": 114, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -160,78 +160,63 @@ pub fn RegionVarBindings<'a>(tcx: &'a ty::ctxt) -> RegionVarBindings<'a> {\n \n impl<'a> RegionVarBindings<'a> {\n     pub fn in_snapshot(&self) -> bool {\n-        let undo_log = self.undo_log.borrow();\n-        undo_log.get().len() > 0\n+        self.undo_log.borrow().len() > 0\n     }\n \n     pub fn start_snapshot(&self) -> uint {\n         debug!(\"RegionVarBindings: start_snapshot()\");\n         if self.in_snapshot() {\n-            {\n-                let undo_log = self.undo_log.borrow();\n-                undo_log.get().len()\n-            }\n+            self.undo_log.borrow().len()\n         } else {\n-            {\n-                let mut undo_log = self.undo_log.borrow_mut();\n-                undo_log.get().push(Snapshot);\n-                0\n-            }\n+            self.undo_log.borrow_mut().push(Snapshot);\n+            0\n         }\n     }\n \n     pub fn commit(&self) {\n         debug!(\"RegionVarBindings: commit()\");\n         let mut undo_log = self.undo_log.borrow_mut();\n-        while undo_log.get().len() > 0 {\n-            undo_log.get().pop().unwrap();\n+        while undo_log.len() > 0 {\n+            undo_log.pop().unwrap();\n         }\n     }\n \n     pub fn rollback_to(&self, snapshot: uint) {\n         debug!(\"RegionVarBindings: rollback_to({})\", snapshot);\n         let mut undo_log = self.undo_log.borrow_mut();\n-        while undo_log.get().len() > snapshot {\n-            let undo_item = undo_log.get().pop().unwrap();\n+        while undo_log.len() > snapshot {\n+            let undo_item = undo_log.pop().unwrap();\n             debug!(\"undo_item={:?}\", undo_item);\n             match undo_item {\n               Snapshot => {}\n               AddVar(vid) => {\n                 let mut var_origins = self.var_origins.borrow_mut();\n-                assert_eq!(var_origins.get().len(), vid.to_uint() + 1);\n-                var_origins.get().pop().unwrap();\n+                assert_eq!(var_origins.len(), vid.to_uint() + 1);\n+                var_origins.pop().unwrap();\n               }\n               AddConstraint(ref constraint) => {\n-                let mut constraints = self.constraints.borrow_mut();\n-                constraints.get().remove(constraint);\n+                self.constraints.borrow_mut().remove(constraint);\n               }\n               AddCombination(Glb, ref regions) => {\n-                let mut glbs = self.glbs.borrow_mut();\n-                glbs.get().remove(regions);\n+                self.glbs.borrow_mut().remove(regions);\n               }\n               AddCombination(Lub, ref regions) => {\n-                let mut lubs = self.lubs.borrow_mut();\n-                lubs.get().remove(regions);\n+                self.lubs.borrow_mut().remove(regions);\n               }\n             }\n         }\n     }\n \n     pub fn num_vars(&self) -> uint {\n-        let var_origins = self.var_origins.borrow();\n-        var_origins.get().len()\n+        self.var_origins.borrow().len()\n     }\n \n     pub fn new_region_var(&self, origin: RegionVariableOrigin) -> RegionVid {\n         let id = self.num_vars();\n-        let mut var_origins = self.var_origins.borrow_mut();\n-        var_origins.get().push(origin);\n+        self.var_origins.borrow_mut().push(origin);\n         let vid = RegionVid { id: id };\n         if self.in_snapshot() {\n-            {\n-                let mut undo_log = self.undo_log.borrow_mut();\n-                undo_log.get().push(AddVar(vid));\n-            }\n+            self.undo_log.borrow_mut().push(AddVar(vid));\n         }\n         debug!(\"created new region variable {:?} with origin {:?}\",\n                vid, origin.repr(self.tcx));\n@@ -274,8 +259,7 @@ impl<'a> RegionVarBindings<'a> {\n     }\n \n     fn values_are_none(&self) -> bool {\n-        let values = self.values.borrow();\n-        values.get().is_none()\n+        self.values.borrow().is_none()\n     }\n \n     pub fn add_constraint(&self,\n@@ -286,13 +270,9 @@ impl<'a> RegionVarBindings<'a> {\n \n         debug!(\"RegionVarBindings: add_constraint({:?})\", constraint);\n \n-        let mut constraints = self.constraints.borrow_mut();\n-        if constraints.get().insert(constraint, origin) {\n+        if self.constraints.borrow_mut().insert(constraint, origin) {\n             if self.in_snapshot() {\n-                {\n-                    let mut undo_log = self.undo_log.borrow_mut();\n-                    undo_log.get().push(AddConstraint(constraint));\n-                }\n+                self.undo_log.borrow_mut().push(AddConstraint(constraint));\n             }\n         }\n     }\n@@ -383,12 +363,10 @@ impl<'a> RegionVarBindings<'a> {\n     }\n \n     pub fn resolve_var(&self, rid: RegionVid) -> ty::Region {\n-        let values = self.values.borrow();\n-        let v = match *values.get() {\n+        let v = match *self.values.borrow() {\n             None => {\n-                let var_origins = self.var_origins.borrow();\n                 self.tcx.sess.span_bug(\n-                    var_origins.get().get(rid.to_uint()).span(),\n+                    self.var_origins.borrow().get(rid.to_uint()).span(),\n                     format!(\"attempt to resolve region variable before \\\n                              values have been computed!\"))\n             }\n@@ -430,25 +408,16 @@ impl<'a> RegionVarBindings<'a> {\n                                  new_r: Region|)\n                         -> Region {\n         let vars = TwoRegions { a: a, b: b };\n-        {\n-            let map = self.combine_map(t).borrow();\n-            match map.get().find(&vars) {\n-                Some(&c) => {\n-                    return ReInfer(ReVar(c));\n-                }\n-                None => {}\n+        match self.combine_map(t).borrow().find(&vars) {\n+            Some(&c) => {\n+                return ReInfer(ReVar(c));\n             }\n+            None => {}\n         }\n         let c = self.new_region_var(infer::MiscVariable(origin.span()));\n-        {\n-            let mut map = self.combine_map(t).borrow_mut();\n-            map.get().insert(vars, c);\n-        }\n+        self.combine_map(t).borrow_mut().insert(vars, c);\n         if self.in_snapshot() {\n-            {\n-                let mut undo_log = self.undo_log.borrow_mut();\n-                undo_log.get().push(AddCombination(t, vars));\n-            }\n+            self.undo_log.borrow_mut().push(AddCombination(t, vars));\n         }\n         relate(self, a, ReInfer(ReVar(c)));\n         relate(self, b, ReInfer(ReVar(c)));\n@@ -458,8 +427,7 @@ impl<'a> RegionVarBindings<'a> {\n \n     pub fn vars_created_since_snapshot(&self, snapshot: uint)\n                                        -> Vec<RegionVid> {\n-        let undo_log = self.undo_log.borrow();\n-        undo_log.get().slice_from(snapshot).iter()\n+        self.undo_log.borrow().slice_from(snapshot).iter()\n             .filter_map(|&elt| match elt {\n                 AddVar(vid) => Some(vid),\n                 _ => None\n@@ -479,10 +447,7 @@ impl<'a> RegionVarBindings<'a> {\n         debug!(\"tainted(snapshot={}, r0={:?})\", snapshot, r0);\n         let _indenter = indenter();\n \n-        let undo_len = {\n-            let undo_log = self.undo_log.borrow();\n-            undo_log.get().len()\n-        };\n+        let undo_len = self.undo_log.borrow().len();\n \n         // `result_set` acts as a worklist: we explore all outgoing\n         // edges and add any new regions we find to result_set.  This\n@@ -498,25 +463,22 @@ impl<'a> RegionVarBindings<'a> {\n             let mut undo_index = snapshot;\n             while undo_index < undo_len {\n                 // nb: can't use uint::range() here as we move result_set\n-                let regs = {\n-                    let undo_log = self.undo_log.borrow();\n-                    match undo_log.get().get(undo_index) {\n-                        &AddConstraint(ConstrainVarSubVar(ref a, ref b)) => {\n-                            Some((ReInfer(ReVar(*a)),\n-                                  ReInfer(ReVar(*b))))\n-                        }\n-                        &AddConstraint(ConstrainRegSubVar(ref a, ref b)) => {\n-                            Some((*a, ReInfer(ReVar(*b))))\n-                        }\n-                        &AddConstraint(ConstrainVarSubReg(ref a, ref b)) => {\n-                            Some((ReInfer(ReVar(*a)), *b))\n-                        }\n-                        &AddConstraint(ConstrainRegSubReg(a, b)) => {\n-                            Some((a, b))\n-                        }\n-                        _ => {\n-                            None\n-                        }\n+                let regs = match self.undo_log.borrow().get(undo_index) {\n+                    &AddConstraint(ConstrainVarSubVar(ref a, ref b)) => {\n+                        Some((ReInfer(ReVar(*a)),\n+                              ReInfer(ReVar(*b))))\n+                    }\n+                    &AddConstraint(ConstrainRegSubVar(ref a, ref b)) => {\n+                        Some((*a, ReInfer(ReVar(*b))))\n+                    }\n+                    &AddConstraint(ConstrainVarSubReg(ref a, ref b)) => {\n+                        Some((ReInfer(ReVar(*a)), *b))\n+                    }\n+                    &AddConstraint(ConstrainRegSubReg(a, b)) => {\n+                        Some((a, b))\n+                    }\n+                    _ => {\n+                        None\n                     }\n                 };\n \n@@ -563,8 +525,7 @@ impl<'a> RegionVarBindings<'a> {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n         let mut errors = vec!();\n         let v = self.infer_variable_values(&mut errors);\n-        let mut values = self.values.borrow_mut();\n-        *values.get() = Some(v);\n+        *self.values.borrow_mut() = Some(v);\n         errors\n     }\n }\n@@ -595,9 +556,8 @@ impl<'a> RegionVarBindings<'a> {\n           }\n \n           (ReInfer(ReVar(v_id)), _) | (_, ReInfer(ReVar(v_id))) => {\n-            let var_origins = self.var_origins.borrow();\n             self.tcx.sess.span_bug(\n-                var_origins.get().get(v_id.to_uint()).span(),\n+                self.var_origins.borrow().get(v_id.to_uint()).span(),\n                 format!(\"lub_concrete_regions invoked with \\\n                       non-concrete regions: {:?}, {:?}\", a, b));\n           }\n@@ -700,9 +660,8 @@ impl<'a> RegionVarBindings<'a> {\n \n             (ReInfer(ReVar(v_id)), _) |\n             (_, ReInfer(ReVar(v_id))) => {\n-                let var_origins = self.var_origins.borrow();\n                 self.tcx.sess.span_bug(\n-                    var_origins.get().get(v_id.to_uint()).span(),\n+                    self.var_origins.borrow().get(v_id.to_uint()).span(),\n                     format!(\"glb_concrete_regions invoked with \\\n                           non-concrete regions: {:?}, {:?}\", a, b));\n             }\n@@ -1004,8 +963,7 @@ impl<'a> RegionVarBindings<'a> {\n         &self,\n         errors: &mut Vec<RegionResolutionError>)\n     {\n-        let constraints = self.constraints.borrow();\n-        for (constraint, _) in constraints.get().iter() {\n+        for (constraint, _) in self.constraints.borrow().iter() {\n             let (sub, sup) = match *constraint {\n                 ConstrainVarSubVar(..) |\n                 ConstrainRegSubVar(..) |\n@@ -1023,7 +981,7 @@ impl<'a> RegionVarBindings<'a> {\n \n             debug!(\"ConcreteFailure: !(sub <= sup): sub={:?}, sup={:?}\",\n                    sub, sup);\n-            let origin = constraints.get().get_copy(constraint);\n+            let origin = self.constraints.borrow().get_copy(constraint);\n             errors.push(ConcreteFailure(origin, sub, sup));\n         }\n     }\n@@ -1112,7 +1070,7 @@ impl<'a> RegionVarBindings<'a> {\n         let num_vars = self.num_vars();\n \n         let constraints = self.constraints.borrow();\n-        let num_edges = constraints.get().len();\n+        let num_edges = constraints.len();\n \n         let mut graph = graph::Graph::with_capacity(num_vars + 1,\n                                                     num_edges);\n@@ -1122,7 +1080,7 @@ impl<'a> RegionVarBindings<'a> {\n         }\n         let dummy_idx = graph.add_node(());\n \n-        for (constraint, _) in constraints.get().iter() {\n+        for (constraint, _) in constraints.iter() {\n             match *constraint {\n                 ConstrainVarSubVar(a_id, b_id) => {\n                     graph.add_edge(NodeIndex(a_id.to_uint()),\n@@ -1174,23 +1132,19 @@ impl<'a> RegionVarBindings<'a> {\n             for upper_bound in upper_bounds.iter() {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n-                    {\n-                        let var_origins = self.var_origins.borrow();\n-                        errors.push(SubSupConflict(\n-                            *var_origins.get().get(node_idx.to_uint()),\n-                            lower_bound.origin,\n-                            lower_bound.region,\n-                            upper_bound.origin,\n-                            upper_bound.region));\n-                        return;\n-                    }\n+                    errors.push(SubSupConflict(\n+                        *self.var_origins.borrow().get(node_idx.to_uint()),\n+                        lower_bound.origin,\n+                        lower_bound.region,\n+                        upper_bound.origin,\n+                        upper_bound.region));\n+                    return;\n                 }\n             }\n         }\n \n-        let var_origins = self.var_origins.borrow();\n         self.tcx.sess.span_bug(\n-            var_origins.get().get(node_idx.to_uint()).span(),\n+            self.var_origins.borrow().get(node_idx.to_uint()).span(),\n             format!(\"collect_error_for_expanding_node() could not find error \\\n                   for var {:?}, lower_bounds={}, upper_bounds={}\",\n                  node_idx,\n@@ -1222,9 +1176,8 @@ impl<'a> RegionVarBindings<'a> {\n                                                 upper_bound_2.region) {\n                   Ok(_) => {}\n                   Err(_) => {\n-                    let var_origins = self.var_origins.borrow();\n                     errors.push(SupSupConflict(\n-                        *var_origins.get().get(node_idx.to_uint()),\n+                        *self.var_origins.borrow().get(node_idx.to_uint()),\n                         upper_bound_1.origin,\n                         upper_bound_1.region,\n                         upper_bound_2.origin,\n@@ -1235,9 +1188,8 @@ impl<'a> RegionVarBindings<'a> {\n             }\n         }\n \n-        let var_origins = self.var_origins.borrow();\n         self.tcx.sess.span_bug(\n-            var_origins.get().get(node_idx.to_uint()).span(),\n+            self.var_origins.borrow().get(node_idx.to_uint()).span(),\n             format!(\"collect_error_for_contracting_node() could not find error \\\n                   for var {:?}, upper_bounds={}\",\n                  node_idx,\n@@ -1317,10 +1269,9 @@ impl<'a> RegionVarBindings<'a> {\n \n                     ConstrainRegSubVar(region, _) |\n                     ConstrainVarSubReg(_, region) => {\n-                        let constraints = this.constraints.borrow();\n                         state.result.push(RegionAndOrigin {\n                             region: region,\n-                            origin: constraints.get().get_copy(&edge.data)\n+                            origin: this.constraints.borrow().get_copy(&edge.data)\n                         });\n                     }\n \n@@ -1340,8 +1291,7 @@ impl<'a> RegionVarBindings<'a> {\n             changed = false;\n             iteration += 1;\n             debug!(\"---- {} Iteration \\\\#{}\", tag, iteration);\n-            let constraints = self.constraints.borrow();\n-            for (constraint, _) in constraints.get().iter() {\n+            for (constraint, _) in self.constraints.borrow().iter() {\n                 let edge_changed = body(constraint);\n                 if edge_changed {\n                     debug!(\"Updated due to constraint {}\","}, {"sha": "20d268bca6c2002dc248a5947643f4d20a70c1cb", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -75,8 +75,7 @@ impl<'a> UnifyInferCtxtMethods for InferCtxt<'a> {\n \n         let tcx = self.tcx;\n         let vb = UnifyVid::appropriate_vals_and_bindings(self);\n-        let mut vb = vb.borrow_mut();\n-        return helper(tcx, vb.get(), vid);\n+        return helper(tcx, &mut *vb.borrow_mut(), vid);\n \n         fn helper<T:Clone, V:Clone+Eq+Vid>(\n             tcx: &ty::ctxt,\n@@ -123,9 +122,9 @@ impl<'a> UnifyInferCtxtMethods for InferCtxt<'a> {\n \n         let vb = UnifyVid::appropriate_vals_and_bindings(self);\n         let mut vb = vb.borrow_mut();\n-        let old_v = (*vb.get().vals.get(&vid.to_uint())).clone();\n-        vb.get().bindings.push((vid.clone(), old_v));\n-        vb.get().vals.insert(vid.to_uint(), new_v);\n+        let old_v = (*vb.vals.get(&vid.to_uint())).clone();\n+        vb.bindings.push((vid.clone(), old_v));\n+        vb.vals.insert(vid.to_uint(), new_v);\n     }\n \n     fn unify<T:Clone + InferStr,"}, {"sha": "22881b26f63e638990dfb9f9801536eef0219824", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -252,8 +252,7 @@ pub struct CrateCtxt<'a> {\n pub fn write_ty_to_tcx(tcx: &ty::ctxt, node_id: ast::NodeId, ty: ty::t) {\n     debug!(\"write_ty_to_tcx({}, {})\", node_id, ppaux::ty_to_str(tcx, ty));\n     assert!(!ty::type_needs_infer(ty));\n-    let mut node_types = tcx.node_types.borrow_mut();\n-    node_types.get().insert(node_id as uint, ty);\n+    tcx.node_types.borrow_mut().insert(node_id as uint, ty);\n }\n pub fn write_substs_to_tcx(tcx: &ty::ctxt,\n                            node_id: ast::NodeId,\n@@ -263,8 +262,7 @@ pub fn write_substs_to_tcx(tcx: &ty::ctxt,\n                substs.map(|t| ppaux::ty_to_str(tcx, *t)));\n         assert!(substs.iter().all(|t| !ty::type_needs_infer(*t)));\n \n-        let mut node_type_substs = tcx.node_type_substs.borrow_mut();\n-        node_type_substs.get().insert(node_id, substs);\n+        tcx.node_type_substs.borrow_mut().insert(node_id, substs);\n     }\n }\n pub fn write_tpt_to_tcx(tcx: &ty::ctxt,\n@@ -277,8 +275,7 @@ pub fn write_tpt_to_tcx(tcx: &ty::ctxt,\n }\n \n pub fn lookup_def_tcx(tcx:&ty::ctxt, sp: Span, id: ast::NodeId) -> ast::Def {\n-    let def_map = tcx.def_map.borrow();\n-    match def_map.get().find(&id) {\n+    match tcx.def_map.borrow().find(&id) {\n         Some(&x) => x,\n         _ => {\n             tcx.sess.span_fatal(sp, \"internal error looking up a definition\")"}, {"sha": "baa4e1c1db1e04f7897b648f7e0bea811069804d", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -359,10 +359,7 @@ impl<'a> Visitor<()> for TermsContext<'a> {\n                 // \"invalid item id\" from \"item id with no\n                 // parameters\".\n                 if self.num_inferred() == inferreds_on_entry {\n-                    let mut item_variance_map = self.tcx\n-                                                    .item_variance_map\n-                                                    .borrow_mut();\n-                    let newly_added = item_variance_map.get().insert(\n+                    let newly_added = self.tcx.item_variance_map.borrow_mut().insert(\n                         ast_util::local_def(item.id),\n                         self.empty_variances);\n                     assert!(newly_added);\n@@ -944,9 +941,8 @@ impl<'a> SolveContext<'a> {\n                 tcx.sess.span_err(tcx.map.span(item_id), found);\n             }\n \n-            let mut item_variance_map = tcx.item_variance_map.borrow_mut();\n-            let newly_added = item_variance_map.get().insert(item_def_id,\n-                                                             @item_variances);\n+            let newly_added = tcx.item_variance_map.borrow_mut()\n+                                 .insert(item_def_id, @item_variances);\n             assert!(newly_added);\n         }\n     }"}, {"sha": "926cf702859bf1f94e27c1e2b182c067f00de674", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbb909bf7cf557e46748ddcf3cdea916f2734c9/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=0dbb909bf7cf557e46748ddcf3cdea916f2734c9", "patch": "@@ -459,9 +459,7 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n       ty_infer(infer_ty) => infer_ty.to_str(),\n       ty_err => ~\"[type error]\",\n       ty_param(param_ty {idx: id, def_id: did}) => {\n-          let ty_param_defs = cx.ty_param_defs.borrow();\n-          let param_def = ty_param_defs.get().find(&did.node);\n-          let ident = match param_def {\n+          let ident = match cx.ty_param_defs.borrow().find(&did.node) {\n               Some(def) => token::get_ident(def.ident).get().to_str(),\n               // This should not happen...\n               None => format!(\"BUG[{:?}]\", id)"}]}