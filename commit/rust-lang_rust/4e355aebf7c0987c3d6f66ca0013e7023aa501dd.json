{"sha": "4e355aebf7c0987c3d6f66ca0013e7023aa501dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlMzU1YWViZjdjMDk4N2MzZDZmNjZjYTAwMTNlNzAyM2FhNTAxZGQ=", "commit": {"author": {"name": "Roy Frostig", "email": "rfrostig@mozilla.com", "date": "2010-09-03T23:18:32Z"}, "committer": {"name": "Roy Frostig", "email": "rfrostig@mozilla.com", "date": "2010-09-03T23:18:32Z"}, "message": "When vec growth results in a newly allocated (extended) buffer, copy existing elements over via element-wise copy, not flat memcpy.  Introduce new vec growth glue to achieve this.", "tree": {"sha": "a1d1490532468b04d76f06a0e3351f869427de48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1d1490532468b04d76f06a0e3351f869427de48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e355aebf7c0987c3d6f66ca0013e7023aa501dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e355aebf7c0987c3d6f66ca0013e7023aa501dd", "html_url": "https://github.com/rust-lang/rust/commit/4e355aebf7c0987c3d6f66ca0013e7023aa501dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e355aebf7c0987c3d6f66ca0013e7023aa501dd/comments", "author": {"login": "froystig", "id": 123903, "node_id": "MDQ6VXNlcjEyMzkwMw==", "avatar_url": "https://avatars.githubusercontent.com/u/123903?v=4", "gravatar_id": "", "url": "https://api.github.com/users/froystig", "html_url": "https://github.com/froystig", "followers_url": "https://api.github.com/users/froystig/followers", "following_url": "https://api.github.com/users/froystig/following{/other_user}", "gists_url": "https://api.github.com/users/froystig/gists{/gist_id}", "starred_url": "https://api.github.com/users/froystig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/froystig/subscriptions", "organizations_url": "https://api.github.com/users/froystig/orgs", "repos_url": "https://api.github.com/users/froystig/repos", "events_url": "https://api.github.com/users/froystig/events{/privacy}", "received_events_url": "https://api.github.com/users/froystig/received_events", "type": "User", "site_admin": false}, "committer": {"login": "froystig", "id": 123903, "node_id": "MDQ6VXNlcjEyMzkwMw==", "avatar_url": "https://avatars.githubusercontent.com/u/123903?v=4", "gravatar_id": "", "url": "https://api.github.com/users/froystig", "html_url": "https://github.com/froystig", "followers_url": "https://api.github.com/users/froystig/followers", "following_url": "https://api.github.com/users/froystig/following{/other_user}", "gists_url": "https://api.github.com/users/froystig/gists{/gist_id}", "starred_url": "https://api.github.com/users/froystig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/froystig/subscriptions", "organizations_url": "https://api.github.com/users/froystig/orgs", "repos_url": "https://api.github.com/users/froystig/repos", "events_url": "https://api.github.com/users/froystig/events{/privacy}", "received_events_url": "https://api.github.com/users/froystig/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1eb2a8b10be2063637e510794ed6bbc49693b5b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1eb2a8b10be2063637e510794ed6bbc49693b5b8", "html_url": "https://github.com/rust-lang/rust/commit/1eb2a8b10be2063637e510794ed6bbc49693b5b8"}], "stats": {"total": 249, "additions": 221, "deletions": 28}, "files": [{"sha": "b58f91259e3fd6269f2956b5cc4812696363e56c", "filename": "src/boot/be/abi.ml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e355aebf7c0987c3d6f66ca0013e7023aa501dd/src%2Fboot%2Fbe%2Fabi.ml", "raw_url": "https://github.com/rust-lang/rust/raw/4e355aebf7c0987c3d6f66ca0013e7023aa501dd/src%2Fboot%2Fbe%2Fabi.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fabi.ml?ref=4e355aebf7c0987c3d6f66ca0013e7023aa501dd", "patch": "@@ -102,8 +102,8 @@ let iterator_args_elt_outer_frame_ptr = 1;;\n \n let indirect_args_elt_closure = 0;;\n \n-(* dst, taskptr, closure-ptr, ty_params, src, src2=target_task *)\n-let worst_case_glue_call_args = 6;;\n+(* Current worst case is by vec grow glue *)\n+let worst_case_glue_call_args = 7;;\n \n type abi =\n   {"}, {"sha": "ef262647b0ce99b7cb8df3d2a3a6e318e30f30a6", "filename": "src/boot/me/semant.ml", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4e355aebf7c0987c3d6f66ca0013e7023aa501dd/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/4e355aebf7c0987c3d6f66ca0013e7023aa501dd/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=4e355aebf7c0987c3d6f66ca0013e7023aa501dd", "patch": "@@ -40,6 +40,7 @@ type glue =\n   | GLUE_obj_drop of node_id      (* Node is the obj.                   *)\n   | GLUE_loop_body of node_id     (* Node is the 'for each' body block. *)\n   | GLUE_forward of (Ast.ident * Ast.ty_obj * Ast.ty_obj)\n+  | GLUE_vec_grow\n ;;\n \n type data =\n@@ -1939,6 +1940,11 @@ and fn_rty (opaque_box_body:bool) (word_bits:Il.bits) : Il.referent_ty =\n \n     r [| code_ptr; box_ptr |]\n \n+and vec_sty (word_bits:Il.bits) : Il.scalar_ty =\n+  let word = word_rty word_bits in\n+  let ptr = Il.ScalarTy (Il.AddrTy Il.OpaqueTy) in\n+    Il.AddrTy (Il.StructTy [| word; word; word; ptr |])\n+\n and referent_type (word_bits:Il.bits) (t:Ast.ty) : Il.referent_ty =\n   let s t = Il.ScalarTy t in\n   let v b = Il.ValTy b in\n@@ -1985,7 +1991,7 @@ and referent_type (word_bits:Il.bits) (t:Ast.ty) : Il.referent_ty =\n       | Ast.TY_mach (TY_f64) -> sv Il.Bits64\n \n       | Ast.TY_str -> sp (Il.StructTy [| word; word; word; ptr |])\n-      | Ast.TY_vec _ -> sp (Il.StructTy [| word; word; word; ptr |])\n+      | Ast.TY_vec _ -> s (vec_sty word_bits)\n       | Ast.TY_tup tt -> tup tt\n       | Ast.TY_rec tr -> tup (Array.map snd tr)\n \n@@ -2344,6 +2350,7 @@ let glue_str (cx:ctxt) (g:glue) : string =\n         ^ id\n         ^ \"$\" ^ (ty_str (Ast.TY_obj oty1))\n         ^ \"$\" ^ (ty_str (Ast.TY_obj oty2))\n+    | GLUE_vec_grow -> \"glue$vec_grow\"\n ;;\n \n "}, {"sha": "b015ca6d1c741d7fbe11557e40d5121d420237af", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 185, "deletions": 16, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/4e355aebf7c0987c3d6f66ca0013e7023aa501dd/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/4e355aebf7c0987c3d6f66ca0013e7023aa501dd/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=4e355aebf7c0987c3d6f66ca0013e7023aa501dd", "patch": "@@ -1740,21 +1740,29 @@ let trans_visitor\n       (ty:Ast.ty)\n       (curr_iso:Ast.ty_iso option)\n       : fixup =\n+    let arg_ty_params_alias = 0 in\n+    let arg_src_alias = 1 in\n+    let arg_initflag = 2 in\n+\n     let g = GLUE_copy ty in\n     let inner (out_ptr:Il.cell) (args:Il.cell) =\n       let dst = deref out_ptr in\n-      let ty_params = deref (get_element_ptr args 0) in\n-      let src = deref (get_element_ptr args 1) in\n+      let ty_params = deref (get_element_ptr args arg_ty_params_alias) in\n+      let src = deref (get_element_ptr args arg_src_alias) in\n \n       (* Translate copy code for the dst-initializing and\n        * dst-non-initializing cases and branch accordingly. *)\n-      let initflag = get_element_ptr args 2 in\n+      let initflag = get_element_ptr args arg_initflag in\n       let jmps = trans_compare_simple Il.JNE (Il.Cell initflag) one in\n+\n         trans_copy_ty ty_params true dst ty src ty curr_iso;\n+\n         let skip_noninit_jmp = mark() in\n           emit (Il.jmp Il.JMP Il.CodeNone);\n           List.iter patch jmps;\n+\n           trans_copy_ty ty_params false dst ty src ty curr_iso;\n+\n           patch skip_noninit_jmp;\n     in\n     let ty_params_ptr = ty_params_covering ty in\n@@ -1767,6 +1775,151 @@ let trans_visitor\n \n   and get_cmp_glue _ = failwith \"TODO\"\n \n+  (*\n+   * Vector-growth glue takes four arguments:\n+   *\n+   *   0. (Implicit) task ptr\n+   *   1. Pointer to the typarams of the caller's frame (possibly required to\n+   *      be passed to element's copy glue).\n+   *   2. Pointer to tydesc of the vec's stored element type, so that elements\n+   *      can be copied to a newly alloc'ed vec if one must be created.\n+   *   3. Alias to vec that needs to grow (i.e. ptr to ptr to rust_vec).\n+   *   4. Number of bytes of growth requested\n+   *)\n+  and emit_vec_grow_glue\n+      (fix:fixup)\n+      (g:glue)\n+      : unit =\n+    let arg_typarams_ptr = 0 in\n+    let arg_tydesc_ptr = 1 in\n+    let arg_vec_alias = 2 in\n+    let arg_nbytes = 3 in\n+\n+    let name = glue_str cx g in\n+      log cx \"emitting glue: %s\" name;\n+\n+      let fn_ty =\n+        mk_simple_ty_fn\n+          [| ty_params_covering Ast.TY_int;      (* an OK lie *)\n+             local_slot Ast.TY_type;\n+             alias_slot (Ast.TY_vec Ast.TY_int); (* an OK lie *)\n+             local_slot Ast.TY_uint; |]\n+      in\n+\n+      let args_rty = call_args_referent_type cx 0 fn_ty None in\n+\n+      let callsz = Il.referent_ty_size word_bits args_rty in\n+      let spill = new_fixup (name ^ \" spill\") in\n+        trans_glue_frame_entry callsz spill false;\n+\n+        let args_cell =\n+          get_element_ptr (caller_args_cell args_rty) Abi.calltup_elt_args\n+        in\n+\n+        let vec_alias_cell = get_element_ptr args_cell arg_vec_alias in\n+        let vec_cell = deref vec_alias_cell in\n+        let nbytes_cell = get_element_ptr args_cell arg_nbytes in\n+        let td_ptr_cell = get_element_ptr args_cell arg_tydesc_ptr in\n+        let ty_params_cell =\n+          deref (get_element_ptr args_cell arg_typarams_ptr)\n+        in\n+\n+        let need_copy_cell = next_vreg_cell word_sty in\n+        let new_vec_cell = next_vreg_cell (vec_sty word_bits) in\n+\n+          aliasing true need_copy_cell\n+            begin\n+              fun need_copy_alias_cell ->\n+                trans_upcall \"upcall_vec_grow\"\n+                  new_vec_cell\n+                  [| Il.Cell vec_cell;\n+                     Il.Cell nbytes_cell;\n+                     Il.Cell need_copy_alias_cell |]\n+            end;\n+\n+          let no_copy_jmps =\n+            trans_compare_simple Il.JE (Il.Cell need_copy_cell) zero\n+          in\n+\n+            let dst_vec = deref new_vec_cell in\n+            let src_vec = deref vec_cell in\n+\n+            let fill =\n+              get_element_ptr_dyn ty_params_cell src_vec Abi.vec_elt_fill\n+            in\n+            let elt_sz =\n+              get_element_ptr (deref td_ptr_cell) Abi.tydesc_field_size\n+            in\n+\n+            let dst_buf =\n+              get_element_ptr_dyn ty_params_cell dst_vec Abi.vec_elt_data\n+            in\n+            let src_buf =\n+              get_element_ptr_dyn ty_params_cell src_vec Abi.vec_elt_data\n+            in\n+\n+            (* Copy loop: *)\n+            let eltp_sty = Il.AddrTy (Il.OpaqueTy) in\n+            let dptr = next_vreg_cell eltp_sty in\n+            let sptr = next_vreg_cell eltp_sty in\n+            let dlim = next_vreg_cell eltp_sty in\n+\n+              lea dptr (fst (need_mem_cell dst_buf));\n+              lea sptr (fst (need_mem_cell src_buf));\n+              mov dlim (Il.Cell dptr);\n+              add_to dlim (Il.Cell fill);\n+\n+              (* Copy loop body: *)\n+              let fwd_jmp = mark () in\n+                emit (Il.jmp Il.JMP Il.CodeNone);\n+                let back_jmp_targ = mark () in\n+\n+                (* Copy *)\n+                let ty_params_ptr =\n+                  get_tydesc_params ty_params_cell td_ptr_cell\n+                in\n+                let initflag = Il.Reg (force_to_reg one) in\n+                  trans_call_dynamic_glue\n+                    td_ptr_cell\n+                    Abi.tydesc_field_copy_glue\n+                    (Some (deref dptr))\n+                    [| ty_params_ptr; sptr; initflag |]\n+                    None;\n+\n+                  add_to dptr (Il.Cell elt_sz);\n+                  add_to sptr (Il.Cell elt_sz);\n+\n+                  patch fwd_jmp;\n+                  let back_jmp =\n+                    trans_compare_simple Il.JB (Il.Cell dptr) (Il.Cell dlim)\n+                  in\n+                    List.iter\n+                      (fun j -> patch_existing j back_jmp_targ) back_jmp;\n+\n+                    (* Set the new vec's fill to the original vec's fill *)\n+                    let dst_fill = get_element_ptr dst_vec Abi.vec_elt_fill in\n+                    let v = next_vreg_cell word_sty in\n+                      mov v (Il.Cell fill);\n+                      mov dst_fill (Il.Cell v);\n+\n+                      List.iter patch no_copy_jmps;\n+\n+                      mov vec_cell (Il.Cell new_vec_cell);\n+\n+                      trans_glue_frame_exit fix spill g\n+\n+\n+  and get_vec_grow_glue _\n+      : fixup =\n+    let g = GLUE_vec_grow in\n+    match htab_search cx.ctxt_glue_code g with\n+        Some code -> code.code_fixup\n+      | None ->\n+          begin\n+            let fix = new_fixup (glue_str cx g) in\n+              emit_vec_grow_glue fix g;\n+              fix\n+          end\n \n   (* Glue functions use mostly the same calling convention as ordinary\n    * functions.\n@@ -4418,21 +4571,29 @@ let trans_visitor\n           (Ast.TY_str, Ast.TY_str)\n         | (Ast.TY_vec _, Ast.TY_vec _)\n             when (simplified_ty dst_ty) = (simplified_ty src_ty) ->\n-            let is_gc = if type_has_state src_ty then 1L else 0L in\n+\n             let src_cell = need_cell src_oper in\n             let src_vec = deref src_cell in\n             let src_fill = get_element_ptr src_vec Abi.vec_elt_fill in\n             let dst_vec = deref dst_cell in\n             let dst_fill = get_element_ptr dst_vec Abi.vec_elt_fill in\n+\n               if trailing_null\n               then sub_from dst_fill (imm 1L);\n-              trans_upcall \"upcall_vec_grow\"\n-                dst_cell\n-                [| Il.Cell dst_cell;\n-                   Il.Cell src_fill;\n-                   imm is_gc |];\n \n-              (* \n+              aliasing true dst_cell\n+                begin\n+                  fun dst_vec_alias ->\n+                    trans_call_simple_static_glue\n+                      (get_vec_grow_glue ())\n+                      (get_ty_params_of_current_frame ())\n+                      [| get_tydesc None elt_ty;\n+                         dst_vec_alias;\n+                         src_fill; |]\n+                      None\n+                end;\n+\n+              (*\n                * By now, dst_cell points to a vec/str with room for us\n                * to add to.\n                *)\n@@ -4486,13 +4647,21 @@ let trans_visitor\n         | (Ast.TY_vec _, e)\n             when e = simplified_ty elt_ty ->\n \n-            let dst_is_gc = if type_has_state dst_ty then 1L else 0L in\n             let elt_sz = ty_sz_in_current_frame elt_ty in\n-              trans_upcall \"upcall_vec_grow\"\n-                dst_cell\n-                [| Il.Cell dst_cell;\n-                   elt_sz;\n-                   imm dst_is_gc |];\n+            let elt_sz_cell = next_vreg_cell word_sty in\n+              mov elt_sz_cell elt_sz;\n+\n+              aliasing true dst_cell\n+                begin\n+                  fun dst_vec_alias ->\n+                    trans_call_simple_static_glue\n+                      (get_vec_grow_glue ())\n+                      (get_ty_params_of_current_frame ())\n+                      [| get_tydesc None elt_ty;\n+                         dst_vec_alias;\n+                         elt_sz_cell; |]\n+                      None\n+                end;\n \n               (* \n                * By now, dst_cell points to a vec/str with room for us"}, {"sha": "954e7a13ded8fffb5dd2df0bdfaeed6b79be3e98", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4e355aebf7c0987c3d6f66ca0013e7023aa501dd/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4e355aebf7c0987c3d6f66ca0013e7023aa501dd/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=4e355aebf7c0987c3d6f66ca0013e7023aa501dd", "patch": "@@ -384,18 +384,23 @@ upcall_new_vec(rust_task *task, size_t fill, type_desc *td) {\n     return v;\n }\n \n-extern \"C\" CDECL rust_str *\n+extern \"C\" CDECL rust_vec *\n upcall_vec_grow(rust_task *task,\n                 rust_vec *v,\n                 size_t n_bytes,\n-                uintptr_t is_gc) {\n+                uintptr_t *need_copy)\n+{\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n-    task->log(rust_log::UPCALL|rust_log::MEM,\n-             \"upcall vec_grow(0x%\" PRIxPTR \", %\" PRIdPTR\n-             \"), alloc=%\" PRIdPTR \", fill=%\" PRIdPTR,\n-             v, n_bytes, v->alloc, v->fill);\n+    task->log(rust_log::UPCALL | rust_log::MEM,\n+              \"upcall vec_grow(0x%\" PRIxPTR \", %\" PRIdPTR\n+              \"), alloc=%\" PRIdPTR \", fill=%\" PRIdPTR\n+              \", need_copy=0x%\" PRIxPTR,\n+              v, n_bytes, v->alloc, v->fill, need_copy);\n+\n+    *need_copy = 0;\n     size_t alloc = next_power_of_two(sizeof(rust_vec) + v->fill + n_bytes);\n+\n     if (v->ref_count == 1) {\n \n         // Fastest path: already large enough.\n@@ -414,16 +419,28 @@ upcall_vec_grow(rust_task *task,\n         v->alloc = alloc;\n \n     } else {\n-        // Slowest path: make a new vec.\n+        /**\n+         * Slowest path: make a new vec.\n+         *\n+         * 1. Allocate a new rust_vec with desired additional space.\n+         * 2. Down-ref the shared rust_vec, point to the new one instead.\n+         * 3. Copy existing elements into the new rust_vec.\n+         *\n+         * Step 3 is a bit tricky.  We don't know how to properly copy the\n+         * elements in the runtime (all we have are bits in a buffer; no\n+         * type infromation and no copy glue).  What we do instead is set the\n+         * need_copy outparam flag to indicate to our caller (vec-copy glue)\n+         * that we need the copies performed for us.\n+         */\n         task->log(rust_log::UPCALL | rust_log::MEM, \"new vec path\");\n         void *mem = dom->malloc(alloc);\n         if (!mem) {\n             task->fail(4);\n             return NULL;\n         }\n         v->deref();\n-        v = new (mem) rust_vec(dom, alloc, v->fill,\n-                               v->fill ? &v->data[0] : NULL);\n+        v = new (mem) rust_vec(dom, alloc, 0, NULL);\n+        *need_copy = 1;\n     }\n     I(dom, sizeof(rust_vec) + v->fill <= v->alloc);\n     return v;"}]}