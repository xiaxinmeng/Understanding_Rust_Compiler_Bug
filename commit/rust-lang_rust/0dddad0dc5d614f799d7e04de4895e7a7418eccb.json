{"sha": "0dddad0dc5d614f799d7e04de4895e7a7418eccb", "node_id": "C_kwDOAAsO6NoAKDBkZGRhZDBkYzVkNjE0Zjc5OWQ3ZTA0ZGU0ODk1ZTdhNzQxOGVjY2I", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-07T11:18:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-07T11:18:22Z"}, "message": "Auto merge of #111161 - compiler-errors:rtn-super, r=cjgillot\n\nSupport return-type bounds on associated methods from supertraits\n\nSupport `T: Trait<method(): Bound>` when `method` comes from a supertrait, aligning it with the behavior of associated type bounds (both equality and trait bounds).\n\nThe only wrinkle is that I have to extend `super_predicates_that_define_assoc_type` to look for *all* items, not just `AssocKind::Ty`. This will also be needed to support `feature(associated_const_equality)` as well, which is subtly broken when it comes to supertraits, though this PR does not fix those yet. There's a slight chance there's a perf regression here, in which case I guess I could split it out into a separate query.", "tree": {"sha": "c9d6db616e9b3a2d0259767a10a52f011564b9df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9d6db616e9b3a2d0259767a10a52f011564b9df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0dddad0dc5d614f799d7e04de4895e7a7418eccb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0dddad0dc5d614f799d7e04de4895e7a7418eccb", "html_url": "https://github.com/rust-lang/rust/commit/0dddad0dc5d614f799d7e04de4895e7a7418eccb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0dddad0dc5d614f799d7e04de4895e7a7418eccb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8660707bb22b2fa0ef6e2d37c60da20d9cf3d7b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8660707bb22b2fa0ef6e2d37c60da20d9cf3d7b9", "html_url": "https://github.com/rust-lang/rust/commit/8660707bb22b2fa0ef6e2d37c60da20d9cf3d7b9"}, {"sha": "76802e31a131d2ac5933b8283a292735b6ab8366", "url": "https://api.github.com/repos/rust-lang/rust/commits/76802e31a131d2ac5933b8283a292735b6ab8366", "html_url": "https://github.com/rust-lang/rust/commit/76802e31a131d2ac5933b8283a292735b6ab8366"}], "stats": {"total": 260, "additions": 210, "deletions": 50}, "files": [{"sha": "3b42b0fe246647013a990b1d3ac00f8fb8c42aca", "filename": "compiler/rustc_hir_analysis/messages.ftl", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fmessages.ftl?ref=0dddad0dc5d614f799d7e04de4895e7a7418eccb", "patch": "@@ -192,7 +192,11 @@ hir_analysis_return_type_notation_equality_bound =\n     return type notation is not allowed to use type equality\n \n hir_analysis_return_type_notation_missing_method =\n-    cannot find associated function `{$assoc_name}` in trait `{$trait_name}`\n+    cannot find associated function `{$assoc_name}` for `{$ty_name}`\n+\n+hir_analysis_return_type_notation_conflicting_bound =\n+    ambiguous associated function `{$assoc_name}` for `{$ty_name}`\n+    .note = `{$assoc_name}` is declared in two supertraits: `{$first_bound}` and `{$second_bound}`\n \n hir_analysis_placeholder_not_allowed_item_signatures = the placeholder `_` is not allowed within types on item signatures for {$kind}\n     .label = not allowed in type signatures"}, {"sha": "5ee0cf94360196cece83143ddd4c4d94cf648560", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=0dddad0dc5d614f799d7e04de4895e7a7418eccb", "patch": "@@ -1062,7 +1062,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n     /// Convert the bounds in `ast_bounds` that refer to traits which define an associated type\n     /// named `assoc_name` into ty::Bounds. Ignore the rest.\n-    pub(crate) fn compute_bounds_that_match_assoc_type(\n+    pub(crate) fn compute_bounds_that_match_assoc_item(\n         &self,\n         param_ty: Ty<'tcx>,\n         ast_bounds: &[hir::GenericBound<'_>],\n@@ -1073,7 +1073,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         for ast_bound in ast_bounds {\n             if let Some(trait_ref) = ast_bound.trait_ref()\n                 && let Some(trait_did) = trait_ref.trait_def_id()\n-                && self.tcx().trait_may_define_assoc_type(trait_did, assoc_name)\n+                && self.tcx().trait_may_define_assoc_item(trait_did, assoc_name)\n             {\n                 result.push(ast_bound.clone());\n             }\n@@ -1141,11 +1141,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             ) {\n                 trait_ref\n             } else {\n-                return Err(tcx.sess.emit_err(crate::errors::ReturnTypeNotationMissingMethod {\n-                    span: binding.span,\n-                    trait_name: tcx.item_name(trait_ref.def_id()),\n-                    assoc_name: binding.item_name.name,\n-                }));\n+                self.one_bound_for_assoc_method(\n+                    traits::supertraits(tcx, trait_ref),\n+                    trait_ref.print_only_trait_path(),\n+                    binding.item_name,\n+                    path_span,\n+                )?\n             }\n         } else if self.trait_defines_associated_item_named(\n             trait_ref.def_id(),\n@@ -1946,7 +1947,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let param_name = tcx.hir().ty_param_name(ty_param_def_id);\n         self.one_bound_for_assoc_type(\n             || {\n-                traits::transitive_bounds_that_define_assoc_type(\n+                traits::transitive_bounds_that_define_assoc_item(\n                     tcx,\n                     predicates.iter().filter_map(|(p, _)| {\n                         Some(p.to_opt_poly_trait_pred()?.map_bound(|t| t.trait_ref))\n@@ -2081,6 +2082,46 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Ok(bound)\n     }\n \n+    #[instrument(level = \"debug\", skip(self, all_candidates, ty_name), ret)]\n+    fn one_bound_for_assoc_method(\n+        &self,\n+        all_candidates: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+        ty_name: impl Display,\n+        assoc_name: Ident,\n+        span: Span,\n+    ) -> Result<ty::PolyTraitRef<'tcx>, ErrorGuaranteed> {\n+        let mut matching_candidates = all_candidates.filter(|r| {\n+            self.trait_defines_associated_item_named(r.def_id(), ty::AssocKind::Fn, assoc_name)\n+        });\n+\n+        let candidate = match matching_candidates.next() {\n+            Some(candidate) => candidate,\n+            None => {\n+                return Err(self.tcx().sess.emit_err(\n+                    crate::errors::ReturnTypeNotationMissingMethod {\n+                        span,\n+                        ty_name: ty_name.to_string(),\n+                        assoc_name: assoc_name.name,\n+                    },\n+                ));\n+            }\n+        };\n+\n+        if let Some(conflicting_candidate) = matching_candidates.next() {\n+            return Err(self.tcx().sess.emit_err(\n+                crate::errors::ReturnTypeNotationConflictingBound {\n+                    span,\n+                    ty_name: ty_name.to_string(),\n+                    assoc_name: assoc_name.name,\n+                    first_bound: candidate.print_only_trait_path(),\n+                    second_bound: conflicting_candidate.print_only_trait_path(),\n+                },\n+            ));\n+        }\n+\n+        Ok(candidate)\n+    }\n+\n     // Create a type from a path to an associated type or to an enum variant.\n     // For a path `A::B::C::D`, `qself_ty` and `qself_def` are the type and def for `A::B::C`\n     // and item_segment is the path segment for `D`. We return a type and a def for"}, {"sha": "b65817ee95e92e7aa437e570689416786f9985e7", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=0dddad0dc5d614f799d7e04de4895e7a7418eccb", "patch": "@@ -64,8 +64,8 @@ pub fn provide(providers: &mut Providers) {\n         explicit_predicates_of: predicates_of::explicit_predicates_of,\n         super_predicates_of: predicates_of::super_predicates_of,\n         implied_predicates_of: predicates_of::implied_predicates_of,\n-        super_predicates_that_define_assoc_type:\n-            predicates_of::super_predicates_that_define_assoc_type,\n+        super_predicates_that_define_assoc_item:\n+            predicates_of::super_predicates_that_define_assoc_item,\n         trait_explicit_predicates_and_bounds: predicates_of::trait_explicit_predicates_and_bounds,\n         type_param_predicates: predicates_of::type_param_predicates,\n         trait_def,"}, {"sha": "6c06957d1ee12722ade8b4ef8446b856e6fa840e", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=0dddad0dc5d614f799d7e04de4895e7a7418eccb", "patch": "@@ -565,7 +565,7 @@ pub(super) fn super_predicates_of(\n     implied_predicates_with_filter(tcx, trait_def_id.to_def_id(), PredicateFilter::SelfOnly)\n }\n \n-pub(super) fn super_predicates_that_define_assoc_type(\n+pub(super) fn super_predicates_that_define_assoc_item(\n     tcx: TyCtxt<'_>,\n     (trait_def_id, assoc_name): (DefId, Ident),\n ) -> ty::GenericPredicates<'_> {\n@@ -640,7 +640,7 @@ pub(super) fn implied_predicates_with_filter(\n         ),\n         PredicateFilter::SelfThatDefines(assoc_name) => (\n             // Convert the bounds that follow the colon (or equal) that reference the associated name\n-            icx.astconv().compute_bounds_that_match_assoc_type(self_param_ty, bounds, assoc_name),\n+            icx.astconv().compute_bounds_that_match_assoc_item(self_param_ty, bounds, assoc_name),\n             // Include where clause bounds for `Self` that reference the associated name\n             icx.type_parameter_bounds_in_generics(\n                 generics,\n@@ -819,7 +819,7 @@ impl<'tcx> ItemCtxt<'tcx> {\n             hir::GenericBound::Trait(poly_trait_ref, _) => {\n                 let trait_ref = &poly_trait_ref.trait_ref;\n                 if let Some(trait_did) = trait_ref.trait_def_id() {\n-                    self.tcx.trait_may_define_assoc_type(trait_did, assoc_name)\n+                    self.tcx.trait_may_define_assoc_item(trait_did, assoc_name)\n                 } else {\n                     false\n                 }"}, {"sha": "ab0dd01ce3aed72bf385a12fe496a8236885ce5a", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=0dddad0dc5d614f799d7e04de4895e7a7418eccb", "patch": "@@ -1652,27 +1652,28 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n             if binding.gen_args.parenthesized == hir::GenericArgsParentheses::ReturnTypeNotation {\n                 let bound_vars = if let Some(type_def_id) = type_def_id\n                     && self.tcx.def_kind(type_def_id) == DefKind::Trait\n-                    // FIXME(return_type_notation): We could bound supertrait methods.\n-                    && let Some(assoc_fn) = self\n-                        .tcx\n-                        .associated_items(type_def_id)\n-                        .find_by_name_and_kind(self.tcx, binding.ident, ty::AssocKind::Fn, type_def_id)\n+                    && let Some((mut bound_vars, assoc_fn)) =\n+                        BoundVarContext::supertrait_hrtb_vars(\n+                            self.tcx,\n+                            type_def_id,\n+                            binding.ident,\n+                            ty::AssocKind::Fn,\n+                        )\n                 {\n-                    self.tcx\n-                        .generics_of(assoc_fn.def_id)\n-                        .params\n-                        .iter()\n-                        .map(|param| match param.kind {\n+                    bound_vars.extend(self.tcx.generics_of(assoc_fn.def_id).params.iter().map(\n+                        |param| match param.kind {\n                             ty::GenericParamDefKind::Lifetime => ty::BoundVariableKind::Region(\n                                 ty::BoundRegionKind::BrNamed(param.def_id, param.name),\n                             ),\n                             ty::GenericParamDefKind::Type { .. } => ty::BoundVariableKind::Ty(\n                                 ty::BoundTyKind::Param(param.def_id, param.name),\n                             ),\n                             ty::GenericParamDefKind::Const { .. } => ty::BoundVariableKind::Const,\n-                        })\n-                        .chain(self.tcx.fn_sig(assoc_fn.def_id).subst_identity().bound_vars())\n-                        .collect()\n+                        },\n+                    ));\n+                    bound_vars\n+                        .extend(self.tcx.fn_sig(assoc_fn.def_id).subst_identity().bound_vars());\n+                    bound_vars\n                 } else {\n                     self.tcx.sess.delay_span_bug(\n                         binding.ident.span,\n@@ -1689,8 +1690,13 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n                     });\n                 });\n             } else if let Some(type_def_id) = type_def_id {\n-                let bound_vars =\n-                    BoundVarContext::supertrait_hrtb_vars(self.tcx, type_def_id, binding.ident);\n+                let bound_vars = BoundVarContext::supertrait_hrtb_vars(\n+                    self.tcx,\n+                    type_def_id,\n+                    binding.ident,\n+                    ty::AssocKind::Type,\n+                )\n+                .map(|(bound_vars, _)| bound_vars);\n                 self.with(scope, |this| {\n                     let scope = Scope::Supertrait {\n                         bound_vars: bound_vars.unwrap_or_default(),\n@@ -1720,11 +1726,15 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n         assoc_name: Ident,\n-    ) -> Option<Vec<ty::BoundVariableKind>> {\n-        let trait_defines_associated_type_named = |trait_def_id: DefId| {\n-            tcx.associated_items(trait_def_id)\n-                .find_by_name_and_kind(tcx, assoc_name, ty::AssocKind::Type, trait_def_id)\n-                .is_some()\n+        assoc_kind: ty::AssocKind,\n+    ) -> Option<(Vec<ty::BoundVariableKind>, &'tcx ty::AssocItem)> {\n+        let trait_defines_associated_item_named = |trait_def_id: DefId| {\n+            tcx.associated_items(trait_def_id).find_by_name_and_kind(\n+                tcx,\n+                assoc_name,\n+                assoc_kind,\n+                trait_def_id,\n+            )\n         };\n \n         use smallvec::{smallvec, SmallVec};\n@@ -1742,10 +1752,10 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n                 _ => break None,\n             }\n \n-            if trait_defines_associated_type_named(def_id) {\n-                break Some(bound_vars.into_iter().collect());\n+            if let Some(assoc_item) = trait_defines_associated_item_named(def_id) {\n+                break Some((bound_vars.into_iter().collect(), assoc_item));\n             }\n-            let predicates = tcx.super_predicates_that_define_assoc_type((def_id, assoc_name));\n+            let predicates = tcx.super_predicates_that_define_assoc_item((def_id, assoc_name));\n             let obligations = predicates.predicates.iter().filter_map(|&(pred, _)| {\n                 let bound_predicate = pred.kind();\n                 match bound_predicate.skip_binder() {"}, {"sha": "379a88538a9219582b81683f348c217f215aa12d", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=0dddad0dc5d614f799d7e04de4895e7a7418eccb", "patch": "@@ -6,7 +6,7 @@ use rustc_errors::{\n     MultiSpan,\n };\n use rustc_macros::{Diagnostic, Subdiagnostic};\n-use rustc_middle::ty::Ty;\n+use rustc_middle::ty::{self, print::TraitRefPrintOnlyTraitPath, Ty};\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n #[derive(Diagnostic)]\n@@ -512,10 +512,22 @@ pub(crate) struct ReturnTypeNotationEqualityBound {\n pub(crate) struct ReturnTypeNotationMissingMethod {\n     #[primary_span]\n     pub span: Span,\n-    pub trait_name: Symbol,\n+    pub ty_name: String,\n     pub assoc_name: Symbol,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_return_type_notation_conflicting_bound)]\n+#[note]\n+pub(crate) struct ReturnTypeNotationConflictingBound<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty_name: String,\n+    pub assoc_name: Symbol,\n+    pub first_bound: ty::Binder<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+    pub second_bound: ty::Binder<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(hir_analysis_placeholder_not_allowed_item_signatures, code = \"E0121\")]\n pub(crate) struct PlaceholderNotAllowedItemSignatures {"}, {"sha": "74a78f38024e0309eb1029147caf64d996e93abd", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=0dddad0dc5d614f799d7e04de4895e7a7418eccb", "patch": "@@ -380,11 +380,11 @@ pub fn transitive_bounds<'tcx>(\n }\n \n /// A specialized variant of `elaborate` that only elaborates trait references that may\n-/// define the given associated type `assoc_name`. It uses the\n-/// `super_predicates_that_define_assoc_type` query to avoid enumerating super-predicates that\n+/// define the given associated item with the name `assoc_name`. It uses the\n+/// `super_predicates_that_define_assoc_item` query to avoid enumerating super-predicates that\n /// aren't related to `assoc_item`. This is used when resolving types like `Self::Item` or\n /// `T::Item` and helps to avoid cycle errors (see e.g. #35237).\n-pub fn transitive_bounds_that_define_assoc_type<'tcx>(\n+pub fn transitive_bounds_that_define_assoc_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n     assoc_name: Ident,\n@@ -397,7 +397,7 @@ pub fn transitive_bounds_that_define_assoc_type<'tcx>(\n             let anon_trait_ref = tcx.anonymize_bound_vars(trait_ref);\n             if visited.insert(anon_trait_ref) {\n                 let super_predicates =\n-                    tcx.super_predicates_that_define_assoc_type((trait_ref.def_id(), assoc_name));\n+                    tcx.super_predicates_that_define_assoc_item((trait_ref.def_id(), assoc_name));\n                 for (super_predicate, _) in super_predicates.predicates {\n                     let subst_predicate = super_predicate.subst_supertrait(tcx, &trait_ref);\n                     if let Some(binder) = subst_predicate.to_opt_poly_trait_pred() {"}, {"sha": "b425c7600ac688912bdd4363ede77d9e8f624695", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=0dddad0dc5d614f799d7e04de4895e7a7418eccb", "patch": "@@ -569,7 +569,7 @@ rustc_queries! {\n     /// returns the full set of predicates. If `Some<Ident>`, then the query returns only the\n     /// subset of super-predicates that reference traits that define the given associated type.\n     /// This is used to avoid cycles in resolving types like `T::Item`.\n-    query super_predicates_that_define_assoc_type(key: (DefId, rustc_span::symbol::Ident)) -> ty::GenericPredicates<'tcx> {\n+    query super_predicates_that_define_assoc_item(key: (DefId, rustc_span::symbol::Ident)) -> ty::GenericPredicates<'tcx> {\n         desc { |tcx| \"computing the super traits of `{}` with associated type name `{}`\",\n             tcx.def_path_str(key.0),\n             key.1"}, {"sha": "a2e248e45ca7373861c05bc740bcf3384e38fb95", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=0dddad0dc5d614f799d7e04de4895e7a7418eccb", "patch": "@@ -1567,11 +1567,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Given the def_id of a Trait `trait_def_id` and the name of an associated item `assoc_name`\n     /// returns true if the `trait_def_id` defines an associated item of name `assoc_name`.\n-    pub fn trait_may_define_assoc_type(self, trait_def_id: DefId, assoc_name: Ident) -> bool {\n+    pub fn trait_may_define_assoc_item(self, trait_def_id: DefId, assoc_name: Ident) -> bool {\n         self.super_traits_of(trait_def_id).any(|trait_did| {\n             self.associated_items(trait_did)\n-                .find_by_name_and_kind(self, assoc_name, ty::AssocKind::Type, trait_did)\n-                .is_some()\n+                .filter_by_name_unhygienic(assoc_name.name)\n+                .any(|item| self.hygienic_eq(assoc_name, item.ident(self), trait_did))\n         })\n     }\n "}, {"sha": "b7e780b94efee759e6298eff4ae101e1ccfda075", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=0dddad0dc5d614f799d7e04de4895e7a7418eccb", "patch": "@@ -2633,6 +2633,12 @@ macro_rules! define_print_and_forward_display {\n #[derive(Copy, Clone, TypeFoldable, TypeVisitable, Lift)]\n pub struct TraitRefPrintOnlyTraitPath<'tcx>(ty::TraitRef<'tcx>);\n \n+impl<'tcx> rustc_errors::IntoDiagnosticArg for TraitRefPrintOnlyTraitPath<'tcx> {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        self.to_string().into_diagnostic_arg()\n+    }\n+}\n+\n impl<'tcx> fmt::Debug for TraitRefPrintOnlyTraitPath<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(self, f)"}, {"sha": "d8e5725d3cafaa438640fa1aaa6137347c4480eb", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dddad0dc5d614f799d7e04de4895e7a7418eccb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=0dddad0dc5d614f799d7e04de4895e7a7418eccb", "patch": "@@ -62,7 +62,7 @@ pub use self::util::elaborate;\n pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n pub use self::util::{get_vtable_index_of_object_method, impl_item_is_final, upcast_choices};\n pub use self::util::{\n-    supertrait_def_ids, supertraits, transitive_bounds, transitive_bounds_that_define_assoc_type,\n+    supertrait_def_ids, supertraits, transitive_bounds, transitive_bounds_that_define_assoc_item,\n     SupertraitDefIds,\n };\n "}, {"sha": "a52562d78f8ae6fbc75cd745f66a51c3e061fd07", "filename": "tests/ui/associated-type-bounds/return-type-notation/missing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dddad0dc5d614f799d7e04de4895e7a7418eccb/tests%2Fui%2Fassociated-type-bounds%2Freturn-type-notation%2Fmissing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dddad0dc5d614f799d7e04de4895e7a7418eccb/tests%2Fui%2Fassociated-type-bounds%2Freturn-type-notation%2Fmissing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-type-bounds%2Freturn-type-notation%2Fmissing.rs?ref=0dddad0dc5d614f799d7e04de4895e7a7418eccb", "patch": "@@ -8,6 +8,6 @@ trait Trait {\n }\n \n fn bar<T: Trait<methid(): Send>>() {}\n-//~^ ERROR cannot find associated function `methid` in trait `Trait`\n+//~^ ERROR cannot find associated function `methid` for `Trait`\n \n fn main() {}"}, {"sha": "5b1c4cb0b2c0acf9be0f66913f0a184adc1a2d97", "filename": "tests/ui/associated-type-bounds/return-type-notation/missing.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dddad0dc5d614f799d7e04de4895e7a7418eccb/tests%2Fui%2Fassociated-type-bounds%2Freturn-type-notation%2Fmissing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0dddad0dc5d614f799d7e04de4895e7a7418eccb/tests%2Fui%2Fassociated-type-bounds%2Freturn-type-notation%2Fmissing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-type-bounds%2Freturn-type-notation%2Fmissing.stderr?ref=0dddad0dc5d614f799d7e04de4895e7a7418eccb", "patch": "@@ -7,7 +7,7 @@ LL | #![feature(return_type_notation, async_fn_in_trait)]\n    = note: see issue #109417 <https://github.com/rust-lang/rust/issues/109417> for more information\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error: cannot find associated function `methid` in trait `Trait`\n+error: cannot find associated function `methid` for `Trait`\n   --> $DIR/missing.rs:10:17\n    |\n LL | fn bar<T: Trait<methid(): Send>>() {}"}, {"sha": "028e526b5f5039c21411d9bb7715749ee04f6110", "filename": "tests/ui/async-await/return-type-notation/super-method-bound-ambig.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0dddad0dc5d614f799d7e04de4895e7a7418eccb/tests%2Fui%2Fasync-await%2Freturn-type-notation%2Fsuper-method-bound-ambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dddad0dc5d614f799d7e04de4895e7a7418eccb/tests%2Fui%2Fasync-await%2Freturn-type-notation%2Fsuper-method-bound-ambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Freturn-type-notation%2Fsuper-method-bound-ambig.rs?ref=0dddad0dc5d614f799d7e04de4895e7a7418eccb", "patch": "@@ -0,0 +1,32 @@\n+// edition:2021\n+\n+#![feature(async_fn_in_trait, return_type_notation)]\n+//~^ WARN the feature `return_type_notation` is incomplete\n+\n+trait Super1<'a> {\n+    async fn test();\n+}\n+impl Super1<'_> for () {\n+    async fn test() {}\n+}\n+\n+trait Super2 {\n+    async fn test();\n+}\n+impl Super2 for () {\n+    async fn test() {}\n+}\n+\n+trait Foo: for<'a> Super1<'a> + Super2 {}\n+impl Foo for () {}\n+\n+fn test<T>()\n+where\n+    T: Foo<test(): Send>,\n+    //~^ ERROR ambiguous associated function `test` for `Foo`\n+{\n+}\n+\n+fn main() {\n+    test::<()>();\n+}"}, {"sha": "5bc8dbde4bcd5ca051b32e449de6dc307b8b6ae6", "filename": "tests/ui/async-await/return-type-notation/super-method-bound-ambig.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0dddad0dc5d614f799d7e04de4895e7a7418eccb/tests%2Fui%2Fasync-await%2Freturn-type-notation%2Fsuper-method-bound-ambig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0dddad0dc5d614f799d7e04de4895e7a7418eccb/tests%2Fui%2Fasync-await%2Freturn-type-notation%2Fsuper-method-bound-ambig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Freturn-type-notation%2Fsuper-method-bound-ambig.stderr?ref=0dddad0dc5d614f799d7e04de4895e7a7418eccb", "patch": "@@ -0,0 +1,19 @@\n+warning: the feature `return_type_notation` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/super-method-bound-ambig.rs:3:31\n+   |\n+LL | #![feature(async_fn_in_trait, return_type_notation)]\n+   |                               ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #109417 <https://github.com/rust-lang/rust/issues/109417> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error: ambiguous associated function `test` for `Foo`\n+  --> $DIR/super-method-bound-ambig.rs:25:12\n+   |\n+LL |     T: Foo<test(): Send>,\n+   |            ^^^^^^^^^^^^\n+   |\n+   = note: `test` is declared in two supertraits: `Super2` and `Super1<'a>`\n+\n+error: aborting due to previous error; 1 warning emitted\n+"}, {"sha": "58ea3578db62eb3ade7ee4b106f2a5c5174919af", "filename": "tests/ui/async-await/return-type-notation/super-method-bound.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0dddad0dc5d614f799d7e04de4895e7a7418eccb/tests%2Fui%2Fasync-await%2Freturn-type-notation%2Fsuper-method-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dddad0dc5d614f799d7e04de4895e7a7418eccb/tests%2Fui%2Fasync-await%2Freturn-type-notation%2Fsuper-method-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Freturn-type-notation%2Fsuper-method-bound.rs?ref=0dddad0dc5d614f799d7e04de4895e7a7418eccb", "patch": "@@ -0,0 +1,25 @@\n+// edition:2021\n+// check-pass\n+\n+#![feature(async_fn_in_trait, return_type_notation)]\n+//~^ WARN the feature `return_type_notation` is incomplete\n+\n+trait Super<'a> {\n+    async fn test();\n+}\n+impl Super<'_> for () {\n+    async fn test() {}\n+}\n+\n+trait Foo: for<'a> Super<'a> {}\n+impl Foo for () {}\n+\n+fn test<T>()\n+where\n+    T: Foo<test(): Send>,\n+{\n+}\n+\n+fn main() {\n+    test::<()>();\n+}"}, {"sha": "ac0668d3c44923c2c06cc7ff79940143a03175c9", "filename": "tests/ui/async-await/return-type-notation/super-method-bound.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0dddad0dc5d614f799d7e04de4895e7a7418eccb/tests%2Fui%2Fasync-await%2Freturn-type-notation%2Fsuper-method-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0dddad0dc5d614f799d7e04de4895e7a7418eccb/tests%2Fui%2Fasync-await%2Freturn-type-notation%2Fsuper-method-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Freturn-type-notation%2Fsuper-method-bound.stderr?ref=0dddad0dc5d614f799d7e04de4895e7a7418eccb", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `return_type_notation` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/super-method-bound.rs:4:31\n+   |\n+LL | #![feature(async_fn_in_trait, return_type_notation)]\n+   |                               ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #109417 <https://github.com/rust-lang/rust/issues/109417> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+warning: 1 warning emitted\n+"}]}