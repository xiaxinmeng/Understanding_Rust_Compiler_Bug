{"sha": "ff54e34463c1af0025e29d41ebfbc1dfb4083e15", "node_id": "C_kwDOAAsO6NoAKGZmNTRlMzQ0NjNjMWFmMDAyNWUyOWQ0MWViZmJjMWRmYjQwODNlMTU", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-03-08T21:43:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-08T21:43:59Z"}, "message": "Rollup merge of #94723 - dtolnay:mustuse, r=Mark-Simulacrum\n\nAdd core::hint::must_use\n\nThe example code in this documentation is minimized from a real-world situation in the `anyhow` crate where this function would have been valuable.\n\nHaving this provided by the standard library is especially useful for proc macros, even more than for macro_rules. That's because proc macro crates aren't allowed to export anything other than macros, so they couldn't make their own `must_use` function for their macro-generated code to call.\n\n<br>\n\n## Rendered documentation\n\n> An identity function that causes an `unused_must_use` warning to be triggered if the given value is not used (returned, stored in a variable, etc) by the caller.\n>\n> This is primarily intended for use in macro-generated code, in which a [`#[must_use]` attribute][must_use] either on a type or a function would not be convenient.\n>\n> [must_use]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n>\n> ### Example\n>\n> ```rust\n> #![feature(hint_must_use)]\n>\n> use core::fmt;\n>\n> pub struct Error(/* ... */);\n>\n> #[macro_export]\n> macro_rules! make_error {\n>     ($($args:expr),*) => {\n>         core::hint::must_use({\n>             let error = $crate::make_error(core::format_args!($($args),*));\n>             error\n>         })\n>     };\n> }\n>\n> // Implementation detail of make_error! macro.\n> #[doc(hidden)]\n> pub fn make_error(args: fmt::Arguments<'_>) -> Error {\n>     Error(/* ... */)\n> }\n>\n> fn demo() -> Option<Error> {\n>     if true {\n>         // Oops, meant to write `return Some(make_error!(\"...\"));`\n>         Some(make_error!(\"...\"));\n>     }\n>     None\n> }\n> ```\n>\n> In the above example, we'd like an `unused_must_use` lint to apply to the value created by `make_error!`. However, neither `#[must_use]` on a struct nor `#[must_use]` on a function is appropriate here, so the macro expands using `core::hint::must_use` instead.\n>\n> - We wouldn't want `#[must_use]` on the `struct Error` because that would make the following unproblematic code trigger a warning:\n>\n>   ```rust\n>   fn f(arg: &str) -> Result<(), Error>\n>\n>   #[test]\n>   fn t() {\n>       // Assert that `f` returns error if passed an empty string.\n>       // A value of type `Error` is unused here but that's not a problem.\n>       f(\"\").unwrap_err();\n>   }\n>   ```\n>\n> - Using `#[must_use]` on `fn make_error` can't help because the return value *is* used, as the right-hand side of a `let` statement. The `let` statement looks useless but is in fact necessary for ensuring that temporaries within the `format_args` expansion are not kept alive past the creation of the `Error`, as keeping them alive past that point can cause autotrait issues in async code:\n>\n>   ```rust\n>   async fn f() {\n>       // Using `let` inside the make_error expansion causes temporaries like\n>       // `unsync()` to drop at the semicolon of that `let` statement, which\n>       // is prior to the await point. They would otherwise stay around until\n>       // the semicolon on *this* statement, which is after the await point,\n>       // and the enclosing Future would not implement Send.\n>       log(make_error!(\"look: {:p}\", unsync())).await;\n>   }\n>\n>   async fn log(error: Error) {/* ... */}\n>\n>   // Returns something without a Sync impl.\n>   fn unsync() -> *const () {\n>       0 as *const ()\n>   }\n>   ```", "tree": {"sha": "1255eb21db39ea1c1c75397a0e4560ef3d18975f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1255eb21db39ea1c1c75397a0e4560ef3d18975f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff54e34463c1af0025e29d41ebfbc1dfb4083e15", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiJ84fCRBK7hj4Ov3rIwAAKhMIAIj3FwhgaDQ+C7lr4fuVxdrG\nQKiFF7AeSlwpFoSQGe/hKLoLvkhlEqhdLh3Ft1x3PQYRjpXTyA2q6IuBee/8+I1y\n7hFx15OVDQFwVOj9drGxmR3rc1AS1Rh9N2seHFZEX8c8uGJBQj2KPit03v/gFSQ2\nTV5BRvi7J7wg5xk+J8XiKKa326H8oGRCUUXWvO0EeUmzJx6sEYZBH7emO8d9bqTV\nn+ZQUjcQsZddO3LDlCqqTruBVSkVNKH82uKlJTmdGZo0pIfyplkQQRgjFmLqwp7k\nGkn+4NoivHtNLcyz27wI0n84duxf1EkL85o/Wnyco7z43C/qVFlZgTB/+vNUIKM=\n=63Ui\n-----END PGP SIGNATURE-----\n", "payload": "tree 1255eb21db39ea1c1c75397a0e4560ef3d18975f\nparent ee8109d12d0c8c236d0a58a3ec7a28769d094731\nparent b2473e988fdf304f87099102019cca8041a64887\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1646775839 +0100\ncommitter GitHub <noreply@github.com> 1646775839 +0100\n\nRollup merge of #94723 - dtolnay:mustuse, r=Mark-Simulacrum\n\nAdd core::hint::must_use\n\nThe example code in this documentation is minimized from a real-world situation in the `anyhow` crate where this function would have been valuable.\n\nHaving this provided by the standard library is especially useful for proc macros, even more than for macro_rules. That's because proc macro crates aren't allowed to export anything other than macros, so they couldn't make their own `must_use` function for their macro-generated code to call.\n\n<br>\n\n## Rendered documentation\n\n> An identity function that causes an `unused_must_use` warning to be triggered if the given value is not used (returned, stored in a variable, etc) by the caller.\n>\n> This is primarily intended for use in macro-generated code, in which a [`#[must_use]` attribute][must_use] either on a type or a function would not be convenient.\n>\n> [must_use]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n>\n> ### Example\n>\n> ```rust\n> #![feature(hint_must_use)]\n>\n> use core::fmt;\n>\n> pub struct Error(/* ... */);\n>\n> #[macro_export]\n> macro_rules! make_error {\n>     ($($args:expr),*) => {\n>         core::hint::must_use({\n>             let error = $crate::make_error(core::format_args!($($args),*));\n>             error\n>         })\n>     };\n> }\n>\n> // Implementation detail of make_error! macro.\n> #[doc(hidden)]\n> pub fn make_error(args: fmt::Arguments<'_>) -> Error {\n>     Error(/* ... */)\n> }\n>\n> fn demo() -> Option<Error> {\n>     if true {\n>         // Oops, meant to write `return Some(make_error!(\"...\"));`\n>         Some(make_error!(\"...\"));\n>     }\n>     None\n> }\n> ```\n>\n> In the above example, we'd like an `unused_must_use` lint to apply to the value created by `make_error!`. However, neither `#[must_use]` on a struct nor `#[must_use]` on a function is appropriate here, so the macro expands using `core::hint::must_use` instead.\n>\n> - We wouldn't want `#[must_use]` on the `struct Error` because that would make the following unproblematic code trigger a warning:\n>\n>   ```rust\n>   fn f(arg: &str) -> Result<(), Error>\n>\n>   #[test]\n>   fn t() {\n>       // Assert that `f` returns error if passed an empty string.\n>       // A value of type `Error` is unused here but that's not a problem.\n>       f(\"\").unwrap_err();\n>   }\n>   ```\n>\n> - Using `#[must_use]` on `fn make_error` can't help because the return value *is* used, as the right-hand side of a `let` statement. The `let` statement looks useless but is in fact necessary for ensuring that temporaries within the `format_args` expansion are not kept alive past the creation of the `Error`, as keeping them alive past that point can cause autotrait issues in async code:\n>\n>   ```rust\n>   async fn f() {\n>       // Using `let` inside the make_error expansion causes temporaries like\n>       // `unsync()` to drop at the semicolon of that `let` statement, which\n>       // is prior to the await point. They would otherwise stay around until\n>       // the semicolon on *this* statement, which is after the await point,\n>       // and the enclosing Future would not implement Send.\n>       log(make_error!(\"look: {:p}\", unsync())).await;\n>   }\n>\n>   async fn log(error: Error) {/* ... */}\n>\n>   // Returns something without a Sync impl.\n>   fn unsync() -> *const () {\n>       0 as *const ()\n>   }\n>   ```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff54e34463c1af0025e29d41ebfbc1dfb4083e15", "html_url": "https://github.com/rust-lang/rust/commit/ff54e34463c1af0025e29d41ebfbc1dfb4083e15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff54e34463c1af0025e29d41ebfbc1dfb4083e15/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee8109d12d0c8c236d0a58a3ec7a28769d094731", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee8109d12d0c8c236d0a58a3ec7a28769d094731", "html_url": "https://github.com/rust-lang/rust/commit/ee8109d12d0c8c236d0a58a3ec7a28769d094731"}, {"sha": "b2473e988fdf304f87099102019cca8041a64887", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2473e988fdf304f87099102019cca8041a64887", "html_url": "https://github.com/rust-lang/rust/commit/b2473e988fdf304f87099102019cca8041a64887"}], "stats": {"total": 123, "additions": 123, "deletions": 0}, "files": [{"sha": "58ea109c735b67afbde616c0d21cb46ce1890ca0", "filename": "library/core/src/hint.rs", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/ff54e34463c1af0025e29d41ebfbc1dfb4083e15/library%2Fcore%2Fsrc%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff54e34463c1af0025e29d41ebfbc1dfb4083e15/library%2Fcore%2Fsrc%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhint.rs?ref=ff54e34463c1af0025e29d41ebfbc1dfb4083e15", "patch": "@@ -173,3 +173,126 @@ pub fn spin_loop() {\n pub const fn black_box<T>(dummy: T) -> T {\n     crate::intrinsics::black_box(dummy)\n }\n+\n+/// An identity function that causes an `unused_must_use` warning to be\n+/// triggered if the given value is not used (returned, stored in a variable,\n+/// etc) by the caller.\n+///\n+/// This is primarily intended for use in macro-generated code, in which a\n+/// [`#[must_use]` attribute][must_use] either on a type or a function would not\n+/// be convenient.\n+///\n+/// [must_use]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(hint_must_use)]\n+///\n+/// use core::fmt;\n+///\n+/// pub struct Error(/* ... */);\n+///\n+/// #[macro_export]\n+/// macro_rules! make_error {\n+///     ($($args:expr),*) => {\n+///         core::hint::must_use({\n+///             let error = $crate::make_error(core::format_args!($($args),*));\n+///             error\n+///         })\n+///     };\n+/// }\n+///\n+/// // Implementation detail of make_error! macro.\n+/// #[doc(hidden)]\n+/// pub fn make_error(args: fmt::Arguments<'_>) -> Error {\n+///     Error(/* ... */)\n+/// }\n+///\n+/// fn demo() -> Option<Error> {\n+///     if true {\n+///         // Oops, meant to write `return Some(make_error!(\"...\"));`\n+///         Some(make_error!(\"...\"));\n+///     }\n+///     None\n+/// }\n+/// #\n+/// # // Make rustdoc not wrap the whole snippet in fn main, so that $crate::make_error works\n+/// # fn main() {}\n+/// ```\n+///\n+/// In the above example, we'd like an `unused_must_use` lint to apply to the\n+/// value created by `make_error!`. However, neither `#[must_use]` on a struct\n+/// nor `#[must_use]` on a function is appropriate here, so the macro expands\n+/// using `core::hint::must_use` instead.\n+///\n+/// - We wouldn't want `#[must_use]` on the `struct Error` because that would\n+///   make the following unproblematic code trigger a warning:\n+///\n+///   ```\n+///   # struct Error;\n+///   #\n+///   fn f(arg: &str) -> Result<(), Error>\n+///   # { Ok(()) }\n+///\n+///   #[test]\n+///   fn t() {\n+///       // Assert that `f` returns error if passed an empty string.\n+///       // A value of type `Error` is unused here but that's not a problem.\n+///       f(\"\").unwrap_err();\n+///   }\n+///   ```\n+///\n+/// - Using `#[must_use]` on `fn make_error` can't help because the return value\n+///   *is* used, as the right-hand side of a `let` statement. The `let`\n+///   statement looks useless but is in fact necessary for ensuring that\n+///   temporaries within the `format_args` expansion are not kept alive past the\n+///   creation of the `Error`, as keeping them alive past that point can cause\n+///   autotrait issues in async code:\n+///\n+///   ```\n+///   # #![feature(hint_must_use)]\n+///   #\n+///   # struct Error;\n+///   #\n+///   # macro_rules! make_error {\n+///   #     ($($args:expr),*) => {\n+///   #         core::hint::must_use({\n+///   #             // If `let` isn't used, then `f()` produces a non-Send future.\n+///   #             let error = make_error(core::format_args!($($args),*));\n+///   #             error\n+///   #         })\n+///   #     };\n+///   # }\n+///   #\n+///   # fn make_error(args: core::fmt::Arguments<'_>) -> Error {\n+///   #     Error\n+///   # }\n+///   #\n+///   async fn f() {\n+///       // Using `let` inside the make_error expansion causes temporaries like\n+///       // `unsync()` to drop at the semicolon of that `let` statement, which\n+///       // is prior to the await point. They would otherwise stay around until\n+///       // the semicolon on *this* statement, which is after the await point,\n+///       // and the enclosing Future would not implement Send.\n+///       log(make_error!(\"look: {:p}\", unsync())).await;\n+///   }\n+///\n+///   async fn log(error: Error) {/* ... */}\n+///\n+///   // Returns something without a Sync impl.\n+///   fn unsync() -> *const () {\n+///       0 as *const ()\n+///   }\n+///   #\n+///   # fn test() {\n+///   #     fn assert_send(_: impl Send) {}\n+///   #     assert_send(f());\n+///   # }\n+///   ```\n+#[unstable(feature = \"hint_must_use\", issue = \"94745\")]\n+#[rustc_const_unstable(feature = \"hint_must_use\", issue = \"94745\")]\n+#[must_use] // <-- :)\n+pub const fn must_use<T>(value: T) -> T {\n+    value\n+}"}]}