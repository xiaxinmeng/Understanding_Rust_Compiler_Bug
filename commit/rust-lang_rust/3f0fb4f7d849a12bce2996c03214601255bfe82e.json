{"sha": "3f0fb4f7d849a12bce2996c03214601255bfe82e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmMGZiNGY3ZDg0OWExMmJjZTI5OTZjMDMyMTQ2MDEyNTViZmU4MmU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-22T16:46:48Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-25T03:38:19Z"}, "message": "split into two matrices", "tree": {"sha": "35228be829743edbf36f7bcbb57c095698fbde25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35228be829743edbf36f7bcbb57c095698fbde25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f0fb4f7d849a12bce2996c03214601255bfe82e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f0fb4f7d849a12bce2996c03214601255bfe82e", "html_url": "https://github.com/rust-lang/rust/commit/3f0fb4f7d849a12bce2996c03214601255bfe82e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f0fb4f7d849a12bce2996c03214601255bfe82e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40498bae652b737dc0885f4de9290ba701a016d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/40498bae652b737dc0885f4de9290ba701a016d5", "html_url": "https://github.com/rust-lang/rust/commit/40498bae652b737dc0885f4de9290ba701a016d5"}], "stats": {"total": 392, "additions": 245, "deletions": 147}, "files": [{"sha": "bc7b8f8df46ec7775a26d121c07b9c850e22140b", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3f0fb4f7d849a12bce2996c03214601255bfe82e/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f0fb4f7d849a12bce2996c03214601255bfe82e/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=3f0fb4f7d849a12bce2996c03214601255bfe82e", "patch": "@@ -43,12 +43,27 @@ impl<C: Idx> BitVector<C> {\n         self.data.iter().map(|e| e.count_ones() as usize).sum()\n     }\n \n+    /// True if `self` contains the bit `bit`.\n     #[inline]\n     pub fn contains(&self, bit: C) -> bool {\n         let (word, mask) = word_mask(bit);\n         (self.data[word] & mask) != 0\n     }\n \n+    /// True if `self` contains all the bits in `other`.\n+    ///\n+    /// The two vectors must have the same length.\n+    #[inline]\n+    pub fn contains_all(&self, other: &BitVector<C>) -> bool {\n+        assert_eq!(self.data.len(), other.data.len());\n+        self.data.iter().zip(&other.data).all(|(a, b)| (a & b) == *b)\n+    }\n+\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.data.iter().all(|a| *a == 0)\n+    }\n+\n     /// Returns true if the bit has changed.\n     #[inline]\n     pub fn insert(&mut self, bit: C) -> bool {\n@@ -349,6 +364,10 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         self.vector.len()\n     }\n \n+    pub fn rows(&self) -> impl Iterator<Item = R> {\n+        self.vector.indices()\n+    }\n+\n     /// Iterates through all the columns set to true in a given row of\n     /// the matrix.\n     pub fn iter<'a>(&'a self, row: R) -> impl Iterator<Item = C> + 'a {\n@@ -522,3 +541,45 @@ fn matrix_iter() {\n     }\n     assert!(iter.next().is_none());\n }\n+\n+#[test]\n+fn sparse_matrix_iter() {\n+    let mut matrix = SparseBitMatrix::new(64, 100);\n+    matrix.add(3, 22);\n+    matrix.add(3, 75);\n+    matrix.add(2, 99);\n+    matrix.add(4, 0);\n+    matrix.merge(3, 5);\n+\n+    let expected = [99];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(2) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [22, 75];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(3) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [0];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(4) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [22, 75];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(5) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+}"}, {"sha": "3ba95895bfdaf7c672001fa31f780fd9ba07a33d", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3f0fb4f7d849a12bce2996c03214601255bfe82e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f0fb4f7d849a12bce2996c03214601255bfe82e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=3f0fb4f7d849a12bce2996c03214601255bfe82e", "patch": "@@ -48,9 +48,6 @@ pub struct RegionInferenceContext<'tcx> {\n     /// from as well as its final inferred value.\n     definitions: IndexVec<RegionVid, RegionDefinition<'tcx>>,\n \n-    /// Maps from points/universal-regions to a `RegionElementIndex`.\n-    elements: Rc<RegionValueElements>,\n-\n     /// The liveness constraints added to each region. For most\n     /// regions, these start out empty and steadily grow, though for\n     /// each universally quantified region R they start out containing\n@@ -219,14 +216,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let mut scc_values = RegionValues::new(elements);\n \n-        for (region, location_set) in liveness_constraints.iter_enumerated() {\n+        for region in liveness_constraints.regions_with_points() {\n             let scc = constraint_sccs.scc(region);\n-            scc_values.merge_into(scc, location_set);\n+            scc_values.merge_row(scc, region, &liveness_constraints);\n         }\n \n         let mut result = Self {\n             definitions,\n-            elements: elements.clone(),\n             liveness_constraints,\n             constraints,\n             constraint_graph,\n@@ -273,7 +269,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n \n         // For each universally quantified region X:\n-        let elements = self.elements.clone();\n         let universal_regions = self.universal_regions.clone();\n         for variable in universal_regions.universal_regions() {\n             // These should be free-region variables.\n@@ -283,9 +278,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             });\n \n             // Add all nodes in the CFG to liveness constraints\n-            for point_index in elements.all_point_indices() {\n-                self.add_live_element(variable, point_index);\n-            }\n+            let variable_scc = self.constraint_sccs.scc(variable);\n+            self.liveness_constraints.add_all_points(variable);\n+            self.scc_values.add_all_points(variable_scc);\n \n             // Add `end(X)` into the set for X.\n             self.add_live_element(variable, variable);\n@@ -782,7 +777,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // now). Therefore, the sup-region outlives the sub-region if,\n         // for each universal region R1 in the sub-region, there\n         // exists some region R2 in the sup-region that outlives R1.\n-        let universal_outlives = self.scc_values\n+        let universal_outlives = self\n+            .scc_values\n             .universal_regions_outlived_by(sub_region_scc)\n             .all(|r1| {\n                 self.scc_values"}, {"sha": "8092b773eae8e90fa2725e507e8779a820e04c96", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 176, "deletions": 136, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/3f0fb4f7d849a12bce2996c03214601255bfe82e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f0fb4f7d849a12bce2996c03214601255bfe82e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=3f0fb4f7d849a12bce2996c03214601255bfe82e", "patch": "@@ -10,11 +10,12 @@\n \n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::ty::RegionVid;\n-use rustc_data_structures::bitvec::{BitVector, SparseBitMatrix};\n+use rustc_data_structures::bitvec::SparseBitMatrix;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt::Debug;\n use std::rc::Rc;\n+use std::ops::Range;\n \n /// Maps between the various kinds of elements of a region value to\n /// the internal indices that w use.\n@@ -50,90 +51,65 @@ impl RegionValueElements {\n \n         Self {\n             statements_before_block,\n-            num_universal_regions,\n             num_points,\n+            num_universal_regions,\n         }\n     }\n \n-    /// Total number of element indices that exist.\n-    crate fn num_elements(&self) -> usize {\n-        self.num_points + self.num_universal_regions\n-    }\n-\n-    /// Converts an element of a region value into a `RegionElementIndex`.\n-    crate fn index<T: ToElementIndex>(&self, elem: T) -> RegionElementIndex {\n-        elem.to_element_index(self)\n+    fn point_from_location(&self, location: Location) -> PointIndex {\n+        let Location {\n+            block,\n+            statement_index,\n+        } = location;\n+        let start_index = self.statements_before_block[block];\n+        PointIndex::new(start_index + statement_index)\n     }\n \n-    /// Iterates over the `RegionElementIndex` for all points in the CFG.\n-    crate fn all_point_indices<'a>(&'a self) -> impl Iterator<Item = RegionElementIndex> + 'a {\n-        (0..self.num_points).map(move |i| RegionElementIndex::new(i + self.num_universal_regions))\n+    /// Range coverting all point indices.\n+    fn all_points(&self) -> Range<PointIndex> {\n+        PointIndex::new(0)..PointIndex::new(self.num_points)\n     }\n \n-    /// Converts a particular `RegionElementIndex` to the `RegionElement` it represents.\n-    crate fn to_element(&self, i: RegionElementIndex) -> RegionElement {\n-        debug!(\"to_element(i={:?})\", i);\n-\n-        if let Some(r) = self.to_universal_region(i) {\n-            RegionElement::UniversalRegion(r)\n-        } else {\n-            let point_index = i.index() - self.num_universal_regions;\n-\n-            // Find the basic block. We have a vector with the\n-            // starting index of the statement in each block. Imagine\n-            // we have statement #22, and we have a vector like:\n-            //\n-            // [0, 10, 20]\n-            //\n-            // In that case, this represents point_index 2 of\n-            // basic block BB2. We know this because BB0 accounts for\n-            // 0..10, BB1 accounts for 11..20, and BB2 accounts for\n-            // 20...\n-            //\n-            // To compute this, we could do a binary search, but\n-            // because I am lazy we instead iterate through to find\n-            // the last point where the \"first index\" (0, 10, or 20)\n-            // was less than the statement index (22). In our case, this will\n-            // be (BB2, 20).\n-            //\n-            // Nit: we could do a binary search here but I'm too lazy.\n-            let (block, &first_index) = self\n-                .statements_before_block\n-                .iter_enumerated()\n-                .filter(|(_, first_index)| **first_index <= point_index)\n-                .last()\n-                .unwrap();\n-\n-            RegionElement::Location(Location {\n-                block,\n-                statement_index: point_index - first_index,\n-            })\n-        }\n-    }\n-\n-    /// Converts a particular `RegionElementIndex` to a universal\n-    /// region, if that is what it represents. Returns `None`\n-    /// otherwise.\n-    crate fn to_universal_region(&self, i: RegionElementIndex) -> Option<RegionVid> {\n-        if i.index() < self.num_universal_regions {\n-            Some(RegionVid::new(i.index()))\n-        } else {\n-            None\n+    /// Converts a particular `RegionElementIndex` to a location, if\n+    /// that is what it represents. Returns `None` otherwise.\n+    crate fn to_location(&self, i: PointIndex) -> Location {\n+        let point_index = i.index();\n+\n+        // Find the basic block. We have a vector with the\n+        // starting index of the statement in each block. Imagine\n+        // we have statement #22, and we have a vector like:\n+        //\n+        // [0, 10, 20]\n+        //\n+        // In that case, this represents point_index 2 of\n+        // basic block BB2. We know this because BB0 accounts for\n+        // 0..10, BB1 accounts for 11..20, and BB2 accounts for\n+        // 20...\n+        //\n+        // To compute this, we could do a binary search, but\n+        // because I am lazy we instead iterate through to find\n+        // the last point where the \"first index\" (0, 10, or 20)\n+        // was less than the statement index (22). In our case, this will\n+        // be (BB2, 20).\n+        //\n+        // Nit: we could do a binary search here but I'm too lazy.\n+        let (block, &first_index) = self\n+            .statements_before_block\n+            .iter_enumerated()\n+            .filter(|(_, first_index)| **first_index <= point_index)\n+            .last()\n+            .unwrap();\n+\n+        Location {\n+            block,\n+            statement_index: point_index - first_index,\n         }\n     }\n }\n \n-/// A newtype for the integers that represent one of the possible\n-/// elements in a region. These are the rows in the `SparseBitMatrix` that\n-/// is used to store the values of all regions. They have the following\n-/// convention:\n-///\n-/// - The first N indices represent free regions (where N = universal_regions.len()).\n-/// - The remainder represent the points in the CFG (see `point_indices` map).\n-///\n-/// You can convert a `RegionElementIndex` into a `RegionElement`\n-/// using the `to_region_elem` method.\n-newtype_index!(RegionElementIndex { DEBUG_FORMAT = \"RegionElementIndex({})\" });\n+/// A single integer representing a `Location` in the MIR control-flow\n+/// graph. Constructed efficiently from `RegionValueElements`.\n+newtype_index!(PointIndex { DEBUG_FORMAT = \"PointIndex({})\" });\n \n /// An individual element in a region value -- the value of a\n /// particular region variable consists of a set of these elements.\n@@ -142,36 +118,9 @@ crate enum RegionElement {\n     /// A point in the control-flow graph.\n     Location(Location),\n \n-    /// An in-scope, universally quantified region (e.g., a lifetime parameter).\n-    UniversalRegion(RegionVid),\n-}\n-\n-crate trait ToElementIndex: Debug + Copy {\n-    fn to_element_index(self, elements: &RegionValueElements) -> RegionElementIndex;\n-}\n-\n-impl ToElementIndex for Location {\n-    fn to_element_index(self, elements: &RegionValueElements) -> RegionElementIndex {\n-        let Location {\n-            block,\n-            statement_index,\n-        } = self;\n-        let start_index = elements.statements_before_block[block];\n-        RegionElementIndex::new(elements.num_universal_regions + start_index + statement_index)\n-    }\n-}\n-\n-impl ToElementIndex for RegionVid {\n-    fn to_element_index(self, elements: &RegionValueElements) -> RegionElementIndex {\n-        assert!(self.index() < elements.num_universal_regions);\n-        RegionElementIndex::new(self.index())\n-    }\n-}\n-\n-impl ToElementIndex for RegionElementIndex {\n-    fn to_element_index(self, _elements: &RegionValueElements) -> RegionElementIndex {\n-        self\n-    }\n+    /// A universally quantified region from the root universe (e.g.,\n+    /// a lifetime parameter).\n+    RootUniversalRegion(RegionVid),\n }\n \n /// Stores the values for a set of regions. These are stored in a\n@@ -181,7 +130,8 @@ impl ToElementIndex for RegionElementIndex {\n #[derive(Clone)]\n crate struct RegionValues<N: Idx> {\n     elements: Rc<RegionValueElements>,\n-    matrix: SparseBitMatrix<N, RegionElementIndex>,\n+    points: SparseBitMatrix<N, PointIndex>,\n+    free_regions: SparseBitMatrix<N, RegionVid>,\n }\n \n impl<N: Idx> RegionValues<N> {\n@@ -191,7 +141,8 @@ impl<N: Idx> RegionValues<N> {\n     crate fn new(elements: &Rc<RegionValueElements>) -> Self {\n         Self {\n             elements: elements.clone(),\n-            matrix: SparseBitMatrix::new(elements.num_elements()),\n+            points: SparseBitMatrix::new(elements.num_points),\n+            free_regions: SparseBitMatrix::new(elements.num_universal_regions),\n         }\n     }\n \n@@ -202,73 +153,110 @@ impl<N: Idx> RegionValues<N> {\n         r: N,\n         elem: impl ToElementIndex,\n     ) -> bool {\n-        let i = self.elements.index(elem);\n         debug!(\"add(r={:?}, elem={:?})\", r, elem);\n-        self.matrix.add(r, i)\n+        elem.add_to_row(self, r)\n+    }\n+\n+    /// Adds all the control-flow points to the values for `r`.\n+    crate fn add_all_points(&mut self, r: N) {\n+        // FIXME OMG so inefficient. We'll fix later.\n+        for p in self.elements.all_points() {\n+            self.points.add(r, p);\n+        }\n     }\n \n     /// Add all elements in `r_from` to `r_to` (because e.g. `r_to:\n     /// r_from`).\n     crate fn add_region(&mut self, r_to: N, r_from: N) -> bool {\n-        self.matrix.merge(r_from, r_to)\n+        self.points.merge(r_from, r_to) | self.free_regions.merge(r_from, r_to)\n+        // FIXME universes?\n     }\n \n     /// True if the region `r` contains the given element.\n-    crate fn contains(&self, r: N, elem: impl ToElementIndex) -> bool {\n-        let i = self.elements.index(elem);\n-        self.matrix.contains(r, i)\n+    crate fn contains(\n+        &self,\n+        r: N,\n+        elem: impl ToElementIndex,\n+    ) -> bool {\n+        elem.contained_in_row(self, r)\n     }\n \n-    /// Iterates through each row and the accompanying bit set.\n-    pub fn iter_enumerated<'a>(\n-        &'a self\n-    ) -> impl Iterator<Item = (N, &'a BitVector<RegionElementIndex>)> + 'a {\n-        self.matrix.iter_enumerated()\n+    /// Iterate through each region that has a value in this set.\n+    crate fn regions_with_points<'a>(&'a self) -> impl Iterator<Item = N> {\n+        self.points.rows()\n     }\n \n-    /// Merge a row, `from`, originating in another `RegionValues` into the `into` row.\n-    pub fn merge_into(&mut self, into: N, from: &BitVector<RegionElementIndex>) -> bool {\n-        self.matrix.merge_into(into, from)\n+    /// `self[to] |= values[from]`, essentially: that is, take all the\n+    /// elements for the region `from` from `values` and add them to\n+    /// the region `to` in `self`.\n+    crate fn merge_row<M: Idx>(&mut self, to: N, from: M, values: &RegionValues<M>) {\n+        if let Some(set) = values.points.row(from) {\n+            self.points.merge_into(to, set);\n+        }\n+\n+        if let Some(set) = values.free_regions.row(from) {\n+            self.free_regions.merge_into(to, set);\n+        }\n     }\n \n     /// True if `sup_region` contains all the CFG points that\n     /// `sub_region` contains. Ignores universal regions.\n-    crate fn contains_points(&self, sup_region: N, sub_region: N) -> bool {\n+    crate fn contains_points(\n+        &self,\n+        sup_region: N,\n+        sub_region: N,\n+    ) -> bool {\n         // This could be done faster by comparing the bitsets. But I\n         // am lazy.\n-        self.element_indices_contained_in(sub_region)\n-            .skip_while(|&i| self.elements.to_universal_region(i).is_some())\n-            .all(|e| self.contains(sup_region, e))\n+        if let Some(sub_row) = self.points.row(sub_region) {\n+            if let Some(sup_row) = self.points.row(sup_region) {\n+                sup_row.contains_all(sub_row)\n+            } else {\n+                // sup row is empty, so sub row must be empty\n+                sub_row.is_empty()\n+            }\n+        } else {\n+            // sub row is empty, always true\n+            true\n+        }\n     }\n \n-    /// Iterate over the value of the region `r`, yielding up element\n-    /// indices. You may prefer `universal_regions_outlived_by` or\n-    /// `elements_contained_in`.\n-    crate fn element_indices_contained_in<'a>(\n+    /// Returns the locations contained within a given region `r`.\n+    crate fn locations_outlived_by<'a>(\n         &'a self,\n         r: N,\n-    ) -> impl Iterator<Item = RegionElementIndex> + 'a {\n-        self.matrix.iter(r).map(move |i| i)\n+    ) -> impl Iterator<Item = Location> + 'a {\n+        self.points\n+            .row(r)\n+            .into_iter()\n+            .flat_map(move |set| set.iter().map(move |p| self.elements.to_location(p)))\n     }\n \n     /// Returns just the universal regions that are contained in a given region's value.\n     crate fn universal_regions_outlived_by<'a>(\n         &'a self,\n         r: N,\n     ) -> impl Iterator<Item = RegionVid> + 'a {\n-        self.element_indices_contained_in(r)\n-            .map(move |i| self.elements.to_universal_region(i))\n-            .take_while(move |v| v.is_some()) // universal regions are a prefix\n-            .map(move |v| v.unwrap())\n+        self.free_regions\n+            .row(r)\n+            .into_iter()\n+            .flat_map(|set| set.iter())\n     }\n \n     /// Returns all the elements contained in a given region's value.\n     crate fn elements_contained_in<'a>(\n         &'a self,\n         r: N,\n     ) -> impl Iterator<Item = RegionElement> + 'a {\n-        self.element_indices_contained_in(r)\n-            .map(move |r| self.elements.to_element(r))\n+        let points_iter = self\n+            .locations_outlived_by(r)\n+            .map(RegionElement::Location);\n+\n+        let free_regions_iter = self\n+            .universal_regions_outlived_by(r)\n+            .map(RegionElement::RootUniversalRegion);\n+\n+        points_iter.chain(free_regions_iter)\n     }\n \n     /// Returns a \"pretty\" string value of the region. Meant for debugging.\n@@ -306,7 +294,7 @@ impl<N: Idx> RegionValues<N> {\n                     open_location = Some((l, l));\n                 }\n \n-                RegionElement::UniversalRegion(fr) => {\n+                RegionElement::RootUniversalRegion(fr) => {\n                     if let Some((location1, location2)) = open_location {\n                         push_sep(&mut result);\n                         Self::push_location_range(&mut result, location1, location2);\n@@ -341,3 +329,55 @@ impl<N: Idx> RegionValues<N> {\n         }\n     }\n }\n+\n+crate trait ToElementIndex: Debug + Copy {\n+    fn add_to_row<N: Idx>(\n+        self,\n+        values: &mut RegionValues<N>,\n+        row: N,\n+    ) -> bool;\n+\n+    fn contained_in_row<N: Idx>(\n+        self,\n+        values: &RegionValues<N>,\n+        row: N,\n+    ) -> bool;\n+}\n+\n+impl ToElementIndex for Location {\n+    fn add_to_row<N: Idx>(\n+        self,\n+        values: &mut RegionValues<N>,\n+        row: N,\n+    ) -> bool {\n+        let index = values.elements.point_from_location(self);\n+        values.points.add(row, index)\n+    }\n+\n+    fn contained_in_row<N: Idx>(\n+        self,\n+        values: &RegionValues<N>,\n+        row: N,\n+    ) -> bool {\n+        let index = values.elements.point_from_location(self);\n+        values.points.contains(row, index)\n+    }\n+}\n+\n+impl ToElementIndex for RegionVid {\n+    fn add_to_row<N: Idx>(\n+        self,\n+        values: &mut RegionValues<N>,\n+        row: N,\n+    ) -> bool {\n+        values.free_regions.add(row, self)\n+    }\n+\n+    fn contained_in_row<N: Idx>(\n+        self,\n+        values: &RegionValues<N>,\n+        row: N,\n+    ) -> bool {\n+        values.free_regions.contains(row, self)\n+    }\n+}"}, {"sha": "382248c2d15dca3479c31234fabc94029dd15922", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f0fb4f7d849a12bce2996c03214601255bfe82e/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f0fb4f7d849a12bce2996c03214601255bfe82e/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=3f0fb4f7d849a12bce2996c03214601255bfe82e", "patch": "@@ -27,6 +27,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(core_intrinsics)]\n #![feature(decl_macro)]\n #![feature(fs_read_write)]\n+#![feature(in_band_lifetimes)]\n #![feature(macro_vis_matcher)]\n #![feature(exhaustive_patterns)]\n #![feature(range_contains)]"}]}