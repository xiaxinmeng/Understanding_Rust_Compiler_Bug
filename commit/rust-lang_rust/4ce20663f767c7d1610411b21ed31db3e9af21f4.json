{"sha": "4ce20663f767c7d1610411b21ed31db3e9af21f4", "node_id": "C_kwDOAAsO6NoAKDRjZTIwNjYzZjc2N2M3ZDE2MTA0MTFiMjFlZDMxZGIzZTlhZjIxZjQ", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-07-03T14:46:41Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2023-05-11T14:23:31Z"}, "message": "Don't use an allocator shim for `#[global_allocator]`\n\nThis makes it possible to use liballoc/libstd in combination with\n`--emit obj` if you use `#[global_allocator]`. Making it work for the\ndefault libstd allocator would require weak functions, which are not\nwell supported on all systems.", "tree": {"sha": "b47cbfe93da3d7ffb5eeae7a49e0ac8d764a45e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b47cbfe93da3d7ffb5eeae7a49e0ac8d764a45e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ce20663f767c7d1610411b21ed31db3e9af21f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ce20663f767c7d1610411b21ed31db3e9af21f4", "html_url": "https://github.com/rust-lang/rust/commit/4ce20663f767c7d1610411b21ed31db3e9af21f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ce20663f767c7d1610411b21ed31db3e9af21f4/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79fa6ce7a140efb47c67567f80e59a4f19b452a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/79fa6ce7a140efb47c67567f80e59a4f19b452a6", "html_url": "https://github.com/rust-lang/rust/commit/79fa6ce7a140efb47c67567f80e59a4f19b452a6"}], "stats": {"total": 337, "additions": 177, "deletions": 160}, "files": [{"sha": "c7ca66bc841b6696d3f8816086740e4193516333", "filename": "compiler/rustc_ast/src/expand/allocator.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4ce20663f767c7d1610411b21ed31db3e9af21f4/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce20663f767c7d1610411b21ed31db3e9af21f4/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fallocator.rs?ref=4ce20663f767c7d1610411b21ed31db3e9af21f4", "patch": "@@ -1,6 +1,6 @@\n use rustc_span::symbol::{sym, Symbol};\n \n-#[derive(Clone, Debug, Copy, HashStable_Generic)]\n+#[derive(Clone, Debug, Copy, Eq, PartialEq, HashStable_Generic)]\n pub enum AllocatorKind {\n     Global,\n     Default,\n@@ -9,12 +9,19 @@ pub enum AllocatorKind {\n impl AllocatorKind {\n     pub fn fn_name(&self, base: Symbol) -> String {\n         match *self {\n-            AllocatorKind::Global => format!(\"__rg_{base}\"),\n+            AllocatorKind::Global => format!(\"__rust_{base}\"),\n             AllocatorKind::Default => format!(\"__rdl_{base}\"),\n         }\n     }\n }\n \n+pub fn alloc_error_handler_name(alloc_error_handler_kind: AllocatorKind) -> &'static str {\n+    match alloc_error_handler_kind {\n+        AllocatorKind::Global => \"__rg_oom\",\n+        AllocatorKind::Default => \"__rdl_oom\",\n+    }\n+}\n+\n pub enum AllocatorTy {\n     Layout,\n     Ptr,"}, {"sha": "ef69d3f7800cb4028ef9a8eab4b874d983cae3dd", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/4ce20663f767c7d1610411b21ed31db3e9af21f4/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce20663f767c7d1610411b21ed31db3e9af21f4/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=4ce20663f767c7d1610411b21ed31db3e9af21f4", "patch": "@@ -3,10 +3,11 @@\n \n use crate::prelude::*;\n \n-use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n+use rustc_ast::expand::allocator::{\n+    alloc_error_handler_name, AllocatorKind, AllocatorTy, ALLOCATOR_METHODS,\n+};\n use rustc_codegen_ssa::base::allocator_kind_for_codegen;\n use rustc_session::config::OomStrategy;\n-use rustc_span::symbol::sym;\n \n /// Returns whether an allocator shim was created\n pub(crate) fn codegen(\n@@ -34,41 +35,43 @@ fn codegen_inner(\n ) {\n     let usize_ty = module.target_config().pointer_type();\n \n-    for method in ALLOCATOR_METHODS {\n-        let mut arg_tys = Vec::with_capacity(method.inputs.len());\n-        for ty in method.inputs.iter() {\n-            match *ty {\n-                AllocatorTy::Layout => {\n-                    arg_tys.push(usize_ty); // size\n-                    arg_tys.push(usize_ty); // align\n-                }\n-                AllocatorTy::Ptr => arg_tys.push(usize_ty),\n-                AllocatorTy::Usize => arg_tys.push(usize_ty),\n+    if kind == AllocatorKind::Default {\n+        for method in ALLOCATOR_METHODS {\n+            let mut arg_tys = Vec::with_capacity(method.inputs.len());\n+            for ty in method.inputs.iter() {\n+                match *ty {\n+                    AllocatorTy::Layout => {\n+                        arg_tys.push(usize_ty); // size\n+                        arg_tys.push(usize_ty); // align\n+                    }\n+                    AllocatorTy::Ptr => arg_tys.push(usize_ty),\n+                    AllocatorTy::Usize => arg_tys.push(usize_ty),\n \n-                AllocatorTy::ResultPtr | AllocatorTy::Unit => panic!(\"invalid allocator arg\"),\n+                    AllocatorTy::ResultPtr | AllocatorTy::Unit => panic!(\"invalid allocator arg\"),\n+                }\n             }\n-        }\n-        let output = match method.output {\n-            AllocatorTy::ResultPtr => Some(usize_ty),\n-            AllocatorTy::Unit => None,\n+            let output = match method.output {\n+                AllocatorTy::ResultPtr => Some(usize_ty),\n+                AllocatorTy::Unit => None,\n \n-            AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n-                panic!(\"invalid allocator output\")\n-            }\n-        };\n+                AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n+                    panic!(\"invalid allocator output\")\n+                }\n+            };\n \n-        let sig = Signature {\n-            call_conv: module.target_config().default_call_conv,\n-            params: arg_tys.iter().cloned().map(AbiParam::new).collect(),\n-            returns: output.into_iter().map(AbiParam::new).collect(),\n-        };\n-        crate::common::create_wrapper_function(\n-            module,\n-            unwind_context,\n-            sig,\n-            &format!(\"__rust_{}\", method.name),\n-            &kind.fn_name(method.name),\n-        );\n+            let sig = Signature {\n+                call_conv: module.target_config().default_call_conv,\n+                params: arg_tys.iter().cloned().map(AbiParam::new).collect(),\n+                returns: output.into_iter().map(AbiParam::new).collect(),\n+            };\n+            crate::common::create_wrapper_function(\n+                module,\n+                unwind_context,\n+                sig,\n+                &format!(\"__rust_{}\", method.name),\n+                &AllocatorKind::Default.fn_name(method.name),\n+            );\n+        }\n     }\n \n     let sig = Signature {\n@@ -81,7 +84,7 @@ fn codegen_inner(\n         unwind_context,\n         sig,\n         \"__rust_alloc_error_handler\",\n-        &alloc_error_handler_kind.fn_name(sym::oom),\n+        &alloc_error_handler_name(alloc_error_handler_kind),\n     );\n \n     let data_id = module.declare_data(OomStrategy::SYMBOL, Linkage::Export, false, false).unwrap();"}, {"sha": "f4105b91e9848adde21aa12a87edec51ae63f0da", "filename": "compiler/rustc_codegen_gcc/src/allocator.rs", "status": "modified", "additions": 61, "deletions": 58, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/4ce20663f767c7d1610411b21ed31db3e9af21f4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce20663f767c7d1610411b21ed31db3e9af21f4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs?ref=4ce20663f767c7d1610411b21ed31db3e9af21f4", "patch": "@@ -1,11 +1,12 @@\n #[cfg(feature=\"master\")]\n use gccjit::FnAttribute;\n use gccjit::{FunctionType, GlobalKind, ToRValue};\n-use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n+use rustc_ast::expand::allocator::{\n+    alloc_error_handler_name, AllocatorKind, AllocatorTy, ALLOCATOR_METHODS,\n+};\n use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::OomStrategy;\n-use rustc_span::symbol::sym;\n \n use crate::GccContext;\n \n@@ -22,69 +23,71 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n     let i8p = i8.make_pointer();\n     let void = context.new_type::<()>();\n \n-    for method in ALLOCATOR_METHODS {\n-        let mut types = Vec::with_capacity(method.inputs.len());\n-        for ty in method.inputs.iter() {\n-            match *ty {\n-                AllocatorTy::Layout => {\n-                    types.push(usize);\n-                    types.push(usize);\n+    if kind == AllocatorKind::Default {\n+        for method in ALLOCATOR_METHODS {\n+            let mut types = Vec::with_capacity(method.inputs.len());\n+            for ty in method.inputs.iter() {\n+                match *ty {\n+                    AllocatorTy::Layout => {\n+                        types.push(usize);\n+                        types.push(usize);\n+                    }\n+                    AllocatorTy::Ptr => types.push(i8p),\n+                    AllocatorTy::Usize => types.push(usize),\n+\n+                    AllocatorTy::ResultPtr | AllocatorTy::Unit => panic!(\"invalid allocator arg\"),\n                 }\n-                AllocatorTy::Ptr => types.push(i8p),\n-                AllocatorTy::Usize => types.push(usize),\n-\n-                AllocatorTy::ResultPtr | AllocatorTy::Unit => panic!(\"invalid allocator arg\"),\n             }\n-        }\n-        let output = match method.output {\n-            AllocatorTy::ResultPtr => Some(i8p),\n-            AllocatorTy::Unit => None,\n+            let output = match method.output {\n+                AllocatorTy::ResultPtr => Some(i8p),\n+                AllocatorTy::Unit => None,\n \n-            AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n-                panic!(\"invalid allocator output\")\n-            }\n-        };\n-        let name = format!(\"__rust_{}\", method.name);\n+                AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n+                    panic!(\"invalid allocator output\")\n+                }\n+            };\n+            let name = format!(\"__rust_{}\", method.name);\n+\n+            let args: Vec<_> = types.iter().enumerate()\n+                .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n+                .collect();\n+            let func = context.new_function(None, FunctionType::Exported, output.unwrap_or(void), &args, name, false);\n \n-        let args: Vec<_> = types.iter().enumerate()\n-            .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n-            .collect();\n-        let func = context.new_function(None, FunctionType::Exported, output.unwrap_or(void), &args, name, false);\n+            if tcx.sess.target.options.default_hidden_visibility {\n+                #[cfg(feature=\"master\")]\n+                func.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n+            }\n+            if tcx.sess.must_emit_unwind_tables() {\n+                // TODO(antoyo): emit unwind tables.\n+            }\n \n-        if tcx.sess.target.options.default_hidden_visibility {\n+            let callee = AllocatorKind::Default.fn_name(method.name);\n+            let args: Vec<_> = types.iter().enumerate()\n+                .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n+                .collect();\n+            let callee = context.new_function(None, FunctionType::Extern, output.unwrap_or(void), &args, callee, false);\n             #[cfg(feature=\"master\")]\n-            func.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n-        }\n-        if tcx.sess.must_emit_unwind_tables() {\n-            // TODO(antoyo): emit unwind tables.\n-        }\n+            callee.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n+\n+            let block = func.new_block(\"entry\");\n+\n+            let args = args\n+                .iter()\n+                .enumerate()\n+                .map(|(i, _)| func.get_param(i as i32).to_rvalue())\n+                .collect::<Vec<_>>();\n+            let ret = context.new_call(None, callee, &args);\n+            //llvm::LLVMSetTailCall(ret, True);\n+            if output.is_some() {\n+                block.end_with_return(None, ret);\n+            }\n+            else {\n+                block.end_with_void_return(None);\n+            }\n \n-        let callee = kind.fn_name(method.name);\n-        let args: Vec<_> = types.iter().enumerate()\n-            .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n-            .collect();\n-        let callee = context.new_function(None, FunctionType::Extern, output.unwrap_or(void), &args, callee, false);\n-        #[cfg(feature=\"master\")]\n-        callee.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n-\n-        let block = func.new_block(\"entry\");\n-\n-        let args = args\n-            .iter()\n-            .enumerate()\n-            .map(|(i, _)| func.get_param(i as i32).to_rvalue())\n-            .collect::<Vec<_>>();\n-        let ret = context.new_call(None, callee, &args);\n-        //llvm::LLVMSetTailCall(ret, True);\n-        if output.is_some() {\n-            block.end_with_return(None, ret);\n-        }\n-        else {\n-            block.end_with_void_return(None);\n+            // TODO(@Commeownist): Check if we need to emit some extra debugging info in certain circumstances\n+            // as described in https://github.com/rust-lang/rust/commit/77a96ed5646f7c3ee8897693decc4626fe380643\n         }\n-\n-        // TODO(@Commeownist): Check if we need to emit some extra debugging info in certain circumstances\n-        // as described in https://github.com/rust-lang/rust/commit/77a96ed5646f7c3ee8897693decc4626fe380643\n     }\n \n     let types = [usize, usize];\n@@ -99,7 +102,7 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n         func.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n     }\n \n-    let callee = alloc_error_handler_kind.fn_name(sym::oom);\n+    let callee = alloc_error_handler_name(alloc_error_handler_kind);\n     let args: Vec<_> = types.iter().enumerate()\n         .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n         .collect();"}, {"sha": "acf44f3276d27ba4bb1c3195a3f4270b169701fa", "filename": "compiler/rustc_codegen_llvm/src/allocator.rs", "status": "modified", "additions": 70, "deletions": 66, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/4ce20663f767c7d1610411b21ed31db3e9af21f4/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce20663f767c7d1610411b21ed31db3e9af21f4/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs?ref=4ce20663f767c7d1610411b21ed31db3e9af21f4", "patch": "@@ -1,10 +1,11 @@\n use crate::attributes;\n use libc::c_uint;\n-use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n+use rustc_ast::expand::allocator::{\n+    alloc_error_handler_name, AllocatorKind, AllocatorTy, ALLOCATOR_METHODS,\n+};\n use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{DebugInfo, OomStrategy};\n-use rustc_span::symbol::sym;\n \n use crate::debuginfo;\n use crate::llvm::{self, False, True};\n@@ -29,75 +30,78 @@ pub(crate) unsafe fn codegen(\n     let i8p = llvm::LLVMPointerType(i8, 0);\n     let void = llvm::LLVMVoidTypeInContext(llcx);\n \n-    for method in ALLOCATOR_METHODS {\n-        let mut args = Vec::with_capacity(method.inputs.len());\n-        for ty in method.inputs.iter() {\n-            match *ty {\n-                AllocatorTy::Layout => {\n-                    args.push(usize); // size\n-                    args.push(usize); // align\n+    if kind == AllocatorKind::Default {\n+        for method in ALLOCATOR_METHODS {\n+            let mut args = Vec::with_capacity(method.inputs.len());\n+            for ty in method.inputs.iter() {\n+                match *ty {\n+                    AllocatorTy::Layout => {\n+                        args.push(usize); // size\n+                        args.push(usize); // align\n+                    }\n+                    AllocatorTy::Ptr => args.push(i8p),\n+                    AllocatorTy::Usize => args.push(usize),\n+\n+                    AllocatorTy::ResultPtr | AllocatorTy::Unit => panic!(\"invalid allocator arg\"),\n                 }\n-                AllocatorTy::Ptr => args.push(i8p),\n-                AllocatorTy::Usize => args.push(usize),\n-\n-                AllocatorTy::ResultPtr | AllocatorTy::Unit => panic!(\"invalid allocator arg\"),\n             }\n-        }\n-        let output = match method.output {\n-            AllocatorTy::ResultPtr => Some(i8p),\n-            AllocatorTy::Unit => None,\n+            let output = match method.output {\n+                AllocatorTy::ResultPtr => Some(i8p),\n+                AllocatorTy::Unit => None,\n \n-            AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n-                panic!(\"invalid allocator output\")\n+                AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n+                    panic!(\"invalid allocator output\")\n+                }\n+            };\n+            let ty = llvm::LLVMFunctionType(\n+                output.unwrap_or(void),\n+                args.as_ptr(),\n+                args.len() as c_uint,\n+                False,\n+            );\n+            let name = format!(\"__rust_{}\", method.name);\n+            let llfn =\n+                llvm::LLVMRustGetOrInsertFunction(llmod, name.as_ptr().cast(), name.len(), ty);\n+\n+            if tcx.sess.target.default_hidden_visibility {\n+                llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n+            }\n+            if tcx.sess.must_emit_unwind_tables() {\n+                let uwtable = attributes::uwtable_attr(llcx);\n+                attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &[uwtable]);\n             }\n-        };\n-        let ty = llvm::LLVMFunctionType(\n-            output.unwrap_or(void),\n-            args.as_ptr(),\n-            args.len() as c_uint,\n-            False,\n-        );\n-        let name = format!(\"__rust_{}\", method.name);\n-        let llfn = llvm::LLVMRustGetOrInsertFunction(llmod, name.as_ptr().cast(), name.len(), ty);\n-\n-        if tcx.sess.target.default_hidden_visibility {\n-            llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n-        }\n-        if tcx.sess.must_emit_unwind_tables() {\n-            let uwtable = attributes::uwtable_attr(llcx);\n-            attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &[uwtable]);\n-        }\n \n-        let callee = kind.fn_name(method.name);\n-        let callee =\n-            llvm::LLVMRustGetOrInsertFunction(llmod, callee.as_ptr().cast(), callee.len(), ty);\n-        llvm::LLVMRustSetVisibility(callee, llvm::Visibility::Hidden);\n-\n-        let llbb = llvm::LLVMAppendBasicBlockInContext(llcx, llfn, \"entry\\0\".as_ptr().cast());\n-\n-        let llbuilder = llvm::LLVMCreateBuilderInContext(llcx);\n-        llvm::LLVMPositionBuilderAtEnd(llbuilder, llbb);\n-        let args = args\n-            .iter()\n-            .enumerate()\n-            .map(|(i, _)| llvm::LLVMGetParam(llfn, i as c_uint))\n-            .collect::<Vec<_>>();\n-        let ret = llvm::LLVMRustBuildCall(\n-            llbuilder,\n-            ty,\n-            callee,\n-            args.as_ptr(),\n-            args.len() as c_uint,\n-            [].as_ptr(),\n-            0 as c_uint,\n-        );\n-        llvm::LLVMSetTailCall(ret, True);\n-        if output.is_some() {\n-            llvm::LLVMBuildRet(llbuilder, ret);\n-        } else {\n-            llvm::LLVMBuildRetVoid(llbuilder);\n+            let callee = AllocatorKind::Default.fn_name(method.name);\n+            let callee =\n+                llvm::LLVMRustGetOrInsertFunction(llmod, callee.as_ptr().cast(), callee.len(), ty);\n+            llvm::LLVMRustSetVisibility(callee, llvm::Visibility::Hidden);\n+\n+            let llbb = llvm::LLVMAppendBasicBlockInContext(llcx, llfn, \"entry\\0\".as_ptr().cast());\n+\n+            let llbuilder = llvm::LLVMCreateBuilderInContext(llcx);\n+            llvm::LLVMPositionBuilderAtEnd(llbuilder, llbb);\n+            let args = args\n+                .iter()\n+                .enumerate()\n+                .map(|(i, _)| llvm::LLVMGetParam(llfn, i as c_uint))\n+                .collect::<Vec<_>>();\n+            let ret = llvm::LLVMRustBuildCall(\n+                llbuilder,\n+                ty,\n+                callee,\n+                args.as_ptr(),\n+                args.len() as c_uint,\n+                [].as_ptr(),\n+                0 as c_uint,\n+            );\n+            llvm::LLVMSetTailCall(ret, True);\n+            if output.is_some() {\n+                llvm::LLVMBuildRet(llbuilder, ret);\n+            } else {\n+                llvm::LLVMBuildRetVoid(llbuilder);\n+            }\n+            llvm::LLVMDisposeBuilder(llbuilder);\n         }\n-        llvm::LLVMDisposeBuilder(llbuilder);\n     }\n \n     // rust alloc error handler\n@@ -118,7 +122,7 @@ pub(crate) unsafe fn codegen(\n         attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &[uwtable]);\n     }\n \n-    let callee = alloc_error_handler_kind.fn_name(sym::oom);\n+    let callee = alloc_error_handler_name(alloc_error_handler_kind);\n     let callee = llvm::LLVMRustGetOrInsertFunction(llmod, callee.as_ptr().cast(), callee.len(), ty);\n     // -> ! DIFlagNoReturn\n     attributes::apply_to_llfn(callee, llvm::AttributePlace::Function, &[no_return]);"}]}