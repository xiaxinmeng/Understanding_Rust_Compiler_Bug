{"sha": "86c28325ff813e5cf4d0cab320a7c9f6fb0766b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2YzI4MzI1ZmY4MTNlNWNmNGQwY2FiMzIwYTdjOWY2ZmIwNzY2Yjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-10T07:46:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-10T07:46:58Z"}, "message": "Auto merge of #66072 - Mark-Simulacrum:next-node-id, r=nikomatsakis\n\nMove next node ID to Resolver\n\nThis moves the `next_node_id` method(s) and related tracking information to the resolver. By doing so, we also remove the OneThread and Cell on next_node_id in Session in this move, which means that the new code is simpler and less \"interesting\" as it doesn't tie itself to a single thread.\n\nThis required moving some of the pretty-printing logic around, but this was just copying the code without any semantic changes, so it's just a second commit instead of a separate PR; I can polish it up a bit more if desired.", "tree": {"sha": "ff5aeb60cbe141f97643322de00f4349ef9adaef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff5aeb60cbe141f97643322de00f4349ef9adaef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8", "html_url": "https://github.com/rust-lang/rust/commit/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57a5f92bef4b459005920f1aeff05a52c7e356b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/57a5f92bef4b459005920f1aeff05a52c7e356b0", "html_url": "https://github.com/rust-lang/rust/commit/57a5f92bef4b459005920f1aeff05a52c7e356b0"}, {"sha": "43a74051c7b699e2df66122cfcf074aaf144a4fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/43a74051c7b699e2df66122cfcf074aaf144a4fe", "html_url": "https://github.com/rust-lang/rust/commit/43a74051c7b699e2df66122cfcf074aaf144a4fe"}], "stats": {"total": 700, "additions": 356, "deletions": 344}, "files": [{"sha": "8b157d2b3f4bc3ddb19cbb2fac3058a3ef3e5541", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=86c28325ff813e5cf4d0cab320a7c9f6fb0766b8", "patch": "@@ -3506,6 +3506,7 @@ dependencies = [\n  \"rustc_mir\",\n  \"rustc_plugin\",\n  \"rustc_plugin_impl\",\n+ \"rustc_resolve\",\n  \"rustc_save_analysis\",\n  \"rustc_target\",\n  \"serialize\","}, {"sha": "f2d5f043f909dcd60b6d731bf3636e30c005b7b9", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=86c28325ff813e5cf4d0cab320a7c9f6fb0766b8", "patch": "@@ -183,6 +183,8 @@ pub trait Resolver {\n     ) -> (ast::Path, Res<NodeId>);\n \n     fn lint_buffer(&mut self) -> &mut lint::LintBuffer;\n+\n+    fn next_node_id(&mut self) -> NodeId;\n }\n \n type NtToTokenstream = fn(&Nonterminal, &ParseSess, Span) -> TokenStream;\n@@ -672,7 +674,8 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn next_id(&mut self) -> hir::HirId {\n-        self.lower_node_id(self.sess.next_node_id())\n+        let node_id = self.resolver.next_node_id();\n+        self.lower_node_id(node_id)\n     }\n \n     fn lower_res(&mut self, res: Res<NodeId>) -> Res {\n@@ -781,7 +784,7 @@ impl<'a> LoweringContext<'a> {\n         hir_name: ParamName,\n         parent_index: DefIndex,\n     ) -> hir::GenericParam {\n-        let node_id = self.sess.next_node_id();\n+        let node_id = self.resolver.next_node_id();\n \n         // Get the name we'll use to make the def-path. Note\n         // that collisions are ok here and this shouldn't\n@@ -1106,7 +1109,7 @@ impl<'a> LoweringContext<'a> {\n                     // Desugar `AssocTy: Bounds` into `AssocTy = impl Bounds`. We do this by\n                     // constructing the HIR for `impl bounds...` and then lowering that.\n \n-                    let impl_trait_node_id = self.sess.next_node_id();\n+                    let impl_trait_node_id = self.resolver.next_node_id();\n                     let parent_def_index = self.current_hir_id_owner.last().unwrap().0;\n                     self.resolver.definitions().create_def_with_parent(\n                         parent_def_index,\n@@ -1117,9 +1120,10 @@ impl<'a> LoweringContext<'a> {\n                     );\n \n                     self.with_dyn_type_scope(false, |this| {\n+                        let node_id = this.resolver.next_node_id();\n                         let ty = this.lower_ty(\n                             &Ty {\n-                                id: this.sess.next_node_id(),\n+                                id: node_id,\n                                 kind: TyKind::ImplTrait(impl_trait_node_id, bounds.clone()),\n                                 span: constraint.span,\n                             },\n@@ -1586,7 +1590,7 @@ impl<'a> LoweringContext<'a> {\n                         name,\n                     }));\n \n-                    let def_node_id = self.context.sess.next_node_id();\n+                    let def_node_id = self.context.resolver.next_node_id();\n                     let hir_id =\n                         self.context.lower_node_id_with_owner(def_node_id, self.opaque_ty_id);\n                     self.context.resolver.definitions().create_def_with_parent(\n@@ -3234,7 +3238,7 @@ impl<'a> LoweringContext<'a> {\n             Some(id) => (id, \"`'_` cannot be used here\", \"`'_` is a reserved lifetime name\"),\n \n             None => (\n-                self.sess.next_node_id(),\n+                self.resolver.next_node_id(),\n                 \"`&` without an explicit lifetime name cannot be used here\",\n                 \"explicit lifetime name needed here\",\n             ),\n@@ -3271,7 +3275,7 @@ impl<'a> LoweringContext<'a> {\n                     span,\n                     \"expected 'implicit elided lifetime not allowed' error\",\n                 );\n-                let id = self.sess.next_node_id();\n+                let id = self.resolver.next_node_id();\n                 self.new_named_lifetime(id, span, hir::LifetimeName::Error)\n             }\n             // `PassThrough` is the normal case."}, {"sha": "42ce74aedef951517328f8994c3d0e8bc74ddd4f", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=86c28325ff813e5cf4d0cab320a7c9f6fb0766b8", "patch": "@@ -595,7 +595,7 @@ impl LoweringContext<'_> {\n         };\n \n         // `::std::task::Poll::Ready(result) => break result`\n-        let loop_node_id = self.sess.next_node_id();\n+        let loop_node_id = self.resolver.next_node_id();\n         let loop_hir_id = self.lower_node_id(loop_node_id);\n         let ready_arm = {\n             let x_ident = Ident::with_dummy_span(sym::result);"}, {"sha": "4e20f476d85cd70a6c831ce6d386b84a1c662022", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=86c28325ff813e5cf4d0cab320a7c9f6fb0766b8", "patch": "@@ -522,7 +522,7 @@ impl LoweringContext<'_> {\n                     let ident = *ident;\n                     let mut path = path.clone();\n                     for seg in &mut path.segments {\n-                        seg.id = self.sess.next_node_id();\n+                        seg.id = self.resolver.next_node_id();\n                     }\n                     let span = path.span;\n \n@@ -599,7 +599,7 @@ impl LoweringContext<'_> {\n \n                     // Give the segments new node-ids since they are being cloned.\n                     for seg in &mut prefix.segments {\n-                        seg.id = self.sess.next_node_id();\n+                        seg.id = self.resolver.next_node_id();\n                     }\n \n                     // Each `use` import is an item and thus are owners of the"}, {"sha": "4a14960aa69bd8f340083adeb07ee77e5b7a8af0", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=86c28325ff813e5cf4d0cab320a7c9f6fb0766b8", "patch": "@@ -1,10 +1,13 @@\n //! Contains infrastructure for configuring the compiler, including parsing\n //! command-line options.\n \n+// ignore-tidy-filelength\n+\n use crate::lint;\n use crate::middle::cstore;\n use crate::session::{early_error, early_warn, Session};\n use crate::session::search_paths::SearchPath;\n+use crate::hir::map as hir_map;\n \n use rustc_data_structures::fx::FxHashSet;\n \n@@ -440,6 +443,8 @@ top_level_options!(\n         // `true` if we're emitting JSON blobs about each artifact produced\n         // by the compiler.\n         json_artifact_notifications: bool [TRACKED],\n+\n+        pretty: Option<(PpMode, Option<UserIdentifiedItem>)> [UNTRACKED],\n     }\n );\n \n@@ -621,6 +626,7 @@ impl Default for Options {\n             remap_path_prefix: Vec::new(),\n             edition: DEFAULT_EDITION,\n             json_artifact_notifications: false,\n+            pretty: None,\n         }\n     }\n }\n@@ -2516,6 +2522,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let remap_path_prefix = parse_remap_path_prefix(matches, error_format);\n \n+    let pretty = parse_pretty(matches, &debugging_opts, error_format);\n+\n     Options {\n         crate_types,\n         optimize: opt_level,\n@@ -2546,6 +2554,73 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         remap_path_prefix,\n         edition,\n         json_artifact_notifications,\n+        pretty,\n+    }\n+}\n+\n+fn parse_pretty(\n+    matches: &getopts::Matches,\n+    debugging_opts: &DebuggingOptions,\n+    efmt: ErrorOutputType,\n+) -> Option<(PpMode, Option<UserIdentifiedItem>)> {\n+    let pretty = if debugging_opts.unstable_options {\n+        matches.opt_default(\"pretty\", \"normal\").map(|a| {\n+            // stable pretty-print variants only\n+            parse_pretty_inner(efmt, &a, false)\n+        })\n+    } else {\n+        None\n+    };\n+\n+    return if pretty.is_none() {\n+        debugging_opts.unpretty.as_ref().map(|a| {\n+            // extended with unstable pretty-print variants\n+            parse_pretty_inner(efmt, &a, true)\n+        })\n+    } else {\n+        pretty\n+    };\n+\n+    fn parse_pretty_inner(\n+        efmt: ErrorOutputType,\n+        name: &str,\n+        extended: bool,\n+    ) -> (PpMode, Option<UserIdentifiedItem>) {\n+        use PpMode::*;\n+        use PpSourceMode::*;\n+        let mut split = name.splitn(2, '=');\n+        let first = split.next().unwrap();\n+        let opt_second = split.next();\n+        let first = match (first, extended) {\n+            (\"normal\", _) => PpmSource(PpmNormal),\n+            (\"identified\", _) => PpmSource(PpmIdentified),\n+            (\"everybody_loops\", true) => PpmSource(PpmEveryBodyLoops),\n+            (\"expanded\", _) => PpmSource(PpmExpanded),\n+            (\"expanded,identified\", _) => PpmSource(PpmExpandedIdentified),\n+            (\"expanded,hygiene\", _) => PpmSource(PpmExpandedHygiene),\n+            (\"hir\", true) => PpmHir(PpmNormal),\n+            (\"hir,identified\", true) => PpmHir(PpmIdentified),\n+            (\"hir,typed\", true) => PpmHir(PpmTyped),\n+            (\"hir-tree\", true) => PpmHirTree(PpmNormal),\n+            (\"mir\", true) => PpmMir,\n+            (\"mir-cfg\", true) => PpmMirCFG,\n+            _ => {\n+                if extended {\n+                    early_error(efmt, &format!(\"argument to `unpretty` must be one of `normal`, \\\n+                                        `expanded`, `identified`, `expanded,identified`, \\\n+                                        `expanded,hygiene`, `everybody_loops`, \\\n+                                        `hir`, `hir,identified`, `hir,typed`, `hir-tree`, \\\n+                                        `mir` or `mir-cfg`; got {}\",\n+                                        name));\n+                } else {\n+                    early_error(efmt, &format!(\"argument to `pretty` must be one of `normal`, \\\n+                                        `expanded`, `identified`, or `expanded,identified`; got {}\",\n+                                        name));\n+                }\n+            }\n+        };\n+        let opt_second = opt_second.and_then(|s| s.parse::<UserIdentifiedItem>().ok());\n+        (first, opt_second)\n     }\n }\n \n@@ -2656,6 +2731,151 @@ impl fmt::Display for CrateType {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum PpSourceMode {\n+    PpmNormal,\n+    PpmEveryBodyLoops,\n+    PpmExpanded,\n+    PpmIdentified,\n+    PpmExpandedIdentified,\n+    PpmExpandedHygiene,\n+    PpmTyped,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum PpMode {\n+    PpmSource(PpSourceMode),\n+    PpmHir(PpSourceMode),\n+    PpmHirTree(PpSourceMode),\n+    PpmMir,\n+    PpmMirCFG,\n+}\n+\n+impl PpMode {\n+    pub fn needs_ast_map(&self, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n+        use PpMode::*;\n+        use PpSourceMode::*;\n+        match *self {\n+            PpmSource(PpmNormal) |\n+            PpmSource(PpmEveryBodyLoops) |\n+            PpmSource(PpmIdentified) => opt_uii.is_some(),\n+\n+            PpmSource(PpmExpanded) |\n+            PpmSource(PpmExpandedIdentified) |\n+            PpmSource(PpmExpandedHygiene) |\n+            PpmHir(_) |\n+            PpmHirTree(_) |\n+            PpmMir |\n+            PpmMirCFG => true,\n+            PpmSource(PpmTyped) => panic!(\"invalid state\"),\n+        }\n+    }\n+\n+    pub fn needs_analysis(&self) -> bool {\n+        use PpMode::*;\n+        match *self {\n+            PpmMir | PpmMirCFG => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum UserIdentifiedItem {\n+    ItemViaNode(ast::NodeId),\n+    ItemViaPath(Vec<String>),\n+}\n+\n+impl FromStr for UserIdentifiedItem {\n+    type Err = ();\n+    fn from_str(s: &str) -> Result<UserIdentifiedItem, ()> {\n+        use UserIdentifiedItem::*;\n+        Ok(s.parse()\n+            .map(ast::NodeId::from_u32)\n+            .map(ItemViaNode)\n+            .unwrap_or_else(|_| ItemViaPath(s.split(\"::\").map(|s| s.to_string()).collect())))\n+    }\n+}\n+\n+pub enum NodesMatchingUII<'a> {\n+    NodesMatchingDirect(std::option::IntoIter<ast::NodeId>),\n+    NodesMatchingSuffix(Box<dyn Iterator<Item = ast::NodeId> + 'a>),\n+}\n+\n+impl<'a> Iterator for NodesMatchingUII<'a> {\n+    type Item = ast::NodeId;\n+\n+    fn next(&mut self) -> Option<ast::NodeId> {\n+        use NodesMatchingUII::*;\n+        match self {\n+            &mut NodesMatchingDirect(ref mut iter) => iter.next(),\n+            &mut NodesMatchingSuffix(ref mut iter) => iter.next(),\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        use NodesMatchingUII::*;\n+        match self {\n+            &NodesMatchingDirect(ref iter) => iter.size_hint(),\n+            &NodesMatchingSuffix(ref iter) => iter.size_hint(),\n+        }\n+    }\n+}\n+\n+impl UserIdentifiedItem {\n+    pub fn reconstructed_input(&self) -> String {\n+        use UserIdentifiedItem::*;\n+        match *self {\n+            ItemViaNode(node_id) => node_id.to_string(),\n+            ItemViaPath(ref parts) => parts.join(\"::\"),\n+        }\n+    }\n+\n+    pub fn all_matching_node_ids<'a, 'hir>(&'a self,\n+                                       map: &'a hir_map::Map<'hir>)\n+                                       -> NodesMatchingUII<'a> {\n+        use UserIdentifiedItem::*;\n+        use NodesMatchingUII::*;\n+        match *self {\n+            ItemViaNode(node_id) => NodesMatchingDirect(Some(node_id).into_iter()),\n+            ItemViaPath(ref parts) => {\n+                NodesMatchingSuffix(Box::new(map.nodes_matching_suffix(&parts)))\n+            }\n+        }\n+    }\n+\n+    pub fn to_one_node_id(self,\n+                      user_option: &str,\n+                      sess: &Session,\n+                      map: &hir_map::Map<'_>)\n+                      -> ast::NodeId {\n+        let fail_because = |is_wrong_because| -> ast::NodeId {\n+            let message = format!(\"{} needs NodeId (int) or unique path suffix (b::c::d); got \\\n+                                   {}, which {}\",\n+                                  user_option,\n+                                  self.reconstructed_input(),\n+                                  is_wrong_because);\n+            sess.fatal(&message)\n+        };\n+\n+        let mut saw_node = ast::DUMMY_NODE_ID;\n+        let mut seen = 0;\n+        for node in self.all_matching_node_ids(map) {\n+            saw_node = node;\n+            seen += 1;\n+            if seen > 1 {\n+                fail_because(\"does not resolve uniquely\");\n+            }\n+        }\n+        if seen == 0 {\n+            fail_because(\"does not resolve to any item\");\n+        }\n+\n+        assert!(seen == 1);\n+        return saw_node;\n+    }\n+}\n+\n /// Command-line arguments passed to the compiler have to be incorporated with\n /// the dependency tracking system for incremental compilation. This module\n /// provides some utilities to make this more convenient."}, {"sha": "bab7ab89ce751b29c0bd04a50de7625168c2e697", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=86c28325ff813e5cf4d0cab320a7c9f6fb0766b8", "patch": "@@ -21,7 +21,6 @@ use errors::{DiagnosticBuilder, DiagnosticId, Applicability};\n use errors::emitter::{Emitter, EmitterWriter};\n use errors::emitter::HumanReadableErrorType;\n use errors::annotate_snippet_emitter_writer::{AnnotateSnippetEmitterWriter};\n-use syntax::ast::{self, NodeId};\n use syntax::edition::Edition;\n use syntax::expand::allocator::AllocatorKind;\n use syntax::feature_gate::{self, AttributeType};\n@@ -38,7 +37,7 @@ use rustc_data_structures::jobserver;\n use ::jobserver::Client;\n \n use std;\n-use std::cell::{self, Cell, RefCell};\n+use std::cell::{self, RefCell};\n use std::env;\n use std::fmt;\n use std::io::Write;\n@@ -127,8 +126,6 @@ pub struct Session {\n     /// Data about code being compiled, gathered during compilation.\n     pub code_stats: Lock<CodeStats>,\n \n-    next_node_id: OneThread<Cell<ast::NodeId>>,\n-\n     /// If `-zfuel=crate=n` is specified, `Some(crate)`.\n     optimization_fuel_crate: Option<String>,\n \n@@ -355,21 +352,6 @@ impl Session {\n         self.diagnostic().span_note_without_error(sp, msg)\n     }\n \n-    pub fn reserve_node_ids(&self, count: usize) -> ast::NodeId {\n-        let id = self.next_node_id.get();\n-\n-        match id.as_usize().checked_add(count) {\n-            Some(next) => {\n-                self.next_node_id.set(ast::NodeId::from_usize(next));\n-            }\n-            None => bug!(\"input too large; ran out of node-IDs!\"),\n-        }\n-\n-        id\n-    }\n-    pub fn next_node_id(&self) -> NodeId {\n-        self.reserve_node_ids(1)\n-    }\n     pub fn diagnostic(&self) -> &errors::Handler {\n         &self.parse_sess.span_diagnostic\n     }\n@@ -1187,7 +1169,6 @@ fn build_session_(\n         recursion_limit: Once::new(),\n         type_length_limit: Once::new(),\n         const_eval_stack_frame_limit: 100,\n-        next_node_id: OneThread::new(Cell::new(NodeId::from_u32(1))),\n         allocator_kind: Once::new(),\n         injected_panic_runtime: Once::new(),\n         imported_macro_spans: OneThread::new(RefCell::new(FxHashMap::default())),"}, {"sha": "0a803187d49a8d8f27c21d5ab996460f81c04fe7", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=86c28325ff813e5cf4d0cab320a7c9f6fb0766b8", "patch": "@@ -27,5 +27,6 @@ rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_interface = { path = \"../librustc_interface\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_resolve = { path = \"../librustc_resolve\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "7973a804f1a460a372b3bbde3ff429c189b8b8a6", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 32, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=86c28325ff813e5cf4d0cab320a7c9f6fb0766b8", "patch": "@@ -25,8 +25,6 @@ extern crate lazy_static;\n \n pub extern crate rustc_plugin_impl as plugin;\n \n-use pretty::{PpMode, UserIdentifiedItem};\n-\n //use rustc_resolve as resolve;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n@@ -285,33 +283,29 @@ pub fn run_compiler(\n             return sess.compile_status();\n         }\n \n-        let pretty_info = parse_pretty(sess, &matches);\n-\n         compiler.parse()?;\n \n-        if let Some((ppm, opt_uii)) = pretty_info {\n+        if let Some((ppm, opt_uii)) = &sess.opts.pretty {\n             if ppm.needs_ast_map(&opt_uii) {\n-                pretty::visit_crate(sess, &mut compiler.parse()?.peek_mut(), ppm);\n                 compiler.global_ctxt()?.peek_mut().enter(|tcx| {\n                     let expanded_crate = compiler.expansion()?.take().0;\n                     pretty::print_after_hir_lowering(\n                         tcx,\n                         compiler.input(),\n                         &expanded_crate,\n-                        ppm,\n+                        *ppm,\n                         opt_uii.clone(),\n                         compiler.output_file().as_ref().map(|p| &**p),\n                     );\n                     Ok(())\n                 })?;\n             } else {\n-                let mut krate = compiler.parse()?.take();\n-                pretty::visit_crate(sess, &mut krate, ppm);\n+                let krate = compiler.parse()?.take();\n                 pretty::print_after_parsing(\n                     sess,\n                     &compiler.input(),\n                     &krate,\n-                    ppm,\n+                    *ppm,\n                     compiler.output_file().as_ref().map(|p| &**p),\n                 );\n             }\n@@ -470,28 +464,6 @@ fn make_input(free_matches: &[String]) -> Option<(Input, Option<PathBuf>, Option\n     }\n }\n \n-fn parse_pretty(sess: &Session,\n-                matches: &getopts::Matches)\n-                -> Option<(PpMode, Option<UserIdentifiedItem>)> {\n-    let pretty = if sess.opts.debugging_opts.unstable_options {\n-        matches.opt_default(\"pretty\", \"normal\").map(|a| {\n-            // stable pretty-print variants only\n-            pretty::parse_pretty(sess, &a, false)\n-        })\n-    } else {\n-        None\n-    };\n-\n-    if pretty.is_none() {\n-        sess.opts.debugging_opts.unpretty.as_ref().map(|a| {\n-            // extended with unstable pretty-print variants\n-            pretty::parse_pretty(sess, &a, true)\n-        })\n-    } else {\n-        pretty\n-    }\n-}\n-\n // Whether to stop or continue compilation.\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum Compilation {"}, {"sha": "23253dc4dadec9733fa37f5fe2768ea9cfd40f43", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 70, "deletions": 258, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=86c28325ff813e5cf4d0cab320a7c9f6fb0766b8", "patch": "@@ -5,117 +5,27 @@ use rustc::hir::map as hir_map;\n use rustc::hir::print as pprust_hir;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::session::Session;\n-use rustc::session::config::Input;\n+use rustc::session::config::{PpMode, PpSourceMode, UserIdentifiedItem, Input};\n use rustc::ty::{self, TyCtxt};\n use rustc::util::common::ErrorReported;\n-use rustc_interface::util::ReplaceBodyWithLoop;\n use rustc_mir::util::{write_mir_pretty, write_mir_graphviz};\n \n use syntax::ast;\n-use syntax::mut_visit::MutVisitor;\n use syntax::print::{pprust};\n use syntax_pos::FileName;\n \n use std::cell::Cell;\n use std::fs::File;\n use std::io::Write;\n-use std::option;\n use std::path::Path;\n-use std::str::FromStr;\n \n pub use self::UserIdentifiedItem::*;\n pub use self::PpSourceMode::*;\n pub use self::PpMode::*;\n-use self::NodesMatchingUII::*;\n use crate::abort_on_err;\n \n use crate::source_name;\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum PpSourceMode {\n-    PpmNormal,\n-    PpmEveryBodyLoops,\n-    PpmExpanded,\n-    PpmIdentified,\n-    PpmExpandedIdentified,\n-    PpmExpandedHygiene,\n-    PpmTyped,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum PpMode {\n-    PpmSource(PpSourceMode),\n-    PpmHir(PpSourceMode),\n-    PpmHirTree(PpSourceMode),\n-    PpmMir,\n-    PpmMirCFG,\n-}\n-\n-impl PpMode {\n-    pub fn needs_ast_map(&self, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n-        match *self {\n-            PpmSource(PpmNormal) |\n-            PpmSource(PpmEveryBodyLoops) |\n-            PpmSource(PpmIdentified) => opt_uii.is_some(),\n-\n-            PpmSource(PpmExpanded) |\n-            PpmSource(PpmExpandedIdentified) |\n-            PpmSource(PpmExpandedHygiene) |\n-            PpmHir(_) |\n-            PpmHirTree(_) |\n-            PpmMir |\n-            PpmMirCFG => true,\n-            PpmSource(PpmTyped) => panic!(\"invalid state\"),\n-        }\n-    }\n-\n-    pub fn needs_analysis(&self) -> bool {\n-        match *self {\n-            PpmMir | PpmMirCFG => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n-pub fn parse_pretty(sess: &Session,\n-                    name: &str,\n-                    extended: bool)\n-                    -> (PpMode, Option<UserIdentifiedItem>) {\n-    let mut split = name.splitn(2, '=');\n-    let first = split.next().unwrap();\n-    let opt_second = split.next();\n-    let first = match (first, extended) {\n-        (\"normal\", _) => PpmSource(PpmNormal),\n-        (\"identified\", _) => PpmSource(PpmIdentified),\n-        (\"everybody_loops\", true) => PpmSource(PpmEveryBodyLoops),\n-        (\"expanded\", _) => PpmSource(PpmExpanded),\n-        (\"expanded,identified\", _) => PpmSource(PpmExpandedIdentified),\n-        (\"expanded,hygiene\", _) => PpmSource(PpmExpandedHygiene),\n-        (\"hir\", true) => PpmHir(PpmNormal),\n-        (\"hir,identified\", true) => PpmHir(PpmIdentified),\n-        (\"hir,typed\", true) => PpmHir(PpmTyped),\n-        (\"hir-tree\", true) => PpmHirTree(PpmNormal),\n-        (\"mir\", true) => PpmMir,\n-        (\"mir-cfg\", true) => PpmMirCFG,\n-        _ => {\n-            if extended {\n-                sess.fatal(&format!(\"argument to `unpretty` must be one of `normal`, \\\n-                                     `expanded`, `identified`, `expanded,identified`, \\\n-                                     `expanded,hygiene`, `everybody_loops`, \\\n-                                     `hir`, `hir,identified`, `hir,typed`, `hir-tree`, \\\n-                                     `mir` or `mir-cfg`; got {}\",\n-                                    name));\n-            } else {\n-                sess.fatal(&format!(\"argument to `pretty` must be one of `normal`, `expanded`, \\\n-                                     `identified`, or `expanded,identified`; got {}\",\n-                                    name));\n-            }\n-        }\n-    };\n-    let opt_second = opt_second.and_then(|s| s.parse::<UserIdentifiedItem>().ok());\n-    (first, opt_second)\n-}\n-\n \n \n // This slightly awkward construction is to allow for each PpMode to\n@@ -131,76 +41,74 @@ pub fn parse_pretty(sess: &Session,\n // (The `use_once_payload` is working around the current lack of once\n // functions in the compiler.)\n \n-impl PpSourceMode {\n-    /// Constructs a `PrinterSupport` object and passes it to `f`.\n-    fn call_with_pp_support<'tcx, A, F>(\n-        &self,\n-        sess: &'tcx Session,\n-        tcx: Option<TyCtxt<'tcx>>,\n-        f: F,\n-    ) -> A\n-    where\n-        F: FnOnce(&dyn PrinterSupport) -> A,\n-    {\n-        match *self {\n-            PpmNormal | PpmEveryBodyLoops | PpmExpanded => {\n-                let annotation = NoAnn {\n-                    sess,\n-                    tcx,\n-                };\n-                f(&annotation)\n-            }\n+/// Constructs a `PrinterSupport` object and passes it to `f`.\n+fn call_with_pp_support<'tcx, A, F>(\n+    ppmode: &PpSourceMode,\n+    sess: &'tcx Session,\n+    tcx: Option<TyCtxt<'tcx>>,\n+    f: F,\n+) -> A\n+where\n+    F: FnOnce(&dyn PrinterSupport) -> A,\n+{\n+    match *ppmode {\n+        PpmNormal | PpmEveryBodyLoops | PpmExpanded => {\n+            let annotation = NoAnn {\n+                sess,\n+                tcx,\n+            };\n+            f(&annotation)\n+        }\n \n-            PpmIdentified | PpmExpandedIdentified => {\n-                let annotation = IdentifiedAnnotation {\n-                    sess,\n-                    tcx,\n-                };\n-                f(&annotation)\n-            }\n-            PpmExpandedHygiene => {\n-                let annotation = HygieneAnnotation {\n-                    sess,\n-                };\n-                f(&annotation)\n-            }\n-            _ => panic!(\"Should use call_with_pp_support_hir\"),\n+        PpmIdentified | PpmExpandedIdentified => {\n+            let annotation = IdentifiedAnnotation {\n+                sess,\n+                tcx,\n+            };\n+            f(&annotation)\n+        }\n+        PpmExpandedHygiene => {\n+            let annotation = HygieneAnnotation {\n+                sess,\n+            };\n+            f(&annotation)\n+        }\n+        _ => panic!(\"Should use call_with_pp_support_hir\"),\n+    }\n+}\n+fn call_with_pp_support_hir<A, F>(ppmode: &PpSourceMode, tcx: TyCtxt<'_>, f: F) -> A\n+where\n+    F: FnOnce(&dyn HirPrinterSupport<'_>, &hir::Crate) -> A,\n+{\n+    match *ppmode {\n+        PpmNormal => {\n+            let annotation = NoAnn {\n+                sess: tcx.sess,\n+                tcx: Some(tcx),\n+            };\n+            f(&annotation, tcx.hir().forest.krate())\n         }\n-    }\n-    fn call_with_pp_support_hir<A, F>(&self, tcx: TyCtxt<'_>, f: F) -> A\n-    where\n-        F: FnOnce(&dyn HirPrinterSupport<'_>, &hir::Crate) -> A,\n-    {\n-        match *self {\n-            PpmNormal => {\n-                let annotation = NoAnn {\n-                    sess: tcx.sess,\n-                    tcx: Some(tcx),\n-                };\n-                f(&annotation, tcx.hir().forest.krate())\n-            }\n \n-            PpmIdentified => {\n-                let annotation = IdentifiedAnnotation {\n-                    sess: tcx.sess,\n-                    tcx: Some(tcx),\n-                };\n+        PpmIdentified => {\n+            let annotation = IdentifiedAnnotation {\n+                sess: tcx.sess,\n+                tcx: Some(tcx),\n+            };\n+            f(&annotation, tcx.hir().forest.krate())\n+        }\n+        PpmTyped => {\n+            abort_on_err(tcx.analysis(LOCAL_CRATE), tcx.sess);\n+\n+            let empty_tables = ty::TypeckTables::empty(None);\n+            let annotation = TypedAnnotation {\n+                tcx,\n+                tables: Cell::new(&empty_tables)\n+            };\n+            tcx.dep_graph.with_ignore(|| {\n                 f(&annotation, tcx.hir().forest.krate())\n-            }\n-            PpmTyped => {\n-                abort_on_err(tcx.analysis(LOCAL_CRATE), tcx.sess);\n-\n-                let empty_tables = ty::TypeckTables::empty(None);\n-                let annotation = TypedAnnotation {\n-                    tcx,\n-                    tables: Cell::new(&empty_tables)\n-                };\n-                tcx.dep_graph.with_ignore(|| {\n-                    f(&annotation, tcx.hir().forest.krate())\n-                })\n-            }\n-            _ => panic!(\"Should use call_with_pp_support\"),\n+            })\n         }\n+        _ => panic!(\"Should use call_with_pp_support\"),\n     }\n }\n \n@@ -482,102 +390,6 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub enum UserIdentifiedItem {\n-    ItemViaNode(ast::NodeId),\n-    ItemViaPath(Vec<String>),\n-}\n-\n-impl FromStr for UserIdentifiedItem {\n-    type Err = ();\n-    fn from_str(s: &str) -> Result<UserIdentifiedItem, ()> {\n-        Ok(s.parse()\n-            .map(ast::NodeId::from_u32)\n-            .map(ItemViaNode)\n-            .unwrap_or_else(|_| ItemViaPath(s.split(\"::\").map(|s| s.to_string()).collect())))\n-    }\n-}\n-\n-enum NodesMatchingUII<'a> {\n-    NodesMatchingDirect(option::IntoIter<ast::NodeId>),\n-    NodesMatchingSuffix(Box<dyn Iterator<Item = ast::NodeId> + 'a>),\n-}\n-\n-impl<'a> Iterator for NodesMatchingUII<'a> {\n-    type Item = ast::NodeId;\n-\n-    fn next(&mut self) -> Option<ast::NodeId> {\n-        match self {\n-            &mut NodesMatchingDirect(ref mut iter) => iter.next(),\n-            &mut NodesMatchingSuffix(ref mut iter) => iter.next(),\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        match self {\n-            &NodesMatchingDirect(ref iter) => iter.size_hint(),\n-            &NodesMatchingSuffix(ref iter) => iter.size_hint(),\n-        }\n-    }\n-}\n-\n-impl UserIdentifiedItem {\n-    fn reconstructed_input(&self) -> String {\n-        match *self {\n-            ItemViaNode(node_id) => node_id.to_string(),\n-            ItemViaPath(ref parts) => parts.join(\"::\"),\n-        }\n-    }\n-\n-    fn all_matching_node_ids<'a, 'hir>(&'a self,\n-                                       map: &'a hir_map::Map<'hir>)\n-                                       -> NodesMatchingUII<'a> {\n-        match *self {\n-            ItemViaNode(node_id) => NodesMatchingDirect(Some(node_id).into_iter()),\n-            ItemViaPath(ref parts) => {\n-                NodesMatchingSuffix(Box::new(map.nodes_matching_suffix(&parts)))\n-            }\n-        }\n-    }\n-\n-    fn to_one_node_id(self,\n-                      user_option: &str,\n-                      sess: &Session,\n-                      map: &hir_map::Map<'_>)\n-                      -> ast::NodeId {\n-        let fail_because = |is_wrong_because| -> ast::NodeId {\n-            let message = format!(\"{} needs NodeId (int) or unique path suffix (b::c::d); got \\\n-                                   {}, which {}\",\n-                                  user_option,\n-                                  self.reconstructed_input(),\n-                                  is_wrong_because);\n-            sess.fatal(&message)\n-        };\n-\n-        let mut saw_node = ast::DUMMY_NODE_ID;\n-        let mut seen = 0;\n-        for node in self.all_matching_node_ids(map) {\n-            saw_node = node;\n-            seen += 1;\n-            if seen > 1 {\n-                fail_because(\"does not resolve uniquely\");\n-            }\n-        }\n-        if seen == 0 {\n-            fail_because(\"does not resolve to any item\");\n-        }\n-\n-        assert!(seen == 1);\n-        return saw_node;\n-    }\n-}\n-\n-pub fn visit_crate(sess: &Session, krate: &mut ast::Crate, ppm: PpMode) {\n-    if let PpmSource(PpmEveryBodyLoops) = ppm {\n-        ReplaceBodyWithLoop::new(sess).visit_crate(krate);\n-    }\n-}\n-\n fn get_source(input: &Input, sess: &Session) -> (String, FileName) {\n     let src_name = source_name(input);\n     let src = String::clone(&sess.source_map()\n@@ -613,7 +425,7 @@ pub fn print_after_parsing(sess: &Session,\n     if let PpmSource(s) = ppm {\n         // Silently ignores an identified node.\n         let out = &mut out;\n-        s.call_with_pp_support(sess, None, move |annotation| {\n+        call_with_pp_support(&s, sess, None, move |annotation| {\n             debug!(\"pretty printing source code {:?}\", s);\n             let sess = annotation.sess();\n             *out = pprust::print_crate(sess.source_map(),\n@@ -658,7 +470,7 @@ pub fn print_after_hir_lowering<'tcx>(\n                 // Silently ignores an identified node.\n                 let out = &mut out;\n                 let src = src.clone();\n-                s.call_with_pp_support(tcx.sess, Some(tcx), move |annotation| {\n+                call_with_pp_support(&s, tcx.sess, Some(tcx), move |annotation| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     *out = pprust::print_crate(sess.source_map(),\n@@ -674,7 +486,7 @@ pub fn print_after_hir_lowering<'tcx>(\n             (PpmHir(s), None) => {\n                 let out = &mut out;\n                 let src = src.clone();\n-                s.call_with_pp_support_hir(tcx, move |annotation, krate| {\n+                call_with_pp_support_hir(&s, tcx, move |annotation, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     *out = pprust_hir::print_crate(sess.source_map(),\n@@ -688,7 +500,7 @@ pub fn print_after_hir_lowering<'tcx>(\n \n             (PpmHirTree(s), None) => {\n                 let out = &mut out;\n-                s.call_with_pp_support_hir(tcx, move |_annotation, krate| {\n+                call_with_pp_support_hir(&s, tcx, move |_annotation, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     *out = format!(\"{:#?}\", krate);\n                 });\n@@ -697,7 +509,7 @@ pub fn print_after_hir_lowering<'tcx>(\n             (PpmHir(s), Some(uii)) => {\n                 let out = &mut out;\n                 let src = src.clone();\n-                s.call_with_pp_support_hir(tcx, move |annotation, _| {\n+                call_with_pp_support_hir(&s, tcx, move |annotation, _| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     let hir_map = annotation.hir_map().expect(\"-Z unpretty missing HIR map\");\n@@ -722,7 +534,7 @@ pub fn print_after_hir_lowering<'tcx>(\n \n             (PpmHirTree(s), Some(uii)) => {\n                 let out = &mut out;\n-                s.call_with_pp_support_hir(tcx, move |_annotation, _krate| {\n+                call_with_pp_support_hir(&s, tcx, move |_annotation, _krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     for node_id in uii.all_matching_node_ids(tcx.hir()) {\n                         let hir_id = tcx.hir().node_to_hir_id(node_id);"}, {"sha": "04a0b0e761961b9d1d730ab43fc2a7be4ac146c2", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=86c28325ff813e5cf4d0cab320a7c9f6fb0766b8", "patch": "@@ -16,6 +16,7 @@ use rustc::traits;\n use rustc::util::common::{time, ErrorReported};\n use rustc::session::Session;\n use rustc::session::config::{self, CrateType, Input, OutputFilenames, OutputType};\n+use rustc::session::config::{PpMode, PpSourceMode};\n use rustc::session::search_paths::PathKind;\n use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n@@ -394,8 +395,12 @@ fn configure_and_expand_inner<'a>(\n \n     // If we're actually rustdoc then there's no need to actually compile\n     // anything, so switch everything to just looping\n-    if sess.opts.actually_rustdoc {\n-        util::ReplaceBodyWithLoop::new(sess).visit_crate(&mut krate);\n+    let mut should_loop = sess.opts.actually_rustdoc;\n+    if let Some((PpMode::PpmSource(PpSourceMode::PpmEveryBodyLoops), _)) = sess.opts.pretty {\n+        should_loop |= true;\n+    }\n+    if should_loop {\n+        util::ReplaceBodyWithLoop::new(&mut resolver).visit_crate(&mut krate);\n     }\n \n     let has_proc_macro_decls = time(sess, \"AST validation\", || {"}, {"sha": "0c08f65d11d95f97f29fea02a534c0c17a85fea0", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=86c28325ff813e5cf4d0cab320a7c9f6fb0766b8", "patch": "@@ -18,7 +18,7 @@ use rustc_mir;\n use rustc_passes;\n use rustc_plugin;\n use rustc_privacy;\n-use rustc_resolve;\n+use rustc_resolve::{self, Resolver};\n use rustc_typeck;\n use std::env;\n use std::env::consts::{DLL_PREFIX, DLL_SUFFIX};\n@@ -715,18 +715,18 @@ pub fn build_output_filenames(\n //    ambitious form of the closed RFC #1637. See also [#34511].\n //\n // [#34511]: https://github.com/rust-lang/rust/issues/34511#issuecomment-322340401\n-pub struct ReplaceBodyWithLoop<'a> {\n+pub struct ReplaceBodyWithLoop<'a, 'b> {\n     within_static_or_const: bool,\n     nested_blocks: Option<Vec<ast::Block>>,\n-    sess: &'a Session,\n+    resolver: &'a mut Resolver<'b>,\n }\n \n-impl<'a> ReplaceBodyWithLoop<'a> {\n-    pub fn new(sess: &'a Session) -> ReplaceBodyWithLoop<'a> {\n+impl<'a, 'b> ReplaceBodyWithLoop<'a, 'b> {\n+    pub fn new(resolver: &'a mut Resolver<'b>) -> ReplaceBodyWithLoop<'a, 'b> {\n         ReplaceBodyWithLoop {\n             within_static_or_const: false,\n             nested_blocks: None,\n-            sess\n+            resolver,\n         }\n     }\n \n@@ -788,11 +788,12 @@ impl<'a> ReplaceBodyWithLoop<'a> {\n     }\n \n     fn is_sig_const(sig: &ast::FnSig) -> bool {\n-        sig.header.constness.node == ast::Constness::Const || Self::should_ignore_fn(&sig.decl)\n+        sig.header.constness.node == ast::Constness::Const ||\n+            ReplaceBodyWithLoop::should_ignore_fn(&sig.decl)\n     }\n }\n \n-impl<'a> MutVisitor for ReplaceBodyWithLoop<'a> {\n+impl<'a> MutVisitor for ReplaceBodyWithLoop<'a, '_> {\n     fn visit_item_kind(&mut self, i: &mut ast::ItemKind) {\n         let is_const = match i {\n             ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => true,\n@@ -827,40 +828,40 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a> {\n     fn visit_block(&mut self, b: &mut P<ast::Block>) {\n         fn stmt_to_block(rules: ast::BlockCheckMode,\n                          s: Option<ast::Stmt>,\n-                         sess: &Session) -> ast::Block {\n+                         resolver: &mut Resolver<'_>) -> ast::Block {\n             ast::Block {\n                 stmts: s.into_iter().collect(),\n                 rules,\n-                id: sess.next_node_id(),\n+                id: resolver.next_node_id(),\n                 span: syntax_pos::DUMMY_SP,\n             }\n         }\n \n-        fn block_to_stmt(b: ast::Block, sess: &Session) -> ast::Stmt {\n+        fn block_to_stmt(b: ast::Block, resolver: &mut Resolver<'_>) -> ast::Stmt {\n             let expr = P(ast::Expr {\n-                id: sess.next_node_id(),\n+                id: resolver.next_node_id(),\n                 kind: ast::ExprKind::Block(P(b), None),\n                 span: syntax_pos::DUMMY_SP,\n                 attrs: ThinVec::new(),\n             });\n \n             ast::Stmt {\n-                id: sess.next_node_id(),\n+                id: resolver.next_node_id(),\n                 kind: ast::StmtKind::Expr(expr),\n                 span: syntax_pos::DUMMY_SP,\n             }\n         }\n \n-        let empty_block = stmt_to_block(BlockCheckMode::Default, None, self.sess);\n+        let empty_block = stmt_to_block(BlockCheckMode::Default, None, self.resolver);\n         let loop_expr = P(ast::Expr {\n             kind: ast::ExprKind::Loop(P(empty_block), None),\n-            id: self.sess.next_node_id(),\n+            id: self.resolver.next_node_id(),\n             span: syntax_pos::DUMMY_SP,\n                 attrs: ThinVec::new(),\n         });\n \n         let loop_stmt = ast::Stmt {\n-            id: self.sess.next_node_id(),\n+            id: self.resolver.next_node_id(),\n             span: syntax_pos::DUMMY_SP,\n             kind: ast::StmtKind::Expr(loop_expr),\n         };\n@@ -878,7 +879,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a> {\n                     // we put a Some in there earlier with that replace(), so this is valid\n                     let new_blocks = self.nested_blocks.take().unwrap();\n                     self.nested_blocks = old_blocks;\n-                    stmts.extend(new_blocks.into_iter().map(|b| block_to_stmt(b, &self.sess)));\n+                    stmts.extend(new_blocks.into_iter().map(|b| block_to_stmt(b, self.resolver)));\n                 }\n \n                 let mut new_block = ast::Block {\n@@ -892,7 +893,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a> {\n                         old_blocks.push(new_block);\n                     }\n \n-                    stmt_to_block(b.rules, Some(loop_stmt), self.sess)\n+                    stmt_to_block(b.rules, Some(loop_stmt), &mut self.resolver)\n                 } else {\n                     //push `loop {}` onto the end of our fresh block and yield that\n                     new_block.stmts.push(loop_stmt);"}, {"sha": "1ce356d48913dd88053ba5f1b936cf5baae84f71", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=86c28325ff813e5cf4d0cab320a7c9f6fb0766b8", "patch": "@@ -449,7 +449,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                                     name: kw::PathRoot,\n                                     span: source.ident.span,\n                                 },\n-                                id: Some(self.r.session.next_node_id()),\n+                                id: Some(self.r.next_node_id()),\n                             });\n                             source.ident.name = crate_name;\n                         }"}, {"sha": "e94b544582e804362f5dc00aae8c9fcb718e6b74", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=86c28325ff813e5cf4d0cab320a7c9f6fb0766b8", "patch": "@@ -961,6 +961,8 @@ pub struct Resolver<'a> {\n     variant_vis: DefIdMap<ty::Visibility>,\n \n     lint_buffer: lint::LintBuffer,\n+\n+    next_node_id: NodeId,\n }\n \n /// Nothing really interesting here; it just provides memory for the rest of the crate.\n@@ -1078,6 +1080,10 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n     fn lint_buffer(&mut self) -> &mut lint::LintBuffer {\n         &mut self.lint_buffer\n     }\n+\n+    fn next_node_id(&mut self) -> NodeId {\n+        self.next_node_id()\n+    }\n }\n \n impl<'a> Resolver<'a> {\n@@ -1226,9 +1232,18 @@ impl<'a> Resolver<'a> {\n                     .collect(),\n             variant_vis: Default::default(),\n             lint_buffer: lint::LintBuffer::default(),\n+            next_node_id: NodeId::from_u32(1),\n         }\n     }\n \n+    pub fn next_node_id(&mut self) -> NodeId {\n+        let next = self.next_node_id.as_usize()\n+            .checked_add(1)\n+            .expect(\"input too large; ran out of NodeIds\");\n+        self.next_node_id = ast::NodeId::from_usize(next);\n+        self.next_node_id\n+    }\n+\n     pub fn lint_buffer(&mut self) -> &mut lint::LintBuffer {\n         &mut self.lint_buffer\n     }\n@@ -2827,9 +2842,9 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn new_ast_path_segment(&self, ident: Ident) -> ast::PathSegment {\n+    fn new_ast_path_segment(&mut self, ident: Ident) -> ast::PathSegment {\n         let mut seg = ast::PathSegment::from_ident(ident);\n-        seg.id = self.session.next_node_id();\n+        seg.id = self.next_node_id();\n         seg\n     }\n "}, {"sha": "cc811d3b59a41c4bec4fdd482857d4e3ef6ec169", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c28325ff813e5cf4d0cab320a7c9f6fb0766b8/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=86c28325ff813e5cf4d0cab320a7c9f6fb0766b8", "patch": "@@ -95,7 +95,7 @@ fn fast_print_path(path: &ast::Path) -> Symbol {\n \n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> NodeId {\n-        self.session.next_node_id()\n+        self.next_node_id()\n     }\n \n     fn resolve_dollar_crates(&mut self) {"}]}