{"sha": "e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzZWQ3YjA1MDFhMjRmNGRlZjNhZmY3NzVjNmZiZjk0ODFlM2M3N2U=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-12-04T16:34:28Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-12-12T16:39:37Z"}, "message": "Implement `#[deprecated]` attribute (RFC 1270)", "tree": {"sha": "f6cc8a0e37570f58704ec03a88a5c50d52d4741d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6cc8a0e37570f58704ec03a88a5c50d52d4741d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "html_url": "https://github.com/rust-lang/rust/commit/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45a73c8c0cf2d5a181be2c1e927212975e0cffc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/45a73c8c0cf2d5a181be2c1e927212975e0cffc7", "html_url": "https://github.com/rust-lang/rust/commit/45a73c8c0cf2d5a181be2c1e927212975e0cffc7"}], "stats": {"total": 1009, "additions": 899, "deletions": 110}, "files": [{"sha": "a20d25711521116d9fcd2bc9912a766d6026f88f", "filename": "src/doc/reference.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "patch": "@@ -2390,6 +2390,8 @@ The currently implemented features of the reference compiler are:\n * - `stmt_expr_attributes` - Allows attributes on expressions and\n                              non-item statements.\n \n+* - `deprecated` - Allows using the `#[deprecated]` attribute.\n+\n If a feature is promoted to a language feature, then all existing programs will\n start to receive compilation warnings about `#![feature]` directives which enabled\n the new feature (because the directive is no longer necessary). However, if a"}, {"sha": "2c3b89bf2fbb2ffa31e77b6ae6c2fc9403c47b72", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "patch": "@@ -135,6 +135,7 @@ pub enum FoundAst<'ast> {\n pub trait CrateStore<'tcx> : Any {\n     // item info\n     fn stability(&self, def: DefId) -> Option<attr::Stability>;\n+    fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>;\n     fn closure_kind(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId)\n                     -> ty::ClosureKind;\n     fn closure_ty(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId)\n@@ -292,6 +293,7 @@ pub struct DummyCrateStore;\n impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // item info\n     fn stability(&self, def: DefId) -> Option<attr::Stability> { unimplemented!() }\n+    fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> { unimplemented!() }\n     fn closure_kind(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId)\n                     -> ty::ClosureKind  { unimplemented!() }\n     fn closure_ty(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId)"}, {"sha": "f7e2135d5a43b85cdebb354c7d9c35760254ee1a", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 125, "deletions": 44, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "patch": "@@ -25,7 +25,7 @@ use syntax::codemap::{Span, DUMMY_SP};\n use syntax::ast;\n use syntax::ast::{NodeId, Attribute};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax::attr::{self, Stability, AttrMetaMethods};\n+use syntax::attr::{self, Stability, Deprecation, AttrMetaMethods};\n use util::nodemap::{DefIdMap, FnvHashSet, FnvHashMap};\n \n use rustc_front::hir;\n@@ -61,7 +61,8 @@ enum AnnotationKind {\n pub struct Index<'tcx> {\n     /// This is mostly a cache, except the stabilities of local items\n     /// are filled by the annotator.\n-    map: DefIdMap<Option<&'tcx Stability>>,\n+    stab_map: DefIdMap<Option<&'tcx Stability>>,\n+    depr_map: DefIdMap<Option<Deprecation>>,\n \n     /// Maps for each crate whether it is part of the staged API.\n     staged_api: FnvHashMap<ast::CrateNum, bool>\n@@ -71,7 +72,8 @@ pub struct Index<'tcx> {\n struct Annotator<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     index: &'a mut Index<'tcx>,\n-    parent: Option<&'tcx Stability>,\n+    parent_stab: Option<&'tcx Stability>,\n+    parent_depr: Option<Deprecation>,\n     access_levels: &'a AccessLevels,\n     in_trait_impl: bool,\n     in_enum: bool,\n@@ -86,31 +88,35 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n     {\n         if self.index.staged_api[&LOCAL_CRATE] && self.tcx.sess.features.borrow().staged_api {\n             debug!(\"annotate(id = {:?}, attrs = {:?})\", id, attrs);\n+            if let Some(..) = attr::find_deprecation(self.tcx.sess.diagnostic(), attrs, item_sp) {\n+                self.tcx.sess.span_err(item_sp, \"`#[deprecated]` cannot be used in staged api, \\\n+                                                 use `#[rustc_deprecated]` instead\");\n+            }\n             if let Some(mut stab) = attr::find_stability(self.tcx.sess.diagnostic(),\n                                                          attrs, item_sp) {\n                 // Error if prohibited, or can't inherit anything from a container\n                 if kind == AnnotationKind::Prohibited ||\n                    (kind == AnnotationKind::Container &&\n                     stab.level.is_stable() &&\n-                    stab.depr.is_none()) {\n+                    stab.rustc_depr.is_none()) {\n                     self.tcx.sess.span_err(item_sp, \"This stability annotation is useless\");\n                 }\n \n                 debug!(\"annotate: found {:?}\", stab);\n                 // If parent is deprecated and we're not, inherit this by merging\n                 // deprecated_since and its reason.\n-                if let Some(parent_stab) = self.parent {\n-                    if parent_stab.depr.is_some() && stab.depr.is_none() {\n-                        stab.depr = parent_stab.depr.clone()\n+                if let Some(parent_stab) = self.parent_stab {\n+                    if parent_stab.rustc_depr.is_some() && stab.rustc_depr.is_none() {\n+                        stab.rustc_depr = parent_stab.rustc_depr.clone()\n                     }\n                 }\n \n                 let stab = self.tcx.intern_stability(stab);\n \n                 // Check if deprecated_since < stable_since. If it is,\n                 // this is *almost surely* an accident.\n-                if let (&Some(attr::Deprecation {since: ref dep_since, ..}),\n-                        &attr::Stable {since: ref stab_since}) = (&stab.depr, &stab.level) {\n+                if let (&Some(attr::RustcDeprecation {since: ref dep_since, ..}),\n+                        &attr::Stable {since: ref stab_since}) = (&stab.rustc_depr, &stab.level) {\n                     // Explicit version of iter::order::lt to handle parse errors properly\n                     for (dep_v, stab_v) in dep_since.split(\".\").zip(stab_since.split(\".\")) {\n                         if let (Ok(dep_v), Ok(stab_v)) = (dep_v.parse::<u64>(), stab_v.parse()) {\n@@ -134,20 +140,20 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 }\n \n                 let def_id = self.tcx.map.local_def_id(id);\n-                self.index.map.insert(def_id, Some(stab));\n+                self.index.stab_map.insert(def_id, Some(stab));\n \n-                let parent = replace(&mut self.parent, Some(stab));\n+                let orig_parent_stab = replace(&mut self.parent_stab, Some(stab));\n                 visit_children(self);\n-                self.parent = parent;\n+                self.parent_stab = orig_parent_stab;\n             } else {\n-                debug!(\"annotate: not found, parent = {:?}\", self.parent);\n+                debug!(\"annotate: not found, parent = {:?}\", self.parent_stab);\n                 let mut is_error = kind == AnnotationKind::Required &&\n                                    self.access_levels.is_reachable(id) &&\n                                    !self.tcx.sess.opts.test;\n-                if let Some(stab) = self.parent {\n+                if let Some(stab) = self.parent_stab {\n                     if stab.level.is_unstable() {\n                         let def_id = self.tcx.map.local_def_id(id);\n-                        self.index.map.insert(def_id, Some(stab));\n+                        self.index.stab_map.insert(def_id, Some(stab));\n                         is_error = false;\n                     }\n                 }\n@@ -165,9 +171,35 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                     attr::mark_used(attr);\n                     self.tcx.sess.span_err(attr.span(), \"stability attributes may not be used \\\n                                                          outside of the standard library\");\n+                } else if tag == \"deprecated\" {\n+                    if !self.tcx.sess.features.borrow().deprecated {\n+                        self.tcx.sess.span_err(attr.span(),\n+                                               \"`#[deprecated]` attribute is unstable\");\n+                        fileline_help!(self.tcx.sess, attr.span(), \"add #![feature(deprecated)] to \\\n+                                                                    the crate features to enable\");\n+                    }\n                 }\n             }\n-            visit_children(self);\n+\n+            if let Some(depr) = attr::find_deprecation(self.tcx.sess.diagnostic(), attrs, item_sp) {\n+                if kind == AnnotationKind::Prohibited {\n+                    self.tcx.sess.span_err(item_sp, \"This deprecation annotation is useless\");\n+                }\n+\n+                // `Deprecation` is just two pointers, no need to intern it\n+                let def_id = self.tcx.map.local_def_id(id);\n+                self.index.depr_map.insert(def_id, Some(depr.clone()));\n+\n+                let orig_parent_depr = replace(&mut self.parent_depr, Some(depr));\n+                visit_children(self);\n+                self.parent_depr = orig_parent_depr;\n+            } else if let Some(depr) = self.parent_depr.clone() {\n+                let def_id = self.tcx.map.local_def_id(id);\n+                self.index.depr_map.insert(def_id, Some(depr));\n+                visit_children(self);\n+            } else {\n+                visit_children(self);\n+            }\n         }\n     }\n }\n@@ -269,7 +301,8 @@ impl<'tcx> Index<'tcx> {\n         let mut annotator = Annotator {\n             tcx: tcx,\n             index: self,\n-            parent: None,\n+            parent_stab: None,\n+            parent_depr: None,\n             access_levels: access_levels,\n             in_trait_impl: false,\n             in_enum: false,\n@@ -291,7 +324,8 @@ impl<'tcx> Index<'tcx> {\n         staged_api.insert(LOCAL_CRATE, is_staged_api);\n         Index {\n             staged_api: staged_api,\n-            map: DefIdMap(),\n+            stab_map: DefIdMap(),\n+            depr_map: DefIdMap(),\n         }\n     }\n }\n@@ -327,7 +361,11 @@ struct Checker<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Checker<'a, 'tcx> {\n-    fn check(&mut self, id: DefId, span: Span, stab: &Option<&Stability>) {\n+    fn check(&mut self, id: DefId, span: Span,\n+             stab: &Option<&Stability>, _depr: &Option<Deprecation>) {\n+        if !is_staged_api(self.tcx, id) {\n+            return;\n+        }\n         // Only the cross-crate scenario matters when checking unstable APIs\n         let cross_crate = !id.is_local();\n         if !cross_crate {\n@@ -395,31 +433,31 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n         if item.span == DUMMY_SP && item.name.as_str() == \"__test\" { return }\n \n         check_item(self.tcx, item, true,\n-                   &mut |id, sp, stab| self.check(id, sp, stab));\n+                   &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_item(self, item);\n     }\n \n     fn visit_expr(&mut self, ex: &hir::Expr) {\n         check_expr(self.tcx, ex,\n-                   &mut |id, sp, stab| self.check(id, sp, stab));\n+                   &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_expr(self, ex);\n     }\n \n     fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n         check_path(self.tcx, path, id,\n-                   &mut |id, sp, stab| self.check(id, sp, stab));\n+                   &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_path(self, path)\n     }\n \n     fn visit_path_list_item(&mut self, prefix: &hir::Path, item: &hir::PathListItem) {\n         check_path_list_item(self.tcx, item,\n-                   &mut |id, sp, stab| self.check(id, sp, stab));\n+                   &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_path_list_item(self, prefix, item)\n     }\n \n     fn visit_pat(&mut self, pat: &hir::Pat) {\n         check_pat(self.tcx, pat,\n-                  &mut |id, sp, stab| self.check(id, sp, stab));\n+                  &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_pat(self, pat)\n     }\n \n@@ -441,7 +479,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n \n /// Helper for discovering nodes to check for stability\n pub fn check_item(tcx: &ty::ctxt, item: &hir::Item, warn_about_defns: bool,\n-                  cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n+                  cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n     match item.node {\n         hir::ItemExternCrate(_) => {\n             // compiler-generated `extern crate` items have a dummy span.\n@@ -478,7 +516,7 @@ pub fn check_item(tcx: &ty::ctxt, item: &hir::Item, warn_about_defns: bool,\n \n /// Helper for discovering nodes to check for stability\n pub fn check_expr(tcx: &ty::ctxt, e: &hir::Expr,\n-                  cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n+                  cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n     let span;\n     let id = match e.node {\n         hir::ExprMethodCall(i, _, _) => {\n@@ -539,7 +577,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &hir::Expr,\n }\n \n pub fn check_path(tcx: &ty::ctxt, path: &hir::Path, id: ast::NodeId,\n-                  cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n+                  cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n     match tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n         Some(def::DefPrimTy(..)) => {}\n         Some(def::DefSelfTy(..)) => {}\n@@ -551,7 +589,7 @@ pub fn check_path(tcx: &ty::ctxt, path: &hir::Path, id: ast::NodeId,\n }\n \n pub fn check_path_list_item(tcx: &ty::ctxt, item: &hir::PathListItem,\n-                  cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n+                  cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n     match tcx.def_map.borrow().get(&item.node.id()).map(|d| d.full_def()) {\n         Some(def::DefPrimTy(..)) => {}\n         Some(def) => {\n@@ -562,7 +600,7 @@ pub fn check_path_list_item(tcx: &ty::ctxt, item: &hir::PathListItem,\n }\n \n pub fn check_pat(tcx: &ty::ctxt, pat: &hir::Pat,\n-                 cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n+                 cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n \n@@ -591,21 +629,21 @@ pub fn check_pat(tcx: &ty::ctxt, pat: &hir::Pat,\n }\n \n fn maybe_do_stability_check(tcx: &ty::ctxt, id: DefId, span: Span,\n-                            cb: &mut FnMut(DefId, Span, &Option<&Stability>)) {\n-    if !is_staged_api(tcx, id) {\n-        debug!(\"maybe_do_stability_check: \\\n-                skipping id={:?} since it is not staged_api\", id);\n-        return;\n-    }\n+                            cb: &mut FnMut(DefId, Span,\n+                                           &Option<&Stability>, &Option<Deprecation>)) {\n     if is_internal(tcx, span) {\n         debug!(\"maybe_do_stability_check: \\\n                 skipping span={:?} since it is internal\", span);\n         return;\n     }\n-    let ref stability = lookup(tcx, id);\n+    let (stability, deprecation) = if is_staged_api(tcx, id) {\n+        (lookup_stability(tcx, id), None)\n+    } else {\n+        (None, lookup_deprecation(tcx, id))\n+    };\n     debug!(\"maybe_do_stability_check: \\\n             inspecting id={:?} span={:?} of stability={:?}\", id, span, stability);\n-    cb(id, span, stability);\n+    cb(id, span, &stability, &deprecation);\n }\n \n fn is_internal(tcx: &ty::ctxt, span: Span) -> bool {\n@@ -627,24 +665,34 @@ fn is_staged_api(tcx: &ty::ctxt, id: DefId) -> bool {\n \n /// Lookup the stability for a node, loading external crate\n /// metadata as necessary.\n-pub fn lookup<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stability> {\n-    if let Some(st) = tcx.stability.borrow().map.get(&id) {\n+pub fn lookup_stability<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stability> {\n+    if let Some(st) = tcx.stability.borrow().stab_map.get(&id) {\n         return *st;\n     }\n \n-    let st = lookup_uncached(tcx, id);\n-    tcx.stability.borrow_mut().map.insert(id, st);\n+    let st = lookup_stability_uncached(tcx, id);\n+    tcx.stability.borrow_mut().stab_map.insert(id, st);\n     st\n }\n \n-fn lookup_uncached<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stability> {\n+pub fn lookup_deprecation<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<Deprecation> {\n+    if let Some(depr) = tcx.stability.borrow().depr_map.get(&id) {\n+        return depr.clone();\n+    }\n+\n+    let depr = lookup_deprecation_uncached(tcx, id);\n+    tcx.stability.borrow_mut().depr_map.insert(id, depr.clone());\n+    depr\n+}\n+\n+fn lookup_stability_uncached<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stability> {\n     debug!(\"lookup(id={:?})\", id);\n \n     // is this definition the implementation of a trait method?\n     match tcx.trait_item_of_item(id) {\n         Some(ty::MethodTraitItemId(trait_method_id)) if trait_method_id != id => {\n             debug!(\"lookup: trait_method_id={:?}\", trait_method_id);\n-            return lookup(tcx, trait_method_id)\n+            return lookup_stability(tcx, trait_method_id)\n         }\n         _ => {}\n     }\n@@ -663,7 +711,40 @@ fn lookup_uncached<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stabil\n                 // unmarked impls for it. See FIXME above for more details.\n \n                 debug!(\"lookup: trait_id={:?}\", trait_id);\n-                return lookup(tcx, trait_id);\n+                return lookup_stability(tcx, trait_id);\n+            }\n+        }\n+        None\n+    })\n+}\n+\n+fn lookup_deprecation_uncached<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<Deprecation> {\n+    debug!(\"lookup(id={:?})\", id);\n+\n+    // is this definition the implementation of a trait method?\n+    match tcx.trait_item_of_item(id) {\n+        Some(ty::MethodTraitItemId(trait_method_id)) if trait_method_id != id => {\n+            debug!(\"lookup: trait_method_id={:?}\", trait_method_id);\n+            return lookup_deprecation(tcx, trait_method_id)\n+        }\n+        _ => {}\n+    }\n+\n+    let item_depr = if id.is_local() {\n+        None // The stability cache is filled partially lazily\n+    } else {\n+        tcx.sess.cstore.deprecation(id)\n+    };\n+\n+    item_depr.or_else(|| {\n+        if tcx.is_impl(id) {\n+            if let Some(trait_id) = tcx.trait_id_of_impl(id) {\n+                // FIXME (#18969): for the time being, simply use the\n+                // stability of the trait to determine the stability of any\n+                // unmarked impls for it. See FIXME above for more details.\n+\n+                debug!(\"lookup: trait_id={:?}\", trait_id);\n+                return lookup_deprecation(tcx, trait_id);\n             }\n         }\n         None"}, {"sha": "249504cbd8dce515bf4e23e9ada7a4d84192c7e6", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "patch": "@@ -575,74 +575,71 @@ impl LateLintPass for MissingDebugImplementations {\n declare_lint! {\n     DEPRECATED,\n     Warn,\n-    \"detects use of #[rustc_deprecated] items\"\n+    \"detects use of `#[deprecated]` or `#[rustc_deprecated]` items\"\n }\n \n-/// Checks for use of items with `#[rustc_deprecated]` attributes\n+/// Checks for use of items with `#[deprecated]` or `#[rustc_deprecated]` attributes\n #[derive(Copy, Clone)]\n-pub struct Stability;\n+pub struct Deprecated;\n \n-impl Stability {\n-    fn lint(&self, cx: &LateContext, _id: DefId,\n-            span: Span, stability: &Option<&attr::Stability>) {\n+impl Deprecated {\n+    fn lint(&self, cx: &LateContext, _id: DefId, span: Span,\n+            stability: &Option<&attr::Stability>, deprecation: &Option<attr::Deprecation>) {\n         // Deprecated attributes apply in-crate and cross-crate.\n-        let (lint, label) = match *stability {\n-            Some(&attr::Stability { depr: Some(_), .. }) =>\n-                (DEPRECATED, \"deprecated\"),\n-            _ => return\n-        };\n-\n-        output(cx, span, stability, lint, label);\n+        if let Some(&attr::Stability{rustc_depr: Some(attr::RustcDeprecation{ref reason, ..}), ..})\n+                = *stability {\n+            output(cx, DEPRECATED, span, Some(&reason))\n+        } else if let Some(attr::Deprecation{ref note, ..}) = *deprecation {\n+            output(cx, DEPRECATED, span, note.as_ref().map(|x| &**x))\n+        }\n \n-        fn output(cx: &LateContext, span: Span, stability: &Option<&attr::Stability>,\n-                  lint: &'static Lint, label: &'static str) {\n-            let msg = match *stability {\n-                Some(&attr::Stability {depr: Some(attr::Deprecation {ref reason, ..}), ..}) => {\n-                    format!(\"use of {} item: {}\", label, reason)\n-                }\n-                _ => format!(\"use of {} item\", label)\n+        fn output(cx: &LateContext, lint: &'static Lint, span: Span, note: Option<&str>) {\n+            let msg = if let Some(note) = note {\n+                format!(\"use of deprecated item: {}\", note)\n+            } else {\n+                format!(\"use of deprecated item\")\n             };\n \n-            cx.span_lint(lint, span, &msg[..]);\n+            cx.span_lint(lint, span, &msg);\n         }\n     }\n }\n \n-impl LintPass for Stability {\n+impl LintPass for Deprecated {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(DEPRECATED)\n     }\n }\n \n-impl LateLintPass for Stability {\n+impl LateLintPass for Deprecated {\n     fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         stability::check_item(cx.tcx, item, false,\n-                              &mut |id, sp, stab|\n-                                self.lint(cx, id, sp, &stab));\n+                              &mut |id, sp, stab, depr|\n+                                self.lint(cx, id, sp, &stab, &depr));\n     }\n \n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         stability::check_expr(cx.tcx, e,\n-                              &mut |id, sp, stab|\n-                                self.lint(cx, id, sp, &stab));\n+                              &mut |id, sp, stab, depr|\n+                                self.lint(cx, id, sp, &stab, &depr));\n     }\n \n     fn check_path(&mut self, cx: &LateContext, path: &hir::Path, id: ast::NodeId) {\n         stability::check_path(cx.tcx, path, id,\n-                              &mut |id, sp, stab|\n-                                self.lint(cx, id, sp, &stab));\n+                              &mut |id, sp, stab, depr|\n+                                self.lint(cx, id, sp, &stab, &depr));\n     }\n \n     fn check_path_list_item(&mut self, cx: &LateContext, item: &hir::PathListItem) {\n         stability::check_path_list_item(cx.tcx, item,\n-                                         &mut |id, sp, stab|\n-                                           self.lint(cx, id, sp, &stab));\n+                                         &mut |id, sp, stab, depr|\n+                                           self.lint(cx, id, sp, &stab, &depr));\n     }\n \n     fn check_pat(&mut self, cx: &LateContext, pat: &hir::Pat) {\n         stability::check_pat(cx.tcx, pat,\n-                             &mut |id, sp, stab|\n-                                self.lint(cx, id, sp, &stab));\n+                             &mut |id, sp, stab, depr|\n+                                self.lint(cx, id, sp, &stab, &depr));\n     }\n }\n "}, {"sha": "69fd569c8d48444a4d4b87b4ce9fbcec19d0eed4", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "patch": "@@ -124,7 +124,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                  UnusedAllocation,\n                  MissingCopyImplementations,\n                  UnstableFeatures,\n-                 Stability,\n+                 Deprecated,\n                  UnconditionalRecursion,\n                  InvalidNoMangleItems,\n                  PluginAsLibrary,"}, {"sha": "479ab7592784795a765e46f7ad4e32ccf4efc880", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "patch": "@@ -237,6 +237,8 @@ pub const tag_impl_coerce_unsized_kind: usize = 0xa5;\n \n pub const tag_items_data_item_constness: usize = 0xa6;\n \n+pub const tag_items_data_item_deprecation: usize = 0xa7;\n+\n pub const tag_rustc_version: usize = 0x10f;\n pub fn rustc_version() -> String {\n     format!("}, {"sha": "ecbc84023309105f9953e0a7babf1a36c43e79d5", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "patch": "@@ -42,6 +42,12 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_stability(&*cdata, def.index)\n     }\n \n+    fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_deprecation(&*cdata, def.index)\n+    }\n+\n     fn closure_kind(&self, _tcx: &ty::ctxt<'tcx>, def_id: DefId) -> ty::ClosureKind\n     {\n         assert!(!def_id.is_local());"}, {"sha": "357158c24bacda8809525246b087e7af956e3b31", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "patch": "@@ -526,6 +526,14 @@ pub fn get_stability(cdata: Cmd, id: DefIndex) -> Option<attr::Stability> {\n     })\n }\n \n+pub fn get_deprecation(cdata: Cmd, id: DefIndex) -> Option<attr::Deprecation> {\n+    let item = cdata.lookup_item(id);\n+    reader::maybe_get_doc(item, tag_items_data_item_deprecation).map(|doc| {\n+        let mut decoder = reader::Decoder::new(doc);\n+        Decodable::decode(&mut decoder).unwrap()\n+    })\n+}\n+\n pub fn get_repr_attrs(cdata: Cmd, id: DefIndex) -> Vec<attr::ReprAttr> {\n     let item = cdata.lookup_item(id);\n     match reader::maybe_get_doc(item, tag_items_data_item_repr).map(|doc| {"}, {"sha": "888776eaa56105647b4846ec518241f41cf9f875", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 49, "deletions": 11, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "patch": "@@ -342,8 +342,10 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_attributes(rbml_w, &attrs);\n         encode_repr_attrs(rbml_w, ecx, &attrs);\n \n-        let stab = stability::lookup(ecx.tcx, vid);\n+        let stab = stability::lookup_stability(ecx.tcx, vid);\n+        let depr = stability::lookup_deprecation(ecx.tcx, vid);\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n \n         encode_struct_fields(rbml_w, variant);\n \n@@ -450,8 +452,10 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     encode_path(rbml_w, path.clone());\n     encode_visibility(rbml_w, vis);\n \n-    let stab = stability::lookup(ecx.tcx, ecx.tcx.map.local_def_id(id));\n+    let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(id));\n+    let depr = stability::lookup_deprecation(ecx.tcx, ecx.tcx.map.local_def_id(id));\n     encode_stability(rbml_w, stab);\n+    encode_deprecation(rbml_w, depr);\n \n     // Encode the reexports of this module, if this module is public.\n     if vis == hir::Public {\n@@ -538,8 +542,10 @@ fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_bounds_and_type_for_item(rbml_w, ecx, index, id);\n     encode_def_id_and_key(ecx, rbml_w, field.did);\n \n-    let stab = stability::lookup(ecx.tcx, field.did);\n+    let stab = stability::lookup_stability(ecx.tcx, field.did);\n+    let depr = stability::lookup_deprecation(ecx.tcx, field.did);\n     encode_stability(rbml_w, stab);\n+    encode_deprecation(rbml_w, depr);\n \n     rbml_w.end_tag();\n }\n@@ -565,8 +571,10 @@ fn encode_info_for_struct_ctor<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_symbol(ecx, rbml_w, ctor_id);\n     }\n \n-    let stab = stability::lookup(ecx.tcx, ecx.tcx.map.local_def_id(ctor_id));\n+    let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(ctor_id));\n+    let depr= stability::lookup_deprecation(ecx.tcx, ecx.tcx.map.local_def_id(ctor_id));\n     encode_stability(rbml_w, stab);\n+    encode_deprecation(rbml_w, depr);\n \n     // indicate that this is a tuple struct ctor, because downstream users will normally want\n     // the tuple struct definition, but without this there is no way for them to tell that\n@@ -700,8 +708,10 @@ fn encode_info_for_associated_const<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_bounds_and_type_for_item(rbml_w, ecx, index,\n                                     ecx.local_id(associated_const.def_id));\n \n-    let stab = stability::lookup(ecx.tcx, associated_const.def_id);\n+    let stab = stability::lookup_stability(ecx.tcx, associated_const.def_id);\n+    let depr = stability::lookup_deprecation(ecx.tcx, associated_const.def_id);\n     encode_stability(rbml_w, stab);\n+    encode_deprecation(rbml_w, depr);\n \n     let elem = ast_map::PathName(associated_const.name);\n     encode_path(rbml_w, impl_path.chain(Some(elem)));\n@@ -735,8 +745,10 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n     encode_item_sort(rbml_w, 'r');\n \n-    let stab = stability::lookup(ecx.tcx, m.def_id);\n+    let stab = stability::lookup_stability(ecx.tcx, m.def_id);\n+    let depr = stability::lookup_deprecation(ecx.tcx, m.def_id);\n     encode_stability(rbml_w, stab);\n+    encode_deprecation(rbml_w, depr);\n \n     let m_node_id = ecx.local_id(m.def_id);\n     encode_bounds_and_type_for_item(rbml_w, ecx, index, m_node_id);\n@@ -789,8 +801,10 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n     encode_item_sort(rbml_w, 't');\n \n-    let stab = stability::lookup(ecx.tcx, associated_type.def_id);\n+    let stab = stability::lookup_stability(ecx.tcx, associated_type.def_id);\n+    let depr = stability::lookup_deprecation(ecx.tcx, associated_type.def_id);\n     encode_stability(rbml_w, stab);\n+    encode_deprecation(rbml_w, depr);\n \n     let elem = ast_map::PathName(associated_type.name);\n     encode_path(rbml_w, impl_path.chain(Some(elem)));\n@@ -891,6 +905,14 @@ fn encode_stability(rbml_w: &mut Encoder, stab_opt: Option<&attr::Stability>) {\n     });\n }\n \n+fn encode_deprecation(rbml_w: &mut Encoder, depr_opt: Option<attr::Deprecation>) {\n+    depr_opt.map(|depr| {\n+        rbml_w.start_tag(tag_items_data_item_deprecation);\n+        depr.encode(rbml_w).unwrap();\n+        rbml_w.end_tag();\n+    });\n+}\n+\n fn encode_xrefs<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                           rbml_w: &mut Encoder,\n                           xrefs: FnvHashMap<XRef<'tcx>, u32>)\n@@ -931,7 +953,8 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n            tcx.sess.codemap().span_to_string(item.span));\n \n     let def_id = ecx.tcx.map.local_def_id(item.id);\n-    let stab = stability::lookup(tcx, ecx.tcx.map.local_def_id(item.id));\n+    let stab = stability::lookup_stability(tcx, ecx.tcx.map.local_def_id(item.id));\n+    let depr = stability::lookup_deprecation(tcx, ecx.tcx.map.local_def_id(item.id));\n \n     match item.node {\n       hir::ItemStatic(_, m, _) => {\n@@ -949,6 +972,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         encode_attributes(rbml_w, &item.attrs);\n         rbml_w.end_tag();\n       }\n@@ -964,6 +988,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         rbml_w.end_tag();\n       }\n       hir::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n@@ -986,6 +1011,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_constness(rbml_w, constness);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         encode_method_argument_names(rbml_w, &**decl);\n         rbml_w.end_tag();\n       }\n@@ -1015,6 +1041,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         }\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         rbml_w.end_tag();\n       }\n       hir::ItemTy(..) => {\n@@ -1027,6 +1054,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         rbml_w.end_tag();\n       }\n       hir::ItemEnum(ref enum_definition, _) => {\n@@ -1051,6 +1079,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         rbml_w.end_tag();\n \n         encode_enum_variant_info(ecx,\n@@ -1077,6 +1106,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_attributes(rbml_w, &item.attrs);\n         encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         encode_visibility(rbml_w, vis);\n         encode_repr_attrs(rbml_w, ecx, &item.attrs);\n \n@@ -1167,6 +1197,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         }\n         encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         rbml_w.end_tag();\n \n         // Iterate down the trait items, emitting them. We rely on the\n@@ -1236,6 +1267,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_attributes(rbml_w, &item.attrs);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         for &method_def_id in tcx.trait_item_def_ids(def_id).iter() {\n             rbml_w.start_tag(tag_item_trait_item);\n             match method_def_id {\n@@ -1274,8 +1306,10 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n             encode_parent_item(rbml_w, def_id);\n \n-            let stab = stability::lookup(tcx, item_def_id.def_id());\n+            let stab = stability::lookup_stability(tcx, item_def_id.def_id());\n+            let depr = stability::lookup_deprecation(tcx, item_def_id.def_id());\n             encode_stability(rbml_w, stab);\n+            encode_deprecation(rbml_w, depr);\n \n             let trait_item_type =\n                 tcx.impl_or_trait_item(item_def_id.def_id());\n@@ -1407,8 +1441,10 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(nitem));\n         }\n         encode_attributes(rbml_w, &*nitem.attrs);\n-        let stab = stability::lookup(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n+        let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n+        let depr = stability::lookup_deprecation(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         encode_symbol(ecx, rbml_w, nitem.id);\n         encode_method_argument_names(rbml_w, &*fndecl);\n       }\n@@ -1420,8 +1456,10 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         }\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, nitem.id);\n         encode_attributes(rbml_w, &*nitem.attrs);\n-        let stab = stability::lookup(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n+        let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n+        let depr = stability::lookup_deprecation(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n         encode_stability(rbml_w, stab);\n+        encode_deprecation(rbml_w, depr);\n         encode_symbol(ecx, rbml_w, nitem.id);\n         encode_name(rbml_w, nitem.name);\n       }"}, {"sha": "5c88576acb7b45065814adc266d9452ac9a31484", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "patch": "@@ -120,7 +120,7 @@ fn try_inline_def(cx: &DocContext, tcx: &ty::ctxt,\n         attrs: load_attrs(cx, tcx, did),\n         inner: inner,\n         visibility: Some(hir::Public),\n-        stability: stability::lookup(tcx, did).clean(cx),\n+        stability: stability::lookup_stability(tcx, did).clean(cx),\n         def_id: did,\n     });\n     Some(ret)\n@@ -303,7 +303,7 @@ pub fn build_impl(cx: &DocContext,\n             name: None,\n             attrs: attrs,\n             visibility: Some(hir::Inherited),\n-            stability: stability::lookup(tcx, did).clean(cx),\n+            stability: stability::lookup_stability(tcx, did).clean(cx),\n             def_id: did,\n         });\n     }\n@@ -333,7 +333,7 @@ pub fn build_impl(cx: &DocContext,\n                     source: clean::Span::empty(),\n                     attrs: vec![],\n                     visibility: None,\n-                    stability: stability::lookup(tcx, did).clean(cx),\n+                    stability: stability::lookup_stability(tcx, did).clean(cx),\n                     def_id: did\n                 })\n             }\n@@ -381,7 +381,7 @@ pub fn build_impl(cx: &DocContext,\n                     source: clean::Span::empty(),\n                     attrs: vec![],\n                     visibility: None,\n-                    stability: stability::lookup(tcx, did).clean(cx),\n+                    stability: stability::lookup_stability(tcx, did).clean(cx),\n                     def_id: did\n                 })\n             }\n@@ -414,7 +414,7 @@ pub fn build_impl(cx: &DocContext,\n         name: None,\n         attrs: attrs,\n         visibility: Some(hir::Inherited),\n-        stability: stability::lookup(tcx, did).clean(cx),\n+        stability: stability::lookup_stability(tcx, did).clean(cx),\n         def_id: did,\n     });\n "}, {"sha": "942cc135aa8f5086d71018f92482fbb133a2ee69", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "patch": "@@ -62,7 +62,7 @@ mod simplify;\n \n // extract the stability index for a node from tcx, if possible\n fn get_stability(cx: &DocContext, def_id: DefId) -> Option<Stability> {\n-    cx.tcx_opt().and_then(|tcx| stability::lookup(tcx, def_id)).clean(cx)\n+    cx.tcx_opt().and_then(|tcx| stability::lookup_stability(tcx, def_id)).clean(cx)\n }\n \n pub trait Clean<T> {\n@@ -2689,12 +2689,12 @@ impl Clean<Stability> for attr::Stability {\n                 attr::Stable {ref since} => since.to_string(),\n                 _ => \"\".to_string(),\n             },\n-            deprecated_since: match self.depr {\n-                Some(attr::Deprecation {ref since, ..}) => since.to_string(),\n+            deprecated_since: match self.rustc_depr {\n+                Some(attr::RustcDeprecation {ref since, ..}) => since.to_string(),\n                 _=> \"\".to_string(),\n             },\n             reason: {\n-                if let Some(ref depr) = self.depr {\n+                if let Some(ref depr) = self.rustc_depr {\n                     depr.reason.to_string()\n                 } else if let attr::Unstable {reason: Some(ref reason), ..} = self.level {\n                     reason.to_string()\n@@ -2782,7 +2782,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedType<'tcx> {\n             inner: AssociatedTypeItem(bounds, self.ty.clean(cx)),\n             visibility: self.vis.clean(cx),\n             def_id: self.def_id,\n-            stability: stability::lookup(cx.tcx(), self.def_id).clean(cx),\n+            stability: stability::lookup_stability(cx.tcx(), self.def_id).clean(cx),\n         }\n     }\n }"}, {"sha": "89527c54a3851e21adfdb1306fd6a4c4674303f9", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     fn stability(&self, id: ast::NodeId) -> Option<attr::Stability> {\n         self.cx.tcx_opt().and_then(|tcx| {\n             self.cx.map.opt_local_def_id(id)\n-                       .and_then(|def_id| stability::lookup(tcx, def_id))\n+                       .and_then(|def_id| stability::lookup_stability(tcx, def_id))\n                        .cloned()\n         })\n     }"}, {"sha": "d511ce09a36167ad1a92ff4f93f7513b98fc93dd", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 81, "deletions": 10, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "patch": "@@ -398,7 +398,7 @@ pub fn cfg_matches<T: CfgDiag>(cfgs: &[P<MetaItem>],\n pub struct Stability {\n     pub level: StabilityLevel,\n     pub feature: InternedString,\n-    pub depr: Option<Deprecation>,\n+    pub rustc_depr: Option<RustcDeprecation>,\n }\n \n /// The available stability levels.\n@@ -410,11 +410,17 @@ pub enum StabilityLevel {\n }\n \n #[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n-pub struct Deprecation {\n+pub struct RustcDeprecation {\n     pub since: InternedString,\n     pub reason: InternedString,\n }\n \n+#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n+pub struct Deprecation {\n+    pub since: Option<InternedString>,\n+    pub note: Option<InternedString>,\n+}\n+\n impl StabilityLevel {\n     pub fn is_unstable(&self) -> bool { if let Unstable {..} = *self { true } else { false }}\n     pub fn is_stable(&self) -> bool { if let Stable {..} = *self { true } else { false }}\n@@ -427,7 +433,7 @@ fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n     where I: Iterator<Item = &'a Attribute>\n {\n     let mut stab: Option<Stability> = None;\n-    let mut depr: Option<Deprecation> = None;\n+    let mut rustc_depr: Option<RustcDeprecation> = None;\n \n     'outer: for attr in attrs_iter {\n         let tag = attr.name();\n@@ -456,7 +462,7 @@ fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n \n             match tag {\n                 \"rustc_deprecated\" => {\n-                    if depr.is_some() {\n+                    if rustc_depr.is_some() {\n                         diagnostic.span_err(item_sp, \"multiple rustc_deprecated attributes\");\n                         break\n                     }\n@@ -477,7 +483,7 @@ fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n \n                     match (since, reason) {\n                         (Some(since), Some(reason)) => {\n-                            depr = Some(Deprecation {\n+                            rustc_depr = Some(RustcDeprecation {\n                                 since: since,\n                                 reason: reason,\n                             })\n@@ -529,7 +535,7 @@ fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n                                     }\n                                 },\n                                 feature: feature,\n-                                depr: None,\n+                                rustc_depr: None,\n                             })\n                         }\n                         (None, _, _) => {\n@@ -569,7 +575,7 @@ fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n                                     since: since,\n                                 },\n                                 feature: feature,\n-                                depr: None,\n+                                rustc_depr: None,\n                             })\n                         }\n                         (None, _) => {\n@@ -591,12 +597,12 @@ fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n     }\n \n     // Merge the deprecation info into the stability info\n-    if let Some(depr) = depr {\n+    if let Some(rustc_depr) = rustc_depr {\n         if let Some(ref mut stab) = stab {\n             if let Unstable {reason: ref mut reason @ None, ..} = stab.level {\n-                *reason = Some(depr.reason.clone())\n+                *reason = Some(rustc_depr.reason.clone())\n             }\n-            stab.depr = Some(depr);\n+            stab.rustc_depr = Some(rustc_depr);\n         } else {\n             diagnostic.span_err(item_sp, \"rustc_deprecated attribute must be paired with \\\n                                           either stable or unstable attribute\");\n@@ -606,12 +612,77 @@ fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n     stab\n }\n \n+fn find_deprecation_generic<'a, I>(diagnostic: &SpanHandler,\n+                                 attrs_iter: I,\n+                                 item_sp: Span)\n+                                 -> Option<Deprecation>\n+    where I: Iterator<Item = &'a Attribute>\n+{\n+    let mut depr: Option<Deprecation> = None;\n+\n+    'outer: for attr in attrs_iter {\n+        if attr.name() != \"deprecated\" {\n+            continue\n+        }\n+\n+        mark_used(attr);\n+\n+        if depr.is_some() {\n+            diagnostic.span_err(item_sp, \"multiple deprecated attributes\");\n+            break\n+        }\n+\n+        depr = if let Some(metas) = attr.meta_item_list() {\n+            let get = |meta: &MetaItem, item: &mut Option<InternedString>| {\n+                if item.is_some() {\n+                    diagnostic.span_err(meta.span, &format!(\"multiple '{}' items\",\n+                                                             meta.name()));\n+                    return false\n+                }\n+                if let Some(v) = meta.value_str() {\n+                    *item = Some(v);\n+                    true\n+                } else {\n+                    diagnostic.span_err(meta.span, \"incorrect meta item\");\n+                    false\n+                }\n+            };\n+\n+            let mut since = None;\n+            let mut note = None;\n+            for meta in metas {\n+                match &*meta.name() {\n+                    \"since\" => if !get(meta, &mut since) { continue 'outer },\n+                    \"note\" => if !get(meta, &mut note) { continue 'outer },\n+                    _ => {\n+                        diagnostic.span_err(meta.span, &format!(\"unknown meta item '{}'\",\n+                                                                meta.name()));\n+                        continue 'outer\n+                    }\n+                }\n+            }\n+\n+            Some(Deprecation {since: since, note: note})\n+        } else {\n+            Some(Deprecation{since: None, note: None})\n+        }\n+    }\n+\n+    depr\n+}\n+\n /// Find the first stability attribute. `None` if none exists.\n pub fn find_stability(diagnostic: &SpanHandler, attrs: &[Attribute],\n                       item_sp: Span) -> Option<Stability> {\n     find_stability_generic(diagnostic, attrs.iter(), item_sp)\n }\n \n+/// Find the deprecation attribute. `None` if none exists.\n+pub fn find_deprecation(diagnostic: &SpanHandler, attrs: &[Attribute],\n+                      item_sp: Span) -> Option<Deprecation> {\n+    find_deprecation_generic(diagnostic, attrs.iter(), item_sp)\n+}\n+\n pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {\n     let mut set = HashSet::new();\n     for meta in metas {"}, {"sha": "6b138b50f038bc7acd844009a0737b512984e204", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "patch": "@@ -230,6 +230,9 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n \n     // Allow attributes on expressions and non-item statements\n     (\"stmt_expr_attributes\", \"1.6.0\", Some(15701), Active),\n+\n+    // Allows `#[deprecated]` attribute\n+    (\"deprecated\", \"1.6.0\", Some(29935), Active),\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -377,6 +380,7 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n     (\"must_use\", Whitelisted, Ungated),\n     (\"stable\", Whitelisted, Ungated),\n     (\"unstable\", Whitelisted, Ungated),\n+    (\"deprecated\", Whitelisted, Ungated),\n \n     (\"rustc_paren_sugar\", Normal, Gated(\"unboxed_closures\",\n                                         \"unboxed_closures are still evolving\")),\n@@ -539,6 +543,7 @@ pub struct Features {\n     pub braced_empty_structs: bool,\n     pub staged_api: bool,\n     pub stmt_expr_attributes: bool,\n+    pub deprecated: bool,\n }\n \n impl Features {\n@@ -573,6 +578,7 @@ impl Features {\n             braced_empty_structs: false,\n             staged_api: false,\n             stmt_expr_attributes: false,\n+            deprecated: false,\n         }\n     }\n }\n@@ -1151,6 +1157,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n         braced_empty_structs: cx.has_feature(\"braced_empty_structs\"),\n         staged_api: cx.has_feature(\"staged_api\"),\n         stmt_expr_attributes: cx.has_feature(\"stmt_expr_attributes\"),\n+        deprecated: cx.has_feature(\"deprecated\"),\n     }\n }\n "}, {"sha": "61c91590b31fe849742e30fbaeb72d8d7775040a", "filename": "src/test/auxiliary/deprecation-lint.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Ftest%2Fauxiliary%2Fdeprecation-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Ftest%2Fauxiliary%2Fdeprecation-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fdeprecation-lint.rs?ref=e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "patch": "@@ -0,0 +1,87 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(deprecated)]\n+\n+#[deprecated(since = \"1.0.0\", note = \"text\")]\n+pub fn deprecated() {}\n+#[deprecated(since = \"1.0.0\", note = \"text\")]\n+pub fn deprecated_text() {}\n+\n+pub struct MethodTester;\n+\n+impl MethodTester {\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    pub fn method_deprecated(&self) {}\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    pub fn method_deprecated_text(&self) {}\n+}\n+\n+pub trait Trait {\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    fn trait_deprecated(&self) {}\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    fn trait_deprecated_text(&self) {}\n+}\n+\n+impl Trait for MethodTester {}\n+\n+#[deprecated(since = \"1.0.0\", note = \"text\")]\n+pub struct DeprecatedStruct {\n+    pub i: isize\n+}\n+\n+#[deprecated(since = \"1.0.0\", note = \"text\")]\n+pub struct DeprecatedUnitStruct;\n+\n+pub enum Enum {\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    DeprecatedVariant,\n+}\n+\n+#[deprecated(since = \"1.0.0\", note = \"text\")]\n+pub struct DeprecatedTupleStruct(pub isize);\n+\n+pub struct Stable {\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    pub override2: u8,\n+}\n+\n+pub struct Stable2(pub u8, pub u8, #[deprecated(since = \"1.0.0\", note = \"text\")] pub u8);\n+\n+#[deprecated(since = \"1.0.0\", note = \"text\")]\n+pub struct Deprecated {\n+    pub inherit: u8,\n+}\n+\n+#[deprecated(since = \"1.0.0\", note = \"text\")]\n+pub struct Deprecated2(pub u8,\n+                       pub u8,\n+                       pub u8);\n+\n+#[deprecated(since = \"1.0.0\", note = \"text\")]\n+pub mod deprecated_mod {\n+    pub fn deprecated() {}\n+}\n+\n+#[macro_export]\n+macro_rules! macro_test {\n+    () => (deprecated());\n+}\n+\n+#[macro_export]\n+macro_rules! macro_test_arg {\n+    ($func:expr) => ($func);\n+}\n+\n+#[macro_export]\n+macro_rules! macro_test_arg_nested {\n+    ($func:ident) => (macro_test_arg!($func()));\n+}"}, {"sha": "4f4aed21f994d8383c109e69ebd305862528457f", "filename": "src/test/compile-fail/deprecation-in-staged-api.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Ftest%2Fcompile-fail%2Fdeprecation-in-staged-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Ftest%2Fcompile-fail%2Fdeprecation-in-staged-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecation-in-staged-api.rs?ref=e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// #[deprecated] can't be used in staged api\n+\n+#![feature(deprecated, staged_api)]\n+\n+#![stable(feature = \"test_feature\", since = \"1.0.0\")]\n+\n+#[deprecated]\n+fn main() { } //~ERROR `#[deprecated]` cannot be used in staged api"}, {"sha": "2817e06652afba450c734a1a891c1340b2aafa1f", "filename": "src/test/compile-fail/deprecation-lint-2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint-2.rs?ref=e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:deprecation-lint.rs\n+// error-pattern: use of deprecated item\n+\n+#![deny(deprecated)]\n+\n+#[macro_use]\n+extern crate deprecation_lint;\n+\n+use deprecation_lint::*;\n+\n+fn main() {\n+    macro_test!();\n+}"}, {"sha": "7faaa181d392261c913048e9c8c05dbc256131ce", "filename": "src/test/compile-fail/deprecation-lint-3.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint-3.rs?ref=e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:deprecation-lint.rs\n+// error-pattern: use of deprecated item\n+\n+#![deny(deprecated)]\n+#![allow(warnings)]\n+\n+#[macro_use]\n+extern crate deprecation_lint;\n+\n+use deprecation_lint::*;\n+\n+fn main() {\n+    macro_test_arg_nested!(deprecated_text);\n+}"}, {"sha": "db6d5fd63e59b7cd7e9add7bd173c251ff683654", "filename": "src/test/compile-fail/deprecation-lint.rs", "status": "added", "additions": 384, "deletions": 0, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecation-lint.rs?ref=e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "patch": "@@ -0,0 +1,384 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:deprecation-lint.rs\n+\n+#![feature(deprecated)]\n+\n+#![deny(deprecated)]\n+#![allow(warnings)]\n+\n+#[macro_use]\n+extern crate deprecation_lint;\n+\n+mod cross_crate {\n+    use deprecation_lint::*;\n+\n+    fn test() {\n+        type Foo = MethodTester;\n+        let foo = MethodTester;\n+\n+        deprecated(); //~ ERROR use of deprecated item\n+        foo.method_deprecated(); //~ ERROR use of deprecated item\n+        Foo::method_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::method_deprecated(&foo); //~ ERROR use of deprecated item\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+\n+        deprecated_text(); //~ ERROR use of deprecated item: text\n+        foo.method_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Foo::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+\n+        let _ = DeprecatedStruct { //~ ERROR use of deprecated item\n+            i: 0 //~ ERROR use of deprecated item\n+        };\n+\n+        let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item\n+\n+        let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated item\n+\n+        let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated item\n+\n+        // At the moment, the lint checker only checks stability in\n+        // in the arguments of macros.\n+        // Eventually, we will want to lint the contents of the\n+        // macro in the module *defining* it. Also, stability levels\n+        // on macros themselves are not yet linted.\n+        macro_test_arg!(deprecated_text()); //~ ERROR use of deprecated item: text\n+        macro_test_arg!(macro_test_arg!(deprecated_text())); //~ ERROR use of deprecated item: text\n+    }\n+\n+    fn test_method_param<Foo: Trait>(foo: Foo) {\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+    }\n+\n+    fn test_method_object(foo: &Trait) {\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+    }\n+\n+    pub fn foo() {\n+        let x = Stable {\n+            override2: 3,\n+            //~^ ERROR use of deprecated item\n+        };\n+\n+        let _ = x.override2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Stable {\n+            override2: _\n+            //~^ ERROR use of deprecated item\n+        } = x;\n+        // all fine\n+        let Stable { .. } = x;\n+\n+        let x = Stable2(1, 2, 3);\n+\n+        let _ = x.2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Stable2(_,\n+                   _,\n+                   _)\n+            //~^ ERROR use of deprecated item\n+            = x;\n+        // all fine\n+        let Stable2(..) = x;\n+\n+        let x = Deprecated {\n+            //~^ ERROR use of deprecated item\n+            inherit: 1,\n+            //~^ ERROR use of deprecated item\n+        };\n+\n+        let _ = x.inherit;\n+        //~^ ERROR use of deprecated item\n+\n+        let Deprecated {\n+            //~^ ERROR use of deprecated item\n+            inherit: _,\n+            //~^ ERROR use of deprecated item\n+        } = x;\n+\n+        let Deprecated\n+            //~^ ERROR use of deprecated item\n+            { .. } = x;\n+\n+        let x = Deprecated2(1, 2, 3);\n+        //~^ ERROR use of deprecated item\n+\n+        let _ = x.0;\n+        //~^ ERROR use of deprecated item\n+        let _ = x.1;\n+        //~^ ERROR use of deprecated item\n+        let _ = x.2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Deprecated2\n+        //~^ ERROR use of deprecated item\n+            (_,\n+             //~^ ERROR use of deprecated item\n+             _,\n+             //~^ ERROR use of deprecated item\n+             _)\n+             //~^ ERROR use of deprecated item\n+            = x;\n+        let Deprecated2\n+        //~^ ERROR use of deprecated item\n+            // the patterns are all fine:\n+            (..) = x;\n+    }\n+}\n+\n+mod inheritance {\n+    use deprecation_lint::*;\n+\n+    fn test_inheritance() {\n+        deprecated_mod::deprecated(); //~ ERROR use of deprecated item\n+    }\n+}\n+\n+mod this_crate {\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    pub fn deprecated() {}\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    pub fn deprecated_text() {}\n+\n+    pub struct MethodTester;\n+\n+    impl MethodTester {\n+        #[deprecated(since = \"1.0.0\", note = \"text\")]\n+        pub fn method_deprecated(&self) {}\n+        #[deprecated(since = \"1.0.0\", note = \"text\")]\n+        pub fn method_deprecated_text(&self) {}\n+    }\n+\n+    pub trait Trait {\n+        #[deprecated(since = \"1.0.0\", note = \"text\")]\n+        fn trait_deprecated(&self) {}\n+        #[deprecated(since = \"1.0.0\", note = \"text\")]\n+        fn trait_deprecated_text(&self) {}\n+    }\n+\n+    impl Trait for MethodTester {}\n+\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    pub struct DeprecatedStruct {\n+        i: isize\n+    }\n+    pub struct UnstableStruct {\n+        i: isize\n+    }\n+    pub struct StableStruct {\n+        i: isize\n+    }\n+\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    pub struct DeprecatedUnitStruct;\n+\n+    pub enum Enum {\n+        #[deprecated(since = \"1.0.0\", note = \"text\")]\n+        DeprecatedVariant,\n+    }\n+\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    pub struct DeprecatedTupleStruct(isize);\n+\n+    fn test() {\n+        // Only the deprecated cases of the following should generate\n+        // errors, because other stability attributes now have meaning\n+        // only *across* crates, not within a single crate.\n+\n+        type Foo = MethodTester;\n+        let foo = MethodTester;\n+\n+        deprecated(); //~ ERROR use of deprecated item\n+        foo.method_deprecated(); //~ ERROR use of deprecated item\n+        Foo::method_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::method_deprecated(&foo); //~ ERROR use of deprecated item\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+\n+        deprecated_text(); //~ ERROR use of deprecated item: text\n+        foo.method_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Foo::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+\n+        let _ = DeprecatedStruct {\n+            //~^ ERROR use of deprecated item\n+            i: 0 //~ ERROR use of deprecated item\n+        };\n+\n+        let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item\n+\n+        let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated item\n+\n+        let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated item\n+    }\n+\n+    fn test_method_param<Foo: Trait>(foo: Foo) {\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+    }\n+\n+    fn test_method_object(foo: &Trait) {\n+        foo.trait_deprecated(); //~ ERROR use of deprecated item\n+        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+    }\n+\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    fn test_fn_body() {\n+        fn fn_in_body() {}\n+        fn_in_body(); //~ ERROR use of deprecated item: text\n+    }\n+\n+    impl MethodTester {\n+        #[deprecated(since = \"1.0.0\", note = \"text\")]\n+        fn test_method_body(&self) {\n+            fn fn_in_body() {}\n+            fn_in_body(); //~ ERROR use of deprecated item: text\n+        }\n+    }\n+\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    pub trait DeprecatedTrait {\n+        fn dummy(&self) { }\n+    }\n+\n+    struct S;\n+\n+    impl DeprecatedTrait for S { } //~ ERROR use of deprecated item\n+\n+    trait LocalTrait : DeprecatedTrait { } //~ ERROR use of deprecated item\n+}\n+\n+mod this_crate2 {\n+    struct Stable {\n+        #[deprecated(since = \"1.0.0\", note = \"text\")]\n+        override2: u8,\n+    }\n+\n+    struct Stable2(u8,\n+                   u8,\n+                   #[deprecated(since = \"1.0.0\", note = \"text\")] u8);\n+\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    struct Deprecated {\n+        inherit: u8,\n+    }\n+\n+    #[deprecated(since = \"1.0.0\", note = \"text\")]\n+    struct Deprecated2(u8,\n+                       u8,\n+                       u8);\n+\n+    pub fn foo() {\n+        let x = Stable {\n+            override2: 3,\n+            //~^ ERROR use of deprecated item\n+        };\n+\n+        let _ = x.override2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Stable {\n+            override2: _\n+            //~^ ERROR use of deprecated item\n+        } = x;\n+        // all fine\n+        let Stable { .. } = x;\n+\n+        let x = Stable2(1, 2, 3);\n+\n+        let _ = x.2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Stable2(_,\n+                   _,\n+                   _)\n+            //~^ ERROR use of deprecated item\n+            = x;\n+        // all fine\n+        let Stable2(..) = x;\n+\n+        let x = Deprecated {\n+            //~^ ERROR use of deprecated item\n+            inherit: 1,\n+            //~^ ERROR use of deprecated item\n+        };\n+\n+        let _ = x.inherit;\n+        //~^ ERROR use of deprecated item\n+\n+        let Deprecated {\n+            //~^ ERROR use of deprecated item\n+            inherit: _,\n+            //~^ ERROR use of deprecated item\n+        } = x;\n+\n+        let Deprecated\n+            //~^ ERROR use of deprecated item\n+            // the patterns are all fine:\n+            { .. } = x;\n+\n+        let x = Deprecated2(1, 2, 3);\n+        //~^ ERROR use of deprecated item\n+\n+        let _ = x.0;\n+        //~^ ERROR use of deprecated item\n+        let _ = x.1;\n+        //~^ ERROR use of deprecated item\n+        let _ = x.2;\n+        //~^ ERROR use of deprecated item\n+\n+        let Deprecated2\n+        //~^ ERROR use of deprecated item\n+            (_,\n+             //~^ ERROR use of deprecated item\n+             _,\n+             //~^ ERROR use of deprecated item\n+             _)\n+            //~^ ERROR use of deprecated item\n+            = x;\n+        let Deprecated2\n+        //~^ ERROR use of deprecated item\n+            // the patterns are all fine:\n+            (..) = x;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6ee5cd2c7e3cf171887d12ce69db6bbc325c4266", "filename": "src/test/compile-fail/deprecation-sanity.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Ftest%2Fcompile-fail%2Fdeprecation-sanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3ed7b0501a24f4def3aff775c6fbf9481e3c77e/src%2Ftest%2Fcompile-fail%2Fdeprecation-sanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecation-sanity.rs?ref=e3ed7b0501a24f4def3aff775c6fbf9481e3c77e", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Various checks that deprecation attributes are used correctly\n+\n+#![feature(deprecated)]\n+\n+mod bogus_attribute_types_1 {\n+    #[deprecated(since = \"a\", note = \"a\", reason)] //~ ERROR unknown meta item 'reason'\n+    fn f1() { }\n+\n+    #[deprecated(since = \"a\", note)] //~ ERROR incorrect meta item\n+    fn f2() { }\n+\n+    #[deprecated(since, note = \"a\")] //~ ERROR incorrect meta item\n+    fn f3() { }\n+\n+    #[deprecated(since = \"a\", note(b))] //~ ERROR incorrect meta item\n+    fn f5() { }\n+\n+    #[deprecated(since(b), note = \"a\")] //~ ERROR incorrect meta item\n+    fn f6() { }\n+}\n+\n+#[deprecated(since = \"a\", note = \"b\")]\n+#[deprecated(since = \"a\", note = \"b\")]\n+fn multiple1() { } //~ ERROR multiple deprecated attributes\n+\n+#[deprecated(since = \"a\", since = \"b\", note = \"c\")] //~ ERROR multiple 'since' items\n+fn f1() { }\n+\n+fn main() { }"}]}