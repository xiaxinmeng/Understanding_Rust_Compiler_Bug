{"sha": "3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiNjMxNGMzOWJmYzEzYjVhNDFjNTNmMTNjM2ZhZmE3YWQ5MWUwNjI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-08-07T16:47:28Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-08-28T01:46:51Z"}, "message": "librustc: Add support for type parameters in the middle of paths.\n\nFor example, `foo::<T>::bar::<U>`.\n\nThis doesn't enforce that the type parameters are in the right\npositions, however.", "tree": {"sha": "f43929dd9d9874c8cd95a69f7c47313b2bcf055a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f43929dd9d9874c8cd95a69f7c47313b2bcf055a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "html_url": "https://github.com/rust-lang/rust/commit/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c3504799deb78d986f8267f753a87fb9e73a452", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c3504799deb78d986f8267f753a87fb9e73a452", "html_url": "https://github.com/rust-lang/rust/commit/5c3504799deb78d986f8267f753a87fb9e73a452"}], "stats": {"total": 1080, "additions": 692, "deletions": 388}, "files": [{"sha": "429a1c35b3421f7d6b786e34d93de89eff735414", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -17,6 +17,7 @@ use syntax::attr;\n use syntax::codemap::dummy_sp;\n use syntax::codemap;\n use syntax::fold;\n+use syntax::opt_vec;\n \n static STD_VERSION: &'static str = \"0.8-pre\";\n \n@@ -90,12 +91,18 @@ fn inject_libstd_ref(sess: Session, crate: &ast::Crate) -> @ast::Crate {\n             let prelude_path = ast::Path {\n                 span: dummy_sp(),\n                 global: false,\n-                idents: ~[\n-                    sess.ident_of(\"std\"),\n-                    sess.ident_of(\"prelude\")\n+                segments: ~[\n+                    ast::PathSegment {\n+                        identifier: sess.ident_of(\"std\"),\n+                        lifetime: None,\n+                        types: opt_vec::Empty,\n+                    },\n+                    ast::PathSegment {\n+                        identifier: sess.ident_of(\"prelude\"),\n+                        lifetime: None,\n+                        types: opt_vec::Empty,\n+                    },\n                 ],\n-                rp: None,\n-                types: ~[]\n             };\n \n             let vp = @spanned(ast::view_path_glob(prelude_path, n2));"}, {"sha": "e70e58342eba5ab372d400a540159bff95eb8edf", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -16,14 +16,15 @@ use front::config;\n \n use std::vec;\n use syntax::ast_util::*;\n+use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap::{dummy_sp, span, ExpnInfo, NameAndSpan};\n use syntax::codemap;\n use syntax::ext::base::ExtCtxt;\n use syntax::fold;\n+use syntax::opt_vec;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n-use syntax::attr::AttrMetaMethods;\n \n type node_id_gen = @fn() -> ast::NodeId;\n \n@@ -383,19 +384,27 @@ fn nospan<T>(t: T) -> codemap::spanned<T> {\n }\n \n fn path_node(ids: ~[ast::ident]) -> ast::Path {\n-    ast::Path { span: dummy_sp(),\n-                global: false,\n-                idents: ids,\n-                rp: None,\n-                types: ~[] }\n+    ast::Path {\n+        span: dummy_sp(),\n+        global: false,\n+        segments: ids.consume_iter().transform(|identifier| ast::PathSegment {\n+            identifier: identifier,\n+            lifetime: None,\n+            types: opt_vec::Empty,\n+        }).collect()\n+    }\n }\n \n fn path_node_global(ids: ~[ast::ident]) -> ast::Path {\n-    ast::Path { span: dummy_sp(),\n-                 global: true,\n-                 idents: ids,\n-                 rp: None,\n-                 types: ~[] }\n+    ast::Path {\n+        span: dummy_sp(),\n+        global: true,\n+        segments: ids.consume_iter().transform(|identifier| ast::PathSegment {\n+            identifier: identifier,\n+            lifetime: None,\n+            types: opt_vec::Empty,\n+        }).collect()\n+    }\n }\n \n #[cfg(stage0)]"}, {"sha": "1b19384af3364b8f0b4b1ebba59c83cedc9fcc8d", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -988,7 +988,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         match ty.node {\n-            ast::ty_path(ref path, ref bounds, _) if path.idents.len() == 1 => {\n+            ast::ty_path(ref path, ref bounds, _) if path.segments\n+                                                         .len() == 1 => {\n                 assert!(bounds.is_none());\n                 encode_impl_type_basename(ecx, ebml_w,\n                                           ast_util::path_to_ident(path));"}, {"sha": "3606ecd8d24c155a00f4858c6c855b9440d9d4f4", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -138,12 +138,20 @@ fn parse_path(st: &mut PState) -> @ast::Path {\n           ':' => { next(st); next(st); }\n           c => {\n             if c == '(' {\n-                return @ast::Path { span: dummy_sp(),\n-                                    global: false,\n-                                    idents: idents,\n-                                    rp: None,\n-                                    types: ~[] };\n-            } else { idents.push(parse_ident_(st, is_last)); }\n+                return @ast::Path {\n+                    span: dummy_sp(),\n+                    global: false,\n+                    segments: idents.consume_iter().transform(|identifier| {\n+                        ast::PathSegment {\n+                            identifier: identifier,\n+                            lifetime: None,\n+                            types: opt_vec::Empty,\n+                        }\n+                    }).collect()\n+                };\n+            } else {\n+                idents.push(parse_ident_(st, is_last));\n+            }\n           }\n         }\n     };"}, {"sha": "fc779f73060a0c80e9a8123a08bbfd4ad891932d", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -141,7 +141,7 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n             // to handle on-demand instantiation of functions via\n             // foo::<bar> in a const. Currently that is only done on\n             // a path in trans::callee that only works in block contexts.\n-            if pth.types.len() != 0 {\n+            if !pth.segments.iter().all(|segment| segment.types.is_empty()) {\n                 sess.span_err(\n                     e.span, \"paths in constants may only refer to \\\n                              items without type parameters\");"}, {"sha": "ec6bb17fb241c5e809f47ed5f3d9be93d9c9b86a", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -251,21 +251,29 @@ impl PrivacyVisitor {\n         match def {\n             def_static_method(method_id, _, _) => {\n                 debug!(\"found static method def, checking it\");\n-                self.check_method_common(span, method_id, path.idents.last())\n+                self.check_method_common(span,\n+                                         method_id,\n+                                         &path.segments.last().identifier)\n             }\n             def_fn(def_id, _) => {\n                 if def_id.crate == LOCAL_CRATE {\n                     if self.local_item_is_private(span, def_id.node) &&\n                             !self.privileged_items.iter().any(|x| x == &def_id.node) {\n                         self.tcx.sess.span_err(span,\n                                           fmt!(\"function `%s` is private\",\n-                                               token::ident_to_str(path.idents.last())));\n+                                               token::ident_to_str(\n+                                                &path.segments\n+                                                     .last()\n+                                                     .identifier)));\n                     }\n                 } else if csearch::get_item_visibility(self.tcx.sess.cstore,\n                                                        def_id) != public {\n                     self.tcx.sess.span_err(span,\n                                       fmt!(\"function `%s` is private\",\n-                                           token::ident_to_str(path.idents.last())));\n+                                           token::ident_to_str(\n+                                                &path.segments\n+                                                     .last()\n+                                                     .identifier)));\n                 }\n             }\n             _ => {}"}, {"sha": "d6b6a948a57155db396145e565ff43fbc381eb93", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -827,7 +827,7 @@ fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n           Some(&ast::def_trait(did)) |\n           Some(&ast::def_struct(did)) => {\n             if did.crate == ast::LOCAL_CRATE {\n-                if cx.region_is_relevant(&path.rp) {\n+                if cx.region_is_relevant(&path.segments.last().lifetime) {\n                     cx.add_dep(did.node);\n                 }\n             } else {\n@@ -837,7 +837,7 @@ fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n                   Some(variance) => {\n                     debug!(\"reference to external, rp'd type %s\",\n                            pprust::ty_to_str(ty, sess.intr()));\n-                    if cx.region_is_relevant(&path.rp) {\n+                    if cx.region_is_relevant(&path.segments.last().lifetime) {\n                         let rv = cx.add_variance(variance);\n                         cx.add_rp(cx.item_id, rv)\n                     }\n@@ -860,7 +860,7 @@ fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n       ast::ty_path(ref path, _, _) => {\n         // type parameters are---for now, anyway---always invariant\n         do cx.with_ambient_variance(rv_invariant) {\n-            for tp in path.types.iter() {\n+            for tp in path.segments.iter().flat_map(|s| s.types.iter()) {\n                 visitor.visit_ty(tp, cx);\n             }\n         }"}, {"sha": "6ae2ac8cffcff2d931aff9509336d92a0193cffb", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 62, "deletions": 39, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -1277,7 +1277,7 @@ impl Resolver {\n                     &Ty {\n                         node: ty_path(ref path, _, _),\n                         _\n-                    } if path.idents.len() == 1 => {\n+                    } if path.segments.len() == 1 => {\n                         let name = path_to_ident(path);\n \n                         let new_parent = match parent.children.find(&name) {\n@@ -1476,20 +1476,22 @@ impl Resolver {\n                     let mut module_path = ~[];\n                     match view_path.node {\n                         view_path_simple(_, ref full_path, _) => {\n-                            let path_len = full_path.idents.len();\n+                            let path_len = full_path.segments.len();\n                             assert!(path_len != 0);\n \n-                            for (i, ident) in full_path.idents.iter().enumerate() {\n+                            for (i, segment) in full_path.segments\n+                                                         .iter()\n+                                                         .enumerate() {\n                                 if i != path_len - 1 {\n-                                    module_path.push(*ident);\n+                                    module_path.push(segment.identifier)\n                                 }\n                             }\n                         }\n \n                         view_path_glob(ref module_ident_path, _) |\n                         view_path_list(ref module_ident_path, _, _) => {\n-                            for ident in module_ident_path.idents.iter() {\n-                                module_path.push(*ident);\n+                            for segment in module_ident_path.segments.iter() {\n+                                module_path.push(segment.identifier)\n                             }\n                         }\n                     }\n@@ -1498,7 +1500,8 @@ impl Resolver {\n                     let module_ = self.get_module_from_parent(parent);\n                     match view_path.node {\n                         view_path_simple(binding, ref full_path, id) => {\n-                            let source_ident = *full_path.idents.last();\n+                            let source_ident =\n+                                full_path.segments.last().identifier;\n                             let subclass = @SingleImport(binding,\n                                                          source_ident);\n                             self.build_import_directive(privacy,\n@@ -2109,6 +2112,14 @@ impl Resolver {\n         return result;\n     }\n \n+    fn path_idents_to_str(@mut self, path: &Path) -> ~str {\n+        let identifiers: ~[ast::ident] = path.segments\n+                                             .iter()\n+                                             .transform(|seg| seg.identifier)\n+                                             .collect();\n+        self.idents_to_str(identifiers)\n+    }\n+\n     pub fn import_directive_subclass_to_str(@mut self,\n                                             subclass: ImportDirectiveSubclass)\n                                             -> @str {\n@@ -3841,8 +3852,7 @@ impl Resolver {\n                                    reference_type: TraitReferenceType) {\n         match self.resolve_path(id, &trait_reference.path, TypeNS, true, visitor) {\n             None => {\n-                let path_str = self.idents_to_str(trait_reference.path.idents);\n-\n+                let path_str = self.path_idents_to_str(&trait_reference.path);\n                 let usage_str = match reference_type {\n                     TraitBoundingTypeParameter => \"bound type parameter with\",\n                     TraitImplementation        => \"implement\",\n@@ -4141,8 +4151,8 @@ impl Resolver {\n                 let mut result_def = None;\n \n                 // First, check to see whether the name is a primitive type.\n-                if path.idents.len() == 1 {\n-                    let name = *path.idents.last();\n+                if path.segments.len() == 1 {\n+                    let name = path.segments.last().identifier;\n \n                     match self.primitive_type_table\n                             .primitive_types\n@@ -4165,7 +4175,7 @@ impl Resolver {\n                                 debug!(\"(resolving type) resolved `%s` to \\\n                                         type %?\",\n                                        self.session.str_of(\n-                                            *path.idents.last()),\n+                                            path.segments.last().identifier),\n                                        def);\n                                 result_def = Some(def);\n                             }\n@@ -4184,14 +4194,15 @@ impl Resolver {\n                         // Write the result into the def map.\n                         debug!(\"(resolving type) writing resolution for `%s` \\\n                                 (id %d)\",\n-                               self.idents_to_str(path.idents),\n+                               self.path_idents_to_str(path),\n                                path_id);\n                         self.record_def(path_id, def);\n                     }\n                     None => {\n                         self.resolve_error\n-                            (ty.span, fmt!(\"use of undeclared type name `%s`\",\n-                                           self.idents_to_str(path.idents)));\n+                            (ty.span,\n+                             fmt!(\"use of undeclared type name `%s`\",\n+                                  self.path_idents_to_str(path)))\n                     }\n                 }\n \n@@ -4230,7 +4241,7 @@ impl Resolver {\n         do walk_pat(pattern) |pattern| {\n             match pattern.node {\n                 pat_ident(binding_mode, ref path, _)\n-                        if !path.global && path.idents.len() == 1 => {\n+                        if !path.global && path.segments.len() == 1 => {\n \n                     // The meaning of pat_ident with no type parameters\n                     // depends on whether an enum variant or unit-like struct\n@@ -4241,7 +4252,7 @@ impl Resolver {\n                     // such a value is simply disallowed (since it's rarely\n                     // what you want).\n \n-                    let ident = path.idents[0];\n+                    let ident = path.segments[0].identifier;\n \n                     match self.resolve_bare_identifier_pattern(ident) {\n                         FoundStructOrEnumVariant(def)\n@@ -4351,7 +4362,9 @@ impl Resolver {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for ty in path.types.iter() {\n+                    for ty in path.segments\n+                                  .iter()\n+                                  .flat_map_(|seg| seg.types.iter()) {\n                         self.resolve_type(ty, visitor);\n                     }\n                 }\n@@ -4375,7 +4388,7 @@ impl Resolver {\n                                 path.span,\n                                 fmt!(\"`%s` is not an enum variant or constant\",\n                                      self.session.str_of(\n-                                         *path.idents.last())));\n+                                         path.segments.last().identifier)))\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n@@ -4384,7 +4397,9 @@ impl Resolver {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for ty in path.types.iter() {\n+                    for ty in path.segments\n+                                  .iter()\n+                                  .flat_map_(|s| s.types.iter()) {\n                         self.resolve_type(ty, visitor);\n                     }\n                 }\n@@ -4402,8 +4417,10 @@ impl Resolver {\n                             self.resolve_error(\n                                 path.span,\n                                 fmt!(\"`%s` is not an enum variant, struct or const\",\n-                                     self.session.str_of(\n-                                         *path.idents.last())));\n+                                     self.session\n+                                         .str_of(path.segments\n+                                                     .last()\n+                                                     .identifier)));\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n@@ -4413,7 +4430,9 @@ impl Resolver {\n                     }\n \n                     // Check the types in the path pattern.\n-                    for ty in path.types.iter() {\n+                    for ty in path.segments\n+                                  .iter()\n+                                  .flat_map_(|s| s.types.iter()) {\n                         self.resolve_type(ty, visitor);\n                     }\n                 }\n@@ -4448,7 +4467,7 @@ impl Resolver {\n                             self.resolve_error(\n                                 path.span,\n                                 fmt!(\"`%s` does not name a structure\",\n-                                     self.idents_to_str(path.idents)));\n+                                     self.path_idents_to_str(path)));\n                         }\n                     }\n                 }\n@@ -4510,7 +4529,7 @@ impl Resolver {\n                         visitor: &mut ResolveVisitor)\n                         -> Option<def> {\n         // First, resolve the types.\n-        for ty in path.types.iter() {\n+        for ty in path.segments.iter().flat_map_(|s| s.types.iter()) {\n             self.resolve_type(ty, visitor);\n         }\n \n@@ -4520,12 +4539,17 @@ impl Resolver {\n                                                     namespace);\n         }\n \n-        let unqualified_def = self.resolve_identifier(\n-            *path.idents.last(), namespace, check_ribs, path.span);\n+        let unqualified_def = self.resolve_identifier(path.segments\n+                                                          .last()\n+                                                          .identifier,\n+                                                      namespace,\n+                                                      check_ribs,\n+                                                      path.span);\n \n-        if path.idents.len() > 1 {\n-            let def = self.resolve_module_relative_path(\n-                path, self.xray_context, namespace);\n+        if path.segments.len() > 1 {\n+            let def = self.resolve_module_relative_path(path,\n+                                                        self.xray_context,\n+                                                        namespace);\n             match (def, unqualified_def) {\n                 (Some(d), Some(ud)) if d == ud => {\n                     self.session.add_lint(unnecessary_qualification,\n@@ -4640,12 +4664,12 @@ impl Resolver {\n \n     pub fn intern_module_part_of_path(@mut self, path: &Path) -> ~[ident] {\n         let mut module_path_idents = ~[];\n-        for (index, ident) in path.idents.iter().enumerate() {\n-            if index == path.idents.len() - 1 {\n+        for (index, segment) in path.segments.iter().enumerate() {\n+            if index == path.segments.len() - 1 {\n                 break;\n             }\n \n-            module_path_idents.push(*ident);\n+            module_path_idents.push(segment.identifier);\n         }\n \n         return module_path_idents;\n@@ -4681,7 +4705,7 @@ impl Resolver {\n             }\n         }\n \n-        let name = *path.idents.last();\n+        let name = path.segments.last().identifier;\n         let def = match self.resolve_definition_of_name_in_module(containing_module,\n                                                         name,\n                                                         namespace,\n@@ -4749,7 +4773,7 @@ impl Resolver {\n             }\n         }\n \n-        let name = *path.idents.last();\n+        let name = path.segments.last().identifier;\n         match self.resolve_definition_of_name_in_module(containing_module,\n                                                         name,\n                                                         namespace,\n@@ -4969,7 +4993,7 @@ impl Resolver {\n                     Some(def) => {\n                         // Write the result into the def map.\n                         debug!(\"(resolving expr) resolved `%s`\",\n-                               self.idents_to_str(path.idents));\n+                               self.path_idents_to_str(path));\n \n                         // First-class methods are not supported yet; error\n                         // out here.\n@@ -4989,8 +5013,7 @@ impl Resolver {\n                         self.record_def(expr.id, def);\n                     }\n                     None => {\n-                        let wrong_name = self.idents_to_str(\n-                            path.idents);\n+                        let wrong_name = self.path_idents_to_str(path);\n                         if self.name_exists_in_scope_struct(wrong_name) {\n                             self.resolve_error(expr.span,\n                                         fmt!(\"unresolved name `%s`. \\\n@@ -5066,7 +5089,7 @@ impl Resolver {\n                         self.resolve_error(\n                             path.span,\n                             fmt!(\"`%s` does not name a structure\",\n-                                 self.idents_to_str(path.idents)));\n+                                 self.path_idents_to_str(path)));\n                     }\n                 }\n "}, {"sha": "0dfce6f42c32970d0cc7cd6d837819c0609a1171", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -559,7 +559,9 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n             v\n           }\n           ast::expr_path(ref pth) => {\n-            assert_eq!(pth.types.len(), 0);\n+            // Assert that there are no type parameters in this path.\n+            assert!(pth.segments.iter().all(|seg| seg.types.is_empty()));\n+\n             let tcx = cx.tcx;\n             match tcx.def_map.find(&e.id) {\n                 Some(&ast::def_fn(def_id, _purity)) => {"}, {"sha": "6425867425f5d47bea71a2cd05b50ed0a99595f9", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -63,7 +63,6 @@ use middle::typeck::rscope::RegionParamNames;\n use middle::typeck::lookup_def_tcx;\n \n use std::result;\n-use std::vec;\n use syntax::abi::AbiSet;\n use syntax::{ast, ast_util};\n use syntax::codemap::span;\n@@ -150,7 +149,8 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Clone + 'static>(\n     // If the type is parameterized by the this region, then replace this\n     // region with the current anon region binding (in other words,\n     // whatever & would get replaced with).\n-    let regions = match (&decl_generics.region_param, &path.rp) {\n+    let regions = match (&decl_generics.region_param,\n+                         &path.segments.last().lifetime) {\n         (&None, &None) => {\n             opt_vec::Empty\n         }\n@@ -169,20 +169,34 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Clone + 'static>(\n         }\n         (&Some(_), &Some(_)) => {\n             opt_vec::with(\n-                ast_region_to_region(this, rscope, path.span, &path.rp))\n+                ast_region_to_region(this,\n+                                     rscope,\n+                                     path.span,\n+                                     &path.segments.last().lifetime))\n         }\n     };\n \n     // Convert the type parameters supplied by the user.\n-    if !vec::same_length(*decl_generics.type_param_defs, path.types) {\n+    let supplied_type_parameter_count =\n+        path.segments.iter().flat_map_(|s| s.types.iter()).len_();\n+    if decl_generics.type_param_defs.len() != supplied_type_parameter_count {\n         this.tcx().sess.span_fatal(\n             path.span,\n             fmt!(\"wrong number of type arguments: expected %u but found %u\",\n-                 decl_generics.type_param_defs.len(), path.types.len()));\n+                 decl_generics.type_param_defs.len(),\n+                 supplied_type_parameter_count));\n+    }\n+    let tps = path.segments\n+                  .iter()\n+                  .flat_map_(|s| s.types.iter())\n+                  .transform(|a_t| ast_ty_to_ty(this, rscope, a_t))\n+                  .collect();\n+\n+    substs {\n+        regions: ty::NonerasedRegions(regions),\n+        self_ty: self_ty,\n+        tps: tps\n     }\n-    let tps = path.types.map(|a_t| ast_ty_to_ty(this, rscope, a_t));\n-\n-    substs {regions:ty::NonerasedRegions(regions), self_ty:self_ty, tps:tps}\n }\n \n pub fn ast_path_to_substs_and_ty<AC:AstConv,\n@@ -325,15 +339,15 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Clone + 'static>(\n                        path: &ast::Path,\n                        flags: uint) {\n         if (flags & NO_TPS) != 0u {\n-            if path.types.len() > 0u {\n+            if !path.segments.iter().all(|s| s.types.is_empty()) {\n                 tcx.sess.span_err(\n                     path.span,\n                     \"type parameters are not allowed on this type\");\n             }\n         }\n \n         if (flags & NO_REGIONS) != 0u {\n-            if path.rp.is_some() {\n+            if path.segments.last().lifetime.is_some() {\n                 tcx.sess.span_err(\n                     path.span,\n                     \"region parameters are not allowed on this type\");"}, {"sha": "fcd62eb92b5127709854e4932b665f11afce2516", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -3146,7 +3146,10 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n     debug!(\">>> instantiate_path\");\n \n     let ty_param_count = tpt.generics.type_param_defs.len();\n-    let ty_substs_len = pth.types.len();\n+    let mut ty_substs_len = 0;\n+    for segment in pth.segments.iter() {\n+        ty_substs_len += segment.types.len()\n+    }\n \n     debug!(\"tpt=%s ty_param_count=%? ty_substs_len=%?\",\n            tpt.repr(fcx.tcx()),\n@@ -3155,7 +3158,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n \n     // determine the region bound, using the value given by the user\n     // (if any) and otherwise using a fresh region variable\n-    let regions = match pth.rp {\n+    let regions = match pth.segments.last().lifetime {\n         Some(_) => { // user supplied a lifetime parameter...\n             match tpt.generics.region_param {\n                 None => { // ...but the type is not lifetime parameterized!\n@@ -3165,7 +3168,10 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n                 }\n                 Some(_) => { // ...and the type is lifetime parameterized, ok.\n                     opt_vec::with(\n-                        ast_region_to_region(fcx, fcx, span, &pth.rp))\n+                        ast_region_to_region(fcx,\n+                                             fcx,\n+                                             span,\n+                                             &pth.segments.last().lifetime))\n                 }\n             }\n         }\n@@ -3204,12 +3210,18 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n         }\n         fcx.infcx().next_ty_vars(ty_param_count)\n     } else {\n-        pth.types.map(|aty| fcx.to_ty(aty))\n+        pth.segments\n+           .iter()\n+           .flat_map_(|s| s.types.iter())\n+           .transform(|aty| fcx.to_ty(aty))\n+           .collect()\n     };\n \n-    let substs = substs {regions: ty::NonerasedRegions(regions),\n-                         self_ty: None,\n-                         tps: tps };\n+    let substs = substs {\n+        regions: ty::NonerasedRegions(regions),\n+        self_ty: None,\n+        tps: tps\n+    };\n     fcx.write_ty_substs(node_id, tpt.ty, substs);\n \n     debug!(\"<<<\");"}, {"sha": "0a13f1a8a5e8f86bfa7c4cf0a7f534b843538d31", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -109,12 +109,21 @@ pub struct Path {\n     /// A `::foo` path, is relative to the crate root rather than current\n     /// module (like paths in an import).\n     global: bool,\n-    /// The segments in the path (the things separated by ::)\n-    idents: ~[ident],\n-    /// \"Region parameter\", currently only one lifetime is allowed in a path.\n-    rp: Option<Lifetime>,\n-    /// These are the type parameters, ie, the `a, b` in `foo::bar::<a, b>`\n-    types: ~[Ty],\n+    /// The segments in the path: the things separated by `::`.\n+    segments: ~[PathSegment],\n+}\n+\n+/// A segment of a path: an identifier, an optional lifetime, and a set of\n+/// types.\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+pub struct PathSegment {\n+    /// The identifier portion of this path segment.\n+    identifier: ident,\n+    /// The lifetime parameter for this path segment. Currently only one\n+    /// lifetime parameter is allowed.\n+    lifetime: Option<Lifetime>,\n+    /// The type parameters for this path segment, if present.\n+    types: OptVec<Ty>,\n }\n \n pub type CrateNum = int;"}, {"sha": "2fe42af65ca17aefd9cd25c71bb8b0fa597ab66d", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -28,8 +28,8 @@ pub fn path_name_i(idents: &[ident]) -> ~str {\n     idents.map(|i| token::interner_get(i.name)).connect(\"::\")\n }\n \n-pub fn path_to_ident(p: &Path) -> ident {\n-    *p.idents.last()\n+pub fn path_to_ident(path: &Path) -> ident {\n+    path.segments.last().identifier\n }\n \n pub fn local_def(id: NodeId) -> def_id {\n@@ -217,12 +217,18 @@ pub fn default_block(\n     }\n }\n \n-pub fn ident_to_path(s: span, i: ident) -> Path {\n-    ast::Path { span: s,\n-                 global: false,\n-                 idents: ~[i],\n-                 rp: None,\n-                 types: ~[] }\n+pub fn ident_to_path(s: span, identifier: ident) -> Path {\n+    ast::Path {\n+        span: s,\n+        global: false,\n+        segments: ~[\n+            ast::PathSegment {\n+                identifier: identifier,\n+                lifetime: None,\n+                types: opt_vec::Empty,\n+            }\n+        ],\n+    }\n }\n \n pub fn ident_to_pat(id: NodeId, s: span, i: ident) -> @pat {\n@@ -420,7 +426,7 @@ impl IdVisitor {\n impl Visitor<()> for IdVisitor {\n     fn visit_mod(&mut self,\n                  module: &_mod,\n-                 _span: span,\n+                 _: span,\n                  node_id: NodeId,\n                  env: ()) {\n         (self.visit_callback)(node_id);"}, {"sha": "7432cf80a41c3756ea280ca155a05e869ac639ee", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -329,20 +329,6 @@ pub fn expr_to_str(cx: @ExtCtxt, expr: @ast::expr, err_msg: &str) -> @str {\n     }\n }\n \n-pub fn expr_to_ident(cx: @ExtCtxt,\n-                     expr: @ast::expr,\n-                     err_msg: &str) -> ast::ident {\n-    match expr.node {\n-      ast::expr_path(ref p) => {\n-        if p.types.len() > 0u || p.idents.len() != 1u {\n-            cx.span_fatal(expr.span, err_msg);\n-        }\n-        return p.idents[0];\n-      }\n-      _ => cx.span_fatal(expr.span, err_msg)\n-    }\n-}\n-\n pub fn check_zero_tts(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree],\n                       name: &str) {\n     if tts.len() != 0 {\n@@ -353,15 +339,15 @@ pub fn check_zero_tts(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree],\n pub fn get_single_str_from_tts(cx: @ExtCtxt,\n                                sp: span,\n                                tts: &[ast::token_tree],\n-                               name: &str) -> @str {\n+                               name: &str)\n+                               -> @str {\n     if tts.len() != 1 {\n         cx.span_fatal(sp, fmt!(\"%s takes 1 argument.\", name));\n     }\n \n     match tts[0] {\n         ast::tt_tok(_, token::LIT_STR(ident)) => cx.str_of(ident),\n-        _ =>\n-        cx.span_fatal(sp, fmt!(\"%s requires a string.\", name))\n+        _ => cx.span_fatal(sp, fmt!(\"%s requires a string.\", name)),\n     }\n }\n "}, {"sha": "a62a1d121e24bf5b2649fb7edbd2bf7c9fc465af", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -233,18 +233,31 @@ impl AstBuilder for @ExtCtxt {\n     fn path_global(&self, span: span, strs: ~[ast::ident]) -> ast::Path {\n         self.path_all(span, true, strs, None, ~[])\n     }\n-    fn path_all(&self, sp: span,\n+    fn path_all(&self,\n+                sp: span,\n                 global: bool,\n-                idents: ~[ast::ident],\n+                mut idents: ~[ast::ident],\n                 rp: Option<ast::Lifetime>,\n                 types: ~[ast::Ty])\n-        -> ast::Path {\n+                -> ast::Path {\n+        let last_identifier = idents.pop();\n+        let mut segments: ~[ast::PathSegment] = idents.consume_iter()\n+                                                      .transform(|ident| {\n+            ast::PathSegment {\n+                identifier: ident,\n+                lifetime: None,\n+                types: opt_vec::Empty,\n+            }\n+        }).collect();\n+        segments.push(ast::PathSegment {\n+            identifier: last_identifier,\n+            lifetime: rp,\n+            types: opt_vec::from(types),\n+        });\n         ast::Path {\n             span: sp,\n             global: global,\n-            idents: idents,\n-            rp: rp,\n-            types: types\n+            segments: segments,\n         }\n     }\n "}, {"sha": "477f3fde99c734c1d23f8650cc317314180bed10", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -12,6 +12,7 @@ use ast;\n use codemap::span;\n use ext::base::*;\n use ext::base;\n+use opt_vec;\n use parse::token;\n use parse::token::{str_to_ident};\n \n@@ -39,9 +40,13 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n             ast::Path {\n                  span: sp,\n                  global: false,\n-                 idents: ~[res],\n-                 rp: None,\n-                 types: ~[],\n+                 segments: ~[\n+                    ast::PathSegment {\n+                        identifier: res,\n+                        lifetime: None,\n+                        types: opt_vec::Empty,\n+                    }\n+                ]\n             }\n         ),\n         span: sp,"}, {"sha": "86639c6f121e8c92ff0ca09baeb55e2301e6db57", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -19,6 +19,7 @@ use codemap;\n use codemap::{span, spanned, ExpnInfo, NameAndSpan};\n use ext::base::*;\n use fold::*;\n+use opt_vec;\n use parse;\n use parse::{parse_item_from_source_str};\n use parse::token;\n@@ -42,13 +43,13 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n             match (*mac).node {\n                 // Token-tree macros:\n                 mac_invoc_tt(ref pth, ref tts) => {\n-                    if (pth.idents.len() > 1u) {\n+                    if (pth.segments.len() > 1u) {\n                         cx.span_fatal(\n                             pth.span,\n                             fmt!(\"expected macro name without module \\\n                                   separators\"));\n                     }\n-                    let extname = &pth.idents[0];\n+                    let extname = &pth.segments[0].identifier;\n                     let extnamestr = ident_to_str(extname);\n                     // leaving explicit deref here to highlight unbox op:\n                     match (*extsbox).find(&extname.name) {\n@@ -143,9 +144,13 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                 ast::Path {\n                     span: span,\n                     global: false,\n-                    idents: ~[ident],\n-                    rp: None,\n-                    types: ~[]\n+                    segments: ~[\n+                        ast::PathSegment {\n+                            identifier: ident,\n+                            lifetime: None,\n+                            types: opt_vec::Empty,\n+                        }\n+                    ],\n                 }\n             }\n \n@@ -368,7 +373,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n         _ => cx.span_bug(it.span, \"invalid item macro invocation\")\n     };\n \n-    let extname = &pth.idents[0];\n+    let extname = &pth.segments[0].identifier;\n     let extnamestr = ident_to_str(extname);\n     let expanded = match (*extsbox).find(&extname.name) {\n         None => cx.span_fatal(pth.span,\n@@ -459,13 +464,13 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n         }\n         _ => return orig(s, sp, fld)\n     };\n-    if (pth.idents.len() > 1u) {\n+    if (pth.segments.len() > 1u) {\n         cx.span_fatal(\n             pth.span,\n             fmt!(\"expected macro name without module \\\n                   separators\"));\n     }\n-    let extname = &pth.idents[0];\n+    let extname = &pth.segments[0].identifier;\n     let extnamestr = ident_to_str(extname);\n     let (fully_expanded, sp) = match (*extsbox).find(&extname.name) {\n         None =>\n@@ -534,10 +539,14 @@ impl Visitor<()> for NewNameFinderContext {\n                     // a path of length one:\n                     &ast::Path {\n                         global: false,\n-                        idents: [id],\n                         span: _,\n-                        rp: _,\n-                        types: _\n+                        segments: [\n+                            ast::PathSegment {\n+                                identifier: id,\n+                                lifetime: _,\n+                                types: _\n+                            }\n+                        ]\n                     } => self.ident_accumulator.push(id),\n                     // I believe these must be enums...\n                     _ => ()"}, {"sha": "327ee331c3814fe6491f514cbe04eb0703b0a1ca", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -16,8 +16,8 @@ use codemap::{BytePos, mk_sp};\n use codemap;\n use parse::lexer::*; //resolve bug?\n use parse::ParseSess;\n-use parse::parser::Parser;\n use parse::attr::parser_attr;\n+use parse::parser::{LifetimeAndTypesWithoutColons, Parser};\n use parse::token::{Token, EOF, to_str, nonterminal, get_ident_interner, ident_to_str};\n use parse::token;\n \n@@ -430,7 +430,9 @@ pub fn parse_nt(p: &Parser, name: &str) -> nonterminal {\n         _ => p.fatal(~\"expected ident, found \"\n                      + token::to_str(get_ident_interner(), p.token))\n       },\n-      \"path\" => token::nt_path(~p.parse_path_with_tps(false)),\n+      \"path\" => {\n+        token::nt_path(~p.parse_path(LifetimeAndTypesWithoutColons).path)\n+      }\n       \"attr\" => token::nt_attr(@p.parse_attribute(false)),\n       \"tt\" => {\n         *p.quote_depth += 1u; //but in theory, non-quoted tts might be useful"}, {"sha": "458737e2fbf0bad484310ff5336bd2628942aa4f", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -765,9 +765,11 @@ fn noop_fold_path(p: &Path, fld: @ast_fold) -> Path {\n     ast::Path {\n         span: fld.new_span(p.span),\n         global: p.global,\n-        idents: p.idents.map(|x| fld.fold_ident(*x)),\n-        rp: p.rp,\n-        types: p.types.map(|x| fld.fold_ty(x)),\n+        segments: p.segments.map(|segment| ast::PathSegment {\n+            identifier: fld.fold_ident(segment.identifier),\n+            lifetime: segment.lifetime,\n+            types: segment.types.map(|typ| fld.fold_ty(typ)),\n+        })\n     }\n }\n "}, {"sha": "56576ee359960b0a40f5fcedaab5a899def08679", "filename": "src/libsyntax/oldvisit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Foldvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Foldvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Foldvisit.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -284,7 +284,11 @@ pub fn visit_ty<E:Clone>(t: &Ty, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_path<E:Clone>(p: &Path, (e, v): (E, vt<E>)) {\n-    for tp in p.types.iter() { (v.visit_ty)(tp, (e.clone(), v)); }\n+    for segment in p.segments.iter() {\n+        for typ in segment.types.iter() {\n+            (v.visit_ty)(typ, (e.clone(), v))\n+        }\n+    }\n }\n \n pub fn visit_pat<E:Clone>(p: &pat, (e, v): (E, vt<E>)) {"}, {"sha": "73e17f551c9f72fc0c8a3109836b3992508efe5b", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 149, "deletions": 78, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -361,27 +361,47 @@ mod test {\n         span{lo:BytePos(a),hi:BytePos(b),expn_info:None}\n     }\n \n-    #[test] fn path_exprs_1 () {\n+    #[test] fn path_exprs_1() {\n         assert_eq!(string_to_expr(@\"a\"),\n-                   @ast::expr{id:1,\n-                              node:ast::expr_path(ast::Path {span:sp(0,1),\n-                                                              global:false,\n-                                                              idents:~[str_to_ident(\"a\")],\n-                                                              rp:None,\n-                                                              types:~[]}),\n-                              span:sp(0,1)})\n+                   @ast::expr{\n+                    id: 1,\n+                    node: ast::expr_path(ast::Path {\n+                        span: sp(0, 1),\n+                        global: false,\n+                        segments: ~[\n+                            ast::PathSegment {\n+                                identifier: str_to_ident(\"a\"),\n+                                lifetime: None,\n+                                types: ~[],\n+                            }\n+                        ],\n+                    }),\n+                    span: sp(0, 1)\n+                   })\n     }\n \n     #[test] fn path_exprs_2 () {\n         assert_eq!(string_to_expr(@\"::a::b\"),\n-                   @ast::expr{id:1,\n-                               node:ast::expr_path(\n-                                    ast::Path {span:sp(0,6),\n-                                               global:true,\n-                                               idents:strs_to_idents(~[\"a\",\"b\"]),\n-                                               rp:None,\n-                                               types:~[]}),\n-                              span:sp(0,6)})\n+                   @ast::expr {\n+                    id:1,\n+                    node: ast::expr_path(ast::Path {\n+                            span: sp(0, 6),\n+                            global: true,\n+                            segments: ~[\n+                                ast::PathSegment {\n+                                    identifier: str_to_ident(\"a\"),\n+                                    lifetime: None,\n+                                    types: ~[],\n+                                },\n+                                ast::PathSegment {\n+                                    identifier: str_to_ident(\"b\"),\n+                                    lifetime: None,\n+                                    types: ~[],\n+                                }\n+                            ]\n+                        },\n+                        span: sp(0, 6))\n+                   })\n     }\n \n     #[should_fail]\n@@ -420,32 +440,43 @@ mod test {\n \n     #[test] fn ret_expr() {\n         assert_eq!(string_to_expr(@\"return d\"),\n-                   @ast::expr{id:2,\n-                              node:ast::expr_ret(\n-                                  Some(@ast::expr{id:1,\n-                                                  node:ast::expr_path(\n-                                                       ast::Path{span:sp(7,8),\n-                                                                 global:false,\n-                                                                 idents:~[str_to_ident(\"d\")],\n-                                                                 rp:None,\n-                                                                 types:~[]\n-                                                                }),\n-                                                  span:sp(7,8)})),\n-                              span:sp(0,8)})\n+                   @ast::expr{\n+                    id:2,\n+                    node:ast::expr_ret(Some(@ast::expr{\n+                        id:1,\n+                        node:ast::expr_path(ast::Path{\n+                            span: sp(7, 8),\n+                            global: false,\n+                            segments: ~[\n+                                ast::PathSegment {\n+                                    identifier: str_to_ident(\"d\"),\n+                                    lifetime: None,\n+                                    types: opt_vec::Empty,\n+                                }\n+                            ],\n+                        }),\n+                        span:sp(7,8)\n+                    })),\n+                    span:sp(0,8)\n+                   })\n     }\n \n     #[test] fn parse_stmt_1 () {\n         assert_eq!(string_to_stmt(@\"b;\"),\n                    @spanned{\n-                       node: ast::stmt_expr(@ast::expr{\n+                       node: ast::stmt_expr(@ast::expr {\n                            id: 1,\n-                           node: ast::expr_path(\n-                                ast::Path{\n-                                   span:sp(0,1),\n-                                   global:false,\n-                                   idents:~[str_to_ident(\"b\")],\n-                                   rp:None,\n-                                   types: ~[]}),\n+                           node: ast::expr_path(ast::Path {\n+                               span:sp(0,1),\n+                               global:false,\n+                               segments: ~[\n+                                ast::PathSegment {\n+                                    identifier: str_to_ident(\"b\"),\n+                                    lifetime: None,\n+                                    types: opt_vec::Empty,\n+                                }\n+                               ],\n+                            }),\n                            span: sp(0,1)},\n                                             2), // fixme\n                        span: sp(0,1)})\n@@ -460,15 +491,20 @@ mod test {\n         let parser = string_to_parser(@\"b\");\n         assert_eq!(parser.parse_pat(),\n                    @ast::pat{id:1, // fixme\n-                             node: ast::pat_ident(ast::bind_infer,\n-                                                   ast::Path{\n-                                                      span:sp(0,1),\n-                                                      global:false,\n-                                                      idents:~[str_to_ident(\"b\")],\n-                                                      rp: None,\n-                                                      types: ~[]},\n-                                                  None // no idea\n-                                                 ),\n+                             node: ast::pat_ident(\n+                                ast::bind_infer,\n+                                ast::Path {\n+                                    span:sp(0,1),\n+                                    global:false,\n+                                    segments: ~[\n+                                        ast::PathSegment {\n+                                            identifier: str_to_ident(\"b\"),\n+                                            lifetime: None,\n+                                            types: opt_vec::Empty,\n+                                        }\n+                                    ],\n+                                },\n+                                None /* no idea */),\n                              span: sp(0,1)});\n         parser_done(parser);\n     }\n@@ -483,21 +519,33 @@ mod test {\n                                         span:sp(4,4), // this is bizarre...\n                                         // check this in the original parser?\n                                         global:false,\n-                                        idents:~[str_to_ident(\"int\")],\n-                                        rp: None,\n-                                        types: ~[]},\n-                                                       None, 2),\n+                                        segments: ~[\n+                                            ast::PathSegment {\n+                                                identifier:\n+                                                    str_to_ident(\"int\"),\n+                                                lifetime: None,\n+                                                types: opt_vec::Empty,\n+                                            }\n+                                        ],\n+                                    }, None, 2),\n                                     span:sp(4,7)},\n                        pat: @ast::pat{id:1,\n-                                      node: ast::pat_ident(ast::bind_infer,\n-                                                            ast::Path{\n-                                                               span:sp(0,1),\n-                                                               global:false,\n-                                                               idents:~[str_to_ident(\"b\")],\n-                                                               rp: None,\n-                                                               types: ~[]},\n-                                                           None // no idea\n-                                                          ),\n+                                      node: ast::pat_ident(\n+                                        ast::bind_infer,\n+                                        ast::Path {\n+                                            span:sp(0,1),\n+                                            global:false,\n+                                            segments: ~[\n+                                                ast::PathSegment {\n+                                                    identifier:\n+                                                        str_to_ident(\"b\"),\n+                                                    lifetime: None,\n+                                                    types: opt_vec::Empty,\n+                                                }\n+                                            ],\n+                                        },\n+                                        None // no idea\n+                                      ),\n                                       span: sp(0,1)},\n                        id: 4 // fixme\n                    })\n@@ -519,23 +567,37 @@ mod test {\n                                                 node: ast::ty_path(ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n-                                        idents:~[str_to_ident(\"int\")],\n-                                        rp: None,\n-                                        types: ~[]},\n-                                                       None, 2),\n-                                                span:sp(10,13)},\n-                                    pat: @ast::pat{id:1, // fixme\n-                                                   node: ast::pat_ident(\n-                                                       ast::bind_infer,\n-                                                       ast::Path{\n-                                                           span:sp(6,7),\n-                                                           global:false,\n-                                                           idents:~[str_to_ident(\"b\")],\n-                                                           rp: None,\n-                                                           types: ~[]},\n-                                                       None // no idea\n-                                                   ),\n-                                                  span: sp(6,7)},\n+                                        segments: ~[\n+                                            ast::PathSegment {\n+                                                identifier:\n+                                                    str_to_ident(\"int\"),\n+                                                lifetime: None,\n+                                                types: opt_vec::Empty,\n+                                            }\n+                                        ],\n+                                        }, None, 2),\n+                                        span:sp(10,13)\n+                                    },\n+                                    pat: @ast::pat {\n+                                        id:1, // fixme\n+                                        node: ast::pat_ident(\n+                                            ast::bind_infer,\n+                                            ast::Path {\n+                                                span:sp(6,7),\n+                                                global:false,\n+                                                segments: ~[\n+                                                    ast::PathSegment {\n+                                                        identifier:\n+                                                            str_to_ident(\"b\"),\n+                                                        lifetime: None,\n+                                                        types: opt_vec::Empty,\n+                                                    }\n+                                                ],\n+                                            },\n+                                            None // no idea\n+                                        ),\n+                                        span: sp(6,7)\n+                                    },\n                                     id: 4 // fixme\n                                 }],\n                                 output: ast::Ty{id:5, // fixme\n@@ -558,9 +620,18 @@ mod test {\n                                                       ast::Path{\n                                                         span:sp(17,18),\n                                                         global:false,\n-                                                        idents:~[str_to_ident(\"b\")],\n-                                                        rp:None,\n-                                                        types: ~[]}),\n+                                                        segments: ~[\n+                                                            ast::PathSegment {\n+                                                                identifier:\n+                                                                str_to_ident(\n+                                                                    \"b\"),\n+                                                                lifetime:\n+                                                                    None,\n+                                                                types:\n+                                                                opt_vec::Empty\n+                                                            }\n+                                                        ],\n+                                                      }),\n                                                 span: sp(17,18)},\n                                                                  7), // fixme\n                                             span: sp(17,18)}],"}, {"sha": "0882a5e314346607278751da2e1d5c0558c06430", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 218, "deletions": 142, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -97,6 +97,37 @@ enum restriction {\n type arg_or_capture_item = Either<arg, ()>;\n type item_info = (ident, item_, Option<~[Attribute]>);\n \n+/// How to parse a path. There are four different kinds of paths, all of which\n+/// are parsed somewhat differently.\n+#[deriving(Eq)]\n+pub enum PathParsingMode {\n+    /// A path with no type parameters; e.g. `foo::bar::Baz`\n+    NoTypesAllowed,\n+    /// A path with a lifetime and type parameters, with no double colons\n+    /// before the type parameters; e.g. `foo::bar<'self>::Baz<T>`\n+    LifetimeAndTypesWithoutColons,\n+    /// A path with a lifetime and type parameters with double colons before\n+    /// the type parameters; e.g. `foo::bar::<'self>::Baz::<T>`\n+    LifetimeAndTypesWithColons,\n+    /// A path with a lifetime and type parameters with bounds before the last\n+    /// set of type parameters only; e.g. `foo::bar<'self>::Baz:X+Y<T>` This\n+    /// form does not use extra double colons.\n+    LifetimeAndTypesAndBounds,\n+}\n+\n+/// A pair of a path segment and group of type parameter bounds. (See `ast.rs`\n+/// for the definition of a path segment.)\n+struct PathSegmentAndBoundSet {\n+    segment: ast::PathSegment,\n+    bound_set: Option<OptVec<TyParamBound>>,\n+}\n+\n+/// A path paired with optional type bounds.\n+struct PathAndBounds {\n+    path: ast::Path,\n+    bounds: Option<OptVec<TyParamBound>>,\n+}\n+\n pub enum item_or_view_item {\n     // Indicates a failure to parse any kind of item. The attributes are\n     // returned.\n@@ -1108,7 +1139,10 @@ impl Parser {\n         } else if *self.token == token::MOD_SEP\n             || is_ident_or_path(self.token) {\n             // NAMED TYPE\n-            let (path, bounds) = self.parse_type_path();\n+            let PathAndBounds {\n+                path,\n+                bounds\n+            } = self.parse_path(LifetimeAndTypesAndBounds);\n             ty_path(path, bounds, self.get_id())\n         } else {\n             self.fatal(fmt!(\"expected type, found token %?\",\n@@ -1329,139 +1363,155 @@ impl Parser {\n         }\n     }\n \n-    // parse a path into a vector of idents, whether the path starts\n-    // with ::, and a span.\n-    pub fn parse_path(&self) -> (~[ast::ident],bool,span) {\n+    /// Parses a path and optional type parameter bounds, depending on the\n+    /// mode. The `mode` parameter determines whether lifetimes, types, and/or\n+    /// bounds are permitted and whether `::` must precede type parameter\n+    /// groups.\n+    pub fn parse_path(&self, mode: PathParsingMode) -> PathAndBounds {\n+        // Check for a whole path...\n+        let found = match *self.token {\n+            INTERPOLATED(token::nt_path(_)) => Some(self.bump_and_get()),\n+            _ => None,\n+        };\n+        match found {\n+            Some(INTERPOLATED(token::nt_path(path))) => {\n+                return PathAndBounds {\n+                    path: path,\n+                    bounds: None,\n+                }\n+            }\n+            _ => {}\n+        }\n+\n         let lo = self.span.lo;\n         let is_global = self.eat(&token::MOD_SEP);\n-        let (ids,span{lo:_,hi,expn_info}) = self.parse_path_non_global();\n-        (ids,is_global,span{lo:lo,hi:hi,expn_info:expn_info})\n-    }\n \n-    // parse a path beginning with an identifier into a vector of idents and a span\n-    pub fn parse_path_non_global(&self) -> (~[ast::ident],span) {\n-        let lo = self.span.lo;\n-        let mut ids = ~[];\n-        // must be at least one to begin:\n-        ids.push(self.parse_ident());\n+        // Parse any number of segments and bound sets. A segment is an\n+        // identifier followed by an optional lifetime and a set of types.\n+        // A bound set is a set of type parameter bounds.\n+        let mut segments = ~[];\n         loop {\n+            // First, parse an identifier.\n             match *self.token {\n-                token::MOD_SEP => {\n-                    let is_ident = do self.look_ahead(1) |t| {\n-                        match *t {\n-                            token::IDENT(*) => true,\n-                            _ => false,\n-                        }\n-                    };\n-                    if is_ident {\n-                        self.bump();\n-                        ids.push(self.parse_ident());\n-                    } else {\n-                        break\n-                    }\n-                }\n-                _ => break\n+                token::IDENT(*) => {}\n+                _ => break,\n             }\n-        }\n-        (ids, mk_sp(lo, self.last_span.hi))\n-    }\n+            let identifier = self.parse_ident();\n \n-    // parse a path that doesn't have type parameters attached\n-    pub fn parse_path_without_tps(&self) -> ast::Path {\n-        maybe_whole!(deref self, nt_path);\n-        let (ids,is_global,sp) = self.parse_path();\n-        ast::Path { span: sp,\n-                     global: is_global,\n-                     idents: ids,\n-                     rp: None,\n-                     types: ~[] }\n-    }\n+            // Next, parse a colon and bounded type parameters, if applicable.\n+            let bound_set = if mode == LifetimeAndTypesAndBounds {\n+                self.parse_optional_ty_param_bounds()\n+            } else {\n+                None\n+            };\n \n-    pub fn parse_bounded_path_with_tps(&self, colons: bool,\n-                                        before_tps: Option<&fn()>) -> ast::Path {\n-        debug!(\"parse_path_with_tps(colons=%b)\", colons);\n+            // Parse the '::' before type parameters if it's required. If\n+            // it is required and wasn't present, then we're done.\n+            if mode == LifetimeAndTypesWithColons &&\n+                    !self.eat(&token::MOD_SEP) {\n+                segments.push(PathSegmentAndBoundSet {\n+                    segment: ast::PathSegment {\n+                        identifier: identifier,\n+                        lifetime: None,\n+                        types: opt_vec::Empty,\n+                    },\n+                    bound_set: bound_set\n+                });\n+                break\n+            }\n \n-        maybe_whole!(deref self, nt_path);\n-        let lo = self.span.lo;\n-        let path = self.parse_path_without_tps();\n-        if colons && !self.eat(&token::MOD_SEP) {\n-            return path;\n-        }\n-\n-        // If the path might have bounds on it, they should be parsed before\n-        // the parameters, e.g. module::TraitName:B1+B2<T>\n-        before_tps.map_move(|callback| callback());\n-\n-        // Parse the (obsolete) trailing region parameter, if any, which will\n-        // be written \"foo/&x\"\n-        let rp_slash = {\n-            if *self.token == token::BINOP(token::SLASH)\n-                && self.look_ahead(1, |t| *t == token::BINOP(token::AND))\n-            {\n-                self.bump(); self.bump();\n-                self.obsolete(*self.last_span, ObsoleteLifetimeNotation);\n-                match *self.token {\n-                    token::IDENT(sid, _) => {\n-                        let span = self.span;\n-                        self.bump();\n-                        Some(ast::Lifetime {\n-                            id: self.get_id(),\n-                            span: *span,\n-                            ident: sid\n-                        })\n+            // Parse the `<` before the lifetime and types, if applicable.\n+            let (any_lifetime_or_types, optional_lifetime, types) =\n+                    if mode != NoTypesAllowed && self.eat(&token::LT) {\n+                // Parse an optional lifetime.\n+                let optional_lifetime = match *self.token {\n+                    token::LIFETIME(*) => Some(self.parse_lifetime()),\n+                    _ => None,\n+                };\n+\n+                // Parse type parameters.\n+                let mut types = opt_vec::Empty;\n+                let mut need_comma = optional_lifetime.is_some();\n+                loop {\n+                    // We're done if we see a `>`.\n+                    match *self.token {\n+                        token::GT | token::BINOP(token::SHR) => {\n+                            self.expect_gt();\n+                            break\n+                        }\n+                        _ => {} // Go on.\n                     }\n-                    _ => {\n-                        self.fatal(fmt!(\"Expected a lifetime name\"));\n+\n+                    if need_comma {\n+                        self.expect(&token::COMMA)\n+                    } else {\n+                        need_comma = true\n                     }\n+\n+                    types.push(self.parse_ty(false))\n                 }\n+\n+                (true, optional_lifetime, types)\n             } else {\n-                None\n-            }\n-        };\n+                (false, None, opt_vec::Empty)\n+            };\n \n-        // Parse any lifetime or type parameters which may appear:\n-        let (lifetimes, tps) = self.parse_generic_values();\n-        let hi = self.span.lo;\n+            // Assemble and push the result.\n+            segments.push(PathSegmentAndBoundSet {\n+                segment: ast::PathSegment {\n+                    identifier: identifier,\n+                    lifetime: optional_lifetime,\n+                    types: types,\n+                },\n+                bound_set: bound_set\n+            });\n \n-        let rp = match (&rp_slash, &lifetimes) {\n-            (&Some(_), _) => rp_slash,\n-            (&None, v) => {\n-                if v.len() == 0 {\n-                    None\n-                } else if v.len() == 1 {\n-                    Some(*v.get(0))\n-                } else {\n-                    self.fatal(fmt!(\"Expected at most one \\\n-                                     lifetime name (for now)\"));\n+            // We're done if we don't see a '::', unless the mode required\n+            // a double colon to get here in the first place.\n+            if !(mode == LifetimeAndTypesWithColons &&\n+                    !any_lifetime_or_types) {\n+                if !self.eat(&token::MOD_SEP) {\n+                    break\n                 }\n             }\n-        };\n-\n-        ast::Path {\n-            span: mk_sp(lo, hi),\n-            rp: rp,\n-            types: tps,\n-            .. path.clone()\n         }\n-    }\n \n-    // parse a path optionally with type parameters. If 'colons'\n-    // is true, then type parameters must be preceded by colons,\n-    // as in a::t::<t1,t2>\n-    pub fn parse_path_with_tps(&self, colons: bool) -> ast::Path {\n-        self.parse_bounded_path_with_tps(colons, None)\n-    }\n+        // Assemble the span.\n+        let span = mk_sp(lo, self.last_span.hi);\n \n-    // Like the above, but can also parse kind bounds in the case of a\n-    // path to be used as a type that might be a trait.\n-    pub fn parse_type_path(&self) -> (ast::Path, Option<OptVec<TyParamBound>>) {\n+        // Assemble the path segments.\n+        let mut path_segments = ~[];\n         let mut bounds = None;\n-        let path = self.parse_bounded_path_with_tps(false, Some(|| {\n-            // Note: this closure might not even get called in the case of a\n-            // macro-generated path. But that's the macro parser's job.\n-            bounds = self.parse_optional_ty_param_bounds();\n-        }));\n-        (path, bounds)\n+        let last_segment_index = segments.len() - 1;\n+        for (i, segment_and_bounds) in segments.consume_iter().enumerate() {\n+            let PathSegmentAndBoundSet {\n+                segment: segment,\n+                bound_set: bound_set\n+            } = segment_and_bounds;\n+            path_segments.push(segment);\n+\n+            if bound_set.is_some() {\n+                if i != last_segment_index {\n+                    self.span_err(span,\n+                                  \"type parameter bounds are allowed only \\\n+                                   before the last segment in a path\")\n+                }\n+\n+                bounds = bound_set\n+            }\n+        }\n+\n+        // Assemble the result.\n+        let path_and_bounds = PathAndBounds {\n+            path: ast::Path {\n+                span: span,\n+                global: is_global,\n+                segments: path_segments,\n+            },\n+            bounds: bounds,\n+        };\n+\n+        path_and_bounds\n     }\n \n     /// parses 0 or 1 lifetime\n@@ -1789,7 +1839,7 @@ impl Parser {\n         } else if *self.token == token::MOD_SEP ||\n                 is_ident(&*self.token) && !self.is_keyword(keywords::True) &&\n                 !self.is_keyword(keywords::False) {\n-            let pth = self.parse_path_with_tps(true);\n+            let pth = self.parse_path(LifetimeAndTypesWithColons).path;\n \n             // `!`, as an operator, is prefix, so we know this isn't that\n             if *self.token == token::NOT {\n@@ -2880,7 +2930,8 @@ impl Parser {\n             let val = self.parse_literal_maybe_minus();\n             if self.eat(&token::DOTDOT) {\n                 let end = if is_ident_or_path(tok) {\n-                    let path = self.parse_path_with_tps(true);\n+                    let path = self.parse_path(LifetimeAndTypesWithColons)\n+                                   .path;\n                     let hi = self.span.hi;\n                     self.mk_expr(lo, hi, expr_path(path))\n                 } else {\n@@ -2909,7 +2960,7 @@ impl Parser {\n                 let end = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n                 pat = pat_range(start, end);\n             } else if is_plain_ident(&*self.token) && !can_be_enum_or_struct {\n-                let name = self.parse_path_without_tps();\n+                let name = self.parse_path(NoTypesAllowed).path;\n                 let sub;\n                 if self.eat(&token::AT) {\n                     // parse foo @ pat\n@@ -2921,7 +2972,8 @@ impl Parser {\n                 pat = pat_ident(bind_infer, name, sub);\n             } else {\n                 // parse an enum pat\n-                let enum_path = self.parse_path_with_tps(true);\n+                let enum_path = self.parse_path(LifetimeAndTypesWithColons)\n+                                    .path;\n                 match *self.token {\n                     token::LBRACE => {\n                         self.bump();\n@@ -2957,7 +3009,7 @@ impl Parser {\n                             }\n                           },\n                           _ => {\n-                              if enum_path.idents.len()==1u {\n+                              if enum_path.segments.len() == 1 {\n                                   // it could still be either an enum\n                                   // or an identifier pattern, resolve\n                                   // will sort it out:\n@@ -2992,7 +3044,7 @@ impl Parser {\n                             \"expected identifier, found path\");\n         }\n         // why a path here, and not just an identifier?\n-        let name = self.parse_path_without_tps();\n+        let name = self.parse_path(NoTypesAllowed).path;\n         let sub = if self.eat(&token::AT) {\n             Some(self.parse_pat())\n         } else {\n@@ -3109,7 +3161,7 @@ impl Parser {\n \n             // Potential trouble: if we allow macros with paths instead of\n             // idents, we'd need to look ahead past the whole path here...\n-            let pth = self.parse_path_without_tps();\n+            let pth = self.parse_path(NoTypesAllowed).path;\n             self.bump();\n \n             let id = if *self.token == token::LPAREN {\n@@ -3785,7 +3837,7 @@ impl Parser {\n     // parse a::B<~str,int>\n     fn parse_trait_ref(&self) -> trait_ref {\n         ast::trait_ref {\n-            path: self.parse_path_with_tps(false),\n+            path: self.parse_path(LifetimeAndTypesWithoutColons).path,\n             ref_id: self.get_id(),\n         }\n     }\n@@ -4701,7 +4753,7 @@ impl Parser {\n             }\n \n             // item macro.\n-            let pth = self.parse_path_without_tps();\n+            let pth = self.parse_path(NoTypesAllowed).path;\n             self.expect(&token::NOT);\n \n             // a 'special' identifier (like what `macro_rules!` uses)\n@@ -4785,11 +4837,17 @@ impl Parser {\n                 let id = self.parse_ident();\n                 path.push(id);\n             }\n-            let path = ast::Path { span: mk_sp(lo, self.span.hi),\n-                                    global: false,\n-                                    idents: path,\n-                                    rp: None,\n-                                    types: ~[] };\n+            let path = ast::Path {\n+                span: mk_sp(lo, self.span.hi),\n+                global: false,\n+                segments: path.consume_iter().transform(|identifier| {\n+                    ast::PathSegment {\n+                        identifier: identifier,\n+                        lifetime: None,\n+                        types: opt_vec::Empty,\n+                    }\n+                }).collect()\n+            };\n             return @spanned(lo, self.span.hi,\n                             view_path_simple(first_ident,\n                                              path,\n@@ -4815,23 +4873,35 @@ impl Parser {\n                         seq_sep_trailing_allowed(token::COMMA),\n                         |p| p.parse_path_list_ident()\n                     );\n-                    let path = ast::Path { span: mk_sp(lo, self.span.hi),\n-                                            global: false,\n-                                            idents: path,\n-                                            rp: None,\n-                                            types: ~[] };\n+                    let path = ast::Path {\n+                        span: mk_sp(lo, self.span.hi),\n+                        global: false,\n+                        segments: path.consume_iter().transform(|identifier| {\n+                            ast::PathSegment {\n+                                identifier: identifier,\n+                                lifetime: None,\n+                                types: opt_vec::Empty,\n+                            }\n+                        }).collect()\n+                    };\n                     return @spanned(lo, self.span.hi,\n                                  view_path_list(path, idents, self.get_id()));\n                   }\n \n                   // foo::bar::*\n                   token::BINOP(token::STAR) => {\n                     self.bump();\n-                    let path = ast::Path { span: mk_sp(lo, self.span.hi),\n-                                            global: false,\n-                                            idents: path,\n-                                            rp: None,\n-                                            types: ~[] };\n+                    let path = ast::Path {\n+                        span: mk_sp(lo, self.span.hi),\n+                        global: false,\n+                        segments: path.consume_iter().transform(|identifier| {\n+                            ast::PathSegment {\n+                                identifier: identifier,\n+                                lifetime: None,\n+                                types: opt_vec::Empty,\n+                            }\n+                        }).collect()\n+                    };\n                     return @spanned(lo, self.span.hi,\n                                     view_path_glob(path, self.get_id()));\n                   }\n@@ -4843,11 +4913,17 @@ impl Parser {\n           _ => ()\n         }\n         let last = path[path.len() - 1u];\n-        let path = ast::Path { span: mk_sp(lo, self.span.hi),\n-                                global: false,\n-                                idents: path,\n-                                rp: None,\n-                                types: ~[] };\n+        let path = ast::Path {\n+            span: mk_sp(lo, self.span.hi),\n+            global: false,\n+            segments: path.consume_iter().transform(|identifier| {\n+                ast::PathSegment {\n+                    identifier: identifier,\n+                    lifetime: None,\n+                    types: opt_vec::Empty,\n+                }\n+            }).collect()\n+        };\n         return @spanned(lo,\n                         self.last_span.hi,\n                         view_path_simple(last, path, self.get_id()));"}, {"sha": "d449ba4eb5fb4609c3045958a7fdb004d1da3f0c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 40, "deletions": 21, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -1501,34 +1501,52 @@ pub fn print_for_decl(s: @ps, loc: &ast::Local, coll: &ast::expr) {\n     print_expr(s, coll);\n }\n \n-fn print_path_(s: @ps, path: &ast::Path, colons_before_params: bool,\n+fn print_path_(s: @ps,\n+               path: &ast::Path,\n+               colons_before_params: bool,\n                opt_bounds: &Option<OptVec<ast::TyParamBound>>) {\n     maybe_print_comment(s, path.span.lo);\n-    if path.global { word(s.s, \"::\"); }\n-    let mut first = true;\n-    for id in path.idents.iter() {\n-        if first { first = false; } else { word(s.s, \"::\"); }\n-        print_ident(s, *id);\n+    if path.global {\n+        word(s.s, \"::\");\n     }\n-    do opt_bounds.map |bounds| {\n-        print_bounds(s, bounds, true);\n-    };\n-    if path.rp.is_some() || !path.types.is_empty() {\n-        if colons_before_params { word(s.s, \"::\"); }\n \n-        if path.rp.is_some() || !path.types.is_empty() {\n+    let mut first = true;\n+    for (i, segment) in path.segments.iter().enumerate() {\n+        if first {\n+            first = false\n+        } else {\n+            word(s.s, \"::\")\n+        }\n+\n+        print_ident(s, segment.identifier);\n+\n+        if segment.lifetime.is_some() || !segment.types.is_empty() {\n+            // If this is the last segment, print the bounds.\n+            if i == path.segments.len() - 1 {\n+                match *opt_bounds {\n+                    None => {}\n+                    Some(ref bounds) => print_bounds(s, bounds, true),\n+                }\n+            }\n+\n+            if colons_before_params {\n+                word(s.s, \"::\")\n+            }\n             word(s.s, \"<\");\n \n-            for r in path.rp.iter() {\n-                print_lifetime(s, r);\n-                if !path.types.is_empty() {\n-                    word_space(s, \",\");\n+            for lifetime in segment.lifetime.iter() {\n+                print_lifetime(s, lifetime);\n+                if !segment.types.is_empty() {\n+                    word_space(s, \",\")\n                 }\n             }\n \n-            commasep(s, inconsistent, path.types, print_type);\n+            commasep(s,\n+                     inconsistent,\n+                     segment.types.map_to_vec(|t| (*t).clone()),\n+                     print_type);\n \n-            word(s.s, \">\");\n+            word(s.s, \">\")\n         }\n     }\n }\n@@ -1819,7 +1837,7 @@ pub fn print_meta_item(s: @ps, item: &ast::MetaItem) {\n pub fn print_view_path(s: @ps, vp: &ast::view_path) {\n     match vp.node {\n       ast::view_path_simple(ident, ref path, _) => {\n-        if path.idents[path.idents.len()-1u] != ident {\n+        if path.segments.last().identifier != ident {\n             print_ident(s, ident);\n             space(s.s);\n             word_space(s, \"=\");\n@@ -1899,8 +1917,9 @@ pub fn print_arg(s: @ps, input: &ast::arg) {\n       _ => {\n         match input.pat.node {\n             ast::pat_ident(_, ref path, _) if\n-                path.idents.len() == 1 &&\n-                path.idents[0] == parse::token::special_idents::invalid => {\n+                path.segments.len() == 1 &&\n+                path.segments[0].identifier ==\n+                    parse::token::special_idents::invalid => {\n                 // Do nothing.\n             }\n             _ => {"}, {"sha": "ef44a368ab517dfe21dc65ba966fc65aa863791c", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -319,8 +319,10 @@ pub fn walk_ty<E:Clone, V:Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n }\n \n pub fn walk_path<E:Clone, V:Visitor<E>>(visitor: &mut V, path: &Path, env: E) {\n-    for typ in path.types.iter() {\n-        visitor.visit_ty(typ, env.clone())\n+    for segment in path.segments.iter() {\n+        for typ in path.types.iter() {\n+            visitor.visit_ty(typ, env.clone())\n+        }\n     }\n }\n "}, {"sha": "8f01bd5e5eacfccf87fab35771ff637f7b26cfea", "filename": "src/test/run-pass/mid-path-type-params.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Ftest%2Frun-pass%2Fmid-path-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Ftest%2Frun-pass%2Fmid-path-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmid-path-type-params.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -0,0 +1,16 @@\n+struct S<T> {\n+    contents: T,\n+}\n+\n+impl<T> S<T> {\n+    fn new<U>(x: T, _: U) -> S<T> {\n+        S {\n+            contents: x,\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let _ = S::<int>::new::<float>(1, 1.0);\n+}\n+"}]}