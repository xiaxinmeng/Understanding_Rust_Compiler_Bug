{"sha": "1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "node_id": "C_kwDOAAsO6NoAKDFhNmFlM2Q2OTJjZmI1MmIyMWQwZjQ1YmE1MGI2NTk0ODZlNTNkNmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-27T20:42:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-27T20:42:46Z"}, "message": "Auto merge of #110916 - matthiaskrgr:rollup-g3c33zc, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #105745 (docs(std): clarify remove_dir_all errors)\n - #106456 (Correct `std::prelude` comment)\n - #106599 (Change memory ordering in System wrapper example)\n - #110838 (More `Typefoldable`/`TypeVisitable` cleanups)\n - #110851 (compiletest: emit assembly-output header in error)\n - #110853 (compiletest: add bpf-linker assembly support)\n - #110878 (Add `known-bug` tests for 4 unsound issues)\n - #110886 (`DepGraph` cleanups)\n - #110905 (Remove invalid value from scraped-examples.md)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "ea9c01c4adf4216e311074d2e9de197aeadd5b52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea9c01c4adf4216e311074d2e9de197aeadd5b52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "html_url": "https://github.com/rust-lang/rust/commit/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c14882f74e8feb3f76ae85ed5cd66afaccd1da67", "url": "https://api.github.com/repos/rust-lang/rust/commits/c14882f74e8feb3f76ae85ed5cd66afaccd1da67", "html_url": "https://github.com/rust-lang/rust/commit/c14882f74e8feb3f76ae85ed5cd66afaccd1da67"}, {"sha": "790912ac769eca2cab9d19c486f728b9b81319ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/790912ac769eca2cab9d19c486f728b9b81319ee", "html_url": "https://github.com/rust-lang/rust/commit/790912ac769eca2cab9d19c486f728b9b81319ee"}], "stats": {"total": 385, "additions": 227, "deletions": 158}, "files": [{"sha": "e375d611936ea9288f785a6e6319c1e404868781", "filename": "compiler/rustc_infer/src/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -20,7 +20,7 @@ pub struct MismatchedProjectionTypes<'tcx> {\n     pub err: ty::error::TypeError<'tcx>,\n }\n \n-#[derive(Clone, TypeFoldable, TypeVisitable)]\n+#[derive(Clone)]\n pub struct Normalized<'tcx, T> {\n     pub value: T,\n     pub obligations: Vec<PredicateObligation<'tcx>>,"}, {"sha": "8a22de931c35b2577e91498d9dd61d64aeabefac", "filename": "compiler/rustc_middle/src/hir/place.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -66,7 +66,6 @@ pub struct Place<'tcx> {\n ///\n /// This is an HIR version of [`rustc_middle::mir::Place`].\n #[derive(Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n-#[derive(TypeFoldable, TypeVisitable)]\n pub struct PlaceWithHirId<'tcx> {\n     /// `HirId` of the expression or pattern producing this value.\n     pub hir_id: HirId,"}, {"sha": "2490b17aac09b35f8c2602901aa406b7a45896bc", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -9,7 +9,7 @@ use crate::mir::visit::MirVisitable;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::fold::{FallibleTypeFolder, TypeFoldable};\n use crate::ty::print::{FmtPrinter, Printer};\n-use crate::ty::visit::{TypeVisitable, TypeVisitableExt, TypeVisitor};\n+use crate::ty::visit::TypeVisitableExt;\n use crate::ty::{self, List, Ty, TyCtxt};\n use crate::ty::{AdtDef, InstanceDef, ScalarInt, UserTypeAnnotationIndex};\n use crate::ty::{GenericArg, InternalSubsts, SubstsRef};\n@@ -36,7 +36,7 @@ use either::Either;\n \n use std::borrow::Cow;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n-use std::ops::{ControlFlow, Index, IndexMut};\n+use std::ops::{Index, IndexMut};\n use std::{iter, mem};\n \n pub use self::query::*;\n@@ -2722,6 +2722,7 @@ impl<'tcx> UserTypeProjections {\n ///   `field[0]` (aka `.0`), indicating that the type of `s` is\n ///   determined by finding the type of the `.0` field from `T`.\n #[derive(Clone, Debug, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n+#[derive(TypeFoldable, TypeVisitable)]\n pub struct UserTypeProjection {\n     pub base: UserTypeAnnotationIndex,\n     pub projs: Vec<ProjectionKind>,\n@@ -2765,28 +2766,6 @@ impl UserTypeProjection {\n     }\n }\n \n-impl<'tcx> TypeFoldable<TyCtxt<'tcx>> for UserTypeProjection {\n-    fn try_fold_with<F: FallibleTypeFolder<TyCtxt<'tcx>>>(\n-        self,\n-        folder: &mut F,\n-    ) -> Result<Self, F::Error> {\n-        Ok(UserTypeProjection {\n-            base: self.base.try_fold_with(folder)?,\n-            projs: self.projs.try_fold_with(folder)?,\n-        })\n-    }\n-}\n-\n-impl<'tcx> TypeVisitable<TyCtxt<'tcx>> for UserTypeProjection {\n-    fn visit_with<Vs: TypeVisitor<TyCtxt<'tcx>>>(\n-        &self,\n-        visitor: &mut Vs,\n-    ) -> ControlFlow<Vs::BreakTy> {\n-        self.base.visit_with(visitor)\n-        // Note: there's nothing in `self.proj` to visit.\n-    }\n-}\n-\n rustc_index::newtype_index! {\n     #[derive(HashStable)]\n     #[debug_format = \"promoted[{}]\"]"}, {"sha": "813e109c41e14b8a2a76aba94fd39b240dc912eb", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -234,7 +234,6 @@ pub enum StmtKind<'tcx> {\n }\n \n #[derive(Clone, Debug, Copy, PartialEq, Eq, Hash, HashStable, TyEncodable, TyDecodable)]\n-#[derive(TypeFoldable, TypeVisitable)]\n pub struct LocalVarId(pub hir::HirId);\n \n /// A THIR expression."}, {"sha": "02433026266a3420b0afa0b356e5e69a42b54175", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -569,7 +569,7 @@ pub struct DerivedObligationCause<'tcx> {\n     pub parent_code: InternedObligationCauseCode<'tcx>,\n }\n \n-#[derive(Clone, Debug, TypeFoldable, TypeVisitable, Lift)]\n+#[derive(Clone, Debug, TypeVisitable, Lift)]\n pub enum SelectionError<'tcx> {\n     /// The trait is not implemented.\n     Unimplemented,"}, {"sha": "f2dda003b99c5d60462456309c4907e69ebdc50e", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -103,7 +103,7 @@ pub type EvaluationCache<'tcx> = Cache<\n /// required for associated types to work in default impls, as the bounds\n /// are visible both as projection bounds and as where-clauses from the\n /// parameter environment.\n-#[derive(PartialEq, Eq, Debug, Clone, TypeFoldable, TypeVisitable)]\n+#[derive(PartialEq, Eq, Debug, Clone, TypeVisitable)]\n pub enum SelectionCandidate<'tcx> {\n     /// A builtin implementation for some specific traits, used in cases\n     /// where we cannot rely an ordinary library implementations."}, {"sha": "6b7b910a59bf90392dfb0b8b1694a2bb07408796", "filename": "compiler/rustc_middle/src/traits/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -120,7 +120,7 @@ impl<'tcx> std::ops::Deref for ExternalConstraints<'tcx> {\n }\n \n /// Additional constraints returned on success.\n-#[derive(Debug, PartialEq, Eq, Clone, Hash, Default, TypeFoldable, TypeVisitable)]\n+#[derive(Debug, PartialEq, Eq, Clone, Hash, Default)]\n pub struct ExternalConstraintsData<'tcx> {\n     // FIXME: implement this.\n     pub region_constraints: QueryRegionConstraints<'tcx>,"}, {"sha": "1be61e16dbed8a3662386896c87134f9e7088f13", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -28,7 +28,7 @@ impl<T> ExpectedFound<T> {\n }\n \n // Data structures used in type unification\n-#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable, Lift, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, TypeVisitable, Lift, PartialEq, Eq)]\n #[rustc_pass_by_value]\n pub enum TypeError<'tcx> {\n     Mismatch,"}, {"sha": "2aced27f7bbdca2585bf515d7f32f5e18222b8b1", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -2690,7 +2690,7 @@ impl<'tcx> ty::PolyTraitPredicate<'tcx> {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, TypeFoldable, TypeVisitable, Lift)]\n+#[derive(Debug, Copy, Clone, Lift)]\n pub struct PrintClosureAsImpl<'tcx> {\n     pub closure: ty::ClosureSubsts<'tcx>,\n }"}, {"sha": "29a3bc8bb975652b7f3f6458a8de1dce3159ffef", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -4,7 +4,6 @@\n //! to help with the tedium.\n \n use crate::mir::interpret;\n-use crate::mir::ProjectionKind;\n use crate::ty::fold::{FallibleTypeFolder, TypeFoldable, TypeSuperFoldable};\n use crate::ty::print::{with_no_trimmed_paths, FmtPrinter, Printer};\n use crate::ty::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor};\n@@ -373,16 +372,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n ///////////////////////////////////////////////////////////////////////////\n // Traversal implementations.\n \n-/// AdtDefs are basically the same as a DefId.\n-impl<'tcx> TypeFoldable<TyCtxt<'tcx>> for ty::AdtDef<'tcx> {\n-    fn try_fold_with<F: FallibleTypeFolder<TyCtxt<'tcx>>>(\n-        self,\n-        _folder: &mut F,\n-    ) -> Result<Self, F::Error> {\n-        Ok(self)\n-    }\n-}\n-\n impl<'tcx> TypeVisitable<TyCtxt<'tcx>> for ty::AdtDef<'tcx> {\n     fn visit_with<V: TypeVisitor<TyCtxt<'tcx>>>(\n         &self,\n@@ -445,15 +434,6 @@ impl<'tcx> TypeFoldable<TyCtxt<'tcx>> for &'tcx ty::List<ty::Const<'tcx>> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<TyCtxt<'tcx>> for &'tcx ty::List<ProjectionKind> {\n-    fn try_fold_with<F: FallibleTypeFolder<TyCtxt<'tcx>>>(\n-        self,\n-        folder: &mut F,\n-    ) -> Result<Self, F::Error> {\n-        ty::util::fold_list(self, folder, |tcx, v| tcx.mk_projs(v))\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<TyCtxt<'tcx>> for Ty<'tcx> {\n     fn try_fold_with<F: FallibleTypeFolder<TyCtxt<'tcx>>>(\n         self,"}, {"sha": "7bda20ffe9a32cbf2a492d6cf3ca7b657f806a5e", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -631,7 +631,7 @@ impl<'tcx> UpvarSubsts<'tcx> {\n /// type of the constant. The reason that `R` is represented as an extra type parameter\n /// is the same reason that [`ClosureSubsts`] have `CS` and `U` as type parameters:\n /// inline const can reference lifetimes that are internal to the creating function.\n-#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable)]\n+#[derive(Copy, Clone, Debug)]\n pub struct InlineConstSubsts<'tcx> {\n     /// Generic parameters from the enclosing item,\n     /// concatenated with the inferred type of the constant."}, {"sha": "8de4d06fe782b0055cf046e3b6a5f35b21b36aa6", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 32, "deletions": 64, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -354,24 +354,20 @@ impl<K: DepKind> DepGraphData<K> {\n                  - dep-node: {key:?}\"\n         );\n \n-        let task_deps = if cx.dep_context().is_eval_always(key.kind) {\n-            None\n+        let with_deps = |task_deps| K::with_deps(task_deps, || task(cx, arg));\n+        let (result, edges) = if cx.dep_context().is_eval_always(key.kind) {\n+            (with_deps(TaskDepsRef::EvalAlways), smallvec![])\n         } else {\n-            Some(Lock::new(TaskDeps {\n+            let task_deps = Lock::new(TaskDeps {\n                 #[cfg(debug_assertions)]\n                 node: Some(key),\n                 reads: SmallVec::new(),\n                 read_set: Default::default(),\n                 phantom_data: PhantomData,\n-            }))\n+            });\n+            (with_deps(TaskDepsRef::Allow(&task_deps)), task_deps.into_inner().reads)\n         };\n \n-        let task_deps_ref =\n-            task_deps.as_ref().map(TaskDepsRef::Allow).unwrap_or(TaskDepsRef::EvalAlways);\n-\n-        let result = K::with_deps(task_deps_ref, || task(cx, arg));\n-        let edges = task_deps.map_or_else(|| smallvec![], |lock| lock.into_inner().reads);\n-\n         let dcx = cx.dep_context();\n         let hashing_timer = dcx.profiler().incr_result_hashing();\n         let current_fingerprint =\n@@ -1236,76 +1232,48 @@ impl<K: DepKind> CurrentDepGraph<K> {\n             self.node_intern_event_id.map(|eid| profiler.generic_activity_with_event_id(eid));\n \n         if let Some(prev_index) = prev_graph.node_to_index_opt(&key) {\n+            let get_dep_node_index = |color, fingerprint| {\n+                if print_status {\n+                    eprintln!(\"[task::{color:}] {key:?}\");\n+                }\n+\n+                let mut prev_index_to_index = self.prev_index_to_index.lock();\n+\n+                let dep_node_index = match prev_index_to_index[prev_index] {\n+                    Some(dep_node_index) => dep_node_index,\n+                    None => {\n+                        let dep_node_index =\n+                            self.encoder.borrow().send(profiler, key, fingerprint, edges);\n+                        prev_index_to_index[prev_index] = Some(dep_node_index);\n+                        dep_node_index\n+                    }\n+                };\n+\n+                #[cfg(debug_assertions)]\n+                self.record_edge(dep_node_index, key, fingerprint);\n+\n+                dep_node_index\n+            };\n+\n             // Determine the color and index of the new `DepNode`.\n             if let Some(fingerprint) = fingerprint {\n                 if fingerprint == prev_graph.fingerprint_by_index(prev_index) {\n-                    if print_status {\n-                        eprintln!(\"[task::green] {key:?}\");\n-                    }\n-\n                     // This is a green node: it existed in the previous compilation,\n                     // its query was re-executed, and it has the same result as before.\n-                    let mut prev_index_to_index = self.prev_index_to_index.lock();\n-\n-                    let dep_node_index = match prev_index_to_index[prev_index] {\n-                        Some(dep_node_index) => dep_node_index,\n-                        None => {\n-                            let dep_node_index =\n-                                self.encoder.borrow().send(profiler, key, fingerprint, edges);\n-                            prev_index_to_index[prev_index] = Some(dep_node_index);\n-                            dep_node_index\n-                        }\n-                    };\n-\n-                    #[cfg(debug_assertions)]\n-                    self.record_edge(dep_node_index, key, fingerprint);\n+                    let dep_node_index = get_dep_node_index(\"green\", fingerprint);\n                     (dep_node_index, Some((prev_index, DepNodeColor::Green(dep_node_index))))\n                 } else {\n-                    if print_status {\n-                        eprintln!(\"[task::red] {key:?}\");\n-                    }\n-\n                     // This is a red node: it existed in the previous compilation, its query\n                     // was re-executed, but it has a different result from before.\n-                    let mut prev_index_to_index = self.prev_index_to_index.lock();\n-\n-                    let dep_node_index = match prev_index_to_index[prev_index] {\n-                        Some(dep_node_index) => dep_node_index,\n-                        None => {\n-                            let dep_node_index =\n-                                self.encoder.borrow().send(profiler, key, fingerprint, edges);\n-                            prev_index_to_index[prev_index] = Some(dep_node_index);\n-                            dep_node_index\n-                        }\n-                    };\n-\n-                    #[cfg(debug_assertions)]\n-                    self.record_edge(dep_node_index, key, fingerprint);\n+                    let dep_node_index = get_dep_node_index(\"red\", fingerprint);\n                     (dep_node_index, Some((prev_index, DepNodeColor::Red)))\n                 }\n             } else {\n-                if print_status {\n-                    eprintln!(\"[task::unknown] {key:?}\");\n-                }\n-\n                 // This is a red node, effectively: it existed in the previous compilation\n                 // session, its query was re-executed, but it doesn't compute a result hash\n                 // (i.e. it represents a `no_hash` query), so we have no way of determining\n                 // whether or not the result was the same as before.\n-                let mut prev_index_to_index = self.prev_index_to_index.lock();\n-\n-                let dep_node_index = match prev_index_to_index[prev_index] {\n-                    Some(dep_node_index) => dep_node_index,\n-                    None => {\n-                        let dep_node_index =\n-                            self.encoder.borrow().send(profiler, key, Fingerprint::ZERO, edges);\n-                        prev_index_to_index[prev_index] = Some(dep_node_index);\n-                        dep_node_index\n-                    }\n-                };\n-\n-                #[cfg(debug_assertions)]\n-                self.record_edge(dep_node_index, key, Fingerprint::ZERO);\n+                let dep_node_index = get_dep_node_index(\"unknown\", Fingerprint::ZERO);\n                 (dep_node_index, Some((prev_index, DepNodeColor::Red)))\n             }\n         } else {"}, {"sha": "77c0526e3aabec179085eff193039b1360d0292c", "filename": "compiler/rustc_transmute/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flib.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -62,15 +62,15 @@ mod rustc {\n \n     use rustc_hir::lang_items::LangItem;\n     use rustc_infer::infer::InferCtxt;\n-    use rustc_macros::{TypeFoldable, TypeVisitable};\n+    use rustc_macros::TypeVisitable;\n     use rustc_middle::traits::ObligationCause;\n     use rustc_middle::ty::Const;\n     use rustc_middle::ty::ParamEnv;\n     use rustc_middle::ty::Ty;\n     use rustc_middle::ty::TyCtxt;\n \n     /// The source and destination types of a transmutation.\n-    #[derive(TypeFoldable, TypeVisitable, Debug, Clone, Copy)]\n+    #[derive(TypeVisitable, Debug, Clone, Copy)]\n     pub struct Types<'tcx> {\n         /// The source type.\n         pub src: Ty<'tcx>,"}, {"sha": "c9675f93f95646a879b2f109a8e19d007172ab73", "filename": "compiler/rustc_type_ir/src/structural_impls.rs", "status": "modified", "additions": 7, "deletions": 28, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_type_ir%2Fsrc%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/compiler%2Frustc_type_ir%2Fsrc%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fstructural_impls.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -6,11 +6,10 @@ use crate::fold::{FallibleTypeFolder, TypeFoldable};\n use crate::visit::{TypeVisitable, TypeVisitor};\n use crate::Interner;\n use rustc_data_structures::functor::IdFunctor;\n+use rustc_data_structures::sync::Lrc;\n use rustc_index::{Idx, IndexVec};\n \n use std::ops::ControlFlow;\n-use std::rc::Rc;\n-use std::sync::Arc;\n \n ///////////////////////////////////////////////////////////////////////////\n // Atomic structs\n@@ -106,25 +105,13 @@ impl<I: Interner, T: TypeVisitable<I>, E: TypeVisitable<I>> TypeVisitable<I> for\n     }\n }\n \n-impl<I: Interner, T: TypeFoldable<I>> TypeFoldable<I> for Rc<T> {\n+impl<I: Interner, T: TypeFoldable<I>> TypeFoldable<I> for Lrc<T> {\n     fn try_fold_with<F: FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         self.try_map_id(|value| value.try_fold_with(folder))\n     }\n }\n \n-impl<I: Interner, T: TypeVisitable<I>> TypeVisitable<I> for Rc<T> {\n-    fn visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        (**self).visit_with(visitor)\n-    }\n-}\n-\n-impl<I: Interner, T: TypeFoldable<I>> TypeFoldable<I> for Arc<T> {\n-    fn try_fold_with<F: FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        self.try_map_id(|value| value.try_fold_with(folder))\n-    }\n-}\n-\n-impl<I: Interner, T: TypeVisitable<I>> TypeVisitable<I> for Arc<T> {\n+impl<I: Interner, T: TypeVisitable<I>> TypeVisitable<I> for Lrc<T> {\n     fn visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n         (**self).visit_with(visitor)\n     }\n@@ -154,19 +141,11 @@ impl<I: Interner, T: TypeVisitable<I>> TypeVisitable<I> for Vec<T> {\n     }\n }\n \n-impl<I: Interner, T: TypeVisitable<I>> TypeVisitable<I> for &[T] {\n-    fn visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.iter().try_for_each(|t| t.visit_with(visitor))\n-    }\n-}\n-\n-impl<I: Interner, T: TypeFoldable<I>> TypeFoldable<I> for Box<[T]> {\n-    fn try_fold_with<F: FallibleTypeFolder<I>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        self.try_map_id(|t| t.try_fold_with(folder))\n-    }\n-}\n+// `TypeFoldable` isn't impl'd for `&[T]`. It doesn't make sense in the general\n+// case, because we can't return a new slice. But note that there are a couple\n+// of trivial impls of `TypeFoldable` for specific slice types elsewhere.\n \n-impl<I: Interner, T: TypeVisitable<I>> TypeVisitable<I> for Box<[T]> {\n+impl<I: Interner, T: TypeVisitable<I>> TypeVisitable<I> for &[T] {\n     fn visit_with<V: TypeVisitor<I>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n         self.iter().try_for_each(|t| t.visit_with(visitor))\n     }"}, {"sha": "ec774e62debbff1a881c2fe94ad5b7f90e232bcd", "filename": "library/std/src/alloc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/library%2Fstd%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/library%2Fstd%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Falloc.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -93,7 +93,7 @@ pub use alloc_crate::alloc::*;\n ///\n /// ```rust\n /// use std::alloc::{System, GlobalAlloc, Layout};\n-/// use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+/// use std::sync::atomic::{AtomicUsize, Ordering::Relaxed};\n ///\n /// struct Counter;\n ///\n@@ -103,22 +103,22 @@ pub use alloc_crate::alloc::*;\n ///     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n ///         let ret = System.alloc(layout);\n ///         if !ret.is_null() {\n-///             ALLOCATED.fetch_add(layout.size(), SeqCst);\n+///             ALLOCATED.fetch_add(layout.size(), Relaxed);\n ///         }\n ///         ret\n ///     }\n ///\n ///     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n ///         System.dealloc(ptr, layout);\n-///         ALLOCATED.fetch_sub(layout.size(), SeqCst);\n+///         ALLOCATED.fetch_sub(layout.size(), Relaxed);\n ///     }\n /// }\n ///\n /// #[global_allocator]\n /// static A: Counter = Counter;\n ///\n /// fn main() {\n-///     println!(\"allocated bytes before main: {}\", ALLOCATED.load(SeqCst));\n+///     println!(\"allocated bytes before main: {}\", ALLOCATED.load(Relaxed));\n /// }\n /// ```\n ///"}, {"sha": "30e553f285b98ceb370ce5fc7fcf7d5fb6364aca", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -2284,6 +2284,11 @@ pub fn remove_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n ///\n /// See [`fs::remove_file`] and [`fs::remove_dir`].\n ///\n+/// `remove_dir_all` will fail if `remove_dir` or `remove_file` fail on any constituent paths, including the root path.\n+/// As a result, the directory you are deleting must exist, meaning that this function is not idempotent.\n+///\n+/// Consider ignoring the error if validating the removal is not required for your use case.\n+///\n /// [`fs::remove_file`]: remove_file\n /// [`fs::remove_dir`]: remove_dir\n ///"}, {"sha": "7a7a773763559c414936cfbe0fc0bc296fbe1601", "filename": "library/std/src/prelude/v1.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -91,10 +91,10 @@ pub use core::prelude::v1::cfg_eval;\n )]\n pub use core::prelude::v1::type_ascribe;\n \n-// The file so far is equivalent to src/libcore/prelude/v1.rs,\n-// and below to src/liballoc/prelude.rs.\n-// Those files are duplicated rather than using glob imports\n-// because we want docs to show these re-exports as pointing to within `std`.\n+// The file so far is equivalent to core/src/prelude/v1.rs. It is duplicated\n+// rather than glob imported because we want docs to show these re-exports as\n+// pointing to within `std`.\n+// Below are the items from the alloc crate.\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]"}, {"sha": "7197e01c8e31319fc08c177a51f1e0bf17c50d1c", "filename": "src/doc/rustdoc/src/scraped-examples.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/src%2Fdoc%2Frustdoc%2Fsrc%2Fscraped-examples.md", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/src%2Fdoc%2Frustdoc%2Fsrc%2Fscraped-examples.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fscraped-examples.md?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -24,14 +24,14 @@ Then this code snippet will be included in the documentation for `a_func`. This\n This feature is unstable, so you can enable it by calling Rustdoc with the unstable `rustdoc-scrape-examples` flag:\n \n ```bash\n-cargo doc -Zunstable-options -Zrustdoc-scrape-examples=examples\n+cargo doc -Zunstable-options -Zrustdoc-scrape-examples\n ```\n \n To enable this feature on [docs.rs](https://docs.rs), add this to your Cargo.toml:\n \n ```toml\n [package.metadata.docs.rs]\n-cargo-args = [\"-Zunstable-options\", \"-Zrustdoc-scrape-examples=examples\"]\n+cargo-args = [\"-Zunstable-options\", \"-Zrustdoc-scrape-examples\"]\n ```\n \n "}, {"sha": "e03a73c4e713c40866bc99ba5e9aed83fbb71272", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -224,6 +224,7 @@ enum Emit {\n     Metadata,\n     LlvmIr,\n     Asm,\n+    LinkArgsAsm,\n }\n \n impl<'test> TestCx<'test> {\n@@ -2035,6 +2036,9 @@ impl<'test> TestCx<'test> {\n             Emit::Asm => {\n                 rustc.args(&[\"--emit\", \"asm\"]);\n             }\n+            Emit::LinkArgsAsm => {\n+                rustc.args(&[\"-Clink-args=--emit=asm\"]);\n+            }\n         }\n \n         if !is_rustdoc {\n@@ -2328,11 +2332,15 @@ impl<'test> TestCx<'test> {\n                 emit = Emit::Asm;\n             }\n \n+            Some(\"bpf-linker\") => {\n+                emit = Emit::LinkArgsAsm;\n+            }\n+\n             Some(\"ptx-linker\") => {\n                 // No extra flags needed.\n             }\n \n-            Some(_) => self.fatal(\"unknown 'assembly-output' header\"),\n+            Some(header) => self.fatal(&format!(\"unknown 'assembly-output' header: {header}\")),\n             None => self.fatal(\"missing 'assembly-output' header\"),\n         }\n "}, {"sha": "cd1df53a5288942ca378ba035dff5ef2efc46959", "filename": "tests/ui/coherence/coherence-overlap-negative-impls.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/tests%2Fui%2Fcoherence%2Fcoherence-overlap-negative-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/tests%2Fui%2Fcoherence%2Fcoherence-overlap-negative-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-overlap-negative-impls.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -0,0 +1,41 @@\n+// check-pass\n+// known-bug: #74629\n+\n+// Should fail. The `0` and `1` impls overlap, violating coherence. Eg, with\n+// `T = Test, F = ()`, all bounds are true, making both impls applicable.\n+// `Test: Fold<Nil>`, `Test: Fold<()>` are true because of `2`.\n+// `Is<Test>: NotNil` is true because of `auto trait` and lack of negative impl.\n+\n+#![feature(negative_impls)]\n+#![feature(auto_traits)]\n+\n+struct Nil;\n+struct Cons<H>(H);\n+struct Test;\n+\n+trait Fold<F> {}\n+\n+impl<T, F> Fold<F> for Cons<T> // 0\n+where\n+    T: Fold<Nil>,\n+{}\n+\n+impl<T, F> Fold<F> for Cons<T> // 1\n+where\n+    T: Fold<F>,\n+    private::Is<T>: private::NotNil,\n+{}\n+\n+impl<F> Fold<F> for Test {} // 2\n+\n+mod private {\n+    use crate::Nil;\n+\n+    pub struct Is<T>(T);\n+    pub auto trait NotNil {}\n+\n+    #[allow(suspicious_auto_trait_impls)]\n+    impl !NotNil for Is<Nil> {}\n+}\n+\n+fn main() {}"}, {"sha": "9805933553dd750374bb4e8f1d88a9b8823a621b", "filename": "tests/ui/specialization/issue-40582.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/tests%2Fui%2Fspecialization%2Fissue-40582.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/tests%2Fui%2Fspecialization%2Fissue-40582.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fissue-40582.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -0,0 +1,35 @@\n+// check-pass\n+// known-bug: #40582\n+\n+// Should fail. Should not be possible to implement `make_static`.\n+\n+#![feature(specialization)]\n+#![allow(incomplete_features)]\n+\n+trait FromRef<'a, T: ?Sized> {\n+    fn from_ref(r: &'a T) -> Self;\n+}\n+\n+impl<'a, T: ?Sized> FromRef<'a, T> for &'a T {\n+    fn from_ref(r: &'a T) -> Self {\n+        r\n+    }\n+}\n+\n+impl<'a, T: ?Sized, R> FromRef<'a, T> for R {\n+    default fn from_ref(_: &'a T) -> Self {\n+        unimplemented!()\n+    }\n+}\n+\n+fn make_static<T: ?Sized>(data: &T) -> &'static T {\n+    fn helper<T: ?Sized, R>(data: &T) -> R {\n+        R::from_ref(data)\n+    }\n+    helper(data)\n+}\n+\n+fn main() {\n+    let s = \"specialization\".to_owned();\n+    println!(\"{:?}\", make_static(s.as_str()));\n+}"}, {"sha": "16ad942d5ab9573eab08cbbe27e2d7634294f3df", "filename": "tests/ui/specialization/specialization-default-items-drop-coherence.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/tests%2Fui%2Fspecialization%2Fspecialization-default-items-drop-coherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/tests%2Fui%2Fspecialization%2Fspecialization-default-items-drop-coherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fspecialization-default-items-drop-coherence.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -0,0 +1,30 @@\n+// check-pass\n+// known-bug: #105782\n+\n+// Should fail. Default items completely drop candidates instead of ambiguity,\n+// which is unsound during coherence, since coherence requires completeness.\n+\n+#![feature(specialization)]\n+#![allow(incomplete_features)]\n+\n+trait Default {\n+   type Id;\n+}\n+\n+impl<T> Default for T {\n+   default type Id = T;\n+}\n+\n+trait Overlap {\n+   type Assoc;\n+}\n+\n+impl Overlap for u32 {\n+   type Assoc = usize;\n+}\n+\n+impl Overlap for <u32 as Default>::Id {\n+   type Assoc = Box<usize>;\n+}\n+\n+fn main() {}"}, {"sha": "c282e2185bca21acbc5691c48a0faba81d4d1994", "filename": "tests/ui/thread-local/thread-local-static-ref-use-after-free.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/tests%2Fui%2Fthread-local%2Fthread-local-static-ref-use-after-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a6ae3d692cfb52b21d0f45ba50b659486e53d6c/tests%2Fui%2Fthread-local%2Fthread-local-static-ref-use-after-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fthread-local%2Fthread-local-static-ref-use-after-free.rs?ref=1a6ae3d692cfb52b21d0f45ba50b659486e53d6c", "patch": "@@ -0,0 +1,46 @@\n+// check-pass\n+// known-bug: #49682\n+// edition:2021\n+\n+// Should fail. Keeping references to thread local statics can result in a\n+// use-after-free.\n+\n+#![feature(thread_local)]\n+\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::thread;\n+\n+#[allow(dead_code)]\n+#[thread_local]\n+static FOO: AtomicUsize = AtomicUsize::new(0);\n+\n+#[allow(dead_code)]\n+async fn bar() {}\n+\n+#[allow(dead_code)]\n+async fn foo() {\n+    let r = &FOO;\n+    bar().await;\n+    r.load(Ordering::SeqCst);\n+}\n+\n+fn main() {\n+    // &FOO = 0x7fd1e9cbf6d0\n+    _ = thread::spawn(|| {\n+        let g = foo();\n+        println!(\"&FOO = {:p}\", &FOO);\n+        g\n+    })\n+    .join()\n+    .unwrap();\n+\n+    // &FOO = 0x7fd1e9cc0f50\n+    println!(\"&FOO = {:p}\", &FOO);\n+\n+    // &FOO = 0x7fd1e9cbf6d0\n+    thread::spawn(move || {\n+        println!(\"&FOO = {:p}\", &FOO);\n+    })\n+    .join()\n+    .unwrap();\n+}"}]}