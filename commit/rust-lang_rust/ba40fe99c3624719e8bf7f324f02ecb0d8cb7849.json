{"sha": "ba40fe99c3624719e8bf7f324f02ecb0d8cb7849", "node_id": "C_kwDOAAsO6NoAKGJhNDBmZTk5YzM2MjQ3MTllOGJmN2YzMjRmMDJlY2IwZDhjYjc4NDk", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-05-26T06:59:15Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-03T10:05:04Z"}, "message": "Compute `is_late_bound` in a separate query.\n\nThe computation is actually much simpler, and can be done by directly\nfetching the HIR for the `FnDecl` and its generics.", "tree": {"sha": "31fda547cbe122fe51ffcdd9deafe5b5821cb0c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31fda547cbe122fe51ffcdd9deafe5b5821cb0c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba40fe99c3624719e8bf7f324f02ecb0d8cb7849", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba40fe99c3624719e8bf7f324f02ecb0d8cb7849", "html_url": "https://github.com/rust-lang/rust/commit/ba40fe99c3624719e8bf7f324f02ecb0d8cb7849", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba40fe99c3624719e8bf7f324f02ecb0d8cb7849/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1294e86bbbccda04da32584484bac4dc47bf0cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1294e86bbbccda04da32584484bac4dc47bf0cc", "html_url": "https://github.com/rust-lang/rust/commit/b1294e86bbbccda04da32584484bac4dc47bf0cc"}], "stats": {"total": 146, "additions": 47, "deletions": 99}, "files": [{"sha": "c2c093f9f2fc74e685b1589063b809c772f09702", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba40fe99c3624719e8bf7f324f02ecb0d8cb7849/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba40fe99c3624719e8bf7f324f02ecb0d8cb7849/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=ba40fe99c3624719e8bf7f324f02ecb0d8cb7849", "patch": "@@ -830,11 +830,11 @@ fn for_each_late_bound_region_defined_on<'tcx>(\n     fn_def_id: DefId,\n     mut f: impl FnMut(ty::Region<'tcx>),\n ) {\n-    if let Some((owner, late_bounds)) = tcx.is_late_bound_map(fn_def_id.expect_local()) {\n+    if let Some(late_bounds) = tcx.is_late_bound_map(fn_def_id.expect_local()) {\n         for &region_def_id in late_bounds.iter() {\n             let name = tcx.item_name(region_def_id.to_def_id());\n             let liberated_region = tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                scope: owner.to_def_id(),\n+                scope: fn_def_id,\n                 bound_region: ty::BoundRegionKind::BrNamed(region_def_id.to_def_id(), name),\n             }));\n             f(liberated_region);"}, {"sha": "2c40eab8764afd6d8f326459f41605bcccae7625", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ba40fe99c3624719e8bf7f324f02ecb0d8cb7849/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba40fe99c3624719e8bf7f324f02ecb0d8cb7849/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=ba40fe99c3624719e8bf7f324f02ecb0d8cb7849", "patch": "@@ -364,7 +364,11 @@ impl<'hir> Map<'hir> {\n         match node.node {\n             OwnerNode::ImplItem(impl_item) => Some(&impl_item.generics),\n             OwnerNode::TraitItem(trait_item) => Some(&trait_item.generics),\n-            OwnerNode::Item(Item {\n+            OwnerNode::ForeignItem(ForeignItem {\n+                kind: ForeignItemKind::Fn(_, _, generics),\n+                ..\n+            })\n+            | OwnerNode::Item(Item {\n                 kind:\n                     ItemKind::Fn(_, generics, _)\n                     | ItemKind::TyAlias(_, generics)"}, {"sha": "899d6c7e490a60416802322c3c208eabbe8cae9c", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba40fe99c3624719e8bf7f324f02ecb0d8cb7849/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba40fe99c3624719e8bf7f324f02ecb0d8cb7849/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=ba40fe99c3624719e8bf7f324f02ecb0d8cb7849", "patch": "@@ -1584,7 +1584,7 @@ rustc_queries! {\n         Option<&'tcx FxHashMap<ItemLocalId, Region>> {\n         desc { \"looking up a named region\" }\n     }\n-    query is_late_bound_map(_: LocalDefId) -> Option<(LocalDefId, &'tcx FxHashSet<LocalDefId>)> {\n+    query is_late_bound_map(_: LocalDefId) -> Option<&'tcx FxHashSet<LocalDefId>> {\n         desc { \"testing if a region is late bound\" }\n     }\n     /// For a given item (like a struct), gets the default lifetimes to be used"}, {"sha": "72e2beb372d3ca117e15ca8a56568679286fef34", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ba40fe99c3624719e8bf7f324f02ecb0d8cb7849/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba40fe99c3624719e8bf7f324f02ecb0d8cb7849/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=ba40fe99c3624719e8bf7f324f02ecb0d8cb7849", "patch": "@@ -2803,6 +2803,13 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.named_region_map(id.owner).and_then(|map| map.get(&id.local_id).cloned())\n     }\n \n+    pub fn is_late_bound(self, id: HirId) -> bool {\n+        self.is_late_bound_map(id.owner).map_or(false, |set| {\n+            let def_id = self.hir().local_def_id(id);\n+            set.contains(&def_id)\n+        })\n+    }\n+\n     pub fn late_bound_vars(self, id: HirId) -> &'tcx List<ty::BoundVariableKind> {\n         self.mk_bound_variable_kinds(\n             self.late_bound_vars_map(id.owner)"}, {"sha": "11f80b314d7702171607eed088358b860c830bce", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 24, "deletions": 68, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ba40fe99c3624719e8bf7f324f02ecb0d8cb7849/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba40fe99c3624719e8bf7f324f02ecb0d8cb7849/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=ba40fe99c3624719e8bf7f324f02ecb0d8cb7849", "patch": "@@ -16,11 +16,11 @@ use rustc_hir::def_id::{DefIdMap, LocalDefId};\n use rustc_hir::hir_id::ItemLocalId;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{GenericArg, GenericParam, LifetimeName, Node};\n-use rustc_hir::{GenericParamKind, HirIdMap, HirIdSet};\n+use rustc_hir::{GenericParamKind, HirIdMap};\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_lifetime::*;\n-use rustc_middle::ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n+use rustc_middle::ty::{self, GenericParamDefKind, TyCtxt};\n use rustc_middle::{bug, span_bug};\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::{kw, sym, Ident};\n@@ -134,11 +134,6 @@ struct NamedRegionMap {\n     // `Region` describing how that region is bound\n     defs: HirIdMap<Region>,\n \n-    // the set of lifetime def ids that are late-bound; a region can\n-    // be late-bound if (a) it does NOT appear in a where-clause and\n-    // (b) it DOES appear in the arguments.\n-    late_bound: HirIdSet,\n-\n     // Maps relevant hir items to the bound vars on them. These include:\n     // - function defs\n     // - function pointers\n@@ -402,15 +397,15 @@ fn resolve_lifetimes_trait_definition(\n     tcx: TyCtxt<'_>,\n     local_def_id: LocalDefId,\n ) -> ResolveLifetimes {\n-    convert_named_region_map(tcx, do_resolve(tcx, local_def_id, true, false))\n+    convert_named_region_map(do_resolve(tcx, local_def_id, true, false))\n }\n \n /// Computes the `ResolveLifetimes` map that contains data for an entire `Item`.\n /// You should not read the result of this query directly, but rather use\n /// `named_region_map`, `is_late_bound_map`, etc.\n #[tracing::instrument(level = \"debug\", skip(tcx))]\n fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> ResolveLifetimes {\n-    convert_named_region_map(tcx, do_resolve(tcx, local_def_id, false, false))\n+    convert_named_region_map(do_resolve(tcx, local_def_id, false, false))\n }\n \n fn do_resolve(\n@@ -422,7 +417,6 @@ fn do_resolve(\n     let item = tcx.hir().expect_item(local_def_id);\n     let mut named_region_map = NamedRegionMap {\n         defs: Default::default(),\n-        late_bound: Default::default(),\n         late_bound_vars: Default::default(),\n         scope_for_path: with_scope_for_path.then(|| Default::default()),\n     };\n@@ -439,18 +433,13 @@ fn do_resolve(\n     named_region_map\n }\n \n-fn convert_named_region_map(tcx: TyCtxt<'_>, named_region_map: NamedRegionMap) -> ResolveLifetimes {\n+fn convert_named_region_map(named_region_map: NamedRegionMap) -> ResolveLifetimes {\n     let mut rl = ResolveLifetimes::default();\n \n     for (hir_id, v) in named_region_map.defs {\n         let map = rl.defs.entry(hir_id.owner).or_default();\n         map.insert(hir_id.local_id, v);\n     }\n-    for hir_id in named_region_map.late_bound {\n-        let map = rl.late_bound.entry(hir_id.owner).or_default();\n-        let def_id = tcx.hir().local_def_id(hir_id);\n-        map.insert(def_id);\n-    }\n     for (hir_id, v) in named_region_map.late_bound_vars {\n         let map = rl.late_bound_vars.entry(hir_id.owner).or_default();\n         map.insert(hir_id.local_id, v);\n@@ -506,28 +495,6 @@ fn item_for(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> LocalDefId {\n     item\n }\n \n-fn is_late_bound_map<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: LocalDefId,\n-) -> Option<(LocalDefId, &'tcx FxHashSet<LocalDefId>)> {\n-    match tcx.def_kind(def_id) {\n-        DefKind::AnonConst | DefKind::InlineConst => {\n-            let mut def_id = tcx.local_parent(def_id);\n-            // We search for the next outer anon const or fn here\n-            // while skipping closures.\n-            //\n-            // Note that for `AnonConst` we still just recurse until we\n-            // find a function body, but who cares :shrug:\n-            while tcx.is_closure(def_id.to_def_id()) {\n-                def_id = tcx.local_parent(def_id);\n-            }\n-\n-            tcx.is_late_bound_map(def_id)\n-        }\n-        _ => resolve_lifetimes_for(tcx, def_id).late_bound.get(&def_id).map(|lt| (def_id, lt)),\n-    }\n-}\n-\n /// In traits, there is an implicit `Self` type parameter which comes before the generics.\n /// We have to account for this when computing the index of the other generic parameters.\n /// This function returns whether there is such an implicit parameter defined on the given item.\n@@ -687,9 +654,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             _ => {}\n         }\n         match item.kind {\n-            hir::ItemKind::Fn(ref sig, ref generics, _) => {\n+            hir::ItemKind::Fn(_, ref generics, _) => {\n                 self.missing_named_lifetime_spots.push(generics.into());\n-                self.visit_early_late(None, item.hir_id(), &sig.decl, generics, |this| {\n+                self.visit_early_late(None, item.hir_id(), generics, |this| {\n                     intravisit::walk_item(this, item);\n                 });\n                 self.missing_named_lifetime_spots.pop();\n@@ -731,13 +698,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                     self.map.defs.insert(hir::HirId { owner, local_id }, *region);\n                                 });\n                             }\n-                            for (&owner, late_bound) in resolved_lifetimes.late_bound.iter() {\n-                                late_bound.iter().for_each(|&id| {\n-                                    let hir_id = self.tcx.local_def_id_to_hir_id(id);\n-                                    debug_assert_eq!(owner, hir_id.owner);\n-                                    self.map.late_bound.insert(hir_id);\n-                                });\n-                            }\n                             for (&owner, late_bound_vars) in\n                                 resolved_lifetimes.late_bound_vars.iter()\n                             {\n@@ -807,8 +767,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n         match item.kind {\n-            hir::ForeignItemKind::Fn(ref decl, _, ref generics) => {\n-                self.visit_early_late(None, item.hir_id(), decl, generics, |this| {\n+            hir::ForeignItemKind::Fn(_, _, ref generics) => {\n+                self.visit_early_late(None, item.hir_id(), generics, |this| {\n                     intravisit::walk_foreign_item(this, item);\n                 })\n             }\n@@ -1085,13 +1045,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         use self::hir::TraitItemKind::*;\n         match trait_item.kind {\n-            Fn(ref sig, _) => {\n+            Fn(_, _) => {\n                 self.missing_named_lifetime_spots.push((&trait_item.generics).into());\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n                     Some(tcx.hir().get_parent_item(trait_item.hir_id())),\n                     trait_item.hir_id(),\n-                    &sig.decl,\n                     &trait_item.generics,\n                     |this| intravisit::walk_trait_item(this, trait_item),\n                 );\n@@ -1153,13 +1112,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         use self::hir::ImplItemKind::*;\n         match impl_item.kind {\n-            Fn(ref sig, _) => {\n+            Fn(..) => {\n                 self.missing_named_lifetime_spots.push((&impl_item.generics).into());\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n                     Some(tcx.hir().get_parent_item(impl_item.hir_id())),\n                     impl_item.hir_id(),\n-                    &sig.decl,\n                     &impl_item.generics,\n                     |this| intravisit::walk_impl_item(this, impl_item),\n                 );\n@@ -1656,14 +1614,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         &mut self,\n         parent_id: Option<LocalDefId>,\n         hir_id: hir::HirId,\n-        decl: &'tcx hir::FnDecl<'tcx>,\n         generics: &'tcx hir::Generics<'tcx>,\n         walk: F,\n     ) where\n         F: for<'b, 'c> FnOnce(&'b mut LifetimeContext<'c, 'tcx>),\n     {\n-        insert_late_bound_lifetimes(self.tcx, self.map, decl, generics);\n-\n         // Find the start of nested early scopes, e.g., in methods.\n         let mut next_early_index = 0;\n         if let Some(parent_id) = parent_id {\n@@ -1687,7 +1642,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             .iter()\n             .filter_map(|param| match param.kind {\n                 GenericParamKind::Lifetime { .. } => {\n-                    if self.map.late_bound.contains(&param.hir_id) {\n+                    if self.tcx.is_late_bound(param.hir_id) {\n                         let late_bound_idx = named_late_bound_vars;\n                         named_late_bound_vars += 1;\n                         Some(Region::late(late_bound_idx, self.tcx.hir(), param))\n@@ -1708,7 +1663,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             .iter()\n             .filter(|param| {\n                 matches!(param.kind, GenericParamKind::Lifetime { .. })\n-                    && self.map.late_bound.contains(&param.hir_id)\n+                    && self.tcx.is_late_bound(param.hir_id)\n             })\n             .enumerate()\n             .map(|(late_bound_idx, param)| {\n@@ -2613,7 +2568,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n }\n \n /// Detects late-bound lifetimes and inserts them into\n-/// `map.late_bound`.\n+/// `late_bound`.\n ///\n /// A region declared on a fn is **late-bound** if:\n /// - it is constrained by an argument type;\n@@ -2622,13 +2577,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n /// \"Constrained\" basically means that it appears in any type but\n /// not amongst the inputs to a projection. In other words, `<&'a\n /// T as Trait<''b>>::Foo` does not constrain `'a` or `'b`.\n-#[tracing::instrument(level = \"debug\", skip(tcx, map))]\n-fn insert_late_bound_lifetimes(\n-    tcx: TyCtxt<'_>,\n-    map: &mut NamedRegionMap,\n-    decl: &hir::FnDecl<'_>,\n-    generics: &hir::Generics<'_>,\n-) {\n+fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxHashSet<LocalDefId>> {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    let decl = tcx.hir().fn_decl_by_hir_id(hir_id)?;\n+    let generics = tcx.hir().get_generics(def_id)?;\n+\n+    let mut late_bound = FxHashSet::default();\n+\n     let mut constrained_by_input = ConstrainedCollector::default();\n     for arg_ty in decl.inputs {\n         constrained_by_input.visit_ty(arg_ty);\n@@ -2675,11 +2630,12 @@ fn insert_late_bound_lifetimes(\n \n         debug!(\"lifetime {:?} with id {:?} is late-bound\", param.name.ident(), param.hir_id);\n \n-        let inserted = map.late_bound.insert(param.hir_id);\n+        let inserted = late_bound.insert(param_def_id);\n         assert!(inserted, \"visited lifetime {:?} twice\", param.hir_id);\n     }\n \n-    return;\n+    debug!(?late_bound);\n+    return Some(tcx.arena.alloc(late_bound));\n \n     #[derive(Default)]\n     struct ConstrainedCollector {"}, {"sha": "34d107349e7c70b29527103fa44f20fbc8264bc2", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ba40fe99c3624719e8bf7f324f02ecb0d8cb7849/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba40fe99c3624719e8bf7f324f02ecb0d8cb7849/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=ba40fe99c3624719e8bf7f324f02ecb0d8cb7849", "patch": "@@ -1364,7 +1364,6 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n \n     fn has_late_bound_regions<'tcx>(\n         tcx: TyCtxt<'tcx>,\n-        def_id: LocalDefId,\n         generics: &'tcx hir::Generics<'tcx>,\n         decl: &'tcx hir::FnDecl<'tcx>,\n     ) -> Option<Span> {\n@@ -1373,14 +1372,9 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n             outer_index: ty::INNERMOST,\n             has_late_bound_regions: None,\n         };\n-        let late_bound_map = tcx.is_late_bound_map(def_id);\n-        let is_late_bound = |id| {\n-            let id = tcx.hir().local_def_id(id);\n-            late_bound_map.map_or(false, |(_, set)| set.contains(&id))\n-        };\n         for param in generics.params {\n             if let GenericParamKind::Lifetime { .. } = param.kind {\n-                if is_late_bound(param.hir_id) {\n+                if tcx.is_late_bound(param.hir_id) {\n                     return Some(param.span);\n                 }\n             }\n@@ -1392,25 +1386,25 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n     match node {\n         Node::TraitItem(item) => match item.kind {\n             hir::TraitItemKind::Fn(ref sig, _) => {\n-                has_late_bound_regions(tcx, item.def_id, &item.generics, sig.decl)\n+                has_late_bound_regions(tcx, &item.generics, sig.decl)\n             }\n             _ => None,\n         },\n         Node::ImplItem(item) => match item.kind {\n             hir::ImplItemKind::Fn(ref sig, _) => {\n-                has_late_bound_regions(tcx, item.def_id, &item.generics, sig.decl)\n+                has_late_bound_regions(tcx, &item.generics, sig.decl)\n             }\n             _ => None,\n         },\n         Node::ForeignItem(item) => match item.kind {\n             hir::ForeignItemKind::Fn(fn_decl, _, ref generics) => {\n-                has_late_bound_regions(tcx, item.def_id, generics, fn_decl)\n+                has_late_bound_regions(tcx, generics, fn_decl)\n             }\n             _ => None,\n         },\n         Node::Item(item) => match item.kind {\n             hir::ItemKind::Fn(ref sig, .., ref generics, _) => {\n-                has_late_bound_regions(tcx, item.def_id, generics, sig.decl)\n+                has_late_bound_regions(tcx, generics, sig.decl)\n             }\n             _ => None,\n         },\n@@ -1671,7 +1665,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n         params.push(opt_self);\n     }\n \n-    let early_lifetimes = early_bound_lifetimes_from_generics(tcx, hir_id.owner, ast_generics);\n+    let early_lifetimes = early_bound_lifetimes_from_generics(tcx, ast_generics);\n     params.extend(early_lifetimes.enumerate().map(|(i, param)| ty::GenericParamDef {\n         name: param.name.ident().name,\n         index: own_start + i as u32,\n@@ -2054,23 +2048,10 @@ fn impl_polarity(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ImplPolarity {\n /// `resolve_lifetime::early_bound_lifetimes`.\n fn early_bound_lifetimes_from_generics<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: LocalDefId,\n     generics: &'a hir::Generics<'a>,\n ) -> impl Iterator<Item = &'a hir::GenericParam<'a>> + Captures<'tcx> {\n-    let late_bound_map = if generics.params.is_empty() {\n-        // This function may be called on `def_id == CRATE_DEF_ID`,\n-        // which makes `is_late_bound_map` ICE.  Don't even try if there\n-        // is no generic parameter.\n-        None\n-    } else {\n-        tcx.is_late_bound_map(def_id)\n-    };\n-    let is_late_bound = move |hir_id| {\n-        let id = tcx.hir().local_def_id(hir_id);\n-        late_bound_map.map_or(false, |(_, set)| set.contains(&id))\n-    };\n     generics.params.iter().filter(move |param| match param.kind {\n-        GenericParamKind::Lifetime { .. } => !is_late_bound(param.hir_id),\n+        GenericParamKind::Lifetime { .. } => !tcx.is_late_bound(param.hir_id),\n         _ => false,\n     })\n }\n@@ -2255,7 +2236,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n     // have to be careful to only iterate over early-bound regions.\n     let mut index = parent_count\n         + has_own_self as u32\n-        + early_bound_lifetimes_from_generics(tcx, hir_id.owner, ast_generics).count() as u32;\n+        + early_bound_lifetimes_from_generics(tcx, ast_generics).count() as u32;\n \n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T: Foo>`)."}]}