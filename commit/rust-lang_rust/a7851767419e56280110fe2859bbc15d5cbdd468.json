{"sha": "a7851767419e56280110fe2859bbc15d5cbdd468", "node_id": "C_kwDOAAsO6NoAKGE3ODUxNzY3NDE5ZTU2MjgwMTEwZmUyODU5YmJjMTVkNWNiZGQ0Njg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-22T17:46:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-22T17:46:57Z"}, "message": "Auto merge of #100881 - Dylan-DPC:rollup-q9rr658, r=Dylan-DPC\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #98200 (Expand potential inner `Or` pattern for THIR)\n - #99770 (Make some const prop mir-opt tests `unit-test`s)\n - #99957 (Rework Ipv6Addr::is_global to check for global reachability rather than global scope - rebase)\n - #100331 (Guarantee `try_reserve` preserves the contents on error)\n - #100336 (Fix two const_trait_impl issues)\n - #100713 (Convert diagnostics in parser/expr to SessionDiagnostic)\n - #100820 (Use pointer `is_aligned*` methods)\n - #100872 (Add guarantee that Vec::default() does not alloc)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "41cc6602b9a79136876c87b4f6945d50bc8d48a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41cc6602b9a79136876c87b4f6945d50bc8d48a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7851767419e56280110fe2859bbc15d5cbdd468", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7851767419e56280110fe2859bbc15d5cbdd468", "html_url": "https://github.com/rust-lang/rust/commit/a7851767419e56280110fe2859bbc15d5cbdd468", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7851767419e56280110fe2859bbc15d5cbdd468/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0dc8d78019ca924203fe153ff0af7f64f68cb5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0dc8d78019ca924203fe153ff0af7f64f68cb5d", "html_url": "https://github.com/rust-lang/rust/commit/e0dc8d78019ca924203fe153ff0af7f64f68cb5d"}, {"sha": "4ed8fa47592ade04e388bc527c26d09c651b6455", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ed8fa47592ade04e388bc527c26d09c651b6455", "html_url": "https://github.com/rust-lang/rust/commit/4ed8fa47592ade04e388bc527c26d09c651b6455"}], "stats": {"total": 1475, "additions": 1050, "deletions": 425}, "files": [{"sha": "3b37a393846b2abfe58bea09d5d6c719a41f7481", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -41,3 +41,112 @@ parser_switch_mut_let_order =\n parser_missing_let_before_mut = missing keyword\n parser_use_let_not_auto = write `let` instead of `auto` to introduce a new variable\n parser_use_let_not_var = write `let` instead of `var` to introduce a new variable\n+\n+parser_invalid_comparison_operator = invalid comparison operator `{$invalid}`\n+    .use_instead = `{$invalid}` is not a valid comparison operator, use `{$correct}`\n+    .spaceship_operator_invalid = `<=>` is not a valid comparison operator, use `std::cmp::Ordering`\n+\n+parser_invalid_logical_operator = `{$incorrect}` is not a logical operator\n+    .note = unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n+    .use_amp_amp_for_conjunction = use `&&` to perform logical conjunction\n+    .use_pipe_pipe_for_disjunction = use `||` to perform logical disjunction\n+\n+parser_tilde_is_not_unary_operator = `~` cannot be used as a unary operator\n+    .suggestion = use `!` to perform bitwise not\n+\n+parser_unexpected_token_after_not = unexpected {$negated_desc} after identifier\n+    .suggestion = use `!` to perform logical negation\n+\n+parser_malformed_loop_label = malformed loop label\n+    .suggestion = use the correct loop label format\n+\n+parser_lifetime_in_borrow_expression = borrow expressions cannot be annotated with lifetimes\n+    .suggestion = remove the lifetime annotation\n+    .label = annotated with lifetime here\n+\n+parser_field_expression_with_generic = field expressions cannot have generic arguments\n+\n+parser_macro_invocation_with_qualified_path = macros cannot use qualified paths\n+\n+parser_unexpected_token_after_label = expected `while`, `for`, `loop` or `{\"{\"}` after a label\n+\n+parser_require_colon_after_labeled_expression = labeled expression must be followed by `:`\n+    .note = labels are used before loops and blocks, allowing e.g., `break 'label` to them\n+    .label = the label\n+    .suggestion = add `:` after the label\n+\n+parser_do_catch_syntax_removed = found removed `do catch` syntax\n+    .note = following RFC #2388, the new non-placeholder syntax is `try`\n+    .suggestion = replace with the new syntax\n+\n+parser_float_literal_requires_integer_part = float literals must have an integer part\n+    .suggestion = must have an integer part\n+\n+parser_invalid_int_literal_width = invalid width `{$width}` for integer literal\n+    .help = valid widths are 8, 16, 32, 64 and 128\n+\n+parser_invalid_num_literal_base_prefix = invalid base prefix for number literal\n+    .note = base prefixes (`0xff`, `0b1010`, `0o755`) are lowercase\n+    .suggestion = try making the prefix lowercase\n+\n+parser_invalid_num_literal_suffix = invalid suffix `{$suffix}` for number literal\n+    .label = invalid suffix `{$suffix}`\n+    .help = the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+\n+parser_invalid_float_literal_width = invalid width `{$width}` for float literal\n+    .help = valid widths are 32 and 64\n+\n+parser_invalid_float_literal_suffix = invalid suffix `{$suffix}` for float literal\n+    .label = invalid suffix `{$suffix}`\n+    .help = valid suffixes are `f32` and `f64`\n+\n+parser_int_literal_too_large = integer literal is too large\n+\n+parser_missing_semicolon_before_array = expected `;`, found `[`\n+    .suggestion = consider adding `;` here\n+\n+parser_invalid_block_macro_segment = cannot use a `block` macro fragment here\n+    .label = the `block` fragment is within this context\n+\n+parser_if_expression_missing_then_block = this `if` expression is missing a block after the condition\n+    .add_then_block = add a block here\n+    .condition_possibly_unfinished = this binary operation is possibly unfinished\n+\n+parser_if_expression_missing_condition = missing condition for `if` expression\n+    .condition_label = expected condition here\n+    .block_label = if this block is the condition of the `if` expression, then it must be followed by another block\n+\n+parser_expected_expression_found_let = expected expression, found `let` statement\n+\n+parser_expected_else_block = expected `{\"{\"}`, found {$first_tok}\n+    .label = expected an `if` or a block after this `else`\n+    .suggestion = add an `if` if this is the condition of a chained `else if` statement\n+\n+parser_outer_attribute_not_allowed_on_if_else = outer attributes are not allowed on `if` and `else` branches\n+    .branch_label = the attributes are attached to this branch\n+    .ctx_label = the branch belongs to this `{$ctx}`\n+    .suggestion = remove the attributes\n+\n+parser_missing_in_in_for_loop = missing `in` in `for` loop\n+    .use_in_not_of = try using `in` here instead\n+    .add_in = try adding `in` here\n+\n+parser_missing_comma_after_match_arm = expected `,` following `match` arm\n+    .suggestion = missing a comma here to end this `match` arm\n+\n+parser_catch_after_try = keyword `catch` cannot follow a `try` block\n+    .help = try using `match` on the result of the `try` block instead\n+\n+parser_comma_after_base_struct = cannot use a comma after the base struct\n+    .note = the base struct must always be the last field\n+    .suggestion = remove this comma\n+\n+parser_eq_field_init = expected `:`, found `=`\n+    .suggestion = replace equals symbol with a colon\n+\n+parser_dotdotdot = unexpected token: `...`\n+    .suggest_exclusive_range = use `..` for an exclusive range\n+    .suggest_inclusive_range = or `..=` for an inclusive range\n+\n+parser_left_arrow_operator = unexpected token: `<-`\n+    .suggestion = if you meant to write a comparison against a negative value, add a space in between `<` and `-`"}, {"sha": "443626d14b9f67c636bed05f1a7483d9366ce79d", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -364,8 +364,8 @@ impl<'a, 'p, 'tcx> fmt::Debug for PatCtxt<'a, 'p, 'tcx> {\n /// A row of a matrix. Rows of len 1 are very common, which is why `SmallVec[_; 2]`\n /// works well.\n #[derive(Clone)]\n-struct PatStack<'p, 'tcx> {\n-    pats: SmallVec<[&'p DeconstructedPat<'p, 'tcx>; 2]>,\n+pub(crate) struct PatStack<'p, 'tcx> {\n+    pub(crate) pats: SmallVec<[&'p DeconstructedPat<'p, 'tcx>; 2]>,\n }\n \n impl<'p, 'tcx> PatStack<'p, 'tcx> {\n@@ -403,6 +403,21 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         })\n     }\n \n+    // Recursively expand all patterns into their subpatterns and push each `PatStack` to matrix.\n+    fn expand_and_extend<'a>(&'a self, matrix: &mut Matrix<'p, 'tcx>) {\n+        if !self.is_empty() && self.head().is_or_pat() {\n+            for pat in self.head().iter_fields() {\n+                let mut new_patstack = PatStack::from_pattern(pat);\n+                new_patstack.pats.extend_from_slice(&self.pats[1..]);\n+                if !new_patstack.is_empty() && new_patstack.head().is_or_pat() {\n+                    new_patstack.expand_and_extend(matrix);\n+                } else if !new_patstack.is_empty() {\n+                    matrix.push(new_patstack);\n+                }\n+            }\n+        }\n+    }\n+\n     /// This computes `S(self.head().ctor(), self)`. See top of the file for explanations.\n     ///\n     /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n@@ -436,7 +451,7 @@ impl<'p, 'tcx> fmt::Debug for PatStack<'p, 'tcx> {\n /// A 2D matrix.\n #[derive(Clone)]\n pub(super) struct Matrix<'p, 'tcx> {\n-    patterns: Vec<PatStack<'p, 'tcx>>,\n+    pub patterns: Vec<PatStack<'p, 'tcx>>,\n }\n \n impl<'p, 'tcx> Matrix<'p, 'tcx> {\n@@ -453,7 +468,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     /// expands it.\n     fn push(&mut self, row: PatStack<'p, 'tcx>) {\n         if !row.is_empty() && row.head().is_or_pat() {\n-            self.patterns.extend(row.expand_or_pat());\n+            row.expand_and_extend(self);\n         } else {\n             self.patterns.push(row);\n         }"}, {"sha": "2c9f9a2c2c2006f8cb6f03d645e7e2cbe6ebcfc7", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -363,6 +363,349 @@ pub enum InvalidVariableDeclarationSub {\n     UseLetNotVar(#[primary_span] Span),\n }\n \n+#[derive(SessionDiagnostic)]\n+#[diag(parser::invalid_comparison_operator)]\n+pub(crate) struct InvalidComparisonOperator {\n+    #[primary_span]\n+    pub span: Span,\n+    pub invalid: String,\n+    #[subdiagnostic]\n+    pub sub: InvalidComparisonOperatorSub,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum InvalidComparisonOperatorSub {\n+    #[suggestion_short(\n+        parser::use_instead,\n+        applicability = \"machine-applicable\",\n+        code = \"{correct}\"\n+    )]\n+    Correctable {\n+        #[primary_span]\n+        span: Span,\n+        invalid: String,\n+        correct: String,\n+    },\n+    #[label(parser::spaceship_operator_invalid)]\n+    Spaceship(#[primary_span] Span),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::invalid_logical_operator)]\n+#[note]\n+pub(crate) struct InvalidLogicalOperator {\n+    #[primary_span]\n+    pub span: Span,\n+    pub incorrect: String,\n+    #[subdiagnostic]\n+    pub sub: InvalidLogicalOperatorSub,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum InvalidLogicalOperatorSub {\n+    #[suggestion_short(\n+        parser::use_amp_amp_for_conjunction,\n+        applicability = \"machine-applicable\",\n+        code = \"&&\"\n+    )]\n+    Conjunction(#[primary_span] Span),\n+    #[suggestion_short(\n+        parser::use_pipe_pipe_for_disjunction,\n+        applicability = \"machine-applicable\",\n+        code = \"||\"\n+    )]\n+    Disjunction(#[primary_span] Span),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::tilde_is_not_unary_operator)]\n+pub(crate) struct TildeAsUnaryOperator(\n+    #[primary_span]\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \"!\")]\n+    pub Span,\n+);\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::unexpected_token_after_not)]\n+pub(crate) struct NotAsNegationOperator {\n+    #[primary_span]\n+    pub negated: Span,\n+    pub negated_desc: String,\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \"!\")]\n+    pub not: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::malformed_loop_label)]\n+pub(crate) struct MalformedLoopLabel {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \"{correct_label}\")]\n+    pub span: Span,\n+    pub correct_label: Ident,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::lifetime_in_borrow_expression)]\n+pub(crate) struct LifetimeInBorrowExpression {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n+    #[label]\n+    pub lifetime_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::field_expression_with_generic)]\n+pub(crate) struct FieldExpressionWithGeneric(#[primary_span] pub Span);\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::macro_invocation_with_qualified_path)]\n+pub(crate) struct MacroInvocationWithQualifiedPath(#[primary_span] pub Span);\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::unexpected_token_after_label)]\n+pub(crate) struct UnexpectedTokenAfterLabel(\n+    #[primary_span]\n+    #[label(parser::unexpected_token_after_label)]\n+    pub Span,\n+);\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::require_colon_after_labeled_expression)]\n+#[note]\n+pub(crate) struct RequireColonAfterLabeledExpression {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub label: Span,\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \": \")]\n+    pub label_end: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::do_catch_syntax_removed)]\n+#[note]\n+pub(crate) struct DoCatchSyntaxRemoved {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \"try\")]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::float_literal_requires_integer_part)]\n+pub(crate) struct FloatLiteralRequiresIntegerPart {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \"{correct}\")]\n+    pub span: Span,\n+    pub correct: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::invalid_int_literal_width)]\n+#[help]\n+pub(crate) struct InvalidIntLiteralWidth {\n+    #[primary_span]\n+    pub span: Span,\n+    pub width: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::invalid_num_literal_base_prefix)]\n+#[note]\n+pub(crate) struct InvalidNumLiteralBasePrefix {\n+    #[primary_span]\n+    #[suggestion(applicability = \"maybe-incorrect\", code = \"{fixed}\")]\n+    pub span: Span,\n+    pub fixed: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::invalid_num_literal_suffix)]\n+#[help]\n+pub(crate) struct InvalidNumLiteralSuffix {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub suffix: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::invalid_float_literal_width)]\n+#[help]\n+pub(crate) struct InvalidFloatLiteralWidth {\n+    #[primary_span]\n+    pub span: Span,\n+    pub width: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::invalid_float_literal_suffix)]\n+#[help]\n+pub(crate) struct InvalidFloatLiteralSuffix {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub suffix: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::int_literal_too_large)]\n+pub(crate) struct IntLiteralTooLarge {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::missing_semicolon_before_array)]\n+pub(crate) struct MissingSemicolonBeforeArray {\n+    #[primary_span]\n+    pub open_delim: Span,\n+    #[suggestion_verbose(applicability = \"maybe-incorrect\", code = \";\")]\n+    pub semicolon: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::invalid_block_macro_segment)]\n+pub(crate) struct InvalidBlockMacroSegment {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub context: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::if_expression_missing_then_block)]\n+pub(crate) struct IfExpressionMissingThenBlock {\n+    #[primary_span]\n+    pub if_span: Span,\n+    #[subdiagnostic]\n+    pub sub: IfExpressionMissingThenBlockSub,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum IfExpressionMissingThenBlockSub {\n+    #[help(parser::condition_possibly_unfinished)]\n+    UnfinishedCondition(#[primary_span] Span),\n+    #[help(parser::add_then_block)]\n+    AddThenBlock(#[primary_span] Span),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::if_expression_missing_condition)]\n+pub(crate) struct IfExpressionMissingCondition {\n+    #[primary_span]\n+    #[label(parser::condition_label)]\n+    pub if_span: Span,\n+    #[label(parser::block_label)]\n+    pub block_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::expected_expression_found_let)]\n+pub(crate) struct ExpectedExpressionFoundLet {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::expected_else_block)]\n+pub(crate) struct ExpectedElseBlock {\n+    #[primary_span]\n+    pub first_tok_span: Span,\n+    pub first_tok: String,\n+    #[label]\n+    pub else_span: Span,\n+    #[suggestion(applicability = \"maybe-incorrect\", code = \"if \")]\n+    pub condition_start: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::outer_attribute_not_allowed_on_if_else)]\n+pub(crate) struct OuterAttributeNotAllowedOnIfElse {\n+    #[primary_span]\n+    pub last: Span,\n+\n+    #[label(parser::branch_label)]\n+    pub branch_span: Span,\n+\n+    #[label(parser::ctx_label)]\n+    pub ctx_span: Span,\n+    pub ctx: String,\n+\n+    #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n+    pub attributes: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::missing_in_in_for_loop)]\n+pub(crate) struct MissingInInForLoop {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: MissingInInForLoopSub,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum MissingInInForLoopSub {\n+    // Has been misleading, at least in the past (closed Issue #48492), thus maybe-incorrect\n+    #[suggestion_short(parser::use_in_not_of, applicability = \"maybe-incorrect\", code = \"in\")]\n+    InNotOf(#[primary_span] Span),\n+    #[suggestion_short(parser::add_in, applicability = \"maybe-incorrect\", code = \" in \")]\n+    AddIn(#[primary_span] Span),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::missing_comma_after_match_arm)]\n+pub(crate) struct MissingCommaAfterMatchArm {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \",\")]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::catch_after_try)]\n+#[help]\n+pub(crate) struct CatchAfterTry {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::comma_after_base_struct)]\n+#[note]\n+pub(crate) struct CommaAfterBaseStruct {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \"\")]\n+    pub comma: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::eq_field_init)]\n+pub(crate) struct EqFieldInit {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(applicability = \"machine-applicable\", code = \":\")]\n+    pub eq: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::dotdotdot)]\n+pub(crate) struct DotDotDot {\n+    #[primary_span]\n+    #[suggestion(parser::suggest_exclusive_range, applicability = \"maybe-incorrect\", code = \"..\")]\n+    #[suggestion(parser::suggest_inclusive_range, applicability = \"maybe-incorrect\", code = \"..=\")]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(parser::left_arrow_operator)]\n+pub(crate) struct LeftArrowOperator {\n+    #[primary_span]\n+    #[suggestion(applicability = \"maybe-incorrect\", code = \"< -\")]\n+    pub span: Span,\n+}\n+\n // SnapshotParser is used to create a snapshot of the parser\n // without causing duplicate errors being emitted when the `Parser`\n // is dropped."}, {"sha": "17117cbc8fbe6682e71b47a2274ce0cf1588db14", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 144, "deletions": 282, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,11 +1,26 @@\n-use super::diagnostics::SnapshotParser;\n+use super::diagnostics::{\n+    CatchAfterTry, CommaAfterBaseStruct, DoCatchSyntaxRemoved, DotDotDot, EqFieldInit,\n+    ExpectedElseBlock, ExpectedExpressionFoundLet, FieldExpressionWithGeneric,\n+    FloatLiteralRequiresIntegerPart, IfExpressionMissingCondition, IfExpressionMissingThenBlock,\n+    IfExpressionMissingThenBlockSub, InvalidBlockMacroSegment, InvalidComparisonOperator,\n+    InvalidComparisonOperatorSub, InvalidLogicalOperator, InvalidLogicalOperatorSub,\n+    LeftArrowOperator, LifetimeInBorrowExpression, MacroInvocationWithQualifiedPath,\n+    MalformedLoopLabel, MissingInInForLoop, MissingInInForLoopSub, MissingSemicolonBeforeArray,\n+    NotAsNegationOperator, OuterAttributeNotAllowedOnIfElse, RequireColonAfterLabeledExpression,\n+    SnapshotParser, TildeAsUnaryOperator, UnexpectedTokenAfterLabel,\n+};\n use super::pat::{CommaRecoveryMode, RecoverColon, RecoverComma, PARAM_EXPECTED};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{\n     AttrWrapper, BlockMode, ClosureSpans, ForceCollect, Parser, PathStyle, Restrictions,\n     SemiColonMode, SeqSep, TokenExpectType, TokenType, TrailingToken,\n };\n use crate::maybe_recover_from_interpolated_ty_qpath;\n+use crate::parser::diagnostics::{\n+    IntLiteralTooLarge, InvalidFloatLiteralSuffix, InvalidFloatLiteralWidth,\n+    InvalidIntLiteralWidth, InvalidNumLiteralBasePrefix, InvalidNumLiteralSuffix,\n+    MissingCommaAfterMatchArm,\n+};\n \n use core::mem;\n use rustc_ast::ptr::P;\n@@ -20,9 +35,10 @@ use rustc_ast::{AnonConst, BinOp, BinOpKind, FnDecl, FnRetTy, MacCall, Param, Ty\n use rustc_ast::{Arm, Async, BlockCheckMode, Expr, ExprKind, Label, Movability, RangeLimits};\n use rustc_ast::{ClosureBinder, StmtKind};\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, PResult};\n+use rustc_errors::{Applicability, Diagnostic, PResult};\n use rustc_session::lint::builtin::BREAK_WITH_LABEL_AND_LOOP;\n use rustc_session::lint::BuiltinLintDiagnostics;\n+use rustc_session::SessionDiagnostic;\n use rustc_span::source_map::{self, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Pos};\n@@ -216,15 +232,18 @@ impl<'a> Parser<'a> {\n                     AssocOp::Equal => \"==\",\n                     AssocOp::NotEqual => \"!=\",\n                     _ => unreachable!(),\n-                };\n-                self.struct_span_err(sp, &format!(\"invalid comparison operator `{sugg}=`\"))\n-                    .span_suggestion_short(\n-                        sp,\n-                        &format!(\"`{s}=` is not a valid comparison operator, use `{s}`\", s = sugg),\n-                        sugg,\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                }\n+                .into();\n+                let invalid = format!(\"{}=\", &sugg);\n+                self.sess.emit_err(InvalidComparisonOperator {\n+                    span: sp,\n+                    invalid: invalid.clone(),\n+                    sub: InvalidComparisonOperatorSub::Correctable {\n+                        span: sp,\n+                        invalid,\n+                        correct: sugg,\n+                    },\n+                });\n                 self.bump();\n             }\n \n@@ -234,14 +253,15 @@ impl<'a> Parser<'a> {\n                 && self.prev_token.span.hi() == self.token.span.lo()\n             {\n                 let sp = op.span.to(self.token.span);\n-                self.struct_span_err(sp, \"invalid comparison operator `<>`\")\n-                    .span_suggestion_short(\n-                        sp,\n-                        \"`<>` is not a valid comparison operator, use `!=`\",\n-                        \"!=\",\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                self.sess.emit_err(InvalidComparisonOperator {\n+                    span: sp,\n+                    invalid: \"<>\".into(),\n+                    sub: InvalidComparisonOperatorSub::Correctable {\n+                        span: sp,\n+                        invalid: \"<>\".into(),\n+                        correct: \"!=\".into(),\n+                    },\n+                });\n                 self.bump();\n             }\n \n@@ -251,12 +271,11 @@ impl<'a> Parser<'a> {\n                 && self.prev_token.span.hi() == self.token.span.lo()\n             {\n                 let sp = op.span.to(self.token.span);\n-                self.struct_span_err(sp, \"invalid comparison operator `<=>`\")\n-                    .span_label(\n-                        sp,\n-                        \"`<=>` is not a valid comparison operator, use `std::cmp::Ordering`\",\n-                    )\n-                    .emit();\n+                self.sess.emit_err(InvalidComparisonOperator {\n+                    span: sp,\n+                    invalid: \"<=>\".into(),\n+                    sub: InvalidComparisonOperatorSub::Spaceship(sp),\n+                });\n                 self.bump();\n             }\n \n@@ -430,31 +449,26 @@ impl<'a> Parser<'a> {\n             }\n             (Some(op), _) => (op, self.token.span),\n             (None, Some((Ident { name: sym::and, span }, false))) => {\n-                self.error_bad_logical_op(\"and\", \"&&\", \"conjunction\");\n+                self.sess.emit_err(InvalidLogicalOperator {\n+                    span: self.token.span,\n+                    incorrect: \"and\".into(),\n+                    sub: InvalidLogicalOperatorSub::Conjunction(self.token.span),\n+                });\n                 (AssocOp::LAnd, span)\n             }\n             (None, Some((Ident { name: sym::or, span }, false))) => {\n-                self.error_bad_logical_op(\"or\", \"||\", \"disjunction\");\n+                self.sess.emit_err(InvalidLogicalOperator {\n+                    span: self.token.span,\n+                    incorrect: \"or\".into(),\n+                    sub: InvalidLogicalOperatorSub::Disjunction(self.token.span),\n+                });\n                 (AssocOp::LOr, span)\n             }\n             _ => return None,\n         };\n         Some(source_map::respan(span, op))\n     }\n \n-    /// Error on `and` and `or` suggesting `&&` and `||` respectively.\n-    fn error_bad_logical_op(&self, bad: &str, good: &str, english: &str) {\n-        self.struct_span_err(self.token.span, &format!(\"`{bad}` is not a logical operator\"))\n-            .span_suggestion_short(\n-                self.token.span,\n-                &format!(\"use `{good}` to perform logical {english}\"),\n-                good,\n-                Applicability::MachineApplicable,\n-            )\n-            .note(\"unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\")\n-            .emit();\n-    }\n-\n     /// Checks if this expression is a successfully parsed statement.\n     fn expr_is_complete(&self, e: &Expr) -> bool {\n         self.restrictions.contains(Restrictions::STMT_EXPR)\n@@ -619,14 +633,7 @@ impl<'a> Parser<'a> {\n \n     // Recover on `!` suggesting for bitwise negation instead.\n     fn recover_tilde_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n-        self.struct_span_err(lo, \"`~` cannot be used as a unary operator\")\n-            .span_suggestion_short(\n-                lo,\n-                \"use `!` to perform bitwise not\",\n-                \"!\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.sess.emit_err(TildeAsUnaryOperator(lo));\n \n         self.parse_unary_expr(lo, UnOp::Not)\n     }\n@@ -652,20 +659,14 @@ impl<'a> Parser<'a> {\n     /// Recover on `not expr` in favor of `!expr`.\n     fn recover_not_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n         // Emit the error...\n-        let not_token = self.look_ahead(1, |t| t.clone());\n-        self.struct_span_err(\n-            not_token.span,\n-            &format!(\"unexpected {} after identifier\", super::token_descr(&not_token)),\n-        )\n-        .span_suggestion_short(\n+        let negated_token = self.look_ahead(1, |t| t.clone());\n+        self.sess.emit_err(NotAsNegationOperator {\n+            negated: negated_token.span,\n+            negated_desc: super::token_descr(&negated_token),\n             // Span the `not` plus trailing whitespace to avoid\n             // trailing whitespace after the `!` in our suggestion\n-            self.sess.source_map().span_until_non_whitespace(lo.to(not_token.span)),\n-            \"use `!` to perform logical negation\",\n-            \"!\",\n-            Applicability::MachineApplicable,\n-        )\n-        .emit();\n+            not: self.sess.source_map().span_until_non_whitespace(lo.to(negated_token.span)),\n+        });\n \n         // ...and recover!\n         self.parse_unary_expr(lo, UnOp::Not)\n@@ -725,14 +726,10 @@ impl<'a> Parser<'a> {\n                         match self.parse_labeled_expr(label, false) {\n                             Ok(expr) => {\n                                 type_err.cancel();\n-                                self.struct_span_err(label.ident.span, \"malformed loop label\")\n-                                    .span_suggestion(\n-                                        label.ident.span,\n-                                        \"use the correct loop label format\",\n-                                        label.ident,\n-                                        Applicability::MachineApplicable,\n-                                    )\n-                                    .emit();\n+                                self.sess.emit_err(MalformedLoopLabel {\n+                                    span: label.ident.span,\n+                                    correct_label: label.ident,\n+                                });\n                                 return Ok(expr);\n                             }\n                             Err(err) => {\n@@ -910,15 +907,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn error_remove_borrow_lifetime(&self, span: Span, lt_span: Span) {\n-        self.struct_span_err(span, \"borrow expressions cannot be annotated with lifetimes\")\n-            .span_label(lt_span, \"annotated with lifetime here\")\n-            .span_suggestion(\n-                lt_span,\n-                \"remove the lifetime annotation\",\n-                \"\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.sess.emit_err(LifetimeInBorrowExpression { span, lifetime_span: lt_span });\n     }\n \n     /// Parse `mut?` or `raw [ const | mut ]`.\n@@ -1272,11 +1261,7 @@ impl<'a> Parser<'a> {\n         } else {\n             // Field access `expr.f`\n             if let Some(args) = segment.args {\n-                self.struct_span_err(\n-                    args.span(),\n-                    \"field expressions cannot have generic arguments\",\n-                )\n-                .emit();\n+                self.sess.emit_err(FieldExpressionWithGeneric(args.span()));\n             }\n \n             let span = lo.to(self.prev_token.span);\n@@ -1489,7 +1474,7 @@ impl<'a> Parser<'a> {\n         let (span, kind) = if self.eat(&token::Not) {\n             // MACRO INVOCATION expression\n             if qself.is_some() {\n-                self.struct_span_err(path.span, \"macros cannot use qualified paths\").emit();\n+                self.sess.emit_err(MacroInvocationWithQualifiedPath(path.span));\n             }\n             let lo = path.span;\n             let mac = P(MacCall {\n@@ -1535,11 +1520,11 @@ impl<'a> Parser<'a> {\n             && (self.check_noexpect(&TokenKind::Comma) || self.check_noexpect(&TokenKind::Gt))\n         {\n             // We're probably inside of a `Path<'a>` that needs a turbofish\n-            let msg = \"expected `while`, `for`, `loop` or `{` after a label\";\n-            self.struct_span_err(self.token.span, msg).span_label(self.token.span, msg).emit();\n+            self.sess.emit_err(UnexpectedTokenAfterLabel(self.token.span));\n             consume_colon = false;\n             Ok(self.mk_expr_err(lo))\n         } else {\n+            // FIXME: use UnexpectedTokenAfterLabel, needs multipart suggestions\n             let msg = \"expected `while`, `for`, `loop` or `{` after a label\";\n \n             let mut err = self.struct_span_err(self.token.span, msg);\n@@ -1604,42 +1589,25 @@ impl<'a> Parser<'a> {\n         }?;\n \n         if !ate_colon && consume_colon {\n-            self.error_labeled_expr_must_be_followed_by_colon(lo, expr.span);\n+            self.sess.emit_err(RequireColonAfterLabeledExpression {\n+                span: expr.span,\n+                label: lo,\n+                label_end: lo.shrink_to_hi(),\n+            });\n         }\n \n         Ok(expr)\n     }\n \n-    fn error_labeled_expr_must_be_followed_by_colon(&self, lo: Span, span: Span) {\n-        self.struct_span_err(span, \"labeled expression must be followed by `:`\")\n-            .span_label(lo, \"the label\")\n-            .span_suggestion_short(\n-                lo.shrink_to_hi(),\n-                \"add `:` after the label\",\n-                \": \",\n-                Applicability::MachineApplicable,\n-            )\n-            .note(\"labels are used before loops and blocks, allowing e.g., `break 'label` to them\")\n-            .emit();\n-    }\n-\n     /// Recover on the syntax `do catch { ... }` suggesting `try { ... }` instead.\n     fn recover_do_catch(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n \n         self.bump(); // `do`\n         self.bump(); // `catch`\n \n-        let span_dc = lo.to(self.prev_token.span);\n-        self.struct_span_err(span_dc, \"found removed `do catch` syntax\")\n-            .span_suggestion(\n-                span_dc,\n-                \"replace with the new syntax\",\n-                \"try\",\n-                Applicability::MachineApplicable,\n-            )\n-            .note(\"following RFC #2388, the new non-placeholder syntax is `try`\")\n-            .emit();\n+        let span = lo.to(self.prev_token.span);\n+        self.sess.emit_err(DoCatchSyntaxRemoved { span });\n \n         self.parse_try_block(lo)\n     }\n@@ -1834,14 +1802,10 @@ impl<'a> Parser<'a> {\n     }\n \n     fn error_float_lits_must_have_int_part(&self, token: &Token) {\n-        self.struct_span_err(token.span, \"float literals must have an integer part\")\n-            .span_suggestion(\n-                token.span,\n-                \"must have an integer part\",\n-                pprust::token_to_string(token),\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.sess.emit_err(FloatLiteralRequiresIntegerPart {\n+            span: token.span,\n+            correct: pprust::token_to_string(token).into_owned(),\n+        });\n     }\n \n     fn report_lit_error(&self, err: LitError, lit: token::Lit, span: Span) {\n@@ -1883,43 +1847,22 @@ impl<'a> Parser<'a> {\n                 let suf = suf.as_str();\n                 if looks_like_width_suffix(&['i', 'u'], &suf) {\n                     // If it looks like a width, try to be helpful.\n-                    let msg = format!(\"invalid width `{}` for integer literal\", &suf[1..]);\n-                    self.struct_span_err(span, &msg)\n-                        .help(\"valid widths are 8, 16, 32, 64 and 128\")\n-                        .emit();\n+                    self.sess.emit_err(InvalidIntLiteralWidth { span, width: suf[1..].into() });\n                 } else if let Some(fixed) = fix_base_capitalisation(suf) {\n-                    let msg = \"invalid base prefix for number literal\";\n-\n-                    self.struct_span_err(span, msg)\n-                        .note(\"base prefixes (`0xff`, `0b1010`, `0o755`) are lowercase\")\n-                        .span_suggestion(\n-                            span,\n-                            \"try making the prefix lowercase\",\n-                            fixed,\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                        .emit();\n+                    self.sess.emit_err(InvalidNumLiteralBasePrefix { span, fixed });\n                 } else {\n-                    let msg = format!(\"invalid suffix `{suf}` for number literal\");\n-                    self.struct_span_err(span, &msg)\n-                        .span_label(span, format!(\"invalid suffix `{suf}`\"))\n-                        .help(\"the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\")\n-                        .emit();\n+                    self.sess.emit_err(InvalidNumLiteralSuffix { span, suffix: suf.to_string() });\n                 }\n             }\n             LitError::InvalidFloatSuffix => {\n                 let suf = suffix.expect(\"suffix error with no suffix\");\n                 let suf = suf.as_str();\n                 if looks_like_width_suffix(&['f'], suf) {\n                     // If it looks like a width, try to be helpful.\n-                    let msg = format!(\"invalid width `{}` for float literal\", &suf[1..]);\n-                    self.struct_span_err(span, &msg).help(\"valid widths are 32 and 64\").emit();\n+                    self.sess\n+                        .emit_err(InvalidFloatLiteralWidth { span, width: suf[1..].to_string() });\n                 } else {\n-                    let msg = format!(\"invalid suffix `{suf}` for float literal\");\n-                    self.struct_span_err(span, &msg)\n-                        .span_label(span, format!(\"invalid suffix `{suf}`\"))\n-                        .help(\"valid suffixes are `f32` and `f64`\")\n-                        .emit();\n+                    self.sess.emit_err(InvalidFloatLiteralSuffix { span, suffix: suf.to_string() });\n                 }\n             }\n             LitError::NonDecimalFloat(base) => {\n@@ -1934,7 +1877,7 @@ impl<'a> Parser<'a> {\n                     .emit();\n             }\n             LitError::IntTooLarge => {\n-                self.struct_span_err(span, \"integer literal is too large\").emit();\n+                self.sess.emit_err(IntLiteralTooLarge { span });\n             }\n         }\n     }\n@@ -2046,14 +1989,10 @@ impl<'a> Parser<'a> {\n                         .span_to_snippet(snapshot.token.span)\n                         .map_or(false, |snippet| snippet == \"]\") =>\n                 {\n-                    let mut err = self.struct_span_err(open_delim_span, \"expected `;`, found `[`\");\n-                    err.span_suggestion_verbose(\n-                        prev_span.shrink_to_hi(),\n-                        \"consider adding `;` here\",\n-                        ';',\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    return Err(err);\n+                    return Err(MissingSemicolonBeforeArray {\n+                        open_delim: open_delim_span,\n+                        semicolon: prev_span.shrink_to_hi(),\n+                    }.into_diagnostic(self.sess));\n                 }\n                 Ok(_) => (),\n                 Err(err) => err.cancel(),\n@@ -2080,9 +2019,10 @@ impl<'a> Parser<'a> {\n         }\n \n         if self.token.is_whole_block() {\n-            self.struct_span_err(self.token.span, \"cannot use a `block` macro fragment here\")\n-                .span_label(lo.to(self.token.span), \"the `block` fragment is within this context\")\n-                .emit();\n+            self.sess.emit_err(InvalidBlockMacroSegment {\n+                span: self.token.span,\n+                context: lo.to(self.token.span),\n+            });\n         }\n \n         let (attrs, blk) = self.parse_block_common(lo, blk_mode)?;\n@@ -2252,11 +2192,19 @@ impl<'a> Parser<'a> {\n             let block = match &mut cond.kind {\n                 ExprKind::Binary(Spanned { span: binop_span, .. }, _, right)\n                     if let ExprKind::Block(_, None) = right.kind => {\n-                        this.error_missing_if_then_block(lo, cond_span.shrink_to_lo().to(*binop_span), true).emit();\n+                        self.sess.emit_err(IfExpressionMissingThenBlock {\n+                            if_span: lo,\n+                            sub: IfExpressionMissingThenBlockSub::UnfinishedCondition(\n+                                cond_span.shrink_to_lo().to(*binop_span)\n+                            ),\n+                        });\n                         std::mem::replace(right, this.mk_expr_err(binop_span.shrink_to_hi()))\n                     },\n                 ExprKind::Block(_, None) => {\n-                    this.error_missing_if_cond(lo, cond_span).emit();\n+                    self.sess.emit_err(IfExpressionMissingCondition {\n+                        if_span: self.sess.source_map().next_point(lo),\n+                        block_span: self.sess.source_map().start_point(cond_span),\n+                    });\n                     std::mem::replace(&mut cond, this.mk_expr_err(cond_span.shrink_to_hi()))\n                 }\n                 _ => {\n@@ -2274,7 +2222,10 @@ impl<'a> Parser<'a> {\n             if let Some(block) = recover_block_from_condition(self) {\n                 block\n             } else {\n-                self.error_missing_if_then_block(lo, cond_span, false).emit();\n+                self.sess.emit_err(IfExpressionMissingThenBlock {\n+                    if_span: lo,\n+                    sub: IfExpressionMissingThenBlockSub::AddThenBlock(cond_span.shrink_to_hi()),\n+                });\n                 self.mk_block_err(cond_span.shrink_to_hi())\n             }\n         } else {\n@@ -2302,39 +2253,6 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::If(cond, thn, els)))\n     }\n \n-    fn error_missing_if_then_block(\n-        &self,\n-        if_span: Span,\n-        cond_span: Span,\n-        is_unfinished: bool,\n-    ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        let mut err = self.struct_span_err(\n-            if_span,\n-            \"this `if` expression is missing a block after the condition\",\n-        );\n-        if is_unfinished {\n-            err.span_help(cond_span, \"this binary operation is possibly unfinished\");\n-        } else {\n-            err.span_help(cond_span.shrink_to_hi(), \"add a block here\");\n-        }\n-        err\n-    }\n-\n-    fn error_missing_if_cond(\n-        &self,\n-        lo: Span,\n-        span: Span,\n-    ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        let next_span = self.sess.source_map().next_point(lo);\n-        let mut err = self.struct_span_err(next_span, \"missing condition for `if` expression\");\n-        err.span_label(next_span, \"expected condition here\");\n-        err.span_label(\n-            self.sess.source_map().start_point(span),\n-            \"if this block is the condition of the `if` expression, then it must be followed by another block\"\n-        );\n-        err\n-    }\n-\n     /// Parses the condition of a `if` or `while` expression.\n     fn parse_cond_expr(&mut self) -> PResult<'a, P<Expr>> {\n         self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL | Restrictions::ALLOW_LET, None)\n@@ -2350,8 +2268,7 @@ impl<'a> Parser<'a> {\n             TokenKind::AndAnd | TokenKind::Ident(kw::If, _) | TokenKind::Ident(kw::While, _)\n         );\n         if !self.restrictions.contains(Restrictions::ALLOW_LET) || not_in_chain {\n-            self.struct_span_err(self.token.span, \"expected expression, found `let` statement\")\n-                .emit();\n+            self.sess.emit_err(ExpectedExpressionFoundLet { span: self.token.span });\n         }\n \n         self.bump(); // Eat `let` token\n@@ -2389,15 +2306,12 @@ impl<'a> Parser<'a> {\n                     if self.check(&TokenKind::OpenDelim(Delimiter::Brace))\n                         && classify::expr_requires_semi_to_be_stmt(&cond) =>\n                 {\n-                    self.struct_span_err(first_tok_span, format!(\"expected `{{`, found {first_tok}\"))\n-                        .span_label(else_span, \"expected an `if` or a block after this `else`\")\n-                        .span_suggestion(\n-                            cond.span.shrink_to_lo(),\n-                            \"add an `if` if this is the condition of a chained `else if` statement\",\n-                            \"if \",\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                        .emit();\n+                    self.sess.emit_err(ExpectedElseBlock {\n+                        first_tok_span,\n+                        first_tok,\n+                        else_span,\n+                        condition_start: cond.span.shrink_to_lo(),\n+                    });\n                     self.parse_if_after_cond(cond.span.shrink_to_lo(), cond)?\n                 }\n                 Err(e) => {\n@@ -2422,16 +2336,18 @@ impl<'a> Parser<'a> {\n         branch_span: Span,\n         attrs: &[ast::Attribute],\n     ) {\n-        let (span, last) = match attrs {\n+        let (attributes, last) = match attrs {\n             [] => return,\n             [x0 @ xn] | [x0, .., xn] => (x0.span.to(xn.span), xn.span),\n         };\n         let ctx = if is_ctx_else { \"else\" } else { \"if\" };\n-        self.struct_span_err(last, \"outer attributes are not allowed on `if` and `else` branches\")\n-            .span_label(branch_span, \"the attributes are attached to this branch\")\n-            .span_label(ctx_span, format!(\"the branch belongs to this `{ctx}`\"))\n-            .span_suggestion(span, \"remove the attributes\", \"\", Applicability::MachineApplicable)\n-            .emit();\n+        self.sess.emit_err(OuterAttributeNotAllowedOnIfElse {\n+            last,\n+            branch_span,\n+            ctx_span,\n+            ctx: ctx.to_string(),\n+            attributes,\n+        });\n     }\n \n     /// Parses `for <src_pat> in <src_expr> <src_loop_block>` (`for` token already eaten).\n@@ -2465,23 +2381,16 @@ impl<'a> Parser<'a> {\n     }\n \n     fn error_missing_in_for_loop(&mut self) {\n-        let (span, msg, sugg) = if self.token.is_ident_named(sym::of) {\n+        let (span, sub): (_, fn(_) -> _) = if self.token.is_ident_named(sym::of) {\n             // Possibly using JS syntax (#75311).\n             let span = self.token.span;\n             self.bump();\n-            (span, \"try using `in` here instead\", \"in\")\n+            (span, MissingInInForLoopSub::InNotOf)\n         } else {\n-            (self.prev_token.span.between(self.token.span), \"try adding `in` here\", \" in \")\n+            (self.prev_token.span.between(self.token.span), MissingInInForLoopSub::AddIn)\n         };\n-        self.struct_span_err(span, \"missing `in` in `for` loop\")\n-            .span_suggestion_short(\n-                span,\n-                msg,\n-                sugg,\n-                // Has been misleading, at least in the past (closed Issue #48492).\n-                Applicability::MaybeIncorrect,\n-            )\n-            .emit();\n+\n+        self.sess.emit_err(MissingInInForLoop { span, sub: sub(span) });\n     }\n \n     /// Parses a `while` or `while let` expression (`while` token already eaten).\n@@ -2787,17 +2696,9 @@ impl<'a> Parser<'a> {\n                                 .is_ok();\n                             if pattern_follows && snapshot.check(&TokenKind::FatArrow) {\n                                 err.cancel();\n-                                this.struct_span_err(\n-                                    hi.shrink_to_hi(),\n-                                    \"expected `,` following `match` arm\",\n-                                )\n-                                .span_suggestion(\n-                                    hi.shrink_to_hi(),\n-                                    \"missing a comma here to end this `match` arm\",\n-                                    \",\",\n-                                    Applicability::MachineApplicable,\n-                                )\n-                                .emit();\n+                                this.sess.emit_err(MissingCommaAfterMatchArm {\n+                                    span: hi.shrink_to_hi(),\n+                                });\n                                 return Ok(true);\n                             }\n                         }\n@@ -2827,13 +2728,7 @@ impl<'a> Parser<'a> {\n     fn parse_try_block(&mut self, span_lo: Span) -> PResult<'a, P<Expr>> {\n         let (attrs, body) = self.parse_inner_attrs_and_block()?;\n         if self.eat_keyword(kw::Catch) {\n-            let mut error = self.struct_span_err(\n-                self.prev_token.span,\n-                \"keyword `catch` cannot follow a `try` block\",\n-            );\n-            error.help(\"try using `match` on the result of the `try` block instead\");\n-            error.emit();\n-            Err(error)\n+            Err(CatchAfterTry { span: self.prev_token.span }.into_diagnostic(self.sess))\n         } else {\n             let span = span_lo.to(body.span);\n             self.sess.gated_spans.gate(sym::try_blocks, span);\n@@ -3082,18 +2977,10 @@ impl<'a> Parser<'a> {\n         if self.token != token::Comma {\n             return;\n         }\n-        self.struct_span_err(\n-            span.to(self.prev_token.span),\n-            \"cannot use a comma after the base struct\",\n-        )\n-        .span_suggestion_short(\n-            self.token.span,\n-            \"remove this comma\",\n-            \"\",\n-            Applicability::MachineApplicable,\n-        )\n-        .note(\"the base struct must always be the last field\")\n-        .emit();\n+        self.sess.emit_err(CommaAfterBaseStruct {\n+            span: span.to(self.prev_token.span),\n+            comma: self.token.span,\n+        });\n         self.recover_stmt();\n     }\n \n@@ -3139,43 +3026,18 @@ impl<'a> Parser<'a> {\n             return;\n         }\n \n-        self.struct_span_err(self.token.span, \"expected `:`, found `=`\")\n-            .span_suggestion(\n-                field_name.span.shrink_to_hi().to(self.token.span),\n-                \"replace equals symbol with a colon\",\n-                \":\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.sess.emit_err(EqFieldInit {\n+            span: self.token.span,\n+            eq: field_name.span.shrink_to_hi().to(self.token.span),\n+        });\n     }\n \n     fn err_dotdotdot_syntax(&self, span: Span) {\n-        self.struct_span_err(span, \"unexpected token: `...`\")\n-            .span_suggestion(\n-                span,\n-                \"use `..` for an exclusive range\",\n-                \"..\",\n-                Applicability::MaybeIncorrect,\n-            )\n-            .span_suggestion(\n-                span,\n-                \"or `..=` for an inclusive range\",\n-                \"..=\",\n-                Applicability::MaybeIncorrect,\n-            )\n-            .emit();\n+        self.sess.emit_err(DotDotDot { span });\n     }\n \n     fn err_larrow_operator(&self, span: Span) {\n-        self.struct_span_err(span, \"unexpected token: `<-`\")\n-            .span_suggestion(\n-                span,\n-                \"if you meant to write a comparison against a negative value, add a \\\n-             space in between `<` and `-`\",\n-                \"< -\",\n-                Applicability::MaybeIncorrect,\n-            )\n-            .emit();\n+        self.sess.emit_err(LeftArrowOperator { span });\n     }\n \n     fn mk_assign_op(&self, binop: BinOp, lhs: P<Expr>, rhs: P<Expr>) -> ExprKind {"}, {"sha": "ed653f0f9c82d70c1dc7bbddfa65916af368dfaf", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -69,9 +69,11 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n     ) {\n         let cause =\n             traits::ObligationCause::new(span, self.body_id, ObligationCauseCode::WellFormed(loc));\n+        // for a type to be WF, we do not need to check if const trait predicates satisfy.\n+        let param_env = self.param_env.without_const();\n         self.ocx.register_obligation(traits::Obligation::new(\n             cause,\n-            self.param_env,\n+            param_env,\n             ty::Binder::dummy(ty::PredicateKind::WellFormed(arg)).to_predicate(self.tcx()),\n         ));\n     }\n@@ -1449,7 +1451,13 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n     assert_eq!(predicates.predicates.len(), predicates.spans.len());\n     let wf_obligations =\n         iter::zip(&predicates.predicates, &predicates.spans).flat_map(|(&p, &sp)| {\n-            traits::wf::predicate_obligations(infcx, wfcx.param_env, wfcx.body_id, p, sp)\n+            traits::wf::predicate_obligations(\n+                infcx,\n+                wfcx.param_env.without_const(),\n+                wfcx.body_id,\n+                p,\n+                sp,\n+            )\n         });\n \n     let obligations: Vec<_> = wf_obligations.chain(default_obligations).collect();"}, {"sha": "4583bc9a158efc02c059e239c40962faf529f9ce", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1010,7 +1010,8 @@ impl<T> BinaryHeap<T> {\n     /// current length. The allocator may reserve more space to speculatively\n     /// avoid frequent allocations. After calling `try_reserve`, capacity will be\n     /// greater than or equal to `self.len() + additional` if it returns\n-    /// `Ok(())`. Does nothing if capacity is already sufficient.\n+    /// `Ok(())`. Does nothing if capacity is already sufficient. This method\n+    /// preserves the contents even if an error occurs.\n     ///\n     /// # Errors\n     ///"}, {"sha": "347a938fd0c5896b92650c5aecd6901431c1918b", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -794,7 +794,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// in the given deque. The collection may reserve more space to speculatively avoid\n     /// frequent reallocations. After calling `try_reserve`, capacity will be\n     /// greater than or equal to `self.len() + additional` if it returns\n-    /// `Ok(())`. Does nothing if capacity is already sufficient.\n+    /// `Ok(())`. Does nothing if capacity is already sufficient. This method\n+    /// preserves the contents even if an error occurs.\n     ///\n     /// # Errors\n     ///"}, {"sha": "e28ace4795f994aaf89123fc443087bef8075dfc", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1080,7 +1080,8 @@ impl String {\n     /// current length. The allocator may reserve more space to speculatively\n     /// avoid frequent allocations. After calling `try_reserve`, capacity will be\n     /// greater than or equal to `self.len() + additional` if it returns\n-    /// `Ok(())`. Does nothing if capacity is already sufficient.\n+    /// `Ok(())`. Does nothing if capacity is already sufficient. This method\n+    /// preserves the contents even if an error occurs.\n     ///\n     /// # Errors\n     ///"}, {"sha": "4351548811d2eb9a0ab594cfbce590fb8747cd38", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -148,7 +148,7 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n \n     #[inline]\n     fn next(&mut self) -> Option<T> {\n-        if self.ptr as *const _ == self.end {\n+        if self.ptr == self.end {\n             None\n         } else if mem::size_of::<T>() == 0 {\n             // purposefully don't use 'ptr.offset' because for"}, {"sha": "2c786fd511eada2e8a1f96cb708b1e62e7f2a51d", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -875,7 +875,8 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// in the given `Vec<T>`. The collection may reserve more space to speculatively avoid\n     /// frequent reallocations. After calling `try_reserve`, capacity will be\n     /// greater than or equal to `self.len() + additional` if it returns\n-    /// `Ok(())`. Does nothing if capacity is already sufficient.\n+    /// `Ok(())`. Does nothing if capacity is already sufficient. This method\n+    /// preserves the contents even if an error occurs.\n     ///\n     /// # Errors\n     ///\n@@ -2927,6 +2928,8 @@ unsafe impl<#[may_dangle] T, A: Allocator> Drop for Vec<T, A> {\n #[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n impl<T> const Default for Vec<T> {\n     /// Creates an empty `Vec<T>`.\n+    ///\n+    /// The vector will not allocate until elements are pushed onto it.\n     fn default() -> Vec<T> {\n         Vec::new()\n     }"}, {"sha": "99bfb2a45ed90434fc79f63d492ed539313bb330", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -38,6 +38,7 @@\n #![feature(const_str_from_utf8)]\n #![feature(nonnull_slice_from_raw_parts)]\n #![feature(panic_update_hook)]\n+#![feature(pointer_is_aligned)]\n #![feature(slice_flatten)]\n #![feature(thin_box)]\n #![feature(bench_black_box)]"}, {"sha": "e008b0cc35718dd8fe0533cb41f61ac66c44eb41", "filename": "library/alloc/tests/thin_box.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Falloc%2Ftests%2Fthin_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Falloc%2Ftests%2Fthin_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fthin_box.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -48,11 +48,11 @@ fn verify_aligned<T>(ptr: *const T) {\n     // practice these checks are mostly just smoke-detectors for an extremely\n     // broken `ThinBox` impl, since it's an extremely subtle piece of code.\n     let ptr = core::hint::black_box(ptr);\n-    let align = core::mem::align_of::<T>();\n     assert!(\n-        (ptr.addr() & (align - 1)) == 0 && !ptr.is_null(),\n-        \"misaligned ThinBox data; valid pointers to `{}` should be aligned to {align}: {ptr:p}\",\n-        core::any::type_name::<T>(),\n+        ptr.is_aligned() && !ptr.is_null(),\n+        \"misaligned ThinBox data; valid pointers to `{ty}` should be aligned to {align}: {ptr:p}\",\n+        ty = core::any::type_name::<T>(),\n+        align = core::mem::align_of::<T>(),\n     );\n }\n "}, {"sha": "441d2382686935b5dc321c095c45d2f7f274f787", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -2139,7 +2139,7 @@ pub(crate) use assert_unsafe_precondition;\n /// Checks whether `ptr` is properly aligned with respect to\n /// `align_of::<T>()`.\n pub(crate) fn is_aligned_and_not_null<T>(ptr: *const T) -> bool {\n-    !ptr.is_null() && ptr.addr() % mem::align_of::<T>() == 0\n+    !ptr.is_null() && ptr.is_aligned()\n }\n \n /// Checks whether the regions of memory starting at `src` and `dst` of size"}, {"sha": "80ed34157e6dcd24b221c81a9dd50a12827dc892", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -290,7 +290,8 @@ impl OsString {\n     /// in the given `OsString`. The string may reserve more space to speculatively avoid\n     /// frequent reallocations. After calling `try_reserve`, capacity will be\n     /// greater than or equal to `self.len() + additional` if it returns `Ok(())`.\n-    /// Does nothing if capacity is already sufficient.\n+    /// Does nothing if capacity is already sufficient. This method preserves\n+    /// the contents even if an error occurs.\n     ///\n     /// See the main `OsString` documentation information about encoding and capacity units.\n     ///"}, {"sha": "71bbf4317e0a5a8767e18763389ad7bd03407d1e", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -296,6 +296,7 @@\n #![feature(panic_can_unwind)]\n #![feature(panic_info_message)]\n #![feature(panic_internals)]\n+#![feature(pointer_is_aligned)]\n #![feature(portable_simd)]\n #![feature(prelude_2024)]\n #![feature(provide_any)]"}, {"sha": "6004810655ebb65ac9c2c725eb7cb767357b1730", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 133, "deletions": 71, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -620,25 +620,31 @@ impl Ipv4Addr {\n         matches!(self.octets(), [169, 254, ..])\n     }\n \n-    /// Returns [`true`] if the address appears to be globally routable.\n-    /// See [iana-ipv4-special-registry][ipv4-sr].\n+    /// Returns [`true`] if the address appears to be globally reachable\n+    /// as specified by the [IANA IPv4 Special-Purpose Address Registry].\n+    /// Whether or not an address is practically reachable will depend on your network configuration.\n+    ///\n+    /// Most IPv4 addresses are globally reachable;\n+    /// unless they are specifically defined as *not* globally reachable.\n     ///\n-    /// The following return [`false`]:\n+    /// Non-exhaustive list of notable addresses that are not globally reachable:\n     ///\n-    /// - private addresses (see [`Ipv4Addr::is_private()`])\n-    /// - the loopback address (see [`Ipv4Addr::is_loopback()`])\n-    /// - the link-local address (see [`Ipv4Addr::is_link_local()`])\n-    /// - the broadcast address (see [`Ipv4Addr::is_broadcast()`])\n-    /// - addresses used for documentation (see [`Ipv4Addr::is_documentation()`])\n-    /// - the unspecified address (see [`Ipv4Addr::is_unspecified()`]), and the whole\n-    ///   `0.0.0.0/8` block\n-    /// - addresses reserved for future protocols, except\n-    /// `192.0.0.9/32` and `192.0.0.10/32` which are globally routable\n-    /// - addresses reserved for future use (see [`Ipv4Addr::is_reserved()`]\n-    /// - addresses reserved for networking devices benchmarking (see\n-    /// [`Ipv4Addr::is_benchmarking()`])\n+    /// - The [unspecified address] ([`is_unspecified`](Ipv4Addr::is_unspecified))\n+    /// - Addresses reserved for private use ([`is_private`](Ipv4Addr::is_private))\n+    /// - Addresses in the shared address space ([`is_shared`](Ipv4Addr::is_shared))\n+    /// - Loopback addresses ([`is_loopback`](Ipv4Addr::is_loopback))\n+    /// - Link-local addresses ([`is_link_local`](Ipv4Addr::is_link_local))\n+    /// - Addresses reserved for documentation ([`is_documentation`](Ipv4Addr::is_documentation))\n+    /// - Addresses reserved for benchmarking ([`is_benchmarking`](Ipv4Addr::is_benchmarking))\n+    /// - Reserved addresses ([`is_reserved`](Ipv4Addr::is_reserved))\n+    /// - The [broadcast address] ([`is_broadcast`](Ipv4Addr::is_broadcast))\n     ///\n-    /// [ipv4-sr]: https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml\n+    /// For the complete overview of which addresses are globally reachable, see the table at the [IANA IPv4 Special-Purpose Address Registry].\n+    ///\n+    /// [IANA IPv4 Special-Purpose Address Registry]: https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml\n+    /// [unspecified address]: Ipv4Addr::UNSPECIFIED\n+    /// [broadcast address]: Ipv4Addr::BROADCAST\n+\n     ///\n     /// # Examples\n     ///\n@@ -647,71 +653,61 @@ impl Ipv4Addr {\n     ///\n     /// use std::net::Ipv4Addr;\n     ///\n-    /// // private addresses are not global\n+    /// // Most IPv4 addresses are globally reachable:\n+    /// assert_eq!(Ipv4Addr::new(80, 9, 12, 3).is_global(), true);\n+    ///\n+    /// // However some addresses have been assigned a special meaning\n+    /// // that makes them not globally reachable. Some examples are:\n+    ///\n+    /// // The unspecified address (`0.0.0.0`)\n+    /// assert_eq!(Ipv4Addr::UNSPECIFIED.is_global(), false);\n+    ///\n+    /// // Addresses reserved for private use (`10.0.0.0/8`, `172.16.0.0/12`, 192.168.0.0/16)\n     /// assert_eq!(Ipv4Addr::new(10, 254, 0, 0).is_global(), false);\n     /// assert_eq!(Ipv4Addr::new(192, 168, 10, 65).is_global(), false);\n     /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_global(), false);\n     ///\n-    /// // the 0.0.0.0/8 block is not global\n-    /// assert_eq!(Ipv4Addr::new(0, 1, 2, 3).is_global(), false);\n-    /// // in particular, the unspecified address is not global\n-    /// assert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_global(), false);\n+    /// // Addresses in the shared address space (`100.64.0.0/10`)\n+    /// assert_eq!(Ipv4Addr::new(100, 100, 0, 0).is_global(), false);\n     ///\n-    /// // the loopback address is not global\n-    /// assert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_global(), false);\n+    /// // The loopback addresses (`127.0.0.0/8`)\n+    /// assert_eq!(Ipv4Addr::LOCALHOST.is_global(), false);\n     ///\n-    /// // link local addresses are not global\n+    /// // Link-local addresses (`169.254.0.0/16`)\n     /// assert_eq!(Ipv4Addr::new(169, 254, 45, 1).is_global(), false);\n     ///\n-    /// // the broadcast address is not global\n-    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_global(), false);\n-    ///\n-    /// // the address space designated for documentation is not global\n+    /// // Addresses reserved for documentation (`192.0.2.0/24`, `198.51.100.0/24`, `203.0.113.0/24`)\n     /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_global(), false);\n     /// assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_global(), false);\n     /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_global(), false);\n     ///\n-    /// // shared addresses are not global\n-    /// assert_eq!(Ipv4Addr::new(100, 100, 0, 0).is_global(), false);\n-    ///\n-    /// // addresses reserved for protocol assignment are not global\n-    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 0).is_global(), false);\n-    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 255).is_global(), false);\n+    /// // Addresses reserved for benchmarking (`198.18.0.0/15`)\n+    /// assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_global(), false);\n     ///\n-    /// // addresses reserved for future use are not global\n+    /// // Reserved addresses (`240.0.0.0/4`)\n     /// assert_eq!(Ipv4Addr::new(250, 10, 20, 30).is_global(), false);\n     ///\n-    /// // addresses reserved for network devices benchmarking are not global\n-    /// assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_global(), false);\n+    /// // The broadcast address (`255.255.255.255`)\n+    /// assert_eq!(Ipv4Addr::BROADCAST.is_global(), false);\n     ///\n-    /// // All the other addresses are global\n-    /// assert_eq!(Ipv4Addr::new(1, 1, 1, 1).is_global(), true);\n-    /// assert_eq!(Ipv4Addr::new(80, 9, 12, 3).is_global(), true);\n+    /// // For a complete overview see the IANA IPv4 Special-Purpose Address Registry.\n     /// ```\n     #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n     #[unstable(feature = \"ip\", issue = \"27709\")]\n     #[must_use]\n     #[inline]\n     pub const fn is_global(&self) -> bool {\n-        // check if this address is 192.0.0.9 or 192.0.0.10. These addresses are the only two\n-        // globally routable addresses in the 192.0.0.0/24 range.\n-        if u32::from_be_bytes(self.octets()) == 0xc0000009\n-            || u32::from_be_bytes(self.octets()) == 0xc000000a\n-        {\n-            return true;\n-        }\n-        !self.is_private()\n-            && !self.is_loopback()\n-            && !self.is_link_local()\n-            && !self.is_broadcast()\n-            && !self.is_documentation()\n-            && !self.is_shared()\n+        !(self.octets()[0] == 0 // \"This network\"\n+            || self.is_private()\n+            || self.is_shared()\n+            || self.is_loopback()\n+            || self.is_link_local()\n             // addresses reserved for future protocols (`192.0.0.0/24`)\n-            && !(self.octets()[0] == 192 && self.octets()[1] == 0 && self.octets()[2] == 0)\n-            && !self.is_reserved()\n-            && !self.is_benchmarking()\n-            // Make sure the address is not in 0.0.0.0/8\n-            && self.octets()[0] != 0\n+            ||(self.octets()[0] == 192 && self.octets()[1] == 0 && self.octets()[2] == 0)\n+            || self.is_documentation()\n+            || self.is_benchmarking()\n+            || self.is_reserved()\n+            || self.is_broadcast())\n     }\n \n     /// Returns [`true`] if this address is part of the Shared Address Space defined in\n@@ -1300,13 +1296,33 @@ impl Ipv6Addr {\n         u128::from_be_bytes(self.octets()) == u128::from_be_bytes(Ipv6Addr::LOCALHOST.octets())\n     }\n \n-    /// Returns [`true`] if the address appears to be globally routable.\n+    /// Returns [`true`] if the address appears to be globally reachable\n+    /// as specified by the [IANA IPv6 Special-Purpose Address Registry].\n+    /// Whether or not an address is practically reachable will depend on your network configuration.\n     ///\n-    /// The following return [`false`]:\n+    /// Most IPv6 addresses are globally reachable;\n+    /// unless they are specifically defined as *not* globally reachable.\n     ///\n-    /// - the loopback address\n-    /// - link-local and unique local unicast addresses\n-    /// - interface-, link-, realm-, admin- and site-local multicast addresses\n+    /// Non-exhaustive list of notable addresses that are not globally reachable:\n+    /// - The [unspecified address] ([`is_unspecified`](Ipv6Addr::is_unspecified))\n+    /// - The [loopback address] ([`is_loopback`](Ipv6Addr::is_loopback))\n+    /// - IPv4-mapped addresses\n+    /// - Addresses reserved for benchmarking\n+    /// - Addresses reserved for documentation ([`is_documentation`](Ipv6Addr::is_documentation))\n+    /// - Unique local addresses ([`is_unique_local`](Ipv6Addr::is_unique_local))\n+    /// - Unicast addresses with link-local scope ([`is_unicast_link_local`](Ipv6Addr::is_unicast_link_local))\n+    ///\n+    /// For the complete overview of which addresses are globally reachable, see the table at the [IANA IPv6 Special-Purpose Address Registry].\n+    ///\n+    /// Note that an address having global scope is not the same as being globally reachable,\n+    /// and there is no direct relation between the two concepts: There exist addresses with global scope\n+    /// that are not globally reachable (for example unique local addresses),\n+    /// and addresses that are globally reachable without having global scope\n+    /// (multicast addresses with non-global scope).\n+    ///\n+    /// [IANA IPv6 Special-Purpose Address Registry]: https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml\n+    /// [unspecified address]: Ipv6Addr::UNSPECIFIED\n+    /// [loopback address]: Ipv6Addr::LOCALHOST\n     ///\n     /// # Examples\n     ///\n@@ -1315,20 +1331,65 @@ impl Ipv6Addr {\n     ///\n     /// use std::net::Ipv6Addr;\n     ///\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_global(), true);\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_global(), false);\n-    /// assert_eq!(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1).is_global(), true);\n+    /// // Most IPv6 addresses are globally reachable:\n+    /// assert_eq!(Ipv6Addr::new(0x26, 0, 0x1c9, 0, 0, 0xafc8, 0x10, 0x1).is_global(), true);\n+    ///\n+    /// // However some addresses have been assigned a special meaning\n+    /// // that makes them not globally reachable. Some examples are:\n+    ///\n+    /// // The unspecified address (`::`)\n+    /// assert_eq!(Ipv6Addr::UNSPECIFIED.is_global(), false);\n+    ///\n+    /// // The loopback address (`::1`)\n+    /// assert_eq!(Ipv6Addr::LOCALHOST.is_global(), false);\n+    ///\n+    /// // IPv4-mapped addresses (`::ffff:0:0/96`)\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_global(), false);\n+    ///\n+    /// // Addresses reserved for benchmarking (`2001:2::/48`)\n+    /// assert_eq!(Ipv6Addr::new(0x2001, 2, 0, 0, 0, 0, 0, 1,).is_global(), false);\n+    ///\n+    /// // Addresses reserved for documentation (`2001:db8::/32`)\n+    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1).is_global(), false);\n+    ///\n+    /// // Unique local addresses (`fc00::/7`)\n+    /// assert_eq!(Ipv6Addr::new(0xfc02, 0, 0, 0, 0, 0, 0, 1).is_global(), false);\n+    ///\n+    /// // Unicast addresses with link-local scope (`fe80::/10`)\n+    /// assert_eq!(Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 1).is_global(), false);\n+    ///\n+    /// // For a complete overview see the IANA IPv6 Special-Purpose Address Registry.\n     /// ```\n     #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n     #[unstable(feature = \"ip\", issue = \"27709\")]\n     #[must_use]\n     #[inline]\n     pub const fn is_global(&self) -> bool {\n-        match self.multicast_scope() {\n-            Some(Ipv6MulticastScope::Global) => true,\n-            None => self.is_unicast_global(),\n-            _ => false,\n-        }\n+        !(self.is_unspecified()\n+            || self.is_loopback()\n+            // IPv4-mapped Address (`::ffff:0:0/96`)\n+            || matches!(self.segments(), [0, 0, 0, 0, 0, 0xffff, _, _])\n+            // IPv4-IPv6 Translat. (`64:ff9b:1::/48`)\n+            || matches!(self.segments(), [0x64, 0xff9b, 1, _, _, _, _, _])\n+            // Discard-Only Address Block (`100::/64`)\n+            || matches!(self.segments(), [0x100, 0, 0, 0, _, _, _, _])\n+            // IETF Protocol Assignments (`2001::/23`)\n+            || (matches!(self.segments(), [0x2001, b, _, _, _, _, _, _] if b < 0x200)\n+                && !(\n+                    // Port Control Protocol Anycast (`2001:1::1`)\n+                    u128::from_be_bytes(self.octets()) == 0x2001_0001_0000_0000_0000_0000_0000_0001\n+                    // Traversal Using Relays around NAT Anycast (`2001:1::2`)\n+                    || u128::from_be_bytes(self.octets()) == 0x2001_0001_0000_0000_0000_0000_0000_0002\n+                    // AMT (`2001:3::/32`)\n+                    || matches!(self.segments(), [0x2001, 3, _, _, _, _, _, _])\n+                    // AS112-v6 (`2001:4:112::/48`)\n+                    || matches!(self.segments(), [0x2001, 4, 0x112, _, _, _, _, _])\n+                    // ORCHIDv2 (`2001:20::/28`)\n+                    || matches!(self.segments(), [0x2001, b, _, _, _, _, _, _] if b >= 0x20 && b <= 0x2F)\n+                ))\n+            || self.is_documentation()\n+            || self.is_unique_local()\n+            || self.is_unicast_link_local())\n     }\n \n     /// Returns [`true`] if this is a unique local address (`fc00::/7`).\n@@ -1525,6 +1586,7 @@ impl Ipv6Addr {\n             && !self.is_unique_local()\n             && !self.is_unspecified()\n             && !self.is_documentation()\n+            && !self.is_benchmarking()\n     }\n \n     /// Returns the address's multicast scope if the address is multicast."}, {"sha": "7c3430b2b217c5b838e22a63bf3511e846bc0f56", "filename": "library/std/src/net/ip/tests.rs", "status": "modified", "additions": 84, "deletions": 14, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -321,15 +321,15 @@ fn ip_properties() {\n     check!(\"fe80:ffff::\");\n     check!(\"febf:ffff::\");\n     check!(\"fec0::\", global);\n-    check!(\"ff01::\", multicast);\n-    check!(\"ff02::\", multicast);\n-    check!(\"ff03::\", multicast);\n-    check!(\"ff04::\", multicast);\n-    check!(\"ff05::\", multicast);\n-    check!(\"ff08::\", multicast);\n+    check!(\"ff01::\", global | multicast);\n+    check!(\"ff02::\", global | multicast);\n+    check!(\"ff03::\", global | multicast);\n+    check!(\"ff04::\", global | multicast);\n+    check!(\"ff05::\", global | multicast);\n+    check!(\"ff08::\", global | multicast);\n     check!(\"ff0e::\", global | multicast);\n     check!(\"2001:db8:85a3::8a2e:370:7334\", doc);\n-    check!(\"2001:2::ac32:23ff:21\", global | benchmarking);\n+    check!(\"2001:2::ac32:23ff:21\", benchmarking);\n     check!(\"102:304:506:708:90a:b0c:d0e:f10\", global);\n }\n \n@@ -609,6 +609,60 @@ fn ipv6_properties() {\n \n     check!(\"1::\", &[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], global | unicast_global);\n \n+    check!(\n+        \"::ffff:127.0.0.1\",\n+        &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, 0x7f, 0, 0, 1],\n+        unicast_global\n+    );\n+\n+    check!(\n+        \"64:ff9b:1::\",\n+        &[0, 0x64, 0xff, 0x9b, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        unicast_global\n+    );\n+\n+    check!(\"100::\", &[0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_global);\n+\n+    check!(\"2001::\", &[0x20, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_global);\n+\n+    check!(\n+        \"2001:1::1\",\n+        &[0x20, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n+        global | unicast_global\n+    );\n+\n+    check!(\n+        \"2001:1::2\",\n+        &[0x20, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n+        global | unicast_global\n+    );\n+\n+    check!(\n+        \"2001:3::\",\n+        &[0x20, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        global | unicast_global\n+    );\n+\n+    check!(\n+        \"2001:4:112::\",\n+        &[0x20, 1, 0, 4, 1, 0x12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        global | unicast_global\n+    );\n+\n+    check!(\n+        \"2001:20::\",\n+        &[0x20, 1, 0, 0x20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        global | unicast_global\n+    );\n+\n+    check!(\"2001:30::\", &[0x20, 1, 0, 0x30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_global);\n+\n+    check!(\n+        \"2001:200::\",\n+        &[0x20, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        global | unicast_global\n+    );\n+\n     check!(\"fc00::\", &[0xfc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unique_local);\n \n     check!(\n@@ -666,21 +720,37 @@ fn ipv6_properties() {\n     check!(\n         \"ff01::\",\n         &[0xff, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        multicast_interface_local\n+        multicast_interface_local | global\n     );\n \n-    check!(\"ff02::\", &[0xff, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], multicast_link_local);\n+    check!(\n+        \"ff02::\",\n+        &[0xff, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_link_local | global\n+    );\n \n-    check!(\"ff03::\", &[0xff, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], multicast_realm_local);\n+    check!(\n+        \"ff03::\",\n+        &[0xff, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_realm_local | global\n+    );\n \n-    check!(\"ff04::\", &[0xff, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], multicast_admin_local);\n+    check!(\n+        \"ff04::\",\n+        &[0xff, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_admin_local | global\n+    );\n \n-    check!(\"ff05::\", &[0xff, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], multicast_site_local);\n+    check!(\n+        \"ff05::\",\n+        &[0xff, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_site_local | global\n+    );\n \n     check!(\n         \"ff08::\",\n         &[0xff, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-        multicast_organization_local\n+        multicast_organization_local | global\n     );\n \n     check!(\n@@ -698,7 +768,7 @@ fn ipv6_properties() {\n     check!(\n         \"2001:2::ac32:23ff:21\",\n         &[0x20, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0xac, 0x32, 0x23, 0xff, 0, 0x21],\n-        global | unicast_global | benchmarking\n+        benchmarking\n     );\n \n     check!("}, {"sha": "5409bd1777c2aadbe1f73a5ccb21326d58db3bce", "filename": "library/std/src/sys/sgx/abi/usercalls/alloc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -117,7 +117,7 @@ pub unsafe trait UserSafe {\n     /// * the pointer is null.\n     /// * the pointed-to range is not in user memory.\n     unsafe fn check_ptr(ptr: *const Self) {\n-        let is_aligned = |p: *const u8| -> bool { 0 == p.addr() & (Self::align_of() - 1) };\n+        let is_aligned = |p: *const u8| -> bool { p.is_aligned_to(Self::align_of()) };\n \n         assert!(is_aligned(ptr as *const u8));\n         assert!(is_user_range(ptr as _, mem::size_of_val(unsafe { &*ptr })));\n@@ -386,7 +386,7 @@ pub(crate) unsafe fn copy_to_userspace(src: *const u8, dst: *mut u8, len: usize)\n         unsafe {\n             copy_bytewise_to_userspace(src, dst, len);\n         }\n-    } else if len % 8 == 0 && dst as usize % 8 == 0 {\n+    } else if len % 8 == 0 && dst.is_aligned_to(8) {\n         // Copying 8-byte aligned quadwords: copy quad word per quad word\n         unsafe {\n             copy_quadwords(src, dst, len);"}, {"sha": "33e20756163fd8761989eb9cf209053909575ed5", "filename": "library/std/src/sys_common/wtf8.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -236,7 +236,8 @@ impl Wtf8Buf {\n     /// in the given `Wtf8Buf`. The `Wtf8Buf` may reserve more space to avoid\n     /// frequent reallocations. After calling `try_reserve`, capacity will be\n     /// greater than or equal to `self.len() + additional`. Does nothing if\n-    /// capacity is already sufficient.\n+    /// capacity is already sufficient. This method preserves the contents even\n+    /// if an error occurs.\n     ///\n     /// # Errors\n     ///"}, {"sha": "04378dbf374d9d74e312363997242227ebbc1dbc", "filename": "src/test/mir-opt/const_prop/aggregate.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Faggregate.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Faggregate.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Faggregate.main.ConstProp.diff?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -24,7 +24,7 @@\n +         _1 = const 1_i32;                // scope 0 at $DIR/aggregate.rs:+1:13: +1:28\n           StorageDead(_2);                 // scope 0 at $DIR/aggregate.rs:+1:27: +1:28\n           StorageDead(_3);                 // scope 0 at $DIR/aggregate.rs:+1:28: +1:29\n-          nop;                             // scope 0 at $DIR/aggregate.rs:+0:11: +2:2\n+          _0 = const ();                   // scope 0 at $DIR/aggregate.rs:+0:11: +2:2\n           StorageDead(_1);                 // scope 0 at $DIR/aggregate.rs:+2:1: +2:2\n           return;                          // scope 0 at $DIR/aggregate.rs:+2:2: +2:2\n       }"}, {"sha": "493d0508a046ddfd220f36f17f2fb9879b7ab44b", "filename": "src/test/mir-opt/const_prop/aggregate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Faggregate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Faggregate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Faggregate.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test: ConstProp\n // compile-flags: -O\n \n // EMIT_MIR aggregate.main.ConstProp.diff"}, {"sha": "439b2a3e16b458fde72d7328c8436f8e48f9fdc9", "filename": "src/test/mir-opt/const_prop/array_index.main.ConstProp.32bit.diff", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Farray_index.main.ConstProp.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Farray_index.main.ConstProp.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Farray_index.main.ConstProp.32bit.diff?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -18,19 +18,20 @@\n           _2 = [const 0_u32, const 1_u32, const 2_u32, const 3_u32]; // scope 0 at $DIR/array_index.rs:+1:18: +1:30\n           StorageLive(_3);                 // scope 0 at $DIR/array_index.rs:+1:31: +1:32\n           _3 = const 2_usize;              // scope 0 at $DIR/array_index.rs:+1:31: +1:32\n-          _4 = const 4_usize;              // scope 0 at $DIR/array_index.rs:+1:18: +1:33\n+-         _4 = Len(_2);                    // scope 0 at $DIR/array_index.rs:+1:18: +1:33\n -         _5 = Lt(_3, _4);                 // scope 0 at $DIR/array_index.rs:+1:18: +1:33\n -         assert(move _5, \"index out of bounds: the length is {} but the index is {}\", move _4, _3) -> bb1; // scope 0 at $DIR/array_index.rs:+1:18: +1:33\n++         _4 = const 4_usize;              // scope 0 at $DIR/array_index.rs:+1:18: +1:33\n +         _5 = const true;                 // scope 0 at $DIR/array_index.rs:+1:18: +1:33\n-+         assert(const true, \"index out of bounds: the length is {} but the index is {}\", const 4_usize, const 2_usize) -> bb1; // scope 0 at $DIR/array_index.rs:+1:18: +1:33\n++         assert(const true, \"index out of bounds: the length is {} but the index is {}\", move _4, _3) -> bb1; // scope 0 at $DIR/array_index.rs:+1:18: +1:33\n       }\n   \n       bb1: {\n -         _1 = _2[_3];                     // scope 0 at $DIR/array_index.rs:+1:18: +1:33\n +         _1 = const 2_u32;                // scope 0 at $DIR/array_index.rs:+1:18: +1:33\n           StorageDead(_3);                 // scope 0 at $DIR/array_index.rs:+1:33: +1:34\n           StorageDead(_2);                 // scope 0 at $DIR/array_index.rs:+1:33: +1:34\n-          nop;                             // scope 0 at $DIR/array_index.rs:+0:11: +2:2\n+          _0 = const ();                   // scope 0 at $DIR/array_index.rs:+0:11: +2:2\n           StorageDead(_1);                 // scope 0 at $DIR/array_index.rs:+2:1: +2:2\n           return;                          // scope 0 at $DIR/array_index.rs:+2:2: +2:2\n       }"}, {"sha": "439b2a3e16b458fde72d7328c8436f8e48f9fdc9", "filename": "src/test/mir-opt/const_prop/array_index.main.ConstProp.64bit.diff", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Farray_index.main.ConstProp.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Farray_index.main.ConstProp.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Farray_index.main.ConstProp.64bit.diff?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -18,19 +18,20 @@\n           _2 = [const 0_u32, const 1_u32, const 2_u32, const 3_u32]; // scope 0 at $DIR/array_index.rs:+1:18: +1:30\n           StorageLive(_3);                 // scope 0 at $DIR/array_index.rs:+1:31: +1:32\n           _3 = const 2_usize;              // scope 0 at $DIR/array_index.rs:+1:31: +1:32\n-          _4 = const 4_usize;              // scope 0 at $DIR/array_index.rs:+1:18: +1:33\n+-         _4 = Len(_2);                    // scope 0 at $DIR/array_index.rs:+1:18: +1:33\n -         _5 = Lt(_3, _4);                 // scope 0 at $DIR/array_index.rs:+1:18: +1:33\n -         assert(move _5, \"index out of bounds: the length is {} but the index is {}\", move _4, _3) -> bb1; // scope 0 at $DIR/array_index.rs:+1:18: +1:33\n++         _4 = const 4_usize;              // scope 0 at $DIR/array_index.rs:+1:18: +1:33\n +         _5 = const true;                 // scope 0 at $DIR/array_index.rs:+1:18: +1:33\n-+         assert(const true, \"index out of bounds: the length is {} but the index is {}\", const 4_usize, const 2_usize) -> bb1; // scope 0 at $DIR/array_index.rs:+1:18: +1:33\n++         assert(const true, \"index out of bounds: the length is {} but the index is {}\", move _4, _3) -> bb1; // scope 0 at $DIR/array_index.rs:+1:18: +1:33\n       }\n   \n       bb1: {\n -         _1 = _2[_3];                     // scope 0 at $DIR/array_index.rs:+1:18: +1:33\n +         _1 = const 2_u32;                // scope 0 at $DIR/array_index.rs:+1:18: +1:33\n           StorageDead(_3);                 // scope 0 at $DIR/array_index.rs:+1:33: +1:34\n           StorageDead(_2);                 // scope 0 at $DIR/array_index.rs:+1:33: +1:34\n-          nop;                             // scope 0 at $DIR/array_index.rs:+0:11: +2:2\n+          _0 = const ();                   // scope 0 at $DIR/array_index.rs:+0:11: +2:2\n           StorageDead(_1);                 // scope 0 at $DIR/array_index.rs:+2:1: +2:2\n           return;                          // scope 0 at $DIR/array_index.rs:+2:2: +2:2\n       }"}, {"sha": "d31c2827b4e0ac94daede6bdfac232dfc1a66204", "filename": "src/test/mir-opt/const_prop/array_index.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Farray_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Farray_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Farray_index.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test: ConstProp\n // EMIT_MIR_FOR_EACH_BIT_WIDTH\n \n // EMIT_MIR array_index.main.ConstProp.diff"}, {"sha": "bea32a67ef4a031b87d257845dfe6be9f105e9d3", "filename": "src/test/mir-opt/const_prop/bad_op_div_by_zero.main.ConstProp.diff", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero.main.ConstProp.diff?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -24,10 +24,9 @@\n           StorageLive(_3);                 // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:18: +2:19\n -         _3 = _1;                         // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:18: +2:19\n -         _4 = Eq(_3, const 0_i32);        // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n--         assert(!move _4, \"attempt to divide `{}` by zero\", const 1_i32) -> bb1; // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n +         _3 = const 0_i32;                // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:18: +2:19\n +         _4 = const true;                 // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n-+         assert(!const true, \"attempt to divide `{}` by zero\", const 1_i32) -> bb1; // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n+          assert(!move _4, \"attempt to divide `{}` by zero\", const 1_i32) -> bb1; // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n       }\n   \n       bb1: {\n@@ -38,14 +37,13 @@\n +         _5 = const false;                // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n +         _6 = const false;                // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n +         _7 = const false;                // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n-+         assert(!const false, \"attempt to compute `{} / {}`, which would overflow\", const 1_i32, const 0_i32) -> bb2; // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n++         assert(!const false, \"attempt to compute `{} / {}`, which would overflow\", const 1_i32, _3) -> bb2; // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n       }\n   \n       bb2: {\n--         _2 = Div(const 1_i32, move _3);  // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n-+         _2 = Div(const 1_i32, const 0_i32); // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n+          _2 = Div(const 1_i32, move _3);  // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:14: +2:19\n           StorageDead(_3);                 // scope 1 at $DIR/bad_op_div_by_zero.rs:+2:18: +2:19\n-          nop;                             // scope 0 at $DIR/bad_op_div_by_zero.rs:+0:11: +3:2\n+          _0 = const ();                   // scope 0 at $DIR/bad_op_div_by_zero.rs:+0:11: +3:2\n           StorageDead(_2);                 // scope 1 at $DIR/bad_op_div_by_zero.rs:+3:1: +3:2\n           StorageDead(_1);                 // scope 0 at $DIR/bad_op_div_by_zero.rs:+3:1: +3:2\n           return;                          // scope 0 at $DIR/bad_op_div_by_zero.rs:+3:2: +3:2"}, {"sha": "a6fd325ece035d14f2b9924911ace9a31aa44de7", "filename": "src/test/mir-opt/const_prop/bad_op_div_by_zero.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test: ConstProp\n // EMIT_MIR bad_op_div_by_zero.main.ConstProp.diff\n #[allow(unconditional_panic)]\n fn main() {"}, {"sha": "c7b609949cd15a58a146013fcd4a79f82483b30f", "filename": "src/test/mir-opt/const_prop/boolean_identities.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboolean_identities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboolean_identities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboolean_identities.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test: ConstProp\n // compile-flags: -O -Zmir-opt-level=4\n \n // EMIT_MIR boolean_identities.test.ConstProp.diff"}, {"sha": "cb82a7bea149381b42e68f9cc0be10961b0a0c2e", "filename": "src/test/mir-opt/const_prop/boxes.main.ConstProp.diff", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboxes.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboxes.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboxes.main.ConstProp.diff?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -24,12 +24,11 @@\n           StorageLive(_3);                 // scope 0 at $DIR/boxes.rs:+1:14: +1:22\n -         _4 = SizeOf(i32);                // scope 2 at $DIR/boxes.rs:+1:14: +1:22\n -         _5 = AlignOf(i32);               // scope 2 at $DIR/boxes.rs:+1:14: +1:22\n--         _6 = alloc::alloc::exchange_malloc(move _4, move _5) -> bb1; // scope 2 at $DIR/boxes.rs:+1:14: +1:22\n +         _4 = const 4_usize;              // scope 2 at $DIR/boxes.rs:+1:14: +1:22\n +         _5 = const 4_usize;              // scope 2 at $DIR/boxes.rs:+1:14: +1:22\n-+         _6 = alloc::alloc::exchange_malloc(const 4_usize, const 4_usize) -> bb1; // scope 2 at $DIR/boxes.rs:+1:14: +1:22\n+          _6 = alloc::alloc::exchange_malloc(move _4, move _5) -> bb1; // scope 2 at $DIR/boxes.rs:+1:14: +1:22\n                                            // mir::Constant\n-                                           // + span: $DIR/boxes.rs:12:14: 12:22\n+                                           // + span: $DIR/boxes.rs:13:14: 13:22\n                                            // + literal: Const { ty: unsafe fn(usize, usize) -> *mut u8 {alloc::alloc::exchange_malloc}, val: Value(<ZST>) }\n       }\n   \n@@ -53,7 +52,7 @@\n   \n       bb2: {\n           StorageDead(_3);                 // scope 0 at $DIR/boxes.rs:+1:26: +1:27\n-          nop;                             // scope 0 at $DIR/boxes.rs:+0:11: +2:2\n+          _0 = const ();                   // scope 0 at $DIR/boxes.rs:+0:11: +2:2\n           StorageDead(_1);                 // scope 0 at $DIR/boxes.rs:+2:1: +2:2\n           return;                          // scope 0 at $DIR/boxes.rs:+2:2: +2:2\n       }"}, {"sha": "d287830db5a56ed86aa83c6ca6a440e9e590ee99", "filename": "src/test/mir-opt/const_prop/boxes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboxes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboxes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboxes.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test: ConstProp\n // compile-flags: -O\n // ignore-emscripten compiled with panic=abort by default\n // ignore-wasm32"}, {"sha": "e040a4b3a53e92b4c3ca489e3c81b5e6d0e996ae", "filename": "src/test/mir-opt/const_prop/cast.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcast.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcast.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcast.main.ConstProp.diff?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -19,7 +19,7 @@\n           StorageLive(_2);                 // scope 1 at $DIR/cast.rs:+3:9: +3:10\n -         _2 = const 42_u32 as u8 (Misc);  // scope 1 at $DIR/cast.rs:+3:13: +3:24\n +         _2 = const 42_u8;                // scope 1 at $DIR/cast.rs:+3:13: +3:24\n-          nop;                             // scope 0 at $DIR/cast.rs:+0:11: +4:2\n+          _0 = const ();                   // scope 0 at $DIR/cast.rs:+0:11: +4:2\n           StorageDead(_2);                 // scope 1 at $DIR/cast.rs:+4:1: +4:2\n           StorageDead(_1);                 // scope 0 at $DIR/cast.rs:+4:1: +4:2\n           return;                          // scope 0 at $DIR/cast.rs:+4:2: +4:2"}, {"sha": "984086eda48b0a0225ca5f8b4d51cf56a60dae91", "filename": "src/test/mir-opt/const_prop/cast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcast.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test: ConstProp\n // EMIT_MIR cast.main.ConstProp.diff\n \n fn main() {"}, {"sha": "96d0d25664a41d15d7aa54c8a942626c08b476fe", "filename": "src/test/mir-opt/const_prop/checked_add.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fchecked_add.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fchecked_add.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fchecked_add.main.ConstProp.diff?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -20,7 +20,7 @@\n       bb1: {\n -         _1 = move (_2.0: u32);           // scope 0 at $DIR/checked_add.rs:+1:18: +1:23\n +         _1 = const 2_u32;                // scope 0 at $DIR/checked_add.rs:+1:18: +1:23\n-          nop;                             // scope 0 at $DIR/checked_add.rs:+0:11: +2:2\n+          _0 = const ();                   // scope 0 at $DIR/checked_add.rs:+0:11: +2:2\n           StorageDead(_1);                 // scope 0 at $DIR/checked_add.rs:+2:1: +2:2\n           return;                          // scope 0 at $DIR/checked_add.rs:+2:2: +2:2\n       }"}, {"sha": "b9860da4c82204777d579a06a4f024fdbaca2037", "filename": "src/test/mir-opt/const_prop/checked_add.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fchecked_add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fchecked_add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fchecked_add.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test: ConstProp\n // compile-flags: -C overflow-checks=on\n \n // EMIT_MIR checked_add.main.ConstProp.diff"}, {"sha": "2cb071deab13fc0ac87f4b9989ce36978cb0c618", "filename": "src/test/mir-opt/const_prop/const_prop_fails_gracefully.main.ConstProp.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fconst_prop_fails_gracefully.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fconst_prop_fails_gracefully.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fconst_prop_fails_gracefully.main.ConstProp.diff?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -18,7 +18,7 @@\n           StorageLive(_3);                 // scope 0 at $DIR/const_prop_fails_gracefully.rs:+2:13: +2:16\n           _3 = const FOO;                  // scope 0 at $DIR/const_prop_fails_gracefully.rs:+2:13: +2:16\n                                            // mir::Constant\n-                                           // + span: $DIR/const_prop_fails_gracefully.rs:7:13: 7:16\n+                                           // + span: $DIR/const_prop_fails_gracefully.rs:8:13: 8:16\n                                            // + literal: Const { ty: &i32, val: Unevaluated(FOO, [], None) }\n           _2 = &raw const (*_3);           // scope 0 at $DIR/const_prop_fails_gracefully.rs:+2:13: +2:16\n           _1 = move _2 as usize (PointerExposeAddress); // scope 0 at $DIR/const_prop_fails_gracefully.rs:+2:13: +2:39\n@@ -29,14 +29,14 @@\n           _5 = _1;                         // scope 1 at $DIR/const_prop_fails_gracefully.rs:+3:10: +3:11\n           _4 = read(move _5) -> bb1;       // scope 1 at $DIR/const_prop_fails_gracefully.rs:+3:5: +3:12\n                                            // mir::Constant\n-                                           // + span: $DIR/const_prop_fails_gracefully.rs:8:5: 8:9\n+                                           // + span: $DIR/const_prop_fails_gracefully.rs:9:5: 9:9\n                                            // + literal: Const { ty: fn(usize) {read}, val: Value(<ZST>) }\n       }\n   \n       bb1: {\n           StorageDead(_5);                 // scope 1 at $DIR/const_prop_fails_gracefully.rs:+3:11: +3:12\n           StorageDead(_4);                 // scope 1 at $DIR/const_prop_fails_gracefully.rs:+3:12: +3:13\n-          nop;                             // scope 0 at $DIR/const_prop_fails_gracefully.rs:+0:11: +4:2\n+          _0 = const ();                   // scope 0 at $DIR/const_prop_fails_gracefully.rs:+0:11: +4:2\n           StorageDead(_1);                 // scope 0 at $DIR/const_prop_fails_gracefully.rs:+4:1: +4:2\n           return;                          // scope 0 at $DIR/const_prop_fails_gracefully.rs:+4:2: +4:2\n       }"}, {"sha": "0a3dcbd380fa823b44acb921e7bab8b9ee1a64cb", "filename": "src/test/mir-opt/const_prop/const_prop_fails_gracefully.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fconst_prop_fails_gracefully.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fconst_prop_fails_gracefully.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fconst_prop_fails_gracefully.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test: ConstProp\n #[inline(never)]\n fn read(_: usize) { }\n "}, {"sha": "7dbe8e7344b1227bb4cbf6389efb961301a4e5bc", "filename": "src/test/mir-opt/const_prop/control-flow-simplification.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcontrol-flow-simplification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcontrol-flow-simplification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcontrol-flow-simplification.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,10 +1,11 @@\n+// unit-test: ConstProp\n // compile-flags: -Zmir-opt-level=1\n \n-trait NeedsDrop:Sized{\n-    const NEEDS:bool=std::mem::needs_drop::<Self>();\n+trait NeedsDrop: Sized {\n+    const NEEDS: bool = std::mem::needs_drop::<Self>();\n }\n \n-impl<This> NeedsDrop for This{}\n+impl<This> NeedsDrop for This {}\n \n // EMIT_MIR control_flow_simplification.hello.ConstProp.diff\n // EMIT_MIR control_flow_simplification.hello.PreCodegen.before.mir"}, {"sha": "6b29bb59c40dacc56c3161cb4bdfe71a6e0d6098", "filename": "src/test/mir-opt/const_prop/discriminant.main.ConstProp.32bit.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.32bit.diff?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -44,7 +44,7 @@\n           _1 = Add(move _2, const 0_i32);  // scope 0 at $DIR/discriminant.rs:+1:13: +1:68\n           StorageDead(_2);                 // scope 0 at $DIR/discriminant.rs:+1:67: +1:68\n           StorageDead(_3);                 // scope 0 at $DIR/discriminant.rs:+1:68: +1:69\n-          nop;                             // scope 0 at $DIR/discriminant.rs:+0:11: +2:2\n+          _0 = const ();                   // scope 0 at $DIR/discriminant.rs:+0:11: +2:2\n           StorageDead(_1);                 // scope 0 at $DIR/discriminant.rs:+2:1: +2:2\n           return;                          // scope 0 at $DIR/discriminant.rs:+2:2: +2:2\n       }"}, {"sha": "6b29bb59c40dacc56c3161cb4bdfe71a6e0d6098", "filename": "src/test/mir-opt/const_prop/discriminant.main.ConstProp.64bit.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.64bit.diff?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -44,7 +44,7 @@\n           _1 = Add(move _2, const 0_i32);  // scope 0 at $DIR/discriminant.rs:+1:13: +1:68\n           StorageDead(_2);                 // scope 0 at $DIR/discriminant.rs:+1:67: +1:68\n           StorageDead(_3);                 // scope 0 at $DIR/discriminant.rs:+1:68: +1:69\n-          nop;                             // scope 0 at $DIR/discriminant.rs:+0:11: +2:2\n+          _0 = const ();                   // scope 0 at $DIR/discriminant.rs:+0:11: +2:2\n           StorageDead(_1);                 // scope 0 at $DIR/discriminant.rs:+2:1: +2:2\n           return;                          // scope 0 at $DIR/discriminant.rs:+2:2: +2:2\n       }"}, {"sha": "fdd67ca8ac44f847634106a98ad31329f457e5b5", "filename": "src/test/mir-opt/const_prop/discriminant.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test: ConstProp\n // compile-flags: -O\n \n // FIXME(wesleywiser): Ideally, we could const-prop away all of this and just be left with"}, {"sha": "948bb7f56fe8589b14acdb9c48d671b4f6aeadb0", "filename": "src/test/mir-opt/const_prop/indirect.main.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Findirect.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Findirect.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Findirect.main.ConstProp.diff?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -18,14 +18,14 @@\n -         assert(!move (_3.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _2, const 1_u8) -> bb1; // scope 0 at $DIR/indirect.rs:+1:13: +1:29\n +         _2 = const 2_u8;                 // scope 0 at $DIR/indirect.rs:+1:13: +1:25\n +         _3 = const (3_u8, false);        // scope 0 at $DIR/indirect.rs:+1:13: +1:29\n-+         assert(!const false, \"attempt to compute `{} + {}`, which would overflow\", const 2_u8, const 1_u8) -> bb1; // scope 0 at $DIR/indirect.rs:+1:13: +1:29\n++         assert(!const false, \"attempt to compute `{} + {}`, which would overflow\", move _2, const 1_u8) -> bb1; // scope 0 at $DIR/indirect.rs:+1:13: +1:29\n       }\n   \n       bb1: {\n -         _1 = move (_3.0: u8);            // scope 0 at $DIR/indirect.rs:+1:13: +1:29\n +         _1 = const 3_u8;                 // scope 0 at $DIR/indirect.rs:+1:13: +1:29\n           StorageDead(_2);                 // scope 0 at $DIR/indirect.rs:+1:28: +1:29\n-          nop;                             // scope 0 at $DIR/indirect.rs:+0:11: +2:2\n+          _0 = const ();                   // scope 0 at $DIR/indirect.rs:+0:11: +2:2\n           StorageDead(_1);                 // scope 0 at $DIR/indirect.rs:+2:1: +2:2\n           return;                          // scope 0 at $DIR/indirect.rs:+2:2: +2:2\n       }"}, {"sha": "44916cbfe743a8781e22e8d35bca33639719ba9a", "filename": "src/test/mir-opt/const_prop/indirect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Findirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Findirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Findirect.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test: ConstProp\n // compile-flags: -C overflow-checks=on\n \n // EMIT_MIR indirect.main.ConstProp.diff"}, {"sha": "6ca03438ef3965239bb0c18b0ee68129627fe066", "filename": "src/test/mir-opt/const_prop/issue-66971.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue-66971.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue-66971.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue-66971.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test: ConstProp\n // compile-flags: -Z mir-opt-level=3\n \n // Due to a bug in propagating scalar pairs the assertion below used to fail. In the expected"}, {"sha": "ffc6fa1f290f3e06210bfd90fe4eb63bc0b70972", "filename": "src/test/mir-opt/const_prop/issue-67019.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue-67019.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue-67019.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue-67019.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test: ConstProp\n // compile-flags: -Z mir-opt-level=3\n \n // This used to ICE in const-prop"}, {"sha": "9d541dcabbb2c24c19109d2351f79d1497feaa37", "filename": "src/test/mir-opt/const_prop/issue_66971.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue_66971.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue_66971.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue_66971.main.ConstProp.diff?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -19,7 +19,7 @@\n           StorageDead(_3);                 // scope 0 at $DIR/issue-66971.rs:+1:21: +1:22\n           _1 = encode(move _2) -> bb1;     // scope 0 at $DIR/issue-66971.rs:+1:5: +1:23\n                                            // mir::Constant\n-                                           // + span: $DIR/issue-66971.rs:16:5: 16:11\n+                                           // + span: $DIR/issue-66971.rs:17:5: 17:11\n                                            // + literal: Const { ty: fn(((), u8, u8)) {encode}, val: Value(<ZST>) }\n       }\n   "}, {"sha": "b79d814760d9eda1ec1d7eab095f28128b7df2bd", "filename": "src/test/mir-opt/const_prop/issue_67019.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue_67019.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue_67019.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue_67019.main.ConstProp.diff?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -20,7 +20,7 @@\n           StorageDead(_3);                 // scope 0 at $DIR/issue-67019.rs:+1:18: +1:19\n           _1 = test(move _2) -> bb1;       // scope 0 at $DIR/issue-67019.rs:+1:5: +1:20\n                                            // mir::Constant\n-                                           // + span: $DIR/issue-67019.rs:11:5: 11:9\n+                                           // + span: $DIR/issue-67019.rs:12:5: 12:9\n                                            // + literal: Const { ty: fn(((u8, u8),)) {test}, val: Value(<ZST>) }\n       }\n   "}, {"sha": "c839f92f2ceb180f9a1aeb9c08987b73f494b988", "filename": "src/test/mir-opt/const_prop/mult_by_zero.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmult_by_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmult_by_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmult_by_zero.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test\n // compile-flags: -O -Zmir-opt-level=4\n \n // EMIT_MIR mult_by_zero.test.ConstProp.diff"}, {"sha": "cb01719dd77a9e97885bbc9395950f26b967384a", "filename": "src/test/mir-opt/const_prop/mutable_variable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test\n // compile-flags: -O\n \n // EMIT_MIR mutable_variable.main.ConstProp.diff"}, {"sha": "d4ff8d89073427e24217112dbfea577fce6cab6f", "filename": "src/test/mir-opt/const_prop/mutable_variable_aggregate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test\n // compile-flags: -O\n \n // EMIT_MIR mutable_variable_aggregate.main.ConstProp.diff"}, {"sha": "9060f7e9bd3e6a8759f3f03e1c030599d1756cb8", "filename": "src/test/mir-opt/const_prop/mutable_variable_aggregate_mut_ref.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_mut_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_mut_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_mut_ref.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test\n // compile-flags: -O\n \n // EMIT_MIR mutable_variable_aggregate_mut_ref.main.ConstProp.diff"}, {"sha": "6eda503c1eec4c615afcb8e467988fc186447935", "filename": "src/test/mir-opt/const_prop/mutable_variable_aggregate_partial_read.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_partial_read.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_partial_read.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_partial_read.main.ConstProp.diff?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -16,7 +16,7 @@\n           StorageLive(_1);                 // scope 0 at $DIR/mutable_variable_aggregate_partial_read.rs:+1:9: +1:14\n           _1 = foo() -> bb1;               // scope 0 at $DIR/mutable_variable_aggregate_partial_read.rs:+1:29: +1:34\n                                            // mir::Constant\n-                                           // + span: $DIR/mutable_variable_aggregate_partial_read.rs:5:29: 5:32\n+                                           // + span: $DIR/mutable_variable_aggregate_partial_read.rs:6:29: 6:32\n                                            // + literal: Const { ty: fn() -> (i32, i32) {foo}, val: Value(<ZST>) }\n       }\n   "}, {"sha": "cb59509ff1061ae1245ab0306c6c00c3a82b8735", "filename": "src/test/mir-opt/const_prop/mutable_variable_aggregate_partial_read.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_partial_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_partial_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_partial_read.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test\n // compile-flags: -O\n \n // EMIT_MIR mutable_variable_aggregate_partial_read.main.ConstProp.diff"}, {"sha": "eb3a7bc96d8822cdf959be5ac9ca55daecc246d0", "filename": "src/test/mir-opt/const_prop/mutable_variable_no_prop.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop.main.ConstProp.diff?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -25,7 +25,7 @@\n           StorageLive(_4);                 // scope 2 at $DIR/mutable_variable_no_prop.rs:+3:13: +3:19\n           _4 = const {alloc1: *mut u32};   // scope 2 at $DIR/mutable_variable_no_prop.rs:+3:13: +3:19\n                                            // mir::Constant\n-                                           // + span: $DIR/mutable_variable_no_prop.rs:9:13: 9:19\n+                                           // + span: $DIR/mutable_variable_no_prop.rs:10:13: 10:19\n                                            // + literal: Const { ty: *mut u32, val: Value(Scalar(alloc1)) }\n           _3 = (*_4);                      // scope 2 at $DIR/mutable_variable_no_prop.rs:+3:13: +3:19\n           _1 = move _3;                    // scope 2 at $DIR/mutable_variable_no_prop.rs:+3:9: +3:19"}, {"sha": "8c23c5fcf0f88948a0952e751394e693bd26ca30", "filename": "src/test/mir-opt/const_prop/mutable_variable_no_prop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test\n // compile-flags: -O\n \n static mut STATIC: u32 = 42;"}, {"sha": "4f205667be0e2821a76f724caa84733ed84e2304", "filename": "src/test/mir-opt/const_prop/mutable_variable_unprop_assign.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.main.ConstProp.diff?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -25,7 +25,7 @@\n           StorageLive(_1);                 // scope 0 at $DIR/mutable_variable_unprop_assign.rs:+1:9: +1:10\n           _1 = foo() -> bb1;               // scope 0 at $DIR/mutable_variable_unprop_assign.rs:+1:13: +1:18\n                                            // mir::Constant\n-                                           // + span: $DIR/mutable_variable_unprop_assign.rs:5:13: 5:16\n+                                           // + span: $DIR/mutable_variable_unprop_assign.rs:6:13: 6:16\n                                            // + literal: Const { ty: fn() -> i32 {foo}, val: Value(<ZST>) }\n       }\n   "}, {"sha": "b077cfd3e0ae71a9cb29b0d0099f09858cfdfaf3", "filename": "src/test/mir-opt/const_prop/mutable_variable_unprop_assign.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test\n // compile-flags: -O\n \n // EMIT_MIR mutable_variable_unprop_assign.main.ConstProp.diff"}, {"sha": "c0fbd2558cd98fd1bc12b3621c654a68887d2840", "filename": "src/test/mir-opt/const_prop/optimizes_into_variable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test\n // compile-flags: -C overflow-checks=on\n \n struct Point {"}, {"sha": "b9c283a54821b7576aa1edb8717ad2daf9d64501", "filename": "src/test/mir-opt/const_prop/read_immutable_static.main.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.main.ConstProp.diff?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -18,15 +18,15 @@\n           StorageLive(_3);                 // scope 0 at $DIR/read_immutable_static.rs:+1:13: +1:16\n           _3 = const {alloc1: &u8};        // scope 0 at $DIR/read_immutable_static.rs:+1:13: +1:16\n                                            // mir::Constant\n-                                           // + span: $DIR/read_immutable_static.rs:7:13: 7:16\n+                                           // + span: $DIR/read_immutable_static.rs:8:13: 8:16\n                                            // + literal: Const { ty: &u8, val: Value(Scalar(alloc1)) }\n -         _2 = (*_3);                      // scope 0 at $DIR/read_immutable_static.rs:+1:13: +1:16\n +         _2 = const 2_u8;                 // scope 0 at $DIR/read_immutable_static.rs:+1:13: +1:16\n           StorageLive(_4);                 // scope 0 at $DIR/read_immutable_static.rs:+1:19: +1:22\n           StorageLive(_5);                 // scope 0 at $DIR/read_immutable_static.rs:+1:19: +1:22\n           _5 = const {alloc1: &u8};        // scope 0 at $DIR/read_immutable_static.rs:+1:19: +1:22\n                                            // mir::Constant\n-                                           // + span: $DIR/read_immutable_static.rs:7:19: 7:22\n+                                           // + span: $DIR/read_immutable_static.rs:8:19: 8:22\n                                            // + literal: Const { ty: &u8, val: Value(Scalar(alloc1)) }\n -         _4 = (*_5);                      // scope 0 at $DIR/read_immutable_static.rs:+1:19: +1:22\n -         _1 = Add(move _2, move _4);      // scope 0 at $DIR/read_immutable_static.rs:+1:13: +1:22"}, {"sha": "4f7afe6cad4a19d5e08ad465ddce6ee0ea57f52c", "filename": "src/test/mir-opt/const_prop/read_immutable_static.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test\n // compile-flags: -O\n \n static FOO: u8 = 2;"}, {"sha": "84ec5c8bb1db1ac1035aaf7813b6539278b52fc3", "filename": "src/test/mir-opt/const_prop/ref_deref_project.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.main.ConstProp.diff?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -13,7 +13,7 @@\n           StorageLive(_2);                 // scope 0 at $DIR/ref_deref_project.rs:+1:6: +1:17\n           _4 = const main::promoted[0];    // scope 0 at $DIR/ref_deref_project.rs:+1:6: +1:17\n                                            // mir::Constant\n-                                           // + span: $DIR/ref_deref_project.rs:5:6: 5:17\n+                                           // + span: $DIR/ref_deref_project.rs:6:6: 6:17\n                                            // + literal: Const { ty: &(i32, i32), val: Unevaluated(main, [], Some(promoted[0])) }\n           _2 = &((*_4).1: i32);            // scope 0 at $DIR/ref_deref_project.rs:+1:6: +1:17\n           _1 = (*_2);                      // scope 0 at $DIR/ref_deref_project.rs:+1:5: +1:17"}, {"sha": "6f3a060a1260a87281f8b73dbed98d1c80ffdb99", "filename": "src/test/mir-opt/const_prop/ref_deref_project.main.PromoteTemps.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.main.PromoteTemps.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.main.PromoteTemps.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.main.PromoteTemps.diff?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -16,7 +16,7 @@\n -         _2 = &(_3.1: i32);               // scope 0 at $DIR/ref_deref_project.rs:+1:6: +1:17\n +         _4 = const main::promoted[0];    // scope 0 at $DIR/ref_deref_project.rs:+1:6: +1:17\n +                                          // mir::Constant\n-+                                          // + span: $DIR/ref_deref_project.rs:5:6: 5:17\n++                                          // + span: $DIR/ref_deref_project.rs:6:6: 6:17\n +                                          // + literal: Const { ty: &(i32, i32), val: Unevaluated(main, [], Some(promoted[0])) }\n +         _2 = &((*_4).1: i32);            // scope 0 at $DIR/ref_deref_project.rs:+1:6: +1:17\n           _1 = (*_2);                      // scope 0 at $DIR/ref_deref_project.rs:+1:5: +1:17"}, {"sha": "659c11d9b0c29f4afae77f07b26913976bce623e", "filename": "src/test/mir-opt/const_prop/ref_deref_project.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -1,3 +1,4 @@\n+// unit-test\n // EMIT_MIR ref_deref_project.main.PromoteTemps.diff\n // EMIT_MIR ref_deref_project.main.ConstProp.diff\n "}, {"sha": "2236a38c37b2bf0ff9b56beba8e19fe3accfa7f0", "filename": "src/test/ui/or-patterns/inner-or-pat.or3.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fui%2For-patterns%2Finner-or-pat.or3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fui%2For-patterns%2Finner-or-pat.or3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Finner-or-pat.or3.stderr?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -0,0 +1,11 @@\n+error[E0308]: mismatched types\n+  --> $DIR/inner-or-pat.rs:38:54\n+   |\n+LL |     match x {\n+   |           - this expression has type `&str`\n+LL |         x @ (((\"h\" | \"ho\" | \"yo\" | (\"dude\" | \"w\")) | () | \"nop\") | (\"hey\" | \"gg\")) |\n+   |                                                      ^^ expected `str`, found `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "058873ff5ff9e13c735be21f5e4dd6c3feb656b7", "filename": "src/test/ui/or-patterns/inner-or-pat.or4.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fui%2For-patterns%2Finner-or-pat.or4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fui%2For-patterns%2Finner-or-pat.or4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Finner-or-pat.or4.stderr?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -0,0 +1,11 @@\n+error[E0408]: variable `x` is not bound in all patterns\n+  --> $DIR/inner-or-pat.rs:53:37\n+   |\n+LL |         (x @ \"red\" | (x @ \"blue\" |  \"red\")) => {\n+   |                       -             ^^^^^ pattern doesn't bind `x`\n+   |                       |\n+   |                       variable not in all patterns\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0408`."}, {"sha": "f4cf4b0c188902e09fe6d17d089a83d1179c9049", "filename": "src/test/ui/or-patterns/inner-or-pat.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fui%2For-patterns%2Finner-or-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fui%2For-patterns%2Finner-or-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Finner-or-pat.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -0,0 +1,73 @@\n+// revisions: or1 or2 or3 or4 or5\n+// [or1] run-pass\n+// [or2] run-pass\n+// [or5] run-pass\n+\n+#![allow(unreachable_patterns)]\n+#![allow(unused_variables)]\n+#![allow(unused_parens)]\n+#![allow(dead_code)]\n+\n+\n+\n+fn foo() {\n+    let x = \"foo\";\n+    match x {\n+        x @ (((\"h\" | \"ho\" | \"yo\" | (\"dude\" | \"w\")) | \"no\" | \"nop\") | (\"hey\" | \"gg\")) |\n+        x @ (\"black\" | \"pink\") |\n+        x @ (\"red\" | \"blue\") => {\n+        }\n+        _ => (),\n+    }\n+}\n+\n+fn bar() {\n+    let x = \"foo\";\n+    match x {\n+        x @ (\"foo\" | \"bar\") |\n+        (x @ \"red\" | (x @ \"blue\" | x @ \"red\")) => {\n+        }\n+        _ => (),\n+    }\n+}\n+\n+#[cfg(or3)]\n+fn zot() {\n+    let x = \"foo\";\n+    match x {\n+        x @ (((\"h\" | \"ho\" | \"yo\" | (\"dude\" | \"w\")) | () | \"nop\") | (\"hey\" | \"gg\")) |\n+        //[or3]~^ ERROR mismatched types\n+        x @ (\"black\" | \"pink\") |\n+        x @ (\"red\" | \"blue\") => {\n+        }\n+        _ => (),\n+    }\n+}\n+\n+\n+#[cfg(or4)]\n+fn hey() {\n+    let x = \"foo\";\n+    match x {\n+        x @ (\"foo\" | \"bar\") |\n+        (x @ \"red\" | (x @ \"blue\" |  \"red\")) => {\n+        //[or4]~^ variable `x` is not bound in all patterns\n+        }\n+        _ => (),\n+    }\n+}\n+\n+fn don() {\n+    enum Foo {\n+        A,\n+        B,\n+        C,\n+    }\n+\n+    match Foo::A {\n+        | _foo @ (Foo::A | Foo::B) => {}\n+        Foo::C => {}\n+    };\n+}\n+\n+fn main(){}"}, {"sha": "1004bb28c59e70b6066beda09c3eb9920196c6a2", "filename": "src/test/ui/rfc-2632-const-trait-impl/issue-100222.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-100222.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7851767419e56280110fe2859bbc15d5cbdd468/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-100222.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-100222.rs?ref=a7851767419e56280110fe2859bbc15d5cbdd468", "patch": "@@ -0,0 +1,29 @@\n+// revisions: nn ny yn yy\n+// check-pass\n+#![feature(const_trait_impl, associated_type_defaults, const_mut_refs)]\n+\n+#[cfg_attr(any(yn, yy), const_trait)]\n+pub trait Index {\n+    type Output;\n+}\n+\n+#[cfg_attr(any(ny, yy), const_trait)]\n+pub trait IndexMut where Self: Index {\n+    const C: <Self as Index>::Output;\n+    type Assoc = <Self as Index>::Output;\n+    fn foo(&mut self, x: <Self as Index>::Output) -> <Self as Index>::Output;\n+}\n+\n+impl Index for () { type Output = (); }\n+\n+impl const IndexMut for <() as Index>::Output {\n+    const C: <Self as Index>::Output = ();\n+    type Assoc = <Self as Index>::Output;\n+    fn foo(&mut self, x: <Self as Index>::Output) -> <Self as Index>::Output\n+        where <Self as Index>::Output:,\n+    {}\n+}\n+\n+const C: <() as Index>::Output = ();\n+\n+fn main() {}"}]}