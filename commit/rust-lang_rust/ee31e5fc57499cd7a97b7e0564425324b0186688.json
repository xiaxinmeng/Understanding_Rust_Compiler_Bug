{"sha": "ee31e5fc57499cd7a97b7e0564425324b0186688", "node_id": "C_kwDOAAsO6NoAKGVlMzFlNWZjNTc0OTljZDdhOTdiN2UwNTY0NDI1MzI0YjAxODY2ODg", "commit": {"author": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2023-03-17T13:33:27Z"}, "committer": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2023-03-17T13:33:57Z"}, "message": "review nits", "tree": {"sha": "a3ae28e1534372591f3275de6fe7cbe828bffec0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3ae28e1534372591f3275de6fe7cbe828bffec0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee31e5fc57499cd7a97b7e0564425324b0186688", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee31e5fc57499cd7a97b7e0564425324b0186688", "html_url": "https://github.com/rust-lang/rust/commit/ee31e5fc57499cd7a97b7e0564425324b0186688", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee31e5fc57499cd7a97b7e0564425324b0186688/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed63201224308614ed20ff0cdd0bb2cd3c753fa7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed63201224308614ed20ff0cdd0bb2cd3c753fa7", "html_url": "https://github.com/rust-lang/rust/commit/ed63201224308614ed20ff0cdd0bb2cd3c753fa7"}], "stats": {"total": 32, "additions": 18, "deletions": 14}, "files": [{"sha": "20ed572df80d6b753688946599c99bfa17a0467e", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee31e5fc57499cd7a97b7e0564425324b0186688/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee31e5fc57499cd7a97b7e0564425324b0186688/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=ee31e5fc57499cd7a97b7e0564425324b0186688", "patch": "@@ -35,6 +35,12 @@ pub struct EvalCtxt<'a, 'tcx> {\n     pub(super) nested_goals: NestedGoals<'tcx>,\n }\n \n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub(super) enum IsNormalizesToHack {\n+    Yes,\n+    No,\n+}\n+\n #[derive(Debug, Clone)]\n pub(super) struct NestedGoals<'tcx> {\n     pub(super) projection_eq_hack_goal: Option<Goal<'tcx, ty::ProjectionPredicate<'tcx>>>,"}, {"sha": "089c5f8fb4dfc974b0e668ad3549dcff2f3c8384", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ee31e5fc57499cd7a97b7e0564425324b0186688/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee31e5fc57499cd7a97b7e0564425324b0186688/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=ee31e5fc57499cd7a97b7e0564425324b0186688", "patch": "@@ -45,7 +45,7 @@ mod trait_goals;\n pub use eval_ctxt::EvalCtxt;\n pub use fulfill::FulfillmentCtxt;\n \n-use self::eval_ctxt::NestedGoals;\n+use self::eval_ctxt::{IsNormalizesToHack, NestedGoals};\n \n trait CanonicalResponseExt {\n     fn has_no_inference_or_external_constraints(&self) -> bool;\n@@ -86,7 +86,7 @@ impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n             var_values: CanonicalVarValues::dummy(),\n             nested_goals: NestedGoals::new(),\n         }\n-        .evaluate_goal(false, goal);\n+        .evaluate_goal(IsNormalizesToHack::No, goal);\n \n         assert!(search_graph.is_empty());\n         result\n@@ -130,7 +130,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n     /// been constrained and the certainty of the result.\n     fn evaluate_goal(\n         &mut self,\n-        is_projection_eq_hack_goal: bool,\n+        is_normalizes_to_hack: IsNormalizesToHack,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n     ) -> Result<(bool, Certainty), NoSolution> {\n         let (orig_values, canonical_goal) = self.canonicalize_goal(goal);\n@@ -153,7 +153,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         // solver cycle.\n         if cfg!(debug_assertions)\n             && has_changed\n-            && !is_projection_eq_hack_goal\n+            && is_normalizes_to_hack == IsNormalizesToHack::No\n             && !self.search_graph.in_cycle()\n         {\n             debug!(\"rerunning goal to check result is stable\");\n@@ -223,11 +223,8 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         } else {\n             let kind = self.infcx.instantiate_binder_with_placeholders(kind);\n             let goal = goal.with(self.tcx(), ty::Binder::dummy(kind));\n-            // `false` is fine to use as if this were a projection goal from the hack there would not be\n-            // a binder as the real projection goal that is the parent of the hack goal would have already\n-            // had its binder replaced with placeholders.\n-            let (_, certainty) = self.evaluate_goal(false, goal)?;\n-            self.evaluate_added_goals_and_make_canonical_response(certainty)\n+            self.add_goal(goal);\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         }\n     }\n \n@@ -436,7 +433,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n                 if let Some(goal) = goals.projection_eq_hack_goal.take() {\n                     let (_, certainty) = match this.evaluate_goal(\n-                        true,\n+                        IsNormalizesToHack::Yes,\n                         goal.with(this.tcx(), ty::Binder::dummy(goal.predicate)),\n                     ) {\n                         Ok(r) => r,\n@@ -480,10 +477,11 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 }\n \n                 for nested_goal in goals.goals.drain(..) {\n-                    let (changed, certainty) = match this.evaluate_goal(false, nested_goal) {\n-                        Ok(result) => result,\n-                        Err(NoSolution) => return Some(Err(NoSolution)),\n-                    };\n+                    let (changed, certainty) =\n+                        match this.evaluate_goal(IsNormalizesToHack::No, nested_goal) {\n+                            Ok(result) => result,\n+                            Err(NoSolution) => return Some(Err(NoSolution)),\n+                        };\n \n                     if changed {\n                         has_changed = Ok(());"}]}