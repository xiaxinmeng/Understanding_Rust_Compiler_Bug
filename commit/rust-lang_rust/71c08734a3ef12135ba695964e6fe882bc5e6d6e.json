{"sha": "71c08734a3ef12135ba695964e6fe882bc5e6d6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxYzA4NzM0YTNlZjEyMTM1YmE2OTU5NjRlNmZlODgyYmM1ZTZkNmU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-01-15T23:09:39Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-01-15T23:09:39Z"}, "message": "Move `ExprPrecedence` to `libsyntax/util/parser.rs`", "tree": {"sha": "fe9fe3c2c6db7fb592d4102031cfcd201a46588c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe9fe3c2c6db7fb592d4102031cfcd201a46588c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71c08734a3ef12135ba695964e6fe882bc5e6d6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71c08734a3ef12135ba695964e6fe882bc5e6d6e", "html_url": "https://github.com/rust-lang/rust/commit/71c08734a3ef12135ba695964e6fe882bc5e6d6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71c08734a3ef12135ba695964e6fe882bc5e6d6e/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afe8d13a66e2f823847b39e8be7e038a67eaa337", "url": "https://api.github.com/repos/rust-lang/rust/commits/afe8d13a66e2f823847b39e8be7e038a67eaa337", "html_url": "https://github.com/rust-lang/rust/commit/afe8d13a66e2f823847b39e8be7e038a67eaa337"}], "stats": {"total": 264, "additions": 128, "deletions": 136}, "files": [{"sha": "3da2855929d3ab56b95b7427785ddff976387b48", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71c08734a3ef12135ba695964e6fe882bc5e6d6e/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c08734a3ef12135ba695964e6fe882bc5e6d6e/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=71c08734a3ef12135ba695964e6fe882bc5e6d6e", "patch": "@@ -41,7 +41,7 @@ use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::TokenStream;\n use syntax::util::ThinVec;\n-use syntax::ast::ExprPrecedence;\n+use syntax::util::parser::ExprPrecedence;\n use ty::AdtKind;\n \n use rustc_data_structures::indexed_vec;"}, {"sha": "a64f1e9e4002cc098a9718e46c2000ec1ef5081c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 135, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/71c08734a3ef12135ba695964e6fe882bc5e6d6e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c08734a3ef12135ba695964e6fe882bc5e6d6e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=71c08734a3ef12135ba695964e6fe882bc5e6d6e", "patch": "@@ -15,17 +15,7 @@ pub use self::UnsafeSource::*;\n pub use self::PathParameters::*;\n pub use symbol::{Ident, Symbol as Name};\n pub use util::ThinVec;\n-pub use util::parser::{\n-    AssocOp,\n-    PREC_RESET,\n-    PREC_CLOSURE,\n-    PREC_JUMP,\n-    PREC_RANGE,\n-    PREC_PREFIX,\n-    PREC_POSTFIX,\n-    PREC_PAREN,\n-    PREC_FORCE_PAREN,\n-};\n+pub use util::parser::ExprPrecedence;\n \n use syntax_pos::{Span, DUMMY_SP};\n use codemap::{respan, Spanned};\n@@ -39,7 +29,6 @@ use tokenstream::{ThinTokenStream, TokenStream};\n \n use serialize::{self, Encoder, Decoder};\n use std::collections::HashSet;\n-use std::cmp::Ordering;\n use std::fmt;\n use std::rc::Rc;\n use std::u32;\n@@ -917,129 +906,6 @@ pub struct Expr {\n     pub attrs: ThinVec<Attribute>\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum ExprPrecedence {\n-    Closure,\n-    Break,\n-    Continue,\n-    Ret,\n-    Yield,\n-\n-    Range,\n-\n-    Binary(BinOpKind),\n-\n-    InPlace,\n-    Cast,\n-    Type,\n-\n-    Assign,\n-    AssignOp,\n-\n-    Box,\n-    AddrOf,\n-    Unary,\n-\n-    Call,\n-    MethodCall,\n-    Field,\n-    TupField,\n-    Index,\n-    Try,\n-    InlineAsm,\n-    Mac,\n-\n-    Array,\n-    Repeat,\n-    Tup,\n-    Lit,\n-    Path,\n-    Paren,\n-    If,\n-    IfLet,\n-    While,\n-    WhileLet,\n-    ForLoop,\n-    Loop,\n-    Match,\n-    Block,\n-    Catch,\n-    Struct,\n-}\n-\n-impl PartialOrd for ExprPrecedence {\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        Some(self.order().cmp(&other.order()))\n-    }\n-}\n-\n-impl Ord for ExprPrecedence {\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.order().cmp(&other.order())\n-    }\n-}\n-\n-impl ExprPrecedence {\n-    pub fn order(self) -> i8 {\n-        match self {\n-            ExprPrecedence::Closure => PREC_CLOSURE,\n-\n-            ExprPrecedence::Break |\n-            ExprPrecedence::Continue |\n-            ExprPrecedence::Ret |\n-            ExprPrecedence::Yield => PREC_JUMP,\n-\n-            // `Range` claims to have higher precedence than `Assign`, but `x .. x = x` fails to\n-            // parse, instead of parsing as `(x .. x) = x`.  Giving `Range` a lower precedence\n-            // ensures that `pprust` will add parentheses in the right places to get the desired\n-            // parse.\n-            ExprPrecedence::Range => PREC_RANGE,\n-\n-            // Binop-like expr kinds, handled by `AssocOp`.\n-            ExprPrecedence::Binary(op) => AssocOp::from_ast_binop(op).precedence() as i8,\n-            ExprPrecedence::InPlace => AssocOp::Inplace.precedence() as i8,\n-            ExprPrecedence::Cast => AssocOp::As.precedence() as i8,\n-            ExprPrecedence::Type => AssocOp::Colon.precedence() as i8,\n-\n-            ExprPrecedence::Assign |\n-            ExprPrecedence::AssignOp => AssocOp::Assign.precedence() as i8,\n-\n-            // Unary, prefix\n-            ExprPrecedence::Box |\n-            ExprPrecedence::AddrOf |\n-            ExprPrecedence::Unary => PREC_PREFIX,\n-\n-            // Unary, postfix\n-            ExprPrecedence::Call |\n-            ExprPrecedence::MethodCall |\n-            ExprPrecedence::Field |\n-            ExprPrecedence::TupField |\n-            ExprPrecedence::Index |\n-            ExprPrecedence::Try |\n-            ExprPrecedence::InlineAsm |\n-            ExprPrecedence::Mac => PREC_POSTFIX,\n-\n-            // Never need parens\n-            ExprPrecedence::Array |\n-            ExprPrecedence::Repeat |\n-            ExprPrecedence::Tup |\n-            ExprPrecedence::Lit |\n-            ExprPrecedence::Path |\n-            ExprPrecedence::Paren |\n-            ExprPrecedence::If |\n-            ExprPrecedence::IfLet |\n-            ExprPrecedence::While |\n-            ExprPrecedence::WhileLet |\n-            ExprPrecedence::ForLoop |\n-            ExprPrecedence::Loop |\n-            ExprPrecedence::Match |\n-            ExprPrecedence::Block |\n-            ExprPrecedence::Catch |\n-            ExprPrecedence::Struct => PREC_PAREN,\n-        }\n-    }\n-}\n-\n impl Expr {\n     /// Wether this expression would be valid somewhere that expects a value, for example, an `if`\n     /// condition."}, {"sha": "86963c4000bd16c84e40a6c77a24e4f13b54b196", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/71c08734a3ef12135ba695964e6fe882bc5e6d6e/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c08734a3ef12135ba695964e6fe882bc5e6d6e/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=71c08734a3ef12135ba695964e6fe882bc5e6d6e", "patch": "@@ -11,6 +11,8 @@ use parse::token::{Token, BinOpToken};\n use symbol::keywords;\n use ast::{self, BinOpKind};\n \n+use std::cmp::Ordering;\n+\n /// Associative operator with precedence.\n ///\n /// This is the enum which specifies operator precedence and fixity to the parser.\n@@ -228,6 +230,130 @@ pub const PREC_POSTFIX: i8 = 60;\n pub const PREC_PAREN: i8 = 99;\n pub const PREC_FORCE_PAREN: i8 = 100;\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum ExprPrecedence {\n+    Closure,\n+    Break,\n+    Continue,\n+    Ret,\n+    Yield,\n+\n+    Range,\n+\n+    Binary(BinOpKind),\n+\n+    InPlace,\n+    Cast,\n+    Type,\n+\n+    Assign,\n+    AssignOp,\n+\n+    Box,\n+    AddrOf,\n+    Unary,\n+\n+    Call,\n+    MethodCall,\n+    Field,\n+    TupField,\n+    Index,\n+    Try,\n+    InlineAsm,\n+    Mac,\n+\n+    Array,\n+    Repeat,\n+    Tup,\n+    Lit,\n+    Path,\n+    Paren,\n+    If,\n+    IfLet,\n+    While,\n+    WhileLet,\n+    ForLoop,\n+    Loop,\n+    Match,\n+    Block,\n+    Catch,\n+    Struct,\n+}\n+\n+impl PartialOrd for ExprPrecedence {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.order().cmp(&other.order()))\n+    }\n+}\n+\n+impl Ord for ExprPrecedence {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.order().cmp(&other.order())\n+    }\n+}\n+\n+impl ExprPrecedence {\n+    pub fn order(self) -> i8 {\n+        match self {\n+            ExprPrecedence::Closure => PREC_CLOSURE,\n+\n+            ExprPrecedence::Break |\n+            ExprPrecedence::Continue |\n+            ExprPrecedence::Ret |\n+            ExprPrecedence::Yield => PREC_JUMP,\n+\n+            // `Range` claims to have higher precedence than `Assign`, but `x .. x = x` fails to\n+            // parse, instead of parsing as `(x .. x) = x`.  Giving `Range` a lower precedence\n+            // ensures that `pprust` will add parentheses in the right places to get the desired\n+            // parse.\n+            ExprPrecedence::Range => PREC_RANGE,\n+\n+            // Binop-like expr kinds, handled by `AssocOp`.\n+            ExprPrecedence::Binary(op) => AssocOp::from_ast_binop(op).precedence() as i8,\n+            ExprPrecedence::InPlace => AssocOp::Inplace.precedence() as i8,\n+            ExprPrecedence::Cast => AssocOp::As.precedence() as i8,\n+            ExprPrecedence::Type => AssocOp::Colon.precedence() as i8,\n+\n+            ExprPrecedence::Assign |\n+            ExprPrecedence::AssignOp => AssocOp::Assign.precedence() as i8,\n+\n+            // Unary, prefix\n+            ExprPrecedence::Box |\n+            ExprPrecedence::AddrOf |\n+            ExprPrecedence::Unary => PREC_PREFIX,\n+\n+            // Unary, postfix\n+            ExprPrecedence::Call |\n+            ExprPrecedence::MethodCall |\n+            ExprPrecedence::Field |\n+            ExprPrecedence::TupField |\n+            ExprPrecedence::Index |\n+            ExprPrecedence::Try |\n+            ExprPrecedence::InlineAsm |\n+            ExprPrecedence::Mac => PREC_POSTFIX,\n+\n+            // Never need parens\n+            ExprPrecedence::Array |\n+            ExprPrecedence::Repeat |\n+            ExprPrecedence::Tup |\n+            ExprPrecedence::Lit |\n+            ExprPrecedence::Path |\n+            ExprPrecedence::Paren |\n+            ExprPrecedence::If |\n+            ExprPrecedence::IfLet |\n+            ExprPrecedence::While |\n+            ExprPrecedence::WhileLet |\n+            ExprPrecedence::ForLoop |\n+            ExprPrecedence::Loop |\n+            ExprPrecedence::Match |\n+            ExprPrecedence::Block |\n+            ExprPrecedence::Catch |\n+            ExprPrecedence::Struct => PREC_PAREN,\n+        }\n+    }\n+}\n+\n+\n /// Expressions that syntactically contain an \"exterior\" struct literal i.e. not surrounded by any\n /// parens or other delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not."}]}