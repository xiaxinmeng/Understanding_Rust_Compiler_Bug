{"sha": "bc48c9d5116f08efea26da94c82a3eaa1622fc5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjNDhjOWQ1MTE2ZjA4ZWZlYTI2ZGE5NGM4MmEzZWFhMTYyMmZjNWQ=", "commit": {"author": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2020-03-23T12:19:09Z"}, "committer": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2020-03-23T12:19:09Z"}, "message": "review comments", "tree": {"sha": "e6aa05f86105c475cd0e5da81647770bf68ecd9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6aa05f86105c475cd0e5da81647770bf68ecd9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc48c9d5116f08efea26da94c82a3eaa1622fc5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc48c9d5116f08efea26da94c82a3eaa1622fc5d", "html_url": "https://github.com/rust-lang/rust/commit/bc48c9d5116f08efea26da94c82a3eaa1622fc5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc48c9d5116f08efea26da94c82a3eaa1622fc5d/comments", "author": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2afccbe47727d9d2787f76efd67f5b5d9ff1d55a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2afccbe47727d9d2787f76efd67f5b5d9ff1d55a", "html_url": "https://github.com/rust-lang/rust/commit/2afccbe47727d9d2787f76efd67f5b5d9ff1d55a"}], "stats": {"total": 131, "additions": 114, "deletions": 17}, "files": [{"sha": "7463b2af77a3a5cb0339b32b9a75b12333636e93", "filename": "crates/ra_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 108, "deletions": 16, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/bc48c9d5116f08efea26da94c82a3eaa1622fc5d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc48c9d5116f08efea26da94c82a3eaa1622fc5d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=bc48c9d5116f08efea26da94c82a3eaa1622fc5d", "patch": "@@ -2,9 +2,8 @@\n \n use std::iter;\n \n-use itertools::Itertools;\n-\n use hir::{Adt, HasSource, Semantics};\n+use itertools::Itertools;\n use ra_ide_db::RootDatabase;\n \n use crate::{Assist, AssistCtx, AssistId};\n@@ -61,20 +60,29 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n             .map(|pat| make::match_arm(iter::once(pat), make::expr_unit()))\n             .collect()\n     } else if let Some(enum_defs) = resolve_tuple_of_enum_def(&ctx.sema, &expr) {\n-        // partial fill not currently supported for tuple of enums\n+        // Partial fill not currently supported for tuple of enums.\n         if !arms.is_empty() {\n             return None;\n         }\n \n+        // We do not currently support filling match arms for a tuple\n+        // containing a single enum.\n+        if enum_defs.len() < 2 {\n+            return None;\n+        }\n+\n+        // When calculating the match arms for a tuple of enums, we want\n+        // to create a match arm for each possible combination of enum\n+        // values. The `multi_cartesian_product` method transforms\n+        // Vec<Vec<EnumVariant>> into Vec<(EnumVariant, .., EnumVariant)>\n+        // where each tuple represents a proposed match arm.\n         enum_defs\n             .into_iter()\n             .map(|enum_def| enum_def.variants(ctx.db))\n             .multi_cartesian_product()\n             .map(|variants| {\n-                let patterns = variants\n-                    .into_iter()\n-                    .filter_map(|variant| build_pat(ctx.db, module, variant))\n-                    .collect::<Vec<_>>();\n+                let patterns =\n+                    variants.into_iter().filter_map(|variant| build_pat(ctx.db, module, variant));\n                 ast::Pat::from(make::tuple_pat(patterns))\n             })\n             .filter(|variant_pat| is_variant_missing(&mut arms, variant_pat))\n@@ -130,16 +138,19 @@ fn resolve_tuple_of_enum_def(\n     sema: &Semantics<RootDatabase>,\n     expr: &ast::Expr,\n ) -> Option<Vec<hir::Enum>> {\n-    Some(\n-        sema.type_of_expr(&expr)?\n-            .tuple_fields(sema.db)\n-            .iter()\n-            .map(|ty| match ty.as_adt() {\n-                Some(Adt::Enum(e)) => e,\n-                _ => panic!(\"handle the case of tuple containing non-enum\"),\n+    sema.type_of_expr(&expr)?\n+        .tuple_fields(sema.db)\n+        .iter()\n+        .map(|ty| {\n+            ty.autoderef(sema.db).find_map(|ty| match ty.as_adt() {\n+                Some(Adt::Enum(e)) => Some(e),\n+                // For now we only handle expansion for a tuple of enums. Here\n+                // we map non-enum items to None and rely on `collect` to\n+                // convert Vec<Option<hir::Enum>> into Option<Vec<hir::Enum>>.\n+                _ => None,\n             })\n-            .collect(),\n-    )\n+        })\n+        .collect()\n }\n \n fn build_pat(db: &RootDatabase, module: hir::Module, var: hir::EnumVariant) -> Option<ast::Pat> {\n@@ -189,6 +200,21 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn tuple_of_non_enum() {\n+        // for now this case is not handled, although it potentially could be\n+        // in the future\n+        check_assist_not_applicable(\n+            fill_match_arms,\n+            r#\"\n+            fn main() {\n+                match (0, false)<|> {\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn partial_fill_record_tuple() {\n         check_assist(\n@@ -389,6 +415,50 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn fill_match_arms_tuple_of_enum_ref() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+            enum B {\n+                One,\n+                Two,\n+            }\n+\n+            fn main() {\n+                let a = A::One;\n+                let b = B::One;\n+                match (&a<|>, &b) {}\n+            }\n+            \"#,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+            enum B {\n+                One,\n+                Two,\n+            }\n+\n+            fn main() {\n+                let a = A::One;\n+                let b = B::One;\n+                match <|>(&a, &b) {\n+                    (A::One, B::One) => (),\n+                    (A::One, B::Two) => (),\n+                    (A::Two, B::One) => (),\n+                    (A::Two, B::Two) => (),\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn fill_match_arms_tuple_of_enum_partial() {\n         check_assist_not_applicable(\n@@ -442,6 +512,28 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn fill_match_arms_single_element_tuple_of_enum() {\n+        // For now we don't hande the case of a single element tuple, but\n+        // we could handle this in the future if `make::tuple_pat` allowed\n+        // creating a tuple with a single pattern.\n+        check_assist_not_applicable(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+\n+            fn main() {\n+                let a = A::One;\n+                match (a<|>, ) {\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_fill_match_arm_refs() {\n         check_assist("}, {"sha": "9257ccd1a444b021cfc772b83df4e13de828a2d9", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bc48c9d5116f08efea26da94c82a3eaa1622fc5d/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc48c9d5116f08efea26da94c82a3eaa1622fc5d/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=bc48c9d5116f08efea26da94c82a3eaa1622fc5d", "patch": "@@ -136,8 +136,13 @@ pub fn placeholder_pat() -> ast::PlaceholderPat {\n     }\n }\n \n+/// Creates a tuple of patterns from an interator of patterns.\n+///\n+/// Invariant: `pats` must be length > 1\n+///\n+/// FIXME handle `pats` length == 1\n pub fn tuple_pat(pats: impl IntoIterator<Item = ast::Pat>) -> ast::TuplePat {\n-    let pats_str = pats.into_iter().map(|p| p.syntax().to_string()).join(\", \");\n+    let pats_str = pats.into_iter().map(|p| p.to_string()).join(\", \");\n     return from_text(&format!(\"({})\", pats_str));\n \n     fn from_text(text: &str) -> ast::TuplePat {"}]}