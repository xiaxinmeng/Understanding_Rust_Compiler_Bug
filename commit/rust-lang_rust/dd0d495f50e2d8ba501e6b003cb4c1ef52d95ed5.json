{"sha": "dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkMGQ0OTVmNTBlMmQ4YmE1MDFlNmIwMDNjYjRjMWVmNTJkOTVlZDU=", "commit": {"author": {"name": "Piotr Jawniak", "email": "sawyer47@gmail.com", "date": "2014-05-26T17:33:04Z"}, "committer": {"name": "Piotr Jawniak", "email": "sawyer47@gmail.com", "date": "2014-05-28T15:15:35Z"}, "message": "Move trait impls for primitives near trait definition\n\nCloses #12925", "tree": {"sha": "1b1f2111b7c14249b9c17593e3f6b7ddae5f827d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b1f2111b7c14249b9c17593e3f6b7ddae5f827d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "html_url": "https://github.com/rust-lang/rust/commit/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/comments", "author": {"login": "Sawyer47", "id": 1534302, "node_id": "MDQ6VXNlcjE1MzQzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/1534302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sawyer47", "html_url": "https://github.com/Sawyer47", "followers_url": "https://api.github.com/users/Sawyer47/followers", "following_url": "https://api.github.com/users/Sawyer47/following{/other_user}", "gists_url": "https://api.github.com/users/Sawyer47/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sawyer47/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sawyer47/subscriptions", "organizations_url": "https://api.github.com/users/Sawyer47/orgs", "repos_url": "https://api.github.com/users/Sawyer47/repos", "events_url": "https://api.github.com/users/Sawyer47/events{/privacy}", "received_events_url": "https://api.github.com/users/Sawyer47/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Sawyer47", "id": 1534302, "node_id": "MDQ6VXNlcjE1MzQzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/1534302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sawyer47", "html_url": "https://github.com/Sawyer47", "followers_url": "https://api.github.com/users/Sawyer47/followers", "following_url": "https://api.github.com/users/Sawyer47/following{/other_user}", "gists_url": "https://api.github.com/users/Sawyer47/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sawyer47/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sawyer47/subscriptions", "organizations_url": "https://api.github.com/users/Sawyer47/orgs", "repos_url": "https://api.github.com/users/Sawyer47/repos", "events_url": "https://api.github.com/users/Sawyer47/events{/privacy}", "received_events_url": "https://api.github.com/users/Sawyer47/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1838295eb3a8086e6022d030a1e9e1b08ecc812", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1838295eb3a8086e6022d030a1e9e1b08ecc812", "html_url": "https://github.com/rust-lang/rust/commit/a1838295eb3a8086e6022d030a1e9e1b08ecc812"}], "stats": {"total": 2040, "additions": 638, "deletions": 1402}, "files": [{"sha": "51ba01a68aae9cb2e8323e13f5de52989f7c6cc5", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 0, "deletions": 143, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "patch": "@@ -10,28 +10,10 @@\n \n //! Operations on boolean values (`bool` type)\n //!\n-//! A quick summary:\n-//!\n-//! Implementations of the following traits:\n-//!\n-//! * `Not`\n-//! * `BitAnd`\n-//! * `BitOr`\n-//! * `BitXor`\n-//! * `Ord`\n-//! * `TotalOrd`\n-//! * `Eq`\n-//! * `TotalEq`\n-//! * `Default`\n-//!\n //! A `to_bit` conversion function.\n \n use num::{Int, one, zero};\n \n-#[cfg(not(test))] use cmp::{Eq, Ord, TotalOrd, Ordering, TotalEq};\n-#[cfg(not(test))] use ops::{Not, BitAnd, BitOr, BitXor};\n-#[cfg(not(test))] use default::Default;\n-\n /////////////////////////////////////////////////////////////////////////////\n // Freestanding functions\n /////////////////////////////////////////////////////////////////////////////\n@@ -51,131 +33,6 @@ pub fn to_bit<N: Int>(p: bool) -> N {\n     if p { one() } else { zero() }\n }\n \n-/////////////////////////////////////////////////////////////////////////////\n-// Trait impls on `bool`\n-/////////////////////////////////////////////////////////////////////////////\n-\n-#[cfg(not(test))]\n-impl Not<bool> for bool {\n-    /// The logical complement of a boolean value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(!true, false);\n-    /// assert_eq!(!false, true);\n-    /// ```\n-    #[inline]\n-    fn not(&self) -> bool { !*self }\n-}\n-\n-#[cfg(not(test))]\n-impl BitAnd<bool, bool> for bool {\n-    /// Conjunction of two boolean values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(false.bitand(&false), false);\n-    /// assert_eq!(true.bitand(&false), false);\n-    /// assert_eq!(false.bitand(&true), false);\n-    /// assert_eq!(true.bitand(&true), true);\n-    ///\n-    /// assert_eq!(false & false, false);\n-    /// assert_eq!(true & false, false);\n-    /// assert_eq!(false & true, false);\n-    /// assert_eq!(true & true, true);\n-    /// ```\n-    #[inline]\n-    fn bitand(&self, b: &bool) -> bool { *self & *b }\n-}\n-\n-#[cfg(not(test))]\n-impl BitOr<bool, bool> for bool {\n-    /// Disjunction of two boolean values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(false.bitor(&false), false);\n-    /// assert_eq!(true.bitor(&false), true);\n-    /// assert_eq!(false.bitor(&true), true);\n-    /// assert_eq!(true.bitor(&true), true);\n-    ///\n-    /// assert_eq!(false | false, false);\n-    /// assert_eq!(true | false, true);\n-    /// assert_eq!(false | true, true);\n-    /// assert_eq!(true | true, true);\n-    /// ```\n-    #[inline]\n-    fn bitor(&self, b: &bool) -> bool { *self | *b }\n-}\n-\n-#[cfg(not(test))]\n-impl BitXor<bool, bool> for bool {\n-    /// An 'exclusive or' of two boolean values.\n-    ///\n-    /// 'exclusive or' is identical to `or(and(a, not(b)), and(not(a), b))`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(false.bitxor(&false), false);\n-    /// assert_eq!(true.bitxor(&false), true);\n-    /// assert_eq!(false.bitxor(&true), true);\n-    /// assert_eq!(true.bitxor(&true), false);\n-    ///\n-    /// assert_eq!(false ^ false, false);\n-    /// assert_eq!(true ^ false, true);\n-    /// assert_eq!(false ^ true, true);\n-    /// assert_eq!(true ^ true, false);\n-    /// ```\n-    #[inline]\n-    fn bitxor(&self, b: &bool) -> bool { *self ^ *b }\n-}\n-\n-#[cfg(not(test))]\n-impl Ord for bool {\n-    #[inline]\n-    fn lt(&self, other: &bool) -> bool {\n-        to_bit::<u8>(*self) < to_bit(*other)\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl TotalOrd for bool {\n-    #[inline]\n-    fn cmp(&self, other: &bool) -> Ordering {\n-        to_bit::<u8>(*self).cmp(&to_bit(*other))\n-    }\n-}\n-\n-/// Equality between two boolean values.\n-///\n-/// Two booleans are equal if they have the same value.\n-///\n-/// # Examples\n-///\n-/// ```rust\n-/// assert_eq!(false.eq(&true), false);\n-/// assert_eq!(false == false, true);\n-/// assert_eq!(false != true, true);\n-/// assert_eq!(false.ne(&false), false);\n-/// ```\n-#[cfg(not(test))]\n-impl Eq for bool {\n-    #[inline]\n-    fn eq(&self, other: &bool) -> bool { (*self) == (*other) }\n-}\n-\n-#[cfg(not(test))]\n-impl TotalEq for bool {}\n-\n-#[cfg(not(test))]\n-impl Default for bool {\n-    fn default() -> bool { false }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use realstd::prelude::*;"}, {"sha": "0c5d3151af0f5b8418a7be97c6707d37b8b05131", "filename": "src/libcore/char.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "patch": "@@ -34,9 +34,6 @@ pub use unicode::normalization::decompose_canonical;\n /// Returns the compatibility decomposition of a character.\n pub use unicode::normalization::decompose_compatible;\n \n-#[cfg(not(test))] use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering};\n-#[cfg(not(test))] use default::Default;\n-\n // UTF-8 ranges and tags for encoding characters\n static TAG_CONT: u8    = 0b1000_0000u8;\n static TAG_TWO_B: u8   = 0b1100_0000u8;\n@@ -601,33 +598,6 @@ impl Char for char {\n     }\n }\n \n-#[cfg(not(test))]\n-impl Eq for char {\n-    #[inline]\n-    fn eq(&self, other: &char) -> bool { (*self) == (*other) }\n-}\n-\n-#[cfg(not(test))]\n-impl TotalEq for char {}\n-\n-#[cfg(not(test))]\n-impl Ord for char {\n-    #[inline]\n-    fn lt(&self, other: &char) -> bool { *self < *other }\n-}\n-\n-#[cfg(not(test))]\n-impl TotalOrd for char {\n-    fn cmp(&self, other: &char) -> Ordering {\n-        (*self as u32).cmp(&(*other as u32))\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl Default for char {\n-    #[inline]\n-    fn default() -> char { '\\x00' }\n-}\n \n #[cfg(test)]\n mod test {"}, {"sha": "1c621f7f4ce154992c27e345711d4bffa7dc8464", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 71, "deletions": 3, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "patch": "@@ -189,27 +189,95 @@ pub fn max<T: TotalOrd>(v1: T, v2: T) -> T {\n     if v1 > v2 { v1 } else { v2 }\n }\n \n-// Implementation of Eq/TotalEq for some primitive types\n+// Implementation of Eq, TotalEq, Ord and TotalOrd for primitive types\n #[cfg(not(test))]\n mod impls {\n-    use cmp::{Ord, TotalOrd, Eq, TotalEq, Ordering, Equal};\n+    use cmp::{Ord, TotalOrd, Eq, TotalEq, Ordering, Less, Greater, Equal};\n+\n+    macro_rules! eq_impl(\n+        ($($t:ty)*) => ($(\n+            impl Eq for $t {\n+                #[inline]\n+                fn eq(&self, other: &$t) -> bool { (*self) == (*other) }\n+                #[inline]\n+                fn ne(&self, other: &$t) -> bool { (*self) != (*other) }\n+            }\n+        )*)\n+    )\n \n     impl Eq for () {\n         #[inline]\n         fn eq(&self, _other: &()) -> bool { true }\n         #[inline]\n         fn ne(&self, _other: &()) -> bool { false }\n     }\n-    impl TotalEq for () {}\n+\n+    eq_impl!(bool char uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+\n+    macro_rules! totaleq_impl(\n+        ($($t:ty)*) => ($(\n+            impl TotalEq for $t {}\n+        )*)\n+    )\n+\n+    totaleq_impl!(() bool char uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+\n+    macro_rules! ord_impl(\n+        ($($t:ty)*) => ($(\n+            impl Ord for $t {\n+                #[inline]\n+                fn lt(&self, other: &$t) -> bool { (*self) < (*other) }\n+                #[inline]\n+                fn le(&self, other: &$t) -> bool { (*self) <= (*other) }\n+                #[inline]\n+                fn ge(&self, other: &$t) -> bool { (*self) >= (*other) }\n+                #[inline]\n+                fn gt(&self, other: &$t) -> bool { (*self) > (*other) }\n+            }\n+        )*)\n+    )\n+\n     impl Ord for () {\n         #[inline]\n         fn lt(&self, _other: &()) -> bool { false }\n     }\n+\n+    impl Ord for bool {\n+        #[inline]\n+        fn lt(&self, other: &bool) -> bool {\n+            (*self as u8) < (*other as u8)\n+        }\n+    }\n+\n+    ord_impl!(char uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+\n+    macro_rules! totalord_impl(\n+        ($($t:ty)*) => ($(\n+            impl TotalOrd for $t {\n+                #[inline]\n+                fn cmp(&self, other: &$t) -> Ordering {\n+                    if *self < *other { Less }\n+                    else if *self > *other { Greater }\n+                    else { Equal }\n+                }\n+            }\n+        )*)\n+    )\n+\n     impl TotalOrd for () {\n         #[inline]\n         fn cmp(&self, _other: &()) -> Ordering { Equal }\n     }\n \n+    impl TotalOrd for bool {\n+        #[inline]\n+        fn cmp(&self, other: &bool) -> Ordering {\n+            (*self as u8).cmp(&(*other as u8))\n+        }\n+    }\n+\n+    totalord_impl!(char uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+\n     // & pointers\n     impl<'a, T: Eq> Eq for &'a T {\n         #[inline]"}, {"sha": "809706b4fd73be962a7d8fffd2eac688e0b930a6", "filename": "src/libcore/default.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "patch": "@@ -16,10 +16,33 @@ pub trait Default {\n     fn default() -> Self;\n }\n \n-impl Default for () {\n-    #[inline]\n-    fn default() -> () { () }\n-}\n+macro_rules! default_impl(\n+    ($t:ty, $v:expr) => {\n+        impl Default for $t {\n+            #[inline]\n+            fn default() -> $t { $v }\n+        }\n+    }\n+)\n+\n+default_impl!((), ())\n+default_impl!(bool, false)\n+default_impl!(char, '\\x00')\n+\n+default_impl!(uint, 0u)\n+default_impl!(u8,  0u8)\n+default_impl!(u16, 0u16)\n+default_impl!(u32, 0u32)\n+default_impl!(u64, 0u64)\n+\n+default_impl!(int, 0i)\n+default_impl!(i8,  0i8)\n+default_impl!(i16, 0i16)\n+default_impl!(i32, 0i32)\n+default_impl!(i64, 0i64)\n+\n+default_impl!(f32, 0.0f32)\n+default_impl!(f64, 0.0f64)\n \n impl<T: Default + 'static> Default for @T {\n     fn default() -> @T { @Default::default() }"}, {"sha": "75d3db596ba5d4737e51f31c089566717315fbc4", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 1, "deletions": 130, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "patch": "@@ -10,16 +10,12 @@\n \n //! Operations and constants for 32-bits floats (`f32` type)\n \n-use default::Default;\n use intrinsics;\n use mem;\n use num::{FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n-use num::{Zero, One, Bounded, Signed, Num, Primitive, Float};\n+use num::Float;\n use option::Option;\n \n-#[cfg(not(test))] use cmp::{Eq, Ord};\n-#[cfg(not(test))] use ops::{Add, Sub, Mul, Div, Rem, Neg};\n-\n pub static RADIX: uint = 2u;\n \n pub static MANTISSA_DIGITS: uint = 24u;\n@@ -104,131 +100,6 @@ pub mod consts {\n     pub static LN_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n \n-#[cfg(not(test))]\n-impl Ord for f32 {\n-    #[inline]\n-    fn lt(&self, other: &f32) -> bool { (*self) < (*other) }\n-    #[inline]\n-    fn le(&self, other: &f32) -> bool { (*self) <= (*other) }\n-    #[inline]\n-    fn ge(&self, other: &f32) -> bool { (*self) >= (*other) }\n-    #[inline]\n-    fn gt(&self, other: &f32) -> bool { (*self) > (*other) }\n-}\n-#[cfg(not(test))]\n-impl Eq for f32 {\n-    #[inline]\n-    fn eq(&self, other: &f32) -> bool { (*self) == (*other) }\n-}\n-\n-impl Num for f32 {}\n-\n-impl Default for f32 {\n-    #[inline]\n-    fn default() -> f32 { 0.0 }\n-}\n-\n-impl Primitive for f32 {}\n-\n-impl Zero for f32 {\n-    #[inline]\n-    fn zero() -> f32 { 0.0 }\n-\n-    /// Returns true if the number is equal to either `0.0` or `-0.0`\n-    #[inline]\n-    fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }\n-}\n-\n-impl One for f32 {\n-    #[inline]\n-    fn one() -> f32 { 1.0 }\n-}\n-\n-#[cfg(not(test))]\n-impl Add<f32,f32> for f32 {\n-    #[inline]\n-    fn add(&self, other: &f32) -> f32 { *self + *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Sub<f32,f32> for f32 {\n-    #[inline]\n-    fn sub(&self, other: &f32) -> f32 { *self - *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Mul<f32,f32> for f32 {\n-    #[inline]\n-    fn mul(&self, other: &f32) -> f32 { *self * *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Div<f32,f32> for f32 {\n-    #[inline]\n-    fn div(&self, other: &f32) -> f32 { *self / *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Rem<f32,f32> for f32 {\n-    #[inline]\n-    fn rem(&self, other: &f32) -> f32 {\n-        extern { fn fmodf(a: f32, b: f32) -> f32; }\n-        unsafe { fmodf(*self, *other) }\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl Neg<f32> for f32 {\n-    #[inline]\n-    fn neg(&self) -> f32 { -*self }\n-}\n-\n-impl Signed for f32 {\n-    /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n-    #[inline]\n-    fn abs(&self) -> f32 {\n-        unsafe { intrinsics::fabsf32(*self) }\n-    }\n-\n-    /// The positive difference of two numbers. Returns `0.0` if the number is\n-    /// less than or equal to `other`, otherwise the difference between`self`\n-    /// and `other` is returned.\n-    #[inline]\n-    fn abs_sub(&self, other: &f32) -> f32 {\n-        extern { fn fdimf(a: f32, b: f32) -> f32; }\n-        unsafe { fdimf(*self, *other) }\n-    }\n-\n-    /// # Returns\n-    ///\n-    /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n-    /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n-    /// - `NAN` if the number is NaN\n-    #[inline]\n-    fn signum(&self) -> f32 {\n-        if self != self { NAN } else {\n-            unsafe { intrinsics::copysignf32(1.0, *self) }\n-        }\n-    }\n-\n-    /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n-    #[inline]\n-    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == INFINITY }\n-\n-    /// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`\n-    #[inline]\n-    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == NEG_INFINITY }\n-}\n-\n-impl Bounded for f32 {\n-    // NOTE: this is the smallest non-infinite f32 value, *not* MIN_VALUE\n-    #[inline]\n-    fn min_value() -> f32 { -MAX_VALUE }\n-\n-    #[inline]\n-    fn max_value() -> f32 { MAX_VALUE }\n-}\n-\n impl Float for f32 {\n     #[inline]\n     fn nan() -> f32 { NAN }"}, {"sha": "d59aad077ccb47c8b7441fb2027390018ef9e1f4", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 1, "deletions": 124, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "patch": "@@ -10,16 +10,12 @@\n \n //! Operations and constants for 64-bits floats (`f64` type)\n \n-use default::Default;\n use intrinsics;\n use mem;\n use num::{FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n-use num::{Zero, One, Bounded, Signed, Num, Primitive, Float};\n+use num::Float;\n use option::Option;\n \n-#[cfg(not(test))] use cmp::{Eq, Ord};\n-#[cfg(not(test))] use ops::{Add, Sub, Mul, Div, Rem, Neg};\n-\n // FIXME(#5527): These constants should be deprecated once associated\n // constants are implemented in favour of referencing the respective\n // members of `Bounded` and `Float`.\n@@ -110,125 +106,6 @@ pub mod consts {\n     pub static LN_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n \n-#[cfg(not(test))]\n-impl Ord for f64 {\n-    #[inline]\n-    fn lt(&self, other: &f64) -> bool { (*self) < (*other) }\n-    #[inline]\n-    fn le(&self, other: &f64) -> bool { (*self) <= (*other) }\n-    #[inline]\n-    fn ge(&self, other: &f64) -> bool { (*self) >= (*other) }\n-    #[inline]\n-    fn gt(&self, other: &f64) -> bool { (*self) > (*other) }\n-}\n-#[cfg(not(test))]\n-impl Eq for f64 {\n-    #[inline]\n-    fn eq(&self, other: &f64) -> bool { (*self) == (*other) }\n-}\n-\n-impl Default for f64 {\n-    #[inline]\n-    fn default() -> f64 { 0.0 }\n-}\n-\n-impl Primitive for f64 {}\n-\n-impl Num for f64 {}\n-\n-impl Zero for f64 {\n-    #[inline]\n-    fn zero() -> f64 { 0.0 }\n-\n-    /// Returns true if the number is equal to either `0.0` or `-0.0`\n-    #[inline]\n-    fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }\n-}\n-\n-impl One for f64 {\n-    #[inline]\n-    fn one() -> f64 { 1.0 }\n-}\n-\n-#[cfg(not(test))]\n-impl Add<f64,f64> for f64 {\n-    #[inline]\n-    fn add(&self, other: &f64) -> f64 { *self + *other }\n-}\n-#[cfg(not(test))]\n-impl Sub<f64,f64> for f64 {\n-    #[inline]\n-    fn sub(&self, other: &f64) -> f64 { *self - *other }\n-}\n-#[cfg(not(test))]\n-impl Mul<f64,f64> for f64 {\n-    #[inline]\n-    fn mul(&self, other: &f64) -> f64 { *self * *other }\n-}\n-#[cfg(not(test))]\n-impl Div<f64,f64> for f64 {\n-    #[inline]\n-    fn div(&self, other: &f64) -> f64 { *self / *other }\n-}\n-#[cfg(not(test))]\n-impl Rem<f64,f64> for f64 {\n-    #[inline]\n-    fn rem(&self, other: &f64) -> f64 {\n-        extern { fn fmod(a: f64, b: f64) -> f64; }\n-        unsafe { fmod(*self, *other) }\n-    }\n-}\n-#[cfg(not(test))]\n-impl Neg<f64> for f64 {\n-    #[inline]\n-    fn neg(&self) -> f64 { -*self }\n-}\n-\n-impl Signed for f64 {\n-    /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n-    #[inline]\n-    fn abs(&self) -> f64 {\n-        unsafe { intrinsics::fabsf64(*self) }\n-    }\n-\n-    /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n-    /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n-    #[inline]\n-    fn abs_sub(&self, other: &f64) -> f64 {\n-        extern { fn fdim(a: f64, b: f64) -> f64; }\n-        unsafe { fdim(*self, *other) }\n-    }\n-\n-    /// # Returns\n-    ///\n-    /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n-    /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n-    /// - `NAN` if the number is NaN\n-    #[inline]\n-    fn signum(&self) -> f64 {\n-        if self != self { NAN } else {\n-            unsafe { intrinsics::copysignf64(1.0, *self) }\n-        }\n-    }\n-\n-    /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n-    #[inline]\n-    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == INFINITY }\n-\n-    /// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`\n-    #[inline]\n-    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == NEG_INFINITY }\n-}\n-\n-impl Bounded for f64 {\n-    // NOTE: this is the smallest non-infinite f32 value, *not* MIN_VALUE\n-    #[inline]\n-    fn min_value() -> f64 { -MAX_VALUE }\n-\n-    #[inline]\n-    fn max_value() -> f64 { MAX_VALUE }\n-}\n-\n impl Float for f64 {\n     #[inline]\n     fn nan() -> f64 { NAN }"}, {"sha": "957e585e71cdfc3676e207280d42f9a399977a44", "filename": "src/libcore/num/i16.rs", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi16.rs?ref=dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "patch": "@@ -10,63 +10,5 @@\n \n //! Operations and constants for signed 16-bits integers (`i16` type)\n \n-use default::Default;\n-use intrinsics;\n-use num::{Bitwise, Bounded, Zero, One, Signed, Num, Primitive, Int};\n-use num::{CheckedDiv, CheckedAdd, CheckedSub, CheckedMul};\n-use option::{Option, Some, None};\n-\n-#[cfg(not(test))]\n-use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n-#[cfg(not(test))]\n-use ops::{Add, Sub, Mul, Div, Rem, Neg, BitOr, BitAnd, BitXor};\n-#[cfg(not(test))]\n-use ops::{Shl, Shr, Not};\n-\n int_module!(i16, 16)\n \n-impl Bitwise for i16 {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> i16 { unsafe { intrinsics::ctpop16(*self as u16) as i16 } }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> i16 { unsafe { intrinsics::ctlz16(*self as u16) as i16 } }\n-\n-    /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn trailing_zeros(&self) -> i16 { unsafe { intrinsics::cttz16(*self as u16) as i16 } }\n-}\n-\n-impl CheckedAdd for i16 {\n-    #[inline]\n-    fn checked_add(&self, v: &i16) -> Option<i16> {\n-        unsafe {\n-            let (x, y) = intrinsics::i16_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n-\n-impl CheckedSub for i16 {\n-    #[inline]\n-    fn checked_sub(&self, v: &i16) -> Option<i16> {\n-        unsafe {\n-            let (x, y) = intrinsics::i16_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n-\n-impl CheckedMul for i16 {\n-    #[inline]\n-    fn checked_mul(&self, v: &i16) -> Option<i16> {\n-        unsafe {\n-            let (x, y) = intrinsics::i16_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}"}, {"sha": "cfeb1020f446aafea4fbdabe0c2e2d05221b8baf", "filename": "src/libcore/num/i32.rs", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi32.rs?ref=dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "patch": "@@ -10,63 +10,5 @@\n \n //! Operations and constants for signed 32-bits integers (`i32` type)\n \n-use default::Default;\n-use intrinsics;\n-use num::{Bitwise, Bounded, Zero, One, Signed, Num, Primitive, Int};\n-use num::{CheckedDiv, CheckedAdd, CheckedSub, CheckedMul};\n-use option::{Option, Some, None};\n-\n-#[cfg(not(test))]\n-use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n-#[cfg(not(test))]\n-use ops::{Add, Sub, Mul, Div, Rem, Neg, BitOr, BitAnd, BitXor};\n-#[cfg(not(test))]\n-use ops::{Shl, Shr, Not};\n-\n int_module!(i32, 32)\n \n-impl Bitwise for i32 {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> i32 { unsafe { intrinsics::ctpop32(*self as u32) as i32 } }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> i32 { unsafe { intrinsics::ctlz32(*self as u32) as i32 } }\n-\n-    /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn trailing_zeros(&self) -> i32 { unsafe { intrinsics::cttz32(*self as u32) as i32 } }\n-}\n-\n-impl CheckedAdd for i32 {\n-    #[inline]\n-    fn checked_add(&self, v: &i32) -> Option<i32> {\n-        unsafe {\n-            let (x, y) = intrinsics::i32_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n-\n-impl CheckedSub for i32 {\n-    #[inline]\n-    fn checked_sub(&self, v: &i32) -> Option<i32> {\n-        unsafe {\n-            let (x, y) = intrinsics::i32_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n-\n-impl CheckedMul for i32 {\n-    #[inline]\n-    fn checked_mul(&self, v: &i32) -> Option<i32> {\n-        unsafe {\n-            let (x, y) = intrinsics::i32_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}"}, {"sha": "21ae162d4aac679d2273301c60012c99533f12c8", "filename": "src/libcore/num/i64.rs", "status": "modified", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi64.rs?ref=dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "patch": "@@ -10,62 +10,5 @@\n \n //! Operations and constants for signed 64-bits integers (`i64` type)\n \n-use default::Default;\n-use intrinsics;\n-use num::{Bitwise, Bounded, Zero, One, Signed, Num, Primitive, Int};\n-use num::{CheckedDiv, CheckedAdd, CheckedSub, CheckedMul};\n-use option::{Option, Some, None};\n-\n-#[cfg(not(test))]\n-use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n-#[cfg(not(test))]\n-use ops::{Add, Sub, Mul, Div, Rem, Neg, BitOr, BitAnd, BitXor};\n-#[cfg(not(test))]\n-use ops::{Shl, Shr, Not};\n-\n int_module!(i64, 64)\n \n-impl Bitwise for i64 {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> i64 { unsafe { intrinsics::ctpop64(*self as u64) as i64 } }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> i64 { unsafe { intrinsics::ctlz64(*self as u64) as i64 } }\n-\n-    /// Counts the number of trailing zeros.\n-    #[inline]\n-    fn trailing_zeros(&self) -> i64 { unsafe { intrinsics::cttz64(*self as u64) as i64 } }\n-}\n-\n-impl CheckedAdd for i64 {\n-    #[inline]\n-    fn checked_add(&self, v: &i64) -> Option<i64> {\n-        unsafe {\n-            let (x, y) = intrinsics::i64_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n-\n-impl CheckedSub for i64 {\n-    #[inline]\n-    fn checked_sub(&self, v: &i64) -> Option<i64> {\n-        unsafe {\n-            let (x, y) = intrinsics::i64_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n-\n-impl CheckedMul for i64 {\n-    #[inline]\n-    fn checked_mul(&self, v: &i64) -> Option<i64> {\n-        unsafe {\n-            let (x, y) = intrinsics::i64_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}"}, {"sha": "b9ae13da07588f5e6511d5d7e976e70bbf2e55bb", "filename": "src/libcore/num/i8.rs", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi8.rs?ref=dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "patch": "@@ -10,63 +10,5 @@\n \n //! Operations and constants for signed 8-bits integers (`i8` type)\n \n-use default::Default;\n-use intrinsics;\n-use num::{Bitwise, Bounded, Zero, One, Signed, Num, Primitive, Int};\n-use num::{CheckedDiv, CheckedAdd, CheckedSub, CheckedMul};\n-use option::{Option, Some, None};\n-\n-#[cfg(not(test))]\n-use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n-#[cfg(not(test))]\n-use ops::{Add, Sub, Mul, Div, Rem, Neg, BitOr, BitAnd, BitXor};\n-#[cfg(not(test))]\n-use ops::{Shl, Shr, Not};\n-\n int_module!(i8, 8)\n \n-impl Bitwise for i8 {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> i8 { unsafe { intrinsics::ctpop8(*self as u8) as i8 } }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> i8 { unsafe { intrinsics::ctlz8(*self as u8) as i8 } }\n-\n-    /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn trailing_zeros(&self) -> i8 { unsafe { intrinsics::cttz8(*self as u8) as i8 } }\n-}\n-\n-impl CheckedAdd for i8 {\n-    #[inline]\n-    fn checked_add(&self, v: &i8) -> Option<i8> {\n-        unsafe {\n-            let (x, y) = intrinsics::i8_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n-\n-impl CheckedSub for i8 {\n-    #[inline]\n-    fn checked_sub(&self, v: &i8) -> Option<i8> {\n-        unsafe {\n-            let (x, y) = intrinsics::i8_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n-\n-impl CheckedMul for i8 {\n-    #[inline]\n-    fn checked_mul(&self, v: &i8) -> Option<i8> {\n-        unsafe {\n-            let (x, y) = intrinsics::i8_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}"}, {"sha": "4979e9e01d3bf88acf972ef3f2011b6f82851c75", "filename": "src/libcore/num/int.rs", "status": "modified", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint.rs?ref=dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "patch": "@@ -10,118 +10,6 @@\n \n //! Operations and constants for architecture-sized signed integers (`int` type)\n \n-use default::Default;\n-use intrinsics;\n-use num::{Bitwise, Bounded, Zero, One, Signed, Num, Primitive, Int};\n-use num::{CheckedDiv, CheckedAdd, CheckedSub, CheckedMul};\n-use option::{Option, Some, None};\n-\n-#[cfg(not(test))]\n-use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n-#[cfg(not(test))]\n-use ops::{Add, Sub, Mul, Div, Rem, Neg, BitOr, BitAnd, BitXor};\n-#[cfg(not(test))]\n-use ops::{Shl, Shr, Not};\n-\n #[cfg(target_word_size = \"32\")] int_module!(int, 32)\n #[cfg(target_word_size = \"64\")] int_module!(int, 64)\n \n-#[cfg(target_word_size = \"32\")]\n-impl Bitwise for int {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> int { (*self as i32).count_ones() as int }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> int { (*self as i32).leading_zeros() as int }\n-\n-    /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn trailing_zeros(&self) -> int { (*self as i32).trailing_zeros() as int }\n-}\n-\n-#[cfg(target_word_size = \"64\")]\n-impl Bitwise for int {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> int { (*self as i64).count_ones() as int }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> int { (*self as i64).leading_zeros() as int }\n-\n-    /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn trailing_zeros(&self) -> int { (*self as i64).trailing_zeros() as int }\n-}\n-\n-#[cfg(target_word_size = \"32\")]\n-impl CheckedAdd for int {\n-    #[inline]\n-    fn checked_add(&self, v: &int) -> Option<int> {\n-        unsafe {\n-            let (x, y) = intrinsics::i32_add_with_overflow(*self as i32, *v as i32);\n-            if y { None } else { Some(x as int) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"64\")]\n-impl CheckedAdd for int {\n-    #[inline]\n-    fn checked_add(&self, v: &int) -> Option<int> {\n-        unsafe {\n-            let (x, y) = intrinsics::i64_add_with_overflow(*self as i64, *v as i64);\n-            if y { None } else { Some(x as int) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"32\")]\n-impl CheckedSub for int {\n-    #[inline]\n-    fn checked_sub(&self, v: &int) -> Option<int> {\n-        unsafe {\n-            let (x, y) = intrinsics::i32_sub_with_overflow(*self as i32, *v as i32);\n-            if y { None } else { Some(x as int) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"64\")]\n-impl CheckedSub for int {\n-    #[inline]\n-    fn checked_sub(&self, v: &int) -> Option<int> {\n-        unsafe {\n-            let (x, y) = intrinsics::i64_sub_with_overflow(*self as i64, *v as i64);\n-            if y { None } else { Some(x as int) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"32\")]\n-impl CheckedMul for int {\n-    #[inline]\n-    fn checked_mul(&self, v: &int) -> Option<int> {\n-        unsafe {\n-            let (x, y) = intrinsics::i32_mul_with_overflow(*self as i32, *v as i32);\n-            if y { None } else { Some(x as int) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"64\")]\n-impl CheckedMul for int {\n-    #[inline]\n-    fn checked_mul(&self, v: &int) -> Option<int> {\n-        unsafe {\n-            let (x, y) = intrinsics::i64_mul_with_overflow(*self as i64, *v as i64);\n-            if y { None } else { Some(x as int) }\n-        }\n-    }\n-}"}, {"sha": "445ac248cd67f58431805cfc7f5c96f00a65e2f5", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 214, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "patch": "@@ -28,220 +28,6 @@ pub static MIN: $T = (-1 as $T) << (BITS - 1);\n // calling the `Bounded::max_value` function.\n pub static MAX: $T = !MIN;\n \n-#[cfg(not(test))]\n-impl Ord for $T {\n-    #[inline]\n-    fn lt(&self, other: &$T) -> bool { *self < *other }\n-}\n-#[cfg(not(test))]\n-impl TotalEq for $T {}\n-#[cfg(not(test))]\n-impl Eq for $T {\n-    #[inline]\n-    fn eq(&self, other: &$T) -> bool { *self == *other }\n-}\n-#[cfg(not(test))]\n-impl TotalOrd for $T {\n-    #[inline]\n-    fn cmp(&self, other: &$T) -> Ordering {\n-        if *self < *other { Less }\n-        else if *self > *other { Greater }\n-        else { Equal }\n-    }\n-}\n-\n-impl Num for $T {}\n-\n-impl Zero for $T {\n-    #[inline]\n-    fn zero() -> $T { 0 }\n-\n-    #[inline]\n-    fn is_zero(&self) -> bool { *self == 0 }\n-}\n-\n-impl One for $T {\n-    #[inline]\n-    fn one() -> $T { 1 }\n-}\n-\n-#[cfg(not(test))]\n-impl Add<$T,$T> for $T {\n-    #[inline]\n-    fn add(&self, other: &$T) -> $T { *self + *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Sub<$T,$T> for $T {\n-    #[inline]\n-    fn sub(&self, other: &$T) -> $T { *self - *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Mul<$T,$T> for $T {\n-    #[inline]\n-    fn mul(&self, other: &$T) -> $T { *self * *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Div<$T,$T> for $T {\n-    /// Integer division, truncated towards 0.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ~~~\n-    /// assert!( 8 /  3 ==  2);\n-    /// assert!( 8 / -3 == -2);\n-    /// assert!(-8 /  3 == -2);\n-    /// assert!(-8 / -3 ==  2);\n-    ///\n-    /// assert!( 1 /  2 ==  0);\n-    /// assert!( 1 / -2 ==  0);\n-    /// assert!(-1 /  2 ==  0);\n-    /// assert!(-1 / -2 ==  0);\n-    /// ~~~\n-    #[inline]\n-    fn div(&self, other: &$T) -> $T { *self / *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Rem<$T,$T> for $T {\n-    /// Returns the integer remainder after division, satisfying:\n-    ///\n-    /// ~~~\n-    /// # let n = 1;\n-    /// # let d = 2;\n-    /// assert!((n / d) * d + (n % d) == n)\n-    /// ~~~\n-    ///\n-    /// # Examples\n-    ///\n-    /// ~~~\n-    /// assert!( 8 %  3 ==  2);\n-    /// assert!( 8 % -3 ==  2);\n-    /// assert!(-8 %  3 == -2);\n-    /// assert!(-8 % -3 == -2);\n-    ///\n-    /// assert!( 1 %  2 ==  1);\n-    /// assert!( 1 % -2 ==  1);\n-    /// assert!(-1 %  2 == -1);\n-    /// assert!(-1 % -2 == -1);\n-    /// ~~~\n-    #[inline]\n-    fn rem(&self, other: &$T) -> $T { *self % *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Neg<$T> for $T {\n-    #[inline]\n-    fn neg(&self) -> $T { -*self }\n-}\n-\n-impl Signed for $T {\n-    /// Computes the absolute value\n-    #[inline]\n-    fn abs(&self) -> $T {\n-        if self.is_negative() { -*self } else { *self }\n-    }\n-\n-    ///\n-    /// The positive difference of two numbers. Returns `0` if the number is less than or\n-    /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n-    ///\n-    #[inline]\n-    fn abs_sub(&self, other: &$T) -> $T {\n-        if *self <= *other { 0 } else { *self - *other }\n-    }\n-\n-    ///\n-    /// # Returns\n-    ///\n-    /// - `0` if the number is zero\n-    /// - `1` if the number is positive\n-    /// - `-1` if the number is negative\n-    ///\n-    #[inline]\n-    fn signum(&self) -> $T {\n-        match *self {\n-            n if n > 0 =>  1,\n-            0          =>  0,\n-            _          => -1,\n-        }\n-    }\n-\n-    /// Returns true if the number is positive\n-    #[inline]\n-    fn is_positive(&self) -> bool { *self > 0 }\n-\n-    /// Returns true if the number is negative\n-    #[inline]\n-    fn is_negative(&self) -> bool { *self < 0 }\n-}\n-\n-#[cfg(not(test))]\n-impl BitOr<$T,$T> for $T {\n-    #[inline]\n-    fn bitor(&self, other: &$T) -> $T { *self | *other }\n-}\n-\n-#[cfg(not(test))]\n-impl BitAnd<$T,$T> for $T {\n-    #[inline]\n-    fn bitand(&self, other: &$T) -> $T { *self & *other }\n-}\n-\n-#[cfg(not(test))]\n-impl BitXor<$T,$T> for $T {\n-    #[inline]\n-    fn bitxor(&self, other: &$T) -> $T { *self ^ *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Shl<$T,$T> for $T {\n-    #[inline]\n-    fn shl(&self, other: &$T) -> $T { *self << *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Shr<$T,$T> for $T {\n-    #[inline]\n-    fn shr(&self, other: &$T) -> $T { *self >> *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Not<$T> for $T {\n-    #[inline]\n-    fn not(&self) -> $T { !*self }\n-}\n-\n-impl Bounded for $T {\n-    #[inline]\n-    fn min_value() -> $T { MIN }\n-\n-    #[inline]\n-    fn max_value() -> $T { MAX }\n-}\n-\n-impl CheckedDiv for $T {\n-    #[inline]\n-    fn checked_div(&self, v: &$T) -> Option<$T> {\n-        if *v == 0 || (*self == MIN && *v == -1) {\n-            None\n-        } else {\n-            Some(self / *v)\n-        }\n-    }\n-}\n-\n-impl Default for $T {\n-    #[inline]\n-    fn default() -> $T { 0 }\n-}\n-\n-impl Int for $T {}\n-\n-impl Primitive for $T {}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::*;"}, {"sha": "fe3f07c6024e0f43910f6392a7a873b76b0dc2d3", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 361, "deletions": 3, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "patch": "@@ -9,12 +9,13 @@\n // except according to those terms.\n \n //! Numeric traits and functions for generic mathematics\n-//!\n-//! These are implemented for the primitive numeric types in `std::{u8, u16,\n-//! u32, u64, uint, i8, i16, i32, i64, int, f32, f64}`.\n \n #![allow(missing_doc)]\n \n+use intrinsics;\n+use {int, i8, i16, i32, i64};\n+use {uint, u8, u16, u32, u64};\n+use {f32, f64};\n use clone::Clone;\n use cmp::{Eq, Ord};\n use kinds::Copy;\n@@ -32,6 +33,14 @@ pub trait Num: Eq + Zero + One\n              + Div<Self,Self>\n              + Rem<Self,Self> {}\n \n+macro_rules! trait_impl(\n+    ($name:ident for $($t:ty)*) => ($(\n+        impl $name for $t {}\n+    )*)\n+)\n+\n+trait_impl!(Num for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+\n /// Simultaneous division and remainder\n #[inline]\n pub fn div_rem<T: Div<T, T> + Rem<T, T>>(x: T, y: T) -> (T, T) {\n@@ -67,6 +76,44 @@ pub trait Zero: Add<Self, Self> {\n     fn is_zero(&self) -> bool;\n }\n \n+macro_rules! zero_impl(\n+    ($t:ty, $v:expr) => {\n+        impl Zero for $t {\n+            #[inline]\n+            fn zero() -> $t { $v }\n+            #[inline]\n+            fn is_zero(&self) -> bool { *self == $v }\n+        }\n+    }\n+)\n+\n+macro_rules! zero_float_impl(\n+    ($t:ty, $v:expr) => {\n+        impl Zero for $t {\n+            #[inline]\n+            fn zero() -> $t { $v }\n+\n+            #[inline]\n+            fn is_zero(&self) -> bool { *self == $v || *self == -$v }\n+        }\n+    }\n+)\n+\n+zero_impl!(uint, 0u)\n+zero_impl!(u8,  0u8)\n+zero_impl!(u16, 0u16)\n+zero_impl!(u32, 0u32)\n+zero_impl!(u64, 0u64)\n+\n+zero_impl!(int, 0i)\n+zero_impl!(i8,  0i8)\n+zero_impl!(i16, 0i16)\n+zero_impl!(i32, 0i32)\n+zero_impl!(i64, 0i64)\n+\n+zero_float_impl!(f32, 0.0f32)\n+zero_float_impl!(f64, 0.0f64)\n+\n /// Returns the additive identity, `0`.\n #[inline(always)] pub fn zero<T: Zero>() -> T { Zero::zero() }\n \n@@ -90,6 +137,30 @@ pub trait One: Mul<Self, Self> {\n     fn one() -> Self;\n }\n \n+macro_rules! one_impl(\n+    ($t:ty, $v:expr) => {\n+        impl One for $t {\n+            #[inline]\n+            fn one() -> $t { $v }\n+        }\n+    }\n+)\n+\n+one_impl!(uint, 1u)\n+one_impl!(u8,  1u8)\n+one_impl!(u16, 1u16)\n+one_impl!(u32, 1u32)\n+one_impl!(u64, 1u64)\n+\n+one_impl!(int, 1i)\n+one_impl!(i8,  1i8)\n+one_impl!(i16, 1i16)\n+one_impl!(i32, 1i32)\n+one_impl!(i64, 1i64)\n+\n+one_impl!(f32, 1.0f32)\n+one_impl!(f64, 1.0f64)\n+\n /// Returns the multiplicative identity, `1`.\n #[inline(always)] pub fn one<T: One>() -> T { One::one() }\n \n@@ -128,6 +199,85 @@ pub trait Signed: Num + Neg<Self> {\n     fn is_negative(&self) -> bool;\n }\n \n+macro_rules! signed_impl(\n+    ($($t:ty)*) => ($(\n+        impl Signed for $t {\n+            #[inline]\n+            fn abs(&self) -> $t {\n+                if self.is_negative() { -*self } else { *self }\n+            }\n+\n+            #[inline]\n+            fn abs_sub(&self, other: &$t) -> $t {\n+                if *self <= *other { 0 } else { *self - *other }\n+            }\n+\n+            #[inline]\n+            fn signum(&self) -> $t {\n+                match *self {\n+                    n if n > 0 => 1,\n+                    0 => 0,\n+                    _ => -1,\n+                }\n+            }\n+\n+            #[inline]\n+            fn is_positive(&self) -> bool { *self > 0 }\n+\n+            #[inline]\n+            fn is_negative(&self) -> bool { *self < 0 }\n+        }\n+    )*)\n+)\n+\n+signed_impl!(int i8 i16 i32 i64)\n+\n+macro_rules! signed_float_impl(\n+    ($t:ty, $nan:expr, $inf:expr, $neg_inf:expr, $fabs:path, $fcopysign:path, $fdim:ident) => {\n+        impl Signed for $t {\n+            /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n+            #[inline]\n+            fn abs(&self) -> $t {\n+                unsafe { $fabs(*self) }\n+            }\n+\n+            /// The positive difference of two numbers. Returns `0.0` if the number is\n+            /// less than or equal to `other`, otherwise the difference between`self`\n+            /// and `other` is returned.\n+            #[inline]\n+            fn abs_sub(&self, other: &$t) -> $t {\n+                extern { fn $fdim(a: $t, b: $t) -> $t; }\n+                unsafe { $fdim(*self, *other) }\n+            }\n+\n+            /// # Returns\n+            ///\n+            /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n+            /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n+            /// - `NAN` if the number is NaN\n+            #[inline]\n+            fn signum(&self) -> $t {\n+                if self != self { $nan } else {\n+                    unsafe { $fcopysign(1.0, *self) }\n+                }\n+            }\n+\n+            /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n+            #[inline]\n+            fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == $inf }\n+\n+            /// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`\n+            #[inline]\n+            fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == $neg_inf }\n+        }\n+    }\n+)\n+\n+signed_float_impl!(f32, f32::NAN, f32::INFINITY, f32::NEG_INFINITY,\n+                   intrinsics::fabsf32, intrinsics::copysignf32, fdimf)\n+signed_float_impl!(f64, f64::NAN, f64::INFINITY, f64::NEG_INFINITY,\n+                   intrinsics::fabsf64, intrinsics::copysignf64, fdim)\n+\n /// Computes the absolute value.\n ///\n /// For `f32` and `f64`, `NaN` will be returned if the number is `NaN`\n@@ -163,6 +313,8 @@ pub fn abs_sub<T: Signed>(x: T, y: T) -> T {\n /// A trait for values which cannot be negative\n pub trait Unsigned: Num {}\n \n+trait_impl!(Unsigned for uint u8 u16 u32 u64)\n+\n /// Raises a value to the power of exp, using exponentiation by squaring.\n ///\n /// # Example\n@@ -197,6 +349,33 @@ pub trait Bounded {\n     fn max_value() -> Self;\n }\n \n+macro_rules! bounded_impl(\n+    ($t:ty, $min:expr, $max:expr) => {\n+        impl Bounded for $t {\n+            #[inline]\n+            fn min_value() -> $t { $min }\n+\n+            #[inline]\n+            fn max_value() -> $t { $max }\n+        }\n+    }\n+)\n+\n+bounded_impl!(uint, uint::MIN, uint::MAX)\n+bounded_impl!(u8, u8::MIN, u8::MAX)\n+bounded_impl!(u16, u16::MIN, u16::MAX)\n+bounded_impl!(u32, u32::MIN, u32::MAX)\n+bounded_impl!(u64, u64::MIN, u64::MAX)\n+\n+bounded_impl!(int, int::MIN, int::MAX)\n+bounded_impl!(i8, i8::MIN, i8::MAX)\n+bounded_impl!(i16, i16::MIN, i16::MAX)\n+bounded_impl!(i32, i32::MIN, i32::MAX)\n+bounded_impl!(i64, i64::MIN, i64::MAX)\n+\n+bounded_impl!(f32, f32::MIN_VALUE, f32::MAX_VALUE)\n+bounded_impl!(f64, f64::MIN_VALUE, f64::MAX_VALUE)\n+\n /// Numbers with a fixed binary representation.\n pub trait Bitwise: Bounded\n                  + Not<Self>\n@@ -259,6 +438,56 @@ pub trait Bitwise: Bounded\n     fn trailing_zeros(&self) -> Self;\n }\n \n+macro_rules! bitwise_impl(\n+    ($t:ty, $co:path, $lz:path, $tz:path) => {\n+        impl Bitwise for $t {\n+            #[inline]\n+            fn count_ones(&self) -> $t { unsafe { $co(*self) } }\n+\n+            #[inline]\n+            fn leading_zeros(&self) -> $t { unsafe { $lz(*self) } }\n+\n+            #[inline]\n+            fn trailing_zeros(&self) -> $t { unsafe { $tz(*self) } }\n+        }\n+    }\n+)\n+\n+macro_rules! bitwise_cast_impl(\n+    ($t:ty, $t_cast:ty,  $co:path, $lz:path, $tz:path) => {\n+        impl Bitwise for $t {\n+            #[inline]\n+            fn count_ones(&self) -> $t { unsafe { $co(*self as $t_cast) as $t } }\n+\n+            #[inline]\n+            fn leading_zeros(&self) -> $t { unsafe { $lz(*self as $t_cast) as $t } }\n+\n+            #[inline]\n+            fn trailing_zeros(&self) -> $t { unsafe { $tz(*self as $t_cast) as $t } }\n+        }\n+    }\n+)\n+\n+#[cfg(target_word_size = \"32\")]\n+bitwise_cast_impl!(uint, u32, intrinsics::ctpop32, intrinsics::ctlz32, intrinsics::cttz32)\n+#[cfg(target_word_size = \"64\")]\n+bitwise_cast_impl!(uint, u64, intrinsics::ctpop64, intrinsics::ctlz64, intrinsics::cttz64)\n+\n+bitwise_impl!(u8, intrinsics::ctpop8, intrinsics::ctlz8, intrinsics::cttz8)\n+bitwise_impl!(u16, intrinsics::ctpop16, intrinsics::ctlz16, intrinsics::cttz16)\n+bitwise_impl!(u32, intrinsics::ctpop32, intrinsics::ctlz32, intrinsics::cttz32)\n+bitwise_impl!(u64, intrinsics::ctpop64, intrinsics::ctlz64, intrinsics::cttz64)\n+\n+#[cfg(target_word_size = \"32\")]\n+bitwise_cast_impl!(int, u32, intrinsics::ctpop32, intrinsics::ctlz32, intrinsics::cttz32)\n+#[cfg(target_word_size = \"64\")]\n+bitwise_cast_impl!(int, u64, intrinsics::ctpop64, intrinsics::ctlz64, intrinsics::cttz64)\n+\n+bitwise_cast_impl!(i8, u8, intrinsics::ctpop8, intrinsics::ctlz8, intrinsics::cttz8)\n+bitwise_cast_impl!(i16, u16, intrinsics::ctpop16, intrinsics::ctlz16, intrinsics::cttz16)\n+bitwise_cast_impl!(i32, u32, intrinsics::ctpop32, intrinsics::ctlz32, intrinsics::cttz32)\n+bitwise_cast_impl!(i64, u64, intrinsics::ctpop64, intrinsics::ctlz64, intrinsics::cttz64)\n+\n /// Specifies the available operations common to all of Rust's core numeric primitives.\n /// These may not always make sense from a purely mathematical point of view, but\n /// may be useful for systems programming.\n@@ -269,6 +498,8 @@ pub trait Primitive: Copy\n                    + Ord\n                    + Bounded {}\n \n+trait_impl!(Primitive for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+\n /// A collection of traits relevant to primitive signed and unsigned integers\n pub trait Int: Primitive\n              + Bitwise\n@@ -277,6 +508,8 @@ pub trait Int: Primitive\n              + CheckedMul\n              + CheckedDiv {}\n \n+trait_impl!(Int for uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+\n /// Returns the smallest power of 2 greater than or equal to `n`.\n #[inline]\n pub fn next_power_of_two<T: Unsigned + Int>(n: T) -> T {\n@@ -842,12 +1075,79 @@ pub trait CheckedAdd: Add<Self, Self> {\n     fn checked_add(&self, v: &Self) -> Option<Self>;\n }\n \n+macro_rules! checked_impl(\n+    ($trait_name:ident, $method:ident, $t:ty, $op:path) => {\n+        impl $trait_name for $t {\n+            #[inline]\n+            fn $method(&self, v: &$t) -> Option<$t> {\n+                unsafe {\n+                    let (x, y) = $op(*self, *v);\n+                    if y { None } else { Some(x) }\n+                }\n+            }\n+        }\n+    }\n+)\n+macro_rules! checked_cast_impl(\n+    ($trait_name:ident, $method:ident, $t:ty, $cast:ty, $op:path) => {\n+        impl $trait_name for $t {\n+            #[inline]\n+            fn $method(&self, v: &$t) -> Option<$t> {\n+                unsafe {\n+                    let (x, y) = $op(*self as $cast, *v as $cast);\n+                    if y { None } else { Some(x as $t) }\n+                }\n+            }\n+        }\n+    }\n+)\n+\n+#[cfg(target_word_size = \"32\")]\n+checked_cast_impl!(CheckedAdd, checked_add, uint, u32, intrinsics::u32_add_with_overflow)\n+#[cfg(target_word_size = \"64\")]\n+checked_cast_impl!(CheckedAdd, checked_add, uint, u64, intrinsics::u64_add_with_overflow)\n+\n+checked_impl!(CheckedAdd, checked_add, u8,  intrinsics::u8_add_with_overflow)\n+checked_impl!(CheckedAdd, checked_add, u16, intrinsics::u16_add_with_overflow)\n+checked_impl!(CheckedAdd, checked_add, u32, intrinsics::u32_add_with_overflow)\n+checked_impl!(CheckedAdd, checked_add, u64, intrinsics::u64_add_with_overflow)\n+\n+#[cfg(target_word_size = \"32\")]\n+checked_cast_impl!(CheckedAdd, checked_add, int, i32, intrinsics::i32_add_with_overflow)\n+#[cfg(target_word_size = \"64\")]\n+checked_cast_impl!(CheckedAdd, checked_add, int, i64, intrinsics::i64_add_with_overflow)\n+\n+checked_impl!(CheckedAdd, checked_add, i8,  intrinsics::i8_add_with_overflow)\n+checked_impl!(CheckedAdd, checked_add, i16, intrinsics::i16_add_with_overflow)\n+checked_impl!(CheckedAdd, checked_add, i32, intrinsics::i32_add_with_overflow)\n+checked_impl!(CheckedAdd, checked_add, i64, intrinsics::i64_add_with_overflow)\n+\n /// Performs subtraction that returns `None` instead of wrapping around on underflow.\n pub trait CheckedSub: Sub<Self, Self> {\n     /// Subtracts two numbers, checking for underflow. If underflow happens, `None` is returned.\n     fn checked_sub(&self, v: &Self) -> Option<Self>;\n }\n \n+#[cfg(target_word_size = \"32\")]\n+checked_cast_impl!(CheckedSub, checked_sub, uint, u32, intrinsics::u32_sub_with_overflow)\n+#[cfg(target_word_size = \"64\")]\n+checked_cast_impl!(CheckedSub, checked_sub, uint, u64, intrinsics::u64_sub_with_overflow)\n+\n+checked_impl!(CheckedSub, checked_sub, u8,  intrinsics::u8_sub_with_overflow)\n+checked_impl!(CheckedSub, checked_sub, u16, intrinsics::u16_sub_with_overflow)\n+checked_impl!(CheckedSub, checked_sub, u32, intrinsics::u32_sub_with_overflow)\n+checked_impl!(CheckedSub, checked_sub, u64, intrinsics::u64_sub_with_overflow)\n+\n+#[cfg(target_word_size = \"32\")]\n+checked_cast_impl!(CheckedSub, checked_sub, int, i32, intrinsics::i32_sub_with_overflow)\n+#[cfg(target_word_size = \"64\")]\n+checked_cast_impl!(CheckedSub, checked_sub, int, i64, intrinsics::i64_sub_with_overflow)\n+\n+checked_impl!(CheckedSub, checked_sub, i8,  intrinsics::i8_sub_with_overflow)\n+checked_impl!(CheckedSub, checked_sub, i16, intrinsics::i16_sub_with_overflow)\n+checked_impl!(CheckedSub, checked_sub, i32, intrinsics::i32_sub_with_overflow)\n+checked_impl!(CheckedSub, checked_sub, i64, intrinsics::i64_sub_with_overflow)\n+\n /// Performs multiplication that returns `None` instead of wrapping around on underflow or\n /// overflow.\n pub trait CheckedMul: Mul<Self, Self> {\n@@ -856,13 +1156,71 @@ pub trait CheckedMul: Mul<Self, Self> {\n     fn checked_mul(&self, v: &Self) -> Option<Self>;\n }\n \n+#[cfg(target_word_size = \"32\")]\n+checked_cast_impl!(CheckedMul, checked_mul, uint, u32, intrinsics::u32_mul_with_overflow)\n+#[cfg(target_word_size = \"64\")]\n+checked_cast_impl!(CheckedMul, checked_mul, uint, u64, intrinsics::u64_mul_with_overflow)\n+\n+checked_impl!(CheckedMul, checked_mul, u8,  intrinsics::u8_mul_with_overflow)\n+checked_impl!(CheckedMul, checked_mul, u16, intrinsics::u16_mul_with_overflow)\n+checked_impl!(CheckedMul, checked_mul, u32, intrinsics::u32_mul_with_overflow)\n+checked_impl!(CheckedMul, checked_mul, u64, intrinsics::u64_mul_with_overflow)\n+\n+#[cfg(target_word_size = \"32\")]\n+checked_cast_impl!(CheckedMul, checked_mul, int, i32, intrinsics::i32_mul_with_overflow)\n+#[cfg(target_word_size = \"64\")]\n+checked_cast_impl!(CheckedMul, checked_mul, int, i64, intrinsics::i64_mul_with_overflow)\n+\n+checked_impl!(CheckedMul, checked_mul, i8,  intrinsics::i8_mul_with_overflow)\n+checked_impl!(CheckedMul, checked_mul, i16, intrinsics::i16_mul_with_overflow)\n+checked_impl!(CheckedMul, checked_mul, i32, intrinsics::i32_mul_with_overflow)\n+checked_impl!(CheckedMul, checked_mul, i64, intrinsics::i64_mul_with_overflow)\n+\n /// Performs division that returns `None` instead of wrapping around on underflow or overflow.\n pub trait CheckedDiv: Div<Self, Self> {\n     /// Divides two numbers, checking for underflow or overflow. If underflow or overflow happens,\n     /// `None` is returned.\n     fn checked_div(&self, v: &Self) -> Option<Self>;\n }\n \n+macro_rules! checkeddiv_int_impl(\n+    ($t:ty, $min:expr) => {\n+        impl CheckedDiv for $t {\n+            #[inline]\n+            fn checked_div(&self, v: &$t) -> Option<$t> {\n+                if *v == 0 || (*self == $min && *v == -1) {\n+                    None\n+                } else {\n+                    Some(self / *v)\n+                }\n+            }\n+        }\n+    }\n+)\n+\n+checkeddiv_int_impl!(int, int::MIN)\n+checkeddiv_int_impl!(i8, i8::MIN)\n+checkeddiv_int_impl!(i16, i16::MIN)\n+checkeddiv_int_impl!(i32, i32::MIN)\n+checkeddiv_int_impl!(i64, i64::MIN)\n+\n+macro_rules! checkeddiv_uint_impl(\n+    ($($t:ty)*) => ($(\n+        impl CheckedDiv for $t {\n+            #[inline]\n+            fn checked_div(&self, v: &$t) -> Option<$t> {\n+                if *v == 0 {\n+                    None\n+                } else {\n+                    Some(self / *v)\n+                }\n+            }\n+        }\n+    )*)\n+)\n+\n+checkeddiv_uint_impl!(uint u8 u16 u32 u64)\n+\n /// Helper function for testing numeric operations\n #[cfg(test)]\n pub fn test_num<T:Num + NumCast + ::std::fmt::Show>(ten: T, two: T) {"}, {"sha": "b3c701115c54f8501d68871570e2bd65b47e8346", "filename": "src/libcore/num/u16.rs", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu16.rs?ref=dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "patch": "@@ -10,47 +10,4 @@\n \n //! Operations and constants for unsigned 16-bits integers (`u16` type)\n \n-use default::Default;\n-use intrinsics;\n-use num::{Bitwise, Bounded, Zero, One, Unsigned, Num, Int, Primitive};\n-use num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n-use option::{Some, None, Option};\n-\n-#[cfg(not(test))]\n-use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n-#[cfg(not(test))]\n-use ops::{Add, Sub, Mul, Div, Rem, Neg, BitAnd, BitOr, BitXor};\n-#[cfg(not(test))]\n-use ops::{Shl, Shr, Not};\n-\n uint_module!(u16, i16, 16)\n-\n-impl CheckedAdd for u16 {\n-    #[inline]\n-    fn checked_add(&self, v: &u16) -> Option<u16> {\n-        unsafe {\n-            let (x, y) = intrinsics::u16_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n-\n-impl CheckedSub for u16 {\n-    #[inline]\n-    fn checked_sub(&self, v: &u16) -> Option<u16> {\n-        unsafe {\n-            let (x, y) = intrinsics::u16_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n-\n-impl CheckedMul for u16 {\n-    #[inline]\n-    fn checked_mul(&self, v: &u16) -> Option<u16> {\n-        unsafe {\n-            let (x, y) = intrinsics::u16_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}"}, {"sha": "46f90dca833333db50490abafa531cb49569fe67", "filename": "src/libcore/num/u32.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu32.rs?ref=dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "patch": "@@ -10,47 +10,5 @@\n \n //! Operations and constants for unsigned 32-bits integers (`u32` type)\n \n-use default::Default;\n-use intrinsics;\n-use num::{Bitwise, Bounded, Zero, One, Unsigned, Num, Int, Primitive};\n-use num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n-use option::{Some, None, Option};\n-\n-#[cfg(not(test))]\n-use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n-#[cfg(not(test))]\n-use ops::{Add, Sub, Mul, Div, Rem, Neg, BitAnd, BitOr, BitXor};\n-#[cfg(not(test))]\n-use ops::{Shl, Shr, Not};\n-\n uint_module!(u32, i32, 32)\n \n-impl CheckedAdd for u32 {\n-    #[inline]\n-    fn checked_add(&self, v: &u32) -> Option<u32> {\n-        unsafe {\n-            let (x, y) = intrinsics::u32_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n-\n-impl CheckedSub for u32 {\n-    #[inline]\n-    fn checked_sub(&self, v: &u32) -> Option<u32> {\n-        unsafe {\n-            let (x, y) = intrinsics::u32_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n-\n-impl CheckedMul for u32 {\n-    #[inline]\n-    fn checked_mul(&self, v: &u32) -> Option<u32> {\n-        unsafe {\n-            let (x, y) = intrinsics::u32_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}"}, {"sha": "bd4333ab5899a0a6de31000b87c5e3b0d3288379", "filename": "src/libcore/num/u64.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu64.rs?ref=dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "patch": "@@ -10,47 +10,5 @@\n \n //! Operations and constants for unsigned 64-bits integer (`u64` type)\n \n-use default::Default;\n-use intrinsics;\n-use num::{Bitwise, Bounded, Zero, One, Unsigned, Num, Int, Primitive};\n-use num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n-use option::{Some, None, Option};\n-\n-#[cfg(not(test))]\n-use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n-#[cfg(not(test))]\n-use ops::{Add, Sub, Mul, Div, Rem, Neg, BitAnd, BitOr, BitXor};\n-#[cfg(not(test))]\n-use ops::{Shl, Shr, Not};\n-\n uint_module!(u64, i64, 64)\n \n-impl CheckedAdd for u64 {\n-    #[inline]\n-    fn checked_add(&self, v: &u64) -> Option<u64> {\n-        unsafe {\n-            let (x, y) = intrinsics::u64_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n-\n-impl CheckedSub for u64 {\n-    #[inline]\n-    fn checked_sub(&self, v: &u64) -> Option<u64> {\n-        unsafe {\n-            let (x, y) = intrinsics::u64_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n-\n-impl CheckedMul for u64 {\n-    #[inline]\n-    fn checked_mul(&self, v: &u64) -> Option<u64> {\n-        unsafe {\n-            let (x, y) = intrinsics::u64_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}"}, {"sha": "00871a1c8fad11b087b1686f234b2753ae1c8a7a", "filename": "src/libcore/num/u8.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu8.rs?ref=dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "patch": "@@ -10,47 +10,5 @@\n \n //! Operations and constants for unsigned 8-bits integers (`u8` type)\n \n-use default::Default;\n-use intrinsics;\n-use num::{Bitwise, Bounded, Zero, One, Unsigned, Num, Int, Primitive};\n-use num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n-use option::{Some, None, Option};\n-\n-#[cfg(not(test))]\n-use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n-#[cfg(not(test))]\n-use ops::{Add, Sub, Mul, Div, Rem, Neg, BitAnd, BitOr, BitXor};\n-#[cfg(not(test))]\n-use ops::{Shl, Shr, Not};\n-\n uint_module!(u8, i8, 8)\n \n-impl CheckedAdd for u8 {\n-    #[inline]\n-    fn checked_add(&self, v: &u8) -> Option<u8> {\n-        unsafe {\n-            let (x, y) = intrinsics::u8_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n-\n-impl CheckedSub for u8 {\n-    #[inline]\n-    fn checked_sub(&self, v: &u8) -> Option<u8> {\n-        unsafe {\n-            let (x, y) = intrinsics::u8_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n-\n-impl CheckedMul for u8 {\n-    #[inline]\n-    fn checked_mul(&self, v: &u8) -> Option<u8> {\n-        unsafe {\n-            let (x, y) = intrinsics::u8_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}"}, {"sha": "99ed7e10bf9e3a3b8bc0e836289b3df3d014c5a2", "filename": "src/libcore/num/uint.rs", "status": "modified", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint.rs?ref=dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "patch": "@@ -10,83 +10,5 @@\n \n //! Operations and constants for architecture-sized unsigned integers (`uint` type)\n \n-use default::Default;\n-use intrinsics;\n-use num::{Bitwise, Bounded, Zero, One, Unsigned, Num, Int, Primitive};\n-use num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n-use option::{Some, None, Option};\n-\n-#[cfg(not(test))]\n-use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n-#[cfg(not(test))]\n-use ops::{Add, Sub, Mul, Div, Rem, Neg, BitAnd, BitOr, BitXor};\n-#[cfg(not(test))]\n-use ops::{Shl, Shr, Not};\n-\n uint_module!(uint, int, ::int::BITS)\n \n-#[cfg(target_word_size = \"32\")]\n-impl CheckedAdd for uint {\n-    #[inline]\n-    fn checked_add(&self, v: &uint) -> Option<uint> {\n-        unsafe {\n-            let (x, y) = intrinsics::u32_add_with_overflow(*self as u32, *v as u32);\n-            if y { None } else { Some(x as uint) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"64\")]\n-impl CheckedAdd for uint {\n-    #[inline]\n-    fn checked_add(&self, v: &uint) -> Option<uint> {\n-        unsafe {\n-            let (x, y) = intrinsics::u64_add_with_overflow(*self as u64, *v as u64);\n-            if y { None } else { Some(x as uint) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"32\")]\n-impl CheckedSub for uint {\n-    #[inline]\n-    fn checked_sub(&self, v: &uint) -> Option<uint> {\n-        unsafe {\n-            let (x, y) = intrinsics::u32_sub_with_overflow(*self as u32, *v as u32);\n-            if y { None } else { Some(x as uint) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"64\")]\n-impl CheckedSub for uint {\n-    #[inline]\n-    fn checked_sub(&self, v: &uint) -> Option<uint> {\n-        unsafe {\n-            let (x, y) = intrinsics::u64_sub_with_overflow(*self as u64, *v as u64);\n-            if y { None } else { Some(x as uint) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"32\")]\n-impl CheckedMul for uint {\n-    #[inline]\n-    fn checked_mul(&self, v: &uint) -> Option<uint> {\n-        unsafe {\n-            let (x, y) = intrinsics::u32_mul_with_overflow(*self as u32, *v as u32);\n-            if y { None } else { Some(x as uint) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"64\")]\n-impl CheckedMul for uint {\n-    #[inline]\n-    fn checked_mul(&self, v: &uint) -> Option<uint> {\n-        unsafe {\n-            let (x, y) = intrinsics::u64_mul_with_overflow(*self as u64, *v as u64);\n-            if y { None } else { Some(x as uint) }\n-        }\n-    }\n-}"}, {"sha": "0e094b9ec31435ed453bcffb4f3b4ad9a27805cf", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 161, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "patch": "@@ -19,167 +19,6 @@ pub static BYTES : uint = ($bits / 8);\n pub static MIN: $T = 0 as $T;\n pub static MAX: $T = 0 as $T - 1 as $T;\n \n-#[cfg(not(test))]\n-impl Ord for $T {\n-    #[inline]\n-    fn lt(&self, other: &$T) -> bool { *self < *other }\n-}\n-#[cfg(not(test))]\n-impl TotalEq for $T {}\n-#[cfg(not(test))]\n-impl Eq for $T {\n-    #[inline]\n-    fn eq(&self, other: &$T) -> bool { *self == *other }\n-}\n-#[cfg(not(test))]\n-impl TotalOrd for $T {\n-    #[inline]\n-    fn cmp(&self, other: &$T) -> Ordering {\n-        if *self < *other { Less }\n-        else if *self > *other { Greater }\n-        else { Equal }\n-    }\n-}\n-\n-impl Num for $T {}\n-\n-impl Zero for $T {\n-    #[inline]\n-    fn zero() -> $T { 0 }\n-\n-    #[inline]\n-    fn is_zero(&self) -> bool { *self == 0 }\n-}\n-\n-impl One for $T {\n-    #[inline]\n-    fn one() -> $T { 1 }\n-}\n-\n-#[cfg(not(test))]\n-impl Add<$T,$T> for $T {\n-    #[inline]\n-    fn add(&self, other: &$T) -> $T { *self + *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Sub<$T,$T> for $T {\n-    #[inline]\n-    fn sub(&self, other: &$T) -> $T { *self - *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Mul<$T,$T> for $T {\n-    #[inline]\n-    fn mul(&self, other: &$T) -> $T { *self * *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Div<$T,$T> for $T {\n-    #[inline]\n-    fn div(&self, other: &$T) -> $T { *self / *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Rem<$T,$T> for $T {\n-    #[inline]\n-    fn rem(&self, other: &$T) -> $T { *self % *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Neg<$T> for $T {\n-    #[inline]\n-    fn neg(&self) -> $T { -(*self as $T_SIGNED) as $T }\n-}\n-\n-impl Unsigned for $T {}\n-\n-#[cfg(not(test))]\n-impl BitOr<$T,$T> for $T {\n-    #[inline]\n-    fn bitor(&self, other: &$T) -> $T { *self | *other }\n-}\n-\n-#[cfg(not(test))]\n-impl BitAnd<$T,$T> for $T {\n-    #[inline]\n-    fn bitand(&self, other: &$T) -> $T { *self & *other }\n-}\n-\n-#[cfg(not(test))]\n-impl BitXor<$T,$T> for $T {\n-    #[inline]\n-    fn bitxor(&self, other: &$T) -> $T { *self ^ *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Shl<$T,$T> for $T {\n-    #[inline]\n-    fn shl(&self, other: &$T) -> $T { *self << *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Shr<$T,$T> for $T {\n-    #[inline]\n-    fn shr(&self, other: &$T) -> $T { *self >> *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Not<$T> for $T {\n-    #[inline]\n-    fn not(&self) -> $T { !*self }\n-}\n-\n-impl Bounded for $T {\n-    #[inline]\n-    fn min_value() -> $T { MIN }\n-\n-    #[inline]\n-    fn max_value() -> $T { MAX }\n-}\n-\n-impl Bitwise for $T {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> $T {\n-        (*self as $T_SIGNED).count_ones() as $T\n-    }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> $T {\n-        (*self as $T_SIGNED).leading_zeros() as $T\n-    }\n-\n-    /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn trailing_zeros(&self) -> $T {\n-        (*self as $T_SIGNED).trailing_zeros() as $T\n-    }\n-}\n-\n-impl CheckedDiv for $T {\n-    #[inline]\n-    fn checked_div(&self, v: &$T) -> Option<$T> {\n-        if *v == 0 {\n-            None\n-        } else {\n-            Some(self / *v)\n-        }\n-    }\n-}\n-\n-impl Int for $T {}\n-\n-impl Primitive for $T {}\n-\n-impl Default for $T {\n-    #[inline]\n-    fn default() -> $T { 0 }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::*;"}, {"sha": "08e033f961f45d3583aa59d5f299641b4f6e48fd", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=dd0d495f50e2d8ba501e6b003cb4c1ef52d95ed5", "patch": "@@ -115,6 +115,18 @@ pub trait Add<RHS,Result> {\n     fn add(&self, rhs: &RHS) -> Result;\n }\n \n+macro_rules! add_impl(\n+    ($($t:ty)*) => ($(\n+        #[cfg(not(test))]\n+        impl Add<$t, $t> for $t {\n+            #[inline]\n+            fn add(&self, other: &$t) -> $t { (*self) + (*other) }\n+        }\n+    )*)\n+)\n+\n+add_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+\n /**\n  *\n  * The `Sub` trait is used to specify the functionality of `-`.\n@@ -145,6 +157,18 @@ pub trait Sub<RHS,Result> {\n     fn sub(&self, rhs: &RHS) -> Result;\n }\n \n+macro_rules! sub_impl(\n+    ($($t:ty)*) => ($(\n+        #[cfg(not(test))]\n+        impl Sub<$t, $t> for $t {\n+            #[inline]\n+            fn sub(&self, other: &$t) -> $t { (*self) - (*other) }\n+        }\n+    )*)\n+)\n+\n+sub_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+\n /**\n  *\n  * The `Mul` trait is used to specify the functionality of `*`.\n@@ -175,6 +199,18 @@ pub trait Mul<RHS,Result> {\n     fn mul(&self, rhs: &RHS) -> Result;\n }\n \n+macro_rules! mul_impl(\n+    ($($t:ty)*) => ($(\n+        #[cfg(not(test))]\n+        impl Mul<$t, $t> for $t {\n+            #[inline]\n+            fn mul(&self, other: &$t) -> $t { (*self) * (*other) }\n+        }\n+    )*)\n+)\n+\n+mul_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+\n /**\n  *\n  * The `Div` trait is used to specify the functionality of `/`.\n@@ -205,6 +241,18 @@ pub trait Div<RHS,Result> {\n     fn div(&self, rhs: &RHS) -> Result;\n }\n \n+macro_rules! div_impl(\n+    ($($t:ty)*) => ($(\n+        #[cfg(not(test))]\n+        impl Div<$t, $t> for $t {\n+            #[inline]\n+            fn div(&self, other: &$t) -> $t { (*self) / (*other) }\n+        }\n+    )*)\n+)\n+\n+div_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+\n /**\n  *\n  * The `Rem` trait is used to specify the functionality of `%`.\n@@ -235,6 +283,33 @@ pub trait Rem<RHS,Result> {\n     fn rem(&self, rhs: &RHS) -> Result;\n }\n \n+macro_rules! rem_impl(\n+    ($($t:ty)*) => ($(\n+        #[cfg(not(test))]\n+        impl Rem<$t, $t> for $t {\n+            #[inline]\n+            fn rem(&self, other: &$t) -> $t { (*self) % (*other) }\n+        }\n+    )*)\n+)\n+\n+macro_rules! rem_float_impl(\n+    ($t:ty, $fmod:ident) => {\n+        #[cfg(not(test))]\n+        impl Rem<$t, $t> for $t {\n+            #[inline]\n+            fn rem(&self, other: &$t) -> $t {\n+                extern { fn $fmod(a: $t, b: $t) -> $t; }\n+                unsafe { $fmod(*self, *other) }\n+            }\n+        }\n+    }\n+)\n+\n+rem_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+rem_float_impl!(f32, fmodf)\n+rem_float_impl!(f64, fmod)\n+\n /**\n  *\n  * The `Neg` trait is used to specify the functionality of unary `-`.\n@@ -265,6 +340,35 @@ pub trait Neg<Result> {\n     fn neg(&self) -> Result;\n }\n \n+macro_rules! neg_impl(\n+    ($($t:ty)*) => ($(\n+        #[cfg(not(test))]\n+        impl Neg<$t> for $t {\n+            #[inline]\n+            fn neg(&self) -> $t { -*self }\n+        }\n+    )*)\n+)\n+\n+macro_rules! neg_uint_impl(\n+    ($t:ty, $t_signed:ty) => {\n+        #[cfg(not(test))]\n+        impl Neg<$t> for $t {\n+            #[inline]\n+            fn neg(&self) -> $t { -(*self as $t_signed) as $t }\n+        }\n+    }\n+)\n+\n+neg_impl!(int i8 i16 i32 i64 f32 f64)\n+\n+neg_uint_impl!(uint, int)\n+neg_uint_impl!(u8, i8)\n+neg_uint_impl!(u16, i16)\n+neg_uint_impl!(u32, i32)\n+neg_uint_impl!(u64, i64)\n+\n+\n /**\n  *\n  * The `Not` trait is used to specify the functionality of unary `!`.\n@@ -295,6 +399,19 @@ pub trait Not<Result> {\n     fn not(&self) -> Result;\n }\n \n+\n+macro_rules! not_impl(\n+    ($($t:ty)*) => ($(\n+        #[cfg(not(test))]\n+        impl Not<$t> for $t {\n+            #[inline]\n+            fn not(&self) -> $t { !*self }\n+        }\n+    )*)\n+)\n+\n+not_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+\n /**\n  *\n  * The `BitAnd` trait is used to specify the functionality of `&`.\n@@ -325,6 +442,18 @@ pub trait BitAnd<RHS,Result> {\n     fn bitand(&self, rhs: &RHS) -> Result;\n }\n \n+macro_rules! bitand_impl(\n+    ($($t:ty)*) => ($(\n+        #[cfg(not(test))]\n+        impl BitAnd<$t, $t> for $t {\n+            #[inline]\n+            fn bitand(&self, rhs: &$t) -> $t { (*self) & (*rhs) }\n+        }\n+    )*)\n+)\n+\n+bitand_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+\n /**\n  *\n  * The `BitOr` trait is used to specify the functionality of `|`.\n@@ -355,6 +484,18 @@ pub trait BitOr<RHS,Result> {\n     fn bitor(&self, rhs: &RHS) -> Result;\n }\n \n+macro_rules! bitor_impl(\n+    ($($t:ty)*) => ($(\n+        #[cfg(not(test))]\n+        impl BitOr<$t,$t> for $t {\n+            #[inline]\n+            fn bitor(&self, rhs: &$t) -> $t { (*self) | (*rhs) }\n+        }\n+    )*)\n+)\n+\n+bitor_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+\n /**\n  *\n  * The `BitXor` trait is used to specify the functionality of `^`.\n@@ -385,6 +526,18 @@ pub trait BitXor<RHS,Result> {\n     fn bitxor(&self, rhs: &RHS) -> Result;\n }\n \n+macro_rules! bitxor_impl(\n+    ($($t:ty)*) => ($(\n+        #[cfg(not(test))]\n+        impl BitXor<$t, $t> for $t {\n+            #[inline]\n+            fn bitxor(&self, other: &$t) -> $t { (*self) ^ (*other) }\n+        }\n+    )*)\n+)\n+\n+bitxor_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+\n /**\n  *\n  * The `Shl` trait is used to specify the functionality of `<<`.\n@@ -415,6 +568,18 @@ pub trait Shl<RHS,Result> {\n     fn shl(&self, rhs: &RHS) -> Result;\n }\n \n+macro_rules! shl_impl(\n+    ($($t:ty)*) => ($(\n+        #[cfg(not(test))]\n+        impl Shl<$t, $t> for $t {\n+            #[inline]\n+            fn shl(&self, other: &$t) -> $t { (*self) << (*other) }\n+        }\n+    )*)\n+)\n+\n+shl_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+\n /**\n  *\n  * The `Shr` trait is used to specify the functionality of `>>`.\n@@ -445,6 +610,18 @@ pub trait Shr<RHS,Result> {\n     fn shr(&self, rhs: &RHS) -> Result;\n }\n \n+macro_rules! shr_impl(\n+    ($($t:ty)*) => ($(\n+        #[cfg(not(test))]\n+        impl Shr<$t, $t> for $t {\n+            #[inline]\n+            fn shr(&self, other: &$t) -> $t { (*self) >> (*other) }\n+        }\n+    )*)\n+)\n+\n+shr_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+\n /**\n  *\n  * The `Index` trait is used to specify the functionality of indexing operations"}]}