{"sha": "20ab47fe499b255498268198279fc3df11a29f3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwYWI0N2ZlNDk5YjI1NTQ5ODI2ODE5ODI3OWZjM2RmMTFhMjlmM2Y=", "commit": {"author": {"name": "Kevin Atkinson", "email": "kevina@cs.utah.edu", "date": "2012-01-23T00:30:07Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-24T01:37:15Z"}, "message": "Allow ast_fold_precursor to change the span.\n\nThis involved changing the prototype for the callbacks to thread the\nspan though.  A wrapper function, fold::wrap, can be used to wrap the\nold style callbacks.", "tree": {"sha": "ca94aea84f0e2f76cf907899260fd4c50237e090", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca94aea84f0e2f76cf907899260fd4c50237e090"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20ab47fe499b255498268198279fc3df11a29f3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20ab47fe499b255498268198279fc3df11a29f3f", "html_url": "https://github.com/rust-lang/rust/commit/20ab47fe499b255498268198279fc3df11a29f3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20ab47fe499b255498268198279fc3df11a29f3f/comments", "author": {"login": "kevina", "id": 1271492, "node_id": "MDQ6VXNlcjEyNzE0OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1271492?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kevina", "html_url": "https://github.com/kevina", "followers_url": "https://api.github.com/users/kevina/followers", "following_url": "https://api.github.com/users/kevina/following{/other_user}", "gists_url": "https://api.github.com/users/kevina/gists{/gist_id}", "starred_url": "https://api.github.com/users/kevina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kevina/subscriptions", "organizations_url": "https://api.github.com/users/kevina/orgs", "repos_url": "https://api.github.com/users/kevina/repos", "events_url": "https://api.github.com/users/kevina/events{/privacy}", "received_events_url": "https://api.github.com/users/kevina/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad21d9c64a1b7b6fb996f37d697c5d4f43f13bae", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad21d9c64a1b7b6fb996f37d697c5d4f43f13bae", "html_url": "https://github.com/rust-lang/rust/commit/ad21d9c64a1b7b6fb996f37d697c5d4f43f13bae"}], "stats": {"total": 196, "additions": 113, "deletions": 83}, "files": [{"sha": "684564052afc188545f3d4eb41e049221e8b9792", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20ab47fe499b255498268198279fc3df11a29f3f/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ab47fe499b255498268198279fc3df11a29f3f/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=20ab47fe499b255498268198279fc3df11a29f3f", "patch": "@@ -27,7 +27,7 @@ fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n \n     let precursor =\n         {fold_mod: bind fold_mod(ctxt, _, _),\n-         fold_block: bind fold_block(ctxt, _, _),\n+         fold_block: fold::wrap(bind fold_block(ctxt, _, _)),\n          fold_native_mod: bind fold_native_mod(ctxt, _, _)\n             with *fold::default_ast_fold()};\n "}, {"sha": "05eedf09bd712b45b5b76651d9f9d0b9d7265482", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20ab47fe499b255498268198279fc3df11a29f3f/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ab47fe499b255498268198279fc3df11a29f3f/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=20ab47fe499b255498268198279fc3df11a29f3f", "patch": "@@ -44,7 +44,7 @@ fn generate_test_harness(sess: session::session,\n           mutable testfns: []};\n \n     let precursor =\n-        {fold_crate: bind fold_crate(cx, _, _),\n+        {fold_crate: fold::wrap(bind fold_crate(cx, _, _)),\n          fold_item: bind fold_item(cx, _, _),\n          fold_mod: bind fold_mod(cx, _, _) with *fold::default_ast_fold()};\n "}, {"sha": "e749b28a417185c72ccc715a60abe0153623a0e3", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/20ab47fe499b255498268198279fc3df11a29f3f/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ab47fe499b255498268198279fc3df11a29f3f/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=20ab47fe499b255498268198279fc3df11a29f3f", "patch": "@@ -10,8 +10,13 @@ import syntax::fold::*;\n import syntax::ext::base::*;\n import syntax::parse::parser::parse_expr_from_source_str;\n \n-fn expand_expr(exts: hashmap<str, syntax_extension>, cx: ext_ctxt, e: expr_,\n-               fld: ast_fold, orig: fn@(expr_, ast_fold) -> expr_) -> expr_ {\n+import codemap::span;\n+\n+fn expand_expr(exts: hashmap<str, syntax_extension>, cx: ext_ctxt,\n+               e: expr_, s: span, fld: ast_fold,\n+               orig: fn@(expr_, span, ast_fold) -> (expr_, span))\n+    -> (expr_, span)\n+{\n     ret alt e {\n           expr_mac(mac) {\n             alt mac.node {\n@@ -31,19 +36,19 @@ fn expand_expr(exts: hashmap<str, syntax_extension>, cx: ext_ctxt, e: expr_,\n                     let fully_expanded = fld.fold_expr(expanded).node;\n                     cx.bt_pop();\n \n-                    fully_expanded\n+                    (fully_expanded, s)\n                   }\n                   some(macro_defining(ext)) {\n                     let named_extension = ext(cx, pth.span, args, body);\n                     exts.insert(named_extension.ident, named_extension.ext);\n-                    ast::expr_rec([], none)\n+                    (ast::expr_rec([], none), s)\n                   }\n                 }\n               }\n               _ { cx.span_bug(mac.span, \"naked syntactic bit\") }\n             }\n           }\n-          _ { orig(e, fld) }\n+          _ { orig(e, s, fld) }\n         };\n }\n \n@@ -67,7 +72,7 @@ fn expand_crate(sess: session::session, c: @crate) -> @crate {\n     let afp = default_ast_fold();\n     let cx: ext_ctxt = mk_ctxt(sess);\n     let f_pre =\n-        {fold_expr: bind expand_expr(exts, cx, _, _, afp.fold_expr)\n+        {fold_expr: bind expand_expr(exts, cx, _, _, _, afp.fold_expr)\n             with *afp};\n     let f = make_fold(f_pre);\n     let cm = parse_expr_from_source_str(\"<anon>\", core_macros(),"}, {"sha": "a8fe550489786991db16f92a2b104b2b0992d741", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/20ab47fe499b255498268198279fc3df11a29f3f/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ab47fe499b255498268198279fc3df11a29f3f/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=20ab47fe499b255498268198279fc3df11a29f3f", "patch": "@@ -194,12 +194,12 @@ fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n     let afp = default_ast_fold();\n     let f_pre =\n         {fold_ident: bind transcribe_ident(cx, b, idx_path, _, _),\n-         fold_path: bind transcribe_path(cx, b, idx_path, _, _),\n+         fold_path: bind transcribe_path(cx, b, idx_path, _, _, _),\n          fold_expr:\n-             bind transcribe_expr(cx, b, idx_path, _, _, afp.fold_expr),\n-         fold_ty: bind transcribe_type(cx, b, idx_path, _, _, afp.fold_ty),\n+             bind transcribe_expr(cx, b, idx_path, _, _, _, afp.fold_expr),\n+         fold_ty: bind transcribe_type(cx, b, idx_path, _, _, _, afp.fold_ty),\n          fold_block:\n-             bind transcribe_block(cx, b, idx_path, _, _, afp.fold_block),\n+             bind transcribe_block(cx, b, idx_path, _, _, _, afp.fold_block),\n          map_exprs: bind transcribe_exprs(cx, b, idx_path, _, _),\n          new_id: bind new_id(_, cx),\n          new_span: bind new_span(cx, _) with *afp};\n@@ -209,7 +209,6 @@ fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n }\n \n \n-\n /* helper: descend into a matcher */\n fn follow(m: arb_depth<matchable>, idx_path: @mutable [uint]) ->\n    arb_depth<matchable> {\n@@ -334,64 +333,67 @@ fn transcribe_ident(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n \n \n fn transcribe_path(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n-                   p: path_, _fld: ast_fold) -> path_ {\n+                   p: path_, s:span, _fld: ast_fold) -> (path_, span) {\n     // Don't substitute into qualified names.\n-    if vec::len(p.types) > 0u || vec::len(p.idents) != 1u { ret p; }\n+    if vec::len(p.types) > 0u || vec::len(p.idents) != 1u { ret (p, s); }\n     ret alt follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n           some(match_ident(id)) {\n-            {global: false, idents: [id.node], types: []}\n+            ({global: false, idents: [id.node], types: []}, s)\n           }\n-          some(match_path(a_pth)) { a_pth.node }\n+          some(match_path(a_pth)) { (a_pth.node, s) }\n           some(m) { match_error(cx, m, \"a path\") }\n-          none { p }\n+          none { (p, s) }\n         }\n }\n \n \n fn transcribe_expr(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n-                   e: ast::expr_, fld: ast_fold,\n-                   orig: fn@(ast::expr_, ast_fold) -> ast::expr_) ->\n-   ast::expr_ {\n+                   e: ast::expr_, s: span, fld: ast_fold,\n+                   orig: fn@(ast::expr_, span, ast_fold)->(ast::expr_, span))\n+    -> (ast::expr_, span)\n+{\n     ret alt e {\n           expr_path(p) {\n             // Don't substitute into qualified names.\n             if vec::len(p.node.types) > 0u || vec::len(p.node.idents) != 1u {\n-                e;\n+                (e, s);\n             }\n             alt follow_for_trans(cx, b.find(p.node.idents[0]), idx_path) {\n               some(match_ident(id)) {\n-                expr_path(@respan(id.span,\n-                                  {global: false,\n-                                   idents: [id.node],\n-                                   types: []}))\n+                (expr_path(@respan(id.span,\n+                                   {global: false,\n+                                    idents: [id.node],\n+                                    types: []})), s)\n               }\n-              some(match_path(a_pth)) { expr_path(a_pth) }\n-              some(match_expr(a_exp)) { a_exp.node }\n+              some(match_path(a_pth)) { (expr_path(a_pth), s) }\n+              some(match_expr(a_exp)) { (a_exp.node, s) }\n               some(m) { match_error(cx, m, \"an expression\") }\n-              none { orig(e, fld) }\n+              none { orig(e, s, fld) }\n             }\n           }\n-          _ { orig(e, fld) }\n+          _ { orig(e, s, fld) }\n         }\n }\n \n fn transcribe_type(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n-                   t: ast::ty_, fld: ast_fold,\n-                   orig: fn@(ast::ty_, ast_fold) -> ast::ty_) -> ast::ty_ {\n+                   t: ast::ty_, s: span, fld: ast_fold,\n+                   orig: fn@(ast::ty_, span, ast_fold) -> (ast::ty_, span))\n+    -> (ast::ty_, span)\n+{\n     ret alt t {\n           ast::ty_path(pth, _) {\n             alt path_to_ident(pth) {\n               some(id) {\n                 alt follow_for_trans(cx, b.find(id), idx_path) {\n-                  some(match_ty(ty)) { ty.node }\n+                  some(match_ty(ty)) { (ty.node, s) }\n                   some(m) { match_error(cx, m, \"a type\") }\n-                  none { orig(t, fld) }\n+                  none { orig(t, s, fld) }\n                 }\n               }\n-              none { orig(t, fld) }\n+              none { orig(t, s, fld) }\n             }\n           }\n-          _ { orig(t, fld) }\n+          _ { orig(t, s, fld) }\n         }\n }\n \n@@ -400,12 +402,14 @@ fn transcribe_type(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n `{v}` */\n \n fn transcribe_block(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n-                    blk: blk_, fld: ast_fold,\n-                    orig: fn@(blk_, ast_fold) -> blk_) -> blk_ {\n+                    blk: blk_, s: span, fld: ast_fold,\n+                    orig: fn@(blk_, span, ast_fold) -> (blk_, span))\n+    -> (blk_, span)\n+{\n     ret alt block_to_ident(blk) {\n           some(id) {\n             alt follow_for_trans(cx, b.find(id), idx_path) {\n-              some(match_block(new_blk)) { new_blk.node }\n+              some(match_block(new_blk)) { (new_blk.node, s) }\n \n \n \n@@ -415,10 +419,10 @@ fn transcribe_block(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n               some(m) {\n                 match_error(cx, m, \"a block\")\n               }\n-              none { orig(blk, fld) }\n+              none { orig(blk, s, fld) }\n             }\n           }\n-          none { orig(blk, fld) }\n+          none { orig(blk, s, fld) }\n         }\n }\n "}, {"sha": "f4647211f611fd9de13d032f20a21ac7aa242a06", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 61, "deletions": 40, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/20ab47fe499b255498268198279fc3df11a29f3f/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ab47fe499b255498268198279fc3df11a29f3f/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=20ab47fe499b255498268198279fc3df11a29f3f", "patch": "@@ -13,35 +13,36 @@ export noop_fold_expr;\n export noop_fold_pat;\n export noop_fold_mod;\n export noop_fold_ty;\n+export wrap;\n \n type ast_fold = @mutable a_f;\n \n // We may eventually want to be able to fold over type parameters, too\n \n type ast_fold_precursor =\n     //unlike the others, item_ is non-trivial\n-    {fold_crate: fn@(crate_, ast_fold) -> crate_,\n-     fold_crate_directive: fn@(crate_directive_,\n-                               ast_fold) -> crate_directive_,\n+    {fold_crate: fn@(crate_, span, ast_fold) -> (crate_, span),\n+     fold_crate_directive: fn@(crate_directive_, span,\n+                               ast_fold) -> (crate_directive_, span),\n      fold_view_item: fn@(view_item_, ast_fold) -> view_item_,\n      fold_native_item: fn@(&&@native_item, ast_fold) -> @native_item,\n      fold_item: fn@(&&@item, ast_fold) -> @item,\n      fold_item_underscore: fn@(item_, ast_fold) -> item_,\n      fold_method: fn@(&&@method, ast_fold) -> @method,\n-     fold_block: fn@(blk_, ast_fold) -> blk_,\n-     fold_stmt: fn@(stmt_, ast_fold) -> stmt_,\n+     fold_block: fn@(blk_, span, ast_fold) -> (blk_, span),\n+     fold_stmt: fn@(stmt_, span, ast_fold) -> (stmt_, span),\n      fold_arm: fn@(arm, ast_fold) -> arm,\n-     fold_pat: fn@(pat_, ast_fold) -> pat_,\n-     fold_decl: fn@(decl_, ast_fold) -> decl_,\n-     fold_expr: fn@(expr_, ast_fold) -> expr_,\n-     fold_ty: fn@(ty_, ast_fold) -> ty_,\n-     fold_constr: fn@(ast::constr_, ast_fold) -> constr_,\n+     fold_pat: fn@(pat_, span, ast_fold) -> (pat_, span),\n+     fold_decl: fn@(decl_, span, ast_fold) -> (decl_, span),\n+     fold_expr: fn@(expr_, span, ast_fold) -> (expr_, span),\n+     fold_ty: fn@(ty_, span, ast_fold) -> (ty_, span),\n+     fold_constr: fn@(ast::constr_, span, ast_fold) -> (constr_, span),\n      fold_mod: fn@(_mod, ast_fold) -> _mod,\n      fold_native_mod: fn@(native_mod, ast_fold) -> native_mod,\n-     fold_variant: fn@(variant_, ast_fold) -> variant_,\n+     fold_variant: fn@(variant_, span, ast_fold) -> (variant_, span),\n      fold_ident: fn@(&&ident, ast_fold) -> ident,\n-     fold_path: fn@(path_, ast_fold) -> path_,\n-     fold_local: fn@(local_, ast_fold) -> local_,\n+     fold_path: fn@(path_, span, ast_fold) -> (path_, span),\n+     fold_local: fn@(local_, span, ast_fold) -> (local_, span),\n      map_exprs: fn@(fn@(&&@expr) -> @expr, [@expr]) -> [@expr],\n      new_id: fn@(node_id) -> node_id,\n      new_span: fn@(span) -> span};\n@@ -305,6 +306,14 @@ fn noop_fold_decl(d: decl_, fld: ast_fold) -> decl_ {\n         }\n }\n \n+fn wrap<T>(f: fn@(T, ast_fold) -> T)\n+    -> fn@(T, span, ast_fold) -> (T, span)\n+{\n+    ret fn@(x: T, s: span, fld: ast_fold) -> (T, span) {\n+        (f(x, fld), s)\n+    }\n+}\n+\n fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n     fn fold_field_(field: field, fld: ast_fold) -> field {\n         ret {node:\n@@ -474,27 +483,27 @@ fn noop_span(sp: span) -> span { ret sp; }\n \n \n fn default_ast_fold() -> @ast_fold_precursor {\n-    ret @{fold_crate: noop_fold_crate,\n-          fold_crate_directive: noop_fold_crate_directive,\n+    ret @{fold_crate: wrap(noop_fold_crate),\n+          fold_crate_directive: wrap(noop_fold_crate_directive),\n           fold_view_item: noop_fold_view_item,\n           fold_native_item: noop_fold_native_item,\n           fold_item: noop_fold_item,\n           fold_item_underscore: noop_fold_item_underscore,\n           fold_method: noop_fold_method,\n-          fold_block: noop_fold_block,\n-          fold_stmt: noop_fold_stmt,\n+          fold_block: wrap(noop_fold_block),\n+          fold_stmt: wrap(noop_fold_stmt),\n           fold_arm: noop_fold_arm,\n-          fold_pat: noop_fold_pat,\n-          fold_decl: noop_fold_decl,\n-          fold_expr: noop_fold_expr,\n-          fold_ty: noop_fold_ty,\n-          fold_constr: noop_fold_constr,\n+          fold_pat: wrap(noop_fold_pat),\n+          fold_decl: wrap(noop_fold_decl),\n+          fold_expr: wrap(noop_fold_expr),\n+          fold_ty: wrap(noop_fold_ty),\n+          fold_constr: wrap(noop_fold_constr),\n           fold_mod: noop_fold_mod,\n           fold_native_mod: noop_fold_native_mod,\n-          fold_variant: noop_fold_variant,\n+          fold_variant: wrap(noop_fold_variant),\n           fold_ident: noop_fold_ident,\n-          fold_path: noop_fold_path,\n-          fold_local: noop_fold_local,\n+          fold_path: wrap(noop_fold_path),\n+          fold_local: wrap(noop_fold_local),\n           map_exprs: noop_map_exprs,\n           new_id: noop_id,\n           new_span: noop_span};\n@@ -531,12 +540,14 @@ fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n \n     /* naturally, a macro to write these would be nice */\n     fn f_crate(afp: ast_fold_precursor, f: ast_fold, c: crate) -> crate {\n-        ret {node: afp.fold_crate(c.node, f), span: afp.new_span(c.span)};\n+        let (n, s) = afp.fold_crate(c.node, c.span, f);\n+        ret {node: n, span: afp.new_span(s)};\n     }\n     fn f_crate_directive(afp: ast_fold_precursor, f: ast_fold,\n                          &&c: @crate_directive) -> @crate_directive {\n-        ret @{node: afp.fold_crate_directive(c.node, f),\n-              span: afp.new_span(c.span)};\n+        let (n, s) = afp.fold_crate_directive(c.node, c.span, f);\n+        ret @{node: n,\n+              span: afp.new_span(s)};\n     }\n     fn f_view_item(afp: ast_fold_precursor, f: ast_fold, &&x: @view_item) ->\n        @view_item {\n@@ -559,33 +570,40 @@ fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n         ret afp.fold_method(x, f);\n     }\n     fn f_block(afp: ast_fold_precursor, f: ast_fold, x: blk) -> blk {\n-        ret {node: afp.fold_block(x.node, f), span: afp.new_span(x.span)};\n+        let (n, s) = afp.fold_block(x.node, x.span, f);\n+        ret {node: n, span: afp.new_span(s)};\n     }\n     fn f_stmt(afp: ast_fold_precursor, f: ast_fold, &&x: @stmt) -> @stmt {\n-        ret @{node: afp.fold_stmt(x.node, f), span: afp.new_span(x.span)};\n+        let (n, s) = afp.fold_stmt(x.node, x.span, f);\n+        ret @{node: n, span: afp.new_span(s)};\n     }\n     fn f_arm(afp: ast_fold_precursor, f: ast_fold, x: arm) -> arm {\n         ret afp.fold_arm(x, f);\n     }\n     fn f_pat(afp: ast_fold_precursor, f: ast_fold, &&x: @pat) -> @pat {\n+        let (n, s) =  afp.fold_pat(x.node, x.span, f);\n         ret @{id: afp.new_id(x.id),\n-              node: afp.fold_pat(x.node, f),\n-              span: afp.new_span(x.span)};\n+              node: n,\n+              span: afp.new_span(s)};\n     }\n     fn f_decl(afp: ast_fold_precursor, f: ast_fold, &&x: @decl) -> @decl {\n-        ret @{node: afp.fold_decl(x.node, f), span: afp.new_span(x.span)};\n+        let (n, s) = afp.fold_decl(x.node, x.span, f);\n+        ret @{node: n, span: afp.new_span(s)};\n     }\n     fn f_expr(afp: ast_fold_precursor, f: ast_fold, &&x: @expr) -> @expr {\n+        let (n, s) = afp.fold_expr(x.node, x.span, f);\n         ret @{id: afp.new_id(x.id),\n-              node: afp.fold_expr(x.node, f),\n-              span: afp.new_span(x.span)};\n+              node: n,\n+              span: afp.new_span(s)};\n     }\n     fn f_ty(afp: ast_fold_precursor, f: ast_fold, &&x: @ty) -> @ty {\n-        ret @{node: afp.fold_ty(x.node, f), span: afp.new_span(x.span)};\n+        let (n, s) = afp.fold_ty(x.node, x.span, f);\n+        ret @{node: n, span: afp.new_span(s)};\n     }\n     fn f_constr(afp: ast_fold_precursor, f: ast_fold, &&x: @ast::constr) ->\n        @ast::constr {\n-        ret @{node: afp.fold_constr(x.node, f), span: afp.new_span(x.span)};\n+        let (n, s) = afp.fold_constr(x.node, x.span, f);\n+        ret @{node: n, span: afp.new_span(s)};\n     }\n     fn f_mod(afp: ast_fold_precursor, f: ast_fold, x: _mod) -> _mod {\n         ret afp.fold_mod(x, f);\n@@ -596,16 +614,19 @@ fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n     }\n     fn f_variant(afp: ast_fold_precursor, f: ast_fold, x: variant) ->\n        variant {\n-        ret {node: afp.fold_variant(x.node, f), span: afp.new_span(x.span)};\n+        let (n, s) = afp.fold_variant(x.node, x.span, f);\n+        ret {node: n, span: afp.new_span(s)};\n     }\n     fn f_ident(afp: ast_fold_precursor, f: ast_fold, &&x: ident) -> ident {\n         ret afp.fold_ident(x, f);\n     }\n     fn f_path(afp: ast_fold_precursor, f: ast_fold, &&x: @path) -> @path {\n-        ret @{node: afp.fold_path(x.node, f), span: afp.new_span(x.span)};\n+        let (n, s) = afp.fold_path(x.node, x.span, f);\n+        ret @{node: n, span: afp.new_span(s)};\n     }\n     fn f_local(afp: ast_fold_precursor, f: ast_fold, &&x: @local) -> @local {\n-        ret @{node: afp.fold_local(x.node, f), span: afp.new_span(x.span)};\n+        let (n, s) = afp.fold_local(x.node, x.span, f);\n+        ret @{node: n, span: afp.new_span(s)};\n     }\n \n     *result ="}, {"sha": "b905bfddddec1a10bf9eb1991a5cb64c164bc86a", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20ab47fe499b255498268198279fc3df11a29f3f/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ab47fe499b255498268198279fc3df11a29f3f/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=20ab47fe499b255498268198279fc3df11a29f3f", "patch": "@@ -187,7 +187,7 @@ fn replace_expr_in_crate(crate: ast::crate, i: uint, newexpr: ast::expr, tm: tes\n         }\n     }\n     let afp =\n-        {fold_expr: bind fold_expr_rep(j, i, newexpr.node, _, _, tm)\n+        {fold_expr: fold::wrap(bind fold_expr_rep(j, i, newexpr.node, _, _, tm))\n             with *fold::default_ast_fold()};\n     let af = fold::make_fold(afp);\n     let crate2: @ast::crate = @af.fold_crate(crate);\n@@ -208,7 +208,7 @@ fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::ty, tm: test_mode\n         } else { fold::noop_fold_ty(original, fld) }\n     }\n     let afp =\n-        {fold_ty: bind fold_ty_rep(j, i, newty.node, _, _, tm)\n+        {fold_ty: fold::wrap(bind fold_ty_rep(j, i, newty.node, _, _, tm))\n             with *fold::default_ast_fold()};\n     let af = fold::make_fold(afp);\n     let crate2: @ast::crate = @af.fold_crate(crate);"}]}