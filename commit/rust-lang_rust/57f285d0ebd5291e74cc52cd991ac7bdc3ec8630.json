{"sha": "57f285d0ebd5291e74cc52cd991ac7bdc3ec8630", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ZjI4NWQwZWJkNTI5MWU3NGNjNTJjZDk5MWFjN2JkYzNlYzg2MzA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-04T10:49:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-04T10:49:24Z"}, "message": "Merge #4283\n\n4283: Support macro for trait items r=matklad a=edwin0cheng\n\nFixed  #4039\r\n\r\nr? @flodiebold \n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\nCo-authored-by: Edwin Cheng <edwin@m-inverse.com>", "tree": {"sha": "35752b33aa57155d43a39fa338603e29b70e8a49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35752b33aa57155d43a39fa338603e29b70e8a49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57f285d0ebd5291e74cc52cd991ac7bdc3ec8630", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJer/M0CRBK7hj4Ov3rIwAAdHIIAKOn5Hzpy8+iQdRs0soMQ58c\n8q2yQ1Me3h2AxaiaysXbET7SknYKN4suWtBWzse4gdKpRnwewdK+6pVoCqIgmXqT\nVkENxqdeaFaYwX2a8JRRYcX8fCpzNNgPPD9uOMkdVr+ZaltHk+Kvl4mgyP86f9yj\nS/DlbX+GiEqSNhEYsH0hMwG1db59/KxS875gMtMoW1xWQDi5nUe1gsf2U9deT47b\nxEZhiR2dV/9wBy6ZGhtOjpaGudNYeqOsspUJLmtV3Y3HT4rEW71eG0E0Hd0VolUG\n65iuKohQfkk64v1Wsf52hZDLzHpChD8S1sTS+87nj9QxpIze6epTurtxl/5k3UM=\n=E4AS\n-----END PGP SIGNATURE-----\n", "payload": "tree 35752b33aa57155d43a39fa338603e29b70e8a49\nparent b1a5dc8c8b8588ac61d1952ba3b4cf3b68d2a477\nparent 5899c8eaa9f8868c5c3858e21f5b9b3bbde1de67\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1588589364 +0000\ncommitter GitHub <noreply@github.com> 1588589364 +0000\n\nMerge #4283\n\n4283: Support macro for trait items r=matklad a=edwin0cheng\n\nFixed  #4039\r\n\r\nr? @flodiebold \n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\nCo-authored-by: Edwin Cheng <edwin@m-inverse.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57f285d0ebd5291e74cc52cd991ac7bdc3ec8630", "html_url": "https://github.com/rust-lang/rust/commit/57f285d0ebd5291e74cc52cd991ac7bdc3ec8630", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57f285d0ebd5291e74cc52cd991ac7bdc3ec8630/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1a5dc8c8b8588ac61d1952ba3b4cf3b68d2a477", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1a5dc8c8b8588ac61d1952ba3b4cf3b68d2a477", "html_url": "https://github.com/rust-lang/rust/commit/b1a5dc8c8b8588ac61d1952ba3b4cf3b68d2a477"}, {"sha": "5899c8eaa9f8868c5c3858e21f5b9b3bbde1de67", "url": "https://api.github.com/repos/rust-lang/rust/commits/5899c8eaa9f8868c5c3858e21f5b9b3bbde1de67", "html_url": "https://github.com/rust-lang/rust/commit/5899c8eaa9f8868c5c3858e21f5b9b3bbde1de67"}], "stats": {"total": 184, "additions": 80, "deletions": 104}, "files": [{"sha": "d4cba4d05eec503525d7930030471ff255c7ad9b", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 60, "deletions": 86, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/57f285d0ebd5291e74cc52cd991ac7bdc3ec8630/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f285d0ebd5291e74cc52cd991ac7bdc3ec8630/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=57f285d0ebd5291e74cc52cd991ac7bdc3ec8630", "patch": "@@ -150,51 +150,31 @@ pub struct TraitData {\n \n impl TraitData {\n     pub(crate) fn trait_data_query(db: &dyn DefDatabase, tr: TraitId) -> Arc<TraitData> {\n-        let src = tr.lookup(db).source(db);\n+        let tr_loc = tr.lookup(db);\n+        let src = tr_loc.source(db);\n         let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let auto = src.value.auto_token().is_some();\n-        let ast_id_map = db.ast_id_map(src.file_id);\n+        let module_id = tr_loc.container.module(db);\n \n         let container = AssocContainerId::TraitId(tr);\n-        let items = if let Some(item_list) = src.value.item_list() {\n-            item_list\n-                .impl_items()\n-                .map(|item_node| match item_node {\n-                    ast::ImplItem::FnDef(it) => {\n-                        let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n-                        let def = FunctionLoc {\n-                            container,\n-                            ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n-                        }\n-                        .intern(db)\n-                        .into();\n-                        (name, def)\n-                    }\n-                    ast::ImplItem::ConstDef(it) => {\n-                        let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n-                        let def = ConstLoc {\n-                            container,\n-                            ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n-                        }\n-                        .intern(db)\n-                        .into();\n-                        (name, def)\n-                    }\n-                    ast::ImplItem::TypeAliasDef(it) => {\n-                        let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n-                        let def = TypeAliasLoc {\n-                            container,\n-                            ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n-                        }\n-                        .intern(db)\n-                        .into();\n-                        (name, def)\n-                    }\n-                })\n-                .collect()\n-        } else {\n-            Vec::new()\n-        };\n+        let mut items = Vec::new();\n+\n+        if let Some(item_list) = src.value.item_list() {\n+            let mut expander = Expander::new(db, tr_loc.ast_id.file_id, module_id);\n+            items.extend(collect_items(\n+                db,\n+                &mut expander,\n+                item_list.impl_items(),\n+                src.file_id,\n+                container,\n+            ));\n+            items.extend(collect_items_in_macros(\n+                db,\n+                &mut expander,\n+                &src.with_value(item_list),\n+                container,\n+            ));\n+        }\n         Arc::new(TraitData { name, items, auto })\n     }\n \n@@ -232,24 +212,22 @@ impl ImplData {\n         let target_type = TypeRef::from_ast_opt(&lower_ctx, src.value.target_type());\n         let is_negative = src.value.excl_token().is_some();\n         let module_id = impl_loc.container.module(db);\n+        let container = AssocContainerId::ImplId(id);\n \n-        let mut items = Vec::new();\n+        let mut items: Vec<AssocItemId> = Vec::new();\n \n         if let Some(item_list) = src.value.item_list() {\n             let mut expander = Expander::new(db, impl_loc.ast_id.file_id, module_id);\n-            items.extend(collect_impl_items(\n-                db,\n-                &mut expander,\n-                item_list.impl_items(),\n-                src.file_id,\n-                id,\n-            ));\n-            items.extend(collect_impl_items_in_macros(\n-                db,\n-                &mut expander,\n-                &src.with_value(item_list),\n-                id,\n-            ));\n+            items.extend(\n+                collect_items(db, &mut expander, item_list.impl_items(), src.file_id, container)\n+                    .into_iter()\n+                    .map(|(_, item)| item),\n+            );\n+            items.extend(\n+                collect_items_in_macros(db, &mut expander, &src.with_value(item_list), container)\n+                    .into_iter()\n+                    .map(|(_, item)| item),\n+            );\n         }\n \n         let res = ImplData { target_trait, target_type, items, is_negative };\n@@ -292,49 +270,50 @@ impl ConstData {\n     }\n }\n \n-fn collect_impl_items_in_macros(\n+fn collect_items_in_macros(\n     db: &dyn DefDatabase,\n     expander: &mut Expander,\n     impl_def: &InFile<ast::ItemList>,\n-    id: ImplId,\n-) -> Vec<AssocItemId> {\n+    container: AssocContainerId,\n+) -> Vec<(Name, AssocItemId)> {\n     let mut res = Vec::new();\n \n     // We set a limit to protect against infinite recursion\n     let limit = 100;\n \n     for m in impl_def.value.syntax().children().filter_map(ast::MacroCall::cast) {\n-        res.extend(collect_impl_items_in_macro(db, expander, m, id, limit))\n+        res.extend(collect_items_in_macro(db, expander, m, container, limit))\n     }\n \n     res\n }\n \n-fn collect_impl_items_in_macro(\n+fn collect_items_in_macro(\n     db: &dyn DefDatabase,\n     expander: &mut Expander,\n     m: ast::MacroCall,\n-    id: ImplId,\n+    container: AssocContainerId,\n     limit: usize,\n-) -> Vec<AssocItemId> {\n+) -> Vec<(Name, AssocItemId)> {\n     if limit == 0 {\n         return Vec::new();\n     }\n \n     if let Some((mark, items)) = expander.enter_expand(db, None, m) {\n         let items: InFile<ast::MacroItems> = expander.to_source(items);\n-        let mut res = collect_impl_items(\n+        let mut res = collect_items(\n             db,\n             expander,\n             items.value.items().filter_map(|it| ImplItem::cast(it.syntax().clone())),\n             items.file_id,\n-            id,\n+            container,\n         );\n+\n         // Recursive collect macros\n         // Note that ast::ModuleItem do not include ast::MacroCall\n         // We cannot use ModuleItemOwner::items here\n         for it in items.value.syntax().children().filter_map(ast::MacroCall::cast) {\n-            res.extend(collect_impl_items_in_macro(db, expander, it, id, limit - 1))\n+            res.extend(collect_items_in_macro(db, expander, it, container, limit - 1))\n         }\n         expander.exit(db, mark);\n         res\n@@ -343,44 +322,39 @@ fn collect_impl_items_in_macro(\n     }\n }\n \n-fn collect_impl_items(\n+fn collect_items(\n     db: &dyn DefDatabase,\n     expander: &mut Expander,\n     impl_items: impl Iterator<Item = ImplItem>,\n     file_id: crate::HirFileId,\n-    id: ImplId,\n-) -> Vec<AssocItemId> {\n+    container: AssocContainerId,\n+) -> Vec<(Name, AssocItemId)> {\n     let items = db.ast_id_map(file_id);\n \n     impl_items\n         .filter_map(|item_node| match item_node {\n             ast::ImplItem::FnDef(it) => {\n+                let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n                 let attrs = expander.parse_attrs(&it);\n                 if !expander.is_cfg_enabled(&attrs) {\n                     return None;\n                 }\n-                let def = FunctionLoc {\n-                    container: AssocContainerId::ImplId(id),\n-                    ast_id: AstId::new(file_id, items.ast_id(&it)),\n-                }\n-                .intern(db);\n-                Some(def.into())\n+                let def = FunctionLoc { container, ast_id: AstId::new(file_id, items.ast_id(&it)) }\n+                    .intern(db);\n+                Some((name, def.into()))\n             }\n             ast::ImplItem::ConstDef(it) => {\n-                let def = ConstLoc {\n-                    container: AssocContainerId::ImplId(id),\n-                    ast_id: AstId::new(file_id, items.ast_id(&it)),\n-                }\n-                .intern(db);\n-                Some(def.into())\n+                let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n+                let def = ConstLoc { container, ast_id: AstId::new(file_id, items.ast_id(&it)) }\n+                    .intern(db);\n+                Some((name, def.into()))\n             }\n             ast::ImplItem::TypeAliasDef(it) => {\n-                let def = TypeAliasLoc {\n-                    container: AssocContainerId::ImplId(id),\n-                    ast_id: AstId::new(file_id, items.ast_id(&it)),\n-                }\n-                .intern(db);\n-                Some(def.into())\n+                let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n+                let def =\n+                    TypeAliasLoc { container, ast_id: AstId::new(file_id, items.ast_id(&it)) }\n+                        .intern(db);\n+                Some((name, def.into()))\n             }\n         })\n         .collect()"}, {"sha": "9d32cbc7a6b7d60909ffc495cca289452a3176d0", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/57f285d0ebd5291e74cc52cd991ac7bdc3ec8630/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f285d0ebd5291e74cc52cd991ac7bdc3ec8630/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=57f285d0ebd5291e74cc52cd991ac7bdc3ec8630", "patch": "@@ -2055,7 +2055,7 @@ fn test<I: Iterator<Item: Iterator<Item = u32>>>() {\n #[test]\n fn proc_macro_server_types() {\n     assert_snapshot!(\n-        infer_with_mismatches(r#\"\n+        infer(r#\"\n macro_rules! with_api {\n     ($S:ident, $self:ident, $m:ident) => {\n         $m! {\n@@ -2069,9 +2069,9 @@ macro_rules! with_api {\n }\n macro_rules! associated_item {\n     (type TokenStream) =>\n-        (type TokenStream: 'static + Clone;);\n+        (type TokenStream: 'static;);\n     (type Group) =>\n-        (type Group: 'static + Clone;);\n+        (type Group: 'static;);\n     ($($item:tt)*) => ($($item)*;)\n }\n macro_rules! declare_server_traits {\n@@ -2083,39 +2083,41 @@ macro_rules! declare_server_traits {\n         }\n \n         $(pub trait $name: Types {\n-            $(associated_item!(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)?);)*\n+            $(associated_item!(fn $method($($arg: $arg_ty),*) $(-> $ret_ty)?);)*\n         })*\n \n         pub trait Server: Types $(+ $name)* {}\n         impl<S: Types $(+ $name)*> Server for S {}\n     }\n }\n+\n with_api!(Self, self_, declare_server_traits);\n-struct Group {}\n-struct TokenStream {}\n+struct G {}\n+struct T {}\n struct Rustc;\n impl Types for Rustc {\n-    type TokenStream = TokenStream;\n-    type Group = Group;\n+    type TokenStream = T;\n+    type Group = G;\n }\n+\n fn make<T>() -> T { loop {} }\n impl TokenStream for Rustc {\n     fn new() -> Self::TokenStream {\n         let group: Self::Group = make();\n         make()\n     }\n }\n-\"#, true),\n+\"#),\n         @r###\"\n-    1115..1126 '{ loop {} }': T\n-    1117..1124 'loop {}': !\n-    1122..1124 '{}': ()\n-    1190..1253 '{     ...     }': {unknown}\n-    1204..1209 'group': {unknown}\n-    1225..1229 'make': fn make<{unknown}>() -> {unknown}\n-    1225..1231 'make()': {unknown}\n-    1241..1245 'make': fn make<{unknown}>() -> {unknown}\n-    1241..1247 'make()': {unknown}\n+    1062..1073 '{ loop {} }': T\n+    1064..1071 'loop {}': !\n+    1069..1071 '{}': ()\n+    1137..1200 '{     ...     }': T\n+    1151..1156 'group': G\n+    1172..1176 'make': fn make<G>() -> G\n+    1172..1178 'make()': G\n+    1188..1192 'make': fn make<T>() -> T\n+    1188..1194 'make()': T\n     \"###\n     );\n }"}]}