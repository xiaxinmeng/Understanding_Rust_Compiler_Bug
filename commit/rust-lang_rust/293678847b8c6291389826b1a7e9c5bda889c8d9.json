{"sha": "293678847b8c6291389826b1a7e9c5bda889c8d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5MzY3ODg0N2I4YzYyOTEzODk4MjZiMWE3ZTljNWJkYTg4OWM4ZDk=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-01-17T02:04:48Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-01-17T02:04:48Z"}, "message": "Convert a bunch of material on items, statements, expressions and typestates.", "tree": {"sha": "de8f9f94de40165407cb76eb71e07d7aca432b1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de8f9f94de40165407cb76eb71e07d7aca432b1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/293678847b8c6291389826b1a7e9c5bda889c8d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/293678847b8c6291389826b1a7e9c5bda889c8d9", "html_url": "https://github.com/rust-lang/rust/commit/293678847b8c6291389826b1a7e9c5bda889c8d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/293678847b8c6291389826b1a7e9c5bda889c8d9/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "236b304f19dab117c916fc7888c97fc0012829a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/236b304f19dab117c916fc7888c97fc0012829a8", "html_url": "https://github.com/rust-lang/rust/commit/236b304f19dab117c916fc7888c97fc0012829a8"}], "stats": {"total": 1218, "additions": 1174, "deletions": 44}, "files": [{"sha": "e6d9a162ca803f2a7f6b42989e50e8a457892be0", "filename": "doc/rust.md", "status": "modified", "additions": 1174, "deletions": 44, "changes": 1218, "blob_url": "https://github.com/rust-lang/rust/blob/293678847b8c6291389826b1a7e9c5bda889c8d9/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/293678847b8c6291389826b1a7e9c5bda889c8d9/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=293678847b8c6291389826b1a7e9c5bda889c8d9", "patch": "@@ -34,9 +34,9 @@ Rust is a work in progress. The language continues to evolve as the design\n shifts and is fleshed out in working code. Certain parts work, certain parts\n do not, certain parts will be removed or changed.\n \n-This manual is a snapshot written in the present tense. All features\n-described exist in working code, but some are quite primitive or remain to\n-be further modified by planned work. Some may be temporary. It is a\n+This manual is a snapshot written in the present tense. All features described\n+exist in working code unless otherwise noted, but some are quite primitive or\n+remain to be further modified by planned work. Some may be temporary. It is a\n *draft*, and we ask that you not take anything you read here as final.\n \n If you have suggestions to make, please try to focus them on *reductions* to\n@@ -82,11 +82,11 @@ Where:\n \n This EBNF dialect should hopefully be familiar to many readers.\n \n-The grammar for Rust given in this document is extracted and verified as\n-LL(1) by an automated grammar-analysis tool, and further tested against the\n-Rust sources. The generated parser is currently *not* the one used by the\n-Rust compiler itself, but in the future we hope to relate the two together\n-more precisely. As of this writing they are only related by testing against\n+The grammar for Rust given in this document is extracted and verified as LL(1)\n+by an automated grammar-analysis tool, and further tested against the Rust\n+sources. The generated parser is currently *not* the one used by the Rust\n+compiler itself, but in the future we hope to relate the two together more\n+precisely. As of this writing they are only related by testing against\n existing source code.\n \n ## Unicode productions\n@@ -99,13 +99,14 @@ Productions](#special-unicode-productions).\n \n ## String table productions\n \n-Some rules in the grammar -- notably [operators](#operators),\n-[keywords](#keywords) and [reserved words](#reserved-words) -- are given in a\n-simplified form: as a listing of a table of unquoted, printable\n-whitespace-separated strings. These cases form a subset of the rules regarding\n-the [token](#tokens) rule, and are assumed to be the result of a\n-lexical-analysis phase feeding the parser, driven by a DFA, operating over the\n-disjunction of all such string table entries.\n+Some rules in the grammar -- notably [unary\n+operators](#unary-operator-expressions), [binary\n+operators](#binary-operator-expressions), [keywords](#keywords) and [reserved\n+words](#reserved-words) -- are given in a simplified form: as a listing of a\n+table of unquoted, printable whitespace-separated strings. These cases form a\n+subset of the rules regarding the [token](#tokens) rule, and are assumed to be\n+the result of a lexical-analysis phase feeding the parser, driven by a DFA,\n+operating over the disjunction of all such string table entries.\n \n When such a string enclosed in double-quotes (`\"`) occurs inside the\n grammar, it is an implicit reference to a single member of such a string table\n@@ -189,7 +190,7 @@ with any other legal whitespace element, such as a single space character.\n \n ~~~~~~~~ {.ebnf .gram}\n simple_token : keyword | reserved | unop | binop ; \n-token : simple_token | ident | immediate | symbol | whitespace token ;\n+token : simple_token | ident | literal | symbol | whitespace token ;\n ~~~~~~~~\n \n Tokens are primitive productions in the grammar defined by regular\n@@ -244,16 +245,16 @@ class trait\n Any of these may have special meaning in future versions of the language, do\n are excluded from the `ident` rule.\n \n-### Immediates\n+### Literals\n \n-Immediates are a subset of all possible literals: those that are defined as\n-single tokens, rather than sequences of tokens.\n-\n-An immediate is a form of [constant expression](#constant-expression), so is\n-evaluated (primarily) at compile time.\n+A literal is an expression consisting of a single token, rather than a\n+sequence of tokens, that immediately and directly denotes the value it\n+evaluates to, rather than referring to it by name or some other evaluation\n+rule. A literal is a form of [constant expression](#constant-expression), so\n+is evaluated (primarily) at compile time.\n \n ~~~~~~~~ {.ebnf .gram}\n-immediate : string_lit | char_lit | num_lit ;\n+literal : string_lit | char_lit | num_lit ;\n ~~~~~~~~\n \n #### Character and string literals\n@@ -406,7 +407,8 @@ symbol : \"::\" \"->\"\n Symbols are a general class of printable [token](#tokens) that play structural\n roles in a variety of grammar productions. They are catalogued here for\n completeness as the set of remaining miscellaneous printable token that do not\n-otherwise appear as [operators](#operators), [keywords](#keywords) or [reserved\n+otherwise appear as [unary operators](#unary-operator-expressions), [binary\n+operators](#binary-operator-expressions), [keywords](#keywords) or [reserved\n words](#reserved-words).\n \n \n@@ -621,15 +623,37 @@ items.\n ### Modules\n \n ~~~~~~~~ {.ebnf .gram}\n-mod_item : \"mod\" '{' mod '}' ;\n+mod_item : \"mod\" ident '{' mod '}' ;\n mod : [ view_item | item ] * ;\n ~~~~~~~~\n \n-A module is a kind of item that contains zero or more [view\n-items](#view-items) and zero or more sub-[items](#items). The view items\n-manage the visibility of the items defined within the module, as well as the\n-visibility of names from outside the module when referenced from inside the\n-module.\n+A module is a container for zero or more [view items](#view-items) and zero or\n+more [items](#items). The view items manage the visibility of the items\n+defined within the module, as well as the visibility of names from outside the\n+module when referenced from inside the module.\n+\n+A _module item_ is a module, surrounded in braces, named, and prefixed with\n+the keyword `mod`. A module item introduces a new, named module into the tree\n+of modules making up a crate. Modules can nest arbitrarily.\n+\n+An example of a module:\n+\n+~~~~~~~~\n+mod math {\n+    type complex = (f64,f64);\n+    fn sin(f64) -> f64 {\n+        ...\n+    }\n+    fn cos(f64) -> f64 {\n+        ...\n+    }\n+    fn tan(f64) -> f64 {\n+        ...\n+    }\n+    ...\n+}\n+~~~~~~~~\n+\n \n #### View items\n \n@@ -650,7 +674,7 @@ view item:\n ~~~~~~~~ {.ebnf .gram}\n use_decl : \"use\" ident [ '(' link_attrs ')' ] ? ;\n link_attrs : link_attr [ ',' link_attrs ] + ;\n-link_attr : ident '=' immediate ;\n+link_attr : ident '=' literal ;\n ~~~~~~~~\n \n A _use declaration_ specifies a dependency on an external crate. The external\n@@ -781,11 +805,220 @@ mod foo {\n \n \n ### Functions\n+\n+A _function item_ defines a sequence of [statements](#statements) and an\n+optional final [expression](#expressions) associated with a name and a set of\n+parameters. Functions are declared with the keyword `fn`. Functions declare a\n+set of *input [slots](#slots)* as parameters, through which the caller passes\n+arguments into the function, and an *output [slot](#slots)* through which the\n+function passes results back to the caller.\n+\n+A function may also be copied into a first class *value*, in which case the\n+value has the corresponding [*function type*](#function-types), and can be\n+used otherwise exactly as a function item (with a minor additional cost of\n+calling the function, as such a call is indirect).\n+\n+Every control path in a function logically ends with a `ret` expression or a\n+diverging expression. If the outermost block of a function has a\n+value-producing expression in its final-expression position, that expression\n+is interpreted as an implicit `ret` expression applied to the\n+final-expression.\n+\n+An example of a function:\n+\n+~~~~\n+fn add(x: int, y: int) -> int {\n+    ret x + y;\n+}\n+~~~~\n+\n+#### Diverging functions\n+\n+A special kind of function can be declared with a `!` character where the\n+output slot type would normally be. For example:\n+\n+~~~~\n+fn my_err(s: str) -> ! {\n+    log(info, s);\n+    fail;\n+}\n+~~~~\n+\n+We call such functions \"diverging\" because they never return a value to the\n+caller. Every control path in a diverging function must end with a\n+[`fail`](#fail-expressions) or a call to another diverging function on every\n+control path. The `!` annotation does *not* denote a type. Rather, the result\n+type of a diverging function is a special type called $\\bot$ (\"bottom\") that\n+unifies with any type. Rust has no syntax for $\\bot$.\n+\n+It might be necessary to declare a diverging function because as mentioned\n+previously, the typechecker checks that every control path in a function ends\n+with a [`ret`](#return-expressions) or diverging expression. So, if `my_err`\n+were declared without the `!` annotation, the following code would not\n+typecheck:\n+\n+~~~~\n+fn f(i: int) -> int {\n+   if i == 42 {\n+     ret 42;\n+   }\n+   else {\n+     my_err(\"Bad number!\");\n+   }\n+}\n+~~~~\n+\n+The typechecker would complain that `f` doesn't return a value in the\n+`else` branch. Adding the `!` annotation on `my_err` would\n+express that `f` requires no explicit `ret`, as if it returns\n+control to the caller, it returns a value (true because it never returns\n+control).\n+\n+#### Predicate functions\n+\n+Any pure boolean function is called a *predicate function*, and may be used in\n+a [constraint](#constraints), as part of the static [typestate\n+system](#typestate-system). A predicate declaration is identical to a function\n+declaration, except that it is declared with the additional keyword `pure`. In\n+addition, the typechecker checks the body of a predicate with a restricted set\n+of typechecking rules. A predicate\n+\n+* may not contain an assignment or self-call expression; and\n+* may only call other predicates, not general functions.\n+\n+An example of a predicate:\n+\n+~~~~\n+pure fn lt_42(x: int) -> bool {\n+    ret (x < 42);\n+}\n+~~~~\n+\n+A non-boolean function may also be declared with `pure fn`. This allows\n+predicates to call non-boolean functions as long as they are pure. For example:\n+\n+~~~~\n+pure fn pure_length<@T>(ls: list<T>) -> uint { /* ... */ }\n+\n+pure fn nonempty_list<@T>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n+~~~~\n+\n+In this example, `nonempty_list` is a predicate---it can be used in a\n+typestate constraint---but the auxiliary function `pure_length`@ is\n+not.\n+\n+*ToDo:* should actually define referential transparency.\n+\n+The effect checking rules previously enumerated are a restricted set of\n+typechecking rules meant to approximate the universe of observably\n+referentially transparent Rust procedures conservatively. Sometimes, these\n+rules are *too* restrictive. Rust allows programmers to violate these rules by\n+writing predicates that the compiler cannot prove to be referentially\n+transparent, using an escape-hatch feature called \"unchecked blocks\". When\n+writing code that uses unchecked blocks, programmers should always be aware\n+that they have an obligation to show that the code *behaves* referentially\n+transparently at all times, even if the compiler cannot *prove* automatically\n+that the code is referentially transparent. In the presence of unchecked\n+blocks, the compiler provides no static guarantee that the code will behave as\n+expected at runtime. Rather, the programmer has an independent obligation to\n+verify the semantics of the predicates they write.\n+\n+*ToDo:* last two sentences are vague.\n+\n+An example of a predicate that uses an unchecked block:\n+\n+~~~~\n+fn pure_foldl<@T, @U>(ls: list<T>, u: U, f: block(&T, &U) -> U) -> U {\n+    alt ls {\n+      nil. { u }\n+      cons(hd, tl) { f(hd, pure_foldl(*tl, f(hd, u), f)) }\n+    }\n+}\n+\n+pure fn pure_length<@T>(ls: list<T>) -> uint {\n+    fn count<T>(_t: T, u: uint) -> uint { u + 1u }\n+    unchecked {\n+        pure_foldl(ls, 0u, count)\n+    }\n+}\n+~~~~\n+\n+Despite its name, `pure_foldl` is a `fn`, not a `pure fn`, because there is no\n+way in Rust to specify that the higher-order function argument `f` is a pure\n+function. So, to use `foldl` in a pure list length function that a predicate\n+could then use, we must use an `unchecked` block wrapped around the call to\n+`pure_foldl` in the definition of `pure_length`.\n+\n+\n ### Type definitions\n+\n+A _type definition_ defines a new name for an existing [type](#types). Type\n+definitions are declared with the keyword `type`. Every value has a single,\n+specific type; the type-specified aspects of a value include:\n+\n+* Whether the value is composed of sub-values or is indivisible.\n+* Whether the value represents textual or numerical information.\n+* Whether the value represents integral or floating-point information.\n+* The sequence of memory operations required to access the value.\n+* The *kind* of the type (pinned, unique or shared).\n+\n+For example, the type `{x: u8, y: u8@`} defines the set of immutable values\n+that are composite records, each containing two unsigned 8-bit integers\n+accessed through the components `x` and `y`, and laid out in memory with the\n+`x` component preceding the `y` component.\n+\n ### Enumerations\n+\n+An _enumeration item_ simultaneously declares a new nominal [enumerated\n+type](#enumerated-type) as well as a set of *constructors* that can be used to\n+create or pattern-match values of the corresponding enumerated type.\n+\n+The constructors of an `enum` type may be recursive: that is, each constructor\n+may take an argument that refers, directly or indirectly, to the enumerated\n+type the constructor is a member of. Such recursion has restrictions:\n+\n+* Recursive types can be introduced only through `enum` constructors.\n+* A recursive `enum` item must have at least one non-recursive constructor (in\n+  order to give the recursion a basis case).\n+* The recursive argument of recursive `enum` constructors must be [*box*\n+  values](#box-types) (in order to bound the in-memory size of the\n+  constructor).\n+* Recursive type definitions can cross module boundaries, but not module\n+  *visibility* boundaries, nor crate boundaries (in order to simplify the\n+  module system).\n+\n+\n+An example of an `enum` item and its use:\n+\n+~~~~\n+enum animal {\n+  dog;\n+  cat;\n+}\n+\n+let a: animal = dog;\n+a = cat;\n+~~~~\n+\n+An example of a *recursive* `enum` item and its use:\n+\n+~~~~\n+enum list<T> {\n+  nil;\n+  cons(T, @list<T>);\n+}\n+\n+let a: list<int> = cons(7, @cons(13, @nil));\n+~~~~\n+\n ### Resources\n+*TODO*.\n+\n ### Interfaces\n+*TODO*.\n+\n ### Implementations\n+*TODO*.\n \n \n ## Attributes\n@@ -851,23 +1084,119 @@ Other attributes may be added or removed during development of the language.\n \n # Statements and expressions\n \n-## Call expressions\n+Rust is _primarily_ an expression language. This means that most forms of\n+value-producing or effect-causing evaluation are directed by the uniform\n+syntax category of _expressions_. Each kind of expression can typically _nest_\n+within each other kind of expression, and rules for evaluation of expressions\n+involve specifying both the value produced by the expression and the order in\n+which its sub-expressions are themselves evaluated.\n \n-~~~~~~~~ {.abnf .gram}\n-expr_list : [ expr [ ',' expr ]* ] ? ;\n-paren_expr_list : '(' expr_list ')' ;\n-call_expr : expr paren_expr_list ;\n-~~~~~~~~\n+In contrast, statements in Rust serve _mostly_ to contain and explicitly\n+sequence expression evaluation.\n+\n+## Statements\n+\n+A _statement_ is a component of a block, which is in turn a component of an\n+outer [block-expression](#block-expressions) or [function](#functions). When a\n+function is spawned into a [task](#tasks), the task *executes* statements in\n+an order determined by the body of the enclosing function. Each statement\n+causes the task to perform certain actions.\n+\n+Rust has two kinds of statement: [declarations](#declarations) and\n+[expressions](#expressions).\n+\n+A declaration serves to introduce a *name* that can be used in the block\n+*scope* enclosing the statement: all statements before and after the\n+name, from the previous opening curly-brace (`{`) up to the next closing\n+curly-brace (`}`).\n+\n+An expression serves the dual roles of causing side effects and producing a\n+*value*. Expressions are said to *evaluate to* a value, and the side effects\n+are caused during *evaluation*. Many expressions contain sub-expressions as\n+operands; the definition of each kind of expression dictates whether or not,\n+and in which order, it will evaluate its sub-expressions, and how the\n+expression's value derives from the value of its sub-expressions.\n+\n+In this way, the structure of execution -- both the overall sequence of\n+observable side effects and the final produced value -- is dictated by the\n+structure of expressions. Blocks themselves are expressions, so the nesting\n+sequence of block, statement, expression, and block can repeatedly nest to an\n+arbitrary depth.\n+\n+### Declaration statements\n+\n+A _declaration statement_ is one that introduces a *name* into the\n+enclosing statement block. The declared name may denote a new slot or a new\n+item.\n+\n+#### Item declarations\n \n-## Operators\n+An _item declaration statement_ has a syntactic form identical to an\n+[item](#items) declaration within a module. Declaring an item -- a function,\n+enumeration, type, resource, interface, implementation or module -- locally\n+within a statement block is simply a way of restricting its scope to a narrow\n+region containing all of its uses; it is otherwise identical in meaning to\n+declaring the item outside the statement block.\n \n-### Unary operators\n+Note: there is no implicit capture of the function's dynamic environment when\n+declaring a function-local item.\n+\n+\n+#### Slot declarations\n+\n+A _slot declaration_ has one one of two forms:\n+\n+* `let` `pattern` `optional-init`;\n+* `let` `pattern` : `type` `optional-init`;\n+\n+Where `type` is a type expression, `pattern` is an irrefutable pattern (often\n+just the name of a single slot), and `optional-init` is an optional\n+initializer. If present, the initializer consists of either an assignment\n+operator (`=`) or move operator (`<-`), followed by an expression.\n+\n+Both forms introduce a new slot into the enclosing block scope. The new slot\n+is visible from the point of declaration until the end of the enclosing block\n+scope.\n+\n+The former form, with no type annotation, causes the compiler to infer the\n+static type of the slot through unification with the types of values assigned\n+to the slot in the remaining code in the block scope. Inference only occurs on\n+frame-local slots, not argument slots. Function and object signatures must\n+always declared types for all argument slots.\n+\n+\n+### Expression statements\n+\n+An _expression statement_ is one that evaluates an [expression](#expressions)\n+and drops its result. The purpose of an expression statement is often to cause\n+the side effects of the expression's evaluation.\n+\n+## Expressions\n+\n+### Literal expressions\n+\n+*TODO*.\n+\n+### Tuple expressions\n+\n+*TODO*.\n+\n+### Record expressions\n+\n+*TODO*.\n+\n+### Vector expressions\n+\n+*TODO*.\n+\n+\n+### Unary operator expressions\n \n ~~~~~~~~ {.unop}\n + - * ! @ ~\n ~~~~~~~~\n \n-### Binary operators\n+### Binary operator expressions\n \n ~~~~~~~~ {.binop}\n .\n@@ -876,11 +1205,604 @@ call_expr : expr paren_expr_list ;\n || &&\n < <= == >= >\n << >> >>>\n+as\n <- <-> = += -= *= /= %= &= |= ^= <<= >>= >>>=\n ~~~~~~~~\n \n+#### Type cast expressions\n+\n+A type cast expression is denoted with the binary operator `as`.\n+\n+Executing an `as` expression casts the value on the left-hand side to the type\n+on the right-hand side.\n+\n+A numeric value can be cast to any numeric type.  A native pointer value can\n+be cast to or from any integral type or native pointer type.  Any other cast\n+is unsupported and will fail to compile.\n+\n+An example of an `as` expression:\n+\n+~~~~\n+fn avg(v: [float]) -> float {\n+  let sum: float = sum(v);\n+  let sz: float = std::vec::len(v) as float;\n+  ret sum / sz;\n+}\n+~~~~\n+\n+A cast is a *trivial cast* iff the type of the casted expression and the\n+target type are identical after replacing all occurences of `int`, `uint`,\n+`float` with their machine type equivalents of the target architecture in both\n+types.\n+\n+\n+#### Binary move expressions\n+\n+A _binary move experssion_ consists of an *lval* followed by a left-pointing\n+arrow (`<-`) and an *rval* expression.\n+\n+Evaluating a move expression causes, as a side effect, the *rval* to be\n+*moved* into the *lval*. If the *rval* was itself an *lval*, it must be a\n+local variable, as it will be de-initialized in the process.\n+\n+Evaluating a move expression does not effect reference counts nor does it\n+cause a deep copy of any unique structure pointed-to by the moved\n+*rval*. Instead, the move expression represents an indivisible *transfer of\n+ownership* from the right-hand-side to the left-hand-side of the\n+expression. No allocation or destruction is entailed.\n+\n+An example of three different move expressions:\n+\n+~~~~~~~~\n+x <- a;\n+x[i] <- b;\n+x.y <- c;\n+~~~~~~~~\n+\n+#### Swap expressions\n+\n+A _swap experssion_ consists of an *lval* followed by a bi-directional arrow\n+(`<->`) and another *lval* expression.\n+\n+Evaluating a swap expression causes, as a side effect, the vales held in the\n+left-hand-side and right-hand-side *lvals* to be exchanged indivisibly.\n+\n+Evaluating a move expression does not effect reference counts nor does it\n+cause a deep copy of any unique structure pointed-to by the moved\n+*rval*. Instead, the move expression represents an indivisible *exchange of\n+ownership* between the right-hand-side to the left-hand-side of the\n+expression. No allocation or destruction is entailed.\n+\n+An example of three different swap expressions:\n+\n+~~~~~~~~\n+x <-> a;\n+x[i] <-> b[i];\n+x.y <-> a.b;\n+~~~~~~~~\n+\n+\n+#### Assignment expressions\n+\n+An _assignment expression_ consists of an *lval* expression followed by an\n+equals-sign (`=`) and an *rval* expression.\n+\n+Evaluating an assignment expression is equivalent to evaluating a [binary move\n+expression](#binary-move-expressions) applied to a [unary copy\n+expression](unary-copy-expressions). For example, the following two\n+expressions have the same effect:\n+\n+~~~~\n+x = y\n+x <- copy y\n+~~~~\n+\n+The former is just more terse and familiar.\n+\n+### Unary copy expressions\n+\n+A _unary copy expression_ consists of the unary `copy` operator applied to\n+some argument expression.\n+\n+Evaluating a copy expression first evaluates the argument expression, then\n+performs a copy of the resulting value, allocating any memory necessary to\n+hold the new copy.\n+\n+[Shared boxes](#shared-box-types) (type `@`) are, as usual, shallow-copied, as\n+they may be cyclic. [Unique boxes](unique-box-types), [vectors](#vector-types)\n+and similar unique types are deep-copied.\n+\n+Since the binary [assignment operator](#assignment-operator) `=` performs a\n+copy implicitly, the unary copy operator is typically only used to cause an\n+argument to a function should be copied, and the copy passed by-value.\n+\n+An example of a copy expression:\n+\n+~~~~\n+fn mutate(vec: [mutable int]) {\n+   vec[0] = 10;\n+}\n+\n+let v = [mutable 1,2,3];\n+\n+mutate(copy v);   // Pass a copy\n+\n+assert v[0] == 1; // Original was not modified\n+~~~~\n+\n+### Unary move expressions\n+\n+*TODO*.\n+\n+\n+### Call expressions\n+\n+~~~~~~~~ {.abnf .gram}\n+expr_list : [ expr [ ',' expr ]* ] ? ;\n+paren_expr_list : '(' expr_list ')' ;\n+call_expr : expr paren_expr_list ;\n+~~~~~~~~\n+\n+A _call expression_ invokes a function, providing a tuple of input slots\n+and a reference slot to serve as the function's output, bound to the\n+`lval` on the right hand side of the call. If the function eventually\n+returns, then the expression completes.\n+\n+A call expression statically requires that the precondition declared in the\n+callee's signature is satisfied by the expression prestate. In this way,\n+typestates propagate through function boundaries. See [Ref.Typestate](#ref.typestate).\n+\n+An example of a call expression:\n+\n+~~~~\n+let x: int = add(1, 2);\n+~~~~\n+\n+\n+### Bind expressions\n+\n+A _bind expression_ constructs a new function from an existing function.^[The\n+`bind` expression is analogous to the `bind` expression in the Sather\n+language.] The new function has zero or more of its arguments *bound* into a\n+new, hidden boxed tuple that holds the bindings. For each concrete argument\n+passed in the `bind` expression, the corresponding parameter in the existing\n+function is *omitted* as a parameter of the new function. For each argument\n+passed the placeholder symbol `_` in the `bind` expression, the corresponding\n+parameter of the existing function is *retained* as a parameter of the new\n+function.\n+\n+Any subsequent invocation of the new function with residual arguments causes\n+invocation of the existing function with the combination of bound arguments\n+and residual arguments that was specified during the binding.\n+\n+An example of a `bind` expression:\n+\n+~~~~\n+fn add(x: int, y: int) -> int {\n+    ret x + y;\n+}\n+type single_param_fn = fn(int) -> int;\n+\n+let add4: single_param_fn = bind add(4, _);\n+\n+let add5: single_param_fn = bind add(_, 5);\n+\n+assert (add(4,5) == add4(5));\n+assert (add(4,5) == add5(4));\n+\n+~~~~\n+\n+A `bind` expression generally stores a copy of the bound arguments in the\n+hidden, boxed tuple, owned by the resulting first-class function. For each\n+bound slot in the bound function's signature, space is allocated in the hidden\n+tuple and populated with a copy of the bound value.\n+\n+A `bind` expression is an alternative way of constructing a shared function\n+closure; the [`fn@` expression](#shared-function-expression) form is another\n+way.\n+\n+### Shared function expressions\n+\n+*TODO*.\n+\n+### Unique function expressions\n+\n+*TODO*.\n+\n+### While expressions\n+\n+A `while` expression is a loop construct. A `while` loop may be either a\n+simple `while` or a `do`-`while` loop.\n+\n+In the case of a simple `while`, the loop begins by evaluating the boolean\n+loop conditional expression. If the loop conditional expression evaluates to\n+`true`, the loop body block executes and control returns to the loop\n+conditional expression. If the loop conditional expression evaluates to\n+`false`, the `while` expression completes.\n+\n+In the case of a `do`-`while`, the loop begins with an execution of the loop\n+body. After the loop body executes, it evaluates the loop conditional\n+expression. If it evaluates to `true`, control returns to the beginning of the\n+loop body. If it evaluates to `false`, control exits the loop.\n+\n+An example of a simple `while` expression:\n+\n+~~~~\n+while (i < 10) {\n+    print(\"hello\\n\");\n+    i = i + 1;\n+}\n+~~~~\n+\n+An example of a `do`-`while` expression:\n+\n+~~~~\n+do {\n+    print(\"hello\\n\");\n+    i = i + 1;\n+} while (i < 10);\n+~~~~\n+\n+\n+### Break expressions\n+\n+Executing a `break` expression immediately terminates the innermost loop\n+enclosing it. It is only permitted in the body of a loop.\n+\n+### Continue expressions\n+\n+Evaluating a `cont` expression immediately terminates the current iteration of\n+the innermost loop enclosing it, returning control to the loop *head*. In the\n+case of a `while` loop, the head is the conditional expression controlling the\n+loop. In the case of a `for` loop, the head is the vector-element increment\n+controlling the loop.\n+\n+A `cont` expression is only permitted in the body of a loop.\n+\n+\n+### For expressions\n+\n+A _for loop_ is controlled by a vector or string. The for loop bounds-checks\n+the underlying sequence *once* when initiating the loop, then repeatedly\n+executes the loop body with the loop variable referencing the successive\n+elements of the underlying sequence, one iteration per sequence element.\n+\n+An example a for loop:\n+\n+~~~~\n+let v: [foo] = [a, b, c];\n+\n+for e: foo in v {\n+    bar(e);\n+}\n+~~~~\n+\n+\n+### If expressions\n+\n+An `if` expression is a conditional branch in program control. The form of\n+an `if` expression is a condition expression, followed by a consequent\n+block, any number of `else if` conditions and blocks, and an optional\n+trailing `else` block. The condition expressions must have type\n+`bool`. If a condition expression evaluates to `true`, the\n+consequent block is executed and any subsequent `else if` or `else`\n+block is skipped. If a condition expression evaluates to `false`, the\n+consequent block is skipped and any subsequent `else if` condition is\n+evaluated. If all `if` and `else if` conditions evaluate to `false`\n+then any `else` block is executed.\n+\n+\n+### Alternative expressions\n+\n+An `alt` expression branches on a *pattern*. The exact form of matching that\n+occurs depends on the pattern. Patterns consist of some combination of\n+literals, destructured tag constructors, records and tuples, variable binding\n+specifications and placeholders (`_`). An `alt` expression has a *head\n+expression*, which is the value to compare to the patterns. The type of the\n+patterns must equal the type of the head expression.\n+\n+To execute an `alt` expression, first the head expression is evaluated, then\n+its value is sequentially compared to the patterns in the arms until a match\n+is found. The first arm with a matching pattern is chosen as the branch target\n+of the `alt`, any variables bound by the pattern are assigned to local slots\n+in the arm's block, and control enters the block.\n+\n+An example of an `alt` expression:\n+\n+\n+~~~~\n+tag list<X> { nil; cons(X, @list<X>); }\n+\n+let x: list<int> = cons(10, @cons(11, @nil));\n+\n+alt x {\n+    cons(a, @cons(b, _)) {\n+        process_pair(a,b);\n+    }\n+    cons(10, _) {\n+        process_ten();\n+    }\n+    nil {\n+        ret;\n+    }\n+    _ {\n+        fail;\n+    }\n+}\n+~~~~\n+\n+Records can also be pattern-matched and their fields bound to variables.\n+When matching fields of a record, the fields being matched are specified\n+first, then a placeholder (`_`) represents the remaining fields.\n+\n+~~~~\n+fn main() {\n+    let r = {\n+        player: \"ralph\",\n+        stats: load_stats(),\n+        options: {\n+            choose: true,\n+            size: \"small\"\n+        }\n+    };\n+\n+    alt r {\n+      {options: {choose: true, _}, _} {\n+        choose_player(r)\n+      }\n+      {player: p, options: {size: \"small\", _}, _} {\n+        log(info, p + \" is small\");\n+      }\n+      _ {\n+        next_player();\n+      }\n+    }\n+}\n+~~~~\n+\n+Multiple alternative patterns may be joined with the `|` operator.  A\n+range of values may be specified with `to`.  For example:\n+\n+~~~~\n+let message = alt x {\n+  0 | 1  { \"not many\" }\n+  2 to 9 { \"a few\" }\n+  _      { \"lots\" }\n+}\n+~~~~\n+\n+Finally, alt patterns can accept *pattern guards* to further refine the\n+criteria for matching a case. Pattern guards appear after the pattern and\n+consist of a bool-typed expression following the `if` keyword. A pattern\n+guard may refer to the variables bound within the pattern they follow.\n+\n+~~~~\n+let message = alt maybe_digit {\n+  some(x) if x < 10 { process_digit(x) }\n+  some(x) { process_other(x) }\n+}\n+~~~~\n+\n+\n+### Fail expressions\n+\n+Evaluating a `fail` expression causes a task to enter the *failing* state. In\n+the *failing* state, a task unwinds its stack, destroying all frames and\n+freeing all resources until it reaches its entry frame, at which point it\n+halts execution in the *dead* state.\n+\n+### Note expressions\n+\n+**Note: Note expressions are not yet supported by the compiler.**\n+\n+A `note` expression has no effect during normal execution. The purpose of a\n+`note` expression is to provide additional diagnostic information to the\n+logging subsystem during task failure. See [log\n+expressions](#log-expressions). Using `note` expressions, normal diagnostic\n+logging can be kept relatively sparse, while still providing verbose\n+diagnostic \"back-traces\" when a task fails.\n+\n+When a task is failing, control frames *unwind* from the innermost frame to\n+the outermost, and from the innermost lexical block within an unwinding frame\n+to the outermost. When unwinding a lexical block, the runtime processes all\n+the `note` expressions in the block sequentially, from the first expression of\n+the block to the last.  During processing, a `note` expression has equivalent\n+meaning to a `log` expression: it causes the runtime to append the argument of\n+the `note` to the internal logging diagnostic buffer.\n+\n+An example of a `note` expression:\n+\n+~~~~\n+fn read_file_lines(path: str) -> [str] {\n+    note path;\n+    let r: [str];\n+    let f: file = open_read(path);\n+    lines(f) {|s|\n+        r += [s];\n+    }\n+    ret r;\n+}\n+~~~~\n+\n+In this example, if the task fails while attempting to open or read a file,\n+the runtime will log the path name that was being read. If the function\n+completes normally, the runtime will not log the path.\n+\n+A value that is marked by a `note` expression is *not* copied aside\n+when control passes through the `note`. In other words, if a `note`\n+expression notes a particular `lval`, and code after the `note`\n+mutates that slot, and then a subsequent failure occurs, the *mutated*\n+value will be logged during unwinding, *not* the original value that was\n+denoted by the `lval` at the moment control passed through the `note`\n+expression.\n+\n+### Return expressions\n+\n+Return expressions are denoted with the keyword `ret`. Evaluating a `ret`\n+expression^[footnote{A `ret` expression is analogous to a `return` expression\n+in the C family.] moves its argument into the output slot of the current\n+function, destroys the current function activation frame, and transfers\n+control to the caller frame.\n+\n+An example of a `ret` expression:\n+\n+~~~~\n+fn max(a: int, b: int) -> int {\n+   if a > b {\n+      ret a;\n+   }\n+   ret b;\n+}\n+~~~~\n+\n+### Log expressions\n+\n+Evaluating a `log` expression may, depending on runtime configuration, cause a\n+value to be appended to an internal diagnostic logging buffer provided by the\n+runtime or emitted to a system console. Log expressions are enabled or\n+disabled dynamically at run-time on a per-task and per-item basis. See\n+[logging system](#logging-system).\n+\n+Each `log` expression must be provided with a *level* argument in\n+addition to the value to log. The logging level is a `u32` value, where\n+lower levels indicate more-urgent levels of logging. By default, the lowest\n+four logging levels (`0_u32 ... 3_u32`) are predefined as the constants\n+`error`, `warn`, `info` and `debug` in the `core` library.\n+\n+Additionally, the macros `#error`, `#warn`, `#info` and `#debug` are defined\n+in the default syntax-extension namespace. These expand into calls to the\n+logging facility composed with calls to the `#fmt` string formatting\n+syntax-extension.\n+\n+The following examples all produce the same output, logged at the `error`\n+logging level:\n+\n+~~~~\n+// Full version, logging a value.\n+log(core::error, \"file not found: \" + filename);\n+\n+// Log-level abbreviated, since core::* is imported by default.\n+log(error, \"file not found: \" + filename);\n+\n+// Formatting the message using a format-string and #fmt\n+log(error, #fmt(\"file not found: %s\", filename));\n+\n+// Using the #error macro, that expands to the previous call.\n+#error(\"file not found: %s\", filename);\n+~~~~\n+\n+A `log` expression is *not evaluated* when logging at the specified\n+logging-level, module or task is disabled at runtime. This makes inactive\n+`log` expressions very cheap; they should be used extensively in Rust\n+code, as diagnostic aids, as they add little overhead beyond a single\n+integer-compare and branch at runtime.\n+\n+Logging is presently implemented as a language built-in feature, as it makes\n+use of compiler-provided logic for allocating the associated per-module\n+logging-control structures visible to the runtime, and lazily evaluating\n+arguments. In the future, as more of the supporting compiler-provided logic is\n+moved into libraries, logging is likely to move to a component of the core\n+library. It is best to use the macro forms of logging (*#error*,\n+*#debug*, etc.) to minimize disruption to code using the logging facility\n+when it is changed.\n+\n+\n+### Check expressions\n+\n+A `check` expression connects dynamic assertions made at run-time to the\n+static [typestate system](#typestate-system). A `check` expression takes a\n+constraint to check at run-time. If the constraint holds at run-time, control\n+passes through the `check` and on to the next expression in the enclosing\n+block. If the condition fails to hold at run-time, the `check` expression\n+behaves as a `fail` expression.\n+\n+The typestate algorithm is built around `check` expressions, and in particular\n+the fact that control *will not pass* a check expression with a condition that\n+fails to hold. The typestate algorithm can therefore assume that the (static)\n+postcondition of a `check` expression includes the checked constraint\n+itself. From there, the typestate algorithm can perform dataflow calculations\n+on subsequent expressions, propagating [conditions](#conditions) forward and\n+statically comparing implied states and their specifications.\n+\n+~~~~~~~~\n+pure fn even(x: int) -> bool {\n+    ret x & 1 == 0;\n+}\n+\n+fn print_even(x: int) : even(x) {\n+    print(x);\n+}\n+\n+fn test() {\n+    let y: int = 8;\n+\n+    // Cannot call print_even(y) here.\n+\n+    check even(y);\n+\n+    // Can call print_even(y) here, since even(y) now holds.\n+    print_even(y);\n+}\n+~~~~~~~~\n+\n+### Prove expressions\n+\n+A `prove` expression has no run-time effect. Its purpose is to statically\n+check (and document) that its argument constraint holds at its expression\n+entry point. If its argument typestate does not hold, under the typestate\n+algorithm, the program containing it will fail to compile.\n+\n+### Claim expressions\n+\n+A `claim` expression is an unsafe variant on a `check` expression that is not\n+actually checked at runtime. Thus, using a `claim` implies a proof obligation\n+to ensure---without compiler assistance---that an assertion always holds.\n+\n+Setting a runtime flag can turn all `claim` expressions into `check`\n+expressions in a compiled Rust program, but the default is to not check the\n+assertion contained in a `claim`. The idea behind `claim` is that performance\n+profiling might identify a few bottlenecks in the code where actually checking\n+a given callee's predicate is too expensive; `claim` allows the code to\n+typecheck without removing the predicate check at every other call site.\n+\n+\n+\n+### If-Check expressions\n+\n+An `if check` expression combines a `if` expression and a `check`\n+expression in an indivisible unit that can be used to build more complex\n+conditional control-flow than the `check` expression affords.\n+\n+In fact, `if check` is a \"more primitive\" expression than `check`;\n+instances of the latter can be rewritten as instances of the former. The\n+following two examples are equivalent:\n+\n+Example using `check`:\n+\n+~~~~\n+check even(x);\n+print_even(x);\n+~~~~\n \n-## Syntax extensions\n+Equivalent example using `if check`:\n+\n+~~~~\n+if check even(x) {\n+    print_even(x);\n+} else {\n+    fail;\n+}\n+~~~~\n+\n+### Assert expressions\n+\n+An `assert` expression is similar to a `check` expression, except\n+the condition may be any boolean-typed expression, and the compiler makes no\n+use of the knowledge that the condition holds if the program continues to\n+execute after the `assert`.\n+\n+\n+### Syntax extension expressions\n \n ~~~~~~~~ {.abnf .gram}\n syntax_ext_expr : '#' ident paren_expr_list ? brace_match ? ;\n@@ -1125,6 +2047,9 @@ tuple of arguments.\n Enumerated types cannot be denoted *structurally* as types, but must be\n denoted by named reference to an [*enumeration* item](#enumerations).\n \n+### Box types\n+\n+*TODO*.\n \n ### Function types\n \n@@ -1135,7 +2060,7 @@ constraints](#input-constraints) and an output slot. See\n \n An example of a `fn` type:\n \n-~~~~\n+~~~~~~~~\n fn add(x: int, y: int) -> int {\n   ret x + y;\n }\n@@ -1145,12 +2070,217 @@ let int x = add(5,7);\n type binop = fn(int,int) -> int;\n let bo: binop = add;\n x = bo(5,7);\n-~~~~\n+~~~~~~~~\n \n \n \n ## Typestate system\n \n+\n+Rust programs have a static semantics that determine the types of values\n+produced by each expression, as well as the *predicates* that hold over\n+slots in the environment at each point in time during execution.\n+\n+The latter semantics -- the dataflow analysis of predicates holding over slots\n+-- is called the *typestate* system.\n+\n+### Points\n+\n+Control flows from statement to statement in a block, and through the\n+evaluation of each expression, from one sub-expression to another. This\n+sequential control flow is specified as a set of _points_, each of which\n+has a set of points before and after it in the implied control flow.\n+\n+For example, this code:\n+\n+~~~~~~~~\n+ s = \"hello, world\";\n+ print(s);\n+~~~~~~~~\n+\n+Consists of 2 statements, 3 expressions and 12 points:\n+\n+\n+* the point before the first statement\n+* the point before evaluating the static initializer `\"hello, world\"`\n+* the point after evaluating the static initializer `\"hello, world\"`\n+* the point after the first statement\n+* the point before the second statement\n+* the point before evaluating the function value `print`\n+* the point after evaluating the function value `print`\n+* the point before evaluating the arguments to `print`\n+* the point before evaluating the symbol `s`\n+* the point after evaluating the symbol `s`\n+* the point after evaluating the arguments to `print`\n+* the point after the second statement\n+\n+\n+Whereas this code:\n+\n+\n+~~~~~~~~\n+ print(x() + y());\n+~~~~~~~~\n+\n+Consists of 1 statement, 7 expressions and 14 points:\n+\n+\n+* the point before the statement\n+* the point before evaluating the function value `print`\n+* the point after evaluating the function value `print`\n+* the point before evaluating the arguments to `print`\n+* the point before evaluating the arguments to `+`\n+* the point before evaluating the function value `x`\n+* the point after evaluating the function value `x`\n+* the point before evaluating the arguments to `x`\n+* the point after evaluating the arguments to `x`\n+* the point before evaluating the function value `y`\n+* the point after evaluating the function value `y`\n+* the point before evaluating the arguments to `y`\n+* the point after evaluating the arguments to `y`\n+* the point after evaluating the arguments to `+`\n+* the point after evaluating the arguments to `print`\n+\n+\n+The typestate system reasons over points, rather than statements or\n+expressions. This may seem counter-intuitive, but points are the more\n+primitive concept. Another way of thinking about a point is as a set of\n+*instants in time* at which the state of a task is fixed. By contrast, a\n+statement or expression represents a *duration in time*, during which the\n+state of the task changes. The typestate system is concerned with constraining\n+the possible states of a task's memory at *instants*; it is meaningless to\n+speak of the state of a task's memory \"at\" a statement or expression, as each\n+statement or expression is likely to change the contents of memory.\n+\n+\n+### Control flow graph\n+\n+Each *point* can be considered a vertex in a directed *graph*. Each\n+kind of expression or statement implies a number of points *and edges* in\n+this graph. The edges connect the points within each statement or expression,\n+as well as between those points and those of nearby statements and expressions\n+in the program. The edges between points represent *possible* indivisible\n+control transfers that might occur during execution.\n+\n+This implicit graph is called the _control-flow graph_, or _CFG_.\n+\n+\n+### Constraints\n+\n+A [_predicate_](#predicate-functions) is a pure boolean function declared with\n+the keywords `pure fn`.\n+\n+A _constraint_ is a predicate applied to specific slots.\n+\n+For example, consider the following code:\n+\n+~~~~~~~~\n+pure fn is_less_than(int a, int b) -> bool {\n+     ret a < b;\n+}\n+\n+fn test() {\n+   let x: int = 10;\n+   let y: int = 20;\n+   check is_less_than(x,y);\n+}\n+~~~~~~~~\n+\n+This example defines the predicate `is_less_than`, and applies it to the slots\n+`x` and `y`. The constraint being checked on the third line of the function is\n+`is_less_than(x,y)`.\n+\n+Predicates can only apply to slots holding immutable values. The slots a\n+predicate applies to can themselves be mutable, but the types of values held\n+in those slots must be immutable.\n+\n+### Conditions\n+\n+A _condition_ is a set of zero or more constraints.\n+\n+Each *point* has an associated *condition*:\n+\n+* The _precondition_ of a statement or expression is the condition required at\n+in the point before it.\n+* The _postcondition_ of a statement or expression is the condition enforced\n+in the point after it.\n+\n+Any constraint present in the precondition and *absent* in the postcondition\n+is considered to be *dropped* by the statement or expression.\n+\n+\n+### Calculated typestates\n+\n+The typestate checking system *calculates* an additional condition for each\n+point called its _typestate_. For a given statement or expression, we call the\n+two typestates associated with its two points the prestate and a poststate.\n+\n+* The _prestate_ of a statement or expression is the typestate of the\n+point before it.\n+* The _poststate_ of a statement or expression is the typestate of the\n+point after it.\n+\n+A _typestate_ is a condition that has _been determined by the typestate\n+algorithm_ to hold at a point. This is a subtle but important point to\n+understand: preconditions and postconditions are *inputs* to the typestate\n+algorithm; prestates and poststates are *outputs* from the typestate\n+algorithm.\n+\n+The typestate algorithm analyses the preconditions and postconditions of every\n+statement and expression in a block, and computes a condition for each\n+typestate. Specifically:\n+\n+\n+* Initially, every typestate is empty.\n+* Each statement or expression's poststate is given the union of the its\n+prestate, precondition, and postcondition.\n+* Each statement or expression's poststate has the difference between its\n+precondition and postcondition removed.\n+* Each statement or expression's prestate is given the intersection of the\n+poststates of every predecessor point in the CFG.\n+* The previous three steps are repeated until no typestates in the\n+block change.\n+\n+The typestate algorithm is a very conventional dataflow calculation, and can\n+be performed using bit-set operations, with one bit per predicate and one\n+bit-set per condition.\n+\n+After the typestates of a block are computed, the typestate algorithm checks\n+that every constraint in the precondition of a statement is satisfied by its\n+prestate. If any preconditions are not satisfied, the mismatch is considered a\n+static (compile-time) error.\n+\n+\n+### Typestate checks\n+\n+The key mechanism that connects run-time semantics and compile-time analysis\n+of typestates is the use of [`check` expressions](#check-expressions). A\n+`check` expression guarantees that *if* control were to proceed past it, the\n+predicate associated with the `check` would have succeeded, so the constraint\n+being checked *statically* holds in subsequent points.^[A `check` expression\n+is similar to an `assert` call in a C program, with the significant difference\n+that the Rust compiler *tracks* the constraint that each `check` expression\n+enforces. Naturally, `check` expressions cannot be omitted from a \"production\n+build\" of a Rust program the same way `asserts` are frequently disabled in\n+deployed C programs.}\n+\n+It is important to understand that the typestate system has *no insight* into\n+the meaning of a particular predicate. Predicates and constraints are not\n+evaluated in any way at compile time. Predicates are treated as specific (but\n+unknown) functions applied to specific (also unknown) slots. All the typestate\n+system does is track which of those predicates -- whatever they calculate --\n+*must have been checked already* in order for program control to reach a\n+particular point in the CFG. The fundamental building block, therefore, is the\n+`check` statement, which tells the typestate system \"if control passes this\n+point, the checked predicate holds\".\n+\n+From this building block, constraints can be propagated to function signatures\n+and constrained types, and the responsibility to `check` a constraint\n+pushed further and further away from the site at which the program requires it\n+to hold in order to execute properly.\n+\n+\n+\n # Memory and concurrency models\n \n Rust has a memory model centered around concurrently-executing _tasks_. Thus\n@@ -1522,7 +2652,7 @@ let s: str = recv(p);\n \n # Appendix: Rationales and design tradeoffs\n \n-_TBD_.\n+*TODO*.\n \n # Appendix: Influences and further references\n "}]}