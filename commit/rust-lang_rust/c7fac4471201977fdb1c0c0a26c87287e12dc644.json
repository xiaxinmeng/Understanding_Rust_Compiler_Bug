{"sha": "c7fac4471201977fdb1c0c0a26c87287e12dc644", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3ZmFjNDQ3MTIwMTk3N2ZkYjFjMGMwYTI2Yzg3Mjg3ZTEyZGM2NDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-07T13:21:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-07T13:21:35Z"}, "message": "auto merge of #13358 : tbu-/rust/pr_doc_equivrel, r=cmr\n\nAdd requirements of TotalEq and TotalOrd\r\n\r\nClarify that TotalEq needs an underlying equivalence relation and that TotalOrd\r\nneeds a total ordering and specifically named the required (and sufficient)\r\nattributes.", "tree": {"sha": "185eea7b5ac36f0c1d38d55b3e3cc4bb85f73006", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/185eea7b5ac36f0c1d38d55b3e3cc4bb85f73006"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7fac4471201977fdb1c0c0a26c87287e12dc644", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7fac4471201977fdb1c0c0a26c87287e12dc644", "html_url": "https://github.com/rust-lang/rust/commit/c7fac4471201977fdb1c0c0a26c87287e12dc644", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7fac4471201977fdb1c0c0a26c87287e12dc644/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd3e5531204840c62097d23c50e87b96b0dafdd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd3e5531204840c62097d23c50e87b96b0dafdd1", "html_url": "https://github.com/rust-lang/rust/commit/dd3e5531204840c62097d23c50e87b96b0dafdd1"}, {"sha": "85129e216948d0a7c83db7048ecf1cc997e09ab7", "url": "https://api.github.com/repos/rust-lang/rust/commits/85129e216948d0a7c83db7048ecf1cc997e09ab7", "html_url": "https://github.com/rust-lang/rust/commit/85129e216948d0a7c83db7048ecf1cc997e09ab7"}], "stats": {"total": 135, "additions": 72, "deletions": 63}, "files": [{"sha": "e39ab4144fd07a5d51051196fe0d9fce73b7f400", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 72, "deletions": 63, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/c7fac4471201977fdb1c0c0a26c87287e12dc644/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7fac4471201977fdb1c0c0a26c87287e12dc644/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=c7fac4471201977fdb1c0c0a26c87287e12dc644", "patch": "@@ -8,50 +8,47 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n-\n-Defines the `Ord` and `Eq` comparison traits.\n-\n-This module defines both `Ord` and `Eq` traits which are used by the compiler\n-to implement comparison operators.\n-Rust programs may implement `Ord` to overload the `<`, `<=`, `>`, and `>=` operators,\n-and may implement `Eq` to overload the `==` and `!=` operators.\n-\n-For example, to define a type with a customized definition for the Eq operators,\n-you could do the following:\n-\n-```rust\n-// Our type.\n-struct SketchyNum {\n-    num : int\n-}\n-\n-// Our implementation of `Eq` to support `==` and `!=`.\n-impl Eq for SketchyNum {\n-    // Our custom eq allows numbers which are near eachother to be equal! :D\n-    fn eq(&self, other: &SketchyNum) -> bool {\n-        (self.num - other.num).abs() < 5\n-    }\n-}\n-\n-// Now these binary operators will work when applied!\n-assert!(SketchyNum {num: 37} == SketchyNum {num: 34});\n-assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n-```\n-\n-*/\n-\n-/**\n-* Trait for values that can be compared for equality and inequality.\n-*\n-* This trait allows partial equality, where types can be unordered instead of strictly equal or\n-* unequal. For example, with the built-in floating-point types `a == b` and `a != b` will both\n-* evaluate to false if either `a` or `b` is NaN (cf. IEEE 754-2008 section 5.11).\n-*\n-* Eq only requires the `eq` method to be implemented; `ne` is its negation by default.\n-*\n-* Eventually, this will be implemented by default for types that implement `TotalEq`.\n-*/\n+//! Defines the `Ord` and `Eq` comparison traits.\n+//!\n+//! This module defines both `Ord` and `Eq` traits which are used by the\n+//! compiler to implement comparison operators. Rust programs may implement\n+//!`Ord` to overload the `<`, `<=`, `>`, and `>=` operators, and may implement\n+//! `Eq` to overload the `==` and `!=` operators.\n+//!\n+//! For example, to define a type with a customized definition for the Eq\n+//! operators, you could do the following:\n+//!\n+//! ```rust\n+//! // Our type.\n+//! struct SketchyNum {\n+//!     num : int\n+//! }\n+//!\n+//! // Our implementation of `Eq` to support `==` and `!=`.\n+//! impl Eq for SketchyNum {\n+//!     // Our custom eq allows numbers which are near eachother to be equal! :D\n+//!     fn eq(&self, other: &SketchyNum) -> bool {\n+//!         (self.num - other.num).abs() < 5\n+//!     }\n+//! }\n+//!\n+//! // Now these binary operators will work when applied!\n+//! assert!(SketchyNum {num: 37} == SketchyNum {num: 34});\n+//! assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n+//! ```\n+\n+/// Trait for values that can be compared for equality and inequality.\n+///\n+/// This trait allows partial equality, where types can be unordered instead of\n+/// strictly equal or unequal. For example, with the built-in floating-point\n+/// types `a == b` and `a != b` will both evaluate to false if either `a` or\n+/// `b` is NaN (cf. IEEE 754-2008 section 5.11).\n+///\n+/// Eq only requires the `eq` method to be implemented; `ne` is its negation by\n+/// default.\n+///\n+/// Eventually, this will be implemented by default for types that implement\n+/// `TotalEq`.\n #[lang=\"eq\"]\n pub trait Eq {\n     /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n@@ -62,7 +59,15 @@ pub trait Eq {\n     fn ne(&self, other: &Self) -> bool { !self.eq(other) }\n }\n \n-/// Trait for equality comparisons where `a == b` and `a != b` are strict inverses.\n+/// Trait for equality comparisons which are [equivalence relations](\n+/// https://en.wikipedia.org/wiki/Equivalence_relation).\n+///\n+/// This means, that in addition to `a == b` and `a != b` being strict\n+/// inverses, the equality must be (for all `a`, `b` and `c`):\n+///\n+/// - reflexive: `a == a`;\n+/// - symmetric: `a == b` implies `b == a`; and\n+/// - transitive: `a == b` and `b == c` implies `a == c`.\n pub trait TotalEq: Eq {\n     // FIXME #13101: this method is used solely by #[deriving] to\n     // assert that every component of a type implements #[deriving]\n@@ -111,7 +116,15 @@ pub enum Ordering {\n    Greater = 1\n }\n \n-/// Trait for types that form a total order.\n+/// Trait for types that form a [total order](\n+/// https://en.wikipedia.org/wiki/Total_order).\n+///\n+/// An order is a total order if it is (for all `a`, `b` and `c`):\n+///\n+/// - total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is\n+///   true; and\n+/// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n+///   both `==` and `>`.\n pub trait TotalOrd: TotalEq + Ord {\n     /// This method returns an ordering between `self` and `other` values.\n     ///\n@@ -168,13 +181,11 @@ totalord_impl!(uint)\n \n totalord_impl!(char)\n \n-/**\n- * Combine orderings, lexically.\n- *\n- * For example for a type `(int, int)`, two comparisons could be done.\n- * If the first ordering is different, the first ordering is all that must be returned.\n- * If the first ordering is equal, then second ordering is returned.\n-*/\n+/// Combine orderings, lexically.\n+///\n+/// For example for a type `(int, int)`, two comparisons could be done.\n+/// If the first ordering is different, the first ordering is all that must be returned.\n+/// If the first ordering is equal, then second ordering is returned.\n #[inline]\n pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n     match o1 {\n@@ -183,16 +194,14 @@ pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n     }\n }\n \n-/**\n-* Trait for values that can be compared for a sort-order.\n-*\n-* Ord only requires implementation of the `lt` method,\n-* with the others generated from default implementations.\n-*\n-* However it remains possible to implement the others separately,\n-* for compatibility with floating-point NaN semantics\n-* (cf. IEEE 754-2008 section 5.11).\n-*/\n+/// Trait for values that can be compared for a sort-order.\n+///\n+/// Ord only requires implementation of the `lt` method,\n+/// with the others generated from default implementations.\n+///\n+/// However it remains possible to implement the others separately,\n+/// for compatibility with floating-point NaN semantics\n+/// (cf. IEEE 754-2008 section 5.11).\n #[lang=\"ord\"]\n pub trait Ord: Eq {\n     /// This method tests less than (for `self` and `other`) and is used by the `<` operator."}]}