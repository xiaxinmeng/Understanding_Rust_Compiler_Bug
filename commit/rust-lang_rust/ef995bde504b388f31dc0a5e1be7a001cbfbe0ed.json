{"sha": "ef995bde504b388f31dc0a5e1be7a001cbfbe0ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmOTk1YmRlNTA0YjM4OGYzMWRjMGE1ZTFiZTdhMDAxY2JmYmUwZWQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2018-01-26T15:12:07Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-03-08T07:34:11Z"}, "message": "Move the pattern checking code to hair", "tree": {"sha": "d56411f43d5ef7d04f4086b09a4d8a91bf9aa308", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d56411f43d5ef7d04f4086b09a4d8a91bf9aa308"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef995bde504b388f31dc0a5e1be7a001cbfbe0ed", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlqg53MACgkQpp+NIls6\n19l8PQ/9G+CMZjGENKF/jrZVcIUBkEtWHMUU+WVNFB95V5kgKgN7KEcOslUsKCjQ\neuAZGQFxTcrsP2qPVtEd/exBhOfUpRObCEGTuLTbDkTF9i2NpZtsomOyNEBOnIq3\nwRHtln0ra4VlOsr+OGwpmHAx3fjq78Yl5jBY/e1R/WfPokWo0WAzj+XjiLRc3uOg\n5+AKmk+qz2iDpfeRMjovk8p0als5On7vUtmkgkJeoHawM7buzWDFKfNO86U6aCDV\nKUVrpV3KKIjguTBYV4O7FWcRKJRwENx6AALnQ5PqeUIniIF3f32cjRuDkoJCi9oZ\nMRXi167HA1eqADP9qH5/rTCNHF2xN8CbkhvRGdgzjoZG4CnBBGg1HBU2la9KVbn/\n5PESKOmawCmx1Q4YM/8DJtk3OgPQY64NYMz4nghDXoRfT4U/bsCGIfV08ICs44YE\nS58dbLpFHDpu8w7ljcAZHoQWU44i2N5bIficIAxJT4F44IEtIw473xNE/B1P2SWc\n1SY+kdIr5sPzgJXB09aP3eLCdFos0U9p+m9R0pY+e/fLxHUqoOA/A64fnxO72irp\nMWQI953ik4Qjl4GarrqAMUjg4aSBgjVkGdMK01gQmUOQkm471MeIwIJ3Yq1aecWm\n82N87A9WvlwcrcQY9IjhvawRVcfpLdwraaGzIyj6EwV3ld4RaBQ=\n=xzP3\n-----END PGP SIGNATURE-----", "payload": "tree d56411f43d5ef7d04f4086b09a4d8a91bf9aa308\nparent bb81f9bdec4c4541c68673b3d01771793465e16e\nauthor Oliver Schneider <git-no-reply-9879165716479413131@oli-obk.de> 1516979527 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1520494451 +0100\n\nMove the pattern checking code to hair\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef995bde504b388f31dc0a5e1be7a001cbfbe0ed", "html_url": "https://github.com/rust-lang/rust/commit/ef995bde504b388f31dc0a5e1be7a001cbfbe0ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef995bde504b388f31dc0a5e1be7a001cbfbe0ed/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb81f9bdec4c4541c68673b3d01771793465e16e", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb81f9bdec4c4541c68673b3d01771793465e16e", "html_url": "https://github.com/rust-lang/rust/commit/bb81f9bdec4c4541c68673b3d01771793465e16e"}], "stats": {"total": 1222, "additions": 1195, "deletions": 27}, "files": [{"sha": "f232d039f6641c0a35ef06db7bca9a3d199b7b1a", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef995bde504b388f31dc0a5e1be7a001cbfbe0ed/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef995bde504b388f31dc0a5e1be7a001cbfbe0ed/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=ef995bde504b388f31dc0a5e1be7a001cbfbe0ed", "patch": "@@ -1048,7 +1048,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(trans: &TransCrate,\n \n         time(time_passes,\n              \"match checking\",\n-             || mir::pattern::check_crate(tcx));\n+             || mir::matchck_crate(tcx));\n \n         // this must run before MIR dump, because\n         // \"not all control paths return a value\" is reported here."}, {"sha": "23c5499bb639648c15a0ac570b531f029087988e", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef995bde504b388f31dc0a5e1be7a001cbfbe0ed/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef995bde504b388f31dc0a5e1be7a001cbfbe0ed/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=ef995bde504b388f31dc0a5e1be7a001cbfbe0ed", "patch": "@@ -11,7 +11,7 @@\n \n use build;\n use hair::cx::Cx;\n-use hair::LintLevel;\n+use hair::{LintLevel, BindingMode, PatternKind};\n use rustc::hir;\n use rustc::hir::def_id::{DefId, LocalDefId};\n use rustc::middle::region;\n@@ -21,7 +21,6 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n use rustc::util::nodemap::NodeMap;\n use rustc_back::PanicStrategy;\n-use pattern::pattern::{BindingMode, PatternKind};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use shim;\n use std::mem;"}, {"sha": "5f60a134fb13063bcbfc6594cf444c6ade8a1ed0", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef995bde504b388f31dc0a5e1be7a001cbfbe0ed/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef995bde504b388f31dc0a5e1be7a001cbfbe0ed/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=ef995bde504b388f31dc0a5e1be7a001cbfbe0ed", "patch": "@@ -26,7 +26,8 @@ use self::cx::Cx;\n \n pub mod cx;\n \n-pub use pattern::pattern::{BindingMode, Pattern, PatternKind, FieldPattern};\n+pub mod pattern;\n+pub use self::pattern::{BindingMode, Pattern, PatternKind, FieldPattern};\n \n #[derive(Copy, Clone, Debug)]\n pub enum LintLevel {"}, {"sha": "7f443893544f40aa9c746451889dc607c9903cc3", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef995bde504b388f31dc0a5e1be7a001cbfbe0ed/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef995bde504b388f31dc0a5e1be7a001cbfbe0ed/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=ef995bde504b388f31dc0a5e1be7a001cbfbe0ed", "patch": "@@ -17,8 +17,8 @@ use rustc::middle::const_val::ConstVal;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n-use super::pattern::{FieldPattern, Pattern, PatternKind};\n-use super::pattern::{PatternFoldable, PatternFolder, compare_const_vals};\n+use super::{FieldPattern, Pattern, PatternKind};\n+use super::{PatternFoldable, PatternFolder, compare_const_vals};\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::RangeEnd;", "previous_filename": "src/librustc_mir/pattern/_match.rs"}, {"sha": "69ed4e6064fcf961f9511b9558edc1f0b602d097", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef995bde504b388f31dc0a5e1be7a001cbfbe0ed/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef995bde504b388f31dc0a5e1be7a001cbfbe0ed/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=ef995bde504b388f31dc0a5e1be7a001cbfbe0ed", "patch": "@@ -12,7 +12,7 @@ use super::_match::{MatchCheckCtxt, Matrix, expand_pattern, is_useful};\n use super::_match::Usefulness::*;\n use super::_match::WitnessPreference::*;\n \n-use super::pattern::{Pattern, PatternContext, PatternError, PatternKind};\n+use super::{Pattern, PatternContext, PatternError, PatternKind};\n \n use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n use rustc::middle::expr_use_visitor::{LoanCause, MutateMode};", "previous_filename": "src/librustc_mir/pattern/check_match.rs"}, {"sha": "1141425c554a96a564d72fa473b7e148c26959fa", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "added", "additions": 1186, "deletions": 0, "changes": 1186, "blob_url": "https://github.com/rust-lang/rust/blob/ef995bde504b388f31dc0a5e1be7a001cbfbe0ed/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef995bde504b388f31dc0a5e1be7a001cbfbe0ed/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=ef995bde504b388f31dc0a5e1be7a001cbfbe0ed", "patch": "@@ -0,0 +1,1186 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Code to validate patterns/matches\n+\n+mod _match;\n+mod check_match;\n+\n+pub use self::check_match::check_crate;\n+pub(crate) use self::check_match::check_match;\n+\n+use interpret::{const_val_field, const_discr};\n+\n+use rustc::middle::const_val::ConstVal;\n+use rustc::mir::{Field, BorrowKind, Mutability};\n+use rustc::mir::interpret::{GlobalId, Value, PrimVal};\n+use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n+use rustc::ty::subst::{Substs, Kind};\n+use rustc::hir::{self, PatKind, RangeEnd};\n+use rustc::hir::def::{Def, CtorKind};\n+use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n+\n+use rustc_data_structures::indexed_vec::Idx;\n+use rustc_const_math::ConstFloat;\n+\n+use std::cmp::Ordering;\n+use std::fmt;\n+use syntax::ast;\n+use syntax::ptr::P;\n+use syntax_pos::Span;\n+\n+#[derive(Clone, Debug)]\n+pub enum PatternError {\n+    StaticInPattern(Span),\n+    FloatBug,\n+    NonConstPath(Span),\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum BindingMode<'tcx> {\n+    ByValue,\n+    ByRef(Region<'tcx>, BorrowKind),\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct FieldPattern<'tcx> {\n+    pub field: Field,\n+    pub pattern: Pattern<'tcx>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Pattern<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    pub span: Span,\n+    pub kind: Box<PatternKind<'tcx>>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum PatternKind<'tcx> {\n+    Wild,\n+\n+    /// x, ref x, x @ P, etc\n+    Binding {\n+        mutability: Mutability,\n+        name: ast::Name,\n+        mode: BindingMode<'tcx>,\n+        var: ast::NodeId,\n+        ty: Ty<'tcx>,\n+        subpattern: Option<Pattern<'tcx>>,\n+    },\n+\n+    /// Foo(...) or Foo{...} or Foo, where `Foo` is a variant name from an adt with >1 variants\n+    Variant {\n+        adt_def: &'tcx AdtDef,\n+        substs: &'tcx Substs<'tcx>,\n+        variant_index: usize,\n+        subpatterns: Vec<FieldPattern<'tcx>>,\n+    },\n+\n+    /// (...), Foo(...), Foo{...}, or Foo, where `Foo` is a variant name from an adt with 1 variant\n+    Leaf {\n+        subpatterns: Vec<FieldPattern<'tcx>>,\n+    },\n+\n+    /// box P, &P, &mut P, etc\n+    Deref {\n+        subpattern: Pattern<'tcx>,\n+    },\n+\n+    Constant {\n+        value: &'tcx ty::Const<'tcx>,\n+    },\n+\n+    Range {\n+        lo: &'tcx ty::Const<'tcx>,\n+        hi: &'tcx ty::Const<'tcx>,\n+        end: RangeEnd,\n+    },\n+\n+    /// matches against a slice, checking the length and extracting elements.\n+    /// irrefutable when there is a slice pattern and both `prefix` and `suffix` are empty.\n+    /// e.g. `&[ref xs..]`.\n+    Slice {\n+        prefix: Vec<Pattern<'tcx>>,\n+        slice: Option<Pattern<'tcx>>,\n+        suffix: Vec<Pattern<'tcx>>,\n+    },\n+\n+    /// fixed match against an array, irrefutable\n+    Array {\n+        prefix: Vec<Pattern<'tcx>>,\n+        slice: Option<Pattern<'tcx>>,\n+        suffix: Vec<Pattern<'tcx>>,\n+    },\n+}\n+\n+fn print_const_val(value: &ty::Const, f: &mut fmt::Formatter) -> fmt::Result {\n+    match value.val {\n+        ConstVal::Value(v) => print_miri_value(v, value.ty, f),\n+        ConstVal::Unevaluated(..) => bug!(\"{:?} not printable in a pattern\", value)\n+    }\n+}\n+\n+fn print_miri_value(value: Value, ty: Ty, f: &mut fmt::Formatter) -> fmt::Result {\n+    use rustc::ty::TypeVariants::*;\n+    match (value, &ty.sty) {\n+        (Value::ByVal(PrimVal::Bytes(0)), &TyBool) => write!(f, \"false\"),\n+        (Value::ByVal(PrimVal::Bytes(1)), &TyBool) => write!(f, \"true\"),\n+        (Value::ByVal(PrimVal::Bytes(n)), &TyUint(..)) => write!(f, \"{:?}\", n),\n+        (Value::ByVal(PrimVal::Bytes(n)), &TyInt(..)) => write!(f, \"{:?}\", n as i128),\n+        (Value::ByVal(PrimVal::Bytes(n)), &TyChar) =>\n+            write!(f, \"{:?}\", ::std::char::from_u32(n as u32).unwrap()),\n+        _ => bug!(\"{:?}: {} not printable in a pattern\", value, ty),\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for Pattern<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self.kind {\n+            PatternKind::Wild => write!(f, \"_\"),\n+            PatternKind::Binding { mutability, name, mode, ref subpattern, .. } => {\n+                let is_mut = match mode {\n+                    BindingMode::ByValue => mutability == Mutability::Mut,\n+                    BindingMode::ByRef(_, bk) => {\n+                        write!(f, \"ref \")?;\n+                        bk == BorrowKind::Mut\n+                    }\n+                };\n+                if is_mut {\n+                    write!(f, \"mut \")?;\n+                }\n+                write!(f, \"{}\", name)?;\n+                if let Some(ref subpattern) = *subpattern {\n+                    write!(f, \" @ {}\", subpattern)?;\n+                }\n+                Ok(())\n+            }\n+            PatternKind::Variant { ref subpatterns, .. } |\n+            PatternKind::Leaf { ref subpatterns } => {\n+                let variant = match *self.kind {\n+                    PatternKind::Variant { adt_def, variant_index, .. } => {\n+                        Some(&adt_def.variants[variant_index])\n+                    }\n+                    _ => if let ty::TyAdt(adt, _) = self.ty.sty {\n+                        if !adt.is_enum() {\n+                            Some(&adt.variants[0])\n+                        } else {\n+                            None\n+                        }\n+                    } else {\n+                        None\n+                    }\n+                };\n+\n+                let mut first = true;\n+                let mut start_or_continue = || if first { first = false; \"\" } else { \", \" };\n+\n+                if let Some(variant) = variant {\n+                    write!(f, \"{}\", variant.name)?;\n+\n+                    // Only for TyAdt we can have `S {...}`,\n+                    // which we handle separately here.\n+                    if variant.ctor_kind == CtorKind::Fictive {\n+                        write!(f, \" {{ \")?;\n+\n+                        let mut printed = 0;\n+                        for p in subpatterns {\n+                            if let PatternKind::Wild = *p.pattern.kind {\n+                                continue;\n+                            }\n+                            let name = variant.fields[p.field.index()].name;\n+                            write!(f, \"{}{}: {}\", start_or_continue(), name, p.pattern)?;\n+                            printed += 1;\n+                        }\n+\n+                        if printed < variant.fields.len() {\n+                            write!(f, \"{}..\", start_or_continue())?;\n+                        }\n+\n+                        return write!(f, \" }}\");\n+                    }\n+                }\n+\n+                let num_fields = variant.map_or(subpatterns.len(), |v| v.fields.len());\n+                if num_fields != 0 || variant.is_none() {\n+                    write!(f, \"(\")?;\n+                    for i in 0..num_fields {\n+                        write!(f, \"{}\", start_or_continue())?;\n+\n+                        // Common case: the field is where we expect it.\n+                        if let Some(p) = subpatterns.get(i) {\n+                            if p.field.index() == i {\n+                                write!(f, \"{}\", p.pattern)?;\n+                                continue;\n+                            }\n+                        }\n+\n+                        // Otherwise, we have to go looking for it.\n+                        if let Some(p) = subpatterns.iter().find(|p| p.field.index() == i) {\n+                            write!(f, \"{}\", p.pattern)?;\n+                        } else {\n+                            write!(f, \"_\")?;\n+                        }\n+                    }\n+                    write!(f, \")\")?;\n+                }\n+\n+                Ok(())\n+            }\n+            PatternKind::Deref { ref subpattern } => {\n+                match self.ty.sty {\n+                    ty::TyAdt(def, _) if def.is_box() => write!(f, \"box \")?,\n+                    ty::TyRef(_, mt) => {\n+                        write!(f, \"&\")?;\n+                        if mt.mutbl == hir::MutMutable {\n+                            write!(f, \"mut \")?;\n+                        }\n+                    }\n+                    _ => bug!(\"{} is a bad Deref pattern type\", self.ty)\n+                }\n+                write!(f, \"{}\", subpattern)\n+            }\n+            PatternKind::Constant { value } => {\n+                print_const_val(value, f)\n+            }\n+            PatternKind::Range { lo, hi, end } => {\n+                print_const_val(lo, f)?;\n+                match end {\n+                    RangeEnd::Included => write!(f, \"...\")?,\n+                    RangeEnd::Excluded => write!(f, \"..\")?,\n+                }\n+                print_const_val(hi, f)\n+            }\n+            PatternKind::Slice { ref prefix, ref slice, ref suffix } |\n+            PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n+                let mut first = true;\n+                let mut start_or_continue = || if first { first = false; \"\" } else { \", \" };\n+                write!(f, \"[\")?;\n+                for p in prefix {\n+                    write!(f, \"{}{}\", start_or_continue(), p)?;\n+                }\n+                if let Some(ref slice) = *slice {\n+                    write!(f, \"{}\", start_or_continue())?;\n+                    match *slice.kind {\n+                        PatternKind::Wild => {}\n+                        _ => write!(f, \"{}\", slice)?\n+                    }\n+                    write!(f, \"..\")?;\n+                }\n+                for p in suffix {\n+                    write!(f, \"{}{}\", start_or_continue(), p)?;\n+                }\n+                write!(f, \"]\")\n+            }\n+        }\n+    }\n+}\n+\n+pub struct PatternContext<'a, 'tcx: 'a> {\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n+    pub tables: &'a ty::TypeckTables<'tcx>,\n+    pub substs: &'tcx Substs<'tcx>,\n+    pub errors: Vec<PatternError>,\n+}\n+\n+impl<'a, 'tcx> Pattern<'tcx> {\n+    pub fn from_hir(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    param_env_and_substs: ty::ParamEnvAnd<'tcx, &'tcx Substs<'tcx>>,\n+                    tables: &'a ty::TypeckTables<'tcx>,\n+                    pat: &'tcx hir::Pat) -> Self {\n+        let mut pcx = PatternContext::new(tcx, param_env_and_substs, tables);\n+        let result = pcx.lower_pattern(pat);\n+        if !pcx.errors.is_empty() {\n+            let msg = format!(\"encountered errors lowering pattern: {:?}\", pcx.errors);\n+            tcx.sess.delay_span_bug(pat.span, &msg);\n+        }\n+        debug!(\"Pattern::from_hir({:?}) = {:?}\", pat, result);\n+        result\n+    }\n+}\n+\n+impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               param_env_and_substs: ty::ParamEnvAnd<'tcx, &'tcx Substs<'tcx>>,\n+               tables: &'a ty::TypeckTables<'tcx>) -> Self {\n+        PatternContext {\n+            tcx,\n+            param_env: param_env_and_substs.param_env,\n+            tables,\n+            substs: param_env_and_substs.value,\n+            errors: vec![]\n+        }\n+    }\n+\n+    pub fn lower_pattern(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n+        // When implicit dereferences have been inserted in this pattern, the unadjusted lowered\n+        // pattern has the type that results *after* dereferencing. For example, in this code:\n+        //\n+        // ```\n+        // match &&Some(0i32) {\n+        //     Some(n) => { ... },\n+        //     _ => { ... },\n+        // }\n+        // ```\n+        //\n+        // the type assigned to `Some(n)` in `unadjusted_pat` would be `Option<i32>` (this is\n+        // determined in rustc_typeck::check::match). The adjustments would be\n+        //\n+        // `vec![&&Option<i32>, &Option<i32>]`.\n+        //\n+        // Applying the adjustments, we want to instead output `&&Some(n)` (as a HAIR pattern). So\n+        // we wrap the unadjusted pattern in `PatternKind::Deref` repeatedly, consuming the\n+        // adjustments in *reverse order* (last-in-first-out, so that the last `Deref` inserted\n+        // gets the least-dereferenced type).\n+        let unadjusted_pat = self.lower_pattern_unadjusted(pat);\n+        self.tables\n+            .pat_adjustments()\n+            .get(pat.hir_id)\n+            .unwrap_or(&vec![])\n+            .iter()\n+            .rev()\n+            .fold(unadjusted_pat, |pat, ref_ty| {\n+                    debug!(\"{:?}: wrapping pattern with type {:?}\", pat, ref_ty);\n+                    Pattern {\n+                        span: pat.span,\n+                        ty: ref_ty,\n+                        kind: Box::new(PatternKind::Deref { subpattern: pat }),\n+                    }\n+                },\n+            )\n+    }\n+\n+    fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n+        let mut ty = self.tables.node_id_to_type(pat.hir_id);\n+\n+        let kind = match pat.node {\n+            PatKind::Wild => PatternKind::Wild,\n+\n+            PatKind::Lit(ref value) => self.lower_lit(value),\n+\n+            PatKind::Range(ref lo_expr, ref hi_expr, end) => {\n+                match (self.lower_lit(lo_expr), self.lower_lit(hi_expr)) {\n+                    (PatternKind::Constant { value: lo },\n+                     PatternKind::Constant { value: hi }) => {\n+                        use std::cmp::Ordering;\n+                        match (end, compare_const_vals(&lo.val, &hi.val, ty).unwrap()) {\n+                            (RangeEnd::Excluded, Ordering::Less) => {},\n+                            (RangeEnd::Excluded, _) => span_err!(\n+                                self.tcx.sess,\n+                                lo_expr.span,\n+                                E0579,\n+                                \"lower range bound must be less than upper\",\n+                            ),\n+                            (RangeEnd::Included, Ordering::Greater) => {\n+                                struct_span_err!(self.tcx.sess, lo_expr.span, E0030,\n+                                    \"lower range bound must be less than or equal to upper\")\n+                                    .span_label(lo_expr.span, \"lower bound larger than upper bound\")\n+                                    .emit();\n+                            },\n+                            (RangeEnd::Included, _) => {}\n+                        }\n+                        PatternKind::Range { lo, hi, end }\n+                    }\n+                    _ => PatternKind::Wild\n+                }\n+            }\n+\n+            PatKind::Path(ref qpath) => {\n+                return self.lower_path(qpath, pat.hir_id, pat.span);\n+            }\n+\n+            PatKind::Ref(ref subpattern, _) |\n+            PatKind::Box(ref subpattern) => {\n+                PatternKind::Deref { subpattern: self.lower_pattern(subpattern) }\n+            }\n+\n+            PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n+                let ty = self.tables.node_id_to_type(pat.hir_id);\n+                match ty.sty {\n+                    ty::TyRef(_, mt) =>\n+                        PatternKind::Deref {\n+                            subpattern: Pattern {\n+                                ty: mt.ty,\n+                                span: pat.span,\n+                                kind: Box::new(self.slice_or_array_pattern(\n+                                    pat.span, mt.ty, prefix, slice, suffix))\n+                            },\n+                        },\n+\n+                    ty::TySlice(..) |\n+                    ty::TyArray(..) =>\n+                        self.slice_or_array_pattern(pat.span, ty, prefix, slice, suffix),\n+\n+                    ref sty =>\n+                        span_bug!(\n+                            pat.span,\n+                            \"unexpanded type for vector pattern: {:?}\",\n+                            sty),\n+                }\n+            }\n+\n+            PatKind::Tuple(ref subpatterns, ddpos) => {\n+                let ty = self.tables.node_id_to_type(pat.hir_id);\n+                match ty.sty {\n+                    ty::TyTuple(ref tys, _) => {\n+                        let subpatterns =\n+                            subpatterns.iter()\n+                                       .enumerate_and_adjust(tys.len(), ddpos)\n+                                       .map(|(i, subpattern)| FieldPattern {\n+                                            field: Field::new(i),\n+                                            pattern: self.lower_pattern(subpattern)\n+                                       })\n+                                       .collect();\n+\n+                        PatternKind::Leaf { subpatterns: subpatterns }\n+                    }\n+\n+                    ref sty => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", sty),\n+                }\n+            }\n+\n+            PatKind::Binding(_, id, ref ident, ref sub) => {\n+                let var_ty = self.tables.node_id_to_type(pat.hir_id);\n+                let region = match var_ty.sty {\n+                    ty::TyRef(r, _) => Some(r),\n+                    _ => None,\n+                };\n+                let bm = *self.tables.pat_binding_modes().get(pat.hir_id)\n+                                                         .expect(\"missing binding mode\");\n+                let (mutability, mode) = match bm {\n+                    ty::BindByValue(hir::MutMutable) =>\n+                        (Mutability::Mut, BindingMode::ByValue),\n+                    ty::BindByValue(hir::MutImmutable) =>\n+                        (Mutability::Not, BindingMode::ByValue),\n+                    ty::BindByReference(hir::MutMutable) =>\n+                        (Mutability::Not, BindingMode::ByRef(\n+                            region.unwrap(), BorrowKind::Mut)),\n+                    ty::BindByReference(hir::MutImmutable) =>\n+                        (Mutability::Not, BindingMode::ByRef(\n+                            region.unwrap(), BorrowKind::Shared)),\n+                };\n+\n+                // A ref x pattern is the same node used for x, and as such it has\n+                // x's type, which is &T, where we want T (the type being matched).\n+                if let ty::BindByReference(_) = bm {\n+                    if let ty::TyRef(_, mt) = ty.sty {\n+                        ty = mt.ty;\n+                    } else {\n+                        bug!(\"`ref {}` has wrong type {}\", ident.node, ty);\n+                    }\n+                }\n+\n+                PatternKind::Binding {\n+                    mutability,\n+                    mode,\n+                    name: ident.node,\n+                    var: id,\n+                    ty: var_ty,\n+                    subpattern: self.lower_opt_pattern(sub),\n+                }\n+            }\n+\n+            PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n+                let def = self.tables.qpath_def(qpath, pat.hir_id);\n+                let adt_def = match ty.sty {\n+                    ty::TyAdt(adt_def, _) => adt_def,\n+                    _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n+                };\n+                let variant_def = adt_def.variant_of_def(def);\n+\n+                let subpatterns =\n+                        subpatterns.iter()\n+                                   .enumerate_and_adjust(variant_def.fields.len(), ddpos)\n+                                   .map(|(i, field)| FieldPattern {\n+                                       field: Field::new(i),\n+                                       pattern: self.lower_pattern(field),\n+                                   })\n+                                   .collect();\n+                self.lower_variant_or_leaf(def, pat.span, ty, subpatterns)\n+            }\n+\n+            PatKind::Struct(ref qpath, ref fields, _) => {\n+                let def = self.tables.qpath_def(qpath, pat.hir_id);\n+                let adt_def = match ty.sty {\n+                    ty::TyAdt(adt_def, _) => adt_def,\n+                    _ => {\n+                        span_bug!(\n+                            pat.span,\n+                            \"struct pattern not applied to an ADT\");\n+                    }\n+                };\n+                let variant_def = adt_def.variant_of_def(def);\n+\n+                let subpatterns =\n+                    fields.iter()\n+                          .map(|field| {\n+                              let index = variant_def.index_of_field_named(field.node.name);\n+                              let index = index.unwrap_or_else(|| {\n+                                  span_bug!(\n+                                      pat.span,\n+                                      \"no field with name {:?}\",\n+                                      field.node.name);\n+                              });\n+                              FieldPattern {\n+                                  field: Field::new(index),\n+                                  pattern: self.lower_pattern(&field.node.pat),\n+                              }\n+                          })\n+                          .collect();\n+\n+                self.lower_variant_or_leaf(def, pat.span, ty, subpatterns)\n+            }\n+        };\n+\n+        Pattern {\n+            span: pat.span,\n+            ty,\n+            kind: Box::new(kind),\n+        }\n+    }\n+\n+    fn lower_patterns(&mut self, pats: &'tcx [P<hir::Pat>]) -> Vec<Pattern<'tcx>> {\n+        pats.iter().map(|p| self.lower_pattern(p)).collect()\n+    }\n+\n+    fn lower_opt_pattern(&mut self, pat: &'tcx Option<P<hir::Pat>>) -> Option<Pattern<'tcx>>\n+    {\n+        pat.as_ref().map(|p| self.lower_pattern(p))\n+    }\n+\n+    fn flatten_nested_slice_patterns(\n+        &mut self,\n+        prefix: Vec<Pattern<'tcx>>,\n+        slice: Option<Pattern<'tcx>>,\n+        suffix: Vec<Pattern<'tcx>>)\n+        -> (Vec<Pattern<'tcx>>, Option<Pattern<'tcx>>, Vec<Pattern<'tcx>>)\n+    {\n+        let orig_slice = match slice {\n+            Some(orig_slice) => orig_slice,\n+            None => return (prefix, slice, suffix)\n+        };\n+        let orig_prefix = prefix;\n+        let orig_suffix = suffix;\n+\n+        // dance because of intentional borrow-checker stupidity.\n+        let kind = *orig_slice.kind;\n+        match kind {\n+            PatternKind::Slice { prefix, slice, mut suffix } |\n+            PatternKind::Array { prefix, slice, mut suffix } => {\n+                let mut orig_prefix = orig_prefix;\n+\n+                orig_prefix.extend(prefix);\n+                suffix.extend(orig_suffix);\n+\n+                (orig_prefix, slice, suffix)\n+            }\n+            _ => {\n+                (orig_prefix, Some(Pattern {\n+                    kind: box kind, ..orig_slice\n+                }), orig_suffix)\n+            }\n+        }\n+    }\n+\n+    fn slice_or_array_pattern(\n+        &mut self,\n+        span: Span,\n+        ty: Ty<'tcx>,\n+        prefix: &'tcx [P<hir::Pat>],\n+        slice: &'tcx Option<P<hir::Pat>>,\n+        suffix: &'tcx [P<hir::Pat>])\n+        -> PatternKind<'tcx>\n+    {\n+        let prefix = self.lower_patterns(prefix);\n+        let slice = self.lower_opt_pattern(slice);\n+        let suffix = self.lower_patterns(suffix);\n+        let (prefix, slice, suffix) =\n+            self.flatten_nested_slice_patterns(prefix, slice, suffix);\n+\n+        match ty.sty {\n+            ty::TySlice(..) => {\n+                // matching a slice or fixed-length array\n+                PatternKind::Slice { prefix: prefix, slice: slice, suffix: suffix }\n+            }\n+\n+            ty::TyArray(_, len) => {\n+                // fixed-length array\n+                let len = len.val.unwrap_u64();\n+                assert!(len >= prefix.len() as u64 + suffix.len() as u64);\n+                PatternKind::Array { prefix: prefix, slice: slice, suffix: suffix }\n+            }\n+\n+            _ => {\n+                span_bug!(span, \"bad slice pattern type {:?}\", ty);\n+            }\n+        }\n+    }\n+\n+    fn lower_variant_or_leaf(\n+        &mut self,\n+        def: Def,\n+        span: Span,\n+        ty: Ty<'tcx>,\n+        subpatterns: Vec<FieldPattern<'tcx>>)\n+        -> PatternKind<'tcx>\n+    {\n+        match def {\n+            Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n+                let enum_id = self.tcx.parent_def_id(variant_id).unwrap();\n+                let adt_def = self.tcx.adt_def(enum_id);\n+                if adt_def.is_enum() {\n+                    let substs = match ty.sty {\n+                        ty::TyAdt(_, substs) |\n+                        ty::TyFnDef(_, substs) => substs,\n+                        _ => bug!(\"inappropriate type for def: {:?}\", ty.sty),\n+                    };\n+                    PatternKind::Variant {\n+                        adt_def,\n+                        substs,\n+                        variant_index: adt_def.variant_index_with_id(variant_id),\n+                        subpatterns,\n+                    }\n+                } else {\n+                    PatternKind::Leaf { subpatterns: subpatterns }\n+                }\n+            }\n+\n+            Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n+            Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) => {\n+                PatternKind::Leaf { subpatterns: subpatterns }\n+            }\n+\n+            _ => {\n+                self.errors.push(PatternError::NonConstPath(span));\n+                PatternKind::Wild\n+            }\n+        }\n+    }\n+\n+    fn lower_path(&mut self,\n+                  qpath: &hir::QPath,\n+                  id: hir::HirId,\n+                  span: Span)\n+                  -> Pattern<'tcx> {\n+        let ty = self.tables.node_id_to_type(id);\n+        let def = self.tables.qpath_def(qpath, id);\n+        let kind = match def {\n+            Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n+                let substs = self.tables.node_substs(id);\n+                match ty::Instance::resolve(\n+                    self.tcx,\n+                    self.param_env,\n+                    def_id,\n+                    substs,\n+                ) {\n+                    Some(instance) => {\n+                        let cid = GlobalId {\n+                            instance,\n+                            promoted: None,\n+                        };\n+                        match self.tcx.at(span).const_eval(self.param_env.and(cid)) {\n+                            Ok(value) => {\n+                                return self.const_to_pat(instance, value, id, span)\n+                            },\n+                            Err(err) => {\n+                                err.report(self.tcx, span, \"pattern\");\n+                                PatternKind::Wild\n+                            },\n+                        }\n+                    },\n+                    None => {\n+                        self.errors.push(PatternError::StaticInPattern(span));\n+                        PatternKind::Wild\n+                    },\n+                }\n+            }\n+            _ => self.lower_variant_or_leaf(def, span, ty, vec![]),\n+        };\n+\n+        Pattern {\n+            span,\n+            ty,\n+            kind: Box::new(kind),\n+        }\n+    }\n+\n+    fn lower_lit(&mut self, expr: &'tcx hir::Expr) -> PatternKind<'tcx> {\n+        match expr.node {\n+            hir::ExprLit(ref lit) => {\n+                let ty = self.tables.expr_ty(expr);\n+                match lit_to_const(&lit.node, self.tcx, ty, false) {\n+                    Ok(val) => {\n+                        let instance = ty::Instance::new(\n+                            self.tables.local_id_root.expect(\"literal outside any scope\"),\n+                            self.substs,\n+                        );\n+                        let cv = self.tcx.mk_const(ty::Const { val, ty });\n+                        *self.const_to_pat(instance, cv, expr.hir_id, lit.span).kind\n+                    },\n+                    Err(()) => {\n+                        self.errors.push(PatternError::FloatBug);\n+                        PatternKind::Wild\n+                    },\n+                }\n+            },\n+            hir::ExprPath(ref qpath) => *self.lower_path(qpath, expr.hir_id, expr.span).kind,\n+            hir::ExprUnary(hir::UnNeg, ref expr) => {\n+                let ty = self.tables.expr_ty(expr);\n+                let lit = match expr.node {\n+                    hir::ExprLit(ref lit) => lit,\n+                    _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n+                };\n+                match lit_to_const(&lit.node, self.tcx, ty, true) {\n+                    Ok(val) => {\n+                        let instance = ty::Instance::new(\n+                            self.tables.local_id_root.expect(\"literal outside any scope\"),\n+                            self.substs,\n+                        );\n+                        let cv = self.tcx.mk_const(ty::Const { val, ty });\n+                        *self.const_to_pat(instance, cv, expr.hir_id, lit.span).kind\n+                    },\n+                    Err(()) => {\n+                        self.errors.push(PatternError::FloatBug);\n+                        PatternKind::Wild\n+                    },\n+                }\n+            }\n+            _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n+        }\n+    }\n+\n+    fn const_to_pat(\n+        &self,\n+        instance: ty::Instance<'tcx>,\n+        cv: &'tcx ty::Const<'tcx>,\n+        id: hir::HirId,\n+        span: Span,\n+    ) -> Pattern<'tcx> {\n+        debug!(\"const_to_pat: cv={:#?}\", cv);\n+        let kind = match cv.ty.sty {\n+            ty::TyFloat(_) => {\n+                let id = self.tcx.hir.hir_to_node_id(id);\n+                self.tcx.lint_node(\n+                    ::rustc::lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n+                    id,\n+                    span,\n+                    \"floating-point types cannot be used in patterns\",\n+                );\n+                PatternKind::Constant {\n+                    value: cv,\n+                }\n+            },\n+            ty::TyAdt(adt_def, _) if adt_def.is_union() => {\n+                // Matching on union fields is unsafe, we can't hide it in constants\n+                self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n+                PatternKind::Wild\n+            }\n+            ty::TyAdt(adt_def, _) if !self.tcx.has_attr(adt_def.did, \"structural_match\") => {\n+                let msg = format!(\"to use a constant of type `{}` in a pattern, \\\n+                                    `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                                    self.tcx.item_path_str(adt_def.did),\n+                                    self.tcx.item_path_str(adt_def.did));\n+                self.tcx.sess.span_err(span, &msg);\n+                PatternKind::Wild\n+            },\n+            ty::TyAdt(adt_def, substs) if adt_def.is_enum() => {\n+                match cv.val {\n+                    ConstVal::Value(val) => {\n+                        let discr = const_discr(\n+                            self.tcx, self.param_env, instance, val, cv.ty\n+                        ).unwrap();\n+                        let variant_index = adt_def\n+                            .discriminants(self.tcx)\n+                            .position(|var| var.val == discr)\n+                            .unwrap();\n+                        PatternKind::Variant {\n+                            adt_def,\n+                            substs,\n+                            variant_index,\n+                            subpatterns: adt_def\n+                                .variants[variant_index]\n+                                .fields\n+                                .iter()\n+                                .enumerate()\n+                                .map(|(i, _)| {\n+                                let field = Field::new(i);\n+                                let val = match cv.val {\n+                                    ConstVal::Value(miri) => const_val_field(\n+                                        self.tcx, self.param_env, instance,\n+                                        Some(variant_index), field, miri, cv.ty,\n+                                    ).unwrap(),\n+                                    _ => bug!(\"{:#?} is not a valid tuple\", cv),\n+                                };\n+                                FieldPattern {\n+                                    field,\n+                                    pattern: self.const_to_pat(instance, val, id, span),\n+                                }\n+                            }).collect(),\n+                        }\n+                    },\n+                    _ => return Pattern {\n+                        span,\n+                        ty: cv.ty,\n+                        kind: Box::new(PatternKind::Constant {\n+                            value: cv,\n+                        }),\n+                    }\n+                }\n+            },\n+            ty::TyAdt(adt_def, _) => {\n+                let struct_var = adt_def.non_enum_variant();\n+                PatternKind::Leaf {\n+                    subpatterns: struct_var.fields.iter().enumerate().map(|(i, _)| {\n+                        let field = Field::new(i);\n+                        let val = match cv.val {\n+                            ConstVal::Value(miri) => const_val_field(\n+                                self.tcx, self.param_env, instance, None, field, miri, cv.ty,\n+                            ).unwrap(),\n+                            _ => bug!(\"{:#?} is not a valid tuple\", cv),\n+                        };\n+                        FieldPattern {\n+                            field,\n+                            pattern: self.const_to_pat(instance, val, id, span),\n+                        }\n+                    }).collect()\n+                }\n+            }\n+            ty::TyTuple(fields, _) => {\n+                PatternKind::Leaf {\n+                    subpatterns: (0..fields.len()).map(|i| {\n+                        let field = Field::new(i);\n+                        let val = match cv.val {\n+                            ConstVal::Value(miri) => const_val_field(\n+                                self.tcx, self.param_env, instance, None, field, miri, cv.ty,\n+                            ).unwrap(),\n+                            _ => bug!(\"{:#?} is not a valid tuple\", cv),\n+                        };\n+                        FieldPattern {\n+                            field,\n+                            pattern: self.const_to_pat(instance, val, id, span),\n+                        }\n+                    }).collect()\n+                }\n+            }\n+            ty::TyArray(_, n) => {\n+                PatternKind::Array {\n+                    prefix: (0..n.val.unwrap_u64()).map(|i| {\n+                        let i = i as usize;\n+                        let field = Field::new(i);\n+                        let val = match cv.val {\n+                            ConstVal::Value(miri) => const_val_field(\n+                                self.tcx, self.param_env, instance, None, field, miri, cv.ty,\n+                            ).unwrap(),\n+                            _ => bug!(\"{:#?} is not a valid tuple\", cv),\n+                        };\n+                        self.const_to_pat(instance, val, id, span)\n+                    }).collect(),\n+                    slice: None,\n+                    suffix: Vec::new(),\n+                }\n+            }\n+            _ => {\n+                PatternKind::Constant {\n+                    value: cv,\n+                }\n+            },\n+        };\n+\n+        Pattern {\n+            span,\n+            ty: cv.ty,\n+            kind: Box::new(kind),\n+        }\n+    }\n+}\n+\n+pub trait PatternFoldable<'tcx> : Sized {\n+    fn fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        self.super_fold_with(folder)\n+    }\n+\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self;\n+}\n+\n+pub trait PatternFolder<'tcx> : Sized {\n+    fn fold_pattern(&mut self, pattern: &Pattern<'tcx>) -> Pattern<'tcx> {\n+        pattern.super_fold_with(self)\n+    }\n+\n+    fn fold_pattern_kind(&mut self, kind: &PatternKind<'tcx>) -> PatternKind<'tcx> {\n+        kind.super_fold_with(self)\n+    }\n+}\n+\n+\n+impl<'tcx, T: PatternFoldable<'tcx>> PatternFoldable<'tcx> for Box<T> {\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let content: T = (**self).fold_with(folder);\n+        box content\n+    }\n+}\n+\n+impl<'tcx, T: PatternFoldable<'tcx>> PatternFoldable<'tcx> for Vec<T> {\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        self.iter().map(|t| t.fold_with(folder)).collect()\n+    }\n+}\n+\n+impl<'tcx, T: PatternFoldable<'tcx>> PatternFoldable<'tcx> for Option<T> {\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self{\n+        self.as_ref().map(|t| t.fold_with(folder))\n+    }\n+}\n+\n+macro_rules! CloneImpls {\n+    (<$lt_tcx:tt> $($ty:ty),+) => {\n+        $(\n+            impl<$lt_tcx> PatternFoldable<$lt_tcx> for $ty {\n+                fn super_fold_with<F: PatternFolder<$lt_tcx>>(&self, _: &mut F) -> Self {\n+                    Clone::clone(self)\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+CloneImpls!{ <'tcx>\n+    Span, Field, Mutability, ast::Name, ast::NodeId, usize, &'tcx ty::Const<'tcx>,\n+    Region<'tcx>, Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n+    &'tcx Substs<'tcx>, &'tcx Kind<'tcx>\n+}\n+\n+impl<'tcx> PatternFoldable<'tcx> for FieldPattern<'tcx> {\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        FieldPattern {\n+            field: self.field.fold_with(folder),\n+            pattern: self.pattern.fold_with(folder)\n+        }\n+    }\n+}\n+\n+impl<'tcx> PatternFoldable<'tcx> for Pattern<'tcx> {\n+    fn fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        folder.fold_pattern(self)\n+    }\n+\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        Pattern {\n+            ty: self.ty.fold_with(folder),\n+            span: self.span.fold_with(folder),\n+            kind: self.kind.fold_with(folder)\n+        }\n+    }\n+}\n+\n+impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n+    fn fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        folder.fold_pattern_kind(self)\n+    }\n+\n+    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            PatternKind::Wild => PatternKind::Wild,\n+            PatternKind::Binding {\n+                mutability,\n+                name,\n+                mode,\n+                var,\n+                ty,\n+                ref subpattern,\n+            } => PatternKind::Binding {\n+                mutability: mutability.fold_with(folder),\n+                name: name.fold_with(folder),\n+                mode: mode.fold_with(folder),\n+                var: var.fold_with(folder),\n+                ty: ty.fold_with(folder),\n+                subpattern: subpattern.fold_with(folder),\n+            },\n+            PatternKind::Variant {\n+                adt_def,\n+                substs,\n+                variant_index,\n+                ref subpatterns,\n+            } => PatternKind::Variant {\n+                adt_def: adt_def.fold_with(folder),\n+                substs: substs.fold_with(folder),\n+                variant_index: variant_index.fold_with(folder),\n+                subpatterns: subpatterns.fold_with(folder)\n+            },\n+            PatternKind::Leaf {\n+                ref subpatterns,\n+            } => PatternKind::Leaf {\n+                subpatterns: subpatterns.fold_with(folder),\n+            },\n+            PatternKind::Deref {\n+                ref subpattern,\n+            } => PatternKind::Deref {\n+                subpattern: subpattern.fold_with(folder),\n+            },\n+            PatternKind::Constant {\n+                value\n+            } => PatternKind::Constant {\n+                value: value.fold_with(folder)\n+            },\n+            PatternKind::Range {\n+                lo,\n+                hi,\n+                end,\n+            } => PatternKind::Range {\n+                lo: lo.fold_with(folder),\n+                hi: hi.fold_with(folder),\n+                end,\n+            },\n+            PatternKind::Slice {\n+                ref prefix,\n+                ref slice,\n+                ref suffix,\n+            } => PatternKind::Slice {\n+                prefix: prefix.fold_with(folder),\n+                slice: slice.fold_with(folder),\n+                suffix: suffix.fold_with(folder)\n+            },\n+            PatternKind::Array {\n+                ref prefix,\n+                ref slice,\n+                ref suffix\n+            } => PatternKind::Array {\n+                prefix: prefix.fold_with(folder),\n+                slice: slice.fold_with(folder),\n+                suffix: suffix.fold_with(folder)\n+            },\n+        }\n+    }\n+}\n+\n+pub fn compare_const_vals(a: &ConstVal, b: &ConstVal, ty: Ty) -> Option<Ordering> {\n+    use rustc_const_math::ConstFloat;\n+    trace!(\"compare_const_vals: {:?}, {:?}\", a, b);\n+    use rustc::mir::interpret::{Value, PrimVal};\n+    match (a, b) {\n+        (&ConstVal::Value(Value::ByVal(PrimVal::Bytes(a))),\n+         &ConstVal::Value(Value::ByVal(PrimVal::Bytes(b)))) => {\n+            match ty.sty {\n+                ty::TyFloat(ty) => {\n+                    let l = ConstFloat {\n+                        bits: a,\n+                        ty,\n+                    };\n+                    let r = ConstFloat {\n+                        bits: b,\n+                        ty,\n+                    };\n+                    // FIXME(oli-obk): report cmp errors?\n+                    l.try_cmp(r).ok()\n+                },\n+                ty::TyInt(_) => Some((a as i128).cmp(&(b as i128))),\n+                _ => Some(a.cmp(&b)),\n+            }\n+        },\n+        _ if a == b => Some(Ordering::Equal),\n+        _ => None,\n+    }\n+}\n+\n+fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          ty: Ty<'tcx>,\n+                          neg: bool)\n+                          -> Result<ConstVal<'tcx>, ()> {\n+    use syntax::ast::*;\n+\n+    use rustc::mir::interpret::*;\n+    let lit = match *lit {\n+        LitKind::Str(ref s, _) => {\n+            let s = s.as_str();\n+            let id = tcx.allocate_cached(s.as_bytes());\n+            let ptr = MemoryPointer::new(id, 0);\n+            Value::ByValPair(\n+                PrimVal::Ptr(ptr),\n+                PrimVal::from_u128(s.len() as u128),\n+            )\n+        },\n+        LitKind::ByteStr(ref data) => {\n+            let id = tcx.allocate_cached(data);\n+            let ptr = MemoryPointer::new(id, 0);\n+            Value::ByVal(PrimVal::Ptr(ptr))\n+        },\n+        LitKind::Byte(n) => Value::ByVal(PrimVal::Bytes(n as u128)),\n+        LitKind::Int(n, _) => {\n+            enum Int {\n+                Signed(IntTy),\n+                Unsigned(UintTy),\n+            }\n+            let ty = match ty.sty {\n+                ty::TyInt(IntTy::Isize) => Int::Signed(tcx.sess.target.isize_ty),\n+                ty::TyInt(other) => Int::Signed(other),\n+                ty::TyUint(UintTy::Usize) => Int::Unsigned(tcx.sess.target.usize_ty),\n+                ty::TyUint(other) => Int::Unsigned(other),\n+                _ => bug!(),\n+            };\n+            let n = match ty {\n+                // FIXME(oli-obk): are these casts correct?\n+                Int::Signed(IntTy::I8) if neg =>\n+                    (n as i128 as i8).overflowing_neg().0 as i128 as u128,\n+                Int::Signed(IntTy::I16) if neg =>\n+                    (n as i128 as i16).overflowing_neg().0 as i128 as u128,\n+                Int::Signed(IntTy::I32) if neg =>\n+                    (n as i128 as i32).overflowing_neg().0 as i128 as u128,\n+                Int::Signed(IntTy::I64) if neg =>\n+                    (n as i128 as i64).overflowing_neg().0 as i128 as u128,\n+                Int::Signed(IntTy::I128) if neg =>\n+                    (n as i128).overflowing_neg().0 as u128,\n+                Int::Signed(IntTy::I8) => n as i128 as i8 as i128 as u128,\n+                Int::Signed(IntTy::I16) => n as i128 as i16 as i128 as u128,\n+                Int::Signed(IntTy::I32) => n as i128 as i32 as i128 as u128,\n+                Int::Signed(IntTy::I64) => n as i128 as i64 as i128 as u128,\n+                Int::Signed(IntTy::I128) => n,\n+                Int::Unsigned(UintTy::U8) => n as u8 as u128,\n+                Int::Unsigned(UintTy::U16) => n as u16 as u128,\n+                Int::Unsigned(UintTy::U32) => n as u32 as u128,\n+                Int::Unsigned(UintTy::U64) => n as u64 as u128,\n+                Int::Unsigned(UintTy::U128) => n,\n+                _ => bug!(),\n+            };\n+            Value::ByVal(PrimVal::Bytes(n))\n+        },\n+        LitKind::Float(n, fty) => {\n+            let n = n.as_str();\n+            let mut f = parse_float(&n, fty)?;\n+            if neg {\n+                f = -f;\n+            }\n+            let bits = f.bits;\n+            Value::ByVal(PrimVal::Bytes(bits))\n+        }\n+        LitKind::FloatUnsuffixed(n) => {\n+            let fty = match ty.sty {\n+                ty::TyFloat(fty) => fty,\n+                _ => bug!()\n+            };\n+            let n = n.as_str();\n+            let mut f = parse_float(&n, fty)?;\n+            if neg {\n+                f = -f;\n+            }\n+            let bits = f.bits;\n+            Value::ByVal(PrimVal::Bytes(bits))\n+        }\n+        LitKind::Bool(b) => Value::ByVal(PrimVal::Bytes(b as u128)),\n+        LitKind::Char(c) => Value::ByVal(PrimVal::Bytes(c as u128)),\n+    };\n+    Ok(ConstVal::Value(lit))\n+}\n+\n+fn parse_float<'tcx>(num: &str, fty: ast::FloatTy)\n+                     -> Result<ConstFloat, ()> {\n+    ConstFloat::from_str(num, fty).map_err(|_| ())\n+}"}, {"sha": "2678984092a52b9cfe4e0a6f03964e29147dcee7", "filename": "src/librustc_mir/hair/pattern/pattern.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef995bde504b388f31dc0a5e1be7a001cbfbe0ed/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef995bde504b388f31dc0a5e1be7a001cbfbe0ed/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fpattern.rs?ref=ef995bde504b388f31dc0a5e1be7a001cbfbe0ed", "previous_filename": "src/librustc_mir/pattern/pattern.rs"}, {"sha": "f6b38dcc00150c6467f9545cf5d45fbb737aa583", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef995bde504b388f31dc0a5e1be7a001cbfbe0ed/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef995bde504b388f31dc0a5e1be7a001cbfbe0ed/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=ef995bde504b388f31dc0a5e1be7a001cbfbe0ed", "patch": "@@ -71,17 +71,17 @@ pub mod transform;\n pub mod util;\n pub mod interpret;\n pub mod monomorphize;\n-pub mod pattern;\n pub mod check_const_err;\n \n+pub use hair::pattern::check_crate as matchck_crate;\n use rustc::ty::maps::Providers;\n \n pub fn provide(providers: &mut Providers) {\n     borrow_check::provide(providers);\n     shim::provide(providers);\n     transform::provide(providers);\n     providers.const_eval = interpret::const_eval_provider;\n-    providers.check_match = pattern::check_match;\n+    providers.check_match = hair::pattern::check_match;\n }\n \n __build_diagnostic_array! { librustc_mir, DIAGNOSTICS }"}, {"sha": "c99dc4a7658d9c413b92fda85e7dfac9b211a7c6", "filename": "src/librustc_mir/pattern/mod.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bb81f9bdec4c4541c68673b3d01771793465e16e/src%2Flibrustc_mir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb81f9bdec4c4541c68673b3d01771793465e16e/src%2Flibrustc_mir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpattern%2Fmod.rs?ref=bb81f9bdec4c4541c68673b3d01771793465e16e", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! constant evaluation on the HIR and code to validate patterns/matches\n-\n-mod _match;\n-mod check_match;\n-pub(crate) mod pattern;\n-\n-pub use self::check_match::check_crate;\n-pub(crate) use self::check_match::check_match;"}]}