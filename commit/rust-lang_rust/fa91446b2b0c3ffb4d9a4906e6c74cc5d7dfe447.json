{"sha": "fa91446b2b0c3ffb4d9a4906e6c74cc5d7dfe447", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhOTE0NDZiMmIwYzNmZmI0ZDlhNDkwNmU2Yzc0Y2M1ZDdkZmU0NDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-16T15:06:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-16T15:06:58Z"}, "message": "auto merge of #11597 : sfackler/rust/err-enums, r=alexcrichton\n\nAn enum allows callers to deal with errors in a more reasonable way.", "tree": {"sha": "1f989745d408af728e3d8ff8798dece9a4bd92ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f989745d408af728e3d8ff8798dece9a4bd92ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa91446b2b0c3ffb4d9a4906e6c74cc5d7dfe447", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa91446b2b0c3ffb4d9a4906e6c74cc5d7dfe447", "html_url": "https://github.com/rust-lang/rust/commit/fa91446b2b0c3ffb4d9a4906e6c74cc5d7dfe447", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa91446b2b0c3ffb4d9a4906e6c74cc5d7dfe447/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f63a7f598a0796b979ec3b626673168e5faa7f3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f63a7f598a0796b979ec3b626673168e5faa7f3f", "html_url": "https://github.com/rust-lang/rust/commit/f63a7f598a0796b979ec3b626673168e5faa7f3f"}, {"sha": "9fe5d1620cc721165062b98229d7fc682f1547ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fe5d1620cc721165062b98229d7fc682f1547ee", "html_url": "https://github.com/rust-lang/rust/commit/9fe5d1620cc721165062b98229d7fc682f1547ee"}], "stats": {"total": 61, "additions": 47, "deletions": 14}, "files": [{"sha": "6f9475d091ad65436dd263244775491f2263ca08", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fa91446b2b0c3ffb4d9a4906e6c74cc5d7dfe447/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa91446b2b0c3ffb4d9a4906e6c74cc5d7dfe447/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=fa91446b2b0c3ffb4d9a4906e6c74cc5d7dfe447", "patch": "@@ -154,7 +154,25 @@ impl<'a> ToBase64 for &'a [u8] {\n pub trait FromBase64 {\n     /// Converts the value of `self`, interpreted as base64 encoded data, into\n     /// an owned vector of bytes, returning the vector.\n-    fn from_base64(&self) -> Result<~[u8], ~str>;\n+    fn from_base64(&self) -> Result<~[u8], FromBase64Error>;\n+}\n+\n+/// Errors that can occur when decoding a base64 encoded string\n+pub enum FromBase64Error {\n+    /// The input contained a character not part of the base64 format\n+    InvalidBase64Character(char, uint),\n+    /// The input had an invalid length\n+    InvalidBase64Length,\n+}\n+\n+impl ToStr for FromBase64Error {\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            InvalidBase64Character(ch, idx) =>\n+                format!(\"Invalid character '{}' at position {}\", ch, idx),\n+            InvalidBase64Length => ~\"Invalid length\",\n+        }\n+    }\n }\n \n impl<'a> FromBase64 for &'a str {\n@@ -188,7 +206,7 @@ impl<'a> FromBase64 for &'a str {\n      * }\n      * ```\n      */\n-    fn from_base64(&self) -> Result<~[u8], ~str> {\n+    fn from_base64(&self) -> Result<~[u8], FromBase64Error> {\n         let mut r = ~[];\n         let mut buf: u32 = 0;\n         let mut modulus = 0;\n@@ -205,8 +223,7 @@ impl<'a> FromBase64 for &'a str {\n                 '/'|'_' => buf |= 0x3F,\n                 '\\r'|'\\n' => continue,\n                 '=' => break,\n-                _ => return Err(format!(\"Invalid character '{}' at position {}\",\n-                                     self.char_at(idx), idx))\n+                _ => return Err(InvalidBase64Character(self.char_at(idx), idx)),\n             }\n \n             buf <<= 6;\n@@ -221,8 +238,7 @@ impl<'a> FromBase64 for &'a str {\n \n         for (idx, byte) in it {\n             if (byte as char) != '=' {\n-                return Err(format!(\"Invalid character '{}' at position {}\",\n-                                self.char_at(idx), idx));\n+                return Err(InvalidBase64Character(self.char_at(idx), idx));\n             }\n         }\n \n@@ -235,7 +251,7 @@ impl<'a> FromBase64 for &'a str {\n                 r.push((buf >> 8 ) as u8);\n             }\n             0 => (),\n-            _ => return Err(~\"Invalid Base64 length\")\n+            _ => return Err(InvalidBase64Length),\n         }\n \n         Ok(r)"}, {"sha": "748289080532cd5e343afbade51403824db5f997", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa91446b2b0c3ffb4d9a4906e6c74cc5d7dfe447/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa91446b2b0c3ffb4d9a4906e6c74cc5d7dfe447/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=fa91446b2b0c3ffb4d9a4906e6c74cc5d7dfe447", "patch": "@@ -127,9 +127,9 @@ mod test {\n         // Rendezvous streams should be able to handle any number of messages being sent\n         let (port, chan) = rendezvous();\n         do spawn {\n-            1000000.times(|| { chan.send(()) })\n+            10000.times(|| { chan.send(()) })\n         }\n-        1000000.times(|| { port.recv() })\n+        10000.times(|| { port.recv() })\n     }\n \n     #[test]"}, {"sha": "e5fcd39667de0a37d4487a993970d3e1847e9e1b", "filename": "src/libextra/hex.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fa91446b2b0c3ffb4d9a4906e6c74cc5d7dfe447/src%2Flibextra%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa91446b2b0c3ffb4d9a4906e6c74cc5d7dfe447/src%2Flibextra%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fhex.rs?ref=fa91446b2b0c3ffb4d9a4906e6c74cc5d7dfe447", "patch": "@@ -53,7 +53,25 @@ impl<'a> ToHex for &'a [u8] {\n pub trait FromHex {\n     /// Converts the value of `self`, interpreted as hexadecimal encoded data,\n     /// into an owned vector of bytes, returning the vector.\n-    fn from_hex(&self) -> Result<~[u8], ~str>;\n+    fn from_hex(&self) -> Result<~[u8], FromHexError>;\n+}\n+\n+/// Errors that can occur when decoding a hex encoded string\n+pub enum FromHexError {\n+    /// The input contained a character not part of the hex format\n+    InvalidHexCharacter(char, uint),\n+    /// The input had a invalid length\n+    InvalidHexLength,\n+}\n+\n+impl ToStr for FromHexError {\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            InvalidHexCharacter(ch, idx) =>\n+                format!(\"Invalid character '{}' at position {}\", ch, idx),\n+            InvalidHexLength => ~\"Invalid input length\",\n+        }\n+    }\n }\n \n impl<'a> FromHex for &'a str {\n@@ -83,7 +101,7 @@ impl<'a> FromHex for &'a str {\n      * }\n      * ```\n      */\n-    fn from_hex(&self) -> Result<~[u8], ~str> {\n+    fn from_hex(&self) -> Result<~[u8], FromHexError> {\n         // This may be an overestimate if there is any whitespace\n         let mut b = vec::with_capacity(self.len() / 2);\n         let mut modulus = 0;\n@@ -100,8 +118,7 @@ impl<'a> FromHex for &'a str {\n                     buf >>= 4;\n                     continue\n                 }\n-                _ => return Err(format!(\"Invalid character '{}' at position {}\",\n-                                        self.char_at(idx), idx))\n+                _ => return Err(InvalidHexCharacter(self.char_at(idx), idx)),\n             }\n \n             modulus += 1;\n@@ -113,7 +130,7 @@ impl<'a> FromHex for &'a str {\n \n         match modulus {\n             0 => Ok(b),\n-            _ => Err(~\"Invalid input length\")\n+            _ => Err(InvalidHexLength),\n         }\n     }\n }"}]}