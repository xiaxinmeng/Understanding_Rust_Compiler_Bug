{"sha": "09fa72ae84605b9997abe345293b8315f7a05d0d", "node_id": "C_kwDOAAsO6NoAKDA5ZmE3MmFlODQ2MDViOTk5N2FiZTM0NTI5M2I4MzE1ZjdhMDVkMGQ", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2021-12-31T23:36:40Z"}, "committer": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-12-31T23:50:20Z"}, "message": " Merge portable-simd#219 - ./std-float\n\n impl std::simd::StdFloat\n\n This introduces an extension trait to allow use of floating point methods\n that need runtime support. It is *excessively* documented because its mere\n existence is quite vexing, as the entire thing constitutes a leakage of\n implementation details into user observable space. Eventually the entire\n thing will ideally be folded into core and restructured to match the rest\n of the library, whatever that structure might look like at the time. This\n is preferred in lieu of the \"lang item\" path because any energy the lang\n items require (and it will be significant, by Simulacrum's estimation) is\n better spent on implementing our libmvec.", "tree": {"sha": "7a16a7b0ee719682ee943f4f674d79f704812c9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a16a7b0ee719682ee943f4f674d79f704812c9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09fa72ae84605b9997abe345293b8315f7a05d0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09fa72ae84605b9997abe345293b8315f7a05d0d", "html_url": "https://github.com/rust-lang/rust/commit/09fa72ae84605b9997abe345293b8315f7a05d0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09fa72ae84605b9997abe345293b8315f7a05d0d/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bbef261b6dd8529dadfd41c04b72137657bc7e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bbef261b6dd8529dadfd41c04b72137657bc7e7", "html_url": "https://github.com/rust-lang/rust/commit/4bbef261b6dd8529dadfd41c04b72137657bc7e7"}, {"sha": "af26e3b9fd5c21492eb603ec57bc72aee8e7f84b", "url": "https://api.github.com/repos/rust-lang/rust/commits/af26e3b9fd5c21492eb603ec57bc72aee8e7f84b", "html_url": "https://github.com/rust-lang/rust/commit/af26e3b9fd5c21492eb603ec57bc72aee8e7f84b"}], "stats": {"total": 286, "additions": 191, "deletions": 95}, "files": [{"sha": "9802386e4566dab1749ccda5991d65594b4fa7c1", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09fa72ae84605b9997abe345293b8315f7a05d0d/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/09fa72ae84605b9997abe345293b8315f7a05d0d/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=09fa72ae84605b9997abe345293b8315f7a05d0d", "patch": "@@ -2,5 +2,6 @@\n \n members = [\n     \"crates/core_simd\",\n+    \"crates/std_float\",\n     \"crates/test_helpers\",\n ]"}, {"sha": "d2ff5f3b1b195fbbf3a55683c173ac19b69f86f0", "filename": "crates/core_simd/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/09fa72ae84605b9997abe345293b8315f7a05d0d/crates%2Fcore_simd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/09fa72ae84605b9997abe345293b8315f7a05d0d/crates%2Fcore_simd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2FCargo.toml?ref=09fa72ae84605b9997abe345293b8315f7a05d0d", "patch": "@@ -26,3 +26,6 @@ features = [\"alloc\"]\n \n [dev-dependencies.test_helpers]\n path = \"../test_helpers\"\n+\n+[dev-dependencies]\n+std_float = { path = \"../std_float/\", features = [\"as_crate\"] }"}, {"sha": "7b1e6840f6424f2f0f232f909c0eaf57e56c2223", "filename": "crates/core_simd/examples/nbody.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09fa72ae84605b9997abe345293b8315f7a05d0d/crates%2Fcore_simd%2Fexamples%2Fnbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09fa72ae84605b9997abe345293b8315f7a05d0d/crates%2Fcore_simd%2Fexamples%2Fnbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fexamples%2Fnbody.rs?ref=09fa72ae84605b9997abe345293b8315f7a05d0d", "patch": "@@ -1,11 +1,13 @@\n-#![cfg_attr(feature = \"std\", feature(portable_simd))]\n+#![feature(portable_simd)]\n+extern crate std_float;\n \n /// Benchmarks game nbody code\n /// Taken from the `packed_simd` crate\n /// Run this benchmark with `cargo test --example nbody`\n-#[cfg(feature = \"std\")]\n mod nbody {\n-    use core_simd::*;\n+    use core_simd::simd::*;\n+    #[allow(unused)] // False positive?\n+    use std_float::StdFloat;\n \n     use std::f64::consts::PI;\n     const SOLAR_MASS: f64 = 4.0 * PI * PI;\n@@ -167,7 +169,6 @@ mod nbody {\n     }\n }\n \n-#[cfg(feature = \"std\")]\n #[cfg(test)]\n mod tests {\n     // Good enough for demonstration purposes, not going for strictness here.\n@@ -184,7 +185,6 @@ mod tests {\n }\n \n fn main() {\n-    #[cfg(feature = \"std\")]\n     {\n         let (energy_before, energy_after) = nbody::run(1000);\n         println!(\"Energy before: {}\", energy_before);"}, {"sha": "0bc241af1f1cdf5fd255abc94aa031c7ad993489", "filename": "crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/09fa72ae84605b9997abe345293b8315f7a05d0d/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09fa72ae84605b9997abe345293b8315f7a05d0d/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=09fa72ae84605b9997abe345293b8315f7a05d0d", "patch": "@@ -87,29 +87,3 @@ extern \"platform-intrinsic\" {\n     #[allow(unused)]\n     pub(crate) fn simd_select_bitmask<M, T>(m: M, a: T, b: T) -> T;\n }\n-\n-#[cfg(feature = \"std\")]\n-mod std {\n-    extern \"platform-intrinsic\" {\n-        // ceil\n-        pub(crate) fn simd_ceil<T>(x: T) -> T;\n-\n-        // floor\n-        pub(crate) fn simd_floor<T>(x: T) -> T;\n-\n-        // round\n-        pub(crate) fn simd_round<T>(x: T) -> T;\n-\n-        // trunc\n-        pub(crate) fn simd_trunc<T>(x: T) -> T;\n-\n-        // fsqrt\n-        pub(crate) fn simd_fsqrt<T>(x: T) -> T;\n-\n-        // fma\n-        pub(crate) fn simd_fma<T>(x: T, y: T, z: T) -> T;\n-    }\n-}\n-\n-#[cfg(feature = \"std\")]\n-pub(crate) use crate::simd::intrinsics::std::*;"}, {"sha": "06ccab3ec494c6b0799bc43f29416b143318deab", "filename": "crates/core_simd/src/round.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/09fa72ae84605b9997abe345293b8315f7a05d0d/crates%2Fcore_simd%2Fsrc%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09fa72ae84605b9997abe345293b8315f7a05d0d/crates%2Fcore_simd%2Fsrc%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fround.rs?ref=09fa72ae84605b9997abe345293b8315f7a05d0d", "patch": "@@ -5,47 +5,6 @@ macro_rules! implement {\n     {\n         $type:ty, $int_type:ty\n     } => {\n-        #[cfg(feature = \"std\")]\n-        impl<const LANES: usize> Simd<$type, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            /// Returns the smallest integer greater than or equal to each lane.\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            #[inline]\n-            pub fn ceil(self) -> Self {\n-                unsafe { intrinsics::simd_ceil(self) }\n-            }\n-\n-            /// Returns the largest integer value less than or equal to each lane.\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            #[inline]\n-            pub fn floor(self) -> Self {\n-                unsafe { intrinsics::simd_floor(self) }\n-            }\n-\n-            /// Rounds to the nearest integer value. Ties round toward zero.\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            #[inline]\n-            pub fn round(self) -> Self {\n-                unsafe { intrinsics::simd_round(self) }\n-            }\n-\n-            /// Returns the floating point's integer value, with its fractional part removed.\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            #[inline]\n-            pub fn trunc(self) -> Self {\n-                unsafe { intrinsics::simd_trunc(self) }\n-            }\n-\n-            /// Returns the floating point's fractional value, with its integer part removed.\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            #[inline]\n-            pub fn fract(self) -> Self {\n-                self - self.trunc()\n-            }\n-        }\n-\n         impl<const LANES: usize> Simd<$type, LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,"}, {"sha": "3528a420351cf6b32e8aaf7202bdbd1985d9d957", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/09fa72ae84605b9997abe345293b8315f7a05d0d/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09fa72ae84605b9997abe345293b8315f7a05d0d/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=09fa72ae84605b9997abe345293b8315f7a05d0d", "patch": "@@ -38,29 +38,6 @@ macro_rules! impl_float_vector {\n                 unsafe { intrinsics::simd_fabs(self) }\n             }\n \n-            /// Fused multiply-add.  Computes `(self * a) + b` with only one rounding error,\n-            /// yielding a more accurate result than an unfused multiply-add.\n-            ///\n-            /// Using `mul_add` *may* be more performant than an unfused multiply-add if the target\n-            /// architecture has a dedicated `fma` CPU instruction.  However, this is not always\n-            /// true, and will be heavily dependent on designing algorithms with specific target\n-            /// hardware in mind.\n-            #[cfg(feature = \"std\")]\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn mul_add(self, a: Self, b: Self) -> Self {\n-                unsafe { intrinsics::simd_fma(self, a, b) }\n-            }\n-\n-            /// Produces a vector where every lane has the square root value\n-            /// of the equivalently-indexed lane in `self`\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            #[cfg(feature = \"std\")]\n-            pub fn sqrt(self) -> Self {\n-                unsafe { intrinsics::simd_fsqrt(self) }\n-            }\n-\n             /// Takes the reciprocal (inverse) of each lane, `1/x`.\n             #[inline]\n             #[must_use = \"method returns a new vector and does not mutate the original value\"]"}, {"sha": "4fb9de198ee15f5678a18eedbed49fbb463f3336", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09fa72ae84605b9997abe345293b8315f7a05d0d/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09fa72ae84605b9997abe345293b8315f7a05d0d/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=09fa72ae84605b9997abe345293b8315f7a05d0d", "patch": "@@ -546,6 +546,8 @@ macro_rules! impl_float_tests {\n \n             #[cfg(feature = \"std\")]\n             mod std {\n+                use std_float::StdFloat;\n+\n                 use super::*;\n                 test_helpers::test_lanes! {\n                     fn sqrt<const LANES: usize>() {"}, {"sha": "1a1bc9ebca76a15d0b5b1bb1b486801d20104168", "filename": "crates/core_simd/tests/round.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09fa72ae84605b9997abe345293b8315f7a05d0d/crates%2Fcore_simd%2Ftests%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09fa72ae84605b9997abe345293b8315f7a05d0d/crates%2Fcore_simd%2Ftests%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fround.rs?ref=09fa72ae84605b9997abe345293b8315f7a05d0d", "patch": "@@ -3,6 +3,8 @@\n macro_rules! float_rounding_test {\n     { $scalar:tt, $int_scalar:tt } => {\n         mod $scalar {\n+            use std_float::StdFloat;\n+\n             type Vector<const LANES: usize> = core_simd::Simd<$scalar, LANES>;\n             type Scalar = $scalar;\n             type IntScalar = $int_scalar;"}, {"sha": "82f66b8dcb7493a378956a3e09578e8ed7b39d66", "filename": "crates/std_float/Cargo.toml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/09fa72ae84605b9997abe345293b8315f7a05d0d/crates%2Fstd_float%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/09fa72ae84605b9997abe345293b8315f7a05d0d/crates%2Fstd_float%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstd_float%2FCargo.toml?ref=09fa72ae84605b9997abe345293b8315f7a05d0d", "patch": "@@ -0,0 +1,13 @@\n+[package]\n+name = \"std_float\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+core_simd = { path = \"../core_simd\" }\n+\n+[features]\n+default = [\"as_crate\"]\n+as_crate = []"}, {"sha": "4bd4d4c05e3b9cb9f1ad258577c6c31d3f0f67db", "filename": "crates/std_float/src/lib.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/09fa72ae84605b9997abe345293b8315f7a05d0d/crates%2Fstd_float%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09fa72ae84605b9997abe345293b8315f7a05d0d/crates%2Fstd_float%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstd_float%2Fsrc%2Flib.rs?ref=09fa72ae84605b9997abe345293b8315f7a05d0d", "patch": "@@ -0,0 +1,165 @@\n+#![cfg_attr(feature = \"as_crate\", no_std)] // We are std!\n+#![cfg_attr(\n+    feature = \"as_crate\",\n+    feature(platform_intrinsics),\n+    feature(portable_simd)\n+)]\n+#[cfg(not(feature = \"as_crate\"))]\n+use core::simd;\n+#[cfg(feature = \"as_crate\")]\n+use core_simd::simd;\n+\n+use simd::{LaneCount, Simd, SupportedLaneCount};\n+\n+#[cfg(feature = \"as_crate\")]\n+mod experimental {\n+    pub trait Sealed {}\n+}\n+\n+#[cfg(feature = \"as_crate\")]\n+use experimental as sealed;\n+\n+use crate::sealed::Sealed;\n+\n+// \"platform intrinsics\" are essentially \"codegen intrinsics\"\n+// each of these may be scalarized and lowered to a libm call\n+extern \"platform-intrinsic\" {\n+    // ceil\n+    fn simd_ceil<T>(x: T) -> T;\n+\n+    // floor\n+    fn simd_floor<T>(x: T) -> T;\n+\n+    // round\n+    fn simd_round<T>(x: T) -> T;\n+\n+    // trunc\n+    fn simd_trunc<T>(x: T) -> T;\n+\n+    // fsqrt\n+    fn simd_fsqrt<T>(x: T) -> T;\n+\n+    // fma\n+    fn simd_fma<T>(x: T, y: T, z: T) -> T;\n+}\n+\n+/// This trait provides a possibly-temporary implementation of float functions\n+/// that may, in the absence of hardware support, canonicalize to calling an\n+/// operating system's `math.h` dynamically-loaded library (also known as a\n+/// shared object). As these conditionally require runtime support, they\n+/// should only appear in binaries built assuming OS support: `std`.\n+///\n+/// However, there is no reason SIMD types, in general, need OS support,\n+/// as for many architectures an embedded binary may simply configure that\n+/// support itself. This means these types must be visible in `core`\n+/// but have these functions available in `std`.\n+///\n+/// [`f32`] and [`f64`] achieve a similar trick by using \"lang items\", but\n+/// due to compiler limitations, it is harder to implement this approach for\n+/// abstract data types like [`Simd`]. From that need, this trait is born.\n+///\n+/// It is possible this trait will be replaced in some manner in the future,\n+/// when either the compiler or its supporting runtime functions are improved.\n+/// For now this trait is available to permit experimentation with SIMD float\n+/// operations that may lack hardware support, such as `mul_add`.\n+pub trait StdFloat: Sealed + Sized {\n+    /// Fused multiply-add.  Computes `(self * a) + b` with only one rounding error,\n+    /// yielding a more accurate result than an unfused multiply-add.\n+    ///\n+    /// Using `mul_add` *may* be more performant than an unfused multiply-add if the target\n+    /// architecture has a dedicated `fma` CPU instruction.  However, this is not always\n+    /// true, and will be heavily dependent on designing algorithms with specific target\n+    /// hardware in mind.\n+    #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn mul_add(self, a: Self, b: Self) -> Self {\n+        unsafe { simd_fma(self, a, b) }\n+    }\n+\n+    /// Produces a vector where every lane has the square root value\n+    /// of the equivalently-indexed lane in `self`\n+    #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn sqrt(self) -> Self {\n+        unsafe { simd_fsqrt(self) }\n+    }\n+\n+    /// Returns the smallest integer greater than or equal to each lane.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    #[inline]\n+    fn ceil(self) -> Self {\n+        unsafe { simd_ceil(self) }\n+    }\n+\n+    /// Returns the largest integer value less than or equal to each lane.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    #[inline]\n+    fn floor(self) -> Self {\n+        unsafe { simd_floor(self) }\n+    }\n+\n+    /// Rounds to the nearest integer value. Ties round toward zero.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    #[inline]\n+    fn round(self) -> Self {\n+        unsafe { simd_round(self) }\n+    }\n+\n+    /// Returns the floating point's integer value, with its fractional part removed.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    #[inline]\n+    fn trunc(self) -> Self {\n+        unsafe { simd_trunc(self) }\n+    }\n+\n+    /// Returns the floating point's fractional value, with its integer part removed.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn fract(self) -> Self;\n+}\n+\n+impl<const N: usize> Sealed for Simd<f32, N> where LaneCount<N>: SupportedLaneCount {}\n+impl<const N: usize> Sealed for Simd<f64, N> where LaneCount<N>: SupportedLaneCount {}\n+\n+// We can safely just use all the defaults.\n+impl<const N: usize> StdFloat for Simd<f32, N>\n+where\n+    LaneCount<N>: SupportedLaneCount,\n+{\n+    /// Returns the floating point's fractional value, with its integer part removed.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    #[inline]\n+    fn fract(self) -> Self {\n+        self - self.trunc()\n+    }\n+}\n+\n+impl<const N: usize> StdFloat for Simd<f64, N>\n+where\n+    LaneCount<N>: SupportedLaneCount,\n+{\n+    /// Returns the floating point's fractional value, with its integer part removed.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    #[inline]\n+    fn fract(self) -> Self {\n+        self - self.trunc()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use simd::*;\n+\n+    #[test]\n+    fn everything_works() {\n+        let x = f32x4::from_array([0.1, 0.5, 0.6, -1.5]);\n+        let x2 = x + x;\n+        let _xc = x.ceil();\n+        let _xf = x.floor();\n+        let _xr = x.round();\n+        let _xt = x.trunc();\n+        let _xfma = x.mul_add(x, x);\n+        let _xsqrt = x.sqrt();\n+        let _ = x2.abs() * x2;\n+    }\n+}"}]}