{"sha": "1afdc579297f68dadbe8ee580040ec6ca95cc58b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhZmRjNTc5Mjk3ZjY4ZGFkYmU4ZWU1ODAwNDBlYzZjYTk1Y2M1OGI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-16T23:06:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-16T23:06:23Z"}, "message": "Merge #4489\n\n4489: Memory allocation optimization r=matklad a=simonvandel\n\nI did some profiling using DHAT, and this was what I could easily optimize without much knowledge of the codebase.\r\n\r\nThis speeds up analysis-stats on rust-analyser by ~4% on my local machine.\r\n\r\n**Benchmark**\r\n\u279c  rust-analyzer-base git:(master) hyperfine --min-runs=2 '/home/simon/Documents/rust-analyzer/target/release/rust-analyzer analysis-stats .' '/home/simon/Documents/rust-analyzer-base/target/release/rust-analyzer analysis-stats .'\r\nBenchmark #1: /home/simon/Documents/rust-analyzer/target/release/rust-analyzer analysis-stats .\r\n  Time (mean \u00b1 \u03c3):     49.621 s \u00b1  0.317 s    [User: 48.725 s, System: 0.792 s]\r\n  Range (min \u2026 max):   49.397 s \u2026 49.846 s    2 runs\r\n \r\nBenchmark #2: /home/simon/Documents/rust-analyzer-base/target/release/rust-analyzer analysis-stats .\r\n  Time (mean \u00b1 \u03c3):     51.764 s \u00b1  0.045 s    [User: 50.882 s, System: 0.756 s]\r\n  Range (min \u2026 max):   51.733 s \u2026 51.796 s    2 runs\r\n \r\nSummary\r\n  '/home/simon/Documents/rust-analyzer/target/release/rust-analyzer analysis-stats .' ran\r\n    1.04 \u00b1 0.01 times faster than '/home/simon/Documents/rust-analyzer-base/target/release/rust-analyzer analysis-stats .'\n\nCo-authored-by: Simon Vandel Sillesen <simon.vandel@gmail.com>", "tree": {"sha": "478b8f648fed106b71ea455410be08707dfac4f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/478b8f648fed106b71ea455410be08707dfac4f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1afdc579297f68dadbe8ee580040ec6ca95cc58b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJewHHvCRBK7hj4Ov3rIwAAdHIIAEUgXcrK9cjWX4oIUgWKskf5\nCR7CbHboMdRO1kgHAGlO3eyt/vCDMrrR9PFi+rncE4ihLN0VI2WXenfyOlUgvDzN\nGlPB5r+ap2+T1arwYELOR42hcS5IANWJulOCHWQ0lGoNSMiEh4z3cqmzQ2BSLPGq\n5l+1sNek222CHGfPDA8Ni9nLXtvlws13yOiNCaaYQMdy+TERrIpX0hloqLlgqdkK\nqCI/VpdOBatpUjXcx9ILic9H/43sCTx49RwoPFfNq2R3dAx8u2fUNEA/i2CEF89X\nNyhQTmSG3cGH6azviwE6krwgt6QYUFrq5EYA3d9BGgcr4yEKCHNBG1pzJ/AS80o=\n=gmwf\n-----END PGP SIGNATURE-----\n", "payload": "tree 478b8f648fed106b71ea455410be08707dfac4f2\nparent 8944a9b35a71c58d2ed903fb2b29dfeeb10d29cd\nparent 1e9172d70cf714dc006c1cbc4a029ae6e848d35b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1589670383 +0000\ncommitter GitHub <noreply@github.com> 1589670383 +0000\n\nMerge #4489\n\n4489: Memory allocation optimization r=matklad a=simonvandel\n\nI did some profiling using DHAT, and this was what I could easily optimize without much knowledge of the codebase.\r\n\r\nThis speeds up analysis-stats on rust-analyser by ~4% on my local machine.\r\n\r\n**Benchmark**\r\n\u279c  rust-analyzer-base git:(master) hyperfine --min-runs=2 '/home/simon/Documents/rust-analyzer/target/release/rust-analyzer analysis-stats .' '/home/simon/Documents/rust-analyzer-base/target/release/rust-analyzer analysis-stats .'\r\nBenchmark #1: /home/simon/Documents/rust-analyzer/target/release/rust-analyzer analysis-stats .\r\n  Time (mean \u00b1 \u03c3):     49.621 s \u00b1  0.317 s    [User: 48.725 s, System: 0.792 s]\r\n  Range (min \u2026 max):   49.397 s \u2026 49.846 s    2 runs\r\n \r\nBenchmark #2: /home/simon/Documents/rust-analyzer-base/target/release/rust-analyzer analysis-stats .\r\n  Time (mean \u00b1 \u03c3):     51.764 s \u00b1  0.045 s    [User: 50.882 s, System: 0.756 s]\r\n  Range (min \u2026 max):   51.733 s \u2026 51.796 s    2 runs\r\n \r\nSummary\r\n  '/home/simon/Documents/rust-analyzer/target/release/rust-analyzer analysis-stats .' ran\r\n    1.04 \u00b1 0.01 times faster than '/home/simon/Documents/rust-analyzer-base/target/release/rust-analyzer analysis-stats .'\n\nCo-authored-by: Simon Vandel Sillesen <simon.vandel@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1afdc579297f68dadbe8ee580040ec6ca95cc58b", "html_url": "https://github.com/rust-lang/rust/commit/1afdc579297f68dadbe8ee580040ec6ca95cc58b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1afdc579297f68dadbe8ee580040ec6ca95cc58b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8944a9b35a71c58d2ed903fb2b29dfeeb10d29cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8944a9b35a71c58d2ed903fb2b29dfeeb10d29cd", "html_url": "https://github.com/rust-lang/rust/commit/8944a9b35a71c58d2ed903fb2b29dfeeb10d29cd"}, {"sha": "1e9172d70cf714dc006c1cbc4a029ae6e848d35b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e9172d70cf714dc006c1cbc4a029ae6e848d35b", "html_url": "https://github.com/rust-lang/rust/commit/1e9172d70cf714dc006c1cbc4a029ae6e848d35b"}], "stats": {"total": 43, "additions": 27, "deletions": 16}, "files": [{"sha": "7c9bb4d00e1a2f5f4d036eaa53393c8a5b77a7a9", "filename": "crates/ra_mbe/src/mbe_expander/transcriber.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1afdc579297f68dadbe8ee580040ec6ca95cc58b/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1afdc579297f68dadbe8ee580040ec6ca95cc58b/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs?ref=1afdc579297f68dadbe8ee580040ec6ca95cc58b", "patch": "@@ -1,4 +1,4 @@\n-//! Transcraber takes a template, like `fn $ident() {}`, a set of bindings like\n+//! Transcriber takes a template, like `fn $ident() {}`, a set of bindings like\n //! `$ident => foo`, interpolates variables in the template, to get `fn foo() {}`\n \n use ra_syntax::SmolStr;\n@@ -53,7 +53,8 @@ impl Bindings {\n pub(super) fn transcribe(template: &tt::Subtree, bindings: &Bindings) -> ExpandResult<tt::Subtree> {\n     assert!(template.delimiter == None);\n     let mut ctx = ExpandCtx { bindings: &bindings, nesting: Vec::new() };\n-    expand_subtree(&mut ctx, template)\n+    let mut arena: Vec<tt::TokenTree> = Vec::new();\n+    expand_subtree(&mut ctx, template, &mut arena)\n }\n \n #[derive(Debug)]\n@@ -73,8 +74,13 @@ struct ExpandCtx<'a> {\n     nesting: Vec<NestingState>,\n }\n \n-fn expand_subtree(ctx: &mut ExpandCtx, template: &tt::Subtree) -> ExpandResult<tt::Subtree> {\n-    let mut buf: Vec<tt::TokenTree> = Vec::new();\n+fn expand_subtree(\n+    ctx: &mut ExpandCtx,\n+    template: &tt::Subtree,\n+    arena: &mut Vec<tt::TokenTree>,\n+) -> ExpandResult<tt::Subtree> {\n+    // remember how many elements are in the arena now - when returning, we want to drain exactly how many elements we added. This way, the recursive uses of the arena get their own \"view\" of the arena, but will reuse the allocation\n+    let start_elements = arena.len();\n     let mut err = None;\n     for op in parse_template(template) {\n         let op = match op {\n@@ -85,25 +91,27 @@ fn expand_subtree(ctx: &mut ExpandCtx, template: &tt::Subtree) -> ExpandResult<t\n             }\n         };\n         match op {\n-            Op::TokenTree(tt @ tt::TokenTree::Leaf(..)) => buf.push(tt.clone()),\n+            Op::TokenTree(tt @ tt::TokenTree::Leaf(..)) => arena.push(tt.clone()),\n             Op::TokenTree(tt::TokenTree::Subtree(tt)) => {\n-                let ExpandResult(tt, e) = expand_subtree(ctx, tt);\n+                let ExpandResult(tt, e) = expand_subtree(ctx, tt, arena);\n                 err = err.or(e);\n-                buf.push(tt.into());\n+                arena.push(tt.into());\n             }\n             Op::Var { name, kind: _ } => {\n                 let ExpandResult(fragment, e) = expand_var(ctx, name);\n                 err = err.or(e);\n-                push_fragment(&mut buf, fragment);\n+                push_fragment(arena, fragment);\n             }\n             Op::Repeat { subtree, kind, separator } => {\n-                let ExpandResult(fragment, e) = expand_repeat(ctx, subtree, kind, separator);\n+                let ExpandResult(fragment, e) = expand_repeat(ctx, subtree, kind, separator, arena);\n                 err = err.or(e);\n-                push_fragment(&mut buf, fragment)\n+                push_fragment(arena, fragment)\n             }\n         }\n     }\n-    ExpandResult(tt::Subtree { delimiter: template.delimiter, token_trees: buf }, err)\n+    // drain the elements added in this instance of expand_subtree\n+    let tts = arena.drain(start_elements..arena.len()).collect();\n+    ExpandResult(tt::Subtree { delimiter: template.delimiter, token_trees: tts }, err)\n }\n \n fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr) -> ExpandResult<Fragment> {\n@@ -155,6 +163,7 @@ fn expand_repeat(\n     template: &tt::Subtree,\n     kind: RepeatKind,\n     separator: Option<Separator>,\n+    arena: &mut Vec<tt::TokenTree>,\n ) -> ExpandResult<Fragment> {\n     let mut buf: Vec<tt::TokenTree> = Vec::new();\n     ctx.nesting.push(NestingState { idx: 0, at_end: false, hit: false });\n@@ -165,7 +174,7 @@ fn expand_repeat(\n     let mut counter = 0;\n \n     loop {\n-        let ExpandResult(mut t, e) = expand_subtree(ctx, template);\n+        let ExpandResult(mut t, e) = expand_subtree(ctx, template, arena);\n         let nesting_state = ctx.nesting.last_mut().unwrap();\n         if nesting_state.at_end || !nesting_state.hit {\n             break;"}, {"sha": "eeb8ad66bd16b3df4339141b111cbf12c094f47a", "filename": "crates/ra_parser/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1afdc579297f68dadbe8ee580040ec6ca95cc58b/crates%2Fra_parser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1afdc579297f68dadbe8ee580040ec6ca95cc58b/crates%2Fra_parser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Flib.rs?ref=1afdc579297f68dadbe8ee580040ec6ca95cc58b", "patch": "@@ -25,7 +25,7 @@ pub(crate) use token_set::TokenSet;\n pub use syntax_kind::SyntaxKind;\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ParseError(pub String);\n+pub struct ParseError(pub Box<String>);\n \n /// `TokenSource` abstracts the source of the tokens parser operates on.\n ///"}, {"sha": "4f59b0a2356fe7a6ee33b7143e703176e1e93be2", "filename": "crates/ra_parser/src/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1afdc579297f68dadbe8ee580040ec6ca95cc58b/crates%2Fra_parser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1afdc579297f68dadbe8ee580040ec6ca95cc58b/crates%2Fra_parser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fparser.rs?ref=1afdc579297f68dadbe8ee580040ec6ca95cc58b", "patch": "@@ -192,7 +192,7 @@ impl<'t> Parser<'t> {\n     /// structured errors with spans and notes, like rustc\n     /// does.\n     pub(crate) fn error<T: Into<String>>(&mut self, message: T) {\n-        let msg = ParseError(message.into());\n+        let msg = ParseError(Box::new(message.into()));\n         self.push_event(Event::Error { msg })\n     }\n "}, {"sha": "e566af7e87acc2271a192c8d50b0ee0413817cad", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1afdc579297f68dadbe8ee580040ec6ca95cc58b/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1afdc579297f68dadbe8ee580040ec6ca95cc58b/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=1afdc579297f68dadbe8ee580040ec6ca95cc58b", "patch": "@@ -70,6 +70,6 @@ impl SyntaxTreeBuilder {\n     }\n \n     pub fn error(&mut self, error: ra_parser::ParseError, text_pos: TextSize) {\n-        self.errors.push(SyntaxError::new_at_offset(error.0, text_pos))\n+        self.errors.push(SyntaxError::new_at_offset(*error.0, text_pos))\n     }\n }"}, {"sha": "5967f44cd08def64eb740335f25a67f9e049985b", "filename": "crates/ra_tt/src/buffer.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1afdc579297f68dadbe8ee580040ec6ca95cc58b/crates%2Fra_tt%2Fsrc%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1afdc579297f68dadbe8ee580040ec6ca95cc58b/crates%2Fra_tt%2Fsrc%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_tt%2Fsrc%2Fbuffer.rs?ref=1afdc579297f68dadbe8ee580040ec6ca95cc58b", "patch": "@@ -42,7 +42,9 @@ impl<'t> TokenBuffer<'t> {\n         buffers: &mut Vec<Box<[Entry<'t>]>>,\n         next: Option<EntryPtr>,\n     ) -> usize {\n-        let mut entries = vec![];\n+        // Must contain everything in tokens and then the Entry::End\n+        let start_capacity = tokens.len() + 1;\n+        let mut entries = Vec::with_capacity(start_capacity);\n         let mut children = vec![];\n \n         for (idx, tt) in tokens.iter().enumerate() {"}]}