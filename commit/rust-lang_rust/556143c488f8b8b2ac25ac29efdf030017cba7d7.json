{"sha": "556143c488f8b8b2ac25ac29efdf030017cba7d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1NjE0M2M0ODhmOGI4YjJhYzI1YWMyOWVmZGYwMzAwMTdjYmE3ZDc=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-03-08T18:19:19Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-03-29T17:53:00Z"}, "message": "commenting parser", "tree": {"sha": "1be3fdba249fec2adcd10d44426080c8a7c9cf59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1be3fdba249fec2adcd10d44426080c8a7c9cf59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/556143c488f8b8b2ac25ac29efdf030017cba7d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/556143c488f8b8b2ac25ac29efdf030017cba7d7", "html_url": "https://github.com/rust-lang/rust/commit/556143c488f8b8b2ac25ac29efdf030017cba7d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/556143c488f8b8b2ac25ac29efdf030017cba7d7/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b07f0fb0018649588cda06bd33c33b71c5cac70", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b07f0fb0018649588cda06bd33c33b71c5cac70", "html_url": "https://github.com/rust-lang/rust/commit/2b07f0fb0018649588cda06bd33c33b71c5cac70"}], "stats": {"total": 54, "additions": 50, "deletions": 4}, "files": [{"sha": "ae7dd8ff96fce3bf311110d21e7a9d8f2e41d2cb", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/556143c488f8b8b2ac25ac29efdf030017cba7d7/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/556143c488f8b8b2ac25ac29efdf030017cba7d7/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=556143c488f8b8b2ac25ac29efdf030017cba7d7", "patch": "@@ -159,6 +159,9 @@ pub impl Parser {\n         }\n     }\n \n+    // if the given word is not a keyword, signal an error.\n+    // if the next token is the given keyword, eat it and return\n+    // true. Otherwise, return false.\n     fn eat_keyword(&self, word: &~str) -> bool {\n         self.require_keyword(word);\n         let is_kw = match *self.token {\n@@ -169,6 +172,9 @@ pub impl Parser {\n         is_kw\n     }\n \n+    // if the given word is not a keyword, signal an error.\n+    // if the next token is not the given word, signal an error.\n+    // otherwise, eat it.\n     fn expect_keyword(&self, word: &~str) {\n         self.require_keyword(word);\n         if !self.eat_keyword(word) {\n@@ -182,10 +188,12 @@ pub impl Parser {\n         }\n     }\n \n+    // return true if the given string is a strict keyword\n     fn is_strict_keyword(&self, word: &~str) -> bool {\n         self.strict_keywords.contains(word)\n     }\n \n+    // signal an error if the current token is a strict keyword\n     fn check_strict_keywords(&self) {\n         match *self.token {\n             token::IDENT(_, false) => {\n@@ -196,16 +204,19 @@ pub impl Parser {\n         }\n     }\n \n+    // signal an error if the given string is a strict keyword\n     fn check_strict_keywords_(&self, w: &~str) {\n         if self.is_strict_keyword(w) {\n             self.fatal(fmt!(\"found `%s` in ident position\", *w));\n         }\n     }\n \n+    // return true if this is a reserved keyword\n     fn is_reserved_keyword(&self, word: &~str) -> bool {\n         self.reserved_keywords.contains(word)\n     }\n \n+    // signal an error if the current token is a reserved keyword\n     fn check_reserved_keywords(&self) {\n         match *self.token {\n             token::IDENT(_, false) => {\n@@ -216,14 +227,16 @@ pub impl Parser {\n         }\n     }\n \n+    // signal an error if the given string is a reserved keyword\n     fn check_reserved_keywords_(&self, w: &~str) {\n         if self.is_reserved_keyword(w) {\n             self.fatal(fmt!(\"`%s` is a reserved keyword\", *w));\n         }\n     }\n \n     // expect and consume a GT. if a >> is seen, replace it\n-    // with a single > and continue.\n+    // with a single > and continue. If a GT is not seen,\n+    // signal an error.\n     fn expect_gt(&self) {\n         if *self.token == token::GT {\n             self.bump();"}, {"sha": "512b6c0ec78ebbf7b917182bf307864b1be06442", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/556143c488f8b8b2ac25ac29efdf030017cba7d7/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/556143c488f8b8b2ac25ac29efdf030017cba7d7/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=556143c488f8b8b2ac25ac29efdf030017cba7d7", "patch": "@@ -80,7 +80,8 @@ pub fn new_low_level_string_reader(span_diagnostic: @span_handler,\n         last_pos: filemap.start_pos,\n         col: CharPos(0),\n         curr: initial_char,\n-        filemap: filemap, interner: itr,\n+        filemap: filemap,\n+        interner: itr,\n         /* dummy values; not read */\n         peek_tok: token::EOF,\n         peek_span: codemap::dummy_sp()\n@@ -150,6 +151,7 @@ impl reader for TtReader {\n }\n \n // EFFECT: advance peek_tok and peek_span to refer to the next token.\n+// EFFECT: update the interner, maybe.\n fn string_advance_token(r: @mut StringReader) {\n     match (consume_whitespace_and_comments(r)) {\n         Some(comment) => {\n@@ -539,6 +541,9 @@ fn ident_continue(c: char) -> bool {\n         || (c > 'z' && char::is_XID_continue(c))\n }\n \n+// return the next token from the string\n+// EFFECT: advances the input past that token\n+// EFFECT: updates the interner\n fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n     let mut accum_str = ~\"\";\n     let mut c = rdr.curr;"}, {"sha": "ba7a9624c18951568dbacb7df12435b4b56c5b93", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/556143c488f8b8b2ac25ac29efdf030017cba7d7/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/556143c488f8b8b2ac25ac29efdf030017cba7d7/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=556143c488f8b8b2ac25ac29efdf030017cba7d7", "patch": "@@ -45,10 +45,14 @@ pub mod classify;\n /// Reporting obsolete syntax\n pub mod obsolete;\n \n+// info about a parsing session.\n+// This structure and the reader both have\n+// an interner associated with them. If they're\n+// not the same, bad things can happen.\n pub struct ParseSess {\n-    cm: @codemap::CodeMap,\n+    cm: @codemap::CodeMap, // better be the same as the one in the reader!\n     next_id: node_id,\n-    span_diagnostic: @span_handler,\n+    span_diagnostic: @span_handler, // better be the same as the one in the reader!\n     interner: @ident_interner,\n }\n "}, {"sha": "fc5254726534d3e3e9438f81b7d8f341182e36c0", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/556143c488f8b8b2ac25ac29efdf030017cba7d7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/556143c488f8b8b2ac25ac29efdf030017cba7d7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=556143c488f8b8b2ac25ac29efdf030017cba7d7", "patch": "@@ -246,6 +246,7 @@ pub fn Parser(sess: @mut ParseSess,\n     }\n }\n \n+// ooh, nasty mutable fields everywhere....\n pub struct Parser {\n     sess: @mut ParseSess,\n     cfg: crate_cfg,\n@@ -338,13 +339,15 @@ pub impl Parser {\n         self.sess.interner.get(id)\n     }\n \n+    // is this one of the keywords that signals a closure type?\n     fn token_is_closure_keyword(&self, tok: &token::Token) -> bool {\n         self.token_is_keyword(&~\"pure\", tok) ||\n             self.token_is_keyword(&~\"unsafe\", tok) ||\n             self.token_is_keyword(&~\"once\", tok) ||\n             self.token_is_keyword(&~\"fn\", tok)\n     }\n \n+    // parse a ty_bare_fun type:\n     fn parse_ty_bare_fn(&self) -> ty_\n     {\n         /*\n@@ -372,6 +375,7 @@ pub impl Parser {\n         });\n     }\n \n+    // parse a ty_closure type\n     fn parse_ty_closure(&self,\n                         sigil: ast::Sigil,\n                         region: Option<@ast::Lifetime>) -> ty_\n@@ -430,6 +434,7 @@ pub impl Parser {\n         }\n     }\n \n+    // parse a function type (following the 'fn')\n     fn parse_ty_fn_decl(&self) -> (fn_decl, OptVec<ast::Lifetime>) {\n         /*\n \n@@ -541,12 +546,14 @@ pub impl Parser {\n     }\n \n \n+    // parse a possibly mutable type\n     fn parse_mt(&self) -> mt {\n         let mutbl = self.parse_mutability();\n         let t = self.parse_ty(false);\n         mt { ty: t, mutbl: mutbl }\n     }\n \n+    // parse [mut/const/imm] ID : TY\n     fn parse_ty_field(&self) -> ty_field {\n         let lo = self.span.lo;\n         let mutbl = self.parse_mutability();\n@@ -563,6 +570,7 @@ pub impl Parser {\n         )\n     }\n \n+    // parse optional return type [ -> TY ] in function decl\n     fn parse_ret_ty(&self) -> (ret_style, @Ty) {\n         return if self.eat(&token::RARROW) {\n             let lo = self.span.lo;\n@@ -591,6 +599,7 @@ pub impl Parser {\n         }\n     }\n \n+    // parse a type.\n     // Useless second parameter for compatibility with quasiquote macros.\n     // Bleh!\n     fn parse_ty(&self, _: bool) -> @Ty {\n@@ -627,15 +636,19 @@ pub impl Parser {\n                 t\n             }\n         } else if *self.token == token::AT {\n+            // MANAGED POINTER\n             self.bump();\n             self.parse_box_or_uniq_pointee(ManagedSigil, ty_box)\n         } else if *self.token == token::TILDE {\n+            // OWNED POINTER\n             self.bump();\n             self.parse_box_or_uniq_pointee(OwnedSigil, ty_uniq)\n         } else if *self.token == token::BINOP(token::STAR) {\n+            // STAR POINTER (bare pointer?)\n             self.bump();\n             ty_ptr(self.parse_mt())\n         } else if *self.token == token::LBRACE {\n+            // STRUCTURAL RECORD (remove?)\n             let elems = self.parse_unspanned_seq(\n                 &token::LBRACE,\n                 &token::RBRACE,\n@@ -648,6 +661,7 @@ pub impl Parser {\n             self.obsolete(*self.last_span, ObsoleteRecordType);\n             ty_nil\n         } else if *self.token == token::LBRACKET {\n+            // VECTOR\n             self.expect(&token::LBRACKET);\n             let mt = self.parse_mt();\n             if mt.mutbl == m_mutbl {    // `m_const` too after snapshot\n@@ -663,16 +677,20 @@ pub impl Parser {\n             self.expect(&token::RBRACKET);\n             t\n         } else if *self.token == token::BINOP(token::AND) {\n+            // BORROWED POINTER\n             self.bump();\n             self.parse_borrowed_pointee()\n         } else if self.eat_keyword(&~\"extern\") {\n+            // EXTERN FUNCTION\n             self.parse_ty_bare_fn()\n         } else if self.token_is_closure_keyword(&copy *self.token) {\n+            // CLOSURE\n             let result = self.parse_ty_closure(ast::BorrowedSigil, None);\n             self.obsolete(*self.last_span, ObsoleteBareFnType);\n             result\n         } else if *self.token == token::MOD_SEP\n             || is_ident_or_path(&*self.token) {\n+            // NAMED TYPE\n             let path = self.parse_path_with_tps(false);\n             ty_path(path, self.get_id())\n         } else {\n@@ -881,6 +899,8 @@ pub impl Parser {\n         let global = self.eat(&token::MOD_SEP);\n         let mut ids = ~[];\n         loop {\n+            // if there's a ::< coming, stop processing\n+            // the path.\n             let is_not_last =\n                 self.look_ahead(2u) != token::LT\n                 && self.look_ahead(1u) == token::MOD_SEP;\n@@ -900,6 +920,9 @@ pub impl Parser {\n                      types: ~[] }\n     }\n \n+    // parse a path optionally with type parameters. If 'colons'\n+    // is true, then type parameters must be preceded by colons,\n+    // as in a::t::<t1,t2>\n     fn parse_path_with_tps(&self, colons: bool) -> @ast::path {\n         debug!(\"parse_path_with_tps(colons=%b)\", colons);\n \n@@ -1067,6 +1090,7 @@ pub impl Parser {\n         self.token_is_keyword(&~\"const\", tok)\n     }\n \n+    // parse mutability declaration (mut/const/imm)\n     fn parse_mutability(&self) -> mutability {\n         if self.eat_keyword(&~\"mut\") {\n             m_mutbl"}]}