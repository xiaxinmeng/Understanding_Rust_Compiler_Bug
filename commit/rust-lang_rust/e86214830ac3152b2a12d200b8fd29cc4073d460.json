{"sha": "e86214830ac3152b2a12d200b8fd29cc4073d460", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NjIxNDgzMGFjMzE1MmIyYTEyZDIwMGI4ZmQyOWNjNDA3M2Q0NjA=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-05T03:44:58Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-05T03:44:58Z"}, "message": "Make \"no implicit copies\" diagnostics controllable through lint settings. Closes #2503.", "tree": {"sha": "a9bc270d0b249e52824211cf6312d983e2520a1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9bc270d0b249e52824211cf6312d983e2520a1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e86214830ac3152b2a12d200b8fd29cc4073d460", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e86214830ac3152b2a12d200b8fd29cc4073d460", "html_url": "https://github.com/rust-lang/rust/commit/e86214830ac3152b2a12d200b8fd29cc4073d460", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e86214830ac3152b2a12d200b8fd29cc4073d460/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6396e2c3c3bedd6f6bdd55e30f064b7edccbce8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6396e2c3c3bedd6f6bdd55e30f064b7edccbce8c", "html_url": "https://github.com/rust-lang/rust/commit/6396e2c3c3bedd6f6bdd55e30f064b7edccbce8c"}], "stats": {"total": 44, "additions": 27, "deletions": 17}, "files": [{"sha": "8e77777828e2e4b5e8acbfd30d70ba9b3d4ef450", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e86214830ac3152b2a12d200b8fd29cc4073d460/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e86214830ac3152b2a12d200b8fd29cc4073d460/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=e86214830ac3152b2a12d200b8fd29cc4073d460", "patch": "@@ -9,7 +9,7 @@ import util::ppaux::{ty_to_str, tys_to_str};\n import syntax::print::pprust::expr_to_str;\n import freevars::freevar_entry;\n import dvec::extensions;\n-import lint::non_implicitly_copyable_typarams;\n+import lint::{non_implicitly_copyable_typarams,implicit_copies};\n \n // Kind analysis pass.\n //\n@@ -83,42 +83,43 @@ fn check_crate(tcx: ty::ctxt,\n     tcx.sess.abort_if_errors();\n }\n \n-type check_fn = fn@(ctx, option<@freevar_entry>, bool, ty::t, sp: span);\n+type check_fn = fn@(ctx, node_id, option<@freevar_entry>,\n+                    bool, ty::t, sp: span);\n \n // Yields the appropriate function to check the kind of closed over\n // variables. `id` is the node_id for some expression that creates the\n // closure.\n fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n-    fn check_for_uniq(cx: ctx, fv: option<@freevar_entry>, is_move: bool,\n-                      var_t: ty::t, sp: span) {\n+    fn check_for_uniq(cx: ctx, id: node_id, fv: option<@freevar_entry>,\n+                      is_move: bool, var_t: ty::t, sp: span) {\n         // all captured data must be sendable, regardless of whether it is\n         // moved in or copied in\n         check_send(cx, var_t, sp);\n \n         // copied in data must be copyable, but moved in data can be anything\n         let is_implicit = fv.is_some();\n-        if !is_move { check_copy(cx, var_t, sp, is_implicit); }\n+        if !is_move { check_copy(cx, id, var_t, sp, is_implicit); }\n \n         // check that only immutable variables are implicitly copied in\n         for fv.each { |fv|\n             check_imm_free_var(cx, fv.def, fv.span);\n         }\n     }\n \n-    fn check_for_box(cx: ctx, fv: option<@freevar_entry>, is_move: bool,\n-                     var_t: ty::t, sp: span) {\n+    fn check_for_box(cx: ctx, id: node_id, fv: option<@freevar_entry>,\n+                     is_move: bool, var_t: ty::t, sp: span) {\n         // copied in data must be copyable, but moved in data can be anything\n         let is_implicit = fv.is_some();\n-        if !is_move { check_copy(cx, var_t, sp, is_implicit); }\n+        if !is_move { check_copy(cx, id, var_t, sp, is_implicit); }\n \n         // check that only immutable variables are implicitly copied in\n         for fv.each { |fv|\n             check_imm_free_var(cx, fv.def, fv.span);\n         }\n     }\n \n-    fn check_for_block(cx: ctx, fv: option<@freevar_entry>, _is_move: bool,\n-                       _var_t: ty::t, sp: span) {\n+    fn check_for_block(cx: ctx, _id: node_id, fv: option<@freevar_entry>,\n+                       _is_move: bool, _var_t: ty::t, sp: span) {\n         // only restriction: no capture clauses (we would have to take\n         // ownership of the moved/copied in data).\n         if fv.is_none() {\n@@ -128,8 +129,8 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n         }\n     }\n \n-    fn check_for_bare(cx: ctx, _fv: option<@freevar_entry>, _is_move: bool,\n-                      _var_t: ty::t, sp: span) {\n+    fn check_for_bare(cx: ctx, _id: node_id, _fv: option<@freevar_entry>,\n+                      _is_move: bool,_var_t: ty::t, sp: span) {\n         cx.tcx.sess.span_err(sp, \"attempted dynamic environment capture\");\n     }\n \n@@ -165,7 +166,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n             let cap_def = cx.tcx.def_map.get(cap_item.id);\n             let cap_def_id = ast_util::def_id_of_def(cap_def).node;\n             let ty = ty::node_id_to_type(cx.tcx, cap_def_id);\n-            chk(cx, none, cap_item.is_move, ty, cap_item.span);\n+            chk(cx, fn_id, none, cap_item.is_move, ty, cap_item.span);\n             cap_def_id\n         };\n \n@@ -187,7 +188,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n             };\n \n             let ty = ty::node_id_to_type(cx.tcx, id);\n-            chk(cx, some(fv), is_move, ty, fv.span);\n+            chk(cx, fn_id, some(fv), is_move, ty, fv.span);\n         }\n     }\n \n@@ -377,7 +378,7 @@ fn check_copy_ex(cx: ctx, ex: @expr, implicit_copy: bool) {\n        !cx.last_use_map.contains_key(ex.id) &&\n        !is_nullary_variant(cx, ex) {\n         let ty = ty::expr_ty(cx.tcx, ex);\n-        check_copy(cx, ty, ex.span, implicit_copy);\n+        check_copy(cx, ex.id, ty, ex.span, implicit_copy);\n     }\n }\n \n@@ -410,12 +411,14 @@ fn check_imm_free_var(cx: ctx, def: def, sp: span) {\n     }\n }\n \n-fn check_copy(cx: ctx, ty: ty::t, sp: span, implicit_copy: bool) {\n+fn check_copy(cx: ctx, id: node_id, ty: ty::t, sp: span,\n+              implicit_copy: bool) {\n     let k = ty::type_kind(cx.tcx, ty);\n     if !ty::kind_can_be_copied(k) {\n         cx.tcx.sess.span_err(sp, \"copying a noncopyable value\");\n     } else if implicit_copy && !ty::kind_can_be_implicitly_copied(k) {\n-        cx.tcx.sess.span_warn(\n+        cx.tcx.sess.span_lint(\n+            implicit_copies, id, cx.current_item,\n             sp,\n             \"implicitly copying a non-implicitly-copyable value\");\n     }"}, {"sha": "d8a88819b36ac99f35fd38263201ed8595db1737", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e86214830ac3152b2a12d200b8fd29cc4073d460/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e86214830ac3152b2a12d200b8fd29cc4073d460/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=e86214830ac3152b2a12d200b8fd29cc4073d460", "patch": "@@ -46,6 +46,7 @@ enum lint {\n     unrecognized_warning,\n     non_implicitly_copyable_typarams,\n     vecs_not_implicitly_copyable,\n+    implicit_copies,\n }\n \n // This is pretty unfortunate. We really want some sort of \"deriving Enum\"\n@@ -60,6 +61,7 @@ fn int_to_lint(i: int) -> lint {\n       5 { unrecognized_warning }\n       6 { non_implicitly_copyable_typarams }\n       7 { vecs_not_implicitly_copyable }\n+      8 { implicit_copies }\n     }\n }\n \n@@ -118,6 +120,11 @@ fn get_lint_dict() -> lint_dict {\n          @{lint: vecs_not_implicitly_copyable,\n            desc: \"make vecs and strs not implicitly copyable\\\n                   ('err' is ignored; only checked at top level\",\n+           default: warn}),\n+\n+        (\"implicit_copies\",\n+         @{lint: implicit_copies,\n+           desc: \"implicit copies of non implicitly copyable data\",\n            default: warn})\n \n     ];"}]}