{"sha": "d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1MTAwMmNlMDc4YzVkZThkNDllNzAwYjNjMjJjOWMzY2M4NGZmOTQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-18T23:52:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-06-18T23:52:10Z"}, "message": "Rollup merge of #61898 - petrochenkov:sekind, r=eddyb\n\nsyntax: Factor out common fields from `SyntaxExtension` variants\n\nAnd some other related cleanups.\n\nContinuation of https://github.com/rust-lang/rust/pull/61606.\nThis will also help to unblock https://github.com/rust-lang/rust/pull/61877.", "tree": {"sha": "a1ad2f138f5c3bf5f37c396b4d974e4ea3eca0dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1ad2f138f5c3bf5f37c396b4d974e4ea3eca0dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdCXkqCRBK7hj4Ov3rIwAAdHIIABSD4EvNc1+h+t3L+H1zTMK5\nvX/nER8SYr4G1My2NkKFcLl/Ae/j9zuFMm77ZMN1t64HdG5lvIT9P0HUQ18eqLEa\neCBmzI0AIrSeqvrNVCxFMwi4+cVRDLsyxaZfEfdQQes0Oev+0FbKlvqcSQN0o00+\n0a+f+PUMCK2ZvAhQ3XhFKjN4vmp5zKpOC1JurtBVA94YEi2uzGbtoZ6e5wKPkhhO\n9SmvwjYQcE0jRV0QExNySTbd3rBmL9B3+zWGXSnt1mO0BGYpvcMqKNMKJoDO2ZNt\nl4abcTBJnfLzNni7ASuYP5tsNbQ4yKSOwlJPE4iqP6NnNsBJ8j0xPgxVBMjero8=\n=oACy\n-----END PGP SIGNATURE-----\n", "payload": "tree a1ad2f138f5c3bf5f37c396b4d974e4ea3eca0dd\nparent dcd5b20177f7b8408ccc42869e9151f7cfd45686\nparent e152554e11ff44b1a08e21a8416e1fc18504764e\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1560901930 +0200\ncommitter GitHub <noreply@github.com> 1560901930 +0200\n\nRollup merge of #61898 - petrochenkov:sekind, r=eddyb\n\nsyntax: Factor out common fields from `SyntaxExtension` variants\n\nAnd some other related cleanups.\n\nContinuation of https://github.com/rust-lang/rust/pull/61606.\nThis will also help to unblock https://github.com/rust-lang/rust/pull/61877.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "html_url": "https://github.com/rust-lang/rust/commit/d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcd5b20177f7b8408ccc42869e9151f7cfd45686", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcd5b20177f7b8408ccc42869e9151f7cfd45686", "html_url": "https://github.com/rust-lang/rust/commit/dcd5b20177f7b8408ccc42869e9151f7cfd45686"}, {"sha": "e152554e11ff44b1a08e21a8416e1fc18504764e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e152554e11ff44b1a08e21a8416e1fc18504764e", "html_url": "https://github.com/rust-lang/rust/commit/e152554e11ff44b1a08e21a8416e1fc18504764e"}], "stats": {"total": 892, "additions": 379, "deletions": 513}, "files": [{"sha": "0e38e2865d89372c53e6489dda43924efe03727d", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -132,7 +132,7 @@ The advantages over a simple `fn(&str) -> u32` are:\n In addition to procedural macros, you can define new\n [`derive`](../../reference/attributes/derive.md)-like attributes and other kinds\n of extensions.  See `Registry::register_syntax_extension` and the\n-`SyntaxExtension` enum.  For a more involved macro example, see\n+`SyntaxExtension` struct.  For a more involved macro example, see\n [`regex_macros`](https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs).\n \n "}, {"sha": "d2b8c4729a42a2b6c489b57f5f1b2deead9fd89e", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -62,14 +62,14 @@ use syntax::errors;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::print::pprust;\n use syntax::ptr::P;\n-use syntax::source_map::{self, respan, CompilerDesugaringKind, Spanned};\n+use syntax::source_map::{self, respan, ExpnInfo, CompilerDesugaringKind, Spanned};\n use syntax::source_map::CompilerDesugaringKind::IfTemporary;\n use syntax::std_inject;\n use syntax::symbol::{kw, sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::{self, Token};\n use syntax::visit::{self, Visitor};\n-use syntax_pos::{DUMMY_SP, edition, Span};\n+use syntax_pos::{DUMMY_SP, Span};\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n@@ -142,6 +142,9 @@ pub struct LoweringContext<'a> {\n     current_hir_id_owner: Vec<(DefIndex, u32)>,\n     item_local_id_counters: NodeMap<u32>,\n     node_id_to_hir_id: IndexVec<NodeId, hir::HirId>,\n+\n+    allow_try_trait: Option<Lrc<[Symbol]>>,\n+    allow_gen_future: Option<Lrc<[Symbol]>>,\n }\n \n pub trait Resolver {\n@@ -267,6 +270,8 @@ pub fn lower_crate(\n         lifetimes_to_define: Vec::new(),\n         is_collecting_in_band_lifetimes: false,\n         in_scope_lifetimes: Vec::new(),\n+        allow_try_trait: Some([sym::try_trait][..].into()),\n+        allow_gen_future: Some([sym::gen_future][..].into()),\n     }.lower_crate(krate)\n }\n \n@@ -848,14 +853,10 @@ impl<'a> LoweringContext<'a> {\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n     ) -> Span {\n         let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(source_map::ExpnInfo {\n-            call_site: span,\n+        mark.set_expn_info(ExpnInfo {\n             def_site: Some(span),\n-            format: source_map::CompilerDesugaring(reason),\n             allow_internal_unstable,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: edition::Edition::from_session(),\n+            ..ExpnInfo::default(source_map::CompilerDesugaring(reason), span, self.sess.edition())\n         });\n         span.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n     }\n@@ -1156,7 +1157,7 @@ impl<'a> LoweringContext<'a> {\n         let unstable_span = self.mark_span_with_reason(\n             CompilerDesugaringKind::Async,\n             span,\n-            Some(vec![sym::gen_future].into()),\n+            self.allow_gen_future.clone(),\n         );\n         let gen_future = self.expr_std_path(\n             unstable_span, &[sym::future, sym::from_generator], None, ThinVec::new());\n@@ -4382,7 +4383,7 @@ impl<'a> LoweringContext<'a> {\n                     let unstable_span = this.mark_span_with_reason(\n                         CompilerDesugaringKind::TryBlock,\n                         body.span,\n-                        Some(vec![sym::try_trait].into()),\n+                        this.allow_try_trait.clone(),\n                     );\n                     let mut block = this.lower_block(body, true).into_inner();\n                     let tail = block.expr.take().map_or_else(\n@@ -4968,13 +4969,13 @@ impl<'a> LoweringContext<'a> {\n                 let unstable_span = self.mark_span_with_reason(\n                     CompilerDesugaringKind::QuestionMark,\n                     e.span,\n-                    Some(vec![sym::try_trait].into()),\n+                    self.allow_try_trait.clone(),\n                 );\n                 let try_span = self.sess.source_map().end_point(e.span);\n                 let try_span = self.mark_span_with_reason(\n                     CompilerDesugaringKind::QuestionMark,\n                     try_span,\n-                    Some(vec![sym::try_trait].into()),\n+                    self.allow_try_trait.clone(),\n                 );\n \n                 // `Try::into_result(<expr>)`\n@@ -5776,7 +5777,7 @@ impl<'a> LoweringContext<'a> {\n         let gen_future_span = self.mark_span_with_reason(\n             CompilerDesugaringKind::Await,\n             await_span,\n-            Some(vec![sym::gen_future].into()),\n+            self.allow_gen_future.clone(),\n         );\n \n         // let mut pinned = <expr>;"}, {"sha": "9430661f75ab79b3d19878c147a161a33c55c556", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -391,10 +391,17 @@ impl_stable_hash_for!(enum ::syntax::ast::MetaItemKind {\n     NameValue(lit)\n });\n \n+impl_stable_hash_for!(enum ::syntax_pos::hygiene::Transparency {\n+    Transparent,\n+    SemiTransparent,\n+    Opaque,\n+});\n+\n impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnInfo {\n     call_site,\n-    def_site,\n     format,\n+    def_site,\n+    default_transparency,\n     allow_internal_unstable,\n     allow_internal_unsafe,\n     local_inner_macros,"}, {"sha": "d402b0ddf6e85f3be4a3fb18c3ca159ab0a3724b", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -19,7 +19,7 @@ use syntax::{\n     mut_visit::{self, MutVisitor},\n     parse::ParseSess,\n     ptr::P,\n-    symbol::{kw, sym, Symbol}\n+    symbol::{kw, sym}\n };\n use syntax_pos::Span;\n \n@@ -58,11 +58,10 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n     fn flat_map_item(&mut self, item: P<Item>) -> SmallVec<[P<Item>; 1]> {\n         debug!(\"in submodule {}\", self.in_submod);\n \n-        let name = if attr::contains_name(&item.attrs, sym::global_allocator) {\n-            \"global_allocator\"\n-        } else {\n+        if !attr::contains_name(&item.attrs, sym::global_allocator) {\n             return mut_visit::noop_flat_map_item(item, self);\n-        };\n+        }\n+\n         match item.node {\n             ItemKind::Static(..) => {}\n             _ => {\n@@ -87,15 +86,9 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n \n         // Create a fresh Mark for the new macro expansion we are about to do\n         let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(ExpnInfo {\n-            call_site: item.span, // use the call site of the static\n-            def_site: None,\n-            format: MacroAttribute(Symbol::intern(name)),\n-            allow_internal_unstable: Some(vec![sym::rustc_attrs].into()),\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: self.sess.edition,\n-        });\n+        mark.set_expn_info(ExpnInfo::with_unstable(\n+            MacroAttribute(sym::global_allocator), item.span, self.sess.edition, &[sym::rustc_attrs]\n+        ));\n \n         // Tie the span to the macro expansion info we just created\n         let span = item.span.with_ctxt(SyntaxContext::empty().apply_mark(mark));"}, {"sha": "df0957254cc093fc2340954b3916ee98ff529e2c", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -26,7 +26,7 @@ use std::{cmp, fs};\n \n use syntax::ast;\n use syntax::attr;\n-use syntax::ext::base::SyntaxExtension;\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::symbol::{Symbol, sym};\n use syntax::visit;\n use syntax::{span_err, span_fatal};\n@@ -611,33 +611,31 @@ impl<'a> CrateLoader<'a> {\n         };\n \n         let extensions = decls.iter().map(|&decl| {\n-            match decl {\n+            let (name, kind, helper_attrs) = match decl {\n                 ProcMacro::CustomDerive { trait_name, attributes, client } => {\n-                    let attrs = attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n-                    (trait_name, SyntaxExtension::Derive(\n-                        Box::new(ProcMacroDerive {\n-                            client,\n-                            attrs: attrs.clone(),\n-                        }),\n-                        attrs,\n-                        root.edition,\n-                    ))\n+                    let helper_attrs =\n+                        attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n+                    (\n+                        trait_name,\n+                        SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive {\n+                            client, attrs: helper_attrs.clone()\n+                        })),\n+                        helper_attrs,\n+                    )\n                 }\n-                ProcMacro::Attr { name, client } => {\n-                    (name, SyntaxExtension::Attr(\n-                        Box::new(AttrProcMacro { client }),\n-                        root.edition,\n-                    ))\n-                }\n-                ProcMacro::Bang { name, client } => {\n-                    (name, SyntaxExtension::Bang {\n-                        expander: Box::new(BangProcMacro { client }),\n-                        allow_internal_unstable: None,\n-                        edition: root.edition,\n-                    })\n-                }\n-            }\n-        }).map(|(name, ext)| (Symbol::intern(name), Lrc::new(ext))).collect();\n+                ProcMacro::Attr { name, client } => (\n+                    name, SyntaxExtensionKind::Attr(Box::new(AttrProcMacro { client })), Vec::new()\n+                ),\n+                ProcMacro::Bang { name, client } => (\n+                    name, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })), Vec::new()\n+                )\n+            };\n+\n+            (Symbol::intern(name), Lrc::new(SyntaxExtension {\n+                helper_attrs,\n+                ..SyntaxExtension::default(kind, root.edition)\n+            }))\n+        }).collect();\n \n         // Intentionally leak the dynamic library. We can't ever unload it\n         // since the library can make things that will live arbitrarily long."}, {"sha": "04a9c4e9a1a11c1083f8d50778965b80c65f6521", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -30,9 +30,11 @@ use syntax::ast;\n use syntax::attr;\n use syntax::source_map;\n use syntax::edition::Edition;\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n use syntax::symbol::{Symbol, sym};\n+use syntax_ext::proc_macro_impl::BangProcMacro;\n use syntax_pos::{Span, NO_EXPANSION, FileName};\n use rustc_data_structures::bit_set::BitSet;\n \n@@ -427,14 +429,11 @@ impl cstore::CStore {\n         if let Some(ref proc_macros) = data.proc_macros {\n             return LoadedMacro::ProcMacro(proc_macros[id.index.to_proc_macro_index()].1.clone());\n         } else if data.name == sym::proc_macro && data.item_name(id.index) == sym::quote {\n-            use syntax::ext::base::SyntaxExtension;\n-            use syntax_ext::proc_macro_impl::BangProcMacro;\n-\n             let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n-            let ext = SyntaxExtension::Bang {\n-                expander: Box::new(BangProcMacro { client }),\n-                allow_internal_unstable: Some(vec![sym::proc_macro_def_site].into()),\n-                edition: data.root.edition,\n+            let kind = SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client }));\n+            let ext = SyntaxExtension {\n+                allow_internal_unstable: Some([sym::proc_macro_def_site][..].into()),\n+                ..SyntaxExtension::default(kind, data.root.edition)\n             };\n             return LoadedMacro::ProcMacro(Lrc::new(ext));\n         }"}, {"sha": "6a5f62aec1537f35fd5a7d43c0630ae28b78d241", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -509,8 +509,9 @@ impl<'a, 'tcx> CrateMetadata {\n         if !self.is_proc_macro(index) {\n             self.entry(index).kind.def_kind()\n         } else {\n-            let kind = self.proc_macros.as_ref().unwrap()[index.to_proc_macro_index()].1.kind();\n-            Some(DefKind::Macro(kind))\n+            Some(DefKind::Macro(\n+                self.proc_macros.as_ref().unwrap()[index.to_proc_macro_index()].1.macro_kind()\n+            ))\n         }\n     }\n \n@@ -737,7 +738,7 @@ impl<'a, 'tcx> CrateMetadata {\n             if id == CRATE_DEF_INDEX {\n                 for (id, &(name, ref ext)) in proc_macros.iter().enumerate() {\n                     let res = Res::Def(\n-                        DefKind::Macro(ext.kind()),\n+                        DefKind::Macro(ext.macro_kind()),\n                         self.local_def_id(DefIndex::from_proc_macro_index(id)),\n                     );\n                     let ident = Ident::with_empty_ctxt(name);"}, {"sha": "16d484e2a98f2e699edc0078c41c61bdd1972544", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -4,9 +4,8 @@ use rustc::lint::{EarlyLintPassObject, LateLintPassObject, LintId, Lint};\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n \n-use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension};\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind, NamedSyntaxExtension};\n use syntax::ext::base::MacroExpanderFn;\n-use syntax::ext::hygiene::Transparency;\n use syntax::symbol::{Symbol, sym};\n use syntax::ast;\n use syntax::feature_gate::AttributeType;\n@@ -89,28 +88,21 @@ impl<'a> Registry<'a> {\n         if name == sym::macro_rules {\n             panic!(\"user-defined macros may not be named `macro_rules`\");\n         }\n-        if let SyntaxExtension::LegacyBang { def_info: ref mut def_info @ None, .. } = extension {\n-            *def_info = Some((ast::CRATE_NODE_ID, self.krate_span));\n+        if extension.def_info.is_none() {\n+            extension.def_info = Some((ast::CRATE_NODE_ID, self.krate_span));\n         }\n         self.syntax_exts.push((name, extension));\n     }\n \n     /// Register a macro of the usual kind.\n     ///\n     /// This is a convenience wrapper for `register_syntax_extension`.\n-    /// It builds for you a `SyntaxExtension::LegacyBang` that calls `expander`,\n+    /// It builds for you a `SyntaxExtensionKind::LegacyBang` that calls `expander`,\n     /// and also takes care of interning the macro's name.\n     pub fn register_macro(&mut self, name: &str, expander: MacroExpanderFn) {\n-        self.register_syntax_extension(Symbol::intern(name), SyntaxExtension::LegacyBang {\n-            expander: Box::new(expander),\n-            def_info: None,\n-            transparency: Transparency::SemiTransparent,\n-            allow_internal_unstable: None,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            unstable_feature: None,\n-            edition: self.sess.edition(),\n-        });\n+        let kind = SyntaxExtensionKind::LegacyBang(Box::new(expander));\n+        let ext = SyntaxExtension::default(kind, self.sess.edition());\n+        self.register_syntax_extension(Symbol::intern(name), ext);\n     }\n \n     /// Register a compiler lint pass."}, {"sha": "616728d5418483a01364b5cdb1d37db32cf1b274", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -772,9 +772,8 @@ impl<'a> Resolver<'a> {\n     pub fn get_macro(&mut self, res: Res) -> Lrc<SyntaxExtension> {\n         let def_id = match res {\n             Res::Def(DefKind::Macro(..), def_id) => def_id,\n-            Res::NonMacroAttr(attr_kind) => return Lrc::new(SyntaxExtension::NonMacroAttr {\n-                mark_used: attr_kind == NonMacroAttrKind::Tool,\n-            }),\n+            Res::NonMacroAttr(attr_kind) =>\n+                return self.non_macro_attr(attr_kind == NonMacroAttrKind::Tool),\n             _ => panic!(\"expected `DefKind::Macro` or `Res::NonMacroAttr`\"),\n         };\n         if let Some(ext) = self.macro_map.get(&def_id) {"}, {"sha": "0fbd0666ad1c13c4af4c30c955861b66c7c9656c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -41,7 +41,7 @@ use rustc_metadata::cstore::CStore;\n use syntax::source_map::SourceMap;\n use syntax::ext::hygiene::{Mark, Transparency, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n-use syntax::ext::base::SyntaxExtension;\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::base::MacroKind;\n use syntax::symbol::{Symbol, kw, sym};\n@@ -1668,6 +1668,7 @@ pub struct Resolver<'a> {\n     macro_use_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n     pub all_macros: FxHashMap<Name, Res>,\n     macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n+    non_macro_attrs: [Lrc<SyntaxExtension>; 2],\n     macro_defs: FxHashMap<Mark, DefId>,\n     local_macro_def_scopes: FxHashMap<NodeId, Module<'a>>,\n \n@@ -1941,6 +1942,10 @@ impl<'a> Resolver<'a> {\n         let mut macro_defs = FxHashMap::default();\n         macro_defs.insert(Mark::root(), root_def_id);\n \n+        let non_macro_attr = |mark_used| Lrc::new(SyntaxExtension::default(\n+            SyntaxExtensionKind::NonMacroAttr { mark_used }, session.edition()\n+        ));\n+\n         Resolver {\n             session,\n \n@@ -2014,6 +2019,7 @@ impl<'a> Resolver<'a> {\n             macro_use_prelude: FxHashMap::default(),\n             all_macros: FxHashMap::default(),\n             macro_map: FxHashMap::default(),\n+            non_macro_attrs: [non_macro_attr(false), non_macro_attr(true)],\n             invocations,\n             macro_defs,\n             local_macro_def_scopes: FxHashMap::default(),\n@@ -2030,6 +2036,10 @@ impl<'a> Resolver<'a> {\n         Default::default()\n     }\n \n+    fn non_macro_attr(&self, mark_used: bool) -> Lrc<SyntaxExtension> {\n+        self.non_macro_attrs[mark_used as usize].clone()\n+    }\n+\n     /// Runs the function on each namespace.\n     fn per_ns<F: FnMut(&mut Self, Namespace)>(&mut self, mut f: F) {\n         f(self, TypeNS);"}, {"sha": "5623016c2e5e7e988b50879cd3e73cf065ac87ba", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -114,6 +114,22 @@ fn sub_namespace_match(candidate: Option<MacroKind>, requirement: Option<MacroKi\n     candidate.is_none() || requirement.is_none() || candidate == requirement\n }\n \n+// We don't want to format a path using pretty-printing,\n+// `format!(\"{}\", path)`, because that tries to insert\n+// line-breaks and is slow.\n+fn fast_print_path(path: &ast::Path) -> String {\n+    let mut path_str = String::with_capacity(64);\n+    for (i, segment) in path.segments.iter().enumerate() {\n+        if i != 0 {\n+            path_str.push_str(\"::\");\n+        }\n+        if segment.ident.name != kw::PathRoot {\n+            path_str.push_str(&segment.ident.as_str())\n+        }\n+    }\n+    path_str\n+}\n+\n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -174,7 +190,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             krate: CrateNum::BuiltinMacros,\n             index: DefIndex::from(self.macro_map.len()),\n         };\n-        let kind = ext.kind();\n+        let kind = ext.macro_kind();\n         self.macro_map.insert(def_id, ext);\n         let binding = self.arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Res(Res::Def(DefKind::Macro(kind), def_id), false),\n@@ -209,14 +225,19 @@ impl<'a> base::Resolver for Resolver<'a> {\n         let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n         let (res, ext) = match self.resolve_macro_to_res(path, kind, &parent_scope, true, force) {\n             Ok((res, ext)) => (res, ext),\n-            Err(Determinacy::Determined) if kind == MacroKind::Attr => {\n-                // Replace unresolved attributes with used inert attributes for better recovery.\n-                return Ok(Some(Lrc::new(SyntaxExtension::NonMacroAttr { mark_used: true })));\n-            }\n+            // Replace unresolved attributes with used inert attributes for better recovery.\n+            Err(Determinacy::Determined) if kind == MacroKind::Attr =>\n+                (Res::Err, self.non_macro_attr(true)),\n             Err(determinacy) => return Err(determinacy),\n         };\n \n-        if let Res::Def(DefKind::Macro(_), def_id) = res {\n+        let format = match kind {\n+            MacroKind::Derive => format!(\"derive({})\", fast_print_path(path)),\n+            _ => fast_print_path(path),\n+        };\n+        invoc.expansion_data.mark.set_expn_info(ext.expn_info(invoc.span(), &format));\n+\n+        if let Res::Def(_, def_id) = res {\n             if after_derive {\n                 self.session.span_err(invoc.span(),\n                                       \"macro attributes must be placed before `#[derive]`\");\n@@ -226,7 +247,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 self.macro_def_scope(invoc.expansion_data.mark).normal_ancestor_id;\n             self.definitions.add_parent_module_of_macro_def(invoc.expansion_data.mark,\n                                                             normal_module_def_id);\n-            invoc.expansion_data.mark.set_default_transparency(ext.default_transparency());\n         }\n \n         Ok(Some(ext))\n@@ -241,11 +261,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn check_unused_macros(&self) {\n         for did in self.unused_macros.iter() {\n-            let id_span = match *self.macro_map[did] {\n-                SyntaxExtension::LegacyBang { def_info, .. } => def_info,\n-                _ => None,\n-            };\n-            if let Some((id, span)) = id_span {\n+            if let Some((id, span)) = self.macro_map[did].def_info {\n                 let lint = lint::builtin::UNUSED_MACROS;\n                 let msg = \"unused macro definition\";\n                 self.session.buffer_lint(lint, id, span, msg);\n@@ -585,17 +601,12 @@ impl<'a> Resolver<'a> {\n                         let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n                         match self.resolve_macro_to_res(derive, MacroKind::Derive,\n                                                         &parent_scope, true, force) {\n-                            Ok((_, ext)) => {\n-                                if let SyntaxExtension::Derive(_, helpers, _) = &*ext {\n-                                    if helpers.contains(&ident.name) {\n-                                        let binding =\n-                                            (Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n-                                            ty::Visibility::Public, derive.span, Mark::root())\n-                                            .to_name_binding(self.arenas);\n-                                        result = Ok((binding, Flags::empty()));\n-                                        break;\n-                                    }\n-                                }\n+                            Ok((_, ext)) => if ext.helper_attrs.contains(&ident.name) {\n+                                let binding = (Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n+                                               ty::Visibility::Public, derive.span, Mark::root())\n+                                               .to_name_binding(self.arenas);\n+                                result = Ok((binding, Flags::empty()));\n+                                break;\n                             }\n                             Err(Determinacy::Determined) => {}\n                             Err(Determinacy::Undetermined) =>"}, {"sha": "9259b3b5d3abb1b1ed91505ee9590550fac3616a", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -3,7 +3,7 @@\n use std::iter::once;\n \n use syntax::ast;\n-use syntax::ext::base::{MacroKind, SyntaxExtension};\n+use syntax::ext::base::MacroKind;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n \n@@ -470,18 +470,12 @@ fn build_macro(cx: &DocContext<'_>, did: DefId, name: ast::Name) -> clean::ItemE\n             })\n         }\n         LoadedMacro::ProcMacro(ext) => {\n-            let helpers = match &*ext {\n-                &SyntaxExtension::Derive(_, ref syms, ..) => { syms.clean(cx) }\n-                _ => Vec::new(),\n-            };\n-\n             clean::ProcMacroItem(clean::ProcMacro {\n-                kind: ext.kind(),\n-                helpers,\n+                kind: ext.macro_kind(),\n+                helpers: ext.helper_attrs.clean(cx),\n             })\n         }\n     }\n-\n }\n \n /// A trait's generics clause actually contains all of the predicates for all of"}, {"sha": "68b96a408294b9429aff7b525d47d575ef6355f5", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -423,7 +423,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n /// Resolves a string as a macro.\n fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n-    use syntax::ext::base::{MacroKind, SyntaxExtension};\n+    use syntax::ext::base::{MacroKind, SyntaxExtensionKind};\n     let segment = ast::PathSegment::from_ident(Ident::from_str(path_str));\n     let path = ast::Path { segments: vec![segment], span: DUMMY_SP };\n     cx.enter_resolver(|resolver| {\n@@ -433,7 +433,7 @@ fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n             if let Res::Def(DefKind::Macro(MacroKind::ProcMacroStub), _) = res {\n                 // skip proc-macro stubs, they'll cause `get_macro` to crash\n             } else {\n-                if let SyntaxExtension::LegacyBang { .. } = *resolver.get_macro(res) {\n+                if let SyntaxExtensionKind::LegacyBang(..) = resolver.get_macro(res).kind {\n                     return Some(res.map_id(|_| panic!(\"unexpected id\")));\n                 }\n             }"}, {"sha": "318a5a3a82a2e6010f9a7d1bd2d46d847eb14a2d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 88, "deletions": 86, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -15,6 +15,7 @@ use crate::tokenstream::{self, TokenStream};\n use errors::{DiagnosticBuilder, DiagnosticId};\n use smallvec::{smallvec, SmallVec};\n use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n+use syntax_pos::hygiene::{ExpnInfo, ExpnFormat};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n@@ -548,46 +549,26 @@ impl MacroKind {\n     }\n }\n \n-/// An enum representing the different kinds of syntax extensions.\n-pub enum SyntaxExtension {\n+/// A syntax extension kind.\n+pub enum SyntaxExtensionKind {\n     /// A token-based function-like macro.\n-    Bang {\n+    Bang(\n         /// An expander with signature TokenStream -> TokenStream.\n-        expander: Box<dyn ProcMacro + sync::Sync + sync::Send>,\n-        /// Whitelist of unstable features that are treated as stable inside this macro.\n-        allow_internal_unstable: Option<Lrc<[Symbol]>>,\n-        /// Edition of the crate in which this macro is defined.\n-        edition: Edition,\n-    },\n+        Box<dyn ProcMacro + sync::Sync + sync::Send>,\n+    ),\n \n     /// An AST-based function-like macro.\n-    LegacyBang {\n+    LegacyBang(\n         /// An expander with signature TokenStream -> AST.\n-        expander: Box<dyn TTMacroExpander + sync::Sync + sync::Send>,\n-        /// Some info about the macro's definition point.\n-        def_info: Option<(ast::NodeId, Span)>,\n-        /// Hygienic properties of identifiers produced by this macro.\n-        transparency: Transparency,\n-        /// Whitelist of unstable features that are treated as stable inside this macro.\n-        allow_internal_unstable: Option<Lrc<[Symbol]>>,\n-        /// Suppresses the `unsafe_code` lint for code produced by this macro.\n-        allow_internal_unsafe: bool,\n-        /// Enables the macro helper hack (`ident!(...)` -> `$crate::ident!(...)`) for this macro.\n-        local_inner_macros: bool,\n-        /// The macro's feature name and tracking issue number if it is unstable.\n-        unstable_feature: Option<(Symbol, u32)>,\n-        /// Edition of the crate in which this macro is defined.\n-        edition: Edition,\n-    },\n+        Box<dyn TTMacroExpander + sync::Sync + sync::Send>,\n+    ),\n \n     /// A token-based attribute macro.\n     Attr(\n         /// An expander with signature (TokenStream, TokenStream) -> TokenStream.\n         /// The first TokenSteam is the attribute itself, the second is the annotated item.\n         /// The produced TokenSteam replaces the input TokenSteam.\n         Box<dyn AttrProcMacro + sync::Sync + sync::Send>,\n-        /// Edition of the crate in which this macro is defined.\n-        Edition,\n     ),\n \n     /// An AST-based attribute macro.\n@@ -599,7 +580,8 @@ pub enum SyntaxExtension {\n     ),\n \n     /// A trivial attribute \"macro\" that does nothing,\n-    /// only keeps the attribute and marks it as known.\n+    /// only keeps the attribute and marks it as inert,\n+    /// thus making it ineligible for further expansion.\n     NonMacroAttr {\n         /// Suppresses the `unused_attributes` lint for this attribute.\n         mark_used: bool,\n@@ -610,10 +592,6 @@ pub enum SyntaxExtension {\n         /// An expander with signature TokenStream -> TokenStream (not yet).\n         /// The produced TokenSteam is appended to the input TokenSteam.\n         Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n-        /// Names of helper attributes registered by this macro.\n-        Vec<Symbol>,\n-        /// Edition of the crate in which this macro is defined.\n-        Edition,\n     ),\n \n     /// An AST-based derive macro.\n@@ -624,42 +602,91 @@ pub enum SyntaxExtension {\n     ),\n }\n \n+/// A struct representing a macro definition in \"lowered\" form ready for expansion.\n+pub struct SyntaxExtension {\n+    /// A syntax extension kind.\n+    pub kind: SyntaxExtensionKind,\n+    /// Some info about the macro's definition point.\n+    pub def_info: Option<(ast::NodeId, Span)>,\n+    /// Hygienic properties of spans produced by this macro by default.\n+    pub default_transparency: Transparency,\n+    /// Whitelist of unstable features that are treated as stable inside this macro.\n+    pub allow_internal_unstable: Option<Lrc<[Symbol]>>,\n+    /// Suppresses the `unsafe_code` lint for code produced by this macro.\n+    pub allow_internal_unsafe: bool,\n+    /// Enables the macro helper hack (`ident!(...)` -> `$crate::ident!(...)`) for this macro.\n+    pub local_inner_macros: bool,\n+    /// The macro's feature name and tracking issue number if it is unstable.\n+    pub unstable_feature: Option<(Symbol, u32)>,\n+    /// Names of helper attributes registered by this macro.\n+    pub helper_attrs: Vec<Symbol>,\n+    /// Edition of the crate in which this macro is defined.\n+    pub edition: Edition,\n+}\n+\n+impl SyntaxExtensionKind {\n+    /// When a syntax extension is constructed,\n+    /// its transparency can often be inferred from its kind.\n+    fn default_transparency(&self) -> Transparency {\n+        match self {\n+            SyntaxExtensionKind::Bang(..) |\n+            SyntaxExtensionKind::Attr(..) |\n+            SyntaxExtensionKind::Derive(..) |\n+            SyntaxExtensionKind::NonMacroAttr { .. } => Transparency::Opaque,\n+            SyntaxExtensionKind::LegacyBang(..) |\n+            SyntaxExtensionKind::LegacyAttr(..) |\n+            SyntaxExtensionKind::LegacyDerive(..) => Transparency::SemiTransparent,\n+        }\n+    }\n+}\n+\n impl SyntaxExtension {\n     /// Returns which kind of macro calls this syntax extension.\n-    pub fn kind(&self) -> MacroKind {\n-        match *self {\n-            SyntaxExtension::Bang { .. } |\n-            SyntaxExtension::LegacyBang { .. } => MacroKind::Bang,\n-            SyntaxExtension::Attr(..) |\n-            SyntaxExtension::LegacyAttr(..) |\n-            SyntaxExtension::NonMacroAttr { .. } => MacroKind::Attr,\n-            SyntaxExtension::Derive(..) |\n-            SyntaxExtension::LegacyDerive(..) => MacroKind::Derive,\n+    pub fn macro_kind(&self) -> MacroKind {\n+        match self.kind {\n+            SyntaxExtensionKind::Bang(..) |\n+            SyntaxExtensionKind::LegacyBang(..) => MacroKind::Bang,\n+            SyntaxExtensionKind::Attr(..) |\n+            SyntaxExtensionKind::LegacyAttr(..) |\n+            SyntaxExtensionKind::NonMacroAttr { .. } => MacroKind::Attr,\n+            SyntaxExtensionKind::Derive(..) |\n+            SyntaxExtensionKind::LegacyDerive(..) => MacroKind::Derive,\n         }\n     }\n \n-    pub fn default_transparency(&self) -> Transparency {\n-        match *self {\n-            SyntaxExtension::LegacyBang { transparency, .. } => transparency,\n-            SyntaxExtension::Bang { .. } |\n-            SyntaxExtension::Attr(..) |\n-            SyntaxExtension::Derive(..) |\n-            SyntaxExtension::NonMacroAttr { .. } => Transparency::Opaque,\n-            SyntaxExtension::LegacyAttr(..) |\n-            SyntaxExtension::LegacyDerive(..) => Transparency::SemiTransparent,\n+    /// Constructs a syntax extension with default properties.\n+    pub fn default(kind: SyntaxExtensionKind, edition: Edition) -> SyntaxExtension {\n+        SyntaxExtension {\n+            def_info: None,\n+            default_transparency: kind.default_transparency(),\n+            allow_internal_unstable: None,\n+            allow_internal_unsafe: false,\n+            local_inner_macros: false,\n+            unstable_feature: None,\n+            helper_attrs: Vec::new(),\n+            edition,\n+            kind,\n         }\n     }\n \n-    pub fn edition(&self, default_edition: Edition) -> Edition {\n-        match *self {\n-            SyntaxExtension::Bang { edition, .. } |\n-            SyntaxExtension::LegacyBang { edition, .. } |\n-            SyntaxExtension::Attr(.., edition) |\n-            SyntaxExtension::Derive(.., edition) => edition,\n-            // Unstable legacy stuff\n-            SyntaxExtension::NonMacroAttr { .. } |\n-            SyntaxExtension::LegacyAttr(..) |\n-            SyntaxExtension::LegacyDerive(..) => default_edition,\n+    fn expn_format(&self, symbol: Symbol) -> ExpnFormat {\n+        match self.kind {\n+            SyntaxExtensionKind::Bang(..) |\n+            SyntaxExtensionKind::LegacyBang(..) => ExpnFormat::MacroBang(symbol),\n+            _ => ExpnFormat::MacroAttribute(symbol),\n+        }\n+    }\n+\n+    pub fn expn_info(&self, call_site: Span, format: &str) -> ExpnInfo {\n+        ExpnInfo {\n+            call_site,\n+            format: self.expn_format(Symbol::intern(format)),\n+            def_site: self.def_info.map(|(_, span)| span),\n+            default_transparency: self.default_transparency,\n+            allow_internal_unstable: self.allow_internal_unstable.clone(),\n+            allow_internal_unsafe: self.allow_internal_unsafe,\n+            local_inner_macros: self.local_inner_macros,\n+            edition: self.edition,\n         }\n     }\n }\n@@ -699,31 +726,6 @@ impl Determinacy {\n     }\n }\n \n-pub struct DummyResolver;\n-\n-impl Resolver for DummyResolver {\n-    fn next_node_id(&mut self) -> ast::NodeId { ast::DUMMY_NODE_ID }\n-\n-    fn get_module_scope(&mut self, _id: ast::NodeId) -> Mark { Mark::root() }\n-\n-    fn resolve_dollar_crates(&mut self, _fragment: &AstFragment) {}\n-    fn visit_ast_fragment_with_placeholders(&mut self, _invoc: Mark, _fragment: &AstFragment,\n-                                            _derives: &[Mark]) {}\n-    fn add_builtin(&mut self, _ident: ast::Ident, _ext: Lrc<SyntaxExtension>) {}\n-\n-    fn resolve_imports(&mut self) {}\n-    fn resolve_macro_invocation(&mut self, _invoc: &Invocation, _invoc_id: Mark, _force: bool)\n-                                -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n-        Err(Determinacy::Determined)\n-    }\n-    fn resolve_macro_path(&mut self, _path: &ast::Path, _kind: MacroKind, _invoc_id: Mark,\n-                          _derives_in_scope: Vec<ast::Path>, _force: bool)\n-                          -> Result<Lrc<SyntaxExtension>, Determinacy> {\n-        Err(Determinacy::Determined)\n-    }\n-    fn check_unused_macros(&self) {}\n-}\n-\n #[derive(Clone)]\n pub struct ModuleData {\n     pub mod_path: Vec<ast::Ident>,"}, {"sha": "abc451c96ae0ef9f1cdc794fb08a6e6f0f42e39b", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -60,15 +60,10 @@ pub fn add_derived_markers<T>(cx: &mut ExtCtxt<'_>, span: Span, traits: &[ast::P\n     }\n     pretty_name.push(')');\n \n-    cx.current_expansion.mark.set_expn_info(ExpnInfo {\n-        call_site: span,\n-        def_site: None,\n-        format: ExpnFormat::MacroAttribute(Symbol::intern(&pretty_name)),\n-        allow_internal_unstable: Some(vec![sym::rustc_attrs, sym::structural_match].into()),\n-        allow_internal_unsafe: false,\n-        local_inner_macros: false,\n-        edition: cx.parse_sess.edition,\n-    });\n+    cx.current_expansion.mark.set_expn_info(ExpnInfo::with_unstable(\n+        ExpnFormat::MacroAttribute(Symbol::intern(&pretty_name)), span, cx.parse_sess.edition,\n+        &[sym::rustc_attrs, sym::structural_match],\n+    ));\n \n     let span = span.with_ctxt(cx.backtrace());\n     item.visit_attrs(|attrs| {"}, {"sha": "be90def0bdd2a2de5de6ba6ba916ed7498850e36", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 35, "deletions": 145, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -1,7 +1,7 @@\n use crate::ast::{self, Block, Ident, LitKind, NodeId, PatKind, Path};\n use crate::ast::{MacStmtStyle, StmtKind, ItemKind};\n use crate::attr::{self, HasAttrs};\n-use crate::source_map::{ExpnInfo, MacroBang, MacroAttribute, dummy_spanned, respan};\n+use crate::source_map::{dummy_spanned, respan};\n use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n use crate::ext::derive::{add_derived_markers, collect_derives};\n@@ -22,7 +22,6 @@ use crate::util::map_in_place::MapInPlace;\n use errors::{Applicability, FatalError};\n use smallvec::{smallvec, SmallVec};\n use syntax_pos::{Span, DUMMY_SP, FileName};\n-use syntax_pos::hygiene::ExpnFormat;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n@@ -189,23 +188,6 @@ impl AstFragmentKind {\n     }\n }\n \n-fn macro_bang_format(path: &ast::Path) -> ExpnFormat {\n-    // We don't want to format a path using pretty-printing,\n-    // `format!(\"{}\", path)`, because that tries to insert\n-    // line-breaks and is slow.\n-    let mut path_str = String::with_capacity(64);\n-    for (i, segment) in path.segments.iter().enumerate() {\n-        if i != 0 {\n-            path_str.push_str(\"::\");\n-        }\n-        if segment.ident.name != kw::PathRoot {\n-            path_str.push_str(&segment.ident.as_str())\n-        }\n-    }\n-\n-    MacroBang(Symbol::intern(&path_str))\n-}\n-\n pub struct Invocation {\n     pub kind: InvocationKind,\n     fragment_kind: AstFragmentKind,\n@@ -388,8 +370,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         derives.push(mark);\n                         let item = match self.cx.resolver.resolve_macro_path(\n                                 path, MacroKind::Derive, Mark::root(), Vec::new(), false) {\n-                            Ok(ext) => match *ext {\n-                                SyntaxExtension::LegacyDerive(..) => item_with_markers.clone(),\n+                            Ok(ext) => match ext.kind {\n+                                SyntaxExtensionKind::LegacyDerive(..) => item_with_markers.clone(),\n                                 _ => item.clone(),\n                             },\n                             _ => item.clone(),\n@@ -509,7 +491,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtension) -> Option<AstFragment> {\n         if invoc.fragment_kind == AstFragmentKind::ForeignItems &&\n            !self.cx.ecfg.macros_in_extern_enabled() {\n-            if let SyntaxExtension::NonMacroAttr { .. } = *ext {} else {\n+            if let SyntaxExtensionKind::NonMacroAttr { .. } = ext.kind {} else {\n                 emit_feature_err(&self.cx.parse_sess, sym::macros_in_extern,\n                                  invoc.span(), GateIssue::Language,\n                                  \"macro invocations in `extern {}` blocks are experimental\");\n@@ -548,34 +530,22 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             _ => unreachable!(),\n         };\n \n-        if let SyntaxExtension::NonMacroAttr { mark_used: false } = *ext {} else {\n-            // Macro attrs are always used when expanded,\n-            // non-macro attrs are considered used when the field says so.\n-            attr::mark_used(&attr);\n-        }\n-        invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n-            call_site: attr.span,\n-            def_site: None,\n-            format: MacroAttribute(Symbol::intern(&attr.path.to_string())),\n-            allow_internal_unstable: None,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: ext.edition(self.cx.parse_sess.edition),\n-        });\n-\n-        match *ext {\n-            SyntaxExtension::NonMacroAttr { .. } => {\n+        match &ext.kind {\n+            SyntaxExtensionKind::NonMacroAttr { mark_used } => {\n                 attr::mark_known(&attr);\n+                if *mark_used {\n+                    attr::mark_used(&attr);\n+                }\n                 item.visit_attrs(|attrs| attrs.push(attr));\n                 Some(invoc.fragment_kind.expect_from_annotatables(iter::once(item)))\n             }\n-            SyntaxExtension::LegacyAttr(ref mac) => {\n+            SyntaxExtensionKind::LegacyAttr(expander) => {\n                 let meta = attr.parse_meta(self.cx.parse_sess)\n                                .map_err(|mut e| { e.emit(); }).ok()?;\n-                let item = mac.expand(self.cx, attr.span, &meta, item);\n+                let item = expander.expand(self.cx, attr.span, &meta, item);\n                 Some(invoc.fragment_kind.expect_from_annotatables(item))\n             }\n-            SyntaxExtension::Attr(ref mac, ..) => {\n+            SyntaxExtensionKind::Attr(expander) => {\n                 self.gate_proc_macro_attr_item(attr.span, &item);\n                 let item_tok = TokenTree::token(token::Interpolated(Lrc::new(match item {\n                     Annotatable::Item(item) => token::NtItem(item),\n@@ -586,13 +556,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     Annotatable::Expr(expr) => token::NtExpr(expr),\n                 })), DUMMY_SP).into();\n                 let input = self.extract_proc_macro_attr_input(attr.tokens, attr.span);\n-                let tok_result = mac.expand(self.cx, attr.span, input, item_tok);\n+                let tok_result = expander.expand(self.cx, attr.span, input, item_tok);\n                 let res = self.parse_ast_fragment(tok_result, invoc.fragment_kind,\n                                                   &attr.path, attr.span);\n                 self.gate_proc_macro_expansion(attr.span, &res);\n                 res\n             }\n-            SyntaxExtension::Derive(..) | SyntaxExtension::LegacyDerive(..) => {\n+            SyntaxExtensionKind::Derive(..) | SyntaxExtensionKind::LegacyDerive(..) => {\n                 self.cx.span_err(attr.span, &format!(\"`{}` is a derive macro\", attr.path));\n                 self.cx.trace_macros_diag();\n                 invoc.fragment_kind.dummy(attr.span)\n@@ -693,29 +663,21 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                          invoc: Invocation,\n                          ext: &SyntaxExtension)\n                          -> Option<AstFragment> {\n-        let (mark, kind) = (invoc.expansion_data.mark, invoc.fragment_kind);\n+        let kind = invoc.fragment_kind;\n         let (mac, ident, span) = match invoc.kind {\n             InvocationKind::Bang { mac, ident, span } => (mac, ident, span),\n             _ => unreachable!(),\n         };\n         let path = &mac.node.path;\n \n         let ident = ident.unwrap_or_else(|| Ident::invalid());\n-        let validate_and_set_expn_info = |this: &mut Self, // arg instead of capture\n-                                          def_site_span: Option<Span>,\n-                                          allow_internal_unstable,\n-                                          allow_internal_unsafe,\n-                                          local_inner_macros,\n-                                          // can't infer this type\n-                                          unstable_feature: Option<(Symbol, u32)>,\n-                                          edition| {\n-\n+        let validate = |this: &mut Self| {\n             // feature-gate the macro invocation\n-            if let Some((feature, issue)) = unstable_feature {\n+            if let Some((feature, issue)) = ext.unstable_feature {\n                 let crate_span = this.cx.current_expansion.crate_span.unwrap();\n                 // don't stability-check macros in the same crate\n                 // (the only time this is null is for syntax extensions registered as macros)\n-                if def_site_span.map_or(false, |def_span| !crate_span.contains(def_span))\n+                if ext.def_info.map_or(false, |(_, def_span)| !crate_span.contains(def_span))\n                     && !span.allows_unstable(feature)\n                     && this.cx.ecfg.features.map_or(true, |feats| {\n                     // macro features will count as lib features\n@@ -734,62 +696,39 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 this.cx.trace_macros_diag();\n                 return Err(kind.dummy(span));\n             }\n-            mark.set_expn_info(ExpnInfo {\n-                call_site: span,\n-                def_site: def_site_span,\n-                format: macro_bang_format(path),\n-                allow_internal_unstable,\n-                allow_internal_unsafe,\n-                local_inner_macros,\n-                edition,\n-            });\n             Ok(())\n         };\n \n-        let opt_expanded = match *ext {\n-            SyntaxExtension::LegacyBang {\n-                ref expander,\n-                def_info,\n-                ref allow_internal_unstable,\n-                allow_internal_unsafe,\n-                local_inner_macros,\n-                unstable_feature,\n-                edition,\n-                ..\n-            } => {\n-                if let Err(dummy_span) = validate_and_set_expn_info(self, def_info.map(|(_, s)| s),\n-                                                                    allow_internal_unstable.clone(),\n-                                                                    allow_internal_unsafe,\n-                                                                    local_inner_macros,\n-                                                                    unstable_feature,\n-                                                                    edition) {\n+        let opt_expanded = match &ext.kind {\n+            SyntaxExtensionKind::LegacyBang(expander) => {\n+                if let Err(dummy_span) = validate(self) {\n                     dummy_span\n                 } else {\n                     kind.make_from(expander.expand(\n                         self.cx,\n                         span,\n                         mac.node.stream(),\n-                        def_info.map(|(_, s)| s),\n+                        ext.def_info.map(|(_, s)| s),\n                     ))\n                 }\n             }\n \n-            SyntaxExtension::Attr(..) |\n-            SyntaxExtension::LegacyAttr(..) |\n-            SyntaxExtension::NonMacroAttr { .. } => {\n+            SyntaxExtensionKind::Attr(..) |\n+            SyntaxExtensionKind::LegacyAttr(..) |\n+            SyntaxExtensionKind::NonMacroAttr { .. } => {\n                 self.cx.span_err(path.span,\n                                  &format!(\"`{}` can only be used in attributes\", path));\n                 self.cx.trace_macros_diag();\n                 kind.dummy(span)\n             }\n \n-            SyntaxExtension::Derive(..) | SyntaxExtension::LegacyDerive(..) => {\n+            SyntaxExtensionKind::Derive(..) | SyntaxExtensionKind::LegacyDerive(..) => {\n                 self.cx.span_err(path.span, &format!(\"`{}` is a derive macro\", path));\n                 self.cx.trace_macros_diag();\n                 kind.dummy(span)\n             }\n \n-            SyntaxExtension::Bang { ref expander, ref allow_internal_unstable, edition } => {\n+            SyntaxExtensionKind::Bang(expander) => {\n                 if ident.name != kw::Invalid {\n                     let msg =\n                         format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n@@ -798,19 +737,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     kind.dummy(span)\n                 } else {\n                     self.gate_proc_macro_expansion_kind(span, kind);\n-                    invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n-                        call_site: span,\n-                        // FIXME procedural macros do not have proper span info\n-                        // yet, when they do, we should use it here.\n-                        def_site: None,\n-                        format: macro_bang_format(path),\n-                        // FIXME probably want to follow macro_rules macros here.\n-                        allow_internal_unstable: allow_internal_unstable.clone(),\n-                        allow_internal_unsafe: false,\n-                        local_inner_macros: false,\n-                        edition,\n-                    });\n-\n                     let tok_result = expander.expand(self.cx, span, mac.node.stream());\n                     let result = self.parse_ast_fragment(tok_result, kind, path, span);\n                     self.gate_proc_macro_expansion(span, &result);\n@@ -867,55 +793,19 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             return None;\n         }\n \n-        let pretty_name = Symbol::intern(&format!(\"derive({})\", path));\n-        let span = path.span;\n-        let attr = ast::Attribute {\n-            path, span,\n-            tokens: TokenStream::empty(),\n-            // irrelevant:\n-            id: ast::AttrId(0), style: ast::AttrStyle::Outer, is_sugared_doc: false,\n-        };\n-\n-        let mut expn_info = ExpnInfo {\n-            call_site: span,\n-            def_site: None,\n-            format: MacroAttribute(pretty_name),\n-            allow_internal_unstable: None,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: ext.edition(self.cx.parse_sess.edition),\n-        };\n-\n-        match ext {\n-            SyntaxExtension::Derive(expander, ..) | SyntaxExtension::LegacyDerive(expander) => {\n-                let meta = match ext {\n-                    SyntaxExtension::Derive(..) => ast::MetaItem { // FIXME(jseyfried) avoid this\n-                        path: Path::from_ident(Ident::invalid()),\n-                        span: DUMMY_SP,\n-                        node: ast::MetaItemKind::Word,\n-                    },\n-                    _ => {\n-                        expn_info.allow_internal_unstable = Some(vec![\n-                            sym::rustc_attrs,\n-                            Symbol::intern(\"derive_clone_copy\"),\n-                            Symbol::intern(\"derive_eq\"),\n-                            // RustcDeserialize and RustcSerialize\n-                            Symbol::intern(\"libstd_sys_internals\"),\n-                        ].into());\n-                        attr.meta()?\n-                    }\n-                };\n-\n-                invoc.expansion_data.mark.set_expn_info(expn_info);\n-                let span = span.with_ctxt(self.cx.backtrace());\n+        match &ext.kind {\n+            SyntaxExtensionKind::Derive(expander) |\n+            SyntaxExtensionKind::LegacyDerive(expander) => {\n+                let meta = ast::MetaItem { node: ast::MetaItemKind::Word, span: path.span, path };\n+                let span = meta.span.with_ctxt(self.cx.backtrace());\n                 let items = expander.expand(self.cx, span, &meta, item);\n                 Some(invoc.fragment_kind.expect_from_annotatables(items))\n             }\n             _ => {\n-                let msg = &format!(\"macro `{}` may not be used for derive attributes\", attr.path);\n-                self.cx.span_err(span, msg);\n+                let msg = &format!(\"macro `{}` may not be used for derive attributes\", path);\n+                self.cx.span_err(path.span, msg);\n                 self.cx.trace_macros_diag();\n-                invoc.fragment_kind.dummy(span)\n+                invoc.fragment_kind.dummy(path.span)\n             }\n         }\n     }"}, {"sha": "7f051c260ec822a88b50dea9e0293bb160e46ff0", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -1,6 +1,7 @@\n use crate::{ast, attr};\n use crate::edition::Edition;\n-use crate::ext::base::{DummyResult, ExtCtxt, MacResult, SyntaxExtension, TTMacroExpander};\n+use crate::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n+use crate::ext::base::{DummyResult, ExtCtxt, MacResult, TTMacroExpander};\n use crate::ext::expand::{AstFragment, AstFragmentKind};\n use crate::ext::hygiene::Transparency;\n use crate::ext::tt::macro_parser::{Success, Error, Failure};\n@@ -376,7 +377,7 @@ pub fn compile(\n         valid,\n     });\n \n-    let transparency = if attr::contains_name(&def.attrs, sym::rustc_transparent_macro) {\n+    let default_transparency = if attr::contains_name(&def.attrs, sym::rustc_transparent_macro) {\n         Transparency::Transparent\n     } else if body.legacy {\n         Transparency::SemiTransparent\n@@ -426,14 +427,15 @@ pub fn compile(\n         }\n     });\n \n-    SyntaxExtension::LegacyBang {\n-        expander,\n+    SyntaxExtension {\n+        kind: SyntaxExtensionKind::LegacyBang(expander),\n         def_info: Some((def.id, def.span)),\n-        transparency,\n+        default_transparency,\n         allow_internal_unstable,\n         allow_internal_unsafe,\n         local_inner_macros,\n         unstable_feature,\n+        helper_attrs: Vec::new(),\n         edition,\n     }\n }"}, {"sha": "6630bf9081546de2a712a73d7355e09debf9465a", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -16,15 +16,9 @@ use syntax_pos::{DUMMY_SP, Span};\n /// The expanded code uses the unstable `#[prelude_import]` attribute.\n fn ignored_span(sp: Span, edition: Edition) -> Span {\n     let mark = Mark::fresh(Mark::root());\n-    mark.set_expn_info(ExpnInfo {\n-        call_site: DUMMY_SP,\n-        def_site: None,\n-        format: MacroAttribute(Symbol::intern(\"std_inject\")),\n-        allow_internal_unstable: Some(vec![sym::prelude_import].into()),\n-        allow_internal_unsafe: false,\n-        local_inner_macros: false,\n-        edition,\n-    });\n+    mark.set_expn_info(ExpnInfo::with_unstable(\n+        MacroAttribute(Symbol::intern(\"std_inject\")), sp, edition, &[sym::prelude_import]\n+    ));\n     sp.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n }\n "}, {"sha": "f90b76721ee16a29402eb3e432505abb288df948", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -280,15 +280,10 @@ fn generate_test_harness(sess: &ParseSess,\n         test_runner\n     };\n \n-    mark.set_expn_info(ExpnInfo {\n-        call_site: DUMMY_SP,\n-        def_site: None,\n-        format: MacroAttribute(sym::test_case),\n-        allow_internal_unstable: Some(vec![sym::main, sym::test, sym::rustc_attrs].into()),\n-        allow_internal_unsafe: false,\n-        local_inner_macros: false,\n-        edition: sess.edition,\n-    });\n+    mark.set_expn_info(ExpnInfo::with_unstable(\n+        MacroAttribute(sym::test_case), DUMMY_SP, sess.edition,\n+        &[sym::main, sym::test, sym::rustc_attrs],\n+    ));\n \n     TestHarnessGenerator {\n         cx,"}, {"sha": "1fe6094fca6861eeb1f2ba417f99769b2e5ed0ef", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -2,9 +2,10 @@\n \n use rustc_data_structures::sync::Lrc;\n use syntax::ast::{self, MetaItem};\n-use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension, Resolver, MultiItemModifier};\n+use syntax::edition::Edition;\n+use syntax::ext::base::{Annotatable, ExtCtxt, Resolver, MultiItemModifier};\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::ext::build::AstBuilder;\n-use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n@@ -67,11 +68,25 @@ macro_rules! derive_traits {\n             }\n         }\n \n-        pub fn register_builtin_derives(resolver: &mut dyn Resolver) {\n+        pub fn register_builtin_derives(resolver: &mut dyn Resolver, edition: Edition) {\n+            let allow_internal_unstable = Some([\n+                sym::core_intrinsics,\n+                sym::rustc_attrs,\n+                Symbol::intern(\"derive_clone_copy\"),\n+                Symbol::intern(\"derive_eq\"),\n+                Symbol::intern(\"libstd_sys_internals\"), // RustcDeserialize and RustcSerialize\n+            ][..].into());\n+\n             $(\n                 resolver.add_builtin(\n                     ast::Ident::with_empty_ctxt(Symbol::intern($name)),\n-                    Lrc::new(SyntaxExtension::LegacyDerive(Box::new(BuiltinDerive($func))))\n+                    Lrc::new(SyntaxExtension {\n+                        allow_internal_unstable: allow_internal_unstable.clone(),\n+                        ..SyntaxExtension::default(\n+                            SyntaxExtensionKind::LegacyDerive(Box::new(BuiltinDerive($func))),\n+                            edition,\n+                        )\n+                    }),\n                 );\n             )*\n         }\n@@ -148,24 +163,11 @@ fn hygienic_type_parameter(item: &Annotatable, base: &str) -> String {\n \n /// Constructs an expression that calls an intrinsic\n fn call_intrinsic(cx: &ExtCtxt<'_>,\n-                  mut span: Span,\n+                  span: Span,\n                   intrinsic: &str,\n                   args: Vec<P<ast::Expr>>)\n                   -> P<ast::Expr> {\n-    let intrinsic_allowed_via_allow_internal_unstable = cx\n-        .current_expansion.mark.expn_info().unwrap()\n-        .allow_internal_unstable.map_or(false, |features| features.iter().any(|&s|\n-            s == sym::core_intrinsics\n-        ));\n-    if intrinsic_allowed_via_allow_internal_unstable {\n-        span = span.with_ctxt(cx.backtrace());\n-    } else { // Avoid instability errors with user defined curstom derives, cc #36316\n-        let mut info = cx.current_expansion.mark.expn_info().unwrap();\n-        info.allow_internal_unstable = Some(vec![sym::core_intrinsics].into());\n-        let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(info);\n-        span = span.with_ctxt(SyntaxContext::empty().apply_mark(mark));\n-    }\n+    let span = span.with_ctxt(cx.backtrace());\n     let path = cx.std_path(&[sym::intrinsics, Symbol::intern(intrinsic)]);\n     let call = cx.expr_call_global(span, path, args);\n "}, {"sha": "b868f5b273c4e6942671bc09f1276a5af34a4274", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 31, "deletions": 39, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -43,32 +43,31 @@ pub mod proc_macro_impl;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n \n-use syntax::ext::base::{MacroExpanderFn, NamedSyntaxExtension, SyntaxExtension};\n-use syntax::ext::hygiene::Transparency;\n+use syntax::ext::base::MacroExpanderFn;\n+use syntax::ext::base::{NamedSyntaxExtension, SyntaxExtension, SyntaxExtensionKind};\n use syntax::edition::Edition;\n use syntax::symbol::{sym, Symbol};\n \n pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n                          user_exts: Vec<NamedSyntaxExtension>,\n                          edition: Edition) {\n-    deriving::register_builtin_derives(resolver);\n+    deriving::register_builtin_derives(resolver, edition);\n \n     let mut register = |name, ext| {\n         resolver.add_builtin(ast::Ident::with_empty_ctxt(name), Lrc::new(ext));\n     };\n     macro_rules! register {\n         ($( $name:ident: $f:expr, )*) => { $(\n-            register(Symbol::intern(stringify!($name)),\n-                     SyntaxExtension::LegacyBang {\n-                        expander: Box::new($f as MacroExpanderFn),\n-                        def_info: None,\n-                        transparency: Transparency::SemiTransparent,\n-                        allow_internal_unstable: None,\n-                        allow_internal_unsafe: false,\n-                        local_inner_macros: false,\n-                        unstable_feature: None,\n-                        edition,\n-                    });\n+            register(Symbol::intern(stringify!($name)), SyntaxExtension::default(\n+                SyntaxExtensionKind::LegacyBang(Box::new($f as MacroExpanderFn)), edition\n+            ));\n+        )* }\n+    }\n+    macro_rules! register_attr {\n+        ($( $name:ident: $f:expr, )*) => { $(\n+            register(Symbol::intern(stringify!($name)), SyntaxExtension::default(\n+                SyntaxExtensionKind::LegacyAttr(Box::new($f)), edition\n+            ));\n         )* }\n     }\n \n@@ -97,33 +96,26 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n         assert: assert::expand_assert,\n     }\n \n-    register(sym::test_case, SyntaxExtension::LegacyAttr(Box::new(test_case::expand)));\n-    register(sym::test, SyntaxExtension::LegacyAttr(Box::new(test::expand_test)));\n-    register(sym::bench, SyntaxExtension::LegacyAttr(Box::new(test::expand_bench)));\n+    register_attr! {\n+        test_case: test_case::expand,\n+        test: test::expand_test,\n+        bench: test::expand_bench,\n+    }\n \n     // format_args uses `unstable` things internally.\n-    register(Symbol::intern(\"format_args\"),\n-             SyntaxExtension::LegacyBang {\n-                expander: Box::new(format::expand_format_args),\n-                def_info: None,\n-                transparency: Transparency::SemiTransparent,\n-                allow_internal_unstable: Some(vec![sym::fmt_internals].into()),\n-                allow_internal_unsafe: false,\n-                local_inner_macros: false,\n-                unstable_feature: None,\n-                edition,\n-            });\n-    register(sym::format_args_nl,\n-             SyntaxExtension::LegacyBang {\n-                 expander: Box::new(format::expand_format_args_nl),\n-                 def_info: None,\n-                 transparency: Transparency::SemiTransparent,\n-                 allow_internal_unstable: Some(vec![sym::fmt_internals].into()),\n-                 allow_internal_unsafe: false,\n-                 local_inner_macros: false,\n-                 unstable_feature: None,\n-                 edition,\n-             });\n+    let allow_internal_unstable = Some([sym::fmt_internals][..].into());\n+    register(Symbol::intern(\"format_args\"), SyntaxExtension {\n+        allow_internal_unstable: allow_internal_unstable.clone(),\n+        ..SyntaxExtension::default(\n+            SyntaxExtensionKind::LegacyBang(Box::new(format::expand_format_args)), edition\n+        )\n+    });\n+    register(sym::format_args_nl, SyntaxExtension {\n+        allow_internal_unstable,\n+        ..SyntaxExtension::default(\n+            SyntaxExtensionKind::LegacyBang(Box::new(format::expand_format_args_nl)), edition\n+        )\n+    });\n \n     for (name, ext) in user_exts {\n         register(name, ext);"}, {"sha": "45e65288a24ee6a3b7614f24ef77d961812cb321", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -347,18 +347,10 @@ fn mk_decls(\n     custom_macros: &[ProcMacroDef],\n ) -> P<ast::Item> {\n     let mark = Mark::fresh(Mark::root());\n-    mark.set_expn_info(ExpnInfo {\n-        call_site: DUMMY_SP,\n-        def_site: None,\n-        format: MacroAttribute(sym::proc_macro),\n-        allow_internal_unstable: Some(vec![\n-            sym::rustc_attrs,\n-            Symbol::intern(\"proc_macro_internals\"),\n-        ].into()),\n-        allow_internal_unsafe: false,\n-        local_inner_macros: false,\n-        edition: cx.parse_sess.edition,\n-    });\n+    mark.set_expn_info(ExpnInfo::with_unstable(\n+        MacroAttribute(sym::proc_macro), DUMMY_SP, cx.parse_sess.edition,\n+        &[sym::rustc_attrs, Symbol::intern(\"proc_macro_internals\")],\n+    ));\n     let span = DUMMY_SP.apply_mark(mark);\n \n     let hidden = cx.meta_list_item_word(span, sym::hidden);"}, {"sha": "24d3055e7114087192cb2ccfa784ac31ebe96425", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -8,7 +8,7 @@ use syntax::attr;\n use syntax::ast;\n use syntax::print::pprust;\n use syntax::symbol::{Symbol, sym};\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::Span;\n use syntax::source_map::{ExpnInfo, MacroAttribute};\n use std::iter;\n \n@@ -62,15 +62,10 @@ pub fn expand_test_or_bench(\n \n     let (sp, attr_sp) = {\n         let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(ExpnInfo {\n-            call_site: DUMMY_SP,\n-            def_site: None,\n-            format: MacroAttribute(sym::test),\n-            allow_internal_unstable: Some(vec![sym::rustc_attrs, sym::test].into()),\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: cx.parse_sess.edition,\n-        });\n+        mark.set_expn_info(ExpnInfo::with_unstable(\n+            MacroAttribute(sym::test), attr_sp, cx.parse_sess.edition,\n+            &[sym::rustc_attrs, sym::test],\n+        ));\n         (item.span.with_ctxt(SyntaxContext::empty().apply_mark(mark)),\n          attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(mark)))\n     };"}, {"sha": "6e3bc05b65e4ee38234135437b9da2b4971b9945", "filename": "src/libsyntax_ext/test_case.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_case.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -15,7 +15,7 @@ use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast;\n use syntax::source_map::respan;\n use syntax::symbol::sym;\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::Span;\n use syntax::source_map::{ExpnInfo, MacroAttribute};\n use syntax::feature_gate;\n \n@@ -37,15 +37,10 @@ pub fn expand(\n \n     let sp = {\n         let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(ExpnInfo {\n-            call_site: DUMMY_SP,\n-            def_site: None,\n-            format: MacroAttribute(sym::test_case),\n-            allow_internal_unstable: Some(vec![sym::test, sym::rustc_attrs].into()),\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: ecx.parse_sess.edition,\n-        });\n+        mark.set_expn_info(ExpnInfo::with_unstable(\n+            MacroAttribute(sym::test_case), attr_sp, ecx.parse_sess.edition,\n+            &[sym::test, sym::rustc_attrs],\n+        ));\n         attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n     };\n "}, {"sha": "4dbd4ccda910a6ef99c4ed010cfe0e07525788be", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 44, "deletions": 29, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -59,13 +59,12 @@ pub struct Mark(u32);\n #[derive(Clone, Debug)]\n struct MarkData {\n     parent: Mark,\n-    default_transparency: Transparency,\n     expn_info: Option<ExpnInfo>,\n }\n \n /// A property of a macro expansion that determines how identifiers\n /// produced by that expansion are resolved.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum Transparency {\n     /// Identifier produced by a transparent expansion is always resolved at call-site.\n     /// Call-site spans in procedural macros, hygiene opt-out in `macro` should use this.\n@@ -85,12 +84,7 @@ pub enum Transparency {\n impl Mark {\n     pub fn fresh(parent: Mark) -> Self {\n         HygieneData::with(|data| {\n-            data.marks.push(MarkData {\n-                parent,\n-                // By default expansions behave like `macro_rules`.\n-                default_transparency: Transparency::SemiTransparent,\n-                expn_info: None,\n-            });\n+            data.marks.push(MarkData { parent, expn_info: None });\n             Mark(data.marks.len() as u32 - 1)\n         })\n     }\n@@ -118,20 +112,14 @@ impl Mark {\n \n     #[inline]\n     pub fn expn_info(self) -> Option<ExpnInfo> {\n-        HygieneData::with(|data| data.expn_info(self))\n+        HygieneData::with(|data| data.expn_info(self).cloned())\n     }\n \n     #[inline]\n     pub fn set_expn_info(self, info: ExpnInfo) {\n         HygieneData::with(|data| data.marks[self.0 as usize].expn_info = Some(info))\n     }\n \n-    #[inline]\n-    pub fn set_default_transparency(self, transparency: Transparency) {\n-        assert_ne!(self, Mark::root());\n-        HygieneData::with(|data| data.marks[self.0 as usize].default_transparency = transparency)\n-    }\n-\n     pub fn is_descendant_of(self, ancestor: Mark) -> bool {\n         HygieneData::with(|data| data.is_descendant_of(self, ancestor))\n     }\n@@ -172,9 +160,8 @@ impl Mark {\n     #[inline]\n     pub fn looks_like_proc_macro_derive(self) -> bool {\n         HygieneData::with(|data| {\n-            let mark_data = &data.marks[self.0 as usize];\n-            if mark_data.default_transparency == Transparency::Opaque {\n-                if let Some(expn_info) = &mark_data.expn_info {\n+            if data.default_transparency(self) == Transparency::Opaque {\n+                if let Some(expn_info) = &data.marks[self.0 as usize].expn_info {\n                     if let ExpnFormat::MacroAttribute(name) = expn_info.format {\n                         if name.as_str().starts_with(\"derive(\") {\n                             return true;\n@@ -199,9 +186,6 @@ impl HygieneData {\n         HygieneData {\n             marks: vec![MarkData {\n                 parent: Mark::root(),\n-                // If the root is opaque, then loops searching for an opaque mark\n-                // will automatically stop after reaching it.\n-                default_transparency: Transparency::Opaque,\n                 expn_info: None,\n             }],\n             syntax_contexts: vec![SyntaxContextData {\n@@ -220,8 +204,8 @@ impl HygieneData {\n         GLOBALS.with(|globals| f(&mut *globals.hygiene_data.borrow_mut()))\n     }\n \n-    fn expn_info(&self, mark: Mark) -> Option<ExpnInfo> {\n-        self.marks[mark.0 as usize].expn_info.clone()\n+    fn expn_info(&self, mark: Mark) -> Option<&ExpnInfo> {\n+        self.marks[mark.0 as usize].expn_info.as_ref()\n     }\n \n     fn is_descendant_of(&self, mut mark: Mark, ancestor: Mark) -> bool {\n@@ -235,7 +219,9 @@ impl HygieneData {\n     }\n \n     fn default_transparency(&self, mark: Mark) -> Transparency {\n-        self.marks[mark.0 as usize].default_transparency\n+        self.marks[mark.0 as usize].expn_info.as_ref().map_or(\n+            Transparency::SemiTransparent, |einfo| einfo.default_transparency\n+        )\n     }\n \n     fn modern(&self, ctxt: SyntaxContext) -> SyntaxContext {\n@@ -427,7 +413,6 @@ impl SyntaxContext {\n         HygieneData::with(|data| {\n             data.marks.push(MarkData {\n                 parent: Mark::root(),\n-                default_transparency: Transparency::SemiTransparent,\n                 expn_info: Some(expansion_info),\n             });\n \n@@ -613,7 +598,7 @@ impl SyntaxContext {\n     /// `ctxt.outer().expn_info()`.\n     #[inline]\n     pub fn outer_expn_info(self) -> Option<ExpnInfo> {\n-        HygieneData::with(|data| data.expn_info(data.outer(self)))\n+        HygieneData::with(|data| data.expn_info(data.outer(self)).cloned())\n     }\n \n     /// `ctxt.outer_and_expn_info()` is equivalent to but faster than\n@@ -622,7 +607,7 @@ impl SyntaxContext {\n     pub fn outer_and_expn_info(self) -> (Mark, Option<ExpnInfo>) {\n         HygieneData::with(|data| {\n             let outer = data.outer(self);\n-            (outer, data.expn_info(outer))\n+            (outer, data.expn_info(outer).cloned())\n         })\n     }\n \n@@ -651,6 +636,7 @@ impl fmt::Debug for SyntaxContext {\n /// Extra information for tracking spans of macro and syntax sugar expansion\n #[derive(Clone, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ExpnInfo {\n+    // --- The part unique to each expansion.\n     /// The location of the actual macro invocation or syntax sugar , e.g.\n     /// `let x = foo!();` or `if let Some(y) = x {}`\n     ///\n@@ -661,13 +647,18 @@ pub struct ExpnInfo {\n     /// call_site span would have its own ExpnInfo, with the call_site\n     /// pointing to the `foo!` invocation.\n     pub call_site: Span,\n+    /// The format with which the macro was invoked.\n+    pub format: ExpnFormat,\n+\n+    // --- The part specific to the macro/desugaring definition.\n+    // --- FIXME: Share it between expansions with the same definition.\n     /// The span of the macro definition itself. The macro may not\n     /// have a sensible definition span (e.g., something defined\n     /// completely inside libsyntax) in which case this is None.\n     /// This span serves only informational purpose and is not used for resolution.\n     pub def_site: Option<Span>,\n-    /// The format with which the macro was invoked.\n-    pub format: ExpnFormat,\n+    /// Transparency used by `apply_mark` for mark with this expansion info by default.\n+    pub default_transparency: Transparency,\n     /// List of #[unstable]/feature-gated features that the macro is allowed to use\n     /// internally without forcing the whole crate to opt-in\n     /// to them.\n@@ -682,6 +673,30 @@ pub struct ExpnInfo {\n     pub edition: Edition,\n }\n \n+impl ExpnInfo {\n+    /// Constructs an expansion info with default properties.\n+    pub fn default(format: ExpnFormat, call_site: Span, edition: Edition) -> ExpnInfo {\n+        ExpnInfo {\n+            call_site,\n+            format,\n+            def_site: None,\n+            default_transparency: Transparency::SemiTransparent,\n+            allow_internal_unstable: None,\n+            allow_internal_unsafe: false,\n+            local_inner_macros: false,\n+            edition,\n+        }\n+    }\n+\n+    pub fn with_unstable(format: ExpnFormat, call_site: Span, edition: Edition,\n+                         allow_internal_unstable: &[Symbol]) -> ExpnInfo {\n+        ExpnInfo {\n+            allow_internal_unstable: Some(allow_internal_unstable.into()),\n+            ..ExpnInfo::default(format, call_site, edition)\n+        }\n+    }\n+}\n+\n /// The source of expansion.\n #[derive(Clone, Hash, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum ExpnFormat {"}, {"sha": "4cf8a4e33c52626bee51f84611cc645fb083d051", "filename": "src/test/run-pass-fulldeps/auxiliary/plugin-args.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51002ce078c5de8d49e700b3c22c9c3cc84ff94/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs?ref=d51002ce078c5de8d49e700b3c22c9c3cc84ff94", "patch": "@@ -11,8 +11,8 @@ extern crate rustc_plugin;\n use std::borrow::ToOwned;\n use syntax::ast;\n use syntax::ext::build::AstBuilder;\n-use syntax::ext::base::{SyntaxExtension, TTMacroExpander, ExtCtxt, MacResult, MacEager};\n-use syntax::ext::hygiene::Transparency;\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n+use syntax::ext::base::{TTMacroExpander, ExtCtxt, MacResult, MacEager};\n use syntax::print::pprust;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n@@ -38,15 +38,7 @@ impl TTMacroExpander for Expander {\n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     let args = reg.args().to_owned();\n-    reg.register_syntax_extension(Symbol::intern(\"plugin_args\"),\n-        SyntaxExtension::LegacyBang {\n-            expander: Box::new(Expander { args: args, }),\n-            def_info: None,\n-            transparency: Transparency::SemiTransparent,\n-            allow_internal_unstable: None,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            unstable_feature: None,\n-            edition: reg.sess.edition(),\n-        });\n+    reg.register_syntax_extension(Symbol::intern(\"plugin_args\"), SyntaxExtension::default(\n+        SyntaxExtensionKind::LegacyBang(Box::new(Expander { args })), reg.sess.edition()\n+    ));\n }"}]}