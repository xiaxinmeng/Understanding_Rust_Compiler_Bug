{"sha": "c9cc43aa66911b38e9da68de6c2c7ee1f37911ea", "node_id": "C_kwDOAAsO6NoAKGM5Y2M0M2FhNjY5MTFiMzhlOWRhNjhkZTZjMmM3ZWUxZjM3OTExZWE", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-09-06T23:16:52Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-03-24T05:31:57Z"}, "message": "Move increment checks to improve errors", "tree": {"sha": "b77280da36514533301d1fcfd278c4c8ab854041", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b77280da36514533301d1fcfd278c4c8ab854041"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9cc43aa66911b38e9da68de6c2c7ee1f37911ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9cc43aa66911b38e9da68de6c2c7ee1f37911ea", "html_url": "https://github.com/rust-lang/rust/commit/c9cc43aa66911b38e9da68de6c2c7ee1f37911ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9cc43aa66911b38e9da68de6c2c7ee1f37911ea/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d9cd4b851f121d0bc84cab474d6c536aba207df", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d9cd4b851f121d0bc84cab474d6c536aba207df", "html_url": "https://github.com/rust-lang/rust/commit/5d9cd4b851f121d0bc84cab474d6c536aba207df"}], "stats": {"total": 365, "additions": 286, "deletions": 79}, "files": [{"sha": "99844bef1ffecadc3a328ee60247b5b549e99d05", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 185, "deletions": 43, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/c9cc43aa66911b38e9da68de6c2c7ee1f37911ea/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9cc43aa66911b38e9da68de6c2c7ee1f37911ea/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=c9cc43aa66911b38e9da68de6c2c7ee1f37911ea", "patch": "@@ -156,6 +156,52 @@ impl AttemptLocalParseRecovery {\n     }\n }\n \n+#[derive(Debug, Copy, Clone)]\n+struct IncDecRecovery {\n+    standalone: bool,\n+    op: IncOrDec,\n+    fixity: UnaryFixity,\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+enum IncOrDec {\n+    Inc,\n+    // FIXME: `i--` recovery isn't implemented yet\n+    #[allow(dead_code)]\n+    Dec,\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+enum UnaryFixity {\n+    Pre,\n+    Post,\n+}\n+\n+impl IncOrDec {\n+    fn chr(&self) -> char {\n+        match self {\n+            Self::Inc => '+',\n+            Self::Dec => '-',\n+        }\n+    }\n+\n+    fn name(&self) -> &'static str {\n+        match self {\n+            Self::Inc => \"increment\",\n+            Self::Dec => \"decrement\",\n+        }\n+    }\n+}\n+\n+impl std::fmt::Display for UnaryFixity {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            Self::Pre => write!(f, \"prefix\"),\n+            Self::Post => write!(f, \"postfix\"),\n+        }\n+    }\n+}\n+\n // SnapshotParser is used to create a snapshot of the parser\n // without causing duplicate errors being emitted when the `Parser`\n // is dropped.\n@@ -1167,6 +1213,145 @@ impl<'a> Parser<'a> {\n         Ok(())\n     }\n \n+    pub(super) fn maybe_recover_from_prefix_increment(\n+        &mut self,\n+        operand_expr: P<Expr>,\n+        op_span: Span,\n+        prev_is_semi: bool,\n+    ) -> PResult<'a, P<Expr>> {\n+        let kind = IncDecRecovery {\n+            standalone: prev_is_semi,\n+            op: IncOrDec::Inc,\n+            fixity: UnaryFixity::Pre,\n+        };\n+\n+        self.recover_from_inc_dec(operand_expr, kind, op_span)\n+    }\n+\n+    pub(super) fn maybe_recover_from_postfix_increment(\n+        &mut self,\n+        operand_expr: P<Expr>,\n+        op_span: Span,\n+        prev_is_semi: bool,\n+    ) -> PResult<'a, P<Expr>> {\n+        let kind = IncDecRecovery {\n+            standalone: prev_is_semi,\n+            op: IncOrDec::Inc,\n+            fixity: UnaryFixity::Post,\n+        };\n+\n+        self.recover_from_inc_dec(operand_expr, kind, op_span)\n+    }\n+\n+    fn recover_from_inc_dec(\n+        &mut self,\n+        base: P<Expr>,\n+        kind: IncDecRecovery,\n+        op_span: Span,\n+    ) -> PResult<'a, P<Expr>> {\n+        let mut err = self.struct_span_err(\n+            op_span,\n+            &format!(\"Rust has no {} {} operator\", kind.fixity, kind.op.name()),\n+        );\n+        err.span_label(op_span, &format!(\"not a valid {} operator\", kind.fixity));\n+\n+        if let ExprKind::Path(_, path) = &base.kind {\n+            if let [segment] = path.segments.as_slice() {\n+                let ident = segment.ident;\n+                // (pre, post)\n+                let spans = match kind.fixity {\n+                    UnaryFixity::Pre => (op_span, ident.span.shrink_to_hi()),\n+                    UnaryFixity::Post => (ident.span.shrink_to_lo(), op_span),\n+                };\n+\n+                if !ident.is_reserved() {\n+                    if kind.standalone {\n+                        return self.inc_dec_standalone_recovery(base, err, kind, ident, spans);\n+                    } else {\n+                        match kind.fixity {\n+                            UnaryFixity::Pre => {\n+                                return self.prefix_inc_dec_suggest_and_recover(\n+                                    base, err, kind, ident, spans,\n+                                );\n+                            }\n+                            UnaryFixity::Post => {\n+                                return self.postfix_inc_dec_suggest_and_recover(\n+                                    base, err, kind, ident, spans,\n+                                );\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        // base case\n+        err.help(&format!(\"use `{}= 1` instead\", kind.op.chr()));\n+        err.emit();\n+\n+        Ok(base)\n+    }\n+\n+    fn prefix_inc_dec_suggest_and_recover(\n+        &mut self,\n+        base: P<Expr>,\n+        mut err: DiagnosticBuilder<'_>,\n+        kind: IncDecRecovery,\n+        ident: Ident,\n+        (pre_span, post_span): (Span, Span),\n+    ) -> PResult<'a, P<Expr>> {\n+        err.multipart_suggestion(\n+            &format!(\"use `{}= 1` instead\", kind.op.chr()),\n+            vec![\n+                (pre_span, \"{ \".to_string()),\n+                (post_span, format!(\" {}= 1; {} }}\", kind.op.chr(), ident)),\n+            ],\n+            Applicability::MachineApplicable,\n+        );\n+        err.emit();\n+        // TODO: recover\n+        Ok(base)\n+    }\n+\n+    fn postfix_inc_dec_suggest_and_recover(\n+        &mut self,\n+        base: P<Expr>,\n+        mut err: DiagnosticBuilder<'_>,\n+        kind: IncDecRecovery,\n+        ident: Ident,\n+        (pre_span, post_span): (Span, Span),\n+    ) -> PResult<'a, P<Expr>> {\n+        err.multipart_suggestion(\n+            &format!(\"use `{}= 1` instead\", kind.op.chr()),\n+            vec![\n+                (pre_span, \"{ let tmp = \".to_string()),\n+                (post_span, format!(\"; {} {}= 1; tmp }}\", ident, kind.op.chr())),\n+            ],\n+            Applicability::MachineApplicable,\n+        );\n+        err.emit();\n+        // TODO: recover\n+        Ok(base)\n+    }\n+\n+    fn inc_dec_standalone_recovery(\n+        &mut self,\n+        base: P<Expr>,\n+        mut err: DiagnosticBuilder<'_>,\n+        kind: IncDecRecovery,\n+        _ident: Ident,\n+        (pre_span, post_span): (Span, Span),\n+    ) -> PResult<'a, P<Expr>> {\n+        err.multipart_suggestion(\n+            &format!(\"use `{}= 1` instead\", kind.op.chr()),\n+            vec![(pre_span, String::new()), (post_span, format!(\" {}= 1\", kind.op.chr()))],\n+            Applicability::MachineApplicable,\n+        );\n+        err.emit();\n+        // TODO: recover\n+        Ok(base)\n+    }\n+\n     /// Tries to recover from associated item paths like `[T]::AssocItem` / `(T, U)::AssocItem`.\n     /// Attempts to convert the base expression/pattern/type into a type, parses the `::AssocItem`\n     /// tail, and combines them into a `<Ty>::AssocItem` expression/pattern/type.\n@@ -1882,49 +2067,6 @@ impl<'a> Parser<'a> {\n             self.sess.expr_parentheses_needed(&mut err, *sp);\n         }\n         err.span_label(span, \"expected expression\");\n-        if self.prev_token.kind == TokenKind::BinOp(token::Plus)\n-            && self.token.kind == TokenKind::BinOp(token::Plus)\n-            && self.look_ahead(1, |t| !t.is_lit())\n-        {\n-            let span = self.prev_token.span.to(self.token.span);\n-            err.note(\"Rust has no dedicated increment operator\");\n-            err.span_suggestion_verbose(\n-                span,\n-                \"try using `+= 1` instead\",\n-                \" += 1\".into(),\n-                Applicability::Unspecified,\n-            );\n-        } else if self.token.kind == TokenKind::BinOp(token::Plus)\n-            && self.look_ahead(1, |t| t.kind == TokenKind::BinOp(token::Plus))\n-            && self.look_ahead(2, |t| !t.is_lit())\n-        {\n-            let target_span = self.look_ahead(2, |t| t.span);\n-            let left_brace_span = target_span.shrink_to_lo();\n-            let pre_span = self.token.span.to(self.look_ahead(1, |t| t.span));\n-            let post_span = target_span.shrink_to_hi();\n-\n-            err.note(\"Rust has no dedicated increment operator\");\n-\n-            if self.prev_token.kind == TokenKind::Semi {\n-                err.multipart_suggestion(\n-                    \"try using `+= 1` instead\",\n-                    vec![(pre_span, String::new()), (post_span, \" += 1\".into())],\n-                    Applicability::MachineApplicable,\n-                );\n-            } else if let Ok(target_snippet) = self.span_to_snippet(target_span) {\n-                err.multipart_suggestion(\n-                    \"try using `+= 1` instead\",\n-                    vec![\n-                        (left_brace_span, \"{ \".to_string()),\n-                        (pre_span, String::new()),\n-                        (post_span, format!(\" += 1; {} }}\", target_snippet)),\n-                    ],\n-                    Applicability::MachineApplicable,\n-                );\n-            } else {\n-                err.span_help(pre_span.to(target_span), \"try using `+= 1` instead\");\n-            }\n-        }\n         err\n     }\n "}, {"sha": "39d96b8a9e32606860a7a7a60918413cbc83ed43", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c9cc43aa66911b38e9da68de6c2c7ee1f37911ea/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9cc43aa66911b38e9da68de6c2c7ee1f37911ea/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=c9cc43aa66911b38e9da68de6c2c7ee1f37911ea", "patch": "@@ -267,6 +267,18 @@ impl<'a> Parser<'a> {\n                 self.bump();\n             }\n \n+            if self.prev_token == token::BinOp(token::Plus)\n+                && self.token == token::BinOp(token::Plus)\n+            {\n+                let op_span = self.prev_token.span.to(self.token.span);\n+                // Eat the second `+`\n+                self.bump();\n+                // TODO: implement\n+                let start_is_semi = false;\n+                lhs = self.maybe_recover_from_postfix_increment(lhs, op_span, start_is_semi)?;\n+                continue;\n+            }\n+\n             let op = op.node;\n             // Special cases:\n             if op == AssocOp::As {\n@@ -586,6 +598,19 @@ impl<'a> Parser<'a> {\n             token::Ident(..) if this.is_mistaken_not_ident_negation() => {\n                 make_it!(this, attrs, |this, _| this.recover_not_expr(lo))\n             }\n+            // Recover from `++x`\n+            token::BinOp(token::Plus)\n+                if this.look_ahead(1, |t| *t == token::BinOp(token::Plus)) =>\n+            {\n+                let prev_is_semi = this.prev_token == token::Semi;\n+                let pre_span = this.token.span.to(this.look_ahead(1, |t| t.span));\n+                // Eat both `+`s.\n+                this.bump();\n+                this.bump();\n+\n+                let operand_expr = this.parse_path_start_expr(Default::default())?;\n+                this.maybe_recover_from_prefix_increment(operand_expr, pre_span, prev_is_semi)\n+            }\n             _ => return this.parse_dot_or_call_expr(Some(attrs)),\n         }\n     }"}, {"sha": "ad61c4e66d28c484b65c23aa0102d301c3b673f4", "filename": "src/test/ui/parser/increment.fixed", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c9cc43aa66911b38e9da68de6c2c7ee1f37911ea/src%2Ftest%2Fui%2Fparser%2Fincrement.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c9cc43aa66911b38e9da68de6c2c7ee1f37911ea/src%2Ftest%2Fui%2Fparser%2Fincrement.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fincrement.fixed?ref=c9cc43aa66911b38e9da68de6c2c7ee1f37911ea", "patch": "@@ -0,0 +1,36 @@\n+// run-rustfix\n+\n+fn post_regular() {\n+    let mut i = 0;\n+    { let tmp = i; i += 1; tmp }; //~ ERROR Rust has no postfix increment operator\n+    println!(\"{}\", i);\n+}\n+\n+fn post_while() {\n+    let mut i = 0;\n+    while { let tmp = i; i += 1; tmp } < 5 {\n+        //~^ ERROR Rust has no postfix increment operator\n+        println!(\"{}\", i);\n+    }\n+}\n+\n+fn pre_regular() {\n+    let mut i = 0;\n+    i += 1; //~ ERROR Rust has no prefix increment operator\n+    println!(\"{}\", i);\n+}\n+\n+fn pre_while() {\n+    let mut i = 0;\n+    while { i += 1; i } < 5 {\n+        //~^ ERROR Rust has no prefix increment operator\n+        println!(\"{}\", i);\n+    }\n+}\n+\n+fn main() {\n+    post_regular();\n+    post_while();\n+    pre_regular();\n+    pre_while();\n+}"}, {"sha": "f31031fed3aff368f3eac3d5bacd218c9709f9ab", "filename": "src/test/ui/parser/increment.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c9cc43aa66911b38e9da68de6c2c7ee1f37911ea/src%2Ftest%2Fui%2Fparser%2Fincrement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9cc43aa66911b38e9da68de6c2c7ee1f37911ea/src%2Ftest%2Fui%2Fparser%2Fincrement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fincrement.rs?ref=c9cc43aa66911b38e9da68de6c2c7ee1f37911ea", "patch": "@@ -1,27 +1,36 @@\n+// run-rustfix\n+\n fn post_regular() {\n-    let i = 0;\n-    i++; //~ ERROR\n+    let mut i = 0;\n+    i++; //~ ERROR Rust has no postfix increment operator\n+    println!(\"{}\", i);\n }\n \n fn post_while() {\n-    let i = 0;\n+    let mut i = 0;\n     while i++ < 5 {\n-        //~^ ERROR\n+        //~^ ERROR Rust has no postfix increment operator\n         println!(\"{}\", i);\n     }\n }\n \n fn pre_regular() {\n-    let i = 0;\n-    ++i; //~ ERROR\n+    let mut i = 0;\n+    ++i; //~ ERROR Rust has no prefix increment operator\n+    println!(\"{}\", i);\n }\n \n fn pre_while() {\n-    let i = 0;\n+    let mut i = 0;\n     while ++i < 5 {\n-        //~^ ERROR\n+        //~^ ERROR Rust has no prefix increment operator\n         println!(\"{}\", i);\n     }\n }\n \n-fn main() {}\n+fn main() {\n+    post_regular();\n+    post_while();\n+    pre_regular();\n+    pre_while();\n+}"}, {"sha": "6a2b37e3ddcf26134e0bd467aeffda8a316e2111", "filename": "src/test/ui/parser/increment.stderr", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c9cc43aa66911b38e9da68de6c2c7ee1f37911ea/src%2Ftest%2Fui%2Fparser%2Fincrement.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9cc43aa66911b38e9da68de6c2c7ee1f37911ea/src%2Ftest%2Fui%2Fparser%2Fincrement.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fincrement.stderr?ref=c9cc43aa66911b38e9da68de6c2c7ee1f37911ea", "patch": "@@ -1,52 +1,47 @@\n-error: expected expression, found `+`\n-  --> $DIR/increment.rs:3:7\n+error: Rust has no postfix increment operator\n+  --> $DIR/increment.rs:5:6\n    |\n LL |     i++;\n-   |       ^ expected expression\n+   |      ^^ not a valid postfix operator\n    |\n-   = note: Rust has no dedicated increment operator\n-help: try using `+= 1` instead\n+help: use `+= 1` instead\n    |\n-LL |     i += 1;\n-   |       ~~~~\n+LL |     { let tmp = i; i += 1; tmp };\n+   |     +++++++++++  ~~~~~~~~~~~~~~~\n \n-error: expected expression, found `+`\n-  --> $DIR/increment.rs:8:13\n+error: Rust has no postfix increment operator\n+  --> $DIR/increment.rs:11:12\n    |\n LL |     while i++ < 5 {\n-   |             ^ expected expression\n+   |            ^^ not a valid postfix operator\n    |\n-   = note: Rust has no dedicated increment operator\n-help: try using `+= 1` instead\n+help: use `+= 1` instead\n    |\n-LL |     while i += 1 < 5 {\n-   |             ~~~~\n+LL |     while { let tmp = i; i += 1; tmp } < 5 {\n+   |           +++++++++++  ~~~~~~~~~~~~~~~\n \n-error: expected expression, found `+`\n-  --> $DIR/increment.rs:16:5\n+error: Rust has no prefix increment operator\n+  --> $DIR/increment.rs:19:5\n    |\n LL |     ++i;\n-   |     ^ expected expression\n+   |     ^^ not a valid prefix operator\n    |\n-   = note: Rust has no dedicated increment operator\n-help: try using `+= 1` instead\n+help: use `+= 1` instead\n    |\n LL -     ++i;\n LL +     i += 1;\n    | \n \n-error: expected expression, found `+`\n-  --> $DIR/increment.rs:21:11\n+error: Rust has no prefix increment operator\n+  --> $DIR/increment.rs:25:11\n    |\n LL |     while ++i < 5 {\n-   |           ^ expected expression\n+   |           ^^ not a valid prefix operator\n    |\n-   = note: Rust has no dedicated increment operator\n-help: try using `+= 1` instead\n+help: use `+= 1` instead\n    |\n-LL -     while ++i < 5 {\n-LL +     while { i += 1; i } < 5 {\n-   | \n+LL |     while { i += 1; i } < 5 {\n+   |           ~   +++++++++\n \n error: aborting due to 4 previous errors\n "}]}