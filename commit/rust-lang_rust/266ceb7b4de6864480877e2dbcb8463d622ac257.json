{"sha": "266ceb7b4de6864480877e2dbcb8463d622ac257", "node_id": "C_kwDOAAsO6NoAKDI2NmNlYjdiNGRlNjg2NDQ4MDg3N2UyZGJjYjg0NjNkNjIyYWMyNTc", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-05-02T08:18:04Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-05-02T08:18:04Z"}, "message": "Fix floating point binop evaluation", "tree": {"sha": "d5acf1f440e4ea16b26806c1ab2a1b29c32200cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5acf1f440e4ea16b26806c1ab2a1b29c32200cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/266ceb7b4de6864480877e2dbcb8463d622ac257", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/266ceb7b4de6864480877e2dbcb8463d622ac257", "html_url": "https://github.com/rust-lang/rust/commit/266ceb7b4de6864480877e2dbcb8463d622ac257", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/266ceb7b4de6864480877e2dbcb8463d622ac257/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a3c3630a25bdd08db0869022e31f9f380f895f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a3c3630a25bdd08db0869022e31f9f380f895f6", "html_url": "https://github.com/rust-lang/rust/commit/3a3c3630a25bdd08db0869022e31f9f380f895f6"}], "stats": {"total": 200, "additions": 139, "deletions": 61}, "files": [{"sha": "b700864f7dd951e870c93a3c26fd776b69fa49af", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/266ceb7b4de6864480877e2dbcb8463d622ac257/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266ceb7b4de6864480877e2dbcb8463d622ac257/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=266ceb7b4de6864480877e2dbcb8463d622ac257", "patch": "@@ -101,6 +101,18 @@ fn bit_op() {\n     check_number(r#\"const GOAL: i8 = 1 << 8\"#, 0);\n }\n \n+#[test]\n+fn floating_point() {\n+    check_number(\n+        r#\"const GOAL: f64 = 2.0 + 3.0 * 5.5 - 8.;\"#,\n+        i128::from_le_bytes(pad16(&f64::to_le_bytes(10.5), true)),\n+    );\n+    check_number(\n+        r#\"const GOAL: f32 = 2.0 + 3.0 * 5.5 - 8.;\"#,\n+        i128::from_le_bytes(pad16(&f32::to_le_bytes(10.5), true)),\n+    );\n+}\n+\n #[test]\n fn casts() {\n     check_number(r#\"const GOAL: usize = 12 as *const i32 as usize\"#, 12);"}, {"sha": "3ac208666a72617ae3343aa55475155d2555d191", "filename": "crates/hir-ty/src/mir.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/266ceb7b4de6864480877e2dbcb8463d622ac257/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266ceb7b4de6864480877e2dbcb8463d622ac257/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir.rs?ref=266ceb7b4de6864480877e2dbcb8463d622ac257", "patch": "@@ -649,6 +649,20 @@ pub enum BinOp {\n     Offset,\n }\n \n+impl BinOp {\n+    fn run_compare<T: PartialEq + PartialOrd>(&self, l: T, r: T) -> bool {\n+        match self {\n+            BinOp::Ge => l >= r,\n+            BinOp::Gt => l > r,\n+            BinOp::Le => l <= r,\n+            BinOp::Lt => l < r,\n+            BinOp::Eq => l == r,\n+            BinOp::Ne => l != r,\n+            x => panic!(\"`run_compare` called on operator {x:?}\"),\n+        }\n+    }\n+}\n+\n impl Display for BinOp {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         f.write_str(match self {"}, {"sha": "9811cd9192bf487a518004862250f3ba71b4c509", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 113, "deletions": 61, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/266ceb7b4de6864480877e2dbcb8463d622ac257/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266ceb7b4de6864480877e2dbcb8463d622ac257/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=266ceb7b4de6864480877e2dbcb8463d622ac257", "patch": "@@ -48,7 +48,7 @@ macro_rules! from_bytes {\n     ($ty:tt, $value:expr) => {\n         ($ty::from_le_bytes(match ($value).try_into() {\n             Ok(x) => x,\n-            Err(_) => return Err(MirEvalError::TypeError(\"mismatched size\")),\n+            Err(_) => return Err(MirEvalError::TypeError(stringify!(mismatched size in constructing $ty))),\n         }))\n     };\n }\n@@ -797,70 +797,122 @@ impl Evaluator<'_> {\n                     lc = self.read_memory(Address::from_bytes(lc)?, size)?;\n                     rc = self.read_memory(Address::from_bytes(rc)?, size)?;\n                 }\n-                let is_signed = matches!(ty.as_builtin(), Some(BuiltinType::Int(_)));\n-                let l128 = i128::from_le_bytes(pad16(lc, is_signed));\n-                let r128 = i128::from_le_bytes(pad16(rc, is_signed));\n-                match op {\n-                    BinOp::Ge | BinOp::Gt | BinOp::Le | BinOp::Lt | BinOp::Eq | BinOp::Ne => {\n-                        let r = match op {\n-                            BinOp::Ge => l128 >= r128,\n-                            BinOp::Gt => l128 > r128,\n-                            BinOp::Le => l128 <= r128,\n-                            BinOp::Lt => l128 < r128,\n-                            BinOp::Eq => l128 == r128,\n-                            BinOp::Ne => l128 != r128,\n-                            _ => unreachable!(),\n-                        };\n-                        let r = r as u8;\n-                        Owned(vec![r])\n-                    }\n-                    BinOp::BitAnd\n-                    | BinOp::BitOr\n-                    | BinOp::BitXor\n-                    | BinOp::Add\n-                    | BinOp::Mul\n-                    | BinOp::Div\n-                    | BinOp::Rem\n-                    | BinOp::Sub => {\n-                        let r = match op {\n-                            BinOp::Add => l128.overflowing_add(r128).0,\n-                            BinOp::Mul => l128.overflowing_mul(r128).0,\n-                            BinOp::Div => l128.checked_div(r128).ok_or_else(|| {\n-                                MirEvalError::Panic(format!(\"Overflow in {op:?}\"))\n-                            })?,\n-                            BinOp::Rem => l128.checked_rem(r128).ok_or_else(|| {\n-                                MirEvalError::Panic(format!(\"Overflow in {op:?}\"))\n-                            })?,\n-                            BinOp::Sub => l128.overflowing_sub(r128).0,\n-                            BinOp::BitAnd => l128 & r128,\n-                            BinOp::BitOr => l128 | r128,\n-                            BinOp::BitXor => l128 ^ r128,\n-                            _ => unreachable!(),\n-                        };\n-                        let r = r.to_le_bytes();\n-                        for &k in &r[lc.len()..] {\n-                            if k != 0 && (k != 255 || !is_signed) {\n-                                return Err(MirEvalError::Panic(format!(\"Overflow in {op:?}\")));\n+                if let TyKind::Scalar(chalk_ir::Scalar::Float(f)) = ty.kind(Interner) {\n+                    match f {\n+                        chalk_ir::FloatTy::F32 => {\n+                            let l = from_bytes!(f32, lc);\n+                            let r = from_bytes!(f32, rc);\n+                            match op {\n+                                BinOp::Ge\n+                                | BinOp::Gt\n+                                | BinOp::Le\n+                                | BinOp::Lt\n+                                | BinOp::Eq\n+                                | BinOp::Ne => {\n+                                    let r = op.run_compare(l, r) as u8;\n+                                    Owned(vec![r])\n+                                }\n+                                BinOp::Add | BinOp::Sub | BinOp::Mul | BinOp::Div => {\n+                                    let r = match op {\n+                                        BinOp::Add => l + r,\n+                                        BinOp::Sub => l - r,\n+                                        BinOp::Mul => l * r,\n+                                        BinOp::Div => l / r,\n+                                        _ => unreachable!(),\n+                                    };\n+                                    Owned(r.to_le_bytes().into())\n+                                }\n+                                x => not_supported!(\n+                                    \"invalid binop {x:?} on floating point operators\"\n+                                ),\n+                            }\n+                        }\n+                        chalk_ir::FloatTy::F64 => {\n+                            let l = from_bytes!(f64, lc);\n+                            let r = from_bytes!(f64, rc);\n+                            match op {\n+                                BinOp::Ge\n+                                | BinOp::Gt\n+                                | BinOp::Le\n+                                | BinOp::Lt\n+                                | BinOp::Eq\n+                                | BinOp::Ne => {\n+                                    let r = op.run_compare(l, r) as u8;\n+                                    Owned(vec![r])\n+                                }\n+                                BinOp::Add | BinOp::Sub | BinOp::Mul | BinOp::Div => {\n+                                    let r = match op {\n+                                        BinOp::Add => l + r,\n+                                        BinOp::Sub => l - r,\n+                                        BinOp::Mul => l * r,\n+                                        BinOp::Div => l / r,\n+                                        _ => unreachable!(),\n+                                    };\n+                                    Owned(r.to_le_bytes().into())\n+                                }\n+                                x => not_supported!(\n+                                    \"invalid binop {x:?} on floating point operators\"\n+                                ),\n                             }\n                         }\n-                        Owned(r[0..lc.len()].into())\n                     }\n-                    BinOp::Shl | BinOp::Shr => {\n-                        let shift_amount = if r128 < 0 {\n-                            return Err(MirEvalError::Panic(format!(\"Overflow in {op:?}\")));\n-                        } else if r128 > 128 {\n-                            return Err(MirEvalError::Panic(format!(\"Overflow in {op:?}\")));\n-                        } else {\n-                            r128 as u8\n-                        };\n-                        let r = match op {\n-                            BinOp::Shl => l128 << shift_amount,\n-                            BinOp::Shr => l128 >> shift_amount,\n-                            _ => unreachable!(),\n-                        };\n-                        Owned(r.to_le_bytes()[0..lc.len()].into())\n+                } else {\n+                    let is_signed = matches!(ty.as_builtin(), Some(BuiltinType::Int(_)));\n+                    let l128 = i128::from_le_bytes(pad16(lc, is_signed));\n+                    let r128 = i128::from_le_bytes(pad16(rc, is_signed));\n+                    match op {\n+                        BinOp::Ge | BinOp::Gt | BinOp::Le | BinOp::Lt | BinOp::Eq | BinOp::Ne => {\n+                            let r = op.run_compare(l128, r128) as u8;\n+                            Owned(vec![r])\n+                        }\n+                        BinOp::BitAnd\n+                        | BinOp::BitOr\n+                        | BinOp::BitXor\n+                        | BinOp::Add\n+                        | BinOp::Mul\n+                        | BinOp::Div\n+                        | BinOp::Rem\n+                        | BinOp::Sub => {\n+                            let r = match op {\n+                                BinOp::Add => l128.overflowing_add(r128).0,\n+                                BinOp::Mul => l128.overflowing_mul(r128).0,\n+                                BinOp::Div => l128.checked_div(r128).ok_or_else(|| {\n+                                    MirEvalError::Panic(format!(\"Overflow in {op:?}\"))\n+                                })?,\n+                                BinOp::Rem => l128.checked_rem(r128).ok_or_else(|| {\n+                                    MirEvalError::Panic(format!(\"Overflow in {op:?}\"))\n+                                })?,\n+                                BinOp::Sub => l128.overflowing_sub(r128).0,\n+                                BinOp::BitAnd => l128 & r128,\n+                                BinOp::BitOr => l128 | r128,\n+                                BinOp::BitXor => l128 ^ r128,\n+                                _ => unreachable!(),\n+                            };\n+                            let r = r.to_le_bytes();\n+                            for &k in &r[lc.len()..] {\n+                                if k != 0 && (k != 255 || !is_signed) {\n+                                    return Err(MirEvalError::Panic(format!(\"Overflow in {op:?}\")));\n+                                }\n+                            }\n+                            Owned(r[0..lc.len()].into())\n+                        }\n+                        BinOp::Shl | BinOp::Shr => {\n+                            let shift_amount = if r128 < 0 {\n+                                return Err(MirEvalError::Panic(format!(\"Overflow in {op:?}\")));\n+                            } else if r128 > 128 {\n+                                return Err(MirEvalError::Panic(format!(\"Overflow in {op:?}\")));\n+                            } else {\n+                                r128 as u8\n+                            };\n+                            let r = match op {\n+                                BinOp::Shl => l128 << shift_amount,\n+                                BinOp::Shr => l128 >> shift_amount,\n+                                _ => unreachable!(),\n+                            };\n+                            Owned(r.to_le_bytes()[0..lc.len()].into())\n+                        }\n+                        BinOp::Offset => not_supported!(\"offset binop\"),\n                     }\n-                    BinOp::Offset => not_supported!(\"offset binop\"),\n                 }\n             }\n             Rvalue::Discriminant(p) => {"}]}