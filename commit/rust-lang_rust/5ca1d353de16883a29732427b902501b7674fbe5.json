{"sha": "5ca1d353de16883a29732427b902501b7674fbe5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjYTFkMzUzZGUxNjg4M2EyOTczMjQyN2I5MDI1MDFiNzY3NGZiZTU=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-07T20:34:58Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-10T01:40:59Z"}, "message": "Implement most of adjustment handling for consts.\n\nChanges the ad-hoc closure adjustment into using adjustment info instead\nof being separately driven from types, and likewise for autoderef.\n\nAlso takes care of autoref (the cases we should be seeing in consts,\nat least, since we can't be doing method calls which would need the\nref-to-vec mode), which didn't quite work right previously.\n\nHowever, \"dereference\" of a newtype isn't handled yet....", "tree": {"sha": "084174067fe37b9f35234df8ba4fa0ab9fde1a1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/084174067fe37b9f35234df8ba4fa0ab9fde1a1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ca1d353de16883a29732427b902501b7674fbe5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ca1d353de16883a29732427b902501b7674fbe5", "html_url": "https://github.com/rust-lang/rust/commit/5ca1d353de16883a29732427b902501b7674fbe5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ca1d353de16883a29732427b902501b7674fbe5/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5571ca9b21f9b6aa9f8877700729564f829a6bef", "url": "https://api.github.com/repos/rust-lang/rust/commits/5571ca9b21f9b6aa9f8877700729564f829a6bef", "html_url": "https://github.com/rust-lang/rust/commit/5571ca9b21f9b6aa9f8877700729564f829a6bef"}], "stats": {"total": 93, "additions": 53, "deletions": 40}, "files": [{"sha": "c570188b8d25e5cc3bf8ed40108420914085510f", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 53, "deletions": 40, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/5ca1d353de16883a29732427b902501b7674fbe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca1d353de16883a29732427b902501b7674fbe5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=5ca1d353de16883a29732427b902501b7674fbe5", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use back::abi;\n use lib::llvm::{llvm, ValueRef, TypeRef, Bool, True, False};\n use metadata::csearch;\n use middle::const_eval;\n@@ -117,22 +118,6 @@ pub fn const_deref(cx: @CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn const_autoderef(cx: @CrateContext, ty: ty::t, v: ValueRef)\n-    -> (ty::t, ValueRef) {\n-    let mut t1 = ty;\n-    let mut v1 = v;\n-    loop {\n-        // Only rptrs can be autoderef'ed in a const context.\n-        match ty::get(t1).sty {\n-            ty::ty_rptr(_, mt) => {\n-                t1 = mt.ty;\n-                v1 = const_deref(cx, v1);\n-            }\n-            _ => return (t1,v1)\n-        }\n-    }\n-}\n-\n pub fn get_const_val(cx: @CrateContext, def_id: ast::def_id) -> ValueRef {\n     let mut def_id = def_id;\n     if !ast_util::is_local(def_id) ||\n@@ -153,15 +138,59 @@ pub fn get_const_val(cx: @CrateContext, def_id: ast::def_id) -> ValueRef {\n }\n \n pub fn const_expr(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n-    let ety = ty::expr_ty_adjusted(cx.tcx, e);\n-    let llty = type_of::sizing_type_of(cx, ety);\n-    let llconst = const_expr_unchecked(cx, e);\n+    let mut llconst = const_expr_unadjusted(cx, e);\n+    let ety = ty::expr_ty(cx.tcx, e);\n+    match cx.tcx.adjustments.find(&e.id) {\n+        None => { }\n+        Some(@ty::AutoAddEnv(ty::re_static, ast::BorrowedSigil)) => {\n+            llconst = C_struct(~[llconst, C_null(T_opaque_box_ptr(cx))])\n+        }\n+        Some(@ty::AutoAddEnv(ref r, ref s)) => {\n+            cx.sess.span_bug(e.span, fmt!(\"unexpected const function: \\\n+                                           region %? sigil %?\", *r, *s))\n+        }\n+        Some(@ty::AutoDerefRef(ref adj)) => {\n+            for adj.autoderefs.times {\n+                llconst = const_deref(cx, llconst)\n+            }\n+\n+            match adj.autoref {\n+                None => { }\n+                Some(ref autoref) => {\n+                    fail_unless!(autoref.region == ty::re_static);\n+                    fail_unless!(autoref.mutbl != ast::m_mutbl);\n+                    match autoref.kind {\n+                        ty::AutoPtr => {\n+                            llconst = const_addr_of(cx, llconst);\n+                        }\n+                        ty::AutoBorrowVec => {\n+                            let base = const_addr_of(cx, llconst);\n+                            let size = machine::llsize_of(cx,\n+                                                          val_ty(llconst));\n+                            fail_unless!(abi::slice_elt_base == 0);\n+                            fail_unless!(abi::slice_elt_len == 1);\n+                            llconst = C_struct(~[base, size]);\n+                        }\n+                        _ => {\n+                            cx.sess.span_bug(e.span,\n+                                             fmt!(\"unimplemented const \\\n+                                                   autoref %?\", autoref))\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    let ety_adjusted = ty::expr_ty_adjusted(cx.tcx, e);\n+    let llty = type_of::sizing_type_of(cx, ety_adjusted);\n     let csize = machine::llsize_of_alloc(cx, val_ty(llconst));\n     let tsize = machine::llsize_of_alloc(cx, llty);\n     if csize != tsize {\n         unsafe {\n+            // XXX these values could use some context\n             llvm::LLVMDumpValue(llconst);\n-            llvm::LLVMDumpValue(C_null(llty));\n+            llvm::LLVMDumpValue(C_undef(llty));\n         }\n         cx.sess.bug(fmt!(\"const %s of type %s has size %u instead of %u\",\n                          expr_repr(cx.tcx, e), ty_to_str(cx.tcx, ety),\n@@ -170,7 +199,7 @@ pub fn const_expr(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n     llconst\n }\n \n-fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n+fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n     unsafe {\n         let _icx = cx.insn_ctxt(\"const_expr\");\n         return match /*bad*/copy e.node {\n@@ -254,20 +283,18 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n             }\n           }\n           ast::expr_field(base, field, _) => {\n-              let bt = ty::expr_ty(cx.tcx, base);\n+              let bt = ty::expr_ty_adjusted(cx.tcx, base);\n               let brepr = adt::represent_type(cx, bt);\n               let bv = const_expr(cx, base);\n-              let (bt, bv) = const_autoderef(cx, bt, bv);\n               do expr::with_field_tys(cx.tcx, bt, None) |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx, field, field_tys);\n                   adt::const_get_field(cx, brepr, bv, discr, ix)\n               }\n           }\n \n           ast::expr_index(base, index) => {\n-              let bt = ty::expr_ty(cx.tcx, base);\n+              let bt = ty::expr_ty_adjusted(cx.tcx, base);\n               let bv = const_expr(cx, base);\n-              let (bt, bv) = const_autoderef(cx, bt, bv);\n               let iv = match const_eval::eval_const_expr(cx.tcx, index) {\n                   const_eval::const_int(i) => i as u64,\n                   const_eval::const_uint(u) => u,\n@@ -425,26 +452,12 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n             fail_unless!(pth.types.len() == 0);\n             match cx.tcx.def_map.find(&e.id) {\n                 Some(ast::def_fn(def_id, _purity)) => {\n-                    let f = if !ast_util::is_local(def_id) {\n+                    if !ast_util::is_local(def_id) {\n                         let ty = csearch::get_type(cx.tcx, def_id).ty;\n                         base::trans_external_path(cx, def_id, ty)\n                     } else {\n                         fail_unless!(ast_util::is_local(def_id));\n                         base::get_item_val(cx, def_id.node)\n-                    };\n-                    let ety = ty::expr_ty_adjusted(cx.tcx, e);\n-                    match ty::get(ety).sty {\n-                        ty::ty_bare_fn(*) | ty::ty_ptr(*) => {\n-                            llvm::LLVMConstPointerCast(f, T_ptr(T_i8()))\n-                        }\n-                        ty::ty_closure(*) => {\n-                            C_struct(~[f, C_null(T_opaque_box_ptr(cx))])\n-                        }\n-                        _ => {\n-                            cx.sess.span_bug(e.span, fmt!(\n-                                \"unexpected const fn type: %s\",\n-                                ty_to_str(cx.tcx, ety)))\n-                        }\n                     }\n                 }\n                 Some(ast::def_const(def_id)) => {"}]}