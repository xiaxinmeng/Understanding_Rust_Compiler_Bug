{"sha": "6dcd0a9b5e8b45262e3225ddff62d0a1098006ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkY2QwYTliNWU4YjQ1MjYyZTMyMjVkZGZmNjJkMGExMDk4MDA2Y2E=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-09-14T21:48:40Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-09-14T21:48:40Z"}, "message": "Remove mention of port, chan and task *types*, as they're not just library-provided. Move some text about channels into the comm section.", "tree": {"sha": "6035ca0131ef6ed0d630daffbe9e2171941977e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6035ca0131ef6ed0d630daffbe9e2171941977e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dcd0a9b5e8b45262e3225ddff62d0a1098006ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dcd0a9b5e8b45262e3225ddff62d0a1098006ca", "html_url": "https://github.com/rust-lang/rust/commit/6dcd0a9b5e8b45262e3225ddff62d0a1098006ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dcd0a9b5e8b45262e3225ddff62d0a1098006ca/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f13acbdbf17d80bd7638d28a8b54b86afc2704c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f13acbdbf17d80bd7638d28a8b54b86afc2704c7", "html_url": "https://github.com/rust-lang/rust/commit/f13acbdbf17d80bd7638d28a8b54b86afc2704c7"}], "stats": {"total": 108, "additions": 11, "deletions": 97}, "files": [{"sha": "db6421bf147ba383616e40aa74c3d83d7a280d59", "filename": "doc/rust.texi", "status": "modified", "additions": 11, "deletions": 97, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/6dcd0a9b5e8b45262e3225ddff62d0a1098006ca/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/6dcd0a9b5e8b45262e3225ddff62d0a1098006ca/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=6dcd0a9b5e8b45262e3225ddff62d0a1098006ca", "patch": "@@ -1474,6 +1474,15 @@ Each channel is bound to a port when the channel is constructed, so the\n destination port for a channel must exist before the channel itself. A channel\n cannot be rebound to a different port from the one it was constructed with.\n \n+Channels are weak: a channel does not keep the port it is bound to\n+alive. Ports are owned by their allocating task and cannot be sent over\n+channels; if a task dies its ports die with it, and all channels bound to\n+those ports no longer function. Messages sent to a channel connected to a dead\n+port will be dropped.\n+\n+Channels are immutable types with meaning known to the runtime; channels can\n+be sent over channels.\n+\n Many channels can be bound to the same port, but each channel is bound to a\n single port. In other words, channels and ports exist in an N:1 relationship,\n N channels to 1 port. @footnote{It may help to remember nautical terminology\n@@ -1482,20 +1491,14 @@ channels -- may lead to the same port.}\n \n Each port and channel can carry only one type of message. The message type is\n encoded as a parameter of the channel or port type. The message type of a\n-channel is equal to the message type of the port it is bound to.\n+channel is equal to the message type of the port it is bound to. The types of\n+messages must be of @emph{unique} kind.\n \n Messages are generally sent asynchronously, with optional rate-limiting on the\n transmit side. A channel contains a message queue and asynchronously sending a\n message merely inserts it into the sending channel's queue; message receipt is\n the responsibility of the receiving task.\n \n-Queued messages in channels are charged to the @emph{sending} task. If too\n-many messages are queued for transmission from a single sending task, without\n-being received by a receiving task, the sending task may exceed its memory\n-budget, which causes a run-time signal. To help control this possibility, a\n-semi-synchronous send operation is possible, which blocks until there is room\n-in the existing queue before sending send.\n-\n Messages are sent on channels and received on ports using standard library\n functions.\n \n@@ -2166,9 +2169,6 @@ Rust; they cannot be used as user-defined identifiers in any context.\n * Ref.Type.Tag::                Disjoint unions of heterogeneous types.\n * Ref.Type.Fn::                 Subroutine types.\n * Ref.Type.Iter::               Scoped coroutine types.\n-* Ref.Type.Port::               Unique inter-task message-receipt endpoints.\n-* Ref.Type.Chan::               Copyable inter-task message-send capabilities.\n-* Ref.Type.Task::               General coroutine-instance types.\n * Ref.Type.Obj::                Abstract types.\n * Ref.Type.Constr::             Constrained types.\n * Ref.Type.Type::               Types describing types.\n@@ -2472,92 +2472,6 @@ for each (i: int in range(5,7)) @{\n @}\n @end example\n \n-\n-@node       Ref.Type.Port\n-@subsection Ref.Type.Port\n-@cindex Port types\n-@cindex Communication\n-\n-The port type-constructor @code{port} forms types that describe ports. A port\n-is the @emph{receiving end} of a typed, asynchronous, simplex inter-task\n-communication facility. @xref{Ref.Task.Comm}. A @code{port} type takes a\n-single type parameter, denoting the type of value that can be received from a\n-@code{port} value of that type.\n-\n-Ports are modeled as stateful native types, with built-in meaning to the\n-language. They cannot be transmitted over channels or otherwise replicated,\n-and are always local to the task that creates them.\n-\n-Ports (like channels) can only be carry types of unique kind. No shared or\n-pinned values can pass over a port or channel.\n-\n-An example of a @code{port} type:\n-@example\n-type svp = port<[str]>;\n-let p: svp = get_port();\n-let v: [str] = p.recv();\n-@end example\n-\n-@node       Ref.Type.Chan\n-@subsection Ref.Type.Chan\n-@cindex Channel types\n-@cindex Communication\n-\n-The channel type-constructor @code{chan} forms types that describe channels. A\n-channel is the @emph{sending end} of a typed, asynchronous, simplex inter-task\n-communication facility. @xref{Ref.Task.Comm}. A @code{chan} type takes a\n-single type parameter, denoting the type of value that can be sent to a\n-channel of that type.\n-\n-Channels are immutable, and can be transmitted over channels to other\n-tasks. They are modeled as immutable native types with built-in meaning to the\n-language.\n-\n-Channels (like ports) can only be carry types of unique kind. No\n-pinned or shared values can pass over a port or channel.\n-\n-When a task sends a message into a channel, the task forms an outgoing queue\n-associated with that channel. The per-task queue @emph{associated} with a\n-channel can be indirectly manipulated by the task, but is @emph{not} otherwise\n-considered ``part of'' to the channel: the queue is ``part of'' the\n-@emph{sending task}. Sending a channel to another task does not copy the queue\n-associated with the channel.\n-\n-Channels are also @emph{weak}: a channel is directly coupled to a particular\n-destination port on a particular task, but does not keep that port or task\n-@emph{alive}. A channel may therefore fail to operate at any moment. If a task\n-sends a message to a channel that is connected to a nonexistent port, the\n-message is dropped.\n-\n-An example of a @code{chan} type:\n-@example\n-type svc = chan<[str]>;\n-let c: svc = get_chan();\n-let v: [str] = [\"hello\", \"world\"];\n-std::comm::send(c, v);\n-@end example\n-\n-@node       Ref.Type.Task\n-@subsection Ref.Type.Task\n-@cindex Task type\n-\n-The task type @code{task} describes values that are @emph{live\n-tasks}.\n-\n-Tasks form an @emph{ownership tree} in which each task (except the root task)\n-is directly owned by exactly one parent task. The purpose of a variable of\n-@code{task} type is to manage the lifecycle of the associated\n-task. Communication is carried out solely using channels and ports.\n-\n-Like ports, tasks are modeled as mutable native types with built-in meaning to\n-the language. They cannot be transmitted over channels or otherwise\n-replicated, and are always local to the task that spawns them.\n-\n-If all references to a task are dropped (due to the release of any structure\n-holding those references), the runtime signals the un-referenced task, which\n-then fails. @xref{Ref.Task.Life}.\n-\n-\n @node       Ref.Type.Obj\n @subsection Ref.Type.Obj\n @c * Ref.Type.Obj::                Object types."}]}