{"sha": "de1fc70ccd3bf7a0850e036a12cf866a80d46458", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlMWZjNzBjY2QzYmY3YTA4NTBlMDM2YTEyY2Y4NjZhODBkNDY0NTg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T17:32:54Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T17:32:54Z"}, "message": "internal: refactor find_map diagnostic", "tree": {"sha": "d93cc6be7678b8be01a5162e80bb3f8df84e8c50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d93cc6be7678b8be01a5162e80bb3f8df84e8c50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de1fc70ccd3bf7a0850e036a12cf866a80d46458", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de1fc70ccd3bf7a0850e036a12cf866a80d46458", "html_url": "https://github.com/rust-lang/rust/commit/de1fc70ccd3bf7a0850e036a12cf866a80d46458", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de1fc70ccd3bf7a0850e036a12cf866a80d46458/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24262f9ff6ae9ea326fa35d238704d18e99d52a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/24262f9ff6ae9ea326fa35d238704d18e99d52a1", "html_url": "https://github.com/rust-lang/rust/commit/24262f9ff6ae9ea326fa35d238704d18e99d52a1"}], "stats": {"total": 385, "additions": 192, "deletions": 193}, "files": [{"sha": "c294a803b28b755c3cca8cbbab84511118e305d5", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/de1fc70ccd3bf7a0850e036a12cf866a80d46458/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de1fc70ccd3bf7a0850e036a12cf866a80d46458/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=de1fc70ccd3bf7a0850e036a12cf866a80d46458", "patch": "@@ -41,6 +41,7 @@ diagnostics![\n     MissingUnsafe,\n     NoSuchField,\n     RemoveThisSemicolon,\n+    ReplaceFilterMapNextWithFindMap,\n     UnimplementedBuiltinMacro,\n     UnresolvedExternCrate,\n     UnresolvedImport,\n@@ -121,31 +122,13 @@ pub struct MissingFields {\n     pub missed_fields: Vec<Name>,\n }\n \n-// Diagnostic: replace-filter-map-next-with-find-map\n-//\n-// This diagnostic is triggered when `.filter_map(..).next()` is used, rather than the more concise `.find_map(..)`.\n #[derive(Debug)]\n pub struct ReplaceFilterMapNextWithFindMap {\n     pub file: HirFileId,\n     /// This expression is the whole method chain up to and including `.filter_map(..).next()`.\n     pub next_expr: AstPtr<ast::Expr>,\n }\n \n-impl Diagnostic for ReplaceFilterMapNextWithFindMap {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"replace-filter-map-next-with-find-map\")\n-    }\n-    fn message(&self) -> String {\n-        \"replace filter_map(..).next() with find_map(..)\".to_string()\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.next_expr.clone().into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct MismatchedArgCount {\n     pub call_expr: InFile<AstPtr<ast::Expr>>,"}, {"sha": "b2731b62fee447d9b21bf95b3578623860e8833a", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/de1fc70ccd3bf7a0850e036a12cf866a80d46458/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de1fc70ccd3bf7a0850e036a12cf866a80d46458/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=de1fc70ccd3bf7a0850e036a12cf866a80d46458", "patch": "@@ -1168,10 +1168,13 @@ impl Function {\n                 }\n                 BodyValidationDiagnostic::ReplaceFilterMapNextWithFindMap { method_call_expr } => {\n                     if let Ok(next_source_ptr) = source_map.expr_syntax(method_call_expr) {\n-                        sink.push(ReplaceFilterMapNextWithFindMap {\n-                            file: next_source_ptr.file_id,\n-                            next_expr: next_source_ptr.value,\n-                        });\n+                        acc.push(\n+                            ReplaceFilterMapNextWithFindMap {\n+                                file: next_source_ptr.file_id,\n+                                next_expr: next_source_ptr.value,\n+                            }\n+                            .into(),\n+                        );\n                     }\n                 }\n                 BodyValidationDiagnostic::MismatchedArgCount { call_expr, expected, found } => {"}, {"sha": "ec53185945082602b94cf5cb213de5be9ff2764d", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 86, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/de1fc70ccd3bf7a0850e036a12cf866a80d46458/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de1fc70ccd3bf7a0850e036a12cf866a80d46458/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=de1fc70ccd3bf7a0850e036a12cf866a80d46458", "patch": "@@ -13,6 +13,7 @@ mod missing_ok_or_some_in_tail_expr;\n mod missing_unsafe;\n mod no_such_field;\n mod remove_this_semicolon;\n+mod replace_filter_map_next_with_find_map;\n mod unimplemented_builtin_macro;\n mod unresolved_extern_crate;\n mod unresolved_import;\n@@ -167,9 +168,6 @@ pub(crate) fn diagnostics(\n         .on::<hir::diagnostics::IncorrectCase, _>(|d| {\n             res.borrow_mut().push(warning_with_fix(d, &sema, resolve));\n         })\n-        .on::<hir::diagnostics::ReplaceFilterMapNextWithFindMap, _>(|d| {\n-            res.borrow_mut().push(warning_with_fix(d, &sema, resolve));\n-        })\n         .on::<UnlinkedFile, _>(|d| {\n             // Limit diagnostic to the first few characters in the file. This matches how VS Code\n             // renders it with the full span, but on other editors, and is less invasive.\n@@ -225,6 +223,7 @@ pub(crate) fn diagnostics(\n             AnyDiagnostic::MissingUnsafe(d) => missing_unsafe::missing_unsafe(&ctx, &d),\n             AnyDiagnostic::NoSuchField(d) => no_such_field::no_such_field(&ctx, &d),\n             AnyDiagnostic::RemoveThisSemicolon(d) => remove_this_semicolon::remove_this_semicolon(&ctx, &d),\n+            AnyDiagnostic::ReplaceFilterMapNextWithFindMap(d) => replace_filter_map_next_with_find_map::replace_filter_map_next_with_find_map(&ctx, &d),\n             AnyDiagnostic::UnimplementedBuiltinMacro(d) => unimplemented_builtin_macro::unimplemented_builtin_macro(&ctx, &d),\n             AnyDiagnostic::UnresolvedExternCrate(d) => unresolved_extern_crate::unresolved_extern_crate(&ctx, &d),\n             AnyDiagnostic::UnresolvedImport(d) => unresolved_import::unresolved_import(&ctx, &d),\n@@ -672,89 +671,6 @@ mod foo;\n         );\n     }\n \n-    // Register the required standard library types to make the tests work\n-    fn add_filter_map_with_find_next_boilerplate(body: &str) -> String {\n-        let prefix = r#\"\n-        //- /main.rs crate:main deps:core\n-        use core::iter::Iterator;\n-        use core::option::Option::{self, Some, None};\n-        \"#;\n-        let suffix = r#\"\n-        //- /core/lib.rs crate:core\n-        pub mod option {\n-            pub enum Option<T> { Some(T), None }\n-        }\n-        pub mod iter {\n-            pub trait Iterator {\n-                type Item;\n-                fn filter_map<B, F>(self, f: F) -> FilterMap where F: FnMut(Self::Item) -> Option<B> { FilterMap }\n-                fn next(&mut self) -> Option<Self::Item>;\n-            }\n-            pub struct FilterMap {}\n-            impl Iterator for FilterMap {\n-                type Item = i32;\n-                fn next(&mut self) -> i32 { 7 }\n-            }\n-        }\n-        \"#;\n-        format!(\"{}{}{}\", prefix, body, suffix)\n-    }\n-\n-    #[test]\n-    fn replace_filter_map_next_with_find_map2() {\n-        check_diagnostics(&add_filter_map_with_find_next_boilerplate(\n-            r#\"\n-            fn foo() {\n-                let m = [1, 2, 3].iter().filter_map(|x| if *x == 2 { Some (4) } else { None }).next();\n-                      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ replace filter_map(..).next() with find_map(..)\n-            }\n-        \"#,\n-        ));\n-    }\n-\n-    #[test]\n-    fn replace_filter_map_next_with_find_map_no_diagnostic_without_next() {\n-        check_diagnostics(&add_filter_map_with_find_next_boilerplate(\n-            r#\"\n-            fn foo() {\n-                let m = [1, 2, 3]\n-                    .iter()\n-                    .filter_map(|x| if *x == 2 { Some (4) } else { None })\n-                    .len();\n-            }\n-            \"#,\n-        ));\n-    }\n-\n-    #[test]\n-    fn replace_filter_map_next_with_find_map_no_diagnostic_with_intervening_methods() {\n-        check_diagnostics(&add_filter_map_with_find_next_boilerplate(\n-            r#\"\n-            fn foo() {\n-                let m = [1, 2, 3]\n-                    .iter()\n-                    .filter_map(|x| if *x == 2 { Some (4) } else { None })\n-                    .map(|x| x + 2)\n-                    .len();\n-            }\n-            \"#,\n-        ));\n-    }\n-\n-    #[test]\n-    fn replace_filter_map_next_with_find_map_no_diagnostic_if_not_in_chain() {\n-        check_diagnostics(&add_filter_map_with_find_next_boilerplate(\n-            r#\"\n-            fn foo() {\n-                let m = [1, 2, 3]\n-                    .iter()\n-                    .filter_map(|x| if *x == 2 { Some (4) } else { None });\n-                let n = m.next();\n-            }\n-            \"#,\n-        ));\n-    }\n-\n     #[test]\n     fn missing_record_pat_field_no_diagnostic_if_not_exhaustive() {\n         check_diagnostics("}, {"sha": "e4bd90c3fc396e365de0825bc8d32bd6ef7ce46f", "filename": "crates/ide/src/diagnostics/fixes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/de1fc70ccd3bf7a0850e036a12cf866a80d46458/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de1fc70ccd3bf7a0850e036a12cf866a80d46458/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs?ref=de1fc70ccd3bf7a0850e036a12cf866a80d46458", "patch": "@@ -1,7 +1,6 @@\n //! Provides a way to attach fixes to the diagnostics.\n //! The same module also has all curret custom fixes for the diagnostics implemented.\n mod change_case;\n-mod replace_with_find_map;\n \n use hir::{diagnostics::Diagnostic, Semantics};\n use ide_assists::AssistResolveStrategy;"}, {"sha": "444bf563b557b02f798b0afad93a5a5e3eee03a2", "filename": "crates/ide/src/diagnostics/fixes/replace_with_find_map.rs", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/24262f9ff6ae9ea326fa35d238704d18e99d52a1/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Freplace_with_find_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24262f9ff6ae9ea326fa35d238704d18e99d52a1/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Freplace_with_find_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Freplace_with_find_map.rs?ref=24262f9ff6ae9ea326fa35d238704d18e99d52a1", "patch": "@@ -1,84 +0,0 @@\n-use hir::{db::AstDatabase, diagnostics::ReplaceFilterMapNextWithFindMap, Semantics};\n-use ide_assists::{Assist, AssistResolveStrategy};\n-use ide_db::{source_change::SourceChange, RootDatabase};\n-use syntax::{\n-    ast::{self, ArgListOwner},\n-    AstNode, TextRange,\n-};\n-use text_edit::TextEdit;\n-\n-use crate::diagnostics::{fix, DiagnosticWithFixes};\n-\n-impl DiagnosticWithFixes for ReplaceFilterMapNextWithFindMap {\n-    fn fixes(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        _resolve: &AssistResolveStrategy,\n-    ) -> Option<Vec<Assist>> {\n-        let root = sema.db.parse_or_expand(self.file)?;\n-        let next_expr = self.next_expr.to_node(&root);\n-        let next_call = ast::MethodCallExpr::cast(next_expr.syntax().clone())?;\n-\n-        let filter_map_call = ast::MethodCallExpr::cast(next_call.receiver()?.syntax().clone())?;\n-        let filter_map_name_range = filter_map_call.name_ref()?.ident_token()?.text_range();\n-        let filter_map_args = filter_map_call.arg_list()?;\n-\n-        let range_to_replace =\n-            TextRange::new(filter_map_name_range.start(), next_expr.syntax().text_range().end());\n-        let replacement = format!(\"find_map{}\", filter_map_args.syntax().text());\n-        let trigger_range = next_expr.syntax().text_range();\n-\n-        let edit = TextEdit::replace(range_to_replace, replacement);\n-\n-        let source_change = SourceChange::from_text_edit(self.file.original_file(sema.db), edit);\n-\n-        Some(vec![fix(\n-            \"replace_with_find_map\",\n-            \"Replace filter_map(..).next() with find_map()\",\n-            source_change,\n-            trigger_range,\n-        )])\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::diagnostics::tests::check_fix;\n-\n-    #[test]\n-    fn replace_with_wind_map() {\n-        check_fix(\n-            r#\"\n-//- /main.rs crate:main deps:core\n-use core::iter::Iterator;\n-use core::option::Option::{self, Some, None};\n-fn foo() {\n-    let m = [1, 2, 3].iter().$0filter_map(|x| if *x == 2 { Some (4) } else { None }).next();\n-}\n-//- /core/lib.rs crate:core\n-pub mod option {\n-    pub enum Option<T> { Some(T), None }\n-}\n-pub mod iter {\n-    pub trait Iterator {\n-        type Item;\n-        fn filter_map<B, F>(self, f: F) -> FilterMap where F: FnMut(Self::Item) -> Option<B> { FilterMap }\n-        fn next(&mut self) -> Option<Self::Item>;\n-    }\n-    pub struct FilterMap {}\n-    impl Iterator for FilterMap {\n-        type Item = i32;\n-        fn next(&mut self) -> i32 { 7 }\n-    }\n-}\n-\"#,\n-            r#\"\n-use core::iter::Iterator;\n-use core::option::Option::{self, Some, None};\n-fn foo() {\n-    let m = [1, 2, 3].iter().find_map(|x| if *x == 2 { Some (4) } else { None });\n-}\n-\"#,\n-        )\n-    }\n-}"}, {"sha": "f3b011495b8a8c8cd5af9090eeaa38acce9849b6", "filename": "crates/ide/src/diagnostics/replace_filter_map_next_with_find_map.rs", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/de1fc70ccd3bf7a0850e036a12cf866a80d46458/crates%2Fide%2Fsrc%2Fdiagnostics%2Freplace_filter_map_next_with_find_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de1fc70ccd3bf7a0850e036a12cf866a80d46458/crates%2Fide%2Fsrc%2Fdiagnostics%2Freplace_filter_map_next_with_find_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Freplace_filter_map_next_with_find_map.rs?ref=de1fc70ccd3bf7a0850e036a12cf866a80d46458", "patch": "@@ -0,0 +1,182 @@\n+use hir::{db::AstDatabase, InFile};\n+use ide_db::source_change::SourceChange;\n+use syntax::{\n+    ast::{self, ArgListOwner},\n+    AstNode, TextRange,\n+};\n+use text_edit::TextEdit;\n+\n+use crate::{\n+    diagnostics::{fix, Diagnostic, DiagnosticsContext},\n+    Assist, Severity,\n+};\n+\n+// Diagnostic: replace-filter-map-next-with-find-map\n+//\n+// This diagnostic is triggered when `.filter_map(..).next()` is used, rather than the more concise `.find_map(..)`.\n+pub(super) fn replace_filter_map_next_with_find_map(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::ReplaceFilterMapNextWithFindMap,\n+) -> Diagnostic {\n+    Diagnostic::new(\n+        \"replace-filter-map-next-with-find-map\",\n+        \"replace filter_map(..).next() with find_map(..)\",\n+        ctx.sema.diagnostics_display_range(InFile::new(d.file, d.next_expr.clone().into())).range,\n+    )\n+    .severity(Severity::WeakWarning)\n+    .with_fixes(fixes(ctx, d))\n+}\n+\n+fn fixes(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::ReplaceFilterMapNextWithFindMap,\n+) -> Option<Vec<Assist>> {\n+    let root = ctx.sema.db.parse_or_expand(d.file)?;\n+    let next_expr = d.next_expr.to_node(&root);\n+    let next_call = ast::MethodCallExpr::cast(next_expr.syntax().clone())?;\n+\n+    let filter_map_call = ast::MethodCallExpr::cast(next_call.receiver()?.syntax().clone())?;\n+    let filter_map_name_range = filter_map_call.name_ref()?.ident_token()?.text_range();\n+    let filter_map_args = filter_map_call.arg_list()?;\n+\n+    let range_to_replace =\n+        TextRange::new(filter_map_name_range.start(), next_expr.syntax().text_range().end());\n+    let replacement = format!(\"find_map{}\", filter_map_args.syntax().text());\n+    let trigger_range = next_expr.syntax().text_range();\n+\n+    let edit = TextEdit::replace(range_to_replace, replacement);\n+\n+    let source_change = SourceChange::from_text_edit(d.file.original_file(ctx.sema.db), edit);\n+\n+    Some(vec![fix(\n+        \"replace_with_find_map\",\n+        \"Replace filter_map(..).next() with find_map()\",\n+        source_change,\n+        trigger_range,\n+    )])\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::check_fix;\n+\n+    // Register the required standard library types to make the tests work\n+    #[track_caller]\n+    fn check_diagnostics(ra_fixture: &str) {\n+        let prefix = r#\"\n+//- /main.rs crate:main deps:core\n+use core::iter::Iterator;\n+use core::option::Option::{self, Some, None};\n+\"#;\n+        let suffix = r#\"\n+//- /core/lib.rs crate:core\n+pub mod option {\n+    pub enum Option<T> { Some(T), None }\n+}\n+pub mod iter {\n+    pub trait Iterator {\n+        type Item;\n+        fn filter_map<B, F>(self, f: F) -> FilterMap where F: FnMut(Self::Item) -> Option<B> { FilterMap }\n+        fn next(&mut self) -> Option<Self::Item>;\n+    }\n+    pub struct FilterMap {}\n+    impl Iterator for FilterMap {\n+        type Item = i32;\n+        fn next(&mut self) -> i32 { 7 }\n+    }\n+}\n+\"#;\n+        crate::diagnostics::tests::check_diagnostics(&format!(\"{}{}{}\", prefix, ra_fixture, suffix))\n+    }\n+\n+    #[test]\n+    fn replace_filter_map_next_with_find_map2() {\n+        check_diagnostics(\n+            r#\"\n+    fn foo() {\n+        let m = [1, 2, 3].iter().filter_map(|x| if *x == 2 { Some (4) } else { None }).next();\n+    }         //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ replace filter_map(..).next() with find_map(..)\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replace_filter_map_next_with_find_map_no_diagnostic_without_next() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    let m = [1, 2, 3]\n+        .iter()\n+        .filter_map(|x| if *x == 2 { Some (4) } else { None })\n+        .len();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replace_filter_map_next_with_find_map_no_diagnostic_with_intervening_methods() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    let m = [1, 2, 3]\n+        .iter()\n+        .filter_map(|x| if *x == 2 { Some (4) } else { None })\n+        .map(|x| x + 2)\n+        .len();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replace_filter_map_next_with_find_map_no_diagnostic_if_not_in_chain() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    let m = [1, 2, 3]\n+        .iter()\n+        .filter_map(|x| if *x == 2 { Some (4) } else { None });\n+    let n = m.next();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replace_with_wind_map() {\n+        check_fix(\n+            r#\"\n+//- /main.rs crate:main deps:core\n+use core::iter::Iterator;\n+use core::option::Option::{self, Some, None};\n+fn foo() {\n+    let m = [1, 2, 3].iter().$0filter_map(|x| if *x == 2 { Some (4) } else { None }).next();\n+}\n+//- /core/lib.rs crate:core\n+pub mod option {\n+    pub enum Option<T> { Some(T), None }\n+}\n+pub mod iter {\n+    pub trait Iterator {\n+        type Item;\n+        fn filter_map<B, F>(self, f: F) -> FilterMap where F: FnMut(Self::Item) -> Option<B> { FilterMap }\n+        fn next(&mut self) -> Option<Self::Item>;\n+    }\n+    pub struct FilterMap {}\n+    impl Iterator for FilterMap {\n+        type Item = i32;\n+        fn next(&mut self) -> i32 { 7 }\n+    }\n+}\n+\"#,\n+            r#\"\n+use core::iter::Iterator;\n+use core::option::Option::{self, Some, None};\n+fn foo() {\n+    let m = [1, 2, 3].iter().find_map(|x| if *x == 2 { Some (4) } else { None });\n+}\n+\"#,\n+        )\n+    }\n+}"}]}