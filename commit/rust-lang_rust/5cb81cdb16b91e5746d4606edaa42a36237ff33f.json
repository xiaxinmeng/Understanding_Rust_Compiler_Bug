{"sha": "5cb81cdb16b91e5746d4606edaa42a36237ff33f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjYjgxY2RiMTZiOTFlNTc0NmQ0NjA2ZWRhYTQyYTM2MjM3ZmYzM2Y=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-20T20:32:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-20T20:32:39Z"}, "message": "Merge pull request #839 from bjorn3/fold_offset_into_load_store\n\nSome runtime optimizations", "tree": {"sha": "30ad01fc1163e463cdb58065009d43292633aaea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30ad01fc1163e463cdb58065009d43292633aaea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cb81cdb16b91e5746d4606edaa42a36237ff33f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd/S/nCRBK7hj4Ov3rIwAAdHIIAKn4+1R+PboIVar+qKUUIlwj\nPZy1UU7FEQ0Ewlr2AXASCbyw+/kcMRCXm+U0OVYf05YIBYXoA55tsrQiXlTbGAfv\nhmNpnVdhHgh41laYygwRJLdaolL3aXQHh4FZX89nV9jNVFEXAdI7NAwKsDrL+Pt9\nW2pDeWUtFUyWVArTPZG7egJSkFBhpFCgqNtz/g15RCesM1miMDgK2/tbM9ljXCUG\n9+gTFQAsPTTuS6CqDeGe+eQKvEQ5yx+9IVfxbphgey4DOd4MeSY5Z+wzs3QtB6vE\nrDDqxnvrX8+fOnQb9wnhoCWUWCzAaAn9XI4TpeZ3S1LTRMW7/nfqXLhKzqMmhT8=\n=Crxq\n-----END PGP SIGNATURE-----\n", "payload": "tree 30ad01fc1163e463cdb58065009d43292633aaea\nparent 79ec8948d8b33c028647c6fe7df3426b8ff4987f\nparent fbbc910ddc00a9b88071aae0aa0d9bce64a3a1cc\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1576873959 +0100\ncommitter GitHub <noreply@github.com> 1576873959 +0100\n\nMerge pull request #839 from bjorn3/fold_offset_into_load_store\n\nSome runtime optimizations"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cb81cdb16b91e5746d4606edaa42a36237ff33f", "html_url": "https://github.com/rust-lang/rust/commit/5cb81cdb16b91e5746d4606edaa42a36237ff33f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cb81cdb16b91e5746d4606edaa42a36237ff33f/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79ec8948d8b33c028647c6fe7df3426b8ff4987f", "url": "https://api.github.com/repos/rust-lang/rust/commits/79ec8948d8b33c028647c6fe7df3426b8ff4987f", "html_url": "https://github.com/rust-lang/rust/commit/79ec8948d8b33c028647c6fe7df3426b8ff4987f"}, {"sha": "fbbc910ddc00a9b88071aae0aa0d9bce64a3a1cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbbc910ddc00a9b88071aae0aa0d9bce64a3a1cc", "html_url": "https://github.com/rust-lang/rust/commit/fbbc910ddc00a9b88071aae0aa0d9bce64a3a1cc"}], "stats": {"total": 417, "additions": 289, "deletions": 128}, "files": [{"sha": "3fc5b2f0bc85b4f03e33d59ce470ee81f6e0de0f", "filename": "src/abi/comments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fcomments.rs?ref=5cb81cdb16b91e5746d4606edaa42a36237ff33f", "patch": "@@ -94,14 +94,14 @@ pub fn add_local_place_comments<'tcx>(\n             align.abi.bytes(),\n             align.pref.bytes(),\n         )),\n-        CPlaceInner::Addr(addr, None) => fx.add_global_comment(format!(\n-            \"reuse {:5} {:20} {:4}b {}, {}              storage={}\",\n+        CPlaceInner::Addr(ptr, None) => fx.add_global_comment(format!(\n+            \"reuse {:5} {:20} {:4}b {}, {}              storage={:?}\",\n             format!(\"{:?}\", local),\n             format!(\"{:?}\", ty),\n             size.bytes(),\n             align.abi.bytes(),\n             align.pref.bytes(),\n-            addr,\n+            ptr,\n         )),\n         CPlaceInner::Addr(_, Some(_)) => unreachable!(),\n     }"}, {"sha": "c626ddfc18411f000759e6913206a720074f7f08", "filename": "src/abi/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=5cb81cdb16b91e5746d4606edaa42a36237ff33f", "patch": "@@ -250,9 +250,7 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n         let ret_vals = self.lib_call(name, input_tys, return_tys, &args);\n         match *ret_vals {\n             [] => CValue::by_ref(\n-                self.bcx\n-                    .ins()\n-                    .iconst(self.pointer_type, self.pointer_type.bytes() as i64),\n+                Pointer::const_addr(self, self.pointer_type.bytes() as i64),\n                 return_layout,\n             ),\n             [val] => CValue::by_val(val, return_layout),\n@@ -352,7 +350,7 @@ pub fn codegen_fn_prelude(fx: &mut FunctionCx<'_, '_, impl Backend>, start_ebb:\n                         // We wont mutate this argument, so it is fine to borrow the backing storage\n                         // of this argument, to prevent a copy.\n \n-                        let place = CPlace::for_addr(addr, val.layout());\n+                        let place = CPlace::for_ptr(Pointer::new(addr), val.layout());\n \n                         #[cfg(debug_assertions)]\n                         self::comments::add_local_place_comments(fx, place, local);\n@@ -613,7 +611,8 @@ pub fn codegen_drop<'tcx>(fx: &mut FunctionCx<'_, 'tcx, impl Backend>, drop_plac\n         let drop_fn_ty = drop_fn.ty(fx.tcx);\n         match ty.kind {\n             ty::Dynamic(..) => {\n-                let (ptr, vtable) = drop_place.to_addr_maybe_unsized(fx);\n+                let (ptr, vtable) = drop_place.to_ptr_maybe_unsized(fx);\n+                let ptr = ptr.get_addr(fx);\n                 let drop_fn = crate::vtable::drop_fn_of_obj(fx, vtable.unwrap());\n \n                 let fn_sig = fx.tcx.normalize_erasing_late_bound_regions("}, {"sha": "d37f05cd98652c0028e5722085ec29e32ef62600", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=5cb81cdb16b91e5746d4606edaa42a36237ff33f", "patch": "@@ -119,7 +119,7 @@ pub fn adjust_arg_for_abi<'tcx>(\n             let (a, b) = arg.load_scalar_pair(fx);\n             Pair(a, b)\n         }\n-        PassMode::ByRef => Single(arg.force_stack(fx)),\n+        PassMode::ByRef => Single(arg.force_stack(fx).get_addr(fx)),\n     }\n }\n \n@@ -158,6 +158,6 @@ pub fn cvalue_for_param<'tcx>(\n             let (a, b) = ebb_params.assert_pair();\n             Some(CValue::by_val_pair(a, b, layout))\n         }\n-        PassMode::ByRef => Some(CValue::by_ref(ebb_params.assert_single(), layout)),\n+        PassMode::ByRef => Some(CValue::by_ref(Pointer::new(ebb_params.assert_single()), layout)),\n     }\n }"}, {"sha": "d566a5176649677b2aa126d1e4baf5301311bce0", "filename": "src/abi/returning.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=5cb81cdb16b91e5746d4606edaa42a36237ff33f", "patch": "@@ -28,7 +28,7 @@ pub fn codegen_return_param(\n         PassMode::ByRef => {\n             let ret_param = fx.bcx.append_ebb_param(start_ebb, fx.pointer_type);\n             fx.local_map\n-                .insert(RETURN_PLACE, CPlace::for_addr(ret_param, ret_layout));\n+                .insert(RETURN_PLACE, CPlace::for_ptr(Pointer::new(ret_param), ret_layout));\n \n             Single(ret_param)\n         }\n@@ -58,7 +58,7 @@ pub fn codegen_with_call_return_arg<'tcx, B: Backend, T>(\n     let return_ptr = match output_pass_mode {\n         PassMode::NoPass => None,\n         PassMode::ByRef => match ret_place {\n-            Some(ret_place) => Some(ret_place.to_addr(fx)),\n+            Some(ret_place) => Some(ret_place.to_ptr(fx).get_addr(fx)),\n             None => Some(fx.bcx.ins().iconst(fx.pointer_type, 43)),\n         },\n         PassMode::ByVal(_) | PassMode::ByValPair(_, _) => None,"}, {"sha": "d118665b92bb30edc8867bf40788a696b15211b1", "filename": "src/analyze.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fanalyze.rs?ref=5cb81cdb16b91e5746d4606edaa42a36237ff33f", "patch": "@@ -30,14 +30,6 @@ pub fn analyze(fx: &FunctionCx<'_, '_, impl Backend>) -> IndexVec<Local, SsaKind\n                 _ => {}\n             }\n         }\n-\n-        match &bb.terminator().kind {\n-            TerminatorKind::Call {\n-                destination: Some((place, _)),\n-                ..\n-            } => analyze_non_ssa_place(&mut flag_map, place),\n-            _ => {}\n-        }\n     }\n \n     flag_map"}, {"sha": "db7ebd075350cba56e3d43f4f893022b33e0ed32", "filename": "src/base.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=5cb81cdb16b91e5746d4606edaa42a36237ff33f", "patch": "@@ -601,7 +601,7 @@ fn codegen_array_len<'tcx>(\n             fx.bcx.ins().iconst(fx.pointer_type, len)\n         }\n         ty::Slice(_elem_ty) => place\n-            .to_addr_maybe_unsized(fx)\n+            .to_ptr_maybe_unsized(fx)\n             .1\n             .expect(\"Length metadata for slice place\"),\n         _ => bug!(\"Rvalue::Len({:?})\", place),\n@@ -616,11 +616,13 @@ pub fn trans_place<'tcx>(\n         PlaceBase::Local(local) => fx.get_local_place(*local),\n         PlaceBase::Static(static_) => match static_.kind {\n             StaticKind::Static => {\n+                // Statics can't be generic, so `static_.ty` doesn't need to be monomorphized.\n                 crate::constant::codegen_static_ref(fx, static_.def_id, static_.ty)\n             }\n             StaticKind::Promoted(promoted, substs) => {\n                 let instance = Instance::new(static_.def_id, fx.monomorphize(&substs));\n-                crate::constant::trans_promoted(fx, instance, promoted, static_.ty)\n+                let ty = fx.monomorphize(&static_.ty);\n+                crate::constant::trans_promoted(fx, instance, promoted, ty)\n             }\n         },\n     };\n@@ -657,25 +659,21 @@ pub fn trans_place<'tcx>(\n                 match cplace.layout().ty.kind {\n                     ty::Array(elem_ty, len) => {\n                         let elem_layout = fx.layout_of(elem_ty);\n-                        let ptr = cplace.to_addr(fx);\n+                        let ptr = cplace.to_ptr(fx);\n                         let len = crate::constant::force_eval_const(fx, len)\n                             .eval_usize(fx.tcx, ParamEnv::reveal_all());\n-                        cplace = CPlace::for_addr(\n-                            fx.bcx\n-                                .ins()\n-                                .iadd_imm(ptr, elem_layout.size.bytes() as i64 * from as i64),\n+                        cplace = CPlace::for_ptr(\n+                            ptr.offset_i64(fx, elem_layout.size.bytes() as i64 * from as i64),\n                             fx.layout_of(fx.tcx.mk_array(elem_ty, len - from as u64 - to as u64)),\n                         );\n                     }\n                     ty::Slice(elem_ty) => {\n                         assert!(from_end, \"slice subslices should be `from_end`\");\n                         let elem_layout = fx.layout_of(elem_ty);\n-                        let (ptr, len) = cplace.to_addr_maybe_unsized(fx);\n+                        let (ptr, len) = cplace.to_ptr_maybe_unsized(fx);\n                         let len = len.unwrap();\n-                        cplace = CPlace::for_addr_with_extra(\n-                            fx.bcx\n-                                .ins()\n-                                .iadd_imm(ptr, elem_layout.size.bytes() as i64 * from as i64),\n+                        cplace = CPlace::for_ptr_with_extra(\n+                            ptr.offset_i64(fx, elem_layout.size.bytes() as i64 * from as i64),\n                             fx.bcx.ins().iadd_imm(len, -(from as i64 + to as i64)),\n                             cplace.layout(),\n                         );"}, {"sha": "53e0941d7e9c1b705920a313341fed9b012d75fa", "filename": "src/constant.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=5cb81cdb16b91e5746d4606edaa42a36237ff33f", "patch": "@@ -132,9 +132,7 @@ pub fn trans_const_value<'tcx>(\n             CValue::by_val(val, layout)\n         }\n         ty::FnDef(_def_id, _substs) => CValue::by_ref(\n-            fx.bcx\n-                .ins()\n-                .iconst(fx.pointer_type, fx.pointer_type.bytes() as i64),\n+            crate::pointer::Pointer::const_addr(fx, fx.pointer_type.bytes() as i64),\n             layout,\n         ),\n         _ => trans_const_place(fx, const_).to_cvalue(fx),\n@@ -265,7 +263,7 @@ fn cplace_for_dataid<'tcx>(\n     let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n     let layout = fx.layout_of(fx.monomorphize(&ty));\n     assert!(!layout.is_unsized(), \"unsized statics aren't supported\");\n-    CPlace::for_addr(global_ptr, layout)\n+    CPlace::for_ptr(crate::pointer::Pointer::new(global_ptr), layout)\n }\n \n fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut Module<impl Backend>, cx: &mut ConstantCx) {"}, {"sha": "44118edb6fd52cc72e6828d0d6572e084dd3bcc8", "filename": "src/intrinsics.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=5cb81cdb16b91e5746d4606edaa42a36237ff33f", "patch": "@@ -446,7 +446,7 @@ pub fn codegen_intrinsic_call<'tcx>(\n         };\n         discriminant_value, (c ptr) {\n             let pointee_layout = fx.layout_of(ptr.layout().ty.builtin_deref(true).unwrap().ty);\n-            let val = CValue::by_ref(ptr.load_scalar(fx), pointee_layout);\n+            let val = CValue::by_ref(Pointer::new(ptr.load_scalar(fx)), pointee_layout);\n             let discr = crate::discriminant::codegen_get_discriminant(fx, val, ret.layout());\n             ret.write_cvalue(fx, discr);\n         };\n@@ -615,6 +615,10 @@ pub fn codegen_intrinsic_call<'tcx>(\n                     let clif_ty = fx.clif_type(layout.ty).unwrap();\n                     let val = match clif_ty {\n                         types::I8 | types::I16 | types::I32 | types::I64 => fx.bcx.ins().iconst(clif_ty, 0),\n+                        types::I128 => {\n+                            let zero = fx.bcx.ins().iconst(types::I64, 0);\n+                            fx.bcx.ins().iconcat(zero, zero)\n+                        }\n                         types::F32 => {\n                             let zero = fx.bcx.ins().iconst(types::I32, 0);\n                             fx.bcx.ins().bitcast(types::F32, zero)\n@@ -629,7 +633,7 @@ pub fn codegen_intrinsic_call<'tcx>(\n                     fx.bcx.def_var(mir_var(var), val);\n                 }\n                 _ => {\n-                    let addr = ret.to_addr(fx);\n+                    let addr = ret.to_ptr(fx).get_addr(fx);\n                     let layout = ret.layout();\n                     fx.bcx.emit_small_memset(fx.module.target_config(), addr, 0, layout.size.bytes(), 1);\n                 }\n@@ -647,6 +651,11 @@ pub fn codegen_intrinsic_call<'tcx>(\n                     let clif_ty = fx.clif_type(layout.ty).unwrap();\n                     let val = match clif_ty {\n                         types::I8 | types::I16 | types::I32 | types::I64 => fx.bcx.ins().iconst(clif_ty, 42),\n+                        types::I128 => {\n+                            let zero = fx.bcx.ins().iconst(types::I64, 0);\n+                            let fourty_two = fx.bcx.ins().iconst(types::I64, 42);\n+                            fx.bcx.ins().iconcat(fourty_two, zero)\n+                        }\n                         types::F32 => {\n                             let zero = fx.bcx.ins().iconst(types::I32, 0xdeadbeef);\n                             fx.bcx.ins().bitcast(types::F32, zero)\n@@ -681,7 +690,8 @@ pub fn codegen_intrinsic_call<'tcx>(\n                 let msb_lz = fx.bcx.ins().clz(msb);\n                 let msb_is_zero = fx.bcx.ins().icmp_imm(IntCC::Equal, msb, 0);\n                 let lsb_lz_plus_64 = fx.bcx.ins().iadd_imm(lsb_lz, 64);\n-                fx.bcx.ins().select(msb_is_zero, lsb_lz_plus_64, msb_lz)\n+                let res = fx.bcx.ins().select(msb_is_zero, lsb_lz_plus_64, msb_lz);\n+                fx.bcx.ins().uextend(types::I128, res)\n             } else {\n                 fx.bcx.ins().clz(arg)\n             };\n@@ -697,7 +707,8 @@ pub fn codegen_intrinsic_call<'tcx>(\n                 let msb_tz = fx.bcx.ins().ctz(msb);\n                 let lsb_is_zero = fx.bcx.ins().icmp_imm(IntCC::Equal, lsb, 0);\n                 let msb_tz_plus_64 = fx.bcx.ins().iadd_imm(msb_tz, 64);\n-                fx.bcx.ins().select(lsb_is_zero, msb_tz_plus_64, lsb_tz)\n+                let res = fx.bcx.ins().select(lsb_is_zero, msb_tz_plus_64, lsb_tz);\n+                fx.bcx.ins().uextend(types::I128, res)\n             } else {\n                 fx.bcx.ins().ctz(arg)\n             };\n@@ -804,12 +815,12 @@ pub fn codegen_intrinsic_call<'tcx>(\n             // Cranelift treats loads as volatile by default\n             let inner_layout =\n                 fx.layout_of(ptr.layout().ty.builtin_deref(true).unwrap().ty);\n-            let val = CValue::by_ref(ptr.load_scalar(fx), inner_layout);\n+            let val = CValue::by_ref(Pointer::new(ptr.load_scalar(fx)), inner_layout);\n             ret.write_cvalue(fx, val);\n         };\n         volatile_store, (v ptr, c val) {\n             // Cranelift treats stores as volatile by default\n-            let dest = CPlace::for_addr(ptr, val.layout());\n+            let dest = CPlace::for_ptr(Pointer::new(ptr), val.layout());\n             dest.write_cvalue(fx, val);\n         };\n \n@@ -843,11 +854,11 @@ pub fn codegen_intrinsic_call<'tcx>(\n         _ if intrinsic.starts_with(\"atomic_load\"), (c ptr) {\n             let inner_layout =\n                 fx.layout_of(ptr.layout().ty.builtin_deref(true).unwrap().ty);\n-            let val = CValue::by_ref(ptr.load_scalar(fx), inner_layout);\n+            let val = CValue::by_ref(Pointer::new(ptr.load_scalar(fx)), inner_layout);\n             ret.write_cvalue(fx, val);\n         };\n         _ if intrinsic.starts_with(\"atomic_store\"), (v ptr, c val) {\n-            let dest = CPlace::for_addr(ptr, val.layout());\n+            let dest = CPlace::for_ptr(Pointer::new(ptr), val.layout());\n             dest.write_cvalue(fx, val);\n         };\n         _ if intrinsic.starts_with(\"atomic_xchg\"), <T> (v ptr, c src) {\n@@ -857,7 +868,7 @@ pub fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, CValue::by_val(old, fx.layout_of(T)));\n \n             // Write new\n-            let dest = CPlace::for_addr(ptr, src.layout());\n+            let dest = CPlace::for_ptr(Pointer::new(ptr), src.layout());\n             dest.write_cvalue(fx, src);\n         };\n         _ if intrinsic.starts_with(\"atomic_cxchg\"), <T> (v ptr, v test_old, v new) { // both atomic_cxchg_* and atomic_cxchgweak_*"}, {"sha": "dedad3b79c1f657c4c11a7e37c24666125ee13b9", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=5cb81cdb16b91e5746d4606edaa42a36237ff33f", "patch": "@@ -49,6 +49,7 @@ mod llvm_intrinsics;\n mod main_shim;\n mod metadata;\n mod num;\n+mod pointer;\n mod pretty_clif;\n mod target_features_whitelist;\n mod trap;\n@@ -106,6 +107,7 @@ mod prelude {\n     pub use crate::cast::*;\n     pub use crate::common::*;\n     pub use crate::debuginfo::{DebugContext, FunctionDebugContext};\n+    pub use crate::pointer::Pointer;\n     pub use crate::trap::*;\n     pub use crate::unimpl::unimpl;\n     pub use crate::value_and_place::{CPlace, CPlaceInner, CValue};"}, {"sha": "3899dd15fa43d0f2711e1a6c1dbb906f65614a53", "filename": "src/pointer.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpointer.rs?ref=5cb81cdb16b91e5746d4606edaa42a36237ff33f", "patch": "@@ -0,0 +1,154 @@\n+use crate::prelude::*;\n+\n+use cranelift::codegen::ir::immediates::Offset32;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct Pointer {\n+    base: PointerBase,\n+    offset: Offset32,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum PointerBase {\n+    Addr(Value),\n+    Stack(StackSlot),\n+}\n+\n+impl Pointer {\n+    pub fn new(addr: Value) -> Self {\n+        Pointer {\n+            base: PointerBase::Addr(addr),\n+            offset: Offset32::new(0),\n+        }\n+    }\n+\n+    pub fn stack_slot(stack_slot: StackSlot) -> Self {\n+        Pointer {\n+            base: PointerBase::Stack(stack_slot),\n+            offset: Offset32::new(0),\n+        }\n+    }\n+\n+    pub fn const_addr<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx, impl Backend>, addr: i64) -> Self {\n+        let addr = fx.bcx.ins().iconst(fx.pointer_type, addr);\n+        Pointer {\n+            base: PointerBase::Addr(addr),\n+            offset: Offset32::new(0),\n+        }\n+    }\n+\n+    pub fn get_addr<'a, 'tcx>(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> Value {\n+        match self.base {\n+            PointerBase::Addr(base_addr) => {\n+                let offset: i64 = self.offset.into();\n+                if offset == 0 {\n+                    base_addr\n+                } else {\n+                    fx.bcx.ins().iadd_imm(base_addr, offset)\n+                }\n+            }\n+            PointerBase::Stack(stack_slot) => fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, self.offset),\n+        }\n+    }\n+\n+    pub fn try_get_addr_and_offset(self) -> Option<(Value, Offset32)> {\n+        match self.base {\n+            PointerBase::Addr(addr) => Some((addr, self.offset)),\n+            PointerBase::Stack(_) => None,\n+        }\n+    }\n+\n+    pub fn offset<'a, 'tcx>(\n+        self,\n+        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+        extra_offset: Offset32,\n+    ) -> Self {\n+        self.offset_i64(fx, extra_offset.into())\n+    }\n+\n+    pub fn offset_i64<'a, 'tcx>(\n+        self,\n+        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+        extra_offset: i64,\n+    ) -> Self {\n+        if let Some(new_offset) = self.offset.try_add_i64(extra_offset) {\n+            Pointer {\n+                base: self.base,\n+                offset: new_offset,\n+            }\n+        } else {\n+            let base_offset: i64 = self.offset.into();\n+            if let Some(new_offset) = base_offset.checked_add(extra_offset){\n+                let base_addr = match self.base {\n+                    PointerBase::Addr(addr) => addr,\n+                    PointerBase::Stack(stack_slot) => fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0),\n+                };\n+                let addr = fx.bcx.ins().iadd_imm(base_addr, new_offset);\n+                Pointer {\n+                    base: PointerBase::Addr(addr),\n+                    offset: Offset32::new(0),\n+                }\n+            } else {\n+                panic!(\"self.offset ({}) + extra_offset ({}) not representable in i64\", base_offset, extra_offset);\n+            }\n+        }\n+    }\n+\n+    pub fn offset_value<'a, 'tcx>(\n+        self,\n+        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+        extra_offset: Value,\n+    ) -> Self {\n+        match self.base {\n+            PointerBase::Addr(addr) => Pointer {\n+                base: PointerBase::Addr(fx.bcx.ins().iadd(addr, extra_offset)),\n+                offset: self.offset,\n+            },\n+            PointerBase::Stack(stack_slot) => {\n+                let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, self.offset);\n+                Pointer {\n+                    base: PointerBase::Addr(fx.bcx.ins().iadd(base_addr, extra_offset)),\n+                    offset: Offset32::new(0),\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn load<'a, 'tcx>(\n+        self,\n+        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+        ty: Type,\n+        flags: MemFlags,\n+    ) -> Value {\n+        match self.base {\n+            PointerBase::Addr(base_addr) => fx.bcx.ins().load(ty, flags, base_addr, self.offset),\n+            PointerBase::Stack(stack_slot) => if ty == types::I128 {\n+                // WORKAROUND for stack_load.i128 not being implemented\n+                let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n+                fx.bcx.ins().load(ty, flags, base_addr, self.offset)\n+            } else {\n+                fx.bcx.ins().stack_load(ty, stack_slot, self.offset)\n+            }\n+        }\n+    }\n+\n+    pub fn store<'a, 'tcx>(\n+        self,\n+        fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+        value: Value,\n+        flags: MemFlags,\n+    ) {\n+        match self.base {\n+            PointerBase::Addr(base_addr) => {\n+                fx.bcx.ins().store(flags, value, base_addr, self.offset);\n+            }\n+            PointerBase::Stack(stack_slot) => if fx.bcx.func.dfg.value_type(value) == types::I128 {\n+                // WORKAROUND for stack_load.i128 not being implemented\n+                let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n+                fx.bcx.ins().store(flags, value, base_addr, self.offset);\n+            } else {\n+                fx.bcx.ins().stack_store(value, stack_slot, self.offset);\n+            }\n+        }\n+    }\n+}"}, {"sha": "e297b27debb3dd74ba2cb2326cd463ce9f2f5bf6", "filename": "src/trap.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftrap.rs?ref=5cb81cdb16b91e5746d4606edaa42a36237ff33f", "patch": "@@ -91,8 +91,7 @@ pub fn trap_unreachable_ret_value<'tcx>(\n     msg: impl AsRef<str>,\n ) -> CValue<'tcx> {\n     trap_unimplemented(fx, msg);\n-    let zero = fx.bcx.ins().iconst(fx.pointer_type, 0);\n-    CValue::by_ref(zero, dest_layout)\n+    CValue::by_ref(Pointer::const_addr(fx, 0), dest_layout)\n }\n \n /// Like `trap_unreachable` but returns a fake place for the specified type.\n@@ -104,6 +103,5 @@ pub fn trap_unreachable_ret_place<'tcx>(\n     msg: impl AsRef<str>,\n ) -> CPlace<'tcx> {\n     trap_unimplemented(fx, msg);\n-    let zero = fx.bcx.ins().iconst(fx.pointer_type, 0);\n-    CPlace::for_addr(zero, dest_layout)\n+    CPlace::for_ptr(Pointer::const_addr(fx, 0), dest_layout)\n }"}, {"sha": "8a497df1e7e9327bf7d20756717b8de192677709", "filename": "src/value_and_place.rs", "status": "modified", "additions": 76, "deletions": 73, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=5cb81cdb16b91e5746d4606edaa42a36237ff33f", "patch": "@@ -1,24 +1,22 @@\n use crate::prelude::*;\n \n+use cranelift::codegen::ir::immediates::Offset32;\n+\n fn codegen_field<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n-    base: Value,\n+    base: Pointer,\n     extra: Option<Value>,\n     layout: TyLayout<'tcx>,\n     field: mir::Field,\n-) -> (Value, TyLayout<'tcx>) {\n+) -> (Pointer, TyLayout<'tcx>) {\n     let field_offset = layout.fields.offset(field.index());\n     let field_layout = layout.field(&*fx, field.index());\n \n     let simple = |fx: &mut FunctionCx<_>| {\n-        if field_offset.bytes() > 0 {\n-            (\n-                fx.bcx.ins().iadd_imm(base, field_offset.bytes() as i64),\n-                field_layout,\n-            )\n-        } else {\n-            (base, field_layout)\n-        }\n+        (\n+            base.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap()),\n+            field_layout,\n+        )\n     };\n \n     if let Some(extra) = extra {\n@@ -44,7 +42,7 @@ fn codegen_field<'tcx>(\n                 let offset = fx.bcx.ins().band(and_lhs, and_rhs);\n \n                 (\n-                    fx.bcx.ins().iadd(base, offset),\n+                    base.offset_value(fx, offset),\n                     field_layout,\n                 )\n             }\n@@ -54,12 +52,12 @@ fn codegen_field<'tcx>(\n     }\n }\n \n-fn scalar_pair_calculate_b_offset(tcx: TyCtxt<'_>, a_scalar: &Scalar, b_scalar: &Scalar) -> i32 {\n+fn scalar_pair_calculate_b_offset(tcx: TyCtxt<'_>, a_scalar: &Scalar, b_scalar: &Scalar) -> Offset32 {\n     let b_offset = a_scalar\n         .value\n         .size(&tcx)\n         .align_to(b_scalar.value.align(&tcx).abi);\n-    b_offset.bytes().try_into().unwrap()\n+    Offset32::new(b_offset.bytes().try_into().unwrap())\n }\n \n /// A read-only value\n@@ -68,14 +66,14 @@ pub struct CValue<'tcx>(CValueInner, TyLayout<'tcx>);\n \n #[derive(Debug, Copy, Clone)]\n enum CValueInner {\n-    ByRef(Value),\n+    ByRef(Pointer),\n     ByVal(Value),\n     ByValPair(Value, Value),\n }\n \n impl<'tcx> CValue<'tcx> {\n-    pub fn by_ref(value: Value, layout: TyLayout<'tcx>) -> CValue<'tcx> {\n-        CValue(CValueInner::ByRef(value), layout)\n+    pub fn by_ref(ptr: Pointer, layout: TyLayout<'tcx>) -> CValue<'tcx> {\n+        CValue(CValueInner::ByRef(ptr), layout)\n     }\n \n     pub fn by_val(value: Value, layout: TyLayout<'tcx>) -> CValue<'tcx> {\n@@ -90,21 +88,31 @@ impl<'tcx> CValue<'tcx> {\n         self.1\n     }\n \n-    pub fn force_stack<'a>(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>) -> Value {\n+    pub fn force_stack<'a>(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>) -> Pointer {\n         let layout = self.1;\n         match self.0 {\n-            CValueInner::ByRef(value) => value,\n+            CValueInner::ByRef(ptr) => ptr,\n             CValueInner::ByVal(_) | CValueInner::ByValPair(_, _) => {\n                 let cplace = CPlace::new_stack_slot(fx, layout.ty);\n                 cplace.write_cvalue(fx, self);\n-                cplace.to_addr(fx)\n+                cplace.to_ptr(fx)\n             }\n         }\n     }\n \n     pub fn try_to_addr(self) -> Option<Value> {\n         match self.0 {\n-            CValueInner::ByRef(addr) => Some(addr),\n+            CValueInner::ByRef(ptr) => {\n+                if let Some((base_addr, offset)) = ptr.try_get_addr_and_offset() {\n+                    if offset == Offset32::new(0) {\n+                        Some(base_addr)\n+                    } else {\n+                        None\n+                    }\n+                } else {\n+                    None\n+                }\n+            }\n             CValueInner::ByVal(_) | CValueInner::ByValPair(_, _) => None,\n         }\n     }\n@@ -113,13 +121,13 @@ impl<'tcx> CValue<'tcx> {\n     pub fn load_scalar<'a>(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>) -> Value {\n         let layout = self.1;\n         match self.0 {\n-            CValueInner::ByRef(addr) => {\n+            CValueInner::ByRef(ptr) => {\n                 let scalar = match layout.abi {\n                     layout::Abi::Scalar(ref scalar) => scalar.clone(),\n                     _ => unreachable!(),\n                 };\n                 let clif_ty = scalar_to_clif_type(fx.tcx, scalar);\n-                fx.bcx.ins().load(clif_ty, MemFlags::new(), addr, 0)\n+                ptr.load(fx, clif_ty, MemFlags::new())\n             }\n             CValueInner::ByVal(value) => value,\n             CValueInner::ByValPair(_, _) => bug!(\"Please use load_scalar_pair for ByValPair\"),\n@@ -133,16 +141,16 @@ impl<'tcx> CValue<'tcx> {\n     ) -> (Value, Value) {\n         let layout = self.1;\n         match self.0 {\n-            CValueInner::ByRef(addr) => {\n+            CValueInner::ByRef(ptr) => {\n                 let (a_scalar, b_scalar) = match &layout.abi {\n                     layout::Abi::ScalarPair(a, b) => (a, b),\n                     _ => unreachable!(\"load_scalar_pair({:?})\", self),\n                 };\n                 let b_offset = scalar_pair_calculate_b_offset(fx.tcx, a_scalar, b_scalar);\n                 let clif_ty1 = scalar_to_clif_type(fx.tcx, a_scalar.clone());\n                 let clif_ty2 = scalar_to_clif_type(fx.tcx, b_scalar.clone());\n-                let val1 = fx.bcx.ins().load(clif_ty1, MemFlags::new(), addr, 0);\n-                let val2 = fx.bcx.ins().load(clif_ty2, MemFlags::new(), addr, b_offset);\n+                let val1 = ptr.load(fx, clif_ty1, MemFlags::new());\n+                let val2 = ptr.offset(fx, b_offset).load(fx, clif_ty2, MemFlags::new());\n                 (val1, val2)\n             }\n             CValueInner::ByVal(_) => bug!(\"Please use load_scalar for ByVal\"),\n@@ -156,12 +164,12 @@ impl<'tcx> CValue<'tcx> {\n         field: mir::Field,\n     ) -> CValue<'tcx> {\n         let layout = self.1;\n-        let base = match self.0 {\n-            CValueInner::ByRef(addr) => addr,\n+        let ptr = match self.0 {\n+            CValueInner::ByRef(ptr) => ptr,\n             _ => bug!(\"place_field for {:?}\", self),\n         };\n \n-        let (field_ptr, field_layout) = codegen_field(fx, base, None, layout, field);\n+        let (field_ptr, field_layout) = codegen_field(fx, ptr, None, layout, field);\n         CValue::by_ref(field_ptr, field_layout)\n     }\n \n@@ -224,7 +232,7 @@ pub struct CPlace<'tcx> {\n #[derive(Debug, Copy, Clone)]\n pub enum CPlaceInner {\n     Var(Local),\n-    Addr(Value, Option<Value>),\n+    Addr(Pointer, Option<Value>),\n     Stack(StackSlot),\n     NoPlace,\n }\n@@ -282,16 +290,16 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n-    pub fn for_addr(addr: Value, layout: TyLayout<'tcx>) -> CPlace<'tcx> {\n+    pub fn for_ptr(ptr: Pointer, layout: TyLayout<'tcx>) -> CPlace<'tcx> {\n         CPlace {\n-            inner: CPlaceInner::Addr(addr, None),\n+            inner: CPlaceInner::Addr(ptr, None),\n             layout,\n         }\n     }\n \n-    pub fn for_addr_with_extra(addr: Value, extra: Value, layout: TyLayout<'tcx>) -> CPlace<'tcx> {\n+    pub fn for_ptr_with_extra(ptr: Pointer, extra: Value, layout: TyLayout<'tcx>) -> CPlace<'tcx> {\n         CPlace {\n-            inner: CPlaceInner::Addr(addr, Some(extra)),\n+            inner: CPlaceInner::Addr(ptr, Some(extra)),\n             layout,\n         }\n     }\n@@ -304,47 +312,42 @@ impl<'tcx> CPlace<'tcx> {\n                 fx.bcx.set_val_label(val, cranelift::codegen::ir::ValueLabel::from_u32(var.as_u32()));\n                 CValue::by_val(val, layout)\n             }\n-            CPlaceInner::Addr(addr, extra) => {\n+            CPlaceInner::Addr(ptr, extra) => {\n                 assert!(extra.is_none(), \"unsized values are not yet supported\");\n-                CValue::by_ref(addr, layout)\n+                CValue::by_ref(ptr, layout)\n             }\n             CPlaceInner::Stack(stack_slot) => CValue::by_ref(\n-                fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0),\n+                Pointer::stack_slot(stack_slot),\n                 layout,\n             ),\n             CPlaceInner::NoPlace => CValue::by_ref(\n-                fx.bcx\n-                    .ins()\n-                    .iconst(fx.pointer_type, fx.pointer_type.bytes() as i64),\n+                Pointer::const_addr(fx, i64::try_from(self.layout.align.pref.bytes()).unwrap()),\n                 layout,\n             ),\n         }\n     }\n \n-    pub fn to_addr(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>) -> Value {\n-        match self.to_addr_maybe_unsized(fx) {\n-            (addr, None) => addr,\n+    pub fn to_ptr(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>) -> Pointer {\n+        match self.to_ptr_maybe_unsized(fx) {\n+            (ptr, None) => ptr,\n             (_, Some(_)) => bug!(\"Expected sized cplace, found {:?}\", self),\n         }\n     }\n \n-    pub fn to_addr_maybe_unsized(\n+    pub fn to_ptr_maybe_unsized(\n         self,\n         fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n-    ) -> (Value, Option<Value>) {\n+    ) -> (Pointer, Option<Value>) {\n         match self.inner {\n-            CPlaceInner::Addr(addr, extra) => (addr, extra),\n+            CPlaceInner::Addr(ptr, extra) => (ptr, extra),\n             CPlaceInner::Stack(stack_slot) => (\n-                fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0),\n+                Pointer::stack_slot(stack_slot),\n                 None,\n             ),\n             CPlaceInner::NoPlace => {\n                 (\n-                    fx.bcx.ins().iconst(\n-                        fx.pointer_type,\n-                        i64::try_from(self.layout.align.pref.bytes()).unwrap(),\n-                    ),\n-                    None\n+                    Pointer::const_addr(fx, i64::try_from(self.layout.align.pref.bytes()).unwrap()),\n+                    None,\n                 )\n             }\n             CPlaceInner::Var(_) => bug!(\"Expected CPlace::Addr, found CPlace::Var\"),\n@@ -420,17 +423,15 @@ impl<'tcx> CPlace<'tcx> {\n         assert_assignable(fx, from_ty, to_ty);\n \n         let dst_layout = self.layout();\n-        let addr = match self.inner {\n+        let to_ptr = match self.inner {\n             CPlaceInner::Var(var) => {\n                 let data = from.load_scalar(fx);\n                 fx.bcx.set_val_label(data, cranelift::codegen::ir::ValueLabel::from_u32(var.as_u32()));\n                 fx.bcx.def_var(mir_var(var), data);\n                 return;\n             }\n-            CPlaceInner::Addr(addr, None) => addr,\n-            CPlaceInner::Stack(stack_slot) => {\n-                fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0)\n-            }\n+            CPlaceInner::Addr(ptr, None) => ptr,\n+            CPlaceInner::Stack(stack_slot) => Pointer::stack_slot(stack_slot),\n             CPlaceInner::NoPlace => {\n                 if dst_layout.abi != Abi::Uninhabited {\n                     assert_eq!(dst_layout.size.bytes(), 0, \"{:?}\", dst_layout);\n@@ -442,27 +443,29 @@ impl<'tcx> CPlace<'tcx> {\n \n         match from.0 {\n             CValueInner::ByVal(val) => {\n-                fx.bcx.ins().store(MemFlags::new(), val, addr, 0);\n+                to_ptr.store(fx, val, MemFlags::new());\n             }\n             CValueInner::ByValPair(value, extra) => match dst_layout.abi {\n                 Abi::ScalarPair(ref a_scalar, ref b_scalar) => {\n                     let b_offset = scalar_pair_calculate_b_offset(fx.tcx, a_scalar, b_scalar);\n-                    fx.bcx.ins().store(MemFlags::new(), value, addr, 0);\n-                    fx.bcx.ins().store(MemFlags::new(), extra, addr, b_offset);\n+                    to_ptr.store(fx, value, MemFlags::new());\n+                    to_ptr.offset(fx, b_offset).store(fx, extra, MemFlags::new());\n                 }\n                 _ => bug!(\n                     \"Non ScalarPair abi {:?} for ByValPair CValue\",\n                     dst_layout.abi\n                 ),\n             },\n-            CValueInner::ByRef(from_addr) => {\n+            CValueInner::ByRef(from_ptr) => {\n+                let from_addr = from_ptr.get_addr(fx);\n+                let to_addr = to_ptr.get_addr(fx);\n                 let src_layout = from.1;\n                 let size = dst_layout.size.bytes();\n                 let src_align = src_layout.align.abi.bytes() as u8;\n                 let dst_align = dst_layout.align.abi.bytes() as u8;\n                 fx.bcx.emit_small_memcpy(\n                     fx.module.target_config(),\n-                    addr,\n+                    to_addr,\n                     from_addr,\n                     size,\n                     dst_align,\n@@ -478,13 +481,13 @@ impl<'tcx> CPlace<'tcx> {\n         field: mir::Field,\n     ) -> CPlace<'tcx> {\n         let layout = self.layout();\n-        let (base, extra) = self.to_addr_maybe_unsized(fx);\n+        let (base, extra) = self.to_ptr_maybe_unsized(fx);\n \n         let (field_ptr, field_layout) = codegen_field(fx, base, extra, layout, field);\n         if field_layout.is_unsized() {\n-            CPlace::for_addr_with_extra(field_ptr, extra.unwrap(), field_layout)\n+            CPlace::for_ptr_with_extra(field_ptr, extra.unwrap(), field_layout)\n         } else {\n-            CPlace::for_addr(field_ptr, field_layout)\n+            CPlace::for_ptr(field_ptr, field_layout)\n         }\n     }\n \n@@ -493,9 +496,9 @@ impl<'tcx> CPlace<'tcx> {\n         fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n         index: Value,\n     ) -> CPlace<'tcx> {\n-        let (elem_layout, addr) = match self.layout().ty.kind {\n-            ty::Array(elem_ty, _) => (fx.layout_of(elem_ty), self.to_addr(fx)),\n-            ty::Slice(elem_ty) => (fx.layout_of(elem_ty), self.to_addr_maybe_unsized(fx).0),\n+        let (elem_layout, ptr) = match self.layout().ty.kind {\n+            ty::Array(elem_ty, _) => (fx.layout_of(elem_ty), self.to_ptr(fx)),\n+            ty::Slice(elem_ty) => (fx.layout_of(elem_ty), self.to_ptr_maybe_unsized(fx).0),\n             _ => bug!(\"place_index({:?})\", self.layout().ty),\n         };\n \n@@ -504,30 +507,30 @@ impl<'tcx> CPlace<'tcx> {\n             .ins()\n             .imul_imm(index, elem_layout.size.bytes() as i64);\n \n-        CPlace::for_addr(fx.bcx.ins().iadd(addr, offset), elem_layout)\n+        CPlace::for_ptr(ptr.offset_value(fx, offset), elem_layout)\n     }\n \n     pub fn place_deref(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>) -> CPlace<'tcx> {\n         let inner_layout = fx.layout_of(self.layout().ty.builtin_deref(true).unwrap().ty);\n         if has_ptr_meta(fx.tcx, inner_layout.ty) {\n             let (addr, extra) = self.to_cvalue(fx).load_scalar_pair(fx);\n-            CPlace::for_addr_with_extra(addr, extra, inner_layout)\n+            CPlace::for_ptr_with_extra(Pointer::new(addr), extra, inner_layout)\n         } else {\n-            CPlace::for_addr(self.to_cvalue(fx).load_scalar(fx), inner_layout)\n+            CPlace::for_ptr(Pointer::new(self.to_cvalue(fx).load_scalar(fx)), inner_layout)\n         }\n     }\n \n     pub fn write_place_ref(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>, dest: CPlace<'tcx>) {\n         if has_ptr_meta(fx.tcx, self.layout().ty) {\n-            let (value, extra) = self.to_addr_maybe_unsized(fx);\n+            let (ptr, extra) = self.to_ptr_maybe_unsized(fx);\n             let ptr = CValue::by_val_pair(\n-                value,\n+                ptr.get_addr(fx),\n                 extra.expect(\"unsized type without metadata\"),\n                 dest.layout(),\n             );\n             dest.write_cvalue(fx, ptr);\n         } else {\n-            let ptr = CValue::by_val(self.to_addr(fx), dest.layout());\n+            let ptr = CValue::by_val(self.to_ptr(fx).get_addr(fx), dest.layout());\n             dest.write_cvalue(fx, ptr);\n         }\n     }"}, {"sha": "c12dff3cdc6b3a6c01515ec02c2072a2a111517d", "filename": "src/vtable.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cb81cdb16b91e5746d4606edaa42a36237ff33f/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=5cb81cdb16b91e5746d4606edaa42a36237ff33f", "patch": "@@ -6,11 +6,17 @@ const DROP_FN_INDEX: usize = 0;\n const SIZE_INDEX: usize = 1;\n const ALIGN_INDEX: usize = 2;\n \n+fn vtable_memflags() -> MemFlags {\n+    let mut flags = MemFlags::trusted(); // A vtable access is always aligned and will never trap.\n+    flags.set_readonly(); // A vtable is always read-only.\n+    flags\n+}\n+\n pub fn drop_fn_of_obj(fx: &mut FunctionCx<'_, '_, impl Backend>, vtable: Value) -> Value {\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n         pointer_ty(fx.tcx),\n-        MemFlags::new(),\n+        vtable_memflags(),\n         vtable,\n         (DROP_FN_INDEX * usize_size) as i32,\n     )\n@@ -20,7 +26,7 @@ pub fn size_of_obj(fx: &mut FunctionCx<'_, '_, impl Backend>, vtable: Value) ->\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n         pointer_ty(fx.tcx),\n-        MemFlags::new(),\n+        vtable_memflags(),\n         vtable,\n         (SIZE_INDEX * usize_size) as i32,\n     )\n@@ -30,7 +36,7 @@ pub fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, impl Backend>, vtable: Value\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n         pointer_ty(fx.tcx),\n-        MemFlags::new(),\n+        vtable_memflags(),\n         vtable,\n         (ALIGN_INDEX * usize_size) as i32,\n     )\n@@ -45,7 +51,7 @@ pub fn get_ptr_and_method_ref<'tcx>(\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes();\n     let func_ref = fx.bcx.ins().load(\n         pointer_ty(fx.tcx),\n-        MemFlags::new(),\n+        vtable_memflags(),\n         vtable,\n         ((idx + 3) * usize_size as usize) as i32,\n     );"}, {"sha": "88a86bcf404605d3ee584783ecf3fda3b7e18259", "filename": "test.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5cb81cdb16b91e5746d4606edaa42a36237ff33f/test.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5cb81cdb16b91e5746d4606edaa42a36237ff33f/test.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test.sh?ref=5cb81cdb16b91e5746d4606edaa42a36237ff33f", "patch": "@@ -78,8 +78,8 @@ hyperfine --runs ${RUN_RUNS:-10} ./raytracer_cg_llvm ./raytracer_cg_clif\n popd\n \n pushd build_sysroot/sysroot_src/src/libcore/tests\n-rm -r sysroot_src/src/**/*/target/ || true\n-cargo test\n+rm -r ./target || true\n+../../../../../cargo.sh test\n popd\n \n pushd regex"}]}