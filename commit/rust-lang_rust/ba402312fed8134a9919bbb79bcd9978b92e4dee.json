{"sha": "ba402312fed8134a9919bbb79bcd9978b92e4dee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhNDAyMzEyZmVkODEzNGE5OTE5YmJiNzliY2Q5OTc4YjkyZTRkZWU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-07T01:52:18Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-08T00:54:34Z"}, "message": "std: Deny most warnings in doctests\n\nAllow a few specific ones but otherwise this helps ensure that our examples are\nsqueaky clean!\n\nCloses #18199", "tree": {"sha": "632e99d9adc3ca92950a86f1b4ba97426057bfce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/632e99d9adc3ca92950a86f1b4ba97426057bfce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba402312fed8134a9919bbb79bcd9978b92e4dee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba402312fed8134a9919bbb79bcd9978b92e4dee", "html_url": "https://github.com/rust-lang/rust/commit/ba402312fed8134a9919bbb79bcd9978b92e4dee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba402312fed8134a9919bbb79bcd9978b92e4dee/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "179719d45023e549a62ec7a584d554408c6d241d", "url": "https://api.github.com/repos/rust-lang/rust/commits/179719d45023e549a62ec7a584d554408c6d241d", "html_url": "https://github.com/rust-lang/rust/commit/179719d45023e549a62ec7a584d554408c6d241d"}], "stats": {"total": 437, "additions": 212, "deletions": 225}, "files": [{"sha": "ece419af9517239cc3e1cb954d475672aa80c4a4", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=ba402312fed8134a9919bbb79bcd9978b92e4dee", "patch": "@@ -229,7 +229,6 @@ macro_rules! writeln {\n /// Iterators:\n ///\n /// ```\n-/// # #![feature(core)]\n /// fn divide_by_three(x: u32) -> u32 { // one of the poorest implementations of x/3\n ///     for i in 0.. {\n ///         if 3*i < i { panic!(\"u32 overflow\"); }"}, {"sha": "f897d565321dabe638452b90b644a1b1ece30e6b", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=ba402312fed8134a9919bbb79bcd9978b92e4dee", "patch": "@@ -304,7 +304,6 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// use std::collections::HashSet;\n     /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n     /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n@@ -335,7 +334,6 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// use std::collections::HashSet;\n     /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n     /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n@@ -362,7 +360,6 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// use std::collections::HashSet;\n     /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n     /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n@@ -388,7 +385,6 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// use std::collections::HashSet;\n     /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n     /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n@@ -471,7 +467,6 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// use std::collections::HashSet;\n     ///\n     /// let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n@@ -491,7 +486,6 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// use std::collections::HashSet;\n     ///\n     /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n@@ -513,7 +507,6 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// use std::collections::HashSet;\n     ///\n     /// let sup: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n@@ -535,7 +528,6 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// use std::collections::HashSet;\n     ///\n     /// let sub: HashSet<_> = [1, 2].iter().cloned().collect();"}, {"sha": "48b95ce6439c9c4ceba4683cb8759225a01f113e", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 180, "deletions": 155, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=ba402312fed8134a9919bbb79bcd9978b92e4dee", "patch": "@@ -10,16 +10,18 @@\n \n //! Collection types.\n //!\n-//! Rust's standard collection library provides efficient implementations of the most common\n-//! general purpose programming data structures. By using the standard implementations,\n-//! it should be possible for two libraries to communicate without significant data conversion.\n-//!\n-//! To get this out of the way: you should probably just use `Vec` or `HashMap`. These two\n-//! collections cover most use cases for generic data storage and processing. They are\n-//! exceptionally good at doing what they do. All the other collections in the standard\n-//! library have specific use cases where they are the optimal choice, but these cases are\n-//! borderline *niche* in comparison. Even when `Vec` and `HashMap` are technically suboptimal,\n-//! they're probably a good enough choice to get started.\n+//! Rust's standard collection library provides efficient implementations of the\n+//! most common general purpose programming data structures. By using the\n+//! standard implementations, it should be possible for two libraries to\n+//! communicate without significant data conversion.\n+//!\n+//! To get this out of the way: you should probably just use `Vec` or `HashMap`.\n+//! These two collections cover most use cases for generic data storage and\n+//! processing. They are exceptionally good at doing what they do. All the other\n+//! collections in the standard library have specific use cases where they are\n+//! the optimal choice, but these cases are borderline *niche* in comparison.\n+//! Even when `Vec` and `HashMap` are technically suboptimal, they're probably a\n+//! good enough choice to get started.\n //!\n //! Rust's collections can be grouped into four major categories:\n //!\n@@ -30,28 +32,31 @@\n //!\n //! # When Should You Use Which Collection?\n //!\n-//! These are fairly high-level and quick break-downs of when each collection should be\n-//! considered. Detailed discussions of strengths and weaknesses of individual collections\n-//! can be found on their own documentation pages.\n+//! These are fairly high-level and quick break-downs of when each collection\n+//! should be considered. Detailed discussions of strengths and weaknesses of\n+//! individual collections can be found on their own documentation pages.\n //!\n //! ### Use a `Vec` when:\n-//! * You want to collect items up to be processed or sent elsewhere later, and don't care about\n-//! any properties of the actual values being stored.\n-//! * You want a sequence of elements in a particular order, and will only be appending to\n-//! (or near) the end.\n+//! * You want to collect items up to be processed or sent elsewhere later, and\n+//!   don't care about any properties of the actual values being stored.\n+//! * You want a sequence of elements in a particular order, and will only be\n+//!   appending to (or near) the end.\n //! * You want a stack.\n //! * You want a resizable array.\n //! * You want a heap-allocated array.\n //!\n //! ### Use a `VecDeque` when:\n-//! * You want a `Vec` that supports efficient insertion at both ends of the sequence.\n+//! * You want a `Vec` that supports efficient insertion at both ends of the\n+//!   sequence.\n //! * You want a queue.\n //! * You want a double-ended queue (deque).\n //!\n //! ### Use a `LinkedList` when:\n-//! * You want a `Vec` or `VecDeque` of unknown size, and can't tolerate amortization.\n+//! * You want a `Vec` or `VecDeque` of unknown size, and can't tolerate\n+//!   amortization.\n //! * You want to efficiently split and append lists.\n-//! * You are *absolutely* certain you *really*, *truly*, want a doubly linked list.\n+//! * You are *absolutely* certain you *really*, *truly*, want a doubly linked\n+//!   list.\n //!\n //! ### Use a `HashMap` when:\n //! * You want to associate arbitrary keys with an arbitrary value.\n@@ -60,7 +65,8 @@\n //!\n //! ### Use a `BTreeMap` when:\n //! * You're interested in what the smallest or largest key-value pair is.\n-//! * You want to find the largest or smallest key that is smaller or larger than something\n+//! * You want to find the largest or smallest key that is smaller or larger\n+//!   than something\n //! * You want to be able to get all of the entries in order on-demand.\n //! * You want a sorted map.\n //!\n@@ -81,29 +87,34 @@\n //! * You want a `BitVec`, but want `Set` properties\n //!\n //! ### Use a `BinaryHeap` when:\n-//! * You want to store a bunch of elements, but only ever want to process the \"biggest\"\n-//! or \"most important\" one at any given time.\n+//!\n+//! * You want to store a bunch of elements, but only ever want to process the\n+//!   \"biggest\" or \"most important\" one at any given time.\n //! * You want a priority queue.\n //!\n //! # Performance\n //!\n-//! Choosing the right collection for the job requires an understanding of what each collection\n-//! is good at. Here we briefly summarize the performance of different collections for certain\n-//! important operations. For further details, see each type's documentation, and note that the\n-//! names of actual methods may differ from the tables below on certain collections.\n+//! Choosing the right collection for the job requires an understanding of what\n+//! each collection is good at. Here we briefly summarize the performance of\n+//! different collections for certain important operations. For further details,\n+//! see each type's documentation, and note that the names of actual methods may\n+//! differ from the tables below on certain collections.\n //!\n-//! Throughout the documentation, we will follow a few conventions. For all operations,\n-//! the collection's size is denoted by n. If another collection is involved in the operation, it\n-//! contains m elements. Operations which have an *amortized* cost are suffixed with a `*`.\n-//! Operations with an *expected* cost are suffixed with a `~`.\n+//! Throughout the documentation, we will follow a few conventions. For all\n+//! operations, the collection's size is denoted by n. If another collection is\n+//! involved in the operation, it contains m elements. Operations which have an\n+//! *amortized* cost are suffixed with a `*`.  Operations with an *expected*\n+//! cost are suffixed with a `~`.\n //!\n-//! All amortized costs are for the potential need to resize when capacity is exhausted.\n-//! If a resize occurs it will take O(n) time. Our collections never automatically shrink,\n-//! so removal operations aren't amortized. Over a sufficiently large series of\n-//! operations, the average cost per operation will deterministically equal the given cost.\n+//! All amortized costs are for the potential need to resize when capacity is\n+//! exhausted.  If a resize occurs it will take O(n) time. Our collections never\n+//! automatically shrink, so removal operations aren't amortized. Over a\n+//! sufficiently large series of operations, the average cost per operation will\n+//! deterministically equal the given cost.\n //!\n-//! Only HashMap has expected costs, due to the probabilistic nature of hashing. It is\n-//! theoretically possible, though very unlikely, for HashMap to experience worse performance.\n+//! Only HashMap has expected costs, due to the probabilistic nature of hashing.\n+//! It is theoretically possible, though very unlikely, for HashMap to\n+//! experience worse performance.\n //!\n //! ## Sequences\n //!\n@@ -120,7 +131,8 @@\n //!\n //! ## Maps\n //!\n-//! For Sets, all operations have the cost of the equivalent Map operation. For BitSet,\n+//! For Sets, all operations have the cost of the equivalent Map operation. For\n+//! BitSet,\n //! refer to VecMap.\n //!\n //! |          | get       | insert   | remove   | predecessor |\n@@ -129,85 +141,95 @@\n //! | BTreeMap | O(log n)  | O(log n) | O(log n) | O(log n)    |\n //! | VecMap   | O(1)      | O(1)?    | O(1)     | O(n)        |\n //!\n-//! Note that VecMap is *incredibly* inefficient in terms of space. The O(1) insertion time\n-//! assumes space for the element is already allocated. Otherwise, a large key may require a\n-//! massive reallocation, with no direct relation to the number of elements in the collection.\n-//! VecMap should only be seriously considered for small keys.\n+//! Note that VecMap is *incredibly* inefficient in terms of space. The O(1)\n+//! insertion time assumes space for the element is already allocated.\n+//! Otherwise, a large key may require a massive reallocation, with no direct\n+//! relation to the number of elements in the collection.  VecMap should only be\n+//! seriously considered for small keys.\n //!\n //! Note also that BTreeMap's precise preformance depends on the value of B.\n //!\n //! # Correct and Efficient Usage of Collections\n //!\n-//! Of course, knowing which collection is the right one for the job doesn't instantly\n-//! permit you to use it correctly. Here are some quick tips for efficient and correct\n-//! usage of the standard collections in general. If you're interested in how to use a\n-//! specific collection in particular, consult its documentation for detailed discussion\n-//! and code examples.\n+//! Of course, knowing which collection is the right one for the job doesn't\n+//! instantly permit you to use it correctly. Here are some quick tips for\n+//! efficient and correct usage of the standard collections in general. If\n+//! you're interested in how to use a specific collection in particular, consult\n+//! its documentation for detailed discussion and code examples.\n //!\n //! ## Capacity Management\n //!\n-//! Many collections provide several constructors and methods that refer to \"capacity\".\n-//! These collections are generally built on top of an array. Optimally, this array would be\n-//! exactly the right size to fit only the elements stored in the collection, but for the\n-//! collection to do this would be very inefficient. If the backing array was exactly the\n-//! right size at all times, then every time an element is inserted, the collection would\n-//! have to grow the array to fit it. Due to the way memory is allocated and managed on most\n-//! computers, this would almost surely require allocating an entirely new array and\n-//! copying every single element from the old one into the new one. Hopefully you can\n-//! see that this wouldn't be very efficient to do on every operation.\n-//!\n-//! Most collections therefore use an *amortized* allocation strategy. They generally let\n-//! themselves have a fair amount of unoccupied space so that they only have to grow\n-//! on occasion. When they do grow, they allocate a substantially larger array to move\n-//! the elements into so that it will take a while for another grow to be required. While\n-//! this strategy is great in general, it would be even better if the collection *never*\n-//! had to resize its backing array. Unfortunately, the collection itself doesn't have\n-//! enough information to do this itself. Therefore, it is up to us programmers to give it\n-//! hints.\n-//!\n-//! Any `with_capacity` constructor will instruct the collection to allocate enough space\n-//! for the specified number of elements. Ideally this will be for exactly that many\n-//! elements, but some implementation details may prevent this. `Vec` and `VecDeque` can\n-//! be relied on to allocate exactly the requested amount, though. Use `with_capacity`\n-//! when you know exactly how many elements will be inserted, or at least have a\n-//! reasonable upper-bound on that number.\n-//!\n-//! When anticipating a large influx of elements, the `reserve` family of methods can\n-//! be used to hint to the collection how much room it should make for the coming items.\n-//! As with `with_capacity`, the precise behavior of these methods will be specific to\n-//! the collection of interest.\n-//!\n-//! For optimal performance, collections will generally avoid shrinking themselves.\n-//! If you believe that a collection will not soon contain any more elements, or\n-//! just really need the memory, the `shrink_to_fit` method prompts the collection\n-//! to shrink the backing array to the minimum size capable of holding its elements.\n-//!\n-//! Finally, if ever you're interested in what the actual capacity of the collection is,\n-//! most collections provide a `capacity` method to query this information on demand.\n-//! This can be useful for debugging purposes, or for use with the `reserve` methods.\n+//! Many collections provide several constructors and methods that refer to\n+//! \"capacity\".  These collections are generally built on top of an array.\n+//! Optimally, this array would be exactly the right size to fit only the\n+//! elements stored in the collection, but for the collection to do this would\n+//! be very inefficient. If the backing array was exactly the right size at all\n+//! times, then every time an element is inserted, the collection would have to\n+//! grow the array to fit it. Due to the way memory is allocated and managed on\n+//! most computers, this would almost surely require allocating an entirely new\n+//! array and copying every single element from the old one into the new one.\n+//! Hopefully you can see that this wouldn't be very efficient to do on every\n+//! operation.\n+//!\n+//! Most collections therefore use an *amortized* allocation strategy. They\n+//! generally let themselves have a fair amount of unoccupied space so that they\n+//! only have to grow on occasion. When they do grow, they allocate a\n+//! substantially larger array to move the elements into so that it will take a\n+//! while for another grow to be required. While this strategy is great in\n+//! general, it would be even better if the collection *never* had to resize its\n+//! backing array. Unfortunately, the collection itself doesn't have enough\n+//! information to do this itself. Therefore, it is up to us programmers to give\n+//! it hints.\n+//!\n+//! Any `with_capacity` constructor will instruct the collection to allocate\n+//! enough space for the specified number of elements. Ideally this will be for\n+//! exactly that many elements, but some implementation details may prevent\n+//! this. `Vec` and `VecDeque` can be relied on to allocate exactly the\n+//! requested amount, though. Use `with_capacity` when you know exactly how many\n+//! elements will be inserted, or at least have a reasonable upper-bound on that\n+//! number.\n+//!\n+//! When anticipating a large influx of elements, the `reserve` family of\n+//! methods can be used to hint to the collection how much room it should make\n+//! for the coming items.  As with `with_capacity`, the precise behavior of\n+//! these methods will be specific to the collection of interest.\n+//!\n+//! For optimal performance, collections will generally avoid shrinking\n+//! themselves.  If you believe that a collection will not soon contain any more\n+//! elements, or just really need the memory, the `shrink_to_fit` method prompts\n+//! the collection to shrink the backing array to the minimum size capable of\n+//! holding its elements.\n+//!\n+//! Finally, if ever you're interested in what the actual capacity of the\n+//! collection is, most collections provide a `capacity` method to query this\n+//! information on demand.  This can be useful for debugging purposes, or for\n+//! use with the `reserve` methods.\n //!\n //! ## Iterators\n //!\n-//! Iterators are a powerful and robust mechanism used throughout Rust's standard\n-//! libraries. Iterators provide a sequence of values in a generic, safe, efficient\n-//! and convenient way. The contents of an iterator are usually *lazily* evaluated,\n-//! so that only the values that are actually needed are ever actually produced, and\n-//! no allocation need be done to temporarily store them. Iterators are primarily\n-//! consumed using a `for` loop, although many functions also take iterators where\n-//! a collection or sequence of values is desired.\n-//!\n-//! All of the standard collections provide several iterators for performing bulk\n-//! manipulation of their contents. The three primary iterators almost every collection\n-//! should provide are `iter`, `iter_mut`, and `into_iter`. Some of these are not\n-//! provided on collections where it would be unsound or unreasonable to provide them.\n+//! Iterators are a powerful and robust mechanism used throughout Rust's\n+//! standard libraries. Iterators provide a sequence of values in a generic,\n+//! safe, efficient and convenient way. The contents of an iterator are usually\n+//! *lazily* evaluated, so that only the values that are actually needed are\n+//! ever actually produced, and no allocation need be done to temporarily store\n+//! them. Iterators are primarily consumed using a `for` loop, although many\n+//! functions also take iterators where a collection or sequence of values is\n+//! desired.\n+//!\n+//! All of the standard collections provide several iterators for performing\n+//! bulk manipulation of their contents. The three primary iterators almost\n+//! every collection should provide are `iter`, `iter_mut`, and `into_iter`.\n+//! Some of these are not provided on collections where it would be unsound or\n+//! unreasonable to provide them.\n //!\n //! `iter` provides an iterator of immutable references to all the contents of a\n-//! collection in the most \"natural\" order. For sequence collections like `Vec`, this\n-//! means the items will be yielded in increasing order of index starting at 0. For ordered\n-//! collections like `BTreeMap`, this means that the items will be yielded in sorted order.\n-//! For unordered collections like `HashMap`, the items will be yielded in whatever order\n-//! the internal representation made most convenient. This is great for reading through\n-//! all the contents of the collection.\n+//! collection in the most \"natural\" order. For sequence collections like `Vec`,\n+//! this means the items will be yielded in increasing order of index starting\n+//! at 0. For ordered collections like `BTreeMap`, this means that the items\n+//! will be yielded in sorted order.  For unordered collections like `HashMap`,\n+//! the items will be yielded in whatever order the internal representation made\n+//! most convenient. This is great for reading through all the contents of the\n+//! collection.\n //!\n //! ```\n //! let vec = vec![1, 2, 3, 4];\n@@ -216,8 +238,8 @@\n //! }\n //! ```\n //!\n-//! `iter_mut` provides an iterator of *mutable* references in the same order as `iter`.\n-//! This is great for mutating all the contents of the collection.\n+//! `iter_mut` provides an iterator of *mutable* references in the same order as\n+//! `iter`.  This is great for mutating all the contents of the collection.\n //!\n //! ```\n //! let mut vec = vec![1, 2, 3, 4];\n@@ -226,13 +248,14 @@\n //! }\n //! ```\n //!\n-//! `into_iter` transforms the actual collection into an iterator over its contents\n-//! by-value. This is great when the collection itself is no longer needed, and the\n-//! values are needed elsewhere. Using `extend` with `into_iter` is the main way that\n-//! contents of one collection are moved into another. Calling `collect` on an iterator\n-//! itself is also a great way to convert one collection into another. Both of these\n-//! methods should internally use the capacity management tools discussed in the\n-//! previous section to do this as efficiently as possible.\n+//! `into_iter` transforms the actual collection into an iterator over its\n+//! contents by-value. This is great when the collection itself is no longer\n+//! needed, and the values are needed elsewhere. Using `extend` with `into_iter`\n+//! is the main way that contents of one collection are moved into another.\n+//! Calling `collect` on an iterator itself is also a great way to convert one\n+//! collection into another. Both of these methods should internally use the\n+//! capacity management tools discussed in the previous section to do this as\n+//! efficiently as possible.\n //!\n //! ```\n //! let mut vec1 = vec![1, 2, 3, 4];\n@@ -247,11 +270,12 @@\n //! let buf: VecDeque<_> = vec.into_iter().collect();\n //! ```\n //!\n-//! Iterators also provide a series of *adapter* methods for performing common tasks to\n-//! sequences. Among the adapters are functional favorites like `map`, `fold`, `skip`,\n-//! and `take`. Of particular interest to collections is the `rev` adapter, that\n-//! reverses any iterator that supports this operation. Most collections provide reversible\n-//! iterators as the way to iterate over them in reverse order.\n+//! Iterators also provide a series of *adapter* methods for performing common\n+//! tasks to sequences. Among the adapters are functional favorites like `map`,\n+//! `fold`, `skip`, and `take`. Of particular interest to collections is the\n+//! `rev` adapter, that reverses any iterator that supports this operation. Most\n+//! collections provide reversible iterators as the way to iterate over them in\n+//! reverse order.\n //!\n //! ```\n //! let vec = vec![1, 2, 3, 4];\n@@ -260,48 +284,50 @@\n //! }\n //! ```\n //!\n-//! Several other collection methods also return iterators to yield a sequence of results\n-//! but avoid allocating an entire collection to store the result in. This provides maximum\n-//! flexibility as `collect` or `extend` can be called to \"pipe\" the sequence into any\n-//! collection if desired. Otherwise, the sequence can be looped over with a `for` loop. The\n-//! iterator can also be discarded after partial use, preventing the computation of the unused\n-//! items.\n+//! Several other collection methods also return iterators to yield a sequence\n+//! of results but avoid allocating an entire collection to store the result in.\n+//! This provides maximum flexibility as `collect` or `extend` can be called to\n+//! \"pipe\" the sequence into any collection if desired. Otherwise, the sequence\n+//! can be looped over with a `for` loop. The iterator can also be discarded\n+//! after partial use, preventing the computation of the unused items.\n //!\n //! ## Entries\n //!\n-//! The `entry` API is intended to provide an efficient mechanism for manipulating\n-//! the contents of a map conditionally on the presence of a key or not. The primary\n-//! motivating use case for this is to provide efficient accumulator maps. For instance,\n-//! if one wishes to maintain a count of the number of times each key has been seen,\n-//! they will have to perform some conditional logic on whether this is the first time\n-//! the key has been seen or not. Normally, this would require a `find` followed by an\n-//! `insert`, effectively duplicating the search effort on each insertion.\n-//!\n-//! When a user calls `map.entry(&key)`, the map will search for the key and then yield\n-//! a variant of the `Entry` enum.\n-//!\n-//! If a `Vacant(entry)` is yielded, then the key *was not* found. In this case the\n-//! only valid operation is to `insert` a value into the entry. When this is done,\n-//! the vacant entry is consumed and converted into a mutable reference to the\n-//! the value that was inserted. This allows for further manipulation of the value\n-//! beyond the lifetime of the search itself. This is useful if complex logic needs to\n-//! be performed on the value regardless of whether the value was just inserted.\n-//!\n-//! If an `Occupied(entry)` is yielded, then the key *was* found. In this case, the user\n-//! has several options: they can `get`, `insert`, or `remove` the value of the occupied\n-//! entry. Additionally, they can convert the occupied entry into a mutable reference\n-//! to its value, providing symmetry to the vacant `insert` case.\n+//! The `entry` API is intended to provide an efficient mechanism for\n+//! manipulating the contents of a map conditionally on the presence of a key or\n+//! not. The primary motivating use case for this is to provide efficient\n+//! accumulator maps. For instance, if one wishes to maintain a count of the\n+//! number of times each key has been seen, they will have to perform some\n+//! conditional logic on whether this is the first time the key has been seen or\n+//! not. Normally, this would require a `find` followed by an `insert`,\n+//! effectively duplicating the search effort on each insertion.\n+//!\n+//! When a user calls `map.entry(&key)`, the map will search for the key and\n+//! then yield a variant of the `Entry` enum.\n+//!\n+//! If a `Vacant(entry)` is yielded, then the key *was not* found. In this case\n+//! the only valid operation is to `insert` a value into the entry. When this is\n+//! done, the vacant entry is consumed and converted into a mutable reference to\n+//! the the value that was inserted. This allows for further manipulation of the\n+//! value beyond the lifetime of the search itself. This is useful if complex\n+//! logic needs to be performed on the value regardless of whether the value was\n+//! just inserted.\n+//!\n+//! If an `Occupied(entry)` is yielded, then the key *was* found. In this case,\n+//! the user has several options: they can `get`, `insert`, or `remove` the\n+//! value of the occupied entry. Additionally, they can convert the occupied\n+//! entry into a mutable reference to its value, providing symmetry to the\n+//! vacant `insert` case.\n //!\n //! ### Examples\n //!\n-//! Here are the two primary ways in which `entry` is used. First, a simple example\n-//! where the logic performed on the values is trivial.\n+//! Here are the two primary ways in which `entry` is used. First, a simple\n+//! example where the logic performed on the values is trivial.\n //!\n //! #### Counting the number of times each character in a string occurs\n //!\n //! ```\n-//! # #![feature(collections)]\n-//! use std::collections::btree_map::{BTreeMap, Entry};\n+//! use std::collections::btree_map::BTreeMap;\n //!\n //! let mut count = BTreeMap::new();\n //! let message = \"she sells sea shells by the sea shore\";\n@@ -318,15 +344,14 @@\n //! }\n //! ```\n //!\n-//! When the logic to be performed on the value is more complex, we may simply use\n-//! the `entry` API to ensure that the value is initialized, and perform the logic\n-//! afterwards.\n+//! When the logic to be performed on the value is more complex, we may simply\n+//! use the `entry` API to ensure that the value is initialized, and perform the\n+//! logic afterwards.\n //!\n //! #### Tracking the inebriation of customers at a bar\n //!\n //! ```\n-//! # #![feature(collections)]\n-//! use std::collections::btree_map::{BTreeMap, Entry};\n+//! use std::collections::btree_map::BTreeMap;\n //!\n //! // A client of the bar. They have an id and a blood alcohol level.\n //! struct Person { id: u32, blood_alcohol: f32 }"}, {"sha": "914830d9dcfea20a84c4681e9409b90e419c62bd", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=ba402312fed8134a9919bbb79bcd9978b92e4dee", "patch": "@@ -96,14 +96,16 @@ pub struct WalkDir {\n \n /// Options and flags which can be used to configure how a file is opened.\n ///\n-/// This builder exposes the ability to configure how a `File` is opened and what operations are\n-/// permitted on the open file. The `File::open` and `File::create` methods are aliases for\n-/// commonly used options using this builder.\n+/// This builder exposes the ability to configure how a `File` is opened and\n+/// what operations are permitted on the open file. The `File::open` and\n+/// `File::create` methods are aliases for commonly used options using this\n+/// builder.\n ///\n-/// Generally speaking, when using `OpenOptions`, you'll first call `new()`, then chain calls to\n-/// methods to set each option, then call `open()`, passing the path of the file you're trying to\n-/// open. This will give you a [`io::Result`][result] with a [`File`][file] inside that you can\n-/// further operate on.\n+/// Generally speaking, when using `OpenOptions`, you'll first call `new()`,\n+/// then chain calls to methods to set each option, then call `open()`, passing\n+/// the path of the file you're trying to open. This will give you a\n+/// [`io::Result`][result] with a [`File`][file] inside that you can further\n+/// operate on.\n ///\n /// [result]: ../io/type.Result.html\n /// [file]: struct.File.html\n@@ -113,16 +115,15 @@ pub struct WalkDir {\n /// Opening a file to read:\n ///\n /// ```no_run\n-/// use std::fs;\n /// use std::fs::OpenOptions;\n ///\n /// let file = OpenOptions::new().read(true).open(\"foo.txt\");\n /// ```\n ///\n-/// Opening a file for both reading and writing, as well as creating it if it doesn't exist:\n+/// Opening a file for both reading and writing, as well as creating it if it\n+/// doesn't exist:\n ///\n /// ```\n-/// use std::fs;\n /// use std::fs::OpenOptions;\n ///\n /// let file = OpenOptions::new()\n@@ -771,7 +772,9 @@ pub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<()>\n /// ```no_run\n /// use std::fs;\n ///\n-/// fs::copy(\"foo.txt\", \"bar.txt\");\n+/// # fn foo() -> std::io::Result<()> {\n+/// try!(fs::copy(\"foo.txt\", \"bar.txt\"));\n+/// # Ok(()) }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<u64> {"}, {"sha": "880770eb41485b15f05427f5ebf4a5aa84e2eec5", "filename": "src/libstd/io/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fio%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fio%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprelude.rs?ref=ba402312fed8134a9919bbb79bcd9978b92e4dee", "patch": "@@ -14,6 +14,7 @@\n //! by adding a glob import to the top of I/O heavy modules:\n //!\n //! ```\n+//! # #![allow(unused_imports)]\n //! use std::io::prelude::*;\n //! ```\n //!"}, {"sha": "b329494a0526bccfa827c18259e1295c927a6cbd", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=ba402312fed8134a9919bbb79bcd9978b92e4dee", "patch": "@@ -103,7 +103,8 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![doc(test(no_crate_inject))]\n+#![doc(test(no_crate_inject, attr(deny(warnings))))]\n+#![doc(test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n \n #![feature(alloc)]\n #![feature(box_syntax)]"}, {"sha": "3abf805c7f643feb184ed3b3866b10fa90f3bdc8", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=ba402312fed8134a9919bbb79bcd9978b92e4dee", "patch": "@@ -281,7 +281,6 @@ impl hash::Hash for SocketAddrV6 {\n /// Some examples:\n ///\n /// ```no_run\n-/// # #![feature(net)]\n /// use std::net::{SocketAddrV4, TcpStream, UdpSocket, TcpListener, Ipv4Addr};\n ///\n /// fn main() {\n@@ -302,7 +301,7 @@ impl hash::Hash for SocketAddrV6 {\n ///     let tcp_l = TcpListener::bind(\"localhost:12345\");\n ///\n ///     let mut udp_s = UdpSocket::bind((\"127.0.0.1\", port)).unwrap();\n-///     udp_s.send_to(&[7], (ip, 23451));\n+///     udp_s.send_to(&[7], (ip, 23451)).unwrap();\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "2da6f7420ac9d31b7e7f26dbb94b992f8ebdd268", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=ba402312fed8134a9919bbb79bcd9978b92e4dee", "patch": "@@ -27,7 +27,6 @@ use sys_common::{AsInner, FromInner};\n /// # Examples\n ///\n /// ```no_run\n-/// # #![feature(net)]\n /// use std::io::prelude::*;\n /// use std::net::TcpStream;\n ///\n@@ -47,7 +46,6 @@ pub struct TcpStream(net_imp::TcpStream);\n /// # Examples\n ///\n /// ```no_run\n-/// # #![feature(net)]\n /// use std::net::{TcpListener, TcpStream};\n /// use std::thread;\n ///"}, {"sha": "bec9c09bc314676ec35fb91f8d373d3d033f3fbe", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=ba402312fed8134a9919bbb79bcd9978b92e4dee", "patch": "@@ -27,7 +27,6 @@ use sys_common::{AsInner, FromInner};\n /// # Examples\n ///\n /// ```no_run\n-/// # #![feature(net)]\n /// use std::net::UdpSocket;\n ///\n /// # fn foo() -> std::io::Result<()> {"}, {"sha": "6128469c60e50cb2b4f39d45445637b7500c7686", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=ba402312fed8134a9919bbb79bcd9978b92e4dee", "patch": "@@ -422,7 +422,6 @@ impl f32 {\n     /// [subnormal][subnormal], or `NaN`.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n     /// use std::f32;\n     ///\n     /// let min = f32::MIN_POSITIVE; // 1.17549435e-38f32\n@@ -856,7 +855,7 @@ impl f32 {\n     /// Convert radians to degrees.\n     ///\n     /// ```\n-    /// # #![feature(std_misc, core)]\n+    /// # #![feature(std_misc)]\n     /// use std::f32::{self, consts};\n     ///\n     /// let angle = consts::PI;\n@@ -987,7 +986,6 @@ impl f32 {\n     /// * Else: `self - other`\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n     /// use std::f32;\n     ///\n     /// let x = 3.0f32;\n@@ -1008,7 +1006,6 @@ impl f32 {\n     /// Take the cubic root of a number.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n     /// use std::f32;\n     ///\n     /// let x = 8.0f32;\n@@ -1210,8 +1207,6 @@ impl f32 {\n     /// number is close to zero.\n     ///\n     /// ```\n-    /// use std::f64;\n-    ///\n     /// let x = 7.0f64;\n     ///\n     /// // e^(ln(7)) - 1"}, {"sha": "ea516e5b20b7a35199395f6a6dab0dfd8d6f50eb", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=ba402312fed8134a9919bbb79bcd9978b92e4dee", "patch": "@@ -280,7 +280,6 @@ pub trait Float\n     /// [subnormal][subnormal], or `NaN`.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f32;\n     ///\n@@ -307,7 +306,6 @@ pub trait Float\n     /// predicate instead.\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// use std::num::{Float, FpCategory};\n     /// use std::f32;\n     ///\n@@ -417,7 +415,6 @@ pub trait Float\n     /// number is `Float::nan()`.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -441,7 +438,6 @@ pub trait Float\n     /// - `Float::nan()` if the number is `Float::nan()`\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -686,7 +682,6 @@ pub trait Float\n     /// Convert radians to degrees.\n     ///\n     /// ```\n-    /// # #![feature(std_misc, core)]\n     /// use std::num::Float;\n     /// use std::f64::consts;\n     ///\n@@ -701,7 +696,7 @@ pub trait Float\n     /// Convert degrees to radians.\n     ///\n     /// ```\n-    /// # #![feature(std_misc, core)]\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f64::consts;\n     ///\n@@ -849,7 +844,6 @@ pub trait Float\n     /// Computes the sine of a number (in radians).\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -864,7 +858,6 @@ pub trait Float\n     /// Computes the cosine of a number (in radians).\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -879,7 +872,6 @@ pub trait Float\n     /// Computes the tangent of a number (in radians).\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -895,7 +887,6 @@ pub trait Float\n     /// [-1, 1].\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -913,7 +904,6 @@ pub trait Float\n     /// [-1, 1].\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -949,7 +939,6 @@ pub trait Float\n     /// * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -975,7 +964,6 @@ pub trait Float\n     /// `(sin(x), cos(x))`.\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1011,7 +999,6 @@ pub trait Float\n     /// the operations were performed separately.\n     ///\n     /// ```\n-    /// # #![feature(std_misc, core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1028,7 +1015,6 @@ pub trait Float\n     /// Hyperbolic sine function.\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1047,7 +1033,6 @@ pub trait Float\n     /// Hyperbolic cosine function.\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1066,7 +1051,6 @@ pub trait Float\n     /// Hyperbolic tangent function.\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1113,7 +1097,6 @@ pub trait Float\n     /// Inverse hyperbolic tangent function.\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///"}, {"sha": "f62b1a836fd10201a4452780afe93d0427245efc", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=ba402312fed8134a9919bbb79bcd9978b92e4dee", "patch": "@@ -48,7 +48,7 @@\n //! * Read lines from stdin\n //!\n //!     ```rust\n-//!     # #![feature(old_io, old_path)]\n+//!     # #![feature(old_io)]\n //!     use std::old_io as io;\n //!     use std::old_io::*;\n //!"}, {"sha": "f5310292b911b8c4f15a204263c849a3179e3341", "filename": "src/libstd/old_io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs?ref=ba402312fed8134a9919bbb79bcd9978b92e4dee", "patch": "@@ -414,7 +414,7 @@ pub struct ParseError;\n /// Some examples:\n ///\n /// ```rust,no_run\n-/// # #![feature(old_io, core, convert)]\n+/// # #![feature(old_io)]\n /// # #![allow(unused_must_use)]\n ///\n /// use std::old_io::{TcpStream, TcpListener};"}, {"sha": "7b23c3e1d03f21f8f60be42924fc1608f3d84f5d", "filename": "src/libstd/old_io/net/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs?ref=ba402312fed8134a9919bbb79bcd9978b92e4dee", "patch": "@@ -191,7 +191,7 @@ impl UnixListener {\n     /// let server = Path::new(\"/path/to/my/socket\");\n     /// let stream = UnixListener::bind(&server);\n     /// for mut client in stream.listen().incoming() {\n-    ///     client.write(&[1, 2, 3, 4]);\n+    ///     let _ = client.write(&[1, 2, 3, 4]);\n     /// }\n     /// # }\n     /// ```"}, {"sha": "b55d1f4db07f78e6e5c57480c557d4192828dca1", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=ba402312fed8134a9919bbb79bcd9978b92e4dee", "patch": "@@ -367,7 +367,7 @@ impl Command {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(old_io, core, convert)]\n+    /// # #![feature(old_io)]\n     /// use std::old_io::Command;\n     ///\n     /// let output = match Command::new(\"cat\").arg(\"foot.txt\").output() {"}, {"sha": "22561c96f636cfe3d6887f2be721bac3ebbab9cd", "filename": "src/libstd/old_path/mod.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fold_path%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fold_path%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fmod.rs?ref=ba402312fed8134a9919bbb79bcd9978b92e4dee", "patch": "@@ -144,12 +144,10 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     ///\n     /// # Examples\n     ///\n-    /// ```\n+    /// ```no_run\n     /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n+    /// # fn main() {\n+    /// use std::old_path::Path;\n     /// let path = Path::new(\"foo/bar\");\n     /// # }\n     /// ```\n@@ -170,12 +168,10 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     ///\n     /// # Examples\n     ///\n-    /// ```\n+    /// ```no_run\n     /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n+    /// # fn main() {\n+    /// use std::old_path::Path;\n     /// let x: &[u8] = b\"foo\\0\";\n     /// assert!(Path::new_opt(x).is_none());\n     /// # }"}, {"sha": "36c0b3e466fe643683f59877bddfab7276061e37", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=ba402312fed8134a9919bbb79bcd9978b92e4dee", "patch": "@@ -38,8 +38,6 @@ use thread;\n /// # Examples\n ///\n /// ```should_panic\n-/// # #![feature(process)]\n-///\n /// use std::process::Command;\n ///\n /// let output = Command::new(\"/bin/cat\").arg(\"file.txt\").output().unwrap_or_else(|e| {\n@@ -267,10 +265,8 @@ impl Command {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(process)]\n     /// use std::process::Command;\n-    ///\n-    /// let output = Command::new(\"cat\").arg(\"foot.txt\").output().unwrap_or_else(|e| {\n+    /// let output = Command::new(\"cat\").arg(\"foo.txt\").output().unwrap_or_else(|e| {\n     ///     panic!(\"failed to execute process: {}\", e)\n     /// });\n     ///\n@@ -291,7 +287,6 @@ impl Command {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(process)]\n     /// use std::process::Command;\n     ///\n     /// let status = Command::new(\"ls\").status().unwrap_or_else(|e| {"}, {"sha": "cd480f8c29e62ab4f18efa14e6d0c56a16e246bf", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba402312fed8134a9919bbb79bcd9978b92e4dee/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=ba402312fed8134a9919bbb79bcd9978b92e4dee", "patch": "@@ -99,6 +99,7 @@\n //! `println!` and `panic!` for the child thread:\n //!\n //! ```rust\n+//! # #![allow(unused_must_use)]\n //! use std::thread;\n //!\n //! thread::Builder::new().name(\"child1\".to_string()).spawn(move || {"}]}