{"sha": "a3c3f722b7e71d5c9985ba318c700b697fd2c106", "node_id": "C_kwDOAAsO6NoAKGEzYzNmNzIyYjdlNzFkNWM5OTg1YmEzMThjNzAwYjY5N2ZkMmMxMDY", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2022-10-22T00:03:48Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2022-10-22T00:46:48Z"}, "message": "Fix mod_inv termination for the last iteration\n\nOn usize=u64 platforms, the 4th iteration would overflow the `mod_gate`\nback to 0. Similarly for usize=u32 platforms, the 3rd iteration would\noverflow much the same way.\n\nI tested various approaches to resolving this, including approaches with\n`saturating_mul` and `widening_mul` to a double usize. Turns out LLVM\nlikes `mul_with_overflow` the best. In fact now, that LLVM can see the\niteration count is limited, it will happily unroll the loop into a nice\nlinear sequence.\n\nYou will also notice that the code around the loop got simplified\nsomewhat. Now that LLVM is handling the loop nicely, there isn\u2019t any\nmore reasons to manually unroll the first iteration out of the loop\n(though looking at the code today I\u2019m not sure all that complexity was\nnecessary in the first place).\n\nFixes #103361", "tree": {"sha": "b0fcb76f9036e00908543604b60eb77c8ab373e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0fcb76f9036e00908543604b60eb77c8ab373e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3c3f722b7e71d5c9985ba318c700b697fd2c106", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3c3f722b7e71d5c9985ba318c700b697fd2c106", "html_url": "https://github.com/rust-lang/rust/commit/a3c3f722b7e71d5c9985ba318c700b697fd2c106", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3c3f722b7e71d5c9985ba318c700b697fd2c106/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c8bff74bc1c52bef0c79f3689bb227f51f3e82d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c8bff74bc1c52bef0c79f3689bb227f51f3e82d", "html_url": "https://github.com/rust-lang/rust/commit/5c8bff74bc1c52bef0c79f3689bb227f51f3e82d"}], "stats": {"total": 66, "additions": 40, "deletions": 26}, "files": [{"sha": "8a9bcf38b906cf4c19ce11215d1287d48f95c0ce", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a3c3f722b7e71d5c9985ba318c700b697fd2c106/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c3f722b7e71d5c9985ba318c700b697fd2c106/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=a3c3f722b7e71d5c9985ba318c700b697fd2c106", "patch": "@@ -1571,8 +1571,8 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     // FIXME(#75598): Direct use of these intrinsics improves codegen significantly at opt-level <=\n     // 1, where the method versions of these operations are not inlined.\n     use intrinsics::{\n-        cttz_nonzero, exact_div, unchecked_rem, unchecked_shl, unchecked_shr, unchecked_sub,\n-        wrapping_add, wrapping_mul, wrapping_sub,\n+        cttz_nonzero, exact_div, mul_with_overflow, unchecked_rem, unchecked_shl, unchecked_shr,\n+        unchecked_sub, wrapping_add, wrapping_mul, wrapping_sub,\n     };\n \n     /// Calculate multiplicative modular inverse of `x` modulo `m`.\n@@ -1592,36 +1592,38 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n         const INV_TABLE_MOD_16: [u8; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n         /// Modulo for which the `INV_TABLE_MOD_16` is intended.\n         const INV_TABLE_MOD: usize = 16;\n-        /// INV_TABLE_MOD\u00b2\n-        const INV_TABLE_MOD_SQUARED: usize = INV_TABLE_MOD * INV_TABLE_MOD;\n \n-        let table_inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1] as usize;\n         // SAFETY: `m` is required to be a power-of-two, hence non-zero.\n         let m_minus_one = unsafe { unchecked_sub(m, 1) };\n-        if m <= INV_TABLE_MOD {\n-            table_inverse & m_minus_one\n-        } else {\n-            // We iterate \"up\" using the following formula:\n-            //\n-            // $$ xy \u2261 1 (mod 2\u207f) \u2192 xy (2 - xy) \u2261 1 (mod 2\u00b2\u207f) $$\n+        let mut inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1] as usize;\n+        let mut mod_gate = INV_TABLE_MOD;\n+        // We iterate \"up\" using the following formula:\n+        //\n+        // $$ xy \u2261 1 (mod 2\u207f) \u2192 xy (2 - xy) \u2261 1 (mod 2\u00b2\u207f) $$\n+        //\n+        // This application needs to be applied at least until `2\u00b2\u207f \u2265 m`, at which point we can\n+        // finally reduce the computation to our desired `m` by taking `inverse mod m`.\n+        //\n+        // This computation is `O(log log m)`, which is to say, that on 64-bit machines this loop\n+        // will always finish in at most 4 iterations.\n+        loop {\n+            // y = y * (2 - xy) mod n\n             //\n-            // until 2\u00b2\u207f \u2265 m. Then we can reduce to our desired `m` by taking the result `mod m`.\n-            let mut inverse = table_inverse;\n-            let mut going_mod = INV_TABLE_MOD_SQUARED;\n-            loop {\n-                // y = y * (2 - xy) mod n\n-                //\n-                // Note, that we use wrapping operations here intentionally \u2013 the original formula\n-                // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n-                // usize::MAX` instead, because we take the result `mod n` at the end\n-                // anyway.\n-                inverse = wrapping_mul(inverse, wrapping_sub(2usize, wrapping_mul(x, inverse)));\n-                if going_mod >= m {\n-                    return inverse & m_minus_one;\n-                }\n-                going_mod = wrapping_mul(going_mod, going_mod);\n+            // Note, that we use wrapping operations here intentionally \u2013 the original formula\n+            // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n+            // usize::MAX` instead, because we take the result `mod n` at the end\n+            // anyway.\n+            if mod_gate >= m {\n+                break;\n+            }\n+            inverse = wrapping_mul(inverse, wrapping_sub(2usize, wrapping_mul(x, inverse)));\n+            let (new_gate, overflow) = mul_with_overflow(mod_gate, mod_gate);\n+            if overflow {\n+                break;\n             }\n+            mod_gate = new_gate;\n         }\n+        inverse & m_minus_one\n     }\n \n     let addr = p.addr();"}, {"sha": "0977980ba47bf0e243c74adb4955907f67fc50b1", "filename": "library/core/tests/ptr.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3c3f722b7e71d5c9985ba318c700b697fd2c106/library%2Fcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c3f722b7e71d5c9985ba318c700b697fd2c106/library%2Fcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fptr.rs?ref=a3c3f722b7e71d5c9985ba318c700b697fd2c106", "patch": "@@ -455,6 +455,18 @@ fn align_offset_various_strides() {\n     assert!(!x);\n }\n \n+#[test]\n+fn align_offset_issue_103361() {\n+    #[cfg(target_pointer_width = \"64\")]\n+    const SIZE: usize = 1 << 47;\n+    #[cfg(target_pointer_width = \"32\")]\n+    const SIZE: usize = 1 << 30;\n+    #[cfg(target_pointer_width = \"16\")]\n+    const SIZE: usize = 1 << 13;\n+    struct HugeSize([u8; SIZE - 1]);\n+    let _ = (SIZE as *const HugeSize).align_offset(SIZE);\n+}\n+\n #[test]\n fn offset_from() {\n     let mut a = [0; 5];"}]}